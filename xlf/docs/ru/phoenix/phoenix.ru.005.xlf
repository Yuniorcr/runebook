<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="250e5a7518c50a847597afadb1487eab6b2f819d" translate="yes" xml:space="preserve">
          <source>For example, this schema specification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fc1b541955c11c7a3a376c9e4b58f9c57708b1" translate="yes" xml:space="preserve">
          <source>For example, to avoid validating an email until the field is blurred, while validating the username at most every 2 seconds after a user changes the field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a90aa8783fdb171b94edeeedb9421523ade4a7" translate="yes" xml:space="preserve">
          <source>For example, to get all posts while running the &quot;lower(?)&quot; function in the database where &lt;code&gt;p.title&lt;/code&gt; is interpolated in place of &lt;code&gt;?&lt;/code&gt;, one can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c268739f07b40440ff73d328a7a5b1783a45e413" translate="yes" xml:space="preserve">
          <source>For example, to get all posts while running the &amp;ldquo;lower(?)&amp;rdquo; function in the database where &lt;code&gt;p.title&lt;/code&gt; is interpolated in place of &lt;code&gt;?&lt;/code&gt;, one can write:</source>
          <target state="translated">Например, чтобы получить все сообщения при выполнении функции &amp;laquo;lower (?)&amp;raquo; В базе данных, где &lt;code&gt;p.title&lt;/code&gt; вставляется вместо &lt;code&gt;?&lt;/code&gt; , можно написать:</target>
        </trans-unit>
        <trans-unit id="712a75ed27773b36d6dab2e762ed7d44810db42c" translate="yes" xml:space="preserve">
          <source>For example, to handle &quot;phx_leave&quot; messages, which is recommended to be handled by all channel implementations, one may do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed93477deaeccf8f807f263aeb1aa8094e246a0" translate="yes" xml:space="preserve">
          <source>For example, to implement infinite scrolling, one might do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa80c213499c1e4e2ebabd1a68490863d99b23c" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phoenix.server&lt;/code&gt; without checking dependencies:</source>
          <target state="translated">Например, чтобы запустить &lt;code&gt;phoenix.server&lt;/code&gt; без проверки зависимостей:</target>
        </trans-unit>
        <trans-unit id="52d1730d810a3213b8ae35feb4a46172562acd1e" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phx.server&lt;/code&gt; without checking dependencies:</source>
          <target state="translated">Например, чтобы запустить &lt;code&gt;phx.server&lt;/code&gt; без проверки зависимостей:</target>
        </trans-unit>
        <trans-unit id="eb24d75387baa2ce86c09393fcd13aa1468c60e5" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phx.server&lt;/code&gt; without recompiling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee191307a2caef15a68ebec9dbfb940793de8194" translate="yes" xml:space="preserve">
          <source>For example, we can use the &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt; function in the test to push messages to the channel (it will invoke &lt;code&gt;handle_in/3&lt;/code&gt;):</source>
          <target state="translated">Например, мы можем использовать функцию &lt;a href=&quot;#push/3&quot;&gt; &lt;code&gt;push/3&lt;/code&gt; &lt;/a&gt; в тесте для &lt;code&gt;handle_in/3&lt;/code&gt; сообщений в канал (она вызовет handle_in / 3 ):</target>
        </trans-unit>
        <trans-unit id="f8d98d4e6c4113b73111361aa0eeba5ba04454b2" translate="yes" xml:space="preserve">
          <source>For example, you can define a new &lt;code&gt;live.html.leex&lt;/code&gt; layout with dynamic content. You must use &lt;code&gt;@inner_content&lt;/code&gt; where the output of the actual template will be placed at:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c7054e90670cbc4ed17910aed6f38d7ea04bcd" translate="yes" xml:space="preserve">
          <source>For example, you may define it as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f038621e4427f7e69c128ca2c67366fe95857d" translate="yes" xml:space="preserve">
          <source>For example, you may way to generate an https URL from an http request. You could define a function like the following:</source>
          <target state="translated">Например,вы можете сгенерировать https URL из http запроса.Вы можете определить функцию,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="d0d6a26a7fdf008c2173a9711decbd13ce937b5b" translate="yes" xml:space="preserve">
          <source>For example, your &lt;code&gt;MyAppWeb.ErrorHelpers&lt;/code&gt; may use this function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="011fbae011e4f284a1bc4a3f9f03b9f3860ee774" translate="yes" xml:space="preserve">
          <source>For further details refer to &lt;a href=&quot;plug.rewriteon&quot;&gt;&lt;code&gt;Plug.RewriteOn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed904b738db7c4a3075c6e430608f75222bb23b" translate="yes" xml:space="preserve">
          <source>For graceful exits, the channel will notify the transort it is gracefully terminating via the following message:</source>
          <target state="translated">Для грациозных выходов канал уведомит трансорт о его грациозном завершении посредством следующего сообщения:</target>
        </trans-unit>
        <trans-unit id="92926b5f41b64990dae4306af8842a9e143deef7" translate="yes" xml:space="preserve">
          <source>For instance, here is how you would pass the SSL options to the Cowboy adapter:</source>
          <target state="translated">Например,вот как вы передаете опции SSL адаптеру Cowboy:</target>
        </trans-unit>
        <trans-unit id="29be4bc5c201dd9ca580d6ef9202fab40016be15" translate="yes" xml:space="preserve">
          <source>For instance, imagine you wrote:</source>
          <target state="translated">Например,представь,что ты написал:</target>
        </trans-unit>
        <trans-unit id="c93a52e328a78cb6709c141ab080c4cb225cf8de" translate="yes" xml:space="preserve">
          <source>For instance, to receive all query events published by a repository called &lt;code&gt;MyApp.Repo&lt;/code&gt;, one would define a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b013b3f06f541fc367f235e64b28c47860501ef" translate="yes" xml:space="preserve">
          <source>For integration with client-side libraries which require a broader access to full DOM management, the &lt;code&gt;LiveSocket&lt;/code&gt; constructor accepts a &lt;code&gt;dom&lt;/code&gt; option with an &lt;code&gt;onBeforeElUpdated&lt;/code&gt; callback. The &lt;code&gt;fromEl&lt;/code&gt; and &lt;code&gt;toEl&lt;/code&gt; DOM nodes are passed to the function just before the DOM patch operations occurs in LiveView. This allows external libraries to (re)initialize DOM elements or copy attributes as necessary as LiveView performs its own patch operations. The update operation cannot be cancelled or deferred, and the return value is ignored. For example, the following option could be used to add &lt;a href=&quot;https://github.com/alpinejs/alpine&quot;&gt;Alpine.js&lt;/a&gt; support to your project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efb74f6dd168bb1337862be11f36c1c678d8fed" translate="yes" xml:space="preserve">
          <source>For internationalization with &lt;a href=&quot;https://hexdocs.pm/gettext/Gettext.html&quot;&gt;gettext&lt;/a&gt;, the locale used within your Plug pipeline can be stored in the Plug session and restored within your LiveView mount. For example, after user signs in or preference changes, you can write the locale to the session:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b6a50a25c3fab8c56cff540874a439588e5f9c" translate="yes" xml:space="preserve">
          <source>For larger templates, you can place them in a file in the same directory and same name as the LiveView. For example, if the file above is placed at &lt;code&gt;lib/my_app_web/live/thermostat_live.ex&lt;/code&gt;, you can also remove the &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt; definition above and instead put the template code at &lt;code&gt;lib/my_app_web/live/thermostat_live.html.leex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cfc16e6569e0061a6e7eac0c582cf092d25b4b" translate="yes" xml:space="preserve">
          <source>For live page navigation via &lt;code&gt;live_redirect&lt;/code&gt; and &lt;code&gt;live_patch&lt;/code&gt;, as well as form submits via &lt;code&gt;phx-submit&lt;/code&gt;, the JavaScript events &lt;code&gt;&quot;phx:page-loading-start&quot;&lt;/code&gt; and &lt;code&gt;&quot;phx:page-loading-stop&quot;&lt;/code&gt; are dispatched on window. Additionally, any &lt;code&gt;phx-&lt;/code&gt; event may dispatch page loading events by annotating the DOM element with &lt;code&gt;phx-page-loading&lt;/code&gt;. This is useful for showing main page loading status, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8555f356953d9e411a255f6f895244740945a0" translate="yes" xml:space="preserve">
          <source>For logging out, we simply defined a form that sends the &lt;code&gt;DELETE&lt;/code&gt; HTTP method to server's session delete path. Now if you visit the sign-in page at &lt;a href=&quot;http://localhost:4000/sessions/new&quot;&gt;http://localhost:4000/sessions/new&lt;/a&gt; and enter a bad email address, you should be greeted with your flash message. Entering a valid email address will redirect to the home page with a success flash notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9022c5a0c8964d6ea0f8ae4b3dab94f265d3706" translate="yes" xml:space="preserve">
          <source>For maps to work in such databases, Ecto will need a JSON library. By default Ecto will use &lt;a href=&quot;http://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt; which needs to be added to your deps in &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">Для работы карт в таких базах данных Ecto потребуется библиотека JSON. По умолчанию Ecto будет использовать &lt;a href=&quot;http://github.com/michalmuskala/jason&quot;&gt;Jason,&lt;/a&gt; которого нужно добавить к вашим deps в &lt;code&gt;mix.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aabcef1b6cb1a82809871c7e4c5c1fbeeb64b061" translate="yes" xml:space="preserve">
          <source>For maps to work in such databases, Ecto will need a JSON library. By default Ecto will use &lt;a href=&quot;https://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt; which needs to be added to your deps in &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad179f69fed4d39adf90ca8b668b0dcf60ff8610" translate="yes" xml:space="preserve">
          <source>For more information on ETS tables, visit the Erlang documentation at &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html.&quot;&gt;http://www.erlang.org/doc/man/ets.html.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aba17a165f8cb7c095fcd429f135914d9b29c38" translate="yes" xml:space="preserve">
          <source>For more information on ETS tables, visit the Erlang documentation at http://www.erlang.org/doc/man/ets.html.</source>
          <target state="translated">Более подробную информацию о таблицах ETS можно найти в документации Erlang на сайте http://www.erlang.org/doc/man/ets.html.</target>
        </trans-unit>
        <trans-unit id="1a5b5eefc79a13a3a9a181a1c7ba5819905b9c98" translate="yes" xml:space="preserve">
          <source>For more information on casting, see &lt;a href=&quot;ecto.type#c:cast/1&quot;&gt;&lt;code&gt;Ecto.Type.cast/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959df3fd0cfdc74970dc2d4527558d71775f58df" translate="yes" xml:space="preserve">
          <source>For more information on dumping, see &lt;a href=&quot;ecto.type#c:dump/1&quot;&gt;&lt;code&gt;Ecto.Type.dump/1&lt;/code&gt;&lt;/a&gt;. Note that this callback &lt;em&gt;will&lt;/em&gt; be called when dumping a &lt;code&gt;nil&lt;/code&gt; value, unlike &lt;a href=&quot;ecto.type#c:dump/1&quot;&gt;&lt;code&gt;Ecto.Type.dump/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c5c587c188573e903e09204ede4dad88b83c93" translate="yes" xml:space="preserve">
          <source>For more information on embedding, see &lt;a href=&quot;ecto.type#c:embed_as/1&quot;&gt;&lt;code&gt;Ecto.Type.embed_as/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf3cc1f04b722de715fcdda4f43335a0fa29ca2" translate="yes" xml:space="preserve">
          <source>For more information on how to modify your database schema please refer to the ecto's migration dsl &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Migration.html&quot;&gt;ecto migration docs&lt;/a&gt;. For example, to alter an existing schema see the documentation on ecto&amp;rsquo;s &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Migration.html#alter/2&quot;&gt;&lt;code&gt;alter/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fe3d8e56fdc17686d2e30d6867234c608125eb" translate="yes" xml:space="preserve">
          <source>For more information on loading, see &lt;a href=&quot;ecto.type#c:load/1&quot;&gt;&lt;code&gt;Ecto.Type.load/1&lt;/code&gt;&lt;/a&gt;. Note that this callback &lt;em&gt;will&lt;/em&gt; be called when loading a &lt;code&gt;nil&lt;/code&gt; value, unlike &lt;a href=&quot;ecto.type#c:load/1&quot;&gt;&lt;code&gt;Ecto.Type.load/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7497a10d07df46f2b4b817a1e9655c0d2b08b83d" translate="yes" xml:space="preserve">
          <source>For more information on named bindings see &quot;Named bindings&quot; in this module doc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86dc89db4b6ce2937afc00f7c25bd37c98b90786" translate="yes" xml:space="preserve">
          <source>For more information on named bindings see &amp;ldquo;Named bindings&amp;rdquo; in this module doc.</source>
          <target state="translated">Для получения дополнительной информации об именованных привязках см. &amp;laquo;Именованные привязки&amp;raquo; в этом модульном документе.</target>
        </trans-unit>
        <trans-unit id="f575930ba40732ed5321d4dfc902877f97a260e8" translate="yes" xml:space="preserve">
          <source>For more information on schema types, see &lt;a href=&quot;ecto.type#c:type/0&quot;&gt;&lt;code&gt;Ecto.Type.type/0&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4afd6eff44c1ca0a8cddb75ff5a6a8d39a20181b" translate="yes" xml:space="preserve">
          <source>For most use cases, this is all you need and form recovery will happen without consideration. In some cases, where forms are built step-by-step in a stateful fashion, it may require extra recovery handling on the server outside of your existing &lt;code&gt;phx-change&lt;/code&gt; callback code. To enable specialized recovery, provide a &lt;code&gt;phx-auto-recover&lt;/code&gt; binding on the form to specify a different event to trigger for recovery, which will receive the form params as usual. For example, imagine a LiveView wizard form where the form is stateful and built based on what step the user is on and by prior selections:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7028da18781b4d884d99f3ee7b8c02bf1245d37" translate="yes" xml:space="preserve">
          <source>For new applications, the ErrorView looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282464bf76622e75b3765b0efb4b281d44c1c143" translate="yes" xml:space="preserve">
          <source>For now it doesn't matter that we don't actually have a &lt;code&gt;HelloWeb.UserController&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56f6e0fcb2fe492fc12d986fac6e6954793e6c8" translate="yes" xml:space="preserve">
          <source>For now, it suffices to say that each Plug defines a slice of request processing. In the endpoint you will find a skeleton roughly like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886bdd0ff64c15f2da68e1f96f4b3b6b7cac28a4" translate="yes" xml:space="preserve">
          <source>For now, user credentials will contain only email information. Our first order of business is to decide where credentials live in the application. We have our &lt;code&gt;Accounts&lt;/code&gt; context, which manages user accounts. User credentials is a natural fit here. Phoenix is also smart enough to generate code inside an existing context, which makes adding new resources to a context a breeze. Run the following command at your project root:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e16e993fd473ea76243c2fdc4e544518d69c0e0" translate="yes" xml:space="preserve">
          <source>For now, we'll ignore the pipelines and the use of &lt;code&gt;scope&lt;/code&gt; here and just focus on adding a route. We will discuss those in &lt;a href=&quot;routing&quot;&gt;the Routing guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47623288c6f7e25e0286078a9bc973202790385a" translate="yes" xml:space="preserve">
          <source>For options and examples see documentation of &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt; и примеры см. В документации embeds_many / 3 .</target>
        </trans-unit>
        <trans-unit id="5fa05355f3967ad546f604ed6817bb6dc2f2810a" translate="yes" xml:space="preserve">
          <source>For options and examples see documentation of &lt;a href=&quot;#embeds_one/3&quot;&gt;&lt;code&gt;embeds_one/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#embeds_one/3&quot;&gt; &lt;code&gt;embeds_one/3&lt;/code&gt; &lt;/a&gt; и примеры см. В документации по embeds_one / 3 .</target>
        </trans-unit>
        <trans-unit id="4f762b81db42047b1f8e5c705f799a2c497f5c89" translate="yes" xml:space="preserve">
          <source>For preloads, the selected fields may be specified from the parent:</source>
          <target state="translated">Для предварительной загрузки выбранные поля могут быть заданы из родительских:</target>
        </trans-unit>
        <trans-unit id="99b2911ab549294cdbf33bc1636f3d5c92514f4c" translate="yes" xml:space="preserve">
          <source>For proper form error tag updates, the error tag must specify which input it belongs to. This is accomplished with the &lt;code&gt;phx-feedback-for&lt;/code&gt; attribute. Failing to add the &lt;code&gt;phx-feedback-for&lt;/code&gt; attribute will result in displaying error messages for form fields that the user has not changed yet (e.g. required fields further down on the page).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a741dc08e6f8380624e48ef2c45211a0061c62e0" translate="yes" xml:space="preserve">
          <source>For relational databases, this means the RETURNING option of those statements is used. For this reason, MySQL does not support this option and will raise an error if a schema is inserted/updated with read after writes fields.</source>
          <target state="translated">Для реляционных баз данных это означает,что используется опция RETURNING.По этой причине MySQL не поддерживает эту опцию и будет вызывать ошибку,если схема будет вставлена/обновлена с прочитанными после записи полями.</target>
        </trans-unit>
        <trans-unit id="00597a349fb6a62ad730ce7a374a1fd3fdf60dfa" translate="yes" xml:space="preserve">
          <source>For relations, these functions will return the changeset data with changes applied. To retrieve raw changesets, please use &lt;a href=&quot;#get_change/3&quot;&gt;&lt;code&gt;get_change/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для отношений эти функции будут возвращать данные набора изменений с примененными изменениями. Чтобы получить необработанные ревизии, используйте &lt;a href=&quot;#get_change/3&quot;&gt; &lt;code&gt;get_change/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a48c0cb962716952cf875975eac6007455ad2f0" translate="yes" xml:space="preserve">
          <source>For relations, these functions will return the changeset original data with changes applied. To retrieve raw changesets, please use &lt;a href=&quot;#fetch_change/2&quot;&gt;&lt;code&gt;fetch_change/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для отношений эти функции будут возвращать исходные данные набора изменений с примененными изменениями. Чтобы получить необработанные ревизии, используйте &lt;a href=&quot;#fetch_change/2&quot;&gt; &lt;code&gt;fetch_change/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e438c72243585ad24059c796c9627a8dd79cb75" translate="yes" xml:space="preserve">
          <source>For requests with a different request method, this plug will only fetch the query params.</source>
          <target state="translated">Для запросов с другим методом запроса этот плагин будет только получать параметры запроса.</target>
        </trans-unit>
        <trans-unit id="9e5eaa2ebb08d285e2d07000eb79f966c0f46f7d" translate="yes" xml:space="preserve">
          <source>For responsive images, pass a map, list or string through &lt;code&gt;:srcset&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8f14bec39884e1bac29f6af6c015070597aa14" translate="yes" xml:space="preserve">
          <source>For security reasons, the form data and parameter values are never re-used in &lt;a href=&quot;#password_input/3&quot;&gt;&lt;code&gt;password_input/3&lt;/code&gt;&lt;/a&gt;. Pass the value explicitly if you would like to set one.</source>
          <target state="translated">По соображениям безопасности данные формы и значения параметров никогда не используются повторно в &lt;a href=&quot;#password_input/3&quot;&gt; &lt;code&gt;password_input/3&lt;/code&gt; &lt;/a&gt; . Передайте значение явно, если хотите его установить.</target>
        </trans-unit>
        <trans-unit id="0c9c55ef99a1b85442974d55919cef61666635f0" translate="yes" xml:space="preserve">
          <source>For security, &lt;code&gt;:to&lt;/code&gt; only accepts paths. Use the &lt;code&gt;:external&lt;/code&gt; option to redirect to any URL.</source>
          <target state="translated">В целях безопасности &lt;code&gt;:to&lt;/code&gt; принимает только пути. Используйте параметр &lt;code&gt;:external&lt;/code&gt; для перенаправления на любой URL-адрес.</target>
        </trans-unit>
        <trans-unit id="c3bb42014432d8496efa23344529a842fdecd850" translate="yes" xml:space="preserve">
          <source>For solutions that operate below the HTTP layer, e.g. using HAProxy, the client IP address can sometimes be passed through the 'PROXY protocol'. Extracting this information must be handled by the Plug adapter. Please refer to the Plug adapter documentation for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04c64cf7b36c911c0f825bd502b4d9dcf238921" translate="yes" xml:space="preserve">
          <source>For staging and production it is necessary to obtain a CA-signed certificate from a trusted Certificate Authority, such as &lt;a href=&quot;https://letsencrypt.org&quot;&gt;Let's Encrypt&lt;/a&gt;. Certificates issued by a CA usually come with an additional file containing one or more certificates that make up the 'CA chain'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff536d187e3538d188ab49aed8a72744fd84f9c" translate="yes" xml:space="preserve">
          <source>For stylesheet files found under the given path, Phoenix will replace asset references with the digested paths, as long as the asset exists in the generated cache manifest.</source>
          <target state="translated">Для файлов таблиц стилей,найденных по заданному пути,Phoenix заменит ссылки на активы перевариваемыми путями,пока актив существует в сгенерированном кэш-манифесте.</target>
        </trans-unit>
        <trans-unit id="8c36fe9b2a7c749e8571085eb2af112fd9083639" translate="yes" xml:space="preserve">
          <source>For such cases, just pass an atom representing the action to dispatch:</source>
          <target state="translated">В таких случаях просто передайте атом,представляющий действие,для отправки:</target>
        </trans-unit>
        <trans-unit id="3e369afedac592425ec8d8e891860e0bbe16c64c" translate="yes" xml:space="preserve">
          <source>For such cases, you need to set the &lt;code&gt;@endpoint&lt;/code&gt; attribute to your controller and pass an atom representing the action to dispatch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c25469cbfa8dfe50c32adf8947d072adc5da07" translate="yes" xml:space="preserve">
          <source>For testing purposes it may be sufficient to use a self-signed certificate. Such certificates generally result in warnings in browsers and failed connections from other tools, but these can be overridden to enable HTTPS testing. This is especially useful for local testing of HTTP 2, which is only specified over TLS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a1f9c6c25c59a377c89a60f258c5d3b208854e" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;:decimal&lt;/code&gt; type, &lt;code&gt;+Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; values are not supported, even though the &lt;a href=&quot;https://hexdocs.pm/decimal/1.5.0/Decimal.html&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; library handles them. To support them, you can create a custom type.</source>
          <target state="translated">Для типа &lt;code&gt;:decimal&lt;/code&gt; значения &lt;code&gt;+Infinity&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; не поддерживаются, хотя их обрабатывает библиотека &lt;a href=&quot;https://hexdocs.pm/decimal/1.5.0/Decimal.html&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; . Чтобы поддержать их, вы можете создать собственный тип.</target>
        </trans-unit>
        <trans-unit id="d601251c886cf09d8df301039ddd66e5410dddf0" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;:decimal&lt;/code&gt; type, &lt;code&gt;+Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; values are not supported, even though the &lt;a href=&quot;https://hexdocs.pm/decimal/1.6.0/Decimal.html&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; library handles them. To support them, you can create a custom type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780c2570702e69db99f32922ce1d16997b165979" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;{:array, inner_type}&lt;/code&gt; and &lt;code&gt;{:map, inner_type}&lt;/code&gt; type, replace &lt;code&gt;inner_type&lt;/code&gt; with one of the valid types, such as &lt;code&gt;:string&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;{:array, inner_type}&lt;/code&gt; и &lt;code&gt;{:map, inner_type}&lt;/code&gt; замените &lt;code&gt;inner_type&lt;/code&gt; одним из допустимых типов, например &lt;code&gt;:string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b121a5201e5fe9abd71ff02499c57b1592c223e" translate="yes" xml:space="preserve">
          <source>For the endpoint:</source>
          <target state="translated">Для конечной точки:</target>
        </trans-unit>
        <trans-unit id="b1f1151b7b2d1e19979f082133ff2e9a94a228d5" translate="yes" xml:space="preserve">
          <source>For the last piece of this puzzle, we'll need a new template. Since it is for the &lt;code&gt;show&lt;/code&gt; action of the &lt;code&gt;HelloController&lt;/code&gt;, it will go into the &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; directory and be called &lt;code&gt;show.html.eex&lt;/code&gt;. It will look surprisingly like our &lt;code&gt;index.html.eex&lt;/code&gt; template, except that we will need to display the name of our messenger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19fd3691f7d4d31387de8d41929bd14c258e795" translate="yes" xml:space="preserve">
          <source>For the live-reload websocket:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81005f9cec33e8f78401fbfd630c9003c91a58e8" translate="yes" xml:space="preserve">
          <source>For these use cases, the &lt;code&gt;phx-change&lt;/code&gt; input does not concern itself with disabling input editing while an event to the server is in flight. When a &lt;code&gt;phx-change&lt;/code&gt; event is sent to the server, the input tag and parent form tag receive the &lt;code&gt;phx-change-loading&lt;/code&gt; css class, then the payload is pushed to the server with a &lt;code&gt;&quot;_target&quot;&lt;/code&gt; param in the root payload containing the keyspace of the input name which triggered the change event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fe2c0bee48cd8643f3d8a46b8a6fe43bb8e581" translate="yes" xml:space="preserve">
          <source>For this exercise, we're going to re-use the &lt;code&gt;HelloController&lt;/code&gt; we just created and just add a new &lt;code&gt;show&lt;/code&gt; action. We'll add a line just below our last route, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6cc26f40ba25b58fe4ceb1492cc4ebe433ed3db" translate="yes" xml:space="preserve">
          <source>For this plug to work, it expects a session to have been previously fetched. It will then compare the plug stored in the session with the one sent by the request to determine the validity of the request. For an invalid request the action taken is based on the &lt;code&gt;:with&lt;/code&gt; option.</source>
          <target state="translated">Чтобы этот плагин работал, он ожидает, что сеанс был предварительно загружен. Затем он сравнит плагин, сохраненный в сеансе, с плагином, отправленным по запросу, чтобы определить действительность запроса. В случае недопустимого запроса действие выполняется на основе параметра &lt;code&gt;:with&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c19aeef5835b8730002052f32c829b18a9a1b368" translate="yes" xml:space="preserve">
          <source>For this plug to work, it expects a session to have been previously fetched. It will then compare the token stored in the session with the one sent by the request to determine the validity of the request. For an invalid request the action taken is based on the &lt;code&gt;:with&lt;/code&gt; option.</source>
          <target state="translated">Чтобы этот плагин работал, он ожидает, что сеанс был предварительно загружен. Затем он сравнит токен, хранящийся в сеансе, с токеном, отправленным по запросу, чтобы определить действительность запроса. В случае недопустимого запроса действие выполняется на основе параметра &lt;code&gt;:with&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acbd3da24abf12ae2ee4b4dbe388f7d784a60abf" translate="yes" xml:space="preserve">
          <source>For this reason, Phoenix automatically includes a &amp;ldquo;_utf8=✓&amp;rdquo; parameter in your forms, to force those browsers to send the data in the proper encoding. This technique has been seen in the Rails web framework and reproduced here.</source>
          <target state="translated">По этой причине Phoenix автоматически включает параметр &amp;laquo;_utf8 = ✓&amp;raquo; в ваши формы, чтобы эти браузеры отправляли данные в правильной кодировке. Этот метод был замечен в веб-фреймворке Rails и воспроизведен здесь.</target>
        </trans-unit>
        <trans-unit id="93af13c5fc0bdc9bd0b9d349f954f83799c8aaa8" translate="yes" xml:space="preserve">
          <source>For this reason, we will use schemas on the remaining examples but remember Ecto does not require them in order to write queries.</source>
          <target state="translated">По этой причине мы будем использовать схемы на остальных примерах,но помните,что Ecto не требует их для написания запросов.</target>
        </trans-unit>
        <trans-unit id="4eee2cf416e710c5d41ff3bd324c67e1310cb64b" translate="yes" xml:space="preserve">
          <source>For use with Plug the certificates and key should be stored in PEM format, containing Base64-encoded data between 'BEGIN' and 'END' markers. Some useful OpenSSL commands for converting certificates/keys from other formats can be found at &lt;a href=&quot;#converting-certificates-and-keys&quot;&gt;the end of this document&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e5ab937cf7dceafaad92974cb027e2587d7a76" translate="yes" xml:space="preserve">
          <source>Force table clean up because the given pid is down asynchronously</source>
          <target state="translated">Принудительная очистка таблицы,потому что данный лошадик опускается асинхронно.</target>
        </trans-unit>
        <trans-unit id="8297c64e60d581b16d4f160782d093bba37f69c8" translate="yes" xml:space="preserve">
          <source>Force table clean up because the given pid is down asynchronously.</source>
          <target state="translated">Принудительная очистка таблицы,потому что данный котел опускается асинхронно.</target>
        </trans-unit>
        <trans-unit id="9376e40f7dd57bd0a80a45f4b597decef3430bb5" translate="yes" xml:space="preserve">
          <source>Forces SSL in the socket connection</source>
          <target state="translated">Усиливает SSL в разъемном соединении</target>
        </trans-unit>
        <trans-unit id="f2f36ba3d6535af9ad03fa2741c09ec0c941cf53" translate="yes" xml:space="preserve">
          <source>Forces SSL in the socket connection.</source>
          <target state="translated">Вводит SSL в разъемное соединение.</target>
        </trans-unit>
        <trans-unit id="a94803f581b82f9ba5bdaf6f21212ed730ebfce9" translate="yes" xml:space="preserve">
          <source>Forces a change on the given &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">Принудительно изменяет данный &lt;code&gt;key&lt;/code&gt; со &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba1f8f66627e0e0f8fe7b916b77edc9622c220fc" translate="yes" xml:space="preserve">
          <source>Forces a change on the given &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Принудительно изменяет данный &lt;code&gt;key&lt;/code&gt; со &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d30ae53e81b25bd47a3ef79f6270bb2aee0a4b4" translate="yes" xml:space="preserve">
          <source>Form Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfc11712b7350cabf491f94f3c35d6b7b4841ba2" translate="yes" xml:space="preserve">
          <source>Form bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59e0684db2c7234ae793772920708c7ec986309" translate="yes" xml:space="preserve">
          <source>Format encoders</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97fca207ecbaf116ba6ca44368cce3e0a305b92" translate="yes" xml:space="preserve">
          <source>Fortunately that&amp;rsquo;s easily solvable by simply rewriting it to:</source>
          <target state="translated">К счастью, это легко решить, просто переписав его так:</target>
        </trans-unit>
        <trans-unit id="ce0ce27512362c06a1b5491aeb75239f7f72fd68" translate="yes" xml:space="preserve">
          <source>Fortunately that's easily solvable by simply rewriting it to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e135da21707dbf32a06679cd1c1f36d2117cbc6" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt;&lt;code&gt;Telemetry.Metrics&lt;/code&gt;&lt;/a&gt; provides the following options to help you classify your events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd153d2c6179415e41d49146fab6f4c5d3731e1" translate="yes" xml:space="preserve">
          <source>Fortunately, our application layout, &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt;, already has markup for displaying flash messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4e72261283258434788542ba397135c10f39d8" translate="yes" xml:space="preserve">
          <source>Forward</source>
          <target state="translated">Forward</target>
        </trans-unit>
        <trans-unit id="243792f59615d8e2d372bd2223d968fccda687be" translate="yes" xml:space="preserve">
          <source>Forwards a request at the given path to a plug</source>
          <target state="translated">Пересылает запрос по заданному пути к штепсельной вилке.</target>
        </trans-unit>
        <trans-unit id="16e33ad48d9a60b2973610a401cef5c85f913f57" translate="yes" xml:space="preserve">
          <source>Forwards a request at the given path to a plug.</source>
          <target state="translated">Пересылает запрос по заданному пути к штепсельной вилке.</target>
        </trans-unit>
        <trans-unit id="b32cf12685ca5dc27b473a969f37f02beef213d2" translate="yes" xml:space="preserve">
          <source>Forwards requests to another Plug. The &lt;code&gt;path_info&lt;/code&gt; of the forwarded connection will exclude the portion of the path specified in the call to &lt;code&gt;forward&lt;/code&gt;. If the path contains any parameters, those will be available in the target Plug in &lt;code&gt;conn.params&lt;/code&gt; and &lt;code&gt;conn.path_params&lt;/code&gt;</source>
          <target state="translated">Перенаправляет запросы на другой Plug. &lt;code&gt;path_info&lt;/code&gt; пересылаемой связи будет исключать часть пути , указанный в вызове &lt;code&gt;forward&lt;/code&gt; . Если путь содержит какие-либо параметры, они будут доступны в целевом &lt;code&gt;conn.params&lt;/code&gt; и &lt;code&gt;conn.path_params&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2b6fd862c663433fb18b8d94573b799a0d0c715" translate="yes" xml:space="preserve">
          <source>Forwards requests to another Plug. The &lt;code&gt;path_info&lt;/code&gt; of the forwarded connection will exclude the portion of the path specified in the call to &lt;code&gt;forward&lt;/code&gt;. If the path contains any parameters, those will be available in the target Plug in &lt;code&gt;conn.params&lt;/code&gt; and &lt;code&gt;conn.path_params&lt;/code&gt;.</source>
          <target state="translated">Перенаправляет запросы на другой Plug. &lt;code&gt;path_info&lt;/code&gt; пересылаемой связи будет исключать часть пути , указанный в вызове &lt;code&gt;forward&lt;/code&gt; . Если путь содержит какие-либо параметры, они будут доступны в целевом подключаемом &lt;code&gt;conn.params&lt;/code&gt; и &lt;code&gt;conn.path_params&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="676ca63eda9f110339bc4562d41c4087d1f58d05" translate="yes" xml:space="preserve">
          <source>Four different datetime primitive types are available:</source>
          <target state="translated">Доступны четыре различных типа примитивов даты:</target>
        </trans-unit>
        <trans-unit id="d45089940ca38bf48726ea01710791bffa1dee6e" translate="yes" xml:space="preserve">
          <source>Fragments</source>
          <target state="translated">Fragments</target>
        </trans-unit>
        <trans-unit id="24ecc99e6f92d07b027a8f31eee228f80d919122" translate="yes" xml:space="preserve">
          <source>From DER to PEM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3351c1a0bc423227fbc6658fde3c845ebb20e75" translate="yes" xml:space="preserve">
          <source>From Erlang/OTP 20, channels automatically hibernate to save memory after 15_000 milliseconds of inactivity. This can be customized by passing the &lt;code&gt;:hibernate_after&lt;/code&gt; option to &lt;code&gt;use Phoenix.Channel&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea65443ee14e0c13f251a23f3960e33cefea03e" translate="yes" xml:space="preserve">
          <source>From PKCS#12 to PEM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e393595a2078a0309f19323b539709581858c3" translate="yes" xml:space="preserve">
          <source>From endpoint to views</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e148084f6ad05655c1539a8c5e852e406d1b752b" translate="yes" xml:space="preserve">
          <source>From the client - this is done by replacing &lt;a href=&quot;../phoenix_html/phoenix.html.link#link/2&quot;&gt;&lt;code&gt;Phoenix.HTML.Link.link/2&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Helpers.live_patch/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Helpers.live_redirect/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c883c0cead87878c13107898743ee64b746f1b75" translate="yes" xml:space="preserve">
          <source>From the description, it's clear we need a &lt;code&gt;Page&lt;/code&gt; resource for storing page information. What about our author information? While we could extend our existing &lt;code&gt;Accounts.User&lt;/code&gt; schema to include information such as bio and role, that would violate the responsibilities we've set up for our contexts. Why should our Account system now be aware of author information? Worse, with a field like &quot;role&quot;, the CMS role in the system will likely conflict or be confused with other account roles for our application. There's a better way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c42ad7be67b12c5ded49ac88365867cded7985" translate="yes" xml:space="preserve">
          <source>From the server - this is done by replacing &lt;a href=&quot;../phoenix/phoenix.controller#redirect/2&quot;&gt;&lt;code&gt;Phoenix.Controller.redirect/2&lt;/code&gt;&lt;/a&gt; calls by &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.push_patch/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.push_redirect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d57ff449f79bf9c5a7e5e0c8035c5660c71a840" translate="yes" xml:space="preserve">
          <source>From this moment on, all future queries done by the current process will run on &lt;code&gt;:tenant_foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7091d22a2b4d23609cc93c591d186ab2886edba6" translate="yes" xml:space="preserve">
          <source>Front-end to Phoenix pubsub layer.</source>
          <target state="translated">Впереди слой пабов Феникса.</target>
        </trans-unit>
        <trans-unit id="9a3dd8d119f213e54043ceb85ba50067487df91c" translate="yes" xml:space="preserve">
          <source>Function Plugs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf236d048ccab1956dd5420be9ebe7d7c44331e" translate="yes" xml:space="preserve">
          <source>Function plugs</source>
          <target state="translated">Функциональные штекеры</target>
        </trans-unit>
        <trans-unit id="2dd4a4a3d83639ed1b8ee2c403652e8e1564593e" translate="yes" xml:space="preserve">
          <source>Function plugs are plugged by passing the function name as an atom. To try the Plug out, go back to your browser and fetch &quot;http://localhost:4000&quot;. You should see something like this printed in your terminal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52ba62be465c21dfd3bd9843b5875f996364af7" translate="yes" xml:space="preserve">
          <source>Functional Web Development with Elixir, OTP, and Phoenix Rethink the Modern Web App (by Lance Halvorsen - 2017)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8578c4e152b3c9315bc17a094d58da8a5fe7bd6e" translate="yes" xml:space="preserve">
          <source>Functionality for providing Basic HTTP authentication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="1442301406adda1b4f88b555bb39bb4cb9e30ff1" translate="yes" xml:space="preserve">
          <source>Furthermore an array type can also be given if it is supported by your database, although it requires the type of the underlying array element to be given too:</source>
          <target state="translated">Кроме того,тип массива может быть указан,если он поддерживается вашей базой данных,хотя для этого требуется указать и тип элемента,лежащего в основе массива:</target>
        </trans-unit>
        <trans-unit id="45c1f2b55dcf3303d32f38fbac65ddded9bd404b" translate="yes" xml:space="preserve">
          <source>Furthermore, both &lt;code&gt;__struct__&lt;/code&gt; and &lt;code&gt;__changeset__&lt;/code&gt; functions are defined so structs and changeset functionalities are available.</source>
          <target state="translated">Кроме того, &lt;code&gt;__struct__&lt;/code&gt; функции __struct__ и &lt;code&gt;__changeset__&lt;/code&gt; , поэтому доступны структуры и функции набора изменений.</target>
        </trans-unit>
        <trans-unit id="dc4cf7a9112b1823e7922465dba21cf009cbc323" translate="yes" xml:space="preserve">
          <source>Furthermore, it is very important to not access the same parameters on both &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt;. For example, do NOT do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2ace48935ec9ca13c146a4d739dd039753a23f" translate="yes" xml:space="preserve">
          <source>Furthermore, it sets the following defaults:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9cc3e69d5248baac17979dd85069ab7aa035bd" translate="yes" xml:space="preserve">
          <source>Furthermore, since the tag information is given as structs read directly from the database, Ecto will treat the data as correct and only do the minimum necessary to guarantee that posts and tags are associated, without trying to update or diff any of the fields in the tag struct.</source>
          <target state="translated">Более того,так как информация тегов дается в виде структур,считываемых непосредственно из базы данных,Ecto будет относиться к данным как к правильным и делать только минимум,необходимый для гарантии того,что сообщения и теги связаны,без попыток обновить или различить любое из полей в структуре тегов.</target>
        </trans-unit>
        <trans-unit id="c338ceb5b7adaaa50f38c347f2349c53389ff49c" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;before_send&lt;/code&gt; field stores callbacks that are invoked before the connection is sent. Callbacks are invoked in the reverse order they are registered (callbacks registered first are invoked last) in order to reproduce a pipeline ordering.</source>
          <target state="translated">Кроме того, в поле &lt;code&gt;before_send&lt;/code&gt; хранятся обратные вызовы, которые вызываются перед отправкой соединения. Обратные вызовы вызываются в порядке, обратном их регистрации (обратные вызовы, зарегистрированные первыми, вызываются последними), чтобы воспроизвести порядок конвейера.</target>
        </trans-unit>
        <trans-unit id="70e2803f5997f8434e1e14d79b67bf417331f761" translate="yes" xml:space="preserve">
          <source>Furthermore, this protocol relies on iodata, which provides better performance when sending or streaming data to the client.</source>
          <target state="translated">Более того,этот протокол полагается на iodata,который обеспечивает более высокую производительность при отправке или потоковой передаче данных клиенту.</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="98281856e51de8bb0669d3ab3f5d42120b606d43" translate="yes" xml:space="preserve">
          <source>GET requests are not protected, as they should not have any side-effect or change your application state. JavaScript requests are an exception: by using a script tag, external websites can embed server-side generated JavaScript, which can leak information. For this reason, this plug also forbids any GET JavaScript request that is not XHR (or AJAX).</source>
          <target state="translated">GET-запросы не защищены,так как они не должны иметь побочных эффектов или изменять состояние вашего приложения.JavaScript-запросы являются исключением:используя тег скрипта,внешние сайты могут встраивать сгенерированный на стороне сервера JavaScript,что может привести к утечке информации.По этой причине данный плагин также запрещает любой GET JavaScript-запрос,не являющийся XHR (или AJAX).</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">сбор мусора</target>
        </trans-unit>
        <trans-unit id="a96be0a4f608d9678cf95140fc6762e7fff0a137" translate="yes" xml:space="preserve">
          <source>Geerates the static URL without any path information</source>
          <target state="translated">Генерирует статический URL-адрес без информации о пути.</target>
        </trans-unit>
        <trans-unit id="18fd8d6947881e76a9476c5cc3ade9f03cb51e63" translate="yes" xml:space="preserve">
          <source>Geerates the static URL without any path information.</source>
          <target state="translated">Генерирует статический URL без информации о пути.</target>
        </trans-unit>
        <trans-unit id="81d73279e9d50f0e75f19715870b45b2edcc66d2" translate="yes" xml:space="preserve">
          <source>General: &lt;a href=&quot;#fragment/1&quot;&gt;&lt;code&gt;fragment/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#field/2&quot;&gt;&lt;code&gt;field/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Общие: &lt;a href=&quot;#fragment/1&quot;&gt; &lt;code&gt;fragment/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#field/2&quot;&gt; &lt;code&gt;field/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff7162efc456a290918a3e5ee7fb1cdec59b3096" translate="yes" xml:space="preserve">
          <source>General: &lt;a href=&quot;#fragment/1&quot;&gt;&lt;code&gt;fragment/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#field/2&quot;&gt;&lt;code&gt;field/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#as/1&quot;&gt;&lt;code&gt;as/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#parent_as/1&quot;&gt;&lt;code&gt;parent_as/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89915973deb8400c76aef3230f3bef302eb16934" translate="yes" xml:space="preserve">
          <source>Generally speaking, &lt;strong&gt;data loading should never happen inside the template&lt;/strong&gt;, regardless if you are using LiveView or not. The difference is that LiveView enforces this best practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a9eeb3344bae3449699429e539fd4fa8761f40" translate="yes" xml:space="preserve">
          <source>Generally speaking, avoid accessing variables inside LiveViews. This also applies to the &lt;code&gt;assigns&lt;/code&gt; variable, except when rendering another &lt;code&gt;.leex&lt;/code&gt; template. In such cases, it is ok to pass the whole assigns, as LiveView will continue to perform change tracking in the called template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bcf392d6ffb2ecf8e6673b16608e3a7f45a1a5" translate="yes" xml:space="preserve">
          <source>Generally speaking, once all assigns are configured, we invoke the View layer. The View layer then renders &quot;show.html&quot; alongside the layout and a response is sent back to the browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6326d5e8e870450f20952d282dad90d36072ad9" translate="yes" xml:space="preserve">
          <source>Generally speaking, the simplest and safest approach is to perform authorization whenever there is an action. For example, imagine that you have a LiveView for a &quot;Blog&quot;, and only editors can edit posts. Therefore, it is best to validate the user is an editor on mount and on every event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02048f2e9cef3e709a6a4f29484a15537a595bf8" translate="yes" xml:space="preserve">
          <source>Generally speaking, you want to avoid both the parent LiveView and the LiveComponent working on two different copies of the state. Instead, you should assume only one of them to be the source of truth. Let's discuss the two different approaches in detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf039f3463a6192dcedbf378221d86ccce25ca4" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form</source>
          <target state="translated">Сгенерировать новый конструктор формы для данного параметра в форме</target>
        </trans-unit>
        <trans-unit id="2809e45ea67772c9b7701d8d849d6d2e451fe427" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form &lt;strong&gt;without&lt;/strong&gt; an anonymous function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e52a102d3768bc19eacc2abb7f4194a20be07e" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form.</source>
          <target state="translated">Сгенерируйте новый конструктор формы для данного параметра по форме.</target>
        </trans-unit>
        <trans-unit id="bc292ee42a9b81099735fa47e66e355172cc4c20" translate="yes" xml:space="preserve">
          <source>Generated migration can use &lt;code&gt;binary_id&lt;/code&gt; for schema&amp;rsquo;s primary key and its references with option &lt;code&gt;--binary-id&lt;/code&gt;.</source>
          <target state="translated">Сгенерированная миграция может использовать &lt;code&gt;binary_id&lt;/code&gt; для первичного ключа схемы и его ссылок с опцией &lt;code&gt;--binary-id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de509ead052a1d21c5bec58e9e137546f9fbc245" translate="yes" xml:space="preserve">
          <source>Generated migration can use &lt;code&gt;binary_id&lt;/code&gt; for schema's primary key and its references with option &lt;code&gt;--binary-id&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64a5913edebccd654a6fcbe563ded9895c73182" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;:inserted_at&lt;/code&gt; and &lt;code&gt;:updated_at&lt;/code&gt; timestamp fields</source>
          <target state="translated">Формирует &lt;code&gt;:inserted_at&lt;/code&gt; и &lt;code&gt;:updated_at&lt;/code&gt; временных меток полей</target>
        </trans-unit>
        <trans-unit id="6e6bf2fc4b7fa7784ba0393c92ca08b83b688b33" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;:inserted_at&lt;/code&gt; and &lt;code&gt;:updated_at&lt;/code&gt; timestamp fields.</source>
          <target state="translated">Формирует &lt;code&gt;:inserted_at&lt;/code&gt; и &lt;code&gt;:updated_at&lt;/code&gt; временные метки полей.</target>
        </trans-unit>
        <trans-unit id="f543054b72a2d883e856cf6feb6ce5419c2d27c6" translate="yes" xml:space="preserve">
          <source>Generates LiveView, templates, and context for a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ec673256a5e76ef7c069fc676e2f5aef51009e" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;socket_ref&lt;/code&gt; for an async reply</source>
          <target state="translated">Создает &lt;code&gt;socket_ref&lt;/code&gt; для асинхронного ответа</target>
        </trans-unit>
        <trans-unit id="89363898c56d89d0dc4865b93a5f0b41e2cb4d20" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;socket_ref&lt;/code&gt; for an async reply.</source>
          <target state="translated">Создает &lt;code&gt;socket_ref&lt;/code&gt; для асинхронного ответа.</target>
        </trans-unit>
        <trans-unit id="7254b9e30fd4dcd56334ce2310a46519a11db327" translate="yes" xml:space="preserve">
          <source>Generates a Phoenix channel.</source>
          <target state="translated">Генерирует канал Феникса.</target>
        </trans-unit>
        <trans-unit id="dbbfe88a5e9c28bee33e4a7709d25c7578b13712" translate="yes" xml:space="preserve">
          <source>Generates a Phoenix resource.</source>
          <target state="translated">Генерирует ресурс Феникса.</target>
        </trans-unit>
        <trans-unit id="396e5bd6ba3cdeb590c49ec0bbf4116674cec309" translate="yes" xml:space="preserve">
          <source>Generates a Presence tracker for your application.</source>
          <target state="translated">Генерирует трекер Присутствия для вашего приложения.</target>
        </trans-unit>
        <trans-unit id="e050d4cb2d11258492bf32d26abe466db5793c12" translate="yes" xml:space="preserve">
          <source>Generates a Presence tracker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b57a23b25adcd3dfb1b05de10692fcac4b0c0a7" translate="yes" xml:space="preserve">
          <source>Generates a button that uses a regular HTML form to submit to the given URL</source>
          <target state="translated">Генерирует кнопку,которая использует обычную HTML-форму для отправки по заданному адресу.</target>
        </trans-unit>
        <trans-unit id="6dc6b7e0d06c3c7fac4214ca839f28cb452a6270" translate="yes" xml:space="preserve">
          <source>Generates a button that uses a regular HTML form to submit to the given URL.</source>
          <target state="translated">Генерирует кнопку,которая использует обычную HTML-форму для отправки по заданному URL.</target>
        </trans-unit>
        <trans-unit id="64561f910e36802f2f2af6c0eeef79ae9959a53a" translate="yes" xml:space="preserve">
          <source>Generates a checkbox</source>
          <target state="translated">Генерирует флажок</target>
        </trans-unit>
        <trans-unit id="9c402930c245037de584689931bc5f98cb925246" translate="yes" xml:space="preserve">
          <source>Generates a checkbox.</source>
          <target state="translated">Генерирует флажок.</target>
        </trans-unit>
        <trans-unit id="e758b3646d387941fe43bb7c638a89c7ddd9d4c8" translate="yes" xml:space="preserve">
          <source>Generates a childspec to be used in the supervision tree</source>
          <target state="translated">Генерирует childspec для использования в дереве супервизии.</target>
        </trans-unit>
        <trans-unit id="084a356e3603b2d7d3058ec01dbce1827e553b3a" translate="yes" xml:space="preserve">
          <source>Generates a childspec to be used in the supervision tree.</source>
          <target state="translated">Генерирует childspec для использования в дереве супервизии.</target>
        </trans-unit>
        <trans-unit id="c63422f792595ace635012713e2e3ec5fdcfe7c7" translate="yes" xml:space="preserve">
          <source>Generates a color input</source>
          <target state="translated">Генерирует цветовой ввод</target>
        </trans-unit>
        <trans-unit id="45606cc48a2c148438a5b2a691378a779e9d8307" translate="yes" xml:space="preserve">
          <source>Generates a color input.</source>
          <target state="translated">Генерирует цветовой ввод.</target>
        </trans-unit>
        <trans-unit id="f79dfad3ee4eee79404d483203748cd197bfb509" translate="yes" xml:space="preserve">
          <source>Generates a context with functions around an Ecto schema.</source>
          <target state="translated">Генерирует контекст с функциями вокруг схемы Ecto.</target>
        </trans-unit>
        <trans-unit id="171627640dc242b4213e2f665007e56c741ce2ff" translate="yes" xml:space="preserve">
          <source>Generates a date input</source>
          <target state="translated">Генерирует ввод даты</target>
        </trans-unit>
        <trans-unit id="1fcc6c8cae144832ffc98dcd40c8eac478e1a7da" translate="yes" xml:space="preserve">
          <source>Generates a date input.</source>
          <target state="translated">Генерирует ввод даты.</target>
        </trans-unit>
        <trans-unit id="67502aa3ceeeceb276d924590c8fa7dd9b0a9b11" translate="yes" xml:space="preserve">
          <source>Generates a datetime-local input</source>
          <target state="translated">Генерирует дату-локальный ввод</target>
        </trans-unit>
        <trans-unit id="ef3ed161bccd6158e836dadcf99ca1633c739273" translate="yes" xml:space="preserve">
          <source>Generates a datetime-local input.</source>
          <target state="translated">Генерирует дату-локальный ввод.</target>
        </trans-unit>
        <trans-unit id="9e84d239e416d559f3c0bccab74b22cff072a5a3" translate="yes" xml:space="preserve">
          <source>Generates a file input</source>
          <target state="translated">Генерирует входной файл</target>
        </trans-unit>
        <trans-unit id="39fb04074dabbb624cbc620ccf147d69b2a45061" translate="yes" xml:space="preserve">
          <source>Generates a file input.</source>
          <target state="translated">Генерирует входной файл.</target>
        </trans-unit>
        <trans-unit id="ab3c6b9191c757e18e68646ddc1874ca970de62b" translate="yes" xml:space="preserve">
          <source>Generates a form tag</source>
          <target state="translated">Генерирует тег формы</target>
        </trans-unit>
        <trans-unit id="b412e1f99156deb9e91f69f6b5ac9155bb03b9cf" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder</source>
          <target state="translated">Генерирует тег формы с помощью создателя формы</target>
        </trans-unit>
        <trans-unit id="15171feee1ac42a2cb8b455685e4d0d0b906602c" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder &lt;strong&gt;without&lt;/strong&gt; an anonymous function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83bd97bb3e9ba2d575b33b43cdc2a09ecc53c26" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder &lt;strong&gt;without&lt;/strong&gt; options or an anonymous function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e62cb449bf1bc7de104a5c6a894843c62b8273" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder and an anonymous function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5867e479588e031d9af73f4e26e2f4bb755d993f" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder.</source>
          <target state="translated">Генерирует тег формы с создателем формы.</target>
        </trans-unit>
        <trans-unit id="1fcf6d502cbed8c6774cbd71cd67cb0475fb8d97" translate="yes" xml:space="preserve">
          <source>Generates a form tag with the given contents</source>
          <target state="translated">Генерирует тег формы с заданным содержимым</target>
        </trans-unit>
        <trans-unit id="73a7ae0251a3209970edcca52c92641cb83828a7" translate="yes" xml:space="preserve">
          <source>Generates a form tag with the given contents.</source>
          <target state="translated">Генерирует тег формы с заданным содержимым.</target>
        </trans-unit>
        <trans-unit id="6fb768c7b9543e92cc3420ccd02e97e5655cfdc3" translate="yes" xml:space="preserve">
          <source>Generates a form tag.</source>
          <target state="translated">Генерирует метку формы.</target>
        </trans-unit>
        <trans-unit id="20996193071a0905fdf25cb5c613758dc8b93878" translate="yes" xml:space="preserve">
          <source>Generates a hidden input</source>
          <target state="translated">Генерирует скрытый вход</target>
        </trans-unit>
        <trans-unit id="5b13e8707f3e8f0d576e0f2751dda4df911730a0" translate="yes" xml:space="preserve">
          <source>Generates a hidden input.</source>
          <target state="translated">Генерирует скрытый вход.</target>
        </trans-unit>
        <trans-unit id="abfeb23072c3a06d67ccfbf879bf2eeab96d5b0f" translate="yes" xml:space="preserve">
          <source>Generates a label tag</source>
          <target state="translated">Генерирует этикетку</target>
        </trans-unit>
        <trans-unit id="ce9ab90073232b80839e14e4bbe7f7a803a34eae" translate="yes" xml:space="preserve">
          <source>Generates a label tag for the given field</source>
          <target state="translated">Генерирует метку метки для данного поля</target>
        </trans-unit>
        <trans-unit id="ab3ca2bbbbcd12eb651c2e27c2a279e192ff3c15" translate="yes" xml:space="preserve">
          <source>Generates a label tag for the given field.</source>
          <target state="translated">Генерирует метку для данного поля.</target>
        </trans-unit>
        <trans-unit id="28a6fc00166a8c669fa44ea65f62685493aa2310" translate="yes" xml:space="preserve">
          <source>Generates a label tag.</source>
          <target state="translated">Генерирует этикетку.</target>
        </trans-unit>
        <trans-unit id="ba5c47606513e6f4c9932f97cff5edb31a7e4352" translate="yes" xml:space="preserve">
          <source>Generates a link that will patch the current LiveView.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64cb73e3623bbaa3ca07f4ea3ebd7ddcfb72cbbe" translate="yes" xml:space="preserve">
          <source>Generates a link that will redirect to a new LiveView.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50123897c2b44bec513e431ba7cb02309189fef" translate="yes" xml:space="preserve">
          <source>Generates a link to the given URL</source>
          <target state="translated">Генерирует ссылку на данный URL</target>
        </trans-unit>
        <trans-unit id="c1f404e8a3f775cd18f3aa5b04a6353a8bd3eb26" translate="yes" xml:space="preserve">
          <source>Generates a link to the given URL.</source>
          <target state="translated">Генерирует ссылку на данный URL.</target>
        </trans-unit>
        <trans-unit id="6ea02c48fa1a1a43ce66c3cf13791ad70aa1639c" translate="yes" xml:space="preserve">
          <source>Generates a loaded version of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc6ea3e0e5e175a0282431e58e112038aaa09c9" translate="yes" xml:space="preserve">
          <source>Generates a meta tag with CSRF information</source>
          <target state="translated">Генерирует метатег с информацией CSRF</target>
        </trans-unit>
        <trans-unit id="2219f0cedebbcfc4a9097edd34a767a497cb1274" translate="yes" xml:space="preserve">
          <source>Generates a meta tag with CSRF information.</source>
          <target state="translated">Генерирует метатег с информацией CSRF.</target>
        </trans-unit>
        <trans-unit id="3aee4fdfd218c8ef8af1764ebe197ddee57e21b5" translate="yes" xml:space="preserve">
          <source>Generates a new file, &lt;code&gt;lib/my_app_web/channels/my_presence.ex&lt;/code&gt;, where &lt;code&gt;my_presence&lt;/code&gt; is the snake-cased version of the provided module name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02411617ad03187efe4d79ddc98c3934f98cab53" translate="yes" xml:space="preserve">
          <source>Generates a new repository.</source>
          <target state="translated">Генерирует новый репозиторий.</target>
        </trans-unit>
        <trans-unit id="ec4e73c7a7527a111588dbb3ab99814034f1ef6f" translate="yes" xml:space="preserve">
          <source>Generates a number input</source>
          <target state="translated">Генерирует числовой ввод</target>
        </trans-unit>
        <trans-unit id="11f48eeb86c1ee3d50fe2a5731642a36708b06b0" translate="yes" xml:space="preserve">
          <source>Generates a number input.</source>
          <target state="translated">Генерирует ввод числа.</target>
        </trans-unit>
        <trans-unit id="47709e3ef4238d15f86dbf2ee76f58d705224d78" translate="yes" xml:space="preserve">
          <source>Generates a password input</source>
          <target state="translated">Генерирует ввод пароля</target>
        </trans-unit>
        <trans-unit id="6d0d9edbf1971f56f1a0efb9364b266914f7db45" translate="yes" xml:space="preserve">
          <source>Generates a password input.</source>
          <target state="translated">Генерирует ввод пароля.</target>
        </trans-unit>
        <trans-unit id="3f4172380d2e87d78dec42dfbd35c80f932ab725" translate="yes" xml:space="preserve">
          <source>Generates a radio button</source>
          <target state="translated">Генерирует радиокнопку</target>
        </trans-unit>
        <trans-unit id="54d925054bfa8df9816df148a94806ed340b7d20" translate="yes" xml:space="preserve">
          <source>Generates a radio button.</source>
          <target state="translated">Генерирует радиокнопку.</target>
        </trans-unit>
        <trans-unit id="4211b9345387b675b9be0fc4617dcd0837432193" translate="yes" xml:space="preserve">
          <source>Generates a range input</source>
          <target state="translated">Генерирует диапазон входа</target>
        </trans-unit>
        <trans-unit id="f1d665b37d2ee2aaaf57abb73a773d37fb5632a4" translate="yes" xml:space="preserve">
          <source>Generates a range input.</source>
          <target state="translated">Генерирует диапазон входа.</target>
        </trans-unit>
        <trans-unit id="42b02a853b6591ae8dcaaf9e2b0f271bae8897d8" translate="yes" xml:space="preserve">
          <source>Generates a reset input to reset all the form fields to their original state</source>
          <target state="translated">Генерирует вход сброса для сброса всех полей формы в их первоначальное состояние</target>
        </trans-unit>
        <trans-unit id="5f9c5b5c3c6b4005d0ded69c44513c4c93741343" translate="yes" xml:space="preserve">
          <source>Generates a reset input to reset all the form fields to their original state.</source>
          <target state="translated">Генерирует вход сброса для сброса всех полей формы в их первоначальное состояние.</target>
        </trans-unit>
        <trans-unit id="c9376cf87944d2c7638464200c033426a186aa76" translate="yes" xml:space="preserve">
          <source>Generates a route match based on an arbitrary HTTP method</source>
          <target state="translated">Генерирует соответствие маршрута на основе произвольного HTTP-метода</target>
        </trans-unit>
        <trans-unit id="cc5394e9f36a89d2ae9bb46e099d38573bd6b481" translate="yes" xml:space="preserve">
          <source>Generates a route match based on an arbitrary HTTP method.</source>
          <target state="translated">Генерирует соответствие маршрута на основе произвольного HTTP-метода.</target>
        </trans-unit>
        <trans-unit id="897983719926fe4ff3d98b2bae0351ca40ad6096" translate="yes" xml:space="preserve">
          <source>Generates a route to a static file in &lt;code&gt;priv/static&lt;/code&gt;</source>
          <target state="translated">Создает маршрут к статическому файлу в &lt;code&gt;priv/static&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf0351ad82e221297ee7764e10c9555e6b0f6dea" translate="yes" xml:space="preserve">
          <source>Generates a route to a static file in &lt;code&gt;priv/static&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="894b7547e38d381fd5440a4e9164d424f886e4e7" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a connect request to the given path</source>
          <target state="translated">Генерирует маршрут для обработки запроса на подключение к данному пути.</target>
        </trans-unit>
        <trans-unit id="574b4ca741e3f439c47b28cd49adf25fd2f68c1b" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a connect request to the given path.</source>
          <target state="translated">Генерирует маршрут для обработки запроса на подключение к данному пути.</target>
        </trans-unit>
        <trans-unit id="378f585ff9da2c90adf66dd182b6c07d40c0b410" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a delete request to the given path</source>
          <target state="translated">Генерирует маршрут для обработки запроса на удаление по заданному пути.</target>
        </trans-unit>
        <trans-unit id="2e5a45bd26b667751489c9867bc4ac2e1ad5f415" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a delete request to the given path.</source>
          <target state="translated">Генерирует маршрут для обработки запроса на удаление к заданному пути.</target>
        </trans-unit>
        <trans-unit id="9b7eea3e2812a3a9f1485a0bf4b06ac9322cb592" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a get request to the given path</source>
          <target state="translated">Генерирует маршрут для обработки запроса на получение по заданному пути.</target>
        </trans-unit>
        <trans-unit id="57d3a2a07eedb652e1be011b09d407612fa940d1" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a get request to the given path.</source>
          <target state="translated">Генерирует маршрут для обработки запроса на получение по заданному пути.</target>
        </trans-unit>
        <trans-unit id="ad76b05490559045cdfdb8bde3bf7f1fbb5c58a4" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a head request to the given path</source>
          <target state="translated">Генерирует маршрут для обработки запроса головы к заданному пути.</target>
        </trans-unit>
        <trans-unit id="90093949144eba1a5fb435edb853256751817dc8" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a head request to the given path.</source>
          <target state="translated">Генерирует маршрут для обработки запроса головы к заданному пути.</target>
        </trans-unit>
        <trans-unit id="e24375171478c89552863fcfeadc3ce58f2e5bca" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a options request to the given path</source>
          <target state="translated">Генерирует маршрут для обработки запроса опций к заданному пути.</target>
        </trans-unit>
        <trans-unit id="77c88cce859e3f038ecdbff85d2d730cb2bf13d0" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a options request to the given path.</source>
          <target state="translated">Генерирует маршрут для обработки запроса опций к заданному пути.</target>
        </trans-unit>
        <trans-unit id="80ed50be25df94aebc7db8a8ad0804d3342708c1" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a patch request to the given path</source>
          <target state="translated">Генерирует маршрут для обработки запроса на исправление к заданному пути.</target>
        </trans-unit>
        <trans-unit id="cca725a12cd24948f36b9ede692ae61a76c694e0" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a patch request to the given path.</source>
          <target state="translated">Генерирует маршрут для обработки запроса на заплатку к заданному пути.</target>
        </trans-unit>
        <trans-unit id="1ac815ff5f9cdaae6a2df79818543d53e1f2f23f" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a post request to the given path</source>
          <target state="translated">Генерирует маршрут для обработки почтового запроса к заданному пути.</target>
        </trans-unit>
        <trans-unit id="6fd5d431492f5f17891de85401d2c1290f388443" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a post request to the given path.</source>
          <target state="translated">Генерирует маршрут для обработки почтового запроса к заданному пути.</target>
        </trans-unit>
        <trans-unit id="2a9d46c0f90d8dd7ffb2914e6f3104c626432be2" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a put request to the given path</source>
          <target state="translated">Генерирует маршрут для обработки запроса на размещение по заданному пути.</target>
        </trans-unit>
        <trans-unit id="f9ffc6392b8fbd3db7cb9e0d3dc9186949c8f8b7" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a put request to the given path.</source>
          <target state="translated">Генерирует маршрут для обработки запроса на размещение по заданному пути.</target>
        </trans-unit>
        <trans-unit id="e0b014c7fd0d0d1d83b5a70fa8d6fe074e0f3052" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a trace request to the given path</source>
          <target state="translated">Генерирует маршрут для обработки запроса на трассировку к заданному пути.</target>
        </trans-unit>
        <trans-unit id="221bae031a3004d5c2045808e65d68d8c217bcd4" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a trace request to the given path.</source>
          <target state="translated">Генерирует маршрут для обработки запроса на трассировку к заданному пути.</target>
        </trans-unit>
        <trans-unit id="a62a15cee984de5f9b1d155a86ae8b908ee45da6" translate="yes" xml:space="preserve">
          <source>Generates a search input</source>
          <target state="translated">Генерирует поисковый вход</target>
        </trans-unit>
        <trans-unit id="9a485964d5b7b8267fbecbe17ff5ca372d19bb8a" translate="yes" xml:space="preserve">
          <source>Generates a search input.</source>
          <target state="translated">Генерирует поисковый вход.</target>
        </trans-unit>
        <trans-unit id="e8a0342fc5c68fc8986011bb012bd0c39bcd4083" translate="yes" xml:space="preserve">
          <source>Generates a secret and prints it to the terminal.</source>
          <target state="translated">Генерирует секрет и печатает его на терминале.</target>
        </trans-unit>
        <trans-unit id="67e63e20fe6b5c241bb9891340bbc4e7f9f2e977" translate="yes" xml:space="preserve">
          <source>Generates a select tag with the given &lt;code&gt;options&lt;/code&gt;</source>
          <target state="translated">Создает тег выбора с заданными &lt;code&gt;options&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8387b222b8a18961d9656292381976a0bb723ec4" translate="yes" xml:space="preserve">
          <source>Generates a select tag with the given &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">Создает тег выбора с заданными &lt;code&gt;options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eb9a468a2e248674c486507b7bdb6b1eceae235" translate="yes" xml:space="preserve">
          <source>Generates a self-signed certificate for HTTPS testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0d06afeae9859b4f3fd6e9e412d3a718e92c81" translate="yes" xml:space="preserve">
          <source>Generates a status message from the template name</source>
          <target state="translated">Генерирует сообщение о состоянии из имени шаблона.</target>
        </trans-unit>
        <trans-unit id="7454d06c3dd95214098294a1b0310dac0b7a4878" translate="yes" xml:space="preserve">
          <source>Generates a status message from the template name.</source>
          <target state="translated">Генерирует сообщение о состоянии из имени шаблона.</target>
        </trans-unit>
        <trans-unit id="067fc3be22bab148f6c9165e5da91f0df3fa5da9" translate="yes" xml:space="preserve">
          <source>Generates a submit button to send the form</source>
          <target state="translated">Генерирует кнопку отправки для отправки формы</target>
        </trans-unit>
        <trans-unit id="312f705dccca8c086547117e4724c8592db5695d" translate="yes" xml:space="preserve">
          <source>Generates a submit button to send the form.</source>
          <target state="translated">Генерирует кнопку отправки для отправки формы.</target>
        </trans-unit>
        <trans-unit id="f4ea648663e608eaa4d4758ecd78961c842e565e" translate="yes" xml:space="preserve">
          <source>Generates a telephone input</source>
          <target state="translated">Генерирует телефонный вход</target>
        </trans-unit>
        <trans-unit id="912392aacff0f7188b964ec552a88e06572c1c85" translate="yes" xml:space="preserve">
          <source>Generates a telephone input.</source>
          <target state="translated">Генерирует телефонный вход.</target>
        </trans-unit>
        <trans-unit id="54aa2d4862224e6c0fb69837326cc7b97ce5c66a" translate="yes" xml:space="preserve">
          <source>Generates a text input</source>
          <target state="translated">Генерирует ввод текста</target>
        </trans-unit>
        <trans-unit id="73f0bd438fee7c9707ed766a9afb23c407583846" translate="yes" xml:space="preserve">
          <source>Generates a text input.</source>
          <target state="translated">Генерирует ввод текста.</target>
        </trans-unit>
        <trans-unit id="45397941ecf32426955313a201964be41c43f1da" translate="yes" xml:space="preserve">
          <source>Generates a textarea input</source>
          <target state="translated">Генерирует текстовый ввод</target>
        </trans-unit>
        <trans-unit id="126b50f201a72f4c020abacab8f934f9f30a6581" translate="yes" xml:space="preserve">
          <source>Generates a textarea input.</source>
          <target state="translated">Генерирует текстовый ввод.</target>
        </trans-unit>
        <trans-unit id="eceb224d2682e883c41b426e06844bbc0bb1dbfb" translate="yes" xml:space="preserve">
          <source>Generates a time input</source>
          <target state="translated">Генерирует временной вход</target>
        </trans-unit>
        <trans-unit id="6248af3237dc2fb4fd35ad1108d254199730ac1e" translate="yes" xml:space="preserve">
          <source>Generates a time input.</source>
          <target state="translated">Генерирует временной вход.</target>
        </trans-unit>
        <trans-unit id="0ae030fe064e790de454fd16af4f1f68f22484a3" translate="yes" xml:space="preserve">
          <source>Generates a token and stores it in the process dictionary if one does not exist.</source>
          <target state="translated">Генерирует токен и сохраняет его в рабочем словаре,если он не существует.</target>
        </trans-unit>
        <trans-unit id="e9144aebe51b655f2f4bb9bb809ff17899371d44" translate="yes" xml:space="preserve">
          <source>Generates a two item tuple containing the &lt;code&gt;static_path&lt;/code&gt; and &lt;code&gt;static_integrity&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07857e5bb53d01eb1dafeb1352fa46eae3a116c" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID</source>
          <target state="translated">Генерирует UUID версии 4 (случайный).</target>
        </trans-unit>
        <trans-unit id="21e2aa08f9efa85d22010347be63b109be8c5a02" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID in the binary format</source>
          <target state="translated">Генерирует UUID версии 4 (случайный)в двоичном формате</target>
        </trans-unit>
        <trans-unit id="a0e42f792fb874b4044bce2c20dbf1af12c49012" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID in the binary format.</source>
          <target state="translated">Генерирует UUID версии 4 (случайный)в двоичном формате.</target>
        </trans-unit>
        <trans-unit id="0f3d3d0bf68951efc2ef0156a57ac19451a2154c" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID.</source>
          <target state="translated">Генерирует UUID версии 4 (случайный).</target>
        </trans-unit>
        <trans-unit id="7f629d614bd57112e09d421f86237a37bc2fa9a5" translate="yes" xml:space="preserve">
          <source>Generates an Ecto model in your Phoenix application.</source>
          <target state="translated">Генерирует модель Ecto в приложении Phoenix.</target>
        </trans-unit>
        <trans-unit id="192881be6736fea74c466100ba43922580a0b06b" translate="yes" xml:space="preserve">
          <source>Generates an Ecto schema and migration.</source>
          <target state="translated">Генерирует схему Экто и миграцию.</target>
        </trans-unit>
        <trans-unit id="3c003e1e5dc81ee91cde965669c00912afc2b27c" translate="yes" xml:space="preserve">
          <source>Generates an email input</source>
          <target state="translated">Генерирует ввод электронной почты</target>
        </trans-unit>
        <trans-unit id="c7bd255992aaeef9602f0be4b666b7be9fe3a2ba" translate="yes" xml:space="preserve">
          <source>Generates an email input.</source>
          <target state="translated">Генерирует ввод электронной почты.</target>
        </trans-unit>
        <trans-unit id="6504cdfcb718565b5576fc2158cd57efe4825bb4" translate="yes" xml:space="preserve">
          <source>Generates an embedded Ecto schema for casting/validating data outside the DB.</source>
          <target state="translated">Генерирует встроенную схему Ecto для литья/проверки данных вне БД.</target>
        </trans-unit>
        <trans-unit id="2cad790430badca14ec8c02cc664082faed9f493" translate="yes" xml:space="preserve">
          <source>Generates an img tag with a src</source>
          <target state="translated">Генерирует img-тег с src.</target>
        </trans-unit>
        <trans-unit id="9b6859233f63365d7a32da180d650f35004ce39e" translate="yes" xml:space="preserve">
          <source>Generates an img tag with a src.</source>
          <target state="translated">Генерирует img tag с src.</target>
        </trans-unit>
        <trans-unit id="31a11500f500d76442b5a7660ff34e1c46e8aaa8" translate="yes" xml:space="preserve">
          <source>Generates an integrity hash to a static file in &lt;code&gt;priv/static&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94584e370048710080737b7da1191363a53d9074" translate="yes" xml:space="preserve">
          <source>Generates an url input</source>
          <target state="translated">Генерирует url-вход</target>
        </trans-unit>
        <trans-unit id="41f536102076cb368a63c9729925c85b108feb67" translate="yes" xml:space="preserve">
          <source>Generates an url input.</source>
          <target state="translated">Генерирует url-вход.</target>
        </trans-unit>
        <trans-unit id="3eaee8e36f647786a53b9f964255fe72cc821f1a" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for a JSON resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822515dec0a67435114ec101cc230428d2840774" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for an HTML resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be50e5d315403c8a6e5ed901af8b36c1c04a5c95" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for an JSON resource.</source>
          <target state="translated">Генерирует контроллер,представления и контекст для ресурса JSON.</target>
        </trans-unit>
        <trans-unit id="e78eb34839e1acd728f57541f822721b2b3ba7cc" translate="yes" xml:space="preserve">
          <source>Generates hidden inputs for the given form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b426df53681f88f2110c30af8bf84dbae2dbb1" translate="yes" xml:space="preserve">
          <source>Generates select tags for date</source>
          <target state="translated">Генерирует теги выбора для даты</target>
        </trans-unit>
        <trans-unit id="900feb5d8076251ce1c88b1c50c88ed36d4df204" translate="yes" xml:space="preserve">
          <source>Generates select tags for date.</source>
          <target state="translated">Генерирует теги выбора даты.</target>
        </trans-unit>
        <trans-unit id="33944458ee24e52c6f57b54406929743c95d1e0f" translate="yes" xml:space="preserve">
          <source>Generates select tags for datetime</source>
          <target state="translated">Генерирует теги выбора для даты</target>
        </trans-unit>
        <trans-unit id="b91c0777babdf510129bdd926e272571b56c507a" translate="yes" xml:space="preserve">
          <source>Generates select tags for datetime.</source>
          <target state="translated">Генерирует теги выбора даты.</target>
        </trans-unit>
        <trans-unit id="2989d503428e011977ec7d2d26ea57f0cd501ff1" translate="yes" xml:space="preserve">
          <source>Generates select tags for time</source>
          <target state="translated">Генерирует теги выбора для времени</target>
        </trans-unit>
        <trans-unit id="44c3290708cfe98a895d3932d31b3028cf656029" translate="yes" xml:space="preserve">
          <source>Generates select tags for time.</source>
          <target state="translated">Генерирует теги выбора для времени.</target>
        </trans-unit>
        <trans-unit id="06abc3fc049f6aeb29e4374ef7a511dc801188d0" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL without any path information</source>
          <target state="translated">Генерирует базовый URL-адрес конечной точки без информации о путях.</target>
        </trans-unit>
        <trans-unit id="0c54d53d2a725dae194fd5931fc6e94b42a7bafb" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL without any path information.</source>
          <target state="translated">Генерирует базовый URL-адрес конечной точки без информации о пути.</target>
        </trans-unit>
        <trans-unit id="566783b0db0c0900209be301c7fb5794061562a0" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL, but as a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct</source>
          <target state="translated">Создает базовый URL-адрес конечной точки, но как структуру &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a457480f3b7970598a96e97a308a2c57be1d9d62" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL, but as a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Создает базовый URL-адрес конечной точки, но как структуру &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a56e0e8f6c89e5bcd6f332dfe4a7f18f1d712206" translate="yes" xml:space="preserve">
          <source>Generates the path information when routing to this endpoint</source>
          <target state="translated">Генерирует информацию о пути при маршрутизации к данной конечной точке.</target>
        </trans-unit>
        <trans-unit id="9de6c6bdf8366eaa60f44b75556d6710e9111768" translate="yes" xml:space="preserve">
          <source>Generates the path information when routing to this endpoint.</source>
          <target state="translated">Генерирует информацию о пути при маршрутизации к этой конечной точке.</target>
        </trans-unit>
        <trans-unit id="92831dcf10942016c97191fd271c8140a6105d73" translate="yes" xml:space="preserve">
          <source>Generates the static URL without any path information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d336eb35990be39ada49eb89ccf7bc531bbf8d59" translate="yes" xml:space="preserve">
          <source>Generating typespecs for schemas is out of the scope of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7afc8fed6ae07096bcda43b2c180de120f70394" translate="yes" xml:space="preserve">
          <source>Generating without a schema</source>
          <target state="translated">Генерация без схемы</target>
        </trans-unit>
        <trans-unit id="3b22374ca8da32cfe346b6ca99bea860d67b2484" translate="yes" xml:space="preserve">
          <source>Generating without a schema or context file</source>
          <target state="translated">Генерация без схемы или контекстного файла</target>
        </trans-unit>
        <trans-unit id="24e7830f821b426f5a51f69a462e899b6faff3ad" translate="yes" xml:space="preserve">
          <source>Gets a change or returns a default value</source>
          <target state="translated">Получает изменение или возвращает значение по умолчанию</target>
        </trans-unit>
        <trans-unit id="20c69fc2d13ee5ae1e5c766de8168c5e86eac703" translate="yes" xml:space="preserve">
          <source>Gets a change or returns a default value.</source>
          <target state="translated">Получает изменение или возвращает значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ae896285359a3676cf6a8e84fe64f02a1009d1d3" translate="yes" xml:space="preserve">
          <source>Gets a field from changes or from the data</source>
          <target state="translated">Получает поле из изменений или из данных.</target>
        </trans-unit>
        <trans-unit id="bd5eebfdc41b8efa306222262683e1e2cb53f629" translate="yes" xml:space="preserve">
          <source>Gets a field from changes or from the data.</source>
          <target state="translated">Получает поле из изменений или из данных.</target>
        </trans-unit>
        <trans-unit id="f0ad8554cfab9a4c20a7b61ea4176e67168e383d" translate="yes" xml:space="preserve">
          <source>Gets a path relative to the application path</source>
          <target state="translated">Получает путь относительно пути приложения</target>
        </trans-unit>
        <trans-unit id="54e09b22dc0bfd8c0d4977361cbe415e92fbad7a" translate="yes" xml:space="preserve">
          <source>Gets a path relative to the application path.</source>
          <target state="translated">Получает путь относительно пути приложения.</target>
        </trans-unit>
        <trans-unit id="988d679daebf10d001e25c095b5b9e286e6bc11c" translate="yes" xml:space="preserve">
          <source>Gets how the type is treated inside embeds for the given format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3ff2dbf500da7f3bca6907ee8045b12c112c08" translate="yes" xml:space="preserve">
          <source>Gets or generates a CSRF token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="997af9359b0274152d5976f8e8ca9230b5813c54" translate="yes" xml:space="preserve">
          <source>Gets presences tracked under a given topic and key pair</source>
          <target state="translated">Получает присутствие,отслеживаемое под заданной темой и ключевой парой</target>
        </trans-unit>
        <trans-unit id="48f0745d124d4e83473eebb47a6d31ab2415d144" translate="yes" xml:space="preserve">
          <source>Gets presences tracked under a given topic and key pair.</source>
          <target state="translated">Получает присутствие,отслеживаемое под заданной темой и ключевой парой.</target>
        </trans-unit>
        <trans-unit id="97e4290574c5ed51caafb10b2de1e172c163410b" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token</source>
          <target state="translated">Получает маркер CSRF</target>
        </trans-unit>
        <trans-unit id="08349fa609238bb75520280fb127235024b0eb68" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token for the associated URL (as a string or a URI struct)</source>
          <target state="translated">Получает CSRF-токен для связанного с ним URL (в виде строки или структуры URI).</target>
        </trans-unit>
        <trans-unit id="ff08f49db7e1265b7a0948738482fffe83f058a7" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token for the associated URL (as a string or a URI struct).</source>
          <target state="translated">Получает CSRF-токен для ассоциированного URL (в виде строки или структуры URI).</target>
        </trans-unit>
        <trans-unit id="8d4fe3f1095bcbf480568f707f0f32660bfed495" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token.</source>
          <target state="translated">Получает жетон CSRF.</target>
        </trans-unit>
        <trans-unit id="cacf574b487bbebb0a08dffbbbde22c3caa9dd7c" translate="yes" xml:space="preserve">
          <source>Gets the given key from the flash storage</source>
          <target state="translated">Получает данный ключ с флэш-накопителя</target>
        </trans-unit>
        <trans-unit id="39a3c0f8225971cc340f65e20abcd3cfd296785c" translate="yes" xml:space="preserve">
          <source>Gets the given key from the flash storage.</source>
          <target state="translated">Получает данный ключ с флэш-накопителя.</target>
        </trans-unit>
        <trans-unit id="96a62524d2bf17765eab415eae3c27d04f1cdf6a" translate="yes" xml:space="preserve">
          <source>Gets the input type for a given field</source>
          <target state="translated">Получает тип ввода для данного поля</target>
        </trans-unit>
        <trans-unit id="66f52ba2db0eb578cab960fd32bdb155e164ce6a" translate="yes" xml:space="preserve">
          <source>Gets the input type for a given field.</source>
          <target state="translated">Получает тип ввода для данного поля.</target>
        </trans-unit>
        <trans-unit id="b27071d61374355defa4f7ba87856a1483070f41" translate="yes" xml:space="preserve">
          <source>Gets the metadata from the given struct</source>
          <target state="translated">Получает метаданные из заданной структуры</target>
        </trans-unit>
        <trans-unit id="678baa7f889b181e04ecd1461201171108459f0b" translate="yes" xml:space="preserve">
          <source>Gets the metadata from the given struct.</source>
          <target state="translated">Получает метаданные из заданной структуры.</target>
        </trans-unit>
        <trans-unit id="3304a8905eb384bf8c92d54b81cce4e1c7c19f8b" translate="yes" xml:space="preserve">
          <source>Gets the nested LiveView child by &lt;code&gt;child_id&lt;/code&gt; from the &lt;code&gt;parent&lt;/code&gt; LiveView.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa65e24dc6d0d5c51eaeaf4bdd4b579ff2fe71c" translate="yes" xml:space="preserve">
          <source>Gets the store name from an atom or a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1baad63621d111aecd80381a2421d2b880bc0a22" translate="yes" xml:space="preserve">
          <source>Gets the whole flash storage</source>
          <target state="translated">Получает всю флэш-память</target>
        </trans-unit>
        <trans-unit id="64814fa71bd4c722ebaa70f584d80370c84fe56a" translate="yes" xml:space="preserve">
          <source>Gets the whole flash storage.</source>
          <target state="translated">Получает всю флэш-память.</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3f22a652c385048db92eec4f86769df4e6a06f" translate="yes" xml:space="preserve">
          <source>Getting Started with Phoenix (by Pluralsight - 2017)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c058929c7d291e4d62d960baf0a6197123595989" translate="yes" xml:space="preserve">
          <source>Give the Erlang/OTP runtime (that is, the BEAM VM executable) permission to bind to privileged ports using 'setcap', e.g. &lt;code&gt;sudo setcap 'cap_net_bind_service=+ep' /usr/lib/erlang/erts-10.1/bin/beam.smp&lt;/code&gt;; update the path as necessary, and remember to run the command again after Erlang upgrades</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8730e43ab24e7c728fed006e4af4c853f6327c" translate="yes" xml:space="preserve">
          <source>Given almost all &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; actions in your application will have to perform these exact steps, we recommend creating a function called &lt;code&gt;assign_defaults/2&lt;/code&gt; or similar, putting it in a new module like &lt;code&gt;MyAppWeb.LiveHelpers&lt;/code&gt;, and modifying &lt;code&gt;lib/my_app_web.ex&lt;/code&gt; so all LiveViews automatically import it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4181efd0f5aa1fb39a060e1a478e56b7d07cbd" translate="yes" xml:space="preserve">
          <source>Given components compartmentalize markup on the server, they are also rendered in isolation on the client, which provides great performance benefits on the client too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b0c7375e98f73f52e1b737eb418a247d1da8fd" translate="yes" xml:space="preserve">
          <source>Given that a LiveView runs on its own process, it is an excellent tool for creating completely isolated UI elements, but it is a slightly expensive abstraction if all you want is to compartmentalize markup and events. For example, if you are showing a table with all users in the system, and you want to compartmentalize this logic, rendering a separate &lt;code&gt;LiveView&lt;/code&gt; for each user, then using a process per user would likely be too expensive. For these cases, LiveView provides &lt;a href=&quot;phoenix.livecomponent&quot;&gt;&lt;code&gt;Phoenix.LiveComponent&lt;/code&gt;&lt;/a&gt;, which are rendered using &lt;code&gt;live_component/3&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50f484d78e3b110b11618fae5e4f8de3a3ef714" translate="yes" xml:space="preserve">
          <source>Given the button does not appear in the UI, triggering the &quot;leave&quot; when the organization has now only one member is an unexpected scenario. This means we can probably rewrite the code above to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaafd2714d8805ff67c29755c6b072c4bffa71a8" translate="yes" xml:space="preserve">
          <source>Given the code on mount runs both on the initial disconnected render and the connected render, an exception on mount will trigger the following events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f418c387ce0535243c1ffc04f850d20578d8ccef" translate="yes" xml:space="preserve">
          <source>Globs can match segments partially too. The difference is the whole segment is captured along with the trailing segments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a88c991df04bd6fcf2fb3f005a3c9207b89cc95" translate="yes" xml:space="preserve">
          <source>Go to &quot;&lt;a href=&quot;http://localhost:4000/%22&quot;&gt;http://localhost:4000/&quot;&lt;/a&gt; and you should see the locale exhibited. Visit &quot;&lt;a href=&quot;http://localhost:4000/?locale=fr%22&quot;&gt;http://localhost:4000/?locale=fr&quot;&lt;/a&gt; and you should see the assign changed to &quot;fr&quot;. Someone can use this information alongside &lt;a href=&quot;https://hexdocs.pm/gettext/Gettext.html&quot;&gt;Gettext&lt;/a&gt; to provide a fully internationalized web application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085bd772dd72f1ee66df662034a18b6fef587590" translate="yes" xml:space="preserve">
          <source>Good work!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f179b6f36465b5aac2f67605586252775def9c70" translate="yes" xml:space="preserve">
          <source>Good:</source>
          <target state="translated">Good:</target>
        </trans-unit>
        <trans-unit id="eef0115acb31caa0fbd5afc01384c4545e7d44b5" translate="yes" xml:space="preserve">
          <source>Gracefully shuts down by broadcasting permdown to all replicas</source>
          <target state="translated">Грациозно останавливается трансляцией на все реплики.</target>
        </trans-unit>
        <trans-unit id="37401107a71883efc56c3d07974d72873ad8f857" translate="yes" xml:space="preserve">
          <source>Gracefully shuts down by broadcasting permdown to all replicas.</source>
          <target state="translated">Грациозно завершает трансляцию на все реплики.</target>
        </trans-unit>
        <trans-unit id="96c55d61787ebd67d87c36f604142bfa3949dd6e" translate="yes" xml:space="preserve">
          <source>Great, so we have this &lt;code&gt;template_not_found/2&lt;/code&gt; function that takes a template and an &lt;code&gt;assigns&lt;/code&gt; map, which we ignore. The &lt;code&gt;template_not_found/2&lt;/code&gt; is invoked whenever a Phoenix.View attempts to render a template but no template is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2bb758deee9a18063c4c798fcdec3e64196126" translate="yes" xml:space="preserve">
          <source>Groups are also supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16fde456fa6a9274b8f28cf87784f0670263c64" translate="yes" xml:space="preserve">
          <source>Groups together rows from the schema that have the same values in the given fields. Using &lt;code&gt;group_by&lt;/code&gt; &quot;groups&quot; the query giving it different semantics in the &lt;code&gt;select&lt;/code&gt; expression. If a query is grouped, only fields that were referenced in the &lt;code&gt;group_by&lt;/code&gt; can be used in the &lt;code&gt;select&lt;/code&gt; or if the field is given as an argument to an aggregate function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="573359f98da0f46d93ce375944dfc230b3eb131f" translate="yes" xml:space="preserve">
          <source>Groups together rows from the schema that have the same values in the given fields. Using &lt;code&gt;group_by&lt;/code&gt; &amp;ldquo;groups&amp;rdquo; the query giving it different semantics in the &lt;code&gt;select&lt;/code&gt; expression. If a query is grouped, only fields that were referenced in the &lt;code&gt;group_by&lt;/code&gt; can be used in the &lt;code&gt;select&lt;/code&gt; or if the field is given as an argument to an aggregate function.</source>
          <target state="translated">Группирует строки из схемы, которые имеют одинаковые значения в заданных полях. Использование &lt;code&gt;group_by&lt;/code&gt; &amp;laquo;группирует&amp;raquo; запрос, придавая ему различную семантику в выражении &lt;code&gt;select&lt;/code&gt; . Если запрос сгруппирован, только поля, на которые есть ссылка в &lt;code&gt;group_by&lt;/code&gt; , могут использоваться в &lt;code&gt;select&lt;/code&gt; или если поле указано в качестве аргумента агрегатной функции.</target>
        </trans-unit>
        <trans-unit id="0d28e5466fe7edf9be0a19b777c6efbf4fc0f1b9" translate="yes" xml:space="preserve">
          <source>Groxio LiveView: Self Study Program (by Bruce Tate - 2020)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de813d4a22ea43705b2409ca317c4ad7be16554" translate="yes" xml:space="preserve">
          <source>Guaranteed to be safe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="d7240b32bd4fb13ad180c29bf544480d25f32149" translate="yes" xml:space="preserve">
          <source>Guides - in-depth guides covering the main components in Phoenix and Phoenix applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ec996853ae990b117722b3dedca88ce5b8b0cb" translate="yes" xml:space="preserve">
          <source>HTML Safe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b092172a89d9cb7710c23a35bcf58905e6ddfd" translate="yes" xml:space="preserve">
          <source>HTTP Strict Transport Security (HSTS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41e81014d243f2d8875ff68c15a184a372a6901" translate="yes" xml:space="preserve">
          <source>HTTP/2 does not support chunking and will instead stream the response without a transfer encoding. When using HTTP/1.1, the Cowboy adapter will stream the response instead of emitting chunks if the &lt;code&gt;content-length&lt;/code&gt; header has been set before calling &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2 не поддерживает разбиение на части и вместо этого будет передавать ответ без кодировки передачи. При использовании HTTP / 1.1 адаптер Cowboy будет передавать ответ в потоковом режиме вместо того, чтобы выдавать фрагменты, если заголовок &lt;code&gt;content-length&lt;/code&gt; был установлен до вызова &lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f52698c28f0d2036450e02a85451ee4f5be02442" translate="yes" xml:space="preserve">
          <source>HTTPS</source>
          <target state="translated">HTTPS</target>
        </trans-unit>
        <trans-unit id="657152afda0bee08d931b261408d17d0b6e96e52" translate="yes" xml:space="preserve">
          <source>Halting a plug pipeline</source>
          <target state="translated">Отключение заглушки трубопровода</target>
        </trans-unit>
        <trans-unit id="1da643070952e956d86d49f8c58821c92fb71c6e" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a Plug pipeline</source>
          <target state="translated">Останавливает конвейер Plug, предотвращая запуск последующих подключений. См. Документацию для &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о остановке конвейера Plug</target>
        </trans-unit>
        <trans-unit id="d9755cdf0347f99433eabcbc87b332485d5af95e" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a Plug pipeline.</source>
          <target state="translated">Останавливает конвейер Plug, предотвращая запуск последующих подключений. См. Документацию для &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о остановке конвейера Plug.</target>
        </trans-unit>
        <trans-unit id="1ccd69770e67bfc169e02509f802dfa9b974fafd" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a plug pipeline</source>
          <target state="translated">Останавливает конвейер Plug, предотвращая запуск последующих подключений. См. Документацию для &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации об остановке конвейера подключения.</target>
        </trans-unit>
        <trans-unit id="eb6de5553592ef40a29a33d8a4f534ccdca762c0" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a plug pipeline.</source>
          <target state="translated">Останавливает конвейер Plug, предотвращая запуск последующих подключений. См. Документацию для &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации об остановке конвейера подключения.</target>
        </trans-unit>
        <trans-unit id="1179f95ead9bf0b9717da1e2ecfd57e128a47608" translate="yes" xml:space="preserve">
          <source>Handle channel joins by &lt;code&gt;topic&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c751925f47985ead2c5d331b34495a279ea3f7ba" translate="yes" xml:space="preserve">
          <source>Handle incoming &lt;code&gt;event&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f1e20c501a3974e2888a65dd307415f027f8bd" translate="yes" xml:space="preserve">
          <source>Handle regular Elixir process messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e4b67d91a6a5a47ead00c473556ef12172e644" translate="yes" xml:space="preserve">
          <source>Handle regular GenServer call messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdffc90c861d354d82cfba6f42150171080724c" translate="yes" xml:space="preserve">
          <source>Handle regular GenServer cast messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f294e1b14ab763746b32a9cdc98d993760a810d1" translate="yes" xml:space="preserve">
          <source>Handles incoming control frames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d31dbed02487ad3b79dcccdca1c4517c3e304c7" translate="yes" xml:space="preserve">
          <source>Handles incoming socket messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad1d4d7277dfbcb95f451d9d6d7bfc9124cb930" translate="yes" xml:space="preserve">
          <source>Handles info messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af19f504ed390f3616fe54d71be3c982a36fb0f" translate="yes" xml:space="preserve">
          <source>Handles the socket connection</source>
          <target state="translated">Ручка гнездового соединения</target>
        </trans-unit>
        <trans-unit id="5b3b8d6bf0e0ed4f6147a59b927ffe862e49bdc4" translate="yes" xml:space="preserve">
          <source>Handles the socket connection.</source>
          <target state="translated">Ручка для розеточного соединения.</target>
        </trans-unit>
        <trans-unit id="58514a1474cd3c04b6d7d45448e942f451571bf2" translate="yes" xml:space="preserve">
          <source>Handling of incoming messages</source>
          <target state="translated">Обработка входящих сообщений</target>
        </trans-unit>
        <trans-unit id="2b9f4508a5e4fc2c2b5ef7294940c248c8c75fd4" translate="yes" xml:space="preserve">
          <source>Handling of outgoing messages</source>
          <target state="translated">Обработка исходящих сообщений</target>
        </trans-unit>
        <trans-unit id="5827156e9f14bdd8a3697b80209b3e3c181665d5" translate="yes" xml:space="preserve">
          <source>Handling of user interaction and inputs, buttons, and forms - such as input validation, dynamic forms, autocomplete, etc;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791b3d718f251049300fc903f9b075211bce25f5" translate="yes" xml:space="preserve">
          <source>Handling request data can be done through the &lt;a href=&quot;../plug.parsers#content&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug. It provides support for parsing URL-encoded, form-data, and JSON data as well as providing a behaviour that others parsers can adopt.</source>
          <target state="translated">Обработка данных запроса может осуществляться через плагин &lt;a href=&quot;../plug.parsers#content&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; . Он обеспечивает поддержку синтаксического анализа данных в кодировке URL, данных формы и JSON, а также обеспечивает поведение, которое могут принять другие синтаксические анализаторы.</target>
        </trans-unit>
        <trans-unit id="b5824e50c0788d6515b063060ac394cb11876c16" translate="yes" xml:space="preserve">
          <source>Handling request data can be done through the &lt;a href=&quot;plug.parsers#content&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug. It provides support for parsing URL-encoded, form-data, and JSON data as well as providing a behaviour that others parsers can adopt.</source>
          <target state="translated">Обработка данных запроса может осуществляться через плагин &lt;a href=&quot;plug.parsers#content&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; . Он обеспечивает поддержку синтаксического анализа данных в кодировке URL, данных формы и JSON, а также обеспечивает поведение, которое могут принять другие синтаксические анализаторы.</target>
        </trans-unit>
        <trans-unit id="c698c3591147b68316110c515f5214cf7d5b3183" translate="yes" xml:space="preserve">
          <source>Having different precisions allows developers to choose a type that will be compatible with the database and your project's precision requirements. For example, some older versions of MySQL do not support microseconds in datetime fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87609125a9917f1d1304583fa33c13ec60b69a2f" translate="yes" xml:space="preserve">
          <source>Having these different types allows developers to choose a type that will be compatible with the database and your project&amp;rsquo;s precision requirements. For example, some older versions of MySQL do not support microseconds in datetime fields.</source>
          <target state="translated">Наличие этих различных типов позволяет разработчикам выбирать тип, который будет совместим с базой данных и требованиями к точности вашего проекта. Например, некоторые старые версии MySQL не поддерживают микросекунды в полях даты и времени.</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="2a35b8be1233091ad5332bbf56f5dc2f7b98ac70" translate="yes" xml:space="preserve">
          <source>Helpers are automatically generated based on the controller name. For example, the route:</source>
          <target state="translated">Помощники генерируются автоматически на основе имени контроллера.Например,маршрут:</target>
        </trans-unit>
        <trans-unit id="ea3deafd82332a10202987c8c0e45b4f54638c37" translate="yes" xml:space="preserve">
          <source>Helpers for working with HTML strings and templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e29e501e0e0abe2c6edb0ec3f800ed7c669e6a" translate="yes" xml:space="preserve">
          <source>Helpers related to formatting text.</source>
          <target state="translated">Помощники,связанные с форматированием текста.</target>
        </trans-unit>
        <trans-unit id="0d4c3aa7d2de3e04c2fa70e9a23a0cc750641d4a" translate="yes" xml:space="preserve">
          <source>Helpers related to producing HTML forms.</source>
          <target state="translated">Помощь в создании HTML форм.</target>
        </trans-unit>
        <trans-unit id="8d3f6ca83c967080b0bd89bc34ea0c0450fad6f1" translate="yes" xml:space="preserve">
          <source>Helpers related to producing HTML tags within templates.</source>
          <target state="translated">Помощь в создании HTML-тегов в шаблонах.</target>
        </trans-unit>
        <trans-unit id="1ae61dee0e45488052c0b40f12b8925406d54456" translate="yes" xml:space="preserve">
          <source>Here is a quick introduction into Phoenix templates terms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1764c5d537b9f3a319ae1d976d0b1ca9635f544" translate="yes" xml:space="preserve">
          <source>Here is a simple echo socket implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0608a11c75facb6614fa80af338062303f83e9" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; can be used in a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; router to parse the JSON-encoded body of a POST request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cdd2430bc9221c06b037fdb8209b829394de4f3" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; can be used in a &lt;a href=&quot;plug.router#content&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; router to parse the JSON-encoded body of a POST request:</source>
          <target state="translated">Вот пример &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; ,&lt;/a&gt; которые можно использовать в маршрутизаторе &lt;a href=&quot;plug.router#content&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; &lt;/a&gt; для анализа тела запроса POST в кодировке JSON:</target>
        </trans-unit>
        <trans-unit id="4bb01d7dff1af36b16e25ff091cce99986ce848e" translate="yes" xml:space="preserve">
          <source>Here is an example of a Telemetry event executed by Ecto when an Ecto repository starts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d2656a4085eae8f685d5ef408efb43bf4ea75b" translate="yes" xml:space="preserve">
          <source>Here is an example of a simple GenServer that emits telemetry events. Create this file in your app at &lt;code&gt;lib/my_app/my_server.ex&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f637f171cd30b36c18ce6cc1ef0b78a381b7d5b" translate="yes" xml:space="preserve">
          <source>Here is an example of an event from your endpoint:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8a0f224b439f3a7c58360fbb55ef423905c7d4" translate="yes" xml:space="preserve">
          <source>Here is an example of how both modules could be used in an application:</source>
          <target state="translated">Приведем пример того,как оба модуля могут быть использованы в приложении:</target>
        </trans-unit>
        <trans-unit id="514a051b8ea91a8358dacf4b2fa3b9efa3ab46e1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a function plug:</source>
          <target state="translated">Вот пример функционального плагина:</target>
        </trans-unit>
        <trans-unit id="afa6cca227f184cb839f4bb2a488e237e45cbd46" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a module plug:</source>
          <target state="translated">Вот пример модуля plug:</target>
        </trans-unit>
        <trans-unit id="294bc9dc3de330e00af0c679783e2c3ab4b482ed" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of receiving an incoming &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; event from one client, and broadcasting the message to all topic subscribers for this socket.</source>
          <target state="translated">Вот пример получения входящего события &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; от одного клиента и широковещательной рассылки сообщения всем подписчикам темы для этого сокета.</target>
        </trans-unit>
        <trans-unit id="2010f6be3cd1e0728d571d7959a93b42f107f411" translate="yes" xml:space="preserve">
          <source>Here's an example of receiving an incoming &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; event from one client, and broadcasting the message to all topic subscribers for this socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc198632123680a802368b24b34a90c40b9cc3b8" translate="yes" xml:space="preserve">
          <source>Here's another example with two scopes that have different pipelines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="293f9c83de18b696d985a3e2757964adfcf31355" translate="yes" xml:space="preserve">
          <source>Here's another look at the router from a newly generated Phoenix application, this time with the api scope uncommented back in and a route added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a396acbc7494836afa8330130078d54d9f2ca540" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;User&lt;/code&gt; schema that Phoenix generated for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e18ca3472a7c2b730d0f1353c2a5e4284080d21" translate="yes" xml:space="preserve">
          <source>Here's the command to install Hex (If you have Hex already installed, it will upgrade Hex to the latest version):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292aca9f06e84483c4664a721bd0d8e611812da1" translate="yes" xml:space="preserve">
          <source>Here's what &lt;a href=&quot;mix.tasks.phx.routes&quot;&gt;&lt;code&gt;mix phx.routes&lt;/code&gt;&lt;/a&gt; tells us:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="433ad4cccaa6f7157e6164318c9efb4b55c0cd17" translate="yes" xml:space="preserve">
          <source>Here's what it looks like in action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b2af54aadfd78a646e888ac25a3cea0e36a97c" translate="yes" xml:space="preserve">
          <source>Here's what the &lt;code&gt;schema_migrations&lt;/code&gt; table looks like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172de218d867931358663fe72b49811c80d28ce7" translate="yes" xml:space="preserve">
          <source>Here, a request to &lt;code&gt;/foo/BAZ/qux&lt;/code&gt; will be forwarded to the &lt;code&gt;FooPlug&lt;/code&gt; plug, which will receive what it will see as a request to &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;conn.params[&quot;bar&quot;]&lt;/code&gt; will be set to &lt;code&gt;&quot;BAZ&quot;&lt;/code&gt;.</source>
          <target state="translated">Здесь запрос к &lt;code&gt;/foo/BAZ/qux&lt;/code&gt; будет перенаправлен на плагин &lt;code&gt;FooPlug&lt;/code&gt; , который получит то, что он будет рассматривать как запрос к &lt;code&gt;/&lt;/code&gt; , а &lt;code&gt;conn.params[&quot;bar&quot;]&lt;/code&gt; будет установлен на &lt;code&gt;&quot;BAZ&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47a188e1572f453ec9eb4d25af8bec31919581b6" translate="yes" xml:space="preserve">
          <source>Here, we have our &lt;code&gt;show/2&lt;/code&gt; and &lt;code&gt;index/2&lt;/code&gt; actions returning static page data. Instead of passing in &lt;code&gt;&quot;show.html&quot;&lt;/code&gt; to &lt;code&gt;render/3&lt;/code&gt; as the template name, we pass &lt;code&gt;&quot;show.json&quot;&lt;/code&gt;. This way, we can have views that are responsible for rendering HTML as well as JSON by pattern matching on different file types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c8c2a15da73762b448647b48304e5984318bb6" translate="yes" xml:space="preserve">
          <source>Here, we start by using the familiar &lt;a href=&quot;../phoenix/phoenix.conntest&quot;&gt;&lt;code&gt;Phoenix.ConnTest&lt;/code&gt;&lt;/a&gt; function, &lt;code&gt;get/2&lt;/code&gt; to test the regular HTTP GET request which invokes mount with a disconnected socket. Next, &lt;a href=&quot;#live/1&quot;&gt;&lt;code&gt;live/1&lt;/code&gt;&lt;/a&gt; is called with our sent connection to mount the view in a connected state, which starts our stateful LiveView process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78f354796364ef7c67c1020994e22a118885793" translate="yes" xml:space="preserve">
          <source>Hibernation</source>
          <target state="translated">Hibernation</target>
        </trans-unit>
        <trans-unit id="5b3268c27e7d59601c440ed37c24688618bcf6ca" translate="yes" xml:space="preserve">
          <source>Hidden fields</source>
          <target state="translated">Скрытые поля</target>
        </trans-unit>
        <trans-unit id="5d18d2a7d4a536a77cc5f61568a124ea48c4b54e" translate="yes" xml:space="preserve">
          <source>Higher level usage of Basic HTTP auth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef8e89aeb708a408921fec1b9e87c4d04faaced" translate="yes" xml:space="preserve">
          <source>Hints</source>
          <target state="translated">Hints</target>
        </trans-unit>
        <trans-unit id="82b440b8be7666b0f091da72ba57b990af92adad" translate="yes" xml:space="preserve">
          <source>Hitting &lt;code&gt;/hello/Frank&lt;/code&gt; now renders the HTML string we defined in the &lt;code&gt;show&lt;/code&gt; action. Note that what we wrote in the action is not an &lt;code&gt;eex&lt;/code&gt; template. It's a multi-line string, so we interpolate the &lt;code&gt;messenger&lt;/code&gt; variable like this &lt;code&gt;#{Plug.HTML.html_escape(messenger)}&lt;/code&gt;, instead of this &lt;code&gt;&amp;lt;%= messenger %&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c930f4814c253272b3742e31b9b46cf3f29406" translate="yes" xml:space="preserve">
          <source>Hopefully, this gives you some inspiration on how to use the &lt;code&gt;:tag_values&lt;/code&gt; option. Just remember to keep this function fast since it is called on every event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da670a6c868ee6474dd213010439fdc6c17c884" translate="yes" xml:space="preserve">
          <source>How to read this guide: Using the context generators is a great way for beginners and intermediate Elixir programmers alike to get up and running quickly while thoughtfully designing their applications. This guide focuses on those readers. On the other hand, experienced developers may get more mileage from nuanced discussions around application design. For those readers, we include a frequently asked questions (FAQ) section at the end of the guide which brings different perspectives to some design decisions made throughout the guide. Beginners can safely skip the FAQ sections and return later when they're ready to dig deeper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bd403a4e9a302e8f2ed9f94925a54db8a68b9f" translate="yes" xml:space="preserve">
          <source>How your migration should be structured depends on the value you pass in &lt;code&gt;:join_through&lt;/code&gt;. If &lt;code&gt;:join_through&lt;/code&gt; is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won&amp;rsquo;t be set by Ecto:</source>
          <target state="translated">Как должна быть структурирована ваша миграция, зависит от передаваемого вами значения &lt;code&gt;:join_through&lt;/code&gt; . Если &lt;code&gt;:join_through&lt;/code&gt; - это просто строка, представляющая таблицу, вы можете определить таблицу без первичных ключей, и вы не должны включать какие-либо дополнительные столбцы, поскольку эти значения не будут установлены Ecto:</target>
        </trans-unit>
        <trans-unit id="e772dd16864f540c21adae4eff7d05aac5466700" translate="yes" xml:space="preserve">
          <source>How your migration should be structured depends on the value you pass in &lt;code&gt;:join_through&lt;/code&gt;. If &lt;code&gt;:join_through&lt;/code&gt; is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won't be set by Ecto:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="758c04f8f966638d8323796933d71c2022e6d322" translate="yes" xml:space="preserve">
          <source>How-to's - a collection of articles on how to achieve certain things with Phoenix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde9c228238451fde38808e6b71a5f4e8db27470" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; also supports direct cache control by using versioned query strings. If the request query string starts with &quot;?vsn=&quot;, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; assumes the application is versioning assets and does not set the &lt;code&gt;ETag&lt;/code&gt; header, meaning the cache behaviour will be specified solely by the &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; config, which defaults to &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca34d2ca00362f79bd18266ad0ec21713be1edf" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; also supports direct cache control by using versioned query strings. If the request query string starts with &amp;ldquo;?vsn=&amp;rdquo;, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; assumes the application is versioning assets and does not set the &lt;code&gt;ETag&lt;/code&gt; header, meaning the cache behaviour will be specified solely by the &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; config, which defaults to &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt;.</source>
          <target state="translated">Однако &lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; также поддерживает прямое управление кешем с помощью строк запросов с контролем версий. Если строка запроса начинается с &amp;laquo;? Vsn =&amp;raquo;, &lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; предполагает, что приложение управляет активами и не устанавливает заголовок &lt;code&gt;ETag&lt;/code&gt; , то есть поведение кеша будет определяться исключительно конфигурацией &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; , которая по умолчанию имеет значение &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c783df751e11e9f0f2d6bc647f8e24682a2b66" translate="yes" xml:space="preserve">
          <source>However, any component can be made stateful by passing an &lt;code&gt;:id&lt;/code&gt; assign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b6ba6983e86cfb8b7f8a1c8aa387837993e78b" translate="yes" xml:space="preserve">
          <source>However, because constraints are only checked if all validations succeed, this function can be used as an early check to provide early feedback to users, since most conflicting data will have been inserted prior to the current validation phase.</source>
          <target state="translated">Однако,поскольку ограничения проверяются только в том случае,если все валидации прошли успешно,эту функцию можно использовать как раннюю проверку для обеспечения ранней обратной связи с пользователями,так как большинство конфликтующих данных будет вставлено до начала текущей фазы валидации.</target>
        </trans-unit>
        <trans-unit id="c576a7810279fa0ef0181e729be5d3e33896301c" translate="yes" xml:space="preserve">
          <source>However, because the rendering of live templates can be dynamic in itself, it is important to distinguish which &lt;code&gt;.leex&lt;/code&gt; template was rendered. For example, imagine this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b56ea8eef111a454a3af358d1c8df493c3834e" translate="yes" xml:space="preserve">
          <source>However, changesets can also be used with &quot;regular&quot; structs too by passing a tuple with the data and its types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d4b9ddb4851e5cb9caec7c806e9ed043982b19" translate="yes" xml:space="preserve">
          <source>However, changesets can also be used with &amp;ldquo;regular&amp;rdquo; structs too by passing a tuple with the data and its types:</source>
          <target state="translated">Однако наборы изменений также можно использовать с &amp;laquo;обычными&amp;raquo; структурами, передав кортеж с данными и их типами:</target>
        </trans-unit>
        <trans-unit id="9c75a911a92357bb55a72a4f5cda6890aa2fa06e" translate="yes" xml:space="preserve">
          <source>However, developers can use the preload functionality in queries to automatically pre-populate the field:</source>
          <target state="translated">Тем не менее,разработчики могут использовать функцию предварительной загрузки в запросах для автоматического предварительного заселения поля:</target>
        </trans-unit>
        <trans-unit id="e072c9f502e82c76107b9c680016ea26f2459bff" translate="yes" xml:space="preserve">
          <source>However, for convenience, this protocol can also be derivable. For example:</source>
          <target state="translated">Однако для удобства этот протокол также может быть производным.Например:</target>
        </trans-unit>
        <trans-unit id="d2e281662c4868a83f42fe2d3a37e4b42a7ba94d" translate="yes" xml:space="preserve">
          <source>However, if the client had sent an expired or otherwise invalid token &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; would have returned an error instead:</source>
          <target state="translated">Однако, если бы клиент отправил просроченный или недействительный токен, &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; вместо этого вернула бы ошибку:</target>
        </trans-unit>
        <trans-unit id="efbb0f8348e6d519f60b96367c6b25b0ab58981a" translate="yes" xml:space="preserve">
          <source>However, if you are just getting started with Phoenix, we recommend you to install PostgreSQL and make sure it is running. The PostgreSQL wiki has &lt;a href=&quot;https://wiki.postgresql.org/wiki/Detailed_installation_guides&quot;&gt;installation guides&lt;/a&gt; for a number of different systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e4154438c600a0964d2ae325cad0bcb77711e5" translate="yes" xml:space="preserve">
          <source>However, if you attempt to persist the struct above, an error will be raised since Ecto validates the types when sending them to the adapter/database.</source>
          <target state="translated">Однако,если вы попытаетесь сохранить структуру,описанную выше,то возникнет ошибка,так как Ecto проверяет типы при отправке их в адаптер/базу данных.</target>
        </trans-unit>
        <trans-unit id="6beb14dbb92a9c5566dff520724cf6035e375bf3" translate="yes" xml:space="preserve">
          <source>However, if you want all generated URLs to always have a certain schema, host, etc, you may use &lt;a href=&quot;#put_router_url/2&quot;&gt;&lt;code&gt;put_router_url/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f38c3f3c2dea225784564c84cad08b3961c4cb" translate="yes" xml:space="preserve">
          <source>However, if you're adding &lt;code&gt;phoenix_live_view&lt;/code&gt; to an umbrella project, the dependency paths should be modified appropriately:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a0deea3d522aed6c2af612ee37d11179610223" translate="yes" xml:space="preserve">
          <source>However, if your &lt;code&gt;:join_through&lt;/code&gt; is a schema, like &lt;code&gt;MyApp.PostTag&lt;/code&gt;, your join table may be structured as any other table in your codebase, including timestamps:</source>
          <target state="translated">Однако, если ваша &lt;code&gt;:join_through&lt;/code&gt; является схемой, такой как &lt;code&gt;MyApp.PostTag&lt;/code&gt; , ваша таблица соединений может быть структурирована как любая другая таблица в вашей кодовой базе, включая временные метки:</target>
        </trans-unit>
        <trans-unit id="61c4ba54704b1e88b02567334a74ea38f7fe843d" translate="yes" xml:space="preserve">
          <source>However, implementing the &lt;a href=&quot;../plug/plug.exception&quot;&gt;&lt;code&gt;Plug.Exception&lt;/code&gt;&lt;/a&gt; protocol by hand can be convenient in certain occasions, such as when providing Actionable ERrors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5054280086d854890f69bc24ac26fee32ed61037" translate="yes" xml:space="preserve">
          <source>However, keep in mind that if a join is removed and its bindings were referenced elsewhere, the bindings won&amp;rsquo;t be removed, leading to a query that won&amp;rsquo;t compile.</source>
          <target state="translated">Однако имейте в виду, что если соединение удалено и на его привязки ссылались в другом месте, привязки не будут удалены, что приведет к невозможности компиляции запроса.</target>
        </trans-unit>
        <trans-unit id="96c145dbff75201402ee148458f35b3b4df8ec98" translate="yes" xml:space="preserve">
          <source>However, keep in mind that if a join is removed and its bindings were referenced elsewhere, the bindings won't be removed, leading to a query that won't compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418e05e8a16e7c15648cf7bdddb205991c4f4a14" translate="yes" xml:space="preserve">
          <source>However, most commonly, structs are cast, validated and manipulated with the &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Однако чаще всего структуры приводятся, проверяются и управляются с &lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; модуля Ecto.Changeset .</target>
        </trans-unit>
        <trans-unit id="b4a5fc9cf571b09944b8a527ce63cf79c0416fc0" translate="yes" xml:space="preserve">
          <source>However, note that components do not have a &lt;code&gt;handle_info/2&lt;/code&gt; callback. Therefore, if you want to track distributed changes on a card, you must have the parent LiveView receive those events and redirect them to the appropriate card. For example, assuming card updates are sent to the &quot;board:ID&quot; topic, and that the board LiveView is subscribed to said topic, one could do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c15cb8377f6937f642e813f984385d51f7b4176e" translate="yes" xml:space="preserve">
          <source>However, note that defining a window is not necessary, as the window definition can be given as the second argument to &lt;code&gt;over&lt;/code&gt;:</source>
          <target state="translated">Однако обратите внимание, что определение окна не обязательно, так как определение окна может быть указано в качестве второго аргумента для &lt;code&gt;over&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="089510bf5810bca9d96388384533d0538018252e" translate="yes" xml:space="preserve">
          <source>However, once the repository is started, you can't directly interact with it, since all operations in &lt;code&gt;MyApp.Repo&lt;/code&gt; are sent by default to the repository named &lt;code&gt;MyApp.Repo&lt;/code&gt;. You can change the default repo at compile time with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fcb1b6a8bd9d33f8942cfd45c40fa04ca503d0c" translate="yes" xml:space="preserve">
          <source>However, one may argue that, if the last member of an organization cannot leave it, it may be better to not even show the &quot;Leave&quot; button in the UI when the organization has only one member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85984fa1288966d45078f191d19bcd6b0fa6962" translate="yes" xml:space="preserve">
          <source>However, parameterized types are also more complex. Therefore, if everything you need to achieve can be done with basic types, they should be preferred to parameterized ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b14f53aaf9b70f512fe7b2db28dcdb79978b4a" translate="yes" xml:space="preserve">
          <source>However, the issue with said approach is that, if you are rendering multiple user components in the same page, you have a N+1 query problem. The &lt;a href=&quot;#c:preload/1&quot;&gt;&lt;code&gt;preload/1&lt;/code&gt;&lt;/a&gt; callback helps address this problem as it is invoked with a list of assigns for all components of the same type. For example, instead of implementing &lt;a href=&quot;#c:update/2&quot;&gt;&lt;code&gt;update/2&lt;/code&gt;&lt;/a&gt; as above, one could implement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94de3aba560958a631f7ce9430b591344ccd7fee" translate="yes" xml:space="preserve">
          <source>However, we don't advise forwarding to another endpoint. The reason is that plugs defined by your app and the forwarded endpoint would be invoked twice, which may lead to errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cabde0cd7b6db0d68f058c5459d05317cac58e4" translate="yes" xml:space="preserve">
          <source>However, what will happen with a LiveView in case of exceptions? Let's talk about unexpected scenarios.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc8ebeaefd55fb22bf6d7071b4fcd39b701a518" translate="yes" xml:space="preserve">
          <source>However, when rendering components on the client, the client needs to choose the mime type of the component contents, which defaults to HTML. This is the best default but in some cases it may lead to unexpected results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9669e5305e15cb7f2d41b7ba261dd4a25e92989e" translate="yes" xml:space="preserve">
          <source>However, when rendering these metrics in LiveDashboard, the value label is output as &lt;code&gt;&quot;Elixir.Phoenix.LiveDashboard.MetricsLive true&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="404d7e0f0a82ca0536563d8523263ae188890052" translate="yes" xml:space="preserve">
          <source>Identifies the Phoenix.Socket for a LiveView client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69818f21f7d2e8e3d4c95d045561623815bfdb97" translate="yes" xml:space="preserve">
          <source>Identifies the socket connection</source>
          <target state="translated">Идентифицирует гнездовое соединение</target>
        </trans-unit>
        <trans-unit id="a1248f63e6d463c737ae4f281ae99a7acd6c280d" translate="yes" xml:space="preserve">
          <source>Identifies the socket connection.</source>
          <target state="translated">Идентифицирует гнездовое соединение.</target>
        </trans-unit>
        <trans-unit id="c2b9e9831550c1277fc0f8c66e430ed4b934322f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c:transaction/2&quot;&gt;&lt;code&gt;transaction/2&lt;/code&gt;&lt;/a&gt; is called inside another transaction, the function is simply executed, without wrapping the new transaction call in any way. If there is an error in the inner transaction and the error is rescued, or the inner transaction is rolled back, the whole outer transaction is marked as tainted, guaranteeing nothing will be committed.</source>
          <target state="translated">Если &lt;a href=&quot;#c:transaction/2&quot;&gt; &lt;code&gt;transaction/2&lt;/code&gt; &lt;/a&gt; вызывается внутри другой транзакции, функция просто выполняется без какой-либо упаковки вызова новой транзакции. Если есть ошибка во внутренней транзакции и ошибка исправлена, или внутренняя транзакция откатывается, вся внешняя транзакция помечается как испорченная, что гарантирует, что ничего не будет зафиксировано.</target>
        </trans-unit>
        <trans-unit id="48bb3facdf6a618d730a68a131d48750e21adc3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:init_opts&lt;/code&gt; is undefined, then all remaining options are passed to the target plug.</source>
          <target state="translated">Если &lt;code&gt;:init_opts&lt;/code&gt; не определен, то все остальные параметры передаются целевому плагину.</target>
        </trans-unit>
        <trans-unit id="d7b518d769ddb0e8a385ef70577decbd4185956c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:select_merge&lt;/code&gt; is called and there is no value selected previously, it will default to the source, &lt;code&gt;p&lt;/code&gt; in the example above.</source>
          <target state="translated">Если &lt;code&gt;:select_merge&lt;/code&gt; и ранее не было выбрано значение, по умолчанию используется источник, &lt;code&gt;p&lt;/code&gt; в примере выше.</target>
        </trans-unit>
        <trans-unit id="39bb4cb75be5b52a2198bb0576f54f0e0ede32c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;charset&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, the value of the &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; response header won&amp;rsquo;t specify a charset.</source>
          <target state="translated">Если &lt;code&gt;charset&lt;/code&gt; равна &lt;code&gt;nil&lt;/code&gt; , значение заголовка ответа &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; не будет указывать кодировку.</target>
        </trans-unit>
        <trans-unit id="0675b7cae7347e027b29d7d61cb63f9f1413731c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;charset&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, the value of the &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; response header won't specify a charset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c771220878c1cca3211d6dc54b16db5f2b01acdb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;leave&lt;/code&gt; fails and returns &lt;code&gt;false&lt;/code&gt;, an exception is raised. It is common for Elixir developers to use exceptions for unexpected scenarios in their Phoenix applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b63bc1203c3dac71786c2dfe06d19a828803701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;leave&lt;/code&gt; returns false by any chance, it will just raise. Or you can even provide a &lt;code&gt;leave!&lt;/code&gt; function that raises a specific exception:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05c265ccb7acfd4d24ba0e20a24a92a6ce9889f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;limit&lt;/code&gt; is given twice, it overrides the previous value.</source>
          <target state="translated">Если &lt;code&gt;limit&lt;/code&gt; указан дважды, он отменяет предыдущее значение.</target>
        </trans-unit>
        <trans-unit id="e957bc885302ec7685e98cd24a82719aa373a888" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is used more than once, the last one used takes precedence.</source>
          <target state="translated">Если &lt;code&gt;lock&lt;/code&gt; используется более одного раза, приоритет имеет последняя использованная.</target>
        </trans-unit>
        <trans-unit id="90da74aa2f941149e52e2553f73747df1e9ff078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nil&lt;/code&gt; is given as id, a new session id should be generated and returned.</source>
          <target state="translated">Если в качестве id задано &lt;code&gt;nil&lt;/code&gt; , должен быть сгенерирован и возвращен новый идентификатор сеанса.</target>
        </trans-unit>
        <trans-unit id="7d493634e419d6aa39da5fc4a5f636e40e36f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;offset&lt;/code&gt; is given twice, it overrides the previous value.</source>
          <target state="translated">Если &lt;code&gt;offset&lt;/code&gt; задано дважды, оно отменяет предыдущее значение.</target>
        </trans-unit>
        <trans-unit id="972e323b8fae502f4935411636b7be015afc29ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options&lt;/code&gt; is map or keyword list where the first element is a string, atom or integer and the second element is a list or a map, it is assumed the key will be wrapped in an &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; and the value will be used to generate &lt;code&gt;&amp;lt;options&amp;gt;&lt;/code&gt; nested under the group.</source>
          <target state="translated">Если &lt;code&gt;options&lt;/code&gt; - это карта или список ключевых слов, где первый элемент - это строка, атом или целое число, а второй элемент - это список или карта, предполагается, что ключ будет заключен в &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; , а значение будет использоваться для генерации &lt;code&gt;&amp;lt;options&amp;gt;&lt;/code&gt; вложены в группу.</target>
        </trans-unit>
        <trans-unit id="a3421dda344b70b936418fb88ce89a791460b02d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path_or_action&lt;/code&gt; is a string, it is considered to be the request path and stored as so in the connection. If an atom, it is assumed to be an action and the connection is dispatched to the given action.</source>
          <target state="translated">Если &lt;code&gt;path_or_action&lt;/code&gt; является строкой, она считается путем запроса и сохраняется в таком виде в соединении. Если это атом, предполагается, что это действие, и соединение отправляется данному действию.</target>
        </trans-unit>
        <trans-unit id="b9c8f702bb6c0810a48712a7631f4ec240983313" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is &lt;code&gt;:closed&lt;/code&gt;, it means the client closed the socket. This is considered a &lt;code&gt;:normal&lt;/code&gt; exit signal, so linked process will not automatically exit. See &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#exit/2&quot;&gt;&lt;code&gt;Process.exit/2&lt;/code&gt;&lt;/a&gt; for more details on exit signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e582e3374d4e382af5d6f29d1086454023de04" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the header is checked against &lt;code&gt;:host&lt;/code&gt; in &lt;code&gt;YourApp.Endpoint.config(:url)[:host]&lt;/code&gt;. If &lt;code&gt;false&lt;/code&gt;, your app is vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. Only use in development, when the host is truly unknown or when serving clients that do not send the &lt;code&gt;origin&lt;/code&gt; header, such as mobile apps. You can also specify a list of explicitly allowed origins. Wildcards are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf67ea57ee4ce23434afd8c43be52701544068b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:cache, cache_function, prepared}&lt;/code&gt; is given, it means the query can be cached and it must be cached by calling the &lt;code&gt;cache_function&lt;/code&gt; function with the cache entry of your choice. Once &lt;code&gt;cache_function&lt;/code&gt; is called, the next time the same query is given to &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;, it will receive the &lt;code&gt;:cached&lt;/code&gt; tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1309c121da20f5187a51a6961ffb575f0b7cff39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:cached, update_function, reset_function, cached}&lt;/code&gt; is given, it means the query has been cached. You may call &lt;code&gt;update_function/1&lt;/code&gt; if you want to update the cached result. Or you may call &lt;code&gt;reset_function/1&lt;/code&gt;, with a new prepared query, to force the query to be cached again. If &lt;code&gt;reset_function/1&lt;/code&gt; is called, the next time the same query is given to &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;, it will receive the &lt;code&gt;:cache&lt;/code&gt; tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e417833516d635fb72f5c63c1ffab31f552e12db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:nocache, prepared}&lt;/code&gt; is given, it means the query was not and cannot be cached. The &lt;code&gt;prepared&lt;/code&gt; value is the value returned by &lt;a href=&quot;#c:prepare/2&quot;&gt;&lt;code&gt;prepare/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98796a5ac95043dc0bbdaf9869321de0caf5c9b9" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65af891627aefc80920df2e764b5156cab6de22" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;https://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3917143de35bdf1d2e86820a8a552e7dc5784eb2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;plug.debugger#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="translated">Если установлена переменная среды &lt;code&gt;PLUG_EDITOR&lt;/code&gt; , &lt;a href=&quot;plug.debugger#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt; будет использовать ее для создания ссылок на ваш текстовый редактор. Переменная должна быть установлена ​​с заполнителями &lt;code&gt;__FILE__&lt;/code&gt; и &lt;code&gt;__LINE__&lt;/code&gt; , которые будут правильно заменены. Например (с редактором &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="49d8918a29c80a70a37b7994f33277bbc4930397" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;plug.debugger#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;https://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8438373db0bb704311f615a6503d58ee84b3d61" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;path&lt;/code&gt; is given, then a regular &lt;code&gt;get(conn, path)&lt;/code&gt; is done and the page is upgraded to a &lt;code&gt;LiveView&lt;/code&gt;. If no path is given, it assumes a previously rendered &lt;code&gt;%Plug.Conn{}&lt;/code&gt; is given, which will be converted to a &lt;code&gt;LiveView&lt;/code&gt; immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f871e965d2407597bc5715cea4f0ab94f714d6e5" translate="yes" xml:space="preserve">
          <source>If a control frame doesn't have a payload, then the payload value will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb554a564dd3cf44251ab909d1682e6cddc415a6" translate="yes" xml:space="preserve">
          <source>If a cookie is invalid, it is automatically discarded from the result.</source>
          <target state="translated">Если куки-файл недействителен,он автоматически отбрасывается из результата.</target>
        </trans-unit>
        <trans-unit id="3710000536ae0ecb682a86fbf651cc12761ba83e" translate="yes" xml:space="preserve">
          <source>If a field is given to &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; but it has not been passed as parameter during &lt;a href=&quot;#cast/3&quot;&gt;&lt;code&gt;cast/3&lt;/code&gt;&lt;/a&gt; (i.e. it has not been changed), then &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; will check for its current value in the data. If the data contains an non-empty value for the field, then no error is added. This allows developers to use &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; to perform partial updates. For example, on &lt;code&gt;insert&lt;/code&gt; all fields would be required, because their default values on the data are all &lt;code&gt;nil&lt;/code&gt;, but on &lt;code&gt;update&lt;/code&gt;, if you don't want to change a field that has been previously set, you are not required to pass it as a paramater, since &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; won't add an error for missing changes as long as the value in the data given to the &lt;code&gt;changeset&lt;/code&gt; is not empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd4733e62d747fd2dc1933eb4482e62fe11f653" translate="yes" xml:space="preserve">
          <source>If a field is unchanged and &lt;code&gt;.leex&lt;/code&gt; believes a dynamic expression no longer needs to be computed, its value in the &lt;code&gt;dynamic&lt;/code&gt; list will be &lt;code&gt;nil&lt;/code&gt;. This information can be leveraged to avoid sending data to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5748e7fd13f50e04ab4f92ee369e7bef4e0182" translate="yes" xml:space="preserve">
          <source>If a file is uploaded via any of the parsers, Plug will stream the uploaded contents to a file in a temporary directory in order to avoid loading the whole file into memory. For such, the &lt;code&gt;:plug&lt;/code&gt; application needs to be started in order for file uploads to work. More details on how the uploaded file is handled can be found in the documentation for &lt;a href=&quot;plug.upload&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если файл загружается через любой из анализаторов, Plug будет передавать загруженное содержимое в файл во временном каталоге, чтобы избежать загрузки всего файла в память. Для этого необходимо запустить приложение &lt;code&gt;:plug&lt;/code&gt; , чтобы загрузка файлов работала. Более подробную информацию о том, как обрабатывается загруженный файл, можно найти в документации для &lt;a href=&quot;plug.upload&quot;&gt; &lt;code&gt;Plug.Upload&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9a66f3d4a76267cf3daa797fca21dffb2926bba" translate="yes" xml:space="preserve">
          <source>If a request id already exists as the &quot;x-request-id&quot; HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff4d7c53872729839a77bd5a96d38cb274491289" translate="yes" xml:space="preserve">
          <source>If a request id already exists as the &amp;ldquo;x-request-id&amp;rdquo; HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated.</source>
          <target state="translated">Если идентификатор запроса уже существует как заголовок HTTP-запроса &amp;laquo;x-request-id&amp;raquo;, то это значение будет использоваться, предполагая, что оно составляет от 20 до 200 символов. Если это не так, будет сгенерирован новый идентификатор запроса.</target>
        </trans-unit>
        <trans-unit id="0a43716c3aaf07a4683f32a558be906bc63cdf44" translate="yes" xml:space="preserve">
          <source>If a source is given, without a schema module, the given fields are passed as is to the adapter.</source>
          <target state="translated">Если дается источник,без модуля схемы,то данные поля передаются как есть адаптеру.</target>
        </trans-unit>
        <trans-unit id="e0fcc0fd0de1b3c59c0bc9f15d6ba587aeb25386" translate="yes" xml:space="preserve">
          <source>If a static asset cannot be found, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; simply forwards the connection to the rest of the pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43529dcc9122748af804be0c58edc57e0c307b24" translate="yes" xml:space="preserve">
          <source>If a static asset cannot be found, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; simply forwards the connection to the rest of the pipeline.</source>
          <target state="translated">Если статический актив не может быть найден, &lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt; просто перенаправляет соединение остальной части конвейера.</target>
        </trans-unit>
        <trans-unit id="5ad05d6344b5d56c40d9d05868bbe0fc447a1ebc" translate="yes" xml:space="preserve">
          <source>If a subquery is given, returns the subquery itself. If any other value is given, it is converted to a query via &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; and wrapped in the &lt;a href=&quot;ecto.subquery&quot;&gt;&lt;code&gt;Ecto.SubQuery&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Если задан подзапрос, возвращает сам подзапрос. Если задано любое другое значение, оно преобразуется в запрос через &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;ecto.subquery&quot;&gt; &lt;code&gt;Ecto.SubQuery&lt;/code&gt; &lt;/a&gt; структуру Ecto.SubQuery .</target>
        </trans-unit>
        <trans-unit id="d48ba6ea6ec7ffa263a8d1a43b7dcdf2efa2753d" translate="yes" xml:space="preserve">
          <source>If a token exists, it is returned, otherwise it is generated and stored in the process dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b893693b1726f40ddda25b9dd0c70ab3cfa2216" translate="yes" xml:space="preserve">
          <source>If a value is given more than once, the last value takes precedence:</source>
          <target state="translated">Если значение дается несколько раз,то приоритет отдается последнему значению:</target>
        </trans-unit>
        <trans-unit id="c72db962fcdc4941c8aba4d0408a0a707016fe8b" translate="yes" xml:space="preserve">
          <source>If a view is provided, the entire LiveView is rendered. If an element is provided, only that element is rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaddcc5aa1077f7a26eab071fe7684352cdb0d24" translate="yes" xml:space="preserve">
          <source>If an unhandled error occurs the transaction will be rolled back and the error will bubble up from the transaction function. If no error occurred the transaction will be committed when the function returns. A transaction can be explicitly rolled back by calling &lt;a href=&quot;#c:rollback/1&quot;&gt;&lt;code&gt;rollback/1&lt;/code&gt;&lt;/a&gt;, this will immediately leave the function and return the value given to &lt;code&gt;rollback&lt;/code&gt; as &lt;code&gt;{:error, value}&lt;/code&gt;.</source>
          <target state="translated">Если возникает необработанная ошибка, транзакция будет отменена, и ошибка возникнет из функции транзакции. Если ошибок не произошло, транзакция будет зафиксирована, когда функция вернется. Транзакцию можно явно откатить, вызвав &lt;a href=&quot;#c:rollback/1&quot;&gt; &lt;code&gt;rollback/1&lt;/code&gt; &lt;/a&gt; , это немедленно оставит функцию и вернет значение, данное &lt;code&gt;rollback&lt;/code&gt; как &lt;code&gt;{:error, value}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="153b8768ac116a6059a08945ee6b26d18eec128a" translate="yes" xml:space="preserve">
          <source>If any of the callbacks return a &lt;code&gt;:stop&lt;/code&gt; tuple, it will also trigger terminate with the reason given in the tuple.</source>
          <target state="translated">Если какой-либо из обратных вызовов возвращает кортеж &lt;code&gt;:stop&lt;/code&gt; , он также запускает завершение по причине, указанной в кортеже.</target>
        </trans-unit>
        <trans-unit id="a8b20d463cde7b903560b17334ed7d36242c5f45" translate="yes" xml:space="preserve">
          <source>If available, the file is sent directly over the socket using the operating system &lt;code&gt;sendfile&lt;/code&gt; operation.</source>
          <target state="translated">Если доступно, файл отправляется непосредственно через сокет с помощью операции &lt;code&gt;sendfile&lt;/code&gt; операционной системы .</target>
        </trans-unit>
        <trans-unit id="82f8819da3536b2ff1e621e91a5108e31f33c3f5" translate="yes" xml:space="preserve">
          <source>If casting of all fields is successful, the changeset is returned as valid.</source>
          <target state="translated">Если кастинг всех полей успешен,changeset возвращается как действительный.</target>
        </trans-unit>
        <trans-unit id="8943a6555280626edd3a71e646c2c513ffe092f9" translate="yes" xml:space="preserve">
          <source>If changing the JSON library, remember to recompile the adapter afterwards by cleaning the current build:</source>
          <target state="translated">При изменении JSON-библиотеки не забудьте перекомпилировать адаптер после этого,очистив текущую сборку:</target>
        </trans-unit>
        <trans-unit id="9d661e3bc80c3727f4d8b3225ce99bc171f66095" translate="yes" xml:space="preserve">
          <source>If for some reason your database does not support case insensitive columns, you can explicitly downcase values before inserting/updating them:</source>
          <target state="translated">Если по каким-либо причинам ваша база данных не поддерживает колонки,не чувствительные к регистру,вы можете явно понизить значения перед их вставкой/обновлением:</target>
        </trans-unit>
        <trans-unit id="14be184c345c7f9dea111444b78e1f2cb754b1fe" translate="yes" xml:space="preserve">
          <source>If installing from Hex, use the latest version from there:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a9f7927001d081a57717076667b9d7a6f459c0" translate="yes" xml:space="preserve">
          <source>If interpolating keyword lists, the keyword list entries are combined using ANDs and joined to any existing expression with an OR:</source>
          <target state="translated">При интерполяции списков ключевых слов,элементы списка ключевых слов объединяются с помощью AND и присоединяются к любому существующему выражению с помощью OR:</target>
        </trans-unit>
        <trans-unit id="76cef5435664170ccd219b3f7c9c0adfb90f5be5" translate="yes" xml:space="preserve">
          <source>If it is a keyword query the first argument must be either an &lt;code&gt;in&lt;/code&gt; expression, or a value that implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol. If the query needs a reference to the data source in any other part of the expression, then an &lt;code&gt;in&lt;/code&gt; must be used to create a reference variable. The second argument should be a keyword query where the keys are expression types and the values are expressions.</source>
          <target state="translated">Если это запрос по ключевым словам, первый аргумент должен быть либо выражением &lt;code&gt;in&lt;/code&gt; , либо значением, реализующим протокол &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt; . Если в запросе требуется ссылка на источник данных в любой другой части выражения, то необходимо использовать &lt;code&gt;in&lt;/code&gt; для создания ссылочной переменной. Второй аргумент должен быть запросом с ключевым словом, где ключи - это типы выражений, а значения - выражения.</target>
        </trans-unit>
        <trans-unit id="e167dc3c73586f0621a46fd98ad4b4b1f1bc7e6b" translate="yes" xml:space="preserve">
          <source>If it is a query expression the first argument must be a value that implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol and the second argument the expression.</source>
          <target state="translated">Если это выражение запроса, первый аргумент должен быть значением, реализующим протокол &lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt; , а второй аргумент - выражением.</target>
        </trans-unit>
        <trans-unit id="c6ade3c42f4b46404eaab263d289e45dd9fd2097" translate="yes" xml:space="preserve">
          <source>If it is your first time with Phoenix, you don't need to worry about the details right now. For now, suffice it to say our application starts a database repository, a pubsub system for sharing messages across processes and nodes, and the application endpoint, which effectively serves HTTP requests. These services are started in the order they are defined and, whenever shutting down your application, they are stopped in the reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2004e501e574e9ee412f8a4a483f6b11c68baa6" translate="yes" xml:space="preserve">
          <source>If multi contains operations that accept changesets (like &lt;a href=&quot;#insert/4&quot;&gt;&lt;code&gt;insert/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update/4&quot;&gt;&lt;code&gt;update/4&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#delete/4&quot;&gt;&lt;code&gt;delete/4&lt;/code&gt;&lt;/a&gt;) they will be checked before starting the transaction. If any changeset has errors, the transaction won&amp;rsquo;t even be started and the error will be immediately returned.</source>
          <target state="translated">Если multi содержит операции, которые принимают ревизии (например, &lt;a href=&quot;#insert/4&quot;&gt; &lt;code&gt;insert/4&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#update/4&quot;&gt; &lt;code&gt;update/4&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#delete/4&quot;&gt; &lt;code&gt;delete/4&lt;/code&gt; &lt;/a&gt; ), они будут проверены перед запуском транзакции. Если какой-либо набор изменений содержит ошибки, транзакция даже не будет запущена, и ошибка будет немедленно возвращена.</target>
        </trans-unit>
        <trans-unit id="63d39ee63729141787866693d23e5982b3dfbe19" translate="yes" xml:space="preserve">
          <source>If multi contains operations that accept changesets (like &lt;a href=&quot;#insert/4&quot;&gt;&lt;code&gt;insert/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update/4&quot;&gt;&lt;code&gt;update/4&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#delete/4&quot;&gt;&lt;code&gt;delete/4&lt;/code&gt;&lt;/a&gt;) they will be checked before starting the transaction. If any changeset has errors, the transaction won't even be started and the error will be immediately returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636fecfc6c19833110f980b78af43a7ddc1683cf" translate="yes" xml:space="preserve">
          <source>If no action has been applied to the changeset or action was set to &lt;code&gt;:ignore&lt;/code&gt;, no errors are shown on the form object even if the changeset has a non-empty &lt;code&gt;:errors&lt;/code&gt; value.</source>
          <target state="translated">Если к набору изменений не было применено никаких действий или для действия было задано значение &lt;code&gt;:ignore&lt;/code&gt; , то в объекте формы не отображаются ошибки, даже если набор изменений имеет непустое значение &lt;code&gt;:errors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf26fadc638285a0643bc477b2beb4a0a2ba425c" translate="yes" xml:space="preserve">
          <source>If no channel module is provided, the socket&amp;rsquo;s handler is used to lookup the matching channel for the given topic.</source>
          <target state="translated">Если модуль канала не указан, обработчик сокета используется для поиска подходящего канала для данной темы.</target>
        </trans-unit>
        <trans-unit id="1a628119141d05e629bf0a8766bdd3134096279c" translate="yes" xml:space="preserve">
          <source>If no channel module is provided, the socket's handler is used to lookup the matching channel for the given topic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2947103d7b79f0495b72a656cc81700719a03f4" translate="yes" xml:space="preserve">
          <source>If no custom parameters are specified, Erlang&amp;rsquo;s &lt;code&gt;ssl&lt;/code&gt; uses its built-in defaults. Since OTP 19 this has been the 2048-bit &amp;lsquo;group 14&amp;rsquo; from RFC 3526.</source>
          <target state="translated">Если специальные параметры не указаны, &lt;code&gt;ssl&lt;/code&gt; Erlang использует свои встроенные значения по умолчанию. Начиная с OTP 19 это была 2048-битная &amp;laquo;группа 14&amp;raquo; из RFC 3526.</target>
        </trans-unit>
        <trans-unit id="ff06cd66143c9798bef49db90969d1d02260d4a5" translate="yes" xml:space="preserve">
          <source>If no custom parameters are specified, Erlang's &lt;code&gt;:ssl&lt;/code&gt; uses its built-in defaults. Since OTP 19 this has been the 2048-bit 'group 14' from RFC3526.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030bd22aca683fa25d2f90bbb7143785a15622d3" translate="yes" xml:space="preserve">
          <source>If no data type is given, it defaults to a string.</source>
          <target state="translated">Если тип данных не указан,то по умолчанию он равен строке.</target>
        </trans-unit>
        <trans-unit id="ad19118a3e502181cda3b94015f8e221a2d0b2b8" translate="yes" xml:space="preserve">
          <source>If no path is given, it will use &lt;code&gt;priv/static&lt;/code&gt; as the input and output path.</source>
          <target state="translated">Если путь не указан, он будет использовать &lt;code&gt;priv/static&lt;/code&gt; в качестве пути ввода и вывода.</target>
        </trans-unit>
        <trans-unit id="8d9d3c05f3dd12de1de5d07c7780f6542cae6c1f" translate="yes" xml:space="preserve">
          <source>If no repo option is given, it is retrieved from the application environment.</source>
          <target state="translated">Если опция повторного использования не указана,она извлекается из прикладной среды.</target>
        </trans-unit>
        <trans-unit id="3ee5c6147c3838216862db0b62414741e83ebcaf" translate="yes" xml:space="preserve">
          <source>If no route matches, no pipeline is invoked and a 404 error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0b5d32c7f6f93cc1778a67587e008602e3131c" translate="yes" xml:space="preserve">
          <source>If no text filter is given, then the query selector itself must return a single element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a1b6ad904f99f371f35324f835d274f96ca690" translate="yes" xml:space="preserve">
          <source>If none of the rendering options above quite fits our needs, we can compose our own using some of the functions that Plug gives us. Let's say we want to send a response with a status of &quot;201&quot; and no body whatsoever. We can easily do that with the &lt;a href=&quot;../plug/plug.conn#send_resp/3&quot;&gt;&lt;code&gt;Plug.Conn.send_resp/3&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adbbb0c65b31d1f51c0020589f3eb9907222ef9" translate="yes" xml:space="preserve">
          <source>If one of the goals of our context is to encapsulate Ecto Repo access, why does &lt;code&gt;create_user/1&lt;/code&gt; return an &lt;code&gt;Ecto.Changeset&lt;/code&gt; struct when we fail to create a user?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac423aab6755d9973153fe985b209449ba726adf" translate="yes" xml:space="preserve">
          <source>If supported by your database, you can also pass query expressions to distinct and it will generate a query with DISTINCT ON. In such cases, &lt;code&gt;distinct&lt;/code&gt; accepts exactly the same expressions as &lt;code&gt;order_by&lt;/code&gt; and any &lt;code&gt;distinct&lt;/code&gt; expression will be automatically prepended to the &lt;code&gt;order_by&lt;/code&gt; expressions in case there is any &lt;code&gt;order_by&lt;/code&gt; expression.</source>
          <target state="translated">Если это поддерживается вашей базой данных, вы также можете передавать выражения запроса в отличные, и они будут генерировать запрос с DISTINCT ON. В таких случаях &lt;code&gt;distinct&lt;/code&gt; принимает точно такие же выражения, что и &lt;code&gt;order_by&lt;/code&gt; , и любое &lt;code&gt;distinct&lt;/code&gt; выражение будет автоматически добавлено к выражениям &lt;code&gt;order_by&lt;/code&gt; в случае, если есть какое-либо выражение &lt;code&gt;order_by&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0223af7ed3699eca63dea1d94efb960cd2c51cb2" translate="yes" xml:space="preserve">
          <source>If the &quot;postgres&quot; role does not have permission to create a database, we'll get this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce73e85073d9175d4905b8efcee9aa421bd12fc3" translate="yes" xml:space="preserve">
          <source>If the &quot;postgres&quot; role does not have permission to log in to the application, we'll get this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de209264f46473a4d55a8d354b626de4aafb07b2" translate="yes" xml:space="preserve">
          <source>If the &quot;postgres&quot; role is using a password different from the default &quot;postgres&quot;, we'll get this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70216b8d4897b8cf4c5ab39916317d1da5fb0d73" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; callback is implemented in the repository, it will be invoked with the first argument set to &lt;code&gt;:runtime&lt;/code&gt;.</source>
          <target state="translated">Если обратный вызов &lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt; реализован в репозитории, он будет вызываться с первым аргументом, установленным в &lt;code&gt;:runtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbad62ac0f0e10ca6a55f7468a042cab7daca496" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:sign&lt;/code&gt; or &lt;code&gt;:encrypt&lt;/code&gt; flag are given, then the cookie value can be any term.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda9d4cb892d2093b03ae139bdc1a11671af1389" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;@title&lt;/code&gt; assign changes, then LiveView will execute &lt;code&gt;expand_title(@title)&lt;/code&gt; and send the new content. If &lt;code&gt;@title&lt;/code&gt; is the same, nothing is executed and nothing is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de200e7c0ff094d2c2c6dcf0b8963fe5d0947ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;@user.name&lt;/code&gt; changes but &lt;code&gt;@user.id&lt;/code&gt; doesn't, then LiveView will re-render only &lt;code&gt;@user.name&lt;/code&gt; and it will not execute or resend &lt;code&gt;@user.id&lt;/code&gt; at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20375713da5b5d68c5268d482ffb338724366ce5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;phx-value-&lt;/code&gt; prefix is used, the server payload will also contain a &lt;code&gt;&quot;value&quot;&lt;/code&gt; if the element's value attribute exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9712dc6b620700aa8412aa4754ed6dd3e600a162" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;required_key&lt;/code&gt; is not present, it will raise &lt;a href=&quot;phoenix.missingparamerror&quot;&gt;&lt;code&gt;Phoenix.MissingParamError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;required_key&lt;/code&gt; отсутствует, это вызовет &lt;a href=&quot;phoenix.missingparamerror&quot;&gt; &lt;code&gt;Phoenix.MissingParamError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd227aadd17ccc0cdbbbf544e1a39ccbddc874c" translate="yes" xml:space="preserve">
          <source>If the LiveView is the source of truth, it will be responsible for fetching all of the cards in a board. Then it will call &lt;code&gt;live_component/3&lt;/code&gt; for each card, passing the card struct as argument to CardComponent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b677401fc03b5a40d9088383358e9a2bc2639670" translate="yes" xml:space="preserve">
          <source>If the LiveView redirects with a live redirect, this macro returns &lt;code&gt;{:ok, live_view, disconnected_html}&lt;/code&gt; with the content of the new LiveView, the same as the &lt;code&gt;live/3&lt;/code&gt; macro. If the LiveView redirects with a regular redirect, this macro returns &lt;code&gt;{:ok, conn}&lt;/code&gt; with the rendered redirected page. In any other case, this macro raises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774625820d7d0ec4e795fa8c9c6c08379f522851" translate="yes" xml:space="preserve">
          <source>If the URL has a host, a CSRF token that is tied to that host will be generated. If it is a relative path URL, a simple token emitted with &lt;a href=&quot;#get_csrf_token/0&quot;&gt;&lt;code&gt;get_csrf_token/0&lt;/code&gt;&lt;/a&gt; will be used.</source>
          <target state="translated">Если URL-адрес имеет хост, будет создан токен CSRF, привязанный к этому хосту. Если это URL относительного пути, будет использоваться простой токен, &lt;a href=&quot;#get_csrf_token/0&quot;&gt; &lt;code&gt;get_csrf_token/0&lt;/code&gt; &lt;/a&gt; с get_csrf_token / 0 .</target>
        </trans-unit>
        <trans-unit id="5e46e2e7ec4df9676257eca653e07b09f347fb52" translate="yes" xml:space="preserve">
          <source>If the adapter does not provide a pool, just calling the passed function and returning its result are enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c467ebfb28c3769c0f60d1ed5192b127c4f129d1" translate="yes" xml:space="preserve">
          <source>If the adapter does not support inform, then &lt;code&gt;{:error, :not_supported}&lt;/code&gt; should be returned.</source>
          <target state="translated">Если адаптер не поддерживает &lt;code&gt;{:error, :not_supported}&lt;/code&gt; необходимо вернуть {: error,: not_supported} .</target>
        </trans-unit>
        <trans-unit id="b83fa861079f61f5349df999d4ab77d5e9dd2d46" translate="yes" xml:space="preserve">
          <source>If the adapter does not support informational responses then this is a noop.</source>
          <target state="translated">Если адаптер не поддерживает информационные ответы,значит,это неудобно.</target>
        </trans-unit>
        <trans-unit id="abd9faa09d21bdad382cd8d73f3c1cd6edf98fe0" translate="yes" xml:space="preserve">
          <source>If the adapter does not support server push then &lt;code&gt;{:error, :not_supported}&lt;/code&gt; should be returned.</source>
          <target state="translated">Если адаптер не поддерживает &lt;code&gt;{:error, :not_supported}&lt;/code&gt; необходимо вернуть {: error,: not_supported} .</target>
        </trans-unit>
        <trans-unit id="03a7adb38fe4fd08405bbe2e59b1dc64945ce1ee" translate="yes" xml:space="preserve">
          <source>If the adapter does not support server push then this is a noop.</source>
          <target state="translated">Если адаптер не поддерживает нажатие сервера,то это noop.</target>
        </trans-unit>
        <trans-unit id="e1ab595daecbe8219ab31d6ce1dc0b9d4bd3ff2d" translate="yes" xml:space="preserve">
          <source>If the adapter provides a pool, it is supposed to &quot;check out&quot; one of the pool connections for the duration of the function call. Which connection is checked out is not passed to the calling function, so it should be done using a stateful method like using the current process' dictionary, process tracking, or some kind of other lookup method. Make sure that this stored connection is then used in the other callbacks implementations, such as &lt;a href=&quot;ecto.adapter.queryable&quot;&gt;&lt;code&gt;Ecto.Adapter.Queryable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ecto.adapter.schema&quot;&gt;&lt;code&gt;Ecto.Adapter.Schema&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e30f305c8d388d84dacb2f22a8db0505392601" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;:select_merge&lt;/code&gt; is a constructed struct (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;) or map (&lt;code&gt;map/2&lt;/code&gt;) where the source to &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;map/2&lt;/code&gt; may be a &lt;code&gt;nil&lt;/code&gt; value (as in an outer join), the source will be returned unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c015b3bdb8e3e97eeb9a475ec46483a71e9b1c" translate="yes" xml:space="preserve">
          <source>If the association has no changes, it will be skipped. If the association is invalid, the changeset will be marked as invalid. If the given value is not any of values below, it will raise.</source>
          <target state="translated">Если ассоциация не изменится,она будет пропущена.Если ассоциация недействительна,changeset будет помечен как недействительный.Если заданное значение не является каким-либо из значений ниже,оно будет увеличено.</target>
        </trans-unit>
        <trans-unit id="6943cbcbf6b1af61a1ee6167ddcf2f6551e4192a" translate="yes" xml:space="preserve">
          <source>If the body of the action needs access to the full map of parameters bound to the params variable in addition to the bound messenger variable, we could define &lt;code&gt;show/2&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f7bac3c27469f7d4914ccb40eab78a149fc9bfe" translate="yes" xml:space="preserve">
          <source>If the change is already present, it is overridden with the new value.</source>
          <target state="translated">Если изменение уже присутствует,оно переопределяется новым значением.</target>
        </trans-unit>
        <trans-unit id="b0a698e1cab1f6f678660aa4dfb67045d6928daa" translate="yes" xml:space="preserve">
          <source>If the change is already present, it is overridden with the new value. If the change has the same value as in the changeset data, it is not added to the list of changes.</source>
          <target state="translated">Если изменение уже присутствует,оно переопределяется новым значением.Если изменение имеет то же значение,что и в changeset-данных,оно не добавляется в список изменений.</target>
        </trans-unit>
        <trans-unit id="d643dc985a9051bacd04e1a9f62548fd0e65c8a1" translate="yes" xml:space="preserve">
          <source>If the changes are valid, all changes are applied to the changeset data. If the changes are invalid, no changes are applied, and an error tuple is returned with the changeset containing the action that was attempted to be applied.</source>
          <target state="translated">Если изменения действительны,все изменения применяются к данным changeset.Если изменения являются недействительными,изменения не применяются,и кортеж ошибки возвращается вместе с changeset'ом,содержащим действие,которое пытались применить.</target>
        </trans-unit>
        <trans-unit id="2757319b7d7f37a81751b87f0ba7d4b5be8070c7" translate="yes" xml:space="preserve">
          <source>If the changeset given to the repository is valid, the function given to &lt;a href=&quot;#prepare_changes/2&quot;&gt;&lt;code&gt;prepare_changes/2&lt;/code&gt;&lt;/a&gt; will be called with the changeset and must return a changeset, allowing developers to do final adjustments to the changeset or to issue data consistency commands. The repository itself can be accessed inside the function under the &lt;code&gt;repo&lt;/code&gt; field in the changeset. If the changeset given to the repository is invalid, the function will not be invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfa9dbe95ded2efddb01ada6c9e4b572e2c816b" translate="yes" xml:space="preserve">
          <source>If the component is the source of truth, then the LiveView must no longer fetch all of the cards structs from the database. Instead, the view must only fetch all of the card ids and render the component only by passing the IDs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67aa5ebe70fe8f05417258db1eb3c5975b93dd2a" translate="yes" xml:space="preserve">
          <source>If the component uses the &lt;code&gt;@myself&lt;/code&gt; assigns, then an &lt;code&gt;id&lt;/code&gt; must be given to it is marked as stateful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344cb03738b4c3ad68a22abc027e74afa335c15c" translate="yes" xml:space="preserve">
          <source>If the connection is accepted, the transport can move the connection to another process, if so desires, or keep using the same process. The process responsible for managing the socket should then call &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d577ab6f6374c6d9db1620ec48bb72e49c4e5c2" translate="yes" xml:space="preserve">
          <source>If the connection was successful, generates &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic from the &lt;code&gt;id/1&lt;/code&gt; callback.</source>
          <target state="translated">Если соединение было успешным, генерирует тему &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; из обратного вызова &lt;code&gt;id/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14c0b3c8ee8241e593e8ad60d75f84e2457bdc6b" translate="yes" xml:space="preserve">
          <source>If the cookie is not signed nor encrypted, then the value must be a binary. Note the value is not automatically escaped. Therefore if you want to store values with non-alphanumeric characters, you must either sign or encrypt the cookie or consider explicitly escaping the cookie value by using a function such as &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; when writing and &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; when reading the cookie. It is important for padding to be disabled since &lt;code&gt;=&lt;/code&gt; is not a valid character in cookie values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864bd00ea3a957445c805b9ef45d85dcecd562f1" translate="yes" xml:space="preserve">
          <source>If the element is does not have a &lt;code&gt;phx-click&lt;/code&gt; attribute but it is a link (the &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tag), the link will be followed accordingly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5834bc3acf73c8335beda9b2b7bbaf51ee3a6e" translate="yes" xml:space="preserve">
          <source>If the embed has no changes, it will be skipped. If the embed is invalid, the changeset will be marked as invalid.</source>
          <target state="translated">Если вложение не имеет изменений,оно будет пропущено.Если embed недействителен,набор изменений будет помечен как недействительный.</target>
        </trans-unit>
        <trans-unit id="077370f1bc31b993e443236f4c6f4806ca2f3eaa" translate="yes" xml:space="preserve">
          <source>If the error happens during an event, the LiveView process will crash. The client will notice the error and remount the LiveView - without reloading the page. This is enough to update the page and show the user the latest information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100887b9de3b56af079f0a72491a4382d1396bb0" translate="yes" xml:space="preserve">
          <source>If the map on the left side is a struct, Ecto will check all of the field on the right previously exist on the left before merging.</source>
          <target state="translated">Если карта слева является структурой,то перед слиянием Ecto проверит все поля справа,ранее существовавшие слева.</target>
        </trans-unit>
        <trans-unit id="67cfc2cb3e12875af3e1ba6a2973b3dbd4bbf5ad" translate="yes" xml:space="preserve">
          <source>If the parameter contains an ID and there is an associated child with such ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with the existing struct and become an update operation</source>
          <target state="translated">Если параметр содержит идентификатор и есть связанный дочерний &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; с таким идентификатором, данные параметра будут переданы в MyApp.Address.changeset / 2 с существующей структурой и станут операцией обновления.</target>
        </trans-unit>
        <trans-unit id="5b235bb233a3f3d355503c030abb877188e1fb03" translate="yes" xml:space="preserve">
          <source>If the parameter contains an ID and there is no associated child with such ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with a new struct and become an insert operation</source>
          <target state="translated">Если параметр содержит идентификатор и нет связанного дочернего &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; с таким идентификатором, данные параметра будут переданы в MyApp.Address.changeset / 2 с новой структурой и станут операцией вставки.</target>
        </trans-unit>
        <trans-unit id="4c2858b55ac4015434edf3d00d6d984a1e7af01d" translate="yes" xml:space="preserve">
          <source>If the parameter does not contain an ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with a new struct and become an insert operation</source>
          <target state="translated">Если параметр не содержит идентификатора, данные параметра будут переданы в &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; с новой структурой и станут операцией вставки.</target>
        </trans-unit>
        <trans-unit id="78ee41955dbd956392d43e790282ee7ecabd02d3" translate="yes" xml:space="preserve">
          <source>If the parameterized type is also a composite type, the inner type can be cast by calling &lt;a href=&quot;ecto.type#cast/2&quot;&gt;&lt;code&gt;Ecto.Type.cast/2&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e14dbb4189c408fd4ca75086bfd71c426f435db" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;:pop&lt;/code&gt;, the return value of this callback must be &lt;code&gt;{value, new_data}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if not present) and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Если переданная функция возвращает &lt;code&gt;:pop&lt;/code&gt; , возвращаемое значение этого обратного вызова должно быть &lt;code&gt;{value, new_data}&lt;/code&gt; где &lt;code&gt;value&lt;/code&gt; - это значение под &lt;code&gt;key&lt;/code&gt; (или &lt;code&gt;nil&lt;/code&gt; , если нет), а &lt;code&gt;new_data&lt;/code&gt; - это &lt;code&gt;data&lt;/code&gt; без &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff09001e9ce2d8278137d1ce993917e82be4cb26" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;{get_value, update_value}&lt;/code&gt;, the return value of this callback should be &lt;code&gt;{get_value, new_data}&lt;/code&gt;, where:</source>
          <target state="translated">Если переданная функция возвращает &lt;code&gt;{get_value, update_value}&lt;/code&gt; , возвращаемое значение этого обратного вызова должно быть &lt;code&gt;{get_value, new_data}&lt;/code&gt; , где:</target>
        </trans-unit>
        <trans-unit id="a2143e7239fbfa87b876c6cf2de6756de08ffc64" translate="yes" xml:space="preserve">
          <source>If the query has a limit, offset or distinct set, it will be automatically wrapped in a subquery in order to return the proper result.</source>
          <target state="translated">Если запрос имеет ограничение,смещение или отдельный набор,он будет автоматически обернут в подзапрос,чтобы вернуть правильный результат.</target>
        </trans-unit>
        <trans-unit id="7d2bddb6cc8d18143b43f8bbafcae7867ac58bcf" translate="yes" xml:space="preserve">
          <source>If the relationship is a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; and the key is set in the given struct, the key will automatically be set in the built association:</source>
          <target state="translated">Если отношение - &lt;code&gt;has_one&lt;/code&gt; или &lt;code&gt;has_many&lt;/code&gt; , и ключ установлен в данной структуре, ключ будет автоматически установлен в построенной ассоциации:</target>
        </trans-unit>
        <trans-unit id="fc8c910d7e1f4a7ca500d332206b3b56b62dcdd3" translate="yes" xml:space="preserve">
          <source>If the relationship is a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; and the primary key is set in the parent struct, the key will automatically be set in the built association:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ab972c154c21dacb18a792e2b9de9b778294e4" translate="yes" xml:space="preserve">
          <source>If the request contains a &quot;_format&quot; parameter, it is considered to be the format desired by the client. If no &quot;_format&quot; parameter is available, this function will parse the &quot;accept&quot; header and find a matching format accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589c270364db1b0108ce43960e91be264009debe" translate="yes" xml:space="preserve">
          <source>If the request contains a &amp;ldquo;_format&amp;rdquo; parameter, it is considered to be the format desired by the client. If no &amp;ldquo;_format&amp;rdquo; parameter is available, this function will parse the &amp;ldquo;accept&amp;rdquo; header and find a matching format accordingly.</source>
          <target state="translated">Если запрос содержит параметр &amp;laquo;_format&amp;raquo;, он считается форматом, желаемым клиентом. Если параметр &amp;laquo;_format&amp;raquo; недоступен, эта функция проанализирует заголовок &amp;laquo;accept&amp;raquo; и найдет соответствующий формат.</target>
        </trans-unit>
        <trans-unit id="c173a238b103f05715b98fa0448f517f74ccec4e" translate="yes" xml:space="preserve">
          <source>If the request has method &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt;, the adapter should not send the response to the client.</source>
          <target state="translated">Если запрос имеет метод &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt; , адаптер не должен отправлять ответ клиенту.</target>
        </trans-unit>
        <trans-unit id="d45df81e2caa272cbf84dfebf38c8aa28609010e" translate="yes" xml:space="preserve">
          <source>If the route contains glob-like patterns, parameters for those have to be given as list:</source>
          <target state="translated">Если маршрут содержит глобусоподобные шаблоны,параметры для них должны быть заданы в виде списка:</target>
        </trans-unit>
        <trans-unit id="2bf5da11b58dcf3690804466cd69ea5e5e4dca07" translate="yes" xml:space="preserve">
          <source>If the same source is selected multiple times with a &lt;code&gt;map&lt;/code&gt;, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</source>
          <target state="translated">Если один и тот же источник выбран несколько раз с помощью &lt;code&gt;map&lt;/code&gt; , поля объединяются, чтобы избежать получения нескольких копий из базы данных. Другими словами, выражение ниже:</target>
        </trans-unit>
        <trans-unit id="652e9d42a43e2b8d5dcd0218df8782089064b141" translate="yes" xml:space="preserve">
          <source>If the same source is selected multiple times with a &lt;code&gt;struct&lt;/code&gt;, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</source>
          <target state="translated">Если один и тот же источник выбран несколько раз с помощью &lt;code&gt;struct&lt;/code&gt; , поля объединяются, чтобы избежать получения нескольких копий из базы данных. Другими словами, выражение ниже:</target>
        </trans-unit>
        <trans-unit id="52eb3cdb7cd07fea24cf8899ccfeee45fa44e2fe" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it&amp;rsquo;ll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security by default.</source>
          <target state="translated">Если схема запроса - &lt;code&gt;https&lt;/code&gt; , он добавит заголовок &lt;code&gt;strict-transport-security&lt;/code&gt; для включения HTTP Strict Transport Security по умолчанию.</target>
        </trans-unit>
        <trans-unit id="564b33d47ddc46edcbbb5f1d39d5ab6ae21f5998" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it&amp;rsquo;ll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security.</source>
          <target state="translated">Если схема запроса - &lt;code&gt;https&lt;/code&gt; , он добавит заголовок &lt;code&gt;strict-transport-security&lt;/code&gt; , чтобы включить HTTP Strict Transport Security.</target>
        </trans-unit>
        <trans-unit id="8ce0178df9065e1071126bd4051a90d7aa5fa061" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it'll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e40997d2cab9139afd7b3e62e6c58a9b6923fe9" translate="yes" xml:space="preserve">
          <source>If the session has already been initialized, the new contents will be merged with the previous ones.</source>
          <target state="translated">Если сессия уже инициализирована,то новое содержимое будет объединено с предыдущим.</target>
        </trans-unit>
        <trans-unit id="187932693c763b03306b32e57e7c13cda06351fc" translate="yes" xml:space="preserve">
          <source>If the struct cannot be found, &lt;a href=&quot;ecto.staleentryerror&quot;&gt;&lt;code&gt;Ecto.StaleEntryError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ac87da8864e486a5dadb087a7c2632f82b5234" translate="yes" xml:space="preserve">
          <source>If the struct has no primary key, &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt;&lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">Если структура не имеет первичного ключа, будет &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt; &lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8767938851ade63a15afc91119604f0839e7344" translate="yes" xml:space="preserve">
          <source>If the struct has no primary key, &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt;&lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt;&lt;/a&gt; will be raised. If the struct has been removed from db prior to call, &lt;a href=&quot;ecto.staleentryerror&quot;&gt;&lt;code&gt;Ecto.StaleEntryError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">Если структура не имеет первичного ключа, будет &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt; &lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt; &lt;/a&gt; . Если структура была удалена из &lt;a href=&quot;ecto.staleentryerror&quot;&gt; &lt;code&gt;Ecto.StaleEntryError&lt;/code&gt; &lt;/a&gt; до вызова, будет вызвана ошибка Ecto.StaleEntryError .</target>
        </trans-unit>
        <trans-unit id="e5578acf03166a21322dd600d9a66efef5d73e58" translate="yes" xml:space="preserve">
          <source>If the underlying input type is a &lt;code&gt;:text_field&lt;/code&gt;, a mapping could be given to further inflect the input type based solely on the field name. The default mapping is:</source>
          <target state="translated">Если базовым типом ввода является &lt;code&gt;:text_field&lt;/code&gt; , можно задать отображение для дальнейшего изменения типа ввода исключительно на основе имени поля. Отображение по умолчанию:</target>
        </trans-unit>
        <trans-unit id="41a1e50f02aaf223bea1728ac3e4f595a0d0fbc9" translate="yes" xml:space="preserve">
          <source>If the value of a field is &lt;code&gt;nil&lt;/code&gt; or a string made only of whitespace, the changeset is marked as invalid, the field is removed from the changeset&amp;rsquo;s changes, and an error is added. Note the error won&amp;rsquo;t be added though if the field already has an error.</source>
          <target state="translated">Если значение поля равно &lt;code&gt;nil&lt;/code&gt; или строка состоит только из пробелов, набор изменений помечается как недопустимый, поле удаляется из изменений набора изменений и добавляется ошибка. Обратите внимание, что ошибка не будет добавлена, если в поле уже есть ошибка.</target>
        </trans-unit>
        <trans-unit id="b51a8cfa4d0487afe8257855e71b56a122faf53b" translate="yes" xml:space="preserve">
          <source>If the value of a field is &lt;code&gt;nil&lt;/code&gt; or a string made only of whitespace, the changeset is marked as invalid, the field is removed from the changeset's changes, and an error is added. An error won't be added if the field already has an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccfc8db638f1f1620ef7b8abebc9015b4310b64a" translate="yes" xml:space="preserve">
          <source>If there is an associated child with an ID and its ID is not given as parameter, the &lt;code&gt;:on_replace&lt;/code&gt; callback for that association will be invoked (see the &quot;On replace&quot; section on the module documentation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc5b56a27b8e1d0d4212e390ddd5e71de7e4d2d" translate="yes" xml:space="preserve">
          <source>If there is an associated child with an ID and its ID is not given as parameter, the &lt;code&gt;:on_replace&lt;/code&gt; callback for that association will be invoked (see the &amp;ldquo;On replace&amp;rdquo; section on the module documentation)</source>
          <target state="translated">Если есть связанный дочерний &lt;code&gt;:on_replace&lt;/code&gt; с идентификатором и его идентификатор не указан в качестве параметра, будет вызван обратный вызов : on_replace для этой связи (см. Раздел &amp;laquo;При замене&amp;raquo; в документации модуля)</target>
        </trans-unit>
        <trans-unit id="3027f8dce56af2e1b89a3dcdf3f1ecf46fe576f2" translate="yes" xml:space="preserve">
          <source>If there is no English translation for the post, the untranslated post &lt;code&gt;title&lt;/code&gt; will be returned and &lt;code&gt;summary&lt;/code&gt; will be &lt;code&gt;nil&lt;/code&gt;. If there is, both &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;summary&lt;/code&gt; will be the value from &lt;code&gt;Post.Translation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1a377354e3a0de11df4acec5746a31c120d5d3" translate="yes" xml:space="preserve">
          <source>If there is no such row, instead return default (which must be of the same type as value). Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d83351b5a78845c987b433bc2606bd08dbd349" translate="yes" xml:space="preserve">
          <source>If we again visit &lt;code&gt;/hello/Frank&lt;/code&gt; in the browser, we should see a block of JSON with the key &lt;code&gt;id&lt;/code&gt; mapped to the string &lt;code&gt;&quot;Frank&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55899f5bba3bae6ddb4b8c3a53a4536e1c0110c" translate="yes" xml:space="preserve">
          <source>If we also have a requirement for the maximum length that a bio can have, we can simply add another validation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43f96c979a225b950bb4dfa9a208756fcb9cd93" translate="yes" xml:space="preserve">
          <source>If we are about to create a new application, configuring our application to use MySQL is easy. We can simply pass the &lt;code&gt;--database mysql&lt;/code&gt; flag to &lt;code&gt;phx.new&lt;/code&gt; and everything will be configured correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbca676064b2672228b8d404db61ea01e7b418d" translate="yes" xml:space="preserve">
          <source>If we are terminating because the client left, the reason will be &lt;code&gt;{:shutdown, :left}&lt;/code&gt;. Similarly, if we are terminating because the client connection was closed, the reason will be &lt;code&gt;{:shutdown, :closed}&lt;/code&gt;.</source>
          <target state="translated">Если мы завершаем работу, потому что клиент ушел, причина будет &lt;code&gt;{:shutdown, :left}&lt;/code&gt; . Точно так же, если мы завершаем работу из-за закрытия клиентского соединения, причиной будет &lt;code&gt;{:shutdown, :closed}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f294c1cc2eca5e08e950254d2b15770ecc60ce6" translate="yes" xml:space="preserve">
          <source>If we care to, we can open up our developer tools, click on the network tab, and visit our root route again. We see two main requests for this page - a get to &lt;code&gt;/&lt;/code&gt; with a status of &lt;code&gt;302&lt;/code&gt;, and a get to &lt;code&gt;/redirect_test&lt;/code&gt; with a status of &lt;code&gt;200&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef5847801c77dfd9829f943c4a44ef415cbf4af" translate="yes" xml:space="preserve">
          <source>If we choose not to have Phoenix install our dependencies when we generate a new application, the &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; task will prompt us to take the necessary steps when we do want to install them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="083bd2611232c5afdab8b58c40dae911b3992cc4" translate="yes" xml:space="preserve">
          <source>If we do duplicate a route, we'll get this familiar warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c2a428049c971561e33683903cb91fda071a38" translate="yes" xml:space="preserve">
          <source>If we don't feel that we need all of these routes, we can be selective using the &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; options to filter certain actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b148b617e87c3d7cf1bf0c454fb60e53b8088cca" translate="yes" xml:space="preserve">
          <source>If we don't have any static assets, or we want to use another build tool, we can pass the &lt;code&gt;--no-webpack&lt;/code&gt; flag when creating a new application and node won't be required at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce90215702773251bdd42373866333197e1b5cb" translate="yes" xml:space="preserve">
          <source>If we don't need a complete HTML/JSON resource and are not interested in generating or altering a context we can use the &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt;&lt;code&gt;mix phx.gen.schema&lt;/code&gt;&lt;/a&gt; task. It will generate a schema, and a migration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391120460ffbf26e5eb0e6249f59b60800a1272f" translate="yes" xml:space="preserve">
          <source>If we don't need a complete HTML/JSON resource and instead are only interested in a context, we can use the &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt;&lt;code&gt;mix phx.gen.context&lt;/code&gt;&lt;/a&gt; task. It will generate a context, a schema, a migration and a test case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0325343ecff8ab2b1c281d1f5eb03e5e5a1f542c" translate="yes" xml:space="preserve">
          <source>If we don't specify a router for this task, it will default to the router Phoenix generated for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbc243df3c98e3ec94e3d2cceb1fad20c911551" translate="yes" xml:space="preserve">
          <source>If we don't want to create a context or schema for our resource we can use the &lt;code&gt;--no-context&lt;/code&gt; flag. Note that this still requires a context module name as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202b483bde361859fe3d989c4fc41024ae857693" translate="yes" xml:space="preserve">
          <source>If we follow the &quot;Back&quot; link, we get a list of all users, which should contain the one we just created. Likewise, we can update this record or delete it. Now that we've seen how it works in the browser, it's time to take a look at the generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8cdc4c30930a9f92ef3229c041981125e1295ee" translate="yes" xml:space="preserve">
          <source>If we go to &lt;a href=&quot;http://localhost:4000/?_format=text&quot;&gt;&lt;code&gt;http://localhost:4000/?_format=text&lt;/code&gt;&lt;/a&gt;, we will see &quot;OMG, this is actually some text.&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cbeea3cdf6c8b4aae44fc28787ce47be0b89ac2" translate="yes" xml:space="preserve">
          <source>If we had aliased the &lt;code&gt;Helpers&lt;/code&gt; module as before (it is only automatically aliased for views, templates and controllers, in this case, since we're inside &lt;code&gt;iex&lt;/code&gt; we need to do it ourselves), we could instead do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd17028a95f476ab737ed8720e1d0211a3a7561" translate="yes" xml:space="preserve">
          <source>If we happen to have another repo that we want to drop the database for, we can specify it with the &lt;code&gt;-r&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7e68839f0a87f7d3b692b54aa39ae82f91218c" translate="yes" xml:space="preserve">
          <source>If we have an existing application, all we need to do is switch adapters and make some small configuration changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658d3ae57e71f3341641eb3949711018592d2d1b" translate="yes" xml:space="preserve">
          <source>If we have an existing configuration block for our &lt;code&gt;HelloPhoenix.Repo&lt;/code&gt;, we can simply change the values to match our new ones. You also need to configure the correct values in the &lt;code&gt;config/test.exs&lt;/code&gt; and &lt;code&gt;config/prod.secret.exs&lt;/code&gt; files as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="963fb6aba8a7d7a559054bec03ba9d17da20b6ff" translate="yes" xml:space="preserve">
          <source>If we have just installed Elixir for the first time, we will need to install the Hex package manager as well. Hex is necessary to get a Phoenix app running (by installing dependencies) and to install any extra dependencies we might need along the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5daa84ed51f538f1246f7583c53daad14892bab5" translate="yes" xml:space="preserve">
          <source>If we log in to our database server, and connect to our &lt;code&gt;hello_dev&lt;/code&gt; database, we should see our &lt;code&gt;users&lt;/code&gt; table. Ecto assumes that we want an integer column called &lt;code&gt;id&lt;/code&gt; as our primary key, so we should see a sequence generated for that as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad55a2d89bb2b694326401b2e1b3ac0d3a25512" translate="yes" xml:space="preserve">
          <source>If we name our repo &lt;code&gt;OurCustom.Repo&lt;/code&gt;, this task will create it here &lt;code&gt;lib/our_custom/repo.ex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410aa46a3f58fdfb55c933dc63ac4ff7560f52cf" translate="yes" xml:space="preserve">
          <source>If we need only the rendered string, without the whole tuple, we can use &lt;code&gt;render_to_string/3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67cebfdb55f59c0c40bdafd0841173e71de24d6" translate="yes" xml:space="preserve">
          <source>If we need to pass values into the template when using &lt;code&gt;render&lt;/code&gt;, that's easy. We can pass a keyword like we've seen with &lt;code&gt;messenger: messenger&lt;/code&gt;, or we can use &lt;a href=&quot;../plug/plug.conn#assign/3&quot;&gt;&lt;code&gt;Plug.Conn.assign/3&lt;/code&gt;&lt;/a&gt;, which conveniently returns &lt;code&gt;conn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0c2ddb5903057e2b6c4bf63e6d7df23b45687f" translate="yes" xml:space="preserve">
          <source>If we open up the &lt;code&gt;User&lt;/code&gt; schema in &lt;code&gt;lib/hello/accounts/user.ex&lt;/code&gt;, it will look immediately familiar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c00f799ed099e309e29da91ee4bd50186d484b2" translate="yes" xml:space="preserve">
          <source>If we require a &lt;code&gt;CMS.Author&lt;/code&gt; to exist every time an &lt;code&gt;Accounts.User&lt;/code&gt; is created, we have to think carefully where to place this dependency. We know our &lt;code&gt;CMS&lt;/code&gt; context depends on the &lt;code&gt;Accounts&lt;/code&gt; context, but it's important to avoid cyclic dependencies across our contexts. For example, imagine we changed our &lt;code&gt;Accounts.create_user&lt;/code&gt; function to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cccbba4146b36292bb913e1fd8ea1a975c343691" translate="yes" xml:space="preserve">
          <source>If we take a look at the migration generated by &lt;code&gt;phx.gen.schema&lt;/code&gt; in &lt;code&gt;priv/repo/migrations&lt;/code&gt;, we'll see that it will add the columns we specified. It will also add timestamp columns for &lt;code&gt;inserted_at&lt;/code&gt; and &lt;code&gt;updated_at&lt;/code&gt; which come from the &lt;code&gt;timestamps/0&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed57a6e9786d7b1c5f997cd519a04906343aa29" translate="yes" xml:space="preserve">
          <source>If we try to cast a user with an email of &quot;example.com&quot;, we should see an error message like the following.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffce6ccf0c01a85d91a8e6ee8f35c6af010a9b1" translate="yes" xml:space="preserve">
          <source>If we wanted to render an xml version of our &lt;code&gt;index&lt;/code&gt; action, we might implement the action like this in &lt;code&gt;lib/hello_web/page_controller.ex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091f04a57770ee0cadc0f3ebc7f970845f788a49" translate="yes" xml:space="preserve">
          <source>If we wanted to return some actions for an &lt;code&gt;MyApp.SomethingNotFoundError&lt;/code&gt; we would implement &lt;a href=&quot;../plug/plug.exception&quot;&gt;&lt;code&gt;Plug.Exception&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3edc855d2066cbc7b5c91623476090fb897ebf1" translate="yes" xml:space="preserve">
          <source>If we wanted to supply a status of 404 for an &lt;code&gt;MyApp.SomethingNotFoundError&lt;/code&gt;, we could do it by defining an implementation for the &lt;a href=&quot;../plug/plug.exception&quot;&gt;&lt;code&gt;Plug.Exception&lt;/code&gt;&lt;/a&gt; protocol like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87783d963f44ae589c50340ce6d86a8678d3af09" translate="yes" xml:space="preserve">
          <source>If we would like to be really specific about the content type, we can use &lt;code&gt;put_resp_content_type/2&lt;/code&gt; in conjunction with &lt;code&gt;send_resp/3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f54692a2228f2c183323a64714165cbc33696b0" translate="yes" xml:space="preserve">
          <source>If we would like to start our application and also have an &lt;code&gt;iex&lt;/code&gt; session open to it, we can run the mix task within &lt;code&gt;iex&lt;/code&gt; like this, &lt;code&gt;iex -S mix phx.server&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56a37255e0b43c2392f533494036f18e8e066b4" translate="yes" xml:space="preserve">
          <source>If you access these fields before fetching them, they will be returned as &lt;a href=&quot;plug.conn.unfetched&quot;&gt;&lt;code&gt;Plug.Conn.Unfetched&lt;/code&gt;&lt;/a&gt; structs.</source>
          <target state="translated">Если вы получите доступ к этим полям до их выборки, они будут возвращены как структуры &lt;a href=&quot;plug.conn.unfetched&quot;&gt; &lt;code&gt;Plug.Conn.Unfetched&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b68cb6ad948ac353881b8951cfd579c0c0ee1df4" translate="yes" xml:space="preserve">
          <source>If you already have a model, the generated model can be skipped with &lt;code&gt;--no-model&lt;/code&gt;. Read the documentation for &lt;code&gt;phoenix.gen.model&lt;/code&gt; for more information on attributes and namespaced resources.</source>
          <target state="translated">Если у вас уже есть модель, ее можно пропустить с помощью &lt;code&gt;--no-model&lt;/code&gt; . Прочтите документацию для &lt;code&gt;phoenix.gen.model&lt;/code&gt; для получения дополнительной информации об атрибутах и ​​ресурсах с именами .</target>
        </trans-unit>
        <trans-unit id="7ff739bec2c4393b5a6029990ea9ff518a68f23c" translate="yes" xml:space="preserve">
          <source>If you also want to send the response, use &lt;a href=&quot;#send_resp/1&quot;&gt;&lt;code&gt;send_resp/1&lt;/code&gt;&lt;/a&gt; after this or use &lt;a href=&quot;#send_resp/3&quot;&gt;&lt;code&gt;send_resp/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы также хотите отправить ответ, используйте &lt;a href=&quot;#send_resp/1&quot;&gt; &lt;code&gt;send_resp/1&lt;/code&gt; &lt;/a&gt; после этого или используйте &lt;a href=&quot;#send_resp/3&quot;&gt; &lt;code&gt;send_resp/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87f449e6752144346e8d0a47354146bcb5ebd1b4" translate="yes" xml:space="preserve">
          <source>If you are already familiar with Elixir, great! If not, there are a number of places to learn. The &lt;a href=&quot;https://elixir-lang.org/getting-started/introduction.html&quot;&gt;Elixir guides&lt;/a&gt; and the &lt;a href=&quot;https://elixir-lang.org/learning.html&quot;&gt;Elixir learning resources page&lt;/a&gt; are two great places to start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15c68af7f32e113d1ad81becc24e17ccf8d3c73" translate="yes" xml:space="preserve">
          <source>If you are coming from an older version of Phoenix, install the &lt;code&gt;:telemetry_metrics&lt;/code&gt; and &lt;code&gt;:telemetry_poller&lt;/code&gt; packages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195b289a7ef348736fb993f011aeccf45570b4ce" translate="yes" xml:space="preserve">
          <source>If you are comparing the username and password with existing strings, do not use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.html#secure_compare/2&quot;&gt;&lt;code&gt;Plug.Crypto.secure_compare/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660ef0380c716ac22c9348212079d101dfdf7227" translate="yes" xml:space="preserve">
          <source>If you are pushing events from a hook to a component, then you must pass an &lt;code&gt;element&lt;/code&gt;, created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt;, as first argument and it must point to a single element on the page with a &lt;code&gt;phx-target&lt;/code&gt; attribute in it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1445ed0a8505a52f1fc2ab343b225750d1c7d54" translate="yes" xml:space="preserve">
          <source>If you are seeing this error, you should check if you are listing the desired formats in your &lt;code&gt;:accepts&lt;/code&gt; plug or if you are setting the proper accept header in the client. The exception contains the acceptable mime types in the &lt;code&gt;accepts&lt;/code&gt; field.</source>
          <target state="translated">Если вы видите эту ошибку, вам следует проверить, указываете ли вы желаемые форматы в своем плагине &lt;code&gt;:accepts&lt;/code&gt; accept или устанавливаете ли вы правильный заголовок accept в клиенте. Исключение содержит допустимые типы mime в поле &lt;code&gt;accepts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8befb119931680b815f371783bc72db7f010ea28" translate="yes" xml:space="preserve">
          <source>If you are seeing this error, you should handle the error and surface it to the end user. It means that there is a parameter missing from the request.</source>
          <target state="translated">Если вы видите эту ошибку,вы должны обработать ее и вывести на поверхность конечного пользователя.Это означает,что в запросе отсутствует параметр.</target>
        </trans-unit>
        <trans-unit id="8281d3b702b25fc319af701ce0fe42f100d16669" translate="yes" xml:space="preserve">
          <source>If you are sending data to a full URI, such as &lt;code&gt;//subdomain.host.com/path&lt;/code&gt; or &lt;code&gt;//external.com/path&lt;/code&gt;, instead of a simple path such as &lt;code&gt;/path&lt;/code&gt;, you may want to consider using &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt;&lt;code&gt;get_csrf_token_for/1&lt;/code&gt;&lt;/a&gt;, as that will encode the host in the CSRF token. Once received, Plug will only consider the CSRF token to be valid if the &lt;code&gt;host&lt;/code&gt; encoded in the token is the same as the one in &lt;code&gt;conn.host&lt;/code&gt;.</source>
          <target state="translated">Если вы отправляете данные на полный URI, такой как &lt;code&gt;//subdomain.host.com/path&lt;/code&gt; или &lt;code&gt;//external.com/path&lt;/code&gt; , вместо простого пути, такого как &lt;code&gt;/path&lt;/code&gt; , вы можете рассмотреть возможность использования &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt; &lt;code&gt;get_csrf_token_for/1&lt;/code&gt; &lt;/a&gt; , поскольку это будет кодировать хост в токене CSRF. После получения Plug будет рассматривать токен CSRF как действительный, только если &lt;code&gt;host&lt;/code&gt; закодированный в токене, совпадает с &lt;code&gt;conn.host&lt;/code&gt; в conn.host .</target>
        </trans-unit>
        <trans-unit id="2860b8a98014af24457d97de2b8635d54397f121" translate="yes" xml:space="preserve">
          <source>If you are trying to debug transaction-related code while using &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt;, it may be more helpful to configure the database to log all statements and consult those logs.</source>
          <target state="translated">Если вы пытаетесь отлаживать код, связанный с &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; , при использовании Ecto.Adapters.SQL.Sandbox , может быть более полезным настроить базу данных для регистрации всех операторов и просмотра этих журналов.</target>
        </trans-unit>
        <trans-unit id="f57bf68c621982c91acd9cc4e5332c480370b66a" translate="yes" xml:space="preserve">
          <source>If you are using Phoenix v1.5, the layout is automatically set when generating apps with the &lt;code&gt;mix phx.new --live&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d8aab708f551e6ce45eaa04e632f244694f2e5f" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; in tests, note that even though each test is inside a transaction, &lt;code&gt;in_transaction?/0&lt;/code&gt; will only return true inside transactions explicitly created with &lt;code&gt;transaction/2&lt;/code&gt;. This is done so the test environment mimics dev and prod.</source>
          <target state="translated">Если вы используете &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; в тестах, обратите внимание, что даже если каждый тест находится внутри транзакции, &lt;code&gt;in_transaction?/0&lt;/code&gt; вернет true только внутри транзакций, явно созданных с помощью &lt;code&gt;transaction/2&lt;/code&gt; . Это сделано для того, чтобы тестовая среда имитировала dev и prod.</target>
        </trans-unit>
        <trans-unit id="942638ba1572b805045a6efb9c529e7e1a50d20b" translate="yes" xml:space="preserve">
          <source>If you attempt to remove associated &lt;code&gt;many_to_many&lt;/code&gt; data, &lt;strong&gt;Ecto will always remove data from the join schema and never from the target associations&lt;/strong&gt; be it by setting &lt;code&gt;:on_replace&lt;/code&gt; to &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; or by using changeset functions such as &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt;&lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt;&lt;/a&gt;. For example, if a &lt;code&gt;Post&lt;/code&gt; has a many to many relationship with &lt;code&gt;Tag&lt;/code&gt;, setting &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; will only delete entries from the &quot;posts_tags&quot; table in case &lt;code&gt;Post&lt;/code&gt; is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3cbaa656dba938c685add2656722d0e125f277" translate="yes" xml:space="preserve">
          <source>If you attempt to remove associated &lt;code&gt;many_to_many&lt;/code&gt; data, &lt;strong&gt;Ecto will always remove data from the join schema and never from the target associations&lt;/strong&gt; be it by setting &lt;code&gt;:on_replace&lt;/code&gt; to &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; or by using changeset functions such as &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt;&lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt;&lt;/a&gt;. For example, if a &lt;code&gt;Post&lt;/code&gt; has a many to many relationship with &lt;code&gt;Tag&lt;/code&gt;, setting &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; will only delete entries from the &amp;ldquo;posts_tags&amp;rdquo; table in case &lt;code&gt;Post&lt;/code&gt; is deleted.</source>
          <target state="translated">При попытке удалить связанные &lt;code&gt;many_to_many&lt;/code&gt; данных, &lt;strong&gt;Ecto всегда будет удалять данные из объединения схемы и никогда от целевых ассоциаций&lt;/strong&gt; будь то настройка &lt;code&gt;:on_replace&lt;/code&gt; для &lt;code&gt;:delete&lt;/code&gt; , &lt;code&gt;:on_delete&lt;/code&gt; к &lt;code&gt;:delete_all&lt;/code&gt; или с помощью функции набора изменений , таких как &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt; &lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt; &lt;/a&gt; . Например, если &lt;code&gt;Post&lt;/code&gt; имеет отношения многие ко многим с &lt;code&gt;Tag&lt;/code&gt; , настройка &lt;code&gt;:on_delete&lt;/code&gt; в &lt;code&gt;:delete_all&lt;/code&gt; будет только удалять записи из таблицы &amp;laquo;posts_tags&amp;raquo; в случае &lt;code&gt;Post&lt;/code&gt; будет удалено.</target>
        </trans-unit>
        <trans-unit id="33aeade4ec4114f6d64f05c0e4ded54c69c06049" translate="yes" xml:space="preserve">
          <source>If you attempt to write it as &lt;code&gt;where: p.id in ^subquery(foo)&lt;/code&gt;, Ecto won&amp;rsquo;t accept such query. However, the subquery above can be written as a JOIN, which is supported by Ecto. The final Ecto query will look like this:</source>
          <target state="translated">Если вы попытаетесь записать его как &lt;code&gt;where: p.id in ^subquery(foo)&lt;/code&gt; , Ecto не примет такой запрос. Однако приведенный выше подзапрос можно записать как JOIN, который поддерживается Ecto. Окончательный запрос Ecto будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="8aa7e8b7dfaa8e37915423085e7692433a23800a" translate="yes" xml:space="preserve">
          <source>If you decide to include the live-reload websocket, you should disable it when building for production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de03b9d15dfe67c307158582293c4bcac372860e" translate="yes" xml:space="preserve">
          <source>If you do that, because &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; is called once and &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt; multiple times, the &quot;post_id&quot; read on mount can get out of sync with the one in &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt;. So once a parameter is read on mount, it should not be read elsewhere. Instead, do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09cb3a84985c7f8fa4e8edcaba166f48f945bf96" translate="yes" xml:space="preserve">
          <source>If you don't have any Ecto schema pointing to the CTE table, you can pass a tuple with the CTE table name as first element and an Ecto schema as second element. This will cast the result rows to Ecto structs as long as the Ecto schema maps to the same fields in the CTE table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9c05c4fa4c6e476b09d8bdf327b4c5f082461f" translate="yes" xml:space="preserve">
          <source>If you find yourself in similar situations where you feel your use case is requiring you to create circular dependencies across contexts, it's a sign you need a new context in the system to handle these application requirements. In our case, what we really want is an interface that handles all requirements when a user is created or registers in our application. To handle this, we could create a &lt;code&gt;UserRegistration&lt;/code&gt; context, which calls into both the &lt;code&gt;Accounts&lt;/code&gt; and &lt;code&gt;CMS&lt;/code&gt; APIs to create a user, then associate a CMS author. Not only would this allow our Accounts to remain as isolated as possible, it gives us a clear, obvious API to handle &lt;code&gt;UserRegistration&lt;/code&gt; needs in the system. If you take this approach, you can also use tools like &lt;code&gt;Ecto.Multi&lt;/code&gt; to handle transactions across different context operations without deeply coupling the internal database calls. Part of our &lt;code&gt;UserRegistration&lt;/code&gt; API could look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6574eccc770115f525bad9e622976b6b343b2538" translate="yes" xml:space="preserve">
          <source>If you followed the &lt;a href=&quot;installation&quot;&gt;Installation Guide&lt;/a&gt; and opted to add &lt;code&gt;{:cowboy, &quot;~&amp;gt; 2.7.0&quot;}&lt;/code&gt; to your mix.exs, go ahead and do that now and run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9d40fe35c9851f255cc70728d792053cc95002" translate="yes" xml:space="preserve">
          <source>If you had previously installed &lt;code&gt;phoenix_live_view&lt;/code&gt; and want to get the latest javascript, then force an install with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415aa01085c0f6d5805f0753fe7636a79914ccaf" translate="yes" xml:space="preserve">
          <source>If you have a session but the CSRF state was not loaded into the current process, you can dump the state from the session:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e22a5ad3894018fe1345caf74da853417ec2369" translate="yes" xml:space="preserve">
          <source>If you have a single username and password, you can use the &lt;a href=&quot;#basic_auth/2&quot;&gt;&lt;code&gt;basic_auth/2&lt;/code&gt;&lt;/a&gt; plug:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce78534925c37d789d5976c765183ee7b5d0b56" translate="yes" xml:space="preserve">
          <source>If you keep components mostly as an application concern with only the necessary assigns, it is unlikely you will run into issues related to stateful components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c0fdbca7cff696f9dab2f2e658e9f4fc49ebd8" translate="yes" xml:space="preserve">
          <source>If you need an escape hatch, Ecto provides fragments (see &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt;&lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt;&lt;/a&gt;) to inject SQL (and non-SQL) fragments into queries.</source>
          <target state="translated">Если вам нужен аварийный люк, Ecto предоставляет фрагменты (см. &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt; &lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt; &lt;/a&gt; ) для вставки фрагментов SQL (и не-SQL) в запросы.</target>
        </trans-unit>
        <trans-unit id="cf93aee615b214a79ea7379cb001c9b4d45fa541" translate="yes" xml:space="preserve">
          <source>If you need custom metrics and instrumentation in your application, you can utilize the &lt;code&gt;:telemetry&lt;/code&gt; package (&lt;a href=&quot;https://hexdocs.pm/telemetry&quot;&gt;https://hexdocs.pm/telemetry&lt;/a&gt;) just like your favorite frameworks and libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ecb1e3f8dbc11e08115c78cf6e2d60dbd4aefe" translate="yes" xml:space="preserve">
          <source>If you need custom options on the underlying field, you can define the field explicitly and then pass &lt;code&gt;define_field: false&lt;/code&gt; to &lt;code&gt;belongs_to&lt;/code&gt;:</source>
          <target state="translated">Если вам нужны настраиваемые параметры в базовом поле, вы можете явно определить поле, а затем передать &lt;code&gt;define_field: false&lt;/code&gt; в &lt;code&gt;belongs_to&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bd51ff6183de690e100505fa4969b12d1551fa2a" translate="yes" xml:space="preserve">
          <source>If you need to dynamically configure how &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Parsers.MULTIPART&lt;/code&gt;&lt;/a&gt; behave, for example, based on the connection or another system parameter, one option is to create your own parser that wraps it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109f5082f2f1b912050b16bb98f4693eba354f1f" translate="yes" xml:space="preserve">
          <source>If you need to guarantee the data in the returned struct mirrors the database, you have three options:</source>
          <target state="translated">Если вам нужно гарантировать данные в возвращаемых структурах зеркал базы данных,у вас есть три варианта:</target>
        </trans-unit>
        <trans-unit id="2e2431436833d547a4e531dda09290f8abafed68" translate="yes" xml:space="preserve">
          <source>If you need to pass any extra values or metadata, such as the &quot;_target&quot; parameter, you can do so by giving a map under the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e668d17ae58bad2b61910c084478c158d0fe3170" translate="yes" xml:space="preserve">
          <source>If you prefer, you can also send a JavaScript script that immediately reloads the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afadb98b6e75520436d2c696ca1b6f38804339a" translate="yes" xml:space="preserve">
          <source>If you visit the Welcome page, you should see the message from the layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6194c95c25393c1533f24ca690885ddce3de29a4" translate="yes" xml:space="preserve">
          <source>If you want a map with only the selected fields to be returned. For more information, read the docs for &lt;a href=&quot;ecto.query.api#struct/2&quot;&gt;&lt;code&gt;Ecto.Query.API.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ecto.query.api#map/2&quot;&gt;&lt;code&gt;Ecto.Query.API.map/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите вернуть карту только с выбранными полями. Для получения дополнительной информации прочтите документацию по &lt;a href=&quot;ecto.query.api#struct/2&quot;&gt; &lt;code&gt;Ecto.Query.API.struct/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;ecto.query.api#map/2&quot;&gt; &lt;code&gt;Ecto.Query.API.map/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b56c7f334ac00fd6eb86d51a4d425fe63a22845f" translate="yes" xml:space="preserve">
          <source>If you want the boolean attribute to be sent as is, you can explicitly convert it to a string before.</source>
          <target state="translated">Если вы хотите,чтобы булевый атрибут был отправлен как есть,вы можете явным образом преобразовать его в строку до этого.</target>
        </trans-unit>
        <trans-unit id="9a8b342259d40c75d399fa621d7ba14972e56c66" translate="yes" xml:space="preserve">
          <source>If you want the latest features, install from GitHub:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71958648bc2ee1d3c516f077771f912b56470ab5" translate="yes" xml:space="preserve">
          <source>If you want to configure the years range:</source>
          <target state="translated">Если вы хотите настроить диапазон лет:</target>
        </trans-unit>
        <trans-unit id="eaaf4a6e48637b0f1ace60064563e26ec60604dd" translate="yes" xml:space="preserve">
          <source>If you want to do so in a case-by-case basis, you can define a custom function that gets the endpoint URI configuration and changes it accordingly. For example, to get the current URL always in HTTPS format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3267ec97b69bd134a5f100a8b20b7af9c4d6bdb9" translate="yes" xml:space="preserve">
          <source>If you want to have functions that manipulate the connection without fully implementing the controller, you can import both modules directly instead of &lt;code&gt;use Phoenix.Controller&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите иметь функции, которые управляют подключением без полной реализации контроллера, вы можете напрямую импортировать оба модуля вместо &lt;code&gt;use Phoenix.Controller&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e505240a0d781b16ebb52afdcfed3cf74a91017d" translate="yes" xml:space="preserve">
          <source>If you want to include the seconds field (hidden by default), pass &lt;code&gt;second: []&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите включить поле секунд (по умолчанию скрыто), введите &lt;code&gt;second: []&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ebd7ac9e06dec198b102f467e0d5a2146add7ac" translate="yes" xml:space="preserve">
          <source>If you want to instrument a piece of code, but the endpoint that should instrument it (the one that contains the &lt;a href=&quot;#c:instrument/3&quot;&gt;&lt;code&gt;instrument/3&lt;/code&gt;&lt;/a&gt; macro you want to use) is not known at compile time, only at runtime, you can use the &lt;a href=&quot;phoenix.endpoint#instrument/4&quot;&gt;&lt;code&gt;Phoenix.Endpoint.instrument/4&lt;/code&gt;&lt;/a&gt; macro. Refer to its documentation for more information.</source>
          <target state="translated">Если вы хотите инструментировать фрагмент кода, но конечная точка, которая должна его инструментировать (та, которая содержит макрос &lt;a href=&quot;#c:instrument/3&quot;&gt; &lt;code&gt;instrument/3&lt;/code&gt; &lt;/a&gt; вы хотите использовать), неизвестна во время компиляции, только во время выполнения, вы можете использовать &lt;a href=&quot;phoenix.endpoint#instrument/4&quot;&gt; &lt;code&gt;Phoenix.Endpoint.instrument/4&lt;/code&gt; &lt;/a&gt; макрос. Обратитесь к его документации для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="49cb9f6ec274ce3774fca3bdf01b6ff3edaab5ff" translate="yes" xml:space="preserve">
          <source>If you want to make your new mix task to use your application's infrastructure, you need to make sure the application is started when mix task is being executed. This is particularly useful if you need to access your database from within the mix task. Thankfully, mix makes it really easy for us:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18f35976119bb4fe304e144acc1ed9a4b56600a" translate="yes" xml:space="preserve">
          <source>If you want to provide your own authentication logic on top of Basic HTTP auth, you can use the low-level functions. As an example, we define &lt;code&gt;:auth&lt;/code&gt; plug that extracts username and password from the request headers, compares them against the database, and either assigns a &lt;code&gt;:current_user&lt;/code&gt; on success or responds with an error on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec5f40c77fd66ea84bc6ba36f0c2a7c3fe56b0a" translate="yes" xml:space="preserve">
          <source>If you want to quickly check a sample application using Ecto, please check the &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;getting started guide&lt;/a&gt; and the accompanying sample application.</source>
          <target state="translated">Если вы хотите быстро проверить образец приложения с помощью Ecto, ознакомьтесь с &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;руководством по началу работы&lt;/a&gt; и прилагаемым образцом приложения.</target>
        </trans-unit>
        <trans-unit id="c4123984bcd758a7753f404a92fb713daeb010c8" translate="yes" xml:space="preserve">
          <source>If you want to quickly check a sample application using Ecto, please check the &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;getting started guide&lt;/a&gt; and the accompanying sample application. &lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto's README&lt;/a&gt; also links to other resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5268cb204fe6237fdb4702e54e332bbb4778e707" translate="yes" xml:space="preserve">
          <source>If you want to render a template within the same view, you can skip the view name, and simply call &lt;code&gt;render(&quot;test.html&quot;, message: &quot;Hello from sibling template!&quot;)&lt;/code&gt; instead. For example, open up &lt;code&gt;lib/hello_web/templates/page/index.html.eex&lt;/code&gt; and add this at the top:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c050fecd9ef681ce1f0f4d13cfe35bf4a562b4" translate="yes" xml:space="preserve">
          <source>If you want to select an option that comes from the database, such as a manager for a given project, you may write:</source>
          <target state="translated">Если вы хотите выбрать опцию,приходящую из базы данных,например,менеджера для данного проекта,вы можете написать:</target>
        </trans-unit>
        <trans-unit id="752842436fbd52f5e0a837820a12e2cf6d06f8ef" translate="yes" xml:space="preserve">
          <source>If you want to show a progress bar as users perform live actions, we recommend using &lt;a href=&quot;https://github.com/rstacruz/nprogress&quot;&gt;&lt;code&gt;nprogress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da18100304362b3e3927019df152258ff3ba53bb" translate="yes" xml:space="preserve">
          <source>If you want to start a separate LiveView from within a LiveView, then you can call &lt;code&gt;live_render/3&lt;/code&gt; instead of &lt;code&gt;render/3&lt;/code&gt;. This child LiveView runs in a separate process than the parent, with its own &lt;code&gt;mount&lt;/code&gt; and &lt;code&gt;handle_event&lt;/code&gt; callbacks. If a child LiveView crashes, it won't affect the parent. If the parent crashes, all children are terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2240497996f5c5fe18575f06718f0c34d8a4556" translate="yes" xml:space="preserve">
          <source>If you want to support a given engine only on a certain template, you can pass it as an option on &lt;code&gt;use Phoenix.Template&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cdb64fa51ca4fb8866fc361686b367dbcbe98f6" translate="yes" xml:space="preserve">
          <source>If you want to target another component, you can also pass an ID or a class selector to any element inside the targeted component. For example, if there is a &lt;code&gt;UserComponent&lt;/code&gt; with the DOM ID of &lt;code&gt;user-13&lt;/code&gt;, using a query selector, we can send an event to it with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e59309dd05a76fcd32896400f87305ec18e206" translate="yes" xml:space="preserve">
          <source>If you want to test how components are mounted by a LiveView and interact with DOM events, you can use the regular &lt;a href=&quot;#live/2&quot;&gt;&lt;code&gt;live/2&lt;/code&gt;&lt;/a&gt; macro to build the LiveView with the component and then scope events by passing the view and a &lt;strong&gt;DOM selector&lt;/strong&gt; in a list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f98f30cf1d08e9178e85581a80a56cb8d7d157" translate="yes" xml:space="preserve">
          <source>If you would prefer to read these guides as an EPUB &lt;a href=&quot;phoenix.epub&quot;&gt;click here!&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6906d4bf644df48b3f0c419b3abf27f44bf197a2" translate="yes" xml:space="preserve">
          <source>If you would prefer to simply merge two multis together, see &lt;a href=&quot;#append/2&quot;&gt;&lt;code&gt;append/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#prepend/2&quot;&gt;&lt;code&gt;prepend/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы предпочитаете просто объединить два мультимедиа, см. &lt;a href=&quot;#append/2&quot;&gt; &lt;code&gt;append/2&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#prepend/2&quot;&gt; &lt;code&gt;prepend/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2467d576cbf855c8ae9348c4a47fdcb13145270e" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you may need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-*&lt;/code&gt; header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906016b8afe13d5670e52576993026f7d29c208a" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you may need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-*&lt;/code&gt; header. This can be done using the &lt;code&gt;:rewrite_on&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa6a80acbf97635e0ac507b93d5063cd5b0d16a" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you will need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-proto&lt;/code&gt; header. This can be done using the &lt;code&gt;:rewrite_on&lt;/code&gt; option:</source>
          <target state="translated">Если ваше приложение Plug находится за прокси-сервером, который обрабатывает HTTPS, вам необходимо указать Plug, чтобы он проанализировал правильный протокол из заголовка &lt;code&gt;x-forwarded-proto&lt;/code&gt; . Это можно сделать с &lt;code&gt;:rewrite_on&lt;/code&gt; опции: rewrite_on :</target>
        </trans-unit>
        <trans-unit id="4ee22e439b0d72c012e013a54bdd332f454b15e8" translate="yes" xml:space="preserve">
          <source>If your adapter is only able to respond to one or a couple of the query functions, add custom implementations of those functions directly to the Repo by using &lt;a href=&quot;ecto.adapter#c:__before_compile__/1&quot;&gt;&lt;code&gt;Ecto.Adapter.__before_compile__/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ea11ef400e8f5b84f516d039032b014e672598" translate="yes" xml:space="preserve">
          <source>If your application was generated with a supervisor (by passing &lt;code&gt;--sup&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt;) you will have a &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; file containing the application start callback that defines and starts your supervisor. You just need to edit the &lt;code&gt;start/2&lt;/code&gt; function to start the repo as a supervisor on your application's supervisor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64da7625aab0af6dfae19c9bbd8cef653814d79" translate="yes" xml:space="preserve">
          <source>If your application was generated with a supervisor (by passing &lt;code&gt;--sup&lt;/code&gt; to &lt;code&gt;mix new&lt;/code&gt;) you will have a &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; file containing the application start callback that defines and starts your supervisor. You just need to edit the &lt;code&gt;start/2&lt;/code&gt; function to start the repo as a supervisor on your application&amp;rsquo;s supervisor:</source>
          <target state="translated">Если ваше приложение было сгенерировано с супервизором (путем передачи &lt;code&gt;--sup&lt;/code&gt; to &lt;code&gt;mix new&lt;/code&gt; ), у вас будет файл &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; , содержащий обратный вызов запуска приложения, который определяет и запускает вашего супервизора. Вам просто нужно отредактировать функцию &lt;code&gt;start/2&lt;/code&gt; , чтобы запустить репо в качестве супервизора супервизора вашего приложения:</target>
        </trans-unit>
        <trans-unit id="9963b98e0a632c06b03f38938368cd7af1095618" translate="yes" xml:space="preserve">
          <source>If your data layer supports embedding or nested associations, you can use &lt;code&gt;inputs_for&lt;/code&gt; to attach nested data to the form.</source>
          <target state="translated">Если ваш уровень данных поддерживает встраивание или вложенные ассоциации, вы можете использовать &lt;code&gt;inputs_for&lt;/code&gt; для присоединения вложенных данных к форме.</target>
        </trans-unit>
        <trans-unit id="cc3f651a489e53e22ef5bfd5ad5ccb20a85f41ce" translate="yes" xml:space="preserve">
          <source>If your primary key is not named &amp;ldquo;id&amp;rdquo; (e.g. if you are working with a legacy database), you can use the &lt;code&gt;@primary_key&lt;/code&gt; attribute to configure your key name using the &lt;code&gt;source&lt;/code&gt; option. For example, the following attribute defines an integer primary key named &lt;code&gt;legacy_id&lt;/code&gt; which is automatically incremented by the database:</source>
          <target state="translated">Если ваш первичный ключ не называется &amp;laquo;id&amp;raquo; (например, если вы работаете с устаревшей базой данных), вы можете использовать атрибут &lt;code&gt;@primary_key&lt;/code&gt; для настройки имени вашего ключа с помощью параметра &lt;code&gt;source&lt;/code&gt; . Например, следующий атрибут определяет целочисленный первичный ключ с именем &lt;code&gt;legacy_id&lt;/code&gt; , который автоматически увеличивается базой данных:</target>
        </trans-unit>
        <trans-unit id="f30aa9bbf518465faa2ed1f37bfe76b59f3c62b2" translate="yes" xml:space="preserve">
          <source>If your screen looks like the image above, congratulations! You now have a working Phoenix application. In case you can't see the page above, try accessing it via &lt;a href=&quot;http://127.0.0.1:4000&quot;&gt;http://127.0.0.1:4000&lt;/a&gt; and later make sure your OS has defined &quot;localhost&quot; as &quot;127.0.0.1&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c262a06dde1c92c1b642e458f52da921424c961b" translate="yes" xml:space="preserve">
          <source>If your socket is implemented using &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt;, you can also pass to each transport above all options accepted on &lt;code&gt;use Phoenix.Socket&lt;/code&gt;. An option given here will override the value in &lt;code&gt;use Phoenix.Socket&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f718c136252a6132fe7a1aa2ed7beedb600c13" translate="yes" xml:space="preserve">
          <source>If your table is partitioned, then your unique index might look different per partition, e.g. Postgres adds p&amp;lt;number&amp;gt; to the middle of your key, like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a69fedcf99422ab483c859e4efba05a441aa355" translate="yes" xml:space="preserve">
          <source>Imagine a relationship where Post has many comments and you want to add a new comment to an existing post. While it is possible to use &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; for this, it would be unecessarily complex. Let&amp;rsquo;s see an example.</source>
          <target state="translated">Представьте себе отношения, в которых у публикации много комментариев, и вы хотите добавить новый комментарий к существующей публикации. Хотя для этого можно использовать &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; , это было бы слишком сложно. Посмотрим на пример.</target>
        </trans-unit>
        <trans-unit id="b9e00b21da4725e0255aeee1974fcbd6702ec96c" translate="yes" xml:space="preserve">
          <source>Imagine a relationship where Post has many comments and you want to add a new comment to an existing post. While it is possible to use &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; for this, it would be unnecessarily complex. Let's see an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab9f45cd5235d2ab5cef0f88fd7c2ff360cc9db" translate="yes" xml:space="preserve">
          <source>Imagine a scenario where LiveView represents a board with each card in it as a separate component. Each card has a form that allows to update its title directly in the component. We will see how to organize the data flow keeping either the view or the component as the source of truth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a80fa7e20b6ec638558d87fd5e8f1b2c820f57" translate="yes" xml:space="preserve">
          <source>Imagine the following &lt;code&gt;handle_in/3&lt;/code&gt; inside a channel:</source>
          <target state="translated">Представьте себе следующий &lt;code&gt;handle_in/3&lt;/code&gt; внутри канала:</target>
        </trans-unit>
        <trans-unit id="d7eaef0786d3c2d56724df9325bdf3c6d03a3696" translate="yes" xml:space="preserve">
          <source>Imagine the following Ecto schemas:</source>
          <target state="translated">Представь себе следующие схемы Экто:</target>
        </trans-unit>
        <trans-unit id="69ed1238c0e40ec582e839a9be87906ea6d1bb56" translate="yes" xml:space="preserve">
          <source>Imagine the following plug:</source>
          <target state="translated">Представьте себе следующую вилку:</target>
        </trans-unit>
        <trans-unit id="6ca34da07d3e254b51321106a99af217f3cef8f8" translate="yes" xml:space="preserve">
          <source>Imagine you are receiving a set of tags you want to associate to a post. Let&amp;rsquo;s imagine that those tags exist upfront and are all persisted to the database. Imagine we get the data in this format:</source>
          <target state="translated">Представьте, что вы получаете набор тегов, которые хотите связать с сообщением. Давайте представим, что эти теги существуют заранее и все они сохраняются в базе данных. Представьте, что мы получаем данные в таком формате:</target>
        </trans-unit>
        <trans-unit id="07174bed3e1206960783f2a30e60773792599d44" translate="yes" xml:space="preserve">
          <source>Imagine you are receiving a set of tags you want to associate to a post. Let's imagine that those tags exist upfront and are all persisted to the database. Imagine we get the data in this format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626b97593e67500eea59fda38eaa3e41d970c5ff" translate="yes" xml:space="preserve">
          <source>Imagine you have a LiveView that redirects on a &lt;code&gt;render_click&lt;/code&gt; event. You can make it sure it immediately redirects after the &lt;code&gt;render_click&lt;/code&gt; action by calling &lt;a href=&quot;#follow_redirect/3&quot;&gt;&lt;code&gt;follow_redirect/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224f74e1875d15da71996dc37aae640fe78641d1" translate="yes" xml:space="preserve">
          <source>Imagine you have a schema &lt;code&gt;Post&lt;/code&gt; with a &lt;code&gt;has_many :comments&lt;/code&gt; association and you execute the following query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ae5ef9b11c014505c58d928130e9d937a57895" translate="yes" xml:space="preserve">
          <source>Imagine you have an schema &lt;code&gt;Post&lt;/code&gt; with a &lt;code&gt;has_many :comments&lt;/code&gt; association and you execute the following query:</source>
          <target state="translated">Представьте, что у вас есть схема &lt;code&gt;Post&lt;/code&gt; с ассоциацией &lt;code&gt;has_many :comments&lt;/code&gt; и вы выполняете следующий запрос:</target>
        </trans-unit>
        <trans-unit id="911d5cbc4bd74830db2cf2e8c805fa896d8b4ab3" translate="yes" xml:space="preserve">
          <source>Imagine you have the following action in your controller:</source>
          <target state="translated">Представьте,что у вас в контроллере есть следующее действие:</target>
        </trans-unit>
        <trans-unit id="c3bcbecb37fb60e6f6b4d98aea0398cac118f78f" translate="yes" xml:space="preserve">
          <source>Imagine you want to encode the ID so they cannot enumerate the content in your application. An Ecto type could handle the conversion between the encoded version of the id and its representation in the database. For the sake of simplicity we'll use base64 encoding in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1656f1d578045bfea05e6c6a2237b5d6e0a2f9f" translate="yes" xml:space="preserve">
          <source>Imagine you want to implement a chat application with LiveView. You could render each message like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e74fb2e9144b4fc1c6e2f7edb9692fba7939fe" translate="yes" xml:space="preserve">
          <source>Imagine you want to store an URI struct as part of a schema in an url-shortening service. There isn&amp;rsquo;t an Ecto field type to support that value at runtime, therefore a custom one is needed.</source>
          <target state="translated">Представьте, что вы хотите сохранить структуру URI как часть схемы в службе сокращения URL-адресов. Типа поля Ecto для поддержки этого значения во время выполнения не существует, поэтому требуется настраиваемый тип.</target>
        </trans-unit>
        <trans-unit id="172eb5a1f40be1a000419ab4add75a6dc3be204b" translate="yes" xml:space="preserve">
          <source>Imagine you want to store an URI struct as part of a schema in an url-shortening service. There isn't an Ecto field type to support that value at runtime, therefore a custom one is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1dad2bc8d9075bbf5f98838633808ebc9eb469" translate="yes" xml:space="preserve">
          <source>Imagine your application is configured to run on &quot;example.com&quot; but after the user signs in, you want all links to use &quot;some_user.example.com&quot;. You can do so by setting the proper router url configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd83f3829baa0b9a2d40da3d590f7c9d0db3a5ca" translate="yes" xml:space="preserve">
          <source>Implementing a Tracker</source>
          <target state="translated">Внедрение Отслеживателя</target>
        </trans-unit>
        <trans-unit id="3d6c2a38d322d3d763e854f7651b3495dd090632" translate="yes" xml:space="preserve">
          <source>Implementing the transport behaviour</source>
          <target state="translated">Реализация поведения при транспортировке</target>
        </trans-unit>
        <trans-unit id="058fd7ed1c45697b86ef3cd0718d7bbfbe7580e9" translate="yes" xml:space="preserve">
          <source>Implementing your own adapter</source>
          <target state="translated">Внедрение собственного адаптера</target>
        </trans-unit>
        <trans-unit id="eeaf0d0aa80addf9bcd22d809311b4d22bbca34c" translate="yes" xml:space="preserve">
          <source>Important: If we don't do this, we will see the following warnings in our logs, and our application will error when trying to execute the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de9ddaf0c21afc63217f2c5ffe75bfdc4b6cd3c" translate="yes" xml:space="preserve">
          <source>Important: If we don't do this, we'll get the following warning in our logs and the application will error when attempting to load the page:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c929d75f4d94fd8fe1c260cbfd2b081155e7fe" translate="yes" xml:space="preserve">
          <source>In Ecto, we have three ways to solve this issue. The simplest is to define multiple fields in the Comment schema, one for each association:</source>
          <target state="translated">В Экто у нас есть три способа решить этот вопрос.Самый простой-определить несколько полей в схеме Comment,по одному для каждой ассоциации:</target>
        </trans-unit>
        <trans-unit id="2da5549fe6372ba474a6b84ff8f0aa9b971f280a" translate="yes" xml:space="preserve">
          <source>In LiveView tests, we interact with views via process communication in substitution of a browser. Like a browser, our test process receives messages about the rendered updates from the view which can be asserted against to test the life-cycle and behavior of LiveViews and their children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382006685c4bc65202ab7101130f82fd90eb1bb5" translate="yes" xml:space="preserve">
          <source>In SQL, COALESCE takes any number of arguments, but in ecto it only takes two, so it must be chained to achieve the same effect.</source>
          <target state="translated">В SQL COALESCE принимает любое количество аргументов,а в экто-только два,поэтому для достижения одного и того же эффекта он должен быть прикован цепью.</target>
        </trans-unit>
        <trans-unit id="8ae8d00a4f35aea9b1e600a76e95f40be1762a98" translate="yes" xml:space="preserve">
          <source>In a nutshell, &lt;code&gt;builder_opts()&lt;/code&gt; allows us to pass the options given when initializing the router to a &lt;code&gt;dispatch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09256d570841fbfb45d7851451305f20a0625cb" translate="yes" xml:space="preserve">
          <source>In addition to a certificate, an HTTPS server needs a secure TLS protocol configuration. &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; always sets the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f8049b39704e81ebed2652617e08d77f57235" translate="yes" xml:space="preserve">
          <source>In addition to inserts, we can also perform updates and deletes with &lt;code&gt;Repo.update/1&lt;/code&gt; and &lt;code&gt;Repo.delete/1&lt;/code&gt; to update or delete a single schema. Ecto also supports bulk persistence with the &lt;code&gt;Repo.insert_all&lt;/code&gt;, &lt;code&gt;Repo.update_all&lt;/code&gt;, and &lt;code&gt;Repo.delete_all&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ac9085e5b012c8583c70779624f050d5eb103a2" translate="yes" xml:space="preserve">
          <source>In addition to pushing messages out when you receive a &lt;code&gt;handle_in&lt;/code&gt; event, you can also reply directly to a client event for request/response style messaging. This is useful when a client must know the result of an operation or to simply ack messages.</source>
          <target state="translated">Помимо &lt;code&gt;handle_in&lt;/code&gt; сообщений, когда вы получаете событие handle_in , вы также можете напрямую отвечать на клиентское событие для обмена сообщениями в стиле запрос / ответ. Это полезно, когда клиент должен знать результат операции или просто подтверждать сообщения.</target>
        </trans-unit>
        <trans-unit id="a42c2c570e4795fcc36b32e73f177e0d5b29e6e2" translate="yes" xml:space="preserve">
          <source>In addition to selecting a group of ciphers, selecting a cipher suite will also disable client renegotiation and force the client to honor the server specified cipher order.</source>
          <target state="translated">Помимо выбора группы шифров,выбор набора шифров также отключит перезаключение клиента и заставит его выполнять указанный сервером порядок шифров.</target>
        </trans-unit>
        <trans-unit id="01ea8672f27177207c552fb1a1c80ac011412a23" translate="yes" xml:space="preserve">
          <source>In addition, both profiles:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f7eb8892415ea0c1aacaa32e064c3934506b5b" translate="yes" xml:space="preserve">
          <source>In all cases, each assign in the template will be accessible as &lt;code&gt;@assign&lt;/code&gt;. You can learn more about &lt;a href=&quot;assigns-eex&quot;&gt;assigns and LiveEEx templates in their own guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e048396b52227039210be32cd7f7739a9bd6e4a9" translate="yes" xml:space="preserve">
          <source>In all examples so far we have used the &lt;strong&gt;keywords query syntax&lt;/strong&gt; to create a query:</source>
          <target state="translated">До сих пор во всех примерах мы использовали &lt;strong&gt;синтаксис запроса&lt;/strong&gt; по &lt;strong&gt;ключевым словам&lt;/strong&gt; для создания запроса:</target>
        </trans-unit>
        <trans-unit id="39c6142f3ef45ee877e9c272f4bb4ce3244f2b98" translate="yes" xml:space="preserve">
          <source>In any case, regardless if a schema has been given or not, Ecto queries are always composable thanks to its binding system.</source>
          <target state="translated">В любом случае,независимо от того,была ли задана схема или нет,запросы Ecto всегда являются композитными благодаря своей системе привязки.</target>
        </trans-unit>
        <trans-unit id="a15d51ecf5a44207426a5880570278383d07dd49" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;a href=&quot;#c:handle_event/3&quot;&gt;&lt;code&gt;handle_event/3&lt;/code&gt;&lt;/a&gt; will be called with the &quot;say_hello&quot; event. When &lt;a href=&quot;#c:handle_event/3&quot;&gt;&lt;code&gt;handle_event/3&lt;/code&gt;&lt;/a&gt; is called for a component, only the diff of the component is sent to the client, making them extremely efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f38f557b90ac2d42e6a751598f4d8bbba9025c" translate="yes" xml:space="preserve">
          <source>In both cases, both types have their semantics specified by the underlying adapter/database. If you use the &lt;code&gt;:id&lt;/code&gt; type with &lt;code&gt;:autogenerate&lt;/code&gt;, it means the database will be responsible for auto-generation of the id. This is often the case for primary keys in relational databases which are auto-incremented.</source>
          <target state="translated">В обоих случаях семантика обоих типов определяется базовым адаптером / базой данных. Если вы используете тип &lt;code&gt;:id&lt;/code&gt; с &lt;code&gt;:autogenerate&lt;/code&gt; , это означает, что база данных будет отвечать за автоматическое создание идентификатора. Это часто имеет место для первичных ключей в реляционных базах данных, которые автоматически увеличиваются.</target>
        </trans-unit>
        <trans-unit id="c8e64dc292736835c5a534ec38dce0f0304db068" translate="yes" xml:space="preserve">
          <source>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to &quot;callback&quot;, but may be configured with the callback option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82af51d52f0d5e198a5e7d698f02d79e495b27b9" translate="yes" xml:space="preserve">
          <source>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to &amp;ldquo;callback&amp;rdquo;, but may be configured with the callback option.</source>
          <target state="translated">Если возвращается ответ JSON, он будет преобразован в JSONP, пока поле обратного вызова присутствует в строке запроса. Само поле обратного вызова по умолчанию имеет значение &amp;laquo;обратный вызов&amp;raquo;, но может быть настроено с помощью параметра обратного вызова.</target>
        </trans-unit>
        <trans-unit id="cce9be04157216a7cdb190a3b918523e8aca6731" translate="yes" xml:space="preserve">
          <source>In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database.</source>
          <target state="translated">В случае предоставления changeset'а,изменения в changeset'е объединяются с полями структуры,и все они отправляются в базу данных.</target>
        </trans-unit>
        <trans-unit id="83a2e40171803838a9ad2e6d9d64ac8dc619d36d" translate="yes" xml:space="preserve">
          <source>In case a previous layout is set, &lt;code&gt;put_root_layout&lt;/code&gt; also accepts the layout name to be given as a string or as an atom. If a string, it must contain the format. Passing an atom means the layout format will be found at rendering time, similar to the template in &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt;. It can also be set to &lt;code&gt;false&lt;/code&gt;. In this case, no layout would be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e804f9ad9af0ffc381cba4d6aa6307ec8f5528fa" translate="yes" xml:space="preserve">
          <source>In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset.</source>
          <target state="translated">В случае задания структуры,она преобразуется в changeset со всеми ненулевыми полями в составе changeset.</target>
        </trans-unit>
        <trans-unit id="c3cb35e3a5542760b8bd73c40248a0ad353cdacc" translate="yes" xml:space="preserve">
          <source>In case an &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; given as any of the field values by the user, it will be sent to the adapter as a tuple with in the shape of &lt;code&gt;{query, params}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b15538982d59e2053fe7e9d8eaeadd4eb2e39f" translate="yes" xml:space="preserve">
          <source>In case an attribute contains a boolean value, its key is repeated when it is true, as expected in HTML, or the attribute is completely removed if it is false:</source>
          <target state="translated">В случае,если атрибут содержит булевое значение,его ключ повторяется,когда он истинен,как и ожидалось в HTML,или атрибут полностью удаляется,если он ложный:</target>
        </trans-unit>
        <trans-unit id="8e575af2759774fa079f44025ceaa854182a1885" translate="yes" xml:space="preserve">
          <source>In case something goes wrong in a request, the router by default will crash, without returning any response to the client. This behaviour can be configured in two ways, by using two different modules:</source>
          <target state="translated">В случае если в запросе что-то пойдет не так,маршрутизатор по умолчанию будет аварийно завершать работу,не возвращая клиенту никакого ответа.Такое поведение можно настроить двумя способами,используя два разных модуля:</target>
        </trans-unit>
        <trans-unit id="9df0afcd7e029ed4180d102a2ae98dc593f2ffcd" translate="yes" xml:space="preserve">
          <source>In case the URL needs to be dynamically configured, for example by reading a system environment variable, such can be done via the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; repository callback:</source>
          <target state="translated">В случае, если URL-адрес необходимо динамически настроить, например, путем чтения переменной системной среды, это можно сделать с помощью обратного вызова репозитория &lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c933f8035c349bb985fc09533544e811593ba38d" translate="yes" xml:space="preserve">
          <source>In case the adapter provides a pool, this guarantees all of the code inside the given &lt;code&gt;fun&lt;/code&gt; runs against the same connection, which might improve performance by for instance allowing multiple related calls to the datastore to share cache information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30bf9e264bce9cb321b7053883e7d31f611e7f05" translate="yes" xml:space="preserve">
          <source>In case the adapter provides a pool, this guarantees all of the code inside the given &lt;code&gt;fun&lt;/code&gt; runs against the same connection.</source>
          <target state="translated">Если адаптер предоставляет пул, это гарантирует, что весь код внутри заданного &lt;code&gt;fun&lt;/code&gt; работать с одним и тем же соединением.</target>
        </trans-unit>
        <trans-unit id="ff857d8a1955260dd298b9e239a24e36bf3592fa" translate="yes" xml:space="preserve">
          <source>In case the association was already loaded, preload won&amp;rsquo;t attempt to reload it.</source>
          <target state="translated">Если ассоциация уже была загружена, предварительная загрузка не будет пытаться перезагрузить ее.</target>
        </trans-unit>
        <trans-unit id="cafa8aa062d6ef4942117b66127dc03a39128b32" translate="yes" xml:space="preserve">
          <source>In case the association was already loaded, preload won't attempt to reload it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be12295c8a6d2df07eacd1bb351f53d2c1496b9" translate="yes" xml:space="preserve">
          <source>In case the database could not be created, see the guides for the &lt;a href=&quot;mix_tasks#mix-ecto-create&quot;&gt;&lt;code&gt;mix ecto.create&lt;/code&gt;&lt;/a&gt; for general trouble-shooting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606100f3e421118140c48c97a79e6b2bfcdaf803" translate="yes" xml:space="preserve">
          <source>In case there is no callback or the response is not encoded in JSON format, it is a no-op.</source>
          <target state="translated">В случае,если нет обратного вызова или ответ не закодирован в формате JSON,он не работает.</target>
        </trans-unit>
        <trans-unit id="8a4c0d85054f4f0cfaba6ef317dc6eb61be6e95d" translate="yes" xml:space="preserve">
          <source>In case there&amp;rsquo;s at least one error, the list of errors will be appended to the &lt;code&gt;:errors&lt;/code&gt; field of the changeset and the &lt;code&gt;:valid?&lt;/code&gt; flag will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если есть хотя бы одна ошибка, список ошибок будет добавлен в поле &lt;code&gt;:errors&lt;/code&gt; набора изменений и &lt;code&gt;:valid?&lt;/code&gt; flag будет установлен в &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8802f9aee3cd3d44f383509389bf5a3ee709a5f4" translate="yes" xml:space="preserve">
          <source>In case there's at least one error, the list of errors will be appended to the &lt;code&gt;:errors&lt;/code&gt; field of the changeset and the &lt;code&gt;:valid?&lt;/code&gt; flag will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d961c79d7700abcfdd8ac118b7d6649979a32d5" translate="yes" xml:space="preserve">
          <source>In case you want to use only a subset of the functionality provided by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Presence&lt;/code&gt;&lt;/a&gt;, such as tracking processes but without broadcasting updates, we recommend that you look at the &lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; functionality from the &lt;code&gt;phoenix_pubsub&lt;/code&gt; project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55c4e4ce95987e0fe79dc9dcc20ddcd0ebdbe7f" translate="yes" xml:space="preserve">
          <source>In cases like above, when you want to work only on a single entry, it is much easier to simply work on the associated directly. For example, we could instead set the &lt;code&gt;post&lt;/code&gt; association in the comment:</source>
          <target state="translated">В случаях, подобных описанию выше, когда вы хотите работать только с одной записью, гораздо проще просто работать с связанной напрямую. Например, мы могли бы вместо этого установить связь с &lt;code&gt;post&lt;/code&gt; в комментарии:</target>
        </trans-unit>
        <trans-unit id="1a433a57ec454997093ca88ba782e60cd40611d5" translate="yes" xml:space="preserve">
          <source>In channel tests, we interact with channels via process communication, sending and receiving messages. It is also common to subscribe to the same topic the channel subscribes to, allowing us to assert if a given message was broadcast or not.</source>
          <target state="translated">При тестировании каналов мы взаимодействуем с каналами через технологическую коммуникацию,отправляя и получая сообщения.Также принято подписываться на одну и ту же тему,на которую подписывается канал,что позволяет нам утверждать,транслировалось ли данное сообщение или нет.</target>
        </trans-unit>
        <trans-unit id="6d0afdb19d32b80bba27b9edef3ebd1dd1cf2d1d" translate="yes" xml:space="preserve">
          <source>In complex cases, instead of relying on name inference, it may be best to set the constraint name explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c8d6fd181489a2dd77e9ab68ac22f7bd4b22c2" translate="yes" xml:space="preserve">
          <source>In fact, given &lt;code&gt;:through&lt;/code&gt; associations are read-only, &lt;strong&gt;using the &lt;a href=&quot;ecto#assoc/2&quot;&gt;&lt;code&gt;Ecto.assoc/2&lt;/code&gt;&lt;/a&gt; format is the preferred mechanism for working with through associations&lt;/strong&gt;. Use the schema-based one only if you need to store the through data alongside of the parent struct, in specific cases such as preloading.</source>
          <target state="translated">Фактически, учитывая &lt;code&gt;:through&lt;/code&gt; ассоциации доступны только для чтения, &lt;strong&gt;использование &lt;a href=&quot;ecto#assoc/2&quot;&gt; &lt;code&gt;Ecto.assoc/2&lt;/code&gt; &lt;/a&gt; является предпочтительным механизмом для работы со сквозными ассоциациями&lt;/strong&gt; . Используйте схему на основе только в том случае, если вам нужно хранить сквозные данные вместе с родительской структурой, в определенных случаях, таких как предварительная загрузка.</target>
        </trans-unit>
        <trans-unit id="e209e8446b46f8896bce3d2476eaddc91e35939f" translate="yes" xml:space="preserve">
          <source>In fact, when you invoke this macro, a field with the name of foreign key is automatically defined in the schema for you.</source>
          <target state="translated">Фактически,при вызове этого макроса в схеме для вас автоматически определяется поле с именем иностранного ключа.</target>
        </trans-unit>
        <trans-unit id="c7989d85bf0c7a46c11c45022e7b193d7c4745ef" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;camelize&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;underscore&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">В общем, &lt;code&gt;camelize&lt;/code&gt; можно рассматривать как обратное символу &lt;code&gt;underscore&lt;/code&gt; , однако в некоторых случаях форматирование может быть потеряно:</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">В общем, &lt;code&gt;underscore&lt;/code&gt; можно рассматривать как противоположность &lt;code&gt;camelize&lt;/code&gt; , однако в некоторых случаях форматирование может быть потеряно:</target>
        </trans-unit>
        <trans-unit id="b7a08909ab028a2dad7ca28f19e7788d3cd3e512" translate="yes" xml:space="preserve">
          <source>In general, it's often more convenient to test the mounting of a view in a single step, provided you don't need the result of the stateless HTTP render. This is done with a single call to &lt;a href=&quot;#live/2&quot;&gt;&lt;code&gt;live/2&lt;/code&gt;&lt;/a&gt;, which performs the &lt;code&gt;get&lt;/code&gt; step for us:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364f40e20dd4114a4cbee3580c6cbdd7d7379b01" translate="yes" xml:space="preserve">
          <source>In general, the scoping rules for pipelines behave as you might expect. In this example, all routes will pipe through the &lt;code&gt;:browser&lt;/code&gt; pipeline. However, only the &lt;code&gt;reviews&lt;/code&gt; resources routes will pipe through the &lt;code&gt;:review_checks&lt;/code&gt; pipeline. Since we declared both pipes &lt;code&gt;pipe_through [:browser, :review_checks]&lt;/code&gt; in a list of pipelines, Phoenix will &lt;code&gt;pipe_through&lt;/code&gt; each of them as it invokes them in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc684728adbd2c911a4a018ef11d85bc94e422b3" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the template format to be set dynamically based on the request. To do so, you can pass the template name as an atom (without the extension):</source>
          <target state="translated">Во многих случаях вы можете захотеть,чтобы формат шаблона устанавливался динамически на основе запроса.Для этого Вы можете передать имя шаблона в виде атома (без расширения):</target>
        </trans-unit>
        <trans-unit id="7b97ae63daf6461e1b56637fd89a1f07f62a49cf" translate="yes" xml:space="preserve">
          <source>In order for the &lt;code&gt;render/3&lt;/code&gt; function to work correctly, the controller and view must have the same root name, which must also have the same root name as the template directory where the &lt;code&gt;show.html.eex&lt;/code&gt; template lives. In other words, the &lt;code&gt;HelloController&lt;/code&gt; requires &lt;code&gt;HelloView&lt;/code&gt;, and &lt;code&gt;HelloView&lt;/code&gt; requires the existence of the &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; directory, which must contain the &lt;code&gt;show.html.eex&lt;/code&gt; template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e42e4abc355dbe4c074a8c669e3ce458db628eaf" translate="yes" xml:space="preserve">
          <source>In order for the example above to work, we need to do content negotiation with the accepts plug before rendering. You can do so by adding the following to your pipeline (in the router):</source>
          <target state="translated">Для того,чтобы пример выше работал,нам нужно провести согласование содержимого с плагином accept перед отрисовкой.Вы можете сделать это,добавив в конвейер (в маршрутизаторе)следующее:</target>
        </trans-unit>
        <trans-unit id="85a3f7a925a56f5571d26cd839de4ab3fe0a021b" translate="yes" xml:space="preserve">
          <source>In order to act as a Plug, a function needs to accept a connection struct (&lt;code&gt;%Plug.Conn{}&lt;/code&gt;) and options. It also needs to return a connection struct. Any function that meets those criteria will do. Here's an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a19ac64c369cd3aa389e69a402bc23919589b6" translate="yes" xml:space="preserve">
          <source>In order to add custom data attributes you need to pass a tuple containing :data atom and a keyword list with data attributes&amp;rsquo; names and values as the first element in the tag&amp;rsquo;s attributes keyword list:</source>
          <target state="translated">Чтобы добавить настраиваемые атрибуты данных, вам необходимо передать кортеж, содержащий: атом данных и список ключевых слов с именами и значениями атрибутов данных в качестве первого элемента в списке ключевых слов атрибутов тега:</target>
        </trans-unit>
        <trans-unit id="ac088c628be1832c3337855895315bec677904de" translate="yes" xml:space="preserve">
          <source>In order to add custom data attributes you need to pass a tuple containing :data atom and a keyword list with data attributes' names and values as the first element in the tag's attributes keyword list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4945c44b05e04ace755224f66c5d74d324ac27b2" translate="yes" xml:space="preserve">
          <source>In order to be able to use types such as &lt;code&gt;User.t()&lt;/code&gt;, &lt;code&gt;t/0&lt;/code&gt; has to be defined manually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb780465e4f134e43bf1e5f6d0a97198b166675" translate="yes" xml:space="preserve">
          <source>In order to build a Phoenix application, we will need a few dependencies installed in our Operating System:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3606aa169919759c5ce830a7a86020dbd731405c" translate="yes" xml:space="preserve">
          <source>In order to create a custom exception, we need to define a new module. Conventionally this will have &quot;Error&quot; in the name. Inside of that module, we need to define a new exception with &lt;code&gt;defexception&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4270d5af79d57d387989112f1ca66b128244614" translate="yes" xml:space="preserve">
          <source>In order to customize the parameter for any struct, one can simply implement this protocol.</source>
          <target state="translated">Для того чтобы настроить параметр для любой структуры,можно просто реализовать этот протокол.</target>
        </trans-unit>
        <trans-unit id="8cea46f6957dacee9307e778c55b234fb7f0b614" translate="yes" xml:space="preserve">
          <source>In order to make it easier to recognize the current &quot;action&quot; your LiveView is on, you can pass the action option when defining LiveViews too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb086d6d7d0263ec8c536ef5b195313198d32a9" translate="yes" xml:space="preserve">
          <source>In order to promote HTML safety, Phoenix templates do not use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt; to convert data types to strings in templates. Instead, Phoenix uses this protocol which must be implemented by data structures and guarantee that a HTML safe representation is returned.</source>
          <target state="translated">В целях повышения безопасности HTML шаблоны Phoenix не используют &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt; для преобразования типов данных в строки в шаблонах. Вместо этого Phoenix использует этот протокол, который должен быть реализован структурами данных и гарантировать возвращение безопасного представления HTML.</target>
        </trans-unit>
        <trans-unit id="a9ca8acf13c91e783afefe3396f6e1d2849afbe0" translate="yes" xml:space="preserve">
          <source>In order to provide better security, this function also enables &lt;code&gt;:reuse_sessions&lt;/code&gt; and &lt;code&gt;:secure_renegotiate&lt;/code&gt; by default, to instruct clients to reuse sessions and enforce secure renegotiation according to RFC 5746 respectively</source>
          <target state="translated">Чтобы обеспечить лучшую безопасность, эта функция также включает &lt;code&gt;:reuse_sessions&lt;/code&gt; и &lt;code&gt;:secure_renegotiate&lt;/code&gt; по умолчанию, чтобы указать клиентам повторно использовать сеансы и обеспечить безопасное повторное согласование согласно RFC 5746 соответственно.</target>
        </trans-unit>
        <trans-unit id="e5e3499f6e463ee690fd83cb4842e911f3133362" translate="yes" xml:space="preserve">
          <source>In order to run the context generators, we need to come up with a module name that groups the related functionality that we're building. In the &lt;a href=&quot;ecto&quot;&gt;Ecto guide&lt;/a&gt;, we saw how we can use Changesets and Repos to validate and persist user schemas, but we didn't integrate this with our application at large. In fact, we didn't think about where a &quot;user&quot; in our application should live at all. Let's take a step back and think about the different parts of our system. We know that we'll have users of our product. Along with users comes things like account login credentials and user registration. An &lt;code&gt;Accounts&lt;/code&gt; context in our system is a natural place for our user functionality to live.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a30ed29655614d78d7122594af4684bbed32e0" translate="yes" xml:space="preserve">
          <source>In order to see our flash messages, we need to be able to retrieve them and display them in a template/layout. One way to do the first part is with &lt;code&gt;get_flash/2&lt;/code&gt; which takes &lt;code&gt;conn&lt;/code&gt; and the key we care about. It then returns the value for that key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acba69363e13d3b2d19cde17064bc6e54ca91a5" translate="yes" xml:space="preserve">
          <source>In order to support databases that do not have string-based queries, like MongoDB, fragments also allow keywords to be given:</source>
          <target state="translated">Для поддержки баз данных,в которых нет строковых запросов,таких как MongoDB,фрагменты также позволяют задавать ключевые слова:</target>
        </trans-unit>
        <trans-unit id="62935c8ccc784ab4effb4cd884f492638a038713" translate="yes" xml:space="preserve">
          <source>In order to support links where &lt;code&gt;:method&lt;/code&gt; is not &lt;code&gt;:get&lt;/code&gt; or use the above data attributes, &lt;a href=&quot;phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; relies on JavaScript. You can load &lt;code&gt;priv/static/phoenix_html.js&lt;/code&gt; into your build tool.</source>
          <target state="translated">Для поддержки ссылок, где &lt;code&gt;:method&lt;/code&gt; не является &lt;code&gt;:get&lt;/code&gt; или использовать указанные выше атрибуты данных, &lt;a href=&quot;phoenix.html&quot;&gt; &lt;code&gt;Phoenix.HTML&lt;/code&gt; &lt;/a&gt; полагается на JavaScript. Вы можете загрузить &lt;code&gt;priv/static/phoenix_html.js&lt;/code&gt; в свой инструмент сборки.</target>
        </trans-unit>
        <trans-unit id="ac2a23cefe6dc405ba7cba0e86c91036507b2c2a" translate="yes" xml:space="preserve">
          <source>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MSSQL, on the other hand, does not yet provide a JSON type, so the value will be stored in a text field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cfbb9e0b757e4a7c387f1a89548e61c769c0468" translate="yes" xml:space="preserve">
          <source>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MySQL and MSSQL, on the other hand, do not yet provide a JSON type, so the value will be stored in a text field.</source>
          <target state="translated">Для поддержки карт в различных базах данных могут использоваться различные методы.Например,PostgreSQL будет хранить эти значения в jsonb-полях,позволяя просто запрашивать их часть.MySQL и MSSQL,с другой стороны,пока не предоставляют тип JSON,поэтому значение будет храниться в текстовом поле.</target>
        </trans-unit>
        <trans-unit id="9cc67ce09af6e2cd4c1b2d88a0add79d7ebdcbc4" translate="yes" xml:space="preserve">
          <source>In order to talk to databases, Phoenix applications use another Elixir package, called &lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto&lt;/a&gt;. If you don't plan to use databases in your application, you can pass the &lt;code&gt;--no-ecto&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a4eecdb1cbcbbac6d6309d8353c385746bf41f" translate="yes" xml:space="preserve">
          <source>In order to try out &lt;code&gt;redirect/2&lt;/code&gt;, let's create a new route in &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e29e7cb4d222c076586aa6d2efe1e067b45ad8" translate="yes" xml:space="preserve">
          <source>In order to use the check constraint, the first step is to define the check constraint in a migration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631c78b05b032bf7a4bc9563b17081acddc1f9da" translate="yes" xml:space="preserve">
          <source>In order to use the foreign key constraint the first step is to define the foreign key in a migration. This is often done with references. For example, imagine you are creating a comments table that belongs to posts. One would have:</source>
          <target state="translated">Для того чтобы использовать ограничение на использование иностранного ключа,первым шагом является определение иностранного ключа в миграции.Часто это делается со ссылками.Например,представьте,что вы создаете таблицу комментариев,которая относится к сообщениям.Так и должно быть:</target>
        </trans-unit>
        <trans-unit id="b25785fbeb7db9f5fe5792dc95bd9802bce1df6e" translate="yes" xml:space="preserve">
          <source>In order to use the uniqueness constraint, the first step is to define the unique index in a migration:</source>
          <target state="translated">Для того чтобы использовать ограничение уникальности,первым шагом является определение уникального индекса в миграции:</target>
        </trans-unit>
        <trans-unit id="d32962e066707989deb6579a1bef99dfb02fd652" translate="yes" xml:space="preserve">
          <source>In order to, for instance, support slower clients you can tune the &lt;code&gt;:read_length&lt;/code&gt; and &lt;code&gt;:read_timeout&lt;/code&gt; options. These specify how much time should be allowed to pass for each read from the underlying socket.</source>
          <target state="translated">Например, для поддержки более медленных клиентов вы можете настроить параметры &lt;code&gt;:read_length&lt;/code&gt; и &lt;code&gt;:read_timeout&lt;/code&gt; . Они определяют, сколько времени должно пройти для каждого чтения из базового сокета.</target>
        </trans-unit>
        <trans-unit id="f369074781af4e45339cc323b1a66a51339ef0e7" translate="yes" xml:space="preserve">
          <source>In order words, to provide custom error pages, we could simply define a the proper &lt;code&gt;render/2&lt;/code&gt; function clause in &lt;code&gt;HelloWeb.ErrorView&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee12c14d9ca00e6cf48da215974e95f0c7e5650" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;...&lt;/code&gt; will include all the binding between the first and the last, which may be no binding at all, one or many.</source>
          <target state="translated">Другими словами, &lt;code&gt;...&lt;/code&gt; будет включать всю привязку между первым и последним, которая может не быть привязкой вообще, одной или несколькими.</target>
        </trans-unit>
        <trans-unit id="5e53d1f0b2def4882c8f42cb4dd37f4b59fc07c1" translate="yes" xml:space="preserve">
          <source>In other words, LiveView will reload the page in case of errors, making it fail as if LiveView was not involved in the rendering in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51f1325a0c1718983754df036a306b6fd8fe04b" translate="yes" xml:space="preserve">
          <source>In other words, the inner template is placed in the &lt;code&gt;@inner_content&lt;/code&gt; assign. You can also find which module and template where used to render the inner content by introspecting the &lt;code&gt;@view_module&lt;/code&gt; and &lt;code&gt;@view_template&lt;/code&gt; assigns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d505d82f389daac5da4c66b35201ad586113ff0" translate="yes" xml:space="preserve">
          <source>In other words, when you find yourself wanting to work only with a subset of the data, then using &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; is most likely unnecessary. Instead, you want to work on the other side of the association.</source>
          <target state="translated">Другими словами, когда вы обнаружите, что хотите работать только с подмножеством данных, использование &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; , скорее всего, не нужно. Вместо этого вы хотите работать по другую сторону ассоциации.</target>
        </trans-unit>
        <trans-unit id="9c973e733faa5d3147a98906879b3bd69d7b92ef" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;contexts&quot;&gt;context guide&lt;/a&gt;, we'll find out how to wrap up our Ecto access and business logic behind modules that group related functionality. We'll see how Phoenix helps us design maintainable applications, and we'll find out about other neat Ecto features along the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbbdd02796e8c750180d95d224e10d5ba7f72ee" translate="yes" xml:space="preserve">
          <source>In our example, a &lt;code&gt;User&lt;/code&gt; has and belongs to many &lt;code&gt;Organization&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ab6ab1980a050c36b66959ba9f3fe938f26932" translate="yes" xml:space="preserve">
          <source>In our example, a User has and belongs to many Organizations</source>
          <target state="translated">В нашем примере,Пользователь имеет и принадлежит ко многим организациям.</target>
        </trans-unit>
        <trans-unit id="0fbfe06d33d66e813a10defbfd79ae7b1d15c17b" translate="yes" xml:space="preserve">
          <source>In particular, controller plugs provide a feature that allows us to execute plugs only within certain actions. For example, you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b939b666f3565b6620c702bbdd16fc9969fa1e4b" translate="yes" xml:space="preserve">
          <source>In practice, developers rarely use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Template&lt;/code&gt;&lt;/a&gt; directly. Instead they use &lt;a href=&quot;phoenix.view&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; which wraps the template functionality and adds some extra conveniences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a1a86627169c9301c553095fe386a37b9ae377" translate="yes" xml:space="preserve">
          <source>In practice, we recommend you to create your own helper with your default builder:</source>
          <target state="translated">На практике мы рекомендуем вам создать своего помощника с вашим сборщиком по умолчанию:</target>
        </trans-unit>
        <trans-unit id="e23fb277659a1ad68bfb10ebf634617c8f5908ca" translate="yes" xml:space="preserve">
          <source>In some cases - often in &lt;code&gt;index&lt;/code&gt; actions, for instance - we don't care about parameters because our behavior doesn't depend on them. In those cases, we don't use the incoming params, and simply prepend the variable name with an underscore, &lt;code&gt;_params&lt;/code&gt;. This will keep the compiler from complaining about the unused variable while still keeping the correct arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993fe331f8eff395e53c329f899a97ba23a0a92b" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to boostrap the context module and tests, but leave internal implementation of the context and schema to yourself. Use the &lt;code&gt;--no-schema&lt;/code&gt; flags to accomplish this.</source>
          <target state="translated">В некоторых случаях вы можете захотеть усилить контекстный модуль и тесты, но оставьте внутреннюю реализацию контекста и схемы себе. Для этого используйте флаги &lt;code&gt;--no-schema&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cd22eb2e0cd9838b3868b47d0fdae86fdaf59c8" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap HTML templates, LiveViews, and tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ee16ec6c8361255e6bb80285b427eaac9246a7" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap HTML templates, controllers, and controller tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade3a11fcd46e0424822bf48a04573731b62fbef" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap JSON views, controllers, and controller tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="translated">В некоторых случаях вы можете захотеть загрузить JSON-представления, контроллеры и тесты контроллеров, но оставьте внутреннюю реализацию контекста или схемы себе. Вы можете использовать флаги &lt;code&gt;--no-context&lt;/code&gt; и &lt;code&gt;--no-schema&lt;/code&gt; для управления генерацией файлов.</target>
        </trans-unit>
        <trans-unit id="f55011b0377dd613950bd33fc87827f221a7e3b5" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap the context module and tests, but leave internal implementation of the context and schema to yourself. Use the &lt;code&gt;--no-schema&lt;/code&gt; flags to accomplish this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c4866aacf268fba081667d7687cebfe5f62ff4" translate="yes" xml:space="preserve">
          <source>In some cases, you might need to render based on the template. For these cases, &lt;code&gt;@view_template&lt;/code&gt; can pair with &lt;a href=&quot;#render_existing/3&quot;&gt;&lt;code&gt;render_existing/3&lt;/code&gt;&lt;/a&gt; for per-template based content, ie:</source>
          <target state="translated">В некоторых случаях может потребоваться рендеринг на основе шаблона. В этих случаях &lt;code&gt;@view_template&lt;/code&gt; может сочетаться с &lt;a href=&quot;#render_existing/3&quot;&gt; &lt;code&gt;render_existing/3&lt;/code&gt; &lt;/a&gt; для контента на основе шаблона, то есть:</target>
        </trans-unit>
        <trans-unit id="9b384998377753d90d4408512efaa31439cf25f8" translate="yes" xml:space="preserve">
          <source>In some cases, you will want to broadcast messages without the context of a &lt;code&gt;socket&lt;/code&gt;. This could be for broadcasting from within your channel to an external topic, or broadcasting from elsewhere in your application like a controller or another process. Such can be done via your endpoint:</source>
          <target state="translated">В некоторых случаях вам может потребоваться широковещательная передача сообщений без контекста &lt;code&gt;socket&lt;/code&gt; . Это может быть трансляция из вашего канала во внешнюю тему или трансляцию из другого места в вашем приложении, например, контроллера или другого процесса. Это можно сделать через вашу конечную точку:</target>
        </trans-unit>
        <trans-unit id="556542b6153a0a9877d7ad7e8e95684ac07433c4" translate="yes" xml:space="preserve">
          <source>In some cases, you&amp;rsquo;ll need to generate a request&amp;rsquo;s URL, but using a different scheme, different host, etc. This can be accomplished by concatentating the request path with a custom built URL from your Router helpers, another Endpoint, mix config, or a hand-built string.</source>
          <target state="translated">В некоторых случаях вам нужно будет сгенерировать URL-адрес запроса, но с использованием другой схемы, другого хоста и т. Д. Это может быть выполнено путем объединения пути запроса с настраиваемым URL-адресом из помощников вашего маршрутизатора, другой конечной точки, смешанной конфигурации, или шнурок ручной работы.</target>
        </trans-unit>
        <trans-unit id="5d135b52253ea1f76dc118e79a5ba5024dc31ed9" translate="yes" xml:space="preserve">
          <source>In some cases, you'll need to generate a request's URL, but using a different scheme, different host, etc. This can be accomplished in two ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925f7c8aaf0732c9cba3eed658f8290b2a10f60a" translate="yes" xml:space="preserve">
          <source>In stateful components, &lt;a href=&quot;#c:mount/1&quot;&gt;&lt;code&gt;mount/1&lt;/code&gt;&lt;/a&gt; is called only once, when the component is first rendered. For each rendering, the optional &lt;a href=&quot;#c:preload/1&quot;&gt;&lt;code&gt;preload/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c:update/2&quot;&gt;&lt;code&gt;update/2&lt;/code&gt;&lt;/a&gt; callbacks are called before &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3f1efde90130546f23b2c2f904814fe3e8fcab" translate="yes" xml:space="preserve">
          <source>In such cases it is possible to pass the private key directly, using the &lt;code&gt;:key&lt;/code&gt; parameter. For example, assuming an RSA private key is available in the PRIVKEY environment variable in Base64 encoded DER format, the key may be set as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68280495d51817872c43fe92d60a5737a8f25c18" translate="yes" xml:space="preserve">
          <source>In that example we have a user&amp;rsquo;s id, we generate a token and verify it using the secret key base configured in the given &lt;code&gt;endpoint&lt;/code&gt;. We guarantee the token will only be valid for one day by setting a max age (recommended).</source>
          <target state="translated">В этом примере у нас есть идентификатор пользователя, мы генерируем токен и проверяем его, используя базу секретных ключей, настроенную в данной &lt;code&gt;endpoint&lt;/code&gt; . Мы гарантируем, что токен будет действителен только в течение одного дня, установив максимальный возраст (рекомендуется).</target>
        </trans-unit>
        <trans-unit id="1f41f3118259de0c9215a6b06e0067217d596aea" translate="yes" xml:space="preserve">
          <source>In that example we have a user's id, we generate a token and verify it using the secret key base configured in the given &lt;code&gt;endpoint&lt;/code&gt;. We guarantee the token will only be valid for one day by setting a max age (recommended).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd49de9316bf15faaf745aa97193e59f4c5ce77a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;changeset/2&lt;/code&gt; function above, we define three validations. They check that &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; fields are present in the changeset, the e-mail is of the specified format, and the age is between 18 and 100 - as well as a unique constraint in the email field.</source>
          <target state="translated">В приведенной выше функции &lt;code&gt;changeset/2&lt;/code&gt; мы определяем три проверки. Они проверяют, присутствуют ли поля &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;email&lt;/code&gt; в наборе изменений, имеет ли электронное письмо указанный формат и возраст от 18 до 100, а также уникальное ограничение в поле электронной почты.</target>
        </trans-unit>
        <trans-unit id="2beaddf1dc1af0a0afed02b2665a4c614e8c9fe1" translate="yes" xml:space="preserve">
          <source>In the CTE query itself use the same table name to leverage recursion that has been passed to the &lt;code&gt;name&lt;/code&gt; argument. Make sure to write a stop condition to avoid infinite recursion loop. Generally speaking, you should only use CTEs in Ecto for writing recursive queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea091611015f8ec7cc9dd9fea5d96ed83e209c4" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;with&lt;/code&gt; is used to match only a successful post fetch, followed by valid authorization for the current user. In the event either of those fail to match, &lt;code&gt;with&lt;/code&gt; will not invoke the render block and instead return the unmatched value. In this case, imagine &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; returned &lt;code&gt;{:error, :not_found}&lt;/code&gt; or &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; returned &lt;code&gt;{:error, :unauthorized}&lt;/code&gt;. For cases where these data structures serve as return values across multiple boundaries in our domain, a single fallback module can be used to translate the value into a valid response. For example, you could write the following fallback controller to handle the above values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5795255717d6356ac87649a6472e670f2673298a" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;with&lt;/code&gt; is used to match only a successful post fetch, followed by valid authorization for the current user. In the event either of those fail to match, &lt;code&gt;with&lt;/code&gt; will not invoke the render block and instead return the unmatched value. In this case, imagine &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; returned &lt;code&gt;{:error, :not_found}&lt;/code&gt; or &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; returned &lt;code&gt;{:error, :unauthorized}&lt;/code&gt;. For cases where these datastructures serve as return values across multiple boundaries in our domain, a single fallback module can be used to translate the value into a valid response. For example, you could write the following fallback controller to handle the above values:</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;with&lt;/code&gt; используется для сопоставления только успешной выборки публикации, за которой следует действительная авторизация для текущего пользователя. В случае если какой-либо из них не соответствует, &lt;code&gt;with&lt;/code&gt; не будет вызывать блок рендеринга и вместо этого вернет несопоставленное значение. В этом случае представьте, что &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; вернул &lt;code&gt;{:error, :not_found}&lt;/code&gt; или &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; вернулся &lt;code&gt;{:error, :unauthorized}&lt;/code&gt; ,: unauthorized} . В случаях, когда эти структуры данных служат в качестве возвращаемых значений через несколько границ в нашем домене, можно использовать один резервный модуль для преобразования значения в действительный ответ. Например, вы можете написать следующий резервный контроллер для обработки вышеуказанных значений:</target>
        </trans-unit>
        <trans-unit id="3b1b0c0a37a5ad734fd8c9a63cf167f822b9d6d7" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don&amp;rsquo;t particularly care about the data being sent, as long as something was replied.</source>
          <target state="translated">В утверждении выше мы не особо заботимся об отправленных данных, если на что-то был получен ответ.</target>
        </trans-unit>
        <trans-unit id="687f064f0b397a245fd7efdac2c169e020ea3fe3" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don&amp;rsquo;t particularly care about the data being sent, as long as something was sent.</source>
          <target state="translated">В утверждении выше мы не особо заботимся об отправленных данных, если что-то было отправлено.</target>
        </trans-unit>
        <trans-unit id="1ed97cc0df14884c8ffa3bce15edcee614a81a95" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don't particularly care about the data being sent, as long as something was replied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd5bb81c813b68dd4c64063dd42225fe58dd0c8" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don't particularly care about the data being sent, as long as something was sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbfb137b25284ebef7ca3ab66b80ac42b70e667" translate="yes" xml:space="preserve">
          <source>In the case of an &lt;code&gt;&quot;element&quot;&lt;/code&gt; page loading event, the info will contain a &lt;code&gt;&quot;target&quot;&lt;/code&gt; key containing the DOM element which triggered the page loading state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f28e9a6e41b204ed7eb1de0dc4ea78da2108aed" translate="yes" xml:space="preserve">
          <source>In the case of forms, when a &lt;code&gt;phx-change&lt;/code&gt; is sent to the server, the input element which emitted the change receives the &lt;code&gt;phx-change-loading&lt;/code&gt; class, along with the parent form tag. The following events receive css loading classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c0702d49a6fa9644c129eb1cbc189ec43c7c1d" translate="yes" xml:space="preserve">
          <source>In the case of our &lt;code&gt;create&lt;/code&gt; action, when we successfully create a user, we use &lt;a href=&quot;phoenix.controller#put_flash/3&quot;&gt;&lt;code&gt;Phoenix.Controller.put_flash/3&lt;/code&gt;&lt;/a&gt; to show a success message, and then we redirect to the &lt;code&gt;user_path&lt;/code&gt;'s show page. Conversely, if &lt;code&gt;Accounts.create_user/1&lt;/code&gt; fails, we render our &lt;code&gt;&quot;new.html&quot;&lt;/code&gt; template and pass along the Ecto changeset for the template to lift error messages from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6084cacdb41ec7942b3031f9f8713fcd0287545b" translate="yes" xml:space="preserve">
          <source>In the changeset examples so far, we have always used changesets to validate and cast data contained in a struct defined by an Ecto schema, such as the &lt;code&gt;%User{}&lt;/code&gt; struct defined by the &lt;code&gt;User&lt;/code&gt; module.</source>
          <target state="translated">До сих пор в примерах наборов изменений мы всегда использовали наборы изменений для проверки и преобразования данных, содержащихся в структуре, определенной схемой Ecto, такой как структура &lt;code&gt;%User{}&lt;/code&gt; определенная модулем &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6967baeb41fe4aaf65135be1a86f7b7f51cb74b8" translate="yes" xml:space="preserve">
          <source>In the default &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt; implementation, the metadata expects the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de678a4f657d9a0b14e4ad6c02a818dd6a2f267d" translate="yes" xml:space="preserve">
          <source>In the documentation below, we will explain how it works internally. For user-facing documentation, see &lt;a href=&quot;phoenix.liveview&quot;&gt;&lt;code&gt;Phoenix.LiveView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05024d1d5f114eed84c10173ddb5b0423ed6df3" translate="yes" xml:space="preserve">
          <source>In the example above we relied on our schema but queries can also be made directly against a table by giving the table name as a string. In such cases, the data to be fetched must be explicitly outlined:</source>
          <target state="translated">В приведенном выше примере мы полагались на нашу схему,но запросы также могут быть сделаны непосредственно к таблице,задавая имя таблицы в виде строки.В таких случаях извлекаемые данные должны быть явно обозначены:</target>
        </trans-unit>
        <trans-unit id="77e215827ec3fbaaba50e0c67d6aa3a380c28048" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;Ecto.build_assoc/3&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6980dcf932f4756073eec7951985832bf4ffdbc2" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;ecto#build_assoc/3&quot;&gt;&lt;code&gt;Ecto.build_assoc/3&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">В приведенном выше примере &lt;a href=&quot;ecto#build_assoc/3&quot;&gt; &lt;code&gt;Ecto.build_assoc/3&lt;/code&gt; &lt;/a&gt; эквивалентен:</target>
        </trans-unit>
        <trans-unit id="c0efaf4e38ac06de9330c96ca3071c0aa49d7d17" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;conn.assigns[:an_option]&lt;/code&gt; will be available to all plugs invoked after &lt;code&gt;:match&lt;/code&gt;. Such plugs can read from &lt;code&gt;conn.assigns&lt;/code&gt; (or &lt;code&gt;conn.private&lt;/code&gt;) to configure their behaviour based on the matched route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b582e24c785d7e528d91beeaeb2094948f8201" translate="yes" xml:space="preserve">
          <source>In the example above, Ecto will cast the age to type integer. When a value cannot be cast, &lt;a href=&quot;ecto.query.casterror&quot;&gt;&lt;code&gt;Ecto.Query.CastError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">В приведенном выше примере Ecto приведёт возраст к типу integer. Когда значение не может быть приведено, &lt;a href=&quot;ecto.query.casterror&quot;&gt; &lt;code&gt;Ecto.Query.CastError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="952705a8404ece781d990a44fb37e80f3335cc68" translate="yes" xml:space="preserve">
          <source>In the example above, LiveView will lookup for an element with ID=user-13 and retrieve its &lt;code&gt;phx-target&lt;/code&gt;. If &lt;code&gt;phx-target&lt;/code&gt; points to a component, that will be the component used, otherwise it will fallback to the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38da296833b2b1ef41965ac27af71cead65925f5" translate="yes" xml:space="preserve">
          <source>In the example above, a request will only match if it is a &lt;code&gt;GET&lt;/code&gt; request and the route is &quot;/hello&quot;. The supported HTTP methods are &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6032006ee3190bfba008183ef22c7724958741" translate="yes" xml:space="preserve">
          <source>In the example above, a request will only match if it is a &lt;code&gt;GET&lt;/code&gt; request and the route is &amp;ldquo;/hello&amp;rdquo;. The supported HTTP methods are &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере запрос будет соответствовать только в том случае, если это &lt;code&gt;GET&lt;/code&gt; а маршрут - &amp;laquo;/ hello&amp;raquo;. Поддерживаемые методы HTTP: &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; и &lt;code&gt;options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbb4d85bfa68b487dba755bf14be4d94f034f1c7" translate="yes" xml:space="preserve">
          <source>In the example above, both &lt;code&gt;at_least_four(:doors)&lt;/code&gt; and &lt;code&gt;at_least_four(:tires)&lt;/code&gt; would be valid calls as the field is dynamically generated.</source>
          <target state="translated">В приведенном выше примере оба &lt;code&gt;at_least_four(:doors)&lt;/code&gt; и &lt;code&gt;at_least_four(:tires)&lt;/code&gt; будут допустимыми, поскольку поле создается динамически.</target>
        </trans-unit>
        <trans-unit id="f151d0619adc353362eafc28e0ed90d66415139d" translate="yes" xml:space="preserve">
          <source>In the example above, instead of issuing a separate query to fetch comments, Ecto will fetch posts and comments in a single query and then do a separate pass associating each comment to its parent post. Therefore, instead of returning &lt;code&gt;number_of_posts * number_of_comments&lt;/code&gt; results, like a &lt;code&gt;join&lt;/code&gt; would, it returns only posts with the &lt;code&gt;comments&lt;/code&gt; fields properly filled in.</source>
          <target state="translated">В приведенном выше примере вместо выдачи отдельного запроса для получения комментариев Ecto будет извлекать сообщения и комментарии в одном запросе, а затем выполнять отдельный проход, связывающий каждый комментарий с его родительским сообщением. Следовательно, вместо того, чтобы возвращать результаты &lt;code&gt;number_of_posts * number_of_comments&lt;/code&gt; , как при &lt;code&gt;join&lt;/code&gt; , он возвращает только сообщения с правильно заполненными полями &lt;code&gt;comments&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8024bb268a6b569b23e03a0cc2bbfe6ea4b6c5f" translate="yes" xml:space="preserve">
          <source>In the example above, the Blog context receives the user on both &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; operations, and always validates accordingly that the user has access, raising an error otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4efbfdb8b81848fa5c5be65d29714905c426ad1" translate="yes" xml:space="preserve">
          <source>In the example above, the current presence information for the socket&amp;rsquo;s topic is pushed to the client as a &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; event. Next, &lt;code&gt;Presence.track&lt;/code&gt; is used to register this channel&amp;rsquo;s process as a presence for the socket&amp;rsquo;s user ID, with a map of metadata.</source>
          <target state="translated">В приведенном выше примере текущая информация о присутствии для темы сокета передается клиенту в виде события &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; Состояние_ присутствия&amp;raquo; . Затем &lt;code&gt;Presence.track&lt;/code&gt; используется для регистрации процесса этого канала как присутствия для идентификатора пользователя сокета с картой метаданных.</target>
        </trans-unit>
        <trans-unit id="b93b04f9b48d20bfebf57013a4e3bc857f160f52" translate="yes" xml:space="preserve">
          <source>In the example above, the current presence information for the socket's topic is pushed to the client as a &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; event. Next, &lt;code&gt;Presence.track&lt;/code&gt; is used to register this channel's process as a presence for the socket's user ID, with a map of metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5fb7697f09cc5ff0d4a520eb43540e86b99510" translate="yes" xml:space="preserve">
          <source>In the example above, the query is built little by little by merging into a final map. If both conditions above are true, the final query would be equivalent to:</source>
          <target state="translated">В приведенном выше примере запрос строится понемногу путем слияния в конечную карту.Если оба вышеприведенных условия верны,то конечный запрос будет эквивалентен:</target>
        </trans-unit>
        <trans-unit id="d450f61126463b7084c0897c03bca594be4602a6" translate="yes" xml:space="preserve">
          <source>In the example above, two events will be emitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58aedac2b16ebd09d651ee588fbf1ba5cf17edd" translate="yes" xml:space="preserve">
          <source>In the example above, we are directly querying the &quot;users&quot; table from the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925feb16ac76c5d3be11e92f48d4338c9def7879" translate="yes" xml:space="preserve">
          <source>In the example above, we are directly querying the &amp;ldquo;users&amp;rdquo; table from the database.</source>
          <target state="translated">В приведенном выше примере мы напрямую запрашиваем таблицу &amp;laquo;пользователей&amp;raquo; из базы данных.</target>
        </trans-unit>
        <trans-unit id="0bdcc56455db35f7ec8e6aad2349adff0d37f04a" translate="yes" xml:space="preserve">
          <source>In the example above, we are using the lower procedure in the database to downcase the title column.</source>
          <target state="translated">В приведенном выше примере мы используем нижнюю процедуру в БД для понижения значения колонки заголовка.</target>
        </trans-unit>
        <trans-unit id="6d69428195f2828f8a6f3b10d5d7bcaad49a7a54" translate="yes" xml:space="preserve">
          <source>In the example above, we get the average salary per department. &lt;code&gt;:department&lt;/code&gt; is the window name, partitioned by &lt;code&gt;e.depname&lt;/code&gt; and &lt;a href=&quot;#avg/1&quot;&gt;&lt;code&gt;avg/1&lt;/code&gt;&lt;/a&gt; is the window function.</source>
          <target state="translated">В приведенном выше примере мы получаем среднюю зарплату по отделам. &lt;code&gt;:department&lt;/code&gt; &lt;code&gt;e.depname&lt;/code&gt; - это имя окна, разделенное e.depname, а &lt;a href=&quot;#avg/1&quot;&gt; &lt;code&gt;avg/1&lt;/code&gt; &lt;/a&gt; - оконная функция.</target>
        </trans-unit>
        <trans-unit id="e6d3d727bce6283546ba164b37335f9c8037c441" translate="yes" xml:space="preserve">
          <source>In the example above, we get the average salary per department. &lt;code&gt;:department&lt;/code&gt; is the window name, partitioned by &lt;code&gt;e.depname&lt;/code&gt; and &lt;code&gt;avg/1&lt;/code&gt; is the window function. For more information on windows functions, see &lt;a href=&quot;ecto.query.windowapi&quot;&gt;&lt;code&gt;Ecto.Query.WindowAPI&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В приведенном выше примере мы получаем среднюю зарплату по отделам. &lt;code&gt;:department&lt;/code&gt; &lt;code&gt;e.depname&lt;/code&gt; - это имя окна, разделенное e.depname, а &lt;code&gt;avg/1&lt;/code&gt; - оконная функция. Для получения дополнительной информации о функциях Windows см. &lt;a href=&quot;ecto.query.windowapi&quot;&gt; &lt;code&gt;Ecto.Query.WindowAPI&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b237c8ca61ef3e508aa687be188e40ca4adf22f" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a &lt;code&gt;has_many :through&lt;/code&gt; association named &lt;code&gt;:comments_authors&lt;/code&gt;. A &lt;code&gt;:through&lt;/code&gt; association always expects a list and the first element of the list must be a previously defined association in the current module. For example, &lt;code&gt;:comments_authors&lt;/code&gt; first points to &lt;code&gt;:comments&lt;/code&gt; in the same module (Post), which then points to &lt;code&gt;:author&lt;/code&gt; in the next schema, &lt;code&gt;Comment&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере мы определили ассоциацию &lt;code&gt;has_many :through&lt;/code&gt; именем &lt;code&gt;:comments_authors&lt;/code&gt; . A &lt;code&gt;:through&lt;/code&gt; ассоциацию всегда ожидается список, и первый элемент списка должен быть ранее определенной ассоциацией в текущем модуле. Например,: &lt;code&gt;:comments_authors&lt;/code&gt; сначала указывает на &lt;code&gt;:comments&lt;/code&gt; в том же модуле (Сообщение), а затем указывает на &lt;code&gt;:author&lt;/code&gt; в следующей схеме, &lt;code&gt;Comment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85ec2ea6c6ded12b6166febab5316f612414d722" translate="yes" xml:space="preserve">
          <source>In the example above, we used &lt;a href=&quot;#datetime_add/3&quot;&gt;&lt;code&gt;datetime_add/3&lt;/code&gt;&lt;/a&gt; to subtract one month from the current datetime and compared it with the &lt;code&gt;p.published_at&lt;/code&gt;. If you want to perform operations on date, &lt;a href=&quot;#date_add/3&quot;&gt;&lt;code&gt;date_add/3&lt;/code&gt;&lt;/a&gt; could be used.</source>
          <target state="translated">В приведенном выше примере мы использовали &lt;a href=&quot;#datetime_add/3&quot;&gt; &lt;code&gt;datetime_add/3&lt;/code&gt; ,&lt;/a&gt; чтобы вычесть один месяц из текущего datetime и сравнить его с &lt;code&gt;p.published_at&lt;/code&gt; . Если вы хотите выполнять операции с датой, можно использовать &lt;a href=&quot;#date_add/3&quot;&gt; &lt;code&gt;date_add/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a77b1f6b12d8b7d6c0db0b804a8d03a2387d7fc2" translate="yes" xml:space="preserve">
          <source>In the example above, we were able to build the query expressions bit by bit, using different bindings, and later interpolate it all at once inside the query.</source>
          <target state="translated">В приведенном выше примере мы смогли построить выражения запроса по битам,используя различные привязки,а затем интерполировать все это сразу внутри запроса.</target>
        </trans-unit>
        <trans-unit id="b3cc98d911ffe36e25f191353a2c3e1efd5e9454" translate="yes" xml:space="preserve">
          <source>In the example below, we get all comments associated to the given post:</source>
          <target state="translated">В примере ниже мы получим все комментарии,связанные с данным постом:</target>
        </trans-unit>
        <trans-unit id="113fef9616300cb9b03a9842f0b9a69b0c3665e7" translate="yes" xml:space="preserve">
          <source>In the examples above, even though it returned &lt;code&gt;:ok&lt;/code&gt;, we do not know if we inserted new data or if we updated only the &lt;code&gt;:on_conflict&lt;/code&gt; fields. In case an update happened, the data in the struct most likely does not match the data in the database. For example, autogenerated fields such as &lt;code&gt;inserted_at&lt;/code&gt; will point to now rather than the time the struct was actually inserted.</source>
          <target state="translated">В приведенных выше примерах, даже если он вернул &lt;code&gt;:ok&lt;/code&gt; , мы не знаем, вставили ли мы новые данные или обновили только поля &lt;code&gt;:on_conflict&lt;/code&gt; . В случае обновления данные в структуре, скорее всего, не соответствуют данным в базе данных. Например, автоматически сгенерированные поля, такие как &lt;code&gt;inserted_at&lt;/code&gt; будут указывать на сейчас, а не на время, когда структура была фактически вставлена.</target>
        </trans-unit>
        <trans-unit id="2930af812f0bb54659d607398b6c6757367b573d" translate="yes" xml:space="preserve">
          <source>In the examples above, we have placed the template directly inside the LiveView:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f37c0e9a5a67e4ea92ceac140f3ed765f58b555" translate="yes" xml:space="preserve">
          <source>In the following sections, we will provide an overview of those components and how they interact with each other. Feel free to access their respective module documentation for more specific examples, options and configuration.</source>
          <target state="translated">В следующих разделах мы представим обзор этих компонентов и то,как они взаимодействуют друг с другом.Не стесняйтесь обращаться к документации по их соответствующим модулям для более конкретных примеров,опций и конфигураций.</target>
        </trans-unit>
        <trans-unit id="05a430899144f4642991576f8481a69501d20d42" translate="yes" xml:space="preserve">
          <source>In the form, you now can:</source>
          <target state="translated">В форме,теперь ты можешь:</target>
        </trans-unit>
        <trans-unit id="b94cd064e93fa734125c2fd704a901c1c0fcb707" translate="yes" xml:space="preserve">
          <source>In the keyword query syntax, those options must be given immediately after the join. In the expression syntax, the options are given as the fifth argument.</source>
          <target state="translated">В синтаксисе запроса по ключевому слову,эти опции должны быть заданы сразу после соединения.В синтаксисе выражений,опции даются в качестве пятого аргумента.</target>
        </trans-unit>
        <trans-unit id="e90e585267bb28783e5461ed42cba84a357ddee0" translate="yes" xml:space="preserve">
          <source>In the middle of the endpoint, there is also a conditional block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925384cf40775541bef0fdb371ddd4f6902ee2ec" translate="yes" xml:space="preserve">
          <source>In the previous section, we have used the &lt;a href=&quot;#c:config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt; function that is automatically generated in your endpoint. Here&amp;rsquo;s a list of all the functions that are automatically defined in your endpoint:</source>
          <target state="translated">В предыдущем разделе мы использовали функцию &lt;a href=&quot;#c:config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; ,&lt;/a&gt; которая автоматически генерируется в вашей конечной точке. Вот список всех функций, которые автоматически определяются в вашей конечной точке:</target>
        </trans-unit>
        <trans-unit id="9f3c7ddaf3d4a8950203ba5460188209b699de98" translate="yes" xml:space="preserve">
          <source>In the previous section, we have used the &lt;a href=&quot;#c:config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt; function that is automatically generated in your endpoint. Here's a list of all the functions that are automatically defined in your endpoint:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db5d6dd9e9298f5fcdd31235b789e1443c4ca39" translate="yes" xml:space="preserve">
          <source>In the router, we can declare plugs inside pipelines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a8e520a230c0312a84d780ae929ea961272701" translate="yes" xml:space="preserve">
          <source>In the same &lt;code&gt;lib/hello&lt;/code&gt; directory, we will find a &lt;code&gt;lib/hello/repo.ex&lt;/code&gt;. It defines a &lt;code&gt;Hello.Repo&lt;/code&gt; module which is our main interface to the database. If you are using Postgres (the default), you will see something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a55cc79b6410f0afe6d205affc7d1b1d385b5c" translate="yes" xml:space="preserve">
          <source>In the second case, the &lt;code&gt;form_for&lt;/code&gt; emits only the opening of the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag, which then needs to be closed explicitly in HTML. Since the anonymous function has been removed, &lt;code&gt;Phoenix.LiveView&lt;/code&gt; is able to optimize forms too. Although outside of live views, we recommend using the first construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610bcbb3b9e32217be658737635c218a337cd80c" translate="yes" xml:space="preserve">
          <source>In the template, we want to wrap all of the messages in a container and tag this content with &lt;code&gt;phx-update&lt;/code&gt;. Remember, we must add an ID to the container as well as to each child:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5900cdb36ee6d103dd2e36b10be0e4e6213e6863" translate="yes" xml:space="preserve">
          <source>In the view we see our &lt;code&gt;render/2&lt;/code&gt; function pattern matching on &lt;code&gt;&quot;index.json&quot;&lt;/code&gt;, &lt;code&gt;&quot;show.json&quot;&lt;/code&gt;, and &lt;code&gt;&quot;page.json&quot;&lt;/code&gt;. The &quot;index.json&quot; and &quot;show.json&quot; are the ones requested directly from the controller. They also match on the assigns sent by the controller. &lt;code&gt;&quot;index.json&quot;&lt;/code&gt; will respond with JSON like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2c6811152e546fda2c29bf344f22b16249e04d" translate="yes" xml:space="preserve">
          <source>In this case you can use the name and suffix options together to match on these dynamic indexes, like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b521e7acb6fef7a8f7e4316ef4bab85906fb67cf" translate="yes" xml:space="preserve">
          <source>In this case, the solution is to not use &lt;code&gt;content_tag&lt;/code&gt; and rely on LiveEEx to build the markup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c678eccca5ec57c1ed60e620ac17c9a5a18d705b" translate="yes" xml:space="preserve">
          <source>In this case, we haven&amp;rsquo;t checked the unique constraint in the e-mail field because the data did not validate. Let&amp;rsquo;s fix the age and assume, however, that the e-mail already exists in the database:</source>
          <target state="translated">В этом случае мы не проверили уникальное ограничение в поле электронной почты, потому что данные не прошли проверку. Давайте зафиксируем возраст и предположим, однако, что электронное письмо уже существует в базе данных:</target>
        </trans-unit>
        <trans-unit id="50bf56697ce917a335edfd2bed8c62011c485096" translate="yes" xml:space="preserve">
          <source>In this case, we haven't checked the unique constraint in the e-mail field because the data did not validate. Let's fix the age and the name, and assume that the e-mail already exists in the database:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94f214e683bc0e00a7e39c7767a3430885c51b2" translate="yes" xml:space="preserve">
          <source>In this example, the phoenix.js client will send the token in the &lt;code&gt;connect&lt;/code&gt; command which is then validated by the server.</source>
          <target state="translated">В этом примере клиент phoenix.js отправит токен в команде &lt;code&gt;connect&lt;/code&gt; который затем проверяется сервером.</target>
        </trans-unit>
        <trans-unit id="84d8d37df15e10105e708f89127c2b3fd59110cd" translate="yes" xml:space="preserve">
          <source>In this example, the stop event's &lt;code&gt;duration&lt;/code&gt; includes the time it takes to parse the request, dispatch it to the correct handler, and execute the handler. The events are not emitted for requests not matching any handlers, since the plug is placed after the match plug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c87280301ac2f9d889847d9370825348892494" translate="yes" xml:space="preserve">
          <source>In this example, we know the client sent a valid token because &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; returned a tuple of type &lt;code&gt;{:ok, user_id}&lt;/code&gt;. The server can now proceed with the request.</source>
          <target state="translated">В этом примере мы знаем, что клиент отправил действительный токен, потому что &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; вернул кортеж типа &lt;code&gt;{:ok, user_id}&lt;/code&gt; . Теперь сервер может продолжить выполнение запроса.</target>
        </trans-unit>
        <trans-unit id="71e6a35d1eff7b2aab276040bac56ef6b66ab6ad" translate="yes" xml:space="preserve">
          <source>In this example, we prepend the new comment to the list of existing comments. Ecto will diff the list of comments currently in &lt;code&gt;post&lt;/code&gt; with the list of comments given, and correctly insert the new comment to the database. Note, however, Ecto is doing a lot of work just to figure out something we knew since the beginning, which is that there is only one new comment.</source>
          <target state="translated">В этом примере мы добавляем новый комментарий к списку существующих комментариев. Ecto сравнит список комментариев, находящихся в данный момент в &lt;code&gt;post&lt;/code&gt; со списком предоставленных комментариев и правильно вставит новый комментарий в базу данных. Обратите внимание, однако, что Ecto проделывает большую работу, чтобы выяснить то, что мы знали с самого начала, а именно, что есть только один новый комментарий.</target>
        </trans-unit>
        <trans-unit id="705c5880cd57ceb565562d6750a24d58f8d72145" translate="yes" xml:space="preserve">
          <source>In this guide, we will show you how to instrument and report on &lt;code&gt;:telemetry&lt;/code&gt; events in your Phoenix application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b71b3e3675710388f0fdbf100ae1a0951ac128" translate="yes" xml:space="preserve">
          <source>In this particular case, this can be addressed by using the &lt;code&gt;form_for&lt;/code&gt; variant without anonymous functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094b03b8c08ae8f0aca1e1b64e1f6fdead91e39c" translate="yes" xml:space="preserve">
          <source>In this scenario we will create a token, sign it, then provide it to a client application. The client will then use this token to authenticate requests for resources from the server. (See &lt;a href=&quot;phoenix.token#content&quot;&gt;&lt;code&gt;Phoenix.Token&lt;/code&gt;&lt;/a&gt; summary for more info about creating tokens.)</source>
          <target state="translated">В этом сценарии мы создадим токен, подпишем его, а затем предоставим клиентскому приложению. Затем клиент будет использовать этот токен для аутентификации запросов на ресурсы с сервера. (См. &lt;a href=&quot;phoenix.token#content&quot;&gt; &lt;code&gt;Phoenix.Token&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации о создании токенов.)</target>
        </trans-unit>
        <trans-unit id="5d2ca7cf6666758e66d70fb72bd2c17d8cc12775" translate="yes" xml:space="preserve">
          <source>In this scenario we will create a token, sign it, then provide it to a client application. The client will then use this token to authenticate requests for resources from the server. See &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Token&lt;/code&gt;&lt;/a&gt; summary for more info about creating tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2b36f6be4273c12b1bf0870e80c1f54e8ebe01" translate="yes" xml:space="preserve">
          <source>In this section, we will talk about error cases that you expect to happen within your application. For example, a user filling in a form with invalid data is expected. In a LiveView, we typically handle those cases by storing a change in the LiveView state, which causes the LiveView to be re-rendered with the error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534f0da6f14534e0120bbc0f42df3e9cafe2ef69" translate="yes" xml:space="preserve">
          <source>In your posts and tasks:</source>
          <target state="translated">В ваших должностях и задачах:</target>
        </trans-unit>
        <trans-unit id="c3b933e481b11d1bde53fbfb5da0612030cd36c5" translate="yes" xml:space="preserve">
          <source>In your test, you can assert that the close happened by:</source>
          <target state="translated">В вашем тесте,вы можете утверждать,что близкое произошло:</target>
        </trans-unit>
        <trans-unit id="b483120f0deedef678421bd74a9a810fadf217f8" translate="yes" xml:space="preserve">
          <source>In-context Relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2145377aa10484f7a6a7e6838ef07513b94b08f3" translate="yes" xml:space="preserve">
          <source>Inclusion operator: &lt;a href=&quot;#in/2&quot;&gt;&lt;code&gt;in/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Оператор включения: &lt;a href=&quot;#in/2&quot;&gt; &lt;code&gt;in/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fb63493844a1ddd4abed4ae031ad06a61ed43a" translate="yes" xml:space="preserve">
          <source>Incoming Events</source>
          <target state="translated">Входящие события</target>
        </trans-unit>
        <trans-unit id="f330c4ccc52c7952a156d5b90f9e2cb96c8ebbb4" translate="yes" xml:space="preserve">
          <source>Incoming messages</source>
          <target state="translated">Входящие сообщения</target>
        </trans-unit>
        <trans-unit id="615a09426a8930c611cc2c8dba4ed06391710162" translate="yes" xml:space="preserve">
          <source>Incoming messages are encoded in whatever way the transport chooses. Those messages must be decoded in the transport into a &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; before being forwarded to a channel.</source>
          <target state="translated">Входящие сообщения кодируются любым способом, который выбирает транспорт. Эти сообщения должны быть декодированы в транспорте в &lt;a href=&quot;phoenix.socket.message&quot;&gt; &lt;code&gt;Phoenix.Socket.Message&lt;/code&gt; &lt;/a&gt; перед пересылкой на канал.</target>
        </trans-unit>
        <trans-unit id="1020e5877fce98955e2ab68a32a4bcc5456449fd" translate="yes" xml:space="preserve">
          <source>Indeed it does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2668d897f3e5655c92b0200386d6b654d95aaf3e" translate="yes" xml:space="preserve">
          <source>Indicates a many-to-many association with another schema</source>
          <target state="translated">Указывает на много-многочисленную связь с другой схемой.</target>
        </trans-unit>
        <trans-unit id="6aedb251e3f9159172c6827ec8ede269c15554c5" translate="yes" xml:space="preserve">
          <source>Indicates a many-to-many association with another schema.</source>
          <target state="translated">Указывает на много-многочисленную связь с другой схемой.</target>
        </trans-unit>
        <trans-unit id="135ecd7103630379591db4bff96d8d8045c40ee5" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-many association with another schema</source>
          <target state="translated">Указывает на ассоциацию &quot;один-ко-многим&quot; с другой схемой.</target>
        </trans-unit>
        <trans-unit id="13d6cb61c10dc318568f2defc7bea984f223dba4" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-many association with another schema.</source>
          <target state="translated">Указывает на связь &quot;один-ко-многим&quot; с другой схемой.</target>
        </trans-unit>
        <trans-unit id="1708cc604ed2771df21bc2d718401a60ab2cc1f0" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one association with another schema</source>
          <target state="translated">Указывает на связь тет-а-тет с другой схемой.</target>
        </trans-unit>
        <trans-unit id="0ae09be75f38bd6a2f7c1a338f1fea359b869e83" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one association with another schema.</source>
          <target state="translated">Указывает на связь тет-а-тет с другой схемой.</target>
        </trans-unit>
        <trans-unit id="2c438499b0af025a1043798095c70140d1dfd657" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one or many-to-one association with another schema</source>
          <target state="translated">Указывает на ассоциацию один к одному или много к одному с другой схемой.</target>
        </trans-unit>
        <trans-unit id="3745614dbe3129d4f977d563860dba9c8231878f" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one or many-to-one association with another schema.</source>
          <target state="translated">Указывает на связь &quot;один к одному&quot; или &quot;много к одному&quot; с другой схемой.</target>
        </trans-unit>
        <trans-unit id="aba2438ae1e81b9920197c224065413b7671c158" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of a schema</source>
          <target state="translated">Указывает на встраивание схемы</target>
        </trans-unit>
        <trans-unit id="b12568554ff04c1842f8599807aa79f64173a10b" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of a schema.</source>
          <target state="translated">Указывает на встраивание схемы.</target>
        </trans-unit>
        <trans-unit id="0754ccd3beda4c7eb864f57ffbfc33fd61e455d7" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of many schemas</source>
          <target state="translated">Указывает на встраивание многих схем</target>
        </trans-unit>
        <trans-unit id="99fc922b999b45aabf4ebb20cd1ef3dfc6c0a01f" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of many schemas.</source>
          <target state="translated">Указывает на встраивание многих схем.</target>
        </trans-unit>
        <trans-unit id="4d6143e57414f523ba3e39d5fe528429bec73741" translate="yes" xml:space="preserve">
          <source>Initialize the endpoint configuration</source>
          <target state="translated">Инициализируйте конфигурацию конечной точки</target>
        </trans-unit>
        <trans-unit id="5feacf6897a98bceba39f5f4a774ab74aa83f3be" translate="yes" xml:space="preserve">
          <source>Initialize the endpoint configuration.</source>
          <target state="translated">Инициализируйте конфигурацию конечной точки.</target>
        </trans-unit>
        <trans-unit id="3397476eb797456dd549685d4d13875789ff5bea" translate="yes" xml:space="preserve">
          <source>Initializes the adapter supervision tree by returning the children and adapter metadata</source>
          <target state="translated">Инициализирует дерево контроля за адаптером,возвращая метаданные о детях и адаптере.</target>
        </trans-unit>
        <trans-unit id="c798c674e519bc2029ac452c4e9259668434c74d" translate="yes" xml:space="preserve">
          <source>Initializes the adapter supervision tree by returning the children and adapter metadata.</source>
          <target state="translated">Инициализирует дерево контроля за адаптером,возвращая метаданные о детях и адаптере.</target>
        </trans-unit>
        <trans-unit id="2a5ae207d4c7ad36e0e12a08bb38366c31c50683" translate="yes" xml:space="preserve">
          <source>Initializes the session with the given contents</source>
          <target state="translated">Инициализирует сеанс с заданным содержанием</target>
        </trans-unit>
        <trans-unit id="3e313d7032fb8b49aa12e688ee30e31dff8431ca" translate="yes" xml:space="preserve">
          <source>Initializes the session with the given contents.</source>
          <target state="translated">Инициализирует сеанс с заданным содержанием.</target>
        </trans-unit>
        <trans-unit id="869617ee9409bb26ae162b9333128e6d4f2497b3" translate="yes" xml:space="preserve">
          <source>Initializes the socket state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc723255ce4cbc0ec464d52fcc972a1cff32563d" translate="yes" xml:space="preserve">
          <source>Initializes the store</source>
          <target state="translated">Инициализирует магазин</target>
        </trans-unit>
        <trans-unit id="1948daa5ef81efb1f6ec1462ab9c9c66bafc872e" translate="yes" xml:space="preserve">
          <source>Initializes the store.</source>
          <target state="translated">Инициализирует магазин.</target>
        </trans-unit>
        <trans-unit id="0a32892f65c6f195d4bdaf7f60b3ed037aaaf563" translate="yes" xml:space="preserve">
          <source>Initiates a transport connection for the socket handler</source>
          <target state="translated">Инициирует транспортное соединение для обработчика гнезда</target>
        </trans-unit>
        <trans-unit id="aa4d0a4055c28858395d1bfeafcca50d2acb136f" translate="yes" xml:space="preserve">
          <source>Initiates a transport connection for the socket handler.</source>
          <target state="translated">Инициирует транспортное соединение для обработчика гнезда.</target>
        </trans-unit>
        <trans-unit id="6966f2c2b0c652d66d13404f26dd54080032e919" translate="yes" xml:space="preserve">
          <source>Inits a session used exclusively for testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5d892e49eb5ac8b64c4d52c39e57d5d2b08b77" translate="yes" xml:space="preserve">
          <source>Inline embedded schema</source>
          <target state="translated">Встроенная схема</target>
        </trans-unit>
        <trans-unit id="569dafe164ae502c9b87c69bc2eeb16d3ac20cb7" translate="yes" xml:space="preserve">
          <source>Inserts a single new struct in the data store</source>
          <target state="translated">Вставляет одну новую структуру в хранилище данных</target>
        </trans-unit>
        <trans-unit id="3a1317498687c5894a20801ea9661a9689ed2d87" translate="yes" xml:space="preserve">
          <source>Inserts a single new struct in the data store.</source>
          <target state="translated">Вставляет одну новую структуру в хранилище данных.</target>
        </trans-unit>
        <trans-unit id="86c1d2240ae2916c99327d1f3c4590ec880385b2" translate="yes" xml:space="preserve">
          <source>Inserts a struct defined via &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; or a changeset</source>
          <target state="translated">Вставляет структуру, определенную через &lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; или набор изменений</target>
        </trans-unit>
        <trans-unit id="a079a1b2f8984d465d9779ce849f02a429912d56" translate="yes" xml:space="preserve">
          <source>Inserts a struct defined via &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; or a changeset.</source>
          <target state="translated">Вставляет структуру, определенную через &lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; или набор изменений.</target>
        </trans-unit>
        <trans-unit id="2181d458ad9deb4e6f83faf70ff675628bae0f26" translate="yes" xml:space="preserve">
          <source>Inserts all entries into the repository</source>
          <target state="translated">Вставляет все записи в репозиторий</target>
        </trans-unit>
        <trans-unit id="bc00e3feeb02479984623c1097211a4ee34ffd3d" translate="yes" xml:space="preserve">
          <source>Inserts all entries into the repository.</source>
          <target state="translated">Вставляет все записи в репозиторий.</target>
        </trans-unit>
        <trans-unit id="9a37ef1a0e51e4ac96d292248e7c141eccd65b5f" translate="yes" xml:space="preserve">
          <source>Inserts multiple entries into the data store</source>
          <target state="translated">Вставляет несколько записей в хранилище данных</target>
        </trans-unit>
        <trans-unit id="45c0d55451df6034857c16938433e2842f295184" translate="yes" xml:space="preserve">
          <source>Inserts multiple entries into the data store.</source>
          <target state="translated">Вставляет несколько записей в хранилище данных.</target>
        </trans-unit>
        <trans-unit id="a7003a167a94b7bd8fae5279ac09697a6145d12e" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the changeset was persisted or not</source>
          <target state="translated">Вставляет или обновляет набор изменений в зависимости от того,был ли набор изменений сохранен или нет.</target>
        </trans-unit>
        <trans-unit id="dcd7179acaea39cd9930239b8c9b516c75b3f0b6" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the changeset was persisted or not.</source>
          <target state="translated">Вставляет или обновляет набор изменений в зависимости от того,был ли набор изменений сохранен или нет.</target>
        </trans-unit>
        <trans-unit id="9eeac09af2f2cedab574e42a13a327495bc47759" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the struct is persisted or not</source>
          <target state="translated">Вставляет или обновляет набор изменений в зависимости от того,сохраняется структура или нет</target>
        </trans-unit>
        <trans-unit id="518a7ab088e5ce8ed019df775d78816d42febbe1" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the struct is persisted or not.</source>
          <target state="translated">Вставляет или обновляет набор изменений в зависимости от того,сохраняется структура или нет.</target>
        </trans-unit>
        <trans-unit id="c6d1a59fa5a20ec26ebff17adad30561c03cb5fa" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;select&lt;/code&gt;, &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt; can also be used to cast fragments:</source>
          <target state="translated">Внутри &lt;code&gt;select&lt;/code&gt; , &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt; также может быть использован для фрагментов литых:</target>
        </trans-unit>
        <trans-unit id="1a47e2355f236a87370793356f456cedb8eb6e91" translate="yes" xml:space="preserve">
          <source>Inside our existing IEx shell, let's create a &lt;code&gt;params&lt;/code&gt; map with valid values plus an extra &lt;code&gt;random_key: &quot;random value&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5d902a671eb6810031f5357cbe6027ed13c2f5" translate="yes" xml:space="preserve">
          <source>Inside select: &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#merge/2&quot;&gt;&lt;code&gt;merge/2&lt;/code&gt;&lt;/a&gt; and literals (map, tuples, lists, etc)</source>
          <target state="translated">Внутри select: &lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#merge/2&quot;&gt; &lt;code&gt;merge/2&lt;/code&gt; &lt;/a&gt; и литералы (map, кортежи, списки и т. Д.)</target>
        </trans-unit>
        <trans-unit id="0bcbada89fa45431c089dbafc4a9e45958d6ebde" translate="yes" xml:space="preserve">
          <source>Inside that directory, let's create a new file, &lt;code&gt;hello.greeting.ex&lt;/code&gt;, that looks like this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54208a58823ef0a76c1b1a086d542dde6d472630" translate="yes" xml:space="preserve">
          <source>Inside the scope block, however, we have our first actual route:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="5017ef1ca24c2a0d39b26c970ff7ebac50e027e8" translate="yes" xml:space="preserve">
          <source>Instead do this:</source>
          <target state="translated">Вместо этого сделай это:</target>
        </trans-unit>
        <trans-unit id="82733e655d9772ce9cd06c72fcb7075dc4b7fc14" translate="yes" xml:space="preserve">
          <source>Instead explicitly precompute the assign in your LiveView, outside of render:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c3011cfb0b3891c2ccfb6fb06de6931b311efd" translate="yes" xml:space="preserve">
          <source>Instead of rendering all points with both static and dynamic parts, it returns a &lt;a href=&quot;phoenix.liveview.comprehension&quot;&gt;&lt;code&gt;Phoenix.LiveView.Comprehension&lt;/code&gt;&lt;/a&gt; struct with the static parts, that are shared across all points, and a list of dynamics to be interpolated inside the static parts. If &lt;code&gt;@points&lt;/code&gt; is a list with &lt;code&gt;%{x: 1, y: 2}&lt;/code&gt; and &lt;code&gt;%{x: 3, y: 4}&lt;/code&gt;, the above expression would return:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f49b4a03d02b3492955bbf412c1bec4c46145a" translate="yes" xml:space="preserve">
          <source>Instead of setting the action manually, you may use &lt;a href=&quot;#apply_action/2&quot;&gt;&lt;code&gt;apply_action/2&lt;/code&gt;&lt;/a&gt; that emulates operations such as &lt;code&gt;Repo.insert&lt;/code&gt;. &lt;a href=&quot;#apply_action/2&quot;&gt;&lt;code&gt;apply_action/2&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;{:ok, changes}&lt;/code&gt; if the changeset is valid or &lt;code&gt;{:error, changeset}&lt;/code&gt;, with the given &lt;code&gt;action&lt;/code&gt; set in the changeset in case of errors.</source>
          <target state="translated">Вместо того, чтобы устанавливать действие вручную, вы можете использовать &lt;a href=&quot;#apply_action/2&quot;&gt; &lt;code&gt;apply_action/2&lt;/code&gt; ,&lt;/a&gt; которая имитирует такие операции, как &lt;code&gt;Repo.insert&lt;/code&gt; . &lt;a href=&quot;#apply_action/2&quot;&gt; &lt;code&gt;apply_action/2&lt;/code&gt; &lt;/a&gt; вернет &lt;code&gt;{:ok, changes}&lt;/code&gt; если набор изменений действителен, или &lt;code&gt;{:error, changeset}&lt;/code&gt; , с заданным &lt;code&gt;action&lt;/code&gt; установленным в наборе изменений, в случае ошибок.</target>
        </trans-unit>
        <trans-unit id="dc625090b0eb339994af40957b6fb0d89ad3361f" translate="yes" xml:space="preserve">
          <source>Instead pass only the keys that you need:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7be3c09bff9978d92d18ecc6c00bb68ff1fa61" translate="yes" xml:space="preserve">
          <source>Instead we can define a Module Plug which knows how to handle these error cases specifically. Since controllers are Module Plugs, let's define our Plug as a controller:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b20dbf47e354f9fd0db114ae3112acc37f568e" translate="yes" xml:space="preserve">
          <source>Instead, it is much simpler to create a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3849a580f55e6b3b71f03e8f33c8ec65f16bcdd1" translate="yes" xml:space="preserve">
          <source>Instead, use a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab4eded4494d51c420236d3c9dde1cb217c024c" translate="yes" xml:space="preserve">
          <source>Instead, you can see the valid options for ciphers in the Erlang SSL documentation: http://erlang.org/doc/man/ssl.html</source>
          <target state="translated">Вместо этого вы можете посмотреть действительные варианты шифровки в документации Erlang SSL:http://erlang.org/doc/man/ssl.html.</target>
        </trans-unit>
        <trans-unit id="cb49b30bf89c4f1a8a29b63caa0a66ed1c9abce4" translate="yes" xml:space="preserve">
          <source>Instrumentation</source>
          <target state="translated">Instrumentation</target>
        </trans-unit>
        <trans-unit id="e963ac54f9b90e504ad8b5131dedaa40800f87bf" translate="yes" xml:space="preserve">
          <source>Instrumenter to handle logging of various instrumentation events.</source>
          <target state="translated">Прибор для протоколирования различных приборостроительных событий.</target>
        </trans-unit>
        <trans-unit id="0a977fa7c155d5db26b9805f1ed5ecb306366925" translate="yes" xml:space="preserve">
          <source>Instruments the given function using the instrumentation provided by the given endpoint</source>
          <target state="translated">Приборы данной функции с использованием приборов,предусмотренных данной конечной точкой.</target>
        </trans-unit>
        <trans-unit id="040ea1fc514e828951fb8bd3d4e6583bf2dab63c" translate="yes" xml:space="preserve">
          <source>Instruments the given function using the instrumentation provided by the given endpoint.</source>
          <target state="translated">Приборы данной функции используют приборы,предоставленные данной конечной точкой.</target>
        </trans-unit>
        <trans-unit id="a4c71d7db6768276e995bf083955f4cf532a2661" translate="yes" xml:space="preserve">
          <source>Integers: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;</source>
          <target state="translated">Целые числа: &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="199cf4a624177d7b6a2189975011d8cf1553a6ea" translate="yes" xml:space="preserve">
          <source>Intercepting Outgoing Events</source>
          <target state="translated">Перехват исходящих событий</target>
        </trans-unit>
        <trans-unit id="e70cfbd4ab25034bd13454c2505b73098457ac1c" translate="yes" xml:space="preserve">
          <source>Intercepts outgoing &lt;code&gt;event&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="280e1b21a8fbf76997de6dc3b8694bbd51187d4e" translate="yes" xml:space="preserve">
          <source>Interestingly, we can use multiple scopes with the same path as long as we are careful not to duplicate routes. This router is perfectly fine with two scopes defined for the same path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352256d32ca814a08dd6fb42ea6e24113694d807" translate="yes" xml:space="preserve">
          <source>Internal function for integrating associations into schemas</source>
          <target state="translated">Внутренняя функция для интеграции ассоциаций в схемы</target>
        </trans-unit>
        <trans-unit id="eb704a4d49662206b6263bee9e3a6a682a47856e" translate="yes" xml:space="preserve">
          <source>Internal function for integrating associations into schemas.</source>
          <target state="translated">Внутренняя функция для интеграции ассоциаций в схемы.</target>
        </trans-unit>
        <trans-unit id="60fcb5d998d297a0c11dd2b6af2c754859e11297" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; behaviour, which means both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions are defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd342be42586a26dea11e10d4f2f734d1e7b515" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; behaviour, which means both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions are defined.</source>
          <target state="translated">Внутри &lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; реализует поведение &lt;a href=&quot;plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; , что означает, что определены функции &lt;code&gt;init/1&lt;/code&gt; и &lt;code&gt;call/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="9e19e8e52d010a3380d2cbbab62c90af63b8d211" translate="yes" xml:space="preserve">
          <source>Interpolation and casting</source>
          <target state="translated">Интерполяция и литьё</target>
        </trans-unit>
        <trans-unit id="28f682fd32feb69dea4dd4ff7adfaeaa1d1cf34e" translate="yes" xml:space="preserve">
          <source>Intersect expression returns only unique rows as if each query returned distinct results. This may cause performance penalty. If you need just to take the intersection of multiple result sets without removing duplicate rows consider using &lt;a href=&quot;#intersect_all/2&quot;&gt;&lt;code&gt;intersect_all/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Выражение пересечения возвращает только уникальные строки, как если бы каждый запрос возвращал разные результаты. Это может привести к снижению производительности. Если вам нужно просто пересечь несколько наборов результатов, не удаляя повторяющиеся строки, рассмотрите возможность использования &lt;a href=&quot;#intersect_all/2&quot;&gt; &lt;code&gt;intersect_all/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99267cc8937fb84d59bd60cc8326f8d752393db1" translate="yes" xml:space="preserve">
          <source>Intervals</source>
          <target state="translated">Intervals</target>
        </trans-unit>
        <trans-unit id="39fc639ab5236d70b6020dbbd7562331428b523c" translate="yes" xml:space="preserve">
          <source>Introduction - the guides you are currently reading. They will cover how to get your first application up and running</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4f328eabc744329e26e1140102953b7cc0083e" translate="yes" xml:space="preserve">
          <source>Intuitively, you would assume the following events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ee41c074ac477895b057c2f41a57f16a778949" translate="yes" xml:space="preserve">
          <source>Invoke this function for each possible value you want to be sent to the server.</source>
          <target state="translated">Вызовите эту функцию для каждого возможного значения,которое вы хотите отправить на сервер.</target>
        </trans-unit>
        <trans-unit id="619c9c50996959b8e8f2beefe6dce08a85ac4c47" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;</source>
          <target state="translated">Вызывается для доступа к значению, хранящемуся под &lt;code&gt;key&lt;/code&gt; в данном &lt;code&gt;term&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">Вызывается для доступа к значению, хранящемуся под &lt;code&gt;key&lt;/code&gt; в данном термине &lt;code&gt;term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3cf9b446c97f792217c895b34619fd73d2391b8" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time</source>
          <target state="translated">Вызывается для доступа к значению под &lt;code&gt;key&lt;/code&gt; и одновременного его обновления.</target>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="translated">Вызывается для доступа к значению под &lt;code&gt;key&lt;/code&gt; и одновременного его обновления.</target>
        </trans-unit>
        <trans-unit id="36dca7d832107fe8c35259472cc9700cfe1e2dbf" translate="yes" xml:space="preserve">
          <source>Invoked on termination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733a4970520b6a464600ddd46a5ea64dba2a7375" translate="yes" xml:space="preserve">
          <source>Invoked to &amp;ldquo;pop&amp;rdquo; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure</source>
          <target state="translated">Вызывается для &amp;laquo;выталкивания&amp;raquo; значения под &lt;code&gt;key&lt;/code&gt; из данной структуры данных</target>
        </trans-unit>
        <trans-unit id="742607736cb1addcde99f49aeedd51a191858b29" translate="yes" xml:space="preserve">
          <source>Invoked to &amp;ldquo;pop&amp;rdquo; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="translated">Вызывается для &amp;laquo;выталкивания&amp;raquo; значения под &lt;code&gt;key&lt;/code&gt; из данной структуры данных.</target>
        </trans-unit>
        <trans-unit id="f35bf2a44d8213b1a251a0c82fa8bd2d26bc1736" translate="yes" xml:space="preserve">
          <source>Invoked when the channel process is about to exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f50a5fe51f51ed7bfe665e624200109386cacc" translate="yes" xml:space="preserve">
          <source>Invoked when the endpoint supervisor starts, allows dynamically configuring the endpoint from system environment or other runtime sources.</source>
          <target state="translated">Запрашивается при запуске супервайзера конечной точки,позволяет динамически настраивать конечную точку из системного окружения или других источников выполнения.</target>
        </trans-unit>
        <trans-unit id="dadda151ad04d6534ebf813dc99705a1a1d25aa9" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns</source>
          <target state="translated">Вызывается при запуске сервера. &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;start/3&lt;/code&gt; будет блокироваться, пока не вернется</target>
        </trans-unit>
        <trans-unit id="fe65c1df5bce54718f5a6ea6e98b5d9c1a779a60" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns.</source>
          <target state="translated">Вызывается при запуске сервера. &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;start/3&lt;/code&gt; будут заблокированы, пока не вернутся .</target>
        </trans-unit>
        <trans-unit id="1a0516c7f6572d24052272cc4f229ec6f77d29e2" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;code&gt;start_link/3&lt;/code&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns</source>
          <target state="translated">Вызывается при запуске сервера. &lt;code&gt;start_link/3&lt;/code&gt; или &lt;code&gt;start/3&lt;/code&gt; будет блокироваться, пока не вернется</target>
        </trans-unit>
        <trans-unit id="092a9376001bb69648a2c2cf84aeeda23d64be60" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;code&gt;start_link/3&lt;/code&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns.</source>
          <target state="translated">Вызывается при запуске сервера. &lt;code&gt;start_link/3&lt;/code&gt; или &lt;code&gt;start/3&lt;/code&gt; будут заблокированы, пока не вернутся .</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c22586bb54f63849624411c842f2723bc94a4ec" translate="yes" xml:space="preserve">
          <source>It accepts an expression representing the path and many options allowing the match to be configured.</source>
          <target state="translated">Он принимает выражение,представляющее путь,и множество опций,позволяющих настроить соответствие.</target>
        </trans-unit>
        <trans-unit id="e9e7a6e5fc7e8d490f61f816d70fa682574386e8" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#read_body/2&quot;&gt;&lt;code&gt;read_body/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Он принимает те же параметры, что и &lt;a href=&quot;#read_body/2&quot;&gt; &lt;code&gt;read_body/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09ea74617913e32e5cdeb3c90a896c1320876968" translate="yes" xml:space="preserve">
          <source>It also supports custom adapter configuration:</source>
          <target state="translated">Он также поддерживает пользовательскую конфигурацию адаптера:</target>
        </trans-unit>
        <trans-unit id="bed9aed2b3feb53ce6e2576687d31f3c4e20815c" translate="yes" xml:space="preserve">
          <source>It always returns &lt;code&gt;:ok&lt;/code&gt;. To assert on the flash message, you can assert on the result of the rendered LiveView.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595822e1d20d7f428a3ef05e5d7b881101ea3807" translate="yes" xml:space="preserve">
          <source>It begins by configuring our &lt;code&gt;otp_app&lt;/code&gt; name and repo module. Then it sets the adapter &amp;ndash; Postgres, in our case. It also sets our login credentials. Of course, you can change these to match your actual credentials if they are different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726bf51434f75d8acf5e951711360513b2a0f6e9" translate="yes" xml:space="preserve">
          <source>It builds a new &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt;, invokes the handler &lt;code&gt;connect/2&lt;/code&gt; callback and returns the result.</source>
          <target state="translated">Он создает новый &lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; &lt;/a&gt; , вызывает обработчик обратного вызова &lt;code&gt;connect/2&lt;/code&gt; и возвращает результат.</target>
        </trans-unit>
        <trans-unit id="a2cee1f656545c050d15a435216908ba321f2198" translate="yes" xml:space="preserve">
          <source>It can be mounted in your endpoint like any other socket:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b86f00ae4f81180f207fb516f99df0d0c9b931" translate="yes" xml:space="preserve">
          <source>It can be used to derive a number of keys for various purposes from a given secret. This lets applications have a single secure secret, but avoid reusing that key in multiple incompatible contexts.</source>
          <target state="translated">Он может быть использован для получения ряда ключей для различных целей из заданного секрета.Это позволяет приложениям иметь единый безопасный секрет,но избегать повторного использования этого ключа в нескольких несовместимых контекстах.</target>
        </trans-unit>
        <trans-unit id="23758d8b77b97b076e10f03ba6b30fb6fdbbbd09" translate="yes" xml:space="preserve">
          <source>It can either be a keyword query or a query expression.</source>
          <target state="translated">Это может быть как запрос по ключевому слову,так и выражение запроса.</target>
        </trans-unit>
        <trans-unit id="186c38e14a6722baf34f425fa70665e109fc23a0" translate="yes" xml:space="preserve">
          <source>It can reset many fields except the query source (&lt;code&gt;from&lt;/code&gt;). When excluding a &lt;code&gt;:join&lt;/code&gt;, it will remove &lt;em&gt;all&lt;/em&gt; types of joins. If you prefer to remove a single type of join, please see paragraph below.</source>
          <target state="translated">Он может сбрасывать многие поля, кроме источника запроса ( &lt;code&gt;from&lt;/code&gt; ). При исключении &lt;code&gt;:join&lt;/code&gt; удаляются &lt;em&gt;все&lt;/em&gt; типы объединений. Если вы предпочитаете удалить один тип соединения, см. Абзац ниже.</target>
        </trans-unit>
        <trans-unit id="19ab39633586fe70e0d92fb43a531d87dd58c9ee" translate="yes" xml:space="preserve">
          <source>It defaults to 5_000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3f06b0deaf4213087d2af935c667afca3512ce" translate="yes" xml:space="preserve">
          <source>It escapes quotes (double and single), double backslashes and others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452abe794374c8a4220fd3958f7c982cbc75a77b" translate="yes" xml:space="preserve">
          <source>It expects &lt;code&gt;{:safe, body}&lt;/code&gt; as a safe response or body as a string which will be HTML escaped.</source>
          <target state="translated">Он ожидает &lt;code&gt;{:safe, body}&lt;/code&gt; как безопасный ответ или тело как строку, которая будет экранирована HTML.</target>
        </trans-unit>
        <trans-unit id="8540fa79ebeeb04321b6937468baa86cf4bdc0a6" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:chunked&lt;/code&gt; afterwards. Otherwise raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Он ожидает соединения, которое еще не было &lt;code&gt;:sent&lt;/code&gt; и впоследствии устанавливает его состояние в &lt;code&gt;:chunked&lt;/code&gt; . В противном случае вызывает &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="acabec8dab50a30917f688b209245a29971cc577" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:chunked&lt;/code&gt; afterwards. Otherwise, raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;. After &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt; is called, chunks can be sent to the client via the &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;chunk/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Он ожидает соединения, которое еще не было &lt;code&gt;:sent&lt;/code&gt; и впоследствии устанавливает его состояние в &lt;code&gt;:chunked&lt;/code&gt; . В противном случае вызывает &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; . После &lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt; фрагменты могут быть отправлены клиенту с помощью функции &lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;chunk/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90c8ac9c1aa8ddc9982ee763c945c57e9b9465d7" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:file&lt;/code&gt; afterwards. Otherwise raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Он ожидает соединения, которое еще не было &lt;code&gt;:sent&lt;/code&gt; и впоследствии устанавливает его состояние в &lt;code&gt;:file&lt;/code&gt; . В противном случае вызывает &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe68caa8735b3dcb8f4a5c0b34b1b868f77311e" translate="yes" xml:space="preserve">
          <source>It expects a connection with state &lt;code&gt;:chunked&lt;/code&gt; as set by &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;. It returns &lt;code&gt;{:ok, conn}&lt;/code&gt; in case of success, otherwise &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt; соединение с state &lt;code&gt;:chunked&lt;/code&gt; , как установлено send_chunked / 2 . В случае успеха он возвращает &lt;code&gt;{:ok, conn}&lt;/code&gt; в противном случае - &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a89874718d53663a7182056d1005a29e9ce37ec6" translate="yes" xml:space="preserve">
          <source>It expects a name or a PID representing a repo.</source>
          <target state="translated">Он ожидает имя или PID,представляющее собой репо.</target>
        </trans-unit>
        <trans-unit id="acb7e336ed29d294c4566b6d952ca3d23d9cfb62" translate="yes" xml:space="preserve">
          <source>It expects a schema module (&lt;code&gt;MyApp.User&lt;/code&gt;) or a source (&lt;code&gt;&quot;users&quot;&lt;/code&gt;) or both (&lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt;) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps.</source>
          <target state="translated">В качестве первого аргумента он ожидает модуль схемы ( &lt;code&gt;MyApp.User&lt;/code&gt; ) или источник ( &lt;code&gt;&quot;users&quot;&lt;/code&gt; ) или оба ( &lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt; ). Второй аргумент - это список записей, которые нужно вставить, либо в виде списков ключевых слов, либо в виде карт.</target>
        </trans-unit>
        <trans-unit id="e373615ede0cb68b0ddc4b7d19e01255f7ceb5ec" translate="yes" xml:space="preserve">
          <source>It expects a schema module (&lt;code&gt;MyApp.User&lt;/code&gt;) or a source (&lt;code&gt;&quot;users&quot;&lt;/code&gt;) or both (&lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt;) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps. The keys of the entries are the field names as atoms and the value should be the respective value for the field type or, optionally, an &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; that returns a single entry with a single value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833cf1288bb8a29f6137f917618b60a72a57a732" translate="yes" xml:space="preserve">
          <source>It expects the connection state to be &lt;code&gt;:set&lt;/code&gt;, otherwise raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; for &lt;code&gt;:unset&lt;/code&gt; connections or a &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; for already &lt;code&gt;:sent&lt;/code&gt; connections.</source>
          <target state="translated">Он ожидает, что состояние соединения будет &lt;code&gt;:set&lt;/code&gt; , в противном случае возникает &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; для &lt;code&gt;:unset&lt;/code&gt; соединений или &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; для уже &lt;code&gt;:sent&lt;/code&gt; соединений.</target>
        </trans-unit>
        <trans-unit id="0a5b52d3a097156da96dfb9a0fc91d7fc8826359" translate="yes" xml:space="preserve">
          <source>It expects the current LiveView, a query selector, and a text filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb5bf8f84e63e5c41f8e19268de1412b7da7891" translate="yes" xml:space="preserve">
          <source>It expects the current LiveView, a query selector, and the form data. The query selector must return a single element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13049f4b2fe95fa18841a16d72fe416ecdcdc085" translate="yes" xml:space="preserve">
          <source>It expects the name of the otp app as the first argument and for the command to be run inside your umbrella application's apps directory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6924324cbc62c482292289a444954ec7291d8685" translate="yes" xml:space="preserve">
          <source>It expects the name of the project as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fca821bf0466e51b6ba5d79e2a1aa5f069282af" translate="yes" xml:space="preserve">
          <source>It expects the path of the project as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08038ecbe054a873bb08a6b11a9614856a8f9ff2" translate="yes" xml:space="preserve">
          <source>It expects the value of &lt;code&gt;get_session(conn, &quot;_csrf_token&quot;)&lt;/code&gt;. It returns &lt;code&gt;nil&lt;/code&gt; if there is no state in the session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c2fa1bb2a3b72c645dc3842e1b860a47918db6" translate="yes" xml:space="preserve">
          <source>It expects the view module, the template as a string, and a set of assigns.</source>
          <target state="translated">Он ожидает модуль представления,шаблон как строку и набор назначений.</target>
        </trans-unit>
        <trans-unit id="31903f698d3d42eef26a2983ba701e0cade71b54" translate="yes" xml:space="preserve">
          <source>It expects three parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f16d994b67422cffaafcda9f7a4a44b5dac9b6a" translate="yes" xml:space="preserve">
          <source>It has to return a supervisor child specification.</source>
          <target state="translated">Он должен вернуть спецификацию ребенка-надзирателя.</target>
        </trans-unit>
        <trans-unit id="4b418dc1717675b2c364bf1025422ff35a375736" translate="yes" xml:space="preserve">
          <source>It implements the required &lt;a href=&quot;#child_spec/3&quot;&gt;&lt;code&gt;child_spec/3&lt;/code&gt;&lt;/a&gt; function as well as the handler for the WebSocket transport.</source>
          <target state="translated">Он реализует необходимую &lt;a href=&quot;#child_spec/3&quot;&gt; &lt;code&gt;child_spec/3&lt;/code&gt; &lt;/a&gt; а также обработчик для транспорта WebSocket.</target>
        </trans-unit>
        <trans-unit id="7050d3a8bafe3360f1738cb2135b721856f7ed7b" translate="yes" xml:space="preserve">
          <source>It implements the required &lt;code&gt;child_spec/3&lt;/code&gt; function as well as the handler for the WebSocket transport.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="078983c5e35a9c8a686a6ae53ccec194f56ab546" translate="yes" xml:space="preserve">
          <source>It invokes the &lt;code&gt;validator&lt;/code&gt; function to perform the validation only if a change for the given &lt;code&gt;field&lt;/code&gt; exists and the change value is not &lt;code&gt;nil&lt;/code&gt;. The function must return a list of errors (with an empty list meaning no errors).</source>
          <target state="translated">Он вызывает функцию &lt;code&gt;validator&lt;/code&gt; для выполнения проверки, только если изменение для данного &lt;code&gt;field&lt;/code&gt; существует и значение изменения не равно &lt;code&gt;nil&lt;/code&gt; . Функция должна возвращать список ошибок (пустой список означает отсутствие ошибок).</target>
        </trans-unit>
        <trans-unit id="b32bb8330646b67711708edabee82d77ea1330ee" translate="yes" xml:space="preserve">
          <source>It is advised to do as little work as possible when handling errors and avoid accessing data like parameters and session, as the parsing of those is what could have led the error to trigger in the first place.</source>
          <target state="translated">Рекомендуется делать как можно меньше работы при работе с ошибками и избегать доступа к таким данным,как параметры и сеанс,так как именно разбор этих данных мог привести к возникновению ошибки в первую очередь.</target>
        </trans-unit>
        <trans-unit id="a9bfb318603777a6353f70162343fdb59351cda5" translate="yes" xml:space="preserve">
          <source>It is also important not to confuse &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;phoenix.view#render/3&quot;&gt;&lt;code&gt;Phoenix.View.render/3&lt;/code&gt;&lt;/a&gt;. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2327b2734d4abd79bc9e71baaac2419dacff235" translate="yes" xml:space="preserve">
          <source>It is also important not to confuse &lt;a href=&quot;phoenix.controller#render/3&quot;&gt;&lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;phoenix.view#render/3&quot;&gt;&lt;code&gt;Phoenix.View.render/3&lt;/code&gt;&lt;/a&gt;. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</source>
          <target state="translated">Также важно не путать &lt;a href=&quot;phoenix.controller#render/3&quot;&gt; &lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt; &lt;/a&gt; с &lt;a href=&quot;phoenix.view#render/3&quot;&gt; &lt;code&gt;Phoenix.View.render/3&lt;/code&gt; &lt;/a&gt; . Первый ожидает соединение и полагается на согласование содержимого, в то время как второй не зависит от соединения и обычно вызывается из ваших представлений.</target>
        </trans-unit>
        <trans-unit id="6a11a5417c769069994d2708a4c685591dad9818" translate="yes" xml:space="preserve">
          <source>It is also important to keep in mind that LiveViews are stateful. Therefore, if you load any data on &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and the data itself changes, the data won't be automatically propagated to the LiveView, unless you broadcast those events with &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a635280fb829c46f3ffad5a5d1753b1e733763d" translate="yes" xml:space="preserve">
          <source>It is also important to specify your handlers first, otherwise Phoenix will intercept the requests before they get to your handler.</source>
          <target state="translated">Также важно сначала указать обработчики,иначе Phoenix будет перехватывать запросы до того,как они попадут к вашему обработчику.</target>
        </trans-unit>
        <trans-unit id="30055e2131468401399af6d6f093161c25f60030" translate="yes" xml:space="preserve">
          <source>It is also not possible to use &lt;code&gt;insert_all&lt;/code&gt; to insert across multiple tables, therefore associations are not supported.</source>
          <target state="translated">Также невозможно использовать &lt;code&gt;insert_all&lt;/code&gt; для вставки в несколько таблиц, поэтому ассоциации не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="5881689e685ad3746b2176daf7ae680c41d23de2" translate="yes" xml:space="preserve">
          <source>It is also possible to assign data to the &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; that will be available to any plug invoked after the &lt;code&gt;:match&lt;/code&gt; plug. This is very useful if you want a matched route to customize how later plugs will behave.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b8d8d53d8d8d7bd2e2cb61ea0c656280b0dd19" translate="yes" xml:space="preserve">
          <source>It is also possible to interpolate an Ecto query on the right side of &lt;code&gt;in&lt;/code&gt;. For example, the query above can also be written as:</source>
          <target state="translated">Также можно интерполировать запрос Ecto в правой части &lt;code&gt;in&lt;/code&gt; . Например, приведенный выше запрос можно также записать как:</target>
        </trans-unit>
        <trans-unit id="f21ad6a95ad909158ac71de812586e3b7701491a" translate="yes" xml:space="preserve">
          <source>It is also possible to interpolate the whole keyword list, allowing you to dynamically filter the source:</source>
          <target state="translated">Также возможна интерполяция всего списка ключевых слов,что позволяет динамически фильтровать источник:</target>
        </trans-unit>
        <trans-unit id="42a3ef7d36b21828db375bf831fd19d83692ffc6" translate="yes" xml:space="preserve">
          <source>It is also possible to nest resources in a Phoenix router. Let's say we also have a &lt;code&gt;posts&lt;/code&gt; resource which has a many-to-one relationship with &lt;code&gt;users&lt;/code&gt;. That is to say, a user can create many posts, and an individual post belongs to only one user. We can represent that by adding a nested route in &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767bbb26545ab7a71781118c61665b361ea9b2c7" translate="yes" xml:space="preserve">
          <source>It is also possible to pass additional session information to the LiveView through a session parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5529f115beed361dd6ff5307741dbc9a975d8d" translate="yes" xml:space="preserve">
          <source>It is also possible to say the type must match the same of a column:</source>
          <target state="translated">Также можно сказать,что тип должен совпадать с типом колонки:</target>
        </trans-unit>
        <trans-unit id="731c24ca319f444e53ad6c345b4820aa7c05979b" translate="yes" xml:space="preserve">
          <source>It is also possible to select a struct and limit the returned fields at the same time:</source>
          <target state="translated">Также можно одновременно выбрать структуру и ограничить возвращаемые поля:</target>
        </trans-unit>
        <trans-unit id="70a7d66c051591aae4846e19708e277358bb5702" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; directly or even run your own pubsub backends outside of an Endpoint.</source>
          <target state="translated">Также можно использовать &lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; напрямую или даже запускать собственные серверные части pubsub вне конечной точки.</target>
        </trans-unit>
        <trans-unit id="a80ee5c83f90af2cbd062b219e7dd0adf9de15c1" translate="yes" xml:space="preserve">
          <source>It is common for a LiveView to have multiple states and multiple URLs. For example, you can have a single LiveView that lists all articles on your web app. For each article there is an &quot;Edit&quot; button which, when pressed, opens up a modal on the same page to edit the article. It is a best practice to use live navigation in those cases, so when you click edit, the URL changes to &quot;/articles/1/edit&quot;, even though you are still within the same LiveView. Similarly, you may also want to show a &quot;New&quot; button, which opens up the modal to create new entries, and you want this to be reflected in the URL as &quot;/articles/new&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a719d875929b73a5f638e46b11bc306d0aaee72" translate="yes" xml:space="preserve">
          <source>It is compiled to:</source>
          <target state="translated">Он составлен для:</target>
        </trans-unit>
        <trans-unit id="5f416c91fdafe72dbbea13ab378ff98cfdfba3e1" translate="yes" xml:space="preserve">
          <source>It is composed of the following fields:</source>
          <target state="translated">Он состоит из следующих полей:</target>
        </trans-unit>
        <trans-unit id="92a07cde7a7c28b24072256a01215dba443d5ba7" translate="yes" xml:space="preserve">
          <source>It is important that &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; is placed before the &lt;code&gt;:dispatch&lt;/code&gt; plug in the pipeline, otherwise the matched clause route will not receive the parsed body in its &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; argument when dispatched.</source>
          <target state="translated">Важно, чтобы &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; помещался перед подключаемым модулем &lt;code&gt;:dispatch&lt;/code&gt; в конвейере, в противном случае маршрут сопоставленного предложения не получит проанализированное тело в своем аргументе &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; при отправке.</target>
        </trans-unit>
        <trans-unit id="a2e2246bf2f06464052843a1b73d10ceadd7820b" translate="yes" xml:space="preserve">
          <source>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to &quot;html&quot; format whenever:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d959bc56d3f9eacdf442d02254dff9bed2d3a24c" translate="yes" xml:space="preserve">
          <source>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to &amp;ldquo;html&amp;rdquo; format whenever:</source>
          <target state="translated">Важно отметить, что браузеры исторически отправляли неверные заголовки приема. По этой причине эта функция по умолчанию будет использовать формат &amp;laquo;html&amp;raquo; всякий раз, когда:</target>
        </trans-unit>
        <trans-unit id="afc85cab7e33f056d309bd20e21206dd571d1b09" translate="yes" xml:space="preserve">
          <source>It is not possible to directly configure the port in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; because HSTS expects the port to be 443 for SSL. If you are not using HSTS and want to redirect to HTTPS on another port, you can sneak it alongside the host, for example: &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df7a21de3fad9373d1e80d0a68fb9c2af463623" translate="yes" xml:space="preserve">
          <source>It is not possible to directly configure the port in &lt;a href=&quot;plug.ssl#content&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; because HSTS expects the port to be 443 for SSL. If you are not using HSTS and wants to redirect to HTTPS on another port, you can sneak it alongside the host, for example: &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt;.</source>
          <target state="translated">Невозможно напрямую настроить порт в &lt;a href=&quot;plug.ssl#content&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; ,&lt;/a&gt; поскольку HSTS ожидает, что порт будет 443 для SSL. Если вы не используете HSTS и хотите перенаправить на HTTPS на другой порт, вы можете скрыть его вместе с хостом, например: &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb866ba422c5f8373a8e029337285f653ad8d5ad" translate="yes" xml:space="preserve">
          <source>It is not possible to represent all possible database queries using Ecto&amp;rsquo;s query syntax. When such is required, it is possible to use fragments to send any expression to the database:</source>
          <target state="translated">Невозможно представить все возможные запросы к базе данных с использованием синтаксиса запросов Ecto. Когда это необходимо, можно использовать фрагменты для отправки любого выражения в базу данных:</target>
        </trans-unit>
        <trans-unit id="c1ce5ae4e3f70bf7bcfc04fd5cadb18e0b1c097f" translate="yes" xml:space="preserve">
          <source>It is not possible to represent all possible database queries using Ecto's query syntax. When such is required, it is possible to use fragments to send any expression to the database:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f6c0d9ff724f7de2dd203438fa29365111d1aa" translate="yes" xml:space="preserve">
          <source>It is possible to add custom media types to your Phoenix application. The first step is to teach Plug about those new media types in your &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">В приложение Phoenix можно добавлять пользовательские типы мультимедиа. Первый шаг - рассказать Plug об этих новых типах мультимедиа в файле &lt;code&gt;config/config.exs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aa42a2a034d292f94558a8e07cc5079c64f6d273" translate="yes" xml:space="preserve">
          <source>It is possible to bundle the certificate files with the application, possibly for packaging into a release. In this case the files must be stored under the application's 'priv' directory. The &lt;code&gt;otp_app&lt;/code&gt; option must be set to the name of the OTP application that contains the files, in order to correctly resolve the relative paths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6fa08a29b74dfb5f5b32afcba99b61a22649c51" translate="yes" xml:space="preserve">
          <source>It is possible to include variables in the path, these will be available in the &lt;code&gt;params&lt;/code&gt; that are passed to the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e2d8626fbe4ef6e2589dce4fc2dd6762fe2a1b8" translate="yes" xml:space="preserve">
          <source>It is possible to make use of PostgreSQL&amp;rsquo;s JSON/JSONB data type with fragments, as well:</source>
          <target state="translated">Также можно использовать тип данных PostgreSQL JSON / JSONB с фрагментами:</target>
        </trans-unit>
        <trans-unit id="5ef6e9ed5dbdf5b36ce6e79f0b64c7e18c4f11c1" translate="yes" xml:space="preserve">
          <source>It is possible to set a prefix for the queries. For Postgres users, this will specify the schema where the table is located, while for MySQL users this will specify the database where the table is located. When no prefix is set, Postgres queries are assumed to be in the public schema, while MySQL queries are assumed to be in the database set in the config for the repo.</source>
          <target state="translated">Можно установить префикс для запросов.Для пользователей Postgres это укажет схему,в которой находится таблица,а для пользователей MySQL это укажет БД,в которой находится таблица.Если префикс не задан,то запросы Postgres предполагаются в публичной схеме,в то время как MySQL запросы предполагаются в базе данных,заданной в конфигурации для репозитория.</target>
        </trans-unit>
        <trans-unit id="700c0f421fd3cd0dfcac1f7b125e6e262daac824" translate="yes" xml:space="preserve">
          <source>It is possible to set:</source>
          <target state="translated">Можно установить:</target>
        </trans-unit>
        <trans-unit id="90c2522cafce21dec34e2ada4a5ef033ed999c16" translate="yes" xml:space="preserve">
          <source>It is possible to specify a &lt;code&gt;:where&lt;/code&gt; option that will filter the records returned by the association. Querying, joining or preloading the association will use the given conditions as shown next:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ec728a65755ba3d79cf56f0945ca98b6fece30" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lower-case, to avoid sending duplicate keys in a request. As a convenience, this is validated during testing which raises a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt; if the header key is not lowercase.</source>
          <target state="translated">Рекомендуется, чтобы ключи заголовка были в нижнем регистре, чтобы избежать отправки повторяющихся ключей в запросе. Для удобства это проверяется во время тестирования, которое вызывает &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; &lt;/a&gt; если ключ заголовка не в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="b406934b6940f484ccb4f4e12d7de52338c19b17" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren't lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40511b3383ca8f06336921afea27344c64c63c88" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren&amp;rsquo;t lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Рекомендуется, чтобы ключи заголовка были в нижнем регистре, чтобы избежать отправки повторяющихся ключей в запросе. Для удобства при использовании адаптера &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; любые заголовки, которые не являются строчными, &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e835d630e658a66295e09f0cfb72bb2ca5635f8b" translate="yes" xml:space="preserve">
          <source>It is recommended to declare your &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt; field with type &lt;code&gt;:map&lt;/code&gt; and a default of &lt;code&gt;&quot;[]&quot;&lt;/code&gt; (although Ecto will also automatically translate &lt;code&gt;nil&lt;/code&gt; values from the database into empty lists).</source>
          <target state="translated">Рекомендуется объявить поле &lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt; с типом &lt;code&gt;:map&lt;/code&gt; и значением по умолчанию &lt;code&gt;&quot;[]&quot;&lt;/code&gt; (хотя Ecto также автоматически переводит значения &lt;code&gt;nil&lt;/code&gt; из базы данных в пустые списки).</target>
        </trans-unit>
        <trans-unit id="06eb543ba97430c42676fb74fc38e6d03236b950" translate="yes" xml:space="preserve">
          <source>It is recommended to declare your &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt; field with type &lt;code&gt;:map&lt;/code&gt; in your migrations, instead of using &lt;code&gt;{:array, :map}&lt;/code&gt;. Ecto can work with both maps and arrays as the container for embeds (and in most databases map are represented as JSON which allows Ecto to choose what works best).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9795c1abaf982033b2c0ed19994a9b57e226ca48" translate="yes" xml:space="preserve">
          <source>It is recommended to generate a custom set of Diffie Hellman parameters, to be used for the DHE key exchange. Use the following OpenSSL CLI command to create a &amp;lsquo;dhparam.pem&amp;rsquo; file:</source>
          <target state="translated">Рекомендуется создать собственный набор параметров Диффи Хеллмана, который будет использоваться для обмена ключами DHE. Используйте следующую команду OpenSSL CLI для создания файла dhparam.pem:</target>
        </trans-unit>
        <trans-unit id="b6125fd22c0937a1706898816d0d97050f844cc0" translate="yes" xml:space="preserve">
          <source>It is recommended to generate a custom set of Diffie-Hellman parameters, to be used for the DHE key exchange. Use the following OpenSSL CLI command to create a &lt;code&gt;dhparam.pem&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed21c543268df4242ce9c821e6a091cd15a3cd4" translate="yes" xml:space="preserve">
          <source>It is recommended to include this metadata configuration in your production configuration file.</source>
          <target state="translated">Рекомендуется включить эту конфигурацию метаданных в рабочий конфигурационный файл.</target>
        </trans-unit>
        <trans-unit id="ee450f18792f77e7f28caa695a4e8a21ae132da1" translate="yes" xml:space="preserve">
          <source>It is recommended to only use this module in production if SSL is enabled and enforced. See &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f5e912f003026e9540afe4bf51bf871b3398c0" translate="yes" xml:space="preserve">
          <source>It is rendered in the error page as a collection of buttons and follows the format of: &lt;code&gt;[%{label: String.t(), handler: {module(), function :: atom(), args :: []}}]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce90e2d8912f1f2f7b4ea1417a8fb3575961cda" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;a href=&quot;#media_type/1&quot;&gt;&lt;code&gt;media_type/1&lt;/code&gt;&lt;/a&gt; except wildcards are not accepted in the type nor in the subtype.</source>
          <target state="translated">Он похож на &lt;a href=&quot;#media_type/1&quot;&gt; &lt;code&gt;media_type/1&lt;/code&gt; ,&lt;/a&gt; за исключением того, что символы подстановки не принимаются ни в типе, ни в подтипе.</target>
        </trans-unit>
        <trans-unit id="ed4b71fb3d52453bbf4aa28da6905ada01f52ccb" translate="yes" xml:space="preserve">
          <source>It is used on &lt;a href=&quot;ecto.repo#c:all/2&quot;&gt;&lt;code&gt;Ecto.Repo.all/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt;&lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt;&lt;/a&gt;. If returns a tuple, saying if this query can be cached or not, and the &lt;code&gt;prepared&lt;/code&gt; query. The &lt;code&gt;prepared&lt;/code&gt; query is any term that will be passed to the adapter's &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8b235293c3fd441987efade8483fcf5a50bbd4" translate="yes" xml:space="preserve">
          <source>It is very common in Phoenix applications to namespace all of your routes under the application scope:</source>
          <target state="translated">В приложениях Phoenix очень часто используется пространство имён для всех ваших маршрутов в области применения:</target>
        </trans-unit>
        <trans-unit id="511755381ec8f835711d51bfe3c71d347d8afc8e" translate="yes" xml:space="preserve">
          <source>It is very important to keep in mind that Ecto is unable to do any type casting described above when fragments are used. You can however use the &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt; function to give Ecto some hints:</source>
          <target state="translated">Очень важно помнить, что Ecto не может выполнять приведение типов, описанных выше, при использовании фрагментов. Однако вы можете использовать функцию &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; ,&lt;/a&gt; чтобы дать Ecto несколько подсказок:</target>
        </trans-unit>
        <trans-unit id="03eb895c6aaf845d553a17cb55cfa9b526d9cdd9" translate="yes" xml:space="preserve">
          <source>It is worth noting that the &lt;code&gt;text/2&lt;/code&gt;, &lt;code&gt;json/2&lt;/code&gt;, and &lt;code&gt;html/2&lt;/code&gt; functions require neither a Phoenix view, nor a template to render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c89a89c57953342eddacd89ee3ae33933dbb8c2" translate="yes" xml:space="preserve">
          <source>It is worth noting that the cipher lists and TLS protocol versions selected by the profiles are whitelists. If a new Erlang/OTP release introduces new TLS protocol versions or ciphers that are not included in the profile definition, they would have to be enabled explicitly by overriding the &lt;code&gt;:ciphers&lt;/code&gt; and/or &lt;code&gt;:versions&lt;/code&gt; options, until such time as they are added to the &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; profiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f8bd155fb3b264871458601bfe98b34947ef8af" translate="yes" xml:space="preserve">
          <source>It must be a map and Ecto itself will always inject two keys into the meta:</source>
          <target state="translated">Это должна быть карта,а сам Ecto всегда будет вставлять две клавиши в мета:</target>
        </trans-unit>
        <trans-unit id="d812a176eca481ceed3aeedcb084d96bdf1cfa9d" translate="yes" xml:space="preserve">
          <source>It must return a tuple containing the number of entries and the result set as a list of lists. The entries in the actual list will depend on what has been selected by the query. The result set may also be &lt;code&gt;nil&lt;/code&gt;, if no value is being selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7bf550d2dd91e3eb7f4d8ba8c5d8e72098cb71" translate="yes" xml:space="preserve">
          <source>It must return a tuple containing the number of entries and the result set as a list of lists. The result set may also be &lt;code&gt;nil&lt;/code&gt; if a particular operation does not support them.</source>
          <target state="translated">Он должен возвращать кортеж, содержащий количество записей и набор результатов в виде списка списков. Набор результатов также может быть &lt;code&gt;nil&lt;/code&gt; если конкретная операция их не поддерживает.</target>
        </trans-unit>
        <trans-unit id="64d6ad431d01d7158a8dd5f4441d9f4c19873287" translate="yes" xml:space="preserve">
          <source>It must return either &lt;code&gt;{:ok, socket}&lt;/code&gt; or &lt;code&gt;{:ok, socket, options}&lt;/code&gt;, where &lt;code&gt;options&lt;/code&gt; is one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c372464cefb3e13bb0538ac72ed0e91a45083451" translate="yes" xml:space="preserve">
          <source>It parses the key and stores the value into the current accumulator. The keys and values are not assumed to be encoded in &quot;x-www-form-urlencoded&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="314f1d4137cff9c77fcca4b6566e917e92565ed8" translate="yes" xml:space="preserve">
          <source>It prints some connection information to the terminal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49388dc41541c5a93c112295bb0bf75921390c9" translate="yes" xml:space="preserve">
          <source>It provides a set of macros to generate routes. For example:</source>
          <target state="translated">Он предоставляет набор макросов для генерации маршрутов.Например:</target>
        </trans-unit>
        <trans-unit id="c755bbbfc1da5a9d523689127fd834eafd36c41a" translate="yes" xml:space="preserve">
          <source>It receives a &lt;code&gt;dumper&lt;/code&gt; function in case the parameterized type is also a composite type. In order to dump the inner type, the &lt;code&gt;dumper&lt;/code&gt; must be called with the inner type and the inner value as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f17d561fdc66ef79304d69e078c0e5c0312c23e" translate="yes" xml:space="preserve">
          <source>It receives a &lt;code&gt;loader&lt;/code&gt; function in case the parameterized type is also a composite type. In order to load the inner type, the &lt;code&gt;loader&lt;/code&gt; must be called with the inner type and the inner value as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328d30d44e29c2cd6e3dd38f65d5cb32fb69e161" translate="yes" xml:space="preserve">
          <source>It receives a connection and options (that we do not use)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb6380d88e1271819dcb40ba83ee9babe0b5d5c" translate="yes" xml:space="preserve">
          <source>It receives a connection, a list of formats that the server is capable of rendering and then proceeds to perform content negotiation based on the request information. If the client accepts any of the given formats, the request proceeds.</source>
          <target state="translated">Он получает соединение,список форматов,которые сервер способен отрисовывать,а затем переходит к выполнению согласования контента на основе информации о запросе.Если клиент принимает любой из данных форматов,запрос продолжается.</target>
        </trans-unit>
        <trans-unit id="a632a124b740ee3ecfe4c66cfbe50a9b8a5330c6" translate="yes" xml:space="preserve">
          <source>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of dumpers with the given type usually at the beginning.</source>
          <target state="translated">Он получает тип примитива и тип Ecto (который может быть и примитивным).Возвращает список дамперов с заданным типом,обычно в начале.</target>
        </trans-unit>
        <trans-unit id="c5336dd4112321d4cfb426214c2399ecd75a7e8c" translate="yes" xml:space="preserve">
          <source>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of loaders with the given type usually at the end.</source>
          <target state="translated">Он получает тип примитива и тип Ecto (который может быть и примитивным).Возвращает список загрузчиков с заданным типом обычно в конце.</target>
        </trans-unit>
        <trans-unit id="8d567de13218d83676c9bf848a612d0dcb63a942" translate="yes" xml:space="preserve">
          <source>It receives the socket options from the endpoint, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eead6f123b731bd151755a8d6351651f60a5cb89" translate="yes" xml:space="preserve">
          <source>It requires the given form to be configured with &lt;code&gt;multipart: true&lt;/code&gt; when invoking &lt;a href=&quot;#form_for/4&quot;&gt;&lt;code&gt;form_for/4&lt;/code&gt;&lt;/a&gt;, otherwise it fails with &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Он требует, чтобы данная форма была сконфигурирована с помощью &lt;code&gt;multipart: true&lt;/code&gt; при вызове &lt;a href=&quot;#form_for/4&quot;&gt; &lt;code&gt;form_for/4&lt;/code&gt; &lt;/a&gt; , в противном случае произойдет сбой с &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b444a758782f3e5a243723f32117b04bcd1193d7" translate="yes" xml:space="preserve">
          <source>It requires two options:</source>
          <target state="translated">Это требует двух вариантов:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
