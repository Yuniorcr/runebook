<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="3f1d6571352636299c2a638ffac8ee18e017790a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.controller&quot;&gt;&lt;code&gt;Phoenix.Controller&lt;/code&gt;&lt;/a&gt; module provides the &lt;code&gt;put_layout/2&lt;/code&gt; function for us to switch layouts. This takes &lt;code&gt;conn&lt;/code&gt; as its first argument and a string for the basename of the layout we want to render. It also accepts &lt;code&gt;false&lt;/code&gt; to disable the layout altogether.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207e43d957b25557eabcceb34d7699aa7a77e89f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt; callback is invoked after &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and before the initial render. It is also invoked every time &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt;&lt;code&gt;live_patch/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt; are used. It receives the request parameters as first argument, the url as second, and the socket as third.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ab5765089e37fe00cdc982a6c6127904496f5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; API allows any of its functions to handle a response from the adapter matching &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt;. The PubSub client will recursively invoke all MFA responses until a result is returned. This is useful for offloading work to clients without blocking your PubSub adapter. See &lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt;&lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt;&lt;/a&gt; implementation for examples.</source>
          <target state="translated">&lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; API позволяет любому из его функций для обработки ответа от согласования адаптера &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt; . Клиент PubSub будет рекурсивно вызывать все ответы MFA, пока не будет возвращен результат. Это полезно для разгрузки работы клиентам, не блокируя адаптер PubSub. См. &lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt; &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; &lt;/a&gt; реализации Phoenix.PubSub.PG2 .</target>
        </trans-unit>
        <trans-unit id="1b0c9e11a76593a12fc7ec6f78afc56ab4d36aaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; API allows any of its functions to handle a response from the adapter matching &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt;. The PubSub client will recursively invoke all MFA responses until a result is returned. This is useful for offloading work to clients without blocking your PubSub adapter. See &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; implementation for examples.</source>
          <target state="translated">&lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; API позволяет любому из его функций для обработки ответа от согласования адаптера &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt; . Клиент PubSub будет рекурсивно вызывать все ответы MFA, пока не будет возвращен результат. Это полезно для разгрузки работы клиентам, не блокируя адаптер PubSub. См. &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; реализации Phoenix.PubSub.PG2 .</target>
        </trans-unit>
        <trans-unit id="5f059f03c50e25491e9ade11affa506a5c85827c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.router#forward/4&quot;&gt;&lt;code&gt;Phoenix.Router.forward/4&lt;/code&gt;&lt;/a&gt; macro can be used to send all requests that start with a particular path to a particular plug. Let's say we have a part of our system that is responsible (it could even be a separate application or library) for running jobs in the background, it could have its own web interface for checking the status of the jobs. We can forward to this admin interface using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf89a86a0eb3ec72901bbad36238d748fb754a69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.router#resources/4&quot;&gt;&lt;code&gt;Phoenix.Router.resources/4&lt;/code&gt;&lt;/a&gt; macro describes additional options for customizing resource routes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32ca35c51fcd8b2c79b98aed4633cc99e6aea64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; module provides conveniences for building plug pipelines.</source>
          <target state="translated">Модуль &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; обеспечивает удобство построения заглушек трубопроводов.</target>
        </trans-unit>
        <trans-unit id="d6e79dbadb31903b9f92905b4723d4810b1bea76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; event is sent by the transport when a channel exits, and represents the channel terminating against its will. The &lt;a href=&quot;#on_exit_message/3&quot;&gt;&lt;code&gt;on_exit_message/3&lt;/code&gt;&lt;/a&gt; function aids in constructing the &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; message.</source>
          <target state="translated">&lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; событие отправляется транспорта , когда выходит из канала, и представляет собой завершающий канал против его воли. Функция &lt;a href=&quot;#on_exit_message/3&quot;&gt; &lt;code&gt;on_exit_message/3&lt;/code&gt; &lt;/a&gt; помогает в &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; сообщения &amp;laquo;phx_error&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="6e450e02e99e9729245c2971a0f234ed37f3b636" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%Phoenix.Socket.Message{}&lt;/code&gt; is the leave message for the transport to relay to the client.</source>
          <target state="translated">&lt;code&gt;%Phoenix.Socket.Message{}&lt;/code&gt; является сообщением оставить на транспорте , чтобы передать клиенту.</target>
        </trans-unit>
        <trans-unit id="bd539ef4a22e6b8ce30fc264d95352ee8a15cefe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_nulls_first&lt;/code&gt; and &lt;code&gt;*_nulls_last&lt;/code&gt; variants are not supported by all databases. While all databases default to ascending order, the choice of &quot;nulls first&quot; or &quot;nulls last&quot; is specific to each database implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d85a8224c78cbfc81cbb854cdafc632fe561a38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_nulls_first&lt;/code&gt; and &lt;code&gt;*_nulls_last&lt;/code&gt; variants are not supported by all databases. While all databases default to ascending order, the choice of &amp;ldquo;nulls first&amp;rdquo; or &amp;ldquo;nulls last&amp;rdquo; is specific to each database implementation.</source>
          <target state="translated">&lt;code&gt;*_nulls_first&lt;/code&gt; и &lt;code&gt;*_nulls_last&lt;/code&gt; варианты не поддерживаются всеми базами данных. Хотя все базы данных по умолчанию работают в порядке возрастания, выбор &amp;laquo;нули сначала&amp;raquo; или &amp;laquo;нули в последнюю очередь&amp;raquo; специфичен для каждой реализации базы данных.</target>
        </trans-unit>
        <trans-unit id="5adb9f7effcd9a92a5c3394cf706464a50f8e854" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--no-halt&lt;/code&gt; flag is automatically added.</source>
          <target state="translated">&lt;code&gt;--no-halt&lt;/code&gt; флаг добавляется автоматически.</target>
        </trans-unit>
        <trans-unit id="23ed4ea9af36661b5bef1c1c6ac364a14dd0fd25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--step&lt;/code&gt; option will behave the same way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d285d5d2d694c280d2af59d2b72a39d127833e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--to&lt;/code&gt; option will run all migrations up to and including given version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea39d3cb35a084383c1603b0beb3c4727483b5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.eex&lt;/code&gt; extension maps to a template engine which tells Phoenix how to compile the code in the file into Elixir source code. After it is compiled, the template can be rendered as:</source>
          <target state="translated">Расширение &lt;code&gt;.eex&lt;/code&gt; сопоставляется с механизмом шаблонов, который сообщает Phoenix, как скомпилировать код в файле в исходный код Elixir. После компиляции шаблон можно отобразить как:</target>
        </trans-unit>
        <trans-unit id="2663c4b667ff4ea7906e8eff89a8ab26b4176847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.leex&lt;/code&gt; (Live EEx) template engine that tracks changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2cbe3b530a3545de3248339706a75f4da234de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:aspect&lt;/code&gt; key of the struct specifies what field is still unfetched.</source>
          <target state="translated">&lt;code&gt;:aspect&lt;/code&gt; ключ из структуры определяет , какое поле еще несобранные.</target>
        </trans-unit>
        <trans-unit id="ef67b3c2738d0f830da956da57f8a9d7ab9878ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:authenticate&lt;/code&gt; plug will be invoked before the action. If the plug calls &lt;a href=&quot;../plug/1.5.1/plug.conn#halt/1&quot;&gt;&lt;code&gt;Plug.Conn.halt/1&lt;/code&gt;&lt;/a&gt; (which is by default imported into controllers), it will halt the pipeline and won&amp;rsquo;t inoke the action.</source>
          <target state="translated">&lt;code&gt;:authenticate&lt;/code&gt; плагин будет вызываться перед действием. Если плагин вызывает &lt;a href=&quot;../plug/1.5.1/plug.conn#halt/1&quot;&gt; &lt;code&gt;Plug.Conn.halt/1&lt;/code&gt; &lt;/a&gt; (который по умолчанию импортируется в контроллеры), он остановит конвейер и не вызовет действие.</target>
        </trans-unit>
        <trans-unit id="2a2077bbe0dc1df2c551ae2d5305040e0b043053" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:authenticate&lt;/code&gt; plug will be invoked before the action. If the plug calls &lt;a href=&quot;../plug/plug.conn#halt/1&quot;&gt;&lt;code&gt;Plug.Conn.halt/1&lt;/code&gt;&lt;/a&gt; (which is by default imported into controllers), it will halt the pipeline and won't invoke the action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18fe4cf95d7fab8a497960c08951af855a55d8a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:browser&lt;/code&gt; and &lt;code&gt;:api&lt;/code&gt; Pipelines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70cf91a624862bdabdacfdc0d7521b33d8e86b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:browser&lt;/code&gt; pipeline has five plugs: &lt;code&gt;plug :accepts, [&quot;html&quot;]&lt;/code&gt; which defines the request format or formats which will be accepted, &lt;code&gt;:fetch_session&lt;/code&gt;, which, naturally, fetches the session data and makes it available in the connection, &lt;code&gt;:fetch_flash&lt;/code&gt; which retrieves any flash messages which may have been set, as well as &lt;code&gt;:protect_from_forgery&lt;/code&gt; and &lt;code&gt;:put_secure_browser_headers&lt;/code&gt;, which protects form posts from cross site forgery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731f4c8f6efafb89aa6c584007065c777c291143" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:cd&lt;/code&gt; option can be used on a watcher to override the folder from which the watcher will run. By default this will be the project&amp;rsquo;s root: &lt;code&gt;File.cwd!()&lt;/code&gt;</source>
          <target state="translated">Параметр &lt;code&gt;:cd&lt;/code&gt; может использоваться в наблюдателе, чтобы переопределить папку, из которой будет запускаться наблюдатель. По умолчанию это будет корень проекта: &lt;code&gt;File.cwd!()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ae21bdba03584c806666010e52a2cb28db8be56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:cd&lt;/code&gt; option can be used on a watcher to override the folder from which the watcher will run. By default this will be the project's root: &lt;code&gt;File.cwd!()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7bc6b309b1a0d5dcb1c973131cf2999c439c9de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:cipher_suite&lt;/code&gt; option provides &lt;code&gt;:strong&lt;/code&gt; and &lt;code&gt;:compatible&lt;/code&gt; options for setting up better cipher and version defaults according to the OWASP recommendations. See the &amp;ldquo;Cipher Suites&amp;rdquo; section below</source>
          <target state="translated">Параметр &lt;code&gt;:cipher_suite&lt;/code&gt; предоставляет параметры &lt;code&gt;:strong&lt;/code&gt; и &lt;code&gt;:compatible&lt;/code&gt; для настройки лучшего шифра и версии по умолчанию в соответствии с рекомендациями OWASP. См. Раздел &amp;laquo;Наборы шифров&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="1e4e2c269f3978f76ff199356c975a07324ab155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:compatible&lt;/code&gt; profile additionally enables AES-CBC ciphers, as well as TLS versions 1.1 and 1.0. Use this configuration to allow connections from older clients, such as older PC or mobile operating systems. Note that RSA key exchange is not enabled by this configuration, due to known weaknesses, so to support clients that do not support ECDHE or DHE it is necessary specify the ciphers explicitly (see &lt;a href=&quot;#manual-configuration&quot;&gt;below&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918f4e83de0e618dc7aa4875d78f6492629319c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:content_type&lt;/code&gt; and &lt;code&gt;:filename&lt;/code&gt; fields in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt; struct are client-controlled. These values should be validated, via file content inspection or similar, before being trusted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb2b2f7e9b4811efb97cc3c2e5e5c07ea928f93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:context&lt;/code&gt; field represents additional state some databases require for proper updates of data. It is not used by the built-in adapters of &lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt; and &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6213d9c5c2d60d6a2f351db0efbb41962d6d16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:context&lt;/code&gt; field represents additional state some databases require for proper updates of data. It is not used by the built-in adapters of &lt;code&gt;Ecto.Adapters.Postres&lt;/code&gt; and &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt;.</source>
          <target state="translated">Поле &lt;code&gt;:context&lt;/code&gt; представляет дополнительное состояние, которое требуется некоторым базам данных для правильного обновления данных. Он не используется встроенными адаптерами &lt;code&gt;Ecto.Adapters.Postres&lt;/code&gt; и &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16a1d1418e35d766234890bac5372c3fa8aab917" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:delete&lt;/code&gt; option in particular must be used carefully as it would allow users to delete any associated data by simply not sending any data for a given field. If you need deletion, it is often preferred to manually mark the changeset for deletion if a &lt;code&gt;delete&lt;/code&gt; field is set in the params, as in the example below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5acd2290f1eeb3bc214ec527b315e41481bcb38d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:delete&lt;/code&gt; option in particular must be used carefully as it would allow users to delete any associated data. If you need deletion, it is often preferred to add a separate boolean virtual field to the changeset function that will allow you to manually mark it for deletion, as in the example below:</source>
          <target state="translated">В частности, следует использовать параметр &lt;code&gt;:delete&lt;/code&gt; с осторожностью, поскольку он позволяет пользователям удалять любые связанные данные. Если вам нужно удаление, часто предпочитают добавить отдельное логическое виртуальное поле в функцию набора изменений, которое позволит вам вручную пометить его для удаления, как в примере ниже:</target>
        </trans-unit>
        <trans-unit id="c252a1b7d9e6defcdc7e6e2741931b5df0cd03a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:duration&lt;/code&gt; measurements are presented in the &lt;code&gt;:native&lt;/code&gt; time unit. You can read more about it in the docs for &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0cb6c08b188d0d4ef6ec2d55ff0640a7a5a562f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:dynamic&lt;/code&gt; field contains a function that takes a boolean argument (see &quot;Tracking changes&quot; below), and returns a list of dynamic content. Each element in the list is either one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d742e4a33ea1296a531ccca07c5ea7b18db14083" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:host&lt;/code&gt; option requires a string or &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt;. Similar to &lt;code&gt;:port&lt;/code&gt;, when given a tuple like &lt;code&gt;{:system, &quot;HOST&quot;}&lt;/code&gt;, the host will be referenced from &lt;code&gt;System.get_env(&quot;HOST&quot;)&lt;/code&gt; at runtime.</source>
          <target state="translated">Для параметра &lt;code&gt;:host&lt;/code&gt; требуется строка или &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt; . Подобно &lt;code&gt;:port&lt;/code&gt; , когда задан кортеж вроде &lt;code&gt;{:system, &quot;HOST&quot;}&lt;/code&gt; , на хост будет ссылаться из &lt;code&gt;System.get_env(&quot;HOST&quot;)&lt;/code&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="dd99d05cad94c87bb280dd5d83fd4ec31d3e120f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:id&lt;/code&gt; type is used when the primary key is an integer while the &lt;code&gt;:binary_id&lt;/code&gt; is used for primary keys in particular binary formats, which may be &lt;a href=&quot;ecto.uuid&quot;&gt;&lt;code&gt;Ecto.UUID&lt;/code&gt;&lt;/a&gt; for databases like PostgreSQL and MySQL, or some specific ObjectID or RecordID often imposed by NoSQL databases.</source>
          <target state="translated">Тип &lt;code&gt;:id&lt;/code&gt; используется, когда первичный ключ является целым числом, а &lt;code&gt;:binary_id&lt;/code&gt; используется для первичных ключей в определенных двоичных форматах, которые могут быть &lt;a href=&quot;ecto.uuid&quot;&gt; &lt;code&gt;Ecto.UUID&lt;/code&gt; &lt;/a&gt; для таких баз данных, как PostgreSQL и MySQL, или некоторым конкретным ObjectID или RecordID, часто навязываемым NoSQL базы данных.</target>
        </trans-unit>
        <trans-unit id="03335948c65fcf829d6e89720eb38d3cb4ea9a0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:layout&lt;/code&gt; option on &lt;code&gt;use&lt;/code&gt; does not apply to LiveViews rendered within other LiveViews. If you want to render child live views or opt-in to a layout, use &lt;code&gt;:layout&lt;/code&gt; as an option in mount:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0a17946500299e7ee12b6af3689a1c4c43f8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:logo&lt;/code&gt; is preferred to be a base64-encoded data URI so not to make any external requests, though external URLs (eg, &lt;code&gt;https://...&lt;/code&gt;) are supported.</source>
          <target state="translated">&lt;code&gt;:logo&lt;/code&gt; является предпочтительным , чтобы быть в кодировке base64 данные URI , чтобы не делать какие - либо внешние запросы, хотя внешние URL (например, &lt;code&gt;https://...&lt;/code&gt; ) поддерживаются.</target>
        </trans-unit>
        <trans-unit id="c3992bb8a6efd8a4bd3e7e1767377cc30d96b760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:measurements&lt;/code&gt; map will include the following, all given in the &lt;code&gt;:native&lt;/code&gt; time unit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25110dc298c23b6bcca6b66d8becb6c3ab0252e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; is required as part of &lt;code&gt;options&lt;/code&gt;. The remaining options are described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a144d9bf2ce178155262a9bed21600765bd913d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; parameter will also be available in the function body as &lt;code&gt;conn.params[&quot;name&quot;]&lt;/code&gt; and &lt;code&gt;conn.path_params[&quot;name&quot;]&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;:name&lt;/code&gt; также будет доступен в теле функции как &lt;code&gt;conn.params[&quot;name&quot;]&lt;/code&gt; и &lt;code&gt;conn.path_params[&quot;name&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c6a9f8fae8b3f03bb8da33b0dd63ade9e7c2388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:namespace&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; options are used to calculate template lookup paths. For example, if you are in &lt;code&gt;MyApp.UserView&lt;/code&gt; and the namespace is &lt;code&gt;MyApp&lt;/code&gt;, templates are expected at &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt;. On the other hand, if the view is &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt;, the path will be &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; and so on. For explicit root path locations, the &lt;code&gt;:path&lt;/code&gt; option can be provided instead. The &lt;code&gt;:root&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; are joined to form the final lookup path. A blank string may be provided to use the &lt;code&gt;:root&lt;/code&gt; path directly as the template lookup path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a1f032809b2a80ee05ed26deb3f2fce84671c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:namespace&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; options are used to calculate template lookup paths. For example, if you are in &lt;code&gt;MyApp.UserView&lt;/code&gt; and the namespace is &lt;code&gt;MyApp&lt;/code&gt;, templates are expected at &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt;. On the other hand, if the view is &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt;, the path will be &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; and so on. For explicit root path locations, the &lt;code&gt;:path&lt;/code&gt; option can instead be provided. The &lt;code&gt;:root&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; are joined to form the final lookup path. A blank string may be provided to use the &lt;code&gt;:root&lt;/code&gt; path directly as the template lookup path.</source>
          <target state="translated">Параметры &lt;code&gt;:namespace&lt;/code&gt; и &lt;code&gt;:path&lt;/code&gt; используются для вычисления путей поиска шаблонов. Например, если вы находитесь в &lt;code&gt;MyApp.UserView&lt;/code&gt; , а пространство имен - &lt;code&gt;MyApp&lt;/code&gt; , шаблоны ожидаются в &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt; . С другой стороны, если представление - &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; , путь будет &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; и так далее. Для явного расположения корневого пути вместо этого может быть предоставлена ​​опция &lt;code&gt;:path&lt;/code&gt; . Пути &lt;code&gt;:root&lt;/code&gt; и &lt;code&gt;:path&lt;/code&gt; объединяются, образуя окончательный путь поиска. Может быть предоставлена ​​пустая строка для использования пути &lt;code&gt;:root&lt;/code&gt; непосредственно в качестве пути поиска шаблона.</target>
        </trans-unit>
        <trans-unit id="895c2ddd40cf8e3567de42e9bf12420974e19653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:on_replace&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;:on_replace&lt;/code&gt; вариант</target>
        </trans-unit>
        <trans-unit id="36d82b1b3e9c0c28b3952588185c19ae211245b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:port&lt;/code&gt; option requires either an integer or string. The &lt;code&gt;:host&lt;/code&gt; option requires a string. The &lt;code&gt;:scheme&lt;/code&gt; option accepts &lt;code&gt;&quot;http&quot;&lt;/code&gt; and &lt;code&gt;&quot;https&quot;&lt;/code&gt; values. Default value is inferred from top level &lt;code&gt;:http&lt;/code&gt; or &lt;code&gt;:https&lt;/code&gt; option. It is useful when hosting Phoenix behind a load balancer or reverse proxy and terminating SSL there. The &lt;code&gt;:path&lt;/code&gt; option can be used to override root path. Useful when hosting Phoenix behind a reverse proxy with URL rewrite rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6168b39090f584c85cff0cc128125156fba6b515" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:port&lt;/code&gt; option requires either an integer, string, or &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt;. When given a tuple like &lt;code&gt;{:system, &quot;PORT&quot;}&lt;/code&gt;, the port will be referenced from &lt;code&gt;System.get_env(&quot;PORT&quot;)&lt;/code&gt; at runtime as a workaround for releases where environment specific information is loaded only at compile-time.</source>
          <target state="translated">Для параметра &lt;code&gt;:port&lt;/code&gt; требуется целое число, строка или &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt; . Если задан кортеж вроде &lt;code&gt;{:system, &quot;PORT&quot;}&lt;/code&gt; , на порт будет ссылаться &lt;code&gt;System.get_env(&quot;PORT&quot;)&lt;/code&gt; во время выполнения в качестве обходного пути для выпусков, в которых информация, относящаяся к среде, загружается только во время компиляции.</target>
        </trans-unit>
        <trans-unit id="92d07421660bd7c638d8258897864e4a9cf3e6ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:prefix&lt;/code&gt; option given to &lt;code&gt;from&lt;/code&gt;/&lt;code&gt;join&lt;/code&gt; has the highest precedence</source>
          <target state="translated">Параметр &lt;code&gt;:prefix&lt;/code&gt; , присвоенный &lt;code&gt;from&lt;/code&gt; / &lt;code&gt;join&lt;/code&gt; , имеет наивысший приоритет</target>
        </trans-unit>
        <trans-unit id="54e1957e79c6b007c7f23224e0a1670cbbc75677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:pubsub_server&lt;/code&gt; must point to an existing pubsub server running in your application, which is included by default as &lt;code&gt;MyApp.PubSub&lt;/code&gt; for new applications.</source>
          <target state="translated">&lt;code&gt;:pubsub_server&lt;/code&gt; должен указывать на существующий сервер PubSub работает в вашем приложении, который включен по умолчанию в качестве &lt;code&gt;MyApp.PubSub&lt;/code&gt; для новых приложений.</target>
        </trans-unit>
        <trans-unit id="5cda43ef4ff3376cfc2c7af75979f3ba0d7ed620" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:reloadable_apps&lt;/code&gt; defaults to &lt;code&gt;nil&lt;/code&gt;. In such case default behaviour is to reload current project if it consists of single app, or all applications within umbrella project. You can set &lt;code&gt;:reloadable_apps&lt;/code&gt; to subset of default applications to reload only some of them, empty list - to effectively disable code reloader, or include external applications from library dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa4db1aa422d9779d3b8729775b268f6c7f02de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:remote_ip&lt;/code&gt; field in the &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct by default contains the network peer IP address. Terminating TLS in a separate process or network element typically masks the actual client IP address from the Elixir application. If proxying is done at the HTTP layer, the original client IP address is often inserted into an HTTP header, e.g. 'X-Forwarded-For'. There are Plug packages available to extract the client IP from such a header and update the &lt;code&gt;:remote_ip&lt;/code&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed05e3737398b3c2beccb1cfaf10e740d96858b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:root&lt;/code&gt; option is required while the &lt;code&gt;:namespace&lt;/code&gt; defaults to the first nesting in the module name. For instance, both &lt;code&gt;MyApp.UserView&lt;/code&gt; and &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; have namespace &lt;code&gt;MyApp&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;:root&lt;/code&gt; является обязательным, в то время как &lt;code&gt;:namespace&lt;/code&gt; умолчанию соответствует первому вложению в имени модуля. Например, и &lt;code&gt;MyApp.UserView&lt;/code&gt; , и &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; имеют пространство имен &lt;code&gt;MyApp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a3296e1c3da0ddff618bfd191c05b175ff0cb1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:schema&lt;/code&gt; field refers the module name for the schema this metadata belongs to.</source>
          <target state="translated">Поле &lt;code&gt;:schema&lt;/code&gt; ссылается на имя модуля для схемы, которой принадлежат эти метаданные.</target>
        </trans-unit>
        <trans-unit id="e2763632c3bc8d8b6f69e916c553e100096271d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:selected&lt;/code&gt; option will mark the given IDs as selected unless the form is being resubmitted. When resubmitted, it uses the form params as values.</source>
          <target state="translated">Параметр &lt;code&gt;:selected&lt;/code&gt; пометит указанные идентификаторы как выбранные, если форма не отправляется повторно. При повторной отправке в качестве значений используются параметры формы.</target>
        </trans-unit>
        <trans-unit id="0cea6902bf81cf806e2e2ff5a1334ab75f6b0054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:source&lt;/code&gt; tracks the (table or collection) where the struct is or should be persisted to.</source>
          <target state="translated">&lt;code&gt;:source&lt;/code&gt; отслеживает (таблицу или коллекцию) , где структура является или должна быть сохранена в.</target>
        </trans-unit>
        <trans-unit id="c67eef75ef4d15947c1d4d035bc00669b3f024ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:static&lt;/code&gt; field is a list of literal strings. This allows the Elixir compiler to optimize this list and avoid allocating its strings on every render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ec232b6cfcdbc23d88179e41f0fb0e88f686fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strong&lt;/code&gt; profile enables AES-GCM ciphers with ECDHE or DHE key exchange, and TLS version 1.2 only. It is intended for typical installations with support for browsers and other modern clients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e4f3969fca2a0c0bce3d4dfbb896188d5e6e36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:where&lt;/code&gt; option expects a keyword list where the key is an atom representing the field and the value is either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6613c6ae5cafc810769cb60c6e62f072ba58bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:where&lt;/code&gt; option may receive a dynamic query, a keyword list or a MFA (a tuple with a module, function and args to invoke). The MFA is especially useful to avoid duplication in those definitions:</source>
          <target state="translated">Параметр &lt;code&gt;:where&lt;/code&gt; может получать динамический запрос, список ключевых слов или MFA (кортеж с модулем, функцией и аргументами для вызова). MFA особенно полезен, чтобы избежать дублирования в этих определениях:</target>
        </trans-unit>
        <trans-unit id="cdf5ea7cc064d3fd02c24e10f92c4d06b0296467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@endpoint&lt;/code&gt; module attribute contains the endpoint under testing, most commonly your application endpoint itself. If you are using the MyApp.ConnCase generated by Phoenix, it is automatically set for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb7111fae5bbf19a11fce2dbdf8ba880cacae4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@primary_key&lt;/code&gt; attribute will tell ecto which type to use for the id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010ab761c017e85e79712afcc13c2e028e60df3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@shortdoc&lt;/code&gt; module attribute holds a string which will describe our task when users invoke &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e515ce695757264b1c2dae6b68e6bbfbc7f198c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method can be overridden only by these HTTP methods:</source>
          <target state="translated">Метод &lt;code&gt;POST&lt;/code&gt; можно переопределить только этими методами HTTP:</target>
        </trans-unit>
        <trans-unit id="ef584d71c526b4b7d03dc94f80f6e8f1d6008b5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PageController&lt;/code&gt; gives us the &lt;code&gt;index&lt;/code&gt; action to display the Phoenix welcome page associated with the default route Phoenix defines in the router.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f0d0f4bd596df0232f105e5e46a46047747cd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SignUp&lt;/code&gt; schema can be cast and validated with the help of the &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; module, and afterwards, you can copy its data to the &lt;code&gt;Profile&lt;/code&gt; and &lt;code&gt;Account&lt;/code&gt; structs that will be persisted to the database with the help of &lt;a href=&quot;ecto.repo&quot;&gt;&lt;code&gt;Ecto.Repo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Схема &lt;code&gt;SignUp&lt;/code&gt; может быть приведена и проверена с помощью модуля &lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; , а затем вы можете скопировать ее данные в структуры &lt;code&gt;Profile&lt;/code&gt; и &lt;code&gt;Account&lt;/code&gt; , которые будут сохранены в базе данных с помощью &lt;a href=&quot;ecto.repo&quot;&gt; &lt;code&gt;Ecto.Repo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0027e32d65973e3996206f15f8d2bc1ec48ab7bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tracker&lt;/code&gt; API is used as a facade for a pool of &lt;a href=&quot;phoenix.tracker.shard&quot;&gt;&lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt;&lt;/a&gt;s. The responsibility of which calls go to which &lt;code&gt;Shard&lt;/code&gt; is determined based on the topic, on which a given function is called.</source>
          <target state="translated">&lt;code&gt;Tracker&lt;/code&gt; API используется в качестве фасада для пула &lt;a href=&quot;phoenix.tracker.shard&quot;&gt; &lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt; &lt;/a&gt; s. Ответственность за то, какие вызовы переходят к тому, какой &lt;code&gt;Shard&lt;/code&gt; определяется в зависимости от темы, по которой вызывается данная функция.</target>
        </trans-unit>
        <trans-unit id="e5479c3d20fe1168228ba562f220f909f384e32e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UserRegistration&lt;/code&gt; setup is likely simpler to implement than the dynamic author system we built &amp;ndash; we decided to take the harder path exactly because those are decisions developers take on their applications every day.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dac19423140ef75ddacc313c1b338418cdd245" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[:telemetry]&lt;/code&gt; library allows you to emit events at various stages of an application's lifecycle. You can then respond to these events by, among other things, aggregating them as metrics and sending the metrics data to a reporting destination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0004743ff2da907b7bfb6253848e44f110fc051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_url&lt;/code&gt; functions will get the host, port, proxy port, and SSL information needed to construct the full URL from the configuration parameters set for each environment. We'll talk about configuration in more detail in its own guide. For now, you can take a look at &lt;code&gt;config/dev.exs&lt;/code&gt; file in your own project to see those values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9380732d83d99aa3ef7e1ee94986487b7d7501fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;adapter_meta&lt;/code&gt; field is a map containing some of the fields found in the &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Поле &lt;code&gt;adapter_meta&lt;/code&gt; - это карта, содержащая некоторые поля, найденные в структуре &lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f72cda2deb8565937044253265942493bf6aa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;belongs_to&lt;/code&gt; association on &lt;code&gt;MyApp.Comment&lt;/code&gt; will also define a &lt;code&gt;:post_id&lt;/code&gt; field with &lt;code&gt;:binary_id&lt;/code&gt; type that references the &lt;code&gt;:id&lt;/code&gt; field of the &lt;code&gt;MyApp.Post&lt;/code&gt; schema.</source>
          <target state="translated">&lt;code&gt;belongs_to&lt;/code&gt; ассоциация по &lt;code&gt;MyApp.Comment&lt;/code&gt; также определить &lt;code&gt;:post_id&lt;/code&gt; поля с &lt;code&gt;:binary_id&lt;/code&gt; типа , который ссылается на &lt;code&gt;:id&lt;/code&gt; поля &lt;code&gt;MyApp.Post&lt;/code&gt; схемы.</target>
        </trans-unit>
        <trans-unit id="87e3861a73f975bf0651f08b600e6e3ad95f45d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cacertfile&lt;/code&gt; option is not needed when using a self-signed certificate, or when the file pointed to by &lt;code&gt;certfile&lt;/code&gt; contains both the server certificate and all necessary CA chain certificates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778cb135fc988ae8195d411110c29d421206d37f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call/2&lt;/code&gt; function that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; provides is used internally to execute all the plugs listed using the &lt;code&gt;plug&lt;/code&gt; macro, so overriding the &lt;code&gt;call/2&lt;/code&gt; function generally implies using &lt;code&gt;super&lt;/code&gt; in order to still call the plug chain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6752d9d305fe4dabd6e9f7e8abc5275de174456b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call/2&lt;/code&gt; function that &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; provides is used internally to execute all the plugs listed using the &lt;code&gt;plug&lt;/code&gt; macro, so overriding the &lt;code&gt;call/2&lt;/code&gt; function generally implies using &lt;code&gt;super&lt;/code&gt; in order to still call the plug chain:</source>
          <target state="translated">Функция &lt;code&gt;call/2&lt;/code&gt; , &lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; предоставляет Plug.Builder, используется внутри для выполнения всех перечисленных &lt;code&gt;plug&lt;/code&gt; макроса plug , поэтому переопределение функции &lt;code&gt;call/2&lt;/code&gt; обычно подразумевает использование &lt;code&gt;super&lt;/code&gt; , чтобы по-прежнему вызывать цепочку плагинов:</target>
        </trans-unit>
        <trans-unit id="59369e81ae4c82531a9066b2b16f4703c7464cfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;changeset/2&lt;/code&gt; function first invokes &lt;a href=&quot;ecto.changeset#cast/4&quot;&gt;&lt;code&gt;Ecto.Changeset.cast/4&lt;/code&gt;&lt;/a&gt; with the struct, the parameters and a list of allowed fields; this returns a changeset. The parameters is a map with binary keys and values that will be cast based on the type defined on the schema.</source>
          <target state="translated">Функция &lt;code&gt;changeset/2&lt;/code&gt; сначала вызывает &lt;a href=&quot;ecto.changeset#cast/4&quot;&gt; &lt;code&gt;Ecto.Changeset.cast/4&lt;/code&gt; &lt;/a&gt; со структурой, параметрами и списком разрешенных полей; это возвращает набор изменений. Параметры - это карта с двоичными ключами и значениями, которые будут преобразованы в зависимости от типа, определенного в схеме.</target>
        </trans-unit>
        <trans-unit id="fcd29f0f3ca38c03e6a05f563bf7684e923be86d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel&lt;/code&gt; macro accepts topic patterns in two flavors. A splat (the &lt;code&gt;*&lt;/code&gt; character) argument can be provided as the last character to indicate a &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; match. If a plain string is provided, only that topic will match the channel handler. Most use-cases will use the &lt;code&gt;&quot;topic:*&quot;&lt;/code&gt; pattern to allow more versatile topic scoping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2294206fb3a150cd9c224614317f9aee05e6f3e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel&lt;/code&gt; macro accepts topic patterns in two flavors. A splat argument can be provided as the last character to indicate a &amp;ldquo;topic:subtopic&amp;rdquo; match. If a plain string is provided, only that topic will match the channel handler. Most use-cases will use the &amp;ldquo;topic:*&amp;rdquo; pattern to allow more versatile topic scoping.</source>
          <target state="translated">&lt;code&gt;channel&lt;/code&gt; макро принимает тему шаблонов в двух вариантах. Аргумент splat может быть указан в качестве последнего символа для обозначения совпадения &amp;laquo;тема: подтема&amp;raquo;. Если указана простая строка, обработчику канала будет соответствовать только эта тема. В большинстве сценариев использования будет использоваться шаблон &amp;laquo;topic: *&amp;raquo;, чтобы обеспечить более гибкое определение тематики.</target>
        </trans-unit>
        <trans-unit id="6fd75bfb56e80fb59c39a66cbca5dfc544043958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do/end&lt;/code&gt; will be available as an anonymous function in an assign named &lt;code&gt;@inner_content&lt;/code&gt;. The anonymous function must be invoked passing a new set of assigns that will be merged into the user assigns. For example, the grid component above could be implemented as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0566567c74373795b6261b3892abb0503ed0e625" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynamic&lt;/code&gt; macro can be interpolated at the root of a &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;having&lt;/code&gt; or a &lt;code&gt;join&lt;/code&gt;'s &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077b06b43fe5cab3947b5c73d7e014aabfed4b80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecto.rollback&lt;/code&gt; task will reverse the last migration we have run, undoing the schema changes. &lt;code&gt;ecto.migrate&lt;/code&gt; and &lt;code&gt;ecto.rollback&lt;/code&gt; are mirror images of each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47faccb75d970d09e733fcef42fb4e981d00af8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-blur&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-blur&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5019576176da0a0182ad14b8fd3ae5734cc494eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-change&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-change&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d153088b0ac1c3ab072462dcfc030a49a5bb2603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-click&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-click&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc050be15922cc83544181133c115aeaf56c9ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-focus&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-focus&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8552f5bca94ee3cd7fe7fd6d2f0771c726944d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-keydown&lt;/code&gt; or &lt;code&gt;phx-window-keydown&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-keydown&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346fe7c5d882669468106690d1f552e7e73c91d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-keyup&lt;/code&gt; or &lt;code&gt;phx-window-keyup&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-keyup&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a298b368b8d58666332ac5fd98b74d5ced7a849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-submit&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-submit&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values, including hidden input fields, can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbf0996b2b7c1661988ea246da6fcdfd58f43b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode!/1&lt;/code&gt; function must return a tuple in the format &lt;code&gt;{:socket_push, :text | :binary, String.t | binary}&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;encode!/1&lt;/code&gt; должна возвращать кортеж в формате &lt;code&gt;{:socket_push, :text | :binary, String.t | binary}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="055209e601ab76424461a3d24cfbe4383896ba1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch/2&lt;/code&gt; function above fetches all users from the database who have registered presences for the given topic. The presences information is then extended with a &lt;code&gt;:user&lt;/code&gt; key of the user's information, while maintaining the required &lt;code&gt;:metas&lt;/code&gt; field from the original presence data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a64f3256798e6a70350cf3a635b234e379dcbdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;form&lt;/code&gt; should either be a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503560113ad63b1bbf6a1ce7a1a79895b311563a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;form&lt;/code&gt; should either be a &lt;a href=&quot;phoenix.html.form#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">&lt;code&gt;form&lt;/code&gt; должна быть либо &lt;a href=&quot;phoenix.html.form#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt; , излучаемый &lt;code&gt;form_for&lt;/code&gt; или атомом.</target>
        </trans-unit>
        <trans-unit id="bd226e25354c107d2906f0cbea19295e4d882cd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json/2&lt;/code&gt; function is obviously useful for writing APIs, and the other two may come in handy, but most of the times we use Phoenix views to build our responses. For this, Phoenix provides the &lt;code&gt;render/3&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d0728771ec4d2ea3c901f60ad19db7fa2a8d0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/hello/application.ex&lt;/code&gt; file defines an Elixir application named &lt;code&gt;Hello.Application&lt;/code&gt;. That's because at the end of the day Phoenix applications are simply Elixir applications. The &lt;code&gt;Hello.Application&lt;/code&gt; module defines which services are part of our application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b44c23c2835aabf2b8a0d71d119e8487fdff8fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/hello&lt;/code&gt; directory hosts all of your business domain. Since our project does not have any business logic yet, the directory is mostly empty. You will only find two files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c968f45c63fd13191f1cd53260d0ffe8f31d44b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/hello_web&lt;/code&gt; directory holds the web-related parts of our application. It looks like this when expanded:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2252012c87ac27460a9e7188fe0a3ff365ab835" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lv:&lt;/code&gt; event prefix supports LiveView specific features that are handled by LiveView without calling the user's &lt;code&gt;handle_event/3&lt;/code&gt; callbacks. Today, the following events are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd5c68b341c68e39c0234d83212f3aebd4c77c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onkeydown&lt;/code&gt;, and &lt;code&gt;onkeyup&lt;/code&gt; events are supported via the &lt;code&gt;phx-keydown&lt;/code&gt;, and &lt;code&gt;phx-keyup&lt;/code&gt; bindings. Each binding supports a &lt;code&gt;phx-key&lt;/code&gt; attribute, which triggers the event for the specific key press. If no &lt;code&gt;phx-key&lt;/code&gt; is provided, the event is triggered for any key press. When pushed, the value sent to the server will contain the &lt;code&gt;&quot;key&quot;&lt;/code&gt; that was pressed, plus any user-defined metadata. For example, pressing the Escape key looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4280e53fd7de2d333eac4e3efda660422aeb8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; contains an &lt;code&gt;opcode&lt;/code&gt; key, this will be either &lt;code&gt;:ping&lt;/code&gt; or &lt;code&gt;:pong&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b7c6ea8c001315dd26a0ae19bec5c510733707" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opts&lt;/code&gt; that are received in the &lt;code&gt;init/1&lt;/code&gt; callback of the Module Plug can be passed as a 3rd argument. For example, maybe the background job lets you set the name of your application to be displayed on the page. This could be passed with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30635ea371ab0a08e396d17ab555117f5134b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; is the list of query parameters. For example, for a query such as &lt;code&gt;from Post, where: [id: ^123]&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt; will be &lt;code&gt;[123]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc799acb99c7c5e0571705aabef686e2a9bc106f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params_or_body&lt;/code&gt; field must be one of:</source>
          <target state="translated">Поле &lt;code&gt;params_or_body&lt;/code&gt; должно быть одним из:</target>
        </trans-unit>
        <trans-unit id="ba32a6b84a77473cde79076160c7d25a5500e027" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; can be either a string or the &lt;code&gt;path_info&lt;/code&gt; segments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6557be94c3b172806d0d806c90f7d5a409872519" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; is commonly the request path with optional query string but it may also be a complete URI. When a URI is given, the host and schema will be used as part of the request too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d55c3d00bf1f0ceaa729d7da79f6e3d8341ed27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-capture-click&lt;/code&gt; event is just like &lt;code&gt;phx-click&lt;/code&gt;, but instead of the click event being dispatched to the closest &lt;code&gt;phx-click&lt;/code&gt; element as it bubbles up through the DOM, the event is dispatched as it propagates from the top of the DOM tree down to the target element. This is useful when wanting to bind click events without receiving bubbled events from child UI elements. Since capturing happens before bubbling, this can also be important for preparing or preventing behaviour that will be applied during the bubbling phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701ba5efe9283602358bbbeacee6d8120c0fe72a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-click&lt;/code&gt; binding is used to send click events to the server. When any client event, such as a &lt;code&gt;phx-click&lt;/code&gt; click is pushed, the value sent to the server will be chosen with the following priority:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecbede8f9d2cd80586f2666e7832e30ea05d175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-submit&lt;/code&gt; event is used for form submissions where major side effects typically happen, such as rendering new containers, calling an external service, or redirecting to a new page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3fdb35b1ba87d8758c4c7f6b8c9c83d6077ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-trigger-action&lt;/code&gt; attribute can be added to a form to trigger a standard form submit on DOM patch to the URL specified in the form's standard &lt;code&gt;action&lt;/code&gt; attribute. This is useful to perform pre-final validation of a LiveView form submit before posting to a controller route for operations that require Plug session mutation. For example, in your LiveView template you can annotate the &lt;code&gt;phx-trigger-action&lt;/code&gt; with a boolean assign:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7722c1018aa1c3f5818dfe70fb8f2d0e854f196c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query_cache&lt;/code&gt; and its state is documented in &lt;a href=&quot;#t:query_cache/0&quot;&gt;&lt;code&gt;query_cache/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd929735613a63a87936d342dcfc378113b7e06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query_meta&lt;/code&gt; field is a map containing some of the fields found in the &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; struct, after they have been normalized. For example, the values &lt;code&gt;selected&lt;/code&gt; by the query, which then have to be returned, can be found in &lt;code&gt;query_meta&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3070b126b1c8e20df8236ea7fbdbd8a762f348" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render_many/3&lt;/code&gt; function takes the data we want to respond with (&lt;code&gt;pages&lt;/code&gt;), a view, and a string to pattern match on the &lt;code&gt;render/2&lt;/code&gt; function defined on view. It will map over each item in &lt;code&gt;pages&lt;/code&gt;, and call &lt;code&gt;PageView.render(&quot;page.json&quot;, %{page: page})&lt;/code&gt;. &lt;code&gt;render_one/3&lt;/code&gt; follows, the same signature, ultimately using the &lt;code&gt;render/2&lt;/code&gt; matching &lt;code&gt;page.json&lt;/code&gt; to specify what each &lt;code&gt;page&lt;/code&gt; looks like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f45984330c354b062f13b6711532673248bd5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reply&lt;/code&gt; is a tuple contain an &lt;code&gt;opcode&lt;/code&gt; atom and a message that can be any term. The built-in websocket transport supports both &lt;code&gt;:text&lt;/code&gt; and &lt;code&gt;:binary&lt;/code&gt; opcode and the message must be always iodata. Long polling only supports text opcode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9961db9b5232c882c065bf97a578f4c214483a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run/1&lt;/code&gt; function is the critical heart of any Mix task. It's the function that does all the work when users invoke our task. In ours, all we do is send a greeting from our app, but we can implement our &lt;code&gt;run/1&lt;/code&gt; function to do whatever we need it to. Note that &lt;code&gt;Mix.shell().info/1&lt;/code&gt; is the preferred way to print text back out to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b70572d736ea97cd893ae8c7a89f40d35ac5c3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use Mix.Task&lt;/code&gt; line brings in functionality from Mix that makes this module behave as a mix task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21cb29773a5a21a0cd8e43940897e0aec855c3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;views&lt;/code&gt; attribute on the pages will not be updated directly by the user, so let's remove it from the generated form. Open &lt;code&gt;lib/hello_web/templates/cms/page/form.html.eex&lt;/code&gt; and remove this part:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7162959016edba78d69180b52bd5f5a794f9abb9" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Compatible&lt;/strong&gt; cipher suite supports tlsv1, tlsv1.1 and tlsv1.2. Ciphers were based on the OWASP Group B and includes support for RSA or ECDSA certificates. The intention of this configuration is to provide as secure as possible defaults that still maintain support for older browsers and Android versions 4.3 and earlier</source>
          <target state="translated">Набор &lt;strong&gt;совместимых&lt;/strong&gt; шифров поддерживает tlsv1, tlsv1.1 и tlsv1.2. Шифры были основаны на OWASP Group B и включают поддержку сертификатов RSA или ECDSA. Цель этой конфигурации - обеспечить как можно более безопасные значения по умолчанию, которые по-прежнему поддерживают старые браузеры и версии Android 4.3 и более ранние.</target>
        </trans-unit>
        <trans-unit id="99eef0b8032d9eb66bdd6211a81ce1aa7ab072a6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Strong&lt;/strong&gt; cipher suite only supports tlsv1.2. Ciphers were based on the OWASP Group A+ and includes support for RSA or ECDSA certificates. The intention of this configuration is to provide as secure as possible defaults knowing that it will not be fully compatible with older browsers and operating systems.</source>
          <target state="translated">Набор шифров &lt;strong&gt;Strong&lt;/strong&gt; поддерживает только tlsv1.2. Шифры были основаны на OWASP Group A + и включают поддержку сертификатов RSA или ECDSA. Цель этой конфигурации - обеспечить как можно более безопасные настройки по умолчанию, зная, что она не будет полностью совместима со старыми браузерами и операционными системами.</target>
        </trans-unit>
        <trans-unit id="1229266af5aeb7323a3edd251846a9e31826c75c" translate="yes" xml:space="preserve">
          <source>The API expected by a module plug is defined as a behaviour by the &lt;a href=&quot;plug#content&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; module (this module).</source>
          <target state="translated">API, ожидаемый модулем plug, определяется как поведение модуля &lt;a href=&quot;plug#content&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; (этот модуль).</target>
        </trans-unit>
        <trans-unit id="397359192255c3cbb30eaefb0a5026e948b7ee90" translate="yes" xml:space="preserve">
          <source>The Complete Elixir and Phoenix Bootcamp Master Functional Programming Techniques with Elixir and Phoenix while Learning to Build Compelling Web Applications (by Stephen Grider - 2017)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca090ddc59b8746edad3d668cd414cb0c01b50e" translate="yes" xml:space="preserve">
          <source>The Controller for LiveView rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a37edfcc20d368aed11372ea5e77be1563e669" translate="yes" xml:space="preserve">
          <source>The Cowboy adapter for Phoenix.</source>
          <target state="translated">Адаптер &quot;Ковбой&quot; для Феникса.</target>
        </trans-unit>
        <trans-unit id="5a9ef2f700440dbe5deb29ded8f4c846809f867a" translate="yes" xml:space="preserve">
          <source>The Cowboy2 adapter for Phoenix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46e58ab01f0b48b2315edfcf8b2bd6c7e2b3937" translate="yes" xml:space="preserve">
          <source>The Ecto implementation of these operators provide only a thin layer above the adapters. So if your adapter allows you to use them in a certain way (like adding a date and an interval in PostgreSQL), it should work just fine in Ecto queries.</source>
          <target state="translated">Реализация Ecto этих операторов обеспечивает только тонкий слой над адаптерами.Поэтому,если ваш адаптер позволяет использовать их определенным образом (например,добавить дату и интервал в PostgreSQL),то в запросах Ecto он должен работать просто отлично.</target>
        </trans-unit>
        <trans-unit id="5fc206f389e6b83e4a0d3d847f1852857f161e08" translate="yes" xml:space="preserve">
          <source>The Ecto type</source>
          <target state="translated">Тип Ecto</target>
        </trans-unit>
        <trans-unit id="dfd71c1d2df0567450285bf90b77cd7746d88f5d" translate="yes" xml:space="preserve">
          <source>The Ecto type.</source>
          <target state="translated">Тип Экто.</target>
        </trans-unit>
        <trans-unit id="8af11c43a109763d817fe84ffba10efa53664805" translate="yes" xml:space="preserve">
          <source>The Ecto.Changeset struct</source>
          <target state="translated">Структура Ecto.Changeset</target>
        </trans-unit>
        <trans-unit id="22799cdc97ac8d9ad98ed9959054ca073ced3180" translate="yes" xml:space="preserve">
          <source>The Elixir and Phoenix communities are friendly and welcoming. All questions and comments are valuable, so please come join the discussion!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df24cb6684bccd3bc7f1741ada3cd48d84d2739" translate="yes" xml:space="preserve">
          <source>The Elixir compiler would infer that the router depends directly on &lt;code&gt;MyApp.PageController&lt;/code&gt;, which is not true. By using scopes, Phoenix can properly hint to the Elixir compiler the controller is not an actual dependency of the router. This provides more efficient compilation times.</source>
          <target state="translated">Компилятор Elixir сделает вывод, что маршрутизатор напрямую зависит от &lt;code&gt;MyApp.PageController&lt;/code&gt; , что неверно. Используя области видимости, Phoenix может правильно намекнуть компилятору Elixir, что контроллер не является действительной зависимостью от маршрутизатора. Это обеспечивает более эффективное время компиляции.</target>
        </trans-unit>
        <trans-unit id="91a790f106411de498ef0d34631c0e826c9311e7" translate="yes" xml:space="preserve">
          <source>The Elixir compiler would infer that the router depends directly on &lt;code&gt;MyAppWeb.PageController&lt;/code&gt;, which is not true. By using scopes, Phoenix can properly hint to the Elixir compiler the controller is not an actual dependency of the router. This provides more efficient compilation times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f2df3ac4e5339357f53ff3d7998fcb1bc9dcf6" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP runtime, with OpenSSL bindings; run &lt;code&gt;:crypto.info_lib()&lt;/code&gt; in an IEx session to verify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64bf2211a83bfb2580975f065ce021d849dded2" translate="yes" xml:space="preserve">
          <source>The ErrorView</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcdec73ad8cfefe7c01cd059a8be75e6642807e" translate="yes" xml:space="preserve">
          <source>The JavaScript client is always the source of truth for current input values. For any given input with focus, LiveView will never overwrite the input's current value, even if it deviates from the server's rendered updates. This works well for updates where major side effects are not expected, such as form validation errors, or additive UX around the user's input values as they fill out a form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831c44469432e217932a773e59cba3396570b870" translate="yes" xml:space="preserve">
          <source>The LiveView entry-point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84226f67c848aa70d2bc109fe1a02c277fbf9624" translate="yes" xml:space="preserve">
          <source>The LiveView programming model is declarative: instead of saying &quot;once event X happens, change Y on the page&quot;, events in LiveView are regular messages which may cause changes to its state. Once the state changes, LiveView will re-render the relevant parts of its HTML template and push it to the browser, which updates itself in the most efficient manner. This means developers write LiveView templates as any other server-rendered HTML and LiveView does the hard work of tracking changes and sending the relevant diffs to the browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cabc4988a5643640cd777c24c4e10db6bb7accd" translate="yes" xml:space="preserve">
          <source>The LiveView socket for Phoenix Endpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e596187a19062dc70866323907923d83b3869a8b" translate="yes" xml:space="preserve">
          <source>The LiveView then receives this event using &lt;code&gt;handle_info&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5341cef174c7e030180c57e14cc0a67dcaa4ae50" translate="yes" xml:space="preserve">
          <source>The MFA is invoked with the request &lt;code&gt;%URI{}&lt;/code&gt; as the first argument, followed by arguments in the MFA list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="270a37f0365dba4dfda17bef61d0b68ede5a7a86" translate="yes" xml:space="preserve">
          <source>The PKCS#12 format is a container format containing one or more certificates and/or encrypted keys. Such files typically have a &lt;code&gt;.p12&lt;/code&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1e3a1bf73da067cc61947c8f82ff5aabd55c0a" translate="yes" xml:space="preserve">
          <source>The Phoenix engine that handles the &lt;code&gt;.eex&lt;/code&gt; extension.</source>
          <target state="translated">Движок Phoenix, обрабатывающий расширение &lt;code&gt;.eex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97f5600c69f57f57eb8f0eebfbf4c79da16ad178" translate="yes" xml:space="preserve">
          <source>The Phoenix engine that handles the &lt;code&gt;.exs&lt;/code&gt; extension.</source>
          <target state="translated">Движок Phoenix, обрабатывающий расширение &lt;code&gt;.exs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c893ff0c14a28253d63b6b6ebed042b7d8d1529" translate="yes" xml:space="preserve">
          <source>The Plug connection.</source>
          <target state="translated">Штепсельное соединение.</target>
        </trans-unit>
        <trans-unit id="922dcb442d54e2eb649f3edaeaaef6847fb03b26" translate="yes" xml:space="preserve">
          <source>The Plug pipeline</source>
          <target state="translated">Плуг-трубопровод</target>
        </trans-unit>
        <trans-unit id="6a8a63036ac108e3e027fabac2b118fd6784c36b" translate="yes" xml:space="preserve">
          <source>The Schema</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c6b8de891ce76973a55d8788f25b02282a6500" translate="yes" xml:space="preserve">
          <source>The Strict-Transport-Security header can be disabled altogether by setting &lt;code&gt;hsts: false&lt;/code&gt; in the &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c9c578a9e075a767d2efcef454f02f30cab843" translate="yes" xml:space="preserve">
          <source>The Telemetry supervisor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75bea59495492e66c838d460fdfd553076619980" translate="yes" xml:space="preserve">
          <source>The Telemetry.Metrics package provides a common interface for defining metrics. It exposes a set of &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#module-metrics&quot;&gt;five metric type functions&lt;/a&gt; that are responsible for structuring a given Telemetry event as a particular measurement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b0c7e1640a8c7aaaeec212113c4828dc9f200b" translate="yes" xml:space="preserve">
          <source>The URL generated in the named URL helpers is based on the configuration for &lt;code&gt;:url&lt;/code&gt;, &lt;code&gt;:http&lt;/code&gt; and &lt;code&gt;:https&lt;/code&gt;. However, if for some reason you need to manually control the URL generation, the url helpers also allow you to pass in a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct:</source>
          <target state="translated">URL генерируется в имя URL помощников основан на конфигурации для &lt;code&gt;:url&lt;/code&gt; , &lt;code&gt;:http&lt;/code&gt; и &lt;code&gt;:https&lt;/code&gt; . Однако, если по какой-то причине вам нужно вручную управлять генерацией URL-адресов, помощники URL-адресов также позволяют вам передать структуру &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="01f10584ffce5babefcdc2a0a4a9fa67e62fc824" translate="yes" xml:space="preserve">
          <source>The above approach is the preferred one when passing blocks to &lt;code&gt;do/end&lt;/code&gt;. However, if you are outside of a .leex template and you want to invoke a component passing a &lt;code&gt;do/end&lt;/code&gt; block, you will have to explicitly handle the assigns by giving it a &lt;code&gt;-&amp;gt;&lt;/code&gt; clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="439164b882483574280fd7b6ddd89690e34cb2f9" translate="yes" xml:space="preserve">
          <source>The above example matches all the posts which are tied for being the most visited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e2cd8ec0b373e2a840d10a660fde9ed74b82f4" translate="yes" xml:space="preserve">
          <source>The above is specially useful to dynamically join on existing queries, for example, to dynamically choose a source, or by choosing between public posts or posts that have been recently published:</source>
          <target state="translated">Вышеизложенное особенно полезно для динамического объединения по существующим запросам,например,для динамического выбора источника,или путем выбора между публичными сообщениями или сообщениями,которые были недавно опубликованы:</target>
        </trans-unit>
        <trans-unit id="ba48186478fa2045834150142a3421eea75c78b0" translate="yes" xml:space="preserve">
          <source>The above life-cycle callbacks have in-scope access to the following attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04796d750e2caa373bfdeb6b87607dcbc4363014" translate="yes" xml:space="preserve">
          <source>The action may be any atom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e8e7c6d83aa7057d13eecb45b68bd52baf600f" translate="yes" xml:space="preserve">
          <source>The action may be one of &lt;code&gt;:insert&lt;/code&gt;, &lt;code&gt;:update&lt;/code&gt;, &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:replace&lt;/code&gt;.</source>
          <target state="translated">Действие может быть один из &lt;code&gt;:insert&lt;/code&gt; , &lt;code&gt;:update&lt;/code&gt; , &lt;code&gt;:delete&lt;/code&gt; , &lt;code&gt;:replace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99e3ae0551db581b86eb9b59e1bc23af5b2492a7" translate="yes" xml:space="preserve">
          <source>The actual routes we get all look right, except for the path helper &lt;code&gt;review_path&lt;/code&gt; at the beginning of each line. We are getting the same helper for both the user facing review routes and the admin ones, which is not correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa523a4ad5df57fc1402bd4a02afcabbc3fd16b" translate="yes" xml:space="preserve">
          <source>The admin review paths could be prefixed with &lt;code&gt;/admin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568c1593cd6ebf7435ec1fe16f10bd8ce0b59776" translate="yes" xml:space="preserve">
          <source>The advantage of configuring the schema via those attributes is that they can be set with a macro to configure application wide defaults.</source>
          <target state="translated">Преимущество настройки схемы через эти атрибуты заключается в том,что их можно настроить с помощью макроса для конфигурирования настроек по умолчанию в масштабе всего приложения.</target>
        </trans-unit>
        <trans-unit id="12424a03c3ce8ae50505e2f4d39be7ede0456bb6" translate="yes" xml:space="preserve">
          <source>The aggregation will fail if any &lt;code&gt;group_by&lt;/code&gt; field is set.</source>
          <target state="translated">Агрегация завершится неудачно, если установлено какое- &lt;code&gt;group_by&lt;/code&gt; поле group_by .</target>
        </trans-unit>
        <trans-unit id="fd3788421c7ea60194ff0b67a68304eebb16c4a2" translate="yes" xml:space="preserve">
          <source>The allowed values are:</source>
          <target state="translated">Допустимые значения:</target>
        </trans-unit>
        <trans-unit id="ea72cf622646db7be3f6fbd8024e8493b451ac92" translate="yes" xml:space="preserve">
          <source>The answer is we've decided to expose &lt;code&gt;%Ecto.Changeset{}&lt;/code&gt; as a public &lt;em&gt;data-structure&lt;/em&gt; in our application. We saw before how changesets allow us to track field changes, perform validations, and generate error messages. Its use here is decoupled from the private Repo access and Ecto changeset API internals. We're exposing a data structure that the caller understands which contains the rich information like field errors. Conveniently for us, the &lt;code&gt;phoenix_ecto&lt;/code&gt; project implements the necessary &lt;a href=&quot;phoenix.param&quot;&gt;&lt;code&gt;Phoenix.Param&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../phoenix_html/phoenix.html.formdata&quot;&gt;&lt;code&gt;Phoenix.HTML.FormData&lt;/code&gt;&lt;/a&gt; protocols which know how to handle &lt;code&gt;%Ecto.Changeset{}&lt;/code&gt;'s for things like form generation and error messages. You can also think about it as being as if you had defined your own &lt;code&gt;%Accounts.Changes{}&lt;/code&gt; struct for the same purpose and implemented the Phoenix protocols for the web-layer integration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84bd30260d2ce05fc55d7e66349743b933c0b4f2" translate="yes" xml:space="preserve">
          <source>The argument given to &lt;code&gt;:select_merge&lt;/code&gt; must always be a map. The value being merged on must be a struct or a map. If it is a struct, the fields merged later on must be part of the struct, otherwise an error is raised.</source>
          <target state="translated">Аргумент, передаваемый &lt;code&gt;:select_merge&lt;/code&gt; , всегда должен быть картой. Объединяемое значение должно быть структурой или картой. Если это структура, объединенные позже поля должны быть частью структуры, в противном случае возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="21c3223c139377b3829c552e343068576edd50ef" translate="yes" xml:space="preserve">
          <source>The argument, which defaults to &lt;code&gt;Presence&lt;/code&gt;, defines the module name of the Presence tracker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629bfd4051da2fa1a32d9993713c3423b906b41a" translate="yes" xml:space="preserve">
          <source>The arguments are:</source>
          <target state="translated">Аргументы таковы:</target>
        </trans-unit>
        <trans-unit id="4fde4255a8dc0fcc4b0ec76dc711d0f44d251bab" translate="yes" xml:space="preserve">
          <source>The assign tracking feature also implies that you MUST avoid performing direct operations in the template. For example, if you perform a database query in your template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a43c3065c3f85e925ab838ea91589ca677d687c" translate="yes" xml:space="preserve">
          <source>The associated data may be given in different formats:</source>
          <target state="translated">Связанные с ними данные могут быть представлены в различных форматах:</target>
        </trans-unit>
        <trans-unit id="8af98cf8faab35d0cae464cb5a1cd4f56217e0ba" translate="yes" xml:space="preserve">
          <source>The association happens through a join schema or source, containing foreign keys to the associated schemas. For example, the association below:</source>
          <target state="translated">Ассоциация происходит через схему соединения или источник,содержащий посторонние ключи от связанных схем.Например,ассоциация,приведенная ниже:</target>
        </trans-unit>
        <trans-unit id="888fd6b9696e2737394550f497e91b80c4256ba5" translate="yes" xml:space="preserve">
          <source>The association struct for &lt;code&gt;has_one&lt;/code&gt; and &lt;code&gt;has_many&lt;/code&gt; associations.</source>
          <target state="translated">Структура ассоциации для ассоциаций &lt;code&gt;has_one&lt;/code&gt; и &lt;code&gt;has_many&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f2a2472baf2138a4d294eca1e823e09180b2a8" translate="yes" xml:space="preserve">
          <source>The association struct for &lt;code&gt;has_one&lt;/code&gt; and &lt;code&gt;has_many&lt;/code&gt; through associations.</source>
          <target state="translated">Структура ассоциации для &lt;code&gt;has_one&lt;/code&gt; и &lt;code&gt;has_many&lt;/code&gt; через ассоциации.</target>
        </trans-unit>
        <trans-unit id="581a7057c4a1b009249b52b9b19b5e74771aaf2a" translate="yes" xml:space="preserve">
          <source>The association struct for &lt;code&gt;many_to_many&lt;/code&gt; associations.</source>
          <target state="translated">Структура ассоциации для ассоциаций &lt;code&gt;many_to_many&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66e6c87098b4230d834f2d5a056760f88cae1720" translate="yes" xml:space="preserve">
          <source>The association struct for a &lt;code&gt;belongs_to&lt;/code&gt; association.</source>
          <target state="translated">Структура ассоциации для ассоциации &lt;code&gt;belongs_to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5205f046f1668f8df50e1a7dbf5d13e856ecfbab" translate="yes" xml:space="preserve">
          <source>The atoms that can be used in place of the status code in many functions are inflected from the reason phrase of the status code. With the above configuration, the following will all work:</source>
          <target state="translated">Атомы,которые могут быть использованы вместо кода статуса во многих функциях,изготавливаются по причине фразы кода статуса.При приведенной выше конфигурации будет работать следующее:</target>
        </trans-unit>
        <trans-unit id="480698b107c5364224299e11120625edd4811333" translate="yes" xml:space="preserve">
          <source>The behaviour above is by design to keep the changes between &lt;code&gt;where&lt;/code&gt; and &lt;code&gt;or_where&lt;/code&gt; minimal. Plus, if you have a keyword list and you would like each pair to be combined using &lt;code&gt;or&lt;/code&gt;, it can be easily done with &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Вышеупомянутое поведение предназначено для &lt;code&gt;or_where&lt;/code&gt; изменений между &lt;code&gt;where&lt;/code&gt; и or_where . Кроме того, если у вас есть список ключевых слов и вы хотите, чтобы каждая пара была объединена с помощью &lt;code&gt;or&lt;/code&gt; , это легко сделать с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3bc279bd4a05a0f1e2ea5d2a5959b414a345411f" translate="yes" xml:space="preserve">
          <source>The benefit of having explicit changesets is that we can easily provide different changesets for different use cases. For example, one could easily provide specific changesets for registering and updating users:</source>
          <target state="translated">Преимущество наличия явных изменений заключается в том,что мы можем легко предоставлять различные изменения для различных случаев использования.Например,можно легко предоставить конкретные наборы изменений для регистрации и обновления пользователей:</target>
        </trans-unit>
        <trans-unit id="a33976fda84cd70626bac12299c44a1b4814775d" translate="yes" xml:space="preserve">
          <source>The binary is assumed to be encoded in &quot;x-www-form-urlencoded&quot; format. The format is decoded and then validated for proper UTF-8 encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0833558fe12b0d9b2e81768ddbb74f8c8021373c" translate="yes" xml:space="preserve">
          <source>The browser can send a variety of events to a LiveView via &lt;code&gt;phx-&lt;/code&gt; bindings, which are sent to the &lt;code&gt;handle_event/3&lt;/code&gt; callback. To test events sent by the browser and assert on the rendered side effect of the event, use the &lt;code&gt;render_*&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47dd120170d17aa1d0f259374abed03b66d4f7d7" translate="yes" xml:space="preserve">
          <source>The cache can be in 3 states, documented below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af03881748bd2064e8f807b0d417c42f2bf8b4b" translate="yes" xml:space="preserve">
          <source>The callback invoked in case the adapter needs to inject code</source>
          <target state="translated">Обратный вызов вызывается в случае,если адаптеру необходимо ввести код.</target>
        </trans-unit>
        <trans-unit id="67ef6fb0196e40fee0ed0f4b18726aa52ce6c746" translate="yes" xml:space="preserve">
          <source>The callback invoked in case the adapter needs to inject code.</source>
          <target state="translated">Обратный вызов вызывается в случае,если адаптеру необходимо ввести код.</target>
        </trans-unit>
        <trans-unit id="5bbfddd88f74a0c053e76f91efe40fb552ccd1a5" translate="yes" xml:space="preserve">
          <source>The callback will be invoked for all queries, including queries made from associations and preloads. It is not invoked for each individual join inside a query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465bc3533bd128c95cfecfc17237e61c1f085130" translate="yes" xml:space="preserve">
          <source>The catch-all verb, &lt;code&gt;:*&lt;/code&gt;, may also be used to match all HTTP methods.</source>
          <target state="translated">Универсальный глагол &lt;code&gt;:*&lt;/code&gt; также может использоваться для сопоставления всех HTTP-методов.</target>
        </trans-unit>
        <trans-unit id="a92f849f6522a2c3db6efb9017fed09736bbac71" translate="yes" xml:space="preserve">
          <source>The certificate and CA chain can also be specified using DER binaries, using the &lt;code&gt;:cert&lt;/code&gt; and &lt;code&gt;:cacerts&lt;/code&gt; options, but this is best avoided. The use of PEM files has been tested much more thoroughly with the Erlang/OTP &lt;code&gt;:ssl&lt;/code&gt; application, and there have been a number of issues with DER binary certificates in the past.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd434dfdfacea66c9516a4ae4981484c3f005f5" translate="yes" xml:space="preserve">
          <source>The certificate files, like keyfile, certfile, cacertfile, dhfile can be given as a relative path. For such, the &lt;code&gt;:otp_app&lt;/code&gt; option must also be given and certificates will be looked from the priv directory of the given application</source>
          <target state="translated">Файлы сертификатов, такие как keyfile, certfile, cacertfile, dhfile, могут быть указаны как относительный путь. Для этого также необходимо &lt;code&gt;:otp_app&lt;/code&gt; параметр : otp_app, и сертификаты будут просматриваться из каталога Priv данного приложения.</target>
        </trans-unit>
        <trans-unit id="5c4d811c59379111f1c1ff93c837d9da4b33e1af" translate="yes" xml:space="preserve">
          <source>The change is to define the &lt;code&gt;live_view&lt;/code&gt; and &lt;code&gt;live_component&lt;/code&gt; functions in your &lt;code&gt;my_app_web.ex&lt;/code&gt; file, while refactoring the &lt;code&gt;view&lt;/code&gt; function. At the end, they will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f895ed3a5a29fab28a57c67512d9e78fea0303d" translate="yes" xml:space="preserve">
          <source>The change tracking also works when rendering other templates as long as they are also &lt;code&gt;.leex&lt;/code&gt; templates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8048a4c70c26c609930c982d23c8e90c3c74914" translate="yes" xml:space="preserve">
          <source>The changeset must have been previously &lt;code&gt;cast&lt;/code&gt; using &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt; before this function is invoked.</source>
          <target state="translated">Набор изменений должен быть предварительно &lt;code&gt;cast&lt;/code&gt; с использованием &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; перед вызовом этой функции.</target>
        </trans-unit>
        <trans-unit id="160a4bd88e21d5ca169655a091e64a1bf7eb4d1d" translate="yes" xml:space="preserve">
          <source>The channel that owns the socket will not receive the published message. The event&amp;rsquo;s message must be a serializable map.</source>
          <target state="translated">Канал, которому принадлежит сокет, не получит опубликованное сообщение. Сообщение события должно быть сериализуемой картой.</target>
        </trans-unit>
        <trans-unit id="14225c93c28bf8ec888fac6e844921cc19f40df5" translate="yes" xml:space="preserve">
          <source>The channel that owns the socket will not receive the published message. The event's message must be a serializable map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87a04668a71cfebe522dc33304dfa1bb9aafa32" translate="yes" xml:space="preserve">
          <source>The check constraint works by relying on the database to check if the check constraint has been violated or not and, if so, Ecto converts it into a changeset error.</source>
          <target state="translated">Ограничение проверки работает,полагаясь на БД для проверки,было ли ограничение проверки нарушено или нет,и если да,то Ecto преобразует его в ошибку changeset.</target>
        </trans-unit>
        <trans-unit id="189a91a56422abe5ad6f16e83079ee9147df5171" translate="yes" xml:space="preserve">
          <source>The ciphers chosen and related configuration are based on &lt;a href=&quot;https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet&quot;&gt;OWASP recommendations&lt;/a&gt;, with some modifications as described in the &lt;a href=&quot;plug.ssl#configure/1&quot;&gt;&lt;code&gt;Plug.SSL.configure/1&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2140aa521991d539b4e2e897df286c32583783" translate="yes" xml:space="preserve">
          <source>The code above builds a query that returns all organizations that belongs to the current user and then validates that the given &quot;org_id&quot; belongs to the user. If there is no such &quot;org_id&quot; or if the user has no access to it, an &lt;code&gt;Ecto.NotFoundError&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55ac05c44eebe5ced7773b3f09d70f633a77d33" translate="yes" xml:space="preserve">
          <source>The column name is arbitrary and doesn&amp;rsquo;t need to be &lt;code&gt;:lock_version&lt;/code&gt;. Now add a field to the schema too:</source>
          <target state="translated">Имя столбца произвольное и не обязательно &lt;code&gt;:lock_version&lt;/code&gt; . Теперь добавим в схему поле:</target>
        </trans-unit>
        <trans-unit id="22ce43d9dab9ba680dd79938365e5a367bde9ba9" translate="yes" xml:space="preserve">
          <source>The column name is arbitrary and doesn't need to be &lt;code&gt;:lock_version&lt;/code&gt;. Now add a field to the schema too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c1a428d5c10266245cfaf3fb20fc81b6b19a29" translate="yes" xml:space="preserve">
          <source>The command above means incoming socket connections can be made via a WebSocket connection. Events are routed by topic to channels:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d46c8827dfa162c3fc24d840406076f113e566" translate="yes" xml:space="preserve">
          <source>The command above means incoming socket connections can be made via the WebSocket transport. Events are routed by topic to channels:</source>
          <target state="translated">Вышеприведенная команда означает,что входящие соединения сокетов могут быть осуществлены с помощью транспорта WebSocket.События маршрутизируются по темам на каналы:</target>
        </trans-unit>
        <trans-unit id="a6bed204f25946a181bf872deafb93e1b8f811e4" translate="yes" xml:space="preserve">
          <source>The command above will effectively change the value of &lt;code&gt;conn.scheme&lt;/code&gt; by the one sent in &lt;code&gt;x-forwarded-proto&lt;/code&gt;.</source>
          <target state="translated">Приведенная выше команда фактически изменит значение &lt;code&gt;conn.scheme&lt;/code&gt; на значение, отправленное в &lt;code&gt;x-forwarded-proto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06d3e38d14906c69fe67c98e93d6ea14a4bb8bfd" translate="yes" xml:space="preserve">
          <source>The component ends up enclosed by the form markup, where LiveView cannot track it. In such cases, you may receive an error such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4afae376b75b4be5f358115a2f298594ed796ab" translate="yes" xml:space="preserve">
          <source>The component that is updated must be stateful (the &lt;code&gt;:id&lt;/code&gt; in the assigns must match the &lt;code&gt;:id&lt;/code&gt; associated with the component) and the component must be mounted within the current LiveView.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac44c98f163a9b266d4abe83ee653c46374e382" translate="yes" xml:space="preserve">
          <source>The configuration above takes care of starting the pubsub backend and exposing its functions via the endpoint module. If no adapter but a name is given, nothing will be started, but the pubsub system will work by sending events and subscribing to the given name.</source>
          <target state="translated">Приведенная выше конфигурация заботится о запуске бэкэнда pubsub и раскрытии его функций через оконечный модуль.Если адаптер не указан,кроме имени,то ничего не будет запущено,но система pubsub будет работать,отправляя события и подписываясь на данное имя.</target>
        </trans-unit>
        <trans-unit id="8b296a52b4ef4041ccbced6b08d102098ca424ae" translate="yes" xml:space="preserve">
          <source>The configuration above will start a Redis pubsub and register it with name &lt;code&gt;:my_pubsub&lt;/code&gt;.</source>
          <target state="translated">Приведенная выше конфигурация запустит pubsub Redis и зарегистрирует его с именем &lt;code&gt;:my_pubsub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c3243504e5d91d9054ed22ddbd7d15078c0b7c3" translate="yes" xml:space="preserve">
          <source>The configuration below can be given to both &lt;code&gt;:websocket&lt;/code&gt; and &lt;code&gt;:longpoll&lt;/code&gt; keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468fbe7bf04f16c5040863a52f0d55b418c094c8" translate="yes" xml:space="preserve">
          <source>The connection state is used to track the connection lifecycle. It starts as &lt;code&gt;:unset&lt;/code&gt; but is changed to &lt;code&gt;:set&lt;/code&gt; (via &lt;a href=&quot;#resp/3&quot;&gt;&lt;code&gt;resp/3&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;:set_chunked&lt;/code&gt; (used only for &lt;code&gt;before_send&lt;/code&gt; callbacks by &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;:file&lt;/code&gt; (when invoked via &lt;a href=&quot;#send_file/3&quot;&gt;&lt;code&gt;send_file/3&lt;/code&gt;&lt;/a&gt;). Its final result is &lt;code&gt;:sent&lt;/code&gt;, &lt;code&gt;:file&lt;/code&gt; or &lt;code&gt;:chunked&lt;/code&gt; depending on the response model.</source>
          <target state="translated">Состояние подключения используется для отслеживания жизненного цикла подключения. Он начинается как &lt;code&gt;:unset&lt;/code&gt; , но изменяется на &lt;code&gt;:set&lt;/code&gt; (через &lt;a href=&quot;#resp/3&quot;&gt; &lt;code&gt;resp/3&lt;/code&gt; &lt;/a&gt; ) или &lt;code&gt;:set_chunked&lt;/code&gt; (используется только для &lt;code&gt;before_send&lt;/code&gt; вызовов &lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt; ) или &lt;code&gt;:file&lt;/code&gt; (при вызове через &lt;a href=&quot;#send_file/3&quot;&gt; &lt;code&gt;send_file/3&lt;/code&gt; &lt;/a&gt; ). Ее конечный результат &lt;code&gt;:sent&lt;/code&gt; , &lt;code&gt;:file&lt;/code&gt; или &lt;code&gt;:chunked&lt;/code&gt; в зависимости от модели реагирования.</target>
        </trans-unit>
        <trans-unit id="48566362cafe346914c5a6f03d80d57d5efcb820" translate="yes" xml:space="preserve">
          <source>The connection will be configured with the given &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;path_or_action&lt;/code&gt; and &lt;code&gt;params_or_body&lt;/code&gt;.</source>
          <target state="translated">Соединение будет настроено с использованием данного &lt;code&gt;method&lt;/code&gt; , &lt;code&gt;path_or_action&lt;/code&gt; и &lt;code&gt;params_or_body&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d448c7ac90d83c40db5bfb1c89d1edee4438350" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s endpoint will be used for URL generation. See &lt;a href=&quot;#current_path/1&quot;&gt;&lt;code&gt;current_path/1&lt;/code&gt;&lt;/a&gt; for details on how the request path is generated.</source>
          <target state="translated">Конечная точка соединения будет использоваться для генерации URL. См. &lt;a href=&quot;#current_path/1&quot;&gt; &lt;code&gt;current_path/1&lt;/code&gt; &lt;/a&gt; для получения подробной информации о том, как создается путь запроса.</target>
        </trans-unit>
        <trans-unit id="d40469a6ab597b422ee4f68bd557b30e3be2a9ae" translate="yes" xml:space="preserve">
          <source>The container can be customized in different ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d4bab9d56a81796bac83a3ef42018e650c34ee" translate="yes" xml:space="preserve">
          <source>The context app</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0facde72bd2ec18fe66926da4d93236d6aff0bce" translate="yes" xml:space="preserve">
          <source>The context is an Elixir module that serves as an API boundary for the given resource. A context often holds many related resources. Therefore, if the context already exists, it will be augmented with functions for the given resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31946d1aec3ffc473697b735314efcde461c192" translate="yes" xml:space="preserve">
          <source>The context is an Elixir module that serves as an API boundary for the given resource. A context often holds many related resources. Therefore, if the context already exists, it will be augmented with functions for the given resource. Note a resource may also be split over distinct contexts (such as Accounts.User and Payments.User).</source>
          <target state="translated">Контекст представляет собой модуль Elixir,который служит границей API для данного ресурса.Контекст часто содержит множество связанных с ним ресурсов.Поэтому,если контекст уже существует,он будет дополнен функциями для данного ресурса.Обратите внимание,что ресурс может быть разделен на различные контексты (такие как Accounts.User и Payments.User).</target>
        </trans-unit>
        <trans-unit id="6ef96e1551a038d10e050b366a6393c8066aa195" translate="yes" xml:space="preserve">
          <source>The cookie value is not automatically escaped. Therefore, if you want to store values with comma, quotes, and so on, you need to explicitly escape them or use a function such as &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; when writing and &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; when reading the cookie. Padding needs to be disabled since &lt;code&gt;=&lt;/code&gt; is not a valid character in cookie values.</source>
          <target state="translated">Значение cookie не экранируется автоматически. Поэтому, если вы хотите хранить значения с запятыми, кавычками и т. Д., Вам нужно явно экранировать их или использовать такую ​​функцию, как &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; при записи и &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; при чтении cookie. Заполнение необходимо отключить, поскольку &lt;code&gt;=&lt;/code&gt; не является допустимым символом в значениях файлов cookie.</target>
        </trans-unit>
        <trans-unit id="0b75f4c0b3e543c026233950dd58d233dabc0916" translate="yes" xml:space="preserve">
          <source>The cookie value is not automatically escaped. Therefore, if you want to store values with comma, quotes, etc, you need to explicitly escape them or use a function such as &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; when writing and &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; when reading the cookie. Padding needs to be disabled since &lt;code&gt;=&lt;/code&gt; is not a valid character in cookie values.</source>
          <target state="translated">Значение cookie не экранируется автоматически. Поэтому, если вы хотите хранить значения с запятыми, кавычками и т. Д., Вам необходимо явно экранировать их или использовать такую ​​функцию, как &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; при записи и &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; при чтении cookie. Заполнение необходимо отключить, поскольку &lt;code&gt;=&lt;/code&gt; не является допустимым символом в значениях файлов cookie.</target>
        </trans-unit>
        <trans-unit id="bc170b7df02149d4f1b41d395782c4bf6a42233e" translate="yes" xml:space="preserve">
          <source>The cookie value that will be sent in cookie headers. This value should be base64 encoded to avoid security issues</source>
          <target state="translated">Значение куки,которое будет отправлено в заголовках куки.Это значение должно быть закодировано в base64,чтобы избежать проблем с безопасностью.</target>
        </trans-unit>
        <trans-unit id="4ed8e930bd798b7f59e1b3906dae0c5ae18ae5f5" translate="yes" xml:space="preserve">
          <source>The cookie value that will be sent in cookie headers. This value should be base64 encoded to avoid security issues.</source>
          <target state="translated">Значение куки,которое будет отправлено в заголовках куки.Это значение должно быть закодировано в base64,чтобы избежать проблем с безопасностью.</target>
        </trans-unit>
        <trans-unit id="6e2028fc8c0e6e2d2a17c2988205cfc1a48f5c7d" translate="yes" xml:space="preserve">
          <source>The core of this action is &lt;code&gt;render(conn, &quot;index.html&quot;)&lt;/code&gt;. It tells Phoenix to render &quot;index.html&quot;. The modules responsible for rendering are views. By default, Phoenix views are named after the controller, so Phoenix is expecting a &lt;code&gt;HelloWeb.HelloView&lt;/code&gt; to exist and handle &quot;index.html&quot; for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fdf691245b570b56fac13fe863e01499ed9c09b" translate="yes" xml:space="preserve">
          <source>The current LiveView will be shut down and a new one will be mounted in its place, without reloading the whole page. This can also be used to remount the same LiveView, in case you want to start fresh. If you want to navigate to the same LiveView without remounting it, use &lt;a href=&quot;#live_patch/2&quot;&gt;&lt;code&gt;live_patch/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0cdcbf70ae3305c8dd93ccd61f868d5e436588" translate="yes" xml:space="preserve">
          <source>The current LiveView will be shutdown and a new one will be mounted in its place, without reloading the whole page. This can also be used to remount the same LiveView, in case you want to start fresh. If you want to navigate to the same LiveView without remounting it, use &lt;a href=&quot;#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b1fd62f16ed364400554fa3c072cfdd758b718" translate="yes" xml:space="preserve">
          <source>The current action will always be available inside the LiveView as the &lt;code&gt;@live_action&lt;/code&gt; assign, that can be used to render a LiveComponent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8e46ad87d3469e7e9f3187e46155cee02aaf64d" translate="yes" xml:space="preserve">
          <source>The current schema belongs to zero or one records of the other schema. The other schema often has a &lt;code&gt;has_one&lt;/code&gt; or a &lt;code&gt;has_many&lt;/code&gt; field with the reverse association.</source>
          <target state="translated">Текущая схема принадлежит нулю или одной записи другой схемы. Другая схема часто имеет &lt;code&gt;has_one&lt;/code&gt; или &lt;code&gt;has_many&lt;/code&gt; с обратной связью .</target>
        </trans-unit>
        <trans-unit id="37f668c1bd4c3e820e33a15f5f380f812917f51d" translate="yes" xml:space="preserve">
          <source>The current schema has zero or more records of the other schema embedded inside of it. Embeds have all the things regular schemas have.</source>
          <target state="translated">Текущая схема имеет ноль или больше записей о другой схеме,встроенной в нее.Во вложениях есть все то,что есть у обычных схем.</target>
        </trans-unit>
        <trans-unit id="bb6532e1cfbc40c65e0d70c093c2d84b8c13c97c" translate="yes" xml:space="preserve">
          <source>The current schema has zero or more records of the other schema. The other schema often has a &lt;code&gt;belongs_to&lt;/code&gt; field with the reverse association.</source>
          <target state="translated">Текущая схема содержит ноль или более записей другой схемы. Другая схема часто имеет поле &lt;code&gt;belongs_to&lt;/code&gt; с обратной связью .</target>
        </trans-unit>
        <trans-unit id="a2400e9bff3b3fcf167090fc4f9675aa1dafa03a" translate="yes" xml:space="preserve">
          <source>The current schema has zero or one records of the other schema embedded inside of it. It uses a field similar to the &lt;code&gt;:map&lt;/code&gt; type for storage, but allows embeds to have all the things regular schema can.</source>
          <target state="translated">Текущая схема имеет ноль или одну запись о другой схеме, встроенной в нее. Он использует поле, подобное типу &lt;code&gt;:map&lt;/code&gt; для хранения, но позволяет встроенным элементам иметь все, что может обычная схема.</target>
        </trans-unit>
        <trans-unit id="543e48ecf9a036c8c3265d90420f7f54855d1f07" translate="yes" xml:space="preserve">
          <source>The current schema has zero or one records of the other schema. The other schema often has a &lt;code&gt;belongs_to&lt;/code&gt; field with the reverse association.</source>
          <target state="translated">Текущая схема имеет ноль или одну запись другой схемы. Другая схема часто имеет поле &lt;code&gt;belongs_to&lt;/code&gt; с обратной связью .</target>
        </trans-unit>
        <trans-unit id="a89c1ce17f89437f89ff113dd237432b1779e13f" translate="yes" xml:space="preserve">
          <source>The current time in UTC is retrieved from Elixir and not from the database.</source>
          <target state="translated">Текущее время в UTC извлекается из Elixir,а не из базы данных.</target>
        </trans-unit>
        <trans-unit id="b052c5d0d8705bd378272066bfc771be8f95160c" translate="yes" xml:space="preserve">
          <source>The data is stored in ETS in the following format:</source>
          <target state="translated">Данные сохраняются в ETS в следующем формате:</target>
        </trans-unit>
        <trans-unit id="1acda630ba32f073701a386f5cfe162756e7c372" translate="yes" xml:space="preserve">
          <source>The data stored in the token is signed to prevent tampering but not encrypted. This means it is safe to store identification information (such as user IDs) but should not be used to store confidential information (such as credit card numbers).</source>
          <target state="translated">Данные,хранящиеся в токене,подписываются для предотвращения взлома,но не шифруются.Это означает,что идентификационная информация (например,идентификаторы пользователей)безопасна для хранения,но не должна использоваться для хранения конфиденциальной информации (например,номера кредитных карт).</target>
        </trans-unit>
        <trans-unit id="f7d8e9c428788f4e316259dfd396beb63eed3450" translate="yes" xml:space="preserve">
          <source>The data world is your oyster, but we won't be covering these options in these guides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e3f4c1170977052f6619c9eadd4414d82a1869" translate="yes" xml:space="preserve">
          <source>The database for HelloPhoenix.repo has been created. We're also ready to run any migrations, or do anything else with Ecto that we might choose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b03cf10e6fc6af894d1777f43a9e4564e801a7" translate="yes" xml:space="preserve">
          <source>The datetime types</source>
          <target state="translated">Типы даты</target>
        </trans-unit>
        <trans-unit id="57585ba4de2b044b0be68355ad35a6afa2297af3" translate="yes" xml:space="preserve">
          <source>The debug state uses the browser's built-in &lt;code&gt;sessionStorage&lt;/code&gt;, so it will remain in effect for as long as your browser session lasts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91240847c4c0b4e5c86209a80fab1b682a0b72d" translate="yes" xml:space="preserve">
          <source>The default Endpoint plugs do quite a lot of work. Here they are in order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d063536b5fd16a46117b63d1178dfcad16b720" translate="yes" xml:space="preserve">
          <source>The default HTML encoder that ships with Phoenix.</source>
          <target state="translated">HTML-кодировщик по умолчанию,который поставляется с Phoenix.</target>
        </trans-unit>
        <trans-unit id="b6a5014904611a0144837aa761a0d9c7ac17de4a" translate="yes" xml:space="preserve">
          <source>The default format is used when none is set in the connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb15ee34b6e76bea7879309e5d7b64c6bf0dee90" translate="yes" xml:space="preserve">
          <source>The default format is used when none is set in the connection.</source>
          <target state="translated">Формат по умолчанию используется,когда ни один из них не установлен в соединении.</target>
        </trans-unit>
        <trans-unit id="565d3288130af0242285fb747529bfd66f40c7d5" translate="yes" xml:space="preserve">
          <source>The default implementation simply passes &lt;code&gt;presences&lt;/code&gt; through unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6676a691528a06988caceda0bdea8ffb85ace6e8" translate="yes" xml:space="preserve">
          <source>The default option can be given to populate the fields if none is given:</source>
          <target state="translated">По умолчанию можно задать заполнение полей,если ни одно из них не задано:</target>
        </trans-unit>
        <trans-unit id="2c66e666e4d64f7851485bf4d02d2f008e867eb1" translate="yes" xml:space="preserve">
          <source>The default router is inflected from the application name unless a configuration named &lt;code&gt;:namespace&lt;/code&gt; is set inside your application configuration. For example, the configuration:</source>
          <target state="translated">Маршрутизатор по умолчанию зависит от имени приложения, если конфигурация с именем &lt;code&gt;:namespace&lt;/code&gt; не установлена ​​в конфигурации вашего приложения. Например, конфигурация:</target>
        </trans-unit>
        <trans-unit id="bef1bc8ef401a761e7d8eba7f4227945005b964c" translate="yes" xml:space="preserve">
          <source>The definition of basic custom types and all of its callbacks is available in this module. You can learn more about parameterized types in &lt;a href=&quot;ecto.parameterizedtype&quot;&gt;&lt;code&gt;Ecto.ParameterizedType&lt;/code&gt;&lt;/a&gt;. If in doubt, prefer to use basic custom types and rely on parameterized types if you need the extra functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bea1b5faf766b56d93add1c5f07efe92cf9dfa" translate="yes" xml:space="preserve">
          <source>The difference between them is that most validations can be executed without a need to interact with the database and, therefore, are always executed before attempting to insert or update the entry in the database. Some validations may happen against the database but they are inherently unsafe. Those validations start with a &lt;code&gt;unsafe_&lt;/code&gt; prefix, such as &lt;a href=&quot;#unsafe_validate_unique/3&quot;&gt;&lt;code&gt;unsafe_validate_unique/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Разница между ними заключается в том, что большинство проверок может выполняться без необходимости взаимодействия с базой данных и, следовательно, всегда выполняются перед попыткой вставить или обновить запись в базе данных. Некоторые проверки могут происходить в базе данных, но они по своей сути небезопасны. Эти проверки начинаются с префикса &lt;code&gt;unsafe_&lt;/code&gt; , например &lt;a href=&quot;#unsafe_validate_unique/3&quot;&gt; &lt;code&gt;unsafe_validate_unique/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b905a6abee1408a861b937e78adce0825322527a" translate="yes" xml:space="preserve">
          <source>The dispatcher must be available on all nodes running the PubSub system. The &lt;code&gt;dispatch/3&lt;/code&gt; function of the given module will be invoked with the subscriptions entries, the broadcaster identifier (either a pid or &lt;code&gt;:none&lt;/code&gt;), and the message to broadcast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a466df0e05cd07db8216347664891ea2d6f388" translate="yes" xml:space="preserve">
          <source>The distinction whether to insert or update will be made on the &lt;a href=&quot;ecto.schema.metadata&quot;&gt;&lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt;&lt;/a&gt; field &lt;code&gt;:state&lt;/code&gt;. The &lt;code&gt;:state&lt;/code&gt; is automatically set by Ecto when loading or building a schema.</source>
          <target state="translated">Различие между вставкой или обновлением будет выполняться в поле &lt;a href=&quot;ecto.schema.metadata&quot;&gt; &lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:state&lt;/code&gt; . Состояние &lt;code&gt;:state&lt;/code&gt; автоматически устанавливается Ecto при загрузке или построении схемы.</target>
        </trans-unit>
        <trans-unit id="98110b4f952a325165904e437acdb05dceca3afb" translate="yes" xml:space="preserve">
          <source>The download is achieved by setting &quot;content-disposition&quot; to attachment. The &quot;content-type&quot; will also be set based on the extension of the given filename but can be customized via the &lt;code&gt;:content_type&lt;/code&gt; and &lt;code&gt;:charset&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bea122452a37ef030f627235ed1844a3ddfe593" translate="yes" xml:space="preserve">
          <source>The download is achieved by setting &amp;ldquo;content-disposition&amp;rdquo; to attachment. The &amp;ldquo;content-type&amp;rdquo; will also be set based on the extension of the given filename but can be customized via the &lt;code&gt;:content_type&lt;/code&gt; and &lt;code&gt;:charset&lt;/code&gt; options.</source>
          <target state="translated">Загрузка достигается установкой &amp;laquo;content-disposition&amp;raquo; для вложения. &amp;laquo;Тип содержимого&amp;raquo; также будет установлен на основе расширения данного имени файла, но его можно настроить с помощью параметров &lt;code&gt;:content_type&lt;/code&gt; и &lt;code&gt;:charset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="305f411cb067461e7008b3366143db8315830828" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto use the primary keys to detect if an embed is being updated or not. If a primary is not present and you still want the list of embeds to be updated, &lt;code&gt;:on_replace&lt;/code&gt; must be set to &lt;code&gt;:delete&lt;/code&gt;, forcing all current embeds to be deleted and replaced by new ones whenever a new list of embeds is set.</source>
          <target state="translated">Встроенный может иметь или не иметь первичный ключ. Ecto использует первичные ключи, чтобы определить, обновляется встраивание или нет. Если первичный элемент отсутствует, но вы по-прежнему хотите, чтобы список встраиваний обновлялся, для &lt;code&gt;:on_replace&lt;/code&gt; должно быть установлено значение &lt;code&gt;:delete&lt;/code&gt; , при котором все текущие вложения должны удаляться и заменяться новыми всякий раз, когда устанавливается новый список вложений.</target>
        </trans-unit>
        <trans-unit id="9851fea47b9bbc161a06c36308d9e5222d41ca5d" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto use the primary keys to detect if an embed is being updated or not. If a primary is not present, &lt;code&gt;:on_replace&lt;/code&gt; should be set to either &lt;code&gt;:update&lt;/code&gt; or &lt;code&gt;:delete&lt;/code&gt; if there is a desire to either update or delete the current embed when a new one is set.</source>
          <target state="translated">Встроенный может иметь или не иметь первичный ключ. Ecto использует первичные ключи, чтобы определить, обновляется встраивание или нет. Если первичного &lt;code&gt;:on_replace&lt;/code&gt; нет, для : on_replace должно быть установлено значение &lt;code&gt;:update&lt;/code&gt; или &lt;code&gt;:delete&lt;/code&gt; , если есть желание обновить или удалить текущее встраивание при установке нового.</target>
        </trans-unit>
        <trans-unit id="1949ed7b2d6dffd9e7c7748d7bd6bc3abd5dcf0c" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto uses the primary keys to detect if an embed is being updated or not. If a primary is not present and you still want the list of embeds to be updated, &lt;code&gt;:on_replace&lt;/code&gt; must be set to &lt;code&gt;:delete&lt;/code&gt;, forcing all current embeds to be deleted and replaced by new ones whenever a new list of embeds is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9a17476a78a7a92bdf8fb962890959f1ad1049" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto uses the primary keys to detect if an embed is being updated or not. If a primary key is not present, &lt;code&gt;:on_replace&lt;/code&gt; should be set to either &lt;code&gt;:update&lt;/code&gt; or &lt;code&gt;:delete&lt;/code&gt; if there is a desire to either update or delete the current embed when a new one is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240ba5b0f9226d65d40a221b0aaca6577ac67121" translate="yes" xml:space="preserve">
          <source>The encoding of server data and the decoding of client data is done according to a serializer, defined in &lt;a href=&quot;phoenix.socket.serializer&quot;&gt;&lt;code&gt;Phoenix.Socket.Serializer&lt;/code&gt;&lt;/a&gt;. By default, JSON encoding is used to broker messages to and from clients with &lt;code&gt;Phoenix.Socket.V2.JSONSerializer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc586997cb9ff4e598fbaf2d150c17e623488e6" translate="yes" xml:space="preserve">
          <source>The endpoint being tested is accessed via the &lt;code&gt;@endpoint&lt;/code&gt; module attribute.</source>
          <target state="translated">Доступ к &lt;code&gt;@endpoint&lt;/code&gt; конечной точке осуществляется через атрибут модуля @endpoint .</target>
        </trans-unit>
        <trans-unit id="1085ea34a986c448fabcc15a67e4b94b2cb117ef" translate="yes" xml:space="preserve">
          <source>The endpoint is the boundary where all requests to your web application start. It is also the interface your application provides to the underlying web servers.</source>
          <target state="translated">Конечная точка-это граница,с которой начинаются все запросы к вашему веб-приложению.Это также интерфейс,который Ваше приложение предоставляет базовым веб-серверам.</target>
        </trans-unit>
        <trans-unit id="74811601480966246292b2b910ca967ac18caf00" translate="yes" xml:space="preserve">
          <source>The endpoint, router, and controllers in Phoenix accept plugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71e0101c0d6d0c31084c2c74654c8ab5ada1e0f" translate="yes" xml:space="preserve">
          <source>The entry point for defining forms in Phoenix is with the &lt;a href=&quot;#form_for/4&quot;&gt;&lt;code&gt;form_for/4&lt;/code&gt;&lt;/a&gt; function. For this example, we will use &lt;code&gt;Ecto.Changeset&lt;/code&gt;, which integrates nicely with Phoenix forms via the &lt;code&gt;phoenix_ecto&lt;/code&gt; package.</source>
          <target state="translated">&lt;a href=&quot;#form_for/4&quot;&gt; &lt;code&gt;form_for/4&lt;/code&gt; &lt;/a&gt; точкой для определения форм в Phoenix является функция form_for / 4 . В этом примере мы будем использовать &lt;code&gt;Ecto.Changeset&lt;/code&gt; , который хорошо интегрируется с формами Phoenix через пакет &lt;code&gt;phoenix_ecto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04c6d1a307f90ddcd28dacda1e19147d95f5924b" translate="yes" xml:space="preserve">
          <source>The event callback is called &lt;em&gt;before&lt;/em&gt; the event happens (in this case, before the view is rendered) with the atom &lt;code&gt;:start&lt;/code&gt; as the first argument; see the &amp;ldquo;Before clause&amp;rdquo; section below.</source>
          <target state="translated">Обратный вызов события вызывается &lt;em&gt;до&lt;/em&gt; того, как событие произойдет (в данном случае перед визуализацией представления) с атомом &lt;code&gt;:start&lt;/code&gt; в качестве первого аргумента; см. раздел &amp;laquo;До&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="757e085e21ddd74789de7bdb0bbe8f07bed88c4b" translate="yes" xml:space="preserve">
          <source>The event callback sequence is:</source>
          <target state="translated">Последовательность обратного вызова событий:</target>
        </trans-unit>
        <trans-unit id="8146ea0120720d389e5e641e32fe81e0949316e4" translate="yes" xml:space="preserve">
          <source>The event occurs (in this case, the view is rendered).</source>
          <target state="translated">Происходит событие (в этом случае выводится изображение).</target>
        </trans-unit>
        <trans-unit id="ae116b624d5b59052eb64f10c8d76ec7dd431042" translate="yes" xml:space="preserve">
          <source>The event&amp;rsquo;s message must be a serializable map.</source>
          <target state="translated">Сообщение события должно быть сериализуемой картой.</target>
        </trans-unit>
        <trans-unit id="59c29c61995ac6adc27d72e58769a2befdbcb1f2" translate="yes" xml:space="preserve">
          <source>The event's message must be a serializable map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f8e9a757d63677055c9099b13a0e178eebb865" translate="yes" xml:space="preserve">
          <source>The example above does not use &lt;code&gt;in&lt;/code&gt; because &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; do not require a reference to the data source. However, extending the query with a where expression would require the use of &lt;code&gt;in&lt;/code&gt;:</source>
          <target state="translated">В приведенном выше примере не используется &lt;code&gt;in&lt;/code&gt; , поскольку &lt;code&gt;limit&lt;/code&gt; и &lt;code&gt;offset&lt;/code&gt; не требуют ссылки на источник данных. Однако расширение запроса выражением where потребует использования &lt;code&gt;in&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2a68a419c4788a627e1c523a21aa9c289200ba77" translate="yes" xml:space="preserve">
          <source>The example above renders a template &quot;show.html&quot; from the &lt;code&gt;MyAppWeb.UserView&lt;/code&gt; and sets the response content type to &quot;text/html&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323718568a794b79b80b9c7f90d47fc0dddb0e78" translate="yes" xml:space="preserve">
          <source>The example above renders a template &amp;ldquo;show.html&amp;rdquo; from the &lt;code&gt;MyApp.UserView&lt;/code&gt; and sets the response content type to &amp;ldquo;text/html&amp;rdquo;.</source>
          <target state="translated">В приведенном выше примере отображается шаблон &amp;laquo;show.html&amp;raquo; из &lt;code&gt;MyApp.UserView&lt;/code&gt; и устанавливается тип содержимого ответа &amp;laquo;text / html&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="263bcd680d02d0dedd523e55597569bfc7eb4085" translate="yes" xml:space="preserve">
          <source>The example above will fetch all posts from the database and then do a separate query returning all comments associated with the given posts. The comments are then processed and associated to each returned &lt;code&gt;post&lt;/code&gt; under the &lt;code&gt;comments&lt;/code&gt; field.</source>
          <target state="translated">В приведенном выше примере будут извлечены все сообщения из базы данных, а затем выполнен отдельный запрос, возвращающий все комментарии, связанные с данными сообщениями. Затем комментарии обрабатываются и связываются с каждым возвращенным &lt;code&gt;post&lt;/code&gt; в поле &lt;code&gt;comments&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b71e88e7ed588cf8386d56a8b902c449be09cbf4" translate="yes" xml:space="preserve">
          <source>The example above will issue two queries, one for loading posts and then another for loading the comments associated with the posts. Comments will be ordered by &lt;code&gt;published_at&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере будет выдано два запроса: один для загрузки сообщений, а второй - для загрузки комментариев, связанных с сообщениями. Комментарии будут отсортированы по &lt;code&gt;published_at&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="924e9a6b17eb83d28266379ce64871ee77dfc336" translate="yes" xml:space="preserve">
          <source>The example above will work if the input query has 1 or 10 bindings. As long as the number of bindings is less than the number of from + joins, Ecto will match only what you have specified. The first binding always matches the source given in &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">Приведенный выше пример будет работать, если входной запрос имеет 1 или 10 привязок. Пока количество привязок меньше количества соединений from +, Ecto будет соответствовать только тому, что вы указали. Первая привязка всегда соответствует источнику, указанному в &lt;code&gt;from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="597f52cde33ea3d40cd216eeff98f0f27574f4d6" translate="yes" xml:space="preserve">
          <source>The exclusion constraint works by relying on the database to check if the exclusion constraint has been violated or not and, if so, Ecto converts it into a changeset error.</source>
          <target state="translated">Ограничение исключения работает,полагаясь на БД для проверки,было ли это ограничение нарушено или нет,и если да,то Ecto преобразует его в ошибку changeset.</target>
        </trans-unit>
        <trans-unit id="77dfbd136a0c7b400c0e6cf8e244d45dcfb4c0ae" translate="yes" xml:space="preserve">
          <source>The field name will be used as is to read and write to the database by all of the built-in adapters unless overridden with the &lt;code&gt;:source&lt;/code&gt; option.</source>
          <target state="translated">Имя поля будет использоваться для чтения и записи в базу данных всеми встроенными адаптерами, если оно не будет переопределено опцией &lt;code&gt;:source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28d67d8abd4a4854029b14119fba01291b055159" translate="yes" xml:space="preserve">
          <source>The fields are:</source>
          <target state="translated">Поля:</target>
        </trans-unit>
        <trans-unit id="23e99979ef97808c907b0384c23bb476163e1c89" translate="yes" xml:space="preserve">
          <source>The fields generated by this macro will automatically be set to the current time when inserting and updating values in a repository.</source>
          <target state="translated">Поля,генерируемые данным макросом,будут автоматически установлены на текущее время при вставке и обновлении значений в репозитории.</target>
        </trans-unit>
        <trans-unit id="b3a7c7070bdd1da6f37c5437d705a4f71db3064c" translate="yes" xml:space="preserve">
          <source>The first argument can also be a &lt;code&gt;types&lt;/code&gt; map:</source>
          <target state="translated">Первым аргументом также может быть карта &lt;code&gt;types&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="49bed0abeb1db58200a4ef0db4c5da86c91aa45c" translate="yes" xml:space="preserve">
          <source>The first argument can be a a schema module, or a map (of types) and determines the return value: a struct or a map, respectively.</source>
          <target state="translated">Первый аргумент может быть модулем схемы,или картой (типов)и определяет возвращаемое значение:структуру или карту,соответственно.</target>
        </trans-unit>
        <trans-unit id="ec0251c98fcdc3180f663f2d434e28c1ff287694" translate="yes" xml:space="preserve">
          <source>The first argument can be a an embedded schema module, or a map (of types) and determines the return value: a struct or a map, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="500f8521003b9bf543828ad835d40f5eeb6af0a7" translate="yes" xml:space="preserve">
          <source>The first argument is a &lt;code&gt;datetime&lt;/code&gt;, the second one is the count for the interval, which may be either positive or negative and the interval value:</source>
          <target state="translated">Первый аргумент - это &lt;code&gt;datetime&lt;/code&gt; и время, второй - счетчик интервала, который может быть положительным или отрицательным, и значение интервала:</target>
        </trans-unit>
        <trans-unit id="c0e54dc181af943e0b3cceca923e134cbcf1e0c6" translate="yes" xml:space="preserve">
          <source>The first argument is the context module followed by the schema module and its plural name (used as the schema table name).</source>
          <target state="translated">Первый аргумент-контекстный модуль,за которым следует модуль схемы и его имя во множественном числе (используется в качестве имени таблицы схем).</target>
        </trans-unit>
        <trans-unit id="4865c8fae49bc4316a74325ea7181643af770fb4" translate="yes" xml:space="preserve">
          <source>The first argument is the context the callback is being invoked. If it is called because the Repo supervisor is starting, it will be &lt;code&gt;:supervisor&lt;/code&gt;. It will be &lt;code&gt;:runtime&lt;/code&gt; if it is called for reading configuration without actually starting a process.</source>
          <target state="translated">Первый аргумент - это контекст, в котором вызывается обратный вызов. Если он вызывается из-за запуска супервизора репо, это будет &lt;code&gt;:supervisor&lt;/code&gt; . Это будет &lt;code&gt;:runtime&lt;/code&gt; если она вызывается для чтения конфигурации без фактического запуска процесса.</target>
        </trans-unit>
        <trans-unit id="abeed1d3f6ef43117d9c456048712438c831279a" translate="yes" xml:space="preserve">
          <source>The first argument is the module name followed by its plural name (used for resources and schema).</source>
          <target state="translated">Первый аргумент-имя модуля,за которым следует его множественное имя (используется для ресурсов и схемы).</target>
        </trans-unit>
        <trans-unit id="964c9cb93e956fb751ffeb1617eb35e4e1dd5ef8" translate="yes" xml:space="preserve">
          <source>The first argument is the module name followed by its plural name (used for the schema).</source>
          <target state="translated">Первый аргумент-имя модуля,за которым следует его имя во множественном числе (используется для схемы).</target>
        </trans-unit>
        <trans-unit id="35f70a15e0108aa4e4b74899ee54723e2a713861" translate="yes" xml:space="preserve">
          <source>The first argument is the path where the static files are located. The &lt;code&gt;-o&lt;/code&gt; option indicates the path that will be used to save the digested and compressed files.</source>
          <target state="translated">Первый аргумент - это путь, по которому находятся статические файлы. Параметр &lt;code&gt;-o&lt;/code&gt; указывает путь, который будет использоваться для сохранения переваренных и сжатых файлов.</target>
        </trans-unit>
        <trans-unit id="2fe4f44a0f785ff10de251522a37c07e0b5ab7bb" translate="yes" xml:space="preserve">
          <source>The first argument is the schema module followed by its plural name (used as the table name).</source>
          <target state="translated">Первый аргумент-модуль схемы,за которым следует его имя во множественном числе (используется в качестве имени таблицы).</target>
        </trans-unit>
        <trans-unit id="e4b02077d7ac802cfee0627d193ca5cd0a9be149" translate="yes" xml:space="preserve">
          <source>The first argument is the schema module followed by the schema attributes</source>
          <target state="translated">Первый аргумент-модуль схемы,за которым следуют атрибуты схемы</target>
        </trans-unit>
        <trans-unit id="d11a276567643357f029e74ffc86b05f8be866b2" translate="yes" xml:space="preserve">
          <source>The first argument is the schema module followed by the schema attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85394c0d9cf1f3bd97ab6925f698c432e75e0ba3" translate="yes" xml:space="preserve">
          <source>The first argument should either be a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5565085e0846e63bdeb7de3b6914b3e5d53f51" translate="yes" xml:space="preserve">
          <source>The first argument to both &lt;a href=&quot;#sign/4&quot;&gt;&lt;code&gt;sign/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; can be one of:</source>
          <target state="translated">Первый аргумент для &lt;a href=&quot;#sign/4&quot;&gt; &lt;code&gt;sign/4&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; может быть одним из:</target>
        </trans-unit>
        <trans-unit id="d49a3d210dbcdc92bf9475253ce66aa64aa7725b" translate="yes" xml:space="preserve">
          <source>The first field name, &lt;code&gt;:email&lt;/code&gt; in this case, will be used as the error key to the changeset errors keyword list. For example, the above &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; would generate something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c98ababa7076deb4b23e215e725e5dcc321dec" translate="yes" xml:space="preserve">
          <source>The first line below the module definition invokes the &lt;code&gt;__using__/1&lt;/code&gt; macro of the &lt;code&gt;HelloWeb&lt;/code&gt; module, which imports some useful modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d9874d0b09b5d634a9bffe5a01fb056e0e669b" translate="yes" xml:space="preserve">
          <source>The first line of this module, &lt;code&gt;use HelloWeb, :router&lt;/code&gt;, simply makes Phoenix router functions available in our particular router.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b536e4964b55b3a608e3b733d3258cc0956029a" translate="yes" xml:space="preserve">
          <source>The first parameter is always &lt;code&gt;conn&lt;/code&gt;, a struct which holds information about the request such as the host, path elements, port, query string, and much more. &lt;code&gt;conn&lt;/code&gt;, comes to Phoenix via Elixir's Plug middleware framework. More detailed info about &lt;code&gt;conn&lt;/code&gt; can be found in &lt;a href=&quot;../plug/plug.conn&quot;&gt;plug's documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb52f0181ac504af2d274804ae227768df1b3b4" translate="yes" xml:space="preserve">
          <source>The first plug will run only when action is show or edit. The second plug will always run, except for the index action.</source>
          <target state="translated">Первый плагин будет работать только при показе или редактировании действия.Второй плагин будет работать всегда,за исключением действия с индексом.</target>
        </trans-unit>
        <trans-unit id="a7a085c723aa2725f1a835b9fa686c2f8a3dbb9f" translate="yes" xml:space="preserve">
          <source>The first question is, where does that error string come from? The answer is right in the &lt;code&gt;ErrorView&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cb90ded997365e136d73bbbbeaa6912dce9a57" translate="yes" xml:space="preserve">
          <source>The first step is to start the adapter of choice in your supervision tree:</source>
          <target state="translated">Первый шаг-запустить адаптер по выбору в дереве управления:</target>
        </trans-unit>
        <trans-unit id="ce8e7b83d95aab3d7102e7f0e03f87b4868c2329" translate="yes" xml:space="preserve">
          <source>The first thing we need to do is create a &lt;code&gt;mix/tasks&lt;/code&gt; directory inside of &lt;code&gt;lib&lt;/code&gt;. This is where any of our application specific mix tasks will go.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e521b29a1418c4c03c1262013a47617e674a9abe" translate="yes" xml:space="preserve">
          <source>The first thing we need to do is name our module. All tasks must be defined in &lt;code&gt;Mix.Tasks&lt;/code&gt; namespace. We'd like to invoke this as &lt;code&gt;mix hello.greeting&lt;/code&gt;, so we complete the module name with &lt;code&gt;Hello.Greeting&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f463e217a7cb3a4cb33031b1d1ba5fe4bbd808" translate="yes" xml:space="preserve">
          <source>The first thing we need to do to create that page is define a route for it. Let's open up &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; in a text editor. For a brand new application, it looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8101d8208169439cea8beb089d2fd5b7d5aeff5" translate="yes" xml:space="preserve">
          <source>The flash functionality is handy when mixed with redirects. Perhaps you want to redirect to a page with some extra information. If we re-use the redirect action from the previous section, we can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23dbc44cf8fcb8401ecac56fad2056f3e27fd632" translate="yes" xml:space="preserve">
          <source>The following approach is &lt;strong&gt;wrong&lt;/strong&gt;:</source>
          <target state="translated">Следующий подход &lt;strong&gt;неверен&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="27f0532927f5dfde2ed38eb7adc999b8682a2ebd" translate="yes" xml:space="preserve">
          <source>The following assigns are reserved, and cannot be set directly:</source>
          <target state="translated">Следующие назначения зарезервированы и не могут быть установлены напрямую:</target>
        </trans-unit>
        <trans-unit id="96a9598d7d5639506795473ffa8dad0e7b28cb27" translate="yes" xml:space="preserve">
          <source>The following configuration applies only to &lt;code&gt;:longpoll&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9626abcad38b5d2ad7be4a47ee7034e64d5860" translate="yes" xml:space="preserve">
          <source>The following configuration applies only to &lt;code&gt;:websocket&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13779d40c7bd0138f604faeb9ae943fd9630bdfd" translate="yes" xml:space="preserve">
          <source>The following events are emitted by all Ecto repositories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697b7462029e6e23c15a3021022337813a16f040" translate="yes" xml:space="preserve">
          <source>The following fields are private and must not be accessed directly.</source>
          <target state="translated">Следующие поля являются приватными и не должны быть доступны напрямую.</target>
        </trans-unit>
        <trans-unit id="baaf66ee23187b5f5ad09e6055f8ea194c2622bf" translate="yes" xml:space="preserve">
          <source>The following function lifts &lt;code&gt;metadata.socket.view&lt;/code&gt; and &lt;code&gt;metadata.socket.connected?&lt;/code&gt; to be top-level keys on &lt;code&gt;metadata&lt;/code&gt;, as we did in the previous example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34d9298df0cbb61838280284087d26545c45a26" translate="yes" xml:space="preserve">
          <source>The following intervals are supported: year, month, week, day, hour, minute, second, millisecond and microsecond.</source>
          <target state="translated">Поддерживаются следующие интервалы:год,месяц,неделя,день,час,минута,секунда,миллисекунда и микросекунда.</target>
        </trans-unit>
        <trans-unit id="1ff93af922ef6535f32352b2b639755a01dafeb3" translate="yes" xml:space="preserve">
          <source>The following keys are allowed when specifying a window.</source>
          <target state="translated">При указании окна допускаются следующие ключи.</target>
        </trans-unit>
        <trans-unit id="59c9c3a965c72c26e14a2014331e87cf4bda5729" translate="yes" xml:space="preserve">
          <source>The following keys are available:</source>
          <target state="translated">Доступны следующие клавиши:</target>
        </trans-unit>
        <trans-unit id="fdd2468c439eb11013c816be656d524ad7f23e6f" translate="yes" xml:space="preserve">
          <source>The following params have special meaning in LiveView:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebca73a523dda1e7ab387256d00be6cee49a026" translate="yes" xml:space="preserve">
          <source>The following public fields represent the LiveView:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77ca9c2bc454b722bf0d3007090b822823c3ad6" translate="yes" xml:space="preserve">
          <source>The following public fields represent the element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d94986edc28d20eb6e61b59ed0d6b150611abc" translate="yes" xml:space="preserve">
          <source>The following returns must be handled by transports:</source>
          <target state="translated">Следующие возвраты должны быть обработаны транспортом:</target>
        </trans-unit>
        <trans-unit id="cc0e8fdffd8fa1f0de767e3b482f423a5a285a50" translate="yes" xml:space="preserve">
          <source>The following specialized behavior is performed for forms and keydown bindings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7450f3bbf7bebc0ac2b8dc21e3fc9b6d5613f466" translate="yes" xml:space="preserve">
          <source>The following status codes can be given as atoms with their respective value shown next:</source>
          <target state="translated">Следующие коды состояния могут быть даны в виде атомов с их соответствующим значением:</target>
        </trans-unit>
        <trans-unit id="c734167c81ee7d5e27dd0815c6c9a86a53980591" translate="yes" xml:space="preserve">
          <source>The following types are supported:</source>
          <target state="translated">Поддерживаются следующие типы:</target>
        </trans-unit>
        <trans-unit id="2047e7bdd4c73fd0eee9eccb4cbf4a0fb4bc1b07" translate="yes" xml:space="preserve">
          <source>The following validations may be included in the result. The list is not necessarily exhaustive. For example, custom validations written by the developer will also appear in our return value.</source>
          <target state="translated">В результат могут быть включены следующие подтверждения.Список не обязательно является исчерпывающим.Например,пользовательские валидации,написанные разработчиком,также будут отображаться в нашем возвращаемом значении.</target>
        </trans-unit>
        <trans-unit id="cba133f413c5a544cc032d45c75d5ce55c737264" translate="yes" xml:space="preserve">
          <source>The following values are supported as date:</source>
          <target state="translated">Следующие значения поддерживаются как дата:</target>
        </trans-unit>
        <trans-unit id="5bfa84ecf1155190787c1f7e94a11fe721e17de4" translate="yes" xml:space="preserve">
          <source>The following values are supported as time:</source>
          <target state="translated">Следующие значения поддерживаются как время:</target>
        </trans-unit>
        <trans-unit id="a481ccb6962d389f9f787ae8a2a1fafb0d321119" translate="yes" xml:space="preserve">
          <source>The following window-level bindings are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce20518f56534bcc1118c0bf986d78eef528c90" translate="yes" xml:space="preserve">
          <source>The following:</source>
          <target state="translated">Следующее:</target>
        </trans-unit>
        <trans-unit id="4117df297cda8bdfcd48daa253e21cdf1ba31860" translate="yes" xml:space="preserve">
          <source>The foreign key constraint works by relying on the database to check if the associated data exists or not. This is useful to guarantee that a child will only be created if the parent exists in the database too.</source>
          <target state="translated">Ограничение постороннего ключа работает,полагаясь на базу данных для проверки наличия или отсутствия связанных с ней данных.Это полезно для гарантии того,что дочерний элемент будет создан только в том случае,если родитель существует и в БД.</target>
        </trans-unit>
        <trans-unit id="9abddf5cdee83822dd2471a1c84adfa00e2761db" translate="yes" xml:space="preserve">
          <source>The form data will be validated directly against the form markup and make sure the data you are changing/submitting actually exists, failing otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fa4eb4ae0982343eb1b5d21fa657d106b56303" translate="yes" xml:space="preserve">
          <source>The form generates a CSRF token by default. Your application should check this token on the server to avoid attackers from making requests on your server in behalf of other users. Phoenix by default checks this token.</source>
          <target state="translated">По умолчанию форма генерирует CSRF-токен.Ваше приложение должно проверить этот маркер на сервере,чтобы злоумышленники не делали запросы на вашем сервере от имени других пользователей.Phoenix по умолчанию проверяет этот маркер.</target>
        </trans-unit>
        <trans-unit id="a1ba555c0e57f112db7c92095d012a43d52db5ee" translate="yes" xml:space="preserve">
          <source>The form receives the &lt;code&gt;&quot;phx-submit-loading&quot;&lt;/code&gt; class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83c045b60690e0951f0d613211981e82b773a3a" translate="yes" xml:space="preserve">
          <source>The form should either be a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d01992897ad728050b4b855767bf08df37caba2" translate="yes" xml:space="preserve">
          <source>The form should either be a &lt;a href=&quot;phoenix.html.form#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">Форма должна быть либо &lt;a href=&quot;phoenix.html.form#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; ,&lt;/a&gt; создаваемой &lt;code&gt;form_for&lt;/code&gt; , либо атомом.</target>
        </trans-unit>
        <trans-unit id="7a6fd6898aaadbc26c2bf3b5a891b41542112f89" translate="yes" xml:space="preserve">
          <source>The form's inputs are set to &lt;code&gt;readonly&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1af6d5bfd7bd7fb64c73cbb0bcf39cb8cf169f9" translate="yes" xml:space="preserve">
          <source>The format has to be expressed as a regular expression.</source>
          <target state="translated">Формат должен быть выражен как регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="489cb5dcb56120d97d2c8e93ec7af5be88c2a077" translate="yes" xml:space="preserve">
          <source>The forwarded plug will be initialized at compile time.</source>
          <target state="translated">Переадресованный плагин будет инициализирован во время компиляции.</target>
        </trans-unit>
        <trans-unit id="77d021b8d46e32208156e088e01303ca1c12d18a" translate="yes" xml:space="preserve">
          <source>The full list of &lt;code&gt;:telemetry&lt;/code&gt; events emitted from Phoenix, along with their measurements and metadata, is available in the &quot;Instrumentation&quot; section of the &lt;a href=&quot;phoenix.logger&quot;&gt;&lt;code&gt;Phoenix.Logger&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f475ae2afee4e174380adc1703f946251ee406f" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; can be used to handle these messages.</source>
          <target state="translated">Для обработки этих сообщений можно использовать функцию &lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2ef8c5833d6215f90102ad8553d89a6b62ac7bf" translate="yes" xml:space="preserve">
          <source>The function above fetches all users from the database who have registered presences for the given topic. The fetched information is then extended with a &lt;code&gt;:user&lt;/code&gt; key of the user&amp;rsquo;s information, while maintaining the required &lt;code&gt;:metas&lt;/code&gt; field from the original presence data.</source>
          <target state="translated">Вышеупомянутая функция извлекает из базы данных всех пользователей, которые зарегистрировались для данной темы. Затем полученная информация дополняется ключом &lt;code&gt;:user&lt;/code&gt; информации о пользователе с сохранением обязательного поля &lt;code&gt;:metas&lt;/code&gt; из исходных данных о присутствии.</target>
        </trans-unit>
        <trans-unit id="3bb5d899f787348b0861709cf9aa7599e25a199f" translate="yes" xml:space="preserve">
          <source>The function accepts a status either as an integer HTTP status or atom, such as &lt;code&gt;404&lt;/code&gt; or &lt;code&gt;:not_found&lt;/code&gt;. If an error is raised, a 3-tuple of the wrapped response is returned matching the status, headers, and body of the response:</source>
          <target state="translated">Функция принимает статус либо как целочисленный статус HTTP, либо как атом, например &lt;code&gt;404&lt;/code&gt; или &lt;code&gt;:not_found&lt;/code&gt; . Если возникает ошибка, возвращается 3-кортеж обернутого ответа, соответствующий статусу, заголовкам и телу ответа:</target>
        </trans-unit>
        <trans-unit id="7a00d6812bf7a0419f2a6f9124c6b63f43006264" translate="yes" xml:space="preserve">
          <source>The function accepts a status either as an integer HTTP status or atom, such as &lt;code&gt;404&lt;/code&gt; or &lt;code&gt;:not_found&lt;/code&gt;. The list of allowed atoms is available in &lt;a href=&quot;../plug/plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt;. If an error is raised, a 3-tuple of the wrapped response is returned matching the status, headers, and body of the response:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f7c94fd7748f67cd09813bdd7706a2edb3046e" translate="yes" xml:space="preserve">
          <source>The function given to &lt;code&gt;run&lt;/code&gt; must return &lt;code&gt;{:ok, value}&lt;/code&gt; or &lt;code&gt;{:error, value}&lt;/code&gt; as its result. Returning an error will abort any further operations and make the whole multi fail.</source>
          <target state="translated">Функция, данная для &lt;code&gt;run&lt;/code&gt; должна возвращать &lt;code&gt;{:ok, value}&lt;/code&gt; или &lt;code&gt;{:error, value}&lt;/code&gt; качестве своего результата. Возврат ошибки приведет к прерыванию любых дальнейших операций и отказу всего мультика.</target>
        </trans-unit>
        <trans-unit id="2a481723c76058903ea9cbe576e12efab982d90c" translate="yes" xml:space="preserve">
          <source>The function must return a map of data matching the outlined Presence data structure, including the &lt;code&gt;:metas&lt;/code&gt; key, but can extend the map of information to include any additional information. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa901f9a75974fd4d90e6889c130fadce04c365a" translate="yes" xml:space="preserve">
          <source>The function returns a tuple with the first element being a quoted reference to the connection and the second element being the compiled quoted pipeline.</source>
          <target state="translated">Функция возвращает кортеж,первый элемент которого является цитируемой ссылкой на соединение,а второй-скомпилированным цитируемым трубопроводом.</target>
        </trans-unit>
        <trans-unit id="153b2df483884d8b989e308df19cc7b9893a9689" translate="yes" xml:space="preserve">
          <source>The function should return either &lt;code&gt;{:ok, value}&lt;/code&gt; or &lt;code&gt;{:error, value}&lt;/code&gt;, and receives the repo as the first argument, and the changes so far as the second argument.</source>
          <target state="translated">Функция должна возвращать либо &lt;code&gt;{:ok, value}&lt;/code&gt; либо &lt;code&gt;{:error, value}&lt;/code&gt; , и принимает репо в качестве первого аргумента, а изменения - во втором аргументе.</target>
        </trans-unit>
        <trans-unit id="a67c783032e2a201537e306cf6f097d5365e66b6" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module helps in performing &quot;origin&quot; header checks and ensuring only SSL connections are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d040f9e18e02bf1e9b7b5a6b1124e1c1c9357436" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module helps in performing &amp;ldquo;origin&amp;rdquo; header checks and ensuring only SSL connections are allowed.</source>
          <target state="translated">Функциональные возможности, предоставляемые этим модулем, помогают выполнять проверки заголовка &amp;laquo;источника&amp;raquo; и гарантировать, что разрешены только SSL-соединения.</target>
        </trans-unit>
        <trans-unit id="f3caf5d490d3889e61dbe8db689ddbc1dc882729" translate="yes" xml:space="preserve">
          <source>The functions in this module can also be used for controller testing. While endpoint testing is preferred over controller testing as a controller often depends on the pipelines invoked in the router and before, unit testing controllers may be helpful in some situations.</source>
          <target state="translated">Функции этого модуля могут также использоваться для тестирования контроллера.Хотя тестирование конечной точки предпочтительнее тестирования контроллера,так как контроллер часто зависит от трубопроводов,вызываемых в маршрутизаторе и ранее,контроллеры юнит-тестирования могут быть полезны в некоторых ситуациях.</target>
        </trans-unit>
        <trans-unit id="5e080e3a5969a0dfe51e38a130fc2af62050c352" translate="yes" xml:space="preserve">
          <source>The functions in this module can also be used for controller testing. While endpoint testing is preferred over controller testing, especially since the controller in Phoenix plays an integration role between your domain and your views, unit testing controllers may be helpful in some situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dd86f90d5374c8aba9a2543470a122fcff086c" translate="yes" xml:space="preserve">
          <source>The functions in this module can be used in three distinct scenarios:</source>
          <target state="translated">Функции этого модуля могут использоваться в трех различных сценариях:</target>
        </trans-unit>
        <trans-unit id="ca241d49313e0782ffcc88432a8a2d858c13e8e9" translate="yes" xml:space="preserve">
          <source>The generated datetime_select can be customized at will by providing a builder option. Here is an example from EEx:</source>
          <target state="translated">Сгенерированный datetime_select можно настроить по желанию,предоставив опцию сборщика.Вот пример из EEx:</target>
        </trans-unit>
        <trans-unit id="a05e320bee1a84e2ffca470cb7c31539b99e85c1" translate="yes" xml:space="preserve">
          <source>The generated files will contain:</source>
          <target state="translated">Генерируемые файлы будут содержаться:</target>
        </trans-unit>
        <trans-unit id="958104172477f9b5a43c314b73c9b38aabb7fb31" translate="yes" xml:space="preserve">
          <source>The generated migration can be skipped with &lt;code&gt;--no-migration&lt;/code&gt;.</source>
          <target state="translated">Созданную миграцию можно пропустить с помощью &lt;code&gt;--no-migration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2360bfab30a1d9a0770994aab3da68e5eb2150e6" translate="yes" xml:space="preserve">
          <source>The generated model will contain:</source>
          <target state="translated">Сгенерированная модель будет содержать:</target>
        </trans-unit>
        <trans-unit id="c2fafd8b72db2fda76555b5c3231ac455bc8d91f" translate="yes" xml:space="preserve">
          <source>The generated request id will be in the format &quot;uq8hs30oafhj5vve8ji5pmp7mtopc08f&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5668b35e826d6b7f7128c9281d2999702c5951" translate="yes" xml:space="preserve">
          <source>The generated request id will be in the format &amp;ldquo;uq8hs30oafhj5vve8ji5pmp7mtopc08f&amp;rdquo;.</source>
          <target state="translated">Сгенерированный идентификатор запроса будет в формате &amp;laquo;uq8hs30oafhj5vve8ji5pmp7mtopc08f&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3f6f61987271b75470a17cf53dff2fe262f3c6a6" translate="yes" xml:space="preserve">
          <source>The generated resource will contain:</source>
          <target state="translated">Сгенерированный ресурс будет содержать:</target>
        </trans-unit>
        <trans-unit id="07a1ec291d930976c73c9d45dd66aa61e5c367bd" translate="yes" xml:space="preserve">
          <source>The generated route above will match on the path &lt;code&gt;&quot;/api/v1/pages/:id&quot;&lt;/code&gt; and will dispatch to &lt;code&gt;:show&lt;/code&gt; action in &lt;code&gt;API.V1.PageController&lt;/code&gt;. A named helper &lt;code&gt;api_v1_page_path&lt;/code&gt; will also be generated.</source>
          <target state="translated">Сгенерированный выше маршрут будет соответствовать пути &lt;code&gt;&quot;/api/v1/pages/:id&quot;&lt;/code&gt; и будет отправлен в &lt;code&gt;:show&lt;/code&gt; action в &lt;code&gt;API.V1.PageController&lt;/code&gt; . Также будет сгенерирован именованный помощник &lt;code&gt;api_v1_page_path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8eb6914d64c4e5b2458e4e1b429f8d5623fada37" translate="yes" xml:space="preserve">
          <source>The generated schema above will contain:</source>
          <target state="translated">Сгенерированная выше схема будет содержать:</target>
        </trans-unit>
        <trans-unit id="b0fe9476efd56f82a1ea6f2439a7dfb5f439d397" translate="yes" xml:space="preserve">
          <source>The generator also supports &lt;code&gt;belongs_to&lt;/code&gt; associations via references:</source>
          <target state="translated">Генератор также поддерживает ассоциации &lt;code&gt;belongs_to&lt;/code&gt; через ссылки:</target>
        </trans-unit>
        <trans-unit id="a584765639065a0e41059878bfc54d658311e358" translate="yes" xml:space="preserve">
          <source>The generator also supports references, which we will properly associate the given column to the primary key column of the referenced table:</source>
          <target state="translated">Генератор также поддерживает ссылки,которые мы будем правильно ассоциировать с основным ключевым столбцом таблицы ссылок:</target>
        </trans-unit>
        <trans-unit id="8ae78460b27964100f540d3c51518f56de1ae5d6" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;data&lt;/code&gt; may be either a changeset, a schema struct or a &lt;code&gt;{data, types}&lt;/code&gt; tuple. The second argument is a map of &lt;code&gt;params&lt;/code&gt; that are cast according to the type information from &lt;code&gt;data&lt;/code&gt;. &lt;code&gt;params&lt;/code&gt; is a map with string keys or a map with atom keys containing potentially invalid data.</source>
          <target state="translated">Указанные &lt;code&gt;data&lt;/code&gt; могут быть набором изменений, структурой схемы или кортежем &lt;code&gt;{data, types}&lt;/code&gt; . Второй аргумент - это карта &lt;code&gt;params&lt;/code&gt; которые приводятся в соответствии с информацией о типе из &lt;code&gt;data&lt;/code&gt; . &lt;code&gt;params&lt;/code&gt; - это карта со строковыми ключами или карта с атомными ключами, содержащая потенциально недопустимые данные.</target>
        </trans-unit>
        <trans-unit id="ed7aeeaafe6c3bad4cfce08f957a5bf97bc013c4" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;function&lt;/code&gt; is invoked with the change value only if there is a change for the given &lt;code&gt;key&lt;/code&gt;. Note that the value of the change can still be &lt;code&gt;nil&lt;/code&gt; (unless the field was marked as required on &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Данная &lt;code&gt;function&lt;/code&gt; вызывается со значением изменения, только если есть изменение для данного &lt;code&gt;key&lt;/code&gt; . Обратите внимание, что значение изменения все еще может быть &lt;code&gt;nil&lt;/code&gt; (если поле не было помечено как обязательное в &lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="12ae3f1712df00636f70321070eb45b1efc012c4" translate="yes" xml:space="preserve">
          <source>The given attributes are expected to be structured data. If you want to build an association with external data, such as a request parameters, you can use &lt;a href=&quot;ecto.changeset#cast/3&quot;&gt;&lt;code&gt;Ecto.Changeset.cast/3&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;build_assoc/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33d234c4ff95f48de07c57959d603389ff704eb" translate="yes" xml:space="preserve">
          <source>The given channel is joined in a separate process which is linked to the test process.</source>
          <target state="translated">Данный канал объединен в отдельный процесс,который связан с процессом тестирования.</target>
        </trans-unit>
        <trans-unit id="d4c5415cdd429b8d05fbc81af9046db394117d84" translate="yes" xml:space="preserve">
          <source>The given definition:</source>
          <target state="translated">Данное определение:</target>
        </trans-unit>
        <trans-unit id="7187a5e81ba59fd9a2b763b67226ecb68e6f3832" translate="yes" xml:space="preserve">
          <source>The given function is guaranteed to run inside the same transaction as the changeset operation for databases that do support transactions.</source>
          <target state="translated">Данная функция гарантированно работает внутри той же самой транзакции,что и changeset для баз данных,которые поддерживают транзакции.</target>
        </trans-unit>
        <trans-unit id="2c8584e031d70f2ab97e4e82d41f8a6fb76ac929" translate="yes" xml:space="preserve">
          <source>The goal of this guide is to talk about Phoenix's request life-cycle. This guide will take a practical approach where we will learn by doing: we will add two new pages to our Phoenix project and comment on how the pieces fit together along the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c29577b9a3f39ac89098a852612cb04bd74935b" translate="yes" xml:space="preserve">
          <source>The guides that you are currently looking at provide an overview of all parts that make Phoenix. Here is a rundown of what they provide:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4310f0789aac7f01d7f849f6e0aa96ec026f81a0" translate="yes" xml:space="preserve">
          <source>The helper function &lt;a href=&quot;#values/2&quot;&gt;&lt;code&gt;values/2&lt;/code&gt;&lt;/a&gt; returns the values for a given schema and field, which can be used in places like form drop-downs. For example, given the following schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef55b811dca93ddd51b8b1f7019f7e4229080fe" translate="yes" xml:space="preserve">
          <source>The hook can push events to the LiveView by using the &lt;code&gt;pushEvent&lt;/code&gt; function and receive a reply from the server via a &lt;code&gt;{:reply, map, socket}&lt;/code&gt; return value. The reply payload will be passed to the optional &lt;code&gt;pushEvent&lt;/code&gt; response callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a573a08337f6f0cf025ec9ae17d9092603c49c35" translate="yes" xml:space="preserve">
          <source>The implementation of this callback should invoke &lt;code&gt;fun&lt;/code&gt; with the value under &lt;code&gt;key&lt;/code&gt; in the passed structure &lt;code&gt;data&lt;/code&gt;, or with &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in it. This function must return either &lt;code&gt;{get_value, update_value}&lt;/code&gt; or &lt;code&gt;:pop&lt;/code&gt;.</source>
          <target state="translated">Реализация этого обратного вызова должна вызывать &lt;code&gt;fun&lt;/code&gt; со значением под &lt;code&gt;key&lt;/code&gt; в переданных &lt;code&gt;data&lt;/code&gt; структуры или с &lt;code&gt;nil&lt;/code&gt; , если &lt;code&gt;key&lt;/code&gt; в нем отсутствует. Эта функция должна возвращать либо &lt;code&gt;{get_value, update_value}&lt;/code&gt; либо &lt;code&gt;:pop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d3c9aaa3512be3173ee88a5acfdcc5972b212b6" translate="yes" xml:space="preserve">
          <source>The instructions below will serve if you are installing the latest stable version from Hex. To start using LiveView, add one of the following dependencies to your &lt;code&gt;mix.exs&lt;/code&gt; and run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e46bc2ee246632c28439adb8036c4ec274b15b36" translate="yes" xml:space="preserve">
          <source>The internal infrastructure LiveView uses to keep track of stateful components is very lightweight. However, be aware that in order to provide change tracking and to send diffs over the wire, all of the components assigns are kept in memory - exactly as it is done in LiveViews themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897fcb552f1ed96e5b37d174da2e32ad713e210e" translate="yes" xml:space="preserve">
          <source>The internal reference to the session in the store</source>
          <target state="translated">Внутренняя ссылка на сеанс в магазине</target>
        </trans-unit>
        <trans-unit id="2b0fb080dc23dfd38867594f47439c384bd3fe00" translate="yes" xml:space="preserve">
          <source>The internal reference to the session in the store.</source>
          <target state="translated">Внутренняя ссылка на сеанс в магазине.</target>
        </trans-unit>
        <trans-unit id="75c017e0096c8191807383c0ba159f9238866e0c" translate="yes" xml:space="preserve">
          <source>The issue is that we have no guarantees the channel has done processing our message after calling &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt;. The best solution is to assert the channel sent us a reply before doing any other assertion. First change the channel to send replies:</source>
          <target state="translated">Проблема в том, что у нас нет гарантий, что канал обработал наше сообщение после вызова &lt;a href=&quot;#push/3&quot;&gt; &lt;code&gt;push/3&lt;/code&gt; &lt;/a&gt; . Лучшее решение - утверждать, что канал отправил нам ответ, прежде чем делать любое другое утверждение. Сначала измените канал для отправки ответов:</target>
        </trans-unit>
        <trans-unit id="bf259ab2dd0402461d9104f43dc12dcf9a9184fd" translate="yes" xml:space="preserve">
          <source>The key can be a string or an atom, where atoms are automatically converted to strings.</source>
          <target state="translated">Ключом может быть строка или атом,где атомы автоматически преобразуются в строки.</target>
        </trans-unit>
        <trans-unit id="f429352c0b3be43a54afc592d7a8110f87f053dd" translate="yes" xml:space="preserve">
          <source>The key can be a string or an atom, where atoms are automatically converted to strings. Can only be invoked on unsent &lt;code&gt;conn&lt;/code&gt;s. Will raise otherwise.</source>
          <target state="translated">Ключ может быть строкой или атомом, где атомы автоматически преобразуются в строки. Может быть вызван только при неотправленных &lt;code&gt;conn&lt;/code&gt; . В противном случае поднимет.</target>
        </trans-unit>
        <trans-unit id="b090269894ef022087b95988c4c1c9ea6c329869" translate="yes" xml:space="preserve">
          <source>The key is the media type, the value is a list of formats the media type can be identified with. For example, by using &quot;json-api&quot;, you will be able to use templates with extension &quot;index.json-api&quot; or to force a particular format in a given URL by sending &quot;?_format=json-api&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4edcd6a27ee607492b3ce414639ce14b3b1badad" translate="yes" xml:space="preserve">
          <source>The key is the media type, the value is a list of formats the media type can be identified with. For example, by using &amp;ldquo;json-api&amp;rdquo;, you will be able to use templates with extension &amp;ldquo;index.json-api&amp;rdquo; or to force a particular format in a given URL by sending &amp;ldquo;?_format=json-api&amp;rdquo;.</source>
          <target state="translated">Ключ - это тип носителя, значение - это список форматов, с которыми можно идентифицировать тип носителя. Например, используя &amp;laquo;json-api&amp;raquo;, вы сможете использовать шаблоны с расширением &amp;laquo;index.json-api&amp;raquo; или форсировать определенный формат в данном URL-адресе, отправив &amp;laquo;? _Format = json-api&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="dc9dd9b6fe649ecbe85232c591304bd2bcb8a124" translate="yes" xml:space="preserve">
          <source>The keys in the list are the names of fields, and the values are a validation associated with the field. A field may occur multiple times in the list.</source>
          <target state="translated">Ключами в списке являются названия полей,а значения-валидация,связанная с полем.Поле может встречаться в списке несколько раз.</target>
        </trans-unit>
        <trans-unit id="44118a922e99586055ff7e96b077e2626d08844b" translate="yes" xml:space="preserve">
          <source>The keys of the map will usually point to a resource ID. The value will contain a map with a &lt;code&gt;:metas&lt;/code&gt; key containing a list of metadata for each resource. Additionally, every metadata entry will contain a &lt;code&gt;:phx_ref&lt;/code&gt; key which can be used to uniquely identify metadata for a given key. In the event that the metadata was previously updated, a &lt;code&gt;:phx_ref_prev&lt;/code&gt; key will be present containing the previous &lt;code&gt;:phx_ref&lt;/code&gt; value.</source>
          <target state="translated">Ключи карты обычно указывают на идентификатор ресурса. Значение будет содержать карту с ключом &lt;code&gt;:metas&lt;/code&gt; , содержащую список метаданных для каждого ресурса. Кроме того, каждая запись метаданных будет содержать ключ &lt;code&gt;:phx_ref&lt;/code&gt; , который можно использовать для однозначной идентификации метаданных для данного ключа. В случае, если метаданные были ранее обновлены, будет присутствовать ключ &lt;code&gt;:phx_ref_prev&lt;/code&gt; , содержащий предыдущее значение &lt;code&gt;:phx_ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd07e57985bded643428c1ca83408a9f2015bf8e" translate="yes" xml:space="preserve">
          <source>The keyword options passed from the Schema's field macro into &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f06d5aeae7960e61046c9013e3025c273538aad" translate="yes" xml:space="preserve">
          <source>The keyword-based and pipe-based examples are equivalent. The downside of using macros is that the binding must be specified for every operation. However, since keyword-based and pipe-based examples are equivalent, the bindingless syntax also works for macros:</source>
          <target state="translated">Примеры,основанные на ключевых словах и трубах,эквивалентны.Недостатком использования макросов является то,что привязка должна быть указана для каждой операции.Однако,поскольку примеры,основанные на ключевых словах и каналах,эквивалентны,синтаксис без привязки также работает и для макросов:</target>
        </trans-unit>
        <trans-unit id="df5c4e04515501f7830b4c4bb804a178cc83618c" translate="yes" xml:space="preserve">
          <source>The last change is to open up &lt;code&gt;lib/hello_phoenix/repo.ex&lt;/code&gt; and make sure to set the &lt;code&gt;:adapter&lt;/code&gt; to &lt;code&gt;Ecto.Adapters.MyXQL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d08d545f1b896c36da46b4bc90528258f9af83a" translate="yes" xml:space="preserve">
          <source>The last input with focus is restored (unless another input has received focus)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0f79f452d7d90593329a433992b7a7e7313371" translate="yes" xml:space="preserve">
          <source>The latter could also be bound to any &lt;code&gt;click&lt;/code&gt; event, but this way you can be sure your custom code is only executed when the code of &lt;code&gt;phoenix_html.js&lt;/code&gt; is run.</source>
          <target state="translated">Последний также может быть привязан к любому событию &lt;code&gt;click&lt;/code&gt; , но таким образом вы можете быть уверены, что ваш собственный код будет выполняться только при &lt;code&gt;phoenix_html.js&lt;/code&gt; кода phoenix_html.js .</target>
        </trans-unit>
        <trans-unit id="94ea7e500eb238ec30986cee0999cc9f163d089b" translate="yes" xml:space="preserve">
          <source>The layout given to &lt;code&gt;put_root_layout&lt;/code&gt; must use &lt;code&gt;&amp;lt;%= @inner_content %&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;lt;%= render(@view_module, @view_template, assigns) %&amp;gt;&lt;/code&gt;. It is typically very barebones, with mostly &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tags. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6744e96e72ecda721afea0237536fd66db392297" translate="yes" xml:space="preserve">
          <source>The layout must be a tuple, specifying the layout view and the layout name, or false. In case a previous layout is set, &lt;code&gt;put_layout&lt;/code&gt; also accepts the layout name to be given as a string or as an atom. If a string, it must contain the format. Passing an atom means the layout format will be found at rendering time, similar to the template in &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt;. It can also be set to &lt;code&gt;false&lt;/code&gt;. In this case, no layout would be used.</source>
          <target state="translated">Макет должен быть кортежем с указанием вида макета и имени макета, или false. Если установлен предыдущий макет, &lt;code&gt;put_layout&lt;/code&gt; также принимает имя макета в виде строки или атома. Если строка, она должна содержать формат. Передача атома означает, что формат макета будет найден во время рендеринга, аналогично шаблону в &lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; &lt;/a&gt; . Также может быть установлено значение &lt;code&gt;false&lt;/code&gt; . В этом случае макет не будет использоваться.</target>
        </trans-unit>
        <trans-unit id="e7d67a564b0265425038298d81b7c53608deaa1e" translate="yes" xml:space="preserve">
          <source>The lib/hello directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d2fa78d75d59a854f8844b73dfc72a968b6f84" translate="yes" xml:space="preserve">
          <source>The lib/hello_web directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92154a1db347f64239f68f87cebd039161ceecac" translate="yes" xml:space="preserve">
          <source>The life-cycle of a LiveView as outlined in the &lt;a href=&quot;phoenix.liveview&quot;&gt;&lt;code&gt;Phoenix.LiveView&lt;/code&gt;&lt;/a&gt; docs details how a view starts as a stateless HTML render in a disconnected socket state. Once the browser receives the HTML, it connects to the server and a new LiveView process is started, remounted in a connected socket state, and the view continues statefully. The LiveView test functions support testing both disconnected and connected mounts separately, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477d068a247e238de404418e92a5a9b81e34e717" translate="yes" xml:space="preserve">
          <source>The list of dynamics is always a list of iodatas or components, as we don't perform change tracking inside the comprehensions themselves. Similarly, comprehensions do not have fingerprints because they are only optimized at the root, so conditional evaluation, as the one seen in rendering, is not possible. The only possible outcome for a dynamic field that returns a comprehension is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30777b456b3f6e3c3a181cabf70cf5ee328a6f81" translate="yes" xml:space="preserve">
          <source>The list of hostnames, if none are specified, defaults to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9089ed404a90b7ca8405732095979a8fb2093289" translate="yes" xml:space="preserve">
          <source>The list of supported values and their behaviour is described in &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt;. If the given value is not any of values listed there, it will raise.</source>
          <target state="translated">Список поддерживаемых значений и их поведение описаны в &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; . Если данное значение не является ни одним из перечисленных здесь значений, оно будет повышено.</target>
        </trans-unit>
        <trans-unit id="1bf6687a8673fe4a0d29060ff11510670a6cb046" translate="yes" xml:space="preserve">
          <source>The location of the web files (LiveView's, views, templates, etc) in an umbrella application will vary based on the &lt;code&gt;:context_app&lt;/code&gt; config located in your applications &lt;code&gt;:generators&lt;/code&gt; configuration. When set, the Phoenix generators will generate web files directly in your lib and test folders since the application is assumed to be isolated to web specific functionality. If &lt;code&gt;:context_app&lt;/code&gt; is not set, the generators will place web related lib and test files in a &lt;code&gt;web/&lt;/code&gt; directory since the application is assumed to be handling both web and domain specific functionality. Example configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba10fe778e8a0ac2bdeed5623f9f0c72f2e97b50" translate="yes" xml:space="preserve">
          <source>The location of the web files (controllers, views, templates, etc) in an umbrella application will vary based on the &lt;code&gt;:context_app&lt;/code&gt; config located in your applications &lt;code&gt;:generators&lt;/code&gt; configuration. When set, the Phoenix generators will generate web files directly in your lib and test folders since the application is assumed to be isolated to web specific functionality. If &lt;code&gt;:context_app&lt;/code&gt; is not set, the generators will place web related lib and test files in a &lt;code&gt;web/&lt;/code&gt; directory since the application is assumed to be handling both web and domain specific functionality. Example configuration:</source>
          <target state="translated">Расположение веб-файлов (контроллеров, представлений, шаблонов и т. Д.) В зонтичном приложении будет зависеть от конфигурации &lt;code&gt;:context_app&lt;/code&gt; , расположенной в ваших приложениях &lt;code&gt;:generators&lt;/code&gt; конфигурации генераторов . Если этот параметр установлен, генераторы Phoenix будут генерировать веб-файлы непосредственно в ваших папках lib и test, поскольку предполагается, что приложение изолировано для конкретных веб-функций. Если &lt;code&gt;:context_app&lt;/code&gt; не установлен, генераторы поместят связанные с Интернетом библиотеки и тестовые файлы в каталог &lt;code&gt;web/&lt;/code&gt; поскольку предполагается, что приложение обрабатывает как веб-функции, так и специфичные для домена. Пример конфигурации:</target>
        </trans-unit>
        <trans-unit id="9838c2015d6a31f43230056050bd48b08264c2d5" translate="yes" xml:space="preserve">
          <source>The log line for each request contains the specific route for that request. This is due to specifying the &lt;code&gt;:tags&lt;/code&gt; option for the summary metric, which takes care of our first requirement; we can use &lt;code&gt;:tags&lt;/code&gt; to group metrics by route. Note that reporters will necessarily handle tags differently depending on the underlying service in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5054ea19f1c0872ef56ffb5ac8d9cbaa2ee98017" translate="yes" xml:space="preserve">
          <source>The logger call won&amp;rsquo;t be removed at compile time as custom level is given.</source>
          <target state="translated">Вызов регистратора не будет удален во время компиляции, поскольку задан настраиваемый уровень.</target>
        </trans-unit>
        <trans-unit id="282bfec61ed3e63c6a621589fc9ff184bc2a5dc3" translate="yes" xml:space="preserve">
          <source>The long poll is configurable in your socket:</source>
          <target state="translated">Длинный опрос настраивается в вашем гнезде:</target>
        </trans-unit>
        <trans-unit id="df55f8f757b374fd6d2aa5a71db086c2cfcd7c1d" translate="yes" xml:space="preserve">
          <source>The main responsibility of a view is to render a template.</source>
          <target state="translated">Основной обязанностью мнения является представление шаблона.</target>
        </trans-unit>
        <trans-unit id="c3ad4277ebaf63c095045d7d65ae5d290329b067" translate="yes" xml:space="preserve">
          <source>The map type</source>
          <target state="translated">Тип карты</target>
        </trans-unit>
        <trans-unit id="fd10459a12af6703afd7079ef61598c3879b0473" translate="yes" xml:space="preserve">
          <source>The map type allows developers to store an Elixir map directly in the database:</source>
          <target state="translated">Тип карты позволяет разработчикам хранить карту Elixir непосредственно в базе данных:</target>
        </trans-unit>
        <trans-unit id="080be8664031b1a1bb94955949d3616301947b14" translate="yes" xml:space="preserve">
          <source>The mechanism for passing the token to the client is typically through a cookie, a JSON response body, or HTTP header. For now, assume the client has received a token it can use to validate requests for protected resources.</source>
          <target state="translated">Механизм передачи токена клиенту,как правило,осуществляется через куки,тело ответа JSON или HTTP-заголовок.На данный момент предположим,что клиент получил токен,который он может использовать для проверки запросов на защищенные ресурсы.</target>
        </trans-unit>
        <trans-unit id="eb58fc9777d3607a5fbb10fc1f79ea8d98ec0269" translate="yes" xml:space="preserve">
          <source>The message format requires the following keys:</source>
          <target state="translated">Формат сообщения требует использования следующих клавиш:</target>
        </trans-unit>
        <trans-unit id="52f5b43827ed9d61c35f578531a7d764f7e53199" translate="yes" xml:space="preserve">
          <source>The message is a term. It must return one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b210dad451da94f2501a9d8d7e918aa3958400" translate="yes" xml:space="preserve">
          <source>The message is represented as &lt;code&gt;{payload, options}&lt;/code&gt;. It must return one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8368bb195a36e75b24e3aa2abd88acdf1b5b819f" translate="yes" xml:space="preserve">
          <source>The metadata returned by the adapter &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Метаданные, возвращаемые адаптером &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b2acf0c1be2b4d18996e01c7970b3c30cc534ab" translate="yes" xml:space="preserve">
          <source>The metadata returned by the adapter &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Метаданные, возвращаемые адаптером &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70bfd62abd8739763f40ffef575496a5c549d630" translate="yes" xml:space="preserve">
          <source>The minimum value for &lt;code&gt;length&lt;/code&gt; is 32.</source>
          <target state="translated">Минимальное значение &lt;code&gt;length&lt;/code&gt; - 32.</target>
        </trans-unit>
        <trans-unit id="9634db4fa76e01e90a42b4c5e5f87e4ad4910fd5" translate="yes" xml:space="preserve">
          <source>The name of each operation does not have to be an atom. This can be particularly useful when you wish to update a collection of changesets at once, and track their errors individually:</source>
          <target state="translated">Название каждой операции не обязательно должно быть атомом.Это может быть особенно полезно,когда вы хотите обновлять коллекцию изменений сразу и отслеживать их ошибки по отдельности:</target>
        </trans-unit>
        <trans-unit id="0a3d293ea6bec7e5c5b00485c524e67b073803fb" translate="yes" xml:space="preserve">
          <source>The name used in assigns is determined from the view. For example the &lt;code&gt;PageView&lt;/code&gt; will use &lt;code&gt;%{page: page}&lt;/code&gt; and the &lt;code&gt;AuthorView&lt;/code&gt; will use &lt;code&gt;%{author: author}&lt;/code&gt;. This can be overridden with the &lt;code&gt;as&lt;/code&gt; option. Let's assume that the author view uses &lt;code&gt;%{writer: writer}&lt;/code&gt; instead of &lt;code&gt;%{author: author}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eacf623a28c1145f1b59317f4cbac89d904671a" translate="yes" xml:space="preserve">
          <source>The named helper can also be customized with the &lt;code&gt;:as&lt;/code&gt; option. Given the route:</source>
          <target state="translated">Именованный помощник также можно настроить с помощью параметра &lt;code&gt;:as&lt;/code&gt; . Учитывая маршрут:</target>
        </trans-unit>
        <trans-unit id="ee9f556bb40887ceb71d128fe3a1686d36cd09f5" translate="yes" xml:space="preserve">
          <source>The only argument is the module name of the Presence tracker, which defaults to Presence.</source>
          <target state="translated">Единственным аргументом является имя модуля трекера Присутствия,который по умолчанию равен Присутствию.</target>
        </trans-unit>
        <trans-unit id="dd6daf265bd0ac4e906fd4bdd897c5919c6282da" translate="yes" xml:space="preserve">
          <source>The only downside is that it will show up as a fragment when inspecting the Elixir query. Other than that, it should be equivalent to a built-in Ecto query function.</source>
          <target state="translated">Единственным недостатком является то,что при проверке запроса Elixir он будет отображаться как фрагмент.Кроме того,он должен быть эквивалентен встроенной функции запроса Ecto.</target>
        </trans-unit>
        <trans-unit id="4f0266dcf90fe67afe6ef36bb73cebc07fd00eac" translate="yes" xml:space="preserve">
          <source>The options are passed to both &lt;code&gt;:http&lt;/code&gt; and &lt;code&gt;:https&lt;/code&gt; keys in the endpoint configuration. However, once you pass your custom dispatch options, you will need to manually wire all Phoenix endpoints, including the socket transports.</source>
          <target state="translated">Параметры передаются в оба ключа &lt;code&gt;:http&lt;/code&gt; и &lt;code&gt;:https&lt;/code&gt; в конфигурации конечной точки. Однако после того, как вы передадите свои пользовательские параметры отправки, вам нужно будет вручную подключить все конечные точки Phoenix, включая транспорты сокетов.</target>
        </trans-unit>
        <trans-unit id="81006dc93621cf7c03e17d32fa7ba38ff44285bc" translate="yes" xml:space="preserve">
          <source>The options are passed to both &lt;code&gt;:http&lt;/code&gt; and &lt;code&gt;:https&lt;/code&gt; keys in the endpoint configuration. However, once you pass your custom dispatch options, you will need to manually wire the Phoenix endpoint by adding the following rule:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34a63fc2945e1d41d9507823f6312b0d54d5e85" translate="yes" xml:space="preserve">
          <source>The options are the same options given to &lt;code&gt;form_for/4&lt;/code&gt;. It can be used by implementations to configure their behaviour and it must be stored in the underlying struct, with any custom field removed.</source>
          <target state="translated">Это те же параметры, что и &lt;code&gt;form_for/4&lt;/code&gt; . Он может использоваться реализациями для настройки своего поведения, и он должен храниться в базовой структуре с удалением всех настраиваемых полей.</target>
        </trans-unit>
        <trans-unit id="e94a4b1ffacdefb101fda0c3d483575fb46108fe" translate="yes" xml:space="preserve">
          <source>The options are the same options given to &lt;code&gt;inputs_for/4&lt;/code&gt;. It can be used by implementations to configure their behaviour and it must be stored in the underlying struct, with any custom field removed.</source>
          <target state="translated">Это те же параметры, что и для &lt;code&gt;inputs_for/4&lt;/code&gt; . Он может использоваться реализациями для настройки своего поведения, и он должен храниться в базовой структуре с удалением всех настраиваемых полей.</target>
        </trans-unit>
        <trans-unit id="cbbc72dee649cfd3da9099e3aaa4dd8de76df598" translate="yes" xml:space="preserve">
          <source>The options returned from this function will be given to &lt;a href=&quot;#get/3&quot;&gt;&lt;code&gt;get/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#put/4&quot;&gt;&lt;code&gt;put/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#delete/3&quot;&gt;&lt;code&gt;delete/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Параметры, возвращаемые этой функцией, будут даны для &lt;a href=&quot;#get/3&quot;&gt; &lt;code&gt;get/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#put/4&quot;&gt; &lt;code&gt;put/4&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#delete/3&quot;&gt; &lt;code&gt;delete/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d384613558e77407526f0c5fbfadcc4a059844a9" translate="yes" xml:space="preserve">
          <source>The options returned from this function will be given to &lt;code&gt;get/3&lt;/code&gt;, &lt;code&gt;put/4&lt;/code&gt; and &lt;code&gt;delete/3&lt;/code&gt;.</source>
          <target state="translated">Параметры, возвращаемые этой функцией, будут даны для &lt;code&gt;get/3&lt;/code&gt; , &lt;code&gt;put/4&lt;/code&gt; и &lt;code&gt;delete/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f06bf866fed12855453f8d5f135a5f4e72431100" translate="yes" xml:space="preserve">
          <source>The other fields are merged with the following criteria:</source>
          <target state="translated">Остальные поля объединены со следующими критериями:</target>
        </trans-unit>
        <trans-unit id="3462b00b6bda12e1014b4b6dc443fa44ae87853c" translate="yes" xml:space="preserve">
          <source>The other validators simply take a value:</source>
          <target state="translated">Остальные валидаторы просто принимают значение:</target>
        </trans-unit>
        <trans-unit id="161c387bc2cd3fea40fa9d1d48103ca6f80cdb4b" translate="yes" xml:space="preserve">
          <source>The output folder will contain:</source>
          <target state="translated">Выходная папка будет содержаться:</target>
        </trans-unit>
        <trans-unit id="9dc286e9190cffa49c47ed0399b1d38337f37d16" translate="yes" xml:space="preserve">
          <source>The package does not perform any aggregation of the measurements itself. Instead, it provides a reporter with the Telemetry event-as-measurement definition and the reporter uses that definition to perform aggregations and report them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd020c2783347fc6755fe582b2d5c9e69b5635df" translate="yes" xml:space="preserve">
          <source>The page we are going to build will simply say &quot;Hello World, from Phoenix!&quot; when we point our browser to &lt;a href=&quot;http://localhost:4000/hello&quot;&gt;http://localhost:4000/hello&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7216cd22ee3c8f81da71805d223b6947bf81bf" translate="yes" xml:space="preserve">
          <source>The parameters for the ParameterizedType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4662009e29483d0cc5077d2eabc424cdf07a6d6" translate="yes" xml:space="preserve">
          <source>The parameters for the given association will be retrieved from &lt;code&gt;changeset.params&lt;/code&gt;. Those parameters are expected to be a map with attributes, similar to the ones passed to &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt;. Once parameters are retrieved, &lt;a href=&quot;#cast_assoc/3&quot;&gt;&lt;code&gt;cast_assoc/3&lt;/code&gt;&lt;/a&gt; will match those parameters with the associations already in the changeset record.</source>
          <target state="translated">Параметры для данной ассоциации будут извлечены из &lt;code&gt;changeset.params&lt;/code&gt; . Ожидается, что эти параметры будут картой с атрибутами, аналогичными тем, которые передаются в &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; . После получения параметров &lt;a href=&quot;#cast_assoc/3&quot;&gt; &lt;code&gt;cast_assoc/3&lt;/code&gt; &lt;/a&gt; сопоставит эти параметры с ассоциациями, уже имеющимися в записи набора изменений.</target>
        </trans-unit>
        <trans-unit id="f162dc3980f9534481973a5e2f3a8df458b6c531" translate="yes" xml:space="preserve">
          <source>The parameters for the given embed will be retrieved from &lt;code&gt;changeset.params&lt;/code&gt;. Those parameters are expected to be a map with attributes, similar to the ones passed to &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt;. Once parameters are retrieved, &lt;a href=&quot;#cast_embed/3&quot;&gt;&lt;code&gt;cast_embed/3&lt;/code&gt;&lt;/a&gt; will match those parameters with the embeds already in the changeset record. See &lt;a href=&quot;#cast_assoc/3&quot;&gt;&lt;code&gt;cast_assoc/3&lt;/code&gt;&lt;/a&gt; for an example of working with casts and associations which would also apply for embeds.</source>
          <target state="translated">Параметры для данной вставки будут получены из &lt;code&gt;changeset.params&lt;/code&gt; . Ожидается, что эти параметры будут картой с атрибутами, аналогичными тем, которые передаются в &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; . После получения параметров &lt;a href=&quot;#cast_embed/3&quot;&gt; &lt;code&gt;cast_embed/3&lt;/code&gt; &lt;/a&gt; сопоставит эти параметры с встраиваемыми версиями, уже присутствующими в записи набора изменений. См. &lt;a href=&quot;#cast_assoc/3&quot;&gt; &lt;code&gt;cast_assoc/3&lt;/code&gt; &lt;/a&gt; для примера работы с приведениями и ассоциациями, которые также применимы для встраивания.</target>
        </trans-unit>
        <trans-unit id="6ccf766b41fe567d6380527225e5d0d0c1950285" translate="yes" xml:space="preserve">
          <source>The path helpers now return what we want them to as well. Run &lt;code&gt;iex -S mix&lt;/code&gt; and give it a try yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d9d95ae05eb4ab7374f78f148d8ced664f6b15" translate="yes" xml:space="preserve">
          <source>The path will be retrieved from the currently requested path via &lt;a href=&quot;#current_path/1&quot;&gt;&lt;code&gt;current_path/1&lt;/code&gt;&lt;/a&gt;. The scheme, host and others will be received from the URL configuration in your Phoenix endpoint. The reason we don't use the host and scheme information in the request is because most applications are behind proxies and the host and scheme may not actually reflect the host and scheme accessed by the client. If you want to access the url precisely as requested by the client, see &lt;a href=&quot;../plug/plug.conn#request_url/1&quot;&gt;&lt;code&gt;Plug.Conn.request_url/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51d7ff1518f2fc26effb50af9e146b994aed2db" translate="yes" xml:space="preserve">
          <source>The paths to the user facing reviews would look like a standard resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8461b08dd0b39472d6e7cab05d0df7c89d7a56a5" translate="yes" xml:space="preserve">
          <source>The plug specification.</source>
          <target state="translated">Спецификация штекера.</target>
        </trans-unit>
        <trans-unit id="43d162b21236b659adf8d5bf3af141f3266eea3d" translate="yes" xml:space="preserve">
          <source>The preferred form is to use &lt;code&gt;:from&lt;/code&gt; with an atom or tuple, since it will make your application independent from the starting directory. For example, if you pass:</source>
          <target state="translated">Предпочтительно использовать форму &lt;code&gt;:from&lt;/code&gt; с атомом или кортежем, поскольку это сделает ваше приложение независимым от начального каталога. Например, если вы прошли:</target>
        </trans-unit>
        <trans-unit id="50998ebe5bad0757359a407f8ec8b122a3958b71" translate="yes" xml:space="preserve">
          <source>The prefixes set in the query will be preserved when loading data.</source>
          <target state="translated">Префиксы,заданные в запросе,будут сохранены при загрузке данных.</target>
        </trans-unit>
        <trans-unit id="867bac9d8d8d9b0a2e78aebeddd2b3b36f5a8853" translate="yes" xml:space="preserve">
          <source>The prerequisites for running an HTTPS server with Plug include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1526ebdce848190098bcbfdfb625b2e2ecb877e8" translate="yes" xml:space="preserve">
          <source>The presence information is returned as a map with presences grouped by key, cast as a string, and accumulated metadata, with the following form:</source>
          <target state="translated">Информация о присутствии возвращается в виде карты с присутствием,сгруппированной по ключам,приведенной в виде строки,и накопленными метаданными,со следующей формой:</target>
        </trans-unit>
        <trans-unit id="8e1834c7ca0296001b89ac9864e746de523a9361" translate="yes" xml:space="preserve">
          <source>The primary key will be automatically included in &lt;code&gt;returning&lt;/code&gt; if the field has type &lt;code&gt;:id&lt;/code&gt; or &lt;code&gt;:binary_id&lt;/code&gt; and no value was set by the developer or none was autogenerated by the adapter.</source>
          <target state="translated">Первичный ключ будет автоматически включен в &lt;code&gt;returning&lt;/code&gt; если поле имеет тип &lt;code&gt;:id&lt;/code&gt; или &lt;code&gt;:binary_id&lt;/code&gt; и разработчик не установил никакого значения или ничего не было автоматически создано адаптером.</target>
        </trans-unit>
        <trans-unit id="f2afcc11c269b0c54b1b7ac0efcd7b569f223f2f" translate="yes" xml:space="preserve">
          <source>The primitive types are:</source>
          <target state="translated">Примитивные типы:</target>
        </trans-unit>
        <trans-unit id="5475cd442271dc875207326bb4064eeb96befb25" translate="yes" xml:space="preserve">
          <source>The problem with this approach is that it breaks references in the database. You can&amp;rsquo;t use foreign keys and it is very inefficient, both in terms of query time and storage.</source>
          <target state="translated">Проблема с этим подходом в том, что он разбивает ссылки в базе данных. Вы не можете использовать внешние ключи, и это очень неэффективно как с точки зрения времени запроса, так и с точки зрения хранения.</target>
        </trans-unit>
        <trans-unit id="7a3a4c7f6a78c9326c8ef25ce0f6c69a3f78f0d2" translate="yes" xml:space="preserve">
          <source>The problem with this approach is that it breaks references in the database. You can't use foreign keys and it is very inefficient, both in terms of query time and storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d89d344e6a03d17bab84b370769a6045fb37ec3" translate="yes" xml:space="preserve">
          <source>The public fields are:</source>
          <target state="translated">Общественные поля:</target>
        </trans-unit>
        <trans-unit id="df908dd7366c676a05daf0e41f416b8dbf39971e" translate="yes" xml:space="preserve">
          <source>The query above will select all posts with category &quot;fresh and new&quot;, order by the most recently published, and return Post structs with only the id, title and body fields set. It is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff2eebe90fad772cf88b9e84a74f0fcaf7b64c1" translate="yes" xml:space="preserve">
          <source>The query above will select all posts with category &amp;ldquo;fresh and new&amp;rdquo;, order by the most recently published, and return Post structs with only the id, title and body fields set. It is equivalent to:</source>
          <target state="translated">Вышеупомянутый запрос выберет все сообщения с категорией &amp;laquo;свежие и новые&amp;raquo;, упорядочит их по последним опубликованным и вернет структуры сообщений только с установленными полями id, title и body. Это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="95ca27e8b5eba197d23e18f17cf9ec5d46b73887" translate="yes" xml:space="preserve">
          <source>The query can be also rewritten as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0868e0ab6d1da07933f0f38d5ca3b2c0b98ed62" translate="yes" xml:space="preserve">
          <source>The query given to preload may also preload its own associations.</source>
          <target state="translated">Запрос,заданный на предварительную загрузку,может также предзагружать свои собственные ассоциации.</target>
        </trans-unit>
        <trans-unit id="5f6733486c5b72fc457e7eabc6d95cf5b2c0075a" translate="yes" xml:space="preserve">
          <source>The query ordering will be automatically reversed, with ASC columns becoming DESC columns (and vice-versa) and limit is set to 1. If there is no ordering, the query will be automatically ordered decreasingly by primary key.</source>
          <target state="translated">Порядок запроса будет автоматически изменен на обратный,столбцы ASC станут столбцами DESC (и наоборот),а ограничение установлено на 1.Если нет порядка,то запрос будет автоматически упорядочен в порядке уменьшения по первичному ключу.</target>
        </trans-unit>
        <trans-unit id="0bac158f3c93347932c98c42dee10fb98d800771" translate="yes" xml:space="preserve">
          <source>The query prefix may be set either for the whole query or on each individual &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; expression. If a &lt;code&gt;prefix&lt;/code&gt; is not given to a &lt;code&gt;from&lt;/code&gt; or a &lt;code&gt;join&lt;/code&gt;, the prefix of the schema given to the &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;join&lt;/code&gt; is used. The query prefix is used only if none of the above are declared.</source>
          <target state="translated">Префикс запроса может быть установлен либо для всего запроса, либо для каждого отдельного выражения &lt;code&gt;from&lt;/code&gt; и &lt;code&gt;join&lt;/code&gt; . Если &lt;code&gt;prefix&lt;/code&gt; не задан для &lt;code&gt;from&lt;/code&gt; или &lt;code&gt;join&lt;/code&gt; , используется префикс схемы, заданный для &lt;code&gt;from&lt;/code&gt; или &lt;code&gt;join&lt;/code&gt; . Префикс запроса используется только в том случае, если ничего из вышеперечисленного не объявлено.</target>
        </trans-unit>
        <trans-unit id="bbd403c978b262ae86cb591bfb4e43647aaa3204" translate="yes" xml:space="preserve">
          <source>The query will be automatically ordered by the primary key unless &lt;code&gt;order_by&lt;/code&gt; is given or &lt;code&gt;order_by&lt;/code&gt; is set in the query. Limit is always set to 1.</source>
          <target state="translated">Запрос будет автоматически отсортированы по первичному ключу , если &lt;code&gt;order_by&lt;/code&gt; не задан или &lt;code&gt;order_by&lt;/code&gt; устанавливается в запросе. Предел всегда установлен на 1.</target>
        </trans-unit>
        <trans-unit id="7f356a4a7c8aa772e039cd5fb20e41a523131c1b" translate="yes" xml:space="preserve">
          <source>The race conditions would make this an unreliable way to update the existing table since multiple callers may be updating out of date view values. There's a better way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae279db8cc5013382df2f8f7a465a8ec13291a8" translate="yes" xml:space="preserve">
          <source>The reason we can use &lt;code&gt;Routes.page_path&lt;/code&gt; instead of the full &lt;code&gt;HelloWeb.Router.Helpers.page_path&lt;/code&gt; name is because &lt;code&gt;HelloWeb.Router.Helpers&lt;/code&gt; is aliased as &lt;code&gt;Routes&lt;/code&gt; by default in the &lt;code&gt;view/0&lt;/code&gt; block defined inside &lt;code&gt;lib/hello_web.ex&lt;/code&gt;. This definition is made available to our templates through &lt;code&gt;use HelloWeb, :view&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cfdedb0bfaec211bb278c06c452d42b9de504d0" translate="yes" xml:space="preserve">
          <source>The reason why the example above is wrong is because &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; always works with the &lt;strong&gt;full data&lt;/strong&gt;. So the example above will effectively &lt;strong&gt;erase all previous comments&lt;/strong&gt; and only keep the comment you are currently adding. Instead, you could try:</source>
          <target state="translated">Причина, по которой приведенный выше пример неверен, заключается в том, что &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; всегда работает с &lt;strong&gt;полными данными&lt;/strong&gt; . Таким образом, приведенный выше пример эффективно &lt;strong&gt;удалит все предыдущие комментарии&lt;/strong&gt; и сохранит только тот комментарий, который вы добавляете в данный момент. Вместо этого вы можете попробовать:</target>
        </trans-unit>
        <trans-unit id="87305add73fb47f8d721c5faef9fcb8523b1a68e" translate="yes" xml:space="preserve">
          <source>The remaining functions in this module, such as validations, constraints, association handling, are about manipulating changesets. Let&amp;rsquo;s discuss some of this extra functionality.</source>
          <target state="translated">Остальные функции в этом модуле, такие как проверки, ограничения, обработка ассоциаций, предназначены для управления наборами изменений. Давайте обсудим некоторые из этих дополнительных функций.</target>
        </trans-unit>
        <trans-unit id="2a63cf0d6104e4fb432f90b5c23167e7813b2aa2" translate="yes" xml:space="preserve">
          <source>The remaining functions in this module, such as validations, constraints, association handling, are about manipulating changesets. Let's discuss some of this extra functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0133540c725182eeb9cebba83044fb36adb332" translate="yes" xml:space="preserve">
          <source>The repositories to create are the ones specified under the &lt;code&gt;:ecto_repos&lt;/code&gt; option in the current app configuration. However, if the &lt;code&gt;-r&lt;/code&gt; option is given, it replaces the &lt;code&gt;:ecto_repos&lt;/code&gt; config.</source>
          <target state="translated">Репозитории, которые нужно создать, указаны в параметре &lt;code&gt;:ecto_repos&lt;/code&gt; в текущей конфигурации приложения. Однако, если задана опция &lt;code&gt;-r&lt;/code&gt; , она заменяет конфигурацию &lt;code&gt;:ecto_repos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40dd881afbf4316e3498baa3ef462026d3e04aaa" translate="yes" xml:space="preserve">
          <source>The repositories to drop are the ones specified under the &lt;code&gt;:ecto_repos&lt;/code&gt; option in the current app configuration. However, if the &lt;code&gt;-r&lt;/code&gt; option is given, it replaces the &lt;code&gt;:ecto_repos&lt;/code&gt; config.</source>
          <target state="translated">&lt;code&gt;:ecto_repos&lt;/code&gt; репозитории - это те, которые указаны в параметре : ecto_repos в текущей конфигурации приложения. Однако, если задана опция &lt;code&gt;-r&lt;/code&gt; , она заменяет конфигурацию &lt;code&gt;:ecto_repos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01f05ddc7ae85e61bdf357b4f9fe87ebe2fb186e" translate="yes" xml:space="preserve">
          <source>The repository will be placed in the &lt;code&gt;lib&lt;/code&gt; directory.</source>
          <target state="translated">Репозиторий будет помещен в каталог &lt;code&gt;lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fed09d1158b42d77503d7a48e9346028a907f505" translate="yes" xml:space="preserve">
          <source>The request &lt;code&gt;method&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; are required arguments. &lt;code&gt;method&lt;/code&gt; may be any value that implements &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; and it will properly converted and normalized (e.g., &lt;code&gt;:get&lt;/code&gt; or &lt;code&gt;&quot;post&quot;&lt;/code&gt;).</source>
          <target state="translated">Запрос &lt;code&gt;method&lt;/code&gt; и &lt;code&gt;path&lt;/code&gt; требуются аргументы. &lt;code&gt;method&lt;/code&gt; может быть любым значением, реализующим &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; ,&lt;/a&gt; и он будет правильно преобразован и нормализован (например ,: &lt;code&gt;:get&lt;/code&gt; или &lt;code&gt;&quot;post&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6553aee7958eb204e762483dc8ab5a0161d11fe" translate="yes" xml:space="preserve">
          <source>The request id is added to the Logger metadata as &lt;code&gt;:request_id&lt;/code&gt; and the response as the &quot;x-request-id&quot; HTTP header. To see the request id in your log output, configure your logger backends to include the &lt;code&gt;:request_id&lt;/code&gt; metadata:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5f074e9b5c412ad29dd19562310620770be9f5" translate="yes" xml:space="preserve">
          <source>The request id is added to the Logger metadata as &lt;code&gt;:request_id&lt;/code&gt; and the response as the &amp;ldquo;x-request-id&amp;rdquo; HTTP header. To see the request id in your log output, configure your logger backends to include the &lt;code&gt;:request_id&lt;/code&gt; metadata:</source>
          <target state="translated">Идентификатор запроса добавляется в метаданные регистратора как &lt;code&gt;:request_id&lt;/code&gt; а ответ - как HTTP-заголовок &amp;laquo;x-request-id&amp;raquo;. Чтобы увидеть идентификатор запроса в выходных данных журнала, настройте серверные части вашего регистратора, включив в него метаданные: &lt;code&gt;:request_id&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bb1a8693dbf7be806d104c7fe770e40145397d5f" translate="yes" xml:space="preserve">
          <source>The request information in these fields is not populated until it is fetched using the associated &lt;code&gt;fetch_&lt;/code&gt; function. For example, the &lt;code&gt;cookies&lt;/code&gt; field uses &lt;a href=&quot;#fetch_cookies/2&quot;&gt;&lt;code&gt;fetch_cookies/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Информация о запросе в этих полях не заполняется до тех пор, пока она не будет &lt;code&gt;fetch_&lt;/code&gt; с помощью связанной функции fetch_ . Например, в поле &lt;code&gt;cookies&lt;/code&gt; используется &lt;a href=&quot;#fetch_cookies/2&quot;&gt; &lt;code&gt;fetch_cookies/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42d5b6701eebdfc545f5a296c3ed4d4a66bb5d50" translate="yes" xml:space="preserve">
          <source>The request will not be processed due to a client error.</source>
          <target state="translated">Запрос не будет обработан из-за ошибки клиента.</target>
        </trans-unit>
        <trans-unit id="4ca366dc222472a65071107117c79a6d7bda94b4" translate="yes" xml:space="preserve">
          <source>The resource fields are given using &lt;code&gt;name:type&lt;/code&gt; syntax where type are the types supported by Ecto. Omitting the type makes it default to &lt;code&gt;:string&lt;/code&gt;:</source>
          <target state="translated">Поля ресурсов задаются с использованием синтаксиса &lt;code&gt;name:type&lt;/code&gt; , где type - это типы, поддерживаемые Ecto. Если тип не указан, по умолчанию используется &lt;code&gt;:string&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1097b0ddcaad963de9fecf51f90f2b6fa20570d6" translate="yes" xml:space="preserve">
          <source>The response will be sent with the status code defined within the connection, via &lt;a href=&quot;../plug/plug.conn#put_status/2&quot;&gt;&lt;code&gt;Plug.Conn.put_status/2&lt;/code&gt;&lt;/a&gt;. If no status code is set, a 302 response is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde9dc4c4422fde222d1887d84b0d0b8e0065c5e" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;init/1&lt;/code&gt; is passed as second argument to &lt;code&gt;call/2&lt;/code&gt;. Note that &lt;code&gt;init/1&lt;/code&gt; may be called during compilation and as such it must not return pids, ports or values that are not specific to the runtime.</source>
          <target state="translated">Результат, возвращаемый &lt;code&gt;init/1&lt;/code&gt; , передается в качестве второго аргумента &lt;code&gt;call/2&lt;/code&gt; . Обратите внимание, что &lt;code&gt;init/1&lt;/code&gt; может быть вызван во время компиляции, и поэтому он не должен возвращать pid, порты или значения, не относящиеся к среде выполнения.</target>
        </trans-unit>
        <trans-unit id="c468a501cc213c281f4ebc6e80d77300fb92019e" translate="yes" xml:space="preserve">
          <source>The return value of each &amp;ldquo;before&amp;rdquo; event callback will be stored and passed to the corresponding &amp;ldquo;after&amp;rdquo; callback.</source>
          <target state="translated">Возвращаемое значение каждого обратного вызова события &amp;laquo;до&amp;raquo; будет сохранено и передано соответствующему обратному вызову &amp;laquo;после&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="bdebdedcaeb020e5415f8353d03e0b77bd7af755" translate="yes" xml:space="preserve">
          <source>The returned result is given to &lt;code&gt;execute/6&lt;/code&gt;.</source>
          <target state="translated">Возвращенный результат передается на &lt;code&gt;execute/6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa37f4a12198ad1c63cc6b2c6592271817c66fee" translate="yes" xml:space="preserve">
          <source>The right side may either be a list, a literal list or even a column in the database with array type:</source>
          <target state="translated">Правая сторона может быть либо списком,либо буквальным списком,либо даже столбцом в БД с типом массива:</target>
        </trans-unit>
        <trans-unit id="43a954d2682fa1c3ad1f60f5e9a5ca9d5b1fd15f" translate="yes" xml:space="preserve">
          <source>The route above tells us that any HTTP GET request for the root of the application will be handled by the &lt;code&gt;index&lt;/code&gt; action of the &lt;code&gt;HelloWeb.PageController&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152177e9ac83ea80f027842928a7dd7f74f8ab54" translate="yes" xml:space="preserve">
          <source>The route above will dispatch to &lt;code&gt;MyApp.PageController&lt;/code&gt;. This syntax is not only convenient for developers, since we don&amp;rsquo;t have to repeat the &lt;code&gt;MyApp.&lt;/code&gt; prefix on all routes, but it also allows Phoenix to put less pressure in the Elixir compiler. If instead we had written:</source>
          <target state="translated">Маршрут, указанный выше, будет отправлен в &lt;code&gt;MyApp.PageController&lt;/code&gt; . Этот синтаксис удобен не только для разработчиков, поскольку нам не нужно повторять &lt;code&gt;MyApp.&lt;/code&gt; префикс на всех маршрутах, но он также позволяет Phoenix меньше загружать компилятор Elixir. Если бы мы написали:</target>
        </trans-unit>
        <trans-unit id="65e16ececbb9266a02583f54b94cf09861ee56a7" translate="yes" xml:space="preserve">
          <source>The route above will dispatch to &lt;code&gt;MyAppWeb.PageController&lt;/code&gt;. This syntax is not only convenient for developers, since we don't have to repeat the &lt;code&gt;MyAppWeb.&lt;/code&gt; prefix on all routes, but it also allows Phoenix to put less pressure on the Elixir compiler. If instead we had written:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ffcfff6909dca94a4eae307d1f02ebefe5118b" translate="yes" xml:space="preserve">
          <source>The route can dispatch either to a function body or a Plug module.</source>
          <target state="translated">Маршрут может быть направлен либо в функциональное тело,либо в штекерный модуль.</target>
        </trans-unit>
        <trans-unit id="a585daba1ebd3d0d2a8f8b5826e4a49abe384c1d" translate="yes" xml:space="preserve">
          <source>The route for our &quot;Welcome to Phoenix!&quot; page from the previous Up And Running Guide looks like this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2939bacf3d39ca96536e1c8b322db4114aa2c1fe" translate="yes" xml:space="preserve">
          <source>The route:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92d4396a601bd78f5174bee334d0b156a731866" translate="yes" xml:space="preserve">
          <source>The router emits the following telemetry events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d645c8dddca0a4767932b2d077924d41ae564a8" translate="yes" xml:space="preserve">
          <source>The router file that Phoenix generates, &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;, will look something like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924f6def1ecc58fdee836524dd685a1ca8eb41c0" translate="yes" xml:space="preserve">
          <source>The router invokes a pipeline on a route defined within a scope. Routes outside of a scope have no pipelines. Although the use of nested scopes is discouraged (see above), if we call &lt;code&gt;pipe_through&lt;/code&gt; within a nested scope, the router will invoke all &lt;code&gt;pipe_through&lt;/code&gt;'s from parent scopes, followed by the nested one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e68c3ae1fbcab887151d89b16d2cba345f34fa8" translate="yes" xml:space="preserve">
          <source>The router is itself a plug, which means it can be invoked as:</source>
          <target state="translated">Маршрутизатор сам по себе является плагином,что означает,что он может быть вызван как:</target>
        </trans-unit>
        <trans-unit id="7cf405b6509f92f8990929f4ff6aee358761fa42" translate="yes" xml:space="preserve">
          <source>The router maps unique HTTP verb/path pairs to controller/action pairs which will handle them. Controllers in Phoenix are simply Elixir modules. Actions are functions that are defined within these controllers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54219a575937cd1ecc7766ae2a1627937d5863d" translate="yes" xml:space="preserve">
          <source>The router provides a set of macros for generating routes that dispatch to specific controllers and actions. Those macros are named after HTTP verbs. For example:</source>
          <target state="translated">Маршрутизатор предоставляет набор макросов для генерации маршрутов,которые отправляются на определенные контроллеры и действия.Эти макросы названы в честь HTTP-глаголов.Например:</target>
        </trans-unit>
        <trans-unit id="e873990af1b506d9425de23745c1354e6b8b3c7a" translate="yes" xml:space="preserve">
          <source>The router supports other macros besides those for HTTP verbs like &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, and &lt;code&gt;put&lt;/code&gt;. The most important among them is &lt;code&gt;resources&lt;/code&gt;. Let's add a resource to our &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; file like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49855ec648da9ffc07970ba4da5777bc9db4c4b3" translate="yes" xml:space="preserve">
          <source>The same event callback is called again, this time with the atom &lt;code&gt;:stop&lt;/code&gt; as the first argument; see the &amp;ldquo;After clause&amp;rdquo; section below.</source>
          <target state="translated">Тот же обратный вызов события вызывается снова, на этот раз с атомом &lt;code&gt;:stop&lt;/code&gt; в качестве первого аргумента; см. раздел &amp;laquo;После&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="65de666ef1e1e220f9c0d9372a51d104406e67a1" translate="yes" xml:space="preserve">
          <source>The schema also allows us to interact with a repository:</source>
          <target state="translated">Схема также позволяет нам взаимодействовать с репозиторием:</target>
        </trans-unit>
        <trans-unit id="dc68d1c060a62f551303cd6da271796006c2c527" translate="yes" xml:space="preserve">
          <source>The schema can be of any value. The path represents the database name while options are simply merged in.</source>
          <target state="translated">Схема может иметь любое значение.Путь представляет собой имя базы данных,в то время как опции просто объединяются.</target>
        </trans-unit>
        <trans-unit id="f4534f8ae409e6a396fbbf9dca42834fd3a4a272" translate="yes" xml:space="preserve">
          <source>The schema is responsible for mapping the database fields into an Elixir struct.</source>
          <target state="translated">Схема отвечает за отображение полей базы данных в структуру Elixir.</target>
        </trans-unit>
        <trans-unit id="f2c63087f504426ce8dc15eb5b941125dcbaa4ed" translate="yes" xml:space="preserve">
          <source>The schema is responsible for mapping the database fields into an Elixir struct. It is followed by an optional list of attributes, with their respective names and types. See &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt;&lt;code&gt;mix phx.gen.schema&lt;/code&gt;&lt;/a&gt; for more information on attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e857c9bd7068c28cafcac14000408ae312ea8b02" translate="yes" xml:space="preserve">
          <source>The schema module can be defined inline in the parent schema in simple cases:</source>
          <target state="translated">В простых случаях модуль схемы может быть определен встроенным в родительскую схему:</target>
        </trans-unit>
        <trans-unit id="35b62780b2378828f2f7ab21b8fde93c07ed6f06" translate="yes" xml:space="preserve">
          <source>The second and third argument that each event callback takes depends on the callback being an &amp;ldquo;after&amp;rdquo; or a &amp;ldquo;before&amp;rdquo; callback i.e. it depends on the value of the first argument, &lt;code&gt;:start&lt;/code&gt; or &lt;code&gt;:stop&lt;/code&gt;. For this reason, most of the time you will want to define (at least) two separate clauses for each event callback, one for the &amp;ldquo;before&amp;rdquo; and one for the &amp;ldquo;after&amp;rdquo; callbacks.</source>
          <target state="translated">Второй и третий аргумент, который принимает каждый обратный вызов события, зависит от того, является ли обратный вызов обратным вызовом &amp;laquo;после&amp;raquo; или &amp;laquo;до&amp;raquo;, т. Е. Зависит от значения первого аргумента &lt;code&gt;:start&lt;/code&gt; или &lt;code&gt;:stop&lt;/code&gt; . По этой причине в большинстве случаев вы захотите определить (как минимум) два отдельных предложения для каждого обратного вызова события, одно для обратных вызовов &amp;laquo;до&amp;raquo; и одно для обратных вызовов &amp;laquo;после&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8e57d6963dd7d705a901c4d4e7c1eb9745bf3c6f" translate="yes" xml:space="preserve">
          <source>The second argument &lt;code&gt;data&lt;/code&gt; specifies fields and values that are to be loaded. It can be a map, a keyword list, or a &lt;code&gt;{fields, values}&lt;/code&gt; tuple. Fields can be atoms or strings.</source>
          <target state="translated">Второй аргумент &lt;code&gt;data&lt;/code&gt; задает поля и значения, которые должны быть загружены. Это может быть карта, список ключевых слов или кортеж &lt;code&gt;{fields, values}&lt;/code&gt; . Поля могут быть атомами или строками.</target>
        </trans-unit>
        <trans-unit id="8bdda78bcfbc0f79c0c506943ef025fc56fbcad4" translate="yes" xml:space="preserve">
          <source>The second argument is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;cryptographic salt&lt;/a&gt; which must be the same in both calls to &lt;a href=&quot;#sign/4&quot;&gt;&lt;code&gt;sign/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt;. For instance, it may be called &quot;user auth&quot; and treated as namespace when generating a token that will be used to authenticate users on channels or on your APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbd999bbec42a3e7fb283772187deec6149dcdd" translate="yes" xml:space="preserve">
          <source>The second argument is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;cryptographic salt&lt;/a&gt; which must be the same in both calls to &lt;a href=&quot;#sign/4&quot;&gt;&lt;code&gt;sign/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt;. For instance, it may be called &amp;ldquo;user auth&amp;rdquo; when generating a token that will be used to authenticate users on channels or on your APIs.</source>
          <target state="translated">Второй аргумент - это &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;криптографическая соль,&lt;/a&gt; которая должна быть одинаковой в обоих вызовах &lt;a href=&quot;#sign/4&quot;&gt; &lt;code&gt;sign/4&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; . Например, его можно назвать &amp;laquo;аутентификацией пользователя&amp;raquo; при создании токена, который будет использоваться для аутентификации пользователей на каналах или в ваших API.</target>
        </trans-unit>
        <trans-unit id="0127918dc247714fd5e025d35570e68dd2593e39" translate="yes" xml:space="preserve">
          <source>The second argument is the repository configuration as stored in the application environment. It must return &lt;code&gt;{:ok, keyword}&lt;/code&gt; with the updated list of configuration or &lt;code&gt;:ignore&lt;/code&gt; (only in the &lt;code&gt;:supervisor&lt;/code&gt; case).</source>
          <target state="translated">Второй аргумент - это конфигурация репозитория, хранящаяся в среде приложения. Он должен возвращать &lt;code&gt;{:ok, keyword}&lt;/code&gt; с обновленным списком конфигурации или &lt;code&gt;:ignore&lt;/code&gt; (только в случае &lt;code&gt;:supervisor&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8ca2c1c0ef1b8f7a6c12e80c16925947b70511e2" translate="yes" xml:space="preserve">
          <source>The second argument must be &lt;code&gt;{:binary, contents}&lt;/code&gt;, where &lt;code&gt;contents&lt;/code&gt; will be sent as download, or&lt;code&gt;{:file, path}&lt;/code&gt;, where &lt;code&gt;path&lt;/code&gt; is the filesystem location of the file to be sent. Be careful to not interpolate the path from external parameters, as it could allow traversal of the filesystem.</source>
          <target state="translated">Второй аргумент должен быть &lt;code&gt;{:binary, contents}&lt;/code&gt; , где &lt;code&gt;contents&lt;/code&gt; будет отправлено как загрузка, или &lt;code&gt;{:file, path}&lt;/code&gt; , где &lt;code&gt;path&lt;/code&gt; - это расположение в файловой системе файла для отправки. Будьте осторожны, чтобы не интерполировать путь из внешних параметров, так как это может позволить обход файловой системы.</target>
        </trans-unit>
        <trans-unit id="4644893fe8ba1bf1c5d0e81a9d6a3f7226fe628b" translate="yes" xml:space="preserve">
          <source>The second parameter is &lt;code&gt;params&lt;/code&gt;. Not surprisingly, this is a map which holds any parameters passed along in the HTTP request. It is a good practice to pattern match against params in the function signature to provide data in a simple package we can pass on to rendering. We saw this in the &lt;a href=&quot;request_lifecycle&quot;&gt;Request life-cycle guide&lt;/a&gt; when we added a messenger parameter to our &lt;code&gt;show&lt;/code&gt; route in &lt;code&gt;lib/hello_web/controllers/hello_controller.ex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2d03f9984f042abc33381531414bedeec9588a" translate="yes" xml:space="preserve">
          <source>The serializer &lt;code&gt;decode!&lt;/code&gt; function must return a &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; which is forwarded to channels except:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d3f623b2642c248a3d2a66503afa329aff8fe9" translate="yes" xml:space="preserve">
          <source>The server may send messages or replies back. For messages, the ref uniquely identifies the message. For replies, the ref matches the original message. Both data-types also include a join_ref that uniquely identifies the currently joined channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25af858d19e12fa8099a294c660a40b18c7cf762" translate="yes" xml:space="preserve">
          <source>The server's &lt;code&gt;handle_event/3&lt;/code&gt; would receive a payload:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdb100e8fb22edffbda4a2f9c62ff5b45f532b5" translate="yes" xml:space="preserve">
          <source>The session contents, the final data to be stored after it has been built with &lt;a href=&quot;plug.conn#put_session/3&quot;&gt;&lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt;&lt;/a&gt; and the other session manipulating functions</source>
          <target state="translated">Содержимое сеанса, окончательные данные, которые будут сохранены после его &lt;a href=&quot;plug.conn#put_session/3&quot;&gt; &lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt; &lt;/a&gt; с помощью Plug.Conn.put_session / 3 и других функций управления сеансом</target>
        </trans-unit>
        <trans-unit id="8b95a016960327d8adfb4b2a4fa7945022268acb" translate="yes" xml:space="preserve">
          <source>The session contents, the final data to be stored after it has been built with &lt;a href=&quot;plug.conn#put_session/3&quot;&gt;&lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt;&lt;/a&gt; and the other session manipulating functions.</source>
          <target state="translated">Содержимое сеанса, окончательные данные, которые будут сохранены после его &lt;a href=&quot;plug.conn#put_session/3&quot;&gt; &lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt; &lt;/a&gt; с помощью Plug.Conn.put_session / 3 и других функций управления сеансом.</target>
        </trans-unit>
        <trans-unit id="a534b349ad0dd4485a26018b51cb99468bc99b42" translate="yes" xml:space="preserve">
          <source>The session id may be nil in case the cookie does not identify any value in the store. The session contents must be a map.</source>
          <target state="translated">Идентификатор сессии может быть нулевым,если куки-файл не идентифицирует какого-либо значения в магазине.Содержимое сессии должно быть картой.</target>
        </trans-unit>
        <trans-unit id="45b3c50494949266d4502d1426e160d856709a04" translate="yes" xml:space="preserve">
          <source>The session is accessed via functions on &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;. Cookies and session have to be fetched with &lt;a href=&quot;plug.conn#fetch_session/1&quot;&gt;&lt;code&gt;Plug.Conn.fetch_session/1&lt;/code&gt;&lt;/a&gt; before the session can be accessed.</source>
          <target state="translated">Доступ к сеансу осуществляется через функции &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; . Файлы cookie и сеанс должны быть &lt;a href=&quot;plug.conn#fetch_session/1&quot;&gt; &lt;code&gt;Plug.Conn.fetch_session/1&lt;/code&gt; &lt;/a&gt; с помощью Plug.Conn.fetch_session / 1 до того, как сеанс станет доступен.</target>
        </trans-unit>
        <trans-unit id="ea6faaf4abb4d9eac550e7cdd062da8586b666dd" translate="yes" xml:space="preserve">
          <source>The session is also lazy. Once configured, a cookie header with the session will only be sent to the client if something is written to the session in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba204c596e34571bf913673b8b59a88885aaca5" translate="yes" xml:space="preserve">
          <source>The signing and encryption keys are derived from the connection's &lt;code&gt;secret_key_base&lt;/code&gt; using a salt that is built by appending &quot;_cookie&quot; to the cookie name. Care should be taken not to derive other keys using this value as the salt. Similarly do not use the same cookie name to store different values with distinct purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43c5d3c5ff242e45bb3d214b290a81d5f13d3bc" translate="yes" xml:space="preserve">
          <source>The simplest component only needs to define a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ed9ada6a0b3a3bc428852c33a8785e0c5e5e57" translate="yes" xml:space="preserve">
          <source>The socket assigns are available directly inside the template as LiveEEx &lt;code&gt;assigns&lt;/code&gt;, such as &lt;code&gt;@foo&lt;/code&gt; and &lt;code&gt;@bar&lt;/code&gt;. Any assign access should be done using the assigns in the template where proper change tracking takes place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42889c924bd9345b669263e4a09c0e69b581550" translate="yes" xml:space="preserve">
          <source>The socket endpoint is read from the &lt;code&gt;@endpoint&lt;/code&gt; variable.</source>
          <target state="translated">Конечная точка сокета считывается из переменной &lt;code&gt;@endpoint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8353003894eb4918615880dd892b3fb26308d6c" translate="yes" xml:space="preserve">
          <source>The socket is then used to subscribe and join channels. Use this function when you want to create a blank socket to pass to functions like &lt;code&gt;UserSocket.connect/2&lt;/code&gt;.</source>
          <target state="translated">Затем сокет используется для подписки и присоединения к каналам. Используйте эту функцию, если вы хотите создать пустой сокет для передачи таким функциям, как &lt;code&gt;UserSocket.connect/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="741b1725667e8d637e90c04ad708be61a6c67966" translate="yes" xml:space="preserve">
          <source>The socket is then used to subscribe and join channels. Use this function when you want to create a blank socket to pass to functions like &lt;code&gt;UserSocket.connect/3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c75fa9c265b104aea9db5e1b8d2884d15b3c1c" translate="yes" xml:space="preserve">
          <source>The source for these guides is &lt;a href=&quot;https://github.com/phoenixframework/phoenix/tree/master/guides&quot;&gt;on GitHub&lt;/a&gt;. To help improve the guides, please report an &lt;a href=&quot;https://github.com/phoenixframework/phoenix/issues&quot;&gt;issue&lt;/a&gt; or open a &lt;a href=&quot;https://github.com/phoenixframework/phoenix/pulls&quot;&gt;pull request&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8020d63833291b1200da532130369857dd6057" translate="yes" xml:space="preserve">
          <source>The state of the schema is stored in the &lt;code&gt;:state&lt;/code&gt; field and allows following values:</source>
          <target state="translated">Состояние схемы хранится в поле &lt;code&gt;:state&lt;/code&gt; и допускает следующие значения:</target>
        </trans-unit>
        <trans-unit id="aa78ee5880f730e34341dec231106792a1c1612d" translate="yes" xml:space="preserve">
          <source>The status can be an integer, an atom, or &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Статус может быть целым числом, атомом или &lt;code&gt;nil&lt;/code&gt; . См. &lt;a href=&quot;plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="549a0fdbf17866c901bbe69f809cf1df06203fc0" translate="yes" xml:space="preserve">
          <source>The status code can be &lt;code&gt;nil&lt;/code&gt;, an integer or an atom. The list of allowed atoms is available in &lt;a href=&quot;plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Код состояния может быть &lt;code&gt;nil&lt;/code&gt; , целым или атомным. Список разрешенных атомов доступен в &lt;a href=&quot;plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3baf68608bb7edc0144295a9de68bd827a0c3d1c" translate="yes" xml:space="preserve">
          <source>The status code can be &lt;code&gt;nil&lt;/code&gt;, an integer, or an atom. The list of allowed atoms is available in &lt;a href=&quot;plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Код состояния может быть &lt;code&gt;nil&lt;/code&gt; , целым или атомным. Список разрешенных атомов доступен в &lt;a href=&quot;plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b85cd2f546627e7f8e771b8e4dacbd15919de6f" translate="yes" xml:space="preserve">
          <source>The status code we provide must be a valid number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d3fec1c36423b15af55e60202f9084e0860082" translate="yes" xml:space="preserve">
          <source>The struct for testing LiveViews.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b011117162e069e69fd96c3b54a5ab2de98fb369" translate="yes" xml:space="preserve">
          <source>The struct representing an internal unique reference to the component instance, available as the &lt;code&gt;@myself&lt;/code&gt; assign in stateful components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffbb97758f6664c833c9c9e920b7aabfee8a286" translate="yes" xml:space="preserve">
          <source>The struct returned by .leex templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db12a53ec7a2451062d21b0ec8554b50bad078d6" translate="yes" xml:space="preserve">
          <source>The struct returned by &lt;a href=&quot;phoenix.liveviewtest#element/3&quot;&gt;&lt;code&gt;Phoenix.LiveViewTest.element/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="336f100817cc09f943763c011543a225c024d68e" translate="yes" xml:space="preserve">
          <source>The struct returned by components in .leex templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96032e1804462a375e61aa3becfddf682507fdb" translate="yes" xml:space="preserve">
          <source>The struct returned by for-comprehensions in .leex templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e71fa009e7b2e244d8ad3544b3e79a8a9bae1d" translate="yes" xml:space="preserve">
          <source>The submitted form is reactivated and loses the &lt;code&gt;&quot;phx-submit-loading&quot;&lt;/code&gt; class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44eb57fe50cca343fe8e2ef06f2524d5aeefcf45" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;pass&lt;/code&gt; may be empty strings;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7700abeab24f899ce4198c80479749838f3339" translate="yes" xml:space="preserve">
          <source>The supported keys are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2280a174b18020a2620736642518bf66a11dab" translate="yes" xml:space="preserve">
          <source>The supported options are:</source>
          <target state="translated">Поддерживаются следующие варианты:</target>
        </trans-unit>
        <trans-unit id="9183fa9d80288d69edd242efa2830a2745f8ab1f" translate="yes" xml:space="preserve">
          <source>The supported values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f20fe2845d2b1bdb9951b6a8d84f277b6b5d78" translate="yes" xml:space="preserve">
          <source>The syntax above is equivalent to:</source>
          <target state="translated">Синтаксис выше эквивалентен:</target>
        </trans-unit>
        <trans-unit id="8a40be796b70fed45f015e64809fd60c04642951" translate="yes" xml:space="preserve">
          <source>The temporary directory where files are streamed to can be customized by setting the &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; environment variable on the host system. If &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; isn&amp;rsquo;t set, Plug will look at some environment variables which usually hold the value of the system&amp;rsquo;s temporary directory (like &lt;code&gt;TMPDIR&lt;/code&gt; or &lt;code&gt;TMP&lt;/code&gt;). If no value is found in any of those variables, &lt;code&gt;/tmp&lt;/code&gt; is used as a default.</source>
          <target state="translated">Временный каталог, в который передаются файлы, можно настроить, установив &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; среды PLUG_TMPDIR в хост-системе. Если &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; не установлен, Plug будет проверять некоторые переменные среды, которые обычно содержат значение временного каталога системы (например, &lt;code&gt;TMPDIR&lt;/code&gt; или &lt;code&gt;TMP&lt;/code&gt; ). Если значение не найдено ни в одной из этих переменных, по умолчанию используется &lt;code&gt;/tmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abfd2e746ee341013e4cdbafc97dfddc04d08e71" translate="yes" xml:space="preserve">
          <source>The temporary directory where files are streamed to can be customized by setting the &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; environment variable on the host system. If &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; isn't set, Plug will look at some environment variables which usually hold the value of the system's temporary directory (like &lt;code&gt;TMPDIR&lt;/code&gt; or &lt;code&gt;TMP&lt;/code&gt;). If no value is found in any of those variables, &lt;code&gt;/tmp&lt;/code&gt; is used as a default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6008af9872175b7be58ce5d3be6044dce8156ae7" translate="yes" xml:space="preserve">
          <source>The test process will not receive the published message. This triggers the &lt;code&gt;handle_out/3&lt;/code&gt; callback in the channel.</source>
          <target state="translated">В процессе тестирования опубликованное сообщение не будет получено. Это вызывает &lt;code&gt;handle_out/3&lt;/code&gt; вызов handle_out / 3 в канале.</target>
        </trans-unit>
        <trans-unit id="96e4f76aa06de2592f470fd3dea7b0c4ef31375c" translate="yes" xml:space="preserve">
          <source>The third and final option is to use &lt;a href=&quot;#many_to_many/3&quot;&gt;&lt;code&gt;many_to_many/3&lt;/code&gt;&lt;/a&gt; to define the relationships between the resources. In this case, the comments table won&amp;rsquo;t have the foreign key, instead there is a intermediary table responsible for associating the entries:</source>
          <target state="translated">Третий и последний вариант - использовать &lt;a href=&quot;#many_to_many/3&quot;&gt; &lt;code&gt;many_to_many/3&lt;/code&gt; &lt;/a&gt; для определения отношений между ресурсами. В этом случае таблица комментариев не будет иметь внешнего ключа, вместо этого будет промежуточная таблица, отвечающая за связывание записей:</target>
        </trans-unit>
        <trans-unit id="8de91f694a160eac98f8736952f2a3f88136e353" translate="yes" xml:space="preserve">
          <source>The third and final option is to use &lt;a href=&quot;#many_to_many/3&quot;&gt;&lt;code&gt;many_to_many/3&lt;/code&gt;&lt;/a&gt; to define the relationships between the resources. In this case, the comments table won't have the foreign key, instead there is an intermediary table responsible for associating the entries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9b72d684ded4fbc52b2db0fd313e2feea35d4f" translate="yes" xml:space="preserve">
          <source>The third argument &lt;code&gt;format&lt;/code&gt; is the format the data has been dumped as. For example, databases may dump embedded to &lt;code&gt;:json&lt;/code&gt;, this function allows such dumped data to be put back into the schemas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22dfe15ea505dc65004d52b00565b0529f3c5106" translate="yes" xml:space="preserve">
          <source>The third argument can be any term (string, int, list, etc.) that you wish to codify into the token. Upon valid verification, this same term will be extracted from the token.</source>
          <target state="translated">Третьим аргументом может быть любой термин (строка,int,список и т.д.),который вы хотите кодифицировать в токен.При корректной проверке этот же термин будет извлечен из токена.</target>
        </trans-unit>
        <trans-unit id="a1c2052b68df8425edb8d31ef1ad3c1921b372fa" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to 100ms.</source>
          <target state="translated">Тайм-аут составляет миллисекунды,а по умолчанию-100 мс.</target>
        </trans-unit>
        <trans-unit id="ecb554852eb06b5cfc5cc2ec1aa86dbe934028bb" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to 100ms. Keep in mind this macro will block the test by the timeout value, so use it only when necessary as overuse will certainly slow down your test suite.</source>
          <target state="translated">Тайм-аут составляет миллисекунды,а по умолчанию-100 мс.Имейте в виду,что этот макрос заблокирует тест на величину таймаута,поэтому используйте его только при необходимости,так как чрезмерное использование,безусловно,замедлит работу вашего тестового набора.</target>
        </trans-unit>
        <trans-unit id="1304926df4500481102d8f6f3aa1797e91270270" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to the &lt;code&gt;:assert_receive_timeout&lt;/code&gt; set on the &lt;code&gt;:ex_unit&lt;/code&gt; application (which defaults to 100ms).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a222ff7aa627d2ff58408f68862da0a0c1ac3d" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to the &lt;code&gt;:refute_receive_timeout&lt;/code&gt; set on the &lt;code&gt;:ex_unit&lt;/code&gt; application (which defaults to 100ms). Keep in mind this macro will block the test by the timeout value, so use it only when necessary as overuse will certainly slow down your test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4fff6f531f38d34226e8259653e269c039cae2" translate="yes" xml:space="preserve">
          <source>The timestamp is updated whenever there is a read or write to the table and it may be used to detect if a session is still active.</source>
          <target state="translated">Штемпель времени обновляется всякий раз,когда происходит чтение или запись в таблицу,и может быть использована для определения того,активна ли сессия.</target>
        </trans-unit>
        <trans-unit id="81762c19246e6846b2e980ea04896a37c7853877" translate="yes" xml:space="preserve">
          <source>The token may be sent by the request either via the params with key &quot;_csrf_token&quot; or a header with name &quot;x-csrf-token&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5072feb3a5cec39cc2fc00a21cad324ac72eccb" translate="yes" xml:space="preserve">
          <source>The token may be sent by the request either via the params with key &amp;ldquo;_csrf_token&amp;rdquo; or a header with name &amp;ldquo;x-csrf-token&amp;rdquo;.</source>
          <target state="translated">Токен может быть отправлен запросом либо через параметры с ключом &amp;laquo;_csrf_token&amp;raquo;, либо через заголовок с именем &amp;laquo;x-csrf-token&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2c49c933ccb1807a833e99f7dd1b49c2eb650bfa" translate="yes" xml:space="preserve">
          <source>The tracked statics on the client will match the ones on the server the huge majority of times. However, if there is a new deployment, those values may differ. You can use this function to detect those cases and show a banner to the user, asking them to reload the page. To do so, first set the assign on mount:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec7f0c751853b58fb208600c6fd51e96a829e62" translate="yes" xml:space="preserve">
          <source>The tracking of changes is done via assigns. Imagine this template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ce00aada35b93b3fdf93d5a2e7544465e5a9ee" translate="yes" xml:space="preserve">
          <source>The transaction will return the value given as &lt;code&gt;{:error, value}&lt;/code&gt;.</source>
          <target state="translated">Транзакция вернет значение, указанное как &lt;code&gt;{:error, value}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="144f4cd1edb440f47f1246559392f7aed2405665" translate="yes" xml:space="preserve">
          <source>The transport behaviour</source>
          <target state="translated">Поведение при транспортировке</target>
        </trans-unit>
        <trans-unit id="ffde96e4790584145c12afb10941ddbcfe63b5c3" translate="yes" xml:space="preserve">
          <source>The transport passes a map of metadata and the socket returns &lt;code&gt;{:ok, state}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt;. The state must be stored by the transport and returned in all future operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0618061b416a03f218c617e087e2e53df218e5c9" translate="yes" xml:space="preserve">
          <source>The transport requires one function:</source>
          <target state="translated">Транспорт требует одной функции:</target>
        </trans-unit>
        <trans-unit id="2c0b95368d8ebf1cd3519374ade97eb4d383c66c" translate="yes" xml:space="preserve">
          <source>The triggers the &lt;code&gt;handle_in/3&lt;/code&gt; callback in the channel.</source>
          <target state="translated">Запускает &lt;code&gt;handle_in/3&lt;/code&gt; обратного вызова в канале.</target>
        </trans-unit>
        <trans-unit id="42337bbf47f302b6017a80123d119d2018afc1ba" translate="yes" xml:space="preserve">
          <source>The underlying data in the JSON column is returned without any additional decoding. This means &quot;null&quot; JSON values are not the same as SQL's &quot;null&quot;. For example, the &lt;code&gt;Repo.all&lt;/code&gt; operation below returns an empty list because &lt;code&gt;p.meta[&quot;author&quot;]&lt;/code&gt; returns JSON's null and therefore &lt;code&gt;is_nil&lt;/code&gt; does not succeed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e53abaed4d2983226c3cac5079451da818bff2" translate="yes" xml:space="preserve">
          <source>The underlying user is passed to the view and template as &lt;code&gt;:user&lt;/code&gt;, which is inferred from the view name. The name of the key in assigns can be customized with the &lt;code&gt;:as&lt;/code&gt; option:</source>
          <target state="translated">Базовый пользователь передается представлению и шаблону как &lt;code&gt;:user&lt;/code&gt; , который выводится из имени представления. Имя клавиши в назначаемых может быть изменено с помощью опции: &lt;code&gt;:as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1dfd3b303d5fe2aedc67a0b4bc8aa60d95f14665" translate="yes" xml:space="preserve">
          <source>The underlying user is passed to the view and template as &lt;code&gt;:user&lt;/code&gt;, which is inflected from the view name. The name of the key in assigns can be customized with the &lt;code&gt;:as&lt;/code&gt; option:</source>
          <target state="translated">Базовый пользователь передается представлению и шаблону как &lt;code&gt;:user&lt;/code&gt; , который изменяется от имени представления. Имя клавиши в назначаемых может быть изменено с помощью опции: &lt;code&gt;:as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ece19487ec4f9c9b42291fc4215172a12c3b8537" translate="yes" xml:space="preserve">
          <source>The unique constraint works by relying on the database to check if the unique constraint has been violated or not and, if so, Ecto converts it into a changeset error.</source>
          <target state="translated">Уникальное ограничение работает,полагаясь на базу данных для проверки,было ли уникальное ограничение нарушено или нет,и если да,то Ecto преобразует его в ошибку changeset.</target>
        </trans-unit>
        <trans-unit id="8f24025f778f23bb692d5c7e74205b6b4b984c73" translate="yes" xml:space="preserve">
          <source>The update expression in Ecto supports the following operators:</source>
          <target state="translated">Выражение update в Ecto поддерживает следующие операторы:</target>
        </trans-unit>
        <trans-unit id="9e941c51bb22eea00a76220d6ae9f744a7be5afe" translate="yes" xml:space="preserve">
          <source>The update function receives the current key's value and returns the updated value. Raises if the key does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6d6cdb41018b373e7cfa4867802d99511b1902" translate="yes" xml:space="preserve">
          <source>The valid keys are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ef4c02aad1666d20571d41d03ccfe5bdef87c8" translate="yes" xml:space="preserve">
          <source>The validate callback simply updates the changeset based on all form input values, then assigns the new changeset to the socket. If the changeset changes, such as generating new errors, &lt;a href=&quot;phoenix.liveview#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt; is invoked and the form is re-rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6cddd8de1840c96ca7fda0519b7a48fb8e1141" translate="yes" xml:space="preserve">
          <source>The values above are not meant to be exact. For example, setting the length to 8_000_000 may end up reading some hundred bytes more from the socket until we halt.</source>
          <target state="translated">Вышеуказанные значения не являются точными.Например,установка длины в 8_000_000 может привести к чтению из сокета на несколько сотен байт больше,пока мы не остановимся.</target>
        </trans-unit>
        <trans-unit id="f62c587734431028a6aa80f1e9be78246f2a1d3f" translate="yes" xml:space="preserve">
          <source>The values above are not meant to be exact. For example, setting the length to &lt;code&gt;8_000_000&lt;/code&gt; may end up reading some hundred bytes more from the socket until we halt.</source>
          <target state="translated">Приведенные выше значения не являются точными. Например, установка длины на &lt;code&gt;8_000_000&lt;/code&gt; может привести к чтению из сокета еще нескольких сотен байтов, пока мы не остановимся.</target>
        </trans-unit>
        <trans-unit id="8ecaa2ac2dc3f10d3435db3d9b4bfce660d8e6fb" translate="yes" xml:space="preserve">
          <source>The view layer also contains conveniences for rendering templates, including support for layouts and encoders per format.</source>
          <target state="translated">Слой просмотра также содержит удобства для отрисовки шаблонов,включая поддержку макетов и кодировщиков для каждого формата.</target>
        </trans-unit>
        <trans-unit id="60741f2b56ae9c96f4fb20a37607c7c8a04c0e31" translate="yes" xml:space="preserve">
          <source>The view's job is not only to render HTML templates. Views are about data presentation. Given a bag of data, the view's purpose is to present that in a meaningful way given some format, be it HTML, JSON, CSV, or others. Many web apps today return JSON to remote clients, and Phoenix Views are &lt;em&gt;great&lt;/em&gt; for JSON rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fa591ef2cba3e61fb437760238714eb628080e" translate="yes" xml:space="preserve">
          <source>The websocket is configurable in your socket:</source>
          <target state="translated">Веб-сокет настраивается в Вашем гнезде:</target>
        </trans-unit>
        <trans-unit id="2b5a7e72a4fe9a475fcfc4b4359c0838c82db1da" translate="yes" xml:space="preserve">
          <source>Then Phoenix will never re-render the section above, even if the number of users in the database changes. Instead, you need to store the users as assigns in your LiveView before it renders the template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19af577dc0e0cc3e9e4137f355fc1af37d4a35b0" translate="yes" xml:space="preserve">
          <source>Then a hook callback object could be defined and passed to the socket:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e364d2682313f21c0b364d5a1f63f57084ff3d81" translate="yes" xml:space="preserve">
          <source>Then access &lt;code&gt;@page_title&lt;/code&gt; in the root layout:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7196b255ac3408de7a3c568b57c1148a6a5e5f86" translate="yes" xml:space="preserve">
          <source>Then add the &lt;a href=&quot;phoenix.liveview.router#fetch_live_flash/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Router.fetch_live_flash/2&lt;/code&gt;&lt;/a&gt; plug to your browser pipeline, in place of &lt;code&gt;:fetch_flash&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c95726962fecc66929136723a6281fa6affd6c" translate="yes" xml:space="preserve">
          <source>Then add to your main application's supervision tree (usually in &lt;code&gt;lib/my_app/application.ex&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab777042c47d40f4805c33c94a1bf2e15d3974d" translate="yes" xml:space="preserve">
          <source>Then expect them in the test:</source>
          <target state="translated">Тогда жди их в тесте:</target>
        </trans-unit>
        <trans-unit id="f64fa9df7a55832de8379999e187333ea71240ba" translate="yes" xml:space="preserve">
          <source>Then in your &lt;code&gt;assets/css/app.css&lt;/code&gt; file, import its style:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b070171e3affccf770658d51e9a5a2feeee14f4d" translate="yes" xml:space="preserve">
          <source>Then in your LiveView &lt;code&gt;mount/3&lt;/code&gt;, you can restore the locale:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c5001f8e7c44fc4729c6dbfba0bf39f72beb09" translate="yes" xml:space="preserve">
          <source>Then in your LiveView, you can toggle the assign to trigger the form with the current fields on next render:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c527e6d510bb99f313314e80e90cb75cc1f4074f" translate="yes" xml:space="preserve">
          <source>Then install the new NPM dependency:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44a39ccd5266edb2d9caad076b683f36a1762b6" translate="yes" xml:space="preserve">
          <source>Then it falls back to the &lt;code&gt;@schema_prefix&lt;/code&gt; attribute declared in the schema given to &lt;code&gt;from&lt;/code&gt;/&lt;code&gt;join&lt;/code&gt;</source>
          <target state="translated">Затем он возвращается к &lt;code&gt;@schema_prefix&lt;/code&gt; объявленному в схеме, предоставленной &lt;code&gt;from&lt;/code&gt; / &lt;code&gt;join&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fe6880ddcb09c2b177e0c20e50dae10169afeef" translate="yes" xml:space="preserve">
          <source>Then it falls back to the query prefix</source>
          <target state="translated">Затем он возвращается к префиксу запроса</target>
        </trans-unit>
        <trans-unit id="a1ac12656c2b3f79bd0a2050e3acbce5cba1ab83" translate="yes" xml:space="preserve">
          <source>Then make sure to call it in every LiveView's &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f55476a7acca9fcf01ed95bca9c169e12918f35" translate="yes" xml:space="preserve">
          <source>Then on the server, all LiveView bindings are handled with the &lt;code&gt;handle_event&lt;/code&gt; callback, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9c975aa67ad159cfffc8aca53b0fcbfcf6e25a" translate="yes" xml:space="preserve">
          <source>Then the &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; callback of your LiveView should execute those same verifications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b91bece7078d6127399b4fede7285d49a284f5" translate="yes" xml:space="preserve">
          <source>Then the module for the &lt;code&gt;@view_module&lt;/code&gt; view can decide to provide scripts with either a precompiled template, or by implementing the function directly, ie:</source>
          <target state="translated">Затем модуль для представления &lt;code&gt;@view_module&lt;/code&gt; может решить предоставить сценарии либо с предварительно скомпилированным шаблоном, либо путем непосредственной реализации функции, то есть:</target>
        </trans-unit>
        <trans-unit id="f14d34a4f2c3d48f59e2e1b8b4a19a69ac94c3f8" translate="yes" xml:space="preserve">
          <source>Then the module under &lt;code&gt;view_module(@conn)&lt;/code&gt; can decide to provide scripts with either a precompiled template, or by implementing the function directly, ie:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd69831783581e277c0c694fce3ca0c8208fd7dc" translate="yes" xml:space="preserve">
          <source>Then the reporter will attach a listener for the &lt;code&gt;&quot;phoenix.endpoint.stop.duration&quot;&lt;/code&gt; event and will respond to this event by calculating a summary metric with the given event metadata and reporting on that metric to the appropriate source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0b9d44aabce7da630f72c56a074c5f7a3f3085" translate="yes" xml:space="preserve">
          <source>Then we can reference our new controller as the &lt;code&gt;action_fallback&lt;/code&gt; and simply remove the &lt;code&gt;else&lt;/code&gt; block from our &lt;code&gt;with&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9c5f3948060b97e1164d834dab0e2986a1f273" translate="yes" xml:space="preserve">
          <source>Then we'll change the &lt;code&gt;index&lt;/code&gt; action to do nothing but redirect to our new route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0dafaeb0118a06673409561de14306159c50ceb" translate="yes" xml:space="preserve">
          <source>Then you are able to use your own datetime_select throughout your whole application.</source>
          <target state="translated">Тогда вы сможете использовать свой собственный datetime_select во всем приложении.</target>
        </trans-unit>
        <trans-unit id="ceb5c8aab927695627e6a415525151e60cdf227b" translate="yes" xml:space="preserve">
          <source>Then you can directly create a socket and &lt;a href=&quot;#subscribe_and_join/4&quot;&gt;&lt;code&gt;subscribe_and_join/4&lt;/code&gt;&lt;/a&gt; topics and channels:</source>
          <target state="translated">Затем вы можете напрямую создать сокет и темы и каналы &lt;a href=&quot;#subscribe_and_join/4&quot;&gt; &lt;code&gt;subscribe_and_join/4&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="584bf72a0acf37e4eddce0ef40e653d37e3153b8" translate="yes" xml:space="preserve">
          <source>Then, in the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback, attach the handler to this event using a unique handler id:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1745b5a982e4f76414fc6a64641255e30bd82f09" translate="yes" xml:space="preserve">
          <source>Then, pass the basename of the new layout into &lt;code&gt;put_layout/2&lt;/code&gt; in our &lt;code&gt;index&lt;/code&gt; action in &lt;code&gt;lib/hello_web/controllers/page_controller.ex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4655c959b82e207027f846c0e96c80c6352c98fa" translate="yes" xml:space="preserve">
          <source>There are a couple of interesting things to notice about what we just did. We didn't need to stop and re-start the server while we made these changes. Yes, Phoenix has hot code reloading! Also, even though our &lt;code&gt;index.html.eex&lt;/code&gt; file consisted of only a single &lt;code&gt;div&lt;/code&gt; tag, the page we get is a full HTML document. Our index template is rendered into the application layout - &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt;. If you open it, you'll see a line that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cfb6706dad4ed0adea156a71a400336e56fc4b3" translate="yes" xml:space="preserve">
          <source>There are a few things that can go wrong with &lt;code&gt;ecto.create&lt;/code&gt;. If our Postgres database doesn't have a &quot;postgres&quot; role (user), we'll get an error like this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dcdee5113beb075e0f94cbe43ea0dc06f75667" translate="yes" xml:space="preserve">
          <source>There are a number of places to connect with community members at all experience levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1b86b915cfde7a7368137f0a2e48d4add28c22" translate="yes" xml:space="preserve">
          <source>There are also optional packages depending on your configuration:</source>
          <target state="translated">Существуют также дополнительные пакеты в зависимости от вашей конфигурации:</target>
        </trans-unit>
        <trans-unit id="48e7b53c5d965f68485b3ddac277b810c18b5b6b" translate="yes" xml:space="preserve">
          <source>There are also use cases which are a bad fit for LiveView:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7d6ee807af67ee19de04b8ba6fe4bb0e14f07b" translate="yes" xml:space="preserve">
          <source>There are currently a number of built-in Phoenix-specific and Ecto-specific mix tasks available to us within a newly-generated application. We can also create our own application specific tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4de1bab3bcb78d7de2f1a97fb1645a22d989827" translate="yes" xml:space="preserve">
          <source>There are just a few more things we need to do to make this work. We need to tell our router that it should accept the &lt;code&gt;text&lt;/code&gt; format. We do that by adding &lt;code&gt;text&lt;/code&gt; to the list of accepted formats in the &lt;code&gt;:browser&lt;/code&gt; pipeline. Let's open up &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; and change the &lt;code&gt;plug :accepts&lt;/code&gt; to include &lt;code&gt;text&lt;/code&gt; as well as &lt;code&gt;html&lt;/code&gt; like this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f91d0d9ce57177167c4420ce8468f849e7c8d5c" translate="yes" xml:space="preserve">
          <source>There are many more validations and transformations we can perform in a changeset. Please see the &lt;a href=&quot;../ecto/ecto.changeset&quot;&gt;Ecto Changeset documentation&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e051d2e913fcf9b1ffdbc95cb07006f322d1bf3e" translate="yes" xml:space="preserve">
          <source>There are many use cases where LiveView is an excellent fit right now:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6aa20209cea63d81eee09d733072aab9dc644cb" translate="yes" xml:space="preserve">
          <source>There are numerous reporters available, for services like StatsD, Prometheus, and more. You can find them by searching for &quot;telemetry_metrics&quot; on &lt;a href=&quot;https://hex.pm/packages?search=telemetry_metrics&quot;&gt;hex.pm&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9fd294c0e0edd78bdfd8fba29d9ae777edf871" translate="yes" xml:space="preserve">
          <source>There are other HTTP verbs. For example, submitting a form typically uses the POST verb.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d080ada9c12b95f9c19b53c77166860854b8a2" translate="yes" xml:space="preserve">
          <source>There are times when we need to communicate with users during the course of an action. Maybe there was an error updating a schema. Maybe we just want to welcome them back to the application. For this, we have flash messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa6f049cdcc785decf9d1331374c9b1898ba4cc" translate="yes" xml:space="preserve">
          <source>There are two common pitfalls to keep in mind when using the &lt;code&gt;~L&lt;/code&gt; sigil or &lt;code&gt;.leex&lt;/code&gt; templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6807336b45c24ae9dbef79351d2099a68159d0ed" translate="yes" xml:space="preserve">
          <source>There are two kind of plugs: function plugs and module plugs.</source>
          <target state="translated">Существует два вида штекеров:функциональные и модульные.</target>
        </trans-unit>
        <trans-unit id="bea848af2e953be99cd126902e2324fb347af163" translate="yes" xml:space="preserve">
          <source>There are two main mechanisms for testing components. To test stateless components or just a regular rendering of a component, one can use &lt;a href=&quot;#render_component/2&quot;&gt;&lt;code&gt;render_component/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1dd6c129ab09fcb3871f141a18dd6dd0425035" translate="yes" xml:space="preserve">
          <source>There are two types of telemetry events. The ones emitted by Ecto and the ones that are adapter specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3abfdacb3ac569bf8db5e65409f9dce9bb486d" translate="yes" xml:space="preserve">
          <source>There are two ways to define primary keys in Ecto: using the &lt;code&gt;@primary_key&lt;/code&gt; module attribute and using &lt;code&gt;primary_key: true&lt;/code&gt; as option for &lt;a href=&quot;#field/3&quot;&gt;&lt;code&gt;field/3&lt;/code&gt;&lt;/a&gt; in your schema definition. They are not mutually exclusive and can be used together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e7530f090b66e3b01b4d280637820412cb520f" translate="yes" xml:space="preserve">
          <source>There can only be one select expression in a query, if the select expression is omitted, the query will by default select the full schema. If select is given more than once, an error is raised. Use &lt;a href=&quot;#exclude/2&quot;&gt;&lt;code&gt;exclude/2&lt;/code&gt;&lt;/a&gt; if you would like to remove a previous select for overriding or see &lt;a href=&quot;#select_merge/3&quot;&gt;&lt;code&gt;select_merge/3&lt;/code&gt;&lt;/a&gt; for a limited version of &lt;code&gt;select&lt;/code&gt; that is composable and can be called multiple times.</source>
          <target state="translated">В запросе может быть только одно выражение выбора, если выражение выбора опущено, запрос по умолчанию выберет полную схему. Если select задан более одного раза, возникает ошибка. Используйте &lt;a href=&quot;#exclude/2&quot;&gt; &lt;code&gt;exclude/2&lt;/code&gt; ,&lt;/a&gt; если вы хотите удалить предыдущий select для переопределения, или смотрите &lt;a href=&quot;#select_merge/3&quot;&gt; &lt;code&gt;select_merge/3&lt;/code&gt; &lt;/a&gt; для ограниченной версии &lt;code&gt;select&lt;/code&gt; , которая является компонуемой и может вызываться несколько раз.</target>
        </trans-unit>
        <trans-unit id="1c88e179b2c1fdccf0ace5889abb511cec846bf3" translate="yes" xml:space="preserve">
          <source>There is a fourth &lt;code&gt;router_opts&lt;/code&gt; argument that can be passed. These options are outlined in the &lt;a href=&quot;phoenix.router#scope/2&quot;&gt;&lt;code&gt;Phoenix.Router.scope/2&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60774986335f094648654b82d018e24c6920015b" translate="yes" xml:space="preserve">
          <source>There is an example of working with changesets in the introductory documentation in the &lt;a href=&quot;ecto&quot;&gt;&lt;code&gt;Ecto&lt;/code&gt;&lt;/a&gt; module. The functions &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#change/2&quot;&gt;&lt;code&gt;change/2&lt;/code&gt;&lt;/a&gt; are the usual entry points for creating changesets. The first one is used to cast and validate external parameters, such as parameters sent through a form, API, command line, etc. The second one is used to change data directly from your application.</source>
          <target state="translated">Пример работы с ревизиями есть во вводной документации модуля &lt;a href=&quot;ecto&quot;&gt; &lt;code&gt;Ecto&lt;/code&gt; &lt;/a&gt; . Функции &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#change/2&quot;&gt; &lt;code&gt;change/2&lt;/code&gt; &lt;/a&gt; - обычные точки входа для создания наборов изменений. Первый используется для приведения и проверки внешних параметров, таких как параметры, отправленные через форму, API, командную строку и т. Д. Второй используется для изменения данных непосредственно из вашего приложения.</target>
        </trans-unit>
        <trans-unit id="6c51bdfb925eab670614cd9390b950e516f949e0" translate="yes" xml:space="preserve">
          <source>There is quite a bit more that Ecto can do and we've only barely scratched the surface. With a solid Ecto foundation in place, we're now ready to continue building our app and integrate the web facing application with our backend persistence. Along the way, we'll expand our Ecto knowledge and learn how to properly isolate our web interface from the underlying details of our system. Please take a look at the &lt;a href=&quot;../ecto/index&quot;&gt;Ecto documentation&lt;/a&gt; for the rest of the story.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00efdd6792388b25c72cb1b0a5d138f97391c9b0" translate="yes" xml:space="preserve">
          <source>There's a bit of a code here, so let's break it down. First, we rewrote the &lt;code&gt;create_page&lt;/code&gt; function to require a &lt;code&gt;CMS.Author&lt;/code&gt; struct, which represents the author publishing the post. We then take our changeset and pass it to &lt;code&gt;Ecto.Changeset.put_change/2&lt;/code&gt; to place the &lt;code&gt;author_id&lt;/code&gt; association in the changeset. Next, we use &lt;code&gt;Repo.insert&lt;/code&gt; to insert the new page into the database, containing our associated &lt;code&gt;author_id&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd27e2a8e827fa726136e1148022cbcd8bbab3bf" translate="yes" xml:space="preserve">
          <source>There's more documentation than code here, but a couple of things are important to highlight. First, we can see again that our Ecto Repo is used under the hood for database access. You probably also noticed the call to &lt;code&gt;User.changeset/2&lt;/code&gt;. We talked about changesets before, and now we see them in action in our context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100960a1d19b2df147cb0c67cb03d0ef859b8a72" translate="yes" xml:space="preserve">
          <source>Therefore it is your responsibility to keep only the assigns necessary in each component. For example, avoid passing all of LiveView components when rendering a component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbe69bd2d1d3f33a0989c0c7daf1e4f17426993" translate="yes" xml:space="preserve">
          <source>Therefore, if you get a warning that the host does not match, it is either because someone is attempting to steal CSRF tokens or because you have a misconfigured host configuration.</source>
          <target state="translated">Поэтому,если вы получаете предупреждение о том,что хост не соответствует,то это либо потому,что кто-то пытается украсть маркеры CSRF,либо потому,что у вас неправильно настроена конфигурация хоста.</target>
        </trans-unit>
        <trans-unit id="3748dac854496bc8faac9591f1822a153d556a4a" translate="yes" xml:space="preserve">
          <source>Therefore, when working with and manipulating external data, it is recommended to use &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s that are able to filter and properly cast external data:</source>
          <target state="translated">Поэтому при работе с внешними данными и манипулировании ими рекомендуется использовать &lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; , которые могут фильтровать и правильно преобразовывать внешние данные:</target>
        </trans-unit>
        <trans-unit id="7e8893d85340fc3862c12874dc8c0caa638bca11" translate="yes" xml:space="preserve">
          <source>Therefore, when working with and manipulating external data, it is recommended to use &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt;'s that are able to filter and properly cast external data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b6dd62855c1cdb8d6d7226945af7408045cf45" translate="yes" xml:space="preserve">
          <source>These attributes are:</source>
          <target state="translated">Эти атрибуты:</target>
        </trans-unit>
        <trans-unit id="dab402ac1558a423d6bfdf184cdcba60e59a9b1c" translate="yes" xml:space="preserve">
          <source>These fields are reserved for libraries/framework usage.</source>
          <target state="translated">Эти поля зарезервированы для использования библиотек/фреймворков.</target>
        </trans-unit>
        <trans-unit id="31125242793acf4be0a0cc8a21b6685bbae8a6a2" translate="yes" xml:space="preserve">
          <source>These fields contain request information:</source>
          <target state="translated">Эти поля содержат информацию о запросах:</target>
        </trans-unit>
        <trans-unit id="9c58c3f5a32cf2cabf47af4ce6c2874bf3d0f839" translate="yes" xml:space="preserve">
          <source>These fields contain response information:</source>
          <target state="translated">Эти поля содержат информацию об ответах:</target>
        </trans-unit>
        <trans-unit id="4bf47d1305fab6c065239130eb679be1db4d2859" translate="yes" xml:space="preserve">
          <source>These guides focus on LiveView bindings and client-side integration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13968d858a6aa2228deefd19ee03e436119ab45" translate="yes" xml:space="preserve">
          <source>These guides focus on server-side functionality:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef711a090a295d12005974a4d06b792bb140e9c3" translate="yes" xml:space="preserve">
          <source>These options are assigned to &lt;code&gt;:private&lt;/code&gt; in the call&amp;rsquo;s &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эти параметры назначаются &lt;code&gt;:private&lt;/code&gt; в &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; вызова .</target>
        </trans-unit>
        <trans-unit id="24e9ee2f9ab53061b515ecbc4fb47faf1d9a6a50" translate="yes" xml:space="preserve">
          <source>Thinking about design</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59fd20a59fd71306464f90cbc93687125b053059" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;:through&lt;/code&gt; association will return all authors for all comments that belongs to that post:</source>
          <target state="translated">Это &lt;code&gt;:through&lt;/code&gt; ассоциацию вернет всех авторов для всех комментариев, относящихся к этому сообщению:</target>
        </trans-unit>
        <trans-unit id="4199b4f5db3f20ec0146877224956a5aadb69e6f" translate="yes" xml:space="preserve">
          <source>This ability to introspect HTTP requests is really powerful -- and this is but one of &lt;em&gt;many&lt;/em&gt; telemetry events emitted by the Phoenix framework! We'll discuss more of these events, as well as specific patterns for extracting valuable data from Phoenix/Plug events in the &lt;a href=&quot;#phoenix-metrics&quot;&gt;Phoenix Metrics&lt;/a&gt; section later in this guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007291854548be2f362800441309464462d301ce" translate="yes" xml:space="preserve">
          <source>This adapter uses the following endpoint configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c1e7b1a6546a0da231a6c048940c7137b1d0c8" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;.leex&lt;/code&gt; templates to drastically optimize the data sent by comprehensions, as the static parts are emitted only once, regardless of the number of items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="314e0a3a76540d899cae17754d71892826cfdce8" translate="yes" xml:space="preserve">
          <source>This allows developers to properly translate values coming from the Ecto into adapter ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</source>
          <target state="translated">Это позволяет разработчикам правильно переводить значения,поступающие из Ecto,в адаптерные.Например,если база данных не поддерживает булеан,а вместо этого возвращает 0 и 1,то можно добавить:</target>
        </trans-unit>
        <trans-unit id="c34b4dd019d2b68a7383ace93f2215401ec4cad3" translate="yes" xml:space="preserve">
          <source>This allows developers to properly translate values coming from the adapters into Ecto ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</source>
          <target state="translated">Это позволяет разработчикам правильно переводить значения,поступающие от адаптеров,в Ecto.Например,если база данных не поддерживает булеан,а вместо этого возвращает 0 и 1,то можно добавить:</target>
        </trans-unit>
        <trans-unit id="fb97fed7c5bb051af51293923cd1d414d840c2fd" translate="yes" xml:space="preserve">
          <source>This approach is useful when both username and password are specified upfront and available at runtime. However, you may also want to compute a different password for each different user. In those cases, we can use the low-level API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9069e4b8ffaf3bc20294b7bd6a863e30171a4d03" translate="yes" xml:space="preserve">
          <source>This approach lets us not worry about keeping track of the position of the bindings when composing the query.</source>
          <target state="translated">Такой подход позволяет нам не беспокоиться о том,чтобы отслеживать положение связок при составлении запроса.</target>
        </trans-unit>
        <trans-unit id="78e0d97646f179af897c91029155ab3de9f02b8b" translate="yes" xml:space="preserve">
          <source>This approach lets us not worry about keeping track of the position of the bindings when composing the query. The &lt;code&gt;:as&lt;/code&gt; option can be given both on joins and on &lt;code&gt;from&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f59bfe0a957636ece0be8bfd839e81d84f8f0ae" translate="yes" xml:space="preserve">
          <source>This behaviour provides presence features such as fetching presences for a given topic, as well as handling diffs of join and leave events as they occur in real-time. Using this module defines a supervisor and a module that implements the &lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour that uses &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; to broadcast presence updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6967adaf22d337178372537c6118e0d2b8a63bd3" translate="yes" xml:space="preserve">
          <source>This behaviour provides presence features such as fetching presences for a given topic, as well as handling diffs of join and leave events as they occur in real-time. Using this module defines a supervisor and allows the calling module to implement the &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.tracker&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour which starts a tracker process to handle presence information.</source>
          <target state="translated">Это поведение обеспечивает функции присутствия, такие как получение данных о присутствии для заданной темы, а также обработку различий событий присоединения и выхода по мере их возникновения в реальном времени. Использование этого модуля определяет супервизора и позволяет вызывающему модулю реализовать поведение &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.tracker&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; ,&lt;/a&gt; которое запускает процесс отслеживания для обработки информации о присутствии.</target>
        </trans-unit>
        <trans-unit id="e21363635aabca14d08079e73432c541e1ab7506" translate="yes" xml:space="preserve">
          <source>This block is only executed in development. It enables live reloading (if you change a CSS file, they are updated in-browser without refreshing the page), code reloading (so we can see changes to our application without restarting the server), and check repo status (which makes sure our database is up to date, raising readable and actionable error otherwise).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7556041936c271690740591770bfe1ea6222272" translate="yes" xml:space="preserve">
          <source>This callback can be used to further modify the query and options before it is transformed and sent to the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5289f3895306f4a2bb2ce650d1609e9b79d9c7" translate="yes" xml:space="preserve">
          <source>This callback is called on external input and can return any type, as long as the &lt;code&gt;dump/1&lt;/code&gt; function is able to convert the returned value into an Ecto native type. There are two situations where this callback is called:</source>
          <target state="translated">Этот обратный вызов вызывается на внешнем входе и может возвращать любой тип, если функция &lt;code&gt;dump/1&lt;/code&gt; способна преобразовать возвращаемое значение в собственный тип Ecto. Есть две ситуации, когда вызывается этот обратный вызов:</target>
        </trans-unit>
        <trans-unit id="f6d40809f5928ded0783d1c5bde4c2ca0dacdca6" translate="yes" xml:space="preserve">
          <source>This callback is called when loading data from the database and receive an Ecto native type. It can return any type, as long as the &lt;code&gt;dump/1&lt;/code&gt; function is able to convert the returned value back into an Ecto native type.</source>
          <target state="translated">Этот обратный вызов вызывается при загрузке данных из базы данных и получении собственного типа Ecto. Он может возвращать любой тип, если функция &lt;code&gt;dump/1&lt;/code&gt; способна преобразовать возвращаемое значение обратно в собственный тип Ecto.</target>
        </trans-unit>
        <trans-unit id="5dba0f0e5df500a1e88b72d27d9b478ed2ccb47c" translate="yes" xml:space="preserve">
          <source>This callback is called when loading data from the database and receives an Ecto native type. It can return any type, as long as the &lt;code&gt;dump/1&lt;/code&gt; function is able to convert the returned value back into an Ecto native type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8391fe8b307eb118c66a1224a190e367cf1e34a5" translate="yes" xml:space="preserve">
          <source>This callback is called with any term that was stored in the struct and it needs to validate them and convert it to an Ecto native type.</source>
          <target state="translated">Этот обратный вызов вызывается любым термином,который был сохранен в структуре,и ему необходимо проверить их и преобразовать в нативный тип Ecto.</target>
        </trans-unit>
        <trans-unit id="6bf00040ea79807475cd31c46b891cb8ded6c579" translate="yes" xml:space="preserve">
          <source>This callback is invoked as the entry point for all repository operations. For example, if you are executing a query with preloads, this callback will be invoked once at the beginning, but the options returned here will be passed to all following operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79748d4f4c53c8b678eba754fd8a33ed0dc52111" translate="yes" xml:space="preserve">
          <source>This callback is invoked for all query APIs, including the &lt;code&gt;stream&lt;/code&gt; function, but it is not invoked for &lt;code&gt;insert_all&lt;/code&gt; nor any of the schema functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b997bebb99d88139d7659f0af87669f8dfb97d13" translate="yes" xml:space="preserve">
          <source>This can be used during tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dd66370a2871bfe63d6fef51a35166fbee8602" translate="yes" xml:space="preserve">
          <source>This can be used to load CSRF state into another process. See &lt;a href=&quot;#dump_state/0&quot;&gt;&lt;code&gt;dump_state/0&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;dump_state_from_session/2&lt;/code&gt; for dumping it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9942f198e47ea544c82a2f3149eb4db211bc77f7" translate="yes" xml:space="preserve">
          <source>This can be used to provide default values per operation that have higher precedence than the values given on configuration or when starting the repository. It can also be used to set query specific options, such as &lt;code&gt;:prefix&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7451f29af9970208fd48c0f77d572d71c9c6abab" translate="yes" xml:space="preserve">
          <source>This can be useful to implement nested layouts. For example, imagine you have an application layout like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c8c29b8e1afac3fcab4f5358a3e87060ee714f" translate="yes" xml:space="preserve">
          <source>This component is never meant to be output directly into the template. It should always be handled by the diffing algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cde890ab9fc7b08ed69780233aa5e8d306807f" translate="yes" xml:space="preserve">
          <source>This converts the given embedded schema to a map to be serialized with the given format. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffb99485473cd5f2890d8e671445895fea64111" translate="yes" xml:space="preserve">
          <source>This cookie store is based on &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageVerifier.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageEncryptor.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt;&lt;/a&gt; which encrypts and signs each cookie to ensure they can&amp;rsquo;t be read nor tampered with.</source>
          <target state="translated">Это хранилище &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageVerifier.html&quot;&gt; &lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt; &lt;/a&gt; cookie основано на Plug.Crypto.MessageVerifier и &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageEncryptor.html&quot;&gt; &lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt; ,&lt;/a&gt; которые шифруют и подписывают каждый файл cookie, чтобы гарантировать, что они не могут быть прочитаны или изменены.</target>
        </trans-unit>
        <trans-unit id="53b55df014db1d36aa928a0d1ab68e9498d7f04f" translate="yes" xml:space="preserve">
          <source>This cookie store is based on &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.MessageVerifier.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.MessageEncryptor.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt;&lt;/a&gt; which encrypts and signs each cookie to ensure they can't be read nor tampered with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f415484d2416f0c9164e685095abeddba09475" translate="yes" xml:space="preserve">
          <source>This does not expect the repository and therefore does not leverage the cache.</source>
          <target state="translated">Это не предполагает репозитория и,следовательно,не использует кэш.</target>
        </trans-unit>
        <trans-unit id="ee92ad563023f60c952d3ce1d1e4f1a71f755d06" translate="yes" xml:space="preserve">
          <source>This doesn't correspond to any action in our controller, which is fine. We'll exercise it in an &lt;code&gt;iex&lt;/code&gt; session. At the root of our project, we can run &lt;code&gt;iex -S mix&lt;/code&gt;, and then explicitly render our template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8358ce5c448165474c59ccb6634f95fedb0d2fb6" translate="yes" xml:space="preserve">
          <source>This emulates behaviour performed by browsers where cookies returned in the response are available in following requests.</source>
          <target state="translated">Это эмулирует поведение,выполняемое браузерами,где куки,возвращаемые в ответе,доступны в следующих запросах.</target>
        </trans-unit>
        <trans-unit id="fa7d6e6dcda78ceca060025cce3f5837a513f835" translate="yes" xml:space="preserve">
          <source>This event should be invoked on every query sent to the adapter, including queries that are related to the transaction management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c41eb119619d93df37edc66780e62d9f72d4b1" translate="yes" xml:space="preserve">
          <source>This exception is commonly raised by &lt;a href=&quot;phoenix.controller#accepts/2&quot;&gt;&lt;code&gt;Phoenix.Controller.accepts/2&lt;/code&gt;&lt;/a&gt; which negotiates the media types the server is able to serve with the contents the client is able to render.</source>
          <target state="translated">Это исключение обычно вызывается &lt;a href=&quot;phoenix.controller#accepts/2&quot;&gt; &lt;code&gt;Phoenix.Controller.accepts/2&lt;/code&gt; ,&lt;/a&gt; который согласовывает типы носителей, которые сервер может обслуживать, с содержимым, которое клиент может отображать.</target>
        </trans-unit>
        <trans-unit id="e27c88fc5d1a3d0121b169f096d2ac516c60e1ae" translate="yes" xml:space="preserve">
          <source>This exception is raised by &lt;a href=&quot;phoenix.controller#scrub_params/2&quot;&gt;&lt;code&gt;Phoenix.Controller.scrub_params/2&lt;/code&gt;&lt;/a&gt; which:</source>
          <target state="translated">Это исключение вызывается &lt;a href=&quot;phoenix.controller#scrub_params/2&quot;&gt; &lt;code&gt;Phoenix.Controller.scrub_params/2&lt;/code&gt; ,&lt;/a&gt; который:</target>
        </trans-unit>
        <trans-unit id="0fa6cbcebc05c777d1c7368f7969366f4e084a6c" translate="yes" xml:space="preserve">
          <source>This feature is very useful when queries need to be built based on some user input, like web search forms, CLIs and so on.</source>
          <target state="translated">Эта функция очень полезна,когда запросы нужно строить на основе некоторого пользовательского ввода,например,поисковых форм,CLI и так далее.</target>
        </trans-unit>
        <trans-unit id="736fb0a01b93ff59374b8773d572c0d61a1c4bf4" translate="yes" xml:space="preserve">
          <source>This first group contains validations that take a keyword list of validators, where the validators are shown immediately following the validation type. This list may also include a &lt;code&gt;message:&lt;/code&gt; key.</source>
          <target state="translated">Эта первая группа содержит проверки, которые принимают список ключевых слов валидаторов, где валидаторы отображаются сразу после типа проверки. Этот список может также включать &lt;code&gt;message:&lt;/code&gt; ключ.</target>
        </trans-unit>
        <trans-unit id="08a01cc9d2b834ac5065ca0c4859bc17a52873c2" translate="yes" xml:space="preserve">
          <source>This format is used when rendering a template as an atom. For example, &lt;code&gt;render(conn, :foo)&lt;/code&gt; will render &lt;code&gt;&quot;foo.FORMAT&quot;&lt;/code&gt; where the format is the one set here. The default format is typically set from the negotiation done in &lt;a href=&quot;#accepts/2&quot;&gt;&lt;code&gt;accepts/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a654e5931463e5b13804f19ebe7438789fab9cac" translate="yes" xml:space="preserve">
          <source>This function accepts all options defined &lt;a href=&quot;http://erlang.org/doc/man/ssl.html&quot;&gt;in Erlang/OTP &lt;code&gt;:ssl&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b203fe59546a0ae658a9d0fdb623d409065b4b9" translate="yes" xml:space="preserve">
          <source>This function accepts and validates all options defined in &lt;a href=&quot;http://www.erlang.org/doc/man/ssl.html&quot;&gt;the &lt;code&gt;ssl&lt;/code&gt; erlang module&lt;/a&gt;. With the following additions:</source>
          <target state="translated">Эта функция принимает и проверяет все параметры , определенные в &lt;a href=&quot;http://www.erlang.org/doc/man/ssl.html&quot;&gt;с &lt;code&gt;ssl&lt;/code&gt; модуля Erlang&lt;/a&gt; . Со следующими дополнениями:</target>
        </trans-unit>
        <trans-unit id="ff98681cd9fee831827f27fd0a9d833563a2d938" translate="yes" xml:space="preserve">
          <source>This function allows you to automatically sign and encrypt cookies. When signing or encryption is enabled, then any Elixir value can be stored in the cookie (except anonymous functions for security reasons). Once a value is signed or encrypted, you must also call &lt;a href=&quot;#fetch_cookies/2&quot;&gt;&lt;code&gt;fetch_cookies/2&lt;/code&gt;&lt;/a&gt; with the name of the cookies that are either signed or encrypted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8560ae300306496e1e57a607297b4be5809ada0e" translate="yes" xml:space="preserve">
          <source>This function behaves the same as &lt;a href=&quot;#dump/2&quot;&gt;&lt;code&gt;dump/2&lt;/code&gt;&lt;/a&gt;, except for composite types the given &lt;code&gt;dumper&lt;/code&gt; function is used.</source>
          <target state="translated">Эта функция ведет себя так же, как &lt;a href=&quot;#dump/2&quot;&gt; &lt;code&gt;dump/2&lt;/code&gt; &lt;/a&gt; , за исключением того, что для составных типов используется данная функция &lt;code&gt;dumper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a586051ba535bcfaa3ec3caebe587edd887bffe" translate="yes" xml:space="preserve">
          <source>This function behaves the same as &lt;a href=&quot;#load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt;, except for composite types the given &lt;code&gt;loader&lt;/code&gt; function is used.</source>
          <target state="translated">Эта функция ведет себя так же, как &lt;a href=&quot;#load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt; , за исключением того, что для составных типов используется данная функция &lt;code&gt;loader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e50d6767dc020a64e6d3d29750a6078f1a51289d" translate="yes" xml:space="preserve">
          <source>This function can also be used to dynamically load through associations by giving it a list. For example, to get all authors for all comments for the given posts, do:</source>
          <target state="translated">Эта функция также может быть использована для динамической загрузки через ассоциации,предоставляя ей список.Например,чтобы получить всех авторов для всех комментариев к данным сообщениям,сделайте:</target>
        </trans-unit>
        <trans-unit id="b31679aebb0e8c28069688039b1fa1e4998948f2" translate="yes" xml:space="preserve">
          <source>This function copies the cookie information in &lt;code&gt;old_conn&lt;/code&gt; into &lt;code&gt;new_conn&lt;/code&gt;, emulating multiple requests done by clients where cookies are always passed forward, and returns the new version of &lt;code&gt;new_conn&lt;/code&gt;.</source>
          <target state="translated">Эта функция копирует информацию cookie из &lt;code&gt;old_conn&lt;/code&gt; в &lt;code&gt;new_conn&lt;/code&gt; , имитируя несколько запросов, выполняемых клиентами, где файлы cookie всегда передаются вперед, и возвращает новую версию &lt;code&gt;new_conn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe1674ac966f1e7e84fdd91a095f600ff50b42e" translate="yes" xml:space="preserve">
          <source>This function depends on gathering the messages sent by the test adapter when assets are pushed. Calling this function will clear the pushed message from the inbox for the process. To assert on multiple pushes, the result of the function should be stored in a variable.</source>
          <target state="translated">Эта функция зависит от сбора сообщений,посылаемых тестовым адаптером при нажатии на активы.При вызове этой функции отодвинутое сообщение из папки &quot;Входящие&quot; удаляется.Для утверждения при многократных нажатиях результат функции должен быть сохранен в переменной.</target>
        </trans-unit>
        <trans-unit id="1660cbe1db7037c9964f911ded4eb4f26591a176" translate="yes" xml:space="preserve">
          <source>This function depends on gathering the messages sent by the test adapter when informational messages, such as an early hint, are sent. Calling this function will clear the informational request messages from the inbox for the process. To assert on multiple informs, the result of the function should be stored in a variable.</source>
          <target state="translated">Эта функция зависит от сбора сообщений,посылаемых тестовым адаптером при отправке информационных сообщений,таких как ранняя подсказка.Вызов этой функции очистит для процесса сообщения с запросом информации из папки &quot;Входящие&quot;.Чтобы утверждать о нескольких сообщениях,результат работы функции должен быть сохранен в переменной.</target>
        </trans-unit>
        <trans-unit id="a9a8dbd1e103ae7949082890ccdcca71a8261b80" translate="yes" xml:space="preserve">
          <source>This function does not fetch parameters from the body. To fetch parameters from the body, use the &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug.</source>
          <target state="translated">Эта функция не извлекает параметры из тела. Для получения параметров из тела используйте плагин &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20ea2b75919a9c3dd8b26d94997fe49393523498" translate="yes" xml:space="preserve">
          <source>This function does the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8689955a82c196a1de5806c3547594bd18663df" translate="yes" xml:space="preserve">
          <source>This function exists as an extension point for libraries to add new types of associations to Ecto. For the existing APIs, see &lt;a href=&quot;#belongs_to/3&quot;&gt;&lt;code&gt;belongs_to/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#has_many/3&quot;&gt;&lt;code&gt;has_many/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#has_one/3&quot;&gt;&lt;code&gt;has_one/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#many_to_many/3&quot;&gt;&lt;code&gt;many_to_many/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция существует как точка расширения для библиотек для добавления новых типов ассоциаций в Ecto. Информацию о существующих API см. В разделе &lt;a href=&quot;#belongs_to/3&quot;&gt; &lt;code&gt;belongs_to/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#has_many/3&quot;&gt; &lt;code&gt;has_many/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#has_one/3&quot;&gt; &lt;code&gt;has_one/3&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#many_to_many/3&quot;&gt; &lt;code&gt;many_to_many/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b2304f76a58fd59e742ef62114c970eef992a68" translate="yes" xml:space="preserve">
          <source>This function exists to provide quick feedback to users of your application. It should not be relied on for any data guarantee as it has race conditions and is inherently unsafe. For example, if this check happens twice in the same time interval (because the user submitted a form twice), both checks may pass and you may end-up with duplicate entries in the database. Therefore, a &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; should also be used to ensure your data won&amp;rsquo;t get corrupted.</source>
          <target state="translated">Эта функция предназначена для быстрой обратной связи с пользователями вашего приложения. На него не следует полагаться для получения каких-либо гарантий данных, поскольку он имеет условия гонки и по своей сути небезопасен. Например, если эта проверка выполняется дважды в один и тот же интервал времени (потому что пользователь отправил форму дважды), обе проверки могут пройти, и вы можете получить повторяющиеся записи в базе данных. Следовательно, также следует использовать &lt;a href=&quot;#unique_constraint/3&quot;&gt; &lt;code&gt;unique_constraint/3&lt;/code&gt; ,&lt;/a&gt; чтобы ваши данные не были повреждены.</target>
        </trans-unit>
        <trans-unit id="dc2d67a85e75f44fb49399d03fb1c45ee6231022" translate="yes" xml:space="preserve">
          <source>This function exists to provide quick feedback to users of your application. It should not be relied on for any data guarantee as it has race conditions and is inherently unsafe. For example, if this check happens twice in the same time interval (because the user submitted a form twice), both checks may pass and you may end-up with duplicate entries in the database. Therefore, a &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; should also be used to ensure your data won't get corrupted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fef9a49538642527fff343bf96706313c19d33" translate="yes" xml:space="preserve">
          <source>This function expects the current schema, the association cardinality, the association name, the association module (that implements &lt;code&gt;Ecto.Association&lt;/code&gt; callbacks) and a keyword list of options.</source>
          <target state="translated">Эта функция ожидает текущую схему, мощность ассоциации, имя ассоциации, модуль ассоциации (который реализует &lt;code&gt;Ecto.Association&lt;/code&gt; вызовы Ecto.Association ) и список ключевых слов параметров.</target>
        </trans-unit>
        <trans-unit id="9dea39cef34defdfd207a8eb99802b8d948cd9f6" translate="yes" xml:space="preserve">
          <source>This function generates the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag without its closing part. Check &lt;a href=&quot;#form_tag/3&quot;&gt;&lt;code&gt;form_tag/3&lt;/code&gt;&lt;/a&gt; for generating an enclosing tag.</source>
          <target state="translated">Эта функция генерирует &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; без его закрывающей части. Проверьте &lt;a href=&quot;#form_tag/3&quot;&gt; &lt;code&gt;form_tag/3&lt;/code&gt; &lt;/a&gt; для создания закрывающего тега.</target>
        </trans-unit>
        <trans-unit id="53f40e7f6118a94a757813a716439f649282ffc1" translate="yes" xml:space="preserve">
          <source>This function is a shortcut for:</source>
          <target state="translated">Эта функция представляет собой ярлык:</target>
        </trans-unit>
        <trans-unit id="6306e2e81e647cdb91b3f8a11699265b79a2778b" translate="yes" xml:space="preserve">
          <source>This function is able to handle both chunked and identity transfer-encoding by default.</source>
          <target state="translated">По умолчанию эта функция способна обрабатывать как пакетное кодирование,так и кодирование переноса идентификационных данных.</target>
        </trans-unit>
        <trans-unit id="d4b953f4ee21fe94d4050f234c2003683ae8f4ad" translate="yes" xml:space="preserve">
          <source>This function is called at compile time, and should raise if invalid values are specified. It is idiomatic that the parameters returned from this are a map. &lt;code&gt;field&lt;/code&gt; and &lt;code&gt;schema&lt;/code&gt; will be injected into the options automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe83ec596d61f20f781d548aba70cef9549cb117" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application&amp;rsquo;s supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="translated">Эта функция вызывается, когда приложение запускается с использованием &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; (и дополнительных функций, таких как &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt; &lt;code&gt;Application.ensure_started/2&lt;/code&gt; &lt;/a&gt; ). Эта функция должна запускать процесс верхнего уровня приложения (который должен быть верхним супервизором дерева надзора за приложением, если приложение следует принципам проектирования OTP в отношении надзора).</target>
        </trans-unit>
        <trans-unit id="f40bd7c1cf4ae95315c3ffd80bd8b3a7c29506eb" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866cdfbc4d38507dc477d2b6e7b5a6b73c6d3bd8" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use reraise/1 or reraise/4 instead.</source>
          <target state="translated">Эта функция устарела.Вместо этого используйте reraise/1 или reraise/4.</target>
        </trans-unit>
        <trans-unit id="889e6268cee5d42d732aa072ffb292fc6aa1faee" translate="yes" xml:space="preserve">
          <source>This function is especially useful when parsing raw query results:</source>
          <target state="translated">Эта функция особенно полезна при разборе необработанных результатов запроса:</target>
        </trans-unit>
        <trans-unit id="1060a96b14370e1a1be3ad60f1c900dfde2028ca" translate="yes" xml:space="preserve">
          <source>This function is meant to mimic what the user can actually do, so you cannot set hidden input values. However, hidden values can be given when calling &lt;a href=&quot;#render_submit/2&quot;&gt;&lt;code&gt;render_submit/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#render_change/2&quot;&gt;&lt;code&gt;render_change/2&lt;/code&gt;&lt;/a&gt;, see their docs for examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2fbdc7b6be0d3c0040fc63965553cbf76fdb977" translate="yes" xml:space="preserve">
          <source>This function is often called internally by adapters, such as Cowboy, to validate and set reasonable defaults for SSL handling. Therefore Plug users are not expected to invoke it directly, rather you pass the relevant SSL options to your adapter which then invokes this.</source>
          <target state="translated">Эта функция часто вызывается внутренне адаптерами,такими как Cowboy,для проверки и установки разумных настроек по умолчанию для работы с SSL.Поэтому от пользователей Plug не ожидается,что они будут вызывать ее напрямую,а скорее вы передаете соответствующие опции SSL вашему адаптеру,который затем вызывает эту функцию.</target>
        </trans-unit>
        <trans-unit id="ce00aa1228b7b92a142997d61b397de721dd3451" translate="yes" xml:space="preserve">
          <source>This function is particularly useful when associations and embeds are cast in the changeset as it will traverse all associations and embeds and place all errors in a series of nested maps.</source>
          <target state="translated">Эта функция особенно полезна,когда ассоциации и вложения в changeset разыгрываются,так как она пройдет через все ассоциации и вложения и поместит все ошибки в серию вложенных карт.</target>
        </trans-unit>
        <trans-unit id="9ea2792030796068ebee3771205dce320fb98fd5" translate="yes" xml:space="preserve">
          <source>This function is primarily used by &lt;a href=&quot;ecto.query#select_merge/3&quot;&gt;&lt;code&gt;Ecto.Query.select_merge/3&lt;/code&gt;&lt;/a&gt; to merge different select clauses.</source>
          <target state="translated">Эта функция в основном используется &lt;a href=&quot;ecto.query#select_merge/3&quot;&gt; &lt;code&gt;Ecto.Query.select_merge/3&lt;/code&gt; &lt;/a&gt; для объединения различных предложений выбора.</target>
        </trans-unit>
        <trans-unit id="95e4d0ba9a962e855d63d60b4fd26e982ea84569" translate="yes" xml:space="preserve">
          <source>This function is used for authorization purposes and it may be invoked outside of the process that effectively runs the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f60f736835987ffe4d869279d98e0a0470fd3a" translate="yes" xml:space="preserve">
          <source>This function is used to work with associations as a whole. For example, if a Post has many Comments, it allows you to add, remove or change all comments at once. If your goal is to simply add a new comment to a post, then it is preferred to do so manually, as we will describe later in the &quot;Example: Adding a comment to a post&quot; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22adf8e4771dc77ddcc4249d7919749c29698a38" translate="yes" xml:space="preserve">
          <source>This function is used to work with associations as a whole. For example, if a Post has many Comments, it allows you to add, remove or change all comments at once. If your goal is to simply add a new comment to a post, then it is preferred to do so manually, as we will describe later in the &amp;ldquo;Example: Adding a comment to a post&amp;rdquo; section.</source>
          <target state="translated">Эта функция используется для работы с ассоциациями в целом. Например, если в сообщении много комментариев, вы можете добавлять, удалять или изменять все комментарии сразу. Если ваша цель - просто добавить новый комментарий к сообщению, то лучше сделать это вручную, как мы опишем позже в разделе &amp;laquo;Пример: добавление комментария к сообщению&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="08eda1f3849525ce418b408dadef19a29c0b6f84" translate="yes" xml:space="preserve">
          <source>This function is used to work with embeds as a whole. For embeds with cardinality one, &lt;code&gt;nil&lt;/code&gt; can be used to remove the existing entry. For embeds with many entries, an empty list may be given instead.</source>
          <target state="translated">Эта функция используется для работы с закладными в целом. Для вложений с числом элементов один можно использовать &lt;code&gt;nil&lt;/code&gt; для удаления существующей записи. Для закладок с большим количеством записей вместо этого может быть предоставлен пустой список.</target>
        </trans-unit>
        <trans-unit id="3dd54b454514d325837202458e298d9589a1ceed" translate="yes" xml:space="preserve">
          <source>This function is useful for removing empty strings sent via HTML forms. If you are providing an API, there is likely no need to invoke &lt;a href=&quot;#scrub_params/2&quot;&gt;&lt;code&gt;scrub_params/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция полезна для удаления пустых строк, отправленных через HTML-формы. Если вы предоставляете API, вероятно, нет необходимости вызывать &lt;a href=&quot;#scrub_params/2&quot;&gt; &lt;code&gt;scrub_params/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64ae2d3a9800574311ce709ebfa7b91aac472431" translate="yes" xml:space="preserve">
          <source>This function is useful for sending boolean values to the server.</source>
          <target state="translated">Эта функция полезна для отправки булевых значений на сервер.</target>
        </trans-unit>
        <trans-unit id="2e8d3ec5712ad07392b313c25f730d33813e39fc" translate="yes" xml:space="preserve">
          <source>This function is useful for:</source>
          <target state="translated">Эта функция полезна:</target>
        </trans-unit>
        <trans-unit id="0f8df1aeec38d6ef055f78ffe52b7fd809b11de3" translate="yes" xml:space="preserve">
          <source>This function is useful in JavaScript responses when there is a need to escape HTML rendered from other templates, like in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd46d36363c15990125532c0d54d1cd70be4c83" translate="yes" xml:space="preserve">
          <source>This function is useful to detect if the client is running on an outdated version of the marked static files. It works by comparing the static paths sent by the client with the one on the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f05751e977e06b61bae3058808ef7801122a3bf" translate="yes" xml:space="preserve">
          <source>This function is useful when the code being invoked crashes and there is a need to verify a particular response was sent even with the crash. It returns a tuple with &lt;code&gt;{status, headers, body}&lt;/code&gt;.</source>
          <target state="translated">Эта функция полезна, когда вызываемый код дает сбой, и есть необходимость проверить, что конкретный ответ был отправлен даже после сбоя. Он возвращает кортеж с &lt;code&gt;{status, headers, body}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feb7b5f249171806db774de8814da72fc6867cc9" translate="yes" xml:space="preserve">
          <source>This function is useful when the multi to be merged requires information from the original multi. Hence the second argument is an anonymous function that receives the multi changes so far. The anonymous function must return another multi.</source>
          <target state="translated">Эта функция полезна в тех случаях,когда для объединяемого мультиплекса требуется информация от оригинального мультиплекса.Следовательно,второй аргумент-анонимная функция,которая получает множественные изменения.Анонимная функция должна возвращать другой мультипликатор.</target>
        </trans-unit>
        <trans-unit id="ea36ab9cf50bba27fd6813a84418b75a89007160" translate="yes" xml:space="preserve">
          <source>This function is useful when you may want to serve different content-types (such as JSON and HTML) from the same routes. However, if you always have distinct routes, you can also disable content negotiation and simply hardcode your format of choice in your route pipelines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ef3241f414eaf2fb4a40b3c68e3fe5a7aa4417" translate="yes" xml:space="preserve">
          <source>This function merges two changesets provided they have been applied to the same data (their &lt;code&gt;:data&lt;/code&gt; field is equal); if the data differs, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised. If one of the changesets has a &lt;code&gt;:repo&lt;/code&gt; field which is not &lt;code&gt;nil&lt;/code&gt;, then the value of that field is used as the &lt;code&gt;:repo&lt;/code&gt; field of the resulting changeset; if both changesets have a non-&lt;code&gt;nil&lt;/code&gt; and different &lt;code&gt;:repo&lt;/code&gt; field, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Эта функция объединяет две ревизии при условии, что они были применены к одним и тем же данным (их поля &lt;code&gt;:data&lt;/code&gt; равны); если данные отличаются, возникает исключение &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; . Если в одном из наборов изменений есть поле &lt;code&gt;:repo&lt;/code&gt; , которое не равно &lt;code&gt;nil&lt;/code&gt; , то значение этого поля используется как поле &lt;code&gt;:repo&lt;/code&gt; результирующего набора изменений; если оба набора изменений имеют поле отличное от &lt;code&gt;nil&lt;/code&gt; и другое &lt;code&gt;:repo&lt;/code&gt; , возникает исключение &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbc0dbbbaa75e1f372b0e07a9f6b951709ad2563" translate="yes" xml:space="preserve">
          <source>This function must be called after the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.CSRFProtection&lt;/code&gt;&lt;/a&gt; plug is invoked. If a token was not yet computed, it will be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d374217596346a6c9bf2274712172feb075b08" translate="yes" xml:space="preserve">
          <source>This function only looks at the &lt;code&gt;:changes&lt;/code&gt; field of the given &lt;code&gt;changeset&lt;/code&gt; and returns &lt;code&gt;{:ok, value}&lt;/code&gt; if the change is present or &lt;code&gt;:error&lt;/code&gt; if it&amp;rsquo;s not.</source>
          <target state="translated">Эта функция просматривает только поле &lt;code&gt;:changes&lt;/code&gt; данного &lt;code&gt;changeset&lt;/code&gt; и возвращает &lt;code&gt;{:ok, value}&lt;/code&gt; если изменение присутствует, или &lt;code&gt;:error&lt;/code&gt; , если его нет.</target>
        </trans-unit>
        <trans-unit id="5e1143e93cf32871e96d09b6d702308f61d09b3a" translate="yes" xml:space="preserve">
          <source>This function only looks at the &lt;code&gt;:changes&lt;/code&gt; field of the given &lt;code&gt;changeset&lt;/code&gt; and returns &lt;code&gt;{:ok, value}&lt;/code&gt; if the change is present or &lt;code&gt;:error&lt;/code&gt; if it's not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8bed5158880c80ee8a08504ebf97b167b84dc1" translate="yes" xml:space="preserve">
          <source>This function overrides the default URL generation pulled from the &lt;code&gt;%Plug.Conn{}&lt;/code&gt;'s endpoint configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cb08d9d2f1cf23b4f2a78d41b863c40f49073a" translate="yes" xml:space="preserve">
          <source>This function raises &lt;a href=&quot;phoenix.notacceptableerror&quot;&gt;&lt;code&gt;Phoenix.NotAcceptableError&lt;/code&gt;&lt;/a&gt;, which is rendered with status 406, whenever the server cannot serve a response in any of the formats expected by the client.</source>
          <target state="translated">Эта функция вызывает &lt;a href=&quot;phoenix.notacceptableerror&quot;&gt; &lt;code&gt;Phoenix.NotAcceptableError&lt;/code&gt; &lt;/a&gt; , которая отображается со статусом 406, когда сервер не может предоставить ответ в любом из форматов, ожидаемых клиентом.</target>
        </trans-unit>
        <trans-unit id="1c663a7b4ad2604d2adc9bea7e89c5bd791f16f9" translate="yes" xml:space="preserve">
          <source>This function reads a chunk of the request body up to a given &lt;code&gt;:length&lt;/code&gt;. If there is more data to be read, then &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; is returned. Otherwise &lt;code&gt;{:ok, body, conn}&lt;/code&gt; is returned. In case of an error reading the socket, &lt;code&gt;{:error, reason}&lt;/code&gt; is returned as per &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt;&lt;code&gt;:gen_tcp.recv/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция читает кусок запроса тела до заданной &lt;code&gt;:length&lt;/code&gt; . Если есть еще данные для чтения, то возвращается &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; . В противном случае возвращается &lt;code&gt;{:ok, body, conn}&lt;/code&gt; . В случае ошибки чтения сокета возвращается &lt;code&gt;{:error, reason}&lt;/code&gt; согласно &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt; &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68ac965b424fbcfc28adb7e70510b4a5060b1986" translate="yes" xml:space="preserve">
          <source>This function reads a chunk of the request body up to a given length (specified by the &lt;code&gt;:length&lt;/code&gt; option). If there is more data to be read, then &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; is returned. Otherwise &lt;code&gt;{:ok, body, conn}&lt;/code&gt; is returned. In case of an error reading the socket, &lt;code&gt;{:error, reason}&lt;/code&gt; is returned as per &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt;&lt;code&gt;:gen_tcp.recv/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция считывает фрагмент тела запроса до заданной длины (заданной параметром &lt;code&gt;:length&lt;/code&gt; ). Если есть еще данные для чтения, то возвращается &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; . В противном случае возвращается &lt;code&gt;{:ok, body, conn}&lt;/code&gt; . В случае ошибки чтения сокета возвращается &lt;code&gt;{:error, reason}&lt;/code&gt; согласно &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt; &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0c8691b7f9dfce0fa8e902a83efb3fb90903475" translate="yes" xml:space="preserve">
          <source>This function removes every key from the session, clearing the session.</source>
          <target state="translated">Данная функция удаляет каждую клавишу из сессии,очищая сессию.</target>
        </trans-unit>
        <trans-unit id="23ea244127c3693a61fb279dd8a8823e78d495c2" translate="yes" xml:space="preserve">
          <source>This function requires the associated data to have been preloaded, except when the parent changeset has been newly build and not yet persisted. Missing data will invoke the &lt;code&gt;:on_replace&lt;/code&gt; behaviour defined on the association.</source>
          <target state="translated">Эта функция требует, чтобы связанные данные были предварительно загружены, за исключением случаев, когда родительский набор изменений был создан заново и еще не сохранен. Отсутствие данных вызовет поведение &lt;code&gt;:on_replace&lt;/code&gt; , определенное для ассоциации.</target>
        </trans-unit>
        <trans-unit id="508ff7af2c7302ba5ea60f62775c6f5a3c9b9900" translate="yes" xml:space="preserve">
          <source>This function requires the associated data to have been preloaded, except when the parent changeset has been newly built and not yet persisted. Missing data will invoke the &lt;code&gt;:on_replace&lt;/code&gt; behaviour defined on the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84382455309fc0aaf784468937d5e8642608c1e5" translate="yes" xml:space="preserve">
          <source>This function should be used when working with the entire association at once (and not a single element of a many-style association) and receiving data external to the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3736933a577a29ee24ad93a05c7c32aef1bea88b" translate="yes" xml:space="preserve">
          <source>This function should be used when working with the entire association at once (and not a single element of a many-style association) and using data external to the application.</source>
          <target state="translated">Эту функцию следует использовать при работе со всей ассоциацией сразу (а не с одним элементом многоуровневой ассоциации)и при использовании данных,внешних по отношению к приложению.</target>
        </trans-unit>
        <trans-unit id="481b5ba0284c556ea198200d20cec067478414db" translate="yes" xml:space="preserve">
          <source>This function should either return &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt; if startup is successful. &lt;code&gt;pid&lt;/code&gt; should be the PID of the top supervisor. &lt;code&gt;state&lt;/code&gt; can be an arbitrary term, and if omitted will default to &lt;code&gt;[]&lt;/code&gt;; if the application is later stopped, &lt;code&gt;state&lt;/code&gt; is passed to the &lt;code&gt;stop/1&lt;/code&gt; callback (see the documentation for the &lt;code&gt;c:stop/1&lt;/code&gt; callback for more information).</source>
          <target state="translated">Эта функция должна либо возвращать &lt;code&gt;{:ok, pid}&lt;/code&gt; либо &lt;code&gt;{:ok, pid, state}&lt;/code&gt; при успешном запуске. &lt;code&gt;pid&lt;/code&gt; должен быть PID верхнего супервизора. &lt;code&gt;state&lt;/code&gt; может быть произвольным термином, и если он не указан, по умолчанию будет &lt;code&gt;[]&lt;/code&gt; ; если приложение позже остановлено, &lt;code&gt;state&lt;/code&gt; передается в функцию обратного вызова &lt;code&gt;stop/1&lt;/code&gt; (дополнительную информацию см. в документации по обратному вызову &lt;code&gt;c:stop/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf1fdd59778e871792165fd9cd597befae6dbe8a" translate="yes" xml:space="preserve">
          <source>This function should return &lt;code&gt;{:ok, value}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; if the key exists in the term, or &lt;code&gt;:error&lt;/code&gt; if the key does not exist in the term.</source>
          <target state="translated">Эта функция должна возвращать &lt;code&gt;{:ok, value}&lt;/code&gt; где &lt;code&gt;value&lt;/code&gt; - это значение под &lt;code&gt;key&lt;/code&gt; если ключ существует в термине, или &lt;code&gt;:error&lt;/code&gt; , если ключ не существует в термине.</target>
        </trans-unit>
        <trans-unit id="5ba272759196f5f4398bb53efebf29cecd454930" translate="yes" xml:space="preserve">
          <source>This function should return:</source>
          <target state="translated">Эта функция должна вернуться:</target>
        </trans-unit>
        <trans-unit id="734b0856ba9ef7d3fe8e856bcb519a57b1180774" translate="yes" xml:space="preserve">
          <source>This function, as well as &lt;a href=&quot;#get/3&quot;&gt;&lt;code&gt;get/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#post/3&quot;&gt;&lt;code&gt;post/3&lt;/code&gt;&lt;/a&gt; and friends, accepts the request body or parameters as last argument:</source>
          <target state="translated">Эта функция, а также &lt;a href=&quot;#get/3&quot;&gt; &lt;code&gt;get/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#post/3&quot;&gt; &lt;code&gt;post/3&lt;/code&gt; &lt;/a&gt; и другие, принимает тело запроса или параметры в качестве последнего аргумента:</target>
        </trans-unit>
        <trans-unit id="206f33c29b6ec02bb699170e45e3a167ce8f68a1" translate="yes" xml:space="preserve">
          <source>This functionality exists mostly for integration with &lt;code&gt;Phoenix.LiveView&lt;/code&gt; that replaces the anonymous function for explicit closing of the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e501818f2a9b8d26ee849f92368c85b2aa84ace" translate="yes" xml:space="preserve">
          <source>This functionality exists mostly for integration with &lt;code&gt;Phoenix.LiveView&lt;/code&gt; that replaces the anonymous function for returning the generated forms instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a9005f28b867008de687c6b297116271dbe0ee" translate="yes" xml:space="preserve">
          <source>This generator uses default options provided in the &lt;code&gt;:generators&lt;/code&gt; configuration of the &lt;code&gt;:phoenix&lt;/code&gt; application. These are the defaults:</source>
          <target state="translated">Этот генератор использует параметры по умолчанию, предоставленные в конфигурации &lt;code&gt;:generators&lt;/code&gt; приложения &lt;code&gt;:phoenix&lt;/code&gt; . Это значения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="a8c79d64b76e704cc3305c267e9609ec954e0a9b" translate="yes" xml:space="preserve">
          <source>This generator uses default options provided in the &lt;code&gt;:generators&lt;/code&gt; configuration of your application. These are the defaults:</source>
          <target state="translated">Этот генератор использует параметры по умолчанию, предоставленные в конфигурации &lt;code&gt;:generators&lt;/code&gt; вашего приложения. Это значения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="ea9fd1bcd7395e4e765f0c8c83f634242ed59708" translate="yes" xml:space="preserve">
          <source>This generator will automatically open the config/config.exs after generation if you have &lt;code&gt;ECTO_EDITOR&lt;/code&gt; set in your environment variable.</source>
          <target state="translated">Этот генератор автоматически откроет config / config.exs после генерации, если в вашей переменной среды установлен &lt;code&gt;ECTO_EDITOR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="799bbac2299c4700ae113704fdd4823ec89feb26" translate="yes" xml:space="preserve">
          <source>This guide assumes that we have generated our new application with Ecto integration and that we will be using PostgreSQL. The introductory guides cover how to get your first application up and running. For instructions on switching to MySQL, please see the &lt;a href=&quot;#using-mysql&quot;&gt;Using MySQL&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9beabe4b707e9a75951987e66a396037df415c99" translate="yes" xml:space="preserve">
          <source>This guide describes how to use these parameters to set up an HTTPS server with Plug, and documents some best-practices and potential pitfalls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351d79dff782082a2ce188e37bb0ce9252eef229" translate="yes" xml:space="preserve">
          <source>This inner representation allows us to render and compose templates easily. For example, if you want to render JSON data, we could do so by adding a &quot;show.json&quot; entry to &lt;code&gt;render/2&lt;/code&gt; in our view:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef1c03d35aad86fcc35b135848f7173bd9a0fa9" translate="yes" xml:space="preserve">
          <source>This inner representation allows us to render and compose templates easily. For example, if you want to render JSON data, we could do so by adding a &amp;ldquo;show.json&amp;rdquo; entry to &lt;code&gt;render/2&lt;/code&gt; in our view:</source>
          <target state="translated">Это внутреннее представление позволяет нам легко визуализировать и составлять шаблоны. Например, если вы хотите отобразить данные JSON, мы могли бы сделать это, добавив запись &amp;laquo;show.json&amp;raquo; в &lt;code&gt;render/2&lt;/code&gt; в нашем представлении:</target>
        </trans-unit>
        <trans-unit id="70ed772bfcabd3597901563673c3cda720c91986" translate="yes" xml:space="preserve">
          <source>This is also what calling &lt;a href=&quot;../phoenix_html/phoenix.html.safe#to_iodata/1&quot;&gt;&lt;code&gt;Phoenix.HTML.Safe.to_iodata/1&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;phoenix.liveview.rendered&quot;&gt;&lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt;&lt;/a&gt; structure returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df51736f8af300b7e83be2bba6d0538a65eaf19" translate="yes" xml:space="preserve">
          <source>This is an implementation of EEx.Engine that guarantees templates are HTML Safe.</source>
          <target state="translated">Это реализация EEx.Engine,которая гарантирует,что шаблоны являются HTML Safe.</target>
        </trans-unit>
        <trans-unit id="22dfd0ec4ef3534510402dea1f9a067863780a64" translate="yes" xml:space="preserve">
          <source>This is available only inside subqueries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5329254754bcb5b1518f7c46c55cd4246cdc7b2b" translate="yes" xml:space="preserve">
          <source>This is best used in conjunction with &lt;code&gt;parent_as&lt;/code&gt; to correlate the subquery with the parent query to test some condition on related rows in a different table. In the above example the query returns posts which have at least one comment that has more than 5 replies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd363ee9be583e8940f3872abf411010d65f4b10" translate="yes" xml:space="preserve">
          <source>This is callback is invoked when a custom type is given to &lt;code&gt;field&lt;/code&gt; with the &lt;code&gt;:autogenerate&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb11a6027445daec6c09612ab24edc4bb15dc55" translate="yes" xml:space="preserve">
          <source>This is callback is invoked when a parameterized type is given to &lt;code&gt;field&lt;/code&gt; with the &lt;code&gt;:autogenerate&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6276fd1995acb9d422ef5b0fccedcd0f49f563" translate="yes" xml:space="preserve">
          <source>This is configured in your application environment like:</source>
          <target state="translated">Это настроено в вашей среде приложений,как:</target>
        </trans-unit>
        <trans-unit id="543130ccea506a07596bda5da2eb43221176545d" translate="yes" xml:space="preserve">
          <source>This is done as a security measure to avoid attacks that attempt to traverse entries with nil columns. To check that value is &lt;code&gt;nil&lt;/code&gt;, use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_nil/1&quot;&gt;&lt;code&gt;is_nil/1&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">Это делается в качестве меры безопасности, чтобы избежать атак, которые пытаются пересечь записи с нулевыми столбцами. Чтобы проверить, что значение равно &lt;code&gt;nil&lt;/code&gt; , используйте вместо этого &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_nil/1&quot;&gt; &lt;code&gt;is_nil/1&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4067008cb24e88317e907e2f01cf3fea3ce7a290" translate="yes" xml:space="preserve">
          <source>This is done by regularly fetching the record from the database, then checking whether another user has made changes to the record &lt;em&gt;only when updating the record&lt;/em&gt;. This behaviour is ideal in situations where the chances of concurrent updates to the same record are low; if they&amp;rsquo;re not, pessimistic locking or other concurrency patterns may be more suited.</source>
          <target state="translated">Это достигается путем регулярного извлечения записи из базы данных и последующей проверки того, внес ли другой пользователь изменения в запись, &lt;em&gt;только при обновлении записи&lt;/em&gt; . Такое поведение идеально подходит в ситуациях, когда вероятность одновременного обновления одной и той же записи невелика; в противном случае более подходящими могут быть пессимистическая блокировка или другие шаблоны параллелизма.</target>
        </trans-unit>
        <trans-unit id="823d31394ade33b7711fd9d9b5d40e1240503c08" translate="yes" xml:space="preserve">
          <source>This is done by regularly fetching the record from the database, then checking whether another user has made changes to the record &lt;em&gt;only when updating the record&lt;/em&gt;. This behaviour is ideal in situations where the chances of concurrent updates to the same record are low; if they're not, pessimistic locking or other concurrency patterns may be more suited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8026b3623dfa096a82605e21a4cd8c802a6f2c" translate="yes" xml:space="preserve">
          <source>This is equivalent to setting the status and the body and then calling &lt;a href=&quot;#send_resp/1&quot;&gt;&lt;code&gt;send_resp/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это эквивалентно установке статуса и тела и последующему вызову &lt;a href=&quot;#send_resp/1&quot;&gt; &lt;code&gt;send_resp/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9ba82c91234fa5021cfb3b5cb56f8799ec54310" translate="yes" xml:space="preserve">
          <source>This is especially useful when working with subqueries, where you may need to refer to a parent binding with &lt;code&gt;parent_as&lt;/code&gt;, which is not known when writing the subquery:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30cd495df7102722d59e1ffd84611b6001636dff" translate="yes" xml:space="preserve">
          <source>This is great, exactly what we want. Note how every route, path helper and controller is properly namespaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c9554f976f86ea7cfddef7a13a078b61322160" translate="yes" xml:space="preserve">
          <source>This is helpful when you are not testing joining the channel and just need the socket.</source>
          <target state="translated">Это полезно,когда вы не тестируете присоединение к каналу и просто нуждаетесь в разъеме.</target>
        </trans-unit>
        <trans-unit id="e67b3c4ca838f0b073d784d2fa79097d1fe7dad2" translate="yes" xml:space="preserve">
          <source>This is invoked only once per socket regardless of the number of transports and should be responsible for setting up any process structure used exclusively by the socket regardless of transports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ca0e35e10c4c620e6434a93de5f315f4cc8c3f" translate="yes" xml:space="preserve">
          <source>This is just what we saw before when we ran &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt;&lt;code&gt;mix phx.gen.schema&lt;/code&gt;&lt;/a&gt;, except here we see a &lt;code&gt;@doc false&lt;/code&gt; above our &lt;code&gt;changeset/2&lt;/code&gt; function. This tells us that while this function is publicly callable, it's not part of the public context API. Callers that build changesets do so via the context API. For example, &lt;code&gt;Accounts.create_user/1&lt;/code&gt; calls into our &lt;code&gt;User.changeset/2&lt;/code&gt; to build the changeset from user input. Callers, such as our controller actions, do not access &lt;code&gt;User.changeset/2&lt;/code&gt; directly. All interaction with our user changesets is done through the public &lt;code&gt;Accounts&lt;/code&gt; context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a657048e2c2cbfd50712010e238e2e21a97516" translate="yes" xml:space="preserve">
          <source>This is known to have a plethora of problems including accessibility, large numbers are converted to exponential notation and scrolling can accidentally increase or decrease the number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575f8d14a96e0e9c2305203019fa9f1c1e03c389" translate="yes" xml:space="preserve">
          <source>This is not intended to be an exhaustive list, as this topic is actually a bit beyond the scope of the current document. The issue is a generic one, not specific to Erlang/Elixir, and further explanations can be found online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0916f452cd067b42f99269461a6e8a22fcd085" translate="yes" xml:space="preserve">
          <source>This is particularly useful when used with &lt;a href=&quot;plug.builder#builder_opts/0&quot;&gt;&lt;code&gt;Plug.Builder.builder_opts/0&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;builder_opts/0&lt;/code&gt; allows us to pass options received when initializing &lt;code&gt;AppRouter&lt;/code&gt; to a specific plug, such as dispatch itself. So if instead of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0146f85b516e587e6b92b0b400db4374bf1c0f28" translate="yes" xml:space="preserve">
          <source>This is significant because we can use the &lt;code&gt;page_path&lt;/code&gt; function in a template to link to the root of our application. We can then use this helper in our templates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e4b6dd8b33a2972a835278b18e46ff4920ac2a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#foreign_key_constraint/3&quot;&gt;&lt;code&gt;foreign_key_constraint/3&lt;/code&gt;&lt;/a&gt; except that the field is inferred from the association definition. This is useful to guarantee that a child will only be created if the parent exists in the database too. Therefore, it only applies to &lt;code&gt;belongs_to&lt;/code&gt; associations.</source>
          <target state="translated">Это похоже на &lt;a href=&quot;#foreign_key_constraint/3&quot;&gt; &lt;code&gt;foreign_key_constraint/3&lt;/code&gt; ,&lt;/a&gt; за исключением того, что поле выводится из определения ассоциации. Это полезно для гарантии того, что дочерний элемент будет создан только в том случае, если родительский элемент также существует в базе данных. Следовательно, это применимо только к ассоциациям &lt;code&gt;belongs_to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02210ecf6e704066e98f3f150578efab0c87344d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#foreign_key_constraint/3&quot;&gt;&lt;code&gt;foreign_key_constraint/3&lt;/code&gt;&lt;/a&gt; except that the field is inferred from the association definition. This is useful to guarantee that parent can only be deleted (or have its primary key changed) if no child exists in the database. Therefore, it only applies to &lt;code&gt;has_*&lt;/code&gt; associations.</source>
          <target state="translated">Это похоже на &lt;a href=&quot;#foreign_key_constraint/3&quot;&gt; &lt;code&gt;foreign_key_constraint/3&lt;/code&gt; ,&lt;/a&gt; за исключением того, что поле выводится из определения ассоциации. Это полезно для гарантии того, что родительский элемент можно удалить (или изменить его первичный ключ), только если дочерний элемент не существует в базе данных. Следовательно, это применимо только к ассоциациям &lt;code&gt;has_*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="246766b43ac065cf7a6813d58181faa7501710d2" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;ecto.query#preload/3&quot;&gt;&lt;code&gt;Ecto.Query.preload/3&lt;/code&gt;&lt;/a&gt; except it allows you to preload structs after they have been fetched from the database.</source>
          <target state="translated">Это похоже на &lt;a href=&quot;ecto.query#preload/3&quot;&gt; &lt;code&gt;Ecto.Query.preload/3&lt;/code&gt; ,&lt;/a&gt; за исключением того, что позволяет предварительно загружать структуры после того, как они были извлечены из базы данных.</target>
        </trans-unit>
        <trans-unit id="e4eed9ef50790eac0932b578ea9d27bff84cfd58" translate="yes" xml:space="preserve">
          <source>This is the documentation for the Phoenix project.</source>
          <target state="translated">Это документация для проекта Феникс.</target>
        </trans-unit>
        <trans-unit id="3ada68d07e24e1da189679d5236f1b2085cd8c85" translate="yes" xml:space="preserve">
          <source>This is the same mechanism provided by &lt;a href=&quot;../phoenix/phoenix.channel&quot;&gt;&lt;code&gt;Phoenix.Channel&lt;/code&gt;&lt;/a&gt;s. Therefore, if your application uses both channels and LiveViews, you can use the same technique to disconnect any stateful connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646640f311b4826df55090d4281da13e20dd6b66" translate="yes" xml:space="preserve">
          <source>This is the standard matrix of HTTP verbs, paths, and controller actions. For a while, this was known as RESTful routes, but most consider this a misnomer nowadays. Let's look at them individually, in a slightly different order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84197d638f69361b43dbeeee6fa00ab6538ceb9" translate="yes" xml:space="preserve">
          <source>This is the task we use to get our application running. It takes no arguments at all. If we pass any in, they will be silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1287cce3e334f0bd268a0fbb70950d2bd00055a6" translate="yes" xml:space="preserve">
          <source>This is the value passed back from &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; and subsequently passed as the last argument to all callbacks. Idiomatically it is a map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1871b378b5a1fb4c4012fd59a4ce5d038f416585" translate="yes" xml:space="preserve">
          <source>This is useful for things like validation hints on form fields, e.g. an empty changeset for a new form. That changeset isn&amp;rsquo;t valid, but we don&amp;rsquo;t want to show errors until an actual user action has been performed.</source>
          <target state="translated">Это полезно для таких вещей, как подсказки по проверке полей формы, например, пустой набор изменений для новой формы. Этот набор изменений недействителен, но мы не хотим отображать ошибки до тех пор, пока не будет выполнено фактическое действие пользователя.</target>
        </trans-unit>
        <trans-unit id="8eac94b23ec614fdc27f65b1253b4162ffa8a109" translate="yes" xml:space="preserve">
          <source>This is useful for things like validation hints on form fields, e.g. an empty changeset for a new form. That changeset isn't valid, but we don't want to show errors until an actual user action has been performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b547124ded5a56cf030283e1096472422e728527" translate="yes" xml:space="preserve">
          <source>This is useful when a specific connection is required for testing a plug or a particular function.</source>
          <target state="translated">Это полезно в тех случаях,когда для тестирования штекера или конкретной функции требуется определенное соединение.</target>
        </trans-unit>
        <trans-unit id="967c2f65e325112d9e81267fb5e803aaad342521" translate="yes" xml:space="preserve">
          <source>This is useful when building the select by hand. It expects all options and one or more select values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc164165494ed01035c2fea10f32c91cf135eaeb" translate="yes" xml:space="preserve">
          <source>This is useful when the whole dataset was already loaded or must be explicitly fetched from elsewhere. The IDs received by the preloading function and the result returned depends on the association type:</source>
          <target state="translated">Это полезно,когда весь набор данных уже загружен или должен быть явно получен из другого места.Идентификаторы,полученные функцией предварительной загрузки,и возвращаемый результат зависят от типа ассоциации:</target>
        </trans-unit>
        <trans-unit id="c1ee8628cd73b8b7149d50d393fe7c8fa56a351b" translate="yes" xml:space="preserve">
          <source>This is useful when you are creating forms that are not backed by any kind of data from the data layer, like a search form.</source>
          <target state="translated">Это полезно,когда вы создаете формы,которые не поддерживаются никакими данными с уровня данных,например,поисковой формой.</target>
        </trans-unit>
        <trans-unit id="0765c6b4474540e333d6f27c42f79680532d7ff2" translate="yes" xml:space="preserve">
          <source>This is useful when you are creating forms that are not backed by any kind of data layer. Let's assume that we're submitting a form to the &lt;code&gt;:new&lt;/code&gt; action in the &lt;code&gt;FooController&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557303ac218e1708373d1b4d8a6f4a9c23b313d1" translate="yes" xml:space="preserve">
          <source>This is useful, for example, to recompile modules that depend on external systems, such as directories, databases, etc. Note if you simply depend on external files, &lt;code&gt;@external_resource&lt;/code&gt; annotation should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf23281d7b92a37b60472183249bb866a988f802" translate="yes" xml:space="preserve">
          <source>This issue can also happen with other helpers, such as &lt;code&gt;content_tag&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f798383afb7474b032be11f12e76fdd26cfd9f6b" translate="yes" xml:space="preserve">
          <source>This layout is used by many parts of your application. However, there is a subsection of your application that wants to also add a sidebar. Let's call it &quot;blog.html&quot;. You can build on top of the existing layout in two steps. First, define the blog layout:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eede1c11892e1de751e301f0909a682510d53c2b" translate="yes" xml:space="preserve">
          <source>This looks good, but there is a problem here. Remember that we wanted both user facing reviews routes &lt;code&gt;/reviews&lt;/code&gt; as well as the admin ones &lt;code&gt;/admin/reviews&lt;/code&gt;. If we now include the user facing reviews in our router under the root scope like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a1ef9e37129dec0a33744ad55541c8ec1d1309" translate="yes" xml:space="preserve">
          <source>This macro accepts a set of options:</source>
          <target state="translated">Данный макрос принимает набор опций:</target>
        </trans-unit>
        <trans-unit id="30cad0a3d348831413868904461ce3cb02695bb7" translate="yes" xml:space="preserve">
          <source>This macro also supports passing a nested block of route definitions. This is helpful for nesting children resources within their parents to generate nested routes.</source>
          <target state="translated">Этот макрос также поддерживает передачу вложенного блока определений маршрута.Это полезно для вложенных ресурсов детей внутри их родителей для создания вложенных маршрутов.</target>
        </trans-unit>
        <trans-unit id="5272cc1708a897442f49d3861c8376d2c1684484" translate="yes" xml:space="preserve">
          <source>This macro doesn&amp;rsquo;t add any guards when adding the new plug to the pipeline; for more information about adding plugs with guards see &lt;code&gt;compile/1&lt;/code&gt;.</source>
          <target state="translated">Этот макрос не добавляет никаких средств защиты при добавлении нового разъема в конвейер; для получения дополнительной информации о добавлении заглушек с защитой см. &lt;code&gt;compile/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84875e3a7e5339034bbbeafae9696406ba8d0be0" translate="yes" xml:space="preserve">
          <source>This macro doesn't add any guards when adding the new plug to the pipeline; for more information about adding plugs with guards see &lt;a href=&quot;#compile/3&quot;&gt;&lt;code&gt;compile/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7e3fdecd39a60479ea64ca6e42ffb064952aa0" translate="yes" xml:space="preserve">
          <source>This macro is similar to &lt;a href=&quot;#select/3&quot;&gt;&lt;code&gt;select/3&lt;/code&gt;&lt;/a&gt; except it may be specified multiple times as long as every entry is a map. This is useful for merging and composing selects. For example:</source>
          <target state="translated">Этот макрос похож на &lt;a href=&quot;#select/3&quot;&gt; &lt;code&gt;select/3&lt;/code&gt; ,&lt;/a&gt; за исключением того, что его можно указывать несколько раз, если каждая запись является картой. Это полезно для объединения и составления выборок. Например:</target>
        </trans-unit>
        <trans-unit id="de8d8b58528e44c756543b77e46f1f172b9e7e02" translate="yes" xml:space="preserve">
          <source>This may accomplish what we want, but now we need to wire up the schema relationships in the &lt;code&gt;Accounts&lt;/code&gt; context to the &lt;code&gt;CMS&lt;/code&gt; author. Worse, we have now taken our isolated &lt;code&gt;Accounts&lt;/code&gt; context and required it to know about a content management system, which in turn knows about &lt;code&gt;Accounts&lt;/code&gt; too. With time, cyclic dependencies would blurry the lines between contexts, which is not what we want for isolated responsibilities in our application. There's a better way to handle these requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80844b87a747d5e664d2490ade69aea11936ad23" translate="yes" xml:space="preserve">
          <source>This may also happen on redirects. If you have a POST request to &lt;code&gt;foo.example.com&lt;/code&gt; that redirects to &lt;code&gt;bar.example.com&lt;/code&gt; with status 307, the token will contain a different host than the one in the request.</source>
          <target state="translated">Это также может произойти при переадресации. Если у вас есть запрос POST к &lt;code&gt;foo.example.com&lt;/code&gt; , который перенаправляет на &lt;code&gt;bar.example.com&lt;/code&gt; со статусом 307, токен будет содержать другой хост, чем тот, который указан в запросе.</target>
        </trans-unit>
        <trans-unit id="45fff2b06c5bcdcfb6cfb7a314ec69dd932215c6" translate="yes" xml:space="preserve">
          <source>This means any HTML code inside the given string won't be escaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4f142c5563004d2613132e5bfe4d91c45a1a1d" translate="yes" xml:space="preserve">
          <source>This means guards can be given to &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">Это означает, что охранники могут быть предоставлены для &lt;code&gt;match&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4e9c6ac4e3bf3b13fcd41f8b0bf87448b7d2126a" translate="yes" xml:space="preserve">
          <source>This means that after each request, &lt;a href=&quot;../plug/plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt;, via &lt;code&gt;:telemetry&lt;/code&gt;, will emit a &quot;stop&quot; event, with a measurement of how long it took to get the response:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ba0c978af1e21d1324664f02c106ebf9733164" translate="yes" xml:space="preserve">
          <source>This means that all routes starting with &lt;code&gt;/jobs&lt;/code&gt; will be sent to the &lt;code&gt;HelloWeb.BackgroundJob.Plug&lt;/code&gt; module. Inside the plug, you can match on subroutes, such as &lt;code&gt;/pending&lt;/code&gt; and &lt;code&gt;/active&lt;/code&gt; that shows the status of certain jobs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fcd9b428f43bc3ceced700d0d499071542798d" translate="yes" xml:space="preserve">
          <source>This means that when working with changesets that are not meant to be persisted to the database, such as schemaless changesets, you may need to explicitly set the action to one specific value. Frameworks such as Phoenix use the action value to define how HTML forms should act.</source>
          <target state="translated">Это означает,что при работе с наборами изменений,которые не предназначены для сохранения в базе данных,например,наборами изменений без схемы,вам может потребоваться явно установить действие на одно конкретное значение.Такие фреймворки,как Phoenix,используют значение действия для определения того,как должны действовать HTML-формы.</target>
        </trans-unit>
        <trans-unit id="202e52fe595d963585538547933f6a4e3cafd0a0" translate="yes" xml:space="preserve">
          <source>This means that whenever the &lt;code&gt;Ecto.Repo.Supervisor&lt;/code&gt; starts, it will emit an event, via &lt;code&gt;:telemetry&lt;/code&gt;, with a measurement of the time at start-up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a058b3195ea17c39bf63ddac4c41f7f9ee1528" translate="yes" xml:space="preserve">
          <source>This means the plugs in the &lt;code&gt;authenticate_user&lt;/code&gt; and &lt;code&gt;ensure_admin&lt;/code&gt; pipelines will be called before the &lt;code&gt;BackgroundJob.Plug&lt;/code&gt; allowing them to send an appropriate response and halt the request accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee54c80446b3760c6fb0a7486f59b47f284f3002" translate="yes" xml:space="preserve">
          <source>This mimics the behaviour existing in clients.</source>
          <target state="translated">Это имитирует поведение,существующее у клиентов.</target>
        </trans-unit>
        <trans-unit id="c496c6a2b0bd7dfb1281705f319360c782f54b15" translate="yes" xml:space="preserve">
          <source>This module also provides functions to enable a secure environment on transports that, at some point, have access to a &lt;a href=&quot;../plug/1.5.1/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот модуль также предоставляет функции, позволяющие создать безопасную среду для транспортов, которые в какой-то момент имеют доступ к &lt;a href=&quot;../plug/1.5.1/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f3ec12e95282c603be600f76b1efa0ba48fef74" translate="yes" xml:space="preserve">
          <source>This module also provides functions to enable a secure environment on transports that, at some point, have access to a &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebb63837f361cbf03a3796451f4fe31cebbd7a9" translate="yes" xml:space="preserve">
          <source>This module also provides functions to simulate leaving and closing a channel. Once you leave or close a channel, because the channel is linked to the test process on join, it will crash the test process:</source>
          <target state="translated">Этот модуль также предоставляет функции для имитации выхода и закрытия канала.Как только вы покидаете или закрываете канал,так как канал связан с процессом тестирования на присоединение,он прерывает процесс тестирования:</target>
        </trans-unit>
        <trans-unit id="85f9b5e0210ecd7fadc5d5b219e6eb2289448aaa" translate="yes" xml:space="preserve">
          <source>This module also specifies a behaviour that all the parsers to be used with Plug should adopt.</source>
          <target state="translated">Этот модуль также определяет поведение,которое должны принять все парсеры,используемые с Plug.</target>
        </trans-unit>
        <trans-unit id="d9c3143248084cc9c9ababd5b063a0b53a122a9b" translate="yes" xml:space="preserve">
          <source>This module can be &lt;code&gt;use&lt;/code&gt;-d into a module in order to build a plug pipeline:</source>
          <target state="translated">Этот модуль можно &lt;code&gt;use&lt;/code&gt; -d в модуле для создания конвейера плагинов:</target>
        </trans-unit>
        <trans-unit id="b51e359d7e48f146d0d1e937d9d0255d91dad914" translate="yes" xml:space="preserve">
          <source>This module can be used in your test cases, like this:</source>
          <target state="translated">Этот модуль может быть использован в ваших тестовых случаях:</target>
        </trans-unit>
        <trans-unit id="29fc81812b5b90ffe59423aab0c8bc729d76484f" translate="yes" xml:space="preserve">
          <source>This module defines a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct and the main functions for working with Plug connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070196252438bbce61c0f717094acdcf2e81b7f0" translate="yes" xml:space="preserve">
          <source>This module defines a &lt;a href=&quot;plug.conn#content&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct and the main functions for working with Plug connections.</source>
          <target state="translated">Этот модуль определяет структуру &lt;a href=&quot;plug.conn#content&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; и основные функции для работы с подключениями Plug.</target>
        </trans-unit>
        <trans-unit id="3a8c2c7d59b4c13115d6ac023bd8ac70e7f55fc3" translate="yes" xml:space="preserve">
          <source>This module describes what is required to build a Phoenix transport. The transport sits between the socket and channels, forwarding client messages to channels and vice-versa.</source>
          <target state="translated">Этот модуль описывает,что требуется для создания транспорта Феникса.Транспорт располагается между сокетами и каналами,переадресовывая клиентские сообщения на каналы и наоборот.</target>
        </trans-unit>
        <trans-unit id="1bf3d32030d6f8a66f143a02bbf8343a335a4b15" translate="yes" xml:space="preserve">
          <source>This module documents each of those macros, providing examples in both the keywords query and pipe expression formats.</source>
          <target state="translated">Данный модуль документирует каждый из этих макросов,предоставляя примеры как в формате запроса по ключевым словам,так и в формате конвейерных выражений.</target>
        </trans-unit>
        <trans-unit id="a4abc0ee1ab071690365f6c903e68103b59a8146" translate="yes" xml:space="preserve">
          <source>This module is commonly used within a &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;plug.router&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; and it wraps the &lt;code&gt;call/2&lt;/code&gt; function.</source>
          <target state="translated">Этот модуль обычно используется в &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;plug.router&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; &lt;/a&gt; и является оболочкой для функции &lt;code&gt;call/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf931afdfdb9158aece8ce5e671b27951b8f8dc7" translate="yes" xml:space="preserve">
          <source>This module is deprecated. To use Cowboy 1 With Plug please include &lt;code&gt;plug_cowboy&lt;/code&gt; version 1.0 or above in your &lt;code&gt;mix.exs&lt;/code&gt; file. It is recommended that you use the &lt;code&gt;Plug.Cowboy&lt;/code&gt; module directly instead of Plug.Adapters.Cowboy.</source>
          <target state="translated">Этот модуль устарел. Чтобы использовать Cowboy 1 With Plug, &lt;code&gt;plug_cowboy&lt;/code&gt; версии 1.0 или выше в свой файл &lt;code&gt;mix.exs&lt;/code&gt; . Рекомендуется использовать модуль &lt;code&gt;Plug.Cowboy&lt;/code&gt; напрямую вместо Plug.Adapters.Cowboy.</target>
        </trans-unit>
        <trans-unit id="4a03284231b4c9beab2d0b3147c2e873d6724e04" translate="yes" xml:space="preserve">
          <source>This module is deprecated. To use Cowboy 2 With Plug please include &lt;code&gt;plug_cowboy&lt;/code&gt; version 2.0 or above in your &lt;code&gt;mix.exs&lt;/code&gt; file. It is recommended that you use the &lt;code&gt;Plug.Cowboy&lt;/code&gt; module directly instead of Plug.Adapters.Cowboy2</source>
          <target state="translated">Этот модуль устарел. Чтобы использовать Cowboy 2 With Plug, &lt;code&gt;plug_cowboy&lt;/code&gt; версии 2.0 или выше в свой файл &lt;code&gt;mix.exs&lt;/code&gt; . Рекомендуется использовать модуль &lt;code&gt;Plug.Cowboy&lt;/code&gt; напрямую вместо Plug.Adapters.Cowboy2.</target>
        </trans-unit>
        <trans-unit id="b1128cd9517be1b80b829d37c77e14445123041b" translate="yes" xml:space="preserve">
          <source>This module is used by Phoenix pubsub adapters to handle their local node subscriptions and it is usually not accessed directly. See &lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt;&lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt;&lt;/a&gt; for an example integration.</source>
          <target state="translated">Этот модуль используется адаптерами Phoenix pubsub для обработки подписок на локальные узлы и обычно не имеет прямого доступа. См. &lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt; &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; &lt;/a&gt; для примера интеграции.</target>
        </trans-unit>
        <trans-unit id="18749daab402c4f9221f76b108eba5a09277b12b" translate="yes" xml:space="preserve">
          <source>This module is used to define the application&amp;rsquo;s main view, which serves as the base for all other views and templates.</source>
          <target state="translated">Этот модуль используется для определения основного представления приложения, которое служит основой для всех других представлений и шаблонов.</target>
        </trans-unit>
        <trans-unit id="6bfcb71b5835a83213d4dfa6ee58017a4845f8d7" translate="yes" xml:space="preserve">
          <source>This module is used to define the application's main view, which serves as the base for all other views and templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd0bbb57a64e46e86f20c8dc2b8b74868181cea" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for reading all files from a particular directory and embedding them into a single module. Imagine you have a directory with templates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4237a22f395fffa8c90b7f272130e1f9c638e3db" translate="yes" xml:space="preserve">
          <source>This module specifies a behaviour that all sockets must implement. &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt; is just one possible implementation of a socket that multiplexes events over multiple channels. Developers can implement their own sockets as long as they implement the behaviour outlined here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c536ba16d8fed4f4c995fae380610c356225909" translate="yes" xml:space="preserve">
          <source>This module will be the public API for all account functionality in our system. For example, in addition to user account management, we may also handle user login credentials, account preferences, and password reset generation. If we look at the &lt;code&gt;list_users/0&lt;/code&gt; function, we can see the private details of user fetching. And it's super simple. We have a call to &lt;code&gt;Repo.all(User)&lt;/code&gt;. We saw how Ecto repo queries worked in &lt;a href=&quot;ecto&quot;&gt;the Ecto guide&lt;/a&gt;, so this call should look familiar. Our &lt;code&gt;list_users&lt;/code&gt; function is a generalized function specifying the &lt;em&gt;intent&lt;/em&gt; of our code &amp;ndash; namely to list users. The details of that intent where we use our Repo to fetch the users from our PostgreSQL database is hidden from our callers. This is a common theme we'll see re-iterated as we use the Phoenix generators. Phoenix will push us to think about where we have different responsibilities in our application, and then to wrap up those different areas behind well-named modules and functions that make the intent of our code clear, while encapsulating the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f8c7a704d8b281a05ab2c2ee94c670ce893f15" translate="yes" xml:space="preserve">
          <source>This must be executed from the process that will effectively operate the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54461d29fcec4b636adb86f49d11ebedc8a4319" translate="yes" xml:space="preserve">
          <source>This operation uses the query cache if one is available.</source>
          <target state="translated">Эта операция использует кэш запросов,если он доступен.</target>
        </trans-unit>
        <trans-unit id="2e6392283fe53096fd6723c6a52bb14c1fbe0eee" translate="yes" xml:space="preserve">
          <source>This operation will return the underlying data with changes regardless if the changeset is valid or not.</source>
          <target state="translated">Эта операция возвращает базовые данные с изменениями,независимо от того,является ли набор изменений действительным или нет.</target>
        </trans-unit>
        <trans-unit id="049c09158996c650e55b8f1ec4561fa180509070" translate="yes" xml:space="preserve">
          <source>This option assumes the project was generated with the &lt;code&gt;--binary-id&lt;/code&gt; option, that sets up models to use &lt;code&gt;binary_id&lt;/code&gt; by default. If that&amp;rsquo;s not the case you can still set all your models to use &lt;code&gt;binary_id&lt;/code&gt; by default, by adding the following to your &lt;code&gt;model&lt;/code&gt; function in &lt;code&gt;web/web.ex&lt;/code&gt; or before the &lt;code&gt;schema&lt;/code&gt; declaration:</source>
          <target state="translated">Этот параметр предполагает, что проект был создан с параметром &lt;code&gt;--binary-id&lt;/code&gt; , который по умолчанию настраивает модели на использование &lt;code&gt;binary_id&lt;/code&gt; . Если это не так, вы все равно можете настроить все свои модели на использование &lt;code&gt;binary_id&lt;/code&gt; по умолчанию, добавив следующее к вашей функции &lt;code&gt;model&lt;/code&gt; в &lt;code&gt;web/web.ex&lt;/code&gt; или перед объявлением &lt;code&gt;schema&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e0391ffae92290b282aabdcb9895807452f2bfe1" translate="yes" xml:space="preserve">
          <source>This option is passed as the &lt;code&gt;:init_mode&lt;/code&gt; to &lt;a href=&quot;plug/plug.builder#compile/3&quot;&gt;&lt;code&gt;Plug.Builder.compile/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fcee5e8373c0151773e4d41d75fd04ea48fab0" translate="yes" xml:space="preserve">
          <source>This plug also fetches query params in the connection through &lt;a href=&quot;plug.conn#fetch_query_params/2&quot;&gt;&lt;code&gt;Plug.Conn.fetch_query_params/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот плагин также получает параметры запроса в соединении через &lt;a href=&quot;plug.conn#fetch_query_params/2&quot;&gt; &lt;code&gt;Plug.Conn.fetch_query_params/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40a4f301d5fad92658d3d0724f2518201be2787a" translate="yes" xml:space="preserve">
          <source>This plug can be mounted in a &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; pipeline as follows:</source>
          <target state="translated">Эта заглушка может быть установлена ​​в трубопровод &lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="f6cd45326cadd9e10a4b5dcc83af5b2968ec6084" translate="yes" xml:space="preserve">
          <source>This plug doesn&amp;rsquo;t accept any options.</source>
          <target state="translated">Эта вилка не допускает никаких опций.</target>
        </trans-unit>
        <trans-unit id="50cd1542f80ce2c27c4180007ab1670d825bb257" translate="yes" xml:space="preserve">
          <source>This plug doesn't accept any options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540542716621eaa96ff36e27e48730d06833088f" translate="yes" xml:space="preserve">
          <source>This plug expects the body parameters to be already parsed and fetched. Those can be fetched with &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот плагин ожидает, что параметры тела уже будут проанализированы и получены. Их можно получить с помощью &lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01da79a8a81b2988c34c2c491464c98d17827644" translate="yes" xml:space="preserve">
          <source>This plug only parses the body if the request method is one of the following:</source>
          <target state="translated">Этот плагин анализирует тело только в том случае,если метод запроса является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="dbc4a6cf27af703236d09b35d3f5b453a3411f43" translate="yes" xml:space="preserve">
          <source>This plug overrides the request&amp;rsquo;s &lt;code&gt;POST&lt;/code&gt; method with the method defined in the &lt;code&gt;_method&lt;/code&gt; request parameter.</source>
          <target state="translated">Этот плагин заменяет метод &lt;code&gt;POST&lt;/code&gt; запроса на метод, определенный в параметре запроса &lt;code&gt;_method&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9183cda5f0f143ddaa1b79b7dc207c527edb3d2" translate="yes" xml:space="preserve">
          <source>This plug overrides the request's &lt;code&gt;POST&lt;/code&gt; method with the method defined in the &lt;code&gt;_method&lt;/code&gt; request parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbb2239965b1d685814f5586def8ff4895965d5" translate="yes" xml:space="preserve">
          <source>This plug will raise &lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt;&lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt;&lt;/a&gt; by default if the request cannot be parsed by any of the given types and the MIME type has not been explicitly accepted with the &lt;code&gt;:pass&lt;/code&gt; option.</source>
          <target state="translated">Этот плагин вызовет &lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt; &lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt; &lt;/a&gt; по умолчанию, если запрос не может быть проанализирован ни одним из заданных типов и тип MIME не был явно принят с параметром &lt;code&gt;:pass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="662ed6e00ff1f8efa3e545b88277587544f54665" translate="yes" xml:space="preserve">
          <source>This plug will raise &lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt;&lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt;&lt;/a&gt; by default if the request cannot be parsed by any of the given types and the MIME type has not been explicity accepted with the &lt;code&gt;:pass&lt;/code&gt; option.</source>
          <target state="translated">Этот плагин вызовет &lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt; &lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt; &lt;/a&gt; по умолчанию, если запрос не может быть проанализирован ни одним из указанных типов и тип MIME не был явно принят с параметром &lt;code&gt;:pass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20bad4ce825285978d82d9c5c3e6eb11442c40e0" translate="yes" xml:space="preserve">
          <source>This plug won&amp;rsquo;t generate tokens automatically. Instead, tokens will be generated only when required by calling &lt;a href=&quot;#get_csrf_token/0&quot;&gt;&lt;code&gt;get_csrf_token/0&lt;/code&gt;&lt;/a&gt;. In case you are generating the token for certain specific URL, you should use &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt;&lt;code&gt;get_csrf_token_for/1&lt;/code&gt;&lt;/a&gt; as that will avoid tokens from being leaked to other applications.</source>
          <target state="translated">Этот плагин не генерирует токены автоматически. Вместо этого токены будут генерироваться только тогда, когда это необходимо, путем вызова &lt;a href=&quot;#get_csrf_token/0&quot;&gt; &lt;code&gt;get_csrf_token/0&lt;/code&gt; &lt;/a&gt; . Если вы генерируете токен для определенного URL-адреса, вам следует использовать &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt; &lt;code&gt;get_csrf_token_for/1&lt;/code&gt; ,так&lt;/a&gt; как это предотвратит утечку токенов в другие приложения.</target>
        </trans-unit>
        <trans-unit id="ebbff7ffc8f75e2adf94800f3c930587cc10fe90" translate="yes" xml:space="preserve">
          <source>This plug won't generate tokens automatically. Instead, tokens will be generated only when required by calling &lt;a href=&quot;#get_csrf_token/0&quot;&gt;&lt;code&gt;get_csrf_token/0&lt;/code&gt;&lt;/a&gt;. In case you are generating the token for certain specific URL, you should use &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt;&lt;code&gt;get_csrf_token_for/1&lt;/code&gt;&lt;/a&gt; as that will avoid tokens from being leaked to other applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c4c29b3d1afbe8ceed819dcb85452fb4b99844" translate="yes" xml:space="preserve">
          <source>This presents a problem, however: only privileged processes can bind to TCP port numbers under 1024, and it is bad idea to run the application as 'root'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d38ed574d39239d3ce1ee54fa402c6b77436c31" translate="yes" xml:space="preserve">
          <source>This process is two-fold:</source>
          <target state="translated">Этот процесс двойной:</target>
        </trans-unit>
        <trans-unit id="a867af678f59d04d7a0076e28e130a1a90e313f4" translate="yes" xml:space="preserve">
          <source>This protocol is used by URL helpers and other parts of the Phoenix stack. For example, when you write:</source>
          <target state="translated">Этот протокол используется URL-помощниками и другими частями стека Phoenix.Например,когда вы пишете:</target>
        </trans-unit>
        <trans-unit id="b21ceddd638e1843ee72cb36616db0e5a04aafff" translate="yes" xml:space="preserve">
          <source>This storage is meant to be used by libraries and frameworks to avoid writing to the user storage (the &lt;code&gt;:assigns&lt;/code&gt; field). It is recommended for libraries/frameworks to prefix the keys with the library name.</source>
          <target state="translated">Это хранилище предназначено для использования библиотеками и фреймворками, чтобы избежать записи в пользовательское хранилище (поле &lt;code&gt;:assigns&lt;/code&gt; ). Для библиотек / фреймворков рекомендуется использовать префикс ключей с именем библиотеки.</target>
        </trans-unit>
        <trans-unit id="bcee46e9d2a4acc15bb7cd9f93742faef542611d" translate="yes" xml:space="preserve">
          <source>This store does not create the ETS table; it expects that an existing named table with public properties is passed as an argument.</source>
          <target state="translated">Это хранилище не создает таблицу ETS;оно ожидает,что в качестве аргумента будет передана существующая именованная таблица с публичными свойствами.</target>
        </trans-unit>
        <trans-unit id="625b9c2d872b70c5c1c2329e2373298bcd36763e" translate="yes" xml:space="preserve">
          <source>This store, however, can be used as an example for creating custom storages, based on Redis, Memcached, or a database itself.</source>
          <target state="translated">Это хранилище,однако,может быть использовано в качестве примера для создания пользовательских хранилищ на основе Redis,Memcached или самой базы данных.</target>
        </trans-unit>
        <trans-unit id="caef9692752dfc364ac9616409959d533077b374" translate="yes" xml:space="preserve">
          <source>This task accepts the same command-line arguments as &lt;code&gt;run&lt;/code&gt;. For additional information, refer to the documentation for &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;Mix.Tasks.Run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта задача принимает те же аргументы командной строки, что и &lt;code&gt;run&lt;/code&gt; . За дополнительной информацией обращайтесь к документации &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;Mix.Tasks.Run&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4685cbdc9dfbc82df635ef6b5492cf1beef5ab7b" translate="yes" xml:space="preserve">
          <source>This task does two things, it creates a digest for our static assets and then compresses them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3709bb1a06688cab88fd712fbb47b0071d18988" translate="yes" xml:space="preserve">
          <source>This task has a single purpose, to show us all the routes defined for a given router. We saw it used extensively in the &lt;a href=&quot;routing&quot;&gt;Routing Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffde0bcebb123a904c4c4eeafe54e75892f6516" translate="yes" xml:space="preserve">
          <source>This task is intended to create a bare Ecto project without web integration, which serves as a core application of your domain for web applications and your greater umbrella platform to integrate with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b654c66530201e2da733b3ab537a9860c5fdd5a9" translate="yes" xml:space="preserve">
          <source>This task is intended to create a bare Phoenix project without database integration, which interfaces with your greater umbrella application(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616b0415ae742d1d7d15218ab99e676b4a35f1b7" translate="yes" xml:space="preserve">
          <source>This task will create the database specified in our repo. By default it will look for the repo named after our application (the one generated with our app unless we opted out of ecto), but we can pass in another repo if we want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc7b8c4356e5eb337a5225b8d22d082a6a6a76d" translate="yes" xml:space="preserve">
          <source>This task will drop the database specified in our repo. By default it will look for the repo named after our application (the one generated with our app unless we opted out of ecto). It will not prompt us to check if we're sure we want to drop the db, so do exercise caution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409b40ea015d00380841d68310ab0678da039272" translate="yes" xml:space="preserve">
          <source>This task will generate a Presence tracker. The module name can be passed as an argument, &lt;code&gt;Presence&lt;/code&gt; is used if no module name is passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d1b8cbdd20775d05499dc18c230d380cd892e5" translate="yes" xml:space="preserve">
          <source>This task will generate a basic Phoenix channel as well a test case for it. It takes the module name for the channel as argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890ecd7a0ef9885062476b818cf0b34cea8d84a4" translate="yes" xml:space="preserve">
          <source>This time around, we used &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt;&lt;code&gt;mix phx.gen.context&lt;/code&gt;&lt;/a&gt;, which is just like &lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt;&lt;code&gt;mix phx.gen.html&lt;/code&gt;&lt;/a&gt;, except it doesn't generate the web files for us. Since we already have controllers and templates for managing users, we can integrate the new credential features into our existing web form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db029b73bc27a4de904b6e1ad6e35f7d5b2ddda5" translate="yes" xml:space="preserve">
          <source>This time we passed the &lt;code&gt;--web&lt;/code&gt; option to the generator. This tells Phoenix what namespace to use for the web modules, such as controllers and views. This is useful when you have conflicting resources in the system, such as our existing &lt;code&gt;PageController&lt;/code&gt;, as well as a way to naturally namespace paths and functionality of different features, like a CMS system. Phoenix instructed us to add a new &lt;code&gt;scope&lt;/code&gt; to the router for a &lt;code&gt;&quot;/cms&quot;&lt;/code&gt; path prefix. Let's copy paste the following into our &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;, but we'll make one modification to the &lt;code&gt;pipe_through&lt;/code&gt; macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5878eb3c414b2f8b0bc85b921219b0b8c00c144" translate="yes" xml:space="preserve">
          <source>This validation is used to check for one specific parameter being true and as such does not require the field to effectively exist in the schema or the data being validated.</source>
          <target state="translated">Эта проверка используется для проверки того,что один конкретный параметр является истинным и поэтому не требует,чтобы поле реально существовало в схеме или чтобы данные проверялись.</target>
        </trans-unit>
        <trans-unit id="d696deb31d0b50d9d5193d12918eed93ff0a69c5" translate="yes" xml:space="preserve">
          <source>This will allow you to cast and update only the association for the given country. The important point for partial changes is that any addresses, which were not preloaded won&amp;rsquo;t be changed.</source>
          <target state="translated">Это позволит вам отображать и обновлять только ассоциацию для данной страны. Важным моментом для частичных изменений является то, что любые адреса, которые не были предварительно загружены, не будут изменены.</target>
        </trans-unit>
        <trans-unit id="a25d158d0047cb15049aa3798895382c7cd6f354" translate="yes" xml:space="preserve">
          <source>This will allow you to cast and update only the association for the given country. The important point for partial changes is that any addresses, which were not preloaded won't be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c8ad2e97ff0533cdfdce33b58a986331978807" translate="yes" xml:space="preserve">
          <source>This will force the token to be deleted once the response is sent.</source>
          <target state="translated">Это заставит маркер быть удаленным после отправки ответа.</target>
        </trans-unit>
        <trans-unit id="c6845572f50f3240fbaa36674696b8cf400c3eda" translate="yes" xml:space="preserve">
          <source>This will result in a migration with an &lt;code&gt;:integer&lt;/code&gt; column of &lt;code&gt;:user_id&lt;/code&gt; and create an index.</source>
          <target state="translated">Это приведет к миграции со столбцом &lt;code&gt;:integer&lt;/code&gt; &lt;code&gt;:user_id&lt;/code&gt; и создаст индекс.</target>
        </trans-unit>
        <trans-unit id="cde93bead76f590b8ac92f4411245903df6471af" translate="yes" xml:space="preserve">
          <source>This will result in a migration with an &lt;code&gt;:integer&lt;/code&gt; column of &lt;code&gt;:user_id&lt;/code&gt; and create an index. It will also generate the appropriate &lt;code&gt;belongs_to&lt;/code&gt; entry in the schema.</source>
          <target state="translated">Это приведет к миграции со столбцом &lt;code&gt;:integer&lt;/code&gt; &lt;code&gt;:user_id&lt;/code&gt; и создаст индекс. Он также сгенерирует соответствующую запись &lt;code&gt;belongs_to&lt;/code&gt; в схеме.</target>
        </trans-unit>
        <trans-unit id="7e29ee867b8709dab14972a2f1549cbc060ff5db" translate="yes" xml:space="preserve">
          <source>This will set up all the correct dependencies and configuration for us automatically. Once we install those dependencies with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;, we'll be ready to begin working with Ecto in our application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4b144557001b546396a316d80e5ba0955281ab" translate="yes" xml:space="preserve">
          <source>This works because both &quot;index.json&quot; and &quot;show.json&quot; builds themselves on top of an internal &quot;page.json&quot; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5fe4ec7110a029f93aee2c49d16dd655e8fb777" translate="yes" xml:space="preserve">
          <source>Those are a lot of words bunched up together. Let's take a look at some examples to untangle their meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a1b1b32231c3e4ff53add950295c72883cbbfb" translate="yes" xml:space="preserve">
          <source>Those functions are imported from two modules:</source>
          <target state="translated">Эти функции импортируются из двух модулей:</target>
        </trans-unit>
        <trans-unit id="6208b0413cd71b1dcc6adedd2bd128dd9d87591a" translate="yes" xml:space="preserve">
          <source>Those guards work like regular Elixir guards and the only variables accessible in the guard are &lt;code&gt;conn&lt;/code&gt;, the &lt;code&gt;action&lt;/code&gt; as an atom and the &lt;code&gt;controller&lt;/code&gt; as an alias.</source>
          <target state="translated">Эти охранники работают как обычные охранники Эликсира, и единственные переменные, доступные в страже, - это &lt;code&gt;conn&lt;/code&gt; , &lt;code&gt;action&lt;/code&gt; как атом и &lt;code&gt;controller&lt;/code&gt; как псевдоним.</target>
        </trans-unit>
        <trans-unit id="f149875499b6816d281bb93f8f7b7be48949a3a5" translate="yes" xml:space="preserve">
          <source>Those values can now be accessed on the connected mount as &lt;a href=&quot;#get_connect_info/1&quot;&gt;&lt;code&gt;get_connect_info/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33c34b9d82c886b7a72a0d75a72202741c4d268" translate="yes" xml:space="preserve">
          <source>Through &lt;em&gt;telemetry&lt;/em&gt;, Phoenix is able to collect metrics and send monitoring events of your application. The &lt;code&gt;lib/hello_web/telemetry.ex&lt;/code&gt; file defines the supervisor responsible for managing the telemetry processes. You can find more information on this topic in the &lt;a href=&quot;telemetry&quot;&gt;Telemetry guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a630c7d1a3b50b97144115174bddba022d807367" translate="yes" xml:space="preserve">
          <source>Time unit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d358d22755c113807898f4d747028acc84c714" translate="yes" xml:space="preserve">
          <source>Timeout while waiting for the request.</source>
          <target state="translated">Таймаут в ожидании запроса.</target>
        </trans-unit>
        <trans-unit id="e399371341816e13494a8f090bb6bc62bee13531" translate="yes" xml:space="preserve">
          <source>To aid debugging on the client when troubleshooting issues, the &lt;code&gt;enableDebug()&lt;/code&gt; and &lt;code&gt;disableDebug()&lt;/code&gt; functions are exposed on the &lt;code&gt;LiveSocket&lt;/code&gt; JavaScript instance. Calling &lt;code&gt;enableDebug()&lt;/code&gt; turns on debug logging which includes LiveView life-cycle and payload events as they come and go from client to server. In practice, you can expose your instance on &lt;code&gt;window&lt;/code&gt; for quick access in the browser's web console, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4909edd3c35b1902875bfd0c83e9c081850f71db" translate="yes" xml:space="preserve">
          <source>To allow the user to download contents that are in memory as a binary or string:</source>
          <target state="translated">Позволяет пользователю загружать содержимое,которое находится в памяти в виде двоичного файла или строки:</target>
        </trans-unit>
        <trans-unit id="e6a6975b062fa8a73779dc6d912719d7498131ee" translate="yes" xml:space="preserve">
          <source>To assert that your channel closes or errors asynchronously, you can monitor the channel process with the tools provided by Elixir, and wait for the &lt;code&gt;:DOWN&lt;/code&gt; message. Imagine an implementation of the &lt;code&gt;handle_info/2&lt;/code&gt; function that closes the channel when it receives &lt;code&gt;:some_message&lt;/code&gt;:</source>
          <target state="translated">Чтобы утверждать, что ваш канал закрывается или происходит асинхронная ошибка, вы можете отслеживать процесс канала с помощью инструментов, предоставляемых Elixir, и ждать сообщения &lt;code&gt;:DOWN&lt;/code&gt; . Представьте себе реализацию функции &lt;code&gt;handle_info/2&lt;/code&gt; , которая закрывает канал при получении &lt;code&gt;:some_message&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="53a832ff355a8bff56d545715860a666b9283a42" translate="yes" xml:space="preserve">
          <source>To authorize a socket in &lt;code&gt;join/3&lt;/code&gt;, return &lt;code&gt;{:ok, socket}&lt;/code&gt;. To refuse authorization in &lt;code&gt;join/3&lt;/code&gt;, return &lt;code&gt;{:error, reply}&lt;/code&gt;.</source>
          <target state="translated">Чтобы авторизовать сокет в &lt;code&gt;join/3&lt;/code&gt; , верните &lt;code&gt;{:ok, socket}&lt;/code&gt; . Чтобы отказаться от авторизации в &lt;code&gt;join/3&lt;/code&gt; , верните &lt;code&gt;{:error, reply}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de3aa50e1fa13ab8540858290ff3bab5cc1ae7a1" translate="yes" xml:space="preserve">
          <source>To authorize a socket, return &lt;code&gt;{:ok, socket}&lt;/code&gt; or &lt;code&gt;{:ok, reply, socket}&lt;/code&gt;. To refuse authorization, return &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68caf8123fc9000c1892d49a830e2a777c1a2f79" translate="yes" xml:space="preserve">
          <source>To avoid race conditions, all code reloads are funneled through a sequential call operation.</source>
          <target state="translated">Чтобы избежать условий гонки,все перезагрузки кода проходят через последовательную операцию вызова.</target>
        </trans-unit>
        <trans-unit id="8adf099970e8f40f42c4a78cc8072bacf109f61f" translate="yes" xml:space="preserve">
          <source>To avoid the repetition of always specifying the types, you may define an &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;. In such cases, Ecto will analyze your queries and automatically cast the interpolated &quot;age&quot; when compared to the &lt;code&gt;u.age&lt;/code&gt; field, as long as the age field is defined with type &lt;code&gt;:integer&lt;/code&gt; in your schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da79393192b9d811f048b628589434c69cfc70f" translate="yes" xml:space="preserve">
          <source>To avoid the repetition of always specifying the types, you may define an &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;. In such cases, Ecto will analyze your queries and automatically cast the interpolated &amp;ldquo;age&amp;rdquo; when compared to the &lt;code&gt;u.age&lt;/code&gt; field, as long as the age field is defined with type &lt;code&gt;:integer&lt;/code&gt; in your schema:</source>
          <target state="translated">Чтобы избежать повторения постоянного указания типов, вы можете определить &lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; . В таких случаях Ecto проанализирует ваши запросы и автоматически &lt;code&gt;u.age&lt;/code&gt; интерполированный &amp;laquo;возраст&amp;raquo; по сравнению с полем u.age , если поле age определено с помощью type &lt;code&gt;:integer&lt;/code&gt; в вашей схеме:</target>
        </trans-unit>
        <trans-unit id="8207ca543301d2f877c271b7b261d6d50b3481d1" translate="yes" xml:space="preserve">
          <source>To capture additional user-defined metadata, the &lt;code&gt;metadata&lt;/code&gt; option for keydown events may be provided to the &lt;code&gt;LiveSocket&lt;/code&gt; constructor. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="671a861e30e1350c320f440b81de252cf52633f6" translate="yes" xml:space="preserve">
          <source>To check if a given value is not nil use:</source>
          <target state="translated">Чтобы проверить,не используется ли заданное значение:</target>
        </trans-unit>
        <trans-unit id="01fee11f0023eae7979272d215e7845252d7aad1" translate="yes" xml:space="preserve">
          <source>To check that we are on Elixir 1.6 and Erlang 20 or later, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d31d5fab3f480e2385850ab0894e631ce9ef5d" translate="yes" xml:space="preserve">
          <source>To complete the web changes, let's display the author when showing a page. First, open up &lt;code&gt;lib/hello_web/views/cms/page_view.ex&lt;/code&gt; and add a helper function to handle formatting the author's name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c397997817b65b5ed32d80d0da887e047de03d3c" translate="yes" xml:space="preserve">
          <source>To convert a single DER-encoded certificate to PEM format: &lt;code&gt;openssl x509 -in server.crt -inform der -out cert.pem&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c91ab4294a0c1228f999e655eeea2400a408db" translate="yes" xml:space="preserve">
          <source>To convert an RSA private key from DER to PEM format: &lt;code&gt;openssl rsa -in privkey.der -inform der -out privkey.pem&lt;/code&gt;. If the private key is a Elliptic Curve key, for use with an ECDSA certificate, replace &lt;code&gt;rsa&lt;/code&gt; with &lt;code&gt;ec&lt;/code&gt;. You may want to add the &lt;code&gt;-aes128&lt;/code&gt; argument to produce an encrypted, password protected PEM file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5971dfca497a6c6184fac2256a6394332e77294b" translate="yes" xml:space="preserve">
          <source>To create a parameterized type, create a module as shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b59c202fb3d6f550fc3db4a98cf2a4a434dded" translate="yes" xml:space="preserve">
          <source>To customize the JSON library, including the following in your &lt;code&gt;config/config.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7347e6fe2acbe195851637b64939807583f935" translate="yes" xml:space="preserve">
          <source>To deny connection, return &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">Чтобы запретить соединение, верните &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2be30a876faae18a5e22e23e0ff825ea8e07d2e2" translate="yes" xml:space="preserve">
          <source>To detect when the page itself has received focus or blur, &lt;code&gt;phx-window-focus&lt;/code&gt; and &lt;code&gt;phx-window-blur&lt;/code&gt; may be specified. These window level events may also be necessary if the element in consideration (most often a &lt;code&gt;div&lt;/code&gt; with no tabindex) cannot receive focus. Like other bindings, &lt;code&gt;phx-value-*&lt;/code&gt; can be provided on the bound element, and those values will be sent as part of the payload. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698f42b33364629b9c00b1979a5fc7ddebd7d515" translate="yes" xml:space="preserve">
          <source>To determine which key has been pressed you should use &lt;code&gt;key&lt;/code&gt; value. The available options can be found on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;MDN&lt;/a&gt; or via the &lt;a href=&quot;https://w3c.github.io/uievents/tools/key-event-viewer.html&quot;&gt;Key Event Viewer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee4e1597fac73b7cdbd9aafc8a4cfde3cac889d" translate="yes" xml:space="preserve">
          <source>To discuss new features in the framework, email the &lt;a href=&quot;https://groups.google.com/group/phoenix-core&quot;&gt;phoenix-core mailing list&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ac5d4ffcf89463b90bde0bceaf630200030aa1" translate="yes" xml:space="preserve">
          <source>To do so, the first step is to mark which assigns are temporary and what values they should be reset to on mount:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f92de1c10aadb6a962f6da37154da77404e61e" translate="yes" xml:space="preserve">
          <source>To do that, we'll use the special EEx tags for executing Elixir expressions - &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt;. Notice that the initial tag has an equals sign like this: &lt;code&gt;&amp;lt;%=&lt;/code&gt; . That means that any Elixir code that goes between those tags will be executed, and the resulting value will replace the tag. If the equals sign were missing, the code would still be executed, but the value would not appear on the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7207faf406837a635de5a70263b6dfda70627f88" translate="yes" xml:space="preserve">
          <source>To do this we modify the &lt;code&gt;index&lt;/code&gt; action as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c26c7d45e6051c71e7fe3c380da3a4f17f88bda" translate="yes" xml:space="preserve">
          <source>To dump the state from the current process and load into another one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1756faaf0ba51188a497e41da02799505ffedbc4" translate="yes" xml:space="preserve">
          <source>To emulate this behaviour, this module provides the idea of recycling. The &lt;a href=&quot;#recycle/1&quot;&gt;&lt;code&gt;recycle/1&lt;/code&gt;&lt;/a&gt; function receives a connection and returns a new connection, similar to the one returned by &lt;a href=&quot;#build_conn/0&quot;&gt;&lt;code&gt;build_conn/0&lt;/code&gt;&lt;/a&gt; with all the response cookies from the previous connection defined as request headers. This is useful when testing multiple routes that require cookies or session to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384f423fceb68dce0e44059e7dc17f0229bd095a" translate="yes" xml:space="preserve">
          <source>To emulate this behaviour, this module provides the idea of recycling. The &lt;a href=&quot;#recycle/1&quot;&gt;&lt;code&gt;recycle/1&lt;/code&gt;&lt;/a&gt; function receives a connection and returns a new connection, similar to the one returned by &lt;a href=&quot;#conn/0&quot;&gt;&lt;code&gt;conn/0&lt;/code&gt;&lt;/a&gt; with all the response cookies from the previous connection defined as request headers. This is useful when testing multiple routes that require cookies or session to work.</source>
          <target state="translated">Чтобы имитировать такое поведение, этот модуль предлагает идею утилизации. Функция &lt;a href=&quot;#recycle/1&quot;&gt; &lt;code&gt;recycle/1&lt;/code&gt; &lt;/a&gt; получает соединение и возвращает новое соединение, подобное тому, которое возвращает &lt;a href=&quot;#conn/0&quot;&gt; &lt;code&gt;conn/0&lt;/code&gt; ,&lt;/a&gt; со всеми ответными куки-файлами из предыдущего соединения, определенными как заголовки запроса. Это полезно при тестировании нескольких маршрутов, для работы которых требуются файлы cookie или сеанс.</target>
        </trans-unit>
        <trans-unit id="091d07c554f0a419f1e21a5c0aae91e5f028e992" translate="yes" xml:space="preserve">
          <source>To encrypt an existing PEM-encoded RSA key use the OpenSSL CLI: &lt;code&gt;openssl rsa -in privkey.pem -out privkey_aes.pem -aes128&lt;/code&gt;. Use &lt;code&gt;ec&lt;/code&gt; instead of &lt;code&gt;rsa&lt;/code&gt; when using an ECDSA certificate. Don't forget to securely erase the unencrypted copy afterwards! Best practice would be to encrypt the file immediately during initial key generation: please refer to the instructions provided by the CA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8e7a44c764d649b22d4767dfb19181500bc611" translate="yes" xml:space="preserve">
          <source>To encrypt, you would do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2c16aad4e09f5b6f276b143ea796814d9ed388" translate="yes" xml:space="preserve">
          <source>To extract a private key from a PKCS#12 file to a PEM file: &lt;code&gt;openssl pkcs12 -in server.p12 -nocerts -nodes -out privkey.pem&lt;/code&gt;. You may want to replace the &lt;code&gt;-nodes&lt;/code&gt; argument with &lt;code&gt;-aes128&lt;/code&gt; to produce an encrypted, password protected PEM file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2808505a7c943eb2ca42f02d966df7c8298102af" translate="yes" xml:space="preserve">
          <source>To extract all certificates from a PKCS#12 file to a PEM file: &lt;code&gt;openssl pkcs12 -in server.p12 -nokeys -out fullchain.pem&lt;/code&gt;. The resulting file contains all certificates from the input file, typically the server certificate and any CA certificates that make up the CA chain. You can split the file into seperate &lt;code&gt;cert.pem&lt;/code&gt; and &lt;code&gt;chain.pem&lt;/code&gt; files using a text editor, or you can just pass &lt;code&gt;certfile: fullchain.pem&lt;/code&gt; to the HTTPS adapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34840b98dd241bba5b79a7b5023d3157b2b9193b" translate="yes" xml:space="preserve">
          <source>To fix this, we can change the password in the environment specific configuration file. For the development environment the password used can be found at the bottom of the &lt;code&gt;config/dev.exs&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7d714947644732e2d22535431e05bc99b95dad" translate="yes" xml:space="preserve">
          <source>To fix this, we need to change the permissions on our &quot;postgres&quot; user in the &lt;code&gt;psql&lt;/code&gt; console to allow database creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5820c90b7b57a2442e1e4a6a440c255446634ff" translate="yes" xml:space="preserve">
          <source>To fix this, we need to change the permissions on our &quot;postgres&quot; user to allow login.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f12d3a42e639e525547c376c3befad88231e53" translate="yes" xml:space="preserve">
          <source>To forgo automatic form recovery, set &lt;code&gt;phx-auto-recover=&quot;ignore&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9add98f21666a54716c50850567b90f96e0b16a8" translate="yes" xml:space="preserve">
          <source>To generate a path to an image hosted in your application &quot;priv/static&quot;, with the &lt;code&gt;@conn&lt;/code&gt; endpoint, use &lt;code&gt;static_path/2&lt;/code&gt; to get a URL with cache control parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31df5e294e6f54107ca6b36caf70de5a703ae9d" translate="yes" xml:space="preserve">
          <source>To generate a path to an image hosted in your application &amp;ldquo;priv/static&amp;rdquo;, use &lt;code&gt;static_path/1&lt;/code&gt; to get a URL with cache control parameters:</source>
          <target state="translated">Чтобы сгенерировать путь к изображению, размещенному в вашем приложении &amp;laquo;priv / static&amp;raquo;, используйте &lt;code&gt;static_path/1&lt;/code&gt; , чтобы получить URL-адрес с параметрами управления кешем:</target>
        </trans-unit>
        <trans-unit id="166e05bfe8272abd2c663bb42e431b56b9c76ee6" translate="yes" xml:space="preserve">
          <source>To generate a path to an image hosted in your application &amp;ldquo;priv/static&amp;rdquo;, with the &lt;code&gt;@conn&lt;/code&gt; endpoint, use &lt;code&gt;static_path/2&lt;/code&gt; to get a URL with cache control parameters:</source>
          <target state="translated">Чтобы сгенерировать путь к изображению, размещенному в вашем приложении &amp;laquo;priv / static&amp;raquo;, с конечной точкой &lt;code&gt;@conn&lt;/code&gt; , используйте &lt;code&gt;static_path/2&lt;/code&gt; для получения URL-адреса с параметрами управления кешем:</target>
        </trans-unit>
        <trans-unit id="da5cf0c3b662f85cf689692d186e495d82685f37" translate="yes" xml:space="preserve">
          <source>To get started, define the module attribute &lt;code&gt;@endpoint&lt;/code&gt; in your test case pointing to your application endpoint.</source>
          <target state="translated">Для начала определите атрибут модуля &lt;code&gt;@endpoint&lt;/code&gt; в вашем тестовом примере, указывающий на конечную точку вашего приложения.</target>
        </trans-unit>
        <trans-unit id="0f00e2408e6e8f684d6ca6cbd6ebed088bfa8147" translate="yes" xml:space="preserve">
          <source>To get started, see our &lt;a href=&quot;phoenix/overview&quot;&gt;overview guides&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba9a108051080537e0193e44354907bb5392a7d" translate="yes" xml:space="preserve">
          <source>To give it a try, let's add this plug to our router:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52a3e3b8dd3d57e8b74bdd60fe023df58eda4ed" translate="yes" xml:space="preserve">
          <source>To handle custom client-side JavaScript when an element is added, updated, or removed by the server, a hook object may be provided with the following life-cycle callbacks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c9f6eff2338b6f7de44ce146c839d9e841d092" translate="yes" xml:space="preserve">
          <source>To handle form changes and submissions, use the &lt;code&gt;phx-change&lt;/code&gt; and &lt;code&gt;phx-submit&lt;/code&gt; events. In general, it is preferred to handle input changes at the form level, where all form fields are passed to the LiveView's callback given any single input change. For example, to handle real-time form validation and saving, your template would use both &lt;code&gt;phx_change&lt;/code&gt; and &lt;code&gt;phx_submit&lt;/code&gt; bindings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="267d7ad17f4eb697f730fe2dade15352df2b644f" translate="yes" xml:space="preserve">
          <source>To handle latent events, any HTML tag can be annotated with &lt;code&gt;phx-disable-with&lt;/code&gt;, which swaps the element's &lt;code&gt;innerText&lt;/code&gt; with the provided value during event submission. For example, the following code would change the &quot;Save&quot; button to &quot;Saving...&quot;, and restore it to &quot;Save&quot; on acknowledgment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c017a576254a552f3b45b37a156813727bf60fc" translate="yes" xml:space="preserve">
          <source>To have coalesce/2 available, just import the module that defines it.</source>
          <target state="translated">Чтобы получить доступ к коалесце/2,просто импортируйте модуль,который его определяет.</target>
        </trans-unit>
        <trans-unit id="e75ef0e9c4fd7b13190431887d04db3dc76e0ef4" translate="yes" xml:space="preserve">
          <source>To hide a fields value from the inspect protocol of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt;, mark the field as &lt;code&gt;redact: true&lt;/code&gt; in the schema, and it will display with the value &lt;code&gt;**redacted**&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855cc0ad003d98da4f4ca9c2d54547a476da02d3" translate="yes" xml:space="preserve">
          <source>To keep things simple, we added both our sign-in and sign-out forms in this template. For our sign-in form, we pass the &lt;code&gt;@conn&lt;/code&gt; directly to &lt;code&gt;form_for&lt;/code&gt;, pointing our form action at &lt;code&gt;session_path(@conn, :create)&lt;/code&gt;. We also pass the &lt;code&gt;as: :user&lt;/code&gt; option which tells Phoenix to wrap the form parameters inside a &lt;code&gt;&quot;user&quot;&lt;/code&gt; key. Next, we used the &lt;code&gt;text_input&lt;/code&gt; and &lt;code&gt;password_input&lt;/code&gt; functions to send up an &lt;code&gt;&quot;email&quot;&lt;/code&gt; and &lt;code&gt;&quot;password&quot;&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ef78913465515a398d685d02fba061196e4bdf" translate="yes" xml:space="preserve">
          <source>To learn more about &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; you can read the &lt;a href=&quot;mix_tasks#phoenix-specific-mix-tasks&quot;&gt;Mix Tasks Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d3efd7490499ce0623a7738176753951ffa31a" translate="yes" xml:space="preserve">
          <source>To learn more about Plugs, see the documentation for &lt;a href=&quot;https://hexdocs.pm/plug&quot;&gt;the Plug project&lt;/a&gt;, which provides many built-in plugs and functionalities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ecc754901c9b7b1612b2347516e5e86c89fd01" translate="yes" xml:space="preserve">
          <source>To load data from non-database sources, use &lt;a href=&quot;ecto#embedded_load/3&quot;&gt;&lt;code&gt;Ecto.embedded_load/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c5bfde6fe357ce410561f8996b3ca30aa626e4" translate="yes" xml:space="preserve">
          <source>To log the status of requests being sent:</source>
          <target state="translated">Журнал состояния отправляемых запросов:</target>
        </trans-unit>
        <trans-unit id="ee680d8d89287bdbf31b386e8103c640bb092faa" translate="yes" xml:space="preserve">
          <source>To log the status of response being sent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84dbd8c1d5f506769b351fa5d09d5ae2afb79fe" translate="yes" xml:space="preserve">
          <source>To make that happen, let's create a new &lt;code&gt;lib/hello_web/controllers/hello_controller.ex&lt;/code&gt; file, and make it look like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba9cdf779e09df433f92db1ffd43f9ee1c2b0dd" translate="yes" xml:space="preserve">
          <source>To make the value label easier to read, we can update our private function to generate more user friendly names. We'll run the value of the &lt;code&gt;:view&lt;/code&gt; through &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#inspect/1&quot;&gt;&lt;code&gt;inspect/1&lt;/code&gt;&lt;/a&gt; to remove the &lt;code&gt;Elixir.&lt;/code&gt; prefix and call another private function to convert the &lt;code&gt;connected?&lt;/code&gt; boolean into human readable text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67920df22e1378273bb126fe074d93ace6df9e19" translate="yes" xml:space="preserve">
          <source>To make this all work, we converted the nested blocks of code and used &lt;code&gt;halt(conn)&lt;/code&gt; whenever we reached a failure path. The &lt;code&gt;halt(conn)&lt;/code&gt; functionality is essential here: it tells Plug that the next plug should not be invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b981e8d2840a199b1a09b482f3875a4d2e4d12a" translate="yes" xml:space="preserve">
          <source>To prevent downgrade attacks, in which an attacker intercepts a plain HTTP request to the server before the redirect to HTTPS takes place, &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; by default sets the '&lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet&quot;&gt;Strict-Transport-Security&lt;/a&gt;' (HSTS) header. This informs the browser that the current site must only ever be accessed over HTTPS, even if the user typed or clicked a plain HTTP URL. This only works if the site is reachable on port 443 (see &lt;a href=&quot;#listening-on-port-443&quot;&gt;Listening on Port 443&lt;/a&gt;, below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc58fd422ebb28e73e66dcbc49fcc7dea92cf94" translate="yes" xml:space="preserve">
          <source>To print the Phoenix installer version, pass &lt;code&gt;-v&lt;/code&gt; or &lt;code&gt;--version&lt;/code&gt;, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c8218895c269e2f70bd1d662ea87120136ac06" translate="yes" xml:space="preserve">
          <source>To protect the private key on disk it is best stored in encrypted PEM format, protected by a password. When configuring a Plug server with an encrypted private key, specify the password using the &lt;code&gt;:password&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f005693574383d47c51cc61b7ad7263f57b279" translate="yes" xml:space="preserve">
          <source>To push out-of-band events to the client, for example to render charting points, one could do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccb94c57dedc205e8813c5305e1507bc38c480d" translate="yes" xml:space="preserve">
          <source>To render the template within the layout, simply call &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt; using the &lt;code&gt;@view_module&lt;/code&gt; and &lt;code&gt;@view_template&lt;/code&gt; assign:</source>
          <target state="translated">Чтобы отобразить шаблон в макете, просто вызовите &lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; &lt;/a&gt; с помощью &lt;code&gt;@view_module&lt;/code&gt; и &lt;code&gt;@view_template&lt;/code&gt; assign:</target>
        </trans-unit>
        <trans-unit id="aa8723d880ffe7172650143b48a2d4553d915169" translate="yes" xml:space="preserve">
          <source>To run &lt;code&gt;phx.server&lt;/code&gt; without checking dependencies, you can run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1965798572eff34dbe863a6ecca7a38fdba4475" translate="yes" xml:space="preserve">
          <source>To see an example of how Phoenix LiveDashboard uses these events to create metrics, visit &lt;a href=&quot;https://hexdocs.pm/phoenix_live_dashboard/metrics.html&quot;&gt;https://hexdocs.pm/phoenix_live_dashboard/metrics.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780f2579e6ee8b79fb5eebbb6a2bad044f0a1da4" translate="yes" xml:space="preserve">
          <source>To see the assign in action, go to the layout in &quot;lib/hello_web/templates/layout/app.html.eex&quot; and add the following close to the main container:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac659bbda0b5959d98ced3480e408112f77540e4" translate="yes" xml:space="preserve">
          <source>To see this in action, let's write a module plug that puts the &lt;code&gt;:locale&lt;/code&gt; key and value into the connection assign for downstream use in other plugs, controller actions, and our views. Put the contents above to a file named &quot;lib/hello_web/plugs/locale.ex&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a700000692ac76dd990fc6ece3a9849d62392d" translate="yes" xml:space="preserve">
          <source>To send a file that is stored inside your application priv directory:</source>
          <target state="translated">Для отправки файла,который хранится в приватном каталоге вашего приложения:</target>
        </trans-unit>
        <trans-unit id="35a9af194f11f81b8d5034792059c6fe96098baa" translate="yes" xml:space="preserve">
          <source>To sign, you would do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fd47beed516022715facac2a1ae8d92a4df5b5" translate="yes" xml:space="preserve">
          <source>To simplify configuration of TLS defaults Plug provides two preconfifured options: &lt;code&gt;cipher_suite: :strong&lt;/code&gt; and &lt;code&gt;cipher_suite: :compatible&lt;/code&gt;. The Ciphers chosen and related configuration come from the OWASP recommendations found here: https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet</source>
          <target state="translated">Чтобы упростить настройку параметров TLS по умолчанию, Plug предоставляет два предварительно настроенных параметра: &lt;code&gt;cipher_suite: :strong&lt;/code&gt; и &lt;code&gt;cipher_suite: :compatible&lt;/code&gt; . Выбранные шифры и соответствующая конфигурация взяты из рекомендаций OWASP, найденных здесь: https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet</target>
        </trans-unit>
        <trans-unit id="0648eaf88db893b2046b349febdc511815782796" translate="yes" xml:space="preserve">
          <source>To simplify configuration of TLS defaults Plug provides two preconfigured options: &lt;code&gt;cipher_suite: :strong&lt;/code&gt; and &lt;code&gt;cipher_suite: :compatible&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f0f28f03a276631d1d8cb8b076f6c25bc731344" translate="yes" xml:space="preserve">
          <source>To simplify configuration of TLS defaults, this function provides two preconfigured options: &lt;code&gt;cipher_suite: :strong&lt;/code&gt; and &lt;code&gt;cipher_suite: :compatible&lt;/code&gt;. The Ciphers chosen and related configuration come from the &lt;a href=&quot;https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet&quot;&gt;OWASP Cipher String Cheat Sheet&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05cfddf3dfec406094311ddae72d16bd5088244a" translate="yes" xml:space="preserve">
          <source>To solve this, all &lt;a href=&quot;phoenix.liveview.rendered&quot;&gt;&lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt;&lt;/a&gt; structs also contain a fingerprint field that uniquely identifies it. If the fingerprints are equal, you have the same template, and therefore it is possible to only transmit its changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fcf5b5fb3d94c82b9314b323af893477190f87" translate="yes" xml:space="preserve">
          <source>To specify private options on &lt;code&gt;match&lt;/code&gt; that can be used by plugs before &lt;code&gt;dispatch&lt;/code&gt; pass an option with key &lt;code&gt;:private&lt;/code&gt; containing a map. Example:</source>
          <target state="translated">Чтобы указать закрытые параметры при &lt;code&gt;match&lt;/code&gt; которые могут использоваться плагинами перед &lt;code&gt;dispatch&lt;/code&gt; передайте параметр с ключом &lt;code&gt;:private&lt;/code&gt; , содержащий карту. Пример:</target>
        </trans-unit>
        <trans-unit id="b3f3f98dc901f9abeb9304c536e620a40b09a54d" translate="yes" xml:space="preserve">
          <source>To specify the endpoint that will provide instrumentation, the first argument can be:</source>
          <target state="translated">Для указания конечной точки,которая будет обеспечивать контрольно-измерительные приборы,первым аргументом может быть:</target>
        </trans-unit>
        <trans-unit id="b1d40c54757f1d4613e7479119437d84155bd019" translate="yes" xml:space="preserve">
          <source>To start a tracker, first add the tracker to your supervision tree:</source>
          <target state="translated">Чтобы запустить трекер,сначала добавьте трекер в дерево наблюдения:</target>
        </trans-unit>
        <trans-unit id="865274f6fae09ebe9585b2086ee27cd4cbdb840c" translate="yes" xml:space="preserve">
          <source>To start, let's think of a function name that describes what we want to accomplish. To authenticate a user by email address, we'll need a way to lookup that user and verify their entered credentials are valid. We can do this by exposing a single function on our &lt;code&gt;Accounts&lt;/code&gt; context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9098d8b92793a95404f15371666be5a41249f2" translate="yes" xml:space="preserve">
          <source>To stop it, we hit &lt;code&gt;ctrl-c&lt;/code&gt; twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d581dcb8a5c7aee4d296819c687a1a0e294823ae" translate="yes" xml:space="preserve">
          <source>To stream data use &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt;&lt;code&gt;Enum.reduce_while/3&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt;&lt;code&gt;Enum.reduce_while/3&lt;/code&gt;&lt;/a&gt; allows aborting the execution if &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;chunk/2&lt;/code&gt;&lt;/a&gt; fails to deliver the chunk of data.</source>
          <target state="translated">Для потоковой передачи данных используйте &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt; &lt;code&gt;Enum.reduce_while/3&lt;/code&gt; &lt;/a&gt; вместо &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt; &lt;code&gt;Enum.reduce_while/3&lt;/code&gt; &lt;/a&gt; позволяет прервать выполнение, если &lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;chunk/2&lt;/code&gt; &lt;/a&gt; не может доставить блок данных.</target>
        </trans-unit>
        <trans-unit id="9fa929e9e71e2e4dc6c3efe3b0fa423875bca234" translate="yes" xml:space="preserve">
          <source>To submit a form along with some with hidden input values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968cfb95ef76146b6409c3b657948cdd5f1f4f75" translate="yes" xml:space="preserve">
          <source>To sum it up:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102bc3a62eadfb6175b1787787fb41a6baa07e87" translate="yes" xml:space="preserve">
          <source>To sum up:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a410cd8f3e812852d23e13de76f2d28e929bd21f" translate="yes" xml:space="preserve">
          <source>To switch adapters, we need to remove the Postgrex dependency and add a new one for Mariaex instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2ee59d6482fe8d57fcc8a0083e0c4366e7446c" translate="yes" xml:space="preserve">
          <source>To template that goes inside the layout will be placed in the &lt;code&gt;@inner_content&lt;/code&gt; assign:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e061ad3871e4c5c14888dba30a6440671c5a6d" translate="yes" xml:space="preserve">
          <source>To test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b1ef54f7afb80af1f92d1a44fccf208e6f5b11" translate="yes" xml:space="preserve">
          <source>To use a precompiled template, create a &lt;code&gt;scripts.html.eex&lt;/code&gt; file in the &lt;code&gt;templates&lt;/code&gt; directory for the corresponding view you want it to render for. For example, for the &lt;code&gt;UserView&lt;/code&gt;, create the &lt;code&gt;scripts.html.eex&lt;/code&gt; file at &lt;code&gt;web/templates/user/&lt;/code&gt;.</source>
          <target state="translated">Чтобы использовать предварительно скомпилированный шаблон, создайте файл &lt;code&gt;scripts.html.eex&lt;/code&gt; в каталоге &lt;code&gt;templates&lt;/code&gt; для соответствующего представления, для которого вы хотите его визуализировать. Например, для &lt;code&gt;UserView&lt;/code&gt; , создайте &lt;code&gt;scripts.html.eex&lt;/code&gt; файл на &lt;code&gt;web/templates/user/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f114bef104473c93c624dc15c134a2506e1bf712" translate="yes" xml:space="preserve">
          <source>To use a precompiled template, create a &lt;code&gt;scripts.html.eex&lt;/code&gt; file in the &lt;code&gt;templates&lt;/code&gt; directory for the corresponding view you want it to render for. For example, for the &lt;code&gt;UserView&lt;/code&gt;, create the &lt;code&gt;scripts.html.eex&lt;/code&gt; file at &lt;code&gt;your_app_web/templates/user/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17a125a5e6e8a005867e5e43c2e03a3bc9ba5a1" translate="yes" xml:space="preserve">
          <source>To use inform for early hints send one or more informs with a status of 103.</source>
          <target state="translated">Чтобы использовать информацию для ранних подсказок,отправьте одну или несколько подсказок со статусом 103.</target>
        </trans-unit>
        <trans-unit id="4c9225f6845b572057c82d533463516a01a74a81" translate="yes" xml:space="preserve">
          <source>To use it as the type for the id in our schema, we can use the &lt;code&gt;@primary_key&lt;/code&gt; module attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c71555f84c848ebd550b0b2837d6569d68c6e857" translate="yes" xml:space="preserve">
          <source>To use it as your PubSub adapter, simply add it to your Endpoint&amp;rsquo;s config:</source>
          <target state="translated">Чтобы использовать его в качестве адаптера PubSub, просто добавьте его в конфигурацию вашей конечной точки:</target>
        </trans-unit>
        <trans-unit id="187cfa2127b5960446298f89ad2cfe623ccc0476" translate="yes" xml:space="preserve">
          <source>To use it, just plug it into the desired module.</source>
          <target state="translated">Чтобы использовать его,просто подключите его к нужному модулю.</target>
        </trans-unit>
        <trans-unit id="2e14f0d8d5504cedce23ae26e51fc49f968cc49d" translate="yes" xml:space="preserve">
          <source>To use it, just plug it into the desired module:</source>
          <target state="translated">Чтобы использовать его,просто подключите его к нужному модулю:</target>
        </trans-unit>
        <trans-unit id="595e3caee2e048e5b6af233064a5c06aa1ae0dd2" translate="yes" xml:space="preserve">
          <source>To use the live layout, update your LiveView to pass the &lt;code&gt;:layout&lt;/code&gt; option to &lt;code&gt;use Phoenix.LiveView&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a467a95e3bae25f66e655cb0e95ae8997b92d46e" translate="yes" xml:space="preserve">
          <source>To use this adapter outside of Phoenix, you must start an instance of this module as part of your supervision tree:</source>
          <target state="translated">Чтобы использовать этот адаптер за пределами Phoenix,вы должны запустить экземпляр этого модуля как часть дерева наблюдения:</target>
        </trans-unit>
        <trans-unit id="c8cc58c102127e1478be2cb62bee842868d8e23c" translate="yes" xml:space="preserve">
          <source>To use this functionality, the first step is to annotate which static files you want to be tracked by LiveView, with the &lt;code&gt;phx-track-static&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117496c10ce2870a7a485406c87644c6a1d5cede" translate="yes" xml:space="preserve">
          <source>To use this plug, just plug it into the desired module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed35357476c8058b977ba69de2188d350955b6b" translate="yes" xml:space="preserve">
          <source>To use this type in a schema field, specify the type and parameters like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be2552a6f37a24285cf8c9a4bbf18c028914ee4" translate="yes" xml:space="preserve">
          <source>To wrap a label around an input, see &lt;a href=&quot;#label/1&quot;&gt;&lt;code&gt;label/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы обернуть метку вокруг входа, см. &lt;a href=&quot;#label/1&quot;&gt; &lt;code&gt;label/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ba8aacdac746a9e58d91fb33fc6cb9465a0339" translate="yes" xml:space="preserve">
          <source>Token generation</source>
          <target state="translated">Поколение Жетонов</target>
        </trans-unit>
        <trans-unit id="f80aa637b7d7bc4574011a6f03ec544bfb7d8aa0" translate="yes" xml:space="preserve">
          <source>Tokens provide a way to generate and verify bearer tokens for use in Channels or API authentication.</source>
          <target state="translated">Токены обеспечивают способ генерации и проверки токенов на предъявителя для использования в каналах или API-аутентификации.</target>
        </trans-unit>
        <trans-unit id="20a6a1c796f4bedac7e31cb355e60cefd679db64" translate="yes" xml:space="preserve">
          <source>Topic Patterns</source>
          <target state="translated">Тематические модели</target>
        </trans-unit>
        <trans-unit id="7ab575de50dde2e85ca0c17176dc52fba2687bb2" translate="yes" xml:space="preserve">
          <source>Topics &amp;amp; Callbacks</source>
          <target state="translated">Темы и обратные вызовы</target>
        </trans-unit>
        <trans-unit id="c05de3133bb80093a252ef28feff7623186b061e" translate="yes" xml:space="preserve">
          <source>Track a channel's process as a presence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="261a0221d2b8ed7abd71a3e4620a5971130fd19b" translate="yes" xml:space="preserve">
          <source>Track an arbitrary process as a presence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ecb082b24a5ab812ebd962ccc4da0fcdfbcfae" translate="yes" xml:space="preserve">
          <source>Tracked presences are grouped by &lt;code&gt;key&lt;/code&gt;, cast as a string. For example, to group each user's channels together, use user IDs as keys. Each presence can be associated with a map of metadata to store small, emphemeral state, such as a user's online status. To store detailed information, see &lt;a href=&quot;#c:fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1815ae87e1ed66b14331696c387c97e3da9eb63" translate="yes" xml:space="preserve">
          <source>Tracker servers use a heartbeat protocol and CRDT to replicate presence information across a cluster in an eventually consistent, conflict-free manner. Under this design, there is no single source of truth or global process. Instead, each node runs one or more &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; servers and node-local changes are replicated across the cluster and handled locally as a diff of changes.</source>
          <target state="translated">Серверы отслеживания используют протокол контрольных сигналов и CRDT для репликации информации о присутствии в кластере согласованным и бесконфликтным образом. В рамках этой схемы нет единого источника истины или глобального процесса. Вместо этого на каждом узле работает один или несколько серверов &lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; ,&lt;/a&gt; и локальные изменения узла реплицируются в кластере и обрабатываются локально как различие изменений.</target>
        </trans-unit>
        <trans-unit id="e426db3c83832b5b1a9b212c38c2b26124ea17c3" translate="yes" xml:space="preserve">
          <source>Tracker shards use a heartbeat protocol and CRDT to replicate presence information across a cluster in an eventually consistent, conflict-free manner. Under this design, there is no single source of truth or global process. Each node runs a pool of &lt;a href=&quot;phoenix.tracker.shard&quot;&gt;&lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt;&lt;/a&gt;s and node-local changes are replicated across the cluster and handled locally as a diff of changes.</source>
          <target state="translated">Осколки трекера используют протокол пульса и CRDT для репликации информации о присутствии в кластере согласованным и бесконфликтным образом. В рамках этой схемы нет единого источника истины или глобального процесса. На каждом узле работает пул &lt;a href=&quot;phoenix.tracker.shard&quot;&gt; &lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt; ,&lt;/a&gt; а локальные изменения узла реплицируются в кластере и обрабатываются локально как разность изменений.</target>
        </trans-unit>
        <trans-unit id="f1a6bb7d4cf7d24a007e92d554e3f03f18d78e05" translate="yes" xml:space="preserve">
          <source>Trackers must implement &lt;code&gt;start_link/1&lt;/code&gt;, &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;handle_diff/2&lt;/code&gt;. The &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback allows the tracker to manage its own state when running within the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; server. The &lt;code&gt;handle_diff&lt;/code&gt; callback is invoked with a diff of presence join and leave events, grouped by topic. As replicas heartbeat and replicate data, the local tracker state is merged with the remote data, and the diff is sent to the callback. The handler can use this information to notify subscribers of events, as done above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386e43727163f9c18a619e32e79443e6e4a3c763" translate="yes" xml:space="preserve">
          <source>Trackers must implement &lt;code&gt;start_link/1&lt;/code&gt;, &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;handle_diff/2&lt;/code&gt;. The &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback allows the tracker to manage its own state when running within the &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; server. The &lt;code&gt;handle_diff&lt;/code&gt; callback is invoked with a diff of presence join and leave events, grouped by topic. As replicas heartbeat and replicate data, the local tracker state is merged with the remote data, and the diff is sent to the callback. The handler can use this information to notify subscribers of events, as done above.</source>
          <target state="translated">Трекеры должны реализовывать &lt;code&gt;start_link/1&lt;/code&gt; , &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;handle_diff/2&lt;/code&gt; . &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; обратных вызов позволяет трекер управлять своим состоянием при работе в &lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; сервере. &lt;code&gt;handle_diff&lt;/code&gt; обратного вызова вызывается с дифф присутствия присоединиться и оставить события, сгруппированные по темам. Когда реплики проверяют пульс и реплицируют данные, состояние локального трекера объединяется с удаленными данными, и разница отправляется в обратный вызов. Обработчик может использовать эту информацию для уведомления подписчиков о событиях, как это было сделано выше.</target>
        </trans-unit>
        <trans-unit id="3a1ce6393d7c243fe58a4abc442faa4d6b63e426" translate="yes" xml:space="preserve">
          <source>Trackers must implement &lt;code&gt;start_link/1&lt;/code&gt;, &lt;code&gt;init/1&lt;/code&gt;, and &lt;code&gt;handle_diff/2&lt;/code&gt;. The &lt;code&gt;init/1&lt;/code&gt; callback allows the tracker to manage its own state when running within the &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; server. The &lt;code&gt;handle_diff&lt;/code&gt; callback is invoked with a diff of presence join and leave events, grouped by topic. As replicas heartbeat and replicate data, the local tracker state is merged with the remote data, and the diff is sent to the callback. The handler can use this information to notify subscribers of events, as done above.</source>
          <target state="translated">Трекеры должны реализовывать &lt;code&gt;start_link/1&lt;/code&gt; , &lt;code&gt;init/1&lt;/code&gt; и &lt;code&gt;handle_diff/2&lt;/code&gt; . &lt;code&gt;init/1&lt;/code&gt; обратных вызов позволяет трекер управлять своим состоянием при работе в &lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; сервере. &lt;code&gt;handle_diff&lt;/code&gt; обратного вызова вызывается с дифф присутствия присоединиться и оставить события, сгруппированные по темам. Когда реплики проверяют пульс и реплицируют данные, состояние локального трекера объединяется с удаленными данными, и разница отправляется в обратный вызов. Обработчик может использовать эту информацию для уведомления подписчиков о событиях, как это было сделано выше.</target>
        </trans-unit>
        <trans-unit id="ec88a8caf33e733f9f82eb74118f40a505db5749" translate="yes" xml:space="preserve">
          <source>Tracking changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd71a4b69dd23e4fec03cebbf6443963a3bb4f1" translate="yes" xml:space="preserve">
          <source>Tracks a presence</source>
          <target state="translated">Отслеживает присутствие</target>
        </trans-unit>
        <trans-unit id="f77d00c25a6c8aa2f028ccd4ee433e0eac247ebb" translate="yes" xml:space="preserve">
          <source>Tracks a presence.</source>
          <target state="translated">Отслеживает присутствие.</target>
        </trans-unit>
        <trans-unit id="4d967b73b508c2dfcc359e0a2212dfc6cf38b5f5" translate="yes" xml:space="preserve">
          <source>Tracks the source prefix in the data storage.</source>
          <target state="translated">Отслеживает исходный префикс в хранилище данных.</target>
        </trans-unit>
        <trans-unit id="04dbde923a480822fb49f6a9f57a11e1e45c2f34" translate="yes" xml:space="preserve">
          <source>Translates a &lt;a href=&quot;phoenix.socket.broadcast&quot;&gt;&lt;code&gt;Phoenix.Socket.Broadcast&lt;/code&gt;&lt;/a&gt; struct to fastlane format</source>
          <target state="translated">Переводит &lt;a href=&quot;phoenix.socket.broadcast&quot;&gt; &lt;code&gt;Phoenix.Socket.Broadcast&lt;/code&gt; &lt;/a&gt; - структуру в FastLane формате</target>
        </trans-unit>
        <trans-unit id="fa2fb74c7c1ff29a1c97955f10736fc44d4c709e" translate="yes" xml:space="preserve">
          <source>Translates to the underlying SQL ILIKE query. This operation is only available on PostgreSQL.</source>
          <target state="translated">Транслирует в основной запрос SQL ILIKE.Эта операция доступна только на PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="5e04600e3ea7e7907ea952ea71a5864369b3424b" translate="yes" xml:space="preserve">
          <source>Translates to the underlying SQL LIKE query, therefore its behaviour is dependent on the database. In particular, PostgreSQL will do a case-sensitive operation, while the majority of other databases will be case-insensitive. For performing a case-insensitive &lt;code&gt;like&lt;/code&gt; in PostgreSQL, see &lt;a href=&quot;#ilike/2&quot;&gt;&lt;code&gt;ilike/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Преобразуется в базовый запрос SQL LIKE, поэтому его поведение зависит от базы данных. В частности, PostgreSQL будет выполнять операцию с учетом регистра, а большинство других баз данных - без учета регистра. Для выполнения без учета регистра, &lt;code&gt;like&lt;/code&gt; в PostgreSQL, см. &lt;a href=&quot;#ilike/2&quot;&gt; &lt;code&gt;ilike/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="892c52a641684add2f2c13d64228138e346b88e9" translate="yes" xml:space="preserve">
          <source>Transports can optionally implement &lt;a href=&quot;#c:handle_control/2&quot;&gt;&lt;code&gt;handle_control/2&lt;/code&gt;&lt;/a&gt; for handling control frames such as &lt;code&gt;:ping&lt;/code&gt; and &lt;code&gt;:pong&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ec8431700d39c092c58101a53cd1456d35e7d7" translate="yes" xml:space="preserve">
          <source>Traverses changeset errors and applies the given function to error messages</source>
          <target state="translated">Обходит ошибки changeset и применяет данную функцию к сообщениям об ошибках.</target>
        </trans-unit>
        <trans-unit id="8cbe92e33468200a0827118c7f3d01b4a4843741" translate="yes" xml:space="preserve">
          <source>Traverses changeset errors and applies the given function to error messages.</source>
          <target state="translated">Обходит ошибки changeset и применяет данную функцию к сообщениям об ошибках.</target>
        </trans-unit>
        <trans-unit id="0f6e81017aaf95b363450b6d7b0752a8fb3d2fef" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;{module, function, args}&lt;/code&gt; can be passed to be invoked each time the plug is checking whether to redirect host. Provided function needs to receive at least one argument (&lt;code&gt;host&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a6dbefab197c1c589aaa284bb9c90aca73a018" translate="yes" xml:space="preserve">
          <source>Two or more consecutive newlines &lt;code&gt;\n\n&lt;/code&gt; or &lt;code&gt;\r\n\r\n&lt;/code&gt; are considered as a paragraph and text between them is wrapped in &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags. One newline &lt;code&gt;\n&lt;/code&gt; or &lt;code&gt;\r\n&lt;/code&gt; is considered as a linebreak and a &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; tag is inserted.</source>
          <target state="translated">Две или более последовательных новой строки &lt;code&gt;\n\n&lt;/code&gt; или &lt;code&gt;\r\n\r\n&lt;/code&gt; считаются абзацем, а текст между ними переносится в теги &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; . Одна новая строка &lt;code&gt;\n&lt;/code&gt; или &lt;code&gt;\r\n&lt;/code&gt; рассматривается как разрыв строки, и вставляется тег &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="154308bd4c8a066d5d9c6258416a1b30f7bd6212" translate="yes" xml:space="preserve">
          <source>Type and subtype are case insensitive while the sensitiveness of params depends on their keys and therefore are not handled by this parser.</source>
          <target state="translated">Тип и подтип не чувствительны к регистру,в то время как чувствительность параметров зависит от их клавиш и поэтому не обрабатываются этим синтаксическим анализатором.</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="2b93aaf665984dcdc2d122fc68d22290dc98430f" translate="yes" xml:space="preserve">
          <source>Types and casting</source>
          <target state="translated">Типы и литьё</target>
        </trans-unit>
        <trans-unit id="fccbdec63f1e673c35ac4ad2b3198a6d03985d97" translate="yes" xml:space="preserve">
          <source>URL can include query parameters to override shared and adapter-specific options &lt;code&gt;ssl&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;pool_timeout&lt;/code&gt;, &lt;code&gt;pool_size&lt;/code&gt;:</source>
          <target state="translated">URL-адрес может включать параметры запроса для переопределения общих и зависящих от адаптера параметров &lt;code&gt;ssl&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;pool_timeout&lt;/code&gt; , &lt;code&gt;pool_size&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2062e8d014f9cc3812946feab252c6f50a8a1a8d" translate="yes" xml:space="preserve">
          <source>URL can include query parameters to override shared and adapter-specific options, like &lt;code&gt;ssl&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;pool_size&lt;/code&gt;. The following example shows how to pass these configuration values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f03837323aab32409bb99c50d6c475179c49df" translate="yes" xml:space="preserve">
          <source>URLs</source>
          <target state="translated">URLs</target>
        </trans-unit>
        <trans-unit id="c936fe014fbf52d248e23e83c4f7c389f5578501" translate="yes" xml:space="preserve">
          <source>UTF-8 encoded &lt;code&gt;string&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; кодировке UTF-8</target>
        </trans-unit>
        <trans-unit id="0541e2d015eef80c9c2da6778b6e2c6a68cb7f30" translate="yes" xml:space="preserve">
          <source>Umbrella projects do not have a default router and therefore always expect a router to be given.</source>
          <target state="translated">Зонтичные проекты не имеют маршрутизатора по умолчанию и поэтому всегда ожидают,что будет дан маршрутизатор.</target>
        </trans-unit>
        <trans-unit id="8768d73251c0569d327c1e364eafb4d5ea1eb2da" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;not&lt;/code&gt; operation</source>
          <target state="translated">Унарная &lt;code&gt;not&lt;/code&gt; операция</target>
        </trans-unit>
        <trans-unit id="ae6d1341c40bcf85b2e3992e163df198136c8fe0" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;not&lt;/code&gt; operation.</source>
          <target state="translated">Унарная &lt;code&gt;not&lt;/code&gt; операция.</target>
        </trans-unit>
        <trans-unit id="8528d9a060404341b909c95a03193ce5217db1fb" translate="yes" xml:space="preserve">
          <source>Uncomment or add the following to this list of children in your Telemetry supervision tree (usually in &lt;code&gt;lib/my_app_web/telemetry.ex&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20734e624a02ccb4b9b198469134b0f85370de0" translate="yes" xml:space="preserve">
          <source>Under other circumstances, you may be testing a view or another layer that requires a connection for processing. For such cases, a connection can be created using the &lt;a href=&quot;#build_conn/3&quot;&gt;&lt;code&gt;build_conn/3&lt;/code&gt;&lt;/a&gt; helper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5c67037bf5470da236e2bdde573521f2424de5" translate="yes" xml:space="preserve">
          <source>Under other circumstances, you may be testing a view or another layer that requires a connection for processing. For such cases, a connection can be created using the &lt;a href=&quot;#conn/3&quot;&gt;&lt;code&gt;conn/3&lt;/code&gt;&lt;/a&gt; helper:</source>
          <target state="translated">В других случаях вы можете тестировать представление или другой уровень, для обработки которого требуется соединение. Для таких случаев соединение можно создать с помощью помощника &lt;a href=&quot;#conn/3&quot;&gt; &lt;code&gt;conn/3&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f1ff53ee2862d2d446a35b1e8111b19a37147a3a" translate="yes" xml:space="preserve">
          <source>Understanding template compilation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c65bf16f98fec621f47e764e587b2f2e1621e5" translate="yes" xml:space="preserve">
          <source>Unexpected scenarios</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a6558018657fa99e805a8a68718f47b7b414d0" translate="yes" xml:space="preserve">
          <source>Unfortunately, different databases provide different guarantees when it comes to case-sensitiveness. For example, in MySQL, comparisons are case-insensitive by default. In Postgres, users can define case insensitive column by using the &lt;code&gt;:citext&lt;/code&gt; type/extension. In your migration:</source>
          <target state="translated">К сожалению, разные базы данных предоставляют разные гарантии чувствительности к регистру. Например, в MySQL сравнения по умолчанию нечувствительны к регистру. В Postgres пользователи могут определять столбец без &lt;code&gt;:citext&lt;/code&gt; регистра, используя тип / расширение : citext . В вашей миграции:</target>
        </trans-unit>
        <trans-unit id="ebda784e9b2848ef9558c97ee4b8fa423fa74c91" translate="yes" xml:space="preserve">
          <source>Union expression returns only unique rows as if each query returned distinct results. This may cause performance penalty. If you need just to combine multiple result sets without removing duplicate rows consider using &lt;a href=&quot;#union_all/2&quot;&gt;&lt;code&gt;union_all/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Выражение Union возвращает только уникальные строки, как если бы каждый запрос возвращал разные результаты. Это может привести к снижению производительности. Если вам нужно просто объединить несколько наборов результатов без удаления повторяющихся строк, рассмотрите возможность использования &lt;a href=&quot;#union_all/2&quot;&gt; &lt;code&gt;union_all/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b3223e5b025350dc7c873af657f6279cba89acf" translate="yes" xml:space="preserve">
          <source>Unique columns can be automatically generated by using:</source>
          <target state="translated">Уникальные колонки могут быть автоматически сгенерированы при использовании:</target>
        </trans-unit>
        <trans-unit id="31a9c9a9da9b4997ddb48f0c0710b0ce5b2a182a" translate="yes" xml:space="preserve">
          <source>Unless held-down keys are required, a better approach is generally to use &lt;code&gt;phx-keyup&lt;/code&gt; bindings which only trigger on key up, thereby being self-limiting. However, &lt;code&gt;phx-keydown&lt;/code&gt; is useful for games and other use cases where a constant press on a key is desired. In such cases, throttle should always be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364ff4689b83184f9cf200c53fb47d7dfe4a19d2" translate="yes" xml:space="preserve">
          <source>Unless you have dozens of columns, this is simpler for the developer, more DB friendly and more efficient in all aspects.</source>
          <target state="translated">Если у вас нет десятков столбцов,это проще для разработчика,более дружелюбный к БД и более эффективный во всех отношениях.</target>
        </trans-unit>
        <trans-unit id="6dbbc01e9238f5b47a1c02fc53c7e8b555358fa3" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the PubSub adapter&amp;rsquo;s topic</source>
          <target state="translated">Отменяет подписку вызывающего абонента от темы адаптера PubSub</target>
        </trans-unit>
        <trans-unit id="482cecc4861f7c77f0cec819a536c79e2d690881" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the PubSub adapter&amp;rsquo;s topic.</source>
          <target state="translated">Отменяет подписку вызывающего абонента от темы адаптера PubSub.</target>
        </trans-unit>
        <trans-unit id="c4431f0ea76c1f1e2f3d65fe926de8de3246221b" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the PubSub adapter's topic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181cb46e23fe9bb176c35f8d9f9e02d873ba1397" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the given topic</source>
          <target state="translated">Отменяет звонящего от данной темы.</target>
        </trans-unit>
        <trans-unit id="dfb3c1161312f219c23d938f551cae6ab3a67d2a" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the given topic.</source>
          <target state="translated">Отменяет звонящего от данной темы.</target>
        </trans-unit>
        <trans-unit id="8e4d4756b56c5c2a38de9c36247d3bf735dff1a1" translate="yes" xml:space="preserve">
          <source>Unsubscribes the pid from the topic</source>
          <target state="translated">Отказывается от темы &quot;Пид&quot;.</target>
        </trans-unit>
        <trans-unit id="937f4447c61b885d2272aeadbcc25a892061149c" translate="yes" xml:space="preserve">
          <source>Unsubscribes the pid from the topic.</source>
          <target state="translated">Отказывается от темы.</target>
        </trans-unit>
        <trans-unit id="f7f95de69369cee5491d0b2318e7e16ee32f3693" translate="yes" xml:space="preserve">
          <source>Untracks a presence</source>
          <target state="translated">Отслеживает присутствие</target>
        </trans-unit>
        <trans-unit id="00a3c6eca2c9c5467d7eda3ff19f2b3a3f0b9f13" translate="yes" xml:space="preserve">
          <source>Untracks a presence.</source>
          <target state="translated">Не обнаруживает присутствия.</target>
        </trans-unit>
        <trans-unit id="f662645adc1966f7f57b2b2a62ac566f868b5e24" translate="yes" xml:space="preserve">
          <source>Up and Running</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb41bed7c754707f32bbce1dc683efccb4519d20" translate="yes" xml:space="preserve">
          <source>Update a channel presence's metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e9810594beffedf05646229838b1d174fadeb7" translate="yes" xml:space="preserve">
          <source>Update a process presence's metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76d18079a076ee34ffc62b5b9bd0909da356dce" translate="yes" xml:space="preserve">
          <source>Updates</source>
          <target state="translated">Updates</target>
        </trans-unit>
        <trans-unit id="efde7464a7ffd43310a0d38ea8d45264ea41ceae" translate="yes" xml:space="preserve">
          <source>Updates a change</source>
          <target state="translated">Обновляет изменение</target>
        </trans-unit>
        <trans-unit id="4960f1d23ffd2b7d1ab51393bbb07ff03fb4eeb5" translate="yes" xml:space="preserve">
          <source>Updates a change.</source>
          <target state="translated">Обновляет изменения.</target>
        </trans-unit>
        <trans-unit id="9e3e9b085b2135f1f85213c1f86af920a1755f04" translate="yes" xml:space="preserve">
          <source>Updates a changeset using its primary key</source>
          <target state="translated">Обновляет набор изменений с помощью своего основного ключа</target>
        </trans-unit>
        <trans-unit id="c93c04e332aa599946d58eaecaa78d3cdd5a2eb1" translate="yes" xml:space="preserve">
          <source>Updates a changeset using its primary key.</source>
          <target state="translated">Обновляет набор изменений,используя его основной ключ.</target>
        </trans-unit>
        <trans-unit id="3385b9dce3c90d599cae02d4653dbca93a29bcc4" translate="yes" xml:space="preserve">
          <source>Updates a presence&amp;rsquo;s metadata</source>
          <target state="translated">Обновляет метаданные присутствия</target>
        </trans-unit>
        <trans-unit id="0acdc22a28ee11a8afdd3431b0315855715fa2bc" translate="yes" xml:space="preserve">
          <source>Updates a presence&amp;rsquo;s metadata.</source>
          <target state="translated">Обновляет метаданные присутствия.</target>
        </trans-unit>
        <trans-unit id="132594d301d9e633427f4d91489bd56edf757c2c" translate="yes" xml:space="preserve">
          <source>Updates a presence's metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01320a0cc1e6fafc6bb2e70c6fddc03bae55710" translate="yes" xml:space="preserve">
          <source>Updates a request header if present, otherwise it sets it to an initial value</source>
          <target state="translated">Обновляет заголовок запроса,если он присутствует,в противном случае он устанавливает его в начальное значение</target>
        </trans-unit>
        <trans-unit id="045227cef9e475014998b6e238302ad6bc1ea08b" translate="yes" xml:space="preserve">
          <source>Updates a request header if present, otherwise it sets it to an initial value.</source>
          <target state="translated">Обновляет заголовок запроса,если он присутствует,в противном случае устанавливает его в начальное значение.</target>
        </trans-unit>
        <trans-unit id="0458896d317ccb81c30dba901118e2743e4a5416" translate="yes" xml:space="preserve">
          <source>Updates a response header if present, otherwise it sets it to an initial value</source>
          <target state="translated">Обновляет заголовок ответа,если он присутствует,в противном случае устанавливает его в начальное значение.</target>
        </trans-unit>
        <trans-unit id="aca7d4e48cb32323eeef9d6da6338f24bc32a47f" translate="yes" xml:space="preserve">
          <source>Updates a response header if present, otherwise it sets it to an initial value.</source>
          <target state="translated">Обновляет заголовок ответа,если он присутствует,в противном случае устанавливает его в начальное значение.</target>
        </trans-unit>
        <trans-unit id="607386542c3c782f031294b17742c0818b532a58" translate="yes" xml:space="preserve">
          <source>Updates a single struct with the given filters</source>
          <target state="translated">Обновляет единую структуру с заданными фильтрами</target>
        </trans-unit>
        <trans-unit id="b883e138c47eee8bc7395bc0ee931698e3b1bac8" translate="yes" xml:space="preserve">
          <source>Updates a single struct with the given filters.</source>
          <target state="translated">Обновляет единую структуру с заданными фильтрами.</target>
        </trans-unit>
        <trans-unit id="c6a6a639373c46aeccd5f9b2b8b38de4b2dae7bd" translate="yes" xml:space="preserve">
          <source>Updates all entries matching the given query with the given values</source>
          <target state="translated">Обновляет все записи,соответствующие заданному запросу,с заданными значениями.</target>
        </trans-unit>
        <trans-unit id="330ebb6cefd9ef9f1f8a72396cfd06403a7c55e1" translate="yes" xml:space="preserve">
          <source>Updates all entries matching the given query with the given values.</source>
          <target state="translated">Обновляет все записи,соответствующие заданному запросу,с заданными значениями.</target>
        </trans-unit>
        <trans-unit id="1c2e283ce7915c1bbb24433633c806a5a301b678" translate="yes" xml:space="preserve">
          <source>Updates an existing key in the socket assigns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7762e945e6baaa0818bffbab49c2f32dcef1ea19" translate="yes" xml:space="preserve">
          <source>Updates are patched to the DOM as usual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9274df775f7c52402be32f42089e570c5a110dfe" translate="yes" xml:space="preserve">
          <source>Updates are used to update the filtered entries. In order for updates to be applied, &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt;&lt;/a&gt; must be invoked.</source>
          <target state="translated">Обновления используются для обновления отфильтрованных записей. Для применения обновлений необходимо вызвать &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt; &lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30d7abe8ce119c87145e38b618e0cb0eb1692bb6" translate="yes" xml:space="preserve">
          <source>Updates the Phoenix project generator locally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34140753c1f89b23cafca5f1dc7b6027ceb0a21" translate="yes" xml:space="preserve">
          <source>Updating of embeds must be done using a changeset for each changed embed.</source>
          <target state="translated">Обновление вложений должно производиться с использованием changeset для каждого измененного вложения.</target>
        </trans-unit>
        <trans-unit id="825dd96949706e54c171f42804e730ef000fc8f8" translate="yes" xml:space="preserve">
          <source>Updating the HTML document title</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde3a12f19329145c5a153296de9637412067eac" translate="yes" xml:space="preserve">
          <source>Uploaded files are stored in a temporary directory and removed from that directory after the process that requested the file dies.</source>
          <target state="translated">Загруженные файлы хранятся во временном каталоге и удаляются из него после того,как процесс,запросивший файл,умирает.</target>
        </trans-unit>
        <trans-unit id="37fa1abd2298ec59d4f7430940833863a90e31b7" translate="yes" xml:space="preserve">
          <source>Upserts</source>
          <target state="translated">Upserts</target>
        </trans-unit>
        <trans-unit id="46c68148d8a37fd928ca23894beb97c2d0282df9" translate="yes" xml:space="preserve">
          <source>Upserts map to &quot;ON CONFLICT&quot; on databases like Postgres and &quot;ON DUPLICATE KEY&quot; on databases such as MySQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f343f4451a0d5b77ecb46c9d17300b873c9ec642" translate="yes" xml:space="preserve">
          <source>Upserts map to &amp;ldquo;ON CONFLICT&amp;rdquo; on databases like Postgres and &amp;ldquo;ON DUPLICATE KEY&amp;rdquo; on databases such as MySQL.</source>
          <target state="translated">Upserts отображает состояние &amp;laquo;ON CONFLICT&amp;raquo; в таких базах данных, как Postgres, и &amp;laquo;ON DUPLICATE KEY&amp;raquo; в таких базах данных, как MySQL.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="translated">Пример использования:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
