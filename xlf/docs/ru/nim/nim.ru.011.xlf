<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="eb68ce2fa4474dfa498dc8618e15328f34f957b8" translate="yes" xml:space="preserve">
          <source>For cross compilation, the compiler invokes a C compiler named like &lt;code&gt;$cpu.$os.$cc&lt;/code&gt; (for example arm.linux.gcc) and the configuration system is used to provide meaningful defaults. For example for &lt;code&gt;ARM&lt;/code&gt; your configuration file should contain something like:</source>
          <target state="translated">Для кросс-компиляции компилятор вызывает компилятор C с именем &lt;code&gt;$cpu.$os.$cc&lt;/code&gt; Cc (например, arm.linux.gcc), и система конфигурации используется для предоставления значимых значений по умолчанию. Например, для &lt;code&gt;ARM&lt;/code&gt; ваш файл конфигурации должен содержать что-то вроде:</target>
        </trans-unit>
        <trans-unit id="bfddb4fd4901c9377aa65c5c53f4fed568adddec" translate="yes" xml:space="preserve">
          <source>For determining a &lt;code&gt;raises&lt;/code&gt; list, the &lt;code&gt;raise&lt;/code&gt; and &lt;code&gt;try&lt;/code&gt; statements of &lt;code&gt;p&lt;/code&gt; are taken into consideration.</source>
          <target state="translated">Для определения &lt;code&gt;raises&lt;/code&gt; список, &lt;code&gt;raise&lt;/code&gt; и &lt;code&gt;try&lt;/code&gt; заявление &lt;code&gt;p&lt;/code&gt; принимается во внимание.</target>
        </trans-unit>
        <trans-unit id="f6433d7fa88d46fa2ef63d15b0a2f1c232846783" translate="yes" xml:space="preserve">
          <source>For each input line we have to create a constant definition (&lt;code&gt;nnkConstDef&lt;/code&gt;) and wrap it inside a constant section (&lt;code&gt;nnkConstSection&lt;/code&gt;). Once these variables are created, we fill them hierarchichally (line 17) like the previous AST dump tree showed: the constant definition is a child of the section definition, and the constant definition has an identifier node, an empty node (we let the compiler figure out the type), and a string literal with the value.</source>
          <target state="translated">Для каждой строки ввода мы должны создать определение константы ( &lt;code&gt;nnkConstDef&lt;/code&gt; ) и заключить его в секцию констант ( &lt;code&gt;nnkConstSection&lt;/code&gt; ). После создания этих переменных мы заполняем их иерархически (строка 17), как показано в предыдущем дереве дампа AST: определение константы является дочерним по отношению к определению раздела, а определение константы имеет узел идентификатора, пустой узел (мы позволяем компилятору выяснить тип) и строковый литерал со значением.</target>
        </trans-unit>
        <trans-unit id="e2287df8e6ff8f1fcddd131d03355087c8ef363b" translate="yes" xml:space="preserve">
          <source>For each token, the parser's &lt;code&gt;kind&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, and &lt;code&gt;val&lt;/code&gt; fields give information about that token. If the token is a long or short option, &lt;code&gt;key&lt;/code&gt; is the option's name, and &lt;code&gt;val&lt;/code&gt; is either the option's value, if provided, or the empty string. For arguments, the &lt;code&gt;key&lt;/code&gt; field contains the argument itself, and &lt;code&gt;val&lt;/code&gt; is unused. To check if the end of the command line has been reached, check if &lt;code&gt;kind&lt;/code&gt; is equal to &lt;code&gt;cmdEnd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d10f6f6e4da7bf81dd537bc78c82cd345945246" translate="yes" xml:space="preserve">
          <source>For easier interoperability with other compiled languages such as C, retrieving the address of a &lt;code&gt;let&lt;/code&gt; variable, a parameter or a &lt;code&gt;for&lt;/code&gt; loop variable, the &lt;code&gt;unsafeAddr&lt;/code&gt; operation can be used:</source>
          <target state="translated">Для облегчения взаимодействия с другими скомпилированными языками , такими как C, извлечением адреса в &lt;code&gt;let&lt;/code&gt; переменной, параметр или &lt;code&gt;for&lt;/code&gt; переменного цикла, то &lt;code&gt;unsafeAddr&lt;/code&gt; операция может быть использована:</target>
        </trans-unit>
        <trans-unit id="da10bc47ce513830b3757fe3c7440fcd62b179cc" translate="yes" xml:space="preserve">
          <source>For either value of &lt;code&gt;skipNonAlpha&lt;/code&gt;, returns false if &lt;code&gt;s&lt;/code&gt; is an empty string.</source>
          <target state="translated">Для любого значения &lt;code&gt;skipNonAlpha&lt;/code&gt; возвращает false, если &lt;code&gt;s&lt;/code&gt; - пустая строка.</target>
        </trans-unit>
        <trans-unit id="e6c82f147503f7c257ef61cf3047e2f8c4af476c" translate="yes" xml:space="preserve">
          <source>For every other call the analysis can determine an exact &lt;code&gt;raises&lt;/code&gt; list.</source>
          <target state="translated">Для каждого второго звонка анализ может составить точный список &lt;code&gt;raises&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e42e98d89a815e38e97e54961734d238a0763f7" translate="yes" xml:space="preserve">
          <source>For every sink parameter &lt;code&gt;x: sink T&lt;/code&gt; the hooks are generated for &lt;code&gt;typeof(x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc513bae3196a45b6b788484cf2f9e6b9080fd1" translate="yes" xml:space="preserve">
          <source>For example C++'s &lt;code&gt;new&lt;/code&gt; operator can be &quot;imported&quot; like this:</source>
          <target state="translated">Например, &lt;code&gt;new&lt;/code&gt; оператор C ++ можно &amp;laquo;импортировать&amp;raquo; следующим образом:</target>
        </trans-unit>
        <trans-unit id="d6943604d0d0031805c4f8cff45ec5239cbec0ac" translate="yes" xml:space="preserve">
          <source>For example on Unix:</source>
          <target state="translated">Например,на Unix:</target>
        </trans-unit>
        <trans-unit id="f46fb3e3b7fdfb1c1f5746b7c3c0d924a5276a3a" translate="yes" xml:space="preserve">
          <source>For example, assume a &lt;code&gt;dir1/foo.nim&lt;/code&gt; that imports a &lt;code&gt;dir2/bar.nim&lt;/code&gt;, have the &lt;code&gt;bar.nim&lt;/code&gt; print out both &lt;code&gt;getProjectPath&lt;/code&gt; and &lt;code&gt;currentSourcePath&lt;/code&gt; outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5093f5246247862415343535a3ea8cef3834a0c" translate="yes" xml:space="preserve">
          <source>For example, if a system had &lt;code&gt;#&lt;/code&gt; as a delimiter, you could do the following to get the tail of the path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da3513cd0ef136598e40fc41ccc6496e8f86d48" translate="yes" xml:space="preserve">
          <source>For example, if a system had &lt;em&gt;#&lt;/em&gt; as a delimiter, you could do the following to get the tail of the path:</source>
          <target state="translated">Например, если в системе используется символ &lt;em&gt;#&lt;/em&gt; в качестве разделителя, вы можете сделать следующее, чтобы получить хвост пути:</target>
        </trans-unit>
        <trans-unit id="0f1d5711f93558dbbd9946c13e3cca40ecd81c0d" translate="yes" xml:space="preserve">
          <source>For example, if you want to match a &lt;code&gt;*&lt;/code&gt; character, you write &lt;code&gt;\*&lt;/code&gt; in the pattern. This escaping action applies whether or not the following character would otherwise be interpreted as a metacharacter, so it is always safe to precede a non-alphanumeric with backslash to specify that it stands for itself. In particular, if you want to match a backslash, you write &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">Например, если вы хотите сопоставить символ &lt;code&gt;*&lt;/code&gt; , вы пишете &lt;code&gt;\*&lt;/code&gt; в шаблоне. Это экранирующее действие применяется независимо от того, интерпретировался бы следующий символ как метасимвол или нет, поэтому всегда безопасно ставить перед не буквенно-цифровым символом обратную косую черту, чтобы указать, что он означает сам себя. В частности, если вы хотите сопоставить обратную косую черту, вы пишете &lt;code&gt;\\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bd116d8eecb1742f2aba0e90a0ed111f48feff3" translate="yes" xml:space="preserve">
          <source>For example, the closest to string &quot;&amp;Auml;u&amp;szlig;erst&quot; in ASCII is &quot;Ausserst&quot;. Some information is lost in this transformation, of course, since several Unicode strings can be transformed in the same ASCII representation. So this is a strictly one-way transformation. However a human reader will probably still be able to guess what original string was meant from the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e8063e111c73956a53cf7043ebd6ff7c73d1a5" translate="yes" xml:space="preserve">
          <source>For example, to generate code for an &lt;span id=&quot;avr_1&quot;&gt;AVR&lt;/span&gt; processor use this command:</source>
          <target state="translated">Например, чтобы сгенерировать код для процессора &lt;span id=&quot;avr_1&quot;&gt;AVR&lt;/span&gt; , используйте эту команду:</target>
        </trans-unit>
        <trans-unit id="d524a00442ffaa71bfebe71d2798beae54e3c6ce" translate="yes" xml:space="preserve">
          <source>For example, with the above mentioned config:</source>
          <target state="translated">Например,с вышеупомянутой конфигурацией:</target>
        </trans-unit>
        <trans-unit id="cf8b8ee94d7ddff05e2d63d37354e348a9214764" translate="yes" xml:space="preserve">
          <source>For example, with the above-mentioned config:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="5a979257c11b99f6ef8da4c81ce4f3101724cf59" translate="yes" xml:space="preserve">
          <source>For example: &quot;..&quot; for POSIX or &quot;::&quot; for the classic Macintosh.</source>
          <target state="translated">Например:&quot;...&quot; для POSIX или &quot;::&quot; для классического Макинтоша.</target>
        </trans-unit>
        <trans-unit id="ce7ab614d3eacbc0791f3fe3e19af3be1ce99832" translate="yes" xml:space="preserve">
          <source>For example: '.' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">Например:&quot;.&quot; для POSIX или &quot;:&quot; для классического Macintosh.</target>
        </trans-unit>
        <trans-unit id="172466eb39b138ca652f86c39241cd5c5c16e5f7" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;&quot;..&quot;&lt;/code&gt; for POSIX or &lt;code&gt;&quot;::&quot;&lt;/code&gt; for the classic Macintosh.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce80f490c4d109b88a7ecf30197ac040d2d1c3b" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'.'&lt;/code&gt; for POSIX or &lt;code&gt;':'&lt;/code&gt; for the classic Macintosh.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037a4a3add4baf2d3ff924d7337a1bbfa00ace3f" translate="yes" xml:space="preserve">
          <source>For examples take a look at the documentation for the modules implementing asynchronous IO. A good place to start is the &lt;a href=&quot;asyncnet&quot;&gt;asyncnet module&lt;/a&gt;.</source>
          <target state="translated">Примеры можно найти в документации по модулям, реализующим асинхронный ввод-вывод. Хорошее место для начала - &lt;a href=&quot;asyncnet&quot;&gt;модуль asyncnet&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1ebac78a3bbe3bfe99348fb588221f4bfac3c17" translate="yes" xml:space="preserve">
          <source>For files an alias for &lt;code&gt;write&lt;/code&gt;. If not specialized further, an alias for &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="989db3b42bc31c2bbd7704de97b6f57d5c9afe15" translate="yes" xml:space="preserve">
          <source>For functional style programming you have different options at your disposal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3abbf1f795d4e9d5c1784083fe048325a83d84" translate="yes" xml:space="preserve">
          <source>For functional style programming you may want to pass &lt;a href=&quot;manual#procedures-anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt; to procs like &lt;code&gt;filter&lt;/code&gt; to reduce typing. Anonymous procs can use &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;the special do notation&lt;/a&gt; which is more convenient in certain situations.</source>
          <target state="translated">Для программирования в функциональном стиле вы можете захотеть передать &lt;a href=&quot;manual#procedures-anonymous-procs&quot;&gt;анонимные процедуры&lt;/a&gt; в такие процедуры, как &lt;code&gt;filter&lt;/code&gt; чтобы уменьшить ввод текста. Анонимные процедуры могут использовать &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;специальную нотацию do,&lt;/a&gt; которая более удобна в определенных ситуациях.</target>
        </trans-unit>
        <trans-unit id="87503a2c24062ef64c2113839dd981902727d48c" translate="yes" xml:space="preserve">
          <source>For further details, see &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Конвертируемое отношение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13b313d692ee716b5f8b3276fdd70745f9ead2a0" translate="yes" xml:space="preserve">
          <source>For high-level wrappers specialized for Linux and BSDs see: &lt;a href=&quot;posix_utils&quot;&gt;posix_utils&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="0f62f66675d36a6676ee88d1387217b9a0cb3dbf" translate="yes" xml:space="preserve">
          <source>For instance, the following directive</source>
          <target state="translated">Например,следующая директива</target>
        </trans-unit>
        <trans-unit id="ebee772072092b992aca9c6d2cc8fa41fdbcc537" translate="yes" xml:space="preserve">
          <source>For internal usage. Do not use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283fb548dad94e8eb61f71a2d771205400c5b6df" translate="yes" xml:space="preserve">
          <source>For interoperability with C see also the &lt;a href=&quot;manual#implementation-specific-pragmas-bitsize-pragma&quot;&gt;bitsize pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8770baa4a92dda2f0c75267da1bf45a501c6f548" translate="yes" xml:space="preserve">
          <source>For iterators, a component of a tuple return type can have a &lt;code&gt;var&lt;/code&gt; type too:</source>
          <target state="translated">Для итераторов компонент возвращаемого типа кортежа также может иметь тип &lt;code&gt;var&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1bec3615cf893c57a0cbb546697b4dd32edca860" translate="yes" xml:space="preserve">
          <source>For let variables the same pragmas are available as for ordinary variables.</source>
          <target state="translated">Для пусть переменных доступны те же прагмы,что и для обычных переменных.</target>
        </trans-unit>
        <trans-unit id="49a6ab6b290c8e19b29832308355873e4c0d7ae9" translate="yes" xml:space="preserve">
          <source>For let variables, the same pragmas are available as for ordinary variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49cb65cc68c3fe05d8b7330df0cdf8005318cfe1" translate="yes" xml:space="preserve">
          <source>For loggers that log to a console or to files, only error and fatal messages will cause their output buffers to be flushed immediately. Use the &lt;a href=&quot;io#flushFile,File&quot;&gt;flushFile proc&lt;/a&gt; to flush the buffer manually if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e60368696919ec36aed35327857c6a7975842e7" translate="yes" xml:space="preserve">
          <source>For loop macro</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ec1a5d2526c1a701579992b7f06bf43e3a282a0" translate="yes" xml:space="preserve">
          <source>For loop macros</source>
          <target state="translated">Для макросов петли</target>
        </trans-unit>
        <trans-unit id="4c0c7feb9fa0ff4f152b87b5bc78bff622fe2f93" translate="yes" xml:space="preserve">
          <source>For more information read &lt;a href=&quot;http://www.unix.com/man-page/posix/3/utimes/&quot;&gt;http://www.unix.com/man-page/posix/3/utimes/&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;http://www.unix.com/man-page/posix/3/utimes/&quot;&gt;Http://www.unix.com/man-page/posix/3/utimes/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26999bb874354b41edf984406af868ff0453d287" translate="yes" xml:space="preserve">
          <source>For more procedures dealing with &lt;code&gt;typedesc&lt;/code&gt;, see &lt;a href=&quot;typetraits&quot;&gt;typetraits module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b270b757b3673b1757f055c08aa37dc2ffdc3b3a" translate="yes" xml:space="preserve">
          <source>For most applications using &lt;code&gt;asyncnet&lt;/code&gt; is the way to go as it builds over all the layers, providing some extra features such as buffering.</source>
          <target state="translated">Для большинства приложений используется &lt;code&gt;asyncnet&lt;/code&gt; , поскольку он строится на всех уровнях, обеспечивая некоторые дополнительные функции, такие как буферизация.</target>
        </trans-unit>
        <trans-unit id="b855e8d2a69b94fb603cd76d8ffd3b97477d2b9d" translate="yes" xml:space="preserve">
          <source>For most purposes you do not need to worry about the &lt;code&gt;Delegate&lt;/code&gt; type. The &lt;code&gt;AsyncSocket&lt;/code&gt; is what you are after. It's a reference to the &lt;code&gt;AsyncSocketObj&lt;/code&gt; object. This object defines events which you should overwrite by your own procedures.</source>
          <target state="translated">В большинстве случаев вам не нужно беспокоиться о типе &lt;code&gt;Delegate&lt;/code&gt; . &lt;code&gt;AsyncSocket&lt;/code&gt; является то , что вы после этого . Это ссылка на объект &lt;code&gt;AsyncSocketObj&lt;/code&gt; . Этот объект определяет события, которые вы должны перезаписать своими собственными процедурами.</target>
        </trans-unit>
        <trans-unit id="82c56a62c887a5008858ef06fc31221465f85713" translate="yes" xml:space="preserve">
          <source>For non ordinal types it is not possible to list every possible value and so these always require an &lt;code&gt;else&lt;/code&gt; part.</source>
          <target state="translated">Для не порядковых типов невозможно перечислить все возможные значения, поэтому для них всегда требуется часть &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="829c51c0d379c6a48e2d4b80c8983380a75c1843" translate="yes" xml:space="preserve">
          <source>For non-ordinal types, it is not possible to list every possible value and so these always require an &lt;code&gt;else&lt;/code&gt; part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b8bbe837ee8842537829c10888fa08ecf522a6" translate="yes" xml:space="preserve">
          <source>For now, a closure iterator cannot be evaluated at compile time.</source>
          <target state="translated">Пока итератор закрытия не может быть вычислен во время компиляции.</target>
        </trans-unit>
        <trans-unit id="60442f2e1ea7e96188f7e824d5499a2b5d0cca4e" translate="yes" xml:space="preserve">
          <source>For now, a closure iterator cannot be executed at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d429d625fe5e6a8fac368190dac2b15a574c80" translate="yes" xml:space="preserve">
          <source>For object oriented programming, the syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. The parentheses can be omitted if there are no remaining arguments: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="translated">Для объектно-ориентированного программирования вместо &lt;code&gt;method(obj, args)&lt;/code&gt; можно использовать синтаксис &lt;code&gt;obj.method(args)&lt;/code&gt; args) . Скобки можно опустить, если не осталось аргументов: &lt;code&gt;obj.len&lt;/code&gt; (вместо &lt;code&gt;len(obj)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfb03b9201a2dc62164a5ee1c24ca9a191e921f2" translate="yes" xml:space="preserve">
          <source>For object-oriented programming, the syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. The parentheses can be omitted if there are no remaining arguments: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e047dc8cf0cf0c6f8e9fbc9b5e9a48f6934f18d4" translate="yes" xml:space="preserve">
          <source>For parameters it currently creates implicitly generic routines:</source>
          <target state="translated">Для параметров он в настоящее время создает неявно общие рутины:</target>
        </trans-unit>
        <trans-unit id="0381d3dfe342faa183e25e1ee71de71a0859eee8" translate="yes" xml:space="preserve">
          <source>For procedures $1 is the return type of the procedure, $2 is the name of the procedure and $3 is the parameter list.</source>
          <target state="translated">Для процедур $1-тип возврата,$2-название процедуры,$3-список параметров.</target>
        </trans-unit>
        <trans-unit id="34556ac1ba7d733468b2f993f99301502888774e" translate="yes" xml:space="preserve">
          <source>For reasons of type safety and implementation simplicity the expression that &lt;code&gt;spawn&lt;/code&gt; takes is restricted:</source>
          <target state="translated">Из соображений безопасности типов и простоты реализации выражение, которое принимает &lt;code&gt;spawn&lt;/code&gt; , ограничено:</target>
        </trans-unit>
        <trans-unit id="531f693384cd4ad63c34772dfec0f60d10560ced" translate="yes" xml:space="preserve">
          <source>For server sockets the only event you need to worry about is the &lt;code&gt;handleAccept&lt;/code&gt; event, in your handleAccept proc you should call &lt;code&gt;accept&lt;/code&gt; on the server socket which will give you the client which is connecting. You should then set any events that you want to use on that client and add it to your dispatcher using the &lt;code&gt;register&lt;/code&gt; procedure.</source>
          <target state="translated">Для серверных сокетов единственное событие, о котором вам нужно беспокоиться, - это событие &lt;code&gt;handleAccept&lt;/code&gt; , в вашей процедуре handleAccept вы должны вызвать &lt;code&gt;accept&lt;/code&gt; на серверном сокете, который предоставит вам подключающегося клиента. Затем вы должны установить любые события, которые вы хотите использовать на этом клиенте, и добавить их в диспетчер с помощью процедуры &lt;code&gt;register&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38d9bef073eca3a25be73089c4f87edb342cf60c" translate="yes" xml:space="preserve">
          <source>For statement</source>
          <target state="translated">Для заявления</target>
        </trans-unit>
        <trans-unit id="98762f11c3ec90831e05ecce839645b778fc2401" translate="yes" xml:space="preserve">
          <source>For strict functions it is then enforced that there is no graph that is both mutated and has an element that is an immutable parameter (that is a parameter that is not of type &lt;code&gt;var T&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e66b9d8bd4ebf421c876d84099cdc2470a333b" translate="yes" xml:space="preserve">
          <source>For strings and numeric types the optional argument is a so-called &quot;standard format specifier&quot;.</source>
          <target state="translated">Для строк и числовых типов необязательным аргументом является так называемый &quot;спецификатор стандартного формата&quot;.</target>
        </trans-unit>
        <trans-unit id="b2b62c1266c113a9bc445db1d2caf01166f03f95" translate="yes" xml:space="preserve">
          <source>For targets with very restricted memory, it might be beneficial to pass some additional flags to both the Nim compiler and the C compiler and/or linker to optimize the build for size. For example, the following flags can be used when targeting a gcc compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5118253ef90c345c13ce011297a04d47555e82ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;NimNode&lt;/code&gt; type, the &lt;code&gt;[]&lt;/code&gt; operator has been overloaded: &lt;code&gt;n[i]&lt;/code&gt; is &lt;code&gt;n&lt;/code&gt;'s &lt;code&gt;i&lt;/code&gt;-th child.</source>
          <target state="translated">Для &lt;code&gt;NimNode&lt;/code&gt; типа, то &lt;code&gt;[]&lt;/code&gt; оператор был перегружен: &lt;code&gt;n[i]&lt;/code&gt; является &lt;code&gt;n&lt;/code&gt; &amp;laquo;S &lt;code&gt;i&lt;/code&gt; -го ребенка.</target>
        </trans-unit>
        <trans-unit id="5b23d075b9b8ec0ab77df3a4277b9163e7d757d8" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;standalone&lt;/code&gt; target one needs to provide a file &lt;code&gt;panicoverride.nim&lt;/code&gt;. See &lt;code&gt;tests/manyloc/standalone/panicoverride.nim&lt;/code&gt; for an example implementation. Additionally, users should specify the amount of heap space to use with the &lt;code&gt;-d:StandaloneHeapSize=&amp;lt;size&amp;gt;&lt;/code&gt; command line switch. Note that the total heap size will be &lt;code&gt;&amp;lt;size&amp;gt; * sizeof(float64)&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;standalone&lt;/code&gt; цели необходимо предоставить файл &lt;code&gt;panicoverride.nim&lt;/code&gt; . См. Примеры реализации в &lt;code&gt;tests/manyloc/standalone/panicoverride.nim&lt;/code&gt; . Кроме того, пользователи должны указать объем кучи для использования с параметром командной строки &lt;code&gt;-d:StandaloneHeapSize=&amp;lt;size&amp;gt;&lt;/code&gt; . Обратите внимание, что общий размер кучи будет &lt;code&gt;&amp;lt;size&amp;gt; * sizeof(float64)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bd447b4c81354efb7aa284920ba753a6e07ea3a" translate="yes" xml:space="preserve">
          <source>For the JavaScript backend, log messages are written to the console, and &lt;code&gt;useStderr&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5b6b1186df78078d05adfad602fa92baed5303" translate="yes" xml:space="preserve">
          <source>For the duration of the borrow operation, no mutations to the borrowed locations may be performed except via the potentially mutable view that borrowed from the location. The borrowed location is said to be &lt;em&gt;sealed&lt;/em&gt; during the borrow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28f94973a02fa8efb6d2d9f2bdf6b84f68ef4a9" translate="yes" xml:space="preserve">
          <source>For the purposes of code generation, all static params are treated as generic params - the proc will be compiled separately for each unique supplied value (or combination of values).</source>
          <target state="translated">Для целей генерации кода все статические параметры рассматриваются как общие параметры-proc будет скомпилирован отдельно для каждого уникального поставляемого значения (или комбинации значений).</target>
        </trans-unit>
        <trans-unit id="c2c74c1ee472ad29842c87cdf299a669bad39ffc" translate="yes" xml:space="preserve">
          <source>For third party pragmas, it depends on its implementation but uses the same syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a599903250272239a970ef2b91cb9fbc4cc7a6e" translate="yes" xml:space="preserve">
          <source>For this kind of query the IDE will most likely ignore all the type/signature info provided by Nimsuggest and concentrate on the filename, line and column position of the multiple returned answers.</source>
          <target state="translated">Для такого рода запросов IDE,скорее всего,проигнорирует всю информацию о типе/подписи,предоставленную Nimsuggest,и сконцентрируется на имени файла,позиции строки и столбца множества возвращаемых ответов.</target>
        </trans-unit>
        <trans-unit id="21e8a16f7bac8ed1e3af0648dd4af16f400ffa1b" translate="yes" xml:space="preserve">
          <source>For this kind of query the IDE will most likely ignore all the type/signature info provided by idetools and concentrate on the filename, line and column position of the multiple returned answers.</source>
          <target state="translated">Для такого рода запросов IDE,скорее всего,проигнорирует всю информацию о типе/подписи,предоставляемую idetools,и сконцентрируется на имени файла,позиции строки и столбца множества возвращаемых ответов.</target>
        </trans-unit>
        <trans-unit id="4f2a830522144ce433b177e154438fbea54f01ba" translate="yes" xml:space="preserve">
          <source>For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.</source>
          <target state="translated">Для небуферизованных сокетов эта функция не прилагает усилий для чтения всех запрашиваемых данных.Она вернет столько данных,сколько предоставляет операционная система.</target>
        </trans-unit>
        <trans-unit id="acc44d22bdd9ff1a4f672371a2d978f27524f187" translate="yes" xml:space="preserve">
          <source>For unlimited queue set &lt;code&gt;maxItems&lt;/code&gt; to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29c22d667f2c9809200dc3c652631cb432b95f9" translate="yes" xml:space="preserve">
          <source>For variables $1 in the format string represents the type of the variable and $2 is the name of the variable.</source>
          <target state="translated">Для переменных $1 в строке формата представляет тип переменной,$2-имя переменной.</target>
        </trans-unit>
        <trans-unit id="d0acef1b99b298eedf58333627b04e7ade8e069b" translate="yes" xml:space="preserve">
          <source>For variables, $1 in the format string represents the type of the variable and $2 is the name of the variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f11073e7aacef9a5488a1392bb54a53d57c2a8f" translate="yes" xml:space="preserve">
          <source>Forces a full garbage collection pass. Ordinary code does not need to call this (and should not).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57f0c15791c6915cb3fe418d16a695f3e93406f" translate="yes" xml:space="preserve">
          <source>Forces the field to be centered within the available space.</source>
          <target state="translated">заставляет поле сосредоточиться в пределах имеющегося пространства.</target>
        </trans-unit>
        <trans-unit id="d7b27b7009675d9666afa3d1598bf15fcf934615" translate="yes" xml:space="preserve">
          <source>Forces the field to be left-aligned within the available space. (This is the default for strings.)</source>
          <target state="translated">заставляет поле быть выровненным по левому краю в пределах имеющегося пространства.(По умолчанию это для строк).</target>
        </trans-unit>
        <trans-unit id="5401c23ac1c35518b24a7af9c1a0f66703531dae" translate="yes" xml:space="preserve">
          <source>Forces the field to be right-aligned within the available space. (This is the default for numbers.)</source>
          <target state="translated">Усиливает выравнивание поля в пределах имеющегося пространства.(По умолчанию для чисел).</target>
        </trans-unit>
        <trans-unit id="5e823a3f6053e51d24188588d1235d16fdedb5e9" translate="yes" xml:space="preserve">
          <source>Foreign function interface</source>
          <target state="translated">Внешний интерфейс функции</target>
        </trans-unit>
        <trans-unit id="62f5fffe14b79a85984464c3815f9c99671b76a7" translate="yes" xml:space="preserve">
          <source>Format &lt;code&gt;dt&lt;/code&gt; using the format specified by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Отформатируйте &lt;code&gt;dt&lt;/code&gt; , используя формат, указанный &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc91fa1264bb70f29dff1283c89ce3d70708411e" translate="yes" xml:space="preserve">
          <source>Format a log message using the &lt;code&gt;frmt&lt;/code&gt; format string, &lt;code&gt;level&lt;/code&gt; and varargs. See the module documentation for the format string syntax.</source>
          <target state="translated">Отформатируйте сообщение журнала, используя &lt;code&gt;frmt&lt;/code&gt; формата frmt , &lt;code&gt;level&lt;/code&gt; и varargs. См. Информацию о синтаксисе строки формата в документации модуля.</target>
        </trans-unit>
        <trans-unit id="23df153e7e0e64b21db9ad3e5939710409b9a30c" translate="yes" xml:space="preserve">
          <source>Format strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fd1007724ad6493fdeb7d3d2e1c8dcb319f39f" translate="yes" xml:space="preserve">
          <source>Format strings support the following variables which must be prefixed with the dollar operator (&lt;code&gt;$&lt;/code&gt;):</source>
          <target state="translated">Строки формата поддерживают следующие переменные, которые должны начинаться с оператора доллара ( &lt;code&gt;$&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="f473a4a2cbe85328e51c6376b1faaa820f7130a0" translate="yes" xml:space="preserve">
          <source>FormatStr:</source>
          <target state="translated">FormatStr:</target>
        </trans-unit>
        <trans-unit id="320a4b0cd77d1079692787bfa5cb01d1507b5a80" translate="yes" xml:space="preserve">
          <source>Formats a log message at the specified level with the given format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5aa38b4d926a0fd6b7ab965445c10223a0ef52" translate="yes" xml:space="preserve">
          <source>Formatting floats</source>
          <target state="translated">Форматирующие поплавки</target>
        </trans-unit>
        <trans-unit id="119b045ed7d9e9597e047eb5230d1263cac6b285" translate="yes" xml:space="preserve">
          <source>Formatting strings</source>
          <target state="translated">Строки форматирования</target>
        </trans-unit>
        <trans-unit id="69f690f33d986c3349097e854e0eb9e08b5cc4f9" translate="yes" xml:space="preserve">
          <source>Forward declarations</source>
          <target state="translated">Форвардные заявления</target>
        </trans-unit>
        <trans-unit id="863ed164c9c45905d0e8f390e051e690266656e8" translate="yes" xml:space="preserve">
          <source>Forward definitions work properly, you just need to always add the &lt;code&gt;{.async.}&lt;/code&gt; pragma:</source>
          <target state="translated">Форвардные определения работают правильно, вам просто нужно всегда добавлять прагму &lt;code&gt;{.async.}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f8c5a89a52fbfb7fb81f2ad9c8f8020cd9035054" translate="yes" xml:space="preserve">
          <source>Found nodes satisfying the condition will be appended to the &lt;code&gt;result&lt;/code&gt; sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd6940a09171e7ee9b5773accc63e225abdd1b0" translate="yes" xml:space="preserve">
          <source>Found nodes satisfying the condition will be appended to the &lt;em&gt;result&lt;/em&gt; sequence, which can't be nil or the proc will crash. Usage example:</source>
          <target state="translated">Найденные узлы, удовлетворяющие условию, будут добавлены к &lt;em&gt;результирующей&lt;/em&gt; последовательности, которая не может быть нулевой, иначе процесс завершится с ошибкой. Пример использования:</target>
        </trans-unit>
        <trans-unit id="9451eac4434aa603b5d91f3457a805bcfe91aafd" translate="yes" xml:space="preserve">
          <source>Free memory referenced by SSLContext.</source>
          <target state="translated">Свободная память,на которую ссылается SSLContext.</target>
        </trans-unit>
        <trans-unit id="8839c93749a51b8f4573af0373c721bea8047dd5" translate="yes" xml:space="preserve">
          <source>Free memory referenced by SslContext.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb76bd366f4e6ba99981748b97fcc7bbe8e1d1c" translate="yes" xml:space="preserve">
          <source>Frees a NULL terminated cstringArray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d4cf3a87e9cdbcca08f62555c9cfbef0748ca7" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated with &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;alloc0&lt;/code&gt; or &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d269a02d2690912f030db18722ad0f6be8902d2f" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated with &lt;code&gt;allocShared&lt;/code&gt;, &lt;code&gt;allocShared0&lt;/code&gt; or &lt;code&gt;reallocShared&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c521c5fef3e2e4b71db5a2712cb612be33ee5fc9" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated with &lt;code&gt;createShared&lt;/code&gt;, &lt;code&gt;createSharedU&lt;/code&gt; or &lt;code&gt;resizeShared&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d32f0b040e1e463f6af2df09fd6c384e49112a6" translate="yes" xml:space="preserve">
          <source>Frees the resources associated with the condition variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217bf834335a4b2616a03e550f18eef5531ae2a0" translate="yes" xml:space="preserve">
          <source>Frees the resources associated with the lock.</source>
          <target state="translated">Освобождает ресурсы,связанные с замком.</target>
        </trans-unit>
        <trans-unit id="3012e87b890b08501d892d7aaf9956fe4b6d7353" translate="yes" xml:space="preserve">
          <source>Frees the thread local heap. Runs every finalizer if &lt;code&gt;runFinalizers&lt;/code&gt; is true. If &lt;code&gt;allowGcAfterwards&lt;/code&gt; is true, a minimal amount of allocation happens to ensure the GC can continue to work after the call to &lt;code&gt;deallocHeap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d3a1861da397f72e90bc587323bda31c9c723e" translate="yes" xml:space="preserve">
          <source>Friendlier version of the low-level &lt;code&gt;sendTo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sendTo&lt;/code&gt; дружественная версия низкоуровневого sendTo .</target>
        </trans-unit>
        <trans-unit id="0651a01fbb901bf5682fe3d0d43a4123bbbc43b0" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;n&lt;/code&gt; up to &lt;code&gt;m&lt;/code&gt; times &lt;code&gt;E&lt;/code&gt;</source>
          <target state="translated">От &lt;code&gt;n&lt;/code&gt; до &lt;code&gt;m&lt;/code&gt; раз &lt;code&gt;E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1ea6e8437394953edbfda643d827e4d4ef3e935" translate="yes" xml:space="preserve">
          <source>From import statement</source>
          <target state="translated">Из импортной ведомости</target>
        </trans-unit>
        <trans-unit id="bee0ffc05592a90a71b79296ba74ad204f6a4854" translate="yes" xml:space="preserve">
          <source>From statement</source>
          <target state="translated">Из заявления</target>
        </trans-unit>
        <trans-unit id="089c0e110f7531cecf41cc21ee48d15578ad6130" translate="yes" xml:space="preserve">
          <source>Full month string, properly capitalized.</source>
          <target state="translated">Целый месяц,с правильной заглавной буквы.</target>
        </trans-unit>
        <trans-unit id="1efdfc3c3fae4cb87be2f821dbd15c17e614eb81" translate="yes" xml:space="preserve">
          <source>Full path to the file containing the symbol.</source>
          <target state="translated">Полный путь к файлу,содержащему символ.</target>
        </trans-unit>
        <trans-unit id="d10e5187c8d103dd4ab7d6a2e82e22d06d193e5e" translate="yes" xml:space="preserve">
          <source>Full qualified path of the symbol. If you are querying a symbol defined in the &lt;code&gt;proj.nim&lt;/code&gt; file, this would have the form &lt;code&gt;proj.symbolName&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa17034b6f9cc3733582b028743a15d4ca9a823" translate="yes" xml:space="preserve">
          <source>Full qualitifed path of the symbol. If you are querying a symbol defined in the &lt;code&gt;proj.nim&lt;/code&gt; file, this would have the form &lt;code&gt;proj.symbolName&lt;/code&gt;.</source>
          <target state="translated">Полный квалифицированный путь символа. Если вы запрашиваете символ, определенный в файле &lt;code&gt;proj.nim&lt;/code&gt; , он будет иметь форму &lt;code&gt;proj.symbolName&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25eab966ab009c6f9396a404c34a6efc2aec6a35" translate="yes" xml:space="preserve">
          <source>Full string for the day of the week.</source>
          <target state="translated">Полная строка для дня недели.</target>
        </trans-unit>
        <trans-unit id="0de75419f9f0e58e30539063692f61bb63a8c14e" translate="yes" xml:space="preserve">
          <source>Full:</source>
          <target state="translated">Full:</target>
        </trans-unit>
        <trans-unit id="baf7883587d0db8919319600b0564cd5911762d2" translate="yes" xml:space="preserve">
          <source>Fully qualified path of the symbol. If you are querying a symbol defined in the &lt;code&gt;proj.nim&lt;/code&gt; file, this would have the form &lt;code&gt;proj.symbolName&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a52eaf688c8eb99e5f2a5f4ed34a39517d41a8" translate="yes" xml:space="preserve">
          <source>Fully supported OS: MacOSX, FreeBSD, OpenBSD, NetBSD, Linux (except for Android).</source>
          <target state="translated">Полностью поддерживаются ОС:MacOSX,FreeBSD,OpenBSD,NetBSD,Linux (кроме Android).</target>
        </trans-unit>
        <trans-unit id="d14c246c1269ccb4359c67583949d6908348f108" translate="yes" xml:space="preserve">
          <source>Func</source>
          <target state="translated">Func</target>
        </trans-unit>
        <trans-unit id="f30878239d150c44656cb1807dfee83bfae26ea8" translate="yes" xml:space="preserve">
          <source>Funcs</source>
          <target state="translated">Funcs</target>
        </trans-unit>
        <trans-unit id="39625e7c38b6dfbbccf8d818160b5949731fbcc2" translate="yes" xml:space="preserve">
          <source>Function that will be called instead of &lt;code&gt;stdmsg.write&lt;/code&gt; when printing stacktrace. Unstable API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103b82fef1279c926f44a70b4dcbb7c19d6cba9c" translate="yes" xml:space="preserve">
          <source>Further complications</source>
          <target state="translated">Дальнейшие осложнения</target>
        </trans-unit>
        <trans-unit id="bab2f0e91a508ebe1da51e92c439b6ffc92bda93" translate="yes" xml:space="preserve">
          <source>Furthermore no backtracking is performed, if parsing fails after a value has already been bound to a matched subexpression this value is not restored to its original value. This rarely causes problems in practice and if it does for you, it's easy enough to bind to a temporary variable first.</source>
          <target state="translated">Более того,обратное отслеживание не выполняется,если парсинг не удается после того,как значение уже привязано к совпадающему подвыражению,то это значение не восстанавливается к исходному значению.На практике это редко приводит к проблемам,и если это так,то сначала легко привязать к временной переменной.</target>
        </trans-unit>
        <trans-unit id="69610179c37adaec5ee39f67c094bcf4f227a4f5" translate="yes" xml:space="preserve">
          <source>Furthermore, every generic type automatically creates a type class of the same name that will match any instantiation of the generic type.</source>
          <target state="translated">Более того,каждый универсальный тип автоматически создает класс с одинаковым именем,который будет соответствовать любому значению универсального типа.</target>
        </trans-unit>
        <trans-unit id="020268db057d0d374d177846575179b989319d62" translate="yes" xml:space="preserve">
          <source>Future directions</source>
          <target state="translated">Дальнейшие направления</target>
        </trans-unit>
        <trans-unit id="08cefc2bd0b44f2a8a17df6ae2c7647385a570c9" translate="yes" xml:space="preserve">
          <source>Future directions:</source>
          <target state="translated">Будущие направления:</target>
        </trans-unit>
        <trans-unit id="628f36f2b247989f52efae291bc0d00b5bc12f2e" translate="yes" xml:space="preserve">
          <source>Future objects can also store a callback procedure which will be called automatically once the future completes.</source>
          <target state="translated">Будущие объекты также могут хранить процедуру обратного вызова,которая будет вызываться автоматически после завершения работы в будущем.</target>
        </trans-unit>
        <trans-unit id="f52ca92f6deff645322e492b01bf4e7e07479dc7" translate="yes" xml:space="preserve">
          <source>Futures should &lt;strong&gt;never&lt;/strong&gt; be discarded. This is because they may contain errors. If you do not care for the result of a Future then you should use the &lt;code&gt;asyncCheck&lt;/code&gt; procedure instead of the &lt;code&gt;discard&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;strong&gt;Никогда не&lt;/strong&gt; следует отказываться от фьючерсов . Это потому, что они могут содержать ошибки. Если вас не волнует результат Future, вам следует использовать процедуру &lt;code&gt;asyncCheck&lt;/code&gt; вместо ключевого слова &lt;code&gt;discard&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="181a7a6f276dfd96625be640094e14ce07c014e5" translate="yes" xml:space="preserve">
          <source>Futures should &lt;strong&gt;never&lt;/strong&gt; be discarded. This is because they may contain errors. If you do not care for the result of a Future then you should use the &lt;code&gt;asyncCheck&lt;/code&gt; procedure instead of the &lt;code&gt;discard&lt;/code&gt; keyword. Note however that this does not wait for completion, and you should use &lt;code&gt;waitFor&lt;/code&gt; for that purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d159d6d60dadf784672c33c747ac7bbedd187d" translate="yes" xml:space="preserve">
          <source>Futures therefore can be thought of as an implementation of the proactor pattern. In this pattern you make a request for an action, and once that action is fulfilled a future is completed with the result of that action. Requests can be made by calling the appropriate functions. For example: calling the &lt;code&gt;recv&lt;/code&gt; function will create a request for some data to be read from a socket. The future which the &lt;code&gt;recv&lt;/code&gt; function returns will then complete once the requested amount of data is read &lt;strong&gt;or&lt;/strong&gt; an exception occurs.</source>
          <target state="translated">Таким образом, будущее можно рассматривать как реализацию шаблона проактора. В этом шаблоне вы делаете запрос на действие, и как только это действие выполнено, будущее завершается с результатом этого действия. Запросы можно делать, вызывая соответствующие функции. Например: вызов функции &lt;code&gt;recv&lt;/code&gt; создаст запрос на чтение некоторых данных из сокета. Будущее, которое возвращает функция &lt;code&gt;recv&lt;/code&gt; , будет завершено после чтения запрошенного объема данных &lt;strong&gt;или&lt;/strong&gt; возникновения исключения.</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="24886e2768e1ad172ed42c67c3aefd8db070df8a" translate="yes" xml:space="preserve">
          <source>GC safety</source>
          <target state="translated">безопасность GC</target>
        </trans-unit>
        <trans-unit id="eaa3fa39346ddc09dbf2bdba8048d23ac925a06b" translate="yes" xml:space="preserve">
          <source>GCStats</source>
          <target state="translated">GCStats</target>
        </trans-unit>
        <trans-unit id="decdf7b7c7e08bf8d9a5d48840bcdaa2ba169aa4" translate="yes" xml:space="preserve">
          <source>GETs the &lt;code&gt;url&lt;/code&gt; and returns a &lt;code&gt;Response&lt;/code&gt; object</source>
          <target state="translated">ПОЛУЧАЕТ &lt;code&gt;url&lt;/code&gt; и возвращает объект &lt;code&gt;Response&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3cdc3ef08c097eb553bfa51683db392e9fd2bf94" translate="yes" xml:space="preserve">
          <source>GETs the body and returns it as a string.</source>
          <target state="translated">Получает тело и возвращает его как строку.</target>
        </trans-unit>
        <trans-unit id="7a252097fa66659331b3cddc9019fcc983caa9d2" translate="yes" xml:space="preserve">
          <source>GUI libraries</source>
          <target state="translated">графические библиотеки</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">сбор мусора</target>
        </trans-unit>
        <trans-unit id="9da6215e0b51f061b3fdba1a1ecfc65cbc078c5c" translate="yes" xml:space="preserve">
          <source>GcTypeKinds:</source>
          <target state="translated">GcTypeKinds:</target>
        </trans-unit>
        <trans-unit id="f6e05ce0d9c731cfa7368a04629cc24b4369f36e" translate="yes" xml:space="preserve">
          <source>General approach: AST replay</source>
          <target state="translated">Общий подход:воспроизведение АСТ</target>
        </trans-unit>
        <trans-unit id="e8d58703ce9850fb34cef0e5f6a677d9ab6d889a" translate="yes" xml:space="preserve">
          <source>General format. Same as 'g' except switches to 'E' if the number gets to large.</source>
          <target state="translated">Общий формат.Тот же,что и 'g',за исключением переключения на 'E',если число становится большим.</target>
        </trans-unit>
        <trans-unit id="a78239c87e6d40ce60ad0d42f7de857091c769b8" translate="yes" xml:space="preserve">
          <source>General format. This prints the number as a fixed-point number, unless the number is too large, in which case it switches to 'e' exponent notation.</source>
          <target state="translated">Общий формат.При этом число печатается как число с фиксированной точкой,если только число не слишком большое,в этом случае оно переключается на обозначение 'e' exponent.</target>
        </trans-unit>
        <trans-unit id="6ab8b3a8d895f749e9bdf5ce934de1c2d1d0b06b" translate="yes" xml:space="preserve">
          <source>Generalized raw string literals</source>
          <target state="translated">Обобщенные строковые литералы</target>
        </trans-unit>
        <trans-unit id="64fc3c60ac61d616b71e452185b1f4af623a77b5" translate="yes" xml:space="preserve">
          <source>Generate MD5 hash for a file. Result is a 32 character</source>
          <target state="translated">Сгенерировать MD5 хэш для файла.Результат-32 символа</target>
        </trans-unit>
        <trans-unit id="9af7c728cf98e71cf64f9b1972e19c2d127c4a0b" translate="yes" xml:space="preserve">
          <source>Generate MD5 hash for a string. Result is a 32 character hex string with lowercase characters</source>
          <target state="translated">Сгенерировать MD5 хэш для строки.Результат-32-символьная шестнадцатеричная строка с строчными символами.</target>
        </trans-unit>
        <trans-unit id="194fd628240e5dda215e0b527d6380a53aeafbc6" translate="yes" xml:space="preserve">
          <source>Generate hash of Oid for use in hashtables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d2101f8c390609a97dc36588eb2c2b928336e4" translate="yes" xml:space="preserve">
          <source>Generated C code directory</source>
          <target state="translated">Каталог сгенерированных C-кодов</target>
        </trans-unit>
        <trans-unit id="35615d886a02b1f0364e6b5e3dd2d7770360bec5" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;SecureHash&lt;/code&gt; from a &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39284be70eadfcb17ab98430a8b07978b57a2e7c" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;SecureHash&lt;/code&gt; from a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="559a8bb5a2a73a549d431251cef37d8a30c8d5fd" translate="yes" xml:space="preserve">
          <source>Generates a fresh symbol that is guaranteed to be unique. The symbol needs to occur in a declaration context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755850f873129edef75e0603bc32b9c1db81e647" translate="yes" xml:space="preserve">
          <source>Generates a tuple constructor expression listing all the local variables in the current scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120bc028779ab10d2c454afa8b36ea6cb77e7649" translate="yes" xml:space="preserve">
          <source>Generates a volatile load of the value stored in the container &lt;code&gt;src&lt;/code&gt;. Note that this only effects code generation on &lt;code&gt;C&lt;/code&gt; like backends</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fc580b3d486415cebb9117f5f9725b055316cc" translate="yes" xml:space="preserve">
          <source>Generates a volatile store into the container &lt;code&gt;dest&lt;/code&gt; of the value &lt;code&gt;val&lt;/code&gt;. Note that this only effects code generation on &lt;code&gt;C&lt;/code&gt; like backends</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289133444536aa23e14085f7d4547c38b4614e68" translate="yes" xml:space="preserve">
          <source>Generates an interpreting event parser &lt;em&gt;proc&lt;/em&gt; according to the specified PEG AST and handler code blocks. The &lt;em&gt;proc&lt;/em&gt; can be called with a string to be parsed and will execute the handler code blocks whenever their associated grammar element is matched. It returns -1 if the string does not match, else the length of the total match. The following example code evaluates an arithmetic expression defined by a simple PEG:</source>
          <target state="translated">Формирует интерпретируя анализатор событий &lt;em&gt;прока&lt;/em&gt; в соответствии с указанной PEG AST и обработчиками блоков кода. &lt;em&gt;Proc&lt;/em&gt; можно назвать со строкой , чтобы быть проанализирован и будет выполнять блоки кода обработчика всякий раз , когда совпавшие связанных с ними грамматики элемент. Он возвращает -1, если строка не совпадает, иначе - длину полного совпадения. В следующем примере кода вычисляется арифметическое выражение, определенное простым PEG:</target>
        </trans-unit>
        <trans-unit id="da34d01460dd01c931af1769caf2e264a100a2c5" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;a&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32be55f1b86f94ed09b67ab8f7fdf18ad6137d7c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;abbr&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc4f1abc0b2fd50ff9ece52303ab7796c2b58c8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;address&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097cb30b6f31aef82824f3db37f2b2d8671714a4" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;annotation-xml&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7186a1cbab5eb0d902bef55e569e69732998ab5" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;annotation&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d3d488209133bc046e1215fc3b05d2d015dd1f" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;area&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a625db72e199f1050b8a5089779786f6974e8b96" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;article&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8abbecd1b46dea914db26539726b5fde4d2f55" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;aside&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ea8019aa9800496595e6fdc945d8e6fb6214b8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;audio&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781e2bff84caf603de6b3f96592899d16001304e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;b&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f97fe8e4d12bfb853835d7ee5a13495b66a3a79" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;base&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bef2ca9a3af4e73d6e4b6860268f8110174379a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;bdi&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26339ee335f1ed3446bbe37852ca6d1094a3b908" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;bdo&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d3d1e102d10a06299849f83848d80d2ce08f48a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;big&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0f3ace6f4bc9198b1c9d689700f7628187b64a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;blockquote&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4aa01acab28ac06305a168352495459e166a2fc" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;body&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519ea02cf4b979961f20c565aac4b75e00a9b086" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;br&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0657c98f3e40dcc75e99d757e4ffd2768f82af28" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;button&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e8fdd28947fe81a182ca47b08e94c34ec1e4d2" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;canvas&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5bfdabbf0147366d16c4eaaa2404e363bd64249" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;caption&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660eb09173253a08b1646718e75541e4fb302d2e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;center&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a07df737a0612622dec66f32371db2c52c4391" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;cite&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0584882269852e7832a727061f5b8b2852cf1d2a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;code&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61de1d464b0fa66efab9ea74c0c855e47cd487b9" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;col&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda768838cb4fecfbc87d29c889e4bef728ecd11" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;colgroup&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2096f5b7f2320775930577813c43c8707525bc" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;data&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b101416b917f90a0263464dc6da695fafdbce2" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;datalist&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1ecdcdf7c377a1b561e70572836e87cdb33693" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;dd&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d660ebebdeff46bec931d3f089a4e59bce312c8e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;del&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d456959c6a20d8c4fe07239ff996e70304cf1df1" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;details&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d917456b26585dced871779a05a80dfb53f0ca" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;dfn&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0928eeba4125b3752b1e2d5e467ab1bc6b57aaa0" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;dialog&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ab607ad1228c7400a9211b50265d207ab975f5" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;div&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38aaeb2765ecda9c1c49044e2770a1d85c3f5960" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;dl&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a760008fc08d6993817e8732bb1bcb173b07a489" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;dt&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b8544b49d83d1d59b33a2ac1f41238fdd0610b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;em&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1570931b6f2239c20d17198d6995af278c83b32" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;embed&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c67ff67bc45f60d4a3cb0372c848130bedf9d14" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;fieldset&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4da2d200679bfe395e63618a960a70487adf672" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;figcaption&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4af81e539fd3886478908c327ad8cffed2d4a1" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;figure&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba154b84b360700071cda4fbd58076d9b6b4be64" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;footer&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc0ef5b06525b6860bbfe5095afa55f7b5f074c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;form&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca6b27c79c2d3b9992d5d07c24a48a10e28b34c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h1&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4789d3b3e9eb88607ad8e8db39b9d84e7e1b387" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h2&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="489e845a836298f33e3b64b19d090b856ebfa27d" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h3&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367b7a712f4fea1207a13b88956c965cceb0ef30" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h4&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe6c0e3c73c7c4ccf27d7ed85e6f4bfb2a015d2" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h5&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb72a2726fc9bcb8698c0aee4124749e011b9975" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;h6&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b741d14550a58d68d35d27def0f2b5f9e4f5ce12" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;head&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be049901a7b44200d29f819318105d88429dfeb4" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;header&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f59f794866fd435a22266af704d282c41c171c9" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;hr&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3260027a04c7712c43bb51eb776720f6e82e196a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;html&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c658c2cb83a97628300d1ce9b62b730e1bc534" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;i&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c90e9cd0c44577a72b0a4003a70f33efd58287a" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;iframe&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189ccdc7739b0beda3532e019673a73764bc2762" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;img&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2689fd6ba4dabf3c926e3011326c0bbe0a6203d0" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;input&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6257c9c257cfbb5f42946162cc1bf3411d1f6048" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;ins&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a789f48702e7ee1ebd0d2c620727682ed0765f3" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;kbd&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d540cb25a4e348c681a560269edf67cb03e7b78f" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;keygen&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9357ea873cb37668266594ebb44bcfcda727c7b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;label&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f647a7e9d56924f3e2c2717cdc6f273fe2e0a9b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;legend&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee495d070a07ef79b104540a24f79c58f34d97ca" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;li&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3bb6c0fe1bc782c3e6ca68919a9c403cd83cbc" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;link&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b96b4c8f496bc552385a5d2d3644aac6928a53fe" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;maction&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/maction&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/maction&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ceb84e08e07283f1c1c70090fb80caa6fa212c8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;main&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21af6208a1e39b94c80eb93cec9f0c52376aa60" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;map&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51d139745dcedc6654f34b51827c38c33b86bd4" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mark&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692d09d61bd0f039746929ac7b0339c9bcd2e702" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;marquee&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499378107de248fd1c359efc6cfd0acff1e25ee8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;math&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/math#Examples&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/math#Examples&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91aed1713f1856c234e3daa198d372bb4b29ae7" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;menclose&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/menclose&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/menclose&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba506a06399b82662ae53bf8eb917307e0f9bcfa" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;merror&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/merror&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/merror&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abf9e36418e2349549d0205093b969a0f74954b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;meta&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68200b0867ed246dfd3cdb816cab3d1aeacdec75" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;meter&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2596787542e0a138581b455419b609ef7faed4" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mfenced&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfenced&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfenced&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6f8830012da66f18b566c07395a10f19162301" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mfrac&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfrac&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mfrac&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be25138e70924676e8c7ecb9a4943d40efdaf3de" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mglyph&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mglyph&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mglyph&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fa624f5b66a9d27dcf9aaa908a6730952e674b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mi&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mi&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mi&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0297c68c3fe75f6d402c686d8fc57d31edd154f0" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mlabeledtr&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mlabeledtr&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mlabeledtr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e431e86f253b36beb5b9ccf8749ec36fb24bf3" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mmultiscripts&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mmultiscripts&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mmultiscripts&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5624407164545b6def82bb7b0c6b1d25f9297f9" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mn&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mn&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mn&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df1bb16fde8f1db840769bf471ea6e0e2ef52e8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mo&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e156e70a4158caeb7b05630f09d639014f44df" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mover&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mover&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mover&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09be696b3bc9f981a56697741573dfe7b31da578" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mpadded&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mpadded&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mpadded&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7cc95c8781953a8bc7c6348ee10e0c0fe11909" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mphantom&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mphantom&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mphantom&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6993bd6efa015fb7c7841e804a7ca66c930e68" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mroot&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mroot&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mroot&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc2ff2117f9a5988690d2964705c6f16da75ccf" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mrow&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mrow&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mrow&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbaa7aa8a33eec37f6d7f827fe244763291ebfc" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;ms&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/ms&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/ms&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa89b6be555f511dfd17db8db5d6c4ed4c7c0ab8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mspace&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mspace&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mspace&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaec7a78e68576394018172847b775e346714fb0" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;msqrt&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msqrt&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msqrt&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2bf0f25240d9ea69cbc45164eaede5871741c0" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mstyle&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mstyle&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mstyle&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483f8abe3b70822527bbdd3904f9b12f64663cea" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;msub&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msub&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msub&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740eb50cfa63dc2584d63e8396667efdb0699087" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;msubsup&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msubsup&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msubsup&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc0451b9f8e78faadbdf7dbaf7edcc9877d78c9" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;msup&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msup&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/msup&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc9144b7c870832664823b5e1bea8d14bf88831" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mtable&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtable&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtable&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a800f093d24fabf56b303c28982c6403d8de4ca" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mtd&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtd&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtd&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a580bcbc406807a386a6ac4e00027e1029bf778" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;mtext&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtext&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mtext&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50436d4782346e0f2c90f5a97d6764b98c3e592" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;munder&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munder&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munder&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb0be55fb6f4c58428dc68ba7c74b76fa9ce00b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;munderover&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munderover&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/munderover&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64be23a3ca78e17c1d11fb87dcf0379edad5f67" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;nav&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f504d61d3d0622640b9a76e75dd4d618dcbc646" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;noscript&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d13d13bd7b8465f26d4689a2d957b6ba8e6914" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;object&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c3a6ea3e2a906df7ce7cb4b4b5e56c942549f2" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;ol&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603574bfaf599f93890e2fb3b00e4937994aee04" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;optgroup&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9a1e23896f777c1a50fe61956d79c83e99fe0e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;option&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e91c1178d6e6a39fdec347b8b933af7f8166404" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;output&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99069d37b3e72a5c699d119936ae25c179638da9" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;p&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c99f67716e604deac5aeaf0ae29679e2e77f56" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;param&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c1cf9b4ee9c05261bc5a92368a61e6e13099a1" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;picture&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927cf9075dfedda1ef6defe172c80896ce8cfa44" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;pre&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7ca998d91d3dca462510461fcabd03805870f7" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;progress&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3394adadad71640f551bb1f0b38f768245eb15" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;q&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b6e8d1cf19a4c0765095254f40e4438dc960ab" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;rb&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f89e55d8df8bc83a1b801ecd4d66561a88adaea" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;rp&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4af404712d5f7e0f310aa3601b0943f64c5267" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;rt&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f47d0bdd2bfea9b65862c99e096c1002435b06c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;rtc&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a420db35452a048fb5dd7cdfdc3b34168fc39dc1" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;ruby&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefeef801650e8395cff2e40d58c915d62540191" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;s&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b88492f1821fa20f6da136ff86ef6965aef816" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;samp&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57b7ae2c2122fc884ed075d827265932c771990" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;script&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032f946dc0943f8f7ff5fc1e8691e6319b52c986" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;section&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ef79bbe2c64b862c935c4c2985f03340f0681c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;select&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885197cf3adff9060d7ad840c9711c0576cbc2f8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;semantics&lt;/code&gt; element. MathML &lt;a href=&quot;https://wikipedia.org/wiki/MathML&quot;&gt;https://wikipedia.org/wiki/MathML&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/semantics&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eef6a77b30b886b5d4b938c85974a8e690613bf" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;slot&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2bf01d48af1a21e5f109a7f960507c0486825c8" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;small&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c9ecb649311996dd7b870242a3044823dab843" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;source&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7248c71b05a3424702099d9262683e171fb9556" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;span&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5759bf6134cc8899c575427332da55100d40b3" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;strong&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a164d164cd14133a71b8e1f766853cd3ff6983" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;style&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e497b992a0963e21d6b405ae152673a691a24a65" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;sub&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f8b492814144ea06fa14f427ccd874ffc0353d" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;summary&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f53281496402bc22649b4ada2e8c39bde66772" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;sup&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b63a1d86f2e4295f86c74d5be70b57361f0a73b" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;table&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e12e676be1691ed4ae7ed6010fb163dcde9fe33" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;tbody&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0a3bb62756c29e3183a118254cece57e00f0c4" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;td&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="176243abebd8e8d175c100a96b2a2e3e91ee2d7e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;template&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad42138b20d64d40d7d3094ad62c106d2cbff9d" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;textarea&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54fbfbd9206b82eff0de8b083d3d5d21d085e817" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;tfoot&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34135dae942c7e7cb4017ee38f734def17f6487" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;th&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ee6106bc8d50c4c02a5987b7fd33771a35478e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;thead&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38ec10e3ae60dfa7d07092b1852f7d445d2e5fb" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;time&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779acc8c7b9a4b1584ca5a5e997ee4104e1bbe16" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;title&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b009451fd485966f84e5d46e1fc1c8e35117afcb" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;tr&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90810fb6ee5e22c2187c395cd31a8fa8dae0e37c" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;track&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ebcdfc397b1445cc709d8890b2dcbf920efe5e" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;tt&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f979d07ab3099ffd83bd2aac6fefcb47cb6e1f26" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;u&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b4ad09cbdd52448a64d367a2530303c8abc4b2" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;ul&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="702489ba723db1998c9363f9002f88e4a94f5003" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;var&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e808918cfd649391788ce9409245da2f232a763d" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;video&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ab02b014d023ecbb9e10205dcb4f53779bfb16" translate="yes" xml:space="preserve">
          <source>Generates the HTML &lt;code&gt;wbr&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d238e05cf8359baddfe7e098b6e336c92a9522a7" translate="yes" xml:space="preserve">
          <source>Generating AST by hand</source>
          <target state="translated">Генерирование АСТ вручную</target>
        </trans-unit>
        <trans-unit id="6d7d9e5c5c51e8cdad797fbcfcf569b8c1cb37c1" translate="yes" xml:space="preserve">
          <source>Generating source code</source>
          <target state="translated">Генерация исходного кода</target>
        </trans-unit>
        <trans-unit id="35071138dc35da926de98aaefe96984d4217c446" translate="yes" xml:space="preserve">
          <source>Generation of HTML documents is done via the &lt;code&gt;doc&lt;/code&gt; command. This command takes either a single .nim file, outputting a single .html file with the same base filename, or multiple .nim files, outputting multiple .html files and, optionally, an index file.</source>
          <target state="translated">Генерация HTML-документов выполняется с помощью команды &lt;code&gt;doc&lt;/code&gt; . Эта команда принимает либо один файл .nim, выводя один файл .html с одним и тем же базовым именем файла, либо несколько файлов .nim, выводя несколько файлов .html и, при необходимости, индексный файл.</target>
        </trans-unit>
        <trans-unit id="fa6d6526a743c04cb138f95e5e874619707d13b3" translate="yes" xml:space="preserve">
          <source>Generation of JSON documents is done via the &lt;code&gt;jsondoc&lt;/code&gt; command. This command takes in a .nim file, and outputs a .json file with the same base filename. Note that this tool is built off of the &lt;code&gt;doc&lt;/code&gt; command (previously &lt;code&gt;doc2&lt;/code&gt;), and contains the same information.</source>
          <target state="translated">Генерация документов JSON осуществляется с помощью команды &lt;code&gt;jsondoc&lt;/code&gt; . Эта команда принимает файл .nim и выводит файл .json с тем же базовым именем. Обратите внимание, что этот инструмент построен на основе команды &lt;code&gt;doc&lt;/code&gt; (ранее &lt;code&gt;doc2&lt;/code&gt; ) и содержит ту же информацию.</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="ecb8455c6017aa556f1a742c2bbe58fd6c33e126" translate="yes" xml:space="preserve">
          <source>Generators that are independent of the default one can be created with the &lt;a href=&quot;#initRand,int64&quot;&gt;initRand proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4da4b25b29a5d42eacf30a326661d0c19bc53d" translate="yes" xml:space="preserve">
          <source>Generic 'sink' operator for Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7d98939d2e599a92fb51644f3d139254dbe639" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for arrays that is lifted from the components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25dc10a10484e99e5be2de9d8740c28db93a4f0d" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for openarrays that is lifted from the components of &lt;code&gt;x&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a593d97b8fcd7767e73733dc0e14657fdc1f4b" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for seqs that is lifted from the components of &lt;code&gt;x&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68472d9619306bbfad1204d0d30f885be44b7a60" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for sets that is lifted from the components of &lt;code&gt;x&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba53755f62ad03138279baf781166a53ed0ab135" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for slices that is lifted from the components of &lt;code&gt;x&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4e342b492689191bbf67b40fa6d701d15a99e8" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;$&lt;/code&gt; operator for tuples that is lifted from the components of &lt;code&gt;x&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3461386e665830f05493540980fbbad3db6e26" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;==&lt;/code&gt; operator for tuples that is lifted from the components. of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b860e8449129db1db575f3ace43091516f67c893" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;importcpp&lt;/code&gt;'ed objects are mapped to C++ templates. This means that one can import C++'s templates rather easily without the need for a pattern language for object types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a377ee820e09df0403fe82c53c3c8f2ee70f4b" translate="yes" xml:space="preserve">
          <source>Generic &lt;code&gt;importcpp&lt;/code&gt;'ed objects are mapped to C++ templates. This means that you can import C++'s templates rather easily without the need for a pattern language for object types:</source>
          <target state="translated">Общие &lt;code&gt;importcpp&lt;/code&gt; сопоставляются с шаблонами C ++. Это означает, что вы можете довольно легко импортировать шаблоны C ++ без необходимости в языке шаблонов для типов объектов:</target>
        </trans-unit>
        <trans-unit id="1a112a59a836ee051dd90640bf9a63207cb67f73" translate="yes" xml:space="preserve">
          <source>Generic &lt;span id=&quot;destructor_1&quot;&gt;destructor&lt;/span&gt; implementation that can be overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48811885ff4e6e1d4496613f53cf4fe6f1a80351" translate="yes" xml:space="preserve">
          <source>Generic &lt;span id=&quot;sink_1&quot;&gt;sink&lt;/span&gt; implementation that can be overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0fbaa97fbe2d5968844c44481eeeeaa9d8cf4d" translate="yes" xml:space="preserve">
          <source>Generic Operating System Services</source>
          <target state="translated">Общие услуги для операционных систем</target>
        </trans-unit>
        <trans-unit id="464fc06b76ab248412509ecef43c71e506b6ded7" translate="yes" xml:space="preserve">
          <source>Generic character types</source>
          <target state="translated">Общие типы символов</target>
        </trans-unit>
        <trans-unit id="91a8b57b838f07b19ed30b33bc5aeffe6a02d4c6" translate="yes" xml:space="preserve">
          <source>Generic compare proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678e67a971cceb4e4204476fbf467e12791b8c3c" translate="yes" xml:space="preserve">
          <source>Generic compare proc. Returns a value &amp;lt; 0 iff x &amp;lt; y, a value &amp;gt; 0 iff x &amp;gt; y and 0 iff x == y. This is useful for writing generic algorithms without performance loss. This generic implementation uses the &lt;em&gt;==&lt;/em&gt; and &lt;em&gt;&amp;lt;&lt;/em&gt; operators.</source>
          <target state="translated">Общая процедура сравнения. Возвращает значение &amp;lt;0, если x &amp;lt;y, значение&amp;gt; 0, если x&amp;gt; y, и 0, если x == y. Это полезно для написания общих алгоритмов без потери производительности. В этой универсальной реализации используются операторы &lt;em&gt;==&lt;/em&gt; и &lt;em&gt;&amp;lt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6aac3374886170bb41e18aa9ef46d585b4c0cf3d" translate="yes" xml:space="preserve">
          <source>Generic concepts and type binding rules</source>
          <target state="translated">Общие понятия и обязательные правила для типов</target>
        </trans-unit>
        <trans-unit id="e9d9ced4a1220da78471017048bb21c0918f5f51" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JArray JsonNode&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a284a5b6d26d3458edbcb91cb0cdc3e895de227" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JBool JsonNode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb570386048b49850a85fb951fecbcbe240a19c3" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JFloat JsonNode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c9abbf466222ff52b0f6a4b2ff30f735f354ff5" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JInt JsonNode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a82330283a77e8f4325ad6d16dda3e1716a317" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JNull JsonNode&lt;/code&gt; if &lt;code&gt;opt&lt;/code&gt; is empty, otherwise it delegates to the underlying value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4aa18634c4bcfb0eb0afbfbb21ce20b58df1e2" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JObject JsonNode&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239890fb8c97702c6d4ee5104521be1ba227b16e" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JObject JsonNode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abdbf1eb8384d43d3616880593cc740080350c2" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;code&gt;JString JsonNode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5758f3b8d7db49429e2450605302abae607b2d2e" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JArray JsonNode&lt;/em&gt;</source>
          <target state="translated">Универсальный конструктор для данных JSON. Создает новый &lt;em&gt;JArray JsonNode&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56196b58c5a518827914bf2b7e0d971615bef4ef" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JBool JsonNode&lt;/em&gt;.</source>
          <target state="translated">Универсальный конструктор для данных JSON. Создает новый &lt;em&gt;JBool JsonNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c522119659c3ad469d660cbc777be1566eab03ca" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JFloat JsonNode&lt;/em&gt;.</source>
          <target state="translated">Универсальный конструктор для данных JSON. Создает новый &lt;em&gt;JFloat JsonNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="428d41d73169fa86a546999a3ecbb89be1dc15dd" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JInt JsonNode&lt;/em&gt;.</source>
          <target state="translated">Универсальный конструктор для данных JSON. Создает новый &lt;em&gt;JInt JsonNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b9a542f51bfb8d8a58c48f28ef2d46b8502cfe" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JObject JsonNode&lt;/em&gt;</source>
          <target state="translated">Универсальный конструктор для данных JSON. Создает новый &lt;em&gt;JObject JsonNode&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2877938000b60f256eb2208f3e2064ca182d0d1e" translate="yes" xml:space="preserve">
          <source>Generic constructor for JSON data. Creates a new &lt;em&gt;JString JsonNode&lt;/em&gt;.</source>
          <target state="translated">Универсальный конструктор для данных JSON. Создает новый &lt;em&gt;JString JsonNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8148d60cedc7cdb10800bc50e60d1a318f6ded" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SFloat SexpNode&lt;/em&gt;.</source>
          <target state="translated">Универсальный конструктор для данных SEXP. Создает новый &lt;em&gt;SFloat SexpNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="368e470b1e2f2321d77f4df18391df0ebee5b99f" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SInt SexpNode&lt;/em&gt;.</source>
          <target state="translated">Универсальный конструктор для данных SEXP. Создает новый &lt;em&gt;SInt SexpNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ce95a5ca77c5c22b17a766116d3147d2635c453e" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SList SexpNode&lt;/em&gt;</source>
          <target state="translated">Универсальный конструктор для данных SEXP. Создает новый &lt;em&gt;SList SexpNode&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70060a28a86cfcd2dc2f2ba89648bd6996b8b345" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SString SexpNode&lt;/em&gt;.</source>
          <target state="translated">Универсальный конструктор для данных SEXP. Создает новый &lt;em&gt;SString SexpNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ea5770ee43cc8a593a59a930e346d52787e2ce7c" translate="yes" xml:space="preserve">
          <source>Generic constructor for SEXP data. Creates a new &lt;em&gt;SSymbol SexpNode&lt;/em&gt; with value t or &lt;em&gt;SNil SexpNode&lt;/em&gt;.</source>
          <target state="translated">Универсальный конструктор для данных SEXP. Создает новый &lt;em&gt;SSymbol SexpNode&lt;/em&gt; со значением t или &lt;em&gt;SNil SexpNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2d9c5b40c902b45136bf82c2680715d032a1618a" translate="yes" xml:space="preserve">
          <source>Generic equals operator for sequences: relies on a equals operator for the element type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fb5138e59ddec98dd809de58b7d3ddb3a5428f" translate="yes" xml:space="preserve">
          <source>Generic equals operator for sequences: relies on a equals operator for the element type &lt;em&gt;T&lt;/em&gt;.</source>
          <target state="translated">Родовой равно оператор для последовательностей: полагается на оператора равна для типа элемента &lt;em&gt;Т&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="24d2e728fc7eb11a101f2306259092cd481ba295" translate="yes" xml:space="preserve">
          <source>Generic hash table, consisting of a key-value pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e8bb6d675a2725d1d4b86c632445dea3d31b1b" translate="yes" xml:space="preserve">
          <source>Generic inference restrictions</source>
          <target state="translated">Общие ограничения на умозаключения</target>
        </trans-unit>
        <trans-unit id="5e6ad75e310df0542586553577d204406a0479d0" translate="yes" xml:space="preserve">
          <source>Generic instantiations are owned by their originating generic symbol. This proc skips such owners and goes straight to the owner of the generic itself (the module or the enclosing proc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c80a0a651229e4de9a85da8c186fe02e0a43aa3f" translate="yes" xml:space="preserve">
          <source>Generic lexicographic &lt;code&gt;&amp;lt;&lt;/code&gt; operator for tuples that is lifted from the components of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. This implementation uses &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1b34ea201f817f3f494d59966d575af6313b1d" translate="yes" xml:space="preserve">
          <source>Generic lexicographic &lt;code&gt;&amp;lt;=&lt;/code&gt; operator for tuples that is lifted from the components of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. This implementation uses &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4ec6bb77472d676b0b71755309ad80e343f837" translate="yes" xml:space="preserve">
          <source>Generic match: &lt;code&gt;f&lt;/code&gt; is a generic type and &lt;code&gt;a&lt;/code&gt; matches, for instance &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a generic (constrained) parameter type (like in &lt;code&gt;[T]&lt;/code&gt; or &lt;code&gt;[T: int|char]&lt;/code&gt;.</source>
          <target state="translated">Общий матч: &lt;code&gt;f&lt;/code&gt; является универсальным типом и &lt;code&gt;a&lt;/code&gt; матчи, например является &lt;code&gt;int&lt;/code&gt; и &lt;code&gt;f&lt;/code&gt; является общим (ограниченно) типом параметра (например , в &lt;code&gt;[T]&lt;/code&gt; или &lt;code&gt;[T: int|char]&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e2cd7649b731671a13f778e5ca52832337336a2" translate="yes" xml:space="preserve">
          <source>Generic ordinal type. Includes integer, bool, character, and enumeration types as well as their subtypes. Note &lt;em&gt;uint&lt;/em&gt; and &lt;em&gt;uint64&lt;/em&gt; are not ordinal types for implementation reasons</source>
          <target state="translated">Общий порядковый тип. Включает целочисленные, логические, символьные и перечисляемые типы, а также их подтипы. Обратите внимание, что &lt;em&gt;uint&lt;/em&gt; и &lt;em&gt;uint64&lt;/em&gt; не являются порядковыми типами по причинам реализации.</target>
        </trans-unit>
        <trans-unit id="b2e02c2b9e86e7cd2c89e27a604e3f3aebbcca9d" translate="yes" xml:space="preserve">
          <source>Generic ordinal type. Includes integer, bool, character, and enumeration types as well as their subtypes. See also &lt;code&gt;SomeOrdinal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205cba3940d3dacf00b9f300477ac45b29168176" translate="yes" xml:space="preserve">
          <source>Generic peek procedure. Peeks &lt;code&gt;result&lt;/code&gt; from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af374b805d45c5e3931a72561172f771a870d67b" translate="yes" xml:space="preserve">
          <source>Generic proc for adding a container &lt;code&gt;y&lt;/code&gt; to a container &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9bb79fde5784544753502a2ab6bdd84e5e8025" translate="yes" xml:space="preserve">
          <source>Generic proc for adding a data item &lt;code&gt;y&lt;/code&gt; to a container &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d85eb1d2101a47518908a9543ab04dd38c3be8" translate="yes" xml:space="preserve">
          <source>Generic proc for adding a data item &lt;em&gt;y&lt;/em&gt; to a container &lt;em&gt;x&lt;/em&gt;. For containers that have an order, &lt;em&gt;add&lt;/em&gt; means &lt;em&gt;append&lt;/em&gt;. New generic containers should also call their adding proc &lt;em&gt;add&lt;/em&gt; for consistency. Generic code becomes much easier to write if the Nim naming scheme is respected.</source>
          <target state="translated">Общая процедура для добавления элемента данных &lt;em&gt;y&lt;/em&gt; в контейнер &lt;em&gt;x&lt;/em&gt; . Для контейнеров, у которых есть заказ, &lt;em&gt;добавить&lt;/em&gt; означает &lt;em&gt;добавить&lt;/em&gt; . Новые универсальные контейнеры также должны вызывать добавление процедур &lt;em&gt;добавления&lt;/em&gt; для согласованности. Общий код становится намного проще писать, если соблюдать схему именования Nim.</target>
        </trans-unit>
        <trans-unit id="29c3bf9a1541d144b2e76c7c575756893384b0a5" translate="yes" xml:space="preserve">
          <source>Generic read procedure. Reads &lt;code&gt;result&lt;/code&gt; from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbccc6a656c4c0fcf5215bff94a25f9c34e2bcf1" translate="yes" xml:space="preserve">
          <source>Generic type to construct a varargs type.</source>
          <target state="translated">Общий тип для построения типа varargs.</target>
        </trans-unit>
        <trans-unit id="d4c17034fe5c9e8772b30101d8cc632e4a17baf3" translate="yes" xml:space="preserve">
          <source>Generic type to construct bit sets.</source>
          <target state="translated">Общий тип для построения битовых наборов.</target>
        </trans-unit>
        <trans-unit id="082c9d1651fdd2acdb7f2c31b3f3648b7afec885" translate="yes" xml:space="preserve">
          <source>Generic type to construct fixed-length arrays.</source>
          <target state="translated">Общий тип для построения массивов фиксированной длины.</target>
        </trans-unit>
        <trans-unit id="ce68ddc8e58b7a3242f91b2251724e6a4a8e1dda" translate="yes" xml:space="preserve">
          <source>Generic type to construct open arrays. Open arrays are implemented as a pointer to the array data and a length field.</source>
          <target state="translated">Общий тип для построения открытых массивов.Открытые массивы реализуются в виде указателя на данные массива и поля длины.</target>
        </trans-unit>
        <trans-unit id="a145c1c6d93be237b998460577b653c1465acceb" translate="yes" xml:space="preserve">
          <source>Generic type to construct range types.</source>
          <target state="translated">Общий тип для построения типов диапазона.</target>
        </trans-unit>
        <trans-unit id="a5a528710df29c84abff0cbb0679efaae048d50e" translate="yes" xml:space="preserve">
          <source>Generic type to construct sequences.</source>
          <target state="translated">Общий тип для построения последовательностей.</target>
        </trans-unit>
        <trans-unit id="78a0e3726f6a2b4d101a3ab834663f5ab843367b" translate="yes" xml:space="preserve">
          <source>Generic write procedure. Writes &lt;code&gt;x&lt;/code&gt; to the stream &lt;code&gt;s&lt;/code&gt;. Implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233fac928becc03e933e67dfcab3334426f64894" translate="yes" xml:space="preserve">
          <source>GenericTypes:</source>
          <target state="translated">GenericTypes:</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="3b461060a51b8a72f2a4cb78364c85efb904c7a8" translate="yes" xml:space="preserve">
          <source>Generics are Nim's means to parametrize procs, iterators or types with &lt;span id=&quot;type-parameters_1&quot;&gt;type parameters&lt;/span&gt;. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type.</source>
          <target state="translated">Обобщения - это средство Nim для параметризации процессов, итераторов или типов с помощью &lt;span id=&quot;type-parameters_1&quot;&gt;параметров типа&lt;/span&gt; . В зависимости от контекста скобки используются либо для введения параметров типа, либо для создания экземпляра универсального процесса, итератора или типа.</target>
        </trans-unit>
        <trans-unit id="6bf7d7c0d998ce8339e4157956b89967e9e5d710" translate="yes" xml:space="preserve">
          <source>Generics are Nim's means to parametrize procs, iterators or types with &lt;span id=&quot;type-parameters_1&quot;&gt;type parameters&lt;/span&gt;. Depending on the context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator, or type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8db3e0e66211eabb3c4f25fee0a1d1829b963a" translate="yes" xml:space="preserve">
          <source>Generics are Nim's means to parametrize procs, iterators or types with &lt;span id=&quot;type-parameters_1&quot;&gt;type parameters&lt;/span&gt;. They are most useful for efficient type safe containers:</source>
          <target state="translated">Generics - это средства Nim для параметризации процессов, итераторов или типов с &lt;span id=&quot;type-parameters_1&quot;&gt;параметрами типа&lt;/span&gt; . Они наиболее полезны для эффективных контейнеров типа безопасного типа:</target>
        </trans-unit>
        <trans-unit id="5219c72bd04864634a1e88b3e8f66e09113a7f2a" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;n&lt;/code&gt;'s &lt;code&gt;i&lt;/code&gt;'th child.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40e8a56834c6a89deae8c24980dea5a106cc1dc" translate="yes" xml:space="preserve">
          <source>Get PSK identity.</source>
          <target state="translated">Получи удостоверение личности PSK.</target>
        </trans-unit>
        <trans-unit id="9c6b60808c47d23e2b6771a2d38777564ed24388" translate="yes" xml:space="preserve">
          <source>Get Proxy URL from environment variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a2ad39e6ce26d304194dfe8051981d34f5f859" translate="yes" xml:space="preserve">
          <source>Get current implementation of &lt;code&gt;callSoon&lt;/code&gt;.</source>
          <target state="translated">Получите текущую реализацию &lt;code&gt;callSoon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5454dcbb9ac5865ed0ee9c43e8d6c25d91b7171b" translate="yes" xml:space="preserve">
          <source>Get current rounding direction.</source>
          <target state="translated">Получить текущее направление округления.</target>
        </trans-unit>
        <trans-unit id="e9ac6d6364d34abd1d69bdc24707956d93bef51b" translate="yes" xml:space="preserve">
          <source>Get network socket, useful if you want to find out more details about the connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7502d212d9b35c5b4b2cd744a48143b4ef4139" translate="yes" xml:space="preserve">
          <source>Get string representation of &lt;code&gt;TimeInterval&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12714742014fb6228a1c3f36ea543012ada95c75" translate="yes" xml:space="preserve">
          <source>Get string representation of &lt;em&gt;TimeInterval&lt;/em&gt;</source>
          <target state="translated">Получить строковое представление &lt;em&gt;TimeInterval&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad54c08fe8749a0e81ff7837b23c3157c0895d10" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Timezone&lt;/code&gt; implementation for the UTC timezone.</source>
          <target state="translated">Получите реализацию &lt;code&gt;Timezone&lt;/code&gt; для часового пояса UTC.</target>
        </trans-unit>
        <trans-unit id="130ee2f075e62422a363a8a189c3d9f93794fbf2" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Timezone&lt;/code&gt; implementation for the local timezone.</source>
          <target state="translated">Получить &lt;code&gt;Timezone&lt;/code&gt; реализацию для местного часового пояса.</target>
        </trans-unit>
        <trans-unit id="7990a11666434ac5f784621308133dfb7f2f044d" translate="yes" xml:space="preserve">
          <source>Get the current &lt;code&gt;MonoTime&lt;/code&gt; timestamp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c7e7bb6bfadc9b10aaa987304f7abf1345c0db" translate="yes" xml:space="preserve">
          <source>Get the current time as a &lt;code&gt;DateTime&lt;/code&gt; in the local timezone.</source>
          <target state="translated">Получите текущее время как &lt;code&gt;DateTime&lt;/code&gt; в местном часовом поясе.</target>
        </trans-unit>
        <trans-unit id="11562b1334027fecd5dcb805739b82f536f9c783" translate="yes" xml:space="preserve">
          <source>Get the fractional part of a &lt;code&gt;Time&lt;/code&gt; as the number of nanoseconds of the second.</source>
          <target state="translated">Получите дробную часть &lt;code&gt;Time&lt;/code&gt; как количество наносекунд секунды.</target>
        </trans-unit>
        <trans-unit id="28122ec43897f8843b8ea9fdf99ecd6c1be76468" translate="yes" xml:space="preserve">
          <source>Get the longest representable duration of negative direction.</source>
          <target state="translated">Получите самую длинную репрезентативную длительность отрицательного направления.</target>
        </trans-unit>
        <trans-unit id="7bdc6c0918cf5d26da44cabeb23abccc70e09b4e" translate="yes" xml:space="preserve">
          <source>Get the longest representable duration.</source>
          <target state="translated">Получите самую длинную представительную продолжительность.</target>
        </trans-unit>
        <trans-unit id="ba447136ea635e0aab9dc6afff0ec9f2acc09668" translate="yes" xml:space="preserve">
          <source>Get the next token from the parser's lexer, and store it in the parser's &lt;code&gt;tok&lt;/code&gt; member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d064c02ff711820791ab991a62468a0815f7d265" translate="yes" xml:space="preserve">
          <source>Get the number of days in &lt;code&gt;month&lt;/code&gt; of &lt;code&gt;year&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf89b2420cafea5152352e14cc484f7a750ccd87" translate="yes" xml:space="preserve">
          <source>Get the number of days in a &lt;code&gt;month&lt;/code&gt; of a &lt;code&gt;year&lt;/code&gt;.</source>
          <target state="translated">Получите количество дней в &lt;code&gt;month&lt;/code&gt; в &lt;code&gt;year&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a91e315a40bea130b02d973a8401879d06157a88" translate="yes" xml:space="preserve">
          <source>Get the number of days in a &lt;code&gt;year&lt;/code&gt;</source>
          <target state="translated">Получите количество дней в &lt;code&gt;year&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f8e6af49ebd57b98c32b3bef36972e51d6956de" translate="yes" xml:space="preserve">
          <source>Get the pragma of a proc type These will be expanded</source>
          <target state="translated">Получите прагму типа &quot;proc&quot;.Они будут расширены.</target>
        </trans-unit>
        <trans-unit id="b4f54efaa84c02fb948f2230067248cb50cecece" translate="yes" xml:space="preserve">
          <source>Get the pragma of a proc type. These will be expanded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fb3d2f912aad36a7a2fab3df616b85598528a1" translate="yes" xml:space="preserve">
          <source>Get the socket's local address and port number.</source>
          <target state="translated">Получите местный адрес сокета и номер порта.</target>
        </trans-unit>
        <trans-unit id="ed61d3d7776639eccbb79106f8cddd298594c0ca" translate="yes" xml:space="preserve">
          <source>Get the socket's peer address and port number.</source>
          <target state="translated">Получите адрес и номер порта сокета.</target>
        </trans-unit>
        <trans-unit id="723d6575987f98cca4d17c0950fa5dba4078249b" translate="yes" xml:space="preserve">
          <source>Get the string of an identifier node</source>
          <target state="translated">Получить строку узла идентификатора</target>
        </trans-unit>
        <trans-unit id="12073f349102ad84aa4a0525eafd4479cd49fcf0" translate="yes" xml:space="preserve">
          <source>Get the string of an identifier node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3f4a8c20a8d9ffaecbbd07858ab29467163519" translate="yes" xml:space="preserve">
          <source>Get the string representation of the &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99521d6ef98a806e912444f989eca6e635eefe5" translate="yes" xml:space="preserve">
          <source>Get the string representation of this option. If the option has a value, the result will be &lt;em&gt;Some(x)&lt;/em&gt; where &lt;em&gt;x&lt;/em&gt; is the string representation of the contained value. If the option does not have a value, the result will be &lt;em&gt;None[T]&lt;/em&gt; where &lt;em&gt;T&lt;/em&gt; is the name of the type contained in the option.</source>
          <target state="translated">Получите строковое представление этой опции. Если параметр имеет значение, результатом будет &lt;em&gt;Some (x),&lt;/em&gt; где &lt;em&gt;x&lt;/em&gt; - строковое представление содержащегося значения. Если параметр не имеет значения, результатом будет &lt;em&gt;Нет [T],&lt;/em&gt; где &lt;em&gt;T&lt;/em&gt; - имя типа, содержащегося в параметре.</target>
        </trans-unit>
        <trans-unit id="d460591b4c527055a972fa5dd0628a7d7d96c7d1" translate="yes" xml:space="preserve">
          <source>Get type information for &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87fde255210c1b5747a10ad9f9fce9a84709dfe" translate="yes" xml:space="preserve">
          <source>Gets &lt;code&gt;n&lt;/code&gt;'s tag as a &lt;code&gt;HtmlTag&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e81c9ca7b9838c7aad39a88a6bc88879fb7071" translate="yes" xml:space="preserve">
          <source>Gets &lt;em&gt;n&lt;/em&gt;'s tag as a &lt;code&gt;HtmlTag&lt;/code&gt;.</source>
          <target state="translated">Получает тег &lt;em&gt;n&lt;/em&gt; как &lt;code&gt;HtmlTag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1564152a0ef38676369c9a5ef127f13b4deb3e" translate="yes" xml:space="preserve">
          <source>Gets a cookie. If no cookie of &lt;code&gt;name&lt;/code&gt; exists, &quot;&quot; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13689de7004dbf96d752346d793d33acafe479cd" translate="yes" xml:space="preserve">
          <source>Gets a cookie. If no cookie of &lt;em&gt;name&lt;/em&gt; exists, &quot;&quot; is returned.</source>
          <target state="translated">Получает куки. Если файл cookie с &lt;em&gt;именем не&lt;/em&gt; существует, возвращается &quot;&quot;.</target>
        </trans-unit>
        <trans-unit id="b7973bd1edf3d8cfdba5e45c82a3bad70d6e244f" translate="yes" xml:space="preserve">
          <source>Gets a field from a &lt;code&gt;JObject&lt;/code&gt;, which must not be nil. If the value at &lt;code&gt;name&lt;/code&gt; does not exist, raises KeyError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11dc4d2dc18b3b4694d9f2f07be175ba7c66cef" translate="yes" xml:space="preserve">
          <source>Gets a field from a &lt;code&gt;node&lt;/code&gt;. If &lt;code&gt;node&lt;/code&gt; is nil or not an object or value at &lt;code&gt;key&lt;/code&gt; does not exist, returns nil</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ee6b6486187c570cea3bd16707c23edffa1180" translate="yes" xml:space="preserve">
          <source>Gets a field from a &lt;em&gt;JObject&lt;/em&gt;, which must not be nil. If the value at &lt;em&gt;name&lt;/em&gt; does not exist, raises KeyError.</source>
          <target state="translated">Получает поле из &lt;em&gt;JObject&lt;/em&gt; , которое не должно быть нулевым. Если значение по &lt;em&gt;имени&lt;/em&gt; не существует, вызывает KeyError.</target>
        </trans-unit>
        <trans-unit id="f35abda3cff44672e27443c29310a4342a3a7c85" translate="yes" xml:space="preserve">
          <source>Gets a field from a &lt;em&gt;node&lt;/em&gt;. If &lt;em&gt;node&lt;/em&gt; is nil or not an object or value at &lt;em&gt;key&lt;/em&gt; does not exist, returns nil</source>
          <target state="translated">Получает поле из &lt;em&gt;узла&lt;/em&gt; . Если &lt;em&gt;узел&lt;/em&gt; равен нулю или не объект или значение в &lt;em&gt;ключе&lt;/em&gt; не существует, возвращает ноль</target>
        </trans-unit>
        <trans-unit id="35bb8b12e628c0e69e3c45da868773dc22a5afa1" translate="yes" xml:space="preserve">
          <source>Gets a field of &lt;code&gt;x&lt;/code&gt;; &lt;code&gt;x&lt;/code&gt; represents an object or a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e896ea8856279a92c23ca43823ce2065dfa17c" translate="yes" xml:space="preserve">
          <source>Gets extension which corresponds to &lt;code&gt;mimetype&lt;/code&gt;. Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;mimetype&lt;/code&gt; could not be found. Extensions are returned without the leading dot.</source>
          <target state="translated">Получает расширение, соответствующее &lt;code&gt;mimetype&lt;/code&gt; . Возвращает &lt;code&gt;default&lt;/code&gt; если &lt;code&gt;mimetype&lt;/code&gt; не найден. Расширения возвращаются без начальной точки.</target>
        </trans-unit>
        <trans-unit id="d2af21c40c8b2beb9e88592fc792fd5b511c29f1" translate="yes" xml:space="preserve">
          <source>Gets extension which corresponds to &lt;code&gt;mimetype&lt;/code&gt;. Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;mimetype&lt;/code&gt; could not be found. Extensions are returned without the leading dot. &lt;code&gt;mimetype&lt;/code&gt; is lowercased before querying &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08dcb1eea4061ffa3605412e9746813dfd3d3a3" translate="yes" xml:space="preserve">
          <source>Gets mimetype which corresponds to &lt;code&gt;ext&lt;/code&gt;. Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;ext&lt;/code&gt; could not be found. &lt;code&gt;ext&lt;/code&gt; can start with an optional dot which is ignored.</source>
          <target state="translated">Получает тип mimetype, соответствующий &lt;code&gt;ext&lt;/code&gt; . Возвращает &lt;code&gt;default&lt;/code&gt; если &lt;code&gt;ext&lt;/code&gt; не может быть найден. &lt;code&gt;ext&lt;/code&gt; может начинаться с необязательной точки, которая игнорируется.</target>
        </trans-unit>
        <trans-unit id="b40b8b0e4a7f80635eb7dd5403cfbd0754192e46" translate="yes" xml:space="preserve">
          <source>Gets mimetype which corresponds to &lt;code&gt;ext&lt;/code&gt;. Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;ext&lt;/code&gt; could not be found. &lt;code&gt;ext&lt;/code&gt; can start with an optional dot which is ignored. &lt;code&gt;ext&lt;/code&gt; is lowercased before querying &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1714560401ef5d53bb12109cf2cb88182bbf5caa" translate="yes" xml:space="preserve">
          <source>Gets the &lt;em&gt;NonTerminalFlag&lt;/em&gt;-typed flags field of the parent &lt;em&gt;Peg&lt;/em&gt; variant object of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">Получает поле флагов &lt;em&gt;типа&lt;/em&gt; NonTerminalFlag родительского объекта варианта &lt;em&gt;Peg&lt;/em&gt; данного &lt;em&gt;NonTerminal&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="92e639fc7e6c6f3a36a4b433e2efd44d76d332e9" translate="yes" xml:space="preserve">
          <source>Gets the &lt;em&gt;Peg&lt;/em&gt; object representing the rule definition of the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">Получает объект &lt;em&gt;Peg,&lt;/em&gt; представляющий определение правила варианта родительского объекта &lt;em&gt;Peg&lt;/em&gt; для данного &lt;em&gt;NonTerminal&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c65ea61d4f736dc4703e718edfd99f538b4da59e" translate="yes" xml:space="preserve">
          <source>Gets the ID of the currently running thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a31ab6e34d28da2594120eec11f6a9e165ade3" translate="yes" xml:space="preserve">
          <source>Gets the Key value of the specified Section.</source>
          <target state="translated">Получает Ключевое значение указанного Раздела.</target>
        </trans-unit>
        <trans-unit id="91e7e705912c92bc18ff83aa63ee0725cc8dd702" translate="yes" xml:space="preserve">
          <source>Gets the Nim command that the compiler has been invoked with, for example &quot;c&quot;, &quot;js&quot;, &quot;build&quot;, &quot;help&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db4276492a87292b45a2d798b8604d66f0972994" translate="yes" xml:space="preserve">
          <source>Gets the PSK identity provided by the client.</source>
          <target state="translated">Получает идентификатор PSK,предоставленный клиентом.</target>
        </trans-unit>
        <trans-unit id="ebc1991c3f4d76f5d82a1d1491c2bca82e49c8c2" translate="yes" xml:space="preserve">
          <source>Gets the associated text with the node &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936f98726360698f2fbd3879fd051a8034e01427" translate="yes" xml:space="preserve">
          <source>Gets the attributes belonging to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac591fc9023da962499b05992f4a42f885cb205" translate="yes" xml:space="preserve">
          <source>Gets the base type's kind; &lt;code&gt;akNone&lt;/code&gt; is returned if &lt;code&gt;x&lt;/code&gt; has no base type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67e2b7f4cd722e96c019267fd8f4fe2119fe30d" translate="yes" xml:space="preserve">
          <source>Gets the client data of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654f49772dc846fc7e8b0b5fafe8aba913ce8713" translate="yes" xml:space="preserve">
          <source>Gets the column number of the definition of the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">Получает номер столбца определения родительского варианта объекта &lt;em&gt;Peg&lt;/em&gt; для заданного &lt;em&gt;NonTerminal&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bd81d39ed2660b2a192796678428676c0ea999cd" translate="yes" xml:space="preserve">
          <source>Gets the current clock time as a string of the format &lt;code&gt;HH:MM:SS&lt;/code&gt;.</source>
          <target state="translated">Получает текущее время в виде строки формата &lt;code&gt;HH:MM:SS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3261759c69cac472d4a177821c0ced7e8297f225" translate="yes" xml:space="preserve">
          <source>Gets the current date as a string of the format &lt;code&gt;YYYY-MM-DD&lt;/code&gt;.</source>
          <target state="translated">Получает текущую дату в виде строки в формате &lt;code&gt;YYYY-MM-DD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60b12a7fed9331a75165888138ad3b08fe8cbcc6" translate="yes" xml:space="preserve">
          <source>Gets the current local clock time as a string of the format &lt;code&gt;HH:mm:ss&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276d1c12f54046c33015b7f91c050da08f21e286" translate="yes" xml:space="preserve">
          <source>Gets the current local date as a string of the format &lt;code&gt;YYYY-MM-DD&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef62ba4079b74bbe4d31e0e21d470ddb156867e" translate="yes" xml:space="preserve">
          <source>Gets the current stack trace. This only works for debug builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="247d662645bc1637ead4656674f1a702738e8829" translate="yes" xml:space="preserve">
          <source>Gets the current time as a &lt;code&gt;Time&lt;/code&gt; with nanosecond resolution.</source>
          <target state="translated">Получает текущее время как &lt;code&gt;Time&lt;/code&gt; с разрешением наносекунды.</target>
        </trans-unit>
        <trans-unit id="0387f3706b353d7ae3e0089106d53591957c6c1e" translate="yes" xml:space="preserve">
          <source>Gets the current time as a &lt;code&gt;Time&lt;/code&gt; with up to nanosecond resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15dce4c95e8e6cf70f2ff21d4705069a9f68f3e" translate="yes" xml:space="preserve">
          <source>Gets the enum field name as a string. &lt;code&gt;x&lt;/code&gt; needs to represent an enum but is only used to access the type information. The field name of &lt;code&gt;ordinalValue&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53bd1efd24342f90bb1e0532dc257b89f8a50185" translate="yes" xml:space="preserve">
          <source>Gets the enum field name as a string. &lt;code&gt;x&lt;/code&gt; needs to represent an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c31138e270bd37015494e80deb2dc7d4ff50d4" translate="yes" xml:space="preserve">
          <source>Gets the enum field ordinal from &lt;code&gt;name&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent an enum but is only used to access the type information. In case of an error &lt;code&gt;low(int)&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c769de6a12c15bcc2c5b444e497708dc0f8ed81" translate="yes" xml:space="preserve">
          <source>Gets the global log filter.</source>
          <target state="translated">Получает фильтр глобального журнала.</target>
        </trans-unit>
        <trans-unit id="f9ac85ebfe353ff303610a6fd2becb00c94ca921" translate="yes" xml:space="preserve">
          <source>Gets the inner text of &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8967e163fbdddcb42a598980b8edacf5b388afd" translate="yes" xml:space="preserve">
          <source>Gets the key value of the specified Section. Returns the specified default value if the specified key does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d0ac9e5207f2824570ddf9a5876cb435b1720a" translate="yes" xml:space="preserve">
          <source>Gets the line number of the definition of the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">Получает номер строки определения родительского варианта объекта &lt;em&gt;Peg&lt;/em&gt; для заданного &lt;em&gt;NonTerminal&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="56bd530836a48d9d37ff0198c3155398e3eb5899" translate="yes" xml:space="preserve">
          <source>Gets the name of the symbol represented by the parent &lt;em&gt;Peg&lt;/em&gt; object variant of a given &lt;em&gt;NonTerminal&lt;/em&gt;.</source>
          <target state="translated">Получает имя символа, представленного вариантом родительского объекта &lt;em&gt;Peg&lt;/em&gt; для заданного &lt;em&gt;NonTerminal&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="28c7fc583337027cefdf3b98cef719005d99ad53" translate="yes" xml:space="preserve">
          <source>Gets the node at &lt;code&gt;index&lt;/code&gt; in an Array. Result is undefined if &lt;code&gt;index&lt;/code&gt; is out of bounds, but as long as array bound checks are enabled it will result in an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fbf54936c22fd972d85ed8d34160d9e21cbc39" translate="yes" xml:space="preserve">
          <source>Gets the node at &lt;em&gt;index&lt;/em&gt; in a List. Result is undefined if &lt;em&gt;index&lt;/em&gt; is out of bounds</source>
          <target state="translated">Получает узел по &lt;em&gt;индексу&lt;/em&gt; в списке. Результат не определен, если &lt;em&gt;индекс&lt;/em&gt; выходит за границы</target>
        </trans-unit>
        <trans-unit id="f194ace764156524b46a54cf14a3d07dfbe7aad4" translate="yes" xml:space="preserve">
          <source>Gets the node at &lt;em&gt;index&lt;/em&gt; in an Array. Result is undefined if &lt;em&gt;index&lt;/em&gt; is out of bounds, but as long as array bound checks are enabled it will result in an exception.</source>
          <target state="translated">Получает узел по &lt;em&gt;индексу&lt;/em&gt; в массиве. Результат не определен, если &lt;em&gt;индекс&lt;/em&gt; выходит за границы, но пока включены проверки привязки массива, это приведет к исключению.</target>
        </trans-unit>
        <trans-unit id="6156c88c4b6d8c7a399e02c694bf7eec39c53e38" translate="yes" xml:space="preserve">
          <source>Gets the prefix dir, usually the parent directory where the binary resides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c0ad78f97cef0021b972740f623249afeb780e" translate="yes" xml:space="preserve">
          <source>Gets the stack trace associated with &lt;code&gt;e&lt;/code&gt;, which is the stack that lead to the &lt;code&gt;raise&lt;/code&gt; statement. This only works for debug builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717d2eaa7b1c9858103e02d4ee329a6170804578" translate="yes" xml:space="preserve">
          <source>Gets the tag name of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3214d0ee72fb998da82e83db8adabb0cda1041" translate="yes" xml:space="preserve">
          <source>Gets the type kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20eff627fc48b7117674c6eedeb81d0d7a63a779" translate="yes" xml:space="preserve">
          <source>Gets time after the UNIX epoch (1970) in seconds. It is a float because sub-second resolution is likely to be supported (depending on the hardware/OS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f692087775e023d27920954ba6a5491569dce2" translate="yes" xml:space="preserve">
          <source>Gets time spent that the CPU spent to run the current process in seconds. This may be more useful for benchmarking than &lt;code&gt;epochTime&lt;/code&gt;. However, it may measure the real time instead (depending on the OS). The value of the result has no meaning. To generate useful timing values, take the difference between the results of two &lt;code&gt;cpuTime&lt;/code&gt; calls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329aa8af8f1565e4ae1eb4a65d49566bcb3acd69" translate="yes" xml:space="preserve">
          <source>Getting a blocking client from an AsyncSocket</source>
          <target state="translated">Получение блокирующего клиента из AsyncSocket.</target>
        </trans-unit>
        <trans-unit id="fccf5719a0d1339930e0856ea9d166d1d319d2fa" translate="yes" xml:space="preserve">
          <source>Gives the difference between &lt;code&gt;startDt&lt;/code&gt; and &lt;code&gt;endDt&lt;/code&gt; as a &lt;code&gt;TimeInterval&lt;/code&gt;. The following guarantees about the result is given:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03e100088f945af4a3c80b4c540244a44679c31" translate="yes" xml:space="preserve">
          <source>Global configuration files under /etc/nim</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef086870f2969d8fb668096b14518cd761c2738" translate="yes" xml:space="preserve">
          <source>GlobalVar</source>
          <target state="translated">GlobalVar</target>
        </trans-unit>
        <trans-unit id="2e0b45f2a456e8db55f08d7b65e87593a3e9a140" translate="yes" xml:space="preserve">
          <source>Go</source>
          <target state="translated">Go</target>
        </trans-unit>
        <trans-unit id="334f5022e7034a30c9d505d7796ba0335c961cbe" translate="yes" xml:space="preserve">
          <source>Goal.borrowChecking</source>
          <target state="translated">Goal.borrowChecking</target>
        </trans-unit>
        <trans-unit id="96311f1bbb4b89b89e7fee8588b3ce2f77acac56" translate="yes" xml:space="preserve">
          <source>Goal.constParameters</source>
          <target state="translated">Goal.constParameters</target>
        </trans-unit>
        <trans-unit id="652a20e779c3edb40a565e088aa9ec6a08f8a6c6" translate="yes" xml:space="preserve">
          <source>Goal.cursorInference</source>
          <target state="translated">Goal.cursorInference</target>
        </trans-unit>
        <trans-unit id="0cabce54968037724a189b4346cbb44ec0484c3d" translate="yes" xml:space="preserve">
          <source>Goal:</source>
          <target state="translated">Goal:</target>
        </trans-unit>
        <trans-unit id="03d0355833db6c38ad46b8c25161e0ab548b7757" translate="yes" xml:space="preserve">
          <source>Graceful Fallback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="4ff36b989c4ec5364741f73abb04f8673b791c08" translate="yes" xml:space="preserve">
          <source>Grouping: Parenthesis can be used to change operator priority.</source>
          <target state="translated">Группировка:С помощью скобки можно изменить приоритет оператора.</target>
        </trans-unit>
        <trans-unit id="f824be4c07d044b0a16411ca3a8b4fc4a03b1f51" translate="yes" xml:space="preserve">
          <source>Grows or shrinks a given memory block on the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d9269d97953fa1fa172932fc112e70b8360490" translate="yes" xml:space="preserve">
          <source>Grows or shrinks a given memory block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfbbb729d4d05d687e4d3812ac17e60d6a1d04a" translate="yes" xml:space="preserve">
          <source>GrowthFactor:</source>
          <target state="translated">GrowthFactor:</target>
        </trans-unit>
        <trans-unit id="db8f40454de4a3c5f9326c0b5a2982f87e8e8255" translate="yes" xml:space="preserve">
          <source>Guards and locks</source>
          <target state="translated">Охрана и замки</target>
        </trans-unit>
        <trans-unit id="2bd9bcf38059609e0eeeb386a0d770db57a4886d" translate="yes" xml:space="preserve">
          <source>Guards and the locks section</source>
          <target state="translated">Охрана и секция замков</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="f86fb5b0e4e4aba5bf48c3f733a13e62daa3f128" translate="yes" xml:space="preserve">
          <source>HTML DOM Aria Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d7ad1571583a88d359a165c32f4d98121c941b" translate="yes" xml:space="preserve">
          <source>HTML DOM Common Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c9ed7b4b0f4c4cbe29ccb07ab4ecb8ff0e1d2d" translate="yes" xml:space="preserve">
          <source>HTML DOM Core Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c8c8533abee764b1f743ea4422f18d94cff3fd" translate="yes" xml:space="preserve">
          <source>HTML DOM Event Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b670aa89386f34895332e01e04f3dc802e9f3d5c" translate="yes" xml:space="preserve">
          <source>HTML anchor generation</source>
          <target state="translated">генерация HTML-анкеров</target>
        </trans-unit>
        <trans-unit id="a2ef27ac824bc904fefaa0d0d28b7f8253599ae9" translate="yes" xml:space="preserve">
          <source>HTML tags are case insensitive, XML tags are case sensitive. Since this library can parse both, only the client knows which comparison is to be used.</source>
          <target state="translated">HTML-теги не чувствительны к регистру,XML-теги чувствительны к регистру.Так как эта библиотека может разобрать и то,и другое,то только клиент знает,какое сравнение будет использоваться.</target>
        </trans-unit>
        <trans-unit id="362f233bfd36bbe9ffba21ece507104cececa24e" translate="yes" xml:space="preserve">
          <source>Handlers</source>
          <target state="translated">Handlers</target>
        </trans-unit>
        <trans-unit id="194f68d829d02bf8087b17ed3a49b755b9584b08" translate="yes" xml:space="preserve">
          <source>Handling Exceptions</source>
          <target state="translated">Исключения при обращении</target>
        </trans-unit>
        <trans-unit id="0ad54594ca575043b9dce31b4a4bf4d6b5f96af0" translate="yes" xml:space="preserve">
          <source>Handling optional keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260da45171e90fa3c6347df36e669fab555188ca" translate="yes" xml:space="preserve">
          <source>Hash sets are different from the &lt;a href=&quot;manual#types-set-type&quot;&gt;built in set type&lt;/a&gt;. Sets allow you to store any value that can be &lt;a href=&quot;hashes&quot;&gt;hashed&lt;/a&gt; and they don't contain duplicate entries.</source>
          <target state="translated">Хеш-наборы отличаются от &lt;a href=&quot;manual#types-set-type&quot;&gt;встроенных наборов&lt;/a&gt; . Наборы позволяют хранить любое значение, которое может быть &lt;a href=&quot;hashes&quot;&gt;хешировано,&lt;/a&gt; и не содержат повторяющихся записей.</target>
        </trans-unit>
        <trans-unit id="7a473e47b59092b03dd1448042a57562e118bc2e" translate="yes" xml:space="preserve">
          <source>Hash table that counts the number of each key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4a2b500895ac4b70ba425d1b1f35bfdaaaaf1f" translate="yes" xml:space="preserve">
          <source>Hash table that remembers insertion order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beae2044fdc9cc3eb616c7214470e48cd3252524" translate="yes" xml:space="preserve">
          <source>Hashes an array of bytes of size &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="13650a25502e1bcae35551cd38b7ddc7b60b6e44" translate="yes" xml:space="preserve">
          <source>Hashing of HashSet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1809488fc3457f3ae3c7f6df26f47396f9a03ee" translate="yes" xml:space="preserve">
          <source>Hashing of OrderedSet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379820ada71e6fc460419ac92a81ed0859a3ea71" translate="yes" xml:space="preserve">
          <source>Have test results printed in color. Default is true for the non-js target, for which &lt;code&gt;stdout&lt;/code&gt; is a tty. Setting the environment variable &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; to &lt;code&gt;always&lt;/code&gt; or &lt;code&gt;never&lt;/code&gt; changes the default for the non-js target to true or false respectively. The deprecated environment variable &lt;code&gt;NIMTEST_NO_COLOR&lt;/code&gt;, when set, changes the defualt to true, if &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; is undefined.</source>
          <target state="translated">Распечатайте результаты теста в цвете. По умолчанию true для цели, отличной от js, для которой &lt;code&gt;stdout&lt;/code&gt; является tty. Установка переменной среды &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; на &lt;code&gt;always&lt;/code&gt; или &lt;code&gt;never&lt;/code&gt; изменяет значение по умолчанию для цели, отличной от js, на true или false соответственно. &lt;code&gt;NIMTEST_NO_COLOR&lt;/code&gt; переменная среды NIMTEST_NO_COLOR , если она установлена, изменяет значение по умолчанию на true, если &lt;code&gt;NIMTEST_COLOR&lt;/code&gt; не определено.</target>
        </trans-unit>
        <trans-unit id="23843a4a411f31b588dbb2d3c2973e3567ff072f" translate="yes" xml:space="preserve">
          <source>Header pragma</source>
          <target state="translated">Заголовочный прагматик</target>
        </trans-unit>
        <trans-unit id="34a7e13c971024e72f200af89b16d872ead96102" translate="yes" xml:space="preserve">
          <source>Header to use for complete XML output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977169a2f56615065497cd1735f54129679d50ec" translate="yes" xml:space="preserve">
          <source>Heap</source>
          <target state="translated">Heap</target>
        </trans-unit>
        <trans-unit id="73a2a0df8c0716bca2e8f0a3245d12dcc9011dbf" translate="yes" xml:space="preserve">
          <source>Heap dump</source>
          <target state="translated">Кучная свалка</target>
        </trans-unit>
        <trans-unit id="cd81a03d092d8f4c8cc38f239229d0a6b095622c" translate="yes" xml:space="preserve">
          <source>Heap queue algorithm (a.k.a. priority queue). Ported from Python heapq.</source>
          <target state="translated">Алгоритм кучной очереди (так же известный как приоритетная очередь).Портирован из Python heapq.</target>
        </trans-unit>
        <trans-unit id="8131611ca642b3a3b9f02be683c0bd269e027af5" translate="yes" xml:space="preserve">
          <source>Heaps are arrays for which a[k] &amp;lt;= a[2*k+1] and a[k] &amp;lt;= a[2*k+2] for all k, counting elements from 0. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that a[0] is always its smallest element.</source>
          <target state="translated">Кучи - это массивы, для которых a [k] &amp;lt;= a [2 * k + 1] и a [k] &amp;lt;= a [2 * k + 2] для всех k, считая элементы от 0. Для сравнения, non -существующие элементы считаются бесконечными. Интересным свойством кучи является то, что [0] всегда является ее наименьшим элементом.</target>
        </trans-unit>
        <trans-unit id="0519b0503186bc1f59cca3b56dc1223ef363db94" translate="yes" xml:space="preserve">
          <source>Helper for performing user-defined range checks. Such checks will be performed only when the &lt;code&gt;rangechecks&lt;/code&gt; compile-time option is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ce8e260901a579961746d0c4e5b3aa2323e89e" translate="yes" xml:space="preserve">
          <source>Helpers for binaries that use compiler passes, e.g.: nim, nimsuggest, nimfix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe815bc3011561cb8a3933b51b18ec4e9c969d5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;odd&lt;/code&gt; depends on &lt;code&gt;even&lt;/code&gt; and vice versa. Thus &lt;code&gt;even&lt;/code&gt; needs to be introduced to the compiler before it is completely defined. The syntax for such a forward declaration is simple: just omit the &lt;code&gt;=&lt;/code&gt; and the procedure's body. The &lt;code&gt;assert&lt;/code&gt; just adds border conditions, and will be covered later in &lt;a href=&quot;#modules&quot;&gt;Modules&lt;/a&gt; section.</source>
          <target state="translated">Здесь &lt;code&gt;odd&lt;/code&gt; зависит от &lt;code&gt;even&lt;/code&gt; и наоборот. Таким образом, компилятор нужно &lt;code&gt;even&lt;/code&gt; представить, прежде чем он будет полностью определен. Синтаксис такого прямого объявления прост: просто опустите &lt;code&gt;=&lt;/code&gt; и тело процедуры. &lt;code&gt;assert&lt;/code&gt; , только добавляет граничные условия, и будут рассмотрены далее в &lt;a href=&quot;#modules&quot;&gt;модулях&lt;/a&gt; раздела.</target>
        </trans-unit>
        <trans-unit id="17aefe7b7076c916d73873643615cffec4a39033" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;var T from container&lt;/code&gt; explicitly exposes that the location is derived from the second parameter (called 'container' in this case). The syntax &lt;code&gt;var T from p&lt;/code&gt; specifies a type &lt;code&gt;varTy[T, 2]&lt;/code&gt; which is incompatible with &lt;code&gt;varTy[T, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b85b0f3abb03a93662419b1e5d9c37d24bb18a1" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;var T from container&lt;/code&gt; explicitly exposes that the location is deviated from the second parameter (called 'container' in this case). The syntax &lt;code&gt;var T from p&lt;/code&gt; specifies a type &lt;code&gt;varTy[T, 2]&lt;/code&gt; which is incompatible with &lt;code&gt;varTy[T, 1]&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;var T from container&lt;/code&gt; явно указывает на отклонение местоположения от второго параметра (в данном случае называемого &amp;laquo;контейнером&amp;raquo;). Синтаксис &lt;code&gt;var T from p&lt;/code&gt; определяет тип &lt;code&gt;varTy[T, 2]&lt;/code&gt; который несовместим с &lt;code&gt;varTy[T, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="249bc2bb97f90836e8e318de7900778d15e98366" translate="yes" xml:space="preserve">
          <source>Here are few examples of using the &lt;code&gt;switch&lt;/code&gt; proc:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b366ec3bfeb8e69a8b8038b2ee4c1d6a28ea529d" translate="yes" xml:space="preserve">
          <source>Here are more examples that illustrate implicit generics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474408b78552b4a0d7ae5fdabc19bf252fc0eb8c" translate="yes" xml:space="preserve">
          <source>Here are some examples for Unix:</source>
          <target state="translated">Вот несколько примеров для Unix:</target>
        </trans-unit>
        <trans-unit id="4f50999e368be6860526051c42f03020821896ea" translate="yes" xml:space="preserve">
          <source>Here is a short overview of the most commonly used functions from the &lt;code&gt;system&lt;/code&gt; module. Function names in the tables below are clickable and will take you to the full documentation of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b5a5ccfafdc873c836f01f1f7137f9ef720f3e" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use the configuration file parser:</source>
          <target state="translated">Приведем пример использования анализатора конфигурационных файлов:</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23c6c65d4dacf92bd4b7dd12966aa26aed4b8f6" translate="yes" xml:space="preserve">
          <source>Here is how a typical multilock statement can be implemented in Nim. Note how the runtime check is required to ensure a global ordering for two locks &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; of the same lock level:</source>
          <target state="translated">Вот как в Nim может быть реализован типичный оператор multilock. Обратите внимание, что проверка времени выполнения требуется для обеспечения глобального упорядочения двух блокировок &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; одного уровня блокировки:</target>
        </trans-unit>
        <trans-unit id="16ec3351fc3909ec123a9438e435e521a554ccaf" translate="yes" xml:space="preserve">
          <source>Here is how to set a timeout when creating an &lt;code&gt;HttpClient&lt;/code&gt; instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8056266ad685c758cc11b7e966ef3226e799b6f" translate="yes" xml:space="preserve">
          <source>Here is some example usage of this module:</source>
          <target state="translated">Приведем пример использования этого модуля:</target>
        </trans-unit>
        <trans-unit id="87a765729a3650e7d53f6368f7d2640621d5290e" translate="yes" xml:space="preserve">
          <source>Here you can see an example about how to set the &lt;code&gt;maxRedirects&lt;/code&gt; of &lt;code&gt;HttpClient&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d75a6bc3a26bf7e15a375f54de00e7b3a24d49e" translate="yes" xml:space="preserve">
          <source>Heterogeneous arrays are not supported.</source>
          <target state="translated">Гетерогенные массивы не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="9a472603c4793ba32a26895360ca1c167352b47b" translate="yes" xml:space="preserve">
          <source>Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9.</source>
          <target state="translated">Гекс-формат.Выводит число в базе 16,используя строчные буквы для цифр выше 9.</target>
        </trans-unit>
        <trans-unit id="16ecf8c049c3a3fc4daf4d45c04ec54049be9338" translate="yes" xml:space="preserve">
          <source>Hex format. Outputs the number in base 16, using uppercase letters for the digits above 9.</source>
          <target state="translated">Гекс-формат.Выводит число в базе 16,используя заглавные буквы для цифр выше 9.</target>
        </trans-unit>
        <trans-unit id="c64b0888277a234e68d21751554b1e7fd37d63e3" translate="yes" xml:space="preserve">
          <source>Hides the cursor.</source>
          <target state="translated">Скрывает курсор.</target>
        </trans-unit>
        <trans-unit id="201789f2014169f3fb9b5be056554d96ad45efe9" translate="yes" xml:space="preserve">
          <source>Higher-level version of &lt;code&gt;recv&lt;/code&gt; which returns a string.</source>
          <target state="translated">Версия &lt;code&gt;recv&lt;/code&gt; более высокого уровня, которая возвращает строку.</target>
        </trans-unit>
        <trans-unit id="375f88a238b922b4a8492616aa39100964dc9e28" translate="yes" xml:space="preserve">
          <source>Higher-level version of &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">Версия &lt;code&gt;recv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bf286ced5eb8cc0d307365394fbc65d95b6115c" translate="yes" xml:space="preserve">
          <source>Hints on the build process:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4fdd84cd707355c0d4470ac34583b420b822e4" translate="yes" xml:space="preserve">
          <source>Hints the optimizer that &lt;code&gt;val&lt;/code&gt; is likely going to be false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f177d57d6287dec01b0af7f6ebac21c70b91405" translate="yes" xml:space="preserve">
          <source>Hints the optimizer that &lt;code&gt;val&lt;/code&gt; is likely going to be true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e181cef40f6b34c1f59ee5117ab9fb62d1330e72" translate="yes" xml:space="preserve">
          <source>Hints the optimizer that &lt;em&gt;val&lt;/em&gt; is likely going to be false.</source>
          <target state="translated">Подсказывает оптимизатору, что &lt;em&gt;val&lt;/em&gt; , вероятно, будет ложным.</target>
        </trans-unit>
        <trans-unit id="19f673072699a2a1b1f923ef0f54e924acd06dc7" translate="yes" xml:space="preserve">
          <source>Hints the optimizer that &lt;em&gt;val&lt;/em&gt; is likely going to be true.</source>
          <target state="translated">Подсказывает оптимизатору, что &lt;em&gt;val&lt;/em&gt; , скорее всего, будет правдой.</target>
        </trans-unit>
        <trans-unit id="8393d3af1bb0b9c3fc06f67e4b0baddd2f8abb94" translate="yes" xml:space="preserve">
          <source>Historically, Nim was a fully &lt;span id=&quot;styleminusinsensitive_1&quot;&gt;style-insensitive&lt;/span&gt; language. This meant that it was not case-sensitive and underscores were ignored and there was not even a distinction between &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Исторически Ним был языком, полностью &lt;span id=&quot;styleminusinsensitive_1&quot;&gt;нечувствительным к стилю&lt;/span&gt; . Это означало, что регистр не учитывался, подчеркивания игнорировались, и даже не было различия между &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9737de0ba24413c483e0607526157c6b5607222d" translate="yes" xml:space="preserve">
          <source>Hook generation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823d6faf924048154ea05aa93a8b2406e5e4a84f" translate="yes" xml:space="preserve">
          <source>Hook lifting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb7c24bb94fb8d304cae1d3ff1be0dcb43bbb49" translate="yes" xml:space="preserve">
          <source>Hot code reloading</source>
          <target state="translated">Перезагрузка горячего кода</target>
        </trans-unit>
        <trans-unit id="c48d4d3dd643b4c5ee380d17a07cb4815d3859c3" translate="yes" xml:space="preserve">
          <source>How long is a day?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ec9f4760713f74026109bf0ded7ccc69847229" translate="yes" xml:space="preserve">
          <source>How the RTL is compiled</source>
          <target state="translated">Как компилируется RTL</target>
        </trans-unit>
        <trans-unit id="edc42b66f73d1503ac061b4ce145b9a1dd7e0b1b" translate="yes" xml:space="preserve">
          <source>How to deal with an absence of a value:</source>
          <target state="translated">Как справиться с отсутствием ценности:</target>
        </trans-unit>
        <trans-unit id="7980a8ae26b43f84582fc4763e99898544da0dad" translate="yes" xml:space="preserve">
          <source>However before the PATH is used the current directory is checked for the file's existence. So if PATH contains &lt;code&gt;$lib&lt;/code&gt; and &lt;code&gt;$lib/bar&lt;/code&gt; and the directory structure looks like this:</source>
          <target state="translated">Однако перед использованием PATH текущий каталог проверяется на наличие файла. Итак, если PATH содержит &lt;code&gt;$lib&lt;/code&gt; и &lt;code&gt;$lib/bar&lt;/code&gt; а структура каталогов выглядит так:</target>
        </trans-unit>
        <trans-unit id="737a9761248665739efdb7e092488b1f4438a576" translate="yes" xml:space="preserve">
          <source>However it is not efficient to do:</source>
          <target state="translated">Однако это неэффективно:</target>
        </trans-unit>
        <trans-unit id="2cbd76edbf731ff982e8e168638d25504365da00" translate="yes" xml:space="preserve">
          <source>However later versions of the language might change this to mean &quot;infer the parameters' types from the body&quot;. Then the above &lt;code&gt;foo&lt;/code&gt; would be rejected as the parameters' types can not be inferred from an empty &lt;code&gt;discard&lt;/code&gt; statement.</source>
          <target state="translated">Однако более поздние версии языка могут изменить это значение, чтобы оно означало &amp;laquo;выводить типы параметров из тела&amp;raquo;. Тогда приведенный выше &lt;code&gt;foo&lt;/code&gt; будет отклонен, поскольку типы параметров не могут быть выведены из пустого оператора &lt;code&gt;discard&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="368170efcb2db228f96a4630432ea5c83ce54ea6" translate="yes" xml:space="preserve">
          <source>However such features are not context sensitive and work simply on string matching, which can be problematic in Nim especially due to the case insensitiveness of the language (plus underscores as separators!).</source>
          <target state="translated">Однако такие возможности не чувствительны к контексту и работают просто на согласовании строк,что может быть проблематично в Nim,особенно из-за нечувствительности языка к регистру (плюс подчеркивания в качестве разделителей!).</target>
        </trans-unit>
        <trans-unit id="c8aede1d3274012cc4621182cf281306471b02d9" translate="yes" xml:space="preserve">
          <source>However the biggest problem is that dead code elimination breaks modularity! To see why, consider this scenario: The module &lt;code&gt;G&lt;/code&gt; (for example the huge Gtk2 module...) is compiled with dead code elimination turned on. So none of &lt;code&gt;G&lt;/code&gt;'s procs is generated at all.</source>
          <target state="translated">Однако самая большая проблема в том, что устранение мертвого кода нарушает модульность! Чтобы понять, почему, рассмотрим этот сценарий: модуль &lt;code&gt;G&lt;/code&gt; (например, огромный модуль Gtk2 ...) скомпилирован с включенным устранением мертвого кода. Таким образом, ни один из процессов &lt;code&gt;G&lt;/code&gt; не генерируется вообще.</target>
        </trans-unit>
        <trans-unit id="acb7eac83c404f63f4743f9a82480d0d20a94377" translate="yes" xml:space="preserve">
          <source>However you don't need to necessarily separate format patterns, a unambiguous format string like &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; is valid too (although only for years in the range 1..9999).</source>
          <target state="translated">Однако вам не обязательно разделять шаблоны формата, также допустима однозначная строка формата, например &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; (хотя только для лет в диапазоне 1..9999).</target>
        </trans-unit>
        <trans-unit id="65d726c6740c8cd087e52ad1bbc8dea1218cd23b" translate="yes" xml:space="preserve">
          <source>However you don't need to necessarily separate format patterns, as an unambiguous format string like &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; is also valid (although only for years in the range 1..9999).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742bd46b7a132e000ef82d863fbcce49eb7c5b85" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;int&lt;/code&gt; literals are implicitly convertible to a smaller integer type if the literal's value fits this smaller type and such a conversion is less expensive than other implicit conversions, so &lt;code&gt;myInt16 + 34&lt;/code&gt; produces an &lt;code&gt;int16&lt;/code&gt; result.</source>
          <target state="translated">Однако литералы &lt;code&gt;int&lt;/code&gt; неявно преобразуются в меньший целочисленный тип, если значение литерала соответствует этому меньшему типу и такое преобразование менее затратно, чем другие неявные преобразования, поэтому &lt;code&gt;myInt16 + 34&lt;/code&gt; дает результат &lt;code&gt;int16&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbf8251069a2532e90f19da84e2234188384c198" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;void&lt;/code&gt; type cannot be inferred in generic code:</source>
          <target state="translated">Однако тип &lt;code&gt;void&lt;/code&gt; не может быть выведен в универсальном коде:</target>
        </trans-unit>
        <trans-unit id="4c9fbaef3ddd5b531468395ce9dec2a5ab4f5ae7" translate="yes" xml:space="preserve">
          <source>However, depending on the use case &lt;code&gt;new Foo&lt;/code&gt; can also be wrapped like this instead:</source>
          <target state="translated">Однако, в зависимости от варианта использования, &lt;code&gt;new Foo&lt;/code&gt; можно также обернуть следующим образом:</target>
        </trans-unit>
        <trans-unit id="31eaf302275d7d94ef88ad6acf5c8f08d9355de8" translate="yes" xml:space="preserve">
          <source>However, for the C like targets you need to link external code either statically or dynamically. The preferred way of integrating native code is to use dynamic linking because it allows you to compile Nim programs without the need for having the related development libraries installed. This is done through the &lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;dynlib pragma for import&lt;/a&gt;, though more specific control can be gained using the &lt;a href=&quot;dynlib&quot;&gt;dynlib module&lt;/a&gt;.</source>
          <target state="translated">Однако для целей, подобных C, вам необходимо связать внешний код статически или динамически. Предпочтительный способ интеграции машинного кода - использовать динамическое связывание, потому что он позволяет компилировать программы Nim без необходимости установки соответствующих библиотек разработки. Это делается с помощью &lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;прагмы dynlib для импорта&lt;/a&gt; , хотя более конкретный контроль можно получить с &lt;a href=&quot;dynlib&quot;&gt;помощью модуля dynlib&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42250089280f811db9d02347ee4c65c943d06404" translate="yes" xml:space="preserve">
          <source>However, for the C like targets you need to link external code either statically or dynamically. The preferred way of integrating native code is to use dynamic linking because it allows you to compile Nim programs without the need for having the related development libraries installed. This is done through the &lt;a href=&quot;manual#foreign-function-interface-dynlib-pragma-for-import&quot;&gt;dynlib pragma for import&lt;/a&gt;, though more specific control can be gained using the &lt;a href=&quot;dynlib&quot;&gt;dynlib module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d22d44af2cd8e5a6cc6b8f108be38e9a251be52" translate="yes" xml:space="preserve">
          <source>However, if more than a single statistical calculation is required, it is more efficient to push the data once to the RunningStat object, and call the numerous statistical procs for the RunningStat object.</source>
          <target state="translated">Однако,если требуется более одного статистического вычисления,более эффективным будет однократный перенос данных в объект RunningStat и вызов многочисленных статистических профилей для объекта RunningStat.</target>
        </trans-unit>
        <trans-unit id="07fd3c66c743affb7b5ece82a87a7adaeb5ee006" translate="yes" xml:space="preserve">
          <source>However, it is not efficient to do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c379ff0f54702af4514aa6f7ffb24917f230d3c8" translate="yes" xml:space="preserve">
          <source>However, it is possible to manually allocate shared memory for channels using e.g. &lt;code&gt;system.allocShared0&lt;/code&gt; and pass these pointers through thread arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f20f62b2a4c64e2d22b78b12676a0c62815d5f" translate="yes" xml:space="preserve">
          <source>However, it is then not an ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt;, &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt; are not available for them either.</source>
          <target state="translated">Однако тогда это уже не порядковый номер, поэтому эти перечисления нельзя использовать в качестве типа индекса для массивов. Для них также недоступны процедуры &lt;code&gt;inc&lt;/code&gt; , &lt;code&gt;dec&lt;/code&gt; , &lt;code&gt;succ&lt;/code&gt; и &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dff82ffd386986c6ed8d26407f7247e97f81abe9" translate="yes" xml:space="preserve">
          <source>However, it is then not ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt;, &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt; are not available for them either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48faa4a84ae67f6ff262efd3ddcb8c99b257507e" translate="yes" xml:space="preserve">
          <source>However, later versions of the language might change this to mean &quot;infer the parameters' types from the body&quot;. Then the above &lt;code&gt;foo&lt;/code&gt; would be rejected as the parameters' types can not be inferred from an empty &lt;code&gt;discard&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cd4c67b60fee0d63736ca3e9d60ab7cbbbc9b5" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;MonoTime&lt;/code&gt; represents the time that has passed since some unknown time origin, it cannot be converted to a human readable timestamp. If this is required, the &lt;code&gt;times.Time&lt;/code&gt; type should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f19c857394d2f63dc7cf9130779ed557032b2a" translate="yes" xml:space="preserve">
          <source>However, since a template cannot iterate over varargs, this feature is generally much more useful for macros.</source>
          <target state="translated">Однако,так как шаблон не может выполнять итерацию через varargs,эта функция обычно гораздо более полезна для макросов.</target>
        </trans-unit>
        <trans-unit id="91f963bca7858da3bd237b4e32710ada3fd1260b" translate="yes" xml:space="preserve">
          <source>However, sometimes one has to optimize. Do it in the following order:</source>
          <target state="translated">Однако иногда приходится оптимизировать.Делайте это в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="406663563bd897705cf8a1dfd9829c366e1e27d8" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;header&lt;/code&gt; pragma is often the better alternative.</source>
          <target state="translated">Однако прагма &lt;code&gt;header&lt;/code&gt; часто является лучшей альтернативой.</target>
        </trans-unit>
        <trans-unit id="0681510216903f8e2197cf4eef03fbf990baedec" translate="yes" xml:space="preserve">
          <source>However, the above code does not compile: the reason is that you have to cover every value that &lt;code&gt;n&lt;/code&gt; may contain, but the code only handles the values &lt;code&gt;0..8&lt;/code&gt;. Since it is not very practical to list every other possible integer (though it is possible thanks to the range notation), we fix this by telling the compiler that for every other value nothing should be done:</source>
          <target state="translated">Однако приведенный выше код не компилируется: причина в том, что вам нужно охватить каждое значение, которое может содержать &lt;code&gt;n&lt;/code&gt; , но код обрабатывает только значения &lt;code&gt;0..8&lt;/code&gt; . Поскольку перечислять все другие возможные целые числа не очень практично (хотя это возможно благодаря обозначению диапазона), мы исправляем это, сообщая компилятору, что для каждого другого значения ничего делать не следует:</target>
        </trans-unit>
        <trans-unit id="c495d80be884cf611f7914197a783d75a72f97b9" translate="yes" xml:space="preserve">
          <source>However, the concept of &quot;order of evaluation&quot; is only applicable after the code was normalized: The normalization involves template expansions and argument reorderings that have been passed to named parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9aeb69b131c87d8cd6853cf77ea1cf9dd6d2ce" translate="yes" xml:space="preserve">
          <source>However, the constraints &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; are not available in ordinary routines.</source>
          <target state="translated">Однако &lt;code&gt;alias&lt;/code&gt; ограничений и &lt;code&gt;noalias&lt;/code&gt; недоступны в обычных подпрограммах.</target>
        </trans-unit>
        <trans-unit id="3cc98398fc87222623ba18963b4867850eff8b10" translate="yes" xml:space="preserve">
          <source>However, the current implementation produces a warning in these cases. There are different ways to deal with this warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56c3539085a2fed48c36c5577618ef3c9427982" translate="yes" xml:space="preserve">
          <source>However, the generated C code is not platform independent. C code generated for Linux does not compile on Windows, for instance. The comment on top of the C file lists the OS, CPU and CC the file has been compiled for.</source>
          <target state="translated">Однако сгенерированный C-код не является платформонезависимым.Например,сгенерированный для Linux C-код не компилируется под Windows.В комментарии поверх C-файла перечислены операционная система,процессор и CC,для которых этот файл был скомпилирован.</target>
        </trans-unit>
        <trans-unit id="29ce0e843ffd1bf978a465d631b8be7e6a19827c" translate="yes" xml:space="preserve">
          <source>However, the generated C code is not platform-independent. C code generated for Linux does not compile on Windows, for instance. The comment on top of the C file lists the OS, CPU, and CC the file has been compiled for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13fe01a81aad0de40fb6ccb549edb2976ed2c1b" translate="yes" xml:space="preserve">
          <source>However, the modules &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;, &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt;, and &lt;a href=&quot;times&quot;&gt;times&lt;/a&gt; are available! To access the DOM, use the &lt;a href=&quot;dom&quot;&gt;dom&lt;/a&gt; module that is only available for the JavaScript platform.</source>
          <target state="translated">Тем не менее, модули &lt;a href=&quot;strutils&quot;&gt;Strutils&lt;/a&gt; , &lt;a href=&quot;math&quot;&gt;математика&lt;/a&gt; и &lt;a href=&quot;times&quot;&gt;время&lt;/a&gt; доступны! Для доступа к DOM используйте модуль &lt;a href=&quot;dom&quot;&gt;dom,&lt;/a&gt; который доступен только для платформы JavaScript.</target>
        </trans-unit>
        <trans-unit id="94036a9c51a3400f9ddd28a5c63cabe204e0c9a5" translate="yes" xml:space="preserve">
          <source>However, the symbols &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are already bound and are not looked up again. As the example shows, &lt;code&gt;bindSym&lt;/code&gt; does work with overloaded symbols implicitly.</source>
          <target state="translated">Однако символы &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeLine&lt;/code&gt; и &lt;code&gt;stdout&lt;/code&gt; уже связаны и больше не просматриваются. Как показывает пример, &lt;code&gt;bindSym&lt;/code&gt; неявно работает с перегруженными символами.</target>
        </trans-unit>
        <trans-unit id="db3f8b29b6aa7fbf63138a0a422b4e572110ad5c" translate="yes" xml:space="preserve">
          <source>However, the values being strings/json is quite problematic: Many lookup tables that are built at compiletime embed &lt;em&gt;proc vars&lt;/em&gt; and types which have no obvious string representation... Seems like AST diffing is still the best idea as it will not require to use an alien API and works with some existing Nimble packages, at least.</source>
          <target state="translated">Однако значения, являющиеся строками / json, довольно проблематичны: многие таблицы поиска, которые создаются во время компиляции, встраивают &lt;em&gt;переменные&lt;/em&gt; и типы процедур, которые не имеют очевидного строкового представления ... Похоже, что сравнение AST по-прежнему является лучшей идеей, поскольку не требует использования чужой API и работает по крайней мере с некоторыми существующими пакетами Nimble.</target>
        </trans-unit>
        <trans-unit id="5b442e77c451b3f66ae133bcb7a6fa4d2d93f7cd" translate="yes" xml:space="preserve">
          <source>However, this does not work. The problem is that the procedure should not only &lt;code&gt;return&lt;/code&gt;, but return and &lt;strong&gt;continue&lt;/strong&gt; after an iteration has finished. This &lt;em&gt;return and continue&lt;/em&gt; is called a &lt;em&gt;yield&lt;/em&gt; statement. Now the only thing left to do is to replace the &lt;code&gt;proc&lt;/code&gt; keyword by &lt;code&gt;iterator&lt;/code&gt; and here it is - our first iterator:</source>
          <target state="translated">Однако это не работает. Проблема в том, что процедура должна не только &lt;code&gt;return&lt;/code&gt; , но и &lt;strong&gt;продолжаться&lt;/strong&gt; после завершения итерации. Этот &lt;em&gt;возврат и продолжение&lt;/em&gt; называется оператором &lt;em&gt;yield&lt;/em&gt; . Теперь осталось только заменить ключевое слово &lt;code&gt;proc&lt;/code&gt; на &lt;code&gt;iterator&lt;/code&gt; и вот он - наш первый итератор:</target>
        </trans-unit>
        <trans-unit id="11fb6436d40287c29f4518b54ff0c8803e2c0fb2" translate="yes" xml:space="preserve">
          <source>However, this is seldom needed. The most common case is to extract an error message from &lt;code&gt;e&lt;/code&gt;, and for such situations it is enough to use &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt;:</source>
          <target state="translated">Однако это требуется редко. Самый распространенный случай - извлечь сообщение об ошибке из &lt;code&gt;e&lt;/code&gt; , и для таких ситуаций достаточно использовать &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="abb9b269452062f371384e39f3c9c804325383d0" translate="yes" xml:space="preserve">
          <source>However, this is seldom needed. The most common case is to extract an error message from &lt;code&gt;e&lt;/code&gt;, and for such situations, it is enough to use &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d419965001ec506c50156ffc5413028fbc540e86" translate="yes" xml:space="preserve">
          <source>However, this means that the method call syntax is not available for &lt;code&gt;gensym&lt;/code&gt;'ed symbols:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae0752c04a35700e1c477d06f622ee35116b587" translate="yes" xml:space="preserve">
          <source>However, you can also use a &lt;code&gt;closure&lt;/code&gt; iterator to get a different set of restrictions. See &lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;first class iterators&lt;/a&gt; for details. Iterators can have the same name and parameters as a proc, since essentially they have their own namespaces. Therefore it is common practice to wrap iterators in procs of the same name which accumulate the result of the iterator and return it as a sequence, like &lt;code&gt;split&lt;/code&gt; from the &lt;a href=&quot;strutils&quot;&gt;strutils module&lt;/a&gt;.</source>
          <target state="translated">Однако вы также можете использовать итератор &lt;code&gt;closure&lt;/code&gt; чтобы получить другой набор ограничений. См. Подробности в &lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;итераторах первого класса&lt;/a&gt; . Итераторы могут иметь то же имя и параметры, что и процедура, поскольку, по сути, у них есть свои собственные пространства имен. Поэтому это обычная практика , чтобы обернуть итераторы в проках одного и то же имя, накапливающихся результат итератора и вернуть его в виде последовательности, как &lt;code&gt;split&lt;/code&gt; из &lt;a href=&quot;strutils&quot;&gt;модуля strutils&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27aa4ebcd005df33a75118f8923b50a0eb6fe684" translate="yes" xml:space="preserve">
          <source>HtmlExt:</source>
          <target state="translated">HtmlExt:</target>
        </trans-unit>
        <trans-unit id="56d4f245bec69d0b576c1bfc554101ec8df594ad" translate="yes" xml:space="preserve">
          <source>Human friendly string representation of &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Удобное для человека строковое представление &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6eabb595031ee4675266447f4a10ddfcfbee137" translate="yes" xml:space="preserve">
          <source>Human friendly string representation of a &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079d3eca7e1c9c2fd619c47e7f37d0a7860da8ba" translate="yes" xml:space="preserve">
          <source>Hygiene in templates</source>
          <target state="translated">Гигиена в шаблонах</target>
        </trans-unit>
        <trans-unit id="0fcb4de22af01003cbbe36bbdb61566a4be791e9" translate="yes" xml:space="preserve">
          <source>I use the term &lt;em&gt;cell&lt;/em&gt; here to refer to everything that is traced (sequences, refs, strings). This section describes how the GC works.</source>
          <target state="translated">Я использую здесь термин &lt;em&gt;ячейка&lt;/em&gt; для обозначения всего, что отслеживается (последовательности, ссылки, строки). В этом разделе описывается, как работает GC.</target>
        </trans-unit>
        <trans-unit id="cfb8efb0ed2a0e843062bd494febb53b03f95265" translate="yes" xml:space="preserve">
          <source>IE 11 on Windows 7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6969542799be4f3a836d0ff1c8e7f05eee2ed94d" translate="yes" xml:space="preserve">
          <source>IE8 on Windows XP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1adbf823c203d9176878f1ea4880115650f6355a" translate="yes" xml:space="preserve">
          <source>IO effect.</source>
          <target state="translated">Эффект ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="43cbc65c44c1dc2f182c90bae6d0aeab5672e98a" translate="yes" xml:space="preserve">
          <source>IPv4 mapped address.</source>
          <target state="translated">IPv4 маппируемый адрес.</target>
        </trans-unit>
        <trans-unit id="5c90dad54fd1910854f6a4d59c28bd806cb73299" translate="yes" xml:space="preserve">
          <source>IPv4-compatible address.</source>
          <target state="translated">IPv4-совместимый адрес.</target>
        </trans-unit>
        <trans-unit id="ad9aff7f64597fbd6b68ad711de514b704a24201" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideChk</source>
          <target state="translated">IdeCmd.ideChk</target>
        </trans-unit>
        <trans-unit id="408d49e1b1b54ed49bb8a7036e1788d1d6904769" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideCon</source>
          <target state="translated">IdeCmd.ideCon</target>
        </trans-unit>
        <trans-unit id="c218025b172e7052d7b555322d8ec0182193f277" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideDef</source>
          <target state="translated">IdeCmd.ideDef</target>
        </trans-unit>
        <trans-unit id="8609943548c6edbc2b3a396b7cfdc5696c923f89" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideDus</source>
          <target state="translated">IdeCmd.ideDus</target>
        </trans-unit>
        <trans-unit id="487335d8217013c7c51994e95da9b65b39ae11ee" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideHighlight</source>
          <target state="translated">IdeCmd.ideHighlight</target>
        </trans-unit>
        <trans-unit id="ef0d60957d129911c945617dc6936a2b0d838c65" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideKnown</source>
          <target state="translated">IdeCmd.ideKnown</target>
        </trans-unit>
        <trans-unit id="af66fa5d4f624290cb3a7375e016e2f1a9d6cd92" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideMod</source>
          <target state="translated">IdeCmd.ideMod</target>
        </trans-unit>
        <trans-unit id="aacddb1abd1dc36d50e62188851845f24b6c5101" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideMsg</source>
          <target state="translated">IdeCmd.ideMsg</target>
        </trans-unit>
        <trans-unit id="3987542ae177afb775e54575ca34e3bd87302450" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideNone</source>
          <target state="translated">IdeCmd.ideNone</target>
        </trans-unit>
        <trans-unit id="7144c11f7efc4c579a3892a3dd6f187c847dc692" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideOutline</source>
          <target state="translated">IdeCmd.ideOutline</target>
        </trans-unit>
        <trans-unit id="82676e35d3d812ccddf64996ea0342ad189aad4a" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideProject</source>
          <target state="translated">IdeCmd.ideProject</target>
        </trans-unit>
        <trans-unit id="524f1b9e740464e5cc4cfac6c7329c11a03cb5cb" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideSug</source>
          <target state="translated">IdeCmd.ideSug</target>
        </trans-unit>
        <trans-unit id="9cd625a93d41e7f1a8a89dfd10ee83e81116c8ea" translate="yes" xml:space="preserve">
          <source>IdeCmd.ideUse</source>
          <target state="translated">IdeCmd.ideUse</target>
        </trans-unit>
        <trans-unit id="781685dbafc4ce6c2834f04d9b9bddb8581e51c1" translate="yes" xml:space="preserve">
          <source>IdeCmd:</source>
          <target state="translated">IdeCmd:</target>
        </trans-unit>
        <trans-unit id="202eae41ba3b623522762ddc9a18dda84472265e" translate="yes" xml:space="preserve">
          <source>Ideally in later versions of the language, the restriction will be enforced at compile time. (Which is also why the name &lt;code&gt;noalias&lt;/code&gt; was choosen instead of a more verbose name like &lt;code&gt;unsafeAssumeNoAlias&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46d64b104cd715eb0457b58becb01c6685a0c79" translate="yes" xml:space="preserve">
          <source>IdentCache:</source>
          <target state="translated">IdentCache:</target>
        </trans-unit>
        <trans-unit id="a44628ba8c21044e8636076b5b9d6ce7f49f8e2a" translate="yes" xml:space="preserve">
          <source>Identifier Mangling</source>
          <target state="translated">Идентификация</target>
        </trans-unit>
        <trans-unit id="1c28aa3eba3eb83da8260427d9817edabf51acf1" translate="yes" xml:space="preserve">
          <source>Identifier construction</source>
          <target state="translated">Определить конструкцию</target>
        </trans-unit>
        <trans-unit id="f85967cd9bf8fa30a0c4ed8ed9689bd0527d9092" translate="yes" xml:space="preserve">
          <source>Identifier equality</source>
          <target state="translated">Равенство идентификаторов</target>
        </trans-unit>
        <trans-unit id="33920d1761007ef9f769013f951c310d3a56264f" translate="yes" xml:space="preserve">
          <source>Identifiers &amp;amp; Keywords</source>
          <target state="translated">Идентификаторы и ключевые слова</target>
        </trans-unit>
        <trans-unit id="20cd19ee47a89934f0e36a1ce365b38563d00949" translate="yes" xml:space="preserve">
          <source>Identifiers are &lt;code&gt;nnkIdent&lt;/code&gt; nodes. After the name lookup pass these nodes get transferred into &lt;code&gt;nnkSym&lt;/code&gt; nodes.</source>
          <target state="translated">Идентификаторы - &lt;code&gt;nnkIdent&lt;/code&gt; узлы nnkIdent . После прохождения поиска по имени эти узлы переводятся в узлы &lt;code&gt;nnkSym&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70f77e9cbcac065322f642e26369053cdd2f513b" translate="yes" xml:space="preserve">
          <source>Identifiers are valid from the point of their declaration until the end of the block in which the declaration occurred. The range where the identifier is known is the scope of the identifier. The exact scope of an identifier depends on the way it was declared.</source>
          <target state="translated">Идентификаторы действительны с момента их декларирования до конца блока,в котором произошло декларирование.Диапазон,в котором известен идентификатор,является областью его действия.Точная сфера применения идентификатора зависит от того,как он был объявлен.</target>
        </trans-unit>
        <trans-unit id="d92daa59c2bffaa34e4f7d06ae7114ce23760fe1" translate="yes" xml:space="preserve">
          <source>Identifiers in Nim can be any string of letters, digits and underscores, beginning with a letter. Two immediate following underscores &lt;code&gt;__&lt;/code&gt; are not allowed:</source>
          <target state="translated">Идентификаторы в Nim могут быть любой строкой букв, цифр и знаков подчеркивания, начинающейся с буквы. Два следующих символа подчеркивания &lt;code&gt;__&lt;/code&gt; не допускаются:</target>
        </trans-unit>
        <trans-unit id="631bea32d0edced136f187185e144840ec08febb" translate="yes" xml:space="preserve">
          <source>Identifiers in Nim can be any string of letters, digits and underscores, with the following restrictions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ece544cbbd4f4b4219db7d53e882c905ac75b6a" translate="yes" xml:space="preserve">
          <source>Identifies the conversion from one codeset to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952eeefab257b1dc395adc18dd057b07d99f8b74" translate="yes" xml:space="preserve">
          <source>Identifies version of block</source>
          <target state="translated">Определяет версию блока</target>
        </trans-unit>
        <trans-unit id="9041398445fc89d9adc20f2af276ac74b5c7695f" translate="yes" xml:space="preserve">
          <source>Idetools invocation</source>
          <target state="translated">Воззвание Idetools</target>
        </trans-unit>
        <trans-unit id="aa8a0ddc0c68ca8c1cc048c8fc326b77812b0717" translate="yes" xml:space="preserve">
          <source>Idetools outputs is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Вывод Idetools всегда возвращается в виде отдельных строк, разделенных символами табуляции ( &lt;code&gt;\t&lt;/code&gt; ). Значения каждого столбца:</target>
        </trans-unit>
        <trans-unit id="3d0ad0f39f445a61643d2d4071287f67b574496b" translate="yes" xml:space="preserve">
          <source>Idetools will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">Idetools всегда ответит одним определением или ни одним,если не найдет ни одного правильного символа,совпадающего с позицией запроса.</target>
        </trans-unit>
        <trans-unit id="cbcd6684d671244fdee86d60056e68d1d16184a4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#randomize&quot;&gt;randomize&lt;/a&gt; has not been called, the order of outcomes from this proc will always be the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaa58002f716e895634b6653c2a52881a8bd474" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#randomize&quot;&gt;randomize&lt;/a&gt; has not been called, the sequence of random numbers returned from this proc will always be the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1275cffa883535748d5035619b8b0ef08c96ca9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;address&lt;/code&gt; is &quot;&quot; then ADDR_ANY will be bound.</source>
          <target state="translated">Если &lt;code&gt;address&lt;/code&gt; &quot;&quot;, то будет привязан ADDR_ANY.</target>
        </trans-unit>
        <trans-unit id="b0679c17ef5dc1d53fe25a90576aa73faa698dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;assumedDescriptorsPerRequest&lt;/code&gt; is 0 or greater the server cares about the process's maximum file descriptor limit. It then ensures that the process still has the resources for &lt;code&gt;assumedDescriptorsPerRequest&lt;/code&gt; file descriptors before accepting a connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37372fbcdbd5728a2d0bd860fbfc0027fc538aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">Если &lt;code&gt;async&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , ошибка не будет выдана в случае, если ошибка была вызвана отсутствием данных, доступных для чтения.</target>
        </trans-unit>
        <trans-unit id="389371efa6da3c7248da8f138d099fa9af63f943" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">Если &lt;code&gt;async&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , ошибка не будет выдана в случае, если ошибка была вызвана отсутствием данных, доступных для чтения.</target>
        </trans-unit>
        <trans-unit id="e29a775354124296f28e9eed8300d0c6214c4fb0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b.len&lt;/code&gt; is not exactly the number of elements that are referred to by &lt;code&gt;x&lt;/code&gt;, a &lt;span id=&quot;splice_1&quot;&gt;splice&lt;/span&gt; is performed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2d08dcff45d58dab9a2535aa2834ec34815d9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b.len&lt;/code&gt; is not exactly the number of elements that are referred to by &lt;code&gt;x&lt;/code&gt;, a &lt;span id=&quot;splice_2&quot;&gt;splice&lt;/span&gt; is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92b13775ef5d4abd1b179130a1e53880a7cf964" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;break&lt;/code&gt; is used without a jump-to location, &lt;code&gt;nnkEmpty&lt;/code&gt; replaces &lt;code&gt;nnkIdent&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;break&lt;/code&gt; используется без места перехода, &lt;code&gt;nnkEmpty&lt;/code&gt; заменяет &lt;code&gt;nnkIdent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="307e3b5354402d4ec96fc67123487c24bedd7bdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cache&lt;/code&gt; is not empty, the results of &lt;code&gt;staticExec&lt;/code&gt; are cached within the &lt;code&gt;nimcache&lt;/code&gt; directory. Use &lt;code&gt;--forceBuild&lt;/code&gt; to get rid of this caching behaviour then. &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; (the concatenated string) is used to determine whether the entry in the cache is still valid. You can use versioning information for &lt;code&gt;cache&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;cache&lt;/code&gt; не пуст, результаты &lt;code&gt;staticExec&lt;/code&gt; кэшируются в каталоге &lt;code&gt;nimcache&lt;/code&gt; . &lt;code&gt;--forceBuild&lt;/code&gt; используйте --forceBuild, чтобы избавиться от этого поведения кеширования. &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; (объединенная строка) используются для определения, действительна ли запись в кэше. Вы можете использовать информацию о версиях для &lt;code&gt;cache&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b925c73f3626e46d93def9af1883e608c8b76c38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmdline == &quot;&quot;&lt;/code&gt;, the real command line as provided by the &lt;code&gt;os&lt;/code&gt; module is retrieved instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3959c38631a1e3835545dd4c60c36192eb7baea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmdline.len == 0&lt;/code&gt;, the real command line as provided by the &lt;code&gt;os&lt;/code&gt; module is retrieved instead. Behavior of the other parameters remains the same as in &lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser(string, ...)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b345cf9e0a07a334467009e3e58006f18498e01b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; cannot be sent immediately it will be buffered and sent when &lt;code&gt;sock&lt;/code&gt; becomes writeable (during the &lt;code&gt;handleWrite&lt;/code&gt; event). It's possible that only a part of &lt;code&gt;data&lt;/code&gt; will be sent immediately, while the rest of it will be buffered and sent later.</source>
          <target state="translated">Если &lt;code&gt;data&lt;/code&gt; не могут быть отправлены немедленно, они будут &lt;code&gt;handleWrite&lt;/code&gt; в буфер и отправлены, когда &lt;code&gt;sock&lt;/code&gt; станет доступным для записи (во время события handleWrite ). Возможно, что сразу будет отправлена только часть &lt;code&gt;data&lt;/code&gt; , а остальная часть будет буферизована и отправлена ​​позже.</target>
        </trans-unit>
        <trans-unit id="2fabc8cf9e4e8d176409d6df5c92154de739b783" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dest&lt;/code&gt; already exists, the file attributes will be preserved and the content overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179c8b020c500392eb1dfa3ed37ad6700578fc18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doInc == true&lt;/code&gt; (default), &lt;code&gt;i&lt;/code&gt; is incremented by the number of bytes that have been processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b577f00ac3cb4195580c22caa7520e6b2cc68a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;doInc == true&lt;/code&gt; (default), &lt;code&gt;pos&lt;/code&gt; is incremented by the number of bytes that have been processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c45493d4069c7c7e10803f397d81b028853a8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;err&lt;/code&gt; is not lower than 0 no exception will be raised.</source>
          <target state="translated">Если значение &lt;code&gt;err&lt;/code&gt; не ниже 0, исключение не возникает.</target>
        </trans-unit>
        <trans-unit id="c232394d07fbecdfb853af6943c852dd56b17fb0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;SafeDisconn&lt;/code&gt;, no exception will be raised when the error was caused by a peer disconnection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992f346f547e129010a04dc7a87a1c4c858a76bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;code&gt;precision&lt;/code&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;biggestFloat&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de5dc05d085caca0d2da81d987cb100c6e2af20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;code&gt;precision&lt;/code&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf358d5e12d7a571236022c026e1ba653036067" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;biggestFloat&lt;/code&gt; type.</source>
          <target state="translated">Если &lt;code&gt;format == ffDecimal&lt;/code&gt; то точность - это количество цифр, которые должны быть напечатаны после десятичной точки. Если &lt;code&gt;format == ffScientific&lt;/code&gt; то точность - это максимальное количество значащих цифр, которые нужно напечатать. &lt;em&gt;По&lt;/em&gt; умолчанию значение &lt;em&gt;precision&lt;/em&gt; - максимальное количество значащих цифр после десятичной точки для типа Nim's &lt;code&gt;biggestFloat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54b435b8d0e06d5409c71a6bb322a443d196828c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">Если &lt;code&gt;format == ffDecimal&lt;/code&gt; то точность - это количество цифр, которые должны быть напечатаны после десятичной точки. Если &lt;code&gt;format == ffScientific&lt;/code&gt; то точность - это максимальное количество значащих цифр, которые нужно напечатать. Значение по умолчанию &lt;em&gt;precision&lt;/em&gt; - максимальное количество значащих цифр после десятичной точки для типа с &lt;code&gt;float&lt;/code&gt; запятой Nim .</target>
        </trans-unit>
        <trans-unit id="24e87f76944be04ed6165ca1ab99d6886718e93f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fromRoot&lt;/code&gt; is true (default: false), the traversal will start from the file system root directory. If &lt;code&gt;inclusive&lt;/code&gt; is true (default), the original argument will be included in the traversal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ace460fa7284386356689f6617103ecd8499358" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fut&lt;/code&gt; completes first the returned future will hold true, otherwise, if &lt;code&gt;timeout&lt;/code&gt; milliseconds has elapsed first, the returned future will hold false.</source>
          <target state="translated">Если &lt;code&gt;fut&lt;/code&gt; завершается первым, возвращаемое future будет иметь значение true, в противном случае, если время &lt;code&gt;timeout&lt;/code&gt; истекло в миллисекундах, возвращенное future будет иметь значение false.</target>
        </trans-unit>
        <trans-unit id="278da5a4825851f6e880eb352bee1e7ea97b26a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;globalRaiseHook&lt;/code&gt; returns false, the exception is caught and does not propagate further through the call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407f272e1c73737914b8601c245e937e7c1645a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in&lt;/code&gt; had been declared as &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; then &lt;code&gt;T&lt;/code&gt; would have been bound to &lt;code&gt;char&lt;/code&gt;. But &lt;code&gt;s&lt;/code&gt; is not compatible to type &lt;code&gt;set[char]&lt;/code&gt;! The solution is to bind &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;range['a'..'z']&lt;/code&gt;. This is achieved by reversing the parameters for &lt;code&gt;contains&lt;/code&gt;; &lt;code&gt;in&lt;/code&gt; then passes its arguments in reverse order.</source>
          <target state="translated">Если бы &lt;code&gt;in&lt;/code&gt; был объявлен как &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; то &lt;code&gt;T&lt;/code&gt; был бы привязан к &lt;code&gt;char&lt;/code&gt; . Но &lt;code&gt;s&lt;/code&gt; не совместим с &lt;code&gt;set[char]&lt;/code&gt; типов [char] ! Решение состоит в том, чтобы привязать &lt;code&gt;T&lt;/code&gt; к &lt;code&gt;range['a'..'z']&lt;/code&gt; . Это достигается изменением параметров для &lt;code&gt;contains&lt;/code&gt; ; Затем &lt;code&gt;in&lt;/code&gt; передает свои аргументы в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="8cdfa42069bdaab72c3cf6574fc0385fb5627407" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inheritable&lt;/code&gt; is false (the default), the new file descriptor will not be inheritable by child processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eeb170458a1fe104e5d45a5ffa26a4dd93248b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inheritable&lt;/code&gt; is false (the default), the resulting client socket will not be inheritable by child processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c45c785b5cf885ca443ac7882ef91c561e30cc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inheritable&lt;/code&gt; is false (the default), the supplied &lt;code&gt;fd&lt;/code&gt; will not be inheritable by child processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406f9addf63c24219d984d581225fbd36b7e59cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is not an empty string, it will be passed as a standard input to the executed program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bf593991981830f4d9acc8190fb39437d3758e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a64c16e7bac188e04713249e1e33b48fab38ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised. One can check with &lt;a href=&quot;#hasKey,OrderedTable%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; whether the key exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8e8766fde6a8a1dcfddaffbc7869351370c283" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised. One can check with &lt;a href=&quot;#hasKey,OrderedTableRef%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; whether the key exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249c0f5a67da0cf5d36d5936c0e387ed53925fc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised. One can check with &lt;a href=&quot;#hasKey,StringTableRef,string&quot;&gt;hasKey proc&lt;/a&gt; whether the key exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34fe873c0c24ba691ca33fcee8e20cd2100b986" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised. One can check with &lt;a href=&quot;#hasKey,Table%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; whether the key exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c366b491959c140ec84844ec33b5bdba7625e9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the &lt;code&gt;KeyError&lt;/code&gt; exception is raised. One can check with &lt;a href=&quot;#hasKey,TableRef%5BA,B%5D,A&quot;&gt;hasKey proc&lt;/a&gt; whether the key exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380fdd32d425d34714b1a7f7c2ff89323d49982f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not in &lt;code&gt;t&lt;/code&gt;, the default value is returned (if not specified, it is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dddc0c1e8e530c684c4b1df8a66360d0d01a571" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;leading&lt;/code&gt; is true (default), leading &lt;code&gt;chars&lt;/code&gt; are stripped. If &lt;code&gt;trailing&lt;/code&gt; is true (default), trailing &lt;code&gt;chars&lt;/code&gt; are stripped. If both are false, the string is returned unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94a1a67a9237104b3f1d2a751939b79d81f08be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;leading&lt;/code&gt; is true (default), leading &lt;code&gt;runes&lt;/code&gt; are stripped. If &lt;code&gt;trailing&lt;/code&gt; is true (default), trailing &lt;code&gt;runes&lt;/code&gt; are stripped. If both are false, the string is returned unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa44a5a1c74e0287d965a233c3c05072e637958" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;linkTitle&lt;/code&gt; or &lt;code&gt;linkDesc&lt;/code&gt; are not the empty string, two additional columns with their contents will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12edc873e65a9a77c6f3d231c1c390abbd00d2ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;localRaiseHook&lt;/code&gt; returns false, the exception is caught and does not propagate further through the call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026648ef593a1b1232f572c220366aa54c2ea801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the binary number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">Если &lt;code&gt;maxLen == 0&lt;/code&gt; длина двоичного числа не имеет верхней границы. В &lt;code&gt;start + maxLen&lt;/code&gt; анализируется не более чем start + maxLen символов, вплоть до длины строки.</target>
        </trans-unit>
        <trans-unit id="a51b764ac263fbad8833f0cd967c9d52db03faf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the hexadecimal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">Если &lt;code&gt;maxLen == 0&lt;/code&gt; длина шестнадцатеричного числа не имеет верхней границы. В &lt;code&gt;start + maxLen&lt;/code&gt; анализируется не более чем start + maxLen символов, вплоть до длины строки.</target>
        </trans-unit>
        <trans-unit id="a562677ba8a99d4d9a7cacc5ea3e9107a7861eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the octal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">Если &lt;code&gt;maxLen == 0&lt;/code&gt; длина восьмеричного числа не имеет верхней границы. В &lt;code&gt;start + maxLen&lt;/code&gt; анализируется не более чем start + maxLen символов, вплоть до длины строки.</target>
        </trans-unit>
        <trans-unit id="893e5d58d510dc2be130e2fbd88c80d3117cd282" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt;, the parsing continues until the first non-bin character or to the end of the string. Otherwise, no more than &lt;code&gt;maxLen&lt;/code&gt; characters are parsed starting from the &lt;code&gt;start&lt;/code&gt; position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4615eaf861e5c44008a7604d9929e84b4e558bfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt;, the parsing continues until the first non-hex character or to the end of the string. Otherwise, no more than &lt;code&gt;maxLen&lt;/code&gt; characters are parsed starting from the &lt;code&gt;start&lt;/code&gt; position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ecf74de409bd74fef9fc6889a2ed9c82a0ea16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt;, the parsing continues until the first non-oct character or to the end of the string. Otherwise, no more than &lt;code&gt;maxLen&lt;/code&gt; characters are parsed starting from the &lt;code&gt;start&lt;/code&gt; position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea53a3bfa9c6fede5ed2cef2db764156ef4fd873" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;xnElement&lt;/code&gt;, runs recursively on each child node and concatenates the results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c56744ea64d2b69dd833961b7b0ac180f77e503" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;xnText&lt;/code&gt; or &lt;code&gt;xnEntity&lt;/code&gt;, returns its content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75335f14f8d8c14a442f3d953a5045449d6890a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is a &lt;code&gt;JArray&lt;/code&gt;, it returns the number of elements. If &lt;code&gt;n&lt;/code&gt; is a &lt;code&gt;JObject&lt;/code&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656c3dd520d94a762eebd679e51a735495d00093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nested&lt;/code&gt; is true (which is the default), the literals are replaced everywhere in the &lt;code&gt;constructor&lt;/code&gt; AST, otherwise only the first level is considered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595e68e557aa9284038e74f56a160c9ff7b91ad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nested&lt;/code&gt; is true, the literals are replaced everywhere in the &lt;code&gt;constructor&lt;/code&gt; AST, otherwise only the first level is considered:</source>
          <target state="translated">Если &lt;code&gt;nested&lt;/code&gt; имеет значение true, литералы заменяются везде в &lt;code&gt;constructor&lt;/code&gt; AST, в противном случае учитывается только первый уровень:</target>
        </trans-unit>
        <trans-unit id="4f29ea9e8bc8cec92963dfa196efcc3cdd9dbf0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;oneshot&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, timer will be notified only once.</source>
          <target state="translated">Если &lt;code&gt;oneshot&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , таймер будет уведомлен только один раз.</target>
        </trans-unit>
        <trans-unit id="fb7fcf3322c4b89ddc898d84136f3902db0b2173" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; can raise an exception, NRVO applies regardless. This can produce observable differences in behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2d85cf4096ccec712e290202f540e8eba644bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is &lt;strong&gt;nil&lt;/strong&gt; then a new memory block is returned. In either way the block has at least &lt;code&gt;T.sizeof * newSize&lt;/code&gt; bytes. If &lt;code&gt;newSize == 0&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; is not &lt;strong&gt;nil&lt;/strong&gt;&lt;code&gt;resize&lt;/code&gt; calls &lt;code&gt;dealloc(p)&lt;/code&gt;. In other cases the block has to be freed with &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed5605b04e8d57058de5a7f3da3929c77cecfcd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is &lt;strong&gt;nil&lt;/strong&gt; then a new memory block is returned. In either way the block has at least &lt;code&gt;T.sizeof * newSize&lt;/code&gt; bytes. If &lt;code&gt;newSize == 0&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; is not &lt;strong&gt;nil&lt;/strong&gt;&lt;code&gt;resizeShared&lt;/code&gt; calls &lt;code&gt;freeShared(p)&lt;/code&gt;. In other cases the block has to be freed with &lt;a href=&quot;#freeShared,ptr.T&quot;&gt;freeShared&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b288f57414901fd3b7c8f558b4ac9ad0c4368e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is &lt;strong&gt;nil&lt;/strong&gt; then a new memory block is returned. In either way the block has at least &lt;code&gt;newSize&lt;/code&gt; bytes. If &lt;code&gt;newSize == 0&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; is not &lt;strong&gt;nil&lt;/strong&gt;&lt;code&gt;realloc&lt;/code&gt; calls &lt;code&gt;dealloc(p)&lt;/code&gt;. In other cases the block has to be freed with &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b9506b555b19e38390b766b3839016f55c3f20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is &lt;strong&gt;nil&lt;/strong&gt; then a new memory block is returned. In either way the block has at least &lt;code&gt;newSize&lt;/code&gt; bytes. If &lt;code&gt;newSize == 0&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; is not &lt;strong&gt;nil&lt;/strong&gt;&lt;code&gt;reallocShared&lt;/code&gt; calls &lt;code&gt;deallocShared(p)&lt;/code&gt;. In other cases the block has to be freed with &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49337ccb0d2caf6cbd714809676678b471a58cd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; has no extension, &lt;code&gt;ext&lt;/code&gt; is the empty string. If &lt;code&gt;path&lt;/code&gt; has no directory component, &lt;code&gt;dir&lt;/code&gt; is the empty string. If &lt;code&gt;path&lt;/code&gt; has no filename component, &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;ext&lt;/code&gt; are empty strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ef0a2efbe04230bcafbfd5fca750d56f178c89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; or &lt;code&gt;len&lt;/code&gt; is negative they count from the end of the string. If &lt;code&gt;len&lt;/code&gt; is not given it means the longest possible string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70580e1cf0a168c03d50768037af1f65f6b54c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;precision == -1&lt;/code&gt;, it tries to format it nicely.</source>
          <target state="translated">Если &lt;code&gt;precision == -1&lt;/code&gt; , он пытается правильно отформатировать его.</target>
        </trans-unit>
        <trans-unit id="5bf1390f2bc8d6e9c194a681c0dcbd434ac66ce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">Если &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; возвращается истина.</target>
        </trans-unit>
        <trans-unit id="cc25ab3f0e351a21f44f27af9ee1d4d7e0821c74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;relative&lt;/code&gt; is true (default: false) the resulting path is shortened to be relative to &lt;code&gt;dir&lt;/code&gt;, otherwise the full path is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0d482ad73be533ef58efb16e6fe7464115647a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; contains none of the characters in &lt;code&gt;chars&lt;/code&gt;, -1 is returned. Otherwise the index returned is relative to &lt;code&gt;s[0]&lt;/code&gt;, not &lt;code&gt;start&lt;/code&gt;. Use &lt;code&gt;s[start..last].find&lt;/code&gt; for a &lt;code&gt;start&lt;/code&gt;-origin index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4618ad326f47cfc4d89b754072a43347be1f7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; contains none of the characters in &lt;code&gt;chars&lt;/code&gt;, -1 is returned. Otherwise the index returned is relative to &lt;code&gt;s[0]&lt;/code&gt;, not &lt;code&gt;start&lt;/code&gt;. Use &lt;code&gt;s[start..last].rfind&lt;/code&gt; for a &lt;code&gt;start&lt;/code&gt;-origin index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9911531b5031bdcc6554ffa1919d8d6e7f1efaf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; does not begin with &lt;code&gt;prefix&lt;/code&gt; and end with &lt;code&gt;suffix&lt;/code&gt; a ValueError exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3611bdbf077701ac2ce63e8fa76875d4287ff11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid binary integer, &lt;code&gt;ValueError&lt;/code&gt; is raised. &lt;code&gt;s&lt;/code&gt; can have one of the following optional prefixes: &lt;code&gt;0b&lt;/code&gt;, &lt;code&gt;0B&lt;/code&gt;. Underscores within &lt;code&gt;s&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05222260cd891e991699712618ddf0c7dfa42bff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid floating point number, &lt;code&gt;ValueError&lt;/code&gt; is raised. &lt;code&gt;NAN&lt;/code&gt;, &lt;code&gt;INF&lt;/code&gt;, &lt;code&gt;-INF&lt;/code&gt; are also supported (case insensitive comparison).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80fb9bde1ef884734a967ebf65c7defe9b17298" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid hex integer, &lt;code&gt;ValueError&lt;/code&gt; is raised. &lt;code&gt;s&lt;/code&gt; can have one of the following optional prefixes: &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0X&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;. Underscores within &lt;code&gt;s&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8944664a31703273acb73b529c6684e13ca1d27d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid integer, &lt;code&gt;ValueError&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0f53b6bc8e0f0dbbffdf8dae723133a74d0bf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid oct integer, &lt;code&gt;ValueError&lt;/code&gt; is raised. &lt;code&gt;s&lt;/code&gt; can have one of the following optional prefixes: &lt;code&gt;0o&lt;/code&gt;, &lt;code&gt;0O&lt;/code&gt;. Underscores within &lt;code&gt;s&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b74ad38f168d9d2226417f5a435c05ea2270de4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a valid octal integer, &lt;code&gt;ValueError&lt;/code&gt; is raised. &lt;code&gt;s&lt;/code&gt; can have one of the following optional prefixes: &lt;code&gt;0o&lt;/code&gt;, &lt;code&gt;0O&lt;/code&gt;. Underscores within &lt;code&gt;s&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2374c2c8aa40a349e05a30284a2b42f18efb33ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt;, then returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;n, no, false, 0, off&lt;/code&gt;, then returns &lt;code&gt;false&lt;/code&gt;. If &lt;code&gt;s&lt;/code&gt; is something else a &lt;code&gt;ValueError&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39dfcd47dad136aebe8c56a844f53a0d8d6ae02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt;, then returns &lt;em&gt;true&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;n, no, false, 0, off&lt;/code&gt;, then returns &lt;em&gt;false&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is something else a &lt;code&gt;ValueError&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; - одно из следующих значений: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt; , то возвращает &lt;em&gt;true&lt;/em&gt; . Если &lt;code&gt;s&lt;/code&gt; - одно из следующих значений: &lt;code&gt;n, no, false, 0, off&lt;/code&gt; , то возвращает &lt;em&gt;false&lt;/em&gt; . Если &lt;code&gt;s&lt;/code&gt; - это что-то еще, возникает исключение &lt;code&gt;ValueError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61ef1bcd9b55e9ade012520c7af4bb721dbb2002" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;safe&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then it will encode using the URL-Safe and Filesystem-safe standard alphabet characters, which substitutes &lt;code&gt;-&lt;/code&gt; instead of &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;_&lt;/code&gt; instead of &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39c36d767045ced0335fba924a908ac5c01042d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;siPrefix&lt;/code&gt; is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as &quot;4.1 k&quot; instead of &quot;4.1e3&quot;. Note that &lt;code&gt;u&lt;/code&gt; is used for micro- in place of the greek letter mu (&amp;mu;) as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&amp;lt;f&amp;lt;1000e18 (1a&amp;lt;f&amp;lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether &lt;code&gt;siPrefix&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010a71c05f1179f8db0658264d0a7a515cb8b523" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; имеет значение false, возвращает true, только если все символы в &lt;code&gt;s&lt;/code&gt; являются алфавитными и строчными.</target>
        </trans-unit>
        <trans-unit id="4f5851e215627025c8523ee634c01c31772cd434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; имеет значение false, возвращает true, только если все символы в &lt;code&gt;s&lt;/code&gt; являются алфавитными и прописными.</target>
        </trans-unit>
        <trans-unit id="a9ffc30f44ce015254cb84f1d8acff12890af1cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; имеет значение false, возвращает true, только если все руны в &lt;code&gt;s&lt;/code&gt; являются алфавитными и строчными.</target>
        </trans-unit>
        <trans-unit id="8c1ee7df97e960b64a9a34fca52a4ee613463ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; имеет значение false, возвращает true, только если все руны в &lt;code&gt;s&lt;/code&gt; являются алфавитными и прописными.</target>
        </trans-unit>
        <trans-unit id="d7daf16ddab2ec83f10b25fc93d560bdca6cc331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; истинно, возвращает истину, если все алфавитные символы в &lt;code&gt;s&lt;/code&gt; строчные. Возвращает false, если ни один из символов в &lt;code&gt;s&lt;/code&gt; не является алфавитным.</target>
        </trans-unit>
        <trans-unit id="5690821da9c726f211bd0d9f591332cb14d7d459" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; истинно, возвращает истину, если все буквенные символы в &lt;code&gt;s&lt;/code&gt; являются прописными. Возвращает false, если ни один из символов в &lt;code&gt;s&lt;/code&gt; не является алфавитным.</target>
        </trans-unit>
        <trans-unit id="317dfb0d58e9180509c313e714059b2f64b10411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; истинно, возвращает истину, если все алфавитные руны в &lt;code&gt;s&lt;/code&gt; строчные. Возвращает false, если ни одна из рун в &lt;code&gt;s&lt;/code&gt; не является алфавитной.</target>
        </trans-unit>
        <trans-unit id="ed588c14681cc5f1a8b51d3a7fac0541af404239" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; истинно, возвращает истину, если все алфавитные руны в &lt;code&gt;s&lt;/code&gt; написаны в верхнем регистре. Возвращает false, если ни одна из рун в &lt;code&gt;s&lt;/code&gt; не является алфавитной.</target>
        </trans-unit>
        <trans-unit id="046a824089b8e2afbd1bb54bbb407aa442933340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;socket&lt;/code&gt; is an SSL socket a handshake will be automatically performed.</source>
          <target state="translated">Если &lt;code&gt;socket&lt;/code&gt; является SSL-сокетом, подтверждение будет выполнено автоматически.</target>
        </trans-unit>
        <trans-unit id="4d0f3c7d51187ced65130a92b89a877fc3668b25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;socket&lt;/code&gt; is an SSL/TLS socket, this proc will also send a closure notification to the peer. If &lt;code&gt;SafeDisconn&lt;/code&gt; is in &lt;code&gt;flags&lt;/code&gt;, failure to do so due to disconnections will be ignored. This is generally safe in practice. See &lt;a href=&quot;https://security.stackexchange.com/a/82044&quot;&gt;here&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060c1aa6f7f394b2b22e4128d7bf5e88f3bff5e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;spread&lt;/code&gt; is false and the length of &lt;code&gt;s&lt;/code&gt; is not a multiple of &lt;code&gt;num&lt;/code&gt;, the proc will max out the first sub-sequence with &lt;code&gt;1 + len(s) div num&lt;/code&gt; entries, leaving the remainder of elements to the last sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657ddf2b2a172bb3a4efe1d540a814def8cd98c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;startDt.timezone != endDt.timezone&lt;/code&gt;, then the result will be equivalent to &lt;code&gt;between(startDt.utc, endDt.utc)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c307f2775a5e9f17487dafb7d99513801ab570" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;startDt.timezone == endDt.timezone&lt;/code&gt;, it is guaranteed that &lt;code&gt;startDt + between(startDt, endDt) == endDt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c110971e46a836dd2629952749afa315b2670098" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">Если &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; возвращается истина.</target>
        </trans-unit>
        <trans-unit id="d757e24742c24af41e66e6d5cd0f46d4cd8adcb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">Если &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; возвращается истина.</target>
        </trans-unit>
        <trans-unit id="23a94d218a3df4e439dc4c897d75080cff84d65f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trim&lt;/code&gt; is set to true, trailing zeros will be removed; if false, the number of digits specified by &lt;code&gt;precision&lt;/code&gt; will always be shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73051fe1df0d6852ad033cd16067f76b3c7f36d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; awaiting &lt;code&gt;fv&lt;/code&gt; will not block.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , ожидание &lt;code&gt;fv&lt;/code&gt; не заблокируется.</target>
        </trans-unit>
        <trans-unit id="adaa3990942a768ad453fdae96d12de0c644136d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, awaiting &lt;code&gt;fv&lt;/code&gt; will not block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ecefbe050b42276046ba620021335a783ef155" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typ&lt;/code&gt; is a tyObject then it is converted into a &lt;code&gt;ref &amp;lt;typ&amp;gt;&lt;/code&gt; and returned. Otherwise &lt;code&gt;typ&lt;/code&gt; is simply returned as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf295e9e7cbbb412c64f6987b18c18312bdc28e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typ&lt;/code&gt; is a tyRef then its immediate son is returned (which in many cases should be a &lt;code&gt;tyObject&lt;/code&gt;). Otherwise &lt;code&gt;typ&lt;/code&gt; is simply returned as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e00843d5aef01872fdcccdd18ef42b91f785478" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typ&lt;/code&gt; is not a tyVar then it is converted into a &lt;code&gt;var &amp;lt;typ&amp;gt;&lt;/code&gt; and returned. Otherwise &lt;code&gt;typ&lt;/code&gt; is simply returned as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9c3ff2a3345cd590a6fedc6177790735c03231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is used to determine the result type of a proc/iterator/converter call &lt;code&gt;c(X)&lt;/code&gt; (where &lt;code&gt;X&lt;/code&gt; stands for a possibly empty list of arguments), the interpretation where &lt;code&gt;c&lt;/code&gt; is an iterator is preferred over the other interpretations:</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; используется для определения типа результата вызова процедуры / итератора / преобразователя &lt;code&gt;c(X)&lt;/code&gt; (где &lt;code&gt;X&lt;/code&gt; означает, возможно, пустой список аргументов), интерпретация, в которой &lt;code&gt;c&lt;/code&gt; является итератором, предпочтительнее других интерпретаций:</target>
        </trans-unit>
        <trans-unit id="57a32de2331e9ab54dec2c66a459bffb42600360" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeof&lt;/code&gt; is used to determine the result type of a proc/iterator/converter call &lt;code&gt;c(X)&lt;/code&gt; (where &lt;code&gt;X&lt;/code&gt; stands for a possibly empty list of arguments), the interpretation, where &lt;code&gt;c&lt;/code&gt; is an iterator, is preferred over the other interpretations, but this behavior can be changed by passing &lt;code&gt;typeOfProc&lt;/code&gt; as the second argument to &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f8f73625233247a8d51ea4a5902a174791b134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;useUnitSpace&lt;/code&gt; is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeec7c4c3cb8ca4e353d938a916ba614cde6a3e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;result&lt;/code&gt; then &lt;code&gt;b&lt;/code&gt; has to be a location derived from the first formal parameter or from a constant location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d912f1092864cc7f5e6b65ecaa626ec86c5e6033" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a mutable view and &lt;code&gt;v&lt;/code&gt; is used to actually mutate the borrowed location, then &lt;code&gt;b&lt;/code&gt; has to be a mutable location. Note: If it is not actually used for mutation, borrowing a mutable view from an immutable location is allowed! This allows for many important idioms and will be justified in an upcoming RFC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0337394aba82feb2ce0b0ccc36cfd2aaf3cae7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;low(x)&lt;/code&gt; (that is -MININT for its type), an overflow exception is thrown (if overflow checking is turned on).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143f147cfc005d34e5469684ef9d46067c58a942" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is empty, 0 is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085a0739df2fb9bb634f99ec2ebd9833415011c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is empty, 1 is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2410e0f5521d539c525fb5bab4dfb899762d20" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fromRoot&lt;/em&gt; is set, the traversal will start from the file system root diretory. If &lt;em&gt;inclusive&lt;/em&gt; is set, the original argument will be included in the traversal.</source>
          <target state="translated">Если &lt;em&gt;задано fromRoot&lt;/em&gt; , обход будет начинаться с корневого каталога файловой системы. Если установлено значение &lt;em&gt;inclusive&lt;/em&gt; , исходный аргумент будет включен в обход.</target>
        </trans-unit>
        <trans-unit id="199de5473c17b3499d89cf849af056dcb7ec2a21" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;leading&lt;/em&gt; is true, leading &lt;em&gt;chars&lt;/em&gt; are stripped. If &lt;em&gt;trailing&lt;/em&gt; is true, trailing &lt;em&gt;chars&lt;/em&gt; are stripped. If both are false, the string is returned unchanged.</source>
          <target state="translated">Если значение &lt;em&gt;интерлиньяжа&lt;/em&gt; истинно, &lt;em&gt;начальные символы&lt;/em&gt; удаляются. Если &lt;em&gt;завершение&lt;/em&gt; истинно, завершающие &lt;em&gt;символы&lt;/em&gt; удаляются. Если оба значения ложны, строка возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="858dcc140fb894e0ab39988b41a394056e356424" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;linkTitle&lt;/em&gt; or &lt;em&gt;linkDesc&lt;/em&gt; are not the empty string, two additional columns with their contents will be added.</source>
          <target state="translated">Если &lt;em&gt;linkTitle&lt;/em&gt; или &lt;em&gt;linkDesc&lt;/em&gt; не является пустой строкой, будут добавлены два дополнительных столбца с их содержимым.</target>
        </trans-unit>
        <trans-unit id="4e866237eb46ef9c2e685eaa551676cfb806b047" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnElement&lt;/em&gt;, runs recursively on each child node and concatenates the results.</source>
          <target state="translated">Если &lt;em&gt;n&lt;/em&gt; равно &lt;em&gt;xnElement&lt;/em&gt; , выполняется рекурсивно на каждом дочернем узле и объединяет результаты.</target>
        </trans-unit>
        <trans-unit id="fa2323ffef001ae4f50de61394ed2c4c06dd1eef" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnText&lt;/em&gt; or &lt;em&gt;xnEntity&lt;/em&gt;, returns its content.</source>
          <target state="translated">Если &lt;em&gt;n&lt;/em&gt; равно &lt;em&gt;xnText&lt;/em&gt; или &lt;em&gt;xnEntity&lt;/em&gt; , возвращает его содержимое.</target>
        </trans-unit>
        <trans-unit id="6015dc5849733f7831bc335a048414718d188cdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JArray&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">Если &lt;em&gt;n&lt;/em&gt; - &lt;em&gt;JArray&lt;/em&gt; , он возвращает количество элементов. Если &lt;em&gt;n&lt;/em&gt; - объект &lt;em&gt;JObject&lt;/em&gt; , он возвращает количество пар. В противном случае он возвращает 0.</target>
        </trans-unit>
        <trans-unit id="bd5549ec7eeae51a8cdef6008f85c363b39530b0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;SList&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">Если &lt;em&gt;n&lt;/em&gt; - &lt;em&gt;SList&lt;/em&gt; , он возвращает количество элементов. Если &lt;em&gt;n&lt;/em&gt; - объект &lt;em&gt;JObject&lt;/em&gt; , он возвращает количество пар. В противном случае он возвращает 0.</target>
        </trans-unit>
        <trans-unit id="b5d453d0776be5e831bfbd8ed97503ad7f979cee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;path&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no directory component, &lt;em&gt;dir&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no filename component, &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;ext&lt;/em&gt; are empty strings.</source>
          <target state="translated">Если &lt;em&gt;путь&lt;/em&gt; не имеет расширения, &lt;em&gt;ext&lt;/em&gt; - это пустая строка. Если &lt;em&gt;путь&lt;/em&gt; не имеет компонента каталога, &lt;em&gt;dir&lt;/em&gt; - это пустая строка. Если &lt;em&gt;путь&lt;/em&gt; не имеет компонента &lt;em&gt;имени&lt;/em&gt; файла, &lt;em&gt;name&lt;/em&gt; и &lt;em&gt;ext&lt;/em&gt; являются пустыми строками.</target>
        </trans-unit>
        <trans-unit id="80be0c8b8f0887f6f6256d7bd08befefadc198dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;places&lt;/em&gt; is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. &lt;em&gt;round(54.5) -&amp;gt; 55.0&lt;/em&gt;). If &lt;em&gt;places&lt;/em&gt; is greater than 0, round to the given number of decimal places, e.g. &lt;em&gt;round(54.346, 2) -&amp;gt; 54.35&lt;/em&gt;. If &lt;em&gt;places&lt;/em&gt; is negative, round to the left of the decimal place, e.g. &lt;em&gt;round(537.345, -1) -&amp;gt; 540.0&lt;/em&gt;</source>
          <target state="translated">Если количество &lt;em&gt;мест&lt;/em&gt; равно 0 (или опущено), округлить до ближайшего целого значения в соответствии с обычными математическими правилами округления (например, &lt;em&gt;round (54,5) -&amp;gt; 55,0&lt;/em&gt; ). Если &lt;em&gt;разрядов&lt;/em&gt; больше 0, округлить до заданного количества десятичных знаков, например, &lt;em&gt;round (54,346, 2) -&amp;gt; 54,35&lt;/em&gt; . Если &lt;em&gt;места&lt;/em&gt; отрицательное, круглая слева от десятичной точки, например , &lt;em&gt;круглого (537.345, -1) -&amp;gt; 540,0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="85943ee873870ccb602997d1ba558ce262f536fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; contains none of the characters in &lt;em&gt;chars&lt;/em&gt;, -1 is returned.</source>
          <target state="translated">Если &lt;em&gt;s не&lt;/em&gt; содержит ни одного символа в &lt;em&gt;chars&lt;/em&gt; , возвращается -1.</target>
        </trans-unit>
        <trans-unit id="918bef596764b0dd1abc0034e3aca9f099546dd6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; does not begin with &lt;code&gt;prefix&lt;/code&gt; and end with &lt;code&gt;suffix&lt;/code&gt; a ValueError exception will be raised.</source>
          <target state="translated">Если &lt;em&gt;s&lt;/em&gt; не начинается с &lt;code&gt;prefix&lt;/code&gt; и не заканчивается &lt;code&gt;suffix&lt;/code&gt; возникает исключение ValueError.</target>
        </trans-unit>
        <trans-unit id="ffecd98c556448bc07a363bac2464a9be3914393" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid binary integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0b&lt;/code&gt;, &lt;code&gt;0B&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">Если &lt;em&gt;s&lt;/em&gt; не является допустимым двоичным целым числом, возникает &lt;em&gt;ошибка ValueError&lt;/em&gt; . &lt;em&gt;s&lt;/em&gt; может иметь один из следующих необязательных префиксов: &lt;code&gt;0b&lt;/code&gt; , &lt;code&gt;0B&lt;/code&gt; . Знаки подчеркивания в &lt;em&gt;s&lt;/em&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="22934de3f162a4b17792ea0eea7d5289abc794bc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid hex integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0X&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">Если &lt;em&gt;s&lt;/em&gt; не является допустимым шестнадцатеричным целым числом, возникает &lt;em&gt;ошибка ValueError&lt;/em&gt; . &lt;em&gt;s&lt;/em&gt; может иметь один из следующих необязательных префиксов: &lt;code&gt;0x&lt;/code&gt; , &lt;code&gt;0X&lt;/code&gt; , &lt;code&gt;#&lt;/code&gt; . Знаки подчеркивания в &lt;em&gt;s&lt;/em&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="31f1b5486de0d368adaea367eae29e732db7fbdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid integer, &lt;em&gt;ValueError&lt;/em&gt; is raised.</source>
          <target state="translated">Если &lt;em&gt;s&lt;/em&gt; не является допустимым целым числом, возникает &lt;em&gt;ошибка ValueError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a06a939f49597f675f8bb03c0e2cb909dc45d17e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid oct integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0o&lt;/code&gt;, &lt;code&gt;0O&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">Если &lt;em&gt;s&lt;/em&gt; не является допустимым целым числом &lt;em&gt;oct,&lt;/em&gt; возникает &lt;em&gt;ошибка ValueError&lt;/em&gt; . &lt;em&gt;s&lt;/em&gt; может иметь один из следующих необязательных префиксов: &lt;code&gt;0o&lt;/code&gt; , &lt;code&gt;0O&lt;/code&gt; . Знаки подчеркивания в &lt;em&gt;s&lt;/em&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="27d35434baea7af37a0b648eef07955006978983" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;siPrefix&lt;/em&gt; is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as &quot;4.1 k&quot; instead of &quot;4.1e3&quot;. Note that &lt;em&gt;u&lt;/em&gt; is used for micro- in place of the greek letter mu (&amp;mu;) as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&amp;lt;f&amp;lt;1000e18 (1a&amp;lt;f&amp;lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether &lt;em&gt;siPrefix&lt;/em&gt; is true.</source>
          <target state="translated">Если для &lt;em&gt;siPrefix&lt;/em&gt; установлено значение true, число будет отображаться с префиксом SI, соответствующим экспоненте. Например, 4100 будет отображаться как &amp;laquo;4.1 k&amp;raquo; вместо &amp;laquo;4.1e3&amp;raquo;. Обратите внимание, что &lt;em&gt;u&lt;/em&gt; используется для микро вместо греческой буквы mu (&amp;mu;) в соответствии с ISO 2955. Числа с абсолютным значением вне диапазона 1e-18 &amp;lt;f &amp;lt;1000e18 (1a &amp;lt;f &amp;lt;1000E) будут отображаться с показатель степени, а не префикс SI, независимо от того, &lt;em&gt;истинно&lt;/em&gt; ли &lt;em&gt;siPrefix&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3c153378df49ceb0514b8f9591a7fe13753328b6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spread&lt;/em&gt; is false and the length of &lt;em&gt;s&lt;/em&gt; is not a multiple of &lt;em&gt;num&lt;/em&gt;, the proc will max out the first sub sequences with &lt;code&gt;1 + len(s) div num&lt;/code&gt; entries, leaving the remainder of elements to the last sequence.</source>
          <target state="translated">Если &lt;em&gt;spread&lt;/em&gt; равен false и длина &lt;em&gt;s&lt;/em&gt; не кратна &lt;em&gt;num&lt;/em&gt; , процедура максимизирует первые подпоследовательности с помощью записей &lt;code&gt;1 + len(s) div num&lt;/code&gt; , оставив оставшиеся элементы последней последовательности.</target>
        </trans-unit>
        <trans-unit id="4775826ae44f8348308b950ee7f0228f3079a862" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;trim&lt;/em&gt; is set to true, trailing zeros will be removed; if false, the number of digits specified by &lt;em&gt;precision&lt;/em&gt; will always be shown.</source>
          <target state="translated">Если для параметра &lt;em&gt;trim&lt;/em&gt; установлено значение true, завершающие нули будут удалены; если false, всегда будет отображаться количество цифр, указанное &lt;em&gt;точностью&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3df1de57df75f3d46e50b0da67618c0e39c016" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;useUnitSpace&lt;/em&gt; is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</source>
          <target state="translated">Если &lt;em&gt;useUnitSpace&lt;/em&gt; имеет значение true, предоставленная единица измерения будет добавлена ​​к строке (с пробелом, как того требует стандарт СИ). Это поведение немного отличается от добавления единицы к результату, поскольку расположение пробела изменяется в зависимости от того, есть ли показатель степени.</target>
        </trans-unit>
        <trans-unit id="e5a02da3e38654c4cf49cce80161e467b81e4e01" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;$&lt;/code&gt; operator for a concrete enumeration is provided, this is used instead. (In other words: &lt;em&gt;Overwriting&lt;/em&gt; is possible.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c624e82a301cd1b0a01c9e7e8780b498a5b18ce" translate="yes" xml:space="preserve">
          <source>If a declared symbol is marked with an &lt;span id=&quot;asterisk_1&quot;&gt;asterisk&lt;/span&gt; it is exported from the current module:</source>
          <target state="translated">Если объявленный символ отмечен &lt;span id=&quot;asterisk_1&quot;&gt;звездочкой,&lt;/span&gt; он экспортируется из текущего модуля:</target>
        </trans-unit>
        <trans-unit id="81ed4de47fdface2b8f48e90c1cc15890ee94e16" translate="yes" xml:space="preserve">
          <source>If a different format string is preferred, refer to the &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;documentation about format strings&lt;/a&gt; for more information, including a list of available variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f356aa84e307221ea1ddc951ea76e3235c5f18" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;ReadFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">Если была получена вся строка; &lt;code&gt;ReadFullLine&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="f6e2de7dd3af4670ee12c88866b53b3fc6104073" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;RecvFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">Если была получена вся строка; &lt;code&gt;RecvFullLine&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="7d4edfbe8476a0a7a39ffd09f45852fb65cecbf1" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">Если читается вся строка &lt;code&gt;\r\L&lt;/code&gt; не добавляется к &lt;code&gt;line&lt;/code&gt; , однако, если читается только &lt;code&gt;\r\L&lt;/code&gt; тогда &lt;code&gt;line&lt;/code&gt; будет установлена ​​на нее.</target>
        </trans-unit>
        <trans-unit id="c16eab689c4842392a5a11dd1c091bb5c2263373" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to the result, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then the result will be set to it.</source>
          <target state="translated">Если читается полная строка, &lt;code&gt;\r\L&lt;/code&gt; не добавляется к результату, однако, если читается только &lt;code&gt;\r\L&lt;/code&gt; тогда результат будет установлен на него.</target>
        </trans-unit>
        <trans-unit id="2e37450d6f575130f1da8f99af9d57374a8a5ea4" translate="yes" xml:space="preserve">
          <source>If a full line is received &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is received then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">Если получена полная строка, &lt;code&gt;\r\L&lt;/code&gt; не добавляется к &lt;code&gt;line&lt;/code&gt; , однако, если получена только &lt;code&gt;\r\L&lt;/code&gt; тогда &lt;code&gt;line&lt;/code&gt; будет установлена ​​на нее.</target>
        </trans-unit>
        <trans-unit id="3ff59a2ff29be49ab647243344f65b1dcbfc2729" translate="yes" xml:space="preserve">
          <source>If a keyword is enclosed in backticks it loses its keyword property and becomes an ordinary identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4578160882d9270d9e934109afdfbf00113bc1cc" translate="yes" xml:space="preserve">
          <source>If a line starts with &lt;code&gt;#&lt;/code&gt; it will be ignored completely, so you can use that for comments.</source>
          <target state="translated">Если строка начинается с символа &lt;code&gt;#&lt;/code&gt; , она будет полностью проигнорирована, поэтому вы можете использовать это для комментариев.</target>
        </trans-unit>
        <trans-unit id="986bd59d4565e747bd03d3184e193b50ce47993b" translate="yes" xml:space="preserve">
          <source>If a module gets recompiled, its dependencies need to be updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae96445a1d8c8a917cd65647c489a45beaae265d" translate="yes" xml:space="preserve">
          <source>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc3730afa8c59c97647c426e37011adafd8a176" translate="yes" xml:space="preserve">
          <source>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified, unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</source>
          <target state="translated">Если модуль импортирует идентификатор двумя разными модулями,каждое появление идентификатора должно быть квалифицировано,если только это не перегруженная процедура или итератор,в этом случае происходит разрешение перегрузки:</target>
        </trans-unit>
        <trans-unit id="efe916c21117e3859222aca055e9bea6cec4eac2" translate="yes" xml:space="preserve">
          <source>If a node is used in a different document than the one that created it (that doesn't support it)</source>
          <target state="translated">Если узел используется в документе,отличном от того,который его создал (который его не поддерживает)</target>
        </trans-unit>
        <trans-unit id="871e2115f882350e714e39955d71707aaebf9ba5" translate="yes" xml:space="preserve">
          <source>If a parameter or an operation is not supported by the underlying object.</source>
          <target state="translated">Если параметр или операция не поддерживаются базовым объектом.</target>
        </trans-unit>
        <trans-unit id="3086cb848c98b3dd77a110e77a2de136bf838978" translate="yes" xml:space="preserve">
          <source>If a proc is annotated with the &lt;code&gt;noinit&lt;/code&gt; pragma this refers to its implicit &lt;code&gt;result&lt;/code&gt; variable:</source>
          <target state="translated">Если процедура аннотирована &lt;code&gt;noinit&lt;/code&gt; это относится к ее неявной переменной &lt;code&gt;result&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="056e8beb820913d3d337f02913145eef09e66318" translate="yes" xml:space="preserve">
          <source>If a reference points to &lt;em&gt;nothing&lt;/em&gt;, it has the value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если ссылка &lt;em&gt;ни&lt;/em&gt; на что &lt;em&gt;не&lt;/em&gt; указывает , она имеет значение &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac6b457358fbbcc06da0a6ca011f44a7007dfb9" translate="yes" xml:space="preserve">
          <source>If a reference points to &lt;em&gt;nothing&lt;/em&gt;, it has the value &lt;code&gt;nil&lt;/code&gt;. &lt;code&gt;nil&lt;/code&gt; is the default value for all &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; types. The &lt;code&gt;nil&lt;/code&gt; value can also be used like any other literal value. For example, it can be used in an assignment like &lt;code&gt;myRef = nil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ad2206a1169aba9bd7c1b09f9fb0941ea61337" translate="yes" xml:space="preserve">
          <source>If a section of code holds a lock of level &lt;code&gt;M&lt;/code&gt; than it can also acquire any lock of level &lt;code&gt;N &amp;lt; M&lt;/code&gt;. Another lock of level &lt;code&gt;M&lt;/code&gt; cannot be acquired. Locks of the same level can only be acquired &lt;em&gt;at the same time&lt;/em&gt; within a single &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">Если секция кода содержит блокировку уровня &lt;code&gt;M&lt;/code&gt; , она также может получить любую блокировку уровня &lt;code&gt;N &amp;lt; M&lt;/code&gt; . Другой замок уровня &lt;code&gt;M&lt;/code&gt; получить нельзя. Замки одного уровня могут быть получены &lt;em&gt;одновременно только в&lt;/em&gt; пределах одной секции &lt;code&gt;locks&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f883af41470e39046741ce71193805e04a0fb408" translate="yes" xml:space="preserve">
          <source>If a structured type features a field with destructable type and the user has not provided an explicit implementation, a destructor for the structured type will be automatically generated. Calls to any base class destructors in both user-defined and generated destructors will be inserted.</source>
          <target state="translated">Если в структурном типе имеется поле с деструктируемым типом и пользователь не предоставил явной реализации,то деструктор для структурного типа будет сгенерирован автоматически.Деструкторы любого базового класса будут вставляться как в деструкторы,заданные пользователем,так и в деструкторы,сгенерированные им.</target>
        </trans-unit>
        <trans-unit id="0db08f2b2e98ccda7902cf1898e764d8c7f5e868" translate="yes" xml:space="preserve">
          <source>If a type section uses generic parameters, they are treated here:</source>
          <target state="translated">Если в разделе типа используются общие параметры,то они обрабатываются здесь:</target>
        </trans-unit>
        <trans-unit id="134dbfacce2b9cb40bf6b486318d4214197c545b" translate="yes" xml:space="preserve">
          <source>If a view type is used as a return type, the location must borrow from a location that is derived from the first parameter that is passed to the proc. See &lt;a href=&quot;manual#procedures-var-return-type&quot;&gt;https://nim-lang.org/docs/manual.html#procedures-var-return-type&lt;/a&gt; for details about how this is done for &lt;code&gt;var T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9d3f35f669e256aa6c736e6a1afde344da10ae" translate="yes" xml:space="preserve">
          <source>If an assertion in Nim's memory manager or GC fails, the stack trace keeps allocating memory! Thus a stack overflow may happen, hiding the real issue.</source>
          <target state="translated">Если утверждение в менеджере памяти Nim или GC не удается,трасса стека продолжает выделять память! Таким образом,может произойти переполнение стека,скрывая реальную проблему.</target>
        </trans-unit>
        <trans-unit id="995c8ccff46b0b1f2916c13247fc81cbf289033e" translate="yes" xml:space="preserve">
          <source>If an attempt is made to add an attribute that is already in use elsewhere</source>
          <target state="translated">Если предпринимается попытка добавить атрибут,который уже используется в другом месте.</target>
        </trans-unit>
        <trans-unit id="a1629656009e8137e699c56c52cd43983c5570b7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</source>
          <target state="translated">Если предпринимается попытка создать или изменить объект некорректным с точки зрения пространств имен образом.</target>
        </trans-unit>
        <trans-unit id="7d19aea11801948c78474316888135ae6018e7ae" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify an object where modifications are not allowed</source>
          <target state="translated">Если предпринимается попытка модифицировать объект,модификация которого запрещена</target>
        </trans-unit>
        <trans-unit id="19d41b1964221f77e17c0e94a5badbf64e32ab22" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify the type of the underlying object.</source>
          <target state="translated">Если предпринимается попытка изменить тип базового объекта.</target>
        </trans-unit>
        <trans-unit id="c2268feb0b92960c8ac6e11b1ff1a253a519fe84" translate="yes" xml:space="preserve">
          <source>If an attempt is made to reference a node in a context where it does not exist</source>
          <target state="translated">Если делается попытка сослаться на узел в контексте,где его нет</target>
        </trans-unit>
        <trans-unit id="95f550c8bb30a788e989fe605398e29ff476452c" translate="yes" xml:space="preserve">
          <source>If an attempt is made to use an object that is not, or is no longer, usable.</source>
          <target state="translated">Если предпринимается попытка использовать объект,который не пригоден или больше не пригоден для использования.</target>
        </trans-unit>
        <trans-unit id="4a5a5458cfa721632e1a44b5d3d63641a792b115" translate="yes" xml:space="preserve">
          <source>If an awaited future completes with an error, then &lt;code&gt;await&lt;/code&gt; will re-raise this error. To avoid this, you can use the &lt;code&gt;yield&lt;/code&gt; keyword instead of &lt;code&gt;await&lt;/code&gt;. The following section shows different ways that you can handle exceptions in async procs.</source>
          <target state="translated">Если ожидаемое будущее завершается с ошибкой, то &lt;code&gt;await&lt;/code&gt; повторно вызовет эту ошибку. Чтобы избежать этого, вы можете использовать ключевое слово &lt;code&gt;yield&lt;/code&gt; вместо &lt;code&gt;await&lt;/code&gt; . В следующем разделе показаны различные способы обработки исключений в асинхронных процессах.</target>
        </trans-unit>
        <trans-unit id="9cfe3c7dc34bbfcf5eaa53fe4a526fe2fa04f7a3" translate="yes" xml:space="preserve">
          <source>If an error occurs EOS will be raised.</source>
          <target state="translated">При возникновении ошибки поднимается EOS.</target>
        </trans-unit>
        <trans-unit id="c762cc02f8bd2fcadfc73b70486affd574b2c259" translate="yes" xml:space="preserve">
          <source>If an error occurs OSError will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20075c8048a0853ffcb0c572ffb4edf2ab4dea98" translate="yes" xml:space="preserve">
          <source>If an error occurs an EOS exception will be raised. Otherwise the return value will be the length of data received.</source>
          <target state="translated">При возникновении ошибки будет поднято исключение EOS.В противном случае возвращаемым значением будет длина полученных данных.</target>
        </trans-unit>
        <trans-unit id="ee9dd9a88b7a108b3b5ddebf055242224e607202" translate="yes" xml:space="preserve">
          <source>If an error occurs an OSError exception will be raised.</source>
          <target state="translated">При возникновении ошибки будет поднято исключение OSError.</target>
        </trans-unit>
        <trans-unit id="19f4f485cf59bf83ace5ba68ed775166e6202e97" translate="yes" xml:space="preserve">
          <source>If an error occurs an OSError exception will be raised. Otherwise the return value will be the length of data received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df3e94f40e9f0642b83425fe8366b3839215739" translate="yes" xml:space="preserve">
          <source>If an error occurs the return value will be &lt;code&gt;-1&lt;/code&gt;. Otherwise the return value will be the length of data received.</source>
          <target state="translated">В случае ошибки возвращается значение &lt;code&gt;-1&lt;/code&gt; . В противном случае возвращаемое значение будет длиной полученных данных.</target>
        </trans-unit>
        <trans-unit id="65934c6d6036cdaf55bf0800e92c5afaa296761f" translate="yes" xml:space="preserve">
          <source>If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.</source>
          <target state="translated">Если четное число обратных слэшей сопровождается двойной кавычкой,то для каждой пары обратных слэшей в массив argv помещается один обратный слэш,а двойная кавычковая кавычка интерпретируется как разделитель строк.</target>
        </trans-unit>
        <trans-unit id="5a8eb863c9933042fa8b79fabcb3a546485426d6" translate="yes" xml:space="preserve">
          <source>If an index is left out, &lt;code&gt;succ(lastIndex)&lt;/code&gt; is used as the index value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7464323e44d0ae19ebeba4498e456ca8adf8480b" translate="yes" xml:space="preserve">
          <source>If an initializer is given the type can be omitted: the variable is then of the same type as the initializing expression. Variables are always initialized with a default value if there is no initializing expression. The default value depends on the type and is always a zero in binary.</source>
          <target state="translated">Если задан инициализатор,то тип можно опустить:тогда переменная имеет тот же тип,что и и инициализирующее выражение.При отсутствии инициализирующего выражения переменные всегда инициализируются значением по умолчанию.Значение по умолчанию зависит от типа и всегда является нулевым в двоичном выражении.</target>
        </trans-unit>
        <trans-unit id="523ee71c788d6ee708d4f30befc0a7f2aeb4aadc" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal string is specified.</source>
          <target state="translated">Если указана недействительная или незаконная строка.</target>
        </trans-unit>
        <trans-unit id="c16639803ee1e2193f59691f27a0a66926df18ac" translate="yes" xml:space="preserve">
          <source>If an invalid range is passed, it raises IndexDefect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31248330f03fa20f9122a001da3f7a4b63664cf0" translate="yes" xml:space="preserve">
          <source>If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is &quot;escaped&quot; by the remaining backslash, causing a literal double quotation mark (&quot;) to be placed in argv.</source>
          <target state="translated">Если нечетное количество обратных слэшей сопровождается двойной кавычкой,то для каждой пары обратных слэшей в массив argv помещается один обратный слэш,а двойная кавычковая кавычка &quot;экранируется&quot; оставшимся обратным слешем,в результате чего в argv помещается буквальный знак двойной кавычки (&quot;).</target>
        </trans-unit>
        <trans-unit id="ac9b41083a3085bc3f11ff622b38e4fe8c4f414b" translate="yes" xml:space="preserve">
          <source>If an optional argument is present the following lookup algorithm is used:</source>
          <target state="translated">При наличии необязательного аргумента используется следующий алгоритм поиска:</target>
        </trans-unit>
        <trans-unit id="a9811584c6a21ee0c14d6db331e13ba352d14ad0" translate="yes" xml:space="preserve">
          <source>If an unary operator's first character is &lt;code&gt;@&lt;/code&gt; it is a &lt;span id=&quot;sigilminuslike_1&quot;&gt;sigil-like&lt;/span&gt; operator which binds stronger than a &lt;code&gt;primarySuffix&lt;/code&gt;: &lt;code&gt;@x.abc&lt;/code&gt; is parsed as &lt;code&gt;(@x).abc&lt;/code&gt; whereas &lt;code&gt;$x.abc&lt;/code&gt; is parsed as &lt;code&gt;$(x.abc)&lt;/code&gt;.</source>
          <target state="translated">Если первый символ одинарного оператора является &lt;code&gt;@&lt;/code&gt; это &lt;span id=&quot;sigilminuslike_1&quot;&gt;сигил-подобный&lt;/span&gt; оператору , который связывает сильнее , чем &lt;code&gt;primarySuffix&lt;/code&gt; : &lt;code&gt;@x.abc&lt;/code&gt; анализируются как &lt;code&gt;(@x).abc&lt;/code&gt; тогда &lt;code&gt;$x.abc&lt;/code&gt; обрабатываются как &lt;code&gt;$(x.abc)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd6f49d0dfcf12fec7bb99768e6a680d44371f26" translate="yes" xml:space="preserve">
          <source>If any node is inserted somewhere it doesn't belong</source>
          <target state="translated">Если какой-нибудь узел вставлен куда-то,то он не принадлежит</target>
        </trans-unit>
        <trans-unit id="7a913709639c29598ea85076fb70279d360292bd" translate="yes" xml:space="preserve">
          <source>If assertions are turned off, it does nothing. If assertions are turned on, later versions will check the string for valid syntax.</source>
          <target state="translated">Если утверждения выключены,это ничего не даст.Если утверждения включены,более поздние версии будут проверять строку на корректность синтаксиса.</target>
        </trans-unit>
        <trans-unit id="74b5d1a57a127216acbfd875469a1f6d6875a284" translate="yes" xml:space="preserve">
          <source>If async dispatcher is not running, &lt;code&gt;cbproc&lt;/code&gt; will be executed immediately.</source>
          <target state="translated">Если диспетчер async не запущен, &lt;code&gt;cbproc&lt;/code&gt; будет запущен немедленно.</target>
        </trans-unit>
        <trans-unit id="7eaacc538f76088f4558f36cb9f8907f19b9ce21" translate="yes" xml:space="preserve">
          <source>If async dispatcher is running, &lt;code&gt;cbproc&lt;/code&gt; will be executed during next dispatcher tick.</source>
          <target state="translated">Если асинхронный диспетчер запущен, &lt;code&gt;cbproc&lt;/code&gt; будет выполнен во время следующего тика диспетчера.</target>
        </trans-unit>
        <trans-unit id="7324648ec3da0700c798c83a7252c4467f507aa2" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;code&gt;RecvFail&lt;/code&gt; is returned.</source>
          <target state="translated">Если вызов &lt;code&gt;recv&lt;/code&gt; не удался; &lt;code&gt;RecvFail&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="71f6a401dad3e06dd5b3b05ed44e34fcc7b8ef06" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;strong&gt;an EOS exception is raised.&lt;/strong&gt;</source>
          <target state="translated">Если вызов &lt;code&gt;recv&lt;/code&gt; не удался; &lt;strong&gt;возникает исключение EOS.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="369d3d999df1754a083b5c2ca0a01d76e66b2ff7" translate="yes" xml:space="preserve">
          <source>If conversion fails, or &lt;code&gt;errorCode&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; then &lt;code&gt;&quot;&quot;&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa867aef2e9b590f00e0b0045de459f37c6f8f5" translate="yes" xml:space="preserve">
          <source>If data is specified for a node which does not support data</source>
          <target state="translated">Если данные указаны для узла,который не поддерживает данные</target>
        </trans-unit>
        <trans-unit id="66ac0ed79e6f3d38e5881a7e4d06e7dc26cae509" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; is defined, &lt;code&gt;$XDG_CONFIG_HOME/nim/config.nims&lt;/code&gt; or &lt;code&gt;~/.config/nim/config.nims&lt;/code&gt; (POSIX) or &lt;code&gt;%APPDATA%/nim/config.nims&lt;/code&gt; (Windows). This file can be skipped with the &lt;code&gt;--skipUserCfg&lt;/code&gt; command line option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e824895cdb4cef64be7375ea8413a63a868d2ccc" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; is defined, &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; or &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; (POSIX) or &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; (Windows). This file can be skipped with the &lt;code&gt;--skipUserCfg&lt;/code&gt; command line option.</source>
          <target state="translated">Если переменная среды &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; определена, &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; или &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; (POSIX) или &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; (Windows). Этот файл можно пропустить с помощью &lt;code&gt;--skipUserCfg&lt;/code&gt; командной строки --skipUserCfg .</target>
        </trans-unit>
        <trans-unit id="20ac8fdf916d130ad74ee2dd25e10ce69bd5ec18" translate="yes" xml:space="preserve">
          <source>If expression</source>
          <target state="translated">Если выражение</target>
        </trans-unit>
        <trans-unit id="69dbcb321d20b0e49d118ee95433af7f3dbbbc3b" translate="yes" xml:space="preserve">
          <source>If future has already completed then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">Если future уже завершился, то немедленно будет вызван &lt;code&gt;cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d41b28de410ec7385af014da7c0540575e3aaaaf" translate="yes" xml:space="preserve">
          <source>If head is the empty string, tail is returned. If tail is the empty string, head is returned with a trailing path separator. If tail starts with a path separator it will be removed when concatenated to head. Other path separators not located on boundaries won't be modified. More examples on Unix:</source>
          <target state="translated">Если голова-пустая строка,возвращается хвост.Если хвост-пустая строка,то голова возвращается с разделителем путей.Если хвост начинается с разделителя путей,то при соединении с головой он удаляется.Другие разделители путей,не расположенные на границах,изменяться не будут.Дополнительные примеры на Unix:</target>
        </trans-unit>
        <trans-unit id="7ed9d728cd6081bbf88a148e476d401db74961e1" translate="yes" xml:space="preserve">
          <source>If in the above example module &lt;code&gt;B&lt;/code&gt; is re-compiled, but &lt;code&gt;A&lt;/code&gt; is not then &lt;code&gt;B&lt;/code&gt; needs to be aware of &lt;code&gt;toBool&lt;/code&gt; even though &lt;code&gt;toBool&lt;/code&gt; is not referenced in &lt;code&gt;B&lt;/code&gt;&lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">Если в приведенном выше примере модуль &lt;code&gt;B&lt;/code&gt; перекомпилирован, а &lt;code&gt;A&lt;/code&gt; - нет, тогда &lt;code&gt;B&lt;/code&gt; должен знать о &lt;code&gt;toBool&lt;/code&gt; , даже если &lt;code&gt;toBool&lt;/code&gt; не упоминается в &lt;code&gt;B&lt;/code&gt; &lt;em&gt;явно&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f6d860796a5fd822923ee9652b94bac30474c3be" translate="yes" xml:space="preserve">
          <source>If index or size is negative, or greater than the allowed value</source>
          <target state="translated">Если индекс или размер отрицательный или больше допустимого значения</target>
        </trans-unit>
        <trans-unit id="06026b50e58de38d4a7da3787b3fc38c6088b7a8" translate="yes" xml:space="preserve">
          <source>If it fails, it returns &lt;code&gt;(false, default(msg))&lt;/code&gt; otherwise it returns &lt;code&gt;(true, msg)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10462bf6533225f5f95a1f66cfe794cb8815ac6" translate="yes" xml:space="preserve">
          <source>If it returns &lt;code&gt;true&lt;/code&gt;, a &lt;code&gt;spawn&lt;/code&gt; may make sense. In general it is not necessary to call this directly; use &lt;a href=&quot;#spawnX.t&quot;&gt;spawnX template&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb76ca4868b2e0aca87e97961ca0eea2622d4bb" translate="yes" xml:space="preserve">
          <source>If many threads will generate random numbers concurrently, it is better to create a single Rand state and pass it to each thread. After passing the Rand state to a thread, call this proc before passing it to the next one. By using the Rand state this way, the subsequences of random numbers generated in each thread will never overlap as long as no thread generates more than 2^64 random numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39e35b0fbc867536af0e669f2cd71c2245083f7" translate="yes" xml:space="preserve">
          <source>If more items are expected to be added, simply add that expected extra amount to the parameter before calling this.</source>
          <target state="translated">Если ожидается добавление большего количества элементов,просто добавьте эту ожидаемую дополнительную сумму к параметру перед вызовом.</target>
        </trans-unit>
        <trans-unit id="053100f3c7f667ff05d2bace27aa288dee22ba26" translate="yes" xml:space="preserve">
          <source>If more precise control is needed, the apostrophe &lt;code&gt;'&lt;/code&gt; can be used in the supplied pattern to denote the concrete type parameters of the generic type. See the usage of the apostrophe operator in proc patterns for more details.</source>
          <target state="translated">Если более точный контроль необходим, апостроф &lt;code&gt;'&lt;/code&gt; может быть использован в поставляемом шаблоне для обозначения параметров типа бетона общего типа. Подробнее см. Использование оператора апострофа в шаблонах proc.</target>
        </trans-unit>
        <trans-unit id="ce96d5e60286391515a7cbb0c79e9c3bb3e9d383" translate="yes" xml:space="preserve">
          <source>If nimcache already contains compiled code from a different compiler for the same project, add the &lt;code&gt;-f&lt;/code&gt; flag to force all files to be recompiled.</source>
          <target state="translated">Если nimcache уже содержит скомпилированный код из другого компилятора для того же проекта, добавьте флаг &lt;code&gt;-f&lt;/code&gt; , чтобы принудительно перекомпилировать все файлы.</target>
        </trans-unit>
        <trans-unit id="5153d6410770a93b318a519a75636621e9c4c3aa" translate="yes" xml:space="preserve">
          <source>If no data could be retrieved; &lt;code&gt;ReadNone&lt;/code&gt; is returned.</source>
          <target state="translated">Если не удалось получить данные; &lt;code&gt;ReadNone&lt;/code&gt; не возвращается.</target>
        </trans-unit>
        <trans-unit id="62072ffbfb683070d4fe0e0d3ee2dfe7022a3652" translate="yes" xml:space="preserve">
          <source>If no exception name is given, the current exception is &lt;span id=&quot;reminusraised_1&quot;&gt;re-raised&lt;/span&gt;. The &lt;span id=&quot;reraisedefect_1&quot;&gt;ReraiseDefect&lt;/span&gt; exception is raised if there is no exception to re-raise. It follows that the &lt;code&gt;raise&lt;/code&gt; statement &lt;em&gt;always&lt;/em&gt; raises an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6c8813bd137356b82ff72079b75a071a3a49ec" translate="yes" xml:space="preserve">
          <source>If no exception name is given, the current exception is &lt;span id=&quot;reminusraised_1&quot;&gt;re-raised&lt;/span&gt;. The &lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt; exception is raised if there is no exception to re-raise. It follows that the &lt;code&gt;raise&lt;/code&gt; statement &lt;em&gt;always&lt;/em&gt; raises an exception.</source>
          <target state="translated">Если имя исключения не указано, текущее исключение &lt;span id=&quot;reminusraised_1&quot;&gt;возбуждается повторно&lt;/span&gt; . &lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt; возбуждается исключение , если не является исключением ререйз. Отсюда следует, что оператор &lt;code&gt;raise&lt;/code&gt; &lt;em&gt;всегда&lt;/em&gt; вызывает исключение.</target>
        </trans-unit>
        <trans-unit id="b8f1c177651d5ac598768ca09b89f39ca965fc8a" translate="yes" xml:space="preserve">
          <source>If no valid color could be parsed &lt;code&gt;ValueError&lt;/code&gt; is raised. Case insensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c31ffeb50efb95d9f7fcbe656ced23bb32fadb" translate="yes" xml:space="preserve">
          <source>If noQuotes is false the symbol may be returned in backticks. This will happen if the name happens to be a keyword or the first character is not part of the SymStartChars set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb6340cf10c05ccf2a7bfa1e1c0783de9d0f0ba" translate="yes" xml:space="preserve">
          <source>If object &lt;code&gt;a&lt;/code&gt; inherits from &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;b&lt;/code&gt;. This subtype relation is extended to the types &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt;:</source>
          <target state="translated">Если объект &lt;code&gt;a&lt;/code&gt; наследуется от &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; является подтипом &lt;code&gt;b&lt;/code&gt; . Это отношение подтипа распространяется на типы &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ptr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3cc150ff93a8e68590168a7d4dcb3edf2c87dc95" translate="yes" xml:space="preserve">
          <source>If only the date &amp;amp; time is considered, it appears that exactly one day has passed. However, the UTC offsets are different, which means that the UTC offset was changed somewhere in between. This happens twice each year for timezones that use daylight savings time. Because of this change, the amount of time that has passed is actually 25 hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05c37fe2a2ba4b139ce3fd0624a1db92445d0b7" translate="yes" xml:space="preserve">
          <source>If possible, prefer &lt;code&gt;isLower&lt;/code&gt; over &lt;code&gt;isUpper&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aade31752df0b65b99399acc157d4e6c367b1d08" translate="yes" xml:space="preserve">
          <source>If possible, prefer &lt;code&gt;toLower&lt;/code&gt; over &lt;code&gt;toUpper&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ad6ae52f22f23880a6fa7417dc9ed9f2690573" translate="yes" xml:space="preserve">
          <source>If possible, the name parameter should match the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously can be used. Note that the timezones name is used for checking equality!</source>
          <target state="translated">Если возможно,параметр name должен совпадать с именем,используемым в БД tz.Если часовой пояс не существует в базе данных tz,или если имя часового пояса неизвестно,то можно использовать любую строку,однозначно описывающую часовой пояс.Обратите внимание,что имя часового пояса используется для проверки равенства!</target>
        </trans-unit>
        <trans-unit id="83cab258bfaceba0e5d7e569b163a43ec079fd90" translate="yes" xml:space="preserve">
          <source>If possible, the name will be the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously might be used. For example, the string &quot;LOCAL&quot; is used for the systems local timezone.</source>
          <target state="translated">По возможности,это имя будет именем,используемым в базе данных tz.Если часовой пояс не существует в базе данных tz,или если имя часового пояса неизвестно,то может быть использована любая строка,которая однозначно описывает часовой пояс.Например,строка &quot;LOCAL&quot; используется для системного локального часового пояса.</target>
        </trans-unit>
        <trans-unit id="7d4e5a5abdc253c34bc8994506a514f7e8a3ab93" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если сокет отключен и данные для чтения недоступны, в будущем будет указано значение &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddadec8d4ad0814aaa2791b6db2a33e17de90113" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Если сокет отключен и данные для чтения недоступны, то будущее завершится со значением &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb3029d46833d06111b6e34f35f0929a92d0edb0" translate="yes" xml:space="preserve">
          <source>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</source>
          <target state="translated">Если розетка отсоединяется во время повторного включения,то в будущем может быть использована только часть запрашиваемых данных.</target>
        </trans-unit>
        <trans-unit id="0df46d3074a79a13b57275819c9d87a8439b076c" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;ReadPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">Если какие-то данные были получены; &lt;code&gt;ReadPartialLine&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="f385d830d03b348ca6c7d251ed0e117515ba157e" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;RecvPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">Если какие-то данные были получены; &lt;code&gt;RecvPartialLine&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="bee5b1199e1feec8f933bd6e8aa87552a7bd77d7" translate="yes" xml:space="preserve">
          <source>If specified &lt;code&gt;entry&lt;/code&gt; does not exist, raises KeyError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b6837e1f741f3a2cc549944f6142c90af6d182" translate="yes" xml:space="preserve">
          <source>If statement</source>
          <target state="translated">Если заявление</target>
        </trans-unit>
        <trans-unit id="04f218769dfcd83f8fc0312e1f3e8248f84dbe92" translate="yes" xml:space="preserve">
          <source>If such a value does not exist, &lt;code&gt;OverflowDefect&lt;/code&gt; is raised or a compile time error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dedc7eb074074f8129a06ee6d4eae6f2c0891b0" translate="yes" xml:space="preserve">
          <source>If such a value does not exist, &lt;code&gt;OverflowDefect&lt;/code&gt; is raised or a compile time error occurs. This is a short notation for: &lt;code&gt;x = pred(x, y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc5aa4c9d62c0a4c5c72638dcde2f2a5ef1a6ad" translate="yes" xml:space="preserve">
          <source>If such a value does not exist, &lt;code&gt;OverflowDefect&lt;/code&gt; is raised or a compile time error occurs. This is a short notation for: &lt;code&gt;x = succ(x, y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841bf5112e092c8cd39e9d2e2357a35f6b5f6da7" translate="yes" xml:space="preserve">
          <source>If the '#' character is present, integers use the 'alternate form' for formatting. This means that binary, octal, and hexadecimal output will be prefixed with '0b', '0o', and '0x', respectively.</source>
          <target state="translated">Если присутствует символ '#',то целые числа используют 'альтернативную форму' для форматирования.Это означает,что двоичный,восьмеричный и шестнадцатеричный вывод будут префиксованы с '0b','0o' и '0x',соответственно.</target>
        </trans-unit>
        <trans-unit id="2701e9b83a0e728206e51f442c68eb180551bc76" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;experimental mode&lt;/a&gt; is active and no other match is found, the first argument &lt;code&gt;a&lt;/code&gt; is dereferenced automatically if it's a pointer type and overloading resolution is tried with &lt;code&gt;a[]&lt;/code&gt; instead.</source>
          <target state="translated">Если активен &lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;экспериментальный режим&lt;/a&gt; и не найдено других совпадений, первый аргумент &lt;code&gt;a&lt;/code&gt; разыменовывается автоматически, если это тип указателя, и вместо этого пробуется разрешение перегрузки с &lt;code&gt;a[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26739fa77f2b7ce510c8a65058c811b7bbfd7c34" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Option&lt;/code&gt; has a value, the result will be &lt;code&gt;Some(x)&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is the string representation of the contained value. If the &lt;code&gt;Option&lt;/code&gt; does not have a value, the result will be &lt;code&gt;None[T]&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the name of the type contained in the &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a9cbb9118b85e5ba10a7abba984340fc868fac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Option&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; of the return type of the &lt;code&gt;callback&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d093b04a14e54cf08a5c56f3c93f1bdd47df2b7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;callback&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the option is returned as &lt;code&gt;Some&lt;/code&gt;. If it returns &lt;code&gt;false&lt;/code&gt;, it is returned as &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5263d26588e23e499a73f68828b3208e4128e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;filename&lt;/code&gt; has no extension, &lt;code&gt;ext&lt;/code&gt; will be added. If &lt;code&gt;ext&lt;/code&gt; == &quot;&quot; then any extension is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f04b40fb234123c9240535d5420bf04b4bad00" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;line&lt;/code&gt; pragma is used with a parameter, the parameter needs be a &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt;. If it is used without a parameter, &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; is used.</source>
          <target state="translated">Если директива &lt;code&gt;line&lt;/code&gt; используется с параметром, параметр должен быть &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt; . Если он используется без параметра, используется &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc91ac0b9432830816ba69fa3ae8519ab1eeae46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;raise&lt;/code&gt; keyword is not followed by an expression, the last exception is &lt;em&gt;re-raised&lt;/em&gt;. For the purpose of avoiding repeating this common code pattern, the template &lt;code&gt;newException&lt;/code&gt; in the &lt;code&gt;system&lt;/code&gt; module can be used:</source>
          <target state="translated">Если &lt;code&gt;raise&lt;/code&gt; ключевое слово не следует выражение, последнее исключение &lt;em&gt;ререйз&lt;/em&gt; . Чтобы избежать повторения этого общего шаблона кода, можно использовать шаблон &lt;code&gt;newException&lt;/code&gt; в &lt;code&gt;system&lt;/code&gt; модуле:</target>
        </trans-unit>
        <trans-unit id="a6220c53edf17f6d6c3f7b003487c554feec55e0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;smtp&lt;/code&gt; object was created with &lt;code&gt;debug&lt;/code&gt; enabled, debugRecv will invoke &lt;code&gt;echo(&quot;S:&quot; &amp;amp; result.string)&lt;/code&gt; after the data is received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3085b8812c2688f5e08f75eadc2fa13e9a9e96" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;smtp&lt;/code&gt; object was created with &lt;code&gt;debug&lt;/code&gt; enabled, debugSend will invoke &lt;code&gt;echo(&quot;C:&quot; &amp;amp; cmd)&lt;/code&gt; before sending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29b5294c2d5b8f33f39477a3e8ec43eeb105639" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stackTrace&lt;/code&gt; option is turned on, the generated C contains code to ensure that proper stack traces are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">Если опция &lt;code&gt;stackTrace&lt;/code&gt; включена , сгенерированный C содержит код, обеспечивающий правильную трассировку стека в случае сбоя программы или возникновения неперехваченного исключения.</target>
        </trans-unit>
        <trans-unit id="66aa11a675956c0c2ffc06581868b69289fea7ae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stackTrace&lt;/code&gt; option is turned on, the generated C contains code to ensure that proper stack traces are given if the program crashes or some uncaught exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69353978c65a0ffe1cd9e998af57fe30abaceb6d" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;filename&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; will be added. If &lt;em&gt;ext&lt;/em&gt; == &quot;&quot; then any extension is removed. &lt;em&gt;Ext&lt;/em&gt; should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</source>
          <target state="translated">Если &lt;em&gt;имя файла&lt;/em&gt; не имеет расширения, будет добавлен &lt;em&gt;ext&lt;/em&gt; . Если &lt;em&gt;ext&lt;/em&gt; == &quot;&quot;, то любое расширение удаляется. &lt;em&gt;Ext&lt;/em&gt; следует указывать без начального символа '.', Потому что некоторые файловые системы могут использовать другой символ. (Хотя я не знаю такого зверя.)</target>
        </trans-unit>
        <trans-unit id="6e6188bf137b40bf7c0100e9bc397d80a81640f7" translate="yes" xml:space="preserve">
          <source>If the AST returned by the macro contains other macro invocations, this process iterates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ace98adbbf3c8936f6e66ea8ff73968f01fefd" translate="yes" xml:space="preserve">
          <source>If the GNU assembler is used, quotes and newlines are inserted automatically:</source>
          <target state="translated">Если используется ассемблер GNU,кавычки и новые строки вставляются автоматически:</target>
        </trans-unit>
        <trans-unit id="0f567e3c2047b434a83b4adc7353c2da45d5c2c6" translate="yes" xml:space="preserve">
          <source>If the awaited futures &lt;em&gt;are&lt;/em&gt;&lt;code&gt;Future[void]&lt;/code&gt;, this proc returns &lt;code&gt;Future[void]&lt;/code&gt;.</source>
          <target state="translated">Если ожидаемые фьючерсы &lt;em&gt;- &lt;/em&gt; &lt;code&gt;Future[void]&lt;/code&gt; , эта процедура возвращает &lt;code&gt;Future[void]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa43020aaaa8cf58315161b2bb7c7b775d6b572a" translate="yes" xml:space="preserve">
          <source>If the awaited futures are not &lt;code&gt;Future[void]&lt;/code&gt;, the returned future will hold the values of all awaited futures in a sequence.</source>
          <target state="translated">Если ожидаемые фьючерсы не являются &lt;code&gt;Future[void]&lt;/code&gt; , возвращенное будущее будет содержать значения всех ожидаемых фьючерсов в последовательности.</target>
        </trans-unit>
        <trans-unit id="a6ef9d4c5f7c94e1677a2aee62e318f20e408e57" translate="yes" xml:space="preserve">
          <source>If the blocks are equal, &lt;code&gt;true&lt;/code&gt; is returned, &lt;code&gt;false&lt;/code&gt; otherwise. Like any procedure dealing with raw memory this is &lt;strong&gt;unsafe&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e214db9e43017090098fcfa4aa20df6a7d5897d9" translate="yes" xml:space="preserve">
          <source>If the conversion fails, &lt;code&gt;ValueError&lt;/code&gt; is raised. However, on most platforms the conversion cannot fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce6f3e71598f7a9a7b81af12401bcfa27f376fb" translate="yes" xml:space="preserve">
          <source>If the current length is greater than the new length, &lt;code&gt;s&lt;/code&gt; will be truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3d450e3aa3af165643f84339cce8ca42f91e47" translate="yes" xml:space="preserve">
          <source>If the error code is &lt;code&gt;0&lt;/code&gt; or an error message could not be retrieved, the message &lt;code&gt;unknown OS error&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107b1dbcd45465b9fb9139f69422c54382db4de7" translate="yes" xml:space="preserve">
          <source>If the file cannot be opened, &lt;code&gt;nil&lt;/code&gt; is returned. See the &lt;a href=&quot;io&quot;&gt;io module&lt;/a&gt; for a list of available &lt;a href=&quot;io#FileMode&quot;&gt;FileMode enums&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb04dbf83fa77a108a19af608dbbb64dcf8bef0" translate="yes" xml:space="preserve">
          <source>If the file does not exist &lt;code&gt;IOError&lt;/code&gt; is raised. The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe1d39f639c6431559fde4aae2a700b0d4ccf44" translate="yes" xml:space="preserve">
          <source>If the file does not exist &lt;em&gt;EIO&lt;/em&gt; is raised. The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">Если файл не существует, поднимается &lt;em&gt;EIO&lt;/em&gt; . Завершающие символы новой строки удаляются из повторяющихся строк. Пример:</target>
        </trans-unit>
        <trans-unit id="bafa24e01b0dca07bfac7c2248312106929d5bde" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then an empty string is returned.</source>
          <target state="translated">Если указатель на файл находится в конце файла,то возвращается пустая строка.</target>
        </trans-unit>
        <trans-unit id="76343cf0f621f6a2b7f316008b6f0e6e56f15e33" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then zero is returned and no bytes are read into &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">Если указатель файла находится за пределами конца файла, возвращается ноль и байты не читаются в &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9e8d1e3329be3b1efe953e0d47c9f6690b475b1" translate="yes" xml:space="preserve">
          <source>If the for loop expression &lt;code&gt;e&lt;/code&gt; does not denote an iterator and the for loop has exactly 1 variable, the for loop expression is rewritten to &lt;code&gt;items(e)&lt;/code&gt;; ie. an &lt;code&gt;items&lt;/code&gt; iterator is implicitly invoked:</source>
          <target state="translated">Если выражение цикла for &lt;code&gt;e&lt;/code&gt; не обозначает итератор, а цикл for имеет ровно 1 переменную, выражение цикла for перезаписывается в &lt;code&gt;items(e)&lt;/code&gt; ; то есть. &lt;code&gt;items&lt;/code&gt; итератора неявно вызывается:</target>
        </trans-unit>
        <trans-unit id="f1948e286ab2aa083c7abdf710bb8b040d1a1433" translate="yes" xml:space="preserve">
          <source>If the for loop has exactly 2 variables, a &lt;code&gt;pairs&lt;/code&gt; iterator is implicitly invoked.</source>
          <target state="translated">Если цикл имеет ровно 2 переменные, а &lt;code&gt;pairs&lt;/code&gt; итераторов неявно вызывается.</target>
        </trans-unit>
        <trans-unit id="f1d9041cac1672dd9769b2ea2138dfba71b254c8" translate="yes" xml:space="preserve">
          <source>If the formal parameter &lt;code&gt;f&lt;/code&gt; is of type &lt;code&gt;var T&lt;/code&gt; (or &lt;code&gt;out T&lt;/code&gt;) in addition to the ordinary type checking, the argument is checked to be an &lt;span id=&quot;lminusvalue_1&quot;&gt;l-value&lt;/span&gt;. &lt;code&gt;var T&lt;/code&gt; (or &lt;code&gt;out T&lt;/code&gt;) matches better than just &lt;code&gt;T&lt;/code&gt; then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6316f54cbdea61f6ea28df0e5d5c083559be9b99" translate="yes" xml:space="preserve">
          <source>If the formal parameter &lt;code&gt;f&lt;/code&gt; is of type &lt;code&gt;var T&lt;/code&gt; in addition to the ordinary type checking, the argument is checked to be an &lt;span id=&quot;lminusvalue_1&quot;&gt;l-value&lt;/span&gt;. &lt;code&gt;var T&lt;/code&gt; matches better than just &lt;code&gt;T&lt;/code&gt; then.</source>
          <target state="translated">Если формальный параметр &lt;code&gt;f&lt;/code&gt; имеет тип &lt;code&gt;var T&lt;/code&gt; в дополнение к обычной проверке типа, аргумент проверяется как &lt;span id=&quot;lminusvalue_1&quot;&gt;l-значение&lt;/span&gt; . Тогда &lt;code&gt;var T&lt;/code&gt; соответствует лучше, чем просто &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06c385a15682548ea060388897b3ee567fedd764" translate="yes" xml:space="preserve">
          <source>If the future stream already has data or is finished then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">Если в будущем потоке уже есть данные или он завершен , немедленно вызывается &lt;code&gt;cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a17c29c098e84ef9b5397d265f349b1b95a392e" translate="yes" xml:space="preserve">
          <source>If the handler does not raise an exception, ordinary control flow continues and the program is terminated.</source>
          <target state="translated">Если обработчик не поднимает исключение,обычный поток управления продолжается,и программа завершается.</target>
        </trans-unit>
        <trans-unit id="ba2e71c9350a067beb4f36ed2c2123aef7d9b604" translate="yes" xml:space="preserve">
          <source>If the implementation does not support the requested type of object or operation.</source>
          <target state="translated">Если реализация не поддерживает запрашиваемый тип объекта или операции.</target>
        </trans-unit>
        <trans-unit id="c9c412224e5b1f16ba846947349eefe31c0a2b58" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the file handle is invalid, &lt;code&gt;OSError&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36df26fc214c0ac51566c4f11deb9d6bc0cf23a" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the file handle is invalid, an error will be thrown.</source>
          <target state="translated">Если информация не может быть получена,например,когда файловая рукоятка недействительна,будет выброшена ошибка.</target>
        </trans-unit>
        <trans-unit id="ff2dbea5ec04b95d862e774824113e63172e2b69" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, &lt;code&gt;OSError&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931654e57ac7ff5e6e25ca20aeac61e7abee7076" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, an error will be thrown.</source>
          <target state="translated">Если информация не может быть получена,например,когда путь не существует,или когда ограничения прав не позволяют программе получить информацию о файле,будет выдана ошибка.</target>
        </trans-unit>
        <trans-unit id="c9e1e4f07efdbdfe683f438bf843008ae55e735b" translate="yes" xml:space="preserve">
          <source>If the iterator yields a tuple, there can be as many iteration variables as there are components in the tuple. The i'th iteration variable's type is the type of the i'th component. In other words, implicit tuple unpacking in a for loop context is supported.</source>
          <target state="translated">Если итератор дает кортеж,то итерационных переменных может быть столько же,сколько и компонентов в кортеже.Тип i-й итерационной переменной-тип i-й компоненты.Другими словами,поддерживается неявная распаковка кортежа в контексте цикла for.</target>
        </trans-unit>
        <trans-unit id="6f90e673e99dd8f0b56aa326b33eb0d0306fdf75" translate="yes" xml:space="preserve">
          <source>If the operator ends with &lt;code&gt;=&lt;/code&gt; and its first character is none of &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, it is an &lt;em&gt;assignment operator&lt;/em&gt; which has the second lowest precedence.</source>
          <target state="translated">Если оператор концы с &lt;code&gt;=&lt;/code&gt; и первым символом не являются ни один из &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , это &lt;em&gt;оператор присваивания,&lt;/em&gt; имеющий второй самый низкий приоритет.</target>
        </trans-unit>
        <trans-unit id="248bf6543c9b80549c21569bb17e72ffe3e4f779" translate="yes" xml:space="preserve">
          <source>If the operator ends with &lt;code&gt;=&lt;/code&gt; and its first character is none of &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, it is an &lt;em&gt;assignment operator&lt;/em&gt; which has the second-lowest precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e7e394fcfc961cebe8bca07c60cb63e58b1db1" translate="yes" xml:space="preserve">
          <source>If the prefix is part of the name (but the name doesn't start with it), these symbols come second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d5ae1836106c51a0b36a1a34e1eea987b0968e" translate="yes" xml:space="preserve">
          <source>If the proc declaration has no body, it is a &lt;span id=&quot;forward_1&quot;&gt;forward&lt;/span&gt; declaration. If the proc returns a value, the procedure body can access an implicitly declared variable named &lt;span id=&quot;result_2&quot;&gt;result&lt;/span&gt; that represents the return value. Procs can be overloaded. The overloading resolution algorithm determines which proc is the best match for the arguments. Example:</source>
          <target state="translated">Если декларация прок не имеет тела, это &lt;span id=&quot;forward_1&quot;&gt;вперед&lt;/span&gt; декларация. Если процедура возвращает значение, тело процедуры может получить доступ к неявно объявленной переменной с именем &lt;span id=&quot;result_2&quot;&gt;result,&lt;/span&gt; которая представляет возвращаемое значение. Проки могут быть перегружены. Алгоритм разрешения перегрузки определяет, какая процедура лучше всего подходит для аргументов. Пример:</target>
        </trans-unit>
        <trans-unit id="7f9553b958c19cddce23d7730df0fa25e4ae656d" translate="yes" xml:space="preserve">
          <source>If the procedure needs to modify the argument for the caller, a &lt;code&gt;var&lt;/code&gt; parameter can be used:</source>
          <target state="translated">Если процедуре необходимо изменить аргумент для вызывающей стороны, можно использовать параметр &lt;code&gt;var&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ffce8267c957e13dff8b29b02ca2b908de49e40" translate="yes" xml:space="preserve">
          <source>If the result of the future is an error then that error will be raised.</source>
          <target state="translated">Если результат будущего-ошибка,то эта ошибка будет повышена.</target>
        </trans-unit>
        <trans-unit id="16b303009a30beca5105d2aa322ae24b48a52b7d" translate="yes" xml:space="preserve">
          <source>If the resulting string is not longer than the original input string, only a single memory allocation is required.</source>
          <target state="translated">Если результирующая строка не длиннее исходной входной строки,требуется только одно выделение памяти.</target>
        </trans-unit>
        <trans-unit id="a9b83a69915f2923c508823edf191d18bfe7c62b" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;ReadDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">Если розетка была отключена; &lt;code&gt;ReadDisconnected&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="2f2159e99fd16ad61ca59fb4cff56737dc03dd06" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;RecvDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">Если розетка была отключена; &lt;code&gt;RecvDisconnected&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="06267d9401718740a7aedde535d821882f38a309" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected in the middle of a line (before &lt;code&gt;\r\L&lt;/code&gt; is read) then line will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;. The partial line &lt;strong&gt;will be lost&lt;/strong&gt;.</source>
          <target state="translated">Если сокет отключен в середине строки (до чтения &lt;code&gt;\r\L&lt;/code&gt; ), тогда строка будет установлена ​​на &lt;code&gt;&quot;&quot;&lt;/code&gt; . Неполная линия &lt;strong&gt;будет потеряна&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="aff4ce46ec1145925961993e78a141b3df5cdc42" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; will be returned.</source>
          <target state="translated">Если сокет отключен, &lt;code&gt;line&lt;/code&gt; будет установлена ​​в &lt;code&gt;&quot;&quot;&lt;/code&gt; и будет возвращено значение &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4152f2601369713f5b3377cbe629187b41c395fa" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если розетка отключена, &lt;code&gt;line&lt;/code&gt; будет установлена ​​на &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7db7153a9dd78804e9f3e45b8ee428bd5b09802b" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, the result will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если сокет отключен, результат будет установлен в &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d578dee840a7c31291fc81e023d496e5514d739" translate="yes" xml:space="preserve">
          <source>If the specified range of text does not fit into a DOMString Currently not used(Since DOMString is just string)</source>
          <target state="translated">Если указанный диапазон текста не помещается в DOMString,который в настоящее время не используется (поскольку DOMString-это просто строка).</target>
        </trans-unit>
        <trans-unit id="c9912e0ea82104240a5215a573498a602831f250" translate="yes" xml:space="preserve">
          <source>If the supplied number of elements exceeds the total number of elements in the deque, the deque will remain empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3e6dac4d1e457dc35cad93fa8d0a3e65325ba3" translate="yes" xml:space="preserve">
          <source>If the symbol should also be exported to a dynamic library, the &lt;code&gt;dynlib&lt;/code&gt; pragma should be used in addition to the &lt;code&gt;exportc&lt;/code&gt; pragma. See &lt;a href=&quot;#foreign-function-interface-dynlib-pragma-for-export&quot;&gt;Dynlib pragma for export&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2557668195fbfe5c8f3c1eca75334e08ac4d4277" translate="yes" xml:space="preserve">
          <source>If the system supports symlinks it also resolves them until it meets the actual file. This behavior can be disabled if desired by setting &lt;code&gt;followSymlinks = false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b18a9e716c01074670be16ff9f7b2d4da9d53a" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned off, &lt;code&gt;TaintedString&lt;/code&gt; is simply an alias for &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Если режим заражения выключен, &lt;code&gt;TaintedString&lt;/code&gt; является просто псевдонимом для &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ade66f9e7d10ed2722b60a91ec1dc67330d9fa7" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned on (via the &lt;code&gt;--taintMode:on&lt;/code&gt; command line option) it is a distinct string type which helps to detect input validation errors:</source>
          <target state="translated">Если режим заражения включен (с помощью параметра &lt;code&gt;--taintMode:on&lt;/code&gt; командной строки), это отдельный строковый тип, который помогает обнаруживать ошибки проверки ввода:</target>
        </trans-unit>
        <trans-unit id="9614b1e1a8be3e96f495969f1af445d51d40d1c3" translate="yes" xml:space="preserve">
          <source>If the template does not have types for its parameters, the type identifiers inside &lt;code&gt;nnkFormalParams&lt;/code&gt; just becomes &lt;code&gt;nnkEmpty&lt;/code&gt;.</source>
          <target state="translated">Если шаблон не имеет типов для своих параметров, идентификаторы типа внутри &lt;code&gt;nnkFormalParams&lt;/code&gt; просто становятся &lt;code&gt;nnkEmpty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80a4298614b1c88fcba898b49b736115a77cf332" translate="yes" xml:space="preserve">
          <source>If the template has no explicit return type, &lt;code&gt;void&lt;/code&gt; is used for consistency with procs and methods.</source>
          <target state="translated">Если шаблон не имеет явного возвращаемого типа, &lt;code&gt;void&lt;/code&gt; используется для согласованности с процедурами и методами.</target>
        </trans-unit>
        <trans-unit id="311a8257dbecbe5f571f1d56880174e340cbb539" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned. To distinguish whether a variable exists or it's value is just &lt;code&gt;&quot;&quot;&lt;/code&gt;, call &lt;a href=&quot;#existsEnv,string&quot;&gt;existsEnv(key) proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea9fb33db15316176ec096b57a2d7c1faae43c3" translate="yes" xml:space="preserve">
          <source>If the width field is preceded by a zero ('0') character, this enables zero-padding.</source>
          <target state="translated">Если полю ширины предшествует символ нуля ('0'),то это включает нулевую подстановку.</target>
        </trans-unit>
        <trans-unit id="08e24dc66cc5899916445680c12d07116f7a31f9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;finally&lt;/code&gt; part, it is always executed after the exception handlers.</source>
          <target state="translated">Если есть часть &lt;code&gt;finally&lt;/code&gt; , она всегда выполняется после обработчиков исключений.</target>
        </trans-unit>
        <trans-unit id="5403f5f769c6890d6ee94ea9cf83af93e0867d21" translate="yes" xml:space="preserve">
          <source>If there is a &lt;span id=&quot;finally_1&quot;&gt;finally&lt;/span&gt; clause, it is always executed after the exception handlers.</source>
          <target state="translated">Если есть предложение &lt;span id=&quot;finally_1&quot;&gt;finally&lt;/span&gt; , оно всегда выполняется после обработчиков исключений.</target>
        </trans-unit>
        <trans-unit id="8f3162b58a35394f9a00eeb14229f14280e86bba" translate="yes" xml:space="preserve">
          <source>If there is a prefix (foo|), symbols starting with this prefix come first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b016123034bebbefe22ae78b4065b8c3fdf35002" translate="yes" xml:space="preserve">
          <source>If there is no data to be read from the socket &lt;code&gt;False&lt;/code&gt; will be returned.</source>
          <target state="translated">Если нет данных для чтения из сокета, будет возвращено значение &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="675af36ecdb4bc1179580030d8540852cbfd5745" translate="yes" xml:space="preserve">
          <source>If this algorithm returns &quot;ambiguous&quot; further disambiguation is performed: If the argument &lt;code&gt;a&lt;/code&gt; matches both the parameter type &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; of &lt;code&gt;q&lt;/code&gt; via a subtyping relation, the inheritance depth is taken into account:</source>
          <target state="translated">Если этот алгоритм возвращает &quot;неоднозначный&quot;, выполняется дальнейшее устранение неоднозначности: если аргумент &lt;code&gt;a&lt;/code&gt; совпадает с типом параметра &lt;code&gt;f&lt;/code&gt; для &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;g&lt;/code&gt; для &lt;code&gt;q&lt;/code&gt; через отношение подтипов, глубина наследования принимается во внимание:</target>
        </trans-unit>
        <trans-unit id="210b5b5558f1d9d1b930518636f98564faf83e54" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd37f3d9598c7f5874dab0ebdd7196f760e5938c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised. If &lt;code&gt;dest&lt;/code&gt; already exists, it will be overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7ae0850651d2d770c981a6dbda59ceaa531c62" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised. This does not fail if the directory never existed in the first place, unless &lt;code&gt;checkDir&lt;/code&gt; = true</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209836da67814eeba98a19e6ddc6b727ffa92871" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised. This does not fail if the file never existed in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2622b56bd072d5f0cccd9fc29dc8d94e327fc30e" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised. This is a wrapper proc around &lt;a href=&quot;#copyDir,string,string&quot;&gt;copyDir&lt;/a&gt; and &lt;a href=&quot;#copyFileWithPermissions,string,string&quot;&gt;copyFileWithPermissions&lt;/a&gt; procs on non-Windows platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa135c30bca2146e78a4a18c707a6e4c9777b26c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the attributes from &lt;em&gt;source&lt;/em&gt; into &lt;em&gt;dest&lt;/em&gt;. On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. To preserve attributes recursively on these platforms use &lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions()&lt;/a&gt;.</source>
          <target state="translated">Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . На платформе Windows этот процесс скопирует атрибуты из &lt;em&gt;источника&lt;/em&gt; в &lt;em&gt;dest&lt;/em&gt; . На других платформах созданные файлы и каталоги будут наследовать разрешения по умолчанию для вновь созданного файла / каталога для пользователя. Для рекурсивного сохранения атрибутов на этих платформах используйте &lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ba7406fce433f75c1da2d28edafd72b5ca2511c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the source file's attributes into dest. On other platforms you need to use &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; to copy them by hand (or use the convenience &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; proc), otherwise &lt;em&gt;dest&lt;/em&gt; will inherit the default permissions of a newly created file for the user. If &lt;em&gt;dest&lt;/em&gt; already exists, the file attributes will be preserved and the content overwritten.</source>
          <target state="translated">Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . На платформе Windows этот процесс скопирует атрибуты исходного файла в dest. На других платформах вам необходимо использовать &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions ()&lt;/a&gt; и &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions (),&lt;/a&gt; чтобы скопировать их вручную (или использовать удобную процедуру &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions ()&lt;/a&gt; ), в противном случае &lt;em&gt;dest&lt;/em&gt; унаследует разрешения по умолчанию для вновь созданного файла для пользователя. Если &lt;em&gt;dest&lt;/em&gt; уже существует, атрибуты файла будут сохранены, а содержимое перезаписано.</target>
        </trans-unit>
        <trans-unit id="1c44eb8131bad6bf3fd6310d51476fb0e8f9dddf" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This does not fail if the directory never existed in the first place.</source>
          <target state="translated">Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . Это не сработает, если каталог никогда не существовал.</target>
        </trans-unit>
        <trans-unit id="b23ad4f30781ff872aab84374d7929409d46858b" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This is a wrapper proc around &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; and &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; on non Windows platforms. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . Это процедура-оболочка для &lt;a href=&quot;#copyDir&quot;&gt;copyDir ()&lt;/a&gt; и &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions ()&lt;/a&gt; на платформах, отличных от Windows. В Windows этот процесс является просто оболочкой для &lt;a href=&quot;#copyDir&quot;&gt;copyDir (),&lt;/a&gt; поскольку этот процесс уже копирует атрибуты.</target>
        </trans-unit>
        <trans-unit id="cb287e8ff379b2457a8e2d4d6e6de03aeec15e42" translate="yes" xml:space="preserve">
          <source>If this fails, returns &lt;code&gt;false&lt;/code&gt;. This does not fail if the file never existed in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb3bbfbdd505f581fd217138a1e2152f6288922" translate="yes" xml:space="preserve">
          <source>If using enums and sets with C, use distinct cint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e140d916a532f239410b33165a6a9a6d5019f98" translate="yes" xml:space="preserve">
          <source>If we have a prefix, only symbols matching this prefix are returned and nothing else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7fa0a4eec37fe2182192ec1daf3f2c74cec8c1f" translate="yes" xml:space="preserve">
          <source>If we have no prefix, consider the context. We currently distinguish between type and non-type contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a699519eb4bcfd6e9b388099f313da1c21a6c3" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;from ... import&lt;/code&gt;, the result is different, too.</source>
          <target state="translated">Если мы используем &lt;code&gt;from ... import&lt;/code&gt; , результат тоже будет другим.</target>
        </trans-unit>
        <trans-unit id="85374d14a596c8e9c56292b195027162f71fdc93" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;generateXML&lt;/code&gt; code shown above and call the SCF file &lt;code&gt;xmlGen.nimf&lt;/code&gt; In your &lt;code&gt;main.nim&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d41cc53a37945c747c32e0bc6d03f91d352c9cd" translate="yes" xml:space="preserve">
          <source>If you are using simple standard types like &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt; for the keys of the table you won't have any problems, but as soon as you try to use a more complex object as a key you will be greeted by a strange compiler error:</source>
          <target state="translated">Если вы используете простые стандартные типы, такие как &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;string&lt;/code&gt; для ключей таблицы, у вас не возникнет никаких проблем, но как только вы попытаетесь использовать более сложный объект в качестве ключа, вас встретит странная ошибка компилятора:</target>
        </trans-unit>
        <trans-unit id="a61618067feb2692a61a1309fe70a37f092e0dcd" translate="yes" xml:space="preserve">
          <source>If you don't want to run all the test case files you can pass any substring as a parameter to &lt;code&gt;caasdriver&lt;/code&gt;. Only files matching the passed substring will be run. The filtering doesn't use any globbing metacharacters, it's a plain match. For example, to run only &lt;code&gt;*-compile*.txt&lt;/code&gt; tests in verbose mode:</source>
          <target state="translated">Если вы не хотите запускать все файлы тестовых примеров, вы можете передать любую подстроку в качестве параметра в &lt;code&gt;caasdriver&lt;/code&gt; . Будут запущены только файлы, соответствующие переданной подстроке. При фильтрации не используются метасимволы подстановки, это простое совпадение. Например, чтобы запустить в подробном режиме только &lt;code&gt;*-compile*.txt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3b65c5702c4312fa92bc7a7a75f7b1cedc2ffdcc" translate="yes" xml:space="preserve">
          <source>If you hyper link a plain name symbol and there are other matches on the same HTML file, most browsers will go to the first one. To differentiate the rest, you will need to use the complex name. A complex name for a callable type is made up from several parts:</source>
          <target state="translated">Если Вы гиперссылка на символ простого имени,а в том же HTML-файле есть и другие совпадения,большинство браузеров перейдут к первому.Чтобы отличить остальные,необходимо использовать сложное имя.Сложное имя для вызываемого типа состоит из нескольких частей:</target>
        </trans-unit>
        <trans-unit id="d77f4e6941e6c25de4bc7bce05e47c82dde3f100" translate="yes" xml:space="preserve">
          <source>If you know what you're doing, you can also mark single string (or sequence) objects as &lt;span id=&quot;shallow_1&quot;&gt;shallow&lt;/span&gt;:</source>
          <target state="translated">Если вы знаете, что делаете, вы также можете пометить объекты с одной строкой (или последовательностью) как &lt;span id=&quot;shallow_1&quot;&gt;мелкие&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="7f6fcefa9ef0d5435edf3a86b98d9d16169b1981" translate="yes" xml:space="preserve">
          <source>If you know what you're doing, you can also mark single-string (or sequence) objects as &lt;span id=&quot;shallow_1&quot;&gt;shallow&lt;/span&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5621699cffb5f6aa7c0cfe6aad046283804e80" translate="yes" xml:space="preserve">
          <source>If you need a asynchronous server socket but you wish to process the clients synchronously then you can use the &lt;code&gt;getSocket&lt;/code&gt; converter to get a &lt;code&gt;Socket&lt;/code&gt; from the &lt;code&gt;AsyncSocket&lt;/code&gt; object, this can then be combined with &lt;code&gt;accept&lt;/code&gt; like so:</source>
          <target state="translated">Если вам нужен асинхронный серверный сокет, но вы хотите синхронно обрабатывать клиентов, вы можете использовать конвертер &lt;code&gt;getSocket&lt;/code&gt; для получения &lt;code&gt;Socket&lt;/code&gt; из объекта &lt;code&gt;AsyncSocket&lt;/code&gt; , затем это можно объединить с &lt;code&gt;accept&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="26b3c92840208778fb540b88ba9546be00de2473" translate="yes" xml:space="preserve">
          <source>If you need a permanent change, use the &lt;a href=&quot;#cd,string&quot;&gt;cd()&lt;/a&gt; proc. Usage example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c9b3765a26fdae2f51885e93ddca25dc0ccca4" translate="yes" xml:space="preserve">
          <source>If you need a sequence with the elements you can use &lt;a href=&quot;sequtils#toSeq.t,untyped&quot;&gt;sequtils.toSeq template&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="006ed832ed732b3be5a2f86089a58493d5e5cace" translate="yes" xml:space="preserve">
          <source>If you need a sequence with the keys you can use &lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq()&lt;/a&gt; on the iterator. Usage example:</source>
          <target state="translated">Если вам нужна последовательность с ключами, вы можете использовать &lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq ()&lt;/a&gt; на итераторе. Пример использования:</target>
        </trans-unit>
        <trans-unit id="5a8d301a71c9a03ca0fcbfc1bd1fbb38ac2c4793" translate="yes" xml:space="preserve">
          <source>If you need more elaborate waiting, you have to use an explicit barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cbb4e4f9774399c5110d17e6f93b09e6789def" translate="yes" xml:space="preserve">
          <source>If you need to &lt;em&gt;access&lt;/em&gt; the actual exception object or message inside an &lt;code&gt;except&lt;/code&gt; branch you can use the &lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException()&lt;/a&gt; and &lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg()&lt;/a&gt; procs from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Example:</source>
          <target state="translated">Если вам нужно получить &lt;em&gt;доступ&lt;/em&gt; к фактическому объекту исключения или сообщению внутри ветви &lt;code&gt;except&lt;/code&gt; , вы можете использовать процедуры &lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException ()&lt;/a&gt; и &lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg ()&lt;/a&gt; из &lt;a href=&quot;system&quot;&gt;системного&lt;/a&gt; модуля. Пример:</target>
        </trans-unit>
        <trans-unit id="369d846e4c1b566404807c8b598a810efa4157ad" translate="yes" xml:space="preserve">
          <source>If you need to allow the rst &lt;code&gt;include&lt;/code&gt; directive or tweak the generated output you have to create your own &lt;code&gt;RstGenerator&lt;/code&gt; with &lt;code&gt;initRstGenerator&lt;/code&gt; and related procs.</source>
          <target state="translated">Если вам нужно разрешить первую директиву &lt;code&gt;include&lt;/code&gt; или настроить сгенерированный вывод, вы должны создать свой собственный &lt;code&gt;RstGenerator&lt;/code&gt; с помощью &lt;code&gt;initRstGenerator&lt;/code&gt; и связанных процедур.</target>
        </trans-unit>
        <trans-unit id="6e0f3b7f2a6e094f5e44833f3b6b6ef4c156c0ee" translate="yes" xml:space="preserve">
          <source>If you need to create multiple identifiers you need to use the lower level &lt;code&gt;newNimNode&lt;/code&gt;:</source>
          <target state="translated">Если вам нужно создать несколько идентификаторов, вам нужно использовать &lt;code&gt;newNimNode&lt;/code&gt; более низкого уровня :</target>
        </trans-unit>
        <trans-unit id="d0579aebab140b65d01d9ce28fdabf2191699ecf" translate="yes" xml:space="preserve">
          <source>If you need to pass around memory allocated by Nim to C, you can use the procs &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; to mark objects as referenced to avoid them being freed by the GC. Other useful procs from &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; you can use to keep track of memory are:</source>
          <target state="translated">Если вам нужно передать память, выделенную Nim, C, вы можете использовать &lt;code&gt;GC_ref&lt;/code&gt; и &lt;code&gt;GC_unref&lt;/code&gt; , чтобы пометить объекты как указанные, чтобы избежать их освобождения GC. Другие полезные процедуры из &lt;a href=&quot;system&quot;&gt;системы, которые&lt;/a&gt; вы можете использовать для отслеживания памяти:</target>
        </trans-unit>
        <trans-unit id="a716ba6d4ad79bc9608a8987c0c272c9d2a66e45" translate="yes" xml:space="preserve">
          <source>If you need to pass around memory allocated by Nim to C, you can use the procs &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; to mark objects as referenced to avoid them being freed by the garbage collector. Other useful procs from &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; you can use to keep track of memory are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148b5ae6727551a8708027a1f900d39f713f26b5" translate="yes" xml:space="preserve">
          <source>If you start with an unsorted array/seq, the repeated permutations will &lt;strong&gt;not&lt;/strong&gt; give you all permutations but stop with last.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af2edf06f6b1a44ed06899aac7fe78217a6197e" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;#toMD5,string&quot;&gt;toMD5 proc&lt;/a&gt; there's no need to call this function explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605d3be2a51e005f46c2c854f15f5f73980b42f0" translate="yes" xml:space="preserve">
          <source>If you use Nim's flexible calling syntax (as in &lt;code&gt;x.len()&lt;/code&gt;), the result is the same as above but wrapped in an &lt;code&gt;nnkCall&lt;/code&gt;.</source>
          <target state="translated">Если вы используете гибкий синтаксис вызова Nim (как в &lt;code&gt;x.len()&lt;/code&gt; ), результат будет таким же, как и выше, но заключен в &lt;code&gt;nnkCall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaabbf0881b8169255900fc2e0a496ccef7b23be" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.recv() or asyncdispatch.accept(), because they are using IOCP, please use nativesockets.recv() and nativesockets.accept() instead.</source>
          <target state="translated">Если вы используете эту функцию,вам не нужно использовать asyncdispatch.recv()или asyncdispatch.accept(),потому что они используют IOCP,пожалуйста,используйте вместо этого nativesockets.recv()и nativesockets.accept().</target>
        </trans-unit>
        <trans-unit id="1badf00dcf0f3800f03821ebc8ea8986cacd6adb" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.send() or asyncdispatch.connect(), because they are using IOCP, please use nativesockets.send() and nativesockets.connect() instead.</source>
          <target state="translated">Если вы используете эту функцию,вам не нужно использовать asyncdispatch.send()или asyncdispatch.connect(),потому что они используют IOCP,пожалуйста,используйте вместо этого nativesockets.send()и nativesockets.connect().</target>
        </trans-unit>
        <trans-unit id="cac223c9791d80e68510ee018f308f5d57991c7e" translate="yes" xml:space="preserve">
          <source>If you want to add the &lt;code&gt;{.raises.}&lt;/code&gt; pragma to existing code, the compiler can also help you. You can add the &lt;code&gt;{.effects.}&lt;/code&gt; pragma statement to your proc and the compiler will output all inferred effects up to that point (exception tracking is part of Nim's effect system). Another more roundabout way to find out the list of exceptions raised by a proc is to use the Nim &lt;code&gt;doc2&lt;/code&gt; command which generates documentation for a whole module and decorates all procs with the list of raised exceptions. You can read more about Nim's &lt;a href=&quot;manual#effect-system&quot;&gt;effect system and related pragmas in the manual&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите добавить прагму &lt;code&gt;{.raises.}&lt;/code&gt; К существующему коду, компилятор также может вам помочь. Вы можете добавить &lt;code&gt;{.effects.}&lt;/code&gt; вашу процедуру, и компилятор выведет все предполагаемые эффекты до этого момента (отслеживание исключений является частью системы эффектов Nim). Другой более окольный способ узнать список исключений, созданных процедурой, - использовать команду Nim &lt;code&gt;doc2&lt;/code&gt; , которая генерирует документацию для всего модуля и украшает все процедуры списком возникших исключений. Вы можете узнать больше о системе &lt;a href=&quot;manual#effect-system&quot;&gt;эффектов&lt;/a&gt; Nim и связанных с ней прагмах в руководстве .</target>
        </trans-unit>
        <trans-unit id="d0c0f4c00b1012d51fb6739c3f68752cf2b7b509" translate="yes" xml:space="preserve">
          <source>If you want to implement hash procs for your custom types you will end up writing the following kind of skeleton of code:</source>
          <target state="translated">Если вы хотите реализовать хэш-проксы для ваших пользовательских типов,то в конечном итоге вы напишете скелет следующего вида кода:</target>
        </trans-unit>
        <trans-unit id="24263f42f3ba40007e49da841b6c42f49b268438" translate="yes" xml:space="preserve">
          <source>If you want to implement hash procs for your custom types, you will end up writing the following kind of skeleton of code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421d4b3269fa42e83ec4575e39cc5f8f9348120c" translate="yes" xml:space="preserve">
          <source>If you want to reset the state of a global variable on each reload, just re-assign a value anywhere within the top-level code:</source>
          <target state="translated">Если вы хотите сбрасывать состояние глобальной переменной при каждой перезагрузке,просто переназначьте значение в любом месте кода верхнего уровня:</target>
        </trans-unit>
        <trans-unit id="95147b50335541913ec2b4cdcd60beea22400d5c" translate="yes" xml:space="preserve">
          <source>If you want to reuse this feature in your own documentation you will have to modify &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; to contain a &lt;code&gt;doc.item.seesrc&lt;/code&gt; value with a hyper link to your own code repository. As you will see by the comments in that file, the value &lt;code&gt;txt&lt;/code&gt; passed on the command line will be used in the HTML template along others like &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$line&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите повторно использовать эту функцию в своей документации, вам придется изменить &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; , чтобы он содержал значение &lt;code&gt;doc.item.seesrc&lt;/code&gt; с гиперссылкой на ваш собственный репозиторий кода. Как вы увидите из комментариев в этом файле, значение &lt;code&gt;txt&lt;/code&gt; , переданное в командной строке, будет использоваться в шаблоне HTML наряду с другими, такими как &lt;code&gt;$path&lt;/code&gt; и &lt;code&gt;$line&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52843b664ac77e24f197735860350aeff2499277" translate="yes" xml:space="preserve">
          <source>If you want to start the server using stdin/stdout as communication you need to type:</source>
          <target state="translated">Если вы хотите запустить сервер,используя stdin/stdout в качестве средства связи,вам необходимо набрать код:</target>
        </trans-unit>
        <trans-unit id="5faec14ac2e7f3a0dbf5ac1fc6670f916e429298" translate="yes" xml:space="preserve">
          <source>If you want to start the server using tcp and a port, you need to type:</source>
          <target state="translated">Если вы хотите запустить сервер с помощью tcp и порта,вам нужно набрать:</target>
        </trans-unit>
        <trans-unit id="0e57ef06f554ec131431cf7cc7b3e87b3087eb9a" translate="yes" xml:space="preserve">
          <source>If you would like to remove the callback simply set it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите удалить обратный вызов, просто установите для него значение &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af0996b6e01e303c65f963b0e8fbe7eeea90dc53" translate="yes" xml:space="preserve">
          <source>If your custom types contain fields for which there already is a hash proc, like for example objects made up of &lt;code&gt;strings&lt;/code&gt;, you can simply hash together the hash value of the individual fields:</source>
          <target state="translated">Если ваши настраиваемые типы содержат поля, для которых уже существует хэш-процедура, например, объекты, состоящие из &lt;code&gt;strings&lt;/code&gt; , вы можете просто хешировать хеш-значения отдельных полей:</target>
        </trans-unit>
        <trans-unit id="7b221d885e608a822eb4dd77455f03fffdf220cc" translate="yes" xml:space="preserve">
          <source>If your platform does not provide these functions it should be trivial to provide an implementation for them and link these to your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a6540e806b12db45a31546a098431a84108a29" translate="yes" xml:space="preserve">
          <source>IgnoreCC:</source>
          <target state="translated">IgnoreCC:</target>
        </trans-unit>
        <trans-unit id="4aadbcf0bb321d44f7f560f38b96c7cecee80738" translate="yes" xml:space="preserve">
          <source>IgnoreTupleFields:</source>
          <target state="translated">IgnoreTupleFields:</target>
        </trans-unit>
        <trans-unit id="ee7d8473b3b03509d036a9e18c0f69477806dbbf" translate="yes" xml:space="preserve">
          <source>Ignoring the return value of a procedure without using a discard statement is a static error.</source>
          <target state="translated">Игнорирование возвращаемого значения процедуры без использования оператора сброса является статической ошибкой.</target>
        </trans-unit>
        <trans-unit id="234aba6f014c3210479a86e1f7e85db4fc781aa3" translate="yes" xml:space="preserve">
          <source>Implementation Specific Pragmas</source>
          <target state="translated">Реализация Конкретные прагмы</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="e4c1e2458dab48a54a1e7f70dcc8c85f1ecef51b" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;span id=&quot;deque_1&quot;&gt;deque&lt;/span&gt; (double-ended queue). The underlying implementation uses a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;span id=&quot;deque_1&quot;&gt;двусторонней очереди&lt;/span&gt; (Двухконтактные очереди). Базовая реализация использует &lt;code&gt;seq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7a46b17c56770ce055c6ddb62375ac14462a9c" translate="yes" xml:space="preserve">
          <source>Implementation of singly and doubly linked lists. Because it makes no sense to do so, the 'next' and 'prev' pointers are not hidden from you and can be manipulated directly for efficiency.</source>
          <target state="translated">Внедрение единичных и двойных связанных списков.Так как это не имеет смысла,то указатели &quot;следующий&quot; и &quot;prev&quot; не скрыты от вас и могут манипулироваться непосредственно для повышения эффективности.</target>
        </trans-unit>
        <trans-unit id="ebf8259b50eb672a953fe5e9182a91f7012116d5" translate="yes" xml:space="preserve">
          <source>Implementation of the check that &lt;code&gt;recover&lt;/code&gt; needs, see &lt;a href=&quot;https://github.com/nim-lang/RFCs/issues/244&quot;&gt;https://github.com/nim-lang/RFCs/issues/244&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4e9bd4bbca2e0729767fd4dd71bc8dfb1e6eec" translate="yes" xml:space="preserve">
          <source>Implementation of the command line parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22d7898babb0b43f69334c0a5efe09a2b8e7018" translate="yes" xml:space="preserve">
          <source>Implementation of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c736db4db506401e673a9f4f1f349ad3e618b7" translate="yes" xml:space="preserve">
          <source>Implements Nim's 'spawn'.</source>
          <target state="translated">Использует &quot;икру&quot; Нима.</target>
        </trans-unit>
        <trans-unit id="9bd1639b0652a75be41ded9fcf655fff747ec529" translate="yes" xml:space="preserve">
          <source>Implements Nim's &lt;a href=&quot;manual_experimental#parallel-amp-spawn&quot;&gt;spawn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc2133e32a735f3f33a5134e088577045119220" translate="yes" xml:space="preserve">
          <source>Implements a representation of Unicode with the limited ASCII character subset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98bff4e5a957f15674cfda3f7cc2d9c63fef8d1" translate="yes" xml:space="preserve">
          <source>Implements an iterator which, when called repeatedly, returns the next top-level statement or emptyNode if end of stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d8bec9622c1c2efe7cbb87c656d2ee4e52f3f9" translate="yes" xml:space="preserve">
          <source>Implements marshaling for the VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab186fe958c9515dc4682be825a79c4504cec277" translate="yes" xml:space="preserve">
          <source>Implements some helper procs for Nimble (Nim's package manager) support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde737fdbb85e35a06847480351be43a531285da" translate="yes" xml:space="preserve">
          <source>Implements the dispatcher for the different parsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e08fdde0cb22bad986cf922e162257fc105db33" translate="yes" xml:space="preserve">
          <source>Implements the module handling, including the caching of modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16e5331a0e8818de21a9814ad59e5ec8b5fc322" translate="yes" xml:space="preserve">
          <source>Implements the new configuration system for Nim. Uses Nim as a scripting language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34284c7e697106a3a469f02b4020f23a7391954" translate="yes" xml:space="preserve">
          <source>Implements type sanity checking for ASTs resulting from macros. Lots of room for improvement here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb0d65e090ee41d0e4de59b229ce10d50db7a16" translate="yes" xml:space="preserve">
          <source>Implicit conversions are also performed for Nim's &lt;code&gt;range&lt;/code&gt; type constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6604e9fb39f02f35b5c6da5cdcf2e3e926fc60" translate="yes" xml:space="preserve">
          <source>Implicit generics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85b8f323c721c3d94c6bf3a4189d897091a2f86" translate="yes" xml:space="preserve">
          <source>Implicit items/pairs invocations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d95a1a4e4b67185b0210fb79bcd67e7997dd49" translate="yes" xml:space="preserve">
          <source>Implict items/pairs invocations</source>
          <target state="translated">Вызовы на элементы/пары изображения</target>
        </trans-unit>
        <trans-unit id="3ed691724b16d193322f0f4e5a05ffaa21ad149b" translate="yes" xml:space="preserve">
          <source>Import section</source>
          <target state="translated">раздел импорта</target>
        </trans-unit>
        <trans-unit id="e1814134be9eb4b4edfac453d80420ef792ece15" translate="yes" xml:space="preserve">
          <source>Import statement</source>
          <target state="translated">импортная декларация</target>
        </trans-unit>
        <trans-unit id="13f50b27b1067e54a93395faae2bf7e5ac61b5af" translate="yes" xml:space="preserve">
          <source>ImportCpp pragma</source>
          <target state="translated">импортная прагма</target>
        </trans-unit>
        <trans-unit id="89cca234c1c2121d46146205b0c1e5f783e9d794" translate="yes" xml:space="preserve">
          <source>ImportJs pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a87c0305fa3a21d3483f32794feeb2ede2ded57" translate="yes" xml:space="preserve">
          <source>ImportObjC pragma</source>
          <target state="translated">ImportObjC прагма</target>
        </trans-unit>
        <trans-unit id="b131713cc5dd52d93c263e9eaa3064820c90d46d" translate="yes" xml:space="preserve">
          <source>Importc pragma</source>
          <target state="translated">импортная прагма</target>
        </trans-unit>
        <trans-unit id="26fce7795dc194794340bfe9430c05967fd0f0b6" translate="yes" xml:space="preserve">
          <source>Importcpp for enums</source>
          <target state="translated">импорт для перечислений</target>
        </trans-unit>
        <trans-unit id="13bc024961b54b45de0538df5d4d8a1057ce09e2" translate="yes" xml:space="preserve">
          <source>Importcpp for objects</source>
          <target state="translated">Импорт для объектов</target>
        </trans-unit>
        <trans-unit id="c0f89463b661b1c831d73789e1f9b7febf176bb2" translate="yes" xml:space="preserve">
          <source>Importcpp for procs</source>
          <target state="translated">Импорт для проката</target>
        </trans-unit>
        <trans-unit id="2a87ed2bec73f0f4c4783390b3b8eb37f3539383" translate="yes" xml:space="preserve">
          <source>Imported exceptions</source>
          <target state="translated">импортируемые исключения</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="651038eb78adfd6971475066b4835457bc4c8cee" translate="yes" xml:space="preserve">
          <source>Imports a node from another document to this document</source>
          <target state="translated">Импортирует узел из другого документа в этот документ.</target>
        </trans-unit>
        <trans-unit id="c57c28d05a963f62cc6e0646415b874f5ec5d460" translate="yes" xml:space="preserve">
          <source>Impure libraries</source>
          <target state="translated">Беспорядочные библиотеки</target>
        </trans-unit>
        <trans-unit id="76eed90bbf51f40c5cdfe6ef9d9c1bd9751546b4" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;f(...)&lt;/code&gt; (function call) hooks are generated for &lt;code&gt;typeof(f(...))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd75085c09d97b8e3bec53c3d230c26383e2dd2b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;if&lt;/code&gt; statements new scopes begin immediately after the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; keywords and ends after the corresponding &lt;em&gt;then&lt;/em&gt; block. For visualization purposes the scopes have been enclosed in &lt;code&gt;{| |}&lt;/code&gt; in the following example:</source>
          <target state="translated">В операторах &lt;code&gt;if&lt;/code&gt; новые области действия начинаются сразу после ключевых слов &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; и заканчиваются после соответствующего блока &lt;em&gt;then&lt;/em&gt; . Для наглядности области видимости заключены в &lt;code&gt;{| |}&lt;/code&gt; в следующем примере:</target>
        </trans-unit>
        <trans-unit id="6e2bd3e8a5584dffb77d444423cb51fec6a6461a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;x = ...&lt;/code&gt; (assignment) hooks are generated for &lt;code&gt;typeof(x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b317a37aea00acb6907f904d75b22bdcc1d94d" translate="yes" xml:space="preserve">
          <source>In Nim exceptions are objects. By convention, exception types are suffixed with 'Error'. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module defines an exception hierarchy that you might want to stick to. Exceptions derive from &lt;code&gt;system.Exception&lt;/code&gt;, which provides the common interface.</source>
          <target state="translated">В Ниме исключения - это объекты. По соглашению к типам исключений добавляется суффикс &amp;laquo;Ошибка&amp;raquo;. &lt;a href=&quot;system&quot;&gt;Система&lt;/a&gt; модуль определяет иерархию исключений , которые вы могли бы хотеть придерживаться. Исключения являются производными от &lt;code&gt;system.Exception&lt;/code&gt; , который предоставляет общий интерфейс.</target>
        </trans-unit>
        <trans-unit id="9cd83e7d1b8675d5def27847af1a08b46fb4b887" translate="yes" xml:space="preserve">
          <source>In Nim it is possible to have a macro with the syntax of a &lt;em&gt;case-of&lt;/em&gt; expression just with the difference that all of branches are passed to and processed by the macro implementation. It is then up the macro implementation to transform the &lt;em&gt;of-branches&lt;/em&gt; into a valid Nim statement. The following example should show how this feature could be used for a lexical analyzer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd1f399e06fb598711f24d731eec160a7ac7612" translate="yes" xml:space="preserve">
          <source>In Nim new types can be defined within a &lt;code&gt;type&lt;/code&gt; statement:</source>
          <target state="translated">В Nim новые типы можно определять с помощью оператора &lt;code&gt;type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b627b4840bb1e194f3e870e54e41a26eeaaa32b6" translate="yes" xml:space="preserve">
          <source>In Nim the compiler cannot always know if a reference is stored on the stack or not. This is caused by var parameters. Consider this example:</source>
          <target state="translated">В Nim компилятор не всегда может знать,хранится ли ссылка в стеке или нет.Это вызвано параметрами var.Рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="3c1e31b69bdf6fd850da3e70033d8d8c55e35892" translate="yes" xml:space="preserve">
          <source>In Nim there is a distinction between &lt;em&gt;simple statements&lt;/em&gt; and &lt;em&gt;complex statements&lt;/em&gt;. &lt;em&gt;Simple statements&lt;/em&gt; cannot contain other statements: Assignment, procedure calls or the &lt;code&gt;return&lt;/code&gt; statement belong to the simple statements. &lt;em&gt;Complex statements&lt;/em&gt; like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; can contain other statements. To avoid ambiguities, complex statements must always be indented, but single simple statements do not:</source>
          <target state="translated">В Nim есть различие между &lt;em&gt;простыми&lt;/em&gt; и &lt;em&gt;сложными операторами&lt;/em&gt; . &lt;em&gt;Простые операторы&lt;/em&gt; не могут содержать другие операторы: присваивание, вызов процедур или оператор &lt;code&gt;return&lt;/code&gt; относятся к простым операторам. &lt;em&gt;Сложные операторы,&lt;/em&gt; такие как &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , могут содержать другие операторы. Чтобы избежать двусмысленности, сложные операторы всегда должны иметь отступ, а отдельные простые операторы - нет:</target>
        </trans-unit>
        <trans-unit id="d57f5186bf8c243d548cc3d53f7d506ffcb92873" translate="yes" xml:space="preserve">
          <source>In Nim, there is a redundant way to specify the type of an integer literal. First of all, it should be unsurprising that every node has a node kind. The node of an integer literal can be any of the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d31e1fe2a898ddbcb325dce9d25ddd964de3ec" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values greater than 128 never match &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, or &lt;code&gt;\w&lt;/code&gt;, and always match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. This is true even when Unicode character property support is available.</source>
          <target state="translated">В режиме UTF-8, символы со значениями больше 128 никогда не совпадают &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , или &lt;code&gt;\w&lt;/code&gt; , и всегда совпадают &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , и &lt;code&gt;\W&lt;/code&gt; . Это верно, даже если доступна поддержка свойств символов Юникода.</target>
        </trans-unit>
        <trans-unit id="3617947965a09e75ebe2e8b672a9f2c8fd3657b4" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; statement tuple unpacking can be performed. The special identifier &lt;code&gt;_&lt;/code&gt; can be used to ignore some parts of the tuple:</source>
          <target state="translated">В операторе &lt;code&gt;var&lt;/code&gt; или &lt;code&gt;let&lt;/code&gt; можно выполнить распаковку кортежа. Специальный идентификатор &lt;code&gt;_&lt;/code&gt; может использоваться для игнорирования некоторых частей кортежа:</target>
        </trans-unit>
        <trans-unit id="82817ac3f312f0760fba2fa577dfeca03d6206c4" translate="yes" xml:space="preserve">
          <source>In a call &lt;code&gt;p(args)&lt;/code&gt; the routine &lt;code&gt;p&lt;/code&gt; that matches best is selected. If multiple routines match equally well, the ambiguity is reported at compiletime.</source>
          <target state="translated">При вызове &lt;code&gt;p(args)&lt;/code&gt; выбирается наиболее подходящая процедура &lt;code&gt;p&lt;/code&gt; . Если несколько подпрограмм совпадают одинаково, о неоднозначности сообщается во время компиляции.</target>
        </trans-unit>
        <trans-unit id="f14b713b025417c0a4e34b72587925af836dc390" translate="yes" xml:space="preserve">
          <source>In a call &lt;code&gt;p(args)&lt;/code&gt; the routine &lt;code&gt;p&lt;/code&gt; that matches best is selected. If multiple routines match equally well, the ambiguity is reported during semantic analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c9e01363343ad91c6333931ae770e8aef4dfbe" translate="yes" xml:space="preserve">
          <source>In a context with multiple overloads, the integer literal kind will always prefer the &lt;code&gt;int&lt;/code&gt; type over all other types. If none of the overloads is of type &lt;code&gt;int&lt;/code&gt;, then there will be an error because of ambiguity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc62f480a3f9078cee56fe51f6444a9d5250214" translate="yes" xml:space="preserve">
          <source>In a list of statements every expression except the last one needs to have the type &lt;code&gt;void&lt;/code&gt;. In addition to this rule an assignment to the builtin &lt;code&gt;result&lt;/code&gt; symbol also triggers a mandatory &lt;code&gt;void&lt;/code&gt; context for the subsequent expressions:</source>
          <target state="translated">В списке операторов каждое выражение, кроме последнего, должно иметь тип &lt;code&gt;void&lt;/code&gt; . В дополнение к этому правилу присвоение встроенному символу &lt;code&gt;result&lt;/code&gt; также запускает обязательный &lt;code&gt;void&lt;/code&gt; контекст для последующих выражений:</target>
        </trans-unit>
        <trans-unit id="488140be7cd1e3d7c93b424038a2aded23329152" translate="yes" xml:space="preserve">
          <source>In a multi-method all parameters that have an object type are used for the dispatching:</source>
          <target state="translated">В многометодном режиме для диспетчеризации используются все параметры,имеющие тип объекта:</target>
        </trans-unit>
        <trans-unit id="691482e2683e9f978caf9b0b633d8df4760325fa" translate="yes" xml:space="preserve">
          <source>In a typical Nim program, most of the code is compiled into the executable. However, some of the code may be executed at &lt;span id=&quot;compileminustime_1&quot;&gt;compile-time&lt;/span&gt;. This can include constant expressions, macro definitions, and Nim procedures used by macro definitions. Most of the Nim language is supported at compile-time, but there are some restrictions -- see &lt;a href=&quot;#restrictions-on-compileminustime-execution&quot;&gt;Restrictions on Compile-Time Execution&lt;/a&gt; for details. We use the term &lt;span id=&quot;runtime_1&quot;&gt;runtime&lt;/span&gt; to cover both compile-time execution and code execution in the executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b365021e4df4ac8585444b431ae5bb9f1b96ec" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; you can avoid the GC by manually allocating memory with procs like &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;allocShared&lt;/code&gt;, or &lt;code&gt;allocCStringArray&lt;/code&gt;. The GC won't try to free them, you need to call their respective &lt;em&gt;dealloc&lt;/em&gt; pairs when you are done with them or they will leak.</source>
          <target state="translated">В дополнении к &lt;code&gt;GC_ref&lt;/code&gt; и &lt;code&gt;GC_unref&lt;/code&gt; вы можете избежать GC вручную распределения памяти с проками как &lt;code&gt;alloc&lt;/code&gt; , &lt;code&gt;allocShared&lt;/code&gt; или &lt;code&gt;allocCStringArray&lt;/code&gt; . GC не будет пытаться освободить их, вам нужно вызвать их соответствующие &lt;em&gt;dealloc&lt;/em&gt; пары , когда вы сделали с ними , или они будут протекать.</target>
        </trans-unit>
        <trans-unit id="7a05427a05a096304d5b7dacd4ee54218ad43b1b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; you can avoid the garbage collector by manually allocating memory with procs like &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;alloc0&lt;/code&gt;, &lt;code&gt;allocShared&lt;/code&gt;, &lt;code&gt;allocShared0&lt;/code&gt; or &lt;code&gt;allocCStringArray&lt;/code&gt;. The garbage collector won't try to free them, you need to call their respective &lt;em&gt;dealloc&lt;/em&gt; pairs (&lt;code&gt;dealloc&lt;/code&gt;, &lt;code&gt;deallocShared&lt;/code&gt;, &lt;code&gt;deallocCStringArray&lt;/code&gt;, etc) when you are done with them or they will leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590bed6910696c3c90f97fbde2ce87692b87d870" translate="yes" xml:space="preserve">
          <source>In addition to fields, routine applications are also rewritten, but only if no other interpretation of the call is possible:</source>
          <target state="translated">Помимо полей,переписываются и рутинные приложения,но только в том случае,если другая интерпретация вызова невозможна:</target>
        </trans-unit>
        <trans-unit id="00b487c57e5ed991eb8dcee9498e5c5bd5a4eb49" translate="yes" xml:space="preserve">
          <source>In addition to reading dynamic data, Nim can also unmarshal JSON directly into a type with the &lt;code&gt;to&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1eb48be581c9adefbce7b80eb339a9d4bdac6f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;untyped&lt;/code&gt; meta-type that prevents type checking there is also &lt;code&gt;varargs[untyped]&lt;/code&gt; so that not even the number of parameters is fixed:</source>
          <target state="translated">В дополнение к &lt;code&gt;untyped&lt;/code&gt; мета-типу, который предотвращает проверку типов, существует также &lt;code&gt;varargs[untyped]&lt;/code&gt; так что даже количество параметров не фиксируется:</target>
        </trans-unit>
        <trans-unit id="387616e73907f1f0c0f9c9b26be0a31bf6568eb0" translate="yes" xml:space="preserve">
          <source>In addition to the previous levels dumps a debug stack trace for compiler developers.</source>
          <target state="translated">В дополнение к предыдущим уровням дампы отладочного стека для разработчиков компиляторов.</target>
        </trans-unit>
        <trans-unit id="ca3ff803089f70d16c29ec3feff03288c4ba5dae" translate="yes" xml:space="preserve">
          <source>In addition to the standard Nim syntax (&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module), NimScripts support the procs and templates defined in the &lt;a href=&quot;nimscript&quot;&gt;nimscript&lt;/a&gt; module too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa62a58dee28a4f60ea67a6c8e5a270a2279ae13" translate="yes" xml:space="preserve">
          <source>In addition to the usual arithmetic operators for signed and unsigned integers (&lt;code&gt;+ - *&lt;/code&gt; etc.) there are also operators that formally work on &lt;em&gt;signed&lt;/em&gt; integers but treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;: They are mostly provided for backwards compatibility with older versions of the language that lacked unsigned integer types. These unsigned operations for signed integers use the &lt;code&gt;%&lt;/code&gt; suffix as convention:</source>
          <target state="translated">В дополнении к обычным арифметическим операторам для подписанных и неподписанных чисел ( &lt;code&gt;+ - *&lt;/code&gt; и т.д.) есть также операторы , которые формально работают на &lt;em&gt;подписанных&lt;/em&gt; целыхах , но рассматривать их аргументы как &lt;em&gt;беззнаковые&lt;/em&gt; : Они в основном предназначены для обеспечения обратной совместимости с более старыми версиями языка , что не хватало беззнаковых целочисленных типов. Эти беззнаковые операции для целых чисел со знаком используют суффикс &lt;code&gt;%&lt;/code&gt; как соглашение:</target>
        </trans-unit>
        <trans-unit id="a505d4cbc395f14732ae7d9715a2d71dbaa23d6d" translate="yes" xml:space="preserve">
          <source>In all descendant types of the object type.</source>
          <target state="translated">Во всех типах объектов-потомках.</target>
        </trans-unit>
        <trans-unit id="50cffa60fb3019583c70c527c490f8ebd32ae536" translate="yes" xml:space="preserve">
          <source>In an unchecked AST, the &lt;code&gt;typ&lt;/code&gt; field is nil. The type checker will set the &lt;code&gt;typ&lt;/code&gt; field accordingly to the node kind. Nodes of kind &lt;code&gt;nkIntLit&lt;/code&gt; will get the integer literal type (e.g. &lt;code&gt;int literal(123)&lt;/code&gt;). Nodes of kind &lt;code&gt;nkUIntLit&lt;/code&gt; will get type &lt;code&gt;uint&lt;/code&gt; (kind &lt;code&gt;tyUint&lt;/code&gt;), etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76eda137068d108454637b6e3ce61730b1cd808d" translate="yes" xml:space="preserve">
          <source>In any case, sorting also considers scoping information. Local variables get high priority.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8255fdf45779c837c0b26b5faea383860b8d458a" translate="yes" xml:space="preserve">
          <source>In both cases the server will start up and await further commands. The syntax of the commands you can now send to the server is practically the same as running the nim compiler on the commandline, you only need to remove the name of the compiler since you are already talking to it. The server will answer with as many lines of text it thinks necessary plus an empty line to indicate the end of the answer.</source>
          <target state="translated">В обоих случаях сервер запустится и будет ожидать дальнейших команд.Синтаксис команд,которые Вы теперь можете посылать на сервер,практически такой же,как и при запуске компилятора nim в командной строке,Вам нужно только удалить имя компилятора,так как Вы уже говорите с ним.Сервер ответит столько строк текста,сколько считает необходимым,плюс пустая строка,указывающая на конец ответа.</target>
        </trans-unit>
        <trans-unit id="87fcb4c9412aaaad5556b10d061891f17209ecf3" translate="yes" xml:space="preserve">
          <source>In contrast to that, a &lt;span id=&quot;closure-iterator_1&quot;&gt;closure iterator&lt;/span&gt; can be passed around more freely:</source>
          <target state="translated">В отличие от этого, &lt;span id=&quot;closure-iterator_1&quot;&gt;итератор закрытия&lt;/span&gt; можно передавать более свободно:</target>
        </trans-unit>
        <trans-unit id="862b7212edc1329bb097b23c4845a8a8f62159ad" translate="yes" xml:space="preserve">
          <source>In debug mode exceptions store the stack trace that led to them. A &lt;code&gt;StackTraceEntry&lt;/code&gt; is a single entry of the stack trace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d690804e9c35517f69d4546186980d7be8f2789c" translate="yes" xml:space="preserve">
          <source>In debug mode exceptions store the stack trace that led to them. A StackTraceEntry is a single entry of the stack trace.</source>
          <target state="translated">В отладочном режиме исключения хранят трассу стека,которая привела к ним.StackTraceEntry-это одиночный вход трассы стека.</target>
        </trans-unit>
        <trans-unit id="af9ba250b7498b9006c490eda9c8a41290e0b66a" translate="yes" xml:space="preserve">
          <source>In every module compilation, reset the variable to its default value.</source>
          <target state="translated">При каждой модульной компиляции необходимо сбрасывать переменную на ее значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fd3c950a71716cce05a73a0cbb5053b0e20a8202" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;.cursor&lt;/code&gt; more generally prevents object construction/destruction pairs and so can also be useful in other contexts. The alternative solution would be to use raw pointers (&lt;code&gt;ptr&lt;/code&gt;) instead which is more cumbersome and also more dangerous for Nim's evolution: Later on, the compiler can try to prove &lt;code&gt;.cursor&lt;/code&gt; annotations to be safe, but for &lt;code&gt;ptr&lt;/code&gt; the compiler has to remain silent about possible problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d14a65a6bcb84eea05fa7cf43ef339b198f107" translate="yes" xml:space="preserve">
          <source>In fact, a trailing comma is allowed for every tuple construction.</source>
          <target state="translated">На самом деле,для каждой конструкции кортежа допускается использование трейлинговой запятой.</target>
        </trans-unit>
        <trans-unit id="4ef2c0c588919c564185ffbc7d6426162cb97e95" translate="yes" xml:space="preserve">
          <source>In fact, as a convention the following tasks should be available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f48cac88984dbe72037f42d9b3ae356eb7d5f2" translate="yes" xml:space="preserve">
          <source>In fact, the root-mean-square error growth, assuming random roundoff errors, is only O(sqrt(log n)), which is nearly indistinguishable from O(1) in practice. See:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e80bc5993cb0fc4644c16fb07461ebb339b897" translate="yes" xml:space="preserve">
          <source>In fact, this decribes how the AST should be stored in the database, as a &quot;shallow&quot; tree. Let's assume we compile module &lt;code&gt;m&lt;/code&gt; with the following contents:</source>
          <target state="translated">Фактически, это описывает, как AST должен храниться в базе данных в виде &amp;laquo;мелкого&amp;raquo; дерева. Предположим, мы компилируем модуль &lt;code&gt;m&lt;/code&gt; со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="969fc90580200d3e34a84a7165170b2d397306ec" translate="yes" xml:space="preserve">
          <source>In fact, this describes how the AST should be stored in the database, as a &quot;shallow&quot; tree. Let's assume we compile module &lt;code&gt;m&lt;/code&gt; with the following contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7200c67cd9ab4646acaefd95fd28854405ad659" translate="yes" xml:space="preserve">
          <source>In general the case statement is used for subrange types or enumerations where it is of great help that the compiler checks that you covered any possible value.</source>
          <target state="translated">В общем случае оператор используется для поддиапазонных типов или перечислений,где компилятору очень помогает проверка того,что вы покрыли любое возможное значение.</target>
        </trans-unit>
        <trans-unit id="df2250e080bf643576540d132cb54644051a2eb3" translate="yes" xml:space="preserve">
          <source>In general, declaring types mirrors this syntax (i.e., &lt;code&gt;nnkStaticTy&lt;/code&gt; for &lt;code&gt;static&lt;/code&gt;, etc.). Examples follow (exceptions marked by &lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">В общем, объявление типов отражает этот синтаксис (например, &lt;code&gt;nnkStaticTy&lt;/code&gt; для &lt;code&gt;static&lt;/code&gt; и т. Д.). Ниже приведены примеры (исключения отмечены &lt;code&gt;*&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="1393a34bf1d4daea288238586a51eb0e1faccf00" translate="yes" xml:space="preserve">
          <source>In general, importing a dynamic library does not require any special linker options or linking with import libraries. This also implies that no &lt;em&gt;devel&lt;/em&gt; packages need to be installed.</source>
          <target state="translated">В общем, импорт динамической библиотеки не требует каких-либо специальных параметров компоновщика или связывания с библиотеками импорта. Это также означает , что никакие &lt;em&gt;Devel&lt;/em&gt; пакеты не должны быть установлены.</target>
        </trans-unit>
        <trans-unit id="0d0713666c6f10149634654fda5f08d4b39e3997" translate="yes" xml:space="preserve">
          <source>In highly specific cases (a dispatch loop of a bytecode interpreter for example) it may provide benefits, though.</source>
          <target state="translated">В весьма специфических случаях (например,в случае диспетчерского цикла байткод-интерпретатора)это может дать преимущества.</target>
        </trans-unit>
        <trans-unit id="ccadb2f2afa462fe0a8e3a89f264df971c7a74b0" translate="yes" xml:space="preserve">
          <source>In many contexts, Nim allows you to treat the names of types as regular values. These values exists only during the compilation phase, but since all values must have a type, &lt;code&gt;type&lt;/code&gt; is considered their special type.</source>
          <target state="translated">Во многих случаях Nim позволяет вам обрабатывать имена типов как обычные значения. Эти значения существуют только на этапе компиляции, но поскольку все значения должны иметь тип, &lt;code&gt;type&lt;/code&gt; считается их особым типом.</target>
        </trans-unit>
        <trans-unit id="5c2d206739a6370d6bd70863bb15b2c58816d4d9" translate="yes" xml:space="preserve">
          <source>In many contexts, Nim treats the names of types as regular values. These values exist only during the compilation phase, but since all values must have a type, &lt;code&gt;typedesc&lt;/code&gt; is considered their special type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92effa90645c39523ba9f53c9bfe7bc808f9c10d" translate="yes" xml:space="preserve">
          <source>In normal debug and release builds code within a &lt;code&gt;runnableExamples&lt;/code&gt; section is ignored.</source>
          <target state="translated">В обычных сборках отладки и выпуска код в разделе &lt;code&gt;runnableExamples&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="0fce6426da4fa8e50461c5a84f0b4bb26d70a6f7" translate="yes" xml:space="preserve">
          <source>In order to begin any sort of transfer of files you must first connect to an FTP server. You can do so with the &lt;code&gt;connect&lt;/code&gt; procedure.</source>
          <target state="translated">Чтобы начать передачу файлов, вы должны сначала подключиться к FTP-серверу. Вы можете сделать это с помощью процедуры &lt;code&gt;connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0b84c550d9a8232bb0005f5c64c0b247f3554dd" translate="yes" xml:space="preserve">
          <source>In order to check for symbols accepting &lt;code&gt;type&lt;/code&gt; params, you must prefix the type with the explicit &lt;code&gt;type&lt;/code&gt; modifier. The named instance of the type, following the &lt;code&gt;concept&lt;/code&gt; keyword is also considered to have the explicit modifier and will be matched only as a type.</source>
          <target state="translated">Чтобы проверить наличие символов, принимающих параметры &lt;code&gt;type&lt;/code&gt; , вы должны указать перед типом явный модификатор &lt;code&gt;type&lt;/code&gt; . Именованный экземпляр типа, следующий за ключевым словом &lt;code&gt;concept&lt;/code&gt; , также считается имеющим явный модификатор и будет сопоставлен только как тип.</target>
        </trans-unit>
        <trans-unit id="ea6a479b9d25899b927b071796e99387ee4ff9e8" translate="yes" xml:space="preserve">
          <source>In order to compile Nim correctly, type-checking has to be separated from parsing. Otherwise generics cannot work.</source>
          <target state="translated">Чтобы правильно скомпилировать Nim,проверка типов должна быть отделена от парсинга.В противном случае генераторы не смогут работать.</target>
        </trans-unit>
        <trans-unit id="f3802bfad258aac8c84f9a57c30500e4a9483a31" translate="yes" xml:space="preserve">
          <source>In order to encode some text simply call the &lt;code&gt;encode&lt;/code&gt; procedure:</source>
          <target state="translated">Чтобы закодировать текст, просто вызовите процедуру &lt;code&gt;encode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a773d5bee7ad3c817ebe19e70c4e28c0ee6b821" translate="yes" xml:space="preserve">
          <source>In order to simplify structural type checking, recursive tuples are not valid:</source>
          <target state="translated">Для упрощения проверки типа конструкции рекурсивные кортежи недействительны:</target>
        </trans-unit>
        <trans-unit id="312ff897ae89606cffe84af5ae7f281fbffba243" translate="yes" xml:space="preserve">
          <source>In order to use the SSL procedures defined in this module, you will need to compile your application with the &lt;code&gt;-d:ssl&lt;/code&gt; flag.</source>
          <target state="translated">Чтобы использовать процедуры SSL, определенные в этом модуле, вам нужно будет скомпилировать приложение с флагом &lt;code&gt;-d:ssl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e1dd897461868e4657b4049dc2954656f20d85f" translate="yes" xml:space="preserve">
          <source>In order to use the SSL procedures defined in this module, you will need to compile your application with the &lt;code&gt;-d:ssl&lt;/code&gt; flag. See the &lt;a href=&quot;net#newContext%2Cstring%2Cstring%2Cstring%2Cstring%2Cstring&quot;&gt;newContext&lt;/a&gt; procedure for additional details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560248995a8c3109fbb872863af1490f690d2896" translate="yes" xml:space="preserve">
          <source>In ordinary object oriented languages, procedures (also called &lt;em&gt;methods&lt;/em&gt;) are bound to a class. This has disadvantages:</source>
          <target state="translated">В обычных объектно-ориентированных языках процедуры (также называемые &lt;em&gt;методами&lt;/em&gt; ) привязаны к классу. У этого есть недостатки:</target>
        </trans-unit>
        <trans-unit id="e4128b2c0621b4875f7c93b74e81a267e43568d9" translate="yes" xml:space="preserve">
          <source>In other words sets a thread's &lt;span id=&quot;affinity_1&quot;&gt;affinity&lt;/span&gt;. If you don't know what this means, you shouldn't use this proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a598cac77f3ad01c6206ae5a35aace4982027b" translate="yes" xml:space="preserve">
          <source>In other words, the lifetime of what &lt;code&gt;result&lt;/code&gt; points to is attached to the lifetime of the first parameter and that is enough knowledge to verify memory safety at the call site.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
