<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="e93d86b822e12c4d9ce33d7af413f341c5867140" translate="yes" xml:space="preserve">
          <source>Shared table support for Nim. Use plain old non GC'ed keys and values or you'll be in trouble. Uses a single lock to protect the table, lockfree implementations welcome but if lock contention is so high that you need a lockfree hash table, you're doing it wrong.</source>
          <target state="translated">Поддержка Ним за общим столом.Используйте обычные старые не GC'ed ключи и значения,иначе у вас будут проблемы.Использует единственную блокировку для защиты таблицы,реализация без блокировки приветствуется,но если содержание блокировки настолько велико,что вам нужна хэш-таблица без блокировки,вы делаете это неправильно.</target>
        </trans-unit>
        <trans-unit id="ec91193d5f88e5c879887f1193cd72ef6a694d25" translate="yes" xml:space="preserve">
          <source>Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off.</source>
          <target state="translated">Сдвигает вправо,вдавливая копии крайнего левого бита слева,и позволяет выпадать крайним правым битам.</target>
        </trans-unit>
        <trans-unit id="05a85db16fbdbc68d6790c4c1c6d2377589785de" translate="yes" xml:space="preserve">
          <source>Short description of Nim's modules</source>
          <target state="translated">Краткое описание модулей Nim</target>
        </trans-unit>
        <trans-unit id="3aea3a391a6ebfd7b559fa27a009254bdee9654e" translate="yes" xml:space="preserve">
          <source>Short notation for:</source>
          <target state="translated">Короткая нотация для:</target>
        </trans-unit>
        <trans-unit id="1b40ffe9db9b97f7227d428a8e93cd1910e5bd51" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;?(a *(b a))&lt;/code&gt;. Usually used for separators.</source>
          <target state="translated">Ярлык для &lt;code&gt;?(a *(b a))&lt;/code&gt; . Обычно используется для разделителей.</target>
        </trans-unit>
        <trans-unit id="0fea2072669df686bfd29fd3b1504df5061432af" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;?(a +(b a))&lt;/code&gt;. Usually used for separators.</source>
          <target state="translated">Ярлык для &lt;code&gt;?(a +(b a))&lt;/code&gt; . Обычно используется для разделителей.</target>
        </trans-unit>
        <trans-unit id="cb96e2c575443083f6d3ddc0cd31cddbe58784dd" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;toHex(x, T.sizeOf * 2)&lt;/code&gt;</source>
          <target state="translated">Ярлык для &lt;code&gt;toHex(x, T.sizeOf * 2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f9539002b86530179421f52fa92949ef36aae77" translate="yes" xml:space="preserve">
          <source>Shortcut version to assign in let blocks. Example:</source>
          <target state="translated">Краткосрочная версия для назначения в пустых блоках.Пример:</target>
        </trans-unit>
        <trans-unit id="7f2812564b5e2e84d2a67a63d392d651dcda3d10" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;dt.inZone(local())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dt.inZone(local())&lt;/code&gt; для dt.inZone (local ()) .</target>
        </trans-unit>
        <trans-unit id="088f96652b3ac9c5f1a3b23e8ff7e823708ee634" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;dt.inZone(utc())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dt.inZone(utc())&lt;/code&gt; для dt.inZone (utc ()) .</target>
        </trans-unit>
        <trans-unit id="7cc17510fc204a22966fffd1886072211dea19a4" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;getTime().local&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getTime().local&lt;/code&gt; для getTime (). Local .</target>
        </trans-unit>
        <trans-unit id="ccefd273539ba57e397a1a987afc4b367d6fd0cb" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;t.inZone(local())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t.inZone(local())&lt;/code&gt; для t.inZone (local ()) .</target>
        </trans-unit>
        <trans-unit id="4d38209d424b19a4a50f30394d53391f0377fef8" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;t.inZone(utc())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t.inZone(utc())&lt;/code&gt; для t.inZone (utc ()) .</target>
        </trans-unit>
        <trans-unit id="6166daff0169e3dc89cc83eb9c8606a8a6917a8d" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to format &lt;code&gt;dt&lt;/code&gt;.</source>
          <target state="translated">Сокращение для создания &lt;code&gt;TimeFormat&lt;/code&gt; и использования его для форматирования &lt;code&gt;dt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f394b42391f134971c4fd4caf836bd1af83856ed" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to format &lt;code&gt;time&lt;/code&gt;. Will use the timezone specified by &lt;code&gt;zone&lt;/code&gt;.</source>
          <target state="translated">Сокращение для создания &lt;code&gt;TimeFormat&lt;/code&gt; и использования его для форматирования &lt;code&gt;time&lt;/code&gt; . Будет использовать часовой пояс, указанный в &lt;code&gt;zone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="719276957fc6ed6b9a172fd432c232dc57b61097" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to parse &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt;, then converting it a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">Сокращение для создания &lt;code&gt;TimeFormat&lt;/code&gt; и использования его для анализа &lt;code&gt;input&lt;/code&gt; как &lt;code&gt;DateTime&lt;/code&gt; , а затем преобразования его во &lt;code&gt;Time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="634ede6a595bd79a1f089d455148e4b9e1b829dc" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to parse &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">Сокращение для создания &lt;code&gt;TimeFormat&lt;/code&gt; и использования его для синтаксического анализа &lt;code&gt;input&lt;/code&gt; как &lt;code&gt;DateTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a88a0a1d83dbc4654c51021948189560a75286b" translate="yes" xml:space="preserve">
          <source>Shows global variables declarations.</source>
          <target state="translated">Показывает объявления глобальных переменных.</target>
        </trans-unit>
        <trans-unit id="0e16604c6fe1879f13dbc7c436126fd3ae0ebb67" translate="yes" xml:space="preserve">
          <source>Shows the cursor.</source>
          <target state="translated">Показывает курсор.</target>
        </trans-unit>
        <trans-unit id="5ddc127fefceccd7916455147b0c6cd1bfd5eb59" translate="yes" xml:space="preserve">
          <source>Shows when the C compiler is called.</source>
          <target state="translated">Показывает,когда вызывается компилятор Си.</target>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="65a4950085292c6592af7d8392c4038e653ea152" translate="yes" xml:space="preserve">
          <source>Sign function. Returns -1 for negative numbers and &lt;em&gt;NegInf&lt;/em&gt;, 1 for positive numbers and &lt;em&gt;Inf&lt;/em&gt;, and 0 for positive zero, negative zero and &lt;em&gt;NaN&lt;/em&gt;.</source>
          <target state="translated">Знак функции. Возвращает -1 для отрицательных чисел и &lt;em&gt;NegInf&lt;/em&gt; , 1 для положительных чисел и &lt;em&gt;Inf&lt;/em&gt; и 0 для положительного нуля, отрицательного нуля и &lt;em&gt;NaN&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8831fa9078748ee02f2347f5d90c34f992582819" translate="yes" xml:space="preserve">
          <source>Signal handling in Nim</source>
          <target state="translated">Обработка сигналов в Ним</target>
        </trans-unit>
        <trans-unit id="f006508366ff589e263e35089658634396886e2b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;recvLine&lt;/code&gt; but designed for non-blocking sockets.</source>
          <target state="translated">Аналогичен &lt;code&gt;recvLine&lt;/code&gt; , но предназначен для неблокирующих сокетов.</target>
        </trans-unit>
        <trans-unit id="3088f8f41c176a8c6c078dcbb7290cd8f5dcfe1d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;write&lt;/code&gt;, but treating terminal style arguments specially. When some argument is &lt;code&gt;Style&lt;/code&gt;, &lt;code&gt;set[Style]&lt;/code&gt;, &lt;code&gt;ForegroundColor&lt;/code&gt;, &lt;code&gt;BackgroundColor&lt;/code&gt; or &lt;code&gt;TerminalCmd&lt;/code&gt; then it is not sent directly to &lt;code&gt;f&lt;/code&gt;, but instead corresponding terminal style proc is called.</source>
          <target state="translated">Подобно &lt;code&gt;write&lt;/code&gt; , но обрабатывает аргументы терминального стиля специально. Когда некоторым аргументом является &lt;code&gt;Style&lt;/code&gt; , &lt;code&gt;set[Style]&lt;/code&gt; , &lt;code&gt;ForegroundColor&lt;/code&gt; , &lt;code&gt;BackgroundColor&lt;/code&gt; или &lt;code&gt;TerminalCmd&lt;/code&gt; , тогда он не отправляется напрямую в &lt;code&gt;f&lt;/code&gt; , а вместо этого вызывается соответствующий процесс стиля терминала.</target>
        </trans-unit>
        <trans-unit id="775c84deb7fd1acce89cc09f380ce7f83b7c3680" translate="yes" xml:space="preserve">
          <source>Similar to POSIX's &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;</source>
          <target state="translated">Подобно &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt; в POSIX&lt;span id=&quot;getpeername_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9112c6f819f5ac3102803b1b46b40279bc4dc6e4" translate="yes" xml:space="preserve">
          <source>Similar to POSIX's &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="translated">Подобно &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt; в POSIX .</target>
        </trans-unit>
        <trans-unit id="d23f8837af17d948ac41ffcd02bd63cca20c677c" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma for C&lt;/a&gt;, the &lt;code&gt;importcpp&lt;/code&gt; pragma can be used to import &lt;span id=&quot;cplusplus_2&quot;&gt;C++&lt;/span&gt; methods or C++ symbols in general. The generated code then uses the C++ method calling syntax: &lt;code&gt;obj-&amp;gt;method(arg)&lt;/code&gt;. In combination with the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;emit&lt;/code&gt; pragmas this allows &lt;em&gt;sloppy&lt;/em&gt; interfacing with libraries written in C++:</source>
          <target state="translated">Подобно &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc прагме для C&lt;/a&gt; , то &lt;code&gt;importcpp&lt;/code&gt; прагма может быть использован для импорта &lt;span id=&quot;cplusplus_2&quot;&gt;C ++&lt;/span&gt; методы или символы C ++ в целом. Сгенерированный код затем использует синтаксис вызова метода C ++: &lt;code&gt;obj-&amp;gt;method(arg)&lt;/code&gt; . В сочетании с &lt;code&gt;header&lt;/code&gt; и &lt;code&gt;emit&lt;/code&gt; прагм это позволяет &lt;em&gt;неаккуратно&lt;/em&gt; взаимодействие с библиотеками , написанными на C ++:</target>
        </trans-unit>
        <trans-unit id="f0db59dc951868b6d9e5ad7d56c503fc95dfe4f0" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma for C&lt;/a&gt;, the &lt;code&gt;importobjc&lt;/code&gt; pragma can be used to import &lt;span id=&quot;objective-c_2&quot;&gt;Objective C&lt;/span&gt; methods. The generated code then uses the Objective C method calling syntax: &lt;code&gt;[obj method param1: arg]&lt;/code&gt;. In addition with the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;emit&lt;/code&gt; pragmas this allows &lt;em&gt;sloppy&lt;/em&gt; interfacing with libraries written in Objective C:</source>
          <target state="translated">Подобно &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;прагме importc для C&lt;/a&gt; , прагма &lt;code&gt;importobjc&lt;/code&gt; может использоваться для импорта методов &lt;span id=&quot;objective-c_2&quot;&gt;Objective C. &lt;/span&gt;Сгенерированный код затем использует синтаксис вызова метода Objective C: &lt;code&gt;[obj method param1: arg]&lt;/code&gt; . Кроме того с &lt;code&gt;header&lt;/code&gt; , и &lt;code&gt;emit&lt;/code&gt; прагм это позволяет &lt;em&gt;неаккуратно&lt;/em&gt; взаимодействие с библиотеками , написанными на Objective C:</target>
        </trans-unit>
        <trans-unit id="3adf311c5dd828b7c450080b9fe51795b3cb57d5" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;code&gt;import&lt;/code&gt; statement, the AST is different for &lt;code&gt;export ... except&lt;/code&gt;.</source>
          <target state="translated">Подобно оператору &lt;code&gt;import&lt;/code&gt; , AST отличается для &lt;code&gt;export ... except&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17f571225bcdb0061542084cc744c2d22c9a95bd" translate="yes" xml:space="preserve">
          <source>Similarly to &lt;span id=&quot;argv_1&quot;&gt;argv&lt;/span&gt; in C, it is possible to call &lt;code&gt;paramStr(0)&lt;/code&gt; but this will return OS specific contents (usually the name of the invoked executable). You should avoid this and call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt; instead.</source>
          <target state="translated">Подобно &lt;span id=&quot;argv_1&quot;&gt;argv&lt;/span&gt; в C, можно вызвать &lt;code&gt;paramStr(0)&lt;/code&gt; но это вернет содержимое, специфичное для ОС (обычно имя вызванного исполняемого файла). Вам следует избегать этого и вместо этого вызывать &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0836ce8cc993ea5e6c237d5e13b1926310dd2fc9" translate="yes" xml:space="preserve">
          <source>Similarly to the old &lt;code&gt;doc&lt;/code&gt; command the old &lt;code&gt;jsondoc&lt;/code&gt; command has been renamed &lt;code&gt;jsondoc0&lt;/code&gt;.</source>
          <target state="translated">Как и старая команда &lt;code&gt;doc&lt;/code&gt; , старая команда &lt;code&gt;jsondoc&lt;/code&gt; была переименована в &lt;code&gt;jsondoc0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="923d2208cc2a00f7a0f1b3452857f4ae436b40d2" translate="yes" xml:space="preserve">
          <source>Similarly, any procedure and procedure type declarations that are longer than one line should do the same thing.</source>
          <target state="translated">Аналогичным образом,любые декларации типов процедур и процедур,которые длиннее одной строки,должны делать то же самое.</target>
        </trans-unit>
        <trans-unit id="03199fb1565fa787d6b802de955cc02879b12e5f" translate="yes" xml:space="preserve">
          <source>Simple PEG (Parsing expression grammar) matching. Uses no memorization, but uses superoperators and symbol inlining to improve performance. Note: Matching performance is hopefully competitive with optimized regular expression engines.</source>
          <target state="translated">Простое совпадение PEG (грамматика выражения парсинга).Не использует запоминание,но использует супероператоры и символьные вставки для улучшения производительности.Обратите внимание:соответствие производительности,надеюсь,конкурирует с оптимизированными движками регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="642d63f4b98668cb5f7dde10bc28bf59ccdf215c" translate="yes" xml:space="preserve">
          <source>Simple assertions</source>
          <target state="translated">Простые утверждения</target>
        </trans-unit>
        <trans-unit id="edcc542b12309c356f091b9913fd4380c94b4828" translate="yes" xml:space="preserve">
          <source>Simple example that parses the &lt;code&gt;/etc/passwd&lt;/code&gt; file line by line:</source>
          <target state="translated">Простой пример, который анализирует файл &lt;code&gt;/etc/passwd&lt;/code&gt; построчно:</target>
        </trans-unit>
        <trans-unit id="e8a60d51d4165fef55cc82ac2db54d5e0a688774" translate="yes" xml:space="preserve">
          <source>Simply add --os:nintendoswitch to your usual &lt;code&gt;nim c&lt;/code&gt; or &lt;code&gt;nim cpp&lt;/code&gt; command and set the &lt;code&gt;passC&lt;/code&gt; and &lt;code&gt;passL&lt;/code&gt; command line switches to something like:</source>
          <target state="translated">Просто добавьте --os: nintendoswitch к своей обычной команде &lt;code&gt;nim c&lt;/code&gt; или &lt;code&gt;nim cpp&lt;/code&gt; и установите &lt;code&gt;passC&lt;/code&gt; командной строки passC и &lt;code&gt;passL&lt;/code&gt; примерно так:</target>
        </trans-unit>
        <trans-unit id="b090179dd62a9781100bf21383b86b639866ae6b" translate="yes" xml:space="preserve">
          <source>Since Nim generates C++ directly, any destructor is called implicitly by the C++ compiler at the scope exits. This means that often one can get away with not wrapping the destructor at all! However when it needs to be invoked explicitly, it needs to be wrapped. The pattern language provides everything that is required:</source>
          <target state="translated">Поскольку Nim генерирует C++напрямую,любой деструктор неявно вызывается компилятором C++при выходе из области видимости.Это означает,что часто можно уйти,вообще не обернув деструктор! Однако,когда его нужно явно вызвать,он должен быть обернут.Язык шаблонов предоставляет все необходимое:</target>
        </trans-unit>
        <trans-unit id="2836b4cd35895fbe3e4607ab829e68b8adca5bab" translate="yes" xml:space="preserve">
          <source>Since Nim is implemented in Nim, one of the nice things of this feature is that any user with an IDE supporting it can quickly jump around the standard library implementation and see exactly what a proc does, learning about the language and seeing real life examples of how to write/implement specific features.</source>
          <target state="translated">Так как Nim реализован в Nim,одна из приятных вещей этой функции заключается в том,что любой пользователь с поддерживаемой IDE может быстро обойти стандартную реализацию библиотеки и посмотреть,что именно делает proc,изучив язык и увидев реальные примеры написания/внедрения специфических функций.</target>
        </trans-unit>
        <trans-unit id="81d6398a9d34106da960c47713538b3d721fae12" translate="yes" xml:space="preserve">
          <source>Since Nim's garbage collector is not aware of the C code, once the &lt;code&gt;gimme&lt;/code&gt; proc has finished it can reclaim the memory of the &lt;code&gt;cstring&lt;/code&gt;. However, from a practical standpoint, the C code invoking the &lt;code&gt;gimme&lt;/code&gt; function directly will be able to use it since Nim's garbage collector has not had a chance to run &lt;em&gt;yet&lt;/em&gt;. This gives you enough time to make a copy for the C side of the program, as calling any further Nim procs &lt;em&gt;might&lt;/em&gt; trigger garbage collection making the previously returned string garbage. Or maybe you are &lt;a href=&quot;gc&quot;&gt;yourself triggering the collection&lt;/a&gt;.</source>
          <target state="translated">Поскольку сборщик мусора Nim не знает кода C, после завершения процесса &lt;code&gt;gimme&lt;/code&gt; он может освободить память &lt;code&gt;cstring&lt;/code&gt; . Однако, с практической точки зрения, код C вызова &lt;code&gt;gimme&lt;/code&gt; функции непосредственно будет иметь возможность использовать его , так как сборщик мусора Nim в не имел возможности работать &lt;em&gt;еще&lt;/em&gt; . Это дает вам достаточно времени, чтобы сделать копию для стороны C программы, поскольку вызов любых дальнейших процессов Nim &lt;em&gt;может&lt;/em&gt; вызвать сборку мусора, сделав ранее возвращенную строку мусором. Или, может быть, вы &lt;a href=&quot;gc&quot;&gt;сами запускаете сбор&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2d2708a6e9c531e547adff103c4d9f239c3ef0" translate="yes" xml:space="preserve">
          <source>Since closures capture local variables by reference it is often not wanted behavior inside loop bodies. See &lt;a href=&quot;system#closureScope&quot;&gt;closureScope&lt;/a&gt; for details on how to change this behavior.</source>
          <target state="translated">Поскольку замыкания захватывают локальные переменные по ссылке, часто нежелательно поведение внутри тела цикла. См. &lt;a href=&quot;system#closureScope&quot;&gt;ClosureScope&lt;/a&gt; для получения подробной информации о том, как изменить это поведение.</target>
        </trans-unit>
        <trans-unit id="433b2057ed04740122c7f9487a7fd644b8ab062a" translate="yes" xml:space="preserve">
          <source>Since counting up occurs so often in programs, Nim also has a &lt;a href=&quot;system#...i,S,T&quot;&gt;..&lt;/a&gt; iterator that does the same:</source>
          <target state="translated">Поскольку в программах счет происходит очень часто, у Nim есть итератор &lt;a href=&quot;system#...i,S,T&quot;&gt;..,&lt;/a&gt; который делает то же самое:</target>
        </trans-unit>
        <trans-unit id="3f5358496f3a495272baef5ad9c4459080748780" translate="yes" xml:space="preserve">
          <source>Since module names are generally long to be descriptive, you can also define a shorter alias to use when qualifying symbols.</source>
          <target state="translated">Поскольку имена модулей обычно длинные,чтобы быть описательными,вы можете также определить более короткий псевдоним,который будет использоваться при квалификации символов.</target>
        </trans-unit>
        <trans-unit id="eeb691770c7129b48bc1fbd85364e037b06e51a3" translate="yes" xml:space="preserve">
          <source>Since objects can reside on the heap or on the stack this greatly enhances the expressivity of the language:</source>
          <target state="translated">Так как объекты могут находиться на куче или на стеке,это значительно увеличивает выразительность языка:</target>
        </trans-unit>
        <trans-unit id="d18abb59d5555a0cd68ad92ca498969b76edc73a" translate="yes" xml:space="preserve">
          <source>Since some cases are specific to either &lt;code&gt;ProcRun&lt;/code&gt; or &lt;code&gt;CaasRun&lt;/code&gt; modes, you can prefix a line with the mode and the line will be processed only in that mode.</source>
          <target state="translated">Поскольку некоторые случаи относятся к &lt;code&gt;ProcRun&lt;/code&gt; или &lt;code&gt;CaasRun&lt;/code&gt; , вы можете добавить к строке префикс режима, и эта строка будет обрабатываться только в этом режиме.</target>
        </trans-unit>
        <trans-unit id="d1b539956855f09af0d247b1afd8148391989674" translate="yes" xml:space="preserve">
          <source>Since templates and macros that are not declared as &lt;code&gt;immediate&lt;/code&gt; participate in overloading resolution it's essential to have a way to pass unresolved expressions to a template or macro. This is what the meta-type &lt;code&gt;untyped&lt;/code&gt; accomplishes:</source>
          <target state="translated">Поскольку шаблоны и макросы, которые не объявлены как &lt;code&gt;immediate&lt;/code&gt; участвуют в разрешении перегрузки, важно иметь способ передать неразрешенные выражения в шаблон или макрос. Это то, что выполняет &lt;code&gt;untyped&lt;/code&gt; мета-тип :</target>
        </trans-unit>
        <trans-unit id="20070e544008a5d9a536d614aa3a8b327168b8fa" translate="yes" xml:space="preserve">
          <source>Since the input is not modified you can use this version of &lt;code&gt;map&lt;/code&gt; to transform the type of the elements in the input container.</source>
          <target state="translated">Поскольку входные данные не изменяются, вы можете использовать эту версию &lt;code&gt;map&lt;/code&gt; для преобразования типа элементов во входном контейнере.</target>
        </trans-unit>
        <trans-unit id="8bd7e9132b57aa66fa0c89392e52a98747d0fab5" translate="yes" xml:space="preserve">
          <source>Since types are graphs which can have cycles, the above algorithm needs an auxiliary set &lt;code&gt;s&lt;/code&gt; to detect this case.</source>
          <target state="translated">Поскольку типы - это графы, которые могут иметь циклы, вышеуказанному алгоритму требуется вспомогательный набор &lt;code&gt;s&lt;/code&gt; для обнаружения этого случая.</target>
        </trans-unit>
        <trans-unit id="693c97bf55b6187119c714b7b185fa6734646019" translate="yes" xml:space="preserve">
          <source>Since we adopt the &quot;replay the top level statements&quot; idea, the natural solution to this problem is to emit pseudo top level statements that reflect the mutations done to the global variable. However, this is MUCH harder than it sounds, for example &lt;code&gt;squeaknim&lt;/code&gt; uses this snippet:</source>
          <target state="translated">Поскольку мы принимаем идею &amp;laquo;воспроизвести операторы верхнего уровня&amp;raquo;, естественным решением этой проблемы является создание операторов псевдо-верхнего уровня, которые отражают мутации, внесенные в глобальную переменную. Однако это НАМНОГО сложнее, чем кажется, например, &lt;code&gt;squeaknim&lt;/code&gt; использует этот фрагмент:</target>
        </trans-unit>
        <trans-unit id="d11cd8a4ff2f39268c05039e2c72e08ef63a5b60" translate="yes" xml:space="preserve">
          <source>Since we are building on the previous example generating source code, we will only mention the differences to it. Instead of creating a temporary &lt;code&gt;string&lt;/code&gt; variable and writing into it source code as if it were written &lt;em&gt;by hand&lt;/em&gt;, we use the &lt;code&gt;result&lt;/code&gt; variable directly and create a statement list node (&lt;code&gt;nnkStmtList&lt;/code&gt;) which will hold our children (line 7).</source>
          <target state="translated">Поскольку мы основываемся на предыдущем примере создания исходного кода, мы упомянем только его отличия. Вместо того, чтобы создавать временную &lt;code&gt;string&lt;/code&gt; переменную и записывать в нее исходный код, как если бы он был написан &lt;em&gt;вручную&lt;/em&gt; , мы напрямую используем &lt;code&gt;result&lt;/code&gt; переменную и создаем узел списка операторов ( &lt;code&gt;nnkStmtList&lt;/code&gt; ), который будет содержать наших дочерних элементов (строка 7).</target>
        </trans-unit>
        <trans-unit id="67281e7beeac085659bafd0aefa97a7715dd587c" translate="yes" xml:space="preserve">
          <source>Skips &lt;code&gt;size&lt;/code&gt; amount of bytes.</source>
          <target state="translated">Пропускает &lt;code&gt;size&lt;/code&gt; в байтах.</target>
        </trans-unit>
        <trans-unit id="caa40925a8a5ba1ec2c47da0074b9498483ee486" translate="yes" xml:space="preserve">
          <source>Skips all characters until one char from the set &lt;em&gt;until&lt;/em&gt; is found or the end is reached. Returns number of characters skipped.</source>
          <target state="translated">Пропускает все символы, пока не будет найден один символ из набора или &lt;em&gt;пока&lt;/em&gt; не будет достигнут конец. Возвращает количество пропущенных символов.</target>
        </trans-unit>
        <trans-unit id="c0250535bb44963b382eb260412b12ae060f9664" translate="yes" xml:space="preserve">
          <source>Skips all characters until the char &lt;em&gt;until&lt;/em&gt; is found or the end is reached. Returns number of characters skipped.</source>
          <target state="translated">Пропускает все символы, пока символ &lt;em&gt;не&lt;/em&gt; будет найден или не будет достигнут конец. Возвращает количество пропущенных символов.</target>
        </trans-unit>
        <trans-unit id="82c633400ddfee46423e0bdfdd5bf1035984706d" translate="yes" xml:space="preserve">
          <source>Skips all characters while one char from the set &lt;em&gt;token&lt;/em&gt; is found. Returns number of characters skipped.</source>
          <target state="translated">Пропускает все символы, пока найден один символ из установленного &lt;em&gt;токена&lt;/em&gt; . Возвращает количество пропущенных символов.</target>
        </trans-unit>
        <trans-unit id="e7c8076f2280bb4f56da2f4ba9faf089bdaf35a9" translate="yes" xml:space="preserve">
          <source>Skips optional whitespace.</source>
          <target state="translated">Пропускает опционально пробелы.</target>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="3b0fe98905d1d18450c150302cb674830bef8f5f" translate="yes" xml:space="preserve">
          <source>Slices are optimized so that no copy is performed. This optimization is not yet performed for ordinary slices outside of a &lt;code&gt;parallel&lt;/code&gt; section.</source>
          <target state="translated">Срезы оптимизированы, поэтому копирование не выполняется. Эта оптимизация еще не выполняется для обычных срезов вне &lt;code&gt;parallel&lt;/code&gt; части.</target>
        </trans-unit>
        <trans-unit id="6b4413ae4cc49215fae1d8456ab98bdf32cdd690" translate="yes" xml:space="preserve">
          <source>Slices look similar to subranges types in syntax but are used in a different context. A slice is just an object of type Slice which contains two bounds, &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;. By itself a slice is not very useful, but other collection types define operators which accept Slice objects to define ranges.</source>
          <target state="translated">Срезы по синтаксису похожи на типы поддиапазонов, но используются в другом контексте. Срез - это просто объект типа Slice, который содержит две границы, &lt;em&gt;a&lt;/em&gt; и &lt;em&gt;b&lt;/em&gt; . Сам по себе срез не очень полезен, но другие типы коллекций определяют операторы, которые принимают объекты среза для определения диапазонов.</target>
        </trans-unit>
        <trans-unit id="c3fee626664b2a86ccfce0881ad458405c843067" translate="yes" xml:space="preserve">
          <source>Slightly different version of &lt;code&gt;acceptAddr&lt;/code&gt;.</source>
          <target state="translated">Немного другая версия &lt;code&gt;acceptAddr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee7a8ef42831f93c54af4a6309b748729834ca0" translate="yes" xml:space="preserve">
          <source>SmallLshouldNotBeUsed</source>
          <target state="translated">SmallLshouldNotBeUsed</target>
        </trans-unit>
        <trans-unit id="75f4dd2393a33188b388008b159b576f9d6c37ce" translate="yes" xml:space="preserve">
          <source>So &quot;pure object oriented&quot; code is easy to write:</source>
          <target state="translated">Таким образом,&quot;чисто объектно-ориентированный&quot; код легко написать:</target>
        </trans-unit>
        <trans-unit id="1884ef29a0caad9d01db393c26a4dacb7998bb83" translate="yes" xml:space="preserve">
          <source>So in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.</source>
          <target state="translated">Поэтому во многих случаях обратный вызов не приводит к чрезмерной консервативности компилятора при анализе эффектов.</target>
        </trans-unit>
        <trans-unit id="d04b96e54f57571cb5f26f417c712886d005cc49" translate="yes" xml:space="preserve">
          <source>So it is not necessary to write &lt;code&gt;peg&quot; 'abc' &quot;&lt;/code&gt; in the above example.</source>
          <target state="translated">Таким образом, в приведенном выше примере нет необходимости писать &lt;code&gt;peg&quot; 'abc' &quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8675cecc3e20035fc6e573ebf270227f7c7eb995" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;G.c&lt;/code&gt; MUST contain both &lt;code&gt;P1&lt;/code&gt; and &lt;code&gt;P2&lt;/code&gt;, but we haven't even loaded &lt;code&gt;P1&lt;/code&gt; from the symbol file, nor do we want to because we then quickly would restore large parts of the whole program.</source>
          <target state="translated">Итак, теперь &lt;code&gt;G.c&lt;/code&gt; ДОЛЖЕН содержать и &lt;code&gt;P1&lt;/code&gt; , и &lt;code&gt;P2&lt;/code&gt; , но мы даже не загрузили &lt;code&gt;P1&lt;/code&gt; из файла символов и не хотим, потому что тогда мы быстро восстановим большие части всей программы.</target>
        </trans-unit>
        <trans-unit id="d2837e373a9e08b8e4ae0fadd7bcf34bea8bba71" translate="yes" xml:space="preserve">
          <source>So the string &lt;code&gt;b&lt;/code&gt; is of length 19, and two different ways of specifying the indices are</source>
          <target state="translated">Таким образом, строка &lt;code&gt;b&lt;/code&gt; имеет длину 19, и два разных способа указания индексов:</target>
        </trans-unit>
        <trans-unit id="e588b1291d20c18b6f2648d5846b37301ef51066" translate="yes" xml:space="preserve">
          <source>So what about &lt;code&gt;2 * a&lt;/code&gt;? We should tell the compiler &lt;code&gt;*&lt;/code&gt; is commutative. We cannot really do that however as the following code only swaps arguments blindly:</source>
          <target state="translated">Так что насчет &lt;code&gt;2 * a&lt;/code&gt; ? Мы должны сказать, что компилятор &lt;code&gt;*&lt;/code&gt; коммутативен. Однако мы не можем этого сделать, поскольку следующий код меняет только аргументы вслепую:</target>
        </trans-unit>
        <trans-unit id="b4e6066da4ec97671c84015a233816abeed1a8d1" translate="yes" xml:space="preserve">
          <source>So, now that we are done with the basics, let's see what Nim offers apart from a nice syntax for procedural programming: &lt;a href=&quot;tut2&quot;&gt;Part II&lt;/a&gt;</source>
          <target state="translated">Итак, теперь, когда мы закончили с основами, давайте посмотрим, что предлагает Nim помимо красивого синтаксиса для процедурного программирования: &lt;a href=&quot;tut2&quot;&gt;Часть II&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99f2336f838a801c19d553e0c88c363ba411da59" translate="yes" xml:space="preserve">
          <source>SockClosed</source>
          <target state="translated">SockClosed</target>
        </trans-unit>
        <trans-unit id="2e364384ea1af26a7ae5749a4ee47846386614a6" translate="yes" xml:space="preserve">
          <source>SockConnected</source>
          <target state="translated">SockConnected</target>
        </trans-unit>
        <trans-unit id="ecb1db9b50d2375a93db032e8269b906e3a2d434" translate="yes" xml:space="preserve">
          <source>SockConnecting</source>
          <target state="translated">SockConnecting</target>
        </trans-unit>
        <trans-unit id="f96262d38e15e56e293b395e3a4e585d00445d21" translate="yes" xml:space="preserve">
          <source>SockIdle</source>
          <target state="translated">SockIdle</target>
        </trans-unit>
        <trans-unit id="49173abf46e65756efd207d62345b6562084170d" translate="yes" xml:space="preserve">
          <source>SockListening</source>
          <target state="translated">SockListening</target>
        </trans-unit>
        <trans-unit id="540e5e4a700a40f5403f5305e76a47af819360b6" translate="yes" xml:space="preserve">
          <source>SockUDPBound</source>
          <target state="translated">SockUDPBound</target>
        </trans-unit>
        <trans-unit id="22beb4639862a7b9b676d1e4836131999f91ce5b" translate="yes" xml:space="preserve">
          <source>Socket has been closed.</source>
          <target state="translated">Розетка закрыта.</target>
        </trans-unit>
        <trans-unit id="879f6e69a5675653a92a791913da83a48c7fb678" translate="yes" xml:space="preserve">
          <source>Socket has only just been initialised, not connected or closed.</source>
          <target state="translated">Гнездо только что было инициализировано,не подключено и не закрыто.</target>
        </trans-unit>
        <trans-unit id="af4d7eba62345b81d526d2643d898eb239b5cdcf" translate="yes" xml:space="preserve">
          <source>Socket is a UDP socket which is listening for data.</source>
          <target state="translated">Сокет-это UDP-сокет,который прослушивает данные.</target>
        </trans-unit>
        <trans-unit id="54b2d18985d4b7f5023824f4fcfddd48ab27cdff" translate="yes" xml:space="preserve">
          <source>Socket is a server socket and is listening for connections.</source>
          <target state="translated">Сокет является сокет сервера и прослушивает соединения.</target>
        </trans-unit>
        <trans-unit id="b53ea21e56f48fba083f112fde7dee58dc547eb7" translate="yes" xml:space="preserve">
          <source>Socket is connected to a server.</source>
          <target state="translated">Сокет подключен к серверу.</target>
        </trans-unit>
        <trans-unit id="84e26ccd61f472edc6a5d97a690d05af186f5bed" translate="yes" xml:space="preserve">
          <source>Socket is in the process of connecting to a server.</source>
          <target state="translated">Сокет находится в процессе подключения к серверу.</target>
        </trans-unit>
        <trans-unit id="53b421c08a7dc0ab4bbd194fdc55f0c8077afbc0" translate="yes" xml:space="preserve">
          <source>Sockets which are &lt;strong&gt;not&lt;/strong&gt; ready for reading, writing or which don't have errors waiting on them are removed from the &lt;code&gt;readfds&lt;/code&gt;, &lt;code&gt;writefds&lt;/code&gt;, &lt;code&gt;exceptfds&lt;/code&gt; sequences respectively.</source>
          <target state="translated">Сокеты, которые &lt;strong&gt;не&lt;/strong&gt; готовы к чтению, записи или которые не имеют ожидающих ошибок, удаляются из последовательностей &lt;code&gt;readfds&lt;/code&gt; , &lt;code&gt;writefds&lt;/code&gt; , &lt;code&gt;exceptfds&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="441c0981544196354c221a53804d865bc53f74b3" translate="yes" xml:space="preserve">
          <source>Solution ~~~~~~~~</source>
          <target state="translated">Решение ~~~~~</target>
        </trans-unit>
        <trans-unit id="a18f034cd6a34c65d1fee4d43db529e754f206cf" translate="yes" xml:space="preserve">
          <source>Some builtins set an error flag. This is then turned into a proper exception. &lt;strong&gt;Note&lt;/strong&gt;: Ordinary application code should not call this.</source>
          <target state="translated">Некоторые встроенные команды устанавливают флаг ошибки. Затем это превращается в собственное исключение. &lt;strong&gt;Примечание&lt;/strong&gt; . Обычный код приложения не должен вызывать это.</target>
        </trans-unit>
        <trans-unit id="ab83d5be81d7366ced8b35ee80f8254106e6acd0" translate="yes" xml:space="preserve">
          <source>Some child may be missing. A missing child is a node of kind &lt;code&gt;nnkEmpty&lt;/code&gt;; a child can never be nil.</source>
          <target state="translated">Некоторые дети могут отсутствовать. Отсутствующий дочерний элемент - это узел вида &lt;code&gt;nnkEmpty&lt;/code&gt; ; ребенок никогда не может быть нулевым.</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">Несколько примеров:</target>
        </trans-unit>
        <trans-unit id="fe96e74863b969e67aadbcee97242dea95a7b5c7" translate="yes" xml:space="preserve">
          <source>Some file not essential for the compiler's working could not be opened.</source>
          <target state="translated">Некоторый файл,несущественный для работы компилятора,не мог быть открыт.</target>
        </trans-unit>
        <trans-unit id="a01546d483ad56932b56e6f4f843c335f7232622" translate="yes" xml:space="preserve">
          <source>Some keywords are unused; they are reserved for future developments of the language.</source>
          <target state="translated">Некоторые ключевые слова не используются,они зарезервированы для будущего развития языка.</target>
        </trans-unit>
        <trans-unit id="7cb6d242fa43323b661e091ed4496920bf211e2d" translate="yes" xml:space="preserve">
          <source>Some terminology: in the example &lt;code&gt;question&lt;/code&gt; is called a (formal) &lt;em&gt;parameter&lt;/em&gt;, &lt;code&gt;&quot;Should I...&quot;&lt;/code&gt; is called an &lt;em&gt;argument&lt;/em&gt; that is passed to this parameter.</source>
          <target state="translated">Немного терминологии: в примере &lt;code&gt;question&lt;/code&gt; называется (формальным) &lt;em&gt;параметром&lt;/em&gt; , &lt;code&gt;&quot;Should I...&quot;&lt;/code&gt; называется &lt;em&gt;аргументом,&lt;/em&gt; который передается этому параметру.</target>
        </trans-unit>
        <trans-unit id="6e93c59acfbd4ca81868fe83cdee12101d3d70c7" translate="yes" xml:space="preserve">
          <source>Some user defined warning.</source>
          <target state="translated">Определенное пользователем предупреждение.</target>
        </trans-unit>
        <trans-unit id="3e528bc25235f43baac24e5a82e6fba6ce5447ef" translate="yes" xml:space="preserve">
          <source>Sometimes a C++ class has a private copy constructor and so code like &lt;code&gt;Class c = Class(1,2);&lt;/code&gt; must not be generated but instead &lt;code&gt;Class c(1,2);&lt;/code&gt;. For this purpose the Nim proc that wraps a C++ constructor needs to be annotated with the &lt;span id=&quot;constructor_1&quot;&gt;constructor&lt;/span&gt; pragma. This pragma also helps to generate faster C++ code since construction then doesn't invoke the copy constructor:</source>
          <target state="translated">Иногда у класса C ++ есть частный конструктор копирования, и поэтому код вроде &lt;code&gt;Class c = Class(1,2);&lt;/code&gt; не должен генерироваться, а вместо этого должен быть &lt;code&gt;Class c(1,2);&lt;/code&gt; , Для этого процесс Nim, который является оболочкой для конструктора C ++, должен быть аннотирован прагмой &lt;span id=&quot;constructor_1&quot;&gt;конструктора&lt;/span&gt; . Эта прагма также помогает генерировать более быстрый код C ++, поскольку конструкция не вызывает конструктор копирования:</target>
        </trans-unit>
        <trans-unit id="e2bd3dc5145a046d8756e4c3b5e6319385dd6c64" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, &lt;code&gt;spawn&lt;/code&gt; is also used in the &lt;code&gt;parallel&lt;/code&gt; statement with slightly different semantics. &lt;code&gt;spawn&lt;/code&gt; always takes a call expression of the form &lt;code&gt;f(a, ...)&lt;/code&gt;. Let &lt;code&gt;T&lt;/code&gt; be &lt;code&gt;f&lt;/code&gt;'s return type. If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt; then &lt;code&gt;spawn&lt;/code&gt;'s return type is also &lt;code&gt;void&lt;/code&gt; otherwise it is &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="translated">Несколько сбивает с толку, что &lt;code&gt;spawn&lt;/code&gt; также используется в операторе &lt;code&gt;parallel&lt;/code&gt; с немного другой семантикой. &lt;code&gt;spawn&lt;/code&gt; всегда принимает выражение вызова в форме &lt;code&gt;f(a, ...)&lt;/code&gt; . Пусть &lt;code&gt;T&lt;/code&gt; будет типом возвращаемого значения &lt;code&gt;f&lt;/code&gt; . Если &lt;code&gt;T&lt;/code&gt; является &lt;code&gt;void&lt;/code&gt; , то &lt;code&gt;spawn&lt;/code&gt; &amp;laquo;ы типа возвращаемого также &lt;code&gt;void&lt;/code&gt; в противном случае это &lt;code&gt;FlowVar[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="e2de8e03eb7da80a014273d286391bd6a4e6c758" translate="yes" xml:space="preserve">
          <source>Source Code Filters</source>
          <target state="translated">Фильтры исходного кода</target>
        </trans-unit>
        <trans-unit id="3c6c119ba4476a2d13a835d7d4fcadc52e3ed050" translate="yes" xml:space="preserve">
          <source>Source code filters</source>
          <target state="translated">Фильтры исходного кода</target>
        </trans-unit>
        <trans-unit id="c53df7c2a21cf1297f0d2b03c1f92cdd4f7da3c4" translate="yes" xml:space="preserve">
          <source>Source highlighter for programming or markup languages. Currently only few languages are supported, other languages may be added. The interface supports one language nested in another.</source>
          <target state="translated">Источник подсветки для языков программирования или разметки.В настоящее время поддерживается только несколько языков,другие языки могут быть добавлены.Интерфейс поддерживает один язык,вложенный в другой.</target>
        </trans-unit>
        <trans-unit id="97ec2600b2e9e2b39f1b45d05ed5cf67fa2a6b53" translate="yes" xml:space="preserve">
          <source>Spacing also determines whether &lt;code&gt;(a, b)&lt;/code&gt; is parsed as an the argument list of a call or whether it is parsed as a tuple constructor:</source>
          <target state="translated">Интервал также определяет, анализируется ли &lt;code&gt;(a, b)&lt;/code&gt; как список аргументов вызова или он анализируется как конструктор кортежа:</target>
        </trans-unit>
        <trans-unit id="49958459a4b8e1eb5bdebb01446519ea2cfeeae3" translate="yes" xml:space="preserve">
          <source>Spacing and Whitespace Conventions</source>
          <target state="translated">Конвенции о межконтинентальном расстоянии и о защите белого пространства</target>
        </trans-unit>
        <trans-unit id="f85b49adfe2544a4256034716240a926337b5692" translate="yes" xml:space="preserve">
          <source>Spawn statement</source>
          <target state="translated">Заявление о рождении</target>
        </trans-unit>
        <trans-unit id="491354246b5eb961b32b192cc1c055827162214c" translate="yes" xml:space="preserve">
          <source>Special Operators</source>
          <target state="translated">Специальные операторы</target>
        </trans-unit>
        <trans-unit id="e552d4b23e8c0dfe309d5166ff7dd844ec3d8ffe" translate="yes" xml:space="preserve">
          <source>Special Types</source>
          <target state="translated">Специальные типы</target>
        </trans-unit>
        <trans-unit id="b23516a1efd1b704e237ef91f3620e190e02d0f3" translate="yes" xml:space="preserve">
          <source>Special built-in that takes a variable number of arguments. Each argument is converted to a string via &lt;code&gt;$&lt;/code&gt;, so it works for user-defined types that have an overloaded &lt;code&gt;$&lt;/code&gt; operator. It is roughly equivalent to &lt;code&gt;writeLine(stdout, x); flushFile(stdout)&lt;/code&gt;, but available for the JavaScript target too.</source>
          <target state="translated">Специальная встроенная функция, которая принимает переменное количество аргументов. Каждый аргумент преобразуется в строку с помощью &lt;code&gt;$&lt;/code&gt; , поэтому он работает с пользовательскими типами, которые имеют перегруженный оператор &lt;code&gt;$&lt;/code&gt; . Это примерно эквивалентно &lt;code&gt;writeLine(stdout, x); flushFile(stdout)&lt;/code&gt; , но также доступен для цели JavaScript.</target>
        </trans-unit>
        <trans-unit id="f05b76e5943515524507d846a60375ad51a71e57" translate="yes" xml:space="preserve">
          <source>Special care has to be taken if an untraced object contains traced objects like traced references, strings or sequences: in order to free everything properly, the built-in procedure &lt;code&gt;GCunref&lt;/code&gt; has to be called before freeing the untraced memory manually:</source>
          <target state="translated">Следует проявлять особую осторожность, если неотслеживаемый объект содержит отслеживаемые объекты, такие как отслеживаемые ссылки, строки или последовательности: для того, чтобы освободить все должным образом, перед освобождением неотслеживаемой памяти вручную должна быть вызвана встроенная процедура &lt;code&gt;GCunref&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a17ccd8347abd9eacd874ea7f27e074ed74467ae" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; can be compiled without any semantic error. This can be used to check whether a type supports some operation:</source>
          <target state="translated">Специальная процедура времени компиляции, которая проверяет, может ли &lt;em&gt;x&lt;/em&gt; быть скомпилирован без какой-либо семантической ошибки. Это можно использовать, чтобы проверить, поддерживает ли тип какую-либо операцию:</target>
        </trans-unit>
        <trans-unit id="a820fa7aa10cc8d5c0e8b3e7af391dbbe69898ef" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is declared in the current scope. &lt;em&gt;x&lt;/em&gt; has to be an identifier.</source>
          <target state="translated">Специальная процедура времени компиляции, которая проверяет, объявлен ли &lt;em&gt;x&lt;/em&gt; в текущей области. &lt;em&gt;x&lt;/em&gt; должен быть идентификатором.</target>
        </trans-unit>
        <trans-unit id="a4043ead367d4586fd4c1c0c21c211b7645a7f10" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is declared. &lt;em&gt;x&lt;/em&gt; has to be an identifier or a qualified identifier. This can be used to check whether a library provides a certain feature or not:</source>
          <target state="translated">Специальная процедура времени компиляции, которая проверяет, объявлен ли &lt;em&gt;x&lt;/em&gt; . &lt;em&gt;x&lt;/em&gt; должен быть идентификатором или квалифицированным идентификатором. Это можно использовать, чтобы проверить, предоставляет ли библиотека определенную функцию или нет:</target>
        </trans-unit>
        <trans-unit id="7c5d0a758aca8fbe6d34b755784c8711b34f72c9" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is defined. &lt;em&gt;x&lt;/em&gt; is an external symbol introduced through the compiler's &lt;a href=&quot;nimc#compile-time-symbols&quot;&gt;-d:x switch&lt;/a&gt; to enable build time conditionals:</source>
          <target state="translated">Специальная процедура времени компиляции, которая проверяет, определено ли &lt;em&gt;x&lt;/em&gt; . &lt;em&gt;x&lt;/em&gt; - это внешний символ, введенный с помощью &lt;a href=&quot;nimc#compile-time-symbols&quot;&gt;переключателя -d: x&lt;/a&gt; компилятора для включения условных обозначений времени сборки:</target>
        </trans-unit>
        <trans-unit id="9417dbf6690f564bf56645ff26108dd839309071" translate="yes" xml:space="preserve">
          <source>Special future that acts as a queue. Its API is still experimental and so is subject to change.</source>
          <target state="translated">Особое будущее,которое действует как очередь.Его API все еще является экспериментальным и поэтому может быть изменен.</target>
        </trans-unit>
        <trans-unit id="57782b746713c4b81ac3390082e47036bd29bd10" translate="yes" xml:space="preserve">
          <source>Special node kinds</source>
          <target state="translated">Специальные виды узлов</target>
        </trans-unit>
        <trans-unit id="202355e0f6c77c7ad33ab91f862395103c925576" translate="yes" xml:space="preserve">
          <source>Specifies an OS Error Code.</source>
          <target state="translated">Указание кода ошибки операционной системы.</target>
        </trans-unit>
        <trans-unit id="8fff1eb8c0263a617b1052dd18dc76abb01e14c4" translate="yes" xml:space="preserve">
          <source>Specifies the default calling convention for all procedures (and procedure types) that follow.</source>
          <target state="translated">Определяет соглашение по умолчанию о вызове для всех последующих процедур (и типов процедур).</target>
        </trans-unit>
        <trans-unit id="33f3e9bd75e7c34e8805079b75662d2523e05166" translate="yes" xml:space="preserve">
          <source>Specifies whether this attribute was specified in the original document</source>
          <target state="translated">Указывает,был ли этот атрибут указан в оригинальном документе.</target>
        </trans-unit>
        <trans-unit id="9340a269dc5c3688e5ddd09b6883c53291b53287" translate="yes" xml:space="preserve">
          <source>Specify the suite name delimited by &lt;code&gt;&quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">Укажите имя набора, разделенное &lt;code&gt;&quot;::&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba777a0b8be9b27a2fc0aebaa99a53bd014d0bab" translate="yes" xml:space="preserve">
          <source>Specify the test name as a command line argument.</source>
          <target state="translated">Укажите имя теста в качестве аргумента командной строки.</target>
        </trans-unit>
        <trans-unit id="9ce8d37027aa3f3951f0667dbca699e808c4574d" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;fromProc&lt;/code&gt;, which is a string specifying the name of the proc that this future belongs to, is a good habit as it helps with debugging.</source>
          <target state="translated">Указание &lt;code&gt;fromProc&lt;/code&gt; , которое представляет собой строку, определяющую имя процесса, которому принадлежит это будущее, является хорошей привычкой, поскольку помогает при отладке.</target>
        </trans-unit>
        <trans-unit id="b1caea9869ffec0e67a014cd78af1ef02ba40db6" translate="yes" xml:space="preserve">
          <source>Specifying the location of the query</source>
          <target state="translated">Указание местоположения запроса</target>
        </trans-unit>
        <trans-unit id="d3924b51dd7eaa83d08808569b1b0ce045cdc5be" translate="yes" xml:space="preserve">
          <source>Split a number into mantissa and exponent. &lt;em&gt;frexp&lt;/em&gt; calculates the mantissa m (a float greater than or equal to 0.5 and less than 1) and the integer value n such that &lt;em&gt;x&lt;/em&gt; (the original float value) equals m * 2**n. frexp stores n in &lt;em&gt;exponent&lt;/em&gt; and returns m.</source>
          <target state="translated">Разделите число на мантиссу и показатель степени. &lt;em&gt;frexp&lt;/em&gt; вычисляет мантиссу m (число с плавающей запятой больше или равно 0,5 и меньше 1) и целочисленное значение n, такое, что &lt;em&gt;x&lt;/em&gt; (исходное значение с плавающей запятой) равно m * 2 ** n. frexp сохраняет n в &lt;em&gt;экспоненте&lt;/em&gt; и возвращает m.</target>
        </trans-unit>
        <trans-unit id="0745140758afddfc4ee7cc02a1b14f4076dc0642" translate="yes" xml:space="preserve">
          <source>Split the string at the first or last occurrence of &lt;em&gt;sep&lt;/em&gt; into a 3-tuple</source>
          <target state="translated">Разделить строку при первом или последнем появлении &lt;em&gt;sep&lt;/em&gt; на 3-кортеж</target>
        </trans-unit>
        <trans-unit id="696d32e8d8bbfbcb085e88d7ad30d5090043c8af" translate="yes" xml:space="preserve">
          <source>Split the string at the last occurrence of &lt;em&gt;sep&lt;/em&gt; into a 3-tuple</source>
          <target state="translated">Разделить строку при последнем вхождении &lt;em&gt;sep&lt;/em&gt; в 3-кортеж</target>
        </trans-unit>
        <trans-unit id="9b30837131faaf707d014d0ca36f825f274439f5" translate="yes" xml:space="preserve">
          <source>Splits a &lt;span id=&quot;command-line_1&quot;&gt;command line&lt;/span&gt; into several components; This proc is only occasionally useful, better use the &lt;em&gt;parseopt&lt;/em&gt; module.</source>
          <target state="translated">Разделяет &lt;span id=&quot;command-line_1&quot;&gt;командную строку&lt;/span&gt; на несколько компонентов; Эта процедура полезна только изредка, лучше использовать модуль &lt;em&gt;parseopt&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f6fefaa7fc5767e6bf862c955b2209fdb94636" translate="yes" xml:space="preserve">
          <source>Splits a directory into (head, tail), so that &lt;code&gt;head / tail == path&lt;/code&gt; (except for edge cases like &quot;/usr&quot;).</source>
          <target state="translated">Разбивает каталог на (голова, хвост), так что &lt;code&gt;head / tail == path&lt;/code&gt; (кроме крайних случаев, таких как &amp;laquo;/ usr&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="d3a95cdd0557cc6b3279f5bbb847dfba5f79895c" translate="yes" xml:space="preserve">
          <source>Splits a filename into (dir, filename, extension). &lt;em&gt;dir&lt;/em&gt; does not end in &lt;em&gt;DirSep&lt;/em&gt;. &lt;em&gt;extension&lt;/em&gt; includes the leading dot.</source>
          <target state="translated">Разделяет имя файла на (каталог, имя файла, расширение). &lt;em&gt;dir&lt;/em&gt; не заканчивается на &lt;em&gt;DirSep&lt;/em&gt; . &lt;em&gt;расширение&lt;/em&gt; включает начальную точку.</target>
        </trans-unit>
        <trans-unit id="38adfc0e948e54bb128886ea5c9d463e755da1e5" translate="yes" xml:space="preserve">
          <source>Splits and distributes a sequence &lt;em&gt;s&lt;/em&gt; into &lt;em&gt;num&lt;/em&gt; sub sequences.</source>
          <target state="translated">Разделяет и распределяет последовательность &lt;em&gt;s&lt;/em&gt; на &lt;em&gt;num&lt;/em&gt; подпоследовательностей.</target>
        </trans-unit>
        <trans-unit id="a0c6e0e448f34874bff64437b7d2ab91fdf935d9" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; at whitespace stripping leading and trailing whitespace if necessary. If &lt;code&gt;maxsplit&lt;/code&gt; is specified and is positive, no more than &lt;code&gt;maxsplit&lt;/code&gt; splits is made.</source>
          <target state="translated">Разделяет строку &lt;code&gt;s&lt;/code&gt; по пробелам, при необходимости удаляя начальные и конечные пробелы. Если указано положительное значение &lt;code&gt;maxsplit&lt;/code&gt; , выполняется не более чем &lt;code&gt;maxsplit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a79255370060c2e50f8a5845d572dc8618abf3bc" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; into a seq of substrings.</source>
          <target state="translated">Разбивает строку &lt;code&gt;s&lt;/code&gt; на последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="cb7b44f53469c886c88f238f833dcf716ae5cf1d" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; into substrings.</source>
          <target state="translated">Разбивает строку &lt;code&gt;s&lt;/code&gt; на подстроки.</target>
        </trans-unit>
        <trans-unit id="7bee92474f34808ecc0e41e36df829980b2f1e85" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into its containing lines.</source>
          <target state="translated">Разбивает строку &lt;em&gt;s&lt;/em&gt; на содержащиеся в ней строки.</target>
        </trans-unit>
        <trans-unit id="5b2ee834c17d5b26b6e4fac9083478adf72ace42" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings from the right using a string separator. Works exactly the same as &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; except in reverse order.</source>
          <target state="translated">Разбивает строку &lt;em&gt;s&lt;/em&gt; на подстроки справа с помощью разделителя строк. Работает точно так же, как &lt;a href=&quot;#split.i,string,char,int&quot;&gt;итератор разделения,&lt;/a&gt; за исключением обратного порядка.</target>
        </trans-unit>
        <trans-unit id="087310e18b69609a2aa211f0f42cebd7c1cd07af" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings from the right using a string separator. Works exactly the same as &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt; except in reverse order.</source>
          <target state="translated">Разбивает строку &lt;em&gt;s&lt;/em&gt; на подстроки справа с помощью разделителя строк. Работает точно так же, как &lt;a href=&quot;#split.i,string,string,int&quot;&gt;итератор разделения,&lt;/a&gt; за исключением обратного порядка.</target>
        </trans-unit>
        <trans-unit id="cd60b97467de78d203515610e7c117f7aca90a40" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a group of separators.</source>
          <target state="translated">Разбивает строку &lt;em&gt;s&lt;/em&gt; на подстроки с помощью группы разделителей.</target>
        </trans-unit>
        <trans-unit id="006e1144089a0526e01f597553d1e7c5c932d6fd" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a single separator.</source>
          <target state="translated">Разбивает строку &lt;em&gt;s&lt;/em&gt; на подстроки с помощью одного разделителя.</target>
        </trans-unit>
        <trans-unit id="f52fdc09a9930420c66d61ce94065811386774f2" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a string separator.</source>
          <target state="translated">Разбивает строку &lt;em&gt;s&lt;/em&gt; на подстроки с помощью разделителя строк.</target>
        </trans-unit>
        <trans-unit id="bdcf8c0eeb58a21cdf0ea123c375dc7b74b4c1c3" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings.</source>
          <target state="translated">Разбивает строку &lt;em&gt;s&lt;/em&gt; на подстроки.</target>
        </trans-unit>
        <trans-unit id="7ba91be4e0a331af370fe3ce81d200f372c209c4" translate="yes" xml:space="preserve">
          <source>Square root for a complex number &lt;em&gt;z&lt;/em&gt;.</source>
          <target state="translated">Квадратный корень из комплексного числа &lt;em&gt;z&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c7d890a6474c971c057ab4ea575d83552a62c69b" translate="yes" xml:space="preserve">
          <source>StackTrace</source>
          <target state="translated">StackTrace</target>
        </trans-unit>
        <trans-unit id="5834da0d9d1f734eeb82b865257b78b65132ac61" translate="yes" xml:space="preserve">
          <source>StackTrace option</source>
          <target state="translated">Опция StackTrace</target>
        </trans-unit>
        <trans-unit id="97a27501491262c65d421114e5586483e201f5db" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;SomeFloat&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">Реализация стандартного формата для &lt;code&gt;SomeFloat&lt;/code&gt; . Не имеет смысла вызывать это напрямую, но это необходимо для макроса &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c9988eb477879aef4e84166efb847dbda62ecb3" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;SomeInteger&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">Реализация стандартного формата для &lt;code&gt;SomeInteger&lt;/code&gt; . Не имеет смысла вызывать это напрямую, но это необходимо для макроса &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82b4f534d5b70cca26d540da82df24c1661c25fa" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;string&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="translated">Реализация стандартного формата для &lt;code&gt;string&lt;/code&gt; . Не имеет смысла вызывать это напрямую, но это необходимо для макроса &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="286926a53b71c9700c85a0fe22c8494800f423ec" translate="yes" xml:space="preserve">
          <source>Standard format specifier for strings, integers and floats</source>
          <target state="translated">Стандартный спецификатор формата для строк,целых чисел и с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="e4536991ce4cfc6d6a8e33066d777f94420dea8c" translate="yes" xml:space="preserve">
          <source>Start types with a capital &lt;code&gt;T&lt;/code&gt;, unless they are pointers/references which start with &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">Начало типы с заглавной &lt;code&gt;T&lt;/code&gt; , если они не являются указателями / ссылки , которые начинаются с &lt;code&gt;P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59898b19b077c1855bd9ba49e69a1b8694d1ea8a" translate="yes" xml:space="preserve">
          <source>Start watching the file descriptor for read availability and then call the callback &lt;code&gt;cb&lt;/code&gt;.</source>
          <target state="translated">Начните следить за дескриптором файла на предмет доступности для чтения, а затем вызовите callback &lt;code&gt;cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c48d22286fde2df857b4c72495d932198256b33b" translate="yes" xml:space="preserve">
          <source>Start watching the file descriptor for write availability and then call the callback &lt;code&gt;cb&lt;/code&gt;.</source>
          <target state="translated">Начните следить за дескриптором файла на предмет доступности записи, а затем вызовите обратный вызов &lt;code&gt;cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e536d288d0851f6d9e8276875d7977f4844842b" translate="yes" xml:space="preserve">
          <source>Starting with c2nim version 0.9.8 it is also possible to directly embed Nim code in the C file. This is handy when you don't want to modify the generated Nim code at all. Nim code can be embedded directly via &lt;code&gt;#@ Nim code here @#&lt;/code&gt;:</source>
          <target state="translated">Начиная с c2nim версии 0.9.8, также можно напрямую встроить код Nim в файл C. Это удобно, если вы вообще не хотите изменять сгенерированный код Nim. Код Nim может быть встроен напрямую через &lt;code&gt;#@ Nim code here @#&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bde902e0e1c0a059e5fe83c9f5f9792a0e51c8a5" translate="yes" xml:space="preserve">
          <source>Starting with the simplest case, a &lt;code&gt;type&lt;/code&gt; section appears much like &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">Начиная с простейшего случая, раздел &lt;code&gt;type&lt;/code&gt; выглядит так же, как &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5750880c4922c991ffb618071f7738d4d0253363" translate="yes" xml:space="preserve">
          <source>Starting with version 0.13.0 of the language Nim supports multiline comments. They look like:</source>
          <target state="translated">Начиная с версии 0.13.0 языка Nim поддерживает многострочные комментарии.Они выглядят так:</target>
        </trans-unit>
        <trans-unit id="0bc24feae6a6568706e81e7f2d7d483485e4dca3" translate="yes" xml:space="preserve">
          <source>Starting with version 0.14 of the language, Nim supports &lt;code&gt;field&lt;/code&gt; as a shortcut for &lt;code&gt;self.field&lt;/code&gt; comparable to the &lt;span id=&quot;this_1&quot;&gt;this&lt;/span&gt; keyword in Java or C++. This feature has to be explicitly enabled via a &lt;code&gt;{.this: self.}&lt;/code&gt; statement pragma. This pragma is active for the rest of the module:</source>
          <target state="translated">Начиная с версии языка 0.14, Nim поддерживает &lt;code&gt;field&lt;/code&gt; как ярлык для &lt;code&gt;self.field&lt;/code&gt; , сравнимый с ключевым словом &lt;span id=&quot;this_1&quot;&gt;this&lt;/span&gt; в Java или C ++. Эта функция должна быть явно активирована с помощью &lt;code&gt;{.this: self.}&lt;/code&gt; оператора {.this: self.} . Эта прагма активна для остальной части модуля:</target>
        </trans-unit>
        <trans-unit id="fb2ad21d99439d76c4ae769b916f899ad8dad268" translate="yes" xml:space="preserve">
          <source>Starts a process. &lt;em&gt;Command&lt;/em&gt; is the executable file, &lt;em&gt;workingDir&lt;/em&gt; is the process's working directory. If &lt;code&gt;workingDir == &quot;&quot;&lt;/code&gt; the current directory is used. &lt;em&gt;args&lt;/em&gt; are the command line arguments that are passed to the process. On many operating systems, the first command line argument is the name of the executable. &lt;em&gt;args&lt;/em&gt; should not contain this argument! &lt;em&gt;env&lt;/em&gt; is the environment that will be passed to the process. If &lt;code&gt;env == nil&lt;/code&gt; the environment is inherited of the parent process. &lt;em&gt;options&lt;/em&gt; are additional flags that may be passed to &lt;em&gt;startProcess&lt;/em&gt;. See the documentation of &lt;code&gt;ProcessOption&lt;/code&gt; for the meaning of these flags. You need to &lt;em&gt;close&lt;/em&gt; the process when done.</source>
          <target state="translated">Запускает процесс. &lt;em&gt;Команда&lt;/em&gt; - это исполняемый файл, &lt;em&gt;WorkingDir&lt;/em&gt; - это рабочий каталог процесса. Если &lt;code&gt;workingDir == &quot;&quot;&lt;/code&gt; используется текущий каталог. &lt;em&gt;args&lt;/em&gt; - это аргументы командной строки, которые передаются процессу. Во многих операционных системах первым аргументом командной строки является имя исполняемого файла. &lt;em&gt;args&lt;/em&gt; не должен содержать этот аргумент! &lt;em&gt;env&lt;/em&gt; - это среда, которая будет передана процессу. Если &lt;code&gt;env == nil&lt;/code&gt; среда наследуется от родительского процесса. &lt;em&gt;Опции&lt;/em&gt; - это дополнительные флаги, которые могут быть переданы в &lt;em&gt;startProcess&lt;/em&gt; . См. Документацию &lt;code&gt;ProcessOption&lt;/code&gt; для значения этих флагов. Когда закончите, вам нужно &lt;em&gt;закрыть&lt;/em&gt; процесс.</target>
        </trans-unit>
        <trans-unit id="e1e47e87b9fe76e44fbbfad1b5c2f3cec6f694d4" translate="yes" xml:space="preserve">
          <source>Starts main coroutine scheduler loop which exits when all coroutines exit. Calling this proc starts execution of first coroutine.</source>
          <target state="translated">Запускает главный цикл планировщика коруселей,который завершается при выходе всех коруселей.При нажатии этой кнопки начинается выполнение первой коруэтки.</target>
        </trans-unit>
        <trans-unit id="e4b62e8fbf218158e05c575bcb526db8434456d7" translate="yes" xml:space="preserve">
          <source>Starts the process of listening for incoming HTTP connections on the specified address and port.</source>
          <target state="translated">Запускает процесс прослушивания входящих HTTP-соединений по указанному адресу и порту.</target>
        </trans-unit>
        <trans-unit id="95e9a635c9383520925e14042d4b923fd6c3ac7c" translate="yes" xml:space="preserve">
          <source>Startswith vs full match</source>
          <target state="translated">Начинается с полного матча</target>
        </trans-unit>
        <trans-unit id="2f3fd7595abb518c6624f116892060fa788f065b" translate="yes" xml:space="preserve">
          <source>State of the random number generator. The procs that use the default state are &lt;strong&gt;not&lt;/strong&gt; thread-safe!</source>
          <target state="translated">Состояние генератора случайных чисел. Процессы, использующие состояние по умолчанию, &lt;strong&gt;не&lt;/strong&gt; являются потокобезопасными!</target>
        </trans-unit>
        <trans-unit id="585af40bd2ea53a8fcbac51a9fdd078062535c3e" translate="yes" xml:space="preserve">
          <source>Statement Macros</source>
          <target state="translated">Ведотельные макросы</target>
        </trans-unit>
        <trans-unit id="c1d090a6c68c4210ac3bd5dfc03a161d8ee95112" translate="yes" xml:space="preserve">
          <source>Statement list</source>
          <target state="translated">Список выписок</target>
        </trans-unit>
        <trans-unit id="e9d413cd91133512c4e3171d0a7ea1f91f1b99be" translate="yes" xml:space="preserve">
          <source>Statement list expression</source>
          <target state="translated">Выражение списка утверждений</target>
        </trans-unit>
        <trans-unit id="561838a377363a51093422d3a816d894fc64a7aa" translate="yes" xml:space="preserve">
          <source>Statement macros are defined just as expression macros. However, they are invoked by an expression following a colon.</source>
          <target state="translated">Макросы выражений определяются так же,как и макросы выражений.Однако,они вызываются выражением,следующим за двоеточием.</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="5328a225bf88e0ed36c05ac4a8717682f2fb065b" translate="yes" xml:space="preserve">
          <source>Statements and expressions</source>
          <target state="translated">Выражения и выражения</target>
        </trans-unit>
        <trans-unit id="28b50d2ede0bbc0df4e2532f866848d6bf82cffb" translate="yes" xml:space="preserve">
          <source>Statements and indentation</source>
          <target state="translated">Заявления и отступы</target>
        </trans-unit>
        <trans-unit id="2f0b50bd8139f25d6003b6a910f512893ff24a3e" translate="yes" xml:space="preserve">
          <source>Statements are separated into &lt;span id=&quot;simple-statements_1&quot;&gt;simple statements&lt;/span&gt; and &lt;span id=&quot;complex-statements_1&quot;&gt;complex statements&lt;/span&gt;. Simple statements are statements that cannot contain other statements like assignments, calls or the &lt;code&gt;return&lt;/code&gt; statement; complex statements can contain other statements. To avoid the &lt;span id=&quot;dangling-else-problem_1&quot;&gt;dangling else problem&lt;/span&gt;, complex statements always have to be indented. The details can be found in the grammar.</source>
          <target state="translated">Заявления делятся на &lt;span id=&quot;simple-statements_1&quot;&gt;простые&lt;/span&gt; и &lt;span id=&quot;complex-statements_1&quot;&gt;сложные&lt;/span&gt; . Простые операторы - это операторы, которые не могут содержать другие операторы, такие как присваивания, вызовы или оператор &lt;code&gt;return&lt;/code&gt; ; сложные операторы могут содержать другие операторы. Чтобы избежать &lt;span id=&quot;dangling-else-problem_1&quot;&gt;проблемы&lt;/span&gt; с &lt;span id=&quot;dangling-else-problem_1&quot;&gt;зависанием else&lt;/span&gt; , сложные операторы всегда должны иметь отступ. Подробности можно найти в грамматике.</target>
        </trans-unit>
        <trans-unit id="73e132de8d234237b097eae09c8f41a5d3aeb437" translate="yes" xml:space="preserve">
          <source>Statements can also occur in an expression context that looks like &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt;. This is called an statement list expression or &lt;code&gt;(;)&lt;/code&gt;. The type of &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; is the type of &lt;code&gt;ex&lt;/code&gt;. All the other statements must be of type &lt;code&gt;void&lt;/code&gt;. (One can use &lt;code&gt;discard&lt;/code&gt; to produce a &lt;code&gt;void&lt;/code&gt; type.) &lt;code&gt;(;)&lt;/code&gt; does not introduce a new scope.</source>
          <target state="translated">Операторы также могут встречаться в контексте выражения, которое выглядит как &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; . Это называется выражением списка операторов или &lt;code&gt;(;)&lt;/code&gt; . Тип &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; - это тип &lt;code&gt;ex&lt;/code&gt; . Все остальные операторы должны иметь тип &lt;code&gt;void&lt;/code&gt; . (Можно использовать &lt;code&gt;discard&lt;/code&gt; для создания типа &lt;code&gt;void&lt;/code&gt; .) &lt;code&gt;(;)&lt;/code&gt; Не вводит новую область видимости.</target>
        </trans-unit>
        <trans-unit id="09ba2d803c92fca5d318023b8b22a1bf044aeec2" translate="yes" xml:space="preserve">
          <source>States that &lt;em&gt;every&lt;/em&gt; other parameter must not alias with the marked parameter.</source>
          <target state="translated">Указывает, что &lt;em&gt;любой&lt;/em&gt; другой параметр не должен иметь псевдонима с отмеченным параметром.</target>
        </trans-unit>
        <trans-unit id="b21c7be07ec4d071647590676d7c707716706eb2" translate="yes" xml:space="preserve">
          <source>States that the marked parameter needs to alias with &lt;em&gt;some&lt;/em&gt; other parameter.</source>
          <target state="translated">Государства, отмеченные потребности параметров для псевдонима с &lt;em&gt;каким - то&lt;/em&gt; другим параметром.</target>
        </trans-unit>
        <trans-unit id="bda29e5bb4f9a6e91109576feba5b699a9ffa7c4" translate="yes" xml:space="preserve">
          <source>Static params can also appear in the signatures of generic types:</source>
          <target state="translated">Статические параметры могут также появляться в сигнатурах родовых типов:</target>
        </trans-unit>
        <trans-unit id="fd4eea69c0fcf4c239e8f32cdb22fe3e56921d96" translate="yes" xml:space="preserve">
          <source>Static statement/expression</source>
          <target state="translated">Статическое высказывание/выражение</target>
        </trans-unit>
        <trans-unit id="1efa0116abdd20c68f5da9f1569291c9d6bcab18" translate="yes" xml:space="preserve">
          <source>Static types, like &lt;code&gt;static[int]&lt;/code&gt;, use &lt;code&gt;nnkIdent&lt;/code&gt; wrapped in &lt;code&gt;nnkStaticTy&lt;/code&gt;.</source>
          <target state="translated">Статические типы, такие как &lt;code&gt;static[int]&lt;/code&gt; , используют &lt;code&gt;nnkIdent&lt;/code&gt; , заключенный в &lt;code&gt;nnkStaticTy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df6826b4250b90fb4e378254d9554431e3e76513" translate="yes" xml:space="preserve">
          <source>Statically typed wrapper around a JavaScript object.</source>
          <target state="translated">Статически набранная обертка вокруг объекта JavaScript.</target>
        </trans-unit>
        <trans-unit id="f99da6af391d7d0b1782b934b78439cc36d3ec64" translate="yes" xml:space="preserve">
          <source>Statistical analysis framework for performing basic statistical analysis of data. The data is analysed in a single pass, when a data value is pushed to the &lt;code&gt;RunningStat&lt;/code&gt; or &lt;code&gt;RunningRegress&lt;/code&gt; objects</source>
          <target state="translated">Структура статистического анализа для выполнения базового статистического анализа данных. Данные анализируются за один проход, когда значение данных &lt;code&gt;RunningRegress&lt;/code&gt; объекты &lt;code&gt;RunningStat&lt;/code&gt; или RunningRegress.</target>
        </trans-unit>
        <trans-unit id="95c5b7897012d8f6b29894d9aacb62893a21c7dd" translate="yes" xml:space="preserve">
          <source>StdTmpl filter</source>
          <target state="translated">фильтр StdTmpl</target>
        </trans-unit>
        <trans-unit id="2d517ff3e91f20612466e4d677722b435331123f" translate="yes" xml:space="preserve">
          <source>Stop the process &lt;em&gt;p&lt;/em&gt;. On Posix OSes the procedure sends &lt;code&gt;SIGTERM&lt;/code&gt; to the process. On Windows the Win32 API function &lt;code&gt;TerminateProcess()&lt;/code&gt; is called to stop the process.</source>
          <target state="translated">Остановить процесс &lt;em&gt;p&lt;/em&gt; . В операционных системах Posix процедура отправляет &lt;code&gt;SIGTERM&lt;/code&gt; процессу. В Windows для остановки процесса вызывается функция Win32 API &lt;code&gt;TerminateProcess()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="193670292bbf8be6929e6f76418e0773142d3e9f" translate="yes" xml:space="preserve">
          <source>Stops coroutine execution and resumes no sooner than after &lt;code&gt;sleeptime&lt;/code&gt; seconds. Until then other coroutines are executed.</source>
          <target state="translated">Останавливает выполнение сопрограммы и возобновляет ее не раньше, чем через секунды &lt;code&gt;sleeptime&lt;/code&gt; . До тех пор выполняются другие сопрограммы.</target>
        </trans-unit>
        <trans-unit id="c692f32f2608c4a295dcfea18799b8cd9fd2f756" translate="yes" xml:space="preserve">
          <source>Stops the program immediately with an exit code.</source>
          <target state="translated">Немедленно останавливает программу с кодом выхода.</target>
        </trans-unit>
        <trans-unit id="6c7da5ae9d8453249af10e3df51f169922c5fe26" translate="yes" xml:space="preserve">
          <source>Store implementation-defined representation of the exception flags indicated by &lt;em&gt;excepts&lt;/em&gt; in the object pointed to by &lt;em&gt;flagp&lt;/em&gt;.</source>
          <target state="translated">Хранить определяемое реализацией представление флагов исключений, указанных &lt;em&gt;исключениями,&lt;/em&gt; в объекте, на который указывает &lt;em&gt;flagp&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bd07ac3fcadc296f8eadaaee32c2d2045b485375" translate="yes" xml:space="preserve">
          <source>Store the current floating-point environment in the object pointed to by &lt;em&gt;envp&lt;/em&gt;.</source>
          <target state="translated">Сохраните текущую среду с плавающей запятой в объекте, на который указывает &lt;em&gt;envp&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ed122e970e1da75eae7113f501ba6a2683599b66" translate="yes" xml:space="preserve">
          <source>Stores arbitrary data inside SSLContext. The unique &lt;em&gt;index&lt;/em&gt; should be retrieved using getSslContextExtraDataIndex.</source>
          <target state="translated">Хранит произвольные данные внутри SSLContext. Уникальный &lt;em&gt;индекс&lt;/em&gt; должен быть получен с помощью getSslContextExtraDataIndex.</target>
        </trans-unit>
        <trans-unit id="3561a6520c3d5d295122d365e075a71d866713db" translate="yes" xml:space="preserve">
          <source>Stores the empty string or the last headline/overline found in the rst document, so it can be used as a prettier name for term index generation.</source>
          <target state="translated">Хранит пустую строку или последний заголовок/перестроку,найденный в rst документе,поэтому его можно использовать как более красивое имя для термина &quot;генерация индекса&quot;.</target>
        </trans-unit>
        <trans-unit id="48c0d4450fba91caf6c704085748bb15b5343e9a" translate="yes" xml:space="preserve">
          <source>Stream interface that supports writing or reading. Note that these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.</source>
          <target state="translated">Потоковый интерфейс,поддерживающий запись или чтение.Обратите внимание,что эти поля здесь не должны использоваться напрямую.Они доступны для того,чтобы потоковая реализация могла их переопределить.</target>
        </trans-unit>
        <trans-unit id="51a31e0d2f2e0f77e70f94326ee6904303908d73" translate="yes" xml:space="preserve">
          <source>String &lt;span id=&quot;interpolation_1&quot;&gt;interpolation&lt;/span&gt; / &lt;span id=&quot;format_1&quot;&gt;format&lt;/span&gt; inspired by Python's &lt;code&gt;f&lt;/code&gt;-strings.</source>
          <target state="translated">Строковая &lt;span id=&quot;interpolation_1&quot;&gt;интерполяция&lt;/span&gt; / &lt;span id=&quot;format_1&quot;&gt;формат,&lt;/span&gt; вдохновленный &lt;code&gt;f&lt;/code&gt; - строками Python .</target>
        </trans-unit>
        <trans-unit id="dff366ef5455c79b8728295225889786b796cf17" translate="yes" xml:space="preserve">
          <source>String and character literals</source>
          <target state="translated">Строковые и буквенные символы</target>
        </trans-unit>
        <trans-unit id="8592962cea78137eedb95afe4474ceef0bee804c" translate="yes" xml:space="preserve">
          <source>String assignments are sometimes expensive in Nim: They are required to copy the whole string. However, the compiler is often smart enough to not copy strings. Due to the argument passing semantics, strings are never copied when passed to subroutines. The compiler does not copy strings that are a result from a procedure call, because the callee returns a new string anyway. Thus it is efficient to do:</source>
          <target state="translated">Задания на струны иногда дорого стоят в Ним:Они необходимы для копирования всей строки.Однако часто компилятор достаточно умен,чтобы не копировать строки.Из-за передаваемой семантики аргументов,строки никогда не копируются при передаче в подпрограммы.Компилятор не копирует строки,являющиеся результатом вызова процедуры,потому что callee все равно возвращает новую строку.Таким образом,это эффективно:</target>
        </trans-unit>
        <trans-unit id="f72b5d43e5245ea7b69b536ff3f8c988cbabcd7f" translate="yes" xml:space="preserve">
          <source>String handling</source>
          <target state="translated">Обработка струн</target>
        </trans-unit>
        <trans-unit id="5993cb336c6391ee8eea94b873bb797a1c4d4619" translate="yes" xml:space="preserve">
          <source>String literals</source>
          <target state="translated">Строковые буквы</target>
        </trans-unit>
        <trans-unit id="af12c2e063676108d00610ed5b2b199ea508a589" translate="yes" xml:space="preserve">
          <source>String literals are enclosed in double quotes. The &lt;code&gt;var&lt;/code&gt; statement declares a new variable named &lt;code&gt;name&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; with the value that is returned by the &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; procedure. Since the compiler knows that &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; returns a string, you can leave out the type in the declaration (this is called &lt;span id=&quot;local-type-inference_1&quot;&gt;local type inference&lt;/span&gt;). So this will work too:</source>
          <target state="translated">Строковые литералы заключаются в двойные кавычки. Оператор &lt;code&gt;var&lt;/code&gt; объявляет новую переменную с именем &lt;code&gt;name&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; со значением, возвращаемым процедурой &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; . Поскольку компилятор знает, что &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; возвращает строку, вы можете не указывать тип в объявлении (это называется &lt;span id=&quot;local-type-inference_1&quot;&gt;выводом локального типа&lt;/span&gt; ). Так что это тоже сработает:</target>
        </trans-unit>
        <trans-unit id="cbd76253c7810952b365eda2c20cec5a247a7e14" translate="yes" xml:space="preserve">
          <source>String literals are enclosed in double quotes; character literals in single quotes. Special characters are escaped with &lt;code&gt;\&lt;/code&gt;: &lt;code&gt;\n&lt;/code&gt; means newline, &lt;code&gt;\t&lt;/code&gt; means tabulator, etc. There are also &lt;em&gt;raw&lt;/em&gt; string literals:</source>
          <target state="translated">Строковые литералы заключаются в двойные кавычки; символьные литералы в одинарных кавычках. Специальные символы экранируются с помощью &lt;code&gt;\&lt;/code&gt; : &lt;code&gt;\n&lt;/code&gt; означает перевод строки, &lt;code&gt;\t&lt;/code&gt; означает табулятор и т. Д. Существуют также &lt;em&gt;необработанные&lt;/em&gt; строковые литералы:</target>
        </trans-unit>
        <trans-unit id="91beede65eb4bf81fa0a0b03f71ed1840d87fbad" translate="yes" xml:space="preserve">
          <source>String literals can also be delimited by three double quotes &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ... &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;. Literals in this form may run for several lines, may contain &lt;code&gt;&quot;&lt;/code&gt; and do not interpret any escape sequences. For convenience, when the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is followed by a newline (there may be whitespace between the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; and the newline), the newline (and the preceding whitespace) is not included in the string. The ending of the string literal is defined by the pattern &lt;code&gt;&quot;&quot;&quot;[^&quot;]&lt;/code&gt;, so this:</source>
          <target state="translated">Строковые литералы также могут быть разделены тремя двойными кавычками &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ... &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; . Литералы в этой форме могут выполняться для нескольких строк, могут содержать &lt;code&gt;&quot;&lt;/code&gt; и не интерпретировать никаких escape-последовательностей. Для удобства, когда за открывающим &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; следует новая строка (между открывающей &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; и новой строкой может быть пробел ) , новая строка (и предшествующий ей пробел) не включается в строку. Окончание строкового литерала определяется шаблоном &lt;code&gt;&quot;&quot;&quot;[^&quot;]&lt;/code&gt; , поэтому это:</target>
        </trans-unit>
        <trans-unit id="a98bf22b08be1e87b2f87e1e68dc04c240c4f84a" translate="yes" xml:space="preserve">
          <source>String literals can be delimited by matching double quotes, and can contain the following &lt;span id=&quot;escape-sequences_1&quot;&gt;escape sequences&lt;/span&gt;:</source>
          <target state="translated">Строковые литералы могут быть разделены двойными кавычками и могут содержать следующие &lt;span id=&quot;escape-sequences_1&quot;&gt;escape-последовательности&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="add4920af30df00399258f443c32b23c074019f6" translate="yes" xml:space="preserve">
          <source>String match ignoring case for back reference.</source>
          <target state="translated">Матч строки игнорируя случай для обратной ссылки.</target>
        </trans-unit>
        <trans-unit id="2a6aa06ff131f3961de8e3d1902b39032ccdc0a1" translate="yes" xml:space="preserve">
          <source>String match ignoring case.</source>
          <target state="translated">Матч на струне,игнорирующий дело.</target>
        </trans-unit>
        <trans-unit id="147076ac16a166598cdc8c313b99f065ab615a6a" translate="yes" xml:space="preserve">
          <source>String match ignoring style for back reference.</source>
          <target state="translated">Матч строк игнорируя стиль для обратной ссылки.</target>
        </trans-unit>
        <trans-unit id="bb24a4c20f47d52b01a258419055f6b3dfdee121" translate="yes" xml:space="preserve">
          <source>String match ignoring style.</source>
          <target state="translated">Матч по струнам игнорирует стиль.</target>
        </trans-unit>
        <trans-unit id="02ac6c5d15d3833eb25c8fee2851790ab39dbbb4" translate="yes" xml:space="preserve">
          <source>String type</source>
          <target state="translated">Тип строки</target>
        </trans-unit>
        <trans-unit id="986c54b2d8959694bd3a8d1059f1a28ae674bd61" translate="yes" xml:space="preserve">
          <source>String variables are &lt;strong&gt;mutable&lt;/strong&gt;, so appending to a string is possible, and quite efficient. Strings in Nim are both zero-terminated and have a length field. A string's length can be retrieved with the builtin &lt;code&gt;len&lt;/code&gt; procedure; the length never counts the terminating zero. Accessing the terminating zero is an error, it only exists so that a Nim string can be converted to a &lt;code&gt;cstring&lt;/code&gt; without doing a copy.</source>
          <target state="translated">Строковые переменные &lt;strong&gt;изменяемы&lt;/strong&gt; , поэтому добавление к строке возможно и довольно эффективно. Строки в Nim заканчиваются нулем и имеют поле длины. Длину строки можно получить с помощью встроенной процедуры &lt;code&gt;len&lt;/code&gt; ; длина никогда не учитывает завершающий ноль. Доступ к завершающему нулю является ошибкой, он существует только для того, чтобы строку Nim можно было преобразовать в &lt;code&gt;cstring&lt;/code&gt; без копирования.</target>
        </trans-unit>
        <trans-unit id="9582510d33852bda61d01257c5b36aff25c4246c" translate="yes" xml:space="preserve">
          <source>String: If the text ahead is the string &lt;em&gt;s&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">Строка: если впереди идет строка &lt;em&gt;s&lt;/em&gt; , используйте ее и укажите успех. В противном случае указать отказ.</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="3fef5979e2a970ce485675c739e2e35d04689a53" translate="yes" xml:space="preserve">
          <source>Strings and C strings</source>
          <target state="translated">Струны и С-струны</target>
        </trans-unit>
        <trans-unit id="1b710e9083a424ca250da057248ace9578ab56d8" translate="yes" xml:space="preserve">
          <source>Strings are compared by their lexicographical order. All comparison operators are available. Strings can be indexed like arrays (lower bound is 0). Unlike arrays, they can be used in case statements:</source>
          <target state="translated">Сравниваются строки по их лексикографическому порядку.Доступны все операторы сравнения.Строки могут быть проиндексированы как массивы (нижний предел равен 0).В отличие от массивов,они могут быть использованы в случае операторов:</target>
        </trans-unit>
        <trans-unit id="09c9bb4c72fe3ad8b1a94e6b29d07b028ab504ba" translate="yes" xml:space="preserve">
          <source>Strings are compared using their lexicographical order. All the comparison operators are supported. By convention, all strings are UTF-8 encoded, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;, not the i-th &lt;em&gt;unichar&lt;/em&gt;.</source>
          <target state="translated">Строки сравниваются в их лексикографическом порядке. Поддерживаются все операторы сравнения. По соглашению все строки имеют кодировку UTF-8, но это не обязательно. Например, при чтении строк из двоичных файлов они представляют собой просто последовательность байтов. Операции индекса &lt;code&gt;s[i]&lt;/code&gt; означает , г-го &lt;em&gt;полукокс&lt;/em&gt; из &lt;code&gt;s&lt;/code&gt; , а не я-я &lt;em&gt;unichar&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="68f5a8dcb38cb2dcf8c5a38294f5911b71dc18ba" translate="yes" xml:space="preserve">
          <source>Strings in Nim may contain any 8-bit value, even embedded zeros. However some operations may interpret the first binary zero as a terminator.</source>
          <target state="translated">Строки в Nim могут содержать любые 8-битные значения,даже встроенные нули.Однако некоторые операции могут интерпретировать первый двоичный ноль как терминатор.</target>
        </trans-unit>
        <trans-unit id="5b34aa10a7504c11b1c238076600885e8cb63777" translate="yes" xml:space="preserve">
          <source>Strip filter</source>
          <target state="translated">Полосовой фильтр</target>
        </trans-unit>
        <trans-unit id="98e0d86ad6cb0129df0228988af89dce21ec584d" translate="yes" xml:space="preserve">
          <source>Strips leading or trailing &lt;em&gt;chars&lt;/em&gt; from &lt;em&gt;s&lt;/em&gt; and returns the resulting string.</source>
          <target state="translated">Удаляет начальные или конечные &lt;em&gt;символы&lt;/em&gt; из &lt;em&gt;s&lt;/em&gt; и возвращает результирующую строку.</target>
        </trans-unit>
        <trans-unit id="c8ff4b4dfac3e5ecfb01fa66e040f2be24062608" translate="yes" xml:space="preserve">
          <source>Structured types</source>
          <target state="translated">Структурированные типы</target>
        </trans-unit>
        <trans-unit id="6617ba0382b36cb88686c64241a0d1066459e84e" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison.</source>
          <target state="translated">Стильное нечувствительное сравнение.</target>
        </trans-unit>
        <trans-unit id="47c3fbfee5ccaddc82435585c637b37f1eed421b" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">Сравнение нечувствительности к стилю. &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; могут быть идентификатором или символом.</target>
        </trans-unit>
        <trans-unit id="327f538ea37da49ccf2c271b65129745ac5559a5" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;a&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">Сравнение нечувствительности к стилю. &lt;code&gt;a&lt;/code&gt; может быть идентификатором или символом.</target>
        </trans-unit>
        <trans-unit id="a24820daa51bd1dce30c8565c1d952ac958b1e4f" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;b&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="translated">Сравнение нечувствительности к стилю. &lt;code&gt;b&lt;/code&gt; может быть идентификатором или символом.</target>
        </trans-unit>
        <trans-unit id="af3750102e983bbf33f619b8dae0de2a0f4b3c0c" translate="yes" xml:space="preserve">
          <source>Subrange of &lt;code&gt;TimeUnit&lt;/code&gt; that only includes units of fixed duration. These are the units that can be represented by a &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Поддиапазоне &lt;code&gt;TimeUnit&lt;/code&gt; , что только включает в себя единица фиксированной длительности. Это единицы, которые могут быть представлены &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3435d7cc8ec39979e476fdb02a131d9a1f16a5a" translate="yes" xml:space="preserve">
          <source>Subrange or subtype match: &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;range[T]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; matches &lt;code&gt;f&lt;/code&gt; exactly. Or: &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Соответствие поддиапазона или подтипа: &lt;code&gt;a&lt;/code&gt; - это &lt;code&gt;range[T]&lt;/code&gt; а &lt;code&gt;T&lt;/code&gt; точно соответствует &lt;code&gt;f&lt;/code&gt; . Или: &lt;code&gt;a&lt;/code&gt; - это подтип &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee14d0889156d81963bda220fbb8514a525f717" translate="yes" xml:space="preserve">
          <source>Subrange types</source>
          <target state="translated">Типы поддиапазонов</target>
        </trans-unit>
        <trans-unit id="041d20cfb351df25518b1fc63a1180aa4794aa06" translate="yes" xml:space="preserve">
          <source>Subranges</source>
          <target state="translated">Subranges</target>
        </trans-unit>
        <trans-unit id="b5f3755a0b5ea501c2ceef9602ab2b833039d687" translate="yes" xml:space="preserve">
          <source>Substitution Expressions (subex)</source>
          <target state="translated">Замена выражений (подсекс)</target>
        </trans-unit>
        <trans-unit id="10ae1fbab8828c5f045753afbdada38d4797d019" translate="yes" xml:space="preserve">
          <source>Substitution variables can also be words (that is &lt;code&gt;[A-Za-z_]+[A-Za-z0-9_]*&lt;/code&gt;) in which case the arguments in &lt;em&gt;a&lt;/em&gt; with even indices are keys and with odd indices are the corresponding values. An example:</source>
          <target state="translated">Переменные подстановки также могут быть словами (то есть &lt;code&gt;[A-Za-z_]+[A-Za-z0-9_]*&lt;/code&gt; ), и в этом случае аргументы в &lt;em&gt;a&lt;/em&gt; с четными индексами являются ключами, а с нечетными индексами - соответствующими значениями. Пример:</target>
        </trans-unit>
        <trans-unit id="834dbbb6edc63f93dd355df612f58e6f6c9305b3" translate="yes" xml:space="preserve">
          <source>Substrings are separated by a substring containing only &lt;em&gt;seps&lt;/em&gt;.</source>
          <target state="translated">Подстроки разделяются подстрокой, содержащей только &lt;em&gt;разделители&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2ec85e175386f10e5a8dc9ec3874b1df9dc2ae" translate="yes" xml:space="preserve">
          <source>Substrings are separated by a substring containing only &lt;em&gt;seps&lt;/em&gt;. Examples:</source>
          <target state="translated">Подстроки разделяются подстрокой, содержащей только &lt;em&gt;разделители&lt;/em&gt; . Примеры:</target>
        </trans-unit>
        <trans-unit id="9b3a380e1c6cb3aaa0328c36e53f0fcd3dd31ec2" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the PEG &lt;em&gt;sep&lt;/em&gt;. Examples:</source>
          <target state="translated">Подстроки отделяются друг от друга PEG &lt;em&gt;сен&lt;/em&gt; . Примеры:</target>
        </trans-unit>
        <trans-unit id="e91de9d53e26c3248ed96f64d99b705efaf9da39" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the character &lt;em&gt;sep&lt;/em&gt;. The code:</source>
          <target state="translated">Подстроки разделяются символом &lt;em&gt;sep&lt;/em&gt; . Код:</target>
        </trans-unit>
        <trans-unit id="5bff515ff93456666b03df7f012092cf65f567c4" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the regular expression &lt;code&gt;sep&lt;/code&gt; (and the portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned).</source>
          <target state="translated">Подстроки разделяются регулярным выражением &lt;code&gt;sep&lt;/code&gt; (и часть, соответствующая &lt;code&gt;sep&lt;/code&gt; , не возвращается).</target>
        </trans-unit>
        <trans-unit id="e8588d2a952b8b1b868045a8e60e1b1612fbdf6e" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the string &lt;em&gt;sep&lt;/em&gt;. The code:</source>
          <target state="translated">Подстроки разделяются строкой &lt;em&gt;sep&lt;/em&gt; . Код:</target>
        </trans-unit>
        <trans-unit id="969d144035ae8c1097f28295048d2e10839468b5" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the string &lt;em&gt;sep&lt;/em&gt;. This is a wrapper around the &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt;.</source>
          <target state="translated">Подстроки разделяются строкой &lt;em&gt;sep&lt;/em&gt; . Это оболочка вокруг &lt;a href=&quot;#split.i,string,string,int&quot;&gt;разделенного итератора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="518967ba497c08dc430a7afa2799aa4c61e41859" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the char &lt;em&gt;sep&lt;/em&gt;</source>
          <target state="translated">Подстроки отделяются справа символом &lt;em&gt;sep&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2cd528c9f9109219b97fe511dbbed0b9acbd1118" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the set of chars &lt;em&gt;seps&lt;/em&gt;</source>
          <target state="translated">Подстроки отделяются справа набором символов &lt;em&gt;seps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e2f8adf7c1cab6995d76bf2a7d0ca46134fd40b" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the string &lt;em&gt;sep&lt;/em&gt;</source>
          <target state="translated">Подстроки отделяются справа строкой &lt;em&gt;sep&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f96fd7e06b2e3440bae01cbcfe7490ed94381668" translate="yes" xml:space="preserve">
          <source>Subtract &lt;code&gt;interval&lt;/code&gt; from &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are subtracted in the order of their size, i.e first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="translated">Вычтите &lt;code&gt;interval&lt;/code&gt; из &lt;code&gt;dt&lt;/code&gt; . Компоненты из &lt;code&gt;interval&lt;/code&gt; вычитаются в порядке их размера, то есть сначала компонент &lt;code&gt;years&lt;/code&gt; , затем компонент &lt;code&gt;months&lt;/code&gt; и так далее. Возвращенный &lt;code&gt;DateTime&lt;/code&gt; будет иметь тот же часовой пояс, что и вход.</target>
        </trans-unit>
        <trans-unit id="76bc475fe96d51312be250027df1a17a17035b2c" translate="yes" xml:space="preserve">
          <source>Subtract &lt;em&gt;y&lt;/em&gt; from &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Вычтем &lt;em&gt;y&lt;/em&gt; из &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b1dcda865799d69866263f2964a5c388fd816f8c" translate="yes" xml:space="preserve">
          <source>Subtract &lt;em&gt;y&lt;/em&gt; from the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Вычтем &lt;em&gt;y&lt;/em&gt; из комплексного числа &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4f3fc03c45197f8110a3f544c2fd44b496e0b4" translate="yes" xml:space="preserve">
          <source>Subtract a duration from another.</source>
          <target state="translated">Вычитайте длительность из другой.</target>
        </trans-unit>
        <trans-unit id="0a0ad440585f43f54b766a259c1467e330bf63c8" translate="yes" xml:space="preserve">
          <source>Subtract int &lt;em&gt;y&lt;/em&gt; from rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Вычтем int &lt;em&gt;y&lt;/em&gt; из рационального &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5428a30fe88840d786a7f61b7d233914d258e100" translate="yes" xml:space="preserve">
          <source>Subtract rational &lt;em&gt;y&lt;/em&gt; from int &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Вычтем рациональное &lt;em&gt;y&lt;/em&gt; из int &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="41acafc64eeedf3eca00c862873071d48f536cc2" translate="yes" xml:space="preserve">
          <source>Subtract rational &lt;em&gt;y&lt;/em&gt; from rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Вычтем рациональное &lt;em&gt;y&lt;/em&gt; из рационального &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7bef7ee0413bb39584843be44a786acae479c9b7" translate="yes" xml:space="preserve">
          <source>Subtract two complex numbers.</source>
          <target state="translated">Вычитайте два комплексных числа.</target>
        </trans-unit>
        <trans-unit id="7189d91ec5033b9efd0a25062c31f9a16c88f644" translate="yes" xml:space="preserve">
          <source>Subtract two rational numbers.</source>
          <target state="translated">Вычитайте два рациональных числа.</target>
        </trans-unit>
        <trans-unit id="000947a7b3b6b45852df6f5a592408f7e55c3bb3" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;em&gt;interval&lt;/em&gt; from Time &lt;em&gt;time&lt;/em&gt;. If &lt;em&gt;interval&lt;/em&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="translated">Вычитает &lt;em&gt;интервальный&lt;/em&gt; от времени &lt;em&gt;времени&lt;/em&gt; . Если &lt;em&gt;интервал&lt;/em&gt; содержит какие-либо годы, месяцы, недели или дни, операция выполняется в местном часовом поясе.</target>
        </trans-unit>
        <trans-unit id="333dcd5ddf8f4d8066eab6ce4acb5ae7c09ae03c" translate="yes" xml:space="preserve">
          <source>Subtracts TimeInterval &lt;code&gt;ti1&lt;/code&gt; from &lt;code&gt;ti2&lt;/code&gt;.</source>
          <target state="translated">Вычитает &lt;code&gt;ti1&lt;/code&gt; времени ti1 из &lt;code&gt;ti2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6179323b99f6b40288e7176393e0e598ec9f2ba" translate="yes" xml:space="preserve">
          <source>Subtracts a duration of time from a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">Вычитает продолжительность времени из &lt;code&gt;Time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dcbc2b9a13a2d866e0df3c601f071ff376561ec" translate="yes" xml:space="preserve">
          <source>Subtracts complex &lt;em&gt;y&lt;/em&gt; from float &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Вычитает комплексный &lt;em&gt;y&lt;/em&gt; из числа с плавающей запятой &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4c88d3850624fa5509b42b7c6454e560083b18e5" translate="yes" xml:space="preserve">
          <source>Subtracts float &lt;em&gt;y&lt;/em&gt; from complex &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Вычитает float &lt;em&gt;y&lt;/em&gt; из комплексного &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f70590b4a99f5ea41cbbb277fc8ae20c97c2f508" translate="yes" xml:space="preserve">
          <source>Subtype relation</source>
          <target state="translated">Отношение подтипа</target>
        </trans-unit>
        <trans-unit id="0dfbf551cd1febe9be3271e47b0ace6915b7e99f" translate="yes" xml:space="preserve">
          <source>Success, SuccessX</source>
          <target state="translated">Успех,УспехХ</target>
        </trans-unit>
        <trans-unit id="d9aa2dd47e2183e4004b0890583ddab7b0dd3b84" translate="yes" xml:space="preserve">
          <source>Successful compilation of a library or a binary.</source>
          <target state="translated">Успешная компиляция библиотеки или двоичного файла.</target>
        </trans-unit>
        <trans-unit id="885db975a310a3bb649f91e5771f94988987874d" translate="yes" xml:space="preserve">
          <source>Suffix</source>
          <target state="translated">Suffix</target>
        </trans-unit>
        <trans-unit id="8e3e076ed673ec7f1a40d1724dfcc98398c4fee1" translate="yes" xml:space="preserve">
          <source>Sugar for contains</source>
          <target state="translated">Сахар для содержания</target>
        </trans-unit>
        <trans-unit id="2b0f1741006e1749638aebbba0c62519275602e6" translate="yes" xml:space="preserve">
          <source>Sugar for not containing</source>
          <target state="translated">Сахар за то,что не содержит</target>
        </trans-unit>
        <trans-unit id="861edba00547bc9ce7a08df78d4378766418179f" translate="yes" xml:space="preserve">
          <source>Suggestions</source>
          <target state="translated">Suggestions</target>
        </trans-unit>
        <trans-unit id="941d7d9ac0746aafb3a7018083b0465f921dce61" translate="yes" xml:space="preserve">
          <source>Supported OS primitives: &lt;code&gt;epoll&lt;/code&gt;, &lt;code&gt;kqueue&lt;/code&gt;, &lt;code&gt;poll&lt;/code&gt; and Windows &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">Поддерживаемые примитивы ОС: &lt;code&gt;epoll&lt;/code&gt; , &lt;code&gt;kqueue&lt;/code&gt; , &lt;code&gt;poll&lt;/code&gt; и &lt;code&gt;select&lt;/code&gt; Windows .</target>
        </trans-unit>
        <trans-unit id="a5f3ef8bd9a226a902e3da626f593d8f6bdd720e" translate="yes" xml:space="preserve">
          <source>Supported PEG grammar</source>
          <target state="translated">Поддерживаемая грамматика PEG</target>
        </trans-unit>
        <trans-unit id="9d80112951ed980c75468e1be3b86df0f222e090" translate="yes" xml:space="preserve">
          <source>Supported features: files, sockets, pipes, timers, processes, signals and user events.</source>
          <target state="translated">Поддерживаемые функции:файлы,сокеты,трубы,таймеры,процессы,сигналы и пользовательские события.</target>
        </trans-unit>
        <trans-unit id="922e354db556982aaec9d3960cdeb221956777ff" translate="yes" xml:space="preserve">
          <source>Supported syntax with default empty &lt;code&gt;shortNoVal&lt;/code&gt;/&lt;code&gt;longNoVal&lt;/code&gt;:</source>
          <target state="translated">Поддерживаемый синтаксис с пустым по умолчанию &lt;code&gt;shortNoVal&lt;/code&gt; / &lt;code&gt;longNoVal&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="52fecfba1182fabfdebf61ef0bd285c76b11a6aa" translate="yes" xml:space="preserve">
          <source>Suspends the execution of the current async procedure for the next &lt;code&gt;ms&lt;/code&gt; milliseconds.</source>
          <target state="translated">Приостанавливает выполнение текущей асинхронной процедуры на следующие миллисекунды &lt;code&gt;ms&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c77fcc8428eb1c29fb0edea391c5fde177f006" translate="yes" xml:space="preserve">
          <source>Suspends the process &lt;em&gt;p&lt;/em&gt;.</source>
          <target state="translated">Приостанавливает процесс &lt;em&gt;p&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ff172170c09b0a3f643ea6f3860725b0e3adcde6" translate="yes" xml:space="preserve">
          <source>Swaps the case of unicode characters in &lt;em&gt;s&lt;/em&gt;</source>
          <target state="translated">Меняет местами регистр символов Юникода в &lt;em&gt;s&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55b596882450b0f897f71f7b842053dfc1583f85" translate="yes" xml:space="preserve">
          <source>Swaps the positions of elements in a sequence randomly.</source>
          <target state="translated">Случайным образом меняет позиции элементов в последовательности.</target>
        </trans-unit>
        <trans-unit id="0ccabcb7feef7d8bfe041ead9426ae3125086c8c" translate="yes" xml:space="preserve">
          <source>Symbol binding in templates</source>
          <target state="translated">Привязка символов в шаблонах</target>
        </trans-unit>
        <trans-unit id="e15d9719893fff31a651b51709f3f17053857c18" translate="yes" xml:space="preserve">
          <source>Symbol lookup in generics</source>
          <target state="translated">Символический поиск в дженерике</target>
        </trans-unit>
        <trans-unit id="93722351d20a0af3b4b9e37b38817089ab39c090" translate="yes" xml:space="preserve">
          <source>Symbol lookup of the identifiers &lt;code&gt;items&lt;/code&gt;/&lt;code&gt;pairs&lt;/code&gt; is performed after the rewriting step, so that all overloads of &lt;code&gt;items&lt;/code&gt;/&lt;code&gt;pairs&lt;/code&gt; are taken into account.</source>
          <target state="translated">Поиск символов &lt;code&gt;items&lt;/code&gt; / &lt;code&gt;pairs&lt;/code&gt; идентификаторов выполняется после шага перезаписи, так что все перегрузки &lt;code&gt;items&lt;/code&gt; / &lt;code&gt;pairs&lt;/code&gt; учитываются.</target>
        </trans-unit>
        <trans-unit id="84e33e2c80c65f15d6048f2ca6f92d94cfd3e6de" translate="yes" xml:space="preserve">
          <source>Symbol usages</source>
          <target state="translated">Символическое использование</target>
        </trans-unit>
        <trans-unit id="15d2715339927ab1cacbd3a795da09326886df84" translate="yes" xml:space="preserve">
          <source>Symbolic link.</source>
          <target state="translated">Символическая связь.</target>
        </trans-unit>
        <trans-unit id="11ad0ab4dc32899beb01665dac0504b053480af8" translate="yes" xml:space="preserve">
          <source>Symbols declared in an &lt;em&gt;enter&lt;/em&gt; handler can be made visible in the corresponding &lt;em&gt;leave&lt;/em&gt; handler by annotating them with an &lt;em&gt;inject&lt;/em&gt; pragma.</source>
          <target state="translated">Символы, объявленные в обработчике &lt;em&gt;ввода,&lt;/em&gt; можно сделать видимыми в соответствующем обработчике &lt;em&gt;выхода&lt;/em&gt; , аннотируя их с помощью &lt;em&gt;прагмы&lt;/em&gt; inject.</target>
        </trans-unit>
        <trans-unit id="a4b7119bc873b1a47de2955098054673778589df" translate="yes" xml:space="preserve">
          <source>Synonym for existsDir</source>
          <target state="translated">Синоним существованияДир</target>
        </trans-unit>
        <trans-unit id="ba60d4cc263ff180c27a4a09e6b636cd98ac4e3b" translate="yes" xml:space="preserve">
          <source>Synonym for existsFile</source>
          <target state="translated">Синоним существованияФайл</target>
        </trans-unit>
        <trans-unit id="e8aa2bdcd24d6964731df6f38e8110132abbce66" translate="yes" xml:space="preserve">
          <source>Syntactically a &lt;em&gt;type conversion&lt;/em&gt; is like a procedure call, but a type name replaces the procedure name. A type conversion is always safe in the sense that a failure to convert a type to another results in an exception (if it cannot be determined statically).</source>
          <target state="translated">Синтаксически &lt;em&gt;преобразование типа&lt;/em&gt; похоже на вызов процедуры, но имя типа заменяет имя процедуры. Преобразование типа всегда безопасно в том смысле, что отказ преобразовать тип в другой приводит к исключению (если его нельзя определить статически).</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="9c59412440fcb6dd3270f66f446a4acc85d89be4" translate="yes" xml:space="preserve">
          <source>Syntax sugar for anonymous procedures.</source>
          <target state="translated">Сахар для анонимных процедур.</target>
        </trans-unit>
        <trans-unit id="a492d9c66fdcf105c885da59425dccb0b62e918e" translate="yes" xml:space="preserve">
          <source>Syntax sugar for procedure types.</source>
          <target state="translated">Сахар синтаксиса для видов процедур.</target>
        </trans-unit>
        <trans-unit id="2e2159d4e1bf250922bd0a832c5179a9837c51e5" translate="yes" xml:space="preserve">
          <source>T = enum</source>
          <target state="translated">Т=перечислить</target>
        </trans-unit>
        <trans-unit id="4434fd593bde3375839bc932883b120b979c7044" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="translated">ЭТО ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ ПРАВООБЛАДАТЕЛЯМИ И СОАВТОРАМИ &quot;КАК ЕСТЬ&quot;,И ЛЮБЫЕ ЯВНЫЕ ИЛИ ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ,ВКЛЮЧАЯ,НО НЕ ОГРАНИЧИВАЯСЬ,ПОДРАЗУМЕВАЕМЫМИ ГАРАНТИЯМИ ТОВАРНОГО СОСТОЯНИЯ И ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ,НЕ ПРИНИМАЮТСЯ.НИ ПРИ КАКИХ ОБСТОЯТЕЛЬСТВАХ ПРАВООБЛАДАТЕЛЬ И УЧАСТНИКИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ЗА ЛЮБЫЕ ПРЯМЫЕ,КОСВЕННЫЕ,СЛУЧАЙНЫЕ,СПЕЦИАЛЬНЫЕ,ТИПИЧНЫЕ ИЛИ КОСВЕННЫЕ УБЫТКИ (ВКЛЮЧАЯ,НО НЕ ОГРАНИЧИВАЯСЬ,ЗАКУПКОЙ ЗАМЕЩАЮЩИХ ТОВАРОВ ИЛИ УСЛУГ;ПОТЕРЮ ДАННЫХ ИЛИ ПРИБЫЛИ;ИЛИ ПЕРЕРЫВ В ПРОИЗВОДСТВЕ),НЕЗАВИСИМО ОТ ТОГО,БЫЛИ ЛИ ОНИ ВЫЗВАНЫ И ПО ЛЮБОЙ ТЕОРИИ ОТВЕТСТВЕННОСТИ,БУДЬ ТО ПО КОНТРАКТУ,СТРОГОЙ ОТВЕТСТВЕННОСТИ ИЛИ ПРАВОНАРУШЕНИЮ (ВКЛЮЧАЯ ХАЛАТНОСТЬ ИЛИ ИНОЕ),ВОЗНИКШЕМУ КАКИМ-ЛИБО ОБРАЗОМ В РЕЗУЛЬТАТЕ ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ,ДАЖЕ ЕСЛИ ОНИ БЫЛИ ПРЕДУПРЕЖДЕНЫ О ВОЗМОЖНОСТИ ТАКОГО УЩЕРБА.</target>
        </trans-unit>
        <trans-unit id="7cbcc89bc56ee06c7485bd88edf78b958d325e03" translate="yes" xml:space="preserve">
          <source>TODO: &lt;code&gt;/dev/poll&lt;/code&gt;, &lt;code&gt;event ports&lt;/code&gt; and filesystem events.</source>
          <target state="translated">TODO: &lt;code&gt;/dev/poll&lt;/code&gt; , &lt;code&gt;event ports&lt;/code&gt; событий и события файловой системы.</target>
        </trans-unit>
        <trans-unit id="cb0d62cece24d665ba7c89ca01c113d1046f4bc2" translate="yes" xml:space="preserve">
          <source>Table constructor</source>
          <target state="translated">Конструктор стола</target>
        </trans-unit>
        <trans-unit id="d9afbd5c6dd4be0b038affd18116707f9d6423e7" translate="yes" xml:space="preserve">
          <source>Tag tracking</source>
          <target state="translated">Отслеживание тегов</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">Режим пятна</target>
        </trans-unit>
        <trans-unit id="dfaa7a1f02c7c5f9df730df7121afa459170ff28" translate="yes" xml:space="preserve">
          <source>Take special care when declaring types as &lt;code&gt;proc&lt;/code&gt;. The behavior is similar to &lt;code&gt;Procedure declaration&lt;/code&gt;, below, but does not treat &lt;code&gt;nnkGenericParams&lt;/code&gt;. Generic parameters are treated in the type, not the &lt;code&gt;proc&lt;/code&gt; itself.</source>
          <target state="translated">Будьте особенно осторожны при объявлении типов как &lt;code&gt;proc&lt;/code&gt; . Поведение аналогично &lt;code&gt;nnkGenericParams&lt;/code&gt; &lt;code&gt;Procedure declaration&lt;/code&gt; ниже, но не обрабатывает nnkGenericParams . Общие параметры рассматриваются в типе, а не &lt;code&gt;proc&lt;/code&gt; сам.</target>
        </trans-unit>
        <trans-unit id="b25c3237baf7da022bd4ce5dd72ff7bbd7b4e0d2" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;typedesc&lt;/code&gt; as its first argument, and a series of expressions of type &lt;code&gt;key: value&lt;/code&gt;, and returns a value of the specified type with each field &lt;code&gt;key&lt;/code&gt; set to &lt;code&gt;value&lt;/code&gt;, as specified in the arguments of &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">Принимает &lt;code&gt;typedesc&lt;/code&gt; в качестве своего первого аргумента и серию выражений типа &lt;code&gt;key: value&lt;/code&gt; и возвращает значение указанного типа с каждым &lt;code&gt;key&lt;/code&gt; поля, установленным в &lt;code&gt;value&lt;/code&gt; , как указано в аргументах &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5694602502f6f1e320a5499e60e3f6eb2a597ab1" translate="yes" xml:space="preserve">
          <source>Takes a float which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">Берет поплавок,который содержит количество секунд с эпохи уникс и возвращает объект времени.</target>
        </trans-unit>
        <trans-unit id="aae55bc35eb360650aead66c4fe99a44fac76e39" translate="yes" xml:space="preserve">
          <source>Takes an int which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">Берет int,который содержит количество секунд,прошедших с эпохи unix,и возвращает объект времени.</target>
        </trans-unit>
        <trans-unit id="4bad4e5a1f77a3fa2ad87fcd6030a2fbe78305df" translate="yes" xml:space="preserve">
          <source>Takes an integer and outputs as many &quot;hello world!&quot;s</source>
          <target state="translated">Берет целое число и выводит столько же &quot;hello world!&quot; s</target>
        </trans-unit>
        <trans-unit id="aca4638357a681dba4149f01bff4b890bc77cb16" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence.</source>
          <target state="translated">Берет несколько элементов последовательности и возвращает их в новой последовательности.</target>
        </trans-unit>
        <trans-unit id="54bd658583d742b0230f0f3e91860906626fd48f" translate="yes" xml:space="preserve">
          <source>Takes the name of a procedure and wraps it into a lambda missing the first argument, which passes the JavaScript builtin &lt;code&gt;this&lt;/code&gt; as the first argument to the procedure. Returns the resulting lambda.</source>
          <target state="translated">Принимает имя процедуры и превращает его в лямбду без первого аргумента, которая передает встроенный в &lt;code&gt;this&lt;/code&gt; JavaScript в качестве первого аргумента процедуры. Возвращает полученную лямбду.</target>
        </trans-unit>
        <trans-unit id="7fbcef4f12fbf3e15c5cc83ae7b0ad02579d3228" translate="yes" xml:space="preserve">
          <source>Template declaration</source>
          <target state="translated">Шаблонная декларация</target>
        </trans-unit>
        <trans-unit id="9d6df49bcce99024a2e48ebc7e962779552b3e40" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from left to right, returning the accumulation.</source>
          <target state="translated">Шаблон для складывания последовательности слева направо,возвращая накопление.</target>
        </trans-unit>
        <trans-unit id="de22212f29283d60e7209a9a47f7c24e8243be55" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from right to left, returning the accumulation.</source>
          <target state="translated">Шаблон для складывания последовательности справа налево,возвращая накопление.</target>
        </trans-unit>
        <trans-unit id="fbe50b6e0ad8f81f8d1ff40ace889c5bf58be0d6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; compile-time switch.</source>
          <target state="translated">Шаблон, который расширяется до stdout или stderr в зависимости от &lt;em&gt;переключателя времени&lt;/em&gt; компиляции &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f24083e3c7410b73370a6d3df27c2a49cb0ea1cc" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt;. Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="translated">Шаблоны (а также макросы, как мы увидим) имеют немного расширенный AST по сравнению с процедурами и итераторами. Причина в [макросе перезаписи терминов] ( &lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt; . Обратите внимание на &lt;code&gt;nnkEmpty()&lt;/code&gt; как на второй аргумент для &lt;code&gt;nnkProcDef&lt;/code&gt; и &lt;code&gt;nnkIteratorDef&lt;/code&gt; выше? Вот где идут макросы перезаписи терминов.</target>
        </trans-unit>
        <trans-unit id="dcfcea00b9c87e288d0369354ff63f75a960b95b" translate="yes" xml:space="preserve">
          <source>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</source>
          <target state="translated">Шаблоны-это простой механизм подстановки,который работает на абстрактных синтаксических деревьях Nim.Шаблоны обрабатываются в семантическом проходе компилятора.Они хорошо интегрируются с остальной частью языка и не имеют недостатков препроцессорных макросов Си.</target>
        </trans-unit>
        <trans-unit id="96f5a0e5d16500060d1f7d5115cee45e47157761" translate="yes" xml:space="preserve">
          <source>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</source>
          <target state="translated">Шаблоны особенно полезны для ленивых оценок.Рассмотрим простой промежуток времени для протоколирования:</target>
        </trans-unit>
        <trans-unit id="a4ab366bab0be60e3998095c84a25a6598269dc1" translate="yes" xml:space="preserve">
          <source>Temporary storage for &lt;code&gt;readLine&lt;/code&gt;</source>
          <target state="translated">Временное хранилище для &lt;code&gt;readLine&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8ead6a06ca5a06f3fd3f26aa97c8aa66bfd565e" translate="yes" xml:space="preserve">
          <source>Term rewriting macros</source>
          <target state="translated">Макросы переписывания термина</target>
        </trans-unit>
        <trans-unit id="a6680ab0f20ce389b5124d56dd72b741a29ed36a" translate="yes" xml:space="preserve">
          <source>Term rewriting macros are macros or templates that have not only a &lt;em&gt;name&lt;/em&gt; but also a &lt;em&gt;pattern&lt;/em&gt; that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</source>
          <target state="translated">Макросы перезаписи терминов - это макросы или шаблоны, которые имеют не только &lt;em&gt;имя,&lt;/em&gt; но и &lt;em&gt;шаблон,&lt;/em&gt; который ищется после фазы семантической проверки компилятора: это означает, что они предоставляют простой способ улучшить конвейер компиляции с помощью определенных пользователем оптимизаций:</target>
        </trans-unit>
        <trans-unit id="41291f4ae4297ee61df6a797422526ba9e83df38" translate="yes" xml:space="preserve">
          <source>Terminal symbol</source>
          <target state="translated">Символ терминала</target>
        </trans-unit>
        <trans-unit id="bef52f1c5083f29909e547fdf32cc8985b604537" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;RSTR_LIT&lt;/code&gt;.</source>
          <target state="translated">Терминальный символ в грамматике: &lt;code&gt;RSTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a8a9bac49fc0459e1510c675469f02c63be7ca" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;STR_LIT&lt;/code&gt;.</source>
          <target state="translated">Терминальный символ в грамматике: &lt;code&gt;STR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d576d491af5f274a42068737f7ccbdab6163370" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">Терминальный символ в грамматике: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e69f5068cdc01aad4375523276cb15e9d4ebbbc8" translate="yes" xml:space="preserve">
          <source>Terminal symbols in the grammar: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt;, &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">Терминальные символы в грамматике: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt; , &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="785f87cb41855c7bc99d2fd2726f808d1af1b5e6" translate="yes" xml:space="preserve">
          <source>Terminates the async http server instance.</source>
          <target state="translated">Прекращает работу асинхронного http-сервера.</target>
        </trans-unit>
        <trans-unit id="751a90a6435d21431d11cc9e3b0833f5ca5eb590" translate="yes" xml:space="preserve">
          <source>Terminates the connection to the server.</source>
          <target state="translated">Прекращает соединение с сервером.</target>
        </trans-unit>
        <trans-unit id="e3597aaf6cdfbeaf6431029759d5522ddcee7a42" translate="yes" xml:space="preserve">
          <source>Test case file format</source>
          <target state="translated">Формат файла тестового случая</target>
        </trans-unit>
        <trans-unit id="b33a4cfd962fe2b39c56b4ecde938402268b2e10" translate="yes" xml:space="preserve">
          <source>Test for a block special file.</source>
          <target state="translated">Тест на специальный файл блока.</target>
        </trans-unit>
        <trans-unit id="a9f69337598e21f93cab2ebd657596ec3df3e129" translate="yes" xml:space="preserve">
          <source>Test for a character special file.</source>
          <target state="translated">Тест на наличие специального файла для символов.</target>
        </trans-unit>
        <trans-unit id="952a8cbcb1fcde688a18a823ebbda401d701fbcd" translate="yes" xml:space="preserve">
          <source>Test for a directory.</source>
          <target state="translated">Тест на наличие каталога.</target>
        </trans-unit>
        <trans-unit id="1d54cb1533572699c4c3111108695b83f5f3b3b8" translate="yes" xml:space="preserve">
          <source>Test for a message queue.</source>
          <target state="translated">Тест на очереди сообщений.</target>
        </trans-unit>
        <trans-unit id="f90ba2506c9fa49f566e376d10a4bb5d7ba584a7" translate="yes" xml:space="preserve">
          <source>Test for a pipe or FIFO special file.</source>
          <target state="translated">Тест на трубу или специальный файл FIFO.</target>
        </trans-unit>
        <trans-unit id="f13d7458dcb8f1aa6f0b325ab968c053f51907a9" translate="yes" xml:space="preserve">
          <source>Test for a regular file.</source>
          <target state="translated">Тест на обычный файл.</target>
        </trans-unit>
        <trans-unit id="2ac777a23cc611262a8452a43aeb1f412c46ac83" translate="yes" xml:space="preserve">
          <source>Test for a semaphore.</source>
          <target state="translated">Тест на семафор.</target>
        </trans-unit>
        <trans-unit id="63a613e82f42e3dfcb1758affe0e08e5bab7c6eb" translate="yes" xml:space="preserve">
          <source>Test for a shared memory object.</source>
          <target state="translated">Тест на объект общей памяти.</target>
        </trans-unit>
        <trans-unit id="c255ce2ca23650ca45172eee903a6b011becc55e" translate="yes" xml:space="preserve">
          <source>Test for a socket.</source>
          <target state="translated">Тест на розетку.</target>
        </trans-unit>
        <trans-unit id="e7ff66eaf314a4eceeaf9ad8b6c2a819916574da" translate="yes" xml:space="preserve">
          <source>Test for a symbolic link.</source>
          <target state="translated">Тест на символическую ссылку.</target>
        </trans-unit>
        <trans-unit id="765e5922fa70d1f573a8d979885d6d361bb38400" translate="yes" xml:space="preserve">
          <source>Test if &lt;em&gt;body&lt;/em&gt; raises an exception found in the passed &lt;em&gt;exceptions&lt;/em&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="translated">Проверьте, вызывает ли &lt;em&gt;тело&lt;/em&gt; исключение из переданных &lt;em&gt;исключений&lt;/em&gt; . Тест считается пройденным, если возникшее исключение является частью допустимых исключений. В противном случае это не удается. Пример:</target>
        </trans-unit>
        <trans-unit id="adc4fd08a5eb9c1e704b8fb9dedc41a222765399" translate="yes" xml:space="preserve">
          <source>Test macro for a typed memory object.</source>
          <target state="translated">Тестовый макрос для типизированного объекта памяти.</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">Тестовый набор</target>
        </trans-unit>
        <trans-unit id="450392a2e8adbf4bec17df3a66d6c7ef132d0fc1" translate="yes" xml:space="preserve">
          <source>Tested on these OSes: Linux, Windows, OSX</source>
          <target state="translated">Протестировано на этих операционных системах:Linux,Windows,OSX</target>
        </trans-unit>
        <trans-unit id="dbb71175e7ed02ff6aee92d2ec95782f4f92c6f4" translate="yes" xml:space="preserve">
          <source>Tests can be nested, however failure of a nested test will not mark the parent test as failed. Setup and teardown are inherited. Setup can be overridden locally.</source>
          <target state="translated">Тесты могут быть вложенными,однако неудача вложенного теста не помечает родительский тест как неудавшийся.Установки и подсчеты наследуются.Установка может быть переопределена локально.</target>
        </trans-unit>
        <trans-unit id="47e7d34d76d0c77b4690ea7930812dcf7ab8551a" translate="yes" xml:space="preserve">
          <source>Tests matching &lt;strong&gt;any&lt;/strong&gt; of the arguments are executed.</source>
          <target state="translated">Выполняются тесты, соответствующие &lt;strong&gt;любому&lt;/strong&gt; из аргументов.</target>
        </trans-unit>
        <trans-unit id="6aab81bfaf53615e8f766c7726f5ae51db83d879" translate="yes" xml:space="preserve">
          <source>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node.</source>
          <target state="translated">Тестирует,реализует ли реализация DOM специфическую функцию,и поддерживается ли эта функция этим узлом.</target>
        </trans-unit>
        <trans-unit id="613d55da24ea8bd5c97f0f07cd2c9af975d55abd" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficical if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="translated">Тесты с GCC на Amd64 показали,что действительно полезно,если указатель 'environment' передается как последний аргумент,а не как первый.</target>
        </trans-unit>
        <trans-unit id="8fd9cd67f9ffbc2e8869c9ea4ebafbfe80184633" translate="yes" xml:space="preserve">
          <source>Thanks to its conditional construct &lt;code&gt;$[0|1|2|else]&lt;/code&gt; it supports &lt;span id=&quot;internationalization_1&quot;&gt;internationalization&lt;/span&gt; of format string literals quite well.</source>
          <target state="translated">Благодаря условной конструкции &lt;code&gt;$[0|1|2|else]&lt;/code&gt; он достаточно хорошо поддерживает &lt;span id=&quot;internationalization_1&quot;&gt;интернационализацию&lt;/span&gt; строковых литералов формата.</target>
        </trans-unit>
        <trans-unit id="12b773bb24713516f53e274a95d42c996bab5cb9" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="translated">Это означает,что только первые буквы сравниваются с учетом регистра.Остальные буквы сравниваются нечувствительно к регистру в диапазоне ASCII,а знаки подчеркивания игнорируются.</target>
        </trans-unit>
        <trans-unit id="15669c375b35911d24b624c36d00f40792243390" translate="yes" xml:space="preserve">
          <source>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</source>
          <target state="translated">Это означает преобразовать его в нижний регистр и удалить любое '_'.Это НЕ следует использовать для нормализации имен идентификаторов Nim.</target>
        </trans-unit>
        <trans-unit id="2158ac17be0eaafff993defade193f729c2e722f" translate="yes" xml:space="preserve">
          <source>The &quot;``&quot; notation can also be used to call an operator just like any other procedure:</source>
          <target state="translated">Нотация &quot;``&quot; также может быть использована для вызова оператора,как и любая другая процедура:</target>
        </trans-unit>
        <trans-unit id="07ebfc1a638cb27eb2a7bdc1bbdba99b104e75e6" translate="yes" xml:space="preserve">
          <source>The &quot;hello world&quot; program contains several identifiers that are already known to the compiler: &lt;code&gt;echo&lt;/code&gt;, &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;, etc. These built-ins are declared in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module which is implicitly imported by any other module.</source>
          <target state="translated">Программа &quot;hello world&quot; содержит несколько идентификаторов, которые уже известны компилятору: &lt;code&gt;echo&lt;/code&gt; , &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; и т. Д. Эти встроенные функции объявлены в &lt;a href=&quot;system&quot;&gt;системном&lt;/a&gt; модуле, который неявно импортируется любым другим модулем.</target>
        </trans-unit>
        <trans-unit id="4660111e8f03f55e19e040ae55e537bca96088fa" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="translated">&amp;laquo;Типы&amp;raquo; шаблоны могут быть символы &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; или &lt;code&gt;type&lt;/code&gt; . Это &amp;laquo;метатипы&amp;raquo;, их можно использовать только в определенных контекстах. Могут использоваться и обычные типы; это означает, что ожидаются &lt;code&gt;typed&lt;/code&gt; выражения.</target>
        </trans-unit>
        <trans-unit id="f29301d597d1872c3e865f162650568b25afe624" translate="yes" xml:space="preserve">
          <source>The 'precision' is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.</source>
          <target state="translated">Точность&quot;-это десятичное число,указывающее,сколько цифр должно отображаться после запятой при преобразовании с плавающей точкой.Для нецифровых типов в поле указывается максимальный размер поля-другими словами,сколько символов будет использовано из содержимого поля.При целочисленном преобразовании точность игнорируется.</target>
        </trans-unit>
        <trans-unit id="77bffde3bb99cdc6cc73c28c1d75251c36736508" translate="yes" xml:space="preserve">
          <source>The 'return' statement should ideally be used when its control-flow properties are required. Use a procedure's implicit 'result' variable whenever possible. This improves readability.</source>
          <target state="translated">Оператор 'return' в идеале должен использоваться,когда требуются его свойства потока управления.По возможности используйте неявную переменную 'result' процедуры.Это улучшает читабельность.</target>
        </trans-unit>
        <trans-unit id="2fffbfa23769923249ad2d3fd0e589b66b9c9408" translate="yes" xml:space="preserve">
          <source>The 'sign' option is only valid for numeric types, and can be one of the following:</source>
          <target state="translated">Опция 'Знак' действительна только для числовых типов и может быть одной из следующих:</target>
        </trans-unit>
        <trans-unit id="fa7a7006450028d34fa532dc709a868bd4924dee" translate="yes" xml:space="preserve">
          <source>The (integer) value of the radix used to represent any floating point type on the architecture used to build the program.</source>
          <target state="translated">(целое)значение радиуса,используемого для представления любого типа с плавающей точкой на архитектуре,используемой для сборки программы.</target>
        </trans-unit>
        <trans-unit id="3ab168c9fb07b629d33d94adcd06a5a7b86f04e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#nimble&quot;&gt;bottom&lt;/a&gt; of this page includes a list of 3rd party packages created by the Nim community. These packages are a useful addition to the modules in the standard library.</source>
          <target state="translated">&lt;a href=&quot;#nimble&quot;&gt;Дно&lt;/a&gt; этой страницы включает в себя список 3 - сторонних пакетов , созданных сообществом Nim. Эти пакеты являются полезным дополнением к модулям стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="2a9b60df59f882b166b262beab63215a98833664" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="translated">В &lt;a href=&quot;nimc&quot;&gt;руководстве пользователя компилятора Nim &lt;/a&gt; &lt;code&gt;.nim&lt;/code&gt; типичный вызов компилятора с использованием команды &lt;code&gt;compile&lt;/code&gt; или &lt;code&gt;c&lt;/code&gt; для преобразования файла .nim в один или несколько файлов &lt;code&gt;.c&lt;/code&gt; , которые затем компилируются с помощью компилятора C платформы в статический двоичный файл. Однако есть и другие команды для компиляции в C ++, Objective-C или JavaScript. В этом документе делается попытка сосредоточить в одном месте все параметры серверной части и интерфейса.</target>
        </trans-unit>
        <trans-unit id="14d9a77578450b8a08312f7178544f27b410a5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;nimc#compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;nimc#dynliboverride&quot;&gt;DynlibOverride&lt;/a&gt; ключ командной строки позволяет избежать динамического связывания , если вам необходимо статически - то вместо этого. Оболочки Nim, предназначенные для статической компоновки исходных файлов, могут использовать &lt;a href=&quot;nimc#compile-pragma&quot;&gt;директиву compile,&lt;/a&gt; если источников мало или предоставить их вместе с кодом Nim проще, чем использовать системную библиотеку. Библиотеки, установленные в хост-системе, могут быть связаны с &lt;a href=&quot;nimc#passl-pragma&quot;&gt;прагмой PassL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee78ba5934ab094d006d5548d674ad0a80ec7579" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system#inc&quot;&gt;inc&lt;/a&gt;, &lt;a href=&quot;system#dec&quot;&gt;dec&lt;/a&gt;, &lt;a href=&quot;system#succ&quot;&gt;succ&lt;/a&gt; and &lt;a href=&quot;system#pred&quot;&gt;pred&lt;/a&gt; operations can fail by raising an &lt;em&gt;EOutOfRange&lt;/em&gt; or &lt;em&gt;EOverflow&lt;/em&gt; exception. (If the code has been compiled with the proper runtime checks turned on.)</source>
          <target state="translated">&lt;a href=&quot;system#inc&quot;&gt;Вкл&lt;/a&gt; , &lt;a href=&quot;system#dec&quot;&gt;декабрь&lt;/a&gt; , &lt;a href=&quot;system#succ&quot;&gt;Succ&lt;/a&gt; и &lt;a href=&quot;system#pred&quot;&gt;Pred&lt;/a&gt; операции могут не путем поднимая &lt;em&gt;EOutOfRange&lt;/em&gt; или &lt;em&gt;EOVERFLOW&lt;/em&gt; исключение. (Если код был скомпилирован с включенными надлежащими проверками времени выполнения.)</target>
        </trans-unit>
        <trans-unit id="15e6a3a29797da15852fead9e28ee2b0370e150e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates:</source>
          <target state="translated">&lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; операторы фактически являются шаблонами:</target>
        </trans-unit>
        <trans-unit id="2199e698bdfaf3681a19531d523f1d0976b1bdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates: this has the benefit that if you overload the &lt;code&gt;==&lt;/code&gt; operator, the &lt;code&gt;!=&lt;/code&gt; operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</source>
          <target state="translated">&lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; операторы фактически являются шаблонами: это имеет то преимущество , что , если вы перегружать &lt;code&gt;==&lt;/code&gt; оператора, &lt;code&gt;!=&lt;/code&gt; Оператор доступен автоматически и делает правильные вещи. (За исключением чисел с плавающей запятой IEEE - NaN нарушает базовую логику.)</target>
        </trans-unit>
        <trans-unit id="094e0d63fcca9df22fc0f3fbd6b2b575dd7da3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; and the &lt;code&gt;#dynlib&lt;/code&gt; directives are mutually exclusive. A binding that uses &lt;code&gt;dynlib&lt;/code&gt; is much more preferable over one that uses &lt;code&gt;header&lt;/code&gt;! The Nim compiler might drop support for the &lt;code&gt;header&lt;/code&gt; pragma in the future as it cannot work for backends that do not generate C code.</source>
          <target state="translated">&lt;code&gt;#header&lt;/code&gt; и &lt;code&gt;#dynlib&lt;/code&gt; директивы являются взаимоисключающими. Привязка, использующая &lt;code&gt;dynlib&lt;/code&gt; , намного предпочтительнее привязки , использующей &lt;code&gt;header&lt;/code&gt; ! Компилятор Nim может отказаться от поддержки прагмы &lt;code&gt;header&lt;/code&gt; в будущем, поскольку он не может работать для бэкэндов, которые не генерируют код C.</target>
        </trans-unit>
        <trans-unit id="f43b7889013c5efda25d7e2a5951e7e48009b60a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; directive tells c2nim that it should annotate every proc that resulted from a C function prototype and every exported variable and type with the &lt;code&gt;header&lt;/code&gt; pragma:</source>
          <target state="translated">&lt;code&gt;#header&lt;/code&gt; директива говорит c2nim , что он должен аннотировать каждый прок, полученный в результате функции C прототипа и каждой экспортируемой переменной и типа с &lt;code&gt;header&lt;/code&gt; Pragma:</target>
        </trans-unit>
        <trans-unit id="8d682f6cc241d8bb6822410eaa23e70f79490caf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#skipcomments&lt;/code&gt; directive can be put into the C code to make c2nim ignore comments and not copy them into the generated Nim file.</source>
          <target state="translated">&lt;code&gt;#skipcomments&lt;/code&gt; директива может быть введена в код C , чтобы c2nim игнорировать комментарии , а не копировать их в созданный файл Nim.</target>
        </trans-unit>
        <trans-unit id="c45bd804ab79049b4d0886ddf5d109c11eb57c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#typeprefixes&lt;/code&gt; directive can be put into the C code to make c2nim generate the &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; prefix for every defined type.</source>
          <target state="translated">&lt;code&gt;#typeprefixes&lt;/code&gt; директива может быть введена в код C , чтобы генерировать c2nim &lt;code&gt;T&lt;/code&gt; или &lt;code&gt;P&lt;/code&gt; префикс для каждого определенного типа.</target>
        </trans-unit>
        <trans-unit id="6ba0d1128c367616c99c9dc0a68b1f43d686832f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator can convert any enumeration value to its name, and the &lt;code&gt;ord&lt;/code&gt; proc can convert it to its underlying integer value.</source>
          <target state="translated">Оператор &lt;code&gt;$&lt;/code&gt; может преобразовать любое значение перечисления в свое имя, а процедура &lt;code&gt;ord&lt;/code&gt; может преобразовать его в соответствующее целочисленное значение.</target>
        </trans-unit>
        <trans-unit id="aae68c571abf2694e7a2359e8dbac146d141b789" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; is much like the &lt;code&gt;*&lt;/code&gt; operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; очень похоже на &lt;code&gt;*&lt;/code&gt; оператор, за исключением того, что он собирает не только все аргументы, но и совпадающая операторы в обратной польской записи:</target>
        </trans-unit>
        <trans-unit id="8023e9669b603ea0fcacf9f6cda5d9d92f066b57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; оператор</target>
        </trans-unit>
        <trans-unit id="d5b2439f0e50417f5d7601f9c27477b456c09ecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; Оператор</target>
        </trans-unit>
        <trans-unit id="aef4abe76e6ffc1cb6cb1bd388d212ec07b74cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can &lt;em&gt;flatten&lt;/em&gt; a nested binary expression like &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; to &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt;:</source>
          <target state="translated">Оператор &lt;code&gt;*&lt;/code&gt; может &lt;em&gt;сгладить&lt;/em&gt; вложенное двоичное выражение, например &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; , в &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7c6b5c181de77c676c99c40b4e5b0d932bb8b8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--context&lt;/code&gt; idetools switch is very similar to the suggestions switch, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">&lt;code&gt;--context&lt;/code&gt; переключатель idetools очень похож на предложения переключения, но вместо того , чтобы использовать после того , как пользователь напечатал точечный характер, это один предназначен для использования после того , как пользователь ввел открывающую скобку , чтобы начать параметры набора текста.</target>
        </trans-unit>
        <trans-unit id="c4b4b572ba4241498b55d821bb912dd3ce8ce04c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--def&lt;/code&gt; idetools switch performs a query about the definition of a specific symbol. If available, idetools will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">В &lt;code&gt;--def&lt;/code&gt; idetools коммутатор выполняет запрос об определении конкретного символа. Если доступно, idetools ответит типом, исходным файлом, информацией о строке / столбце и другими вспомогательными данными, если они доступны, например, строкой документации. Обладая этой информацией, IDE может предоставить типичный &lt;em&gt;переход к определению,&lt;/em&gt; когда пользователь помещает курсор на символ или использует мышь для его выбора и перенаправляется к месту, где расположен символ.</target>
        </trans-unit>
        <trans-unit id="dd3e3ce57e9aecee15d1c10869647548dba0871c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;переключатель компилятор&lt;/a&gt; может быть использован для , чтобы изменить &lt;code&gt;nimcache&lt;/code&gt; каталог.</target>
        </trans-unit>
        <trans-unit id="788b5d4a8f1368ab06e596c6b7b65932cae8614e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--suggest&lt;/code&gt; idetools switch performs a query about possible completion symbols at some point in the file. IDEs can easily provide an autocompletion feature where the IDE scans the current file (and related ones, if it knows about the language being edited and follows includes/imports) and when the user starts typing something a completion box with different options appears.</source>
          <target state="translated">Переключатель &lt;code&gt;--suggest&lt;/code&gt; idetools выполняет запрос о возможных символах завершения в некоторой точке файла. IDE могут легко предоставить функцию автозаполнения, при которой среда IDE сканирует текущий файл (и связанные с ним, если он знает о редактируемом языке и следует включает / импортирует), и когда пользователь начинает что-то вводить, появляется окно завершения с различными параметрами.</target>
        </trans-unit>
        <trans-unit id="984ae4024ec2641122166acc2ed459d4784e8ac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--usages&lt;/code&gt; idetools switch lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time. Again, a pure string based search and replace may catch symbols out of the scope of a function/loop.</source>
          <target state="translated">Переключатель &lt;code&gt;--usages&lt;/code&gt; idetools перечисляет все случаи использования символа в позиции. IDE могут использовать это, чтобы найти все места в файле, где используется символ, и предложить пользователю переименовать его во всех местах одновременно. Опять же, поиск и замена на основе чистой строки могут перехватывать символы, выходящие за рамки функции / цикла.</target>
        </trans-unit>
        <trans-unit id="45fbc61391e1a4b2d9263d29ca29efb51c1bb5ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">Файл &lt;code&gt;.&lt;/code&gt; (доступ к оператору поля кортежа / объекта) и операторы &lt;code&gt;[]&lt;/code&gt; (оператор индекса массива / строки / последовательности) выполняют неявные операции разыменования для ссылочных типов:</target>
        </trans-unit>
        <trans-unit id="78cd0d64a2665d2e29cb96ea56b4b61eaca69557" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C2NIM&lt;/code&gt; symbol is only recognized in &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; constructs! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; work.</source>
          <target state="translated">Символ &lt;code&gt;C2NIM&lt;/code&gt; распознается только в конструкциях &lt;code&gt;#ifdef&lt;/code&gt; и &lt;code&gt;#ifndef&lt;/code&gt; ! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; делает &lt;strong&gt;не&lt;/strong&gt; работа.</target>
        </trans-unit>
        <trans-unit id="a092497804c363adf0a9b85877d3ac5364f557a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DateTime&lt;/code&gt; type can be parsed and formatted using the different &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; procedures.</source>
          <target state="translated">Тип &lt;code&gt;DateTime&lt;/code&gt; можно анализировать и форматировать с помощью различных процедур &lt;code&gt;parse&lt;/code&gt; и &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b02713e2a0c1ca4eb80a37fb1dc1324674096936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; exception is raised if &lt;code&gt;x&lt;/code&gt; is not a &lt;code&gt;Student&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InvalidObjectConversionError&lt;/code&gt; возбуждается исключение , если &lt;code&gt;x&lt;/code&gt; не &lt;code&gt;Student&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="400dc7a3bd3178893b14b3f966ead94a0da3a473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RstParseOptions&lt;/code&gt;, &lt;code&gt;FindFileHandler&lt;/code&gt; and &lt;code&gt;MsgHandler&lt;/code&gt; types are defined in the the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. &lt;code&gt;options&lt;/code&gt; selects the behaviour of the rst parser.</source>
          <target state="translated">В &lt;code&gt;RstParseOptions&lt;/code&gt; , &lt;code&gt;FindFileHandler&lt;/code&gt; и &lt;code&gt;MsgHandler&lt;/code&gt; типов определены в то &lt;a href=&quot;rst&quot;&gt;/ Docutils / первый модуль пакетов&lt;/a&gt; . &lt;code&gt;options&lt;/code&gt; выбирает поведение первого парсера.</target>
        </trans-unit>
        <trans-unit id="00aa0e83fb2fddd7efccd136ea820b487d913775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; is called a &lt;span id=&quot;generic-type-parameter_1&quot;&gt;generic type parameter&lt;/span&gt; or a &lt;span id=&quot;type-variable_1&quot;&gt;type variable&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; называется &lt;span id=&quot;generic-type-parameter_1&quot;&gt;общим параметром типа&lt;/span&gt; или &lt;span id=&quot;type-variable_1&quot;&gt;тип переменной&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="ab738a00bda430d5fb380595920132610b0ad705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[: ]&lt;/code&gt; notation has been designed to mitigate this issue: &lt;code&gt;x.p[:T]&lt;/code&gt; is rewritten by the parser to &lt;code&gt;p[T](x)&lt;/code&gt;, &lt;code&gt;x.p[:T](y)&lt;/code&gt; is rewritten to &lt;code&gt;p[T](x, y)&lt;/code&gt;. Note that &lt;code&gt;[: ]&lt;/code&gt; has no AST representation, the rewrite is performed directly in the parsing step.</source>
          <target state="translated">&lt;code&gt;[: ]&lt;/code&gt; Обозначение было разработано , чтобы смягчить эту проблему: &lt;code&gt;x.p[:T]&lt;/code&gt; перезаписывается с помощью синтаксического анализа для &lt;code&gt;p[T](x)&lt;/code&gt; , &lt;code&gt;x.p[:T](y)&lt;/code&gt; переписывается &lt;code&gt;p[T](x, y)&lt;/code&gt; . Обратите внимание, что &lt;code&gt;[: ]&lt;/code&gt; не имеет представления AST, перезапись выполняется непосредственно на этапе синтаксического анализа.</target>
        </trans-unit>
        <trans-unit id="2a7a43acb1307f045b6107d24a38c825385ea414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; array access operator can be overloaded to provide &lt;span id=&quot;array-properties_1&quot;&gt;array properties&lt;/span&gt;:</source>
          <target state="translated">Оператор доступа к массиву &lt;code&gt;[]&lt;/code&gt; может быть перегружен для предоставления &lt;span id=&quot;array-properties_1&quot;&gt;свойств массива&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="914a69574ba02242343d8c757f3b0950ffcaeca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist. If you wish to avoid this behaviour you can use the &lt;code&gt;{}&lt;/code&gt; operator instead, it will simply return &lt;code&gt;nil&lt;/code&gt; when the field is not found. The &lt;code&gt;get&lt;/code&gt;-family of procedures will return a default value when called on &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;[]&lt;/code&gt; вызовет исключение, если указанное поле не существует. Если вы хотите избежать такого поведения, вы можете вместо этого использовать оператор &lt;code&gt;{}&lt;/code&gt; , он просто вернет &lt;code&gt;nil&lt;/code&gt; , если поле не будет найдено. &lt;code&gt;get&lt;/code&gt; -семейством процедур будет возвращать значение по умолчанию при вызове на &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d733185fdec6756a23f89ac0039a4d5fad38bdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; subscript operator for arrays/openarrays/sequences can be overloaded.</source>
          <target state="translated">Оператор индекса &lt;code&gt;[]&lt;/code&gt; для массивов / открытых массивов / последовательностей может быть перегружен.</target>
        </trans-unit>
        <trans-unit id="208edec1bf02d3f5453b13c50f0afe4bdd7b43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between &lt;code&gt;\Z&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; is that &lt;code&gt;\Z&lt;/code&gt; matches before a newline that is the last character of the string as well as at the end of the string, whereas &lt;code&gt;\z&lt;/code&gt; matches only at the end.</source>
          <target state="translated">Утверждения &lt;code&gt;\A&lt;/code&gt; , &lt;code&gt;\Z&lt;/code&gt; и &lt;code&gt;\z&lt;/code&gt; отличаются от традиционного циркумфлекса и доллара тем, что они всегда соответствуют только в самом начале и конце строки темы, какие бы параметры не были установлены. Разница между &lt;code&gt;\Z&lt;/code&gt; и &lt;code&gt;\z&lt;/code&gt; заключается в том, что &lt;code&gt;\Z&lt;/code&gt; соответствует перед новой строкой, которая является последним символом строки, а также в конце строки, тогда как &lt;code&gt;\z&lt;/code&gt; соответствует только в конце.</target>
        </trans-unit>
        <trans-unit id="7e817ef93305a23fbf7c9a80e38b0806e7482064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; suffix is used for release builds, &lt;code&gt;_d&lt;/code&gt; is for debug builds.</source>
          <target state="translated">&lt;code&gt;_r&lt;/code&gt; суффикс используется для версии релиза, &lt;code&gt;_d&lt;/code&gt; для отладки сборки.</target>
        </trans-unit>
        <trans-unit id="07747905d782c21340b66ec287991fea62bc1650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call may result in an error if the connecting socket disconnects during the duration of the &lt;code&gt;accept&lt;/code&gt;. If the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is specified then this error will not be raised and instead accept will be called again.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; вызов может привести к ошибке , если соединительные гнезда отключаются в течение срока действия &lt;code&gt;accept&lt;/code&gt; . Если указан флаг &lt;code&gt;SafeDisconn&lt;/code&gt; , эта ошибка не будет возникать, и вместо этого снова будет вызван accept.</target>
        </trans-unit>
        <trans-unit id="94b1ebe9dc31ad8dd9efa346619cf83e23a375a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;acyclic&lt;/code&gt; pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an &lt;strong&gt;optimization&lt;/strong&gt; for the garbage collector to not consider objects of this type as part of a cycle:</source>
          <target state="translated">&lt;code&gt;acyclic&lt;/code&gt; прагма может использоваться для типов объектов , чтобы пометить их как ациклические , даже если они кажутся циклическими. Это &lt;strong&gt;оптимизация,&lt;/strong&gt; позволяющая сборщику мусора не рассматривать объекты этого типа как часть цикла:</target>
        </trans-unit>
        <trans-unit id="613f12943604467ec30c9f5050f1fcb757eb0680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;em&gt;addr&lt;/em&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="translated">Оператор &lt;code&gt;addr&lt;/code&gt; возвращает адрес l-значения. Если тип местоположения является &lt;code&gt;T&lt;/code&gt; , то &lt;em&gt;адр&lt;/em&gt; результат оператора типа &lt;code&gt;ptr T&lt;/code&gt; . Адрес всегда является неотслеживаемой ссылкой. Принятие адреса объекта, который находится в стеке, &lt;strong&gt;небезопасно&lt;/strong&gt; , поскольку указатель может существовать дольше, чем объект в стеке, и, таким образом, может ссылаться на несуществующий объект. Можно получить адрес переменных, но нельзя использовать его для переменных, объявленных с помощью операторов &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bae94e7bbf49797d2a7e82b8a0df92aa58eba2b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; procedures also offer limited support for the try statement.</source>
          <target state="translated">В &lt;code&gt;async&lt;/code&gt; процедуре также предлагает ограниченную поддержку заявления попробовать.</target>
        </trans-unit>
        <trans-unit id="50db6910ce0829d49cf640239e7c5e2012608b2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; type can only be used for return types and parameters. For return types it causes the compiler to infer the type from the routine body:</source>
          <target state="translated">Тип &lt;code&gt;auto&lt;/code&gt; можно использовать только для возвращаемых типов и параметров. Для возвращаемых типов он заставляет компилятор вывести тип из тела подпрограммы:</target>
        </trans-unit>
        <trans-unit id="c935fb430329bfdcd15706ca3da9cc7d25a5deb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;await&lt;/code&gt; call may be used in many contexts. It can be used on the right hand side of a variable declaration: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt;, in which case the variable will be set to the value of the future automatically. It can be used to await a &lt;code&gt;Future&lt;/code&gt; object, and it can be used to await a procedure returning a &lt;code&gt;Future[void]&lt;/code&gt;: &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;await&lt;/code&gt; вызов может быть использован во многих контекстах. Его можно использовать в правой части объявления переменной: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt; , и в этом случае переменной будет автоматически присвоено значение future. Его можно использовать для ожидания объекта &lt;code&gt;Future&lt;/code&gt; и его можно использовать для ожидания процедуры, возвращающей &lt;code&gt;Future[void]&lt;/code&gt; : &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3034958596b82fd279a106ed77e05a13c012c241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; statement is the counterpart to the &lt;code&gt;mixin&lt;/code&gt; statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</source>
          <target state="translated">Оператор &lt;code&gt;bind&lt;/code&gt; является аналогом оператора &lt;code&gt;mixin&lt;/code&gt; . Его можно использовать для явного объявления идентификаторов, которые должны быть привязаны на ранней стадии (т.е. идентификаторы следует искать в области действия шаблона / общего определения):</target>
        </trans-unit>
        <trans-unit id="2689f22307a3f463f4d508ab1aa3def314234321" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bitsize&lt;/code&gt; pragma is for object field members. It declares the field as a bitfield in C/C++.</source>
          <target state="translated">&lt;code&gt;bitsize&lt;/code&gt; прагма для членов поля объекта. Он объявляет поле как битовое поле в C / C ++.</target>
        </trans-unit>
        <trans-unit id="3194ada345dceb4b88200e579d663c2676d8313e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;borrow&lt;/code&gt; pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.</source>
          <target state="translated">&lt;code&gt;borrow&lt;/code&gt; Прагма делает компилятор использовать ту же реализацию , как прок , что имеет дело с базовым типом особого типа, поэтому код не генерируются.</target>
        </trans-unit>
        <trans-unit id="ecd73ebdde8c6264e667c9b2e15208469fb20c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement is used to leave a block immediately. If &lt;code&gt;symbol&lt;/code&gt; is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</source>
          <target state="translated">Оператор &lt;code&gt;break&lt;/code&gt; используется для немедленного выхода из блока. Если указан &lt;code&gt;symbol&lt;/code&gt; , это имя закрывающего блока, который нужно оставить. Если его нет, остается самый внутренний блок.</target>
        </trans-unit>
        <trans-unit id="3b17893941a66444039629e3f18a21d2a35573b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bycopy&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:</source>
          <target state="translated">&lt;code&gt;bycopy&lt;/code&gt; прагма может быть применена к объекту или кортеж типа и инструктирует компилятор передать тип по значению проков:</target>
        </trans-unit>
        <trans-unit id="2cbef8ce9bc4f27aa65fea1e9689cc4a8226d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;byref&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.</source>
          <target state="translated">&lt;code&gt;byref&lt;/code&gt; прагма может быть применена к объекту или кортеж типа и инструктирует компилятор передать тип по ссылке (скрыто указатель) к прокам.</target>
        </trans-unit>
        <trans-unit id="77887b44cd49a95c9b69ac0376b1caf0f2b195c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; constraint is particularly useful to implement a move optimization for types that have copying semantics:</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; ограничение является особенно полезным для реализации оптимизации перемещения для типов , которые имеют семантику копирования:</target>
        </trans-unit>
        <trans-unit id="33fe5bba83ee973b32a89460ea4507bb32681a04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword &lt;code&gt;case&lt;/code&gt; is evaluated and if its value is in a &lt;em&gt;slicelist&lt;/em&gt; the corresponding statements (after the &lt;code&gt;of&lt;/code&gt; keyword) are executed. If the value is not in any given &lt;em&gt;slicelist&lt;/em&gt; the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part and not all possible values that &lt;code&gt;expr&lt;/code&gt; can hold occur in a &lt;code&gt;slicelist&lt;/code&gt;, a static error occurs. This holds only for expressions of ordinal types. &quot;All possible values&quot; of &lt;code&gt;expr&lt;/code&gt; are determined by &lt;code&gt;expr&lt;/code&gt;'s type. To suppress the static error an &lt;code&gt;else&lt;/code&gt; part with an empty &lt;code&gt;discard&lt;/code&gt; statement should be used.</source>
          <target state="translated">Оператор &lt;code&gt;case&lt;/code&gt; аналогичен оператору if, но представляет выбор с несколькими ветвями. Выражение после ключевого слова &lt;code&gt;case&lt;/code&gt; оценивается, и если его значение находится в &lt;em&gt;списке срезов, выполняются&lt;/em&gt; соответствующие операторы (после ключевого слова &lt;code&gt;of&lt;/code&gt; ). Если значение отсутствует в каком-либо заданном &lt;em&gt;списке слайсов,&lt;/em&gt; выполняется часть &lt;code&gt;else&lt;/code&gt; . Если в &lt;code&gt;slicelist&lt;/code&gt; нет части &lt;code&gt;else&lt;/code&gt; и не все возможные значения, которые может содержать &lt;code&gt;expr&lt;/code&gt; , возникает статическая ошибка. Это справедливо только для выражений порядковых типов. &quot;Все возможные значения&quot; &lt;code&gt;expr&lt;/code&gt; определяются &lt;code&gt;expr&lt;/code&gt; типа. Чтобы подавить статическую ошибку, следует использовать часть &lt;code&gt;else&lt;/code&gt; с пустым оператором &lt;code&gt;discard&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b931d0051b260f30fa749dc3d29290c854e0e0fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;codegenDecl&lt;/code&gt; pragma can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.</source>
          <target state="translated">&lt;code&gt;codegenDecl&lt;/code&gt; прагма может быть использована непосредственно влиять на генератор кода Nim в. Он получает строку формата, которая определяет, как переменная или процедура объявляется в сгенерированном коде.</target>
        </trans-unit>
        <trans-unit id="4a60295e92762b0a268d73c57558484ce5962353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; pragma can be used to compile and link a C/C++ source file with the project:</source>
          <target state="translated">&lt;code&gt;compile&lt;/code&gt; прагма можно использовать для компиляции и компоновки исходного файла С / С ++ с проектом:</target>
        </trans-unit>
        <trans-unit id="32f5047930630f7d43dcd54eb01e5361a0735034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used at compile time only. No code will be generated for it. Compile time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;compileTime&lt;/code&gt; прагма используются для обозначения процедурного или переменного для использования только на время компиляции. Для этого не будет создан код. Процедуры времени компиляции полезны как помощники для макросов. Начиная с версии языка 0.12.0, процедура, использующая &lt;code&gt;system.NimNode&lt;/code&gt; в своих типах параметров, неявно объявляется &lt;code&gt;compileTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e71c552e9eb087bf7303d12b46f93a710977aea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;computedGoto&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_2&quot;&gt;case&lt;/span&gt; in a &lt;code&gt;while true&lt;/code&gt; statement. Syntactically it has to be used as a statement inside the loop:</source>
          <target state="translated">&lt;code&gt;computedGoto&lt;/code&gt; прагма может быть использована , чтобы сообщить компилятору , как составить Nim &lt;span id=&quot;case_2&quot;&gt;случай&lt;/span&gt; в &lt;code&gt;while true&lt;/code&gt; заявление. Синтаксически он должен использоваться как оператор внутри цикла:</target>
        </trans-unit>
        <trans-unit id="13725b1c9ade232410cac093cb3d9c609f4347af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;con&lt;/code&gt; Nimsuggest command is very similar to the suggestions command, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">Команда &lt;code&gt;con&lt;/code&gt; Nimsuggest очень похожа на команду предложений, но вместо того, чтобы использоваться после того, как пользователь ввел символ точки, она предназначена для использования после того, как пользователь ввел открывающую скобку, чтобы начать ввод параметров.</target>
        </trans-unit>
        <trans-unit id="a4393be6b906a951ceceb50efcf150dd498771f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;em&gt;compatible string&lt;/em&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible to the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="translated">Тип &lt;code&gt;cstring&lt;/code&gt; , означающий, что &lt;em&gt;совместимая строка,&lt;/em&gt; является собственным представлением строки для серверной части компиляции. Для бэкэнда &lt;code&gt;cstring&lt;/code&gt; тип cstring представляет собой указатель на массив символов с завершающим нулем, совместимый с типом &lt;code&gt;char*&lt;/code&gt; в Ansi C. Его основная цель заключается в простом взаимодействии с C. Операция индекса &lt;code&gt;s[i]&lt;/code&gt; означает i-й &lt;em&gt;символ.&lt;/em&gt; из &lt;code&gt;s&lt;/code&gt; ; однако проверка границ для &lt;code&gt;cstring&lt;/code&gt; не выполняется, что делает операцию индекса небезопасной.</target>
        </trans-unit>
        <trans-unit id="94b4450902f6290125300edf3507775a37d2e1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when &lt;code&gt;ev&lt;/code&gt; happens.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; являются применение определенных данных, которые будут переданы , когда &lt;code&gt;ev&lt;/code&gt; происходят.</target>
        </trans-unit>
        <trans-unit id="2420343b67cf5f6d0ad1bb94f0326b094a8ab2e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when process with &lt;code&gt;pid&lt;/code&gt; has exited.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; являются применение определенных данных, которые будут переданы , когда процесс с &lt;code&gt;pid&lt;/code&gt; завершились.</target>
        </trans-unit>
        <trans-unit id="944bc8355b34d79d86a6c6b2a6eb683062d9add5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when signal raises.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; являются применение определенных данных, которые будут переданы , когда возникает сигнал.</target>
        </trans-unit>
        <trans-unit id="39620c3fad1d30f3b1f821ad058fe01edf735504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed, when the timer is triggered.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; является применение определенных данных, которые будут переданы, когда таймер запускается.</target>
        </trans-unit>
        <trans-unit id="d408a6fed5457e4eb16aefaa58b57d0d3444464a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def&lt;/code&gt; Nimsuggest command performs a query about the definition of a specific symbol. If available, Nimsuggest will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">Команда &lt;code&gt;def&lt;/code&gt; Nimsuggest выполняет запрос об определении конкретного символа. Если доступно, Nimsuggest ответит типом, исходным файлом, информацией о строке / столбце и другими дополнительными данными, если они доступны, например, строкой документации. Обладая этой информацией, IDE может предоставить типичный &lt;em&gt;переход к определению,&lt;/em&gt; когда пользователь помещает курсор на символ или использует мышь для его выбора и перенаправляется к месту, где расположен символ.</target>
        </trans-unit>
        <trans-unit id="a06a0dec2b01f32c664435ab9f31e13949ab037d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement can also be used to create block comments as described in the &lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt; section.</source>
          <target state="translated">Оператор &lt;code&gt;discard&lt;/code&gt; также может использоваться для создания блочных комментариев, как описано в разделе &amp;laquo; &lt;a href=&quot;#comments&quot;&gt;Комментарии&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9b91a9fbefbe79c145dec481daa3f20cf6495d82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away.</source>
          <target state="translated">Оператор &lt;code&gt;discard&lt;/code&gt; оценивает свое выражение на предмет побочных эффектов и отбрасывает результирующее значение выражения.</target>
        </trans-unit>
        <trans-unit id="e03a7cd86091bf4978da827132b8b38c56f5a7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc&lt;/code&gt; command:</source>
          <target state="translated">Команда &lt;code&gt;doc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9ca7671dacb127635569222e277ebf2ecb0f66a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; import mechanism supports a versioning scheme:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt; механизм импорта поддерживает схему управления версиями:</target>
        </trans-unit>
        <trans-unit id="711b0f2233816783424452869696407ac31e0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as argument but also string expressions in general:</source>
          <target state="translated">В &lt;code&gt;dynlib&lt;/code&gt; Pragma поддерживает не только постоянные строки в качестве аргумента , но и строковые выражения в целом:</target>
        </trans-unit>
        <trans-unit id="0a70d199da0b3634e63e2a723bfea6e65d9ac0d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;effects&lt;/code&gt; pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the &lt;code&gt;effects&lt;/code&gt;'s position:</source>
          <target state="translated">&lt;code&gt;effects&lt;/code&gt; Прагма была разработана , чтобы помочь программисту с анализом эффектов. Это утверждение , что делает вывод компилятора все предполагаемые эффекты вплоть до &lt;code&gt;effects&lt;/code&gt; положения &amp;laquo;S:</target>
        </trans-unit>
        <trans-unit id="e6f0db3ce7d6ed0afa4949c7005ccdb2e6f1d36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. So it makes your code unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="translated">&lt;code&gt;emit&lt;/code&gt; прагма может быть использована непосредственно влияет на выходе генератора кода компилятора. Таким образом, ваш код становится непереносимым для других генераторов кода / бэкэндов. Его использование крайне не рекомендуется! Однако он может быть чрезвычайно полезен для взаимодействия с кодом &lt;span id=&quot;cplusplus_1&quot;&gt;C ++&lt;/span&gt; или &lt;span id=&quot;objective-c_1&quot;&gt;Objective C.&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="4e1c7e194942108d8e21f2868b591c724f772ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; procedure takes an &lt;code&gt;openarray&lt;/code&gt; so both arrays and sequences can be passed as parameters.</source>
          <target state="translated">Процедура &lt;code&gt;encode&lt;/code&gt; принимает &lt;code&gt;openarray&lt;/code&gt; поэтому в качестве параметров можно передавать как массивы, так и последовательности.</target>
        </trans-unit>
        <trans-unit id="0be6fe6293d87b67dc2913d9bce025978f0a0479" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; прагма также может быть использована для аннотирования символа (например , итератор или Proc). &lt;em&gt;Использование&lt;/em&gt; символа затем вызывает ошибку времени компиляции. Это особенно полезно, чтобы исключить допустимую операцию из-за перегрузки и преобразования типов:</target>
        </trans-unit>
        <trans-unit id="4f57f84a99b6715a53ef1c48e22f80406dcf7a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; Прагма используется , чтобы сделать вывод компилятора сообщение об ошибке с данным содержанием. Однако компиляция не обязательно прерывается после ошибки.</target>
        </trans-unit>
        <trans-unit id="6e20ba8aa37ee9c1d06ae011187ea2193578fda3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</source>
          <target state="translated">&lt;code&gt;experimental&lt;/code&gt; Прагма позволяет экспериментальные функции языка. В зависимости от конкретной функции это означает, что функция либо считается слишком нестабильной для стабильной версии, либо ее будущее остается неопределенным (ее можно удалить в любой момент).</target>
        </trans-unit>
        <trans-unit id="5c5fb8cbfdf80872586dff5915d97b9df4693c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exportc&lt;/code&gt; pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;exportc&lt;/code&gt; прагма обеспечивает средство для экспорта типа, переменной или процедуры для C. Перечисления и константы не могут быть экспортированы. Необязательный аргумент - это строка, содержащая идентификатор C. Если аргумент отсутствует, имя C является идентификатором Nim в &lt;em&gt;точности так, как написано&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="47b24553ecff8957d4500654446c7208e0bde7f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;let x = expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; в &lt;code&gt;let x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b98b3911e1265813479591033e8dcbc4614d140" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;result = expr&lt;/code&gt; where &lt;code&gt;result&lt;/code&gt; is the special symbol introduced by the compiler.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; в &lt;code&gt;result = expr&lt;/code&gt; , где &lt;code&gt;result&lt;/code&gt; является специальным символом , введенный компилятором.</target>
        </trans-unit>
        <trans-unit id="9a1869dad0651b77d39e69eb4e5353bc58adc7c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;return expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; в &lt;code&gt;return expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78082c4233243f41109f44b1a863ec8557ffce70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;var x = expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; в &lt;code&gt;var x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ccc224f63d4c9f00b3f6c42a04670fca5ecc5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="translated">&lt;code&gt;fatal&lt;/code&gt; Прагма используется , чтобы сделать вывод компилятора сообщение об ошибке с заданным содержанием. В отличие от прагмы &lt;code&gt;error&lt;/code&gt; , эта прагма гарантирует прерывание компиляции. Пример:</target>
        </trans-unit>
        <trans-unit id="4a8a977747b68cc9df3227b470584d16d2fcbb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="translated">Параметра &lt;code&gt;file&lt;/code&gt; достаточно для статического анализа, но в IDE обычно есть &lt;em&gt;несохраненные буферы, в&lt;/em&gt; которых пользователь все еще может вводить строку. В таких ситуациях IDE может сохранить текущее содержимое во временный файл, а затем использовать параметр &lt;code&gt;dirtyfile.nim&lt;/code&gt; , чтобы сообщить Nimsuggest, что &lt;code&gt;foobar.nim&lt;/code&gt; следует взять из &lt;code&gt;temporary/foobar.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32aac42cbd8ce78d102f6016c7193cba8438ab2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;final&lt;/code&gt; pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the &lt;code&gt;object of SuperType&lt;/code&gt; syntax) or that have been marked as &lt;code&gt;inheritable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; прагма может быть использована для типа объекта , чтобы указать , что он не может быть унаследован от. Обратите внимание, что наследование доступно только для объектов, которые наследуются от существующего объекта (через &lt;code&gt;object of SuperType&lt;/code&gt; синтаксиса SuperType ) или которые были помечены как &lt;code&gt;inheritable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc6920d18d66b9005034c2f565bcac18339a40f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;generalized raw string literal&lt;/a&gt;. This has some surprising effects:</source>
          <target state="translated">&lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; синтаксис более эстетично, но она скрывает небольшой Гоча. Строка - это &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;обобщенный необработанный строковый литерал&lt;/a&gt; . Это дает несколько удивительных эффектов:</target>
        </trans-unit>
        <trans-unit id="436147e1c09214f0e309d989b28b417ff7622040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</source>
          <target state="translated">Цикл &lt;code&gt;for&lt;/code&gt; объявляет переменные итерации - их область действия достигает конца тела цикла. Типы переменных итерации определяются возвращаемым типом итератора.</target>
        </trans-unit>
        <trans-unit id="d87dfe950dbe2084f156bb115bd025bb3ef4b279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. But if you use the two variable form, the first variable will hold the index position and the second variable will hold the value. Here the &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Examples:</source>
          <target state="translated">Оператор &lt;code&gt;for&lt;/code&gt; может использоваться с одной или двумя переменными при использовании с последовательностью. Когда вы используете форму с одной переменной, переменная будет содержать значение, предоставленное последовательностью. Оператор &lt;code&gt;for&lt;/code&gt; перебирает результаты итератора &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items ()&lt;/a&gt; из &lt;a href=&quot;system&quot;&gt;системного&lt;/a&gt; модуля. Но если вы используете форму с двумя переменными, первая переменная будет содержать позицию индекса, а вторая переменная будет содержать значение. Здесь оператор &lt;code&gt;for&lt;/code&gt; перебирает результаты итератора &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pair ()&lt;/a&gt; из &lt;a href=&quot;system&quot;&gt;системного&lt;/a&gt; модуля. Примеры:</target>
        </trans-unit>
        <trans-unit id="7a5f8ddc630011123a75729ce1011d437f837fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement is a construct to loop over any element an &lt;em&gt;iterator&lt;/em&gt; provides. The example uses the built-in &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; iterator:</source>
          <target state="translated">Оператор &lt;code&gt;for&lt;/code&gt; - это конструкция для перебора любого элемента, предоставляемого &lt;em&gt;итератором&lt;/em&gt; . В примере используется встроенный итератор &lt;a href=&quot;system#countup&quot;&gt;обратного&lt;/a&gt; отсчета:</target>
        </trans-unit>
        <trans-unit id="a3b3d0f268a26cc4a0699d12f685526f47dd2e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified to be used.</source>
          <target state="translated">Оператор &lt;code&gt;from&lt;/code&gt; также может принудительно определять пространство имен для символов, тем самым делая символы доступными, но при этом их необходимо уточнять для использования.</target>
        </trans-unit>
        <trans-unit id="628bb89d094225e527b7e15df6b1eb1b878153d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;func&lt;/code&gt; keyword introduces a shortcut for a &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; proc.</source>
          <target state="translated">В &lt;code&gt;func&lt;/code&gt; ключевое слово вводит ярлык для &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; Proc.</target>
        </trans-unit>
        <trans-unit id="d0083ea6cc0b6494a6dbfc51aca179ac8b3c56af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackError&lt;/code&gt; if there is no value. There is another option for obtaining the value: &lt;code&gt;unsafeGet&lt;/code&gt;, but you must only use it when you are absolutely sure the value is present (e.g. after checking &lt;code&gt;isSome&lt;/code&gt;). If you do not care about the tiny overhead that &lt;code&gt;get&lt;/code&gt; causes, you should simply never use &lt;code&gt;unsafeGet&lt;/code&gt;.</source>
          <target state="translated">Операция &lt;code&gt;get&lt;/code&gt; , показанная выше, возвращает базовое значение или вызывает &lt;code&gt;UnpackError&lt;/code&gt; если значение отсутствует. Существует еще один вариант получения значения: &lt;code&gt;unsafeGet&lt;/code&gt; , но вы должны использовать его только тогда, когда вы абсолютно уверены, что значение присутствует (например, после проверки &lt;code&gt;isSome&lt;/code&gt; ). Если вы не заботитесь о крошечных накладных расходов , которые &lt;code&gt;get&lt;/code&gt; причины, вы должны просто не использовать &lt;code&gt;unsafeGet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b262a4793a87dcd3423e3de392c1373594c7a80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; прагма может применяться к переменной в прок , чтобы указать компилятору , чтобы сохранить его в глобальном месте и инициализировать ее один раз при запуске программы.</target>
        </trans-unit>
        <trans-unit id="f3137d8ded88666f115e1ad63a5e346dd2aff08c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;guard&lt;/code&gt; annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</source>
          <target state="translated">&lt;code&gt;guard&lt;/code&gt; аннотаций также может быть использован для защиты полей внутри объекта. Тогда охранник должен быть другим полем в том же объекте или глобальной переменной.</target>
        </trans-unit>
        <trans-unit id="e66122e0d67f678d2cd3350768f39275164af1b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string contant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; Pragma всегда ожидает постоянную строку. Строка contant содержит файл заголовка: Как обычно для C, файл заголовка системы заключен в угловые скобки: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Если угловые скобки не указаны, Nim заключает файл заголовка в &lt;code&gt;&quot;&quot;&lt;/code&gt; в сгенерированном коде C.</target>
        </trans-unit>
        <trans-unit id="0b679c76e7a9ed62a93f723575cfccef75d26424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; Pragma очень похож на &lt;code&gt;noDecl&lt;/code&gt; прагму: Он может быть применен к почти любому символу и указует , что он не должен быть объявлен и вместо того, чтобы сгенерированный код должен содержать &lt;code&gt;#include&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a9ed3be3ca0ab53ad4c051a00d1adf22ed5686a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hint&lt;/code&gt; pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</source>
          <target state="translated">&lt;code&gt;hint&lt;/code&gt; прагма используется , чтобы сделать намек сообщение вывода компилятора с данным содержанием. Компиляция продолжается после подсказки.</target>
        </trans-unit>
        <trans-unit id="2ebd6b843b12e6bfab912253ce8368ae735e6323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is a simple way to make a branch in the control flow: The expression after the keyword &lt;code&gt;if&lt;/code&gt; is evaluated, if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. Otherwise the expression after the &lt;code&gt;elif&lt;/code&gt; is evaluated (if there is an &lt;code&gt;elif&lt;/code&gt; branch), if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. This goes on until the last &lt;code&gt;elif&lt;/code&gt;. If all conditions fail, the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part, execution continues with the next statement.</source>
          <target state="translated">Оператор &lt;code&gt;if&lt;/code&gt; - это простой способ создать ветвь в потоке управления: выполняется выражение после ключевого слова &lt;code&gt;if&lt;/code&gt; , если оно истинно , выполняются соответствующие операторы после &lt;code&gt;:&lt;/code&gt; . В противном случае вычисляется выражение после &lt;code&gt;elif&lt;/code&gt; (если есть ветвь &lt;code&gt;elif&lt;/code&gt; ), если оно истинно , выполняются соответствующие операторы после &lt;code&gt;:&lt;/code&gt; . Так продолжается до последнего &lt;code&gt;elif&lt;/code&gt; . Если все условия не выполняются, выполняется часть &lt;code&gt;else&lt;/code&gt; . Если части &lt;code&gt;else&lt;/code&gt; нет , выполнение продолжается со следующего оператора.</target>
        </trans-unit>
        <trans-unit id="fd9a59bb3838f7721c56dcd3c0f527061c3d17e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;importc&lt;/code&gt; pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;importc&lt;/code&gt; прагма обеспечивает средство для импорта процедурный или переменную из C. Необязательный аргумент является строкой , содержащей идентификатор C. Если аргумент отсутствует, имя C является идентификатором Nim в &lt;em&gt;точности так, как написано&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="ad4417d81051ba2fda59de7fd41e5159b1404cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement does something fundamentally different than importing a module: it merely includes the contents of a file. The &lt;code&gt;include&lt;/code&gt; statement is useful to split up a large module into several files:</source>
          <target state="translated">Оператор &lt;code&gt;include&lt;/code&gt; выполняет нечто принципиально иное, чем импорт модуля: он просто включает содержимое файла. Оператор &lt;code&gt;include&lt;/code&gt; полезен для разделения большого модуля на несколько файлов:</target>
        </trans-unit>
        <trans-unit id="0f94857a75c9bc1979ffd9f951809e759cc263fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incompleteStruct&lt;/code&gt; pragma tells the compiler to not use the underlying C &lt;code&gt;struct&lt;/code&gt; in a &lt;code&gt;sizeof&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;incompleteStruct&lt;/code&gt; прагма сообщает компилятору , чтобы не использовать основной C - &lt;code&gt;struct&lt;/code&gt; в &lt;code&gt;sizeof&lt;/code&gt; выражении:</target>
        </trans-unit>
        <trans-unit id="bf743bc2a57bf16453dba05ab29e67acdfb89a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</source>
          <target state="translated">В &lt;code&gt;inject&lt;/code&gt; и &lt;code&gt;gensym&lt;/code&gt; псевдокомментарии вторые аннотаций класса; у них нет семантики вне определения шаблона, и их нельзя абстрагировать:</target>
        </trans-unit>
        <trans-unit id="c48a2765e8c42b7c535b1be5ad5b35ddb4c24b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;injectStmt&lt;/code&gt; pragma can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:</source>
          <target state="translated">&lt;code&gt;injectStmt&lt;/code&gt; прагма может использоваться , чтобы ввести заявление перед каждым другим утверждением в текущем модуле. Его следует использовать только для отладки:</target>
        </trans-unit>
        <trans-unit id="633eb4e1412a3b13001ffe18b5db908a368027e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient int set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;. &lt;strong&gt;Note&lt;/strong&gt;: Since Nim currently does not allow the assignment operator to be overloaded, &lt;code&gt;=&lt;/code&gt; for int sets performs some rather meaningless shallow copy; use &lt;code&gt;assign&lt;/code&gt; to get a deep copy.</source>
          <target state="translated">Модуль &lt;code&gt;intsets&lt;/code&gt; реализует эффективный набор int, реализованный как &lt;span id=&quot;sparse-bit-set_1&quot;&gt;разреженный набор бит&lt;/span&gt; . &lt;strong&gt;Примечание&lt;/strong&gt; . Поскольку в настоящее время Nim не позволяет перегружать оператор присваивания, &lt;code&gt;=&lt;/code&gt; для наборов int выполняет довольно бессмысленное поверхностное копирование; используйте &lt;code&gt;assign&lt;/code&gt; , чтобы получить полную копию.</target>
        </trans-unit>
        <trans-unit id="ac6a8f8a9038fd001e9bcf25c7590eeedb8367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int{lit}&lt;/code&gt; parameter pattern matches against an expression of type &lt;code&gt;int&lt;/code&gt;, but only if it's a literal.</source>
          <target state="translated">В &lt;code&gt;int{lit}&lt;/code&gt; шаблон параметров матчи против выражения типа &lt;code&gt;int&lt;/code&gt; , но только если это буквальное.</target>
        </trans-unit>
        <trans-unit id="dbcf608e730943249674bddace7178d1650d4c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator checks for type equivalence at compile time. It is therefore very useful for type specialization within generic code:</source>
          <target state="translated">Оператор &lt;code&gt;is&lt;/code&gt; проверяет эквивалентность типов во время компиляции. Поэтому это очень полезно для специализации типов в универсальном коде:</target>
        </trans-unit>
        <trans-unit id="bab0e112ac9b29f05be238eca0977fc170691191" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; type is always of the calling convention &lt;code&gt;closure&lt;/code&gt; implicitly; the following example shows how to use iterators to implement a &lt;span id=&quot;collaborative-tasking_1&quot;&gt;collaborative tasking&lt;/span&gt; system:</source>
          <target state="translated">Тип &lt;code&gt;iterator&lt;/code&gt; всегда неявно соответствует &lt;code&gt;closure&lt;/code&gt; соглашения о вызовах ; В следующем примере показано, как использовать итераторы для реализации системы &lt;span id=&quot;collaborative-tasking_1&quot;&gt;совместной работы&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="8c51c8609edeb22ed76fcbde9b258a50e77c8157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc0&lt;/code&gt; command:</source>
          <target state="translated">Команда &lt;code&gt;jsondoc0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d07ffe6edb5db09dbe2b7e3001f8af54d7978127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc&lt;/code&gt; command:</source>
          <target state="translated">Команда &lt;code&gt;jsondoc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f86e1a24462b67c7426c7b0acfee59f9a241fd55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;koch&lt;/code&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; documentation.</source>
          <target state="translated">Программа &lt;code&gt;koch&lt;/code&gt; - это сценарий обслуживания Нима. Это замена для сценариев make и оболочки с тем преимуществом, что он намного более переносим. Более подробную информацию о его опциях можно найти в документации &lt;a href=&quot;koch&quot;&gt;коч&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b2c762fac40a5608e0b7e7de49ebe36c6b608ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; statement works like the &lt;code&gt;var&lt;/code&gt; statement but the declared symbols are &lt;em&gt;single assignment&lt;/em&gt; variables: After the initialization their value cannot change:</source>
          <target state="translated">Оператор &lt;code&gt;let&lt;/code&gt; работает аналогично оператору &lt;code&gt;var&lt;/code&gt; , но объявленные символы являются &lt;em&gt;одиночными&lt;/em&gt; переменными &lt;em&gt;присваивания&lt;/em&gt; : после инициализации их значение не может измениться:</target>
        </trans-unit>
        <trans-unit id="2e8bf1e1e37d7a0035195dab30ef109a27650d29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; прагма может использоваться повлиять на информацию строки аннотированном заявления , как показано в стеке цепочек вызовов:</target>
        </trans-unit>
        <trans-unit id="915701467dacb0f53184563a8354aa1f016b1417" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineDir&lt;/code&gt; option can be turned on or off. If turned on the generated C code contains &lt;code&gt;#line&lt;/code&gt; directives. This may be helpful for debugging with GDB.</source>
          <target state="translated">&lt;code&gt;lineDir&lt;/code&gt; опция может быть включена или выключена. Если он включен, сгенерированный код C содержит директивы &lt;code&gt;#line&lt;/code&gt; . Это может быть полезно для отладки с помощью GDB.</target>
        </trans-unit>
        <trans-unit id="8862192e862105c15d55393354d8d5087e6d99c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineInfoFrom&lt;/code&gt; parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.</source>
          <target state="translated">Параметр &lt;code&gt;lineInfoFrom&lt;/code&gt; используется для информации о строке при сбое созданного кода. Вы должны убедиться, что он установлен на узел, который вы преобразовываете.</target>
        </trans-unit>
        <trans-unit id="947951cac85d38c8083826636d24bf5d2f716054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineTrace&lt;/code&gt; option implies the &lt;code&gt;stackTrace&lt;/code&gt; option. If turned on, the generated C contains code to ensure that proper stack traces with line number information are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">Параметр &lt;code&gt;lineTrace&lt;/code&gt; подразумевает параметр &lt;code&gt;stackTrace&lt;/code&gt; . Если этот параметр включен, сгенерированный C содержит код, обеспечивающий правильную трассировку стека с информацией о номере строки, если программа дает сбой или возникает неперехваченное исключение.</target>
        </trans-unit>
        <trans-unit id="d980b3bcc3269067f6e576157b155e2551065156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_1&quot;&gt;case&lt;/span&gt; statement. Syntactically it has to be used as a statement:</source>
          <target state="translated">&lt;code&gt;linearScanEnd&lt;/code&gt; прагма может быть использована , чтобы сообщить компилятору , как составить Nim &lt;span id=&quot;case_1&quot;&gt;дела&lt;/span&gt; заявления. Синтаксически это должно использоваться как утверждение:</target>
        </trans-unit>
        <trans-unit id="81348c7397c56af7cb77770121f3f2ce241cb992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole &lt;code&gt;case&lt;/code&gt; statement, the whole &lt;code&gt;case&lt;/code&gt; statement uses linear scanning.</source>
          <target state="translated">&lt;code&gt;linearScanEnd&lt;/code&gt; прагма должна быть введена в последнюю ветвь , которая должна быть испытана в соответствии с помощью линейного сканирования. Если поместить в последнюю ветвь всего оператора &lt;code&gt;case&lt;/code&gt; , весь оператор &lt;code&gt;case&lt;/code&gt; использует линейное сканирование.</target>
        </trans-unit>
        <trans-unit id="661a3797ceadcd6fa8b44a4a0a3e4223544ab7e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; pragma can be used to link an additional file with the project:</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; прагма может использоваться , чтобы связать дополнительный файл с проектом:</target>
        </trans-unit>
        <trans-unit id="c23f1774076a702902344c093a45ba7378aef4c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma can also take the special value &lt;code&gt;&quot;unknown&quot;&lt;/code&gt;. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the &lt;code&gt;base&lt;/code&gt; case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling &lt;code&gt;g.testMethod&lt;/code&gt; cannot be inferred statically, leading to compiler warnings. By using &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt;, the base method can be marked explicitly as having unknown lock level as well:</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; Прагма также может принять специальное значение &lt;code&gt;&quot;unknown&quot;&lt;/code&gt; . Это полезно в контексте диспетчеризации динамических методов. В следующем примере компилятор может вывести уровень блокировки 0 для &lt;code&gt;base&lt;/code&gt; случая. Однако один из перегруженных методов вызывает procvar, потенциально блокирующий. Таким образом, уровень блокировки вызова &lt;code&gt;g.testMethod&lt;/code&gt; не может быть определен статически, что приводит к предупреждениям компилятора. Используя &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt; , Базовый метод также может быть явно отмечен как имеющий неизвестный уровень блокировки:</target>
        </trans-unit>
        <trans-unit id="d06a4c92dabcb638ee9265fba0f2704858746025" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma takes a list of lock expressions &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; in order to support &lt;em&gt;multi lock&lt;/em&gt; statements. Why these are essential is explained in the &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;lock levels&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; Прагма принимает список блокировки выражений &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; в целях поддержки &lt;em&gt;мульти блокировки&lt;/em&gt; заявлений. Почему это важно, объясняется в разделе &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;уровней блокировки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aae9f3366ca8ab53657f45e7a28b3801e912c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</source>
          <target state="translated">Раздел &lt;code&gt;locks&lt;/code&gt; намеренно выглядит некрасиво, потому что он не имеет семантики времени выполнения и не должен использоваться напрямую! Его следует использовать только в шаблонах, которые также реализуют некоторую форму блокировки во время выполнения:</target>
        </trans-unit>
        <trans-unit id="9be3a7206cb8c2fa20f67cb405592a8272cb3e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; can can modify &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;pairExists&lt;/code&gt; values to change the mapping of the key or delete it from the table. When adding a value, make sure to set &lt;code&gt;pairExists&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; along with modifying the &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; может может изменить &lt;code&gt;val&lt;/code&gt; и &lt;code&gt;pairExists&lt;/code&gt; значения , чтобы изменить отображение ключа или удалить его из таблицы. При добавлении значения, убедитесь , что установил &lt;code&gt;pairExists&lt;/code&gt; в &lt;code&gt;true&lt;/code&gt; наряду с модификацией &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7db9956ef94890909f647902398c88b4235d0a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; takes 3 arguments:</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; принимает 3 аргумента:</target>
        </trans-unit>
        <trans-unit id="e2aecc3d04e1ba9c4da69fcea31f814e198a879c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. &lt;code&gt;resString&lt;/code&gt; will be truncated after that.</source>
          <target state="translated">Параметр &lt;code&gt;maxLength&lt;/code&gt; определяет максимальное количество символов, которое можно прочитать. &lt;code&gt;resString&lt;/code&gt; этого resString будет обрезана .</target>
        </trans-unit>
        <trans-unit id="5170e2edf536777dba0d2b9cf8223c8b3f59eaa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. The result is truncated after that.</source>
          <target state="translated">Параметр &lt;code&gt;maxLength&lt;/code&gt; определяет максимальное количество символов, которое можно прочитать. После этого результат обрезается.</target>
        </trans-unit>
        <trans-unit id="12a39cee8d46eadd14d3ca1ab6f3b43021968677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msgHandler&lt;/code&gt; is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass &lt;code&gt;nil&lt;/code&gt;, a default message handler will be used which writes the messages to the standard output.</source>
          <target state="translated">&lt;code&gt;msgHandler&lt;/code&gt; является процедура используется для сообщения об ошибках пользователя. Он будет вызываться с именем файла, строкой, столбцом и типом любой ошибки, обнаруженной во время синтаксического анализа. Если вы передадите &lt;code&gt;nil&lt;/code&gt; , будет использоваться обработчик сообщений по умолчанию, который записывает сообщения в стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="65292252dedeb03bdd4cf17027914a7ac8f246a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="translated">В &lt;code&gt;nim&lt;/code&gt; файлы исполняемых процессы конфигурации в следующих каталогах (в этом порядке, а позже файлы перезаписывать предыдущие настройки):</target>
        </trans-unit>
        <trans-unit id="2224eba7d666dacb73dc23680ccb160ec95313ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nnkElifBranch&lt;/code&gt; and &lt;code&gt;nnkElse&lt;/code&gt; parts may be missing.</source>
          <target state="translated">В &lt;code&gt;nnkElifBranch&lt;/code&gt; и &lt;code&gt;nnkElse&lt;/code&gt; часть может отсутствовать.</target>
        </trans-unit>
        <trans-unit id="32f208ade320ac5ce50ba89abb7bedd7b3b6454d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noDecl&lt;/code&gt; pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For example:</source>
          <target state="translated">&lt;code&gt;noDecl&lt;/code&gt; прагма может быть применена к почти любому символу (переменный, Proc, типа и т.д.) и иногда полезно для взаимодействия с C: Это говорит Nim , что он не должен генерировать заявление для символа в коде C. Например:</target>
        </trans-unit>
        <trans-unit id="80a70425379e8b6e57d7dbe189a2d199ed50d30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="translated">&lt;code&gt;noSideEffect&lt;/code&gt; прагма используются для обозначения процедурного / итератор , не имеет никаких побочных эффектов. Это означает, что процесс / итератор изменяет только те местоположения, которые доступны по его параметрам, а возвращаемое значение зависит только от аргументов. Если ни один из его параметров не имеют тип &lt;code&gt;var T&lt;/code&gt; или &lt;code&gt;ref T&lt;/code&gt; или &lt;code&gt;ptr T&lt;/code&gt; этого средства нет места не изменяются. Статическая ошибка отмечать процесс / итератор как не имеющий побочного эффекта, если компилятор не может это проверить.</target>
        </trans-unit>
        <trans-unit id="2f748ada5af7bcb027fed012bb10126b2e9ffdf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; pragma is used to mark a proc that never returns.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; Прагма используется для обозначения процедурного , что никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="6b1eff353ff0898aff7ebac46828c56901af2121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</source>
          <target state="translated">Параметр &lt;code&gt;operation&lt;/code&gt; должен быть выражением, которое использует переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; для каждого шага свертки. Поскольку это левая складка, для неассоциативных бинарных операций, таких как вычитание, подумайте, что последовательность чисел 1, 2 и 3 будет заключена в круглые скобки как (((1) - 2) - 3).</target>
        </trans-unit>
        <trans-unit id="cf888b143d2f4149c1d7d438f9d55fbfcce18b54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</source>
          <target state="translated">Параметр &lt;code&gt;operation&lt;/code&gt; должен быть выражением, которое использует переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; для каждого шага свертки. Поскольку это правая складка, для неассоциативных бинарных операций, таких как вычитание, подумайте, что последовательность чисел 1, 2 и 3 будет заключена в скобки как (1 - (2 - (3))).</target>
        </trans-unit>
        <trans-unit id="92b676ebe4f3f6e80af4461a2389327433cc03e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. The &lt;code&gt;first&lt;/code&gt; parameter is the start value (the first &lt;code&gt;a&lt;/code&gt;) and therefor defines the type of the result.</source>
          <target state="translated">Параметр &lt;code&gt;operation&lt;/code&gt; должен быть выражением, которое использует переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; для каждого шага свертки. &lt;code&gt;first&lt;/code&gt; параметр является начальным значением (первое &lt;code&gt;a&lt;/code&gt; ) , и для этого определяет тип результата.</target>
        </trans-unit>
        <trans-unit id="e2887106b7df244891547998dfdb11bc056b419b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optPeg&lt;/code&gt; template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global &lt;code&gt;gl&lt;/code&gt; which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</source>
          <target state="translated">&lt;code&gt;optPeg&lt;/code&gt; шаблон оптимизирует случай привязки конструктора с строковым литералом, так что образец будет проанализирован только один раз при запуске программы и сохраняется в глобальном &lt;code&gt;gl&lt;/code&gt; который затем повторно использовать. Эта оптимизация называется подъемом, потому что она сопоставима с классическим подъемом петли.</target>
        </trans-unit>
        <trans-unit id="79bf8ca22f95d3471dae0c1cf77a6259078a951a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; прагма может быть применена к любому &lt;code&gt;object&lt;/code&gt; типу. Это гарантирует, что поля объекта будут упакованы в памяти один за другим. Полезно хранить пакеты или сообщения из / в сетевые или аппаратные драйверы, а также для взаимодействия с C. Объединение упакованной прагмы с наследованием не определено, и ее не следует использовать с памятью GC (ref).</target>
        </trans-unit>
        <trans-unit id="b1e59de77052cfdd0f7bf673a9989ac1cea0fa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; массив должен начинаться с типом возвращаемого прока, а затем списком IdentDefs, устанавливающим Params.</target>
        </trans-unit>
        <trans-unit id="899485653059d1572f2f010810cdc7109336ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseJson&lt;/code&gt; procedure takes a string containing JSON and returns a &lt;code&gt;JsonNode&lt;/code&gt; object. This is an object variant and it is either a &lt;code&gt;JObject&lt;/code&gt;, &lt;code&gt;JArray&lt;/code&gt;, &lt;code&gt;JString&lt;/code&gt;, &lt;code&gt;JInt&lt;/code&gt;, &lt;code&gt;JFloat&lt;/code&gt;, &lt;code&gt;JBool&lt;/code&gt; or &lt;code&gt;JNull&lt;/code&gt;. You check the kind of this object variant by using the &lt;code&gt;kind&lt;/code&gt; accessor.</source>
          <target state="translated">Процедура &lt;code&gt;parseJson&lt;/code&gt; принимает строку, содержащую JSON, и возвращает объект &lt;code&gt;JsonNode&lt;/code&gt; . Это вариант объекта, и это либо &lt;code&gt;JObject&lt;/code&gt; , &lt;code&gt;JArray&lt;/code&gt; , &lt;code&gt;JString&lt;/code&gt; , &lt;code&gt;JInt&lt;/code&gt; , &lt;code&gt;JFloat&lt;/code&gt; , &lt;code&gt;JBool&lt;/code&gt; или &lt;code&gt;JNull&lt;/code&gt; . Вы проверяете тип этого варианта объекта, используя метод доступа &lt;code&gt;kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7500e4fe275240ec3e962a88617dbb075a1767f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.This is an example of how a configuration file may look like:</source>
          <target state="translated">Модуль &lt;code&gt;parsecfg&lt;/code&gt; реализует высокопроизводительный анализатор файла конфигурации. Синтаксис файла конфигурации аналогичен формату Windows &lt;code&gt;.ini&lt;/code&gt; , но гораздо более мощный, поскольку он не является анализатором на основе строк. Строковые литералы, необработанные строковые литералы и строковые литералы в тройных кавычках поддерживаются, как и в языке программирования Nim. Это пример того, как может выглядеть файл конфигурации:</target>
        </trans-unit>
        <trans-unit id="efd64c6ce1f02ecfbb0ad808048c92aad34275ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsesql&lt;/code&gt; module implements a high performance SQL file parser. It parses PostgreSQL syntax and the SQL ANSI standard.</source>
          <target state="translated">Модуль &lt;code&gt;parsesql&lt;/code&gt; реализует высокопроизводительный анализатор файлов SQL. Он анализирует синтаксис PostgreSQL и стандарт SQL ANSI.</target>
        </trans-unit>
        <trans-unit id="56d6940c534b2d5fc6c85df625e69961eee4fb6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passC&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like you would using the commandline switch &lt;code&gt;--passC&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passC&lt;/code&gt; прагма может быть использована для передачи дополнительных параметров компилятора C , как вы бы с помощью командной строки коммутатора &lt;code&gt;--passC&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="85c8b7f23a56b9ff37dc65de5153a5e24bf44f34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like you would using the commandline switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passL&lt;/code&gt; прагма может быть использована для передачи дополнительных параметров линкера , как вы бы с помощью командной строки коммутатора &lt;code&gt;--passL&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3f85014800afa36f3b960f11ad58d019170e999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function will not, on its own, return any events. Instead an appropriate &lt;code&gt;Future&lt;/code&gt; object will be completed. A &lt;code&gt;Future&lt;/code&gt; is a type which holds a value which is not yet available, but which &lt;em&gt;may&lt;/em&gt; be available in the future. You can check whether a future is finished by using the &lt;code&gt;finished&lt;/code&gt; function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the &lt;code&gt;failed&lt;/code&gt; function.</source>
          <target state="translated">Функция &lt;code&gt;poll&lt;/code&gt; сама по себе не возвращает никаких событий. Вместо этого будет завершен соответствующий объект &lt;code&gt;Future&lt;/code&gt; . &lt;code&gt;Future&lt;/code&gt; является типом , который имеет значение , которое не является еще доступно, но которые &lt;em&gt;могут&lt;/em&gt; быть доступны в будущем. Вы можете проверить , является ли будущим закончено, используя &lt;code&gt;finished&lt;/code&gt; функцию. Когда фьючерс завершен, это означает, что либо значение, которое оно хранит, теперь доступно, либо вместо этого содержится ошибка. Последняя ситуация возникает, когда операция завершения будущего завершается неудачно с исключением. Вы можете различить две ситуации с &lt;code&gt;failed&lt;/code&gt; функцией.</target>
        </trans-unit>
        <trans-unit id="27a7881313cd70143e77c7b574a9601952ffdf78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt; прагма может использоваться для пользовательских объявить определенные прагмы. Это полезно, потому что шаблоны и макросы Nim не влияют на прагмы. Прагмы, определяемые пользователем, находятся в другой области модуля, чем все другие символы. Их нельзя импортировать из модуля.</target>
        </trans-unit>
        <trans-unit id="93c3772886433492aac2ca1b4e999a7c892e1968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc will open the given filename and return a &lt;code&gt;Table&lt;/code&gt; from the &lt;a href=&quot;tables&quot;&gt;tables module&lt;/a&gt;. The parsing of the file is done (without much care for handling invalid data or corner cases) using the &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines proc from the strutils module&lt;/a&gt;. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</source>
          <target state="translated">Процесс &lt;code&gt;readCfgAtRuntime&lt;/code&gt; откроет заданное имя файла и вернет &lt;code&gt;Table&lt;/code&gt; из &lt;a href=&quot;tables&quot;&gt;модуля таблиц&lt;/a&gt; . Анализ файла выполняется (без особого внимания к недопустимым данным или угловым случаям) с использованием процедуры &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines из модуля Strutils&lt;/a&gt; . Есть много вещей, которые могут потерпеть неудачу; помните, цель состоит в том, чтобы объяснить, как выполнить этот запуск во время компиляции, а не как правильно реализовать схему DRM.</target>
        </trans-unit>
        <trans-unit id="a044506e0603eea131639eb9376dd6b5cddf2eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;register&lt;/code&gt;, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; прагма только для переменных. Он объявляет переменную как &lt;code&gt;register&lt;/code&gt; , давая компилятору подсказку, что переменная должна быть помещена в аппаратный регистр для более быстрого доступа. Компиляторы C обычно игнорируют это, и по уважительным причинам: часто они и без этого справляются лучше.</target>
        </trans-unit>
        <trans-unit id="8e697c97568aeba97089d02acbf3eabde37e8d56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialised with the type's default value. Note that referential data types will be &lt;code&gt;nil&lt;/code&gt; at the start of the procedure, and thus may require manual initialisation.</source>
          <target state="translated">&lt;code&gt;result&lt;/code&gt; переменный уже неявно объявляются в начале функции, так как объявить его снова &amp;laquo;результат вара&amp;raquo;, например, будет тень его с обычным переменным с тем же именем. Переменная результата также уже инициализирована значением типа по умолчанию. Обратите внимание, что ссылочные типы данных будут &lt;code&gt;nil&lt;/code&gt; в начале процедуры, и поэтому может потребоваться ручная инициализация.</target>
        </trans-unit>
        <trans-unit id="425fcae39b623db5726296d9c803046886d46240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement ends the execution of the current procedure. It is only allowed in procedures. If there is an &lt;code&gt;expr&lt;/code&gt;, this is syntactic sugar for:</source>
          <target state="translated">Оператор &lt;code&gt;return&lt;/code&gt; завершает выполнение текущей процедуры. Это разрешено только в процедурах. Если есть &lt;code&gt;expr&lt;/code&gt; , это синтаксический сахар для:</target>
        </trans-unit>
        <trans-unit id="22be64c3baaca8bed87e9a59bcd86debbab1977d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rst2tex&lt;/code&gt; command is invoked identically to &lt;code&gt;rst2html&lt;/code&gt;, but outputs a .tex file instead of .html.</source>
          <target state="translated">Команда &lt;code&gt;rst2tex&lt;/code&gt; вызывается так же, как и &lt;code&gt;rst2html&lt;/code&gt; , но выводит файл .tex вместо .html.</target>
        </trans-unit>
        <trans-unit id="ac1c0e0c744f03f7d86ed6c0e6ccc56589352680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scanp&lt;/code&gt; maps the grammar code into Nim code that performs the parsing. The parsing is performed with the help of 3 helper templates that that can be implemented for a custom type.</source>
          <target state="translated">&lt;code&gt;scanp&lt;/code&gt; отображает грамматику код в Nim код , который выполняет синтаксический анализ. Синтаксический анализ выполняется с помощью 3 вспомогательных шаблонов, которые можно реализовать для настраиваемого типа.</target>
        </trans-unit>
        <trans-unit id="23546f4b46dd4608db4ddbed2703e5c7ee24bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sets&lt;/code&gt; module implements an efficient &lt;span id=&quot;hash-set_1&quot;&gt;hash set&lt;/span&gt; and ordered hash set.</source>
          <target state="translated">Модуль &lt;code&gt;sets&lt;/code&gt; реализует эффективный &lt;span id=&quot;hash-set_1&quot;&gt;набор хешей&lt;/span&gt; и упорядоченный набор хешей.</target>
        </trans-unit>
        <trans-unit id="e59337587ab0c8780c2022ab5a55fc7fbccf5729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shallow&lt;/code&gt; pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</source>
          <target state="translated">&lt;code&gt;shallow&lt;/code&gt; Прагма влияет на семантику типа: Компилятор разрешается сделать неполную копию. Это может вызвать серьезные семантические проблемы и нарушить безопасность памяти! Однако это может значительно ускорить назначение, потому что семантика Nim требует глубокого копирования последовательностей и строк. Это может быть дорого, особенно если для построения древовидной структуры используются последовательности:</target>
        </trans-unit>
        <trans-unit id="5afbb3aa2be881123747a6ecc1beb41e7bc4bafa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode. An efficient string substitution operator &lt;code&gt;%&lt;/code&gt; for the string table is also provided.</source>
          <target state="translated">Модуль &lt;code&gt;strtabs&lt;/code&gt; реализует эффективную хеш-таблицу, которая отображает строки в строки. Поддерживает режимы с учетом регистра, без учета регистра и без учета стиля. Также предоставляется эффективный оператор подстановки строк &lt;code&gt;%&lt;/code&gt; для таблицы строк.</target>
        </trans-unit>
        <trans-unit id="1bdd9a9646780d7c99c91ba808857d4c209506e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sug&lt;/code&gt; Nimsuggest command performs a query about possible completion symbols at some point in the file.</source>
          <target state="translated">Команда &lt;code&gt;sug&lt;/code&gt; Nimsuggest выполняет запрос о возможных символах завершения в некоторой точке файла.</target>
        </trans-unit>
        <trans-unit id="0ad03b44ad275fed9c4ae098f471d2c17ea38253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; модуль содержит часть RTL , которая нуждается в поддержке со стороны компилятора магии (и материал , который должен быть в этом , потому что спецификация говорит так). Генератор кода C генерирует для него код C, как и любой другой модуль. Однако вызовы некоторых процедур, таких как &lt;code&gt;addInt&lt;/code&gt; , вставляются CCG. Поэтому модуль &lt;code&gt;magicsys&lt;/code&gt; содержит таблицу ( &lt;code&gt;compilerprocs&lt;/code&gt; ) со всеми символами, которые помечены как &lt;code&gt;compilerproc&lt;/code&gt; . &lt;code&gt;compilerprocs&lt;/code&gt; необходимы генератору кода. &lt;code&gt;magic&lt;/code&gt; прок не то же самое , как &lt;code&gt;compilerproc&lt;/code&gt; : а &lt;code&gt;magic&lt;/code&gt; является прок , что потребности компилятор магии для его семантической моконтроль, &lt;code&gt;compilerproc&lt;/code&gt; - это процесс, который используется генератором кода.</target>
        </trans-unit>
        <trans-unit id="62ca4c72a3bc5eec2d4c6c1463c200d704c694f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module defines the important &lt;a href=&quot;system#Natural&quot;&gt;Natural&lt;/a&gt; type as &lt;code&gt;range[0..high(int)]&lt;/code&gt; (&lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often &lt;strong&gt;unwise&lt;/strong&gt;: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's &lt;code&gt;Natural&lt;/code&gt; type helps to avoid this common programming error.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; модуль определяет важный &lt;a href=&quot;system#Natural&quot;&gt;природный&lt;/a&gt; тип, &lt;code&gt;range[0..high(int)]&lt;/code&gt; ( &lt;a href=&quot;system#high&quot;&gt;высокий&lt;/a&gt; возвращает значение максимального). Другие языки программирования могут предлагать использование целых чисел без знака для натуральных чисел. Часто это &lt;strong&gt;неразумно&lt;/strong&gt; : вам не нужна беззнаковая арифметика (которая повторяется) только потому, что числа не могут быть отрицательными. Тип Нима &lt;code&gt;Natural&lt;/code&gt; помогает избежать этой распространенной ошибки программирования.</target>
        </trans-unit>
        <trans-unit id="14dc5a05b6b245cb0be25c1bbcfb8cbd3c4b9fb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values. &lt;code&gt;Table&lt;/code&gt; is the usual hash table, &lt;code&gt;OrderedTable&lt;/code&gt; is like &lt;code&gt;Table&lt;/code&gt; but remembers insertion order and &lt;code&gt;CountTable&lt;/code&gt; is a mapping from a key to its number of occurrences. For consistency with every other data type in Nim these have &lt;strong&gt;value&lt;/strong&gt; semantics, this means that &lt;code&gt;=&lt;/code&gt; performs a copy of the hash table. For &lt;strong&gt;reference&lt;/strong&gt; semantics use the &lt;code&gt;Ref&lt;/code&gt; variant: &lt;code&gt;TableRef&lt;/code&gt;, &lt;code&gt;OrderedTableRef&lt;/code&gt;, &lt;code&gt;CountTableRef&lt;/code&gt;. To give an example, when &lt;em&gt;a&lt;/em&gt; is a Table, then &lt;em&gt;var b = a&lt;/em&gt; gives &lt;em&gt;b&lt;/em&gt; as a new independent table. b is initialised with the contents of &lt;em&gt;a&lt;/em&gt;. Changing &lt;em&gt;b&lt;/em&gt; does not affect &lt;em&gt;a&lt;/em&gt; and vice versa:</source>
          <target state="translated">Модуль &lt;code&gt;tables&lt;/code&gt; реализует варианты эффективной &lt;span id=&quot;hash-table_1&quot;&gt;хэш-таблицы&lt;/span&gt; (также часто называемой &lt;span id=&quot;dictionary_1&quot;&gt;словарем&lt;/span&gt; в других языках программирования), которая является отображением ключей в значения. &lt;code&gt;Table&lt;/code&gt; - это обычная хэш-таблица, &lt;code&gt;OrderedTable&lt;/code&gt; похожа на &lt;code&gt;Table&lt;/code&gt; , но запоминает порядок вставки, а &lt;code&gt;CountTable&lt;/code&gt; - это отображение ключа на количество его вхождений. Для согласованности с любым другим типом данных в Nim они имеют семантику &lt;strong&gt;значений&lt;/strong&gt; , это означает, что &lt;code&gt;=&lt;/code&gt; выполняет копию хеш-таблицы. Для &lt;strong&gt;эталонной&lt;/strong&gt; семантики используйте вариант &lt;code&gt;Ref&lt;/code&gt; : &lt;code&gt;TableRef&lt;/code&gt; , &lt;code&gt;OrderedTableRef&lt;/code&gt; , &lt;code&gt;CountTableRef&lt;/code&gt; . В качестве примера, когда &lt;em&gt;a&lt;/em&gt; является таблицей, тогда &lt;em&gt;var b = a&lt;/em&gt; дает &lt;em&gt;b&lt;/em&gt; как новую независимую таблицу. b инициализируется содержимым &lt;em&gt;a&lt;/em&gt; . Изменение &lt;em&gt;b&lt;/em&gt; не влияет на &lt;em&gt;a,&lt;/em&gt; и наоборот:</target>
        </trans-unit>
        <trans-unit id="56ae4324ab0abf484cafe035da581771b6411aae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; аргумент определяет максимальное количество миллисекунд функция будет заблокирована , если никаких событий не готовы. Указание тайм-аута &lt;code&gt;-1&lt;/code&gt; приводит к тому, что функция блокируется на неопределенный срок.</target>
        </trans-unit>
        <trans-unit id="d431b3c8673538504427a8309f89779fe91091e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely. All available events will be stored in &lt;code&gt;results&lt;/code&gt; array.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; аргумент определяет максимальное количество миллисекунд функция будет заблокирована , если никаких событий не готовы. Указание тайм-аута &lt;code&gt;-1&lt;/code&gt; приводит к тому, что функция блокируется на неопределенный срок. Все доступные события будут сохранены в массиве &lt;code&gt;results&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8dfd6109dacde12070a0913015e494bbf03c02d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; paremeter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="translated">Параметр &lt;code&gt;timeout&lt;/code&gt; указывает время в миллисекундах, в течение которого можно установить соединение с сервером.</target>
        </trans-unit>
        <trans-unit id="f2168e89685d500f34305fadd8a799ea9837bc0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; statement handles exceptions:</source>
          <target state="translated">Оператор &lt;code&gt;try&lt;/code&gt; обрабатывает исключения:</target>
        </trans-unit>
        <trans-unit id="ec7d06e028291e266b3574501a3bbca632d71df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unchecked&lt;/code&gt; pragma can be used to mark a named array as &lt;code&gt;unchecked&lt;/code&gt; meaning its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:</source>
          <target state="translated">&lt;code&gt;unchecked&lt;/code&gt; прагма может быть использована для обозначения именованного массива как &lt;code&gt;unchecked&lt;/code&gt; смысл его граница не проверяется. Это часто бывает полезно для реализации настраиваемых массивов гибкого размера. Дополнительно непроверенный массив переводится в массив C неопределенного размера:</target>
        </trans-unit>
        <trans-unit id="c94b76defb11868b1ae8894e3bb63b7d8285f9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;union&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It means all of the object's fields are overlaid in memory. This produces a &lt;code&gt;union&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt; in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; прагма может быть применен к любому &lt;code&gt;object&lt;/code&gt; типа. Это означает, что все поля объекта накладываются в память. Это создает &lt;code&gt;union&lt;/code&gt; вместо &lt;code&gt;struct&lt;/code&gt; в сгенерированном коде C / C ++. В этом случае объявление объекта не должно использовать наследование или какую-либо память с GC, но это в настоящее время не проверяется.</target>
        </trans-unit>
        <trans-unit id="5512388758e298c4c26f4a165b06bea0eae327c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unroll&lt;/code&gt; pragma can be used to tell the compiler that it should unroll a &lt;span id=&quot;for_2&quot;&gt;for&lt;/span&gt; or &lt;span id=&quot;while_1&quot;&gt;while&lt;/span&gt; loop for runtime efficiency:</source>
          <target state="translated">&lt;code&gt;unroll&lt;/code&gt; прагма может быть использована , чтобы сообщить компилятору , что он должен раскатать &lt;span id=&quot;for_2&quot;&gt;для&lt;/span&gt; или во &lt;span id=&quot;while_1&quot;&gt;время&lt;/span&gt; цикла для выполнения эффективности:</target>
        </trans-unit>
        <trans-unit id="965b5f72fd2186e49462ff5ed9043780f9e1cb58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; Nimsuggest command lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time.</source>
          <target state="translated">Команда &lt;code&gt;use&lt;/code&gt; Nimsuggest перечисляет все случаи использования символа в позиции. IDE могут использовать это, чтобы найти все места в файле, где используется символ, и предложить пользователю переименовать его во всех местах одновременно.</target>
        </trans-unit>
        <trans-unit id="bded0ec11c200a51a4e6475dbab31e4355ab12d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;using&lt;/code&gt; section uses the same indentation based grouping syntax as a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; section.</source>
          <target state="translated">Раздел &lt;code&gt;using&lt;/code&gt; использует тот же синтаксис группировки на основе отступов, что и раздел &lt;code&gt;var&lt;/code&gt; или &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf32e53e4609c5f4cde4e84fe336750a3c4a317a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;varargs&lt;/code&gt; pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:</source>
          <target state="translated">&lt;code&gt;varargs&lt;/code&gt; прагма может быть применена только к процедурам (и типам процедуры). Он сообщает Nim, что процедура может принимать переменное количество параметров после последнего указанного параметра. Строковые значения NIM будут автоматически преобразованы в строки C:</target>
        </trans-unit>
        <trans-unit id="fac4b56c328a62775e81f815e78bd26e59b4f4d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type denotes the absence of any type. Parameters of type &lt;code&gt;void&lt;/code&gt; are treated as non-existent, &lt;code&gt;void&lt;/code&gt; as a return type means that the procedure does not return a value:</source>
          <target state="translated">Тип &lt;code&gt;void&lt;/code&gt; означает отсутствие какого-либо типа. Параметры типа &lt;code&gt;void&lt;/code&gt; обрабатываются как несуществующие, &lt;code&gt;void&lt;/code&gt; как возвращаемый тип означает, что процедура не возвращает значение:</target>
        </trans-unit>
        <trans-unit id="d54f05d7805d3d20206628828c5a46105e33e791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is only valid for parameters and return types; other symbols cannot have the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;void&lt;/code&gt; действителен только для параметров и возвращаемых типов; другие символы не могут иметь тип &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d46bfe15b6bb594dd4d7b4f9ac119c89f36e71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is particularly useful for generic code:</source>
          <target state="translated">Тип &lt;code&gt;void&lt;/code&gt; особенно полезен для универсального кода:</target>
        </trans-unit>
        <trans-unit id="9d170c08bbf58e946b9ec8840f5556c7094bc2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volatile&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;volatile&lt;/code&gt;, whatever that means in C/C++ (its semantics are not well defined in C/C++).</source>
          <target state="translated">&lt;code&gt;volatile&lt;/code&gt; прагма только переменные. Он объявляет переменную как &lt;code&gt;volatile&lt;/code&gt; , что бы это ни значило в C / C ++ (ее семантика плохо определена в C / C ++).</target>
        </trans-unit>
        <trans-unit id="45f140f4f01fe1213690fb05d3fda0c6d1fe6699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warning&lt;/code&gt; pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</source>
          <target state="translated">&lt;code&gt;warning&lt;/code&gt; Прагма используется , чтобы сделать вывод компилятора предупреждающее сообщение с указанным содержанием. Компиляция продолжается после предупреждения.</target>
        </trans-unit>
        <trans-unit id="9509e80840bb0f1df308f8032f3bb053eea5da51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement enables conditional compilation techniques. As a special syntactic extension, the &lt;code&gt;when&lt;/code&gt; construct is also available within &lt;code&gt;object&lt;/code&gt; definitions.</source>
          <target state="translated">Оператор &lt;code&gt;when&lt;/code&gt; включает методы условной компиляции. В качестве специального синтаксического расширения конструкция &lt;code&gt;when&lt;/code&gt; также доступна в определениях &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3923b0ea614af5c8a6acc8fd050a8e60d9177947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement with some exceptions:</source>
          <target state="translated">Оператор &lt;code&gt;when&lt;/code&gt; практически идентичен оператору &lt;code&gt;if&lt;/code&gt; за некоторыми исключениями:</target>
        </trans-unit>
        <trans-unit id="238308d0a093ac5ec92a1fb377ed60fb2c7f5746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement, but with these differences:</source>
          <target state="translated">Оператор &lt;code&gt;when&lt;/code&gt; почти идентичен оператору &lt;code&gt;if&lt;/code&gt; , но с некоторыми отличиями:</target>
        </trans-unit>
        <trans-unit id="57d001b8d7b1eb7efa8f75e5bfa898d7953ff6a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is useful for writing platform specific code, similar to the &lt;code&gt;#ifdef&lt;/code&gt; construct in the C programming language.</source>
          <target state="translated">Оператор &lt;code&gt;when&lt;/code&gt; полезен для написания кода для конкретной платформы, подобно конструкции &lt;code&gt;#ifdef&lt;/code&gt; в языке программирования C.</target>
        </trans-unit>
        <trans-unit id="3ed2216fef6cefddc51b5dfc1501acbc63519752" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;em&gt;implicit block&lt;/em&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; оператор не выполняется , пока &lt;code&gt;expr&lt;/code&gt; оценивается как ложное. Бесконечные циклы - это не ошибка. Операторы &lt;code&gt;while&lt;/code&gt; открывают &lt;em&gt;неявный блок&lt;/em&gt; , поэтому их можно оставить с оператором &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77e5c5d6d627aa54296b3870cd7922006782e15e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="translated">Оператор &lt;code&gt;yield&lt;/code&gt; используется вместо оператора &lt;code&gt;return&lt;/code&gt; в итераторах. Действует только в итераторах. Выполнение возвращается в тело цикла for, который вызвал итератор. Yield не завершает итерационный процесс, но выполнение возвращается итератору, если начинается следующая итерация. См. Раздел об итераторах ( &lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Итераторы и оператор&lt;/a&gt; for) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="0694f678da714119225cabbbd0654c71587ddfa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{}&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; Оператор</target>
        </trans-unit>
        <trans-unit id="1201154eaa53a6a08247d7a1f878b08cbcc71415" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; оператор</target>
        </trans-unit>
        <trans-unit id="7b0bf905e381cc04d13b47c0b5b03f3639bd78ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator if used as infix operator creates an ordered choice:</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; оператор, если он используется как инфиксный оператор, создает упорядоченный выбор:</target>
        </trans-unit>
        <trans-unit id="64228bf590558ad4fc967418a6eab8c95681462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; symbols are used to mark alternatives and have the lowest precedence. &lt;code&gt;/&lt;/code&gt; is the ordered choice that requires the parser to try the alternatives in the given order. &lt;code&gt;/&lt;/code&gt; is often used to ensure the grammar is not ambiguous.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; , символы &lt;code&gt;/&lt;/code&gt; используются для обозначения альтернатив и имеют самый низкий приоритет. &lt;code&gt;/&lt;/code&gt; - это упорядоченный выбор, который требует, чтобы синтаксический анализатор пробовал альтернативы в заданном порядке. &lt;code&gt;/&lt;/code&gt; часто используется, чтобы гарантировать отсутствие двусмысленности в грамматике.</target>
        </trans-unit>
        <trans-unit id="c06e1a048dfb09f151ad6af04b4cc2cbab7ce373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; Оператор</target>
        </trans-unit>
        <trans-unit id="9856d0d900d79fc607cd6848700f2bafec366603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator is the &lt;strong&gt;not&lt;/strong&gt; operator in patterns:</source>
          <target state="translated">Оператор &lt;code&gt;~&lt;/code&gt; является оператором &lt;strong&gt;not&lt;/strong&gt; в шаблонах:</target>
        </trans-unit>
        <trans-unit id="6edb4e4054e37bf60483392193b7ad3441d67ddf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for count tables.</source>
          <target state="translated">Оператор &lt;em&gt;$&lt;/em&gt; для счетных таблиц.</target>
        </trans-unit>
        <trans-unit id="8c6a817abf878b263302b528ba9eba150a0b5e4f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for hash tables.</source>
          <target state="translated">Оператор &lt;em&gt;$&lt;/em&gt; для хеш-таблиц.</target>
        </trans-unit>
        <trans-unit id="21210e15f2beb096edd05ccec6e1b9573b666a36" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for int sets.</source>
          <target state="translated">Оператор &lt;em&gt;$&lt;/em&gt; для наборов int.</target>
        </trans-unit>
        <trans-unit id="6d5e46312d92579508d6c9ed937fbbd4c1df3a3a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for ordered hash tables.</source>
          <target state="translated">Оператор &lt;em&gt;$&lt;/em&gt; для упорядоченных хеш-таблиц.</target>
        </trans-unit>
        <trans-unit id="9eea65ebe90881c4414538083cd97f3fc9aef8d6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for string tables.</source>
          <target state="translated">Оператор &lt;em&gt;$&lt;/em&gt; для строковых таблиц.</target>
        </trans-unit>
        <trans-unit id="1a84d3734edf137dc85d74d27bc8c4eec4e9620e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;%&lt;/em&gt; operator for string tables.</source>
          <target state="translated">Оператор &lt;em&gt;%&lt;/em&gt; для строковых таблиц.</target>
        </trans-unit>
        <trans-unit id="42fb88e76a89671075d6dad00a270f10b9b6f1ed" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для счетных таблиц. Возвращает &lt;code&gt;true&lt;/code&gt; если обе таблицы содержат одинаковые ключи с одинаковым счетчиком. Порядок вставки не имеет значения.</target>
        </trans-unit>
        <trans-unit id="f3c437f641f31ef6a98cac2a696fbef8b9e8bc19" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для счетных таблиц. Возвращает &lt;code&gt;true&lt;/code&gt; если либо обе таблицы равны &lt;code&gt;nil&lt;/code&gt; либо ни одна из них не равна &lt;code&gt;nil&lt;/code&gt; и обе содержат одинаковые ключи с одинаковым счетчиком. Порядок вставки не имеет значения.</target>
        </trans-unit>
        <trans-unit id="65caa9363c9c4bee80ce44c109b6388268b58a9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для хеш-таблиц. Возвращает &lt;code&gt;true&lt;/code&gt; если либо обе таблицы равны &lt;code&gt;nil&lt;/code&gt; либо ни одна из них не равна &lt;code&gt;nil&lt;/code&gt; и содержимое обеих таблиц содержит одинаковые пары ключ-значение. Порядок вставки не имеет значения.</target>
        </trans-unit>
        <trans-unit id="ecfa374c36b6bffd18a0ef6cce629ecea93ec8e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для хеш-таблиц. Возвращает &lt;code&gt;true&lt;/code&gt; , если содержимое обеих таблиц содержит одинаковые пары ключ-значение. Порядок вставки не имеет значения.</target>
        </trans-unit>
        <trans-unit id="eadaefcf55fb6edbf3abdf3db98fb0843d048aaf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff both the content and the order are equal.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для упорядоченных хеш-таблиц. Возвращает true, если и содержимое, и порядок равны.</target>
        </trans-unit>
        <trans-unit id="8914eb62f26e75052b45d57bea0bc85c1277e2e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для упорядоченных хеш-таблиц. Возвращает истину, если обе таблицы равны &lt;code&gt;nil&lt;/code&gt; или ни одна из них не равна &lt;code&gt;nil&lt;/code&gt; а содержимое и порядок обеих таблиц равны.</target>
        </trans-unit>
        <trans-unit id="4d36127144c35e196b74a69bb0dd19d7650ca3b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Nim compiler&lt;/em&gt; also has support for RST (reStructuredText) files with the &lt;code&gt;rst2html&lt;/code&gt; and &lt;code&gt;rst2tex&lt;/code&gt; commands. Documents like this one are initially written in a dialect of RST which adds support for nim sourcecode highlighting with the &lt;code&gt;.. code-block:: nim&lt;/code&gt; prefix. &lt;code&gt;code-block&lt;/code&gt; also supports highlighting of C++ and some other c-like languages.</source>
          <target state="translated">&lt;em&gt;Компилятор Nim&lt;/em&gt; также имеет поддержку файлов RST (ReStructuredText) с &lt;code&gt;rst2html&lt;/code&gt; и &lt;code&gt;rst2tex&lt;/code&gt; команд. Документы, подобные этому, изначально написаны на диалекте RST, который добавляет поддержку выделения исходного &lt;code&gt;.. code-block:: nim&lt;/code&gt; префикса .. code-block :: nim . &lt;code&gt;code-block&lt;/code&gt; также поддерживает выделение C ++ и некоторых других c-подобных языков.</target>
        </trans-unit>
        <trans-unit id="64b9df197c2acb72edd07ad4070f99730861f242" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;case expression&lt;/em&gt; is again very similar to the case statement:</source>
          <target state="translated">&lt;em&gt;Выражение случая&lt;/em&gt; опять очень похоже на саз:</target>
        </trans-unit>
        <trans-unit id="dd1e3926f728dc35f509a5bf9e5f4dad82e16ce3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;character type&lt;/em&gt; is called &lt;code&gt;char&lt;/code&gt;. Its size is always one byte, so it cannot represent most UTF-8 characters; but it &lt;em&gt;can&lt;/em&gt; represent one of the bytes that makes up a multi-byte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes.</source>
          <target state="translated">Тип &lt;em&gt;символа&lt;/em&gt; называется &lt;code&gt;char&lt;/code&gt; . Его размер всегда составляет один байт, поэтому он не может отображать большинство символов UTF-8; но он &lt;em&gt;может&lt;/em&gt; представлять один из байтов, составляющих многобайтовый символ UTF-8. Причина этого - эффективность: в подавляющем большинстве случаев использования результирующие программы по-прежнему будут правильно обрабатывать UTF-8, поскольку UTF-8 был специально разработан для этого. Символьные литералы заключаются в одинарные кавычки.</target>
        </trans-unit>
        <trans-unit id="71d5db35b5bd11b522d53f5b565bc1dd579987f8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;em&gt;filename&lt;/em&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overriden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="translated">Параметр &lt;em&gt;filename&lt;/em&gt; будет использоваться для сообщения об ошибках и создания гиперссылок индекса на файл, но вы можете передать здесь пустую строку, если вы анализируете поток в памяти. Если &lt;em&gt;имя файла&lt;/em&gt; оканчивается расширением &lt;code&gt;.nim&lt;/code&gt; , заголовок документа будет установлен по умолчанию как &lt;code&gt;Module filename&lt;/code&gt; . Этот заголовок по умолчанию может быть заменен встроенным заголовком, но он помогает уточнить сгенерированный индекс, если заголовок не найден.</target>
        </trans-unit>
        <trans-unit id="edbaae9f7ab66a5f097fb8ddd27afa919150b133" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handlers&lt;/em&gt; parameter consists of code blocks for &lt;em&gt;PegKinds&lt;/em&gt;, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An &lt;em&gt;enter&lt;/em&gt; handler can access the specific PEG AST node being matched as &lt;em&gt;p&lt;/em&gt;, the entire parsed string as &lt;em&gt;s&lt;/em&gt; and the position of the matched text segment in &lt;em&gt;s&lt;/em&gt; as &lt;em&gt;start&lt;/em&gt;. A &lt;em&gt;leave&lt;/em&gt; handler can access &lt;em&gt;p&lt;/em&gt;, &lt;em&gt;s&lt;/em&gt;, &lt;em&gt;start&lt;/em&gt; and also the length of the matched text segment as &lt;em&gt;length&lt;/em&gt;. For an unsuccessful match, the &lt;em&gt;enter&lt;/em&gt; and &lt;em&gt;leave&lt;/em&gt; handlers will be executed, with &lt;em&gt;length&lt;/em&gt; set to -1.</source>
          <target state="translated">&lt;em&gt;Обработчиков&lt;/em&gt; параметров состоит из кодовых блоков для &lt;em&gt;PegKinds&lt;/em&gt; , которые определяют грамматические элементы , представляющие интерес. Каждый блок может содержать код обработчика, который будет выполняться, когда синтаксический анализатор входит и оставляет текст, соответствующий элементу грамматики. &lt;em&gt;Ввести&lt;/em&gt; обработчик может получить доступ к конкретному ПЭГУ АСТОГО узла, совпадающий , как &lt;em&gt;р&lt;/em&gt; , вся анализируемой строка как &lt;em&gt;с&lt;/em&gt; и положением согласованного текстового сегмента в &lt;em&gt;сек&lt;/em&gt; , как &lt;em&gt;начала&lt;/em&gt; . &lt;em&gt;Отпуск&lt;/em&gt; обработчика доступа может &lt;em&gt;р&lt;/em&gt; , &lt;em&gt;с&lt;/em&gt; , &lt;em&gt;начать&lt;/em&gt; , а также длину согласованного текстового сегмента в качестве &lt;em&gt;длины&lt;/em&gt; . При неудачном матче&lt;em&gt;&lt;/em&gt;Обработчики &lt;em&gt;входа&lt;/em&gt; и &lt;em&gt;выхода&lt;/em&gt; будут выполнены с &lt;em&gt;длиной,&lt;/em&gt; равной -1.</target>
        </trans-unit>
        <trans-unit id="64386956b3c73085d6328c9f138a7d8052469400" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;id&lt;/em&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;em&gt;id&lt;/em&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="translated">К &lt;em&gt;идентификатору&lt;/em&gt; будет добавлен символ решетки, только если его длина не равна нулю, в противном случае конкретная привязка не будет сгенерирована. В общем, вы должны передавать только пустое значение &lt;em&gt;id&lt;/em&gt; для заголовка автономных первых документов (они являются специальными для процедуры &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes ()&lt;/a&gt; , дополнительную информацию см. В разделе &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Формат файла индекса (idx)&lt;/a&gt; ). В отличие от других терминов указателя, записи заголовка вставляются в начало накопленного буфера для поддержания логического порядка записей.</target>
        </trans-unit>
        <trans-unit id="e7bcea88e9b3afcedaf4fe86c7903aad3e98b4fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">Параметр &lt;em&gt;initialSize&lt;/em&gt; должен быть степенью двойки. Вы можете использовать &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo ()&lt;/a&gt; или &lt;em&gt;rightSize,&lt;/em&gt; чтобы гарантировать это во время выполнения. Все переменные набора должны быть инициализированы перед использованием с другими процедурами из этого модуля, за исключением &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt; и &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e595993e5c058be0e84afb91215737952ff662f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">Параметр &lt;em&gt;initialSize&lt;/em&gt; должен быть степенью двойки. Вы можете использовать &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo ()&lt;/a&gt; или &lt;em&gt;rightSize,&lt;/em&gt; чтобы гарантировать это во время выполнения. Все переменные набора должны быть инициализированы перед использованием с другими процедурами из этого модуля, за исключением &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt; и &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c214c728d4121535b4b7a34f396ea719117cb4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</source>
          <target state="translated">Область &lt;em&gt;действия&lt;/em&gt; переменной, объявленной в части объявления блока, действительна с момента объявления до конца блока. Если блок содержит второй блок, в котором повторно объявляется идентификатор, то внутри этого блока будет действительным второе объявление. После выхода из внутреннего блока первое объявление снова становится действительным. Идентификатор не может быть переопределен в том же блоке, за исключением случаев, когда он действителен для целей перегрузки процедуры или итератора.</target>
        </trans-unit>
        <trans-unit id="31957fd1dab3297b9650262294cc9e647a86c978" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sloppy interfacing&lt;/em&gt; example uses &lt;code&gt;.emit&lt;/code&gt; to produce &lt;code&gt;using namespace&lt;/code&gt; declarations. It is usually much better to instead refer to the imported name via the &lt;code&gt;namespace::identifier&lt;/code&gt; notation:</source>
          <target state="translated">В примере с &lt;em&gt;небрежным интерфейсом &lt;/em&gt; &lt;code&gt;.emit&lt;/code&gt; используется для создания объявлений &lt;code&gt;using namespace&lt;/code&gt; . Обычно гораздо лучше вместо этого ссылаться на импортированное имя через нотацию &lt;code&gt;namespace::identifier&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ea5cdc44b88b5634c8f912a49a8f74da86b5d738" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt; character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">Символ &lt;span id=&quot;backslash_1&quot;&gt;обратной косой&lt;/span&gt; черты имеет несколько применений. Во-первых, если за ним следует не буквенно-цифровой символ, он удаляет любое специальное значение, которое может иметь этот символ. Такое использование обратной косой черты в качестве escape-символа применяется как внутри, так и за пределами классов символов.</target>
        </trans-unit>
        <trans-unit id="b06b473e1ee1762f517fd6999bd07dece354bc29" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;boot_1&quot;&gt;boot&lt;/span&gt; command bootstraps the compiler, and it accepts different options:</source>
          <target state="translated">Команда &lt;span id=&quot;boot_1&quot;&gt;загрузки загружает&lt;/span&gt; компилятор и принимает различные параметры:</target>
        </trans-unit>
        <trans-unit id="fe5c377ca282280b9863d88ec5a8f55bcf5f2255" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">Команда &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; создает &lt;span id=&quot;csource_1&quot;&gt;исходные коды&lt;/span&gt; C для установки. Он принимает те же параметры, которые вы передали бы команде &lt;a href=&quot;#boot-command&quot;&gt;загрузки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="debca29a7a9e313a0d076cc0661ed876f0ad8d69" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; statement is an abstract mechanism to iterate over the elements of a container. It relies on an &lt;span id=&quot;iterator_1&quot;&gt;iterator&lt;/span&gt; to do so. Like &lt;code&gt;while&lt;/code&gt; statements, &lt;code&gt;for&lt;/code&gt; statements open an &lt;span id=&quot;implicit-block_1&quot;&gt;implicit block&lt;/span&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">Оператор &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; - это абстрактный механизм для перебора элементов контейнера. Для этого он полагается на &lt;span id=&quot;iterator_1&quot;&gt;итератор&lt;/span&gt; . Как &lt;code&gt;while&lt;/code&gt; операторы while, операторы &lt;code&gt;for&lt;/code&gt; открывают &lt;span id=&quot;implicit-block_1&quot;&gt;неявный блок&lt;/span&gt; , поэтому их можно оставить с оператором &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d9382afc1ab3b35fd9c7113d6add76969213268" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. &lt;code&gt;spawn&lt;/code&gt; is usually the preferable method. Either way the invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="translated">&lt;span id=&quot;gcsafe_1&quot;&gt;Gcsafe&lt;/span&gt; аннотация может быть использована для обозначения процедурного быть gcsafe, в противном случае этого свойство выводится компилятором. Обратите внимание, что &lt;code&gt;noSideEffect&lt;/code&gt; подразумевает &lt;code&gt;gcsafe&lt;/code&gt; . Единственный способ создать поток - через &lt;code&gt;spawn&lt;/code&gt; или &lt;code&gt;createThread&lt;/code&gt; . &lt;code&gt;spawn&lt;/code&gt; обычно является предпочтительным методом. В любом случае вызываемая процедура не должна использовать параметры &lt;code&gt;var&lt;/code&gt; ,и ни один из ее параметров не должен содержать тип &lt;code&gt;ref&lt;/code&gt; или &lt;code&gt;closure&lt;/code&gt; . Это приводит к &lt;em&gt;запрету совместного использования кучи&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="91164a5c7f6c7e859655b6b6af4545842eee07d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; option enables special compilation mode where changes in the code can be applied automatically to a running program. The code reloading happens at the granularity of an individual module. When a module is reloaded, Nim will preserve the state of all global variables which are initialized with a standard variable declaration in the code. All other top level code will be executed repeatedly on each reload. If you want to prevent this behavior, you can guard a block of code with the &lt;code&gt;once&lt;/code&gt; construct:</source>
          <target state="translated">Параметр &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; включает специальный режим компиляции, в котором изменения в коде могут автоматически применяться к работающей программе. Перезагрузка кода происходит на уровне детализации отдельного модуля. Когда модуль перезагружается, Nim сохранит состояние всех глобальных переменных, которые инициализируются стандартным объявлением переменных в коде. Весь другой код верхнего уровня будет выполняться повторно при каждой перезагрузке. Если вы хотите , чтобы предотвратить такое поведение, вы можете защитить блок кода с &lt;code&gt;once&lt;/code&gt; конструкцией:</target>
        </trans-unit>
        <trans-unit id="57a3663a206275ec6b24a0d4f5e454d389b9f45f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. The word &lt;em&gt;koch&lt;/em&gt; means &lt;em&gt;cook&lt;/em&gt; in German. &lt;code&gt;koch&lt;/code&gt; is used mainly to build the Nim compiler, but it can also be used for other tasks. This document describes the supported commands and their options.</source>
          <target state="translated">Программа &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; - это сценарий обслуживания Нима. Это замена для сценариев make и оболочки с тем преимуществом, что он намного более переносим. Слово &lt;em&gt;koch в&lt;/em&gt; переводе с немецкого означает &lt;em&gt;готовить&lt;/em&gt; . &lt;code&gt;koch&lt;/code&gt; используется в основном для сборки компилятора Nim, но его также можно использовать для других задач. В этом документе описаны поддерживаемые команды и их параметры.</target>
        </trans-unit>
        <trans-unit id="a53571f24b323d265b8569c9fb2bedae1b76e3af" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="translated">&lt;span id=&quot;nimcache_1&quot;&gt;Nimcache&lt;/span&gt; каталог создается во время компиляции и будет держать либо временные или окончательные файлы в зависимости от вашей цели бэкэнда. Имя по умолчанию для каталога зависит от используемой серверной части и вашей ОС, но вы можете использовать &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;компилятора &lt;/a&gt;--nimcache, чтобы изменить его.</target>
        </trans-unit>
        <trans-unit id="54a1e48458551511422bbb61f22c648f60734046" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;parameter-constraint_1&quot;&gt;parameter constraint&lt;/span&gt; expression can use the operators &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;&amp;amp;&lt;/code&gt; (and) and &lt;code&gt;~&lt;/code&gt; (not) and the following predicates:</source>
          <target state="translated">В выражении &lt;span id=&quot;parameter-constraint_1&quot;&gt;ограничения параметра&lt;/span&gt; можно использовать операторы &lt;code&gt;|&lt;/code&gt; (или), &lt;code&gt;&amp;amp;&lt;/code&gt; (и) и &lt;code&gt;~&lt;/code&gt; (не) и следующие предикаты:</target>
        </trans-unit>
        <trans-unit id="cfa661ac5acf3812a9603d558f0cc5e9d16b725f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;pushslashpop_1&quot;&gt;push/pop&lt;/span&gt; pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</source>
          <target state="translated">В &lt;span id=&quot;pushslashpop_1&quot;&gt;нажимных / попе&lt;/span&gt; псевдокомментарии очень похож на директивы опции, но используется для переопределения настройки временно. Пример:</target>
        </trans-unit>
        <trans-unit id="87bbfad905a0fc037232436963bb95bf7f76d077" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator .. takes precedence over other tokens that contain a dot: {..} are the three tokens {, .., } and not the two tokens {., .}.</source>
          <target state="translated">Оператор &lt;span id=&quot;slice_1&quot;&gt;среза&lt;/span&gt; .. имеет приоритет над другими токенами, содержащими точку: {..} - это три токена {, ..,}, а не два токена {.,.}.</target>
        </trans-unit>
        <trans-unit id="5af8373b9460197079b99667c8fea57ecbb59884" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">Оператор &lt;span id=&quot;substitution_1&quot;&gt;подстановки&lt;/span&gt; выполняет подстановку строк в &lt;em&gt;formatstr&lt;/em&gt; и возвращает измененный &lt;em&gt;formatstr&lt;/em&gt; . Это часто называют &lt;span id=&quot;string-interpolation_1&quot;&gt;строковой интерполяцией&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="6513fa7dcefd8fcc828e499152082db4c572537e" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_2&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_2&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">Оператор &lt;span id=&quot;substitution_2&quot;&gt;подстановки&lt;/span&gt; выполняет подстановку строк в &lt;em&gt;formatstr&lt;/em&gt; и возвращает измененный &lt;em&gt;formatstr&lt;/em&gt; . Это часто называют &lt;span id=&quot;string-interpolation_2&quot;&gt;строковой интерполяцией&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="6f1b458b1b19b189d8e65f1668a50897e0a48f44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;tests/testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="translated">Команду &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; также можно вызывать с помощью псевдонимов &lt;code&gt;tests&lt;/code&gt; . Эта команда скомпилирует и запустит &lt;code&gt;tests/testament/tester.nim&lt;/code&gt; , который является основным драйвером набора тестов Nim. Вы можете передать параметры &lt;code&gt;test&lt;/code&gt; команде, они будут отправлены тестеру. Смотрите его исходный код для доступных опций.</target>
        </trans-unit>
        <trans-unit id="b2c15981e5e4830750c05aa5cb51e33019a0e2a4" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;web_1&quot;&gt;web&lt;/span&gt; command converts the documentation in the &lt;code&gt;doc&lt;/code&gt; directory from rst to HTML. It also repeats the same operation but places the result in the &lt;code&gt;web/upload&lt;/code&gt; which can be used to update the website at &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;.</source>
          <target state="translated">&lt;span id=&quot;web_1&quot;&gt;Веб&lt;/span&gt; - команда преобразует документы в &lt;code&gt;doc&lt;/code&gt; каталог от первого к HTML. Он также повторяет ту же операцию, но помещает результат в &lt;code&gt;web/upload&lt;/code&gt; , который можно использовать для обновления веб-сайта по адресу &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dea7302995c2fe043006be5d95cc1952f9177148" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="translated">Параметра &lt;strong&gt;FILE&lt;/strong&gt; достаточно для статического анализа, но IDE, как правило, имеют &lt;em&gt;несохраненные буферы, в&lt;/em&gt; которых пользователь все еще может печатать строку. В таких ситуациях IDE может сохранить текущее содержимое во временный файл, а затем использовать переключатель &lt;code&gt;--trackDirty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c27b669448c36c816470b9ecb178842de255828a" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action.</source>
          <target state="translated">API разработан, чтобы быть &lt;strong&gt;простым в использовании&lt;/strong&gt; и последовательным. Простота использования измеряется количеством вызовов для достижения конкретного действия высокого уровня.</target>
        </trans-unit>
        <trans-unit id="c73b5df5c651cfdc62f3ab0cb7d427e139e5b455" translate="yes" xml:space="preserve">
          <source>The API should embrace the AST diffing notion: See the module &lt;code&gt;macrocache&lt;/code&gt; for the final details.</source>
          <target state="translated">API должен охватывать понятие &lt;code&gt;macrocache&lt;/code&gt; AST: см. Макрокэш модуля для окончательных деталей.</target>
        </trans-unit>
        <trans-unit id="340251b1d9f2a716c84b7e7a92de21c0f5e2b332" translate="yes" xml:space="preserve">
          <source>The AST in Nim</source>
          <target state="translated">АСТ в Ним</target>
        </trans-unit>
        <trans-unit id="d9e072d30e620c5ec90f1b3cdaf9f07a7689786e" translate="yes" xml:space="preserve">
          <source>The C like backends will place their temporary &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files in the &lt;code&gt;nimcache&lt;/code&gt; directory. The naming of these files follows the pattern &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;nimcache&lt;/code&gt; подобные C, помещают свои временные файлы &lt;code&gt;.c&lt;/code&gt; , &lt;code&gt;.cpp&lt;/code&gt; или &lt;code&gt;.m&lt;/code&gt; в каталог nimcache . Именование этих файлов соответствует шаблону &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7c1c75d070fdb7254d04b1bbedfea64bf072a3ea" translate="yes" xml:space="preserve">
          <source>The C like targets</source>
          <target state="translated">С как мишени</target>
        </trans-unit>
        <trans-unit id="5d8208a944d082cd05346b5083e300cf7433b341" translate="yes" xml:space="preserve">
          <source>The CellSet data structure</source>
          <target state="translated">Структура данных CellSet</target>
        </trans-unit>
        <trans-unit id="6ed4e2479ba02a41f340ac876f235bcda842872e" translate="yes" xml:space="preserve">
          <source>The DevkitPro setup must be the same as the default with their new installer &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;here for Mac/Linux&lt;/a&gt; or &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;here for Windows&lt;/a&gt;.</source>
          <target state="translated">Настройка DevkitPro должна быть такой же, как по умолчанию, с их новым установщиком &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;здесь для Mac / Linux&lt;/a&gt; или &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;здесь для Windows&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd5b1c0ab5a21a3d6f5ddcb44893f272563ba0a" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversation leads to undefined behaviour.</source>
          <target state="translated">&lt;code&gt;TCellSet&lt;/code&gt; зависит от чрезвычайно эффективной структуры данных для хранения набора указателей - в исходном коде это называется TCellSet . Вставка, удаление и поиск выполняются в постоянное время. Однако изменение &lt;code&gt;TCellSet&lt;/code&gt; во время обхода приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="ebc02645609d7f52fae8aedf8c4c8bf347d64250" translate="yes" xml:space="preserve">
          <source>The GC is only triggered in a memory allocation operation. It is not triggered by some timer and does not run in a background thread.</source>
          <target state="translated">ГХ запускается только в процессе выделения памяти.Он не срабатывает по какому-либо таймеру и не запускается в фоновом потоке.</target>
        </trans-unit>
        <trans-unit id="05815d59fb042a842f4d63bb24b3e64b07d2dee5" translate="yes" xml:space="preserve">
          <source>The GC's way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="translated">Метод GC для измерения времени использует (см. &lt;code&gt;lib/system/timers.nim&lt;/code&gt; в lib / system / timers.nim ):</target>
        </trans-unit>
        <trans-unit id="ea7df501b4189771d55e6aaa674cc650d42d3aa3" translate="yes" xml:space="preserve">
          <source>The Garbage Collector</source>
          <target state="translated">Мусорщик</target>
        </trans-unit>
        <trans-unit id="dcad958e2a5300a34865aa11366e580e6c78767e" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;, &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;, &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;, &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;, and &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; base class.</source>
          <target state="translated">Исключения IEEE либо игнорируются во время выполнения, либо сопоставляются с исключениями Nim: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt; , &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt; , &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt; , &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt; и &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt; . Эти исключения наследуются от базового класса &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="e93e53c09fc19a935940b71534b7f3d3ef1586f6" translate="yes" xml:space="preserve">
          <source>The IEEE standard defines five types of floating-point exceptions:</source>
          <target state="translated">Стандарт IEEE определяет пять типов исключений с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="3a986d0cb1d3a266cf50f1d33d468ab68b62b7e0" translate="yes" xml:space="preserve">
          <source>The JS target is actually &lt;code&gt;node.js&lt;/code&gt;.</source>
          <target state="translated">Мишень JS на самом деле &lt;code&gt;node.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6137eefe505bc68232cc4d0ce7515cc44adc09e" translate="yes" xml:space="preserve">
          <source>The JavaScript target</source>
          <target state="translated">Цель JavaScript</target>
        </trans-unit>
        <trans-unit id="4cbe26954e5cc8b26988852f379eeeef2ae7a95f" translate="yes" xml:space="preserve">
          <source>The JavaScript target doesn't have any further interfacing considerations since it also has garbage collection, but the C targets require you to initialize Nim's internals, which is done calling a &lt;code&gt;NimMain&lt;/code&gt; function. Also, C code requires you to specify a forward declaration for functions or the compiler will assume certain types for the return value and parameters which will likely make your program crash at runtime.</source>
          <target state="translated">Целевой объект JavaScript не имеет дополнительных соображений по взаимодействию, поскольку он также имеет сборку мусора, но целевые объекты C требуют, чтобы вы инициализировали внутренние &lt;code&gt;NimMain&lt;/code&gt; Nim, что выполняется с помощью функции NimMain . Кроме того, код C требует, чтобы вы указали предварительное объявление для функций, иначе компилятор примет определенные типы для возвращаемого значения и параметров, которые, вероятно, вызовут сбой вашей программы во время выполнения.</target>
        </trans-unit>
        <trans-unit id="c71fa4398834a6a9a72702a17c78e6eacdbf2bf6" translate="yes" xml:space="preserve">
          <source>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; string type declared in the &lt;code&gt;system&lt;/code&gt; module.</source>
          <target state="translated">Компилятор Nim и большая часть стандартной библиотеки поддерживают режим заражения. Входные строки объявляются строковым типом &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString,&lt;/span&gt; объявленным в &lt;code&gt;system&lt;/code&gt; модуле.</target>
        </trans-unit>
        <trans-unit id="def6a14c368cd75cd8626ee152affd572b2968a4" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="translated">Компилятор Nim может сгенерировать заголовок интерфейса C с помощью &lt;code&gt;--header&lt;/code&gt; командной строки --header . Сгенерированный заголовок будет содержать все экспортированные символы и процесс &lt;code&gt;NimMain&lt;/code&gt; , который вам нужно вызвать перед любым другим кодом Nim.</target>
        </trans-unit>
        <trans-unit id="94228688470dadb9d05b8e3aa4652ece8f0668d5" translate="yes" xml:space="preserve">
          <source>The Nim compiler emits different kinds of messages: &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;, &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;, and &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; messages. An &lt;em&gt;error&lt;/em&gt; message is emitted if the compiler encounters any static error.</source>
          <target state="translated">Компилятор Nim выдает разные типы сообщений: &lt;span id=&quot;hint_1&quot;&gt;подсказки&lt;/span&gt; , &lt;span id=&quot;warning_1&quot;&gt;предупреждения&lt;/span&gt; и сообщения &lt;span id=&quot;error_1&quot;&gt;об&lt;/span&gt; ошибках. &lt;em&gt;Ошибка&lt;/em&gt; сообщение испускается , если компилятор встречает любую статическую ошибку.</target>
        </trans-unit>
        <trans-unit id="925789b7eec75edffc7a653892e368b900774bb2" translate="yes" xml:space="preserve">
          <source>The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.</source>
          <target state="translated">Компилятор Nim включает в себя простой решатель линейных уравнений,позволяющий делать выводы о статических параметрах в некоторых ситуациях,когда задействована целочисленная арифметика.</target>
        </trans-unit>
        <trans-unit id="0aad288594b7108c08933546073e4929c7d5707a" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files which can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone nodejs program&lt;/a&gt;.</source>
          <target state="translated">Компилятор Nim поддерживает в основном два семейства серверных программ: цели C, C ++ и Objective-C и цель JavaScript. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;Цели, подобные C,&lt;/a&gt; создают исходные файлы, которые могут быть скомпилированы в библиотеку или окончательный исполняемый файл. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;Целевой объект JavaScript&lt;/a&gt; может сгенерировать файл &lt;code&gt;.js&lt;/code&gt; ,на который вы ссылаетесь из файла HTML, или создать &lt;a href=&quot;http://nodejs.org&quot;&gt;автономную программу nodejs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab9acd635a298ee76edc5f11e47d2fedf88be9db" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports source code filters as a simple yet powerful builtin templating system.</source>
          <target state="translated">Компилятор Nim поддерживает фильтры исходного кода как простую,но мощную систему построения шаблонов.</target>
        </trans-unit>
        <trans-unit id="3b52099df7643f4b981a178452104474413203d0" translate="yes" xml:space="preserve">
          <source>The Nim compiler will handle linking the source files generated in the &lt;code&gt;nimcache&lt;/code&gt; directory into the &lt;code&gt;libfib.nim.a&lt;/code&gt; static library, which you can then link into your C program. Note that these commands are generic and will vary for each system. For instance, on Linux systems you will likely need to use &lt;code&gt;-ldl&lt;/code&gt; too to link in required dlopen functionality.</source>
          <target state="translated">Компилятор Nim будет обрабатывать ссылки на исходные файлы , сгенерированные в &lt;code&gt;nimcache&lt;/code&gt; директории в &lt;code&gt;libfib.nim.a&lt;/code&gt; библиотеки статической, которые затем можно связать в программу C. Обратите внимание, что эти команды являются общими и будут отличаться для каждой системы. Например, в системах Linux вам, вероятно, также потребуется использовать &lt;code&gt;-ldl&lt;/code&gt; для подключения необходимых функций dlopen.</target>
        </trans-unit>
        <trans-unit id="1fdb91e1f0e7364e6a781dd1b11345e2628e4a18" translate="yes" xml:space="preserve">
          <source>The Nim library makes heavy use of overloading - one reason for this is that each operator like &lt;code&gt;+&lt;/code&gt; is just an overloaded proc. The parser lets you use operators in &lt;em&gt;infix notation&lt;/em&gt; (&lt;code&gt;a + b&lt;/code&gt;) or &lt;em&gt;prefix notation&lt;/em&gt; (&lt;code&gt;+ a&lt;/code&gt;). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does &lt;code&gt;a @ @ b&lt;/code&gt; mean &lt;code&gt;(a) @ (@b)&lt;/code&gt; or &lt;code&gt;(a@) @ (b)&lt;/code&gt;? It always means &lt;code&gt;(a) @ (@b)&lt;/code&gt;, because there are no postfix operators in Nim.)</source>
          <target state="translated">Библиотека Nim интенсивно использует перегрузку - одна из причин этого в том, что каждый оператор, например &lt;code&gt;+&lt;/code&gt; , является просто перегруженной процедурой. Анализатор позволяет использовать операторы в &lt;em&gt;инфиксной записи&lt;/em&gt; ( &lt;code&gt;a + b&lt;/code&gt; ) или в &lt;em&gt;префиксной записи&lt;/em&gt; ( &lt;code&gt;+ a&lt;/code&gt; ). Инфиксный оператор всегда получает два аргумента, префиксный оператор всегда один. (Операторы Postfix не представляется возможным, так как это будет неоднозначным: делает &lt;code&gt;a @ @ b&lt;/code&gt; средней &lt;code&gt;(a) @ (@b)&lt;/code&gt; или &lt;code&gt;(a@) @ (b)&lt;/code&gt; это всегда означает? &lt;code&gt;(a) @ (@b)&lt;/code&gt; , потому что постфиксных операторов в ним нет.)</target>
        </trans-unit>
        <trans-unit id="b17c19d995b51a702da47a322eb14c3c3f74d169" translate="yes" xml:space="preserve">
          <source>The Nim manual is a draft that will evolve into a proper specification.</source>
          <target state="translated">Руководство по НИМ-это проект,который будет развиваться в надлежащую спецификацию.</target>
        </trans-unit>
        <trans-unit id="e4eee78d4b7b5546dac0f0bcfd4ab8e0361f503a" translate="yes" xml:space="preserve">
          <source>The Nim programming language has no concept of Posix's signal handling mechanisms. However, the standard library offers some rudimentary support for signal handling, in particular, segmentation faults are turned into fatal errors that produce a stack trace. This can be disabled with the &lt;code&gt;-d:noSignalHandler&lt;/code&gt; switch.</source>
          <target state="translated">В языке программирования Nim нет концепции механизмов обработки сигналов Posix. Однако стандартная библиотека предлагает некоторую элементарную поддержку обработки сигналов, в частности, ошибки сегментации превращаются в фатальные ошибки, приводящие к трассировке стека. Это можно отключить с &lt;code&gt;-d:noSignalHandler&lt;/code&gt; переключателя -d: noSignalHandler .</target>
        </trans-unit>
        <trans-unit id="e3345c6b8f143dcd54f42f93fcf9a202601d5fc9" translate="yes" xml:space="preserve">
          <source>The Nim project's directory structure is:</source>
          <target state="translated">Структура каталогов проекта Nim:</target>
        </trans-unit>
        <trans-unit id="745ed56715666ebf26c03c8cf5d30717ab67de33" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;em&gt;addQuoted&lt;/em&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="translated">Стандартная библиотека Nim использует эту функцию для элементов коллекций при создании строкового представления коллекции. Рекомендуется использовать эту функцию также для пользовательских коллекций. Пользователи могут перегрузить &lt;em&gt;addQuoted&lt;/em&gt; для пользовательских (строковых) типов, если они хотят реализовать настраиваемое представление элемента.</target>
        </trans-unit>
        <trans-unit id="54b8c6d91ca6a5455af26ed86869eb5c4519994d" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part one deals with the basics.</source>
          <target state="translated">Первая часть учебника &quot;Ним&quot; посвящена основам.</target>
        </trans-unit>
        <trans-unit id="9a6b7b3f497d2672fe45a7b21b92290089548d77" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part two deals with the advanced language constructs.</source>
          <target state="translated">Во второй части учебника Nim рассматриваются продвинутые языковые конструкции.</target>
        </trans-unit>
        <trans-unit id="c83305965ac9b2ed953b344478f9a769c28c7aba" translate="yes" xml:space="preserve">
          <source>The PEG parser implements this grammar (written in PEG syntax):</source>
          <target state="translated">Парсер PEG реализует эту грамматику (написанную в синтаксисе PEG):</target>
        </trans-unit>
        <trans-unit id="b2baf9c90ee9c6afac7ad841487341acef025679" translate="yes" xml:space="preserve">
          <source>The above &lt;code&gt;debug&lt;/code&gt; macro relies on the fact that &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka &lt;span id=&quot;symbols_1&quot;&gt;symbols&lt;/span&gt;) instead of using unbound identifiers. The &lt;code&gt;bindSym&lt;/code&gt; builtin can be used for that:</source>
          <target state="translated">Вышеупомянутый макрос &lt;code&gt;debug&lt;/code&gt; основывается на том факте, что &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeLine&lt;/code&gt; и &lt;code&gt;stdout&lt;/code&gt; объявлены в системном модуле и, следовательно, видны в контексте создания экземпляра. Есть способ использовать связанные идентификаторы (также известные как &lt;span id=&quot;symbols_1&quot;&gt;символы&lt;/span&gt; ) вместо использования несвязанных идентификаторов. Для &lt;code&gt;bindSym&lt;/code&gt; можно использовать встроенную команду bindSym :</target>
        </trans-unit>
        <trans-unit id="ed87b5819ca0a50089cd2bf1bad97ce7b0637b5f" translate="yes" xml:space="preserve">
          <source>The above code fails with the mysterious error message that &lt;code&gt;i&lt;/code&gt; has already been declared. The reason for this is that the &lt;code&gt;var i = ...&lt;/code&gt; bodies need to be type-checked before they are passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed &lt;code&gt;i&lt;/code&gt; needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="translated">Приведенный выше код выдает сообщение об ошибке загадочного , что &lt;code&gt;i&lt;/code&gt; уже был объявлен. Причина этого в том, что тела &lt;code&gt;var i = ...&lt;/code&gt; должны быть проверены на тип, прежде чем они будут переданы в параметр &lt;code&gt;body&lt;/code&gt; , а проверка типа в Nim подразумевает поиск символов. Для успешного поиска символов &lt;code&gt;i&lt;/code&gt; нужно добавить в текущую (т.е. внешнюю) область видимости. После проверки типа эти добавления в таблицу символов не откатываются (к лучшему или худшему). Тот же код работает с &lt;code&gt;untyped&lt;/code&gt; поскольку переданное тело не требует проверки типа:</target>
        </trans-unit>
        <trans-unit id="b3982101b8689b140d25aa17cb82ea30c138360e" translate="yes" xml:space="preserve">
          <source>The above code outputs:</source>
          <target state="translated">Вышеуказанные кодовые выходы:</target>
        </trans-unit>
        <trans-unit id="dc4bda02bd351eb1e53dd407e05088912ae083f6" translate="yes" xml:space="preserve">
          <source>The above example will fail, to ensure c2nim &lt;em&gt;processes&lt;/em&gt; these defines and expands them, use c2nim's &lt;code&gt;#def&lt;/code&gt; directive:</source>
          <target state="translated">В приведенном выше примере произойдет сбой, чтобы гарантировать, что c2nim &lt;em&gt;обрабатывает&lt;/em&gt; эти определения и расширяет их, используйте директиву c2nim &lt;code&gt;#def&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af1747a46fc4da26a624c04d36cc94dfd97e3023" translate="yes" xml:space="preserve">
          <source>The above module exports &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, but not &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Вышеупомянутый модуль экспортирует &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;*&lt;/code&gt; , но не &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2164536ddfd6de29510303b3ffa83bdfffcb08d5" translate="yes" xml:space="preserve">
          <source>The above output could be the result of a code snippet like:</source>
          <target state="translated">Вышеуказанный вывод может быть результатом такого фрагмента кода как:</target>
        </trans-unit>
        <trans-unit id="3921e4649d03a4f2c2e0f1f2787d19741635bd73" translate="yes" xml:space="preserve">
          <source>The access to field &lt;code&gt;x.v&lt;/code&gt; is allowed since its guard &lt;code&gt;x.L&lt;/code&gt; is active. After template expansion, this amounts to:</source>
          <target state="translated">Доступ к полю &lt;code&gt;x.v&lt;/code&gt; разрешен, так как его защита &lt;code&gt;x.L&lt;/code&gt; активна. После расширения шаблона это составляет:</target>
        </trans-unit>
        <trans-unit id="8dd5c61046585195d0c3e2c466315972a1789d8b" translate="yes" xml:space="preserve">
          <source>The addr operator</source>
          <target state="translated">Оператор аддера</target>
        </trans-unit>
        <trans-unit id="9c16d3733ab5de84d13321ea183405e627ced8c0" translate="yes" xml:space="preserve">
          <source>The algorithm for compiling modules is:</source>
          <target state="translated">Алгоритм компиляции модулей таков:</target>
        </trans-unit>
        <trans-unit id="7735ffef84f6b2ad890f11a7dd0ee082beb33ad5" translate="yes" xml:space="preserve">
          <source>The algorithm is based on the theory of continued fractions.</source>
          <target state="translated">Алгоритм основан на теории непрерывных дробей.</target>
        </trans-unit>
        <trans-unit id="d614f17a9f1bd45756a257161f52b39079cec7a1" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings always copies the string. The &lt;code&gt;&amp;amp;&lt;/code&gt; operator concatenates strings.</source>
          <target state="translated">Оператор присваивания для строк всегда копирует строку. Оператор &lt;code&gt;&amp;amp;&lt;/code&gt; объединяет строки.</target>
        </trans-unit>
        <trans-unit id="7d2817b98254430aea892c64ac0086b7f62a2214" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings copies the string. You can use the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to concatenate strings and &lt;code&gt;add&lt;/code&gt; to append to a string.</source>
          <target state="translated">Оператор присваивания для строк копирует строку. Вы можете использовать оператор &lt;code&gt;&amp;amp;&lt;/code&gt; для объединения строк и &lt;code&gt;add&lt;/code&gt; для добавления к строке.</target>
        </trans-unit>
        <trans-unit id="bb716b99b45cbb4781636530d6cc58814ca4c5cf" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described in &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt;.</source>
          <target state="translated">Оператор присваивания для кортежей копирует каждый компонент. Оператор присваивания по умолчанию для объектов копирует каждый компонент. Перегрузка оператора присваивания описана в &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad5e1062fa49239262e20658b8eefbafc9c44097" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The notation &lt;code&gt;t.field&lt;/code&gt; is used to access a tuple's field. Another notation is &lt;code&gt;t[i]&lt;/code&gt; to access the &lt;code&gt;i&lt;/code&gt;'th field. Here &lt;code&gt;i&lt;/code&gt; must be a constant integer.</source>
          <target state="translated">Оператор присваивания для кортежей копирует каждый компонент. Обозначение &lt;code&gt;t.field&lt;/code&gt; используется для доступа к полю кортежа. Другое обозначение - &lt;code&gt;t[i]&lt;/code&gt; для доступа к &lt;code&gt;i&lt;/code&gt; -му полю. Здесь &lt;code&gt;i&lt;/code&gt; должно быть постоянным целым числом.</target>
        </trans-unit>
        <trans-unit id="804f01a733a67cfcf057f33e60859ec41e2582ef" translate="yes" xml:space="preserve">
          <source>The assignment operator needs to be attached to an object or distinct type &lt;code&gt;T&lt;/code&gt;. Its signature has to be &lt;code&gt;(var T, T)&lt;/code&gt;. Example:</source>
          <target state="translated">Оператор присваивания должен быть прикреплен к объекту или отдельного типа &lt;code&gt;T&lt;/code&gt; . Его подпись должна быть &lt;code&gt;(var T, T)&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="57e23a9b21d323dac48595a4bbc01b14afe5e195" translate="yes" xml:space="preserve">
          <source>The assignment statement</source>
          <target state="translated">Заявление о назначении</target>
        </trans-unit>
        <trans-unit id="69e1ab703b32f93b8ef72d294804a9cde1a4f4f9" translate="yes" xml:space="preserve">
          <source>The assignment statement assigns a new value to a variable or more generally to a storage location:</source>
          <target state="translated">Оператор присваивания присваивает новое значение переменной или,в более общем случае,месту хранения:</target>
        </trans-unit>
        <trans-unit id="d73476dc2a350d437b107b771d2828a4abae111d" translate="yes" xml:space="preserve">
          <source>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</source>
          <target state="translated">Диспетчер по асинхронизации внедряет систему проакторов,а также осуществляет ИОКП.Он реализует проакторную модель для других ОС через модуль селекторов.Здесь также осуществляется будущее,и все процедуры возвращаются в будущее.</target>
        </trans-unit>
        <trans-unit id="b8f9435ff6dfbae860f91fa36f9f0b5fbb9f39e8" translate="yes" xml:space="preserve">
          <source>The available floating point presentation types are:</source>
          <target state="translated">Доступные типы презентаций с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="translated">Доступны целые типы представления:</target>
        </trans-unit>
        <trans-unit id="79db556b1fc1486c80abc68c65a3dd21e5851952" translate="yes" xml:space="preserve">
          <source>The backend must have some logic so that if the currently processed module is from the compilation cache, the &lt;code&gt;ast&lt;/code&gt; field is not accessed. Instead the generated C(++) for the symbol's body needs to be cached too and inserted back into the produced C file. This approach seems to deal with all the outlined problems above.</source>
          <target state="translated">Бэкэнд должен иметь некоторую логику, чтобы, если в настоящее время обрабатываемый модуль находится из кеша компиляции, доступ к полю &lt;code&gt;ast&lt;/code&gt; не выполнялся. Вместо этого сгенерированный C (++) для тела символа также необходимо кэшировать и вставлять обратно в созданный файл C. Такой подход, кажется, решает все перечисленные выше проблемы.</target>
        </trans-unit>
        <trans-unit id="ac450c1d36f3fc4bcff981788349d27816a68afe" translate="yes" xml:space="preserve">
          <source>The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.</source>
          <target state="translated">Базовый тип непроверенного массива может не содержать памяти GC'ed,но на данный момент он не проверяется.</target>
        </trans-unit>
        <trans-unit id="179771803cf0c16d91d22dfc5e7584351c3201db" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferred Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance (and easier C code generation). Cycle detection is currently done by a simple mark&amp;amp;sweep GC that has to scan the full (thread local heap). &lt;code&gt;--gc:v2&lt;/code&gt; replaces this with an incremental mark and sweep. That it is not production ready yet, however.</source>
          <target state="translated">Базовый алгоритм - &lt;em&gt;отсроченный подсчет ссылок&lt;/em&gt; с обнаружением цикла. Ссылки в стеке не учитываются для повышения производительности (и упрощения генерации кода C). Обнаружение цикла в настоящее время выполняется простым сборщиком мусора mark &amp;amp; ​​sweep, который должен сканировать всю (локальную кучу потока). &lt;code&gt;--gc:v2&lt;/code&gt; заменяет это на инкрементную метку и развертку. Однако он еще не готов к производству.</target>
        </trans-unit>
        <trans-unit id="6d21aca78505b578689d1824dee245b0be8d52e9" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferrent Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance and easier C code generation.</source>
          <target state="translated">Базовый алгоритм - &lt;em&gt;отсроченный подсчет ссылок&lt;/em&gt; с обнаружением цикла. Ссылки в стеке не учитываются для повышения производительности и упрощения генерации кода C.</target>
        </trans-unit>
        <trans-unit id="01e318808654d94079517579df63094331b22821" translate="yes" xml:space="preserve">
          <source>The binary &lt;code&gt;^*&lt;/code&gt; operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise &lt;code&gt;^+&lt;/code&gt; means 1 or more occurrences: &lt;code&gt;a ^+ b&lt;/code&gt; is short for &lt;code&gt;a (b a)*&lt;/code&gt; and &lt;code&gt;a ^* b&lt;/code&gt; is short for &lt;code&gt;(a (b a)*)?&lt;/code&gt;. Example:</source>
          <target state="translated">Двоичный оператор &lt;code&gt;^*&lt;/code&gt; используется как сокращение для 0 или более вхождений, разделенных вторым аргументом; аналогично &lt;code&gt;^+&lt;/code&gt; означает 1 или несколько вхождений: &lt;code&gt;a ^+ b&lt;/code&gt; - сокращение от &lt;code&gt;a (b a)*&lt;/code&gt; а &lt;code&gt;a ^* b&lt;/code&gt; - сокращение от &lt;code&gt;(a (b a)*)?&lt;/code&gt; , Пример:</target>
        </trans-unit>
        <trans-unit id="10ef37192c4c3ac0d1a132ff61857597f3ebc82a" translate="yes" xml:space="preserve">
          <source>The block statement is a means to group statements to a (named) &lt;code&gt;block&lt;/code&gt;. Inside the block, the &lt;code&gt;break&lt;/code&gt; statement is allowed to leave the block immediately. A &lt;code&gt;break&lt;/code&gt; statement can contain a name of a surrounding block to specify which block is to leave.</source>
          <target state="translated">Оператор блока - это средство группировки операторов в (именованный) &lt;code&gt;block&lt;/code&gt; . Внутри блока оператору &lt;code&gt;break&lt;/code&gt; разрешено немедленно покинуть блок. &lt;code&gt;break&lt;/code&gt; заявление может содержать имя окружающего блока , чтобы указать , какой блок должен уйти.</target>
        </trans-unit>
        <trans-unit id="4ac080ff8c42136d469aa9618ca8dd14a7c9497c" translate="yes" xml:space="preserve">
          <source>The block's &lt;em&gt;label&lt;/em&gt; (&lt;code&gt;myblock&lt;/code&gt; in the example) is optional.</source>
          <target state="translated">&lt;em&gt;Метка&lt;/em&gt; блока ( в примере - &lt;code&gt;myblock&lt;/code&gt; ) необязательна.</target>
        </trans-unit>
        <trans-unit id="390a433a85fe95c30ff748c4a4396344238da974" translate="yes" xml:space="preserve">
          <source>The boolean type is named &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; in Nim and can be one of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elif&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;-statements need to be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Логический тип в Nim называется &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; и может быть одним из двух предопределенных значений &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; . Условия в &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;elif&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; -statements должны быть типа &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2ce9bd7c5f1b8affcc95224634c4003923668d" translate="yes" xml:space="preserve">
          <source>The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:</source>
          <target state="translated">Прагматика заимствования может также использоваться для аннотирования особого типа,позволяющего проводить определенные строительные работы:</target>
        </trans-unit>
        <trans-unit id="f277ec78fce68a5d9247ac9d7120e37c595d4513" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc returns the array's length. &lt;a href=&quot;system#low&quot;&gt;low(a)&lt;/a&gt; returns the lowest valid index for the array &lt;em&gt;a&lt;/em&gt; and &lt;a href=&quot;system#high&quot;&gt;high(a)&lt;/a&gt; the highest valid index.</source>
          <target state="translated">Встроенная процедура &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; возвращает длину массива. &lt;a href=&quot;system#low&quot;&gt;low (a)&lt;/a&gt; возвращает самый низкий допустимый индекс для массива &lt;em&gt;a,&lt;/em&gt; а &lt;a href=&quot;system#high&quot;&gt;high (a) -&lt;/a&gt; самый высокий допустимый индекс.</target>
        </trans-unit>
        <trans-unit id="a9933530b06a29cb28167851eb7193a2ebfd89d2" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="translated">Встроенный &lt;code&gt;deepCopy&lt;/code&gt; может даже клонировать затворы и их окружение. Подробности смотрите в документации по &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18e36e8445862a6742d9876a1c8ed0b253932bec" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;system.finished&lt;/code&gt; can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</source>
          <target state="translated">Встроенный &lt;code&gt;system.finished&lt;/code&gt; может быть использовано , чтобы определить , является ли итератор закончил свою работу; при попытке вызвать итератор, который уже завершил свою работу, исключение не возникает.</target>
        </trans-unit>
        <trans-unit id="d3ed05fd4188503b5e918e419071d83535ca6d73" translate="yes" xml:space="preserve">
          <source>The builtin document generator &lt;code&gt;nim doc&lt;/code&gt; generates HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files.</source>
          <target state="translated">Встроенный генератор документов &lt;code&gt;nim doc&lt;/code&gt; генерирует HTML-документацию из исходных файлов &lt;code&gt;.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03f6f784af17f7bc54b3aa6aaca5046f4b889d50" translate="yes" xml:space="preserve">
          <source>The callback is also called when the future is completed. So you should use &lt;code&gt;finished&lt;/code&gt; to check whether data is available.</source>
          <target state="translated">Обратный вызов также вызывается, когда будущее завершено. Таким образом , вы должны использовать &lt;code&gt;finished&lt;/code&gt; , чтобы проверить , является ли данные.</target>
        </trans-unit>
        <trans-unit id="fda0db03a44323f53881c6ed07ea62221c4d40ac" translate="yes" xml:space="preserve">
          <source>The callback should return one of:</source>
          <target state="translated">Обратный звонок должен вернуть один из них:</target>
        </trans-unit>
        <trans-unit id="98431101a07bff81af63ae772b99a639ecfd446d" translate="yes" xml:space="preserve">
          <source>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</source>
          <target state="translated">Символ каретты (^)не распознается как экранирующий или разделительный символ.Символ полностью обрабатывается парсером командной строки в операционной системе перед передачей в массив argv в программе.</target>
        </trans-unit>
        <trans-unit id="275705377e0dee3785eb3e50c9fe458fd4e6307b" translate="yes" xml:space="preserve">
          <source>The case statement can deal with integers, other ordinal types and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:</source>
          <target state="translated">Оператор регистра может работать с целыми числами,другими порядковыми типами и строками.(То,что является порядковым типом,скоро будет объяснено.)Для целых чисел или других порядковых типов также возможны диапазоны значений:</target>
        </trans-unit>
        <trans-unit id="3cb06e2eb10f97945a6a1dc769debf11f66cc02b" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="translated">Соглашение cdecl означает, что процедура должна использовать то же соглашение, что и компилятор C. В Windows сгенерированная процедура C объявляется с &lt;code&gt;__cdecl&lt;/code&gt; словом __cdecl .</target>
        </trans-unit>
        <trans-unit id="cf2d21d3ec49f1b953444178b23232a5b0355231" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as ':' for POSIX or ';' for Windows.</source>
          <target state="translated">Символ,обычно используемый операционной системой для разделения компонентов поиска заплаток (как в PATH),таких как ':' для POSIX или ';' для Windows.</target>
        </trans-unit>
        <trans-unit id="daf14d8e5ee092bdea92e4c3639c4ffbc471a82f" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">Тип &lt;code&gt;char&lt;/code&gt; в ним называется char . Его размер - один байт. Таким образом, он не может представлять символ UTF-8, а является его частью. Причина этого - эффективность: в подавляющем большинстве случаев использования результирующие программы по-прежнему будут правильно обрабатывать UTF-8, поскольку UTF-8 был специально разработан для этого. Другая причина в том, что Nim может эффективно поддерживать &lt;code&gt;array[char, int]&lt;/code&gt; или &lt;code&gt;set[char]&lt;/code&gt; поскольку многие алгоритмы полагаются на эту функцию. Тип &lt;em&gt;Rune&lt;/em&gt; используется для символов Unicode, он может представлять любой символ Unicode. &lt;code&gt;Rune&lt;/code&gt; объявлена ​​в &lt;a href=&quot;unicode&quot;&gt;модуле юникода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="012338159832c9f5b5b221070a9909e38b48330b" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example, '/' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">Символ,используемый операционной системой для разделения патнаментных компонентов,например,'/' для POSIX или ':' для классического Macintosh.</target>
        </trans-unit>
        <trans-unit id="8595c8efa2aa083f52c712e47adba9de6178e714" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the '.' in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="translated">Символ, отделяющий базовое имя файла от расширения; например, &quot;.&quot; в &lt;code&gt;os.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e0adad1955b78ddab6f74ee977c388f8e7ad21e" translate="yes" xml:space="preserve">
          <source>The choice of style is up to you.</source>
          <target state="translated">Выбор стиля зависит от вас.</target>
        </trans-unit>
        <trans-unit id="78f0b6da6c7f59b81902fe7eaf3cc327e7160fa5" translate="yes" xml:space="preserve">
          <source>The closing &lt;code&gt;@#&lt;/code&gt; needs to be on a line of its own, only preceeded by optional whitespace. This way &lt;code&gt;@#&lt;/code&gt; can otherwise occur in the Nim code as the example shows.</source>
          <target state="translated">Закрывающий &lt;code&gt;@#&lt;/code&gt; должен находиться в отдельной строке, только перед ним должен стоять необязательный пробел. В противном случае &lt;code&gt;@#&lt;/code&gt; может появиться в коде Nim, как показано в примере.</target>
        </trans-unit>
        <trans-unit id="c2a6d13754b9070007f419ad05ea1ed9a30039c9" translate="yes" xml:space="preserve">
          <source>The code contains a confusing &lt;code&gt;var&lt;/code&gt; declaration.</source>
          <target state="translated">Код содержит запутанное объявление &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27b7a967cf2c61e046012b3021e3386a2439d280" translate="yes" xml:space="preserve">
          <source>The code contains an unsupported octal sequence.</source>
          <target state="translated">Код содержит неподдерживаемую восьмеричную последовательность.</target>
        </trans-unit>
        <trans-unit id="6648d68a40326bd32903c1e98c224eb206ee30b9" translate="yes" xml:space="preserve">
          <source>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</source>
          <target state="translated">Функция переупорядочивания кода может неявно переставлять определения процедур,шаблонов и макросов вместе с объявлениями переменных и инициализациями на верхнем уровне,так что программисту в значительной степени не нужно беспокоиться о правильном упорядочивании определений или быть вынужденным использовать прямые объявления для определений предисловий внутри модуля.</target>
        </trans-unit>
        <trans-unit id="fd31996b685a939214cab476b507369c2a26dbe0" translate="yes" xml:space="preserve">
          <source>The code uses a deprecated symbol.</source>
          <target state="translated">В коде используется устаревший символ.</target>
        </trans-unit>
        <trans-unit id="cadbefb6d63605ada88260c0953028138c9935e0" translate="yes" xml:space="preserve">
          <source>The coercion &lt;code&gt;type(x)&lt;/code&gt; can be used to obtain the type of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Принуждения &lt;code&gt;type(x)&lt;/code&gt; может быть использован для получения типа данного выражения &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21a01b95e07874cdea952698896961c01561234b" translate="yes" xml:space="preserve">
          <source>The collector checks whether there is still time left for its work after every &lt;code&gt;workPackage&lt;/code&gt;'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus &lt;code&gt;workPackage&lt;/code&gt; affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.</source>
          <target state="translated">После каждой &lt;code&gt;workPackage&lt;/code&gt; сборщик проверяет, осталось ли время для его работы . В настоящее время установлено значение 100, что означает, что до 100 объектов проходят и освобождаются перед повторной проверкой. Таким образом, &lt;code&gt;workPackage&lt;/code&gt; влияет на детализацию синхронизации и может потребовать настройки в узкоспециализированных средах или для более старого оборудования.</target>
        </trans-unit>
        <trans-unit id="79afdb7f6889da26e189c0f3c33044a04e18d142" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. The (&lt;a href=&quot;#do-notation&quot;&gt;do notation&lt;/a&gt;) is limited, but usable for a single proc (see the example in the corresponding section). Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</source>
          <target state="translated">Синтаксис вызова команды также не может иметь в качестве аргументов сложные выражения. Например: ( &lt;a href=&quot;#anonymous-procs&quot;&gt;анонимные процедуры&lt;/a&gt; ), &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; или &lt;code&gt;try&lt;/code&gt; . &lt;a href=&quot;#do-notation&quot;&gt;Обозначение&lt;/a&gt; ( do ) ограничено, но может использоваться для одного процесса (см. Пример в соответствующем разделе). Для вызовов функций без аргументов по-прежнему требуется (), чтобы различать вызов и саму функцию как значение первого класса.</target>
        </trans-unit>
        <trans-unit id="bbb3a5b11c8c58cd3db6e75b060c5cb1256d4072" translate="yes" xml:space="preserve">
          <source>The commands to compile to either C, C++ or Objective-C are:</source>
          <target state="translated">Команды для компиляции либо на C,либо на C++или на Objective-C:</target>
        </trans-unit>
        <trans-unit id="9147d3666608b3555f82a0b1ee6751419dc98de6" translate="yes" xml:space="preserve">
          <source>The common &lt;code&gt;--&lt;/code&gt; non-option argument delimiter appears as an empty string long option key. &lt;code&gt;OptParser.cmd&lt;/code&gt;, &lt;code&gt;OptParser.pos&lt;/code&gt;, and &lt;code&gt;os.parseCmdLine&lt;/code&gt; may be used to complete parsing in that case.</source>
          <target state="translated">Распространенный &lt;code&gt;--&lt;/code&gt; не параметр аргумент Разделитель выглядит как пустая строка ключ длинного варианта. &lt;code&gt;OptParser.cmd&lt;/code&gt; этом случае для завершения синтаксического анализа можно использовать OptParser.cmd , &lt;code&gt;OptParser.pos&lt;/code&gt; и &lt;code&gt;os.parseCmdLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdfd6148988703a688e3c05eca6a8eff773759f" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for floats and follow the IEEE-754 standard.</source>
          <target state="translated">Общие операторы &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; Определены для чисел с плавающей запятой и соответствуют стандарту IEEE-754.</target>
        </trans-unit>
        <trans-unit id="883abbd0b16cdebab167565d80838c6044a1fcf0" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for integers. The &lt;code&gt;and or xor not&lt;/code&gt; operators are also defined for integers, and provide &lt;em&gt;bitwise&lt;/em&gt; operations. Left bit shifting is done with the &lt;code&gt;shl&lt;/code&gt;, right shifting with the &lt;code&gt;shr&lt;/code&gt; operator. Bit shifting operators always treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;. For &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;arithmetic bit shifts&lt;/span&gt; ordinary multiplication or division can be used.</source>
          <target state="translated">Общие операторы &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; Определены для целых чисел. Операторы &lt;code&gt;and or xor not&lt;/code&gt; также определены для целых чисел и обеспечивают &lt;em&gt;побитовые&lt;/em&gt; операции. Битовый сдвиг влево выполняется с &lt;code&gt;shl&lt;/code&gt; оператора shl , сдвиг вправо - с помощью оператора &lt;code&gt;shr&lt;/code&gt; . Операторы битового сдвига всегда обрабатывают свои аргументы как &lt;em&gt;беззнаковые&lt;/em&gt; . Для &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;арифметических битовых сдвигов&lt;/span&gt; можно использовать обычное умножение или деление.</target>
        </trans-unit>
        <trans-unit id="93c350055cc7a991a83791a66ef96ae8da82f094" translate="yes" xml:space="preserve">
          <source>The compiler checks that each parameter receives exactly one argument.</source>
          <target state="translated">Компилятор проверяет,что каждый параметр получает ровно один аргумент.</target>
        </trans-unit>
        <trans-unit id="124083caaf9e67c2924ff4ad019f8bdbdc5c26c4" translate="yes" xml:space="preserve">
          <source>The compiler checks the semantics and produces code &lt;em&gt;only&lt;/em&gt; for the statements that belong to the first condition that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Компилятор проверяет семантику и создает код &lt;em&gt;только&lt;/em&gt; для операторов, принадлежащих первому условию, которое оценивается как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47314c2a3c9cb869c3d9611f5dd9ca92a7d73b2a" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#cross-compilation&quot;&gt;specify additional switches for cross compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="translated">Команды компилятора выбирают целевой бэкэнд, но при необходимости вы можете &lt;a href=&quot;nimc#cross-compilation&quot;&gt;указать дополнительные переключатели для кросс-компиляции,&lt;/a&gt; чтобы выбрать целевой ЦП, операционную систему или команды компилятора / компоновщика.</target>
        </trans-unit>
        <trans-unit id="93170a1da8e409d02256d9f99c47fbb958d19414" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">Компилятор зависит от системного модуля для правильной работы, а системный модуль зависит от компилятора. Большинство перечисленных здесь подпрограмм используют особую магию компилятора. Каждый модуль неявно импортирует модуль System; он не должен указываться явно. Из-за этого не может быть определяемого пользователем модуля с именем &lt;code&gt;system&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20fd635c293115e7e5e8cbd64caf63eed7e31f4f" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="translated">Компилятор гарантирует,что каждый путь кода инициализирует переменные,содержащие не нулевые указатели.Подробности данного анализа еще предстоит уточнить здесь.</target>
        </trans-unit>
        <trans-unit id="24838b6da70bcf6db067073b75a8fadd6fa3eb45" translate="yes" xml:space="preserve">
          <source>The compiler generates code as if the programmer would have written this:</source>
          <target state="translated">Компилятор генерирует код так,как будто это написал бы программист:</target>
        </trans-unit>
        <trans-unit id="7fae9d1a9ed8aeef0ae7bee39888a86acbeeaae5" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:release&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="translated">Компилятор может вообще не сгенерировать какой-либо код для &lt;code&gt;assert&lt;/code&gt; , если это рекомендуется сделать с помощью параметров &lt;a href=&quot;nimc#command-line-switches&quot;&gt;командной строки &lt;/a&gt; &lt;code&gt;-d:release&lt;/code&gt; или &lt;code&gt;--assertions:off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db364455640be314eef1467aaec6fd2d418125f9" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate C++ (command &lt;code&gt;cpp&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;cpp&lt;/code&gt; is defined when the compiler emits C++ code.</source>
          <target state="translated">Чтобы это сработало, необходимо &lt;code&gt;cpp&lt;/code&gt; компилятору сгенерировать C ++ (команда cpp ). Условный символ &lt;code&gt;cpp&lt;/code&gt; определяется, когда компилятор генерирует код C ++.</target>
        </trans-unit>
        <trans-unit id="b07c704d05cf142e0a3e3c5f7b0076809faa6524" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate Objective C (command &lt;code&gt;objc&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;objc&lt;/code&gt; is defined when the compiler emits Objective C code.</source>
          <target state="translated">&lt;code&gt;objc&lt;/code&gt; это сработало, компилятору нужно указать, что он должен сгенерировать Objective C (команда objc ). Условный символ &lt;code&gt;objc&lt;/code&gt; определяется, когда компилятор генерирует код Objective C.</target>
        </trans-unit>
        <trans-unit id="f8805142a67c1fcd5058bf1936f838d762e70095" translate="yes" xml:space="preserve">
          <source>The compiler now rewrites &lt;code&gt;x * 2&lt;/code&gt; as &lt;code&gt;x + x&lt;/code&gt;. The code inside the curlies is the pattern to match against. The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation, so to match verbatim against &lt;code&gt;*&lt;/code&gt; the ordinary function call syntax needs to be used.</source>
          <target state="translated">Теперь компилятор переписывает &lt;code&gt;x * 2&lt;/code&gt; как &lt;code&gt;x + x&lt;/code&gt; . Код внутри фигурных скобок - это образец для сопоставления. Операторы &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; имеют особое значение в шаблонах, если они написаны в инфиксной нотации, поэтому для дословного сопоставления с &lt;code&gt;*&lt;/code&gt; необходимо использовать обычный синтаксис вызова функции.</target>
        </trans-unit>
        <trans-unit id="98ccaef8e67a887a919921b63fd9651f08d45b7b" translate="yes" xml:space="preserve">
          <source>The compiler optimizes string case statements: A hashing scheme is used for them if several different string constants are used. So code like this is reasonably efficient:</source>
          <target state="translated">Компилятор оптимизирует строковые операторы регистра:Для них используется схема хэширования,если используется несколько различных строковых констант.Таким образом,подобный код достаточно эффективен:</target>
        </trans-unit>
        <trans-unit id="99dc98d2e9fd018605a9070695e4f40f907e1508" translate="yes" xml:space="preserve">
          <source>The compiler produces a hint message that &lt;code&gt;IOError&lt;/code&gt; can be raised. &lt;code&gt;OSError&lt;/code&gt; is not listed as it cannot be raised in the branch the &lt;code&gt;effects&lt;/code&gt; pragma appears in.</source>
          <target state="translated">Компилятор выдает подсказку о том, что может возникнуть &lt;code&gt;IOError&lt;/code&gt; . &lt;code&gt;OSError&lt;/code&gt; не указана, поскольку ее нельзя вызвать в ветке, в которой отображается прагма &lt;code&gt;effects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e1191530a1aabbbcf17eb667a751d36496cbed2" translate="yes" xml:space="preserve">
          <source>The compiler supports the built-in stringify operator &lt;code&gt;$&lt;/code&gt; for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:</source>
          <target state="translated">Компилятор поддерживает встроенный оператор строкового преобразования &lt;code&gt;$&lt;/code&gt; для перечислений. Результатом stringify можно управлять, явно задавая используемые строковые значения:</target>
        </trans-unit>
        <trans-unit id="278d7d171283ed12aaddd7862802da6834c8c0bb" translate="yes" xml:space="preserve">
          <source>The compiler then ensures that every access of &lt;code&gt;gdata&lt;/code&gt; is within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">Затем компилятор гарантирует, что каждый доступ к &lt;code&gt;gdata&lt;/code&gt; находится в разделе &lt;code&gt;locks&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e1c591d42a39fa2cac9b572e36ef028dda7cec6f" translate="yes" xml:space="preserve">
          <source>The compiler's architecture</source>
          <target state="translated">Архитектура компилятора</target>
        </trans-unit>
        <trans-unit id="d997b4ac7c8e54accc0951c93c7af7ae2bdbee79" translate="yes" xml:space="preserve">
          <source>The complementary error function</source>
          <target state="translated">Функция дополнительной ошибки</target>
        </trans-unit>
        <trans-unit id="5846f2c1b1099d4de8d1900d6964f1db9892caf2" translate="yes" xml:space="preserve">
          <source>The complier will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="translated">Компилятор сообщит о любом отказе в оценке выражения или о возможной ошибке несоответствия типа.</target>
        </trans-unit>
        <trans-unit id="22e9c95f9ebf3625a28669e8b3ce3192da579bb4" translate="yes" xml:space="preserve">
          <source>The concept is a match if:</source>
          <target state="translated">Концепция совпадает,если:</target>
        </trans-unit>
        <trans-unit id="aaa92c15c23e4f3caae54c3381bbefb039b5333e" translate="yes" xml:space="preserve">
          <source>The concept types can be parametric just like the regular generic types:</source>
          <target state="translated">Типы концепций могут быть параметрическими так же,как и обычные общие типы:</target>
        </trans-unit>
        <trans-unit id="7ec85a5fad9202d978280705ad23fc7951fe5afb" translate="yes" xml:space="preserve">
          <source>The condition in a &lt;code&gt;do while(condition)&lt;/code&gt; statement must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Условие в операторе &lt;code&gt;do while(condition)&lt;/code&gt; должно быть &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46668a8f385559561fb965d9c9162d27d76feb6a" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory.</source>
          <target state="translated">Константная строка,используемая операционной системой для ссылки на текущий каталог.</target>
        </trans-unit>
        <trans-unit id="b7d275cdb93fdbf6c6bdd566733c471d5cb82c86" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory.</source>
          <target state="translated">Константная строка,используемая операционной системой для ссылки на родительский каталог.</target>
        </trans-unit>
        <trans-unit id="2496559a72199a18b9bd92fb0f307658c3e8c8db" translate="yes" xml:space="preserve">
          <source>The constraint can be a concrete type or a type class.</source>
          <target state="translated">Ограничение может быть конкретным типом или классом.</target>
        </trans-unit>
        <trans-unit id="bdda80e1481774a2bcf89e333a8a607041b5e8d4" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; exists too. It is a shortcut for &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">Идентификатор конструкции &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; тоже существует. Это ярлык для &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b76daad7f41aa0f12c4252effb99658f3e34679b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt;, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</source>
          <target state="translated">Идентификатор конструкции &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (без пробелов между идентификатором и открывающей кавычкой) является обобщенным необработанным строковым литералом. Это ярлык для &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt; конструкции (r &amp;laquo;строковый литерал&amp;raquo;) , поэтому он обозначает вызов процедуры с необработанным строковым литералом в качестве единственного аргумента. Обобщенные необработанные строковые литералы особенно удобны для встраивания мини-языков непосредственно в Nim (например, регулярных выражений).</target>
        </trans-unit>
        <trans-unit id="15d06627966f858375d16fcd25aa9c8d53eb89d1" translate="yes" xml:space="preserve">
          <source>The contravariant parameters introduced with the &lt;code&gt;in&lt;/code&gt; modifier are currently useful only when interfacing with imported types having such semantics.</source>
          <target state="translated">Контравариантные параметры, введенные с помощью модификатора &lt;code&gt;in&lt;/code&gt; , в настоящее время полезны только при взаимодействии с импортированными типами, имеющими такую ​​семантику.</target>
        </trans-unit>
        <trans-unit id="f79116fcf17d026b0e4914fbd53c2223ebb6510b" translate="yes" xml:space="preserve">
          <source>The convertible relation can be relaxed by a user-defined type &lt;span id=&quot;converter_1&quot;&gt;converter&lt;/span&gt;.</source>
          <target state="translated">Конвертируемое отношение может быть ослаблено с помощью определяемого пользователем &lt;span id=&quot;converter_1&quot;&gt;преобразователя&lt;/span&gt; типов .</target>
        </trans-unit>
        <trans-unit id="b18a614e84b5a50fd0095d557ca3e5d6b4cdd331" translate="yes" xml:space="preserve">
          <source>The crit bit tree can either be used as a mapping from strings to some type &lt;code&gt;T&lt;/code&gt; or as a set of strings if &lt;code&gt;T&lt;/code&gt; is void.</source>
          <target state="translated">Дерево битов крита может использоваться либо как отображение строк в некоторый тип &lt;code&gt;T&lt;/code&gt; , либо как набор строк, если &lt;code&gt;T&lt;/code&gt; пусто.</target>
        </trans-unit>
        <trans-unit id="9b76fe6e6adda8db66493cbcc5c7f0fd20c378ec" translate="yes" xml:space="preserve">
          <source>The current implementation poses some restrictions for compile time evaluation: Code which contains &lt;code&gt;cast&lt;/code&gt; or makes use of the foreign function interface cannot be evaluated at compile time. Later versions of Nim will support the FFI at compile time.</source>
          <target state="translated">Текущая реализация накладывает некоторые ограничения на оценку времени компиляции: код, содержащий &lt;code&gt;cast&lt;/code&gt; типов или использующий интерфейс внешней функции, не может быть оценен во время компиляции. Более поздние версии Nim будут поддерживать FFI во время компиляции.</target>
        </trans-unit>
        <trans-unit id="a150efd164504eebf2c6ca387f4a2724cdddad5b" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the GC with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="translated">Сборщик циклов можно включить / отключить независимо от других частей GC с помощью &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; и &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="translated">Сборка проекта по умолчанию - это &lt;span id=&quot;debug-build_1&quot;&gt;отладочная сборка&lt;/span&gt; . Чтобы скомпилировать &lt;span id=&quot;release-build_1&quot;&gt;сборку выпуска,&lt;/span&gt; определите символ &lt;code&gt;release&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="translated">Соглашение о вызовах по умолчанию - &lt;code&gt;nimcall&lt;/code&gt; , если только это не внутренняя процедура (процедура внутри процедуры). Для внутреннего процесса выполняется анализ, получает ли он доступ к своей среде. Если это так, у него есть &lt;code&gt;closure&lt;/code&gt; соглашения о вызовах , в противном случае - соглашение о &lt;code&gt;nimcall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="translated">Компилятор по умолчанию определен в верхней части &lt;code&gt;config\nim.cfg&lt;/code&gt; . Изменение этого параметра влияет на компилятор, используемый &lt;code&gt;koch&lt;/code&gt; для (пере) сборки Nim.</target>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">Конфигурация по умолчанию ( &lt;em&gt;trim = true&lt;/em&gt; и &lt;em&gt;precision = 10&lt;/em&gt; ) показывает самую &lt;strong&gt;короткую&lt;/strong&gt; форму, которая точно (максимум до 10 знаков после запятой) отображает значение. Например, 4.100000 будет отображаться как 4.1 (что математически идентично), тогда как 4.1000003 будет отображаться как 4.1000003.</target>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="translated">По умолчанию используется тип &lt;code&gt;float&lt;/code&gt; . В текущей реализации &lt;code&gt;float&lt;/code&gt; всегда 64-битный.</target>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="translated">Значение по умолчанию для символов сущностей &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; является &lt;code&gt;gensym&lt;/code&gt; и &lt;code&gt;proc&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; , &lt;code&gt;converter&lt;/code&gt; , &lt;code&gt;template&lt;/code&gt; , &lt;code&gt;macro&lt;/code&gt; является &lt;code&gt;inject&lt;/code&gt; . Однако, если имя объекта передается в качестве параметра шаблона, это введенный символ:</target>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="translated">Целочисленный тип по умолчанию - &lt;code&gt;int&lt;/code&gt; . Целочисленные литералы могут иметь &lt;em&gt;суффикс типа,&lt;/em&gt; чтобы указать целочисленный тип, &lt;em&gt;отличный&lt;/em&gt; от используемого по умолчанию:</target>
        </trans-unit>
        <trans-unit id="a938a7c0d5ddba81851d8d833ea57ac0a05a8458" translate="yes" xml:space="preserve">
          <source>The deprecated pragma is used to mark a symbol as deprecated:</source>
          <target state="translated">Устаревшая прагма используется для обозначения символа как устаревшего:</target>
        </trans-unit>
        <trans-unit id="e86d1f1124b9d68611440bacc4bff7bcfe2f6e0a" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">Разница между 1.0 и наименьшим числом больше 1.0,которое может быть представлено в 32-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="afc1aa22832c69c45d0caa9362039ca2a87d5b07" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">Разница между 1.0 и наименьшим числом больше 1.0,которое может быть представлено в 64-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="8d3ea0a55b18000a3ec2d6587062c904d3e896cd" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is: &lt;code&gt;let&lt;/code&gt; introduces a variable that can not be re-assigned, &lt;code&gt;const&lt;/code&gt; means &quot;enforce compile time evaluation and put it into a data section&quot;:</source>
          <target state="translated">Разница между &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; заключается в следующем: &lt;code&gt;let&lt;/code&gt; вводит переменную, которую нельзя переназначить, &lt;code&gt;const&lt;/code&gt; означает &amp;laquo;принудительно выполнить оценку времени компиляции и поместить ее в раздел данных&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="0a74b6801170bf0f38a336281fab4bfa8303a82a" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and not members of &lt;em&gt;s2&lt;/em&gt;. Example:</source>
          <target state="translated">Разница между двумя наборами математически представлена ​​как &lt;em&gt;AB&lt;/em&gt; и представляет собой набор всех объектов, которые являются членами &lt;em&gt;s1,&lt;/em&gt; но не членами &lt;em&gt;s2&lt;/em&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="7c0c41b3f142cacbbcc66573b8adaf31d489334d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">Разница в отношении процедуры &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl ()&lt;/a&gt; заключается в том, что эта процедура возвращает &lt;em&gt;истину,&lt;/em&gt; если &lt;em&gt;ключ&lt;/em&gt; не указан в &lt;em&gt;s&lt;/em&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="d1de829e0ca997f038aa2fbccf312c02165e0cb7" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">Разница в отношении процедуры &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl ()&lt;/a&gt; заключается в том, что эта процедура возвращает &lt;em&gt;истину,&lt;/em&gt; если &lt;em&gt;ключ&lt;/em&gt; не указан в &lt;em&gt;s&lt;/em&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="18b21997787778562d6aa4adbaf236a4acd894b9" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">Разница в отношении процедуры &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl ()&lt;/a&gt; заключается в том, что эта процедура возвращает &lt;em&gt;истину,&lt;/em&gt; если &lt;em&gt;ключ&lt;/em&gt; уже присутствует в &lt;em&gt;s&lt;/em&gt; . Процесс вернет false, если &lt;em&gt;ключ&lt;/em&gt; был добавлен как новое значение в &lt;em&gt;s&lt;/em&gt; во время этого вызова. Пример:</target>
        </trans-unit>
        <trans-unit id="9b85f52a313da4c653da005f49f49e563663ab9e" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">Разница в отношении процедуры &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl ()&lt;/a&gt; заключается в том, что эта процедура возвращает &lt;em&gt;истину,&lt;/em&gt; если &lt;em&gt;ключ&lt;/em&gt; уже присутствует в &lt;em&gt;s&lt;/em&gt; . Процесс вернет false, если &lt;em&gt;ключ&lt;/em&gt; был добавлен как новое значение в &lt;em&gt;s&lt;/em&gt; во время этого вызова. Пример:</target>
        </trans-unit>
        <trans-unit id="220030e8b435e84f93ba209fa1bb4177a255c969" translate="yes" xml:space="preserve">
          <source>The different format patterns that are supported are documented below.</source>
          <target state="translated">Ниже описаны поддерживаемые шаблоны различных форматов.</target>
        </trans-unit>
        <trans-unit id="d7d6c6dc11f53e07d9cdc8acaebc2671f78a141c" translate="yes" xml:space="preserve">
          <source>The direct embedding of assembler code into Nim code is supported by the unsafe &lt;code&gt;asm&lt;/code&gt; statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is &lt;code&gt;'`'&lt;/code&gt;:</source>
          <target state="translated">Прямое встраивание кода ассемблера в код Nim поддерживается оператором unsafe &lt;code&gt;asm&lt;/code&gt; . Идентификаторы в коде ассемблера, которые ссылаются на идентификаторы Nim, должны быть заключены в специальный символ, который может быть указан в прагмах оператора. Специальный символ по умолчанию - &lt;code&gt;'`'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="79c14e4edc4e62d3b50ec111744e90c76fe6415b" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. It does &lt;strong&gt;not&lt;/strong&gt; fail if the directory already exists because for most usages this does not indicate an error.</source>
          <target state="translated">Каталог может содержать несколько подкаталогов, которые еще не существуют. Создан полный путь. Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . Это &lt;strong&gt;не&lt;/strong&gt; сработает, если каталог уже существует, потому что для большинства случаев использования это не указывает на ошибку.</target>
        </trans-unit>
        <trans-unit id="3d9c316616578336f1d520853682d58bf4e6eb88" translate="yes" xml:space="preserve">
          <source>The dispatcher acts as a kind of event loop. You must call &lt;code&gt;poll&lt;/code&gt; on it (or a function which does so for you such as &lt;code&gt;waitFor&lt;/code&gt; or &lt;code&gt;runForever&lt;/code&gt;) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.</source>
          <target state="translated">Диспетчер действует как своего рода цикл событий. Вы должны вызвать для него &lt;code&gt;poll&lt;/code&gt; (или функцию, которая делает это за вас, например, &lt;code&gt;waitFor&lt;/code&gt; или &lt;code&gt;runForever&lt;/code&gt; ), чтобы опросить любые невыполненные события. Базовая реализация основана на epoll в Linux, портах завершения ввода-вывода в Windows и некоторых других операционных системах.</target>
        </trans-unit>
        <trans-unit id="ad786784a7a091bc39b8e45514e333722de53121" translate="yes" xml:space="preserve">
          <source>The documentation consists of several documents:</source>
          <target state="translated">Документация состоит из нескольких документов:</target>
        </trans-unit>
        <trans-unit id="37bdec1f204951850d37528255d2ee12a6d8560b" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation the examples are put into an &lt;code&gt;$file_example.nim&lt;/code&gt; file, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="translated">Генератор документации знает об этих примерах и считает их частью комментария &lt;code&gt;##&lt;/code&gt; doc. На последнем этапе создания документации примеры помещаются в файл &lt;code&gt;$file_example.nim&lt;/code&gt; , компилируются и тестируются. Собранные примеры помещаются в отдельный модуль, чтобы гарантировать, что примеры не относятся к неэкспортированным символам.</target>
        </trans-unit>
        <trans-unit id="1d6f51cc7af628cca8e6d65688dcf5a3aea1a258" translate="yes" xml:space="preserve">
          <source>The effect system (&lt;code&gt;raises: []&lt;/code&gt;) does not work with async procedures.</source>
          <target state="translated">Система эффектов ( &lt;code&gt;raises: []&lt;/code&gt; ) не работает с асинхронными процедурами.</target>
        </trans-unit>
        <trans-unit id="c5c6ad0fa17f28cab354438579a552a5a86576fc" translate="yes" xml:space="preserve">
          <source>The empty &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; is a &lt;em&gt;do nothing&lt;/em&gt; statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">Пустой &lt;a href=&quot;#procedures-discard-statement&quot;&gt;оператор сброса&lt;/a&gt; - это оператор &lt;em&gt;ничего не делать&lt;/em&gt; . Компилятор знает, что оператор case с частью else не может дать сбой, и поэтому ошибка исчезает. Обратите внимание, что невозможно охватить все возможные строковые значения: поэтому для строковых случаев всегда нужна ветвь &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d537489684ccaa630656ec96401b6693a6022d" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;[]&lt;/code&gt; subscript notation can be used to &lt;em&gt;derefer&lt;/em&gt; a reference, meaning to retrieve the item the reference points to. The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">Нотация пустого индекса &lt;code&gt;[]&lt;/code&gt; может использоваться для &lt;em&gt;разыменования&lt;/em&gt; ссылки, то есть для извлечения элемента, на который указывает ссылка. Файл &lt;code&gt;.&lt;/code&gt; (доступ к оператору поля кортежа / объекта) и операторы &lt;code&gt;[]&lt;/code&gt; (оператор индекса массива / строки / последовательности) выполняют неявные операции разыменования для ссылочных типов:</target>
        </trans-unit>
        <trans-unit id="ffc8ff3a5600abff18d1541feff45aa3dbf706b3" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;except&lt;/code&gt; part is executed if there is an exception that is not explicitly listed. It is similar to an &lt;code&gt;else&lt;/code&gt; part in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">Пустая часть &lt;code&gt;except&lt;/code&gt; выполняется, если есть исключение, которое явно не указано. Это похоже на часть &lt;code&gt;else&lt;/code&gt; в операторах &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65c91587bac500ac8c7817439d895663e0f5eef7" translate="yes" xml:space="preserve">
          <source>The empty &lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt; clause is executed if there is an exception that is not listed otherwise. It is similar to an &lt;code&gt;else&lt;/code&gt; clause in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">Предложение пустое &lt;span id=&quot;except_1&quot;&gt;исключение&lt;/span&gt; выполняется, если есть исключение, которое не указано иначе. Это похоже на предложение &lt;code&gt;else&lt;/code&gt; в операторах &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c1d4d209aa8e17c99e2eb2160eabae179a2322b" translate="yes" xml:space="preserve">
          <source>The empty table can be written &lt;code&gt;{:}&lt;/code&gt; (in contrast to the empty set which is &lt;code&gt;{}&lt;/code&gt;) which is thus another way to write as the empty array constructor &lt;code&gt;[]&lt;/code&gt;. This slightly unusual way of supporting tables has lots of advantages:</source>
          <target state="translated">Пустая таблица может быть записана &lt;code&gt;{:}&lt;/code&gt; (в отличие от пустого набора, которым является &lt;code&gt;{}&lt;/code&gt; ), что, таким образом, является другим способом записи в качестве конструктора пустого массива &lt;code&gt;[]&lt;/code&gt; . Этот несколько необычный способ поддержки таблиц имеет ряд преимуществ:</target>
        </trans-unit>
        <trans-unit id="64a046b2305ba9ca93a6dc63513571f740cfbd0a" translate="yes" xml:space="preserve">
          <source>The error function</source>
          <target state="translated">Функция ошибки</target>
        </trans-unit>
        <trans-unit id="07d3a0d65c780c53b944c8f6088eecf4c5ac94f3" translate="yes" xml:space="preserve">
          <source>The example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.</source>
          <target state="translated">Пример также показывает,что тело proc может состоять из одного выражения,значение которого затем возвращается неявно.</target>
        </trans-unit>
        <trans-unit id="1ee7135c60a97c9109575a0365bdcd4548a56a80" translate="yes" xml:space="preserve">
          <source>The example is silly, since a vector is better modelled by a tuple which already provides &lt;code&gt;v[]&lt;/code&gt; access.</source>
          <target state="translated">Пример глупый, поскольку вектор лучше моделируется кортежем, который уже предоставляет доступ &lt;code&gt;v[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c91aee76f225823a200aa2713bba977502db3e5" translate="yes" xml:space="preserve">
          <source>The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of &lt;code&gt;add&lt;/code&gt; is used. The built-in &lt;code&gt;add&lt;/code&gt; procedure for sequences is not hidden and is used in the &lt;code&gt;preorder&lt;/code&gt; iterator.</source>
          <target state="translated">В примере показано общее двоичное дерево. В зависимости от контекста скобки используются либо для введения параметров типа, либо для создания экземпляра универсального процесса, итератора или типа. Как показывает пример, дженерики работают с перегрузкой: используется лучшее соответствие &lt;code&gt;add&lt;/code&gt; . Встроенная процедура &lt;code&gt;add&lt;/code&gt; последовательностей не скрывается и используется в итераторе &lt;code&gt;preorder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f68d69ad3fae0ae0b097e4eebbbc1987f9438cae" translate="yes" xml:space="preserve">
          <source>The example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).</source>
          <target state="translated">В примере используется временный цикл,чтобы продолжать запрашивать у пользователей их имена до тех пор,пока пользователь ничего не набирает (только нажимает RETURN).</target>
        </trans-unit>
        <trans-unit id="9e69f04e6b758773caa47fda144764cd2b769f26" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an &lt;code&gt;except&lt;/code&gt; part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">Исключение &lt;em&gt;используется&lt;/em&gt; в части &lt;code&gt;except&lt;/code&gt; . Если исключение не обрабатывается, оно распространяется через стек вызовов. Это означает, что часто остальная часть процедуры, не входящая в предложение &lt;code&gt;finally&lt;/code&gt; , не выполняется (если возникает исключение).</target>
        </trans-unit>
        <trans-unit id="ff3ed48d6f7129871b8222e272bcbad9f0531ac9" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">Исключение &lt;em&gt;обрабатывается&lt;/em&gt; обработчиком исключений. Однако обработчик исключений может вызвать другое исключение. Если исключение не обрабатывается, оно распространяется через стек вызовов. Это означает, что часто остальная часть процедуры, не входящая в предложение &lt;code&gt;finally&lt;/code&gt; , не выполняется (если возникает исключение).</target>
        </trans-unit>
        <trans-unit id="c1d798ae9282ab3c90cac1e64ce5600a12ced505" translate="yes" xml:space="preserve">
          <source>The exception tracking is part of Nim's &lt;span id=&quot;effect-system_1&quot;&gt;effect system&lt;/span&gt;. Raising an exception is an &lt;em&gt;effect&lt;/em&gt;. Other effects can also be defined. A user defined effect is a means to &lt;em&gt;tag&lt;/em&gt; a routine and to perform checks against this tag:</source>
          <target state="translated">Отслеживание исключений - часть системы &lt;span id=&quot;effect-system_1&quot;&gt;эффектов&lt;/span&gt; Нима . Возникновение исключения - это &lt;em&gt;эффект&lt;/em&gt; . Также можно определить другие эффекты. Определяемый пользователем эффект - это средство &lt;em&gt;пометить&lt;/em&gt; процедуру и выполнить проверки по этому тегу:</target>
        </trans-unit>
        <trans-unit id="f4d218a789a1df54f173c0ece34a43f3b86bc503" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are stricly speaking not catchable as they can also be mapped to an operation that terminates the whole process. Exceptions that indicate any other runtime error that can be caught inherit from &lt;code&gt;system.CatchableError&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;).</source>
          <target state="translated">Дерево исключений определяется в &lt;a href=&quot;system&quot;&gt;системном&lt;/a&gt; модуле. Каждое исключение наследуется от &lt;code&gt;system.Exception&lt;/code&gt; . Исключения, которые указывают на программные ошибки, наследуются от &lt;code&gt;system.Defect&lt;/code&gt; (который является подтипом &lt;code&gt;Exception&lt;/code&gt; ) и, строго говоря, не поддаются улавливанию, поскольку они также могут быть сопоставлены с операцией, завершающей весь процесс. Исключения, указывающие на любую другую ошибку времени выполнения, которая может быть обнаружена, наследуются от &lt;code&gt;system.CatchableError&lt;/code&gt; (который является подтипом &lt;code&gt;Exception&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8eb9fe59b5acee224134869a4fa8ee343bb10bba" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;x.f&lt;/code&gt; needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to &lt;code&gt;f(x)&lt;/code&gt;. Therefore the dot syntax has some limitations when it is used to invoke templates/macros:</source>
          <target state="translated">Выражение &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;x.f&lt;/code&gt; необходимо семантически проверить (что означает поиск символов и проверку типа), прежде чем можно будет решить, что его нужно переписать в &lt;code&gt;f(x)&lt;/code&gt; . Поэтому точечный синтаксис имеет некоторые ограничения, когда он используется для вызова шаблонов / макросов:</target>
        </trans-unit>
        <trans-unit id="5d1f3451fa30a273a7f6aed76323af4d8616546f" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;em&gt;#&lt;/em&gt; and whitespace are ignored.</source>
          <target state="translated">Расширенный означает, что комментарии, начинающиеся с символа &lt;em&gt;#&lt;/em&gt; и пробела, игнорируются.</target>
        </trans-unit>
        <trans-unit id="12b4cab5727b122b7b1ec87cba8d2831f9aab5a6" translate="yes" xml:space="preserve">
          <source>The field identifiers inside a tuple or object definition are valid in the following places:</source>
          <target state="translated">Идентификаторы полей внутри кортежа или определения объектов действительны в следующих местах:</target>
        </trans-unit>
        <trans-unit id="dd916f7a49d8a7ac10551fea591882cb2dbe45da" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish another simple task: To determine all the links an HTML document contains.</source>
          <target state="translated">Файл &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; демонстрирует, как использовать синтаксический анализатор XML для выполнения другой простой задачи: определения всех ссылок, содержащихся в документе HTML.</target>
        </trans-unit>
        <trans-unit id="20888f5db03e3bbd07212160a3014e7495057d4b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish a simple task: To determine the title of an HTML document.</source>
          <target state="translated">Файл &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; демонстрирует, как использовать синтаксический анализатор XML для выполнения простой задачи: определить заголовок документа HTML.</target>
        </trans-unit>
        <trans-unit id="787b89eaa57a97560754c43aa4b06898c7b48aec" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &quot;&quot; for POSIX, &quot;bat&quot; on Windows.</source>
          <target state="translated">Расширение файла скрипта.Например:&quot;&quot; для POSIX,&quot;летучая мышь&quot; для Windows.</target>
        </trans-unit>
        <trans-unit id="8875b78032e0936292139b8d9ad9a639776438c6" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &quot;&quot; for POSIX, &quot;exe&quot; on Windows.</source>
          <target state="translated">Файловое расширение нативных исполняемых файлов.Например:&quot;&quot; для POSIX,&quot;exe&quot; для Windows.</target>
        </trans-unit>
        <trans-unit id="aa1522384259bb7f728de722e2a3a3b90755fa75" translate="yes" xml:space="preserve">
          <source>The file mode when opening a file.</source>
          <target state="translated">Режим работы с файлами при открытии файла.</target>
        </trans-unit>
        <trans-unit id="b0d5634247976656f5fce2a230b840835d3dfc38" translate="yes" xml:space="preserve">
          <source>The file you want to perform the query on. Usually you will pass in the same value as &lt;strong&gt;proj.nim&lt;/strong&gt;.</source>
          <target state="translated">Файл, по которому вы хотите выполнить запрос. Обычно вы передаете то же значение, что и &lt;strong&gt;proj.nim&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d49d4484596c8b0e0159eb69ef8f9c586d3b72f8" translate="yes" xml:space="preserve">
          <source>The filter transforms this into:</source>
          <target state="translated">Фильтр превращает это в:</target>
        </trans-unit>
        <trans-unit id="ca2479d6b8b610f51a5a98ec6a8fac67b9578c0a" translate="yes" xml:space="preserve">
          <source>The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.</source>
          <target state="translated">Последний слой-это асинхронная ожидающая трансформация.Это позволяет писать асинхронный код в синхронном стиле и работает аналогично ожиданию на C#.Преобразование работает путем преобразования любых асинхронных процедур в итератор.</target>
        </trans-unit>
        <trans-unit id="92e24af529f18eee0612283d52e69f9a932a8269" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files form &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="translated">Первая команда запускает компилятор Nim с тремя специальными параметрами, чтобы избежать генерации функции &lt;code&gt;main()&lt;/code&gt; в сгенерированных файлах, избежать связывания объектных файлов с конечным двоичным файлом и явно создать файл заголовка для интеграции C. Все сгенерированные файлы помещаются в каталог &lt;code&gt;nimcache&lt;/code&gt; . Вот почему следующая команда компилирует &lt;code&gt;maths.c&lt;/code&gt; код maths.c плюс все файлы &lt;code&gt;.c&lt;/code&gt; из &lt;code&gt;nimcache&lt;/code&gt; . В дополнение к этому пути вы также должны указать компилятору C, где найти &lt;code&gt;nimbase.h&lt;/code&gt; заголовка Nimbase.h от Nim .</target>
        </trans-unit>
        <trans-unit id="2e1aabe2958ba075f566d5962b4d499e691da35a" translate="yes" xml:space="preserve">
          <source>The first line indicates the main project file.</source>
          <target state="translated">Первая строка указывает на основной файл проекта.</target>
        </trans-unit>
        <trans-unit id="070b4e293fffd6ce73b8fe7be23fcf1de6e8b78b" translate="yes" xml:space="preserve">
          <source>The first program</source>
          <target state="translated">Первая программа</target>
        </trans-unit>
        <trans-unit id="d0b3d98d639136123acdde78f568ba55378801a8" translate="yes" xml:space="preserve">
          <source>The first thing to note is that all callable types have at least a comma, even if they don't have any parameters. If there are parameters, they are represented by their types and will be comma separated. To the plain symbol a suffix may be added depending on the type of the callable:</source>
          <target state="translated">Первое,что следует отметить,это то,что все вызываемые типы имеют как минимум запятую,даже если у них нет никаких параметров.Если есть параметры,то они представлены своими типами и будут разделены запятыми.К обычному символу может быть добавлен суффикс в зависимости от типа вызываемого:</target>
        </trans-unit>
        <trans-unit id="4999312ef44c80455b502761b700c78c2fa7ee69" translate="yes" xml:space="preserve">
          <source>The first thing you will always need to do in order to start using sockets, is to create a new instance of the &lt;code&gt;Socket&lt;/code&gt; type using the &lt;code&gt;newSocket&lt;/code&gt; procedure.</source>
          <target state="translated">Первое, что вам всегда нужно делать, чтобы начать использовать сокеты, - это создать новый экземпляр типа &lt;code&gt;Socket&lt;/code&gt; с &lt;code&gt;newSocket&lt;/code&gt; процедуры newSocket .</target>
        </trans-unit>
        <trans-unit id="492b47655f6079de4ef1caff7c3c1bff381df22c" translate="yes" xml:space="preserve">
          <source>The first version uses &lt;em&gt;cmp&lt;/em&gt; to compare the elements. The expected return values are the same as that of system.cmp. The second version uses the default comparison function &lt;em&gt;cmp&lt;/em&gt;.</source>
          <target state="translated">Первая версия использует &lt;em&gt;cmp&lt;/em&gt; для сравнения элементов. Ожидаемые возвращаемые значения такие же, как у system.cmp. Вторая версия использует функцию сравнения по умолчанию &lt;em&gt;cmp&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f04db68a5b3cac0d3a181a32ee15094e36574928" translate="yes" xml:space="preserve">
          <source>The following Nim code:</source>
          <target state="translated">Следующий Ним-код:</target>
        </trans-unit>
        <trans-unit id="7ffd87a515c30c8b2fec87be6689a08608b581e5" translate="yes" xml:space="preserve">
          <source>The following algorithm (in pseudo-code) determines whether two types are equal with no respect to &lt;code&gt;distinct&lt;/code&gt; types. For brevity the cycle check with an auxiliary set &lt;code&gt;s&lt;/code&gt; is omitted:</source>
          <target state="translated">Следующий алгоритм (в псевдокоде) определяет, равны ли два типа без учета &lt;code&gt;distinct&lt;/code&gt; типов. Для краткости проверка цикла с вспомогательным набором &lt;code&gt;s&lt;/code&gt; опущена:</target>
        </trans-unit>
        <trans-unit id="6090c7cb57b21b2858f8d3bdfeddde8fc3e0c835" translate="yes" xml:space="preserve">
          <source>The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="translated">Следующие встроенные профили не могут быть перегружены по причинам простоты реализации (они требуют специализированной семантической проверки):</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">Следующий код:</target>
        </trans-unit>
        <trans-unit id="9e6abf51c6a7caaa00936172c084814413d0375a" translate="yes" xml:space="preserve">
          <source>The following dot operators are available:</source>
          <target state="translated">Доступны следующие точечные операторы:</target>
        </trans-unit>
        <trans-unit id="64478c18e3d0e98035bc04ab8a881a14b95dcc0f" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a simple chat server.</source>
          <target state="translated">Следующий пример демонстрирует простой чат-сервер.</target>
        </trans-unit>
        <trans-unit id="0f231e3e3462123dc4c8a24dcb21c49c8592a8ba" translate="yes" xml:space="preserve">
          <source>The following example demonstrates loading a function called 'greet' from a library that is determined at runtime based upon a language choice. If the library fails to load or the function 'greet' is not found, it quits with a failure error code.</source>
          <target state="translated">Следующий пример демонстрирует загрузку функции под названием 'greet' из библиотеки,которая определяется во время выполнения на основе выбора языка.Если библиотека не загружается или функция 'greet' не найдена,то она завершает работу с кодом ошибки.</target>
        </trans-unit>
        <trans-unit id="1d58b86348511b493c86a97949db3309ab3fe22e" translate="yes" xml:space="preserve">
          <source>The following example demonstrates logging to three different handlers simultaneously:</source>
          <target state="translated">Следующий пример демонстрирует протоколирование трех различных обработчиков одновременно:</target>
        </trans-unit>
        <trans-unit id="cf3bc2b5c483a0603436689403c8ba9fb562644c" translate="yes" xml:space="preserve">
          <source>The following example implements a powerful &lt;code&gt;debug&lt;/code&gt; command that accepts a variable number of arguments:</source>
          <target state="translated">В следующем примере реализуется мощная команда &lt;code&gt;debug&lt;/code&gt; которая принимает переменное количество аргументов:</target>
        </trans-unit>
        <trans-unit id="4f734436e3f885c81c0eadfbb6a2b481609c6a63" translate="yes" xml:space="preserve">
          <source>The following example outlines a macro that generates a lexical analyzer from regular expressions:</source>
          <target state="translated">Следующий пример описывает макрос,который генерирует лексический анализатор из регулярных выражений:</target>
        </trans-unit>
        <trans-unit id="13db42d616e29834b46f311e3a54ec91b9956d97" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modelled:</source>
          <target state="translated">В следующем примере показано,как можно смоделировать общее двоичное дерево:</target>
        </trans-unit>
        <trans-unit id="873ce1a1fdbf3cb02ed243f39b15af534c75db54" translate="yes" xml:space="preserve">
          <source>The following example shows how some form of hoisting can be implemented:</source>
          <target state="translated">Следующий пример показывает,как может быть реализована та или иная форма подъема:</target>
        </trans-unit>
        <trans-unit id="a71a0ac5c57a9a249cd9d88a6571b08a6d33aaff" translate="yes" xml:space="preserve">
          <source>The following example shows how some simple partial evaluation can be implemented with term rewriting:</source>
          <target state="translated">Следующий пример показывает,как некоторые простые частичные оценки могут быть реализованы с помощью переписывания терминов:</target>
        </trans-unit>
        <trans-unit id="49a73336f3c49f017bc0c2b05195fd5ec881be73" translate="yes" xml:space="preserve">
          <source>The following examples will generate documentation for the below contrived &lt;em&gt;Nim&lt;/em&gt; module, aptly named 'sample.nim'</source>
          <target state="translated">Следующие примеры будут генерировать документацию для созданного ниже модуля &lt;em&gt;Nim&lt;/em&gt; , метко названного 'sample.nim'</target>
        </trans-unit>
        <trans-unit id="bca8bd37c432e705556c08bdad3554df72311569" translate="yes" xml:space="preserve">
          <source>The following floating point types are pre-defined:</source>
          <target state="translated">Предварительно определены следующие типы с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="e001b72ea1919b9c8b5454d3e5745443232dfc3d" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved and cannot be used as identifiers:</source>
          <target state="translated">Следующие ключевые слова зарезервированы и не могут быть использованы в качестве идентификаторов:</target>
        </trans-unit>
        <trans-unit id="7a481f800b73584de7da49ba29d51edc5e8e325d" translate="yes" xml:space="preserve">
          <source>The following nim code:</source>
          <target state="translated">Следующий ним-код:</target>
        </trans-unit>
        <trans-unit id="6a498725f77daa319527cf92f4474c6333dfd7c1" translate="yes" xml:space="preserve">
          <source>The following paragraphs are mostly a reminder for myself. Things to keep in mind:</source>
          <target state="translated">Следующие параграфы в основном напоминают мне о себе.Вещи,которые нужно иметь в виду:</target>
        </trans-unit>
        <trans-unit id="61304b559e87418b6d1e3732c6eb734eea6a3b9b" translate="yes" xml:space="preserve">
          <source>The following section defines several relations on types that are needed to describe the type checking done by the compiler.</source>
          <target state="translated">Следующий раздел определяет несколько отношений по типам,которые необходимы для описания проверки типов,выполняемой компилятором.</target>
        </trans-unit>
        <trans-unit id="9926ea103ae5593a38a4d6fb91b32805b8670e76" translate="yes" xml:space="preserve">
          <source>The following sections define the expected output for each kind of symbol for which idetools returns valid output.</source>
          <target state="translated">Следующие разделы определяют ожидаемый вывод для каждого типа символов,для которых idetools возвращает действительный вывод.</target>
        </trans-unit>
        <trans-unit id="6af8e1a2f34a50e4507418236b89fc3d2ccf3867" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each of the metacharacters.</source>
          <target state="translated">В следующих разделах описывается использование каждого из метасимволов.</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">Следующие строки обозначают другие жетоны:</target>
        </trans-unit>
        <trans-unit id="fb3d56eb3ea6e9604bb48a3710981f35773bad09" translate="yes" xml:space="preserve">
          <source>The format string to turn a filename into a &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; file (also called &lt;span id=&quot;shared-object_1&quot;&gt;shared object&lt;/span&gt; on some operating systems).</source>
          <target state="translated">Строка формата для преобразования имени файла в файл &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; (также называемый &lt;span id=&quot;shared-object_1&quot;&gt;общим объектом&lt;/span&gt; в некоторых операционных системах).</target>
        </trans-unit>
        <trans-unit id="e0651b47a0b75f9bee920150d8eee4c5416bccac" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the iterator is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the iterator.</source>
          <target state="translated">Четвертый столбец будет пустой строкой,если задан итератор,так как на тот момент в файле парсер еще не обработал всю строку.Сигнатура будет возвращена полной в последующих экземплярах итератора.</target>
        </trans-unit>
        <trans-unit id="44fc97c45a76e00051690505a1a829c9f330d1aa" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the macro is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the macro.</source>
          <target state="translated">Четвертый столбец будет пустой строкой,если задан макрос,так как на тот момент в файле парсер еще не обработал всю строку.Сигнатура будет возвращена полной в последующих экземплярах макроса.</target>
        </trans-unit>
        <trans-unit id="d08eba1a7248e709a58efba0473c7cce761f8eca" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the method is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the method.</source>
          <target state="translated">Четвертая колонка будет пустой строкой,если определяется метод,так как на тот момент в файле синтаксический анализатор еще не обработал всю строку.Сигнатура будет возвращена полной в последующих экземплярах метода.</target>
        </trans-unit>
        <trans-unit id="9cac080ce5d18f814923daa287cef0ac2f3d19be" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the proc is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the proc.</source>
          <target state="translated">Четвертый столбец будет пустой строкой,если определяется proc,так как на тот момент в файле синтаксический анализатор еще не обработал всю строку.Подпись будет возвращена полной в последующих экземплярах proc.</target>
        </trans-unit>
        <trans-unit id="54e7544248ea9ef4bea128a267709875e2c3f3de" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the template is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the template.</source>
          <target state="translated">Четвертая колонка будет пустой строкой,если задан шаблон,так как на тот момент в файле парсер еще не обработал всю строку.Сигнатура будет возвращена полной в последующих экземплярах шаблона.</target>
        </trans-unit>
        <trans-unit id="55c1deefa556120681916d6951582e608271f06c" translate="yes" xml:space="preserve">
          <source>The fourth use of backslash is for certain &lt;span id=&quot;simple-assertions_1&quot;&gt;simple assertions&lt;/span&gt;. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are::</source>
          <target state="translated">Четвертое использование обратной косой черты - для некоторых &lt;span id=&quot;simple-assertions_1&quot;&gt;простых утверждений&lt;/span&gt; . Утверждение определяет условие, которое должно быть выполнено в определенной точке совпадения, без использования каких-либо символов из строки темы. Использование подшаблонов для более сложных утверждений описано ниже. Утверждения с обратной косой чертой:</target>
        </trans-unit>
        <trans-unit id="870186741ca6e1d444f360ccba4f4fded87a39e7" translate="yes" xml:space="preserve">
          <source>The fractional part of duration, as a duration.</source>
          <target state="translated">Дробная часть длительности,как длительность.</target>
        </trans-unit>
        <trans-unit id="4f2b0c3709a2752c88fc8474be143cd0204e9b79" translate="yes" xml:space="preserve">
          <source>The full output can be seen here: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt;. It runs after semantic checking, and includes pragmas attached implicitly by the compiler.</source>
          <target state="translated">Полный вывод можно увидеть здесь: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt; . Он запускается после семантической проверки и включает прагмы, неявно прикрепленные компилятором.</target>
        </trans-unit>
        <trans-unit id="552ab82c6faae30ed9dbac63563f851d644aaccd" translate="yes" xml:space="preserve">
          <source>The functionality implemented by &lt;code&gt;HttpClient&lt;/code&gt; and &lt;code&gt;AsyncHttpClient&lt;/code&gt; is the same, so you can use whichever one suits you best in the examples shown here.</source>
          <target state="translated">Функциональность, реализованная &lt;code&gt;HttpClient&lt;/code&gt; и &lt;code&gt;AsyncHttpClient&lt;/code&gt; , одинакова, поэтому вы можете использовать тот, который вам больше всего подходит в приведенных здесь примерах.</target>
        </trans-unit>
        <trans-unit id="59835708b577fecda7c831ca2458e4c628fc710f" translate="yes" xml:space="preserve">
          <source>The future stream is completed (this means that no more data will be written).</source>
          <target state="translated">Будущий поток завершен (это означает,что больше никаких данных не будет записываться).</target>
        </trans-unit>
        <trans-unit id="9be33b21289a1eef5808366623258d9dbcbaa46c" translate="yes" xml:space="preserve">
          <source>The gamma function</source>
          <target state="translated">Гамма-функция</target>
        </trans-unit>
        <trans-unit id="7a4585c32f1f4c6914153a2005cd46dd9de070e8" translate="yes" xml:space="preserve">
          <source>The gamma function &lt;strong&gt;Deprecated since version 0.19.0&lt;/strong&gt;: Use &lt;code&gt;gamma&lt;/code&gt; instead.</source>
          <target state="translated">Гамма-функция Не &lt;strong&gt;рекомендуется, начиная с версии 0.19.0&lt;/strong&gt; : используйте &lt;code&gt;gamma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da16bec30ab8a97eb878d0183e447bbc8ee7a461" translate="yes" xml:space="preserve">
          <source>The general form of a standard format specifier is:</source>
          <target state="translated">Общая форма стандартного спецификатора формата:</target>
        </trans-unit>
        <trans-unit id="c09a581cb8f65c3c5d14cf7a67dcb119a964cc82" translate="yes" xml:space="preserve">
          <source>The generated C code will not have any explicit calling convention and thus use the C compiler's default calling convention. This is needed because Nim's default calling convention for procedures is &lt;code&gt;fastcall&lt;/code&gt; to improve speed.</source>
          <target state="translated">Сгенерированный код C не будет иметь явного соглашения о вызовах и, следовательно, будет использовать соглашение о вызовах по умолчанию компилятора C. Это необходимо, потому что стандартное соглашение о &lt;code&gt;fastcall&lt;/code&gt; Nim для процедур - fastcall для повышения скорости.</target>
        </trans-unit>
        <trans-unit id="b7379e59f2bd87fdbadd32039106a54f883a446d" translate="yes" xml:space="preserve">
          <source>The generated HTML for some of these wrappers is so huge that it is not contained in the distribution. You can then find them on the website.</source>
          <target state="translated">Сгенерированный HTML для некоторых из этих оберток настолько огромен,что не содержится в дистрибутиве.Вы можете найти их на сайте.</target>
        </trans-unit>
        <trans-unit id="aa03edbbdb0c3d938f260d58cb5ca2f51408059e" translate="yes" xml:space="preserve">
          <source>The generated files that Nim produces all go into a subdirectory called &lt;code&gt;nimcache&lt;/code&gt;. Its full path is</source>
          <target state="translated">Все сгенерированные файлы, которые создает Nim, &lt;code&gt;nimcache&lt;/code&gt; в подкаталог с именем nimcache . Его полный путь</target>
        </trans-unit>
        <trans-unit id="4c785c59836bb83ab636f8a5d0cda606ab17c5e4" translate="yes" xml:space="preserve">
          <source>The generated index. &lt;strong&gt;Index + (Ctrl+F) == Joy&lt;/strong&gt;</source>
          <target state="translated">Сгенерированный index. &lt;strong&gt;Индекс + (Ctrl + F) == Радость&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f790d93cc82c110db5a7f7d8300334c9fc7c8808" translate="yes" xml:space="preserve">
          <source>The getrlimit() system call gets resource limits.</source>
          <target state="translated">Системный вызов getrlimit()получает лимит ресурсов.</target>
        </trans-unit>
        <trans-unit id="dba6185483a07591222dc085893c06cb1d77fd81" translate="yes" xml:space="preserve">
          <source>The good news is not much has changed! First, we need to change the handling of the input parameter (line 3). In the dynamic version the &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc receives a string parameter. However, in the macro version it is also declared as string, but this is the &lt;em&gt;outside&lt;/em&gt; interface of the macro. When the macro is run, it actually gets a &lt;code&gt;PNimNode&lt;/code&gt; object instead of a string, and we have to call the &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (line 5) from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt; to obtain the string being passed in to the macro.</source>
          <target state="translated">Хорошая новость: изменилось немногое! Во-первых, нам нужно изменить обработку входного параметра (строка 3). В динамической версии процедура &lt;code&gt;readCfgAtRuntime&lt;/code&gt; получает строковый параметр. Однако в версии макроса он также объявлен как строка, но это &lt;em&gt;внешний&lt;/em&gt; интерфейс макроса. Когда макрос запускается, он фактически получает объект &lt;code&gt;PNimNode&lt;/code&gt; вместо строки, и мы должны вызвать процедуру &lt;a href=&quot;macros#strVal&quot;&gt;strVal&lt;/a&gt; (строка 5) из &lt;a href=&quot;macros&quot;&gt;модуля макросов,&lt;/a&gt; чтобы получить строку, передаваемую в макрос.</target>
        </trans-unit>
        <trans-unit id="14f57dccb74a2123a9f5546e3bebaee4e90cb289" translate="yes" xml:space="preserve">
          <source>The grammar's start symbol is &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">Начальный символ грамматики - &lt;code&gt;module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6743543c75d60b9f024c8d8ce6011899979a9a7" translate="yes" xml:space="preserve">
          <source>The greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.</source>
          <target state="translated">Программа приветствий состоит из 3-х высказываний,которые выполняются последовательно.Это может сойти с рук только самым примитивным программам:разветвление и петлевание тоже необходимы.</target>
        </trans-unit>
        <trans-unit id="ac70a8fca453e797498ff8e165be78d4d719a059" translate="yes" xml:space="preserve">
          <source>The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:</source>
          <target state="translated">Охранник не обязательно должен быть какого-либо конкретного типа.Он достаточно гибкий,чтобы моделировать механизмы без замков низкого уровня:</target>
        </trans-unit>
        <trans-unit id="d0d6ece26593eceae5133245593e5e87cf3e06f3" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">Обращение с обратным слешем,за которым следует цифра,отличная от 0,является сложным.Вне класса символов PCRE считывает его и любые последующие цифры как десятичное число.Если число меньше 10,или если в выражении было,по крайней мере,так много предыдущих захватов левых круглых скобок,вся последовательность берется как обратная ссылка.Описание того,как это работает,будет дано позже,после обсуждения подмакетов в круглых скобках.</target>
        </trans-unit>
        <trans-unit id="a0b88ec5fc66250e8218fe5157065e3562f9959e" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="translated">Функция дампа кучи все еще находится в зачаточном состоянии, но она уже оказалась полезной для нас, поэтому может быть полезной для вас. Чтобы получить дамп кучи, скомпилируйте с &lt;code&gt;-d:nimTypeNames&lt;/code&gt; и вызовите &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; в стратегическом месте вашей программы. Это создает список типов, используемых в вашей программе, и для каждого типа общее количество экземпляров объекта для этого типа, а также общее количество байтов, которые эти экземпляры занимают. В настоящий момент этот список не отсортирован! Вам нужно использовать взлом внешнего сценария оболочки, чтобы отсортировать его.</target>
        </trans-unit>
        <trans-unit id="eddf728b23d010d05fee2b18ba2bee9bcf3ad561" translate="yes" xml:space="preserve">
          <source>The hostname of the client that made the request.</source>
          <target state="translated">Имя хоста клиента,сделавшего запрос.</target>
        </trans-unit>
        <trans-unit id="ae4bd9577099eefd3ac234c48f0755b6cae28779" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible, ranging from 0-23.</source>
          <target state="translated">Часы в одной цифре,если возможно,в диапазоне от 0 до 23.</target>
        </trans-unit>
        <trans-unit id="508ac3f8b6d5beb7c16ecbb475b705dc160e6aea" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible. Ranging from 1-12.</source>
          <target state="translated">Часы в одной цифре,если возможно.От 1 до 12.</target>
        </trans-unit>
        <trans-unit id="6e46e361665712eacbeb9a335f8ac314ff87abf9" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. 0 is prepended if the hour is one digit.</source>
          <target state="translated">Часы в двух цифрах всегда.0 предваряется,если час-одна цифра.</target>
        </trans-unit>
        <trans-unit id="35c9e4c595e71cdcb96dde240197d1b8a79fe6b5" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit 0 is prepended.</source>
          <target state="translated">Часы в двух цифрах всегда.Если час-одна цифра 0,то предваряется.</target>
        </trans-unit>
        <trans-unit id="dcaf88b5d30ee42061a975ec06cd4f726da65a81" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;em&gt;type&lt;/em&gt; modifier to create a named instance of the type itself:</source>
          <target state="translated">Идентификаторы, следующие за ключевым словом &lt;code&gt;concept&lt;/code&gt; , представляют экземпляры текущего сопоставленного типа. Вы можете применить любой из стандартных модификаторов типа, таких как &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ptr&lt;/code&gt; и &lt;code&gt;static&lt;/code&gt; , для обозначения более конкретного типа экземпляра. Вы также можете применить модификатор &lt;em&gt;типа&lt;/em&gt; для создания именованного экземпляра самого типа:</target>
        </trans-unit>
        <trans-unit id="bbb5916fc4882a2710c89523611ae3521f422971" translate="yes" xml:space="preserve">
          <source>The idetools command can be run as a compiler service (CAAS), where you first launch the compiler and it will stay online as a server, accepting queries in a telnet like fashion. The advantage of staying on is that for many queries the compiler can cache the results of the compilation, and subsequent queries should be fast in the millisecond range, thus being responsive enough for IDEs.</source>
          <target state="translated">Команда idetools может быть запущена как служба компиляции (CAAS),где вы сначала запустите компилятор,и он останется онлайн в качестве сервера,принимая запросы в telnet как модно.Преимущество работы в том,что для многих запросов компилятор может кэшировать результаты компиляции,а последующие запросы должны быть быстрыми в диапазоне миллисекунд,таким образом,будучи достаточно отзывчивыми для IDE.</target>
        </trans-unit>
        <trans-unit id="79d04054b05925070544c64b6a10b2d6f82716f2" translate="yes" xml:space="preserve">
          <source>The if statement is one way to branch the control flow:</source>
          <target state="translated">Если утверждение является одним из способов разветвления потока управления:</target>
        </trans-unit>
        <trans-unit id="186aff351d775e0607553eab0c0008691860c0dc" translate="yes" xml:space="preserve">
          <source>The imaginary unit. &amp;radic;-1.</source>
          <target state="translated">Мнимая единица. &amp;radic;-1.</target>
        </trans-unit>
        <trans-unit id="2e0e8535555370a430de44e05424a154580b342b" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="translated">Непосредственная прагма устарела. См. &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Типизированные и нетипизированные параметры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc80eb338f0f7897699f01c0d17e46fc45536bb" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="translated">Реализация выравнивает поля для наилучшей производительности доступа.Выравнивание совместимо с тем,как это делает компилятор Си.</target>
        </trans-unit>
        <trans-unit id="a9335f13c424aeabf870c93de05f27167c506276" translate="yes" xml:space="preserve">
          <source>The implementation currently provides the following possible options (various others may be added later).</source>
          <target state="translated">Реализация в настоящее время предусматривает следующие возможные варианты (различные другие могут быть добавлены позже).</target>
        </trans-unit>
        <trans-unit id="c3d620a68814993a0e566de11d8cdb73db09b126" translate="yes" xml:space="preserve">
          <source>The implementation of the compilation cache is tricky: There are lots of issues to be solved for the front- and backend.</source>
          <target state="translated">Реализация кэша компиляции хитрая:для фронт-и бэкенда есть много проблем,которые необходимо решить.</target>
        </trans-unit>
        <trans-unit id="c05e5029b48899e6e6d2a69b1f77e63ebf121b7d" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="translated">Неявную инициализацию также можно предотвратить с помощью прагмы типа &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; . Компилятору требуется явная инициализация объекта и всех его полей. Однако он выполняет &lt;span id=&quot;control-flow-analysis_1&quot;&gt;анализ потока управления,&lt;/span&gt; чтобы доказать, что переменная была инициализирована, и не полагается на синтаксические свойства:</target>
        </trans-unit>
        <trans-unit id="6bee0de5240bc2aece39314fb5444f70f1444362" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be avoided for optimization reasons with the &lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; pragma:</source>
          <target state="translated">Неявной инициализации можно избежать по причинам оптимизации с помощью &lt;span id=&quot;noinit_1&quot;&gt;прагмы noinit&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="3b7fd6facf0715e6c58bb9982e48c189f4d6d0c2" translate="yes" xml:space="preserve">
          <source>The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.</source>
          <target state="translated">Обработка отпечатков осуществляется следующим образом:Лексер аннотирует следующий токен предыдущим количеством пробелов;отступ не является отдельным токеном.Этот трюк позволяет разобрать Ним,имея только 1 токен lookahead.</target>
        </trans-unit>
        <trans-unit id="beff0881d78e8e065e276388970843e17443daff" translate="yes" xml:space="preserve">
          <source>The index generation tools try to differentiate between documentation generated from &lt;code&gt;.nim&lt;/code&gt; files and documentation generated from &lt;code&gt;.txt&lt;/code&gt; or &lt;code&gt;.rst&lt;/code&gt; files. The former are always closely related to source code and consist mainly of API entries. The latter are generic documents meant for human reading.</source>
          <target state="translated">Инструменты генерации индекса пытаются различать документацию, созданную из файлов &lt;code&gt;.nim&lt;/code&gt; , и документацию, созданную из файлов &lt;code&gt;.txt&lt;/code&gt; или &lt;code&gt;.rst&lt;/code&gt; . Первые всегда тесно связаны с исходным кодом и состоят в основном из записей API. Последние представляют собой общие документы, предназначенные для чтения человеком.</target>
        </trans-unit>
        <trans-unit id="6306cc92a3bed777b6c141274a3bc860eba5a71d" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;docgen#index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="translated">Индекс не будет записан на диск, если вы не &lt;a href=&quot;#writeIndexFile&quot;&gt;вызовете writeIndexFile ()&lt;/a&gt; . Назначение индекса задокументировано в &lt;a href=&quot;docgen#index-switch&quot;&gt;руководстве по инструментам docgen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7771da68e022b74bd5731922346ef2df52d2b53c" translate="yes" xml:space="preserve">
          <source>The inference for read/write tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">Вывод для отслеживания чтения/записи аналогичен выводу для отслеживания исключений.</target>
        </trans-unit>
        <trans-unit id="8d228a4803537313b1b78b37775bd1778df6dcc5" translate="yes" xml:space="preserve">
          <source>The inference for tag tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">Умозаключение для слежения за меткой аналогично умозаключению для слежения за исключением.</target>
        </trans-unit>
        <trans-unit id="f5fb44e48abd9154517dcc0228213cb6390a548c" translate="yes" xml:space="preserve">
          <source>The inline convention means the the caller should not call the procedure, but inline its code directly. Note that Nim does not inline, but leaves this to the C compiler; it generates &lt;code&gt;__inline&lt;/code&gt; procedures. This is only a hint for the compiler: it may completely ignore it and it may inline procedures that are not marked as &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">Встроенное соглашение означает, что вызывающий должен не вызывать процедуру, а напрямую встроить ее код. Обратите внимание, что Nim не встраивается, но оставляет это компилятору C; он генерирует &lt;code&gt;__inline&lt;/code&gt; процедуры. Это только подсказка для компилятора: он может полностью игнорировать его и может встроить процедуры, которые не отмечены как &lt;code&gt;inline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0e8a627ab18ca245222565836c8b78837c0f702" translate="yes" xml:space="preserve">
          <source>The interaction between threads and exceptions is simple: A &lt;em&gt;handled&lt;/em&gt; exception in one thread cannot affect any other thread. However, an &lt;em&gt;unhandled&lt;/em&gt; exception in one thread terminates the whole &lt;em&gt;process&lt;/em&gt;!</source>
          <target state="translated">Взаимодействие между потоками и исключениями простое: &lt;em&gt;обработанное&lt;/em&gt; исключение в одном потоке не может повлиять на какой-либо другой поток. Однако &lt;em&gt;необработанное&lt;/em&gt; исключение в одном потоке завершает весь &lt;em&gt;процесс&lt;/em&gt; !</target>
        </trans-unit>
        <trans-unit id="a3f5985cf8e619dcc28842b0431cc6a248880914" translate="yes" xml:space="preserve">
          <source>The interesting thing is that our macro does not return a runtime &lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt; object. Instead, it builds up Nim source code into the &lt;code&gt;source&lt;/code&gt; variable. For each line of the configuration file a &lt;code&gt;const&lt;/code&gt; variable will be generated (line 15). To avoid conflicts we prefix these variables with &lt;code&gt;cfg&lt;/code&gt;. In essence, what the compiler is doing is replacing the line calling the macro with the following snippet of code:</source>
          <target state="translated">Интересно то, что наш макрос не возвращает объект &lt;a href=&quot;tables#Table&quot;&gt;таблицы&lt;/a&gt; времени выполнения . Вместо этого он встраивает исходный код Nim в &lt;code&gt;source&lt;/code&gt; переменную. Для каждой строки файла конфигурации &lt;code&gt;const&lt;/code&gt; переменной будет сгенерирован (строка 15). Чтобы избежать конфликтов, мы ставим перед этими переменными префикс &lt;code&gt;cfg&lt;/code&gt; . По сути, компилятор заменяет строку, вызывающую макрос, следующим фрагментом кода:</target>
        </trans-unit>
        <trans-unit id="7fda431dba2bcff15441a32a1ff7eabe4a0fcf00" translate="yes" xml:space="preserve">
          <source>The internal documentation describes how the compiler is implemented. Read this if you want to hack the compiler.</source>
          <target state="translated">Внутренняя документация описывает,как реализуется компилятор.Прочтите это,если вы хотите взломать компилятор.</target>
        </trans-unit>
        <trans-unit id="3e39595327b5d15b7987f46c8523802d25b3413e" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and &lt;em&gt;s2&lt;/em&gt; at the same time. Example:</source>
          <target state="translated">Пересечение двух множеств математически представлено как &lt;em&gt;A &amp;cap; B&lt;/em&gt; и представляет собой множество всех объектов, которые являются членами &lt;em&gt;s1&lt;/em&gt; и &lt;em&gt;s2&lt;/em&gt; одновременно. Пример:</target>
        </trans-unit>
        <trans-unit id="ea2460c0b5417fd480903274412d643b12ea3569" translate="yes" xml:space="preserve">
          <source>The language constructs are explained using an extended BNF, in which &lt;code&gt;(a)*&lt;/code&gt; means 0 or more &lt;code&gt;a&lt;/code&gt;'s, &lt;code&gt;a+&lt;/code&gt; means 1 or more &lt;code&gt;a&lt;/code&gt;'s, and &lt;code&gt;(a)?&lt;/code&gt; means an optional &lt;em&gt;a&lt;/em&gt;. Parentheses may be used to group elements.</source>
          <target state="translated">Языковые конструкции объясняются с использованием расширенного BNF, в котором &lt;code&gt;(a)*&lt;/code&gt; означает 0 или более &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;a+&lt;/code&gt; означает 1 или более &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;(a)?&lt;/code&gt; означает необязательный &lt;em&gt;a&lt;/em&gt; . Круглые скобки могут использоваться для группировки элементов.</target>
        </trans-unit>
        <trans-unit id="5fa17fe926761d71195e28d1150f004609551f7f" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">Наибольшее положительное число,которое может быть представлено в 32-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="df1bceb0b90a5c84eca91bbd3d5e55dc6f933514" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">Наибольшее положительное число,которое может быть представлено в 64-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="c6b90ce83aefcb334988e56d2cf302f465c1ef2d" translate="yes" xml:space="preserve">
          <source>The last two digits of the year. When parsing, the current century is assumed.</source>
          <target state="translated">Последние две цифры года.При разборе подразумевается текущий век.</target>
        </trans-unit>
        <trans-unit id="d738ffb3d9772102e7dddad8f87eb9e66e116402" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt;.</source>
          <target state="translated">Последние два параметра указывают путь к файлу сертификата и путь к файлу ключа, без них сокет сервера, скорее всего, не будет работать. Сертификаты могут быть сгенерированы с помощью следующей команды: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22883001fe945b433749aff495f00df528dc3c12" translate="yes" xml:space="preserve">
          <source>The let statement</source>
          <target state="translated">Заявление о допущении</target>
        </trans-unit>
        <trans-unit id="d0faa7666c0de3db04b2c000430e78a9499fe142" translate="yes" xml:space="preserve">
          <source>The letter 'l' should not be used as an identifier.</source>
          <target state="translated">Буква 'l' не должна использоваться в качестве идентификатора.</target>
        </trans-unit>
        <trans-unit id="e1a4f72b5fdcd674f6a9f4458b16b275e31bc2a1" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful.</source>
          <target state="translated">Библиотека использует простую схему именования,которая использует общие аббревиатуры,чтобы сохранить имена короткими,но значимыми.</target>
        </trans-unit>
        <trans-unit id="03449ea33dc1c4c4ed0647ce0ae2f4b3f5ab6c04" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful. Since version 0.8.2 many symbols have been renamed to fit this scheme. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">В библиотеке используется простая схема именования, в которой используются общие сокращения, чтобы имена были короткими, но значимыми. Начиная с версии 0.8.2 многие символы были переименованы, чтобы соответствовать этой схеме. Конечная цель состоит в том, чтобы программист мог &lt;em&gt;угадать&lt;/em&gt; имя.</target>
        </trans-unit>
        <trans-unit id="81b15f3b8be0db527b2dd32e57b3edc710545648" translate="yes" xml:space="preserve">
          <source>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</source>
          <target state="translated">Перечисленные здесь pragmas могут быть использованы для переопределения опций генерации кода для proc/method/converter.</target>
        </trans-unit>
        <trans-unit id="d6ba5327d8647bd7ed894bcffd2bb86402f1c550" translate="yes" xml:space="preserve">
          <source>The lower bound of an array or sequence may be received by the built-in proc &lt;code&gt;low()&lt;/code&gt;, the higher bound by &lt;code&gt;high()&lt;/code&gt;. The length may be received by &lt;code&gt;len()&lt;/code&gt;. &lt;code&gt;low()&lt;/code&gt; for a sequence or an open array always returns 0, as this is the first valid index. One can append elements to a sequence with the &lt;code&gt;add()&lt;/code&gt; proc or the &lt;code&gt;&amp;amp;&lt;/code&gt; operator, and remove (and get) the last element of a sequence with the &lt;code&gt;pop()&lt;/code&gt; proc.</source>
          <target state="translated">Нижняя граница массива или последовательности может быть получена встроенной процедурой &lt;code&gt;low()&lt;/code&gt; , верхняя граница - &lt;code&gt;high()&lt;/code&gt; . Длина может быть получена &lt;code&gt;len()&lt;/code&gt; . &lt;code&gt;low()&lt;/code&gt; для последовательности или открытого массива всегда возвращает 0, поскольку это первый допустимый индекс. Можно добавить элементы к последовательности с помощью процедуры &lt;code&gt;add()&lt;/code&gt; или оператора &lt;code&gt;&amp;amp;&lt;/code&gt; , а удалить (и получить) последний элемент последовательности с помощью процедуры &lt;code&gt;pop()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5734f010cce3ed3e6eb9ebff7381b95381124003" translate="yes" xml:space="preserve">
          <source>The macro call expands to:</source>
          <target state="translated">Макровызов расширяется:</target>
        </trans-unit>
        <trans-unit id="ba15c60c9b85487537b51042f4adcf6c970f986b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed any more. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="translated">В руководстве упоминается, что &lt;a href=&quot;manual#cstring-type&quot;&gt;строки Nim неявно конвертируются в строки cstrings,&lt;/a&gt; что обычно делает взаимодействие безболезненным. Большинству функций C, принимающих строку Nim, преобразованную в &lt;code&gt;cstring&lt;/code&gt; , скорее всего, не нужно будет хранить эту строку, и к тому времени, когда они вернут строку, она больше не понадобится. Однако в тех редких случаях, когда строку Nim необходимо сохранить и сделать доступной для бэкэнда C как &lt;code&gt;cstring&lt;/code&gt; , вам нужно будет вручную предотвратить освобождение строковых данных с помощью &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; и &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d055cba0dbcd824c3d51d9d663b957c1d43495ed" translate="yes" xml:space="preserve">
          <source>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</source>
          <target state="translated">Соответствующие операторы могут быть символами любого вызываемого вида (прок,шаблоны и макросы),в зависимости от желаемого эффекта:</target>
        </trans-unit>
        <trans-unit id="aa302af914c04b9a452351c8217335cf34464abe" translate="yes" xml:space="preserve">
          <source>The matching AST must be a call/apply expression.</source>
          <target state="translated">Соответствующий AST должен быть выражением вызова/приложения.</target>
        </trans-unit>
        <trans-unit id="0b44d6a083a904cecf3aef26278e11886b2e549d" translate="yes" xml:space="preserve">
          <source>The matching AST must be an lvalue.</source>
          <target state="translated">Соответствующий АСТ должен иметь значение.</target>
        </trans-unit>
        <trans-unit id="9fac33d3e99596d75ad6eeca948e5afafcf536ac" translate="yes" xml:space="preserve">
          <source>The matching AST must have a side effect.</source>
          <target state="translated">Соответствующий АСТ должен иметь побочный эффект.</target>
        </trans-unit>
        <trans-unit id="62342d8683b403d83a8513c785f6aafa6bfbd8b4" translate="yes" xml:space="preserve">
          <source>The matching AST must have no side effect.</source>
          <target state="translated">Соответствующий АСТ не должен иметь побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="5661a426b593f52c0ca7fa90eafc833175b21253" translate="yes" xml:space="preserve">
          <source>The matching AST must have the specified kind. (Example: &lt;code&gt;nkIfStmt&lt;/code&gt; denotes an &lt;code&gt;if&lt;/code&gt; statement.)</source>
          <target state="translated">Соответствующий AST должен иметь указанный вид. (Пример: &lt;code&gt;nkIfStmt&lt;/code&gt; обозначает оператор &lt;code&gt;if&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="eb0f0fe081b64818b6b3016af8a01416e217ed1f" translate="yes" xml:space="preserve">
          <source>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</source>
          <target state="translated">Сопоставление выполняется после того,как компилятор выполнил некоторые оптимизации,такие как постоянное сгибание,поэтому следующее не работает:</target>
        </trans-unit>
        <trans-unit id="25c9e6f14aaa1c25059b8a65928452c58ffeac86" translate="yes" xml:space="preserve">
          <source>The matching node has no children.</source>
          <target state="translated">У соответствующего узла нет детей.</target>
        </trans-unit>
        <trans-unit id="3bee02bd8ec9e041895cdd7f8534811610597c81" translate="yes" xml:space="preserve">
          <source>The matching node is a literal like &quot;abc&quot;, 12.</source>
          <target state="translated">Соответствующий узел буквально &quot;abc&quot;,12.</target>
        </trans-unit>
        <trans-unit id="721eb0da3439ce9f34194a03def0ba45ab30e608" translate="yes" xml:space="preserve">
          <source>The matching node must be a symbol (a bound identifier).</source>
          <target state="translated">Соответствующий узел должен быть символом (связанным идентификатором).</target>
        </trans-unit>
        <trans-unit id="be1a3bab050b769c30c8177fd935188143910209" translate="yes" xml:space="preserve">
          <source>The matching node must be an identifier (an unbound identifier).</source>
          <target state="translated">Соответствующий узел должен быть идентификатором (несвязанным идентификатором).</target>
        </trans-unit>
        <trans-unit id="4f8a620db21ad017e74d603c8e4851fa5f18d228" translate="yes" xml:space="preserve">
          <source>The maximum content-length that will be read for the body.</source>
          <target state="translated">Максимальная длина содержимого,которая будет считываться для тела.</target>
        </trans-unit>
        <trans-unit id="43fd98d19fce24bd57a3a5dd301ed84cfd20f560" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">Максимальное значение &lt;em&gt;x&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; должен иметь оператор &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d2d6e30267d2820d060080987be5a5b7a4f91f3" translate="yes" xml:space="preserve">
          <source>The maximum value of two integers.</source>
          <target state="translated">Максимальное значение двух целых чисел.</target>
        </trans-unit>
        <trans-unit id="bb9b388505eb1fb774570095acc72dd570fedb16" translate="yes" xml:space="preserve">
          <source>The method call syntax conflicts with explicit generic instantiations: &lt;code&gt;p[T](x)&lt;/code&gt; cannot be written as &lt;code&gt;x.p[T]&lt;/code&gt; because &lt;code&gt;x.p[T]&lt;/code&gt; is always parsed as &lt;code&gt;(x.p)[T]&lt;/code&gt;.</source>
          <target state="translated">Синтаксис вызова метода конфликтует с явными универсальными экземплярами: &lt;code&gt;p[T](x)&lt;/code&gt; нельзя записать как &lt;code&gt;x.p[T]&lt;/code&gt; потому что &lt;code&gt;x.p[T]&lt;/code&gt; всегда анализируется как &lt;code&gt;(x.p)[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ef8bda90a06a0c3f6e30dace9ed42593b23481" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">Минимальное значение &lt;em&gt;x&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; должен иметь оператор &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6382aa6ed7dc87e04b1c5dfd0efac1c3cf2ff114" translate="yes" xml:space="preserve">
          <source>The minimum value of two integers.</source>
          <target state="translated">Минимальное значение двух целых чисел.</target>
        </trans-unit>
        <trans-unit id="42618bccaa1614ff3af2e91f3ca07f6ebdc8c5aa" translate="yes" xml:space="preserve">
          <source>The minutes in 1 digit if possible.</source>
          <target state="translated">Минуты в 1 цифре,если это возможно.</target>
        </trans-unit>
        <trans-unit id="b3095d9956a51342dd5a97c0ff4d61f08e5b0b7f" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; to disable compiler intrinsics.</source>
          <target state="translated">Модуль будет использовать чистые процессы NIM, если серверная часть не поддерживается. Вы также можете использовать флаг &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; для отключения встроенных &lt;em&gt;функций&lt;/em&gt; компилятора.</target>
        </trans-unit>
        <trans-unit id="8e065869153c9cf19339eeb5fe17bfa8010a6236" translate="yes" xml:space="preserve">
          <source>The month in one digit if possible.</source>
          <target state="translated">Месяц в одну цифру,если возможно.</target>
        </trans-unit>
        <trans-unit id="8eb37896b3a59b2013774ad8a8bc6115389438f2" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended.</source>
          <target state="translated">Месяц в двухзначных числах всегда.0 предоплачен.</target>
        </trans-unit>
        <trans-unit id="9b7d512c82e7ce84b958ad19e901783b62720ac2" translate="yes" xml:space="preserve">
          <source>The most important reason for RTTI. Generating traversal procedures produces bigger code and is likely to be slower on modern hardware as dynamic procedure binding is hard to predict.</source>
          <target state="translated">Самая важная причина для RTTI.Генерация процедур обхода приводит к большему объему кода и,скорее всего,будет более медленной на современном оборудовании,так как динамическое связывание процедур трудно предсказать.</target>
        </trans-unit>
        <trans-unit id="cf6c2e2953025ff455ecd8b6b1f063d8970db911" translate="yes" xml:space="preserve">
          <source>The most reliable way to handle exceptions is to use &lt;code&gt;yield&lt;/code&gt; on a future then check the future's &lt;code&gt;failed&lt;/code&gt; property. For example:</source>
          <target state="translated">Самый надежный способ обработки исключений - использовать &lt;code&gt;yield&lt;/code&gt; on a future, а затем проверять &lt;code&gt;failed&lt;/code&gt; свойство future . Например:</target>
        </trans-unit>
        <trans-unit id="abac663a9e4ad29972ddcc95fc577538bbcbd3dd" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command line invocations:</source>
          <target state="translated">Наиболее существенное различие между этими командами заключается в том, что если вы &lt;code&gt;nimcache&lt;/code&gt; каталог nimcache, вы найдете файлы &lt;code&gt;.c&lt;/code&gt; , &lt;code&gt;.cpp&lt;/code&gt; или &lt;code&gt;.m&lt;/code&gt; , кроме того, все они создадут собственный двоичный файл для вашего проекта. Это позволяет вам взять сгенерированный код и поместить его прямо в проект, используя любой из этих языков. Вот несколько типичных вызовов командной строки:</target>
        </trans-unit>
        <trans-unit id="69f05063edc5202ee9c72c0096b575ad8468f147" translate="yes" xml:space="preserve">
          <source>The name of the timezone.</source>
          <target state="translated">Название часового пояса.</target>
        </trans-unit>
        <trans-unit id="f458d384ea0910910144b31e2bb7acec5965f32b" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;import&lt;/code&gt; statement will bring in all exported symbols. These can be limited by naming symbols which should be excluded with the &lt;code&gt;except&lt;/code&gt; qualifier.</source>
          <target state="translated">Обычный оператор &lt;code&gt;import&lt;/code&gt; вводит все экспортированные символы. Они могут быть ограничены именованием символов, которые следует исключить с помощью квалификатора &lt;code&gt;except&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="629262f7b72a57e5a72d86066221973769332f9a" translate="yes" xml:space="preserve">
          <source>The normal operation mode is called &lt;code&gt;ProcRun&lt;/code&gt; and it involves starting a process for each command or query, similar to running manually the Nim compiler from the commandline. The &lt;code&gt;CaasRun&lt;/code&gt; mode starts a server process to answer all queries. The &lt;code&gt;SymbolProcRun&lt;/code&gt; mode is used by compiler developers. This means that running all tests involves processing all &lt;code&gt;*.txt&lt;/code&gt; files three times, which can be quite time consuming.</source>
          <target state="translated">Обычный режим работы называется &lt;code&gt;ProcRun&lt;/code&gt; , и он включает запуск процесса для каждой команды или запроса, аналогично запуску компилятора Nim вручную из командной строки. Режим &lt;code&gt;CaasRun&lt;/code&gt; запускает серверный процесс для ответа на все запросы. Режим &lt;code&gt;SymbolProcRun&lt;/code&gt; используется разработчиками компилятора. Это означает, что запуск всех тестов требует трехкратной обработки всех файлов &lt;code&gt;*.txt&lt;/code&gt; , что может занять довольно много времени.</target>
        </trans-unit>
        <trans-unit id="4bae69dda155aa8a4d14da3a2fc6579a9ca759df" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; can be used to access the i-th element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Обозначение &lt;code&gt;x[i]&lt;/code&gt; может использоваться для доступа к i-му элементу &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="658eabb7c8362bd8ccc2db983d207e849c519eb7" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; is used to access the i-th element of &lt;code&gt;x&lt;/code&gt;. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--bound_checks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">Обозначение &lt;code&gt;x[i]&lt;/code&gt; используется для доступа к i-му элементу &lt;code&gt;x&lt;/code&gt; . Доступ к массиву всегда проверяется по границам (во время компиляции или во время выполнения). Эти проверки можно отключить с помощью прагм или вызвать компилятор с помощью &lt;code&gt;--bound_checks:off&lt;/code&gt; командной строки --bound_checks: off .</target>
        </trans-unit>
        <trans-unit id="84253c85ff2fe63ceae34cee869e8056c8618b6f" translate="yes" xml:space="preserve">
          <source>The notation used for a PEG is similar to that of EBNF:</source>
          <target state="translated">Обозначение,используемое для PEG,аналогично обозначению EBNF:</target>
        </trans-unit>
        <trans-unit id="35c5176abc505099c32f5f56c77ef46929971143" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to 's[i]' including following combining characters.</source>
          <target state="translated">Количество байтов,принадлежащих 's[i]',включая следующие комбинированные символы.</target>
        </trans-unit>
        <trans-unit id="67410fb726aaa716bc56a897729095f56b009d39" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all GC heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="translated">Числа подсчитывают количество объектов во всех кучах сборщика мусора, они относятся ко всем запущенным потокам, а не только к текущему потоку. (Текущий поток будет потоком, который вызывает &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; .) Это может измениться в более поздних версиях.</target>
        </trans-unit>
        <trans-unit id="943d32e77792f1b379a556185254f33101e23b55" translate="yes" xml:space="preserve">
          <source>The numerical identifier is just a random number. The number gets assigned according to the section and position of the symbol in the file being processed and you should not rely on it being constant: if you add or remove a symbol the numbers may shuffle around.</source>
          <target state="translated">Числовой идентификатор-просто случайное число.Номер присваивается в соответствии с разделом и положением символа в обрабатываемом файле,и не стоит полагаться на то,что он постоянный:при добавлении или удалении символа числа могут перемешаться.</target>
        </trans-unit>
        <trans-unit id="727a603933eb24259acf39e94c54b8c8c69ecf4d" translate="yes" xml:space="preserve">
          <source>The occasional use of idetools is acceptable for things like definitions, where the user puts the cursor on a symbol or double clicks it and after a second or two the IDE displays where that symbol is defined. Such latencies would be terrible for features like symbol suggestion, plus why wait at all if we can avoid it?</source>
          <target state="translated">Иногда использование idetools допустимо для таких вещей,как определения,когда пользователь навел курсор на символ или дважды щелкнул по нему,и через секунду или две IDE показывает,где этот символ определен.Такие задержки были бы ужасны для таких функций,как предложение символа,плюс зачем вообще ждать,если можно избежать этого?</target>
        </trans-unit>
        <trans-unit id="37994ecd43903ca9e4ef6ac25795c9cd0cb6d035" translate="yes" xml:space="preserve">
          <source>The only case where things aren't as easy is when the garbage collector needs some assembler tweaking to work. The standard version of the GC uses C's &lt;code&gt;setjmp&lt;/code&gt; function to store all registers on the hardware stack. It may be necessary that the new platform needs to replace this generic code by some assembler code.</source>
          <target state="translated">Единственный случай, когда все не так просто, - это когда сборщик мусора нуждается в некоторой настройке ассемблера для работы. Стандартная версия GC использует функцию C &lt;code&gt;setjmp&lt;/code&gt; для хранения всех регистров аппаратного стека. Может потребоваться, чтобы новая платформа заменила этот общий код некоторым кодом ассемблера.</target>
        </trans-unit>
        <trans-unit id="e2f49d4957d979510c6bf361e27282ecac40ce06" translate="yes" xml:space="preserve">
          <source>The only difference between the contents of that file and the values provided by this proc is the &lt;code&gt;doc.file&lt;/code&gt; variable. The &lt;code&gt;doc.file&lt;/code&gt; variable of the configuration file contains HTML to build standalone pages, while this proc returns just the content for procs like &lt;code&gt;rstToHtml&lt;/code&gt; to generate the bare minimum HTML.</source>
          <target state="translated">Единственная разница между содержимым этого файла и значениями, предоставляемыми этой процедурой, - это переменная &lt;code&gt;doc.file&lt;/code&gt; . &lt;code&gt;doc.file&lt;/code&gt; переменного конфигурационного файла содержит HTML для сборки отдельных страниц, в то время как эта процедура возвращает только контент для проков как &lt;code&gt;rstToHtml&lt;/code&gt; генерировать голый минимум HTML.</target>
        </trans-unit>
        <trans-unit id="66d1058ab09e19fbf4fbe3d6ea05970103c3b41c" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating point types.</source>
          <target state="translated">Единственные операции, на которые влияет прагма &lt;code&gt;floatChecks&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; это операторы &lt;code&gt;+&lt;/code&gt; , - , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; для типов с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="168d790e853cbd9034f71729f2476481319d159c" translate="yes" xml:space="preserve">
          <source>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</source>
          <target state="translated">Тип открытого массива не может быть вложен:многомерные открытые массивы не поддерживаются,так как это редко требуется и не может быть сделано эффективно.</target>
        </trans-unit>
        <trans-unit id="c4e0647a4c89f8b16abd9dcace05bac8931235f1" translate="yes" xml:space="preserve">
          <source>The operation is performed atomically and other operations on the table will be blocked while the &lt;code&gt;mapper&lt;/code&gt; is invoked, so it should be short and simple.</source>
          <target state="translated">Операция выполняется атомарно, и другие операции с таблицей будут заблокированы во время вызова &lt;code&gt;mapper&lt;/code&gt; , поэтому она должна быть короткой и простой.</target>
        </trans-unit>
        <trans-unit id="83ab7b4d2bb2233e5f2fab96873b663a53e9e12f" translate="yes" xml:space="preserve">
          <source>The operation produced a result that cannot be represented with infinite precision -- for example: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</source>
          <target state="translated">Операция дала результат, который невозможно представить с бесконечной точностью - например: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8377f7d618fcf4075ebaa21071b51f158edf57be" translate="yes" xml:space="preserve">
          <source>The operation produced a result that exceeds the range of the exponent.</source>
          <target state="translated">В результате операции был получен результат,превышающий диапазон экспонента.</target>
        </trans-unit>
        <trans-unit id="33f13b87dbb9bcf04674b0e7829c348aac46fcd6" translate="yes" xml:space="preserve">
          <source>The operation produced a result that is too small to be represented as a normal number.</source>
          <target state="translated">Результат операции оказался слишком мал,чтобы его можно было представить в виде обычного числа.</target>
        </trans-unit>
        <trans-unit id="941ce1be2e887859312d9d5ab72c51d7733f52a5" translate="yes" xml:space="preserve">
          <source>The operator's precedence is determined by its first character. The details can be found in the manual.</source>
          <target state="translated">Приоритет оператора определяется его первым символом.Подробности приведены в руководстве.</target>
        </trans-unit>
        <trans-unit id="c0e839d05d73521d7af47a856f782f7c30977b0c" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation.</source>
          <target state="translated">Операторы &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; имеют особое значение в образцах, если они записаны в инфиксной записи.</target>
        </trans-unit>
        <trans-unit id="bf012723c5a2a5eb3b690eb90475c06700cb84be" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-circuit evaluation. For example:</source>
          <target state="translated">Операторы &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; определены для типа bool. Операторы &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; выполняют оценку короткого замыкания. Например:</target>
        </trans-unit>
        <trans-unit id="5a6dbe81c71ecdddbb102d68881f2f73beabe16e" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-cut evaluation. Example:</source>
          <target state="translated">Операторы &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; определены для типа bool. Операторы &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; выполняют сокращенную оценку. Пример:</target>
        </trans-unit>
        <trans-unit id="81caedce7ab00b1fe39f7b3ec76b901fbe2f933f" translate="yes" xml:space="preserve">
          <source>The optional 'fill' character defines the character to be used to pad the field to the minimum width. The fill character, if present, must be followed by an alignment flag.</source>
          <target state="translated">Опциональный символ 'заполнение' определяет символ,который будет использоваться для заполнения поля до минимальной ширины.Символ заполнения,если он присутствует,должен сопровождаться флагом выравнивания.</target>
        </trans-unit>
        <trans-unit id="e4b3a59de6d012b18e22a8e7a284e6db58df1867" translate="yes" xml:space="preserve">
          <source>The optional align flag can be one of the following:</source>
          <target state="translated">Дополнительный флаг выравнивания может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="a0e3a6522c824ed95aa3e1f8fe8ce4a5f4f147b1" translate="yes" xml:space="preserve">
          <source>The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt;.</source>
          <target state="translated">Порядок &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt; (ключ, значение) сохраняется, поэтому упорядоченные словари легко поддерживать, например, с помощью {key: val} .newOrderedTable .</target>
        </trans-unit>
        <trans-unit id="429f542ce113c15e57f01af974550e0e5b305975" translate="yes" xml:space="preserve">
          <source>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</source>
          <target state="translated">Порядок замены имеет значение.Более ранние замены предпочтительнее,чем более поздние замены в списке аргументов.</target>
        </trans-unit>
        <trans-unit id="dacff1821dbef72a128b774b46c26a9e053a10c5" translate="yes" xml:space="preserve">
          <source>The original module name is then not accessible. The notations &lt;code&gt;path/to/module&lt;/code&gt; or &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; can be used to refer to a module in subdirectories:</source>
          <target state="translated">Тогда исходное имя модуля становится недоступным. Обозначения &lt;code&gt;path/to/module&lt;/code&gt; или &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; могут использоваться для ссылки на модуль в подкаталогах:</target>
        </trans-unit>
        <trans-unit id="cc86fbbfca2829ffbb5ee4206b27f3d101a719c7" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;em&gt;width&lt;/em&gt; is less than or equal to &lt;em&gt;s.len&lt;/em&gt;.</source>
          <target state="translated">Исходная строка возвращается, если &lt;em&gt;ширина&lt;/em&gt; меньше или равна &lt;em&gt;s.len&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="56fcfadb9f1701723ceb4fcaae9d90dddc612821" translate="yes" xml:space="preserve">
          <source>The other reason is that the dirty file can appear anywhere on disk (e.g. in tmpfs), but it must be treated as having a path matching the original module when it comes to usage of relative paths, etc. Queries, however, will refer to the dirty module name in their answers instead of the normal filename.</source>
          <target state="translated">Другая причина заключается в том,что грязный файл может появиться где угодно на диске (например,в tmpfs),но он должен рассматриваться как имеющий путь,совпадающий с исходным модулем,когда дело доходит до использования относительных путей и т.д.Запросы,однако,будут ссылаться на имя &quot;грязного&quot; модуля в своих ответах,а не на обычное имя файла.</target>
        </trans-unit>
        <trans-unit id="81362a99790f1d4f0fa145c5d4c8a309f3b532a8" translate="yes" xml:space="preserve">
          <source>The output for HTML and LaTeX comes from the &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; and &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; configuration files. You can add and modify these files to your project to change the look of docgen output.</source>
          <target state="translated">Вывод для HTML и LaTeX поступает из файлов конфигурации &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; и &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; . Вы можете добавлять и изменять эти файлы в свой проект, чтобы изменить внешний вид вывода docgen.</target>
        </trans-unit>
        <trans-unit id="5fab1111abe4336bbc798351e8ca9549d09746d9" translate="yes" xml:space="preserve">
          <source>The output is twice the input long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated.</source>
          <target state="translated">Выходной файл в два раза длиннее входного. Префикса типа &lt;code&gt;0x&lt;/code&gt; не создается.</target>
        </trans-unit>
        <trans-unit id="533631499bbd1d8be6ff4dcee292a72b882cc3f0" translate="yes" xml:space="preserve">
          <source>The output verbosity of the tests.</source>
          <target state="translated">Выходная многословие тестов.</target>
        </trans-unit>
        <trans-unit id="461db813bbace1635974b27e6126d38b9c4ee9ad" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked to be free of data races at compile time. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="translated">Оператор parallel - предпочтительный механизм для введения параллелизма в программу Nim. Подмножество языка Nim действует в &lt;code&gt;parallel&lt;/code&gt; разделе. Это подмножество проверяется на отсутствие гонок данных во время компиляции. Утонченная &lt;span id=&quot;disjoint-checker_1&quot;&gt;непересекающихся шашка&lt;/span&gt; гарантирует , что никакие скачки данных не возможны , даже если общая память широко поддерживается!</target>
        </trans-unit>
        <trans-unit id="d785f95df44f47948246d72ae65b3b0c993eb38c" translate="yes" xml:space="preserve">
          <source>The parameters' types can be ordinary types or the meta types &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt;, or &lt;code&gt;type&lt;/code&gt;. &lt;code&gt;type&lt;/code&gt; suggests that only a type symbol may be given as an argument, and &lt;code&gt;untyped&lt;/code&gt; means symbol lookups and type resolution is not performed before the expression is passed to the template.</source>
          <target state="translated">Типы параметров могут быть обычными типами или типами меты &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; , или &lt;code&gt;type&lt;/code&gt; . &lt;code&gt;type&lt;/code&gt; предполагает, что в качестве аргумента может быть задан только символ типа, а &lt;code&gt;untyped&lt;/code&gt; означает, что поиск символов и разрешение типа не выполняются до передачи выражения в шаблон.</target>
        </trans-unit>
        <trans-unit id="81b1f54dcfe838ac2e0c59b6f42dae3e0756b1fe" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="translated">Парсер использует стек уровней отступа: стек состоит из целых чисел, считая пробелы. Информация об отступах запрашивается в стратегических местах синтаксического анализатора, но в противном случае игнорируется: псевдотерминал &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; обозначает отступ, который состоит из большего количества пробелов, чем запись наверху стека; &lt;code&gt;IND{=}&lt;/code&gt; отступ с таким же количеством пробелов. &lt;code&gt;DED&lt;/code&gt; - это еще один псевдотерминал, который описывает &lt;em&gt;действие&lt;/em&gt; извлечения значения из стека, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; затем подразумевает отправку значения в стек.</target>
        </trans-unit>
        <trans-unit id="7f9027f1cfc9029d9bab0ad3b282e7849cb03b34" translate="yes" xml:space="preserve">
          <source>The path analysis is &lt;strong&gt;currently unsound&lt;/strong&gt;, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.</source>
          <target state="translated">Анализ пути в &lt;strong&gt;настоящее время не работает&lt;/strong&gt; , но это не делает его бесполезным. Два пути считаются эквивалентными, если они синтаксически одинаковы.</target>
        </trans-unit>
        <trans-unit id="e21fa755d2f9dd13f4c401361fe48cbd80c4ec20" translate="yes" xml:space="preserve">
          <source>The plain name of a symbol is a simplified version of its fully exported signature. Variables or constants have the same plain name symbol as their complex name. The plain name for procs, templates, and other callable types will be their unquoted value after removing parameters, return types and pragmas. The plain name allows short and nice linking of symbols which works unless you have a module with collisions due to overloading.</source>
          <target state="translated">Обычное название символа является упрощенной версией его полностью экспортируемой подписи.Переменные или константы имеют то же самое простое имя,что и их сложное название.Обычное имя для прок,шаблонов и других вызываемых типов будет их нецитируемым значением после удаления параметров,типов возврата и прагм.Простое имя позволяет короткое и красивое связывание символов,которое работает,если только у вас нет модуля с коллизиями из-за перегрузки.</target>
        </trans-unit>
        <trans-unit id="14e09d7c794944bac489c1fb890465f3395a7739" translate="yes" xml:space="preserve">
          <source>The portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned.</source>
          <target state="translated">Часть, соответствующая &lt;code&gt;sep&lt;/code&gt; , не возвращается.</target>
        </trans-unit>
        <trans-unit id="5905889f12b10a582b5de19496532d186574a39d" translate="yes" xml:space="preserve">
          <source>The pragmas listed here can be used to optionally accept values from the -d/--define option at compile time.</source>
          <target state="translated">Перечисленные здесь прагмы могут быть использованы для опционального принятия значений из опции -d/--define во время компиляции.</target>
        </trans-unit>
        <trans-unit id="f4c1f5ea59e38f8446c010800e904b6889b2d6f5" translate="yes" xml:space="preserve">
          <source>The problem here is that the compiler already decided that &lt;code&gt;something()&lt;/code&gt; as an iterator is not callable in this context before &lt;code&gt;toSeq&lt;/code&gt; gets its chance to convert it into a sequence.</source>
          <target state="translated">Проблема здесь в том, что компилятор уже решил, что &lt;code&gt;something()&lt;/code&gt; как итератор не может быть вызван в этом контексте, прежде чем &lt;code&gt;toSeq&lt;/code&gt; получит шанс преобразовать его в последовательность.</target>
        </trans-unit>
        <trans-unit id="1413d5988b205726c716a63467c96b038a113fd1" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; is called implicitly when your nim program finishes without incident for platforms where this is the expected behavior. A raised unhandled exception is equivalent to calling &lt;code&gt;quit(QuitFailure)&lt;/code&gt;.</source>
          <target state="translated">Процедура &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; вызывается неявно, когда ваша программа nim завершается без происшествий для платформ, где такое поведение является ожидаемым. &lt;code&gt;quit(QuitFailure)&lt;/code&gt; необработанное исключение эквивалентно вызову quit (QuitFailure) .</target>
        </trans-unit>
        <trans-unit id="7e2d3b14bba8ee482acb489760d42aaa50f22724" translate="yes" xml:space="preserve">
          <source>The proc is meant to parse the Cookie header set by a client, not the &quot;Set-Cookie&quot; header set by servers.</source>
          <target state="translated">Прок предназначен для разбора заголовка Cookie,установленного клиентом,а не заголовка &quot;Set-Cookie&quot;,установленного серверами.</target>
        </trans-unit>
        <trans-unit id="37ebd1b54b6f7339d68d2b35085cae9b111d5bdc" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes. &lt;strong&gt;Note&lt;/strong&gt;: This is not correct for producing Ansi C code!</source>
          <target state="translated">Процедура была разработана таким образом, чтобы ее вывод можно было использовать для многих различных распространенных синтаксисов. &lt;strong&gt;Примечание&lt;/strong&gt; : это неверно для создания кода Ansi C!</target>
        </trans-unit>
        <trans-unit id="e4ed2941bc29e9113b49ab22213c1bd08c56b866" translate="yes" xml:space="preserve">
          <source>The progress of either a file upload or a file download can be checked by specifying a &lt;code&gt;onProgressChanged&lt;/code&gt; procedure to the &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;retrFile&lt;/code&gt; procedures.</source>
          <target state="translated">Ход загрузки или загрузки файла можно проверить, указав процедуру &lt;code&gt;onProgressChanged&lt;/code&gt; для процедур &lt;code&gt;store&lt;/code&gt; или &lt;code&gt;retrFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f15f5453e331e56f9b69a6e72ccfba467ab59e8f" translate="yes" xml:space="preserve">
          <source>The project makes use of a deprecated config file.</source>
          <target state="translated">В проекте используется устаревший конфигурационный файл.</target>
        </trans-unit>
        <trans-unit id="0151e7d00a06bf727dbd72da71ba5ce97b155194" translate="yes" xml:space="preserve">
          <source>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the &lt;code&gt;echo&lt;/code&gt; statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactivated with the &lt;code&gt;--patterns:off&lt;/code&gt; command line option or temporarily with the &lt;code&gt;patterns&lt;/code&gt; pragma.</source>
          <target state="translated">Причина в том, что компилятор уже преобразовал 1 в &amp;laquo;1&amp;raquo; для оператора &lt;code&gt;echo&lt;/code&gt; . Однако макрос перезаписи терминов в любом случае не должен изменять семантику. Фактически, их можно отключить с помощью &lt;code&gt;--patterns:off&lt;/code&gt; командной строки --patterns: off или временно с помощью директивы &lt;code&gt;patterns&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f950b9dc37be83169d340916b25b6ad1600d2a00" translate="yes" xml:space="preserve">
          <source>The reimplementation of this code as a compile time proc will allow us to get rid of the &lt;code&gt;data.cfg&lt;/code&gt; file we would need to distribute along the binary, plus if the information is really constant, it doesn't make from a logical point of view to have it &lt;em&gt;mutable&lt;/em&gt; in a global variable, it would be better if it was a constant. Finally, and likely the most valuable feature, we can implement some verification at compile time. You could think of this as a &lt;em&gt;better unit testing&lt;/em&gt;, since it is impossible to obtain a binary unless everything is correct, preventing you to ship to users a broken program which won't start because a small critical file is missing or its contents changed by mistake to something invalid.</source>
          <target state="translated">Повторная реализация этого кода в качестве процедуры времени компиляции позволит нам избавиться от файла &lt;code&gt;data.cfg&lt;/code&gt; , который нам потребуется распространять по двоичному файлу, плюс, если информация действительно постоянна, с логической точки зрения это не делает чтобы он &lt;em&gt;изменялся&lt;/em&gt; в глобальной переменной, было бы лучше, если бы это была константа. Наконец, и это, вероятно, самая ценная функция, мы можем реализовать некоторую проверку во время компиляции. Вы можете думать об этом как о &lt;em&gt;лучшем модульном тестировании&lt;/em&gt; , поскольку невозможно получить двоичный файл, если все не правильно, что не позволяет вам отправить пользователям неработающую программу, которая не запускается из-за отсутствия небольшого критического файла или его содержимого, измененного на ошибка к чему-то недействительному.</target>
        </trans-unit>
        <trans-unit id="bd941de653f278721095a2c43367c41906f6489e" translate="yes" xml:space="preserve">
          <source>The relationship of type to suffix is made by the proc &lt;code&gt;complexName&lt;/code&gt; in the &lt;code&gt;compiler/docgen.nim&lt;/code&gt; file. Here are some examples of complex names for symbols in the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt;.</source>
          <target state="translated">Связь типа с суффиксом устанавливается параметром proc &lt;code&gt;complexName&lt;/code&gt; в файле &lt;code&gt;compiler/docgen.nim&lt;/code&gt; . Вот несколько примеров сложных имен для символов в &lt;a href=&quot;system&quot;&gt;системном модуле&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf0a82f5d893e438a2023ce750bc90f2a128096" translate="yes" xml:space="preserve">
          <source>The removal of existing files.</source>
          <target state="translated">Удаление существующих файлов.</target>
        </trans-unit>
        <trans-unit id="d6fd935f249c62b7608872cee19d42012edb0e86" translate="yes" xml:space="preserve">
          <source>The replace filter replaces substrings in each line.</source>
          <target state="translated">Заменяющий фильтр заменяет подложки в каждой строке.</target>
        </trans-unit>
        <trans-unit id="28a78280047d22a351983c3a0d358b7203f54114" translate="yes" xml:space="preserve">
          <source>The representation of the &lt;code&gt;if&lt;/code&gt; expression is subtle, but easy to traverse.</source>
          <target state="translated">Представление выражения &lt;code&gt;if&lt;/code&gt; тонкое, но легко проходимое.</target>
        </trans-unit>
        <trans-unit id="73836858e4d8022cd4c46c9283cbdf6cfe3ad8c7" translate="yes" xml:space="preserve">
          <source>The representation of the if statement is subtle, but easy to traverse. If there is no &lt;code&gt;else&lt;/code&gt; branch, no &lt;code&gt;nnkElse&lt;/code&gt; child exists.</source>
          <target state="translated">Представление оператора if тонкое, но легко проходимое. Если ветки &lt;code&gt;else&lt;/code&gt; нет, &lt;code&gt;nnkElse&lt;/code&gt; дочерний элемент nnkElse не существует.</target>
        </trans-unit>
        <trans-unit id="28c784e74f236c4964b6fd6d91fbb0a37256995f" translate="yes" xml:space="preserve">
          <source>The response's body stream is read synchronously.</source>
          <target state="translated">Поток тела ответа считывается синхронно.</target>
        </trans-unit>
        <trans-unit id="989aceedc601a5b9a5742f1d14477507d7adf53d" translate="yes" xml:space="preserve">
          <source>The rest of the line is treated as a &lt;a href=&quot;re&quot;&gt;regular expression&lt;/a&gt;, so be careful escaping metacharacters like parenthesis.</source>
          <target state="translated">Остальная часть строки рассматривается как &lt;a href=&quot;re&quot;&gt;регулярное выражение&lt;/a&gt; , поэтому будьте осторожны, избегая метасимволов, таких как скобки.</target>
        </trans-unit>
        <trans-unit id="6de3479f33b83e39dae126f685d1475edff6c449" translate="yes" xml:space="preserve">
          <source>The resulting client socket is automatically registered to the dispatcher.</source>
          <target state="translated">Полученное клиентское гнездо автоматически регистрируется на диспетчере.</target>
        </trans-unit>
        <trans-unit id="e81240f3c82766aef65cfde973adbe5730fdaa4e" translate="yes" xml:space="preserve">
          <source>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</source>
          <target state="translated">Результирующий клиент унаследует любые свойства сокета сервера.Например:буферизован ли сокет или нет.</target>
        </trans-unit>
        <trans-unit id="1d0eda4f937e942666810677280a88be73c7577b" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="translated">Результирующая строка всегда имеет длину &lt;em&gt;len&lt;/em&gt; символов. Ни один ведущий &lt;code&gt;0b&lt;/code&gt; префикс не генерируется.</target>
        </trans-unit>
        <trans-unit id="ea3fa6f05db7b82f91043df8507510ba9b2c0af9" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="translated">Результирующая строка всегда имеет длину &lt;em&gt;len&lt;/em&gt; символов. Ни один ведущий &lt;code&gt;0o&lt;/code&gt; префикс не генерируется.</target>
        </trans-unit>
        <trans-unit id="45fdb218e0bbadf017f51aea11eb54c54acabed2" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;em&gt;prefix&lt;/em&gt; and suffixed with &lt;em&gt;suffix&lt;/em&gt;. Both may be empty strings.</source>
          <target state="translated">Результирующая строка имеет префикс &lt;em&gt;prefix&lt;/em&gt; и суффикс &lt;em&gt;суффикса&lt;/em&gt; . Оба могут быть пустыми строками.</target>
        </trans-unit>
        <trans-unit id="403899c0e7f32ab870cef66df940fa7e27c170e3" translate="yes" xml:space="preserve">
          <source>The resulting string may not have a leading zero. Its length is always exactly 3.</source>
          <target state="translated">Результирующая строка может не иметь ведущего нуля.Ее длина всегда равна 3.</target>
        </trans-unit>
        <trans-unit id="30afb7397e54c9840f15c6ce3837b090cbb826dc" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;em&gt;len&lt;/em&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;em&gt;x&lt;/em&gt; is treated as an unsigned value.</source>
          <target state="translated">Результирующая строка будет иметь длину ровно &lt;em&gt;len&lt;/em&gt; символов. Префикса типа &lt;code&gt;0x&lt;/code&gt; не создается. &lt;em&gt;x&lt;/em&gt; рассматривается как беззнаковое значение.</target>
        </trans-unit>
        <trans-unit id="f90efc9f77052cc77655df5707232ad9216984b9" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;em&gt;minchars&lt;/em&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="translated">Результирующая строка будет иметь минимальную &lt;em&gt;длину minchars&lt;/em&gt; символов. Это достигается добавлением ведущих нулей.</target>
        </trans-unit>
        <trans-unit id="a48658314c6de6bf50c3ec96a319b4bcbf46bc4f" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;code&gt;discardable&lt;/code&gt; pragma:</source>
          <target state="translated">Возвращаемое значение можно неявно игнорировать, если вызываемый proc / итератор был объявлен с помощью &lt;code&gt;discardable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="67bd9c724c4f982734f839921c898bc019482c8d" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;span id=&quot;discardable_1&quot;&gt;discardable&lt;/span&gt; pragma:</source>
          <target state="translated">Возвращаемое значение можно неявно игнорировать, если вызываемый proc / итератор был объявлен с помощью &lt;span id=&quot;discardable_1&quot;&gt;директивы discardable&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="756b0797d628461ffc91c206ce4262901afa5425" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;StringTableRef&lt;/code&gt; contains the parameters used by the HTML engine to build the final output. For information on what these parameters are and their purpose, please look up the file &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; bundled with the compiler.</source>
          <target state="translated">Возвращается &lt;code&gt;StringTableRef&lt;/code&gt; содержит параметры , используемые в HTML двигателя для создания окончательного вывода. Для получения информации об этих параметрах и их назначении, пожалуйста, посмотрите файл &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; , поставляемый с компилятором.</target>
        </trans-unit>
        <trans-unit id="6d314e6c213f7dc11b7be0a941b6f5bc49b81919" translate="yes" xml:space="preserve">
          <source>The returned Future will complete once all data has been written to the specified file.</source>
          <target state="translated">Возвращаемое будущее будет завершено,как только все данные будут записаны в указанный файл.</target>
        </trans-unit>
        <trans-unit id="d420b4d0177cf52670fb1bd5d6c63c44491d8117" translate="yes" xml:space="preserve">
          <source>The rules for compile-time computability are:</source>
          <target state="translated">Правила для вычислительной способности во время компиляции:</target>
        </trans-unit>
        <trans-unit id="698e091efe4e128cb702c79882a2f45f056f90d7" translate="yes" xml:space="preserve">
          <source>The same action can also be performed asynchronously, simply use the &lt;code&gt;AsyncHttpClient&lt;/code&gt;:</source>
          <target state="translated">То же действие можно выполнить и асинхронно, просто используйте &lt;code&gt;AsyncHttpClient&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4d8108fe45337e2b675ce1f770f1401249335850" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;add(s, formatstr % a)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">То же, что и &lt;code&gt;add(s, formatstr % a)&lt;/code&gt; , но более эффективно.</target>
        </trans-unit>
        <trans-unit id="eea3f061ff9424cd86d52bd3cac8dfd6e94a7529" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</source>
          <target state="translated">То же, что и &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4562377386ad596a9d2e194a9741b56a7124917" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt; unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="translated">То же, что и &lt;code&gt;parentDir(head) / tail&lt;/code&gt; если нет родительского каталога. Затем вместо этого выполняется &lt;code&gt;head / tail&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="896b7a919e5c694aa0a0d238075545c1cae1c488" translate="yes" xml:space="preserve">
          <source>The same as &lt;em&gt;joinPath(head, tail)&lt;/em&gt;, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.</source>
          <target state="translated">То же, что и &lt;em&gt;joinPath (голова, хвост)&lt;/em&gt; , но работает с любым количеством частей каталога. Вам необходимо передать хотя бы один элемент, иначе процедура будет утверждена в отладочных сборках и выйдет из строя при выпуске сборок.</target>
        </trans-unit>
        <trans-unit id="25fcdd3704177b32025508d9d8dc540fb2c73caa" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;итератор rsplit&lt;/a&gt; , но это процедура, возвращающая последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="db09ba6be055ec25fc71a3c77b55d883dbb50574" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;итератор rsplit&lt;/a&gt; , но это процедура, возвращающая последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="872080f867045c7487dbf61ec0245aa4502cb8a8" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;итератор rsplit&lt;/a&gt; , но это процедура, возвращающая последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="6e5fe058f47f2922444e3cdf8a11480b26b2bdc0" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что &lt;a href=&quot;#split.i,string,char,int&quot;&gt;итератор разделения&lt;/a&gt; , но представляет собой процедуру, возвращающую последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="55216d0743f38afb17e58bb0b29813f0ebcc2b0b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;итератор разделения&lt;/a&gt; , но представляет собой процедуру, возвращающую последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="f6bd26725a590268da07c53a69dedbe58085e4ed" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что итератор &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; , но представляет собой процедуру, возвращающую последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="155ce31bc857a624f4b637a724b282d2d7a0299b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что итератор &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; , но процедура, возвращающая последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="10f55c7794b6e447d4540977b35266563d3b8496" translate="yes" xml:space="preserve">
          <source>The same syntax applies to &lt;code&gt;iterator&lt;/code&gt; (with &lt;code&gt;nnkIteratorTy&lt;/code&gt;), but &lt;em&gt;does not&lt;/em&gt; apply to &lt;code&gt;converter&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">Тот же синтаксис применяется к &lt;code&gt;iterator&lt;/code&gt; (с &lt;code&gt;nnkIteratorTy&lt;/code&gt; ), но &lt;em&gt;не&lt;/em&gt; применяется к &lt;code&gt;converter&lt;/code&gt; или &lt;code&gt;template&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f2b58b4e423bfdce9cdf95cfb670ae8ff6353ae" translate="yes" xml:space="preserve">
          <source>The scanp macro</source>
          <target state="translated">Макрос сканирования</target>
        </trans-unit>
        <trans-unit id="1c86c735cf43c50791d8029b9f0a87ffd482fd7f" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;em&gt;*&lt;/em&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="translated">Второй оператор &lt;em&gt;*&lt;/em&gt; должен быть параметром; он используется для сбора всех аргументов. Выражение &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; передается &lt;code&gt;optConc&lt;/code&gt; в в специальный список (благостного &lt;code&gt;nkArgList&lt;/code&gt; ) , который сглажен в выражении вызова; таким образом, вызов &lt;code&gt;optConc&lt;/code&gt; производит: &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ae0df5a264f4266cdb5160062cd0aaa33125c37" translate="yes" xml:space="preserve">
          <source>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying &lt;code&gt;operation&lt;/code&gt;.</source>
          <target state="translated">В последовательности должен быть хотя бы один элемент. В этой ситуации будут утверждены отладочные версии вашей программы, но релизные версии будут успешно реализованы. Если в последовательности есть один элемент, он будет возвращен без применения &lt;code&gt;operation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de05e83beaaac1f274966bd69ab8d48a0491b166" translate="yes" xml:space="preserve">
          <source>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:</source>
          <target state="translated">Тип набора моделирует математическое понятие набора.Базой множества может быть только порядковый тип определенного размера,а именно:</target>
        </trans-unit>
        <trans-unit id="aa01d82d61dfce28cfeda16c5bd80e4dbed31204" translate="yes" xml:space="preserve">
          <source>The setrlimit() system calls sets resource limits.</source>
          <target state="translated">Системные вызовы setrlimit()устанавливают лимиты ресурсов.</target>
        </trans-unit>
        <trans-unit id="2b11bf3cb2bd50300b9f5b036f32f39ad404f4b8" translate="yes" xml:space="preserve">
          <source>The signature has to be:</source>
          <target state="translated">Подпись должна быть:</target>
        </trans-unit>
        <trans-unit id="2bed7f833a05e8210ed42f0ce7ddfee8765659dd" translate="yes" xml:space="preserve">
          <source>The size of the bool type is one byte.</source>
          <target state="translated">Размер шерсти-один байт.</target>
        </trans-unit>
        <trans-unit id="d6a8c97ed2a17dc44a3f97e1801a8e2cbc5ffe6e" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">Наименьшее положительное (ненулевое)число,которое может быть представлено в 32-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="37339a476e0f2e7116d49064ea767be2f3f7d153" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">Наименьшее положительное (ненулевое)число,которое может быть представлено в 64-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="dc5780ad9a486e96ea340daaaf93bd9d64035e65" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;strong&gt;re-play&lt;/strong&gt; the module's top level statements. This solves the problem without having to special case the logic that fills the internal seqs which are affected by the pragmas.</source>
          <target state="translated">Решение состоит в том, чтобы &lt;strong&gt;повторно воспроизвести&lt;/strong&gt; операторы верхнего уровня модуля. Это решает проблему без особого случая логики, заполняющей внутренние последовательности, на которые влияют прагмы.</target>
        </trans-unit>
        <trans-unit id="9449ed4a1afa5ff8ca6796adc72142c21a9e0e84" translate="yes" xml:space="preserve">
          <source>The source line that triggered a diagnostic message.</source>
          <target state="translated">Строка-источник,вызвавшая диагностическое сообщение.</target>
        </trans-unit>
        <trans-unit id="799e7aa051d179767ffba8160a4bb2cdfa09b721" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">Специальная переменная &lt;code&gt;result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68b5ebd6f219423fa1db061ea18fb296f76e1f9f" translate="yes" xml:space="preserve">
          <source>The square brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional element.</source>
          <target state="translated">Квадратные скобки &lt;code&gt;[]&lt;/code&gt; указывают на необязательный элемент.</target>
        </trans-unit>
        <trans-unit id="f2a70efe37ccaad3ecc8b9b1191dbd149f70e953" translate="yes" xml:space="preserve">
          <source>The standard distribution ships with the following tools:</source>
          <target state="translated">Стандартные распределительные суда со следующими инструментами:</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">Стандартный поток ошибок.</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">Стандартный входной поток.</target>
        </trans-unit>
        <trans-unit id="0c3f75a49135f9016942ef1a6c30dd582e32a67d" translate="yes" xml:space="preserve">
          <source>The standard library can be avoided to a point where C code generation for 16bit micro controllers is feasible. Use the &lt;span id=&quot;standalone_1&quot;&gt;standalone&lt;/span&gt; target (&lt;code&gt;--os:standalone&lt;/code&gt;) for a bare bones standard library that lacks any OS features.</source>
          <target state="translated">Стандартной библиотеки можно избежать до такой степени, что генерация кода C для 16-битных микроконтроллеров станет возможной. Используйте &lt;span id=&quot;standalone_1&quot;&gt;автономную&lt;/span&gt; цель ( &lt;code&gt;--os:standalone&lt;/code&gt; ) для простой стандартной библиотеки, в которой отсутствуют какие-либо функции ОС.</target>
        </trans-unit>
        <trans-unit id="3bbcfca9d43af60421b59aa297f2843d4ff476d7" translate="yes" xml:space="preserve">
          <source>The standard library supports a growing number of &lt;code&gt;useX&lt;/code&gt; conditional defines affecting how some features are implemented. This section tries to give a complete list.</source>
          <target state="translated">Стандартная библиотека поддерживает все большее количество условных определений &lt;code&gt;useX&lt;/code&gt; , влияющих на реализацию некоторых функций. В этом разделе делается попытка дать полный список.</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">Стандартный выходной поток.</target>
        </trans-unit>
        <trans-unit id="e587b063e208685c74c0b90958dc5ab40a14e654" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed in sequential order unless an exception &lt;code&gt;e&lt;/code&gt; is raised. If the exception type of &lt;code&gt;e&lt;/code&gt; matches any listed in an &lt;code&gt;except&lt;/code&gt; clause the corresponding statements are executed. The statements following the &lt;code&gt;except&lt;/code&gt; clauses are called &lt;span id=&quot;exception-handlers_1&quot;&gt;exception handlers&lt;/span&gt;.</source>
          <target state="translated">Операторы после &lt;code&gt;try&lt;/code&gt; выполняются в последовательном порядке, если не возникает исключение &lt;code&gt;e&lt;/code&gt; . Если тип исключения &lt;code&gt;e&lt;/code&gt; соответствует любому из перечисленных в разделе &lt;code&gt;except&lt;/code&gt; , выполняются соответствующие операторы. Операторы, следующие &lt;code&gt;except&lt;/code&gt; предложениями except , называются &lt;span id=&quot;exception-handlers_1&quot;&gt;обработчиками исключений&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="5e42bdb57f1a751ebb6ae75640b75ab4a37accc2" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed unless an exception is raised. Then the appropriate &lt;code&gt;except&lt;/code&gt; part is executed.</source>
          <target state="translated">Операторы после &lt;code&gt;try&lt;/code&gt; выполняются, если не возникает исключение. Затем выполняется соответствующая часть &lt;code&gt;except&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f3324ba035483cd423641c95748bc8274785628" translate="yes" xml:space="preserve">
          <source>The statements do not open a new scope.</source>
          <target state="translated">Эти заявления не открывают новых возможностей.</target>
        </trans-unit>
        <trans-unit id="885e9c28443dfee3e864ed46b2792fa6eef8a60c" translate="yes" xml:space="preserve">
          <source>The statements that belong to the expression that evaluated to true are translated by the compiler, the other statements are not checked for semantics! However, each condition is checked for semantics.</source>
          <target state="translated">Операции,принадлежащие выражению,которое оценивалось как истинное,транслируются компилятором,остальные операторы не проверяются на семантику! Однако каждое условие проверяется на семантику.</target>
        </trans-unit>
        <trans-unit id="e6d4574c29f988390f3a56cfec01b716ffdcfb61" translate="yes" xml:space="preserve">
          <source>The statements within a branch do not open a new scope.</source>
          <target state="translated">Заявления в филиале не открывают новой области применения.</target>
        </trans-unit>
        <trans-unit id="4e30151d5e9f17c8b266d5c2ebc2ca35ea0c04ba" translate="yes" xml:space="preserve">
          <source>The status of a test when it is done.</source>
          <target state="translated">Статус теста,когда он будет выполнен.</target>
        </trans-unit>
        <trans-unit id="fd60c4990adcd88d94b2b574d1d8c68d1fefb098" translate="yes" xml:space="preserve">
          <source>The stdlib API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">API stdlib разработан, чтобы быть &lt;strong&gt;простым в использовании&lt;/strong&gt; и последовательным. Простота использования измеряется количеством вызовов для достижения конкретного действия высокого уровня. Конечная цель состоит в том, чтобы программист мог &lt;em&gt;угадать&lt;/em&gt; имя.</target>
        </trans-unit>
        <trans-unit id="10b2a953237a037ac2265ff58952966ca750b340" translate="yes" xml:space="preserve">
          <source>The stdtmpl filter provides a simple templating engine for Nim. The filter uses a line based parser: Lines prefixed with a &lt;em&gt;meta character&lt;/em&gt; (default: &lt;code&gt;#&lt;/code&gt;) contain Nim code, other lines are verbatim. Because indentation-based parsing is not suited for a templating engine, control flow statements need &lt;code&gt;end X&lt;/code&gt; delimiters.</source>
          <target state="translated">Фильтр stdtmpl предоставляет простой движок шаблонов для Nim. Фильтр использует синтаксический анализатор на основе строк: строки с префиксом &lt;em&gt;метасимвола&lt;/em&gt; (по умолчанию: &lt;code&gt;#&lt;/code&gt; ) содержат код Nim, остальные строки дословно. Поскольку синтаксический анализ на основе отступов не подходит для механизма шаблонов, операторы потока управления нуждаются в &lt;code&gt;end X&lt;/code&gt; разделителях X.</target>
        </trans-unit>
        <trans-unit id="d853705ac2e16ddbf20df344526fe76e5bbe1d6b" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;exportc&lt;/code&gt; can be a format string:</source>
          <target state="translated">Строковый литерал, переданный в &lt;code&gt;exportc&lt;/code&gt; , может быть форматной строкой:</target>
        </trans-unit>
        <trans-unit id="bc021537db9d4c37bc85c30ff44582b67a30832c" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;importc&lt;/code&gt; can be a format string:</source>
          <target state="translated">Строковый литерал, переданный в &lt;code&gt;importc&lt;/code&gt; , может быть строкой формата:</target>
        </trans-unit>
        <trans-unit id="4d2a1a53ec06666d804727e437f2a83c5ef106f3" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">Оператор строкового преобразования для аргумента CString. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в строку.</target>
        </trans-unit>
        <trans-unit id="c484fec0f015605339671fc06ee766d4baaf377e" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;em&gt;x&lt;/em&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="translated">Оператор строкового преобразования для логического аргумента. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в строку &amp;laquo;false&amp;raquo; или &amp;laquo;true&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a992e6797c902629fdda65b889cba064825234dc" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">Оператор строкового преобразования для символьного аргумента. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в строку.</target>
        </trans-unit>
        <trans-unit id="89e3fe4dd1865173eb89990a7d7f5be7c43387f1" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">Оператор строкового преобразования для аргумента с плавающей запятой. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в десятичную строку.</target>
        </trans-unit>
        <trans-unit id="c0db5c9df492c1a8b3dd9a2a95f9cef2f3e526af" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;em&gt;x&lt;/em&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="translated">Оператор строкового преобразования для строкового аргумента. Возвращает &lt;em&gt;x&lt;/em&gt; как есть. Этот оператор полезен для универсального кода, поэтому &lt;code&gt;$expr&lt;/code&gt; также работает, если &lt;code&gt;expr&lt;/code&gt; уже является строкой.</target>
        </trans-unit>
        <trans-unit id="3ee7503135fe164e7c14568404ab5024b8abba0c" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a &lt;code&gt;$&lt;/code&gt; operator for a concrete enumeration is provided, this is used instead. (In other words: &lt;em&gt;Overwriting&lt;/em&gt; is possible.)</source>
          <target state="translated">Оператор строкового преобразования для аргумента перечисления. Это работает для любого типа перечисления благодаря магии компилятора. Если для конкретного перечисления предоставляется оператор &lt;code&gt;$&lt;/code&gt; , он используется вместо него. (Другими словами: &lt;em&gt;перезапись&lt;/em&gt; возможна.)</target>
        </trans-unit>
        <trans-unit id="e386bfe78072559f8bbde8532560130a6e7ea6ed" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">Оператор строкового преобразования для целочисленного аргумента. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в десятичную строку.</target>
        </trans-unit>
        <trans-unit id="606e2a47ef9a1510fef08559a8704f9cc52bd2a6" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="translated">Оператор строкового преобразования для целочисленного аргумента. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в десятичную строку. &lt;code&gt;$&lt;/code&gt; - это общий способ написания &lt;span id=&quot;tostring_1&quot;&gt;toString в&lt;/span&gt; Ниме .</target>
        </trans-unit>
        <trans-unit id="df81e6c55f80fcc8fa6ae2e9828d9cd7028b723f" translate="yes" xml:space="preserve">
          <source>The strip filter simply removes leading and trailing whitespace from each line.</source>
          <target state="translated">Полосовой фильтр просто удаляет лидирующие и скользящие пробелы из каждой линии.</target>
        </trans-unit>
        <trans-unit id="8354da2777d5d9c0570db388afcea4a685a09419" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is an optional argument passed to &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">Подвыражение после двоеточия ( &lt;code&gt;arg&lt;/code&gt; в &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; ) является необязательным аргументом, передаваемым в &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="085f167d1954a66b4d663e11ef8c099c5beed236" translate="yes" xml:space="preserve">
          <source>The subset is in fact the full language with the following restrictions / changes:</source>
          <target state="translated">Подмножество на самом деле является полным языком со следующими ограничениями/изменениями:</target>
        </trans-unit>
        <trans-unit id="13d7858966cc6cd5e4db4c4d41318b516b21b8a4" translate="yes" xml:space="preserve">
          <source>The substitution character introduces a Nim expression &lt;em&gt;e&lt;/em&gt; within the string literal. &lt;em&gt;e&lt;/em&gt; is converted to a string with the &lt;em&gt;toString&lt;/em&gt; operation which defaults to &lt;code&gt;$&lt;/code&gt;. For strong type checking, set &lt;code&gt;toString&lt;/code&gt; to the empty string. &lt;em&gt;e&lt;/em&gt; must match this PEG pattern:</source>
          <target state="translated">Символ подстановки вводит выражение Nim &lt;em&gt;e&lt;/em&gt; в строковом литерале. &lt;em&gt;e&lt;/em&gt; преобразуется в строку с помощью операции &lt;em&gt;toString,&lt;/em&gt; которая по умолчанию равна &lt;code&gt;$&lt;/code&gt; . Для строгой проверки типов установите для параметра &lt;code&gt;toString&lt;/code&gt; пустую строку. &lt;em&gt;e&lt;/em&gt; должен соответствовать этому шаблону PEG:</target>
        </trans-unit>
        <trans-unit id="167b71fcfef3ed3730604fc6b40f66159f634c79" translate="yes" xml:space="preserve">
          <source>The substitution variables (the thing after the &lt;code&gt;$&lt;/code&gt;) are enumerated from 1 to &lt;code&gt;a.len&lt;/code&gt;. To produce a verbatim &lt;code&gt;$&lt;/code&gt;, use &lt;code&gt;$$&lt;/code&gt;. The notation &lt;code&gt;$#&lt;/code&gt; can be used to refer to the next substitution variable:</source>
          <target state="translated">Переменные подстановки (вещь после &lt;code&gt;a.len&lt;/code&gt; &lt;code&gt;$&lt;/code&gt; ) пронумерованы от 1 до a.len . Чтобы получить дословный знак &lt;code&gt;$&lt;/code&gt; , используйте &lt;code&gt;$$&lt;/code&gt; . Обозначение &lt;code&gt;$#&lt;/code&gt; может использоваться для обозначения следующей переменной подстановки:</target>
        </trans-unit>
        <trans-unit id="d363d1e70588dfd25d1127db5f03a916d9f112a5" translate="yes" xml:space="preserve">
          <source>The suite will run the individual test cases in the order in which they were listed. With default global settings the above code prints:</source>
          <target state="translated">Комплект будет выполнять отдельные тестовые случаи в том порядке,в котором они были перечислены.При глобальных настройках по умолчанию приведенный выше код распечатывается:</target>
        </trans-unit>
        <trans-unit id="58f6801df2beac64305a6335b8896742f456c35c" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;fd&lt;/code&gt;'s non-blocking state will be enabled implicitly.</source>
          <target state="translated">Неблокирующее состояние предоставленного &lt;code&gt;fd&lt;/code&gt; будет включено неявно.</target>
        </trans-unit>
        <trans-unit id="80f2150ae39427c1e80e64b88f0a9a85b61d40f9" translate="yes" xml:space="preserve">
          <source>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</source>
          <target state="translated">Правила связывания символов в дженериках несколько неуловимы:есть &quot;открытые&quot; и &quot;закрытые&quot; символы.Символ &quot;закрытый&quot; не может быть переплетен в контексте инстанцирования,символ &quot;открытый&quot; может быть переплетен.По умолчанию перегруженные символы являются открытыми,а все остальные символы закрыты.</target>
        </trans-unit>
        <trans-unit id="1b8df85fe6e5d00af794928d133e0df6b4e79a93" translate="yes" xml:space="preserve">
          <source>The symbol's &lt;code&gt;ast&lt;/code&gt; field is loaded lazily, on demand. This is where most savings come from, only the shallow outer AST is reconstructed immediately.</source>
          <target state="translated">Поле &lt;code&gt;ast&lt;/code&gt; символа загружается лениво, по запросу. Отсюда большая часть экономии, сразу реконструируется только неглубокая внешняя AST.</target>
        </trans-unit>
        <trans-unit id="9db37ffc32ca144aebdbca14546aec93600a111e" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A △ B&lt;/em&gt; or &lt;em&gt;A ⊖ B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; or &lt;em&gt;s2&lt;/em&gt; but not both at the same time. Example:</source>
          <target state="translated">Симметричная разность двух множеств математически представлена ​​как &lt;em&gt;A △ B&lt;/em&gt; или &lt;em&gt;A ⊖ B&lt;/em&gt; и представляет собой набор всех объектов, которые являются членами &lt;em&gt;s1&lt;/em&gt; или &lt;em&gt;s2,&lt;/em&gt; но не обоими одновременно. Пример:</target>
        </trans-unit>
        <trans-unit id="b6a7467e652ab7936684b0f288dffd1681193ff3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; can be used to import multiple modules from the same directory.</source>
          <target state="translated">Синтаксис &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; может использоваться для импорта нескольких модулей из одного каталога.</target>
        </trans-unit>
        <trans-unit id="b40da33c17602bee643c7f4057eb8022801e2460" translate="yes" xml:space="preserve">
          <source>The syntax for iterators is similar to procs, but with &lt;code&gt;nnkIteratorDef&lt;/code&gt; replacing &lt;code&gt;nnkProcDef&lt;/code&gt;.</source>
          <target state="translated">Синтаксис итераторов похож на procs, но &lt;code&gt;nnkIteratorDef&lt;/code&gt; заменяет &lt;code&gt;nnkProcDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e8fda84a4ffe40d2120509d7a72b690281067e4" translate="yes" xml:space="preserve">
          <source>The syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided in height levels accessed through their integer index:</source>
          <target state="translated">Синтаксис для вложенных массивов (многомерных)на других языках-это вопрос добавления дополнительных скобок,потому что обычно каждое измерение ограничено одним и тем же типом индекса,что и другие.В Nim вы можете иметь разные размеры с разными типами индексов,поэтому синтаксис вложенности немного отличается.Основываясь на предыдущем примере,где уровень определяется как массив перечислений,проиндексированных еще одним перечислением,мы можем добавить следующие строки,чтобы добавить тип световой башни,разделенный на уровни высоты,доступ к которым осуществляется через их целочисленный индекс:</target>
        </trans-unit>
        <trans-unit id="0fc163c5356858c1953a68e20f8853fbed990195" translate="yes" xml:space="preserve">
          <source>The syntax for type conversions is &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (like an ordinary call):</source>
          <target state="translated">Синтаксис преобразования типов - &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (как при обычном вызове):</target>
        </trans-unit>
        <trans-unit id="2f95970b03c93b55b855c3143404ffb154e93738" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;case&lt;/code&gt; in an object declaration follows closely the syntax of the &lt;code&gt;case&lt;/code&gt; statement: The branches in a &lt;code&gt;case&lt;/code&gt; section may be indented too.</source>
          <target state="translated">Синтаксис &lt;code&gt;case&lt;/code&gt; в объявлении объекта точно следует синтаксису оператора &lt;code&gt;case&lt;/code&gt; : ветви в разделе &lt;code&gt;case&lt;/code&gt; также могут иметь отступ.</target>
        </trans-unit>
        <trans-unit id="8df91b05c23f64188bd8503b3710389f5709acad" translate="yes" xml:space="preserve">
          <source>The syntax to &lt;em&gt;invoke&lt;/em&gt; a template is the same as calling a procedure.</source>
          <target state="translated">Синтаксис &lt;em&gt;вызова&lt;/em&gt; шаблона такой же, как и при вызове процедуры.</target>
        </trans-unit>
        <trans-unit id="379a9e1787c2fb57f06adcc397630994d8088c6e" translate="yes" xml:space="preserve">
          <source>The syntax tree</source>
          <target state="translated">Синтаксическое дерево</target>
        </trans-unit>
        <trans-unit id="f8025e01a9219586f4ea9ca1e8fe9cf0b016b7a2" translate="yes" xml:space="preserve">
          <source>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the &quot;ast&quot; module for the type definitions. The &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module contains many examples how the AST represents each syntactic structure.</source>
          <target state="translated">Синтаксическое дерево состоит из узлов, которые могут иметь произвольное количество дочерних элементов. Типы и символы представлены другими узлами, поскольку они могут содержать циклы. AST меняет свою форму после семантической проверки. Это нужно, чтобы облегчить жизнь генераторам кода. См. Модуль &quot;ast&quot; для определения типов. Модуль &lt;a href=&quot;macros&quot;&gt;макросов&lt;/a&gt; содержит множество примеров того, как AST представляет каждую синтаксическую структуру.</target>
        </trans-unit>
        <trans-unit id="46885e1cfadfc4a010003eabca5811146f7c040a" translate="yes" xml:space="preserve">
          <source>The syscall convention is the same as &lt;code&gt;__syscall&lt;/code&gt; in C. It is used for interrupts.</source>
          <target state="translated">Соглашение о системных вызовах такое же, как &lt;code&gt;__syscall&lt;/code&gt; в C. Оно используется для прерываний.</target>
        </trans-unit>
        <trans-unit id="a3f6bdaaf4d5477f1c500a92aa3e349f56e0070d" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">Команда temp создает компилятор Nim, но с другим окончательным именем ( &lt;code&gt;nim_temp&lt;/code&gt; ), поэтому он не перезаписывает ваш обычный компилятор. Вы можете использовать эту команду для проверки различных параметров, точно так же, как и для команды &lt;a href=&quot;#boot-command&quot;&gt;загрузки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3df22e7a1794dd0ef985c2174f0bd9d90ca21bb9" translate="yes" xml:space="preserve">
          <source>The template engine is quite flexible. It is easy to produce a procedure that writes the template code directly to a file:</source>
          <target state="translated">Двигатель шаблонов достаточно гибкий.Легко создать процедуру,которая записывает код шаблона непосредственно в файл:</target>
        </trans-unit>
        <trans-unit id="5d144a85c6f59928edd7f189f3b6401e2a927278" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression.</source>
          <target state="translated">Шаблон вводит переменную &lt;code&gt;it&lt;/code&gt; , которую вы можете использовать непосредственно в выражении.</target>
        </trans-unit>
        <trans-unit id="9b23f79ed77cf3b0ae3ac2cd0d6a1fd2ff5bea88" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. Example:</source>
          <target state="translated">Шаблон вводит переменную &lt;code&gt;it&lt;/code&gt; , которую вы можете использовать непосредственно в выражении. Пример:</target>
        </trans-unit>
        <trans-unit id="71559554774a606802fa41138d874a38d2c3c673" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating.</source>
          <target state="translated">Шаблон вводит переменную &lt;code&gt;it&lt;/code&gt; , которую вы можете использовать непосредственно в выражении. Выражение должно возвращать тот же тип, что и изменяемая последовательность.</target>
        </trans-unit>
        <trans-unit id="7e6285ee4f6bf81ff2cc725be672e1b5b5dc8943" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. You also need to pass as &lt;em&gt;typ&lt;/em&gt; the type of the expression, since the new returned sequence can have a different type than the original.</source>
          <target state="translated">Шаблон вводит переменную &lt;code&gt;it&lt;/code&gt; , которую вы можете использовать непосредственно в выражении. Кроме того, необходимо пройти как &lt;em&gt;типовой&lt;/em&gt; типа выражения, поскольку новая возвращаются последовательность может иметь различный тип , чем оригинал.</target>
        </trans-unit>
        <trans-unit id="a708a430f68cec5b9b3fed13a7aade1b333cf36a" translate="yes" xml:space="preserve">
          <source>The terminating zero cannot be accessed unless the string is converted to the &lt;code&gt;cstring&lt;/code&gt; type first. The terminating zero assures that this conversion can be done in O(1) and without any allocations.</source>
          <target state="translated">К завершающему нулю нельзя получить доступ, если сначала строка не преобразована в тип &lt;code&gt;cstring&lt;/code&gt; . Завершающий ноль гарантирует, что это преобразование может быть выполнено за O (1) и без каких-либо выделений.</target>
        </trans-unit>
        <trans-unit id="6f48e150aa0a5a53af6ca79d3b6ba9e7f7657bf6" translate="yes" xml:space="preserve">
          <source>The test status and name is printed after any output or traceback.</source>
          <target state="translated">Состояние и имя теста печатается после любого вывода или прослеживания.</target>
        </trans-unit>
        <trans-unit id="526c72c6f1f64cc3b20092dd199d521f48bbae6b" translate="yes" xml:space="preserve">
          <source>The third and last way to write string literals are &lt;em&gt;long string literals&lt;/em&gt;. They are written with three quotes: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;; they can span over multiple lines and the &lt;code&gt;\&lt;/code&gt; is not an escape character either. They are very useful for embedding HTML code templates for example.</source>
          <target state="translated">Третий и последний способ записи строковых литералов - &lt;em&gt;длинные строковые литералы&lt;/em&gt; . Они пишутся в трех кавычках: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; ; они могут занимать несколько строк, и &lt;code&gt;\&lt;/code&gt; также не является escape-символом. Они очень полезны, например, для встраивания шаблонов HTML-кода.</target>
        </trans-unit>
        <trans-unit id="c7d0bff946245f3196ff3fec3eab7b5f9ec10e1f" translate="yes" xml:space="preserve">
          <source>The third use of backslash is for specifying &lt;span id=&quot;generic-character-types_1&quot;&gt;generic character types&lt;/span&gt;. The following are always recognized:</source>
          <target state="translated">Третий вариант использования обратной косой черты - для указания &lt;span id=&quot;generic-character-types_1&quot;&gt;общих типов символов&lt;/span&gt; . Всегда признаются:</target>
        </trans-unit>
        <trans-unit id="716122720506770b96f97a3949c5f63d216ca318" translate="yes" xml:space="preserve">
          <source>The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">Символ(и)новой строки удаляется(ются)из итерационных строк.Пример:</target>
        </trans-unit>
        <trans-unit id="088f34b2b9f2860def75b9865d8fa88192adf164" translate="yes" xml:space="preserve">
          <source>The type coercion &lt;code&gt;static(x)&lt;/code&gt; can be used to force the compile-time evaluation of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Тип принуждение &lt;code&gt;static(x)&lt;/code&gt; может использоваться для принудительной оценки времени компиляции данного выражения &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ed681a392a0c61fb28eee2975db81a956d2924e" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; holds.</source>
          <target state="translated">Преобразование типа &lt;code&gt;T(a)&lt;/code&gt; является L-значением, если &lt;code&gt;a&lt;/code&gt; является L-значением и &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7007f414d9f07ec9d9545e70f77c0fb11e2655f" translate="yes" xml:space="preserve">
          <source>The type of a parameter may be prefixed with the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">Тип параметра может быть предварен ключевым словом &lt;code&gt;var&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b4149e9c761a9c5b1d817b72b94a54f51db12381" translate="yes" xml:space="preserve">
          <source>The type representing a file handle.</source>
          <target state="translated">Тип,представляющий файловую рукоятку.</target>
        </trans-unit>
        <trans-unit id="9b4854aa3e47cfa3fa7a0d71ef4763a784b0d2a7" translate="yes" xml:space="preserve">
          <source>The type suffixes are:</source>
          <target state="translated">Типы суффиксов:</target>
        </trans-unit>
        <trans-unit id="4006d5cc88fdabea98a514a10633d32480b50418" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="translated">Типы &lt;code&gt;var T&lt;/code&gt; и &lt;code&gt;typedesc[T]&lt;/code&gt; не могут быть выведены в универсальном экземпляре. Не допускается следующее:</target>
        </trans-unit>
        <trans-unit id="15965d3cd0f4bb804b8212dddb5431bf9b84d441" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or Javascript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">Типичное использование компилятора включает использование команды &lt;code&gt;compile&lt;/code&gt; или &lt;code&gt;c&lt;/code&gt; для преобразования файла &lt;code&gt;.nim&lt;/code&gt; в один или несколько файлов &lt;code&gt;.c&lt;/code&gt; , которые затем компилируются с помощью компилятора C платформы в статический двоичный файл. Однако есть и другие команды для компиляции в C ++, Objective-C или Javascript. Более подробную информацию можно прочитать в &lt;a href=&quot;backends&quot;&gt;документе Nim Backend Integration&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2323beee7c184cc654539984a6ab3af180da6e48" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">Типичным сценарием использования этой опции является ее вызов после того, как пользователь набрал точку для &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;объектно-ориентированного синтаксиса вызова&lt;/a&gt; . Idetools попытается вернуть предложения, отсортированные сначала по области (от самого внутреннего до самого внешнего), а затем по имени элемента.</target>
        </trans-unit>
        <trans-unit id="b45de376a3cd2738b15e943470c78ad94bed4791" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">Типичным сценарием использования этой опции является ее вызов после того, как пользователь набрал точку для &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;объектно-ориентированного синтаксиса вызова&lt;/a&gt; . Nimsuggest попытается вернуть предложения, отсортированные сначала по области действия (от самого внутреннего до самого внешнего), а затем по имени элемента.</target>
        </trans-unit>
        <trans-unit id="c1bb924a06b99256d96c42fb02e7ceffd0f6c417" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt; or both. Example:</source>
          <target state="translated">Объединение двух наборов математически представляется как &lt;em&gt;A &amp;cup; B&lt;/em&gt; и представляет собой набор всех объектов, которые являются членами &lt;em&gt;s1&lt;/em&gt; , &lt;em&gt;s2&lt;/em&gt; или обоих. Пример:</target>
        </trans-unit>
        <trans-unit id="d8d1d1447b153afdb0a97fd8b87918bc4140f680" translate="yes" xml:space="preserve">
          <source>The unit of the parameters &lt;code&gt;maxPauseInUs&lt;/code&gt; and &lt;code&gt;us&lt;/code&gt; is microseconds.</source>
          <target state="translated">Единица измерения параметров &lt;code&gt;maxPauseInUs&lt;/code&gt; и &lt;code&gt;us&lt;/code&gt; - микросекунды.</target>
        </trans-unit>
        <trans-unit id="ebb55c959a3f02d3eea1dc9ff808f8bb2abaea44" translate="yes" xml:space="preserve">
          <source>The unsafeAddr operator</source>
          <target state="translated">Оператор небезопасногоAddr</target>
        </trans-unit>
        <trans-unit id="0ef21f06b17eb379f0787340a289e02dd9482513" translate="yes" xml:space="preserve">
          <source>The upload of new files.</source>
          <target state="translated">Загрузка новых файлов.</target>
        </trans-unit>
        <trans-unit id="ffb9dbd8c79b78dedb57dfcf3aa60f5d7e195511" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;concept&lt;/code&gt; (experimental) is similar to objects.</source>
          <target state="translated">Использование &lt;code&gt;concept&lt;/code&gt; (экспериментальное) аналогично объектам.</target>
        </trans-unit>
        <trans-unit id="9a559c657b3e94a5a3b4f28ede4f3e541e9898aa" translate="yes" xml:space="preserve">
          <source>The user guide lists command line arguments, special features of the compiler, etc.</source>
          <target state="translated">В руководстве пользователя перечислены аргументы командной строки,особенности компилятора и т.д.</target>
        </trans-unit>
        <trans-unit id="aec3c4c08d9fd434b6b3b95d1925acd83f75de3e" translate="yes" xml:space="preserve">
          <source>The using statement provides syntactic convenience in modules where the same parameter names and types are used over and over. Instead of:</source>
          <target state="translated">Оператор use обеспечивает синтаксическое удобство в модулях,где снова и снова используются одни и те же имена и типы параметров.Вместо:</target>
        </trans-unit>
        <trans-unit id="99d6383e434dd62dcbce9c98ef86b8da04045406" translate="yes" xml:space="preserve">
          <source>The values of the returned enum should be pretty self explanatory:</source>
          <target state="translated">Значения возвращаемого перечисления должны быть довольно понятными:</target>
        </trans-unit>
        <trans-unit id="e580cb29ada1c872bcbdfbf5d59c299cb8b1209f" translate="yes" xml:space="preserve">
          <source>The var statement</source>
          <target state="translated">Вариационное заявление</target>
        </trans-unit>
        <trans-unit id="44981de5f0080cccfda5bafeb275d3e5b51b6196" translate="yes" xml:space="preserve">
          <source>The var statement declares a new local or global variable:</source>
          <target state="translated">Оператор var объявляет новую локальную или глобальную переменную:</target>
        </trans-unit>
        <trans-unit id="a7fb42712b4a095b6edcf947d23562ccc99a3384" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;i&lt;/code&gt; is implicitly declared by the &lt;code&gt;for&lt;/code&gt; loop and has the type &lt;code&gt;int&lt;/code&gt;, because that is what &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; returns. &lt;code&gt;i&lt;/code&gt; runs through the values 1, 2, .., 10. Each value is &lt;code&gt;echo&lt;/code&gt;-ed. This code does the same:</source>
          <target state="translated">Переменная &lt;code&gt;i&lt;/code&gt; неявно объявляется циклом &lt;code&gt;for&lt;/code&gt; и имеет тип &lt;code&gt;int&lt;/code&gt; , потому что именно это возвращает &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; . &lt;code&gt;i&lt;/code&gt; пробегает значения 1, 2, .., 10. Каждое значение отображается &lt;code&gt;echo&lt;/code&gt; . Этот код делает то же самое:</target>
        </trans-unit>
        <trans-unit id="bc84debb5dc6452e51fb2c78cf8623fbed79f8ac" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;em&gt;cmpIgnoreStyle&lt;/em&gt;. &lt;em&gt;ValueError&lt;/em&gt; is raised if an ill-formed format string has been passed to the &lt;em&gt;%&lt;/em&gt; operator.</source>
          <target state="translated">Переменные сравниваются с &lt;em&gt;cmpIgnoreStyle&lt;/em&gt; . &lt;em&gt;ValueError&lt;/em&gt; возникает, если неверно сформированная строка формата была передана оператору &lt;em&gt;%&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2fa9f6f05c0209f1598bd49966b81632306fcee5" translate="yes" xml:space="preserve">
          <source>The while statement is a simple looping construct:</source>
          <target state="translated">В то время как утверждение является простой петлевой конструкцией:</target>
        </trans-unit>
        <trans-unit id="aba71dc483d2c43f3b09cfa11f1f0b476cc3d1fd" translate="yes" xml:space="preserve">
          <source>The year without any padding. Is always positive, even when the year is BC.</source>
          <target state="translated">Год без набивки.Всегда позитивен,даже когда год-это БК.</target>
        </trans-unit>
        <trans-unit id="ab38f01dd3bc85831012f0bac4816fc3e75b4486" translate="yes" xml:space="preserve">
          <source>The year without any padding. Will be negative when the year is BC.</source>
          <target state="translated">Год без набивки.Будет отрицательно когда годом будет BC.</target>
        </trans-unit>
        <trans-unit id="b039a29b58c22bdb2915a3acea080780142c1b28" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="translated">Год,с четырьмя цифрами.Всегда положительный,даже когда год BC.Когда год больше чем 4 цифры,предварено '+'.</target>
        </trans-unit>
        <trans-unit id="2f78eca394ea113bd4e29e67d3fec4d4e88e2b66" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="translated">Год,с четырьмя цифрами.Будет отрицательно когда годом будет BC.Когда год больше чем 4 цифры,&quot;+&quot; предварено если год не BC.</target>
        </trans-unit>
        <trans-unit id="7ff8ad7505b8b464009361f8dda42aba0d8ec846" translate="yes" xml:space="preserve">
          <source>Then calls &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">Затем вызывает &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; и после этого закрывает файл. Возвращает строку. Вызывает исключение ввода-вывода в случае ошибки. Если вам нужно вызвать это внутри макроса времени компиляции, вы можете использовать &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="030aaf6f2fc0e5a5cf064da69f557632a5c59e9e" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;A&lt;/code&gt; (that depends on &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;) is compiled and &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; are left unchanged. &lt;code&gt;A&lt;/code&gt; requires &lt;code&gt;G.P2&lt;/code&gt;.</source>
          <target state="translated">Затем модуль &lt;code&gt;A&lt;/code&gt; (который зависит от &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;G&lt;/code&gt; ) компилируется, а &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;G&lt;/code&gt; остаются без изменений. &lt;code&gt;A&lt;/code&gt; требует &lt;code&gt;G.P2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ade512072594e8264ff592564aff0e3bc992458" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;B&lt;/code&gt; is compiled that requires &lt;code&gt;G.P1&lt;/code&gt;. Ok, no problem, &lt;code&gt;G.P1&lt;/code&gt; is loaded from the symbol file and &lt;code&gt;G.c&lt;/code&gt; now contains &lt;code&gt;G.P1&lt;/code&gt;.</source>
          <target state="translated">Затем компилируется модуль &lt;code&gt;B&lt;/code&gt; ,для которого требуется &lt;code&gt;G.P1&lt;/code&gt; . Хорошо, без проблем, &lt;code&gt;G.P1&lt;/code&gt; загружен из файла символов, а &lt;code&gt;G.c&lt;/code&gt; теперь содержит &lt;code&gt;G.P1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a70a722d347238a21f07b6a20009bf20f06664" translate="yes" xml:space="preserve">
          <source>Then move the C code and the compile script &lt;code&gt;compile_myproject.sh&lt;/code&gt; to your Linux i386 machine and run the script.</source>
          <target state="translated">Затем переместите код C и сценарий компиляции &lt;code&gt;compile_myproject.sh&lt;/code&gt; на компьютер с Linux i386 и запустите сценарий.</target>
        </trans-unit>
        <trans-unit id="23f5d4391872d1d0618203f6cd8356fa03af48c8" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size. Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.</source>
          <target state="translated">Есть 2 вида итераторов в Nim: &lt;em&gt;встроенная&lt;/em&gt; и &lt;em&gt;закрытие&lt;/em&gt; итераторы. Встроенный &lt;span id=&quot;inline-iterator_1&quot;&gt;итератор&lt;/span&gt; - это итератор, который всегда встроен компилятором, что приводит к нулевым накладным расходам для абстракции, но может привести к значительному увеличению размера кода. Встроенные итераторы - это граждане второго сорта; Их можно передавать как параметры только в другие средства встраивания кода, такие как шаблоны, макросы и другие встроенные итераторы.</target>
        </trans-unit>
        <trans-unit id="2204cd4df928fb544bb442ca84cde7bf3009d982" translate="yes" xml:space="preserve">
          <source>There are 3 operations that are bound to a type:</source>
          <target state="translated">Есть 3 операции,которые привязаны к типу:</target>
        </trans-unit>
        <trans-unit id="a85b79c160e40ebe8ffa7f8d4d317c2a9bf28239" translate="yes" xml:space="preserve">
          <source>There are a few things that don't work because the DevkitPro libraries don't support them. They are:</source>
          <target state="translated">Есть несколько вещей,которые не работают,потому что библиотеки DevkitPro не поддерживают их.Поддерживают:</target>
        </trans-unit>
        <trans-unit id="0ab99b54c858ac8f9d51bf5e5fe33ce55f9ff7f8" translate="yes" xml:space="preserve">
          <source>There are also raw string literals that are preceded with the letter &lt;code&gt;r&lt;/code&gt; (or &lt;code&gt;R&lt;/code&gt;) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:</source>
          <target state="translated">Существуют также необработанные строковые литералы, которым предшествует буква &lt;code&gt;r&lt;/code&gt; (или &lt;code&gt;R&lt;/code&gt; ), они разделяются соответствующими двойными кавычками (как и обычные строковые литералы) и не интерпретируют escape-последовательности. Это особенно удобно для регулярных выражений или путей Windows:</target>
        </trans-unit>
        <trans-unit id="ca885d10f37134acc825e1d0fd4f729e20b0c53b" translate="yes" xml:space="preserve">
          <source>There are currently only two options for verify mode; one is &lt;code&gt;CVerifyNone&lt;/code&gt; and with it certificates will not be verified the other is &lt;code&gt;CVerifyPeer&lt;/code&gt; and certificates will be verified for it, &lt;code&gt;CVerifyPeer&lt;/code&gt; is the safest choice.</source>
          <target state="translated">В настоящее время есть только два варианта режима проверки; один - &lt;code&gt;CVerifyNone&lt;/code&gt; , и сертификаты не будут проверяться; другой - &lt;code&gt;CVerifyPeer&lt;/code&gt; , и сертификаты будут проверены для него, &lt;code&gt;CVerifyPeer&lt;/code&gt; - самый безопасный выбор.</target>
        </trans-unit>
        <trans-unit id="b9bd1745d20224197bc6b19e361674c1fbfbfeef" translate="yes" xml:space="preserve">
          <source>There are multiple ways to get around this, including the use of the &lt;code&gt;&amp;amp;&lt;/code&gt; operator:</source>
          <target state="translated">Есть несколько способов обойти это, включая использование оператора &lt;code&gt;&amp;amp;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dfad946c72305fa2959afdaad8dd73249e24fab2" translate="yes" xml:space="preserve">
          <source>There are no constraints for the &lt;code&gt;constructor&lt;/code&gt; AST, it works for nested tuples of arrays of sets etc.</source>
          <target state="translated">Для &lt;code&gt;constructor&lt;/code&gt; AST нет ограничений , он работает для вложенных кортежей массивов наборов и т. Д.</target>
        </trans-unit>
        <trans-unit id="3e9b3d4d5566426791f36142323c5dcdbd575538" translate="yes" xml:space="preserve">
          <source>There are several node kinds that are used for semantic checking or code generation. These are accessible from this module, but should not be used. Other node kinds are especially designed to make AST manipulations easier. These are explained here.</source>
          <target state="translated">Существует несколько типов узлов,которые используются для семантической проверки или генерации кода.Они доступны из этого модуля,но не должны использоваться.Другие типы узлов специально разработаны для облегчения манипуляций с AST.Они объясняются здесь.</target>
        </trans-unit>
        <trans-unit id="70805ca564aa8b928a6ee8c36e9ffa0c1565c921" translate="yes" xml:space="preserve">
          <source>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">Существует два различных набора мета-символов:те,которые распознаются в любом месте образца,кроме квадратных скобок,и те,которые распознаются в квадратных скобках.За пределами квадратных скобок мета-символы распознаются следующим образом:</target>
        </trans-unit>
        <trans-unit id="9518223ac809befff3867df05b169ff12200b863" translate="yes" xml:space="preserve">
          <source>There are two pseudo directories:</source>
          <target state="translated">Есть два псевдо-каталога:</target>
        </trans-unit>
        <trans-unit id="b6623c5091377da7e54f379e771f12aab4eb9ebe" translate="yes" xml:space="preserve">
          <source>There are two ways to construct a PEG in Nim code:</source>
          <target state="translated">Есть два способа сконструировать PEG в Nim-коде:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
