<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="7e30a1e9a0acdfc19a0c0083bbed66bee81f8c64" translate="yes" xml:space="preserve">
          <source>This section deals with the basic built-in types and the operations that are available for them in detail.</source>
          <target state="translated">В этом разделе подробно рассматриваются основные встроенные типы и операции,доступные для них.</target>
        </trans-unit>
        <trans-unit id="39b66580a9224160aed4a56da61d43fa2a3bbf6f" translate="yes" xml:space="preserve">
          <source>This section describes Nim's additional features that are not listed in the Nim manual. Some of the features here only make sense for the C code generator and are subject to change.</source>
          <target state="translated">В этом разделе описаны дополнительные функции Nim,которые не перечислены в руководстве Nim.Некоторые из функций здесь имеют смысл только для генератора C-кода и могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="cbfa8ca764ad8bfb7ab8cb634f105e3b8af514a0" translate="yes" xml:space="preserve">
          <source>This section describes additional pragmas that the current Nim implementation supports but which should not be seen as part of the language specification.</source>
          <target state="translated">В этом разделе описаны дополнительные прагмы,которые поддерживает текущая реализация Nim,но которые не должны рассматриваться как часть спецификации языка.</target>
        </trans-unit>
        <trans-unit id="a3df74b1ff5eebb36ece2e259d2d5e805032af28" translate="yes" xml:space="preserve">
          <source>This section describes how the AST is modelled with Nim's type system. The AST consists of nodes (&lt;code&gt;NimNode&lt;/code&gt;) with a variable number of children. Each node has a field named &lt;code&gt;kind&lt;/code&gt; which describes what the node contains:</source>
          <target state="translated">В этом разделе описывается, как AST моделируется с помощью системы типов Nim. AST состоит из узлов ( &lt;code&gt;NimNode&lt;/code&gt; ) с переменным количеством дочерних узлов . У каждого узла есть поле с именем &lt;code&gt;kind&lt;/code&gt; , которое описывает, что этот узел содержит:</target>
        </trans-unit>
        <trans-unit id="b28cfadb305f94e005219763b91c53ae1a57afd3" translate="yes" xml:space="preserve">
          <source>This section lists Nim's standard syntax. How the parser handles the indentation is already described in the &lt;a href=&quot;#lexical-analysis&quot;&gt;Lexical Analysis&lt;/a&gt; section.</source>
          <target state="translated">В этом разделе перечислен стандартный синтаксис Nim. Как анализатор обрабатывает отступы, уже описано в разделе &amp;laquo; &lt;a href=&quot;#lexical-analysis&quot;&gt;Лексический анализ&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2dd3a9a0b54b906c2f17ac03b05d99470504a894" translate="yes" xml:space="preserve">
          <source>This should be called on a connected socket, and will perform an SSL handshake immediately.</source>
          <target state="translated">Он должен быть вызван на подключенном сокет,и немедленно выполнит SSL рукопожатие.</target>
        </trans-unit>
        <trans-unit id="206d66b1088d1b595bbfc280833418dec7ec898c" translate="yes" xml:space="preserve">
          <source>This should be used instead of &lt;code&gt;discard&lt;/code&gt; to discard void futures, or use &lt;code&gt;waitFor&lt;/code&gt; if you need to wait for the future's completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33d2aee12f9e4445c80f6903f9125cbac15130e" translate="yes" xml:space="preserve">
          <source>This should be used instead of &lt;code&gt;discard&lt;/code&gt; to discard void futures.</source>
          <target state="translated">Это следует использовать вместо &lt;code&gt;discard&lt;/code&gt; , чтобы отбросить недействительные фьючерсы.</target>
        </trans-unit>
        <trans-unit id="79d43e8081cd2738e9c8a30d0556e7afa9f98284" translate="yes" xml:space="preserve">
          <source>This should produce roughly this code:</source>
          <target state="translated">Это должно дать примерно такой код:</target>
        </trans-unit>
        <trans-unit id="6b78681456f7ad6085cc3fd61d2310d5e876df2d" translate="yes" xml:space="preserve">
          <source>This should resolve to root of nim sources, whether running nim from a local</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829889669aebe1d850c5abf95f09a062fffb5092" translate="yes" xml:space="preserve">
          <source>This string can be passed as the &lt;code&gt;frmStr&lt;/code&gt; argument to procs that create new loggers, such as the &lt;a href=&quot;#newConsoleLogger&quot;&gt;newConsoleLogger proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4682779a113516e431fc633b78e3eb5afe0b69" translate="yes" xml:space="preserve">
          <source>This symbol takes a string as its value, like &lt;code&gt;--define:tempDir:/some/temp/path&lt;/code&gt; to override the temporary directory returned by &lt;code&gt;os.getTempDir()&lt;/code&gt;. The value &lt;strong&gt;should&lt;/strong&gt; end with a directory separator character. (Relevant for the Android platform)</source>
          <target state="translated">Этот символ принимает в качестве значения строку, например &lt;code&gt;--define:tempDir:/some/temp/path&lt;/code&gt; , чтобы переопределить временный каталог, возвращаемый &lt;code&gt;os.getTempDir()&lt;/code&gt; . Значение &lt;strong&gt;должно&lt;/strong&gt; заканчиваться символом-разделителем каталогов. (Актуально для платформы Android)</target>
        </trans-unit>
        <trans-unit id="9b990f66ca4d7aa57f0cf0dd33176a666917f9d2" translate="yes" xml:space="preserve">
          <source>This symbol takes a string as its value, like &lt;code&gt;--define:useShPath:/opt/sh/bin/sh&lt;/code&gt; to override the path for the &lt;code&gt;sh&lt;/code&gt; binary, in cases where it is not located in the default location &lt;code&gt;/bin/sh&lt;/code&gt;.</source>
          <target state="translated">Этот символ принимает в качестве значения строку, например &lt;code&gt;--define:useShPath:/opt/sh/bin/sh&lt;/code&gt; , чтобы переопределить путь для двоичного файла &lt;code&gt;sh&lt;/code&gt; в тех случаях, когда он не находится в местоположении по умолчанию &lt;code&gt;/bin/sh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c554f8359760cdb8ba631a7cf391a049d75587f" translate="yes" xml:space="preserve">
          <source>This template will resolve into &quot;&lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;&quot; which is a string literal and since {.discardable.} doesn't apply to literals, the compiler will error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb8c91cc0539e7ac1fcb6913e444dfab0dfc651" translate="yes" xml:space="preserve">
          <source>This the stdcall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__stdcall&lt;/code&gt; keyword.</source>
          <target state="translated">Это соглашение stdcall, указанное Microsoft. Сгенерированная процедура C объявляется с &lt;code&gt;__stdcall&lt;/code&gt; словом __stdcall .</target>
        </trans-unit>
        <trans-unit id="0b9b3843bbbc030dffd360d54d7289f5101d67e4" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;#genericHead,typedesc&quot;&gt;genericHead&lt;/a&gt;, but instead of producing error for non-generic types, it will just return them unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a29bb19075988ba4154f245cf61264e6c3403b" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;em&gt;genericHead&lt;/em&gt;, but instead of producing error for non-generic types, it will just return them unmodified.</source>
          <target state="translated">Эта черта похожа на &lt;em&gt;genericHead&lt;/em&gt; , но вместо того, чтобы вызывать ошибку для неуниверсальных типов, она просто возвращает их без изменений.</target>
        </trans-unit>
        <trans-unit id="7ffbddf53bccfca8c9441dc5126a0ad4adef516e" translate="yes" xml:space="preserve">
          <source>This trait returns true if the type &lt;code&gt;t&lt;/code&gt; is safe to use for &lt;span id=&quot;copymem_1&quot;&gt;copyMem&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b73c4d12f30a07a08773a16f4683aba0e028b0" translate="yes" xml:space="preserve">
          <source>This trait returns true iff the type &lt;code&gt;t&lt;/code&gt; is safe to use for &lt;span id=&quot;copymem_1&quot;&gt;copyMem&lt;/span&gt;. Other languages name a type like these &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt;.</source>
          <target state="translated">Эта черта возвращает истину, если тип &lt;code&gt;t&lt;/code&gt; можно безопасно использовать для &lt;span id=&quot;copymem_1&quot;&gt;copyMem&lt;/span&gt; . В других языках такой тип называется &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="3824e56a10ede7c713ffb39e26e88a788482118a" translate="yes" xml:space="preserve">
          <source>This transformation is only done if the varargs parameter is the last parameter in the procedure header. It is also possible to perform type conversions in this context:</source>
          <target state="translated">Это преобразование выполняется только в том случае,если параметр varargs является последним параметром в заголовке процедуры.В этом контексте можно также выполнять приведение типов:</target>
        </trans-unit>
        <trans-unit id="66d1986229bd95fd619538b360b3cc3585eddf09" translate="yes" xml:space="preserve">
          <source>This type contains a description of a person</source>
          <target state="translated">Данный тип содержит описание человека</target>
        </trans-unit>
        <trans-unit id="fbd40a9a943d55e10d3df8977110f491416639de" translate="yes" xml:space="preserve">
          <source>This uses saturated arithmetic, so that each color component cannot overflow (255 is used as a maximum).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccecba9f8fd98b29868f4f80752b0322a7cb469c" translate="yes" xml:space="preserve">
          <source>This uses saturated arithmetic, so that each color component cannot underflow (0 is used as a minimum).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d9daad0926694b235ad99d9f58721fb3438862" translate="yes" xml:space="preserve">
          <source>This uses the &lt;span id=&quot;levenshtein_1&quot;&gt;Levenshtein&lt;/span&gt; distance algorithm with only a linear memory overhead.</source>
          <target state="translated">Здесь используется алгоритм расстояния &lt;span id=&quot;levenshtein_1&quot;&gt;Левенштейна&lt;/span&gt; с линейными накладными расходами памяти.</target>
        </trans-unit>
        <trans-unit id="6b48430da58c59da89011fc9d5e023d5bae81854" translate="yes" xml:space="preserve">
          <source>This uses the &lt;span id=&quot;levenshtein_2&quot;&gt;Levenshtein&lt;/span&gt; distance algorithm with only a linear memory overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4922584a12b79a219eaa16925bbb909743a91e2e" translate="yes" xml:space="preserve">
          <source>This uses the algorithm specified in &lt;a href=&quot;http://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;section 5.2.2 of RFC 3986&lt;/a&gt;.</source>
          <target state="translated">При этом используется алгоритм, указанный в &lt;a href=&quot;http://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;разделе 5.2.2 RFC 3986&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c864fd9946dbfd759a1749312c80f484d9172698" translate="yes" xml:space="preserve">
          <source>This uses the algorithm specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;section 5.2.2 of RFC 3986&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e216d34b156aa03e46b15d955959dbcd959d74" translate="yes" xml:space="preserve">
          <source>This uses the configuration defined in &lt;code&gt;config\nim.cfg&lt;/code&gt; for &lt;code&gt;lvm_gcc&lt;/code&gt;.</source>
          <target state="translated">При этом используется конфигурация, определенная в &lt;code&gt;config\nim.cfg&lt;/code&gt; для &lt;code&gt;lvm_gcc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94ac188fe1ac2d6a8cd8bd239dd487b9b38f11d0" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;foldl&lt;/code&gt; gets a &lt;strong&gt;starting parameter&lt;/strong&gt;. This makes it possible to accumulate the sequence into a different type than the sequence elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5505a00f1063702f80a5818b1a5c8c32d61e3710" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;foldl&lt;/code&gt; gets a starting parameter. This makes it possible to accumulate the sequence into a different type than the sequence elements.</source>
          <target state="translated">Эта версия &lt;code&gt;foldl&lt;/code&gt; получает начальный параметр. Это позволяет накапливать последовательность в типе, отличном от элементов последовательности.</target>
        </trans-unit>
        <trans-unit id="7bac1b6d0db41715df5581bb4825ea90b0b4190f" translate="yes" xml:space="preserve">
          <source>This will generate a file called &lt;code&gt;switchhomebrew.elf&lt;/code&gt; which can then be turned into an nro file with the &lt;code&gt;elf2nro&lt;/code&gt; tool in the DevkitPro release. Examples can be found at &lt;a href=&quot;https://github.com/jyapayne/nim-libnx.git&quot;&gt;the nim-libnx github repo&lt;/a&gt;.</source>
          <target state="translated">Это сгенерирует файл с именем &lt;code&gt;switchhomebrew.elf&lt;/code&gt; , который затем можно превратить в файл nro с &lt;code&gt;elf2nro&lt;/code&gt; инструмента elf2nro в выпуске DevkitPro. Примеры можно найти в &lt;a href=&quot;https://github.com/jyapayne/nim-libnx.git&quot;&gt;репозитории github nim-libnx&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26136905c2efd9e1d537dc87f61ea998287f6a6d" translate="yes" xml:space="preserve">
          <source>This will generate an index of all the exported symbols in the input Nim module, and put it into a neighboring file with the extension of &lt;code&gt;.idx&lt;/code&gt;. The index file is line oriented (newlines have to be escaped). Each line represents a tab separated record of several columns, the first two mandatory, the rest optional. See the &lt;a href=&quot;#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; section for details.</source>
          <target state="translated">Это сгенерирует индекс всех экспортированных символов во входном модуле Nim и поместит его в соседний файл с расширением &lt;code&gt;.idx&lt;/code&gt; . Индексный файл ориентирован на строку (символы новой строки должны быть экранированы). Каждая строка представляет собой разделенную табуляцией запись из нескольких столбцов, первые два являются обязательными, остальные - необязательными. Подробнее см. В разделе о &lt;a href=&quot;#index-idx-file-format&quot;&gt;формате файла индекса (idx)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ead03785f5fb54bd6190bd855d00357524e06d3" translate="yes" xml:space="preserve">
          <source>This will provide Hints in the compiler output either every time the concept is not matched or only on the particular call-site.</source>
          <target state="translated">Это обеспечит подсказки в выводе компилятора либо каждый раз,когда концепция не совпадает,либо только на конкретном call-сайте.</target>
        </trans-unit>
        <trans-unit id="aa4705d432fb1b0185c67d13ccff0749b0afd34e" translate="yes" xml:space="preserve">
          <source>This will raise &lt;code&gt;ValueError&lt;/code&gt; if &lt;code&gt;future&lt;/code&gt; is finished.</source>
          <target state="translated">Это вызовет &lt;code&gt;ValueError&lt;/code&gt; , если &lt;code&gt;future&lt;/code&gt; закончится.</target>
        </trans-unit>
        <trans-unit id="77dd0890df14804d1f6f5c6ad7d8c663331e013e" translate="yes" xml:space="preserve">
          <source>This will recursively generate documentation of all nim modules imported into the input module that belong to the Nimble package that &lt;code&gt;filename.nim&lt;/code&gt; belongs to.</source>
          <target state="translated">Это рекурсивно сгенерирует документацию по всем модулям nim, импортированным во входной модуль, которые принадлежат пакету Nimble, которому принадлежит &lt;code&gt;filename.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01e5c517031f780132f7de304e80ce21fd6382d8" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;.</source>
          <target state="translated">Это работает только для букв &lt;code&gt;A-Z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cd34efcb73d9e9a4a38033e49417a668da60801" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toLower&quot;&gt;unicode.toLower&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="translated">Это работает только для букв &lt;code&gt;A-Z&lt;/code&gt; . См. &lt;a href=&quot;unicode#toLower&quot;&gt;Unicode.toLower&lt;/a&gt; для версии, которая работает с любым символом Unicode.</target>
        </trans-unit>
        <trans-unit id="d28e108b410326da5c7b53479c9b85473d7f8bc9" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toLower,Rune&quot;&gt;unicode.toLower&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b234fd83af98adae4a04fed787579367a1e8b539" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toLower,string&quot;&gt;unicode.toLower&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3189c7fd9700aaadbf4a4dd6af6df7937cf0b2d7" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toUpper&quot;&gt;unicode.toUpper&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="translated">Это работает только для букв &lt;code&gt;A-Z&lt;/code&gt; . См. &lt;a href=&quot;unicode#toUpper&quot;&gt;Unicode.toUpper&lt;/a&gt; для версии, которая работает с любым символом Unicode.</target>
        </trans-unit>
        <trans-unit id="b9616a4c434f44d69fc9dd652fbbd1ccf5a4d774" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toUpper,Rune&quot;&gt;unicode.toUpper&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d002ee894dde8162f608dbcae78b528d1a0a98f9" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toUpper,string&quot;&gt;unicode.toUpper&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8039b7fd0e6adffb69eb9d5e34ba51659c72eed" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. Use &lt;a href=&quot;unicode&quot;&gt;Unicode module&lt;/a&gt; for UTF-8 support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc168569a3d857e9b97041d394676d2e416f6807" translate="yes" xml:space="preserve">
          <source>This would be any of the other idetools available options, like &lt;code&gt;--def&lt;/code&gt; or &lt;code&gt;--suggest&lt;/code&gt; explained in the following sections.</source>
          <target state="translated">Это может быть любой из других доступных параметров &lt;code&gt;--def&lt;/code&gt; , например --def или &lt;code&gt;--suggest&lt;/code&gt; ,которые описаны в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="3974135028a38a44142b8af58d9f501e1acc3c71" translate="yes" xml:space="preserve">
          <source>This zero copy, memchr-limited interface is probably the fastest way to iterate over line-like records in a file. However, returned (data,size) objects are not Nim strings, bounds checked Nim arrays, or even terminated C strings. So, care is required to access the data (e.g., think C mem* functions, not str* functions).</source>
          <target state="translated">Этот интерфейс с нулевой копией и ограничением по memchr является,пожалуй,самым быстрым способом итерации по строковым записям в файле.Тем не менее,возвращаемые (данные,размер)объекты не являются Nim-строками,границами проверенных Nim-массивов или даже завершёнными C-строками.Поэтому для доступа к данным требуется осторожность (например,подумайте о функциях C mem*,а не str*).</target>
        </trans-unit>
        <trans-unit id="3f848317832fae19e0085de9e23738862798395f" translate="yes" xml:space="preserve">
          <source>Though it should be pretty obvious what the program does, I will explain the syntax: statements which are not indented are executed when the program starts. Indentation is Nim's way of grouping statements. Indentation is done with spaces only, tabulators are not allowed.</source>
          <target state="translated">Хотя должно быть вполне очевидно,что делает программа,я объясню синтаксис:выражения,которые не имеют отступов,выполняются,когда программа запускается.Отступ-это способ группировки выражений Нима.Отступ делается только пробелами,табуляторы не допускаются.</target>
        </trans-unit>
        <trans-unit id="6d02e1b27f5da6165217ae6af04fef8718253485" translate="yes" xml:space="preserve">
          <source>Though the Nim Standard Library is still evolving, it is already quite usable. It is divided into &lt;em&gt;pure libraries&lt;/em&gt;, &lt;em&gt;impure libraries&lt;/em&gt; and &lt;em&gt;wrappers&lt;/em&gt;.</source>
          <target state="translated">Хотя стандартная библиотека Nim все еще развивается, ее уже можно использовать. Он разделен на &lt;em&gt;чистые библиотеки&lt;/em&gt; , &lt;em&gt;нечистые библиотеки&lt;/em&gt; и &lt;em&gt;оболочки&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cc7e4d5579d2abc9a379f6ffd100e925cda3b1" translate="yes" xml:space="preserve">
          <source>Thread coordination</source>
          <target state="translated">Координация резьбы</target>
        </trans-unit>
        <trans-unit id="59a7e2e5a99004361b87c2d5390e14c75d8f283e" translate="yes" xml:space="preserve">
          <source>Thread pragma</source>
          <target state="translated">Нитевидная прагма</target>
        </trans-unit>
        <trans-unit id="1e7adbec474ff10a2fb8698f0489cdf3b418554b" translate="yes" xml:space="preserve">
          <source>Thread support for Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1d54b91c07f35c7604f3ddd4b6f833468ea9ba" translate="yes" xml:space="preserve">
          <source>Thread support for Nim. &lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support you need to compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="translated">Поддержка потоков для Nim. &lt;strong&gt;Примечание&lt;/strong&gt; : это часть системного модуля. Не импортируйте его напрямую. Чтобы активировать поддержку потоков, вам необходимо выполнить компиляцию с параметром &lt;code&gt;--threads:on&lt;/code&gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="5541d0b76d127f6a3c54bbc247ffcc1b6c2bbc25" translate="yes" xml:space="preserve">
          <source>Threading</source>
          <target state="translated">Threading</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="efcacaedc288d5f1ee9e06293407eb061bd561ea" translate="yes" xml:space="preserve">
          <source>Threads and exceptions</source>
          <target state="translated">Нитки и исключения</target>
        </trans-unit>
        <trans-unit id="9e9af3f7a423d176c8e989c93a406d4e77eaeeca" translate="yes" xml:space="preserve">
          <source>Threadvar pragma</source>
          <target state="translated">Threadvar прагма</target>
        </trans-unit>
        <trans-unit id="7c599a1317d70c1913cfd27374ce0f1835f7e408" translate="yes" xml:space="preserve">
          <source>Three characters indicating the type of returned answer (e.g. &lt;code&gt;def&lt;/code&gt; for definition, &lt;code&gt;sug&lt;/code&gt; for suggestion, etc).</source>
          <target state="translated">Три символа, обозначающие тип возвращаемого ответа (например, &lt;code&gt;def&lt;/code&gt; для определения, &lt;code&gt;sug&lt;/code&gt; для предложения и т. Д.).</target>
        </trans-unit>
        <trans-unit id="cb0fdc12f844b31a8cf54439d51d7813e5ece7c9" translate="yes" xml:space="preserve">
          <source>Three characters indicating the type of returned answer (e.g. def for definition, &lt;code&gt;sug&lt;/code&gt; for suggestion, etc).</source>
          <target state="translated">Три символа, обозначающие тип возвращаемого ответа (например, def для определения, &lt;code&gt;sug&lt;/code&gt; для предложения и т. Д.).</target>
        </trans-unit>
        <trans-unit id="04a4b67d34c6ea267e9e2aa731f12d8004957357" translate="yes" xml:space="preserve">
          <source>Three letter string which indicates the day of the week.</source>
          <target state="translated">Три буквенных строки,обозначающие день недели.</target>
        </trans-unit>
        <trans-unit id="166b5ad7cdc1ddb77e376400c9f9b2e942b944d7" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;-d:x&lt;/code&gt; or &lt;code&gt;--define:x&lt;/code&gt; switch you can define compile time symbols for conditional compilation. The defined switches can be checked in source code with the &lt;a href=&quot;manual#when-statement&quot;&gt;when statement&lt;/a&gt; and &lt;a href=&quot;system#defined&quot;&gt;defined proc&lt;/a&gt;. The typical use of this switch is to enable builds in release mode (&lt;code&gt;-d:release&lt;/code&gt;) where certain safety checks are omitted for better performance. Another common use is the &lt;code&gt;-d:ssl&lt;/code&gt; switch to activate SSL sockets.</source>
          <target state="translated">С помощью переключателя &lt;code&gt;-d:x&lt;/code&gt; или &lt;code&gt;--define:x&lt;/code&gt; вы можете определить символы времени компиляции для условной компиляции. Определенные переключатели можно проверить в исходном коде с помощью &lt;a href=&quot;manual#when-statement&quot;&gt;оператора when&lt;/a&gt; и &lt;a href=&quot;system#defined&quot;&gt;определенной процедуры&lt;/a&gt; . Обычно этот переключатель используется для включения сборок в режиме выпуска ( &lt;code&gt;-d:release&lt;/code&gt; ), где некоторые проверки безопасности не выполняются для повышения производительности. Другое распространенное использование - переключатель &lt;code&gt;-d:ssl&lt;/code&gt; для активации сокетов SSL.</target>
        </trans-unit>
        <trans-unit id="b77791f49945f5e1a1fc02beea100a1fbe48fd06" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;-d:x&lt;/code&gt; or &lt;code&gt;--define:x&lt;/code&gt; switch you can define compile-time symbols for conditional compilation. The defined switches can be checked in source code with the &lt;a href=&quot;manual#statements-and-expressions-when-statement&quot;&gt;when statement&lt;/a&gt; and &lt;a href=&quot;system#defined,untyped&quot;&gt;defined proc&lt;/a&gt;. The typical use of this switch is to enable builds in release mode (&lt;code&gt;-d:release&lt;/code&gt;) where optimizations are enabled for better performance. Another common use is the &lt;code&gt;-d:ssl&lt;/code&gt; switch to activate SSL sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053686996ea91f5f0bd8bfc5be9311b2dfb9563b" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;nimsuggest&lt;/code&gt; tool, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">С &lt;code&gt;nimsuggest&lt;/code&gt; инструмента nimsuggest любая IDE может запросить исходный файл &lt;code&gt;.nim&lt;/code&gt; и получить полезную информацию, такую ​​как определение символов или предложения для завершения.</target>
        </trans-unit>
        <trans-unit id="645311b7482290ae055f08a018122a58f2c3b9eb" translate="yes" xml:space="preserve">
          <source>Through the use of the optional &lt;code&gt;{.raises.}&lt;/code&gt; pragma you can specify that a proc is meant to raise a specific set of exceptions, or none at all. If the &lt;code&gt;{.raises.}&lt;/code&gt; pragma is used, the compiler will verify that this is true. For instance, if you specify that a proc raises &lt;code&gt;IOError&lt;/code&gt;, and at some point it (or one of the procs it calls) starts raising a new exception the compiler will prevent that proc from compiling. Usage example:</source>
          <target state="translated">С помощью необязательной &lt;code&gt;{.raises.}&lt;/code&gt; Вы можете указать, что процедура предназначена для создания определенного набора исключений или вообще не вызывает их. Если используется &lt;code&gt;{.raises.}&lt;/code&gt; , Компилятор проверит, что это правда. Например, если вы укажете, что процедура вызывает &lt;code&gt;IOError&lt;/code&gt; , и в какой-то момент она (или одна из вызываемых процедур) начинает генерировать новое исключение, компилятор предотвратит компиляцию этой процедуры. Пример использования:</target>
        </trans-unit>
        <trans-unit id="7e4ee67f0e9e151a472bd4d369d44933d3da7821" translate="yes" xml:space="preserve">
          <source>Thrown in the &lt;code&gt;getContent&lt;/code&gt; proc and &lt;code&gt;postContent&lt;/code&gt; proc, when the server returns an error</source>
          <target state="translated">Брошено в процессах &lt;code&gt;getContent&lt;/code&gt; и &lt;code&gt;postContent&lt;/code&gt; , когда сервер возвращает ошибку</target>
        </trans-unit>
        <trans-unit id="03d3eb95788413ec11f05c2375f128ca82e7acba" translate="yes" xml:space="preserve">
          <source>Thus the checks would have been very difficult to implement properly with little benefit, especially since they are simple to implement in the client. The client should use the &lt;code&gt;errorMsgExpected&lt;/code&gt; proc to generate a nice error message that fits the other error messages this library creates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37977e3077bc9851c1ffd00107b486f2f8f09038" translate="yes" xml:space="preserve">
          <source>Thus the checks would have been very difficult to implement properly with little benefit, especially since they are simple to implement in the client. The client should use the &lt;em&gt;errorMsgExpected&lt;/em&gt; proc to generate a nice error message that fits the other error messages this library creates.</source>
          <target state="translated">Таким образом, проверки было бы очень сложно реализовать должным образом с небольшой пользой, тем более что их просто реализовать в клиенте. Клиент должен использовать процедуру &lt;em&gt;errorMsgExpected&lt;/em&gt; для создания приятного сообщения об ошибке, которое соответствует другим сообщениям об ошибках, создаваемым этой библиотекой.</target>
        </trans-unit>
        <trans-unit id="d39bb08fac5f6360feb78a680d458fc658579909" translate="yes" xml:space="preserve">
          <source>Thus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may &lt;span id=&quot;shadow_1&quot;&gt;shadow&lt;/span&gt; the definition in the &lt;code&gt;system&lt;/code&gt; module. From this list the following should not be written in dot notation &lt;code&gt;x.f&lt;/code&gt; since &lt;code&gt;x&lt;/code&gt; cannot be type checked before it gets passed to &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">Таким образом, они действуют больше как ключевые слова, чем как обычные идентификаторы; Однако, в отличие от ключевого слова, переопределение может &lt;span id=&quot;shadow_1&quot;&gt;затенять&lt;/span&gt; определение в &lt;code&gt;system&lt;/code&gt; модуле. Из этого списка не следует записывать следующее в точечной нотации &lt;code&gt;x.f&lt;/code&gt; поскольку тип &lt;code&gt;x&lt;/code&gt; не может быть проверен до того, как он будет передан в &lt;code&gt;f&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9d79fc7d78ae54d780ab0a897b4c2f9e3e7adc79" translate="yes" xml:space="preserve">
          <source>Thus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may &lt;span id=&quot;shadow_1&quot;&gt;shadow&lt;/span&gt; the definition in the &lt;code&gt;system&lt;/code&gt; module. From this list the following should not be written in dot notation &lt;code&gt;x.f&lt;/code&gt; since &lt;code&gt;x&lt;/code&gt; cannot be type-checked before it gets passed to &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee323ffc9625d6bc28b4f8cc717e26ebd77ac1a" translate="yes" xml:space="preserve">
          <source>Thus, north &amp;lt; east &amp;lt; south &amp;lt; west. The comparison operators can be used with enumeration types. Instead of &lt;code&gt;north&lt;/code&gt; etc, the enum value can also be qualified with the enum type that it resides in, &lt;code&gt;Direction.north&lt;/code&gt;.</source>
          <target state="translated">Таким образом, север &amp;lt;восток &amp;lt;юг &amp;lt;запад. Операторы сравнения могут использоваться с типами перечисления. Вместо &lt;code&gt;north&lt;/code&gt; т. Д. Значение перечисления также может быть уточнено типом перечисления, в котором оно находится, &lt;code&gt;Direction.north&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b4b8a59ee4623c1899387bf6de6586afc3a5dc2" translate="yes" xml:space="preserve">
          <source>Time components are subtracted one-by-one, see output:</source>
          <target state="translated">Временные компоненты вычитаются один за другим,см.вывод:</target>
        </trans-unit>
        <trans-unit id="3fb812b32f09c8031753f69acac0c61789f34460" translate="yes" xml:space="preserve">
          <source>Time effect.</source>
          <target state="translated">Эффект времени.</target>
        </trans-unit>
        <trans-unit id="7a03fc1f8577334bd0ba540d8fe94c1c217d7663" translate="yes" xml:space="preserve">
          <source>Time handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3ccfa05db1ce4bb37a133e936dac6618864488" translate="yes" xml:space="preserve">
          <source>Time measurement</source>
          <target state="translated">Измерение времени</target>
        </trans-unit>
        <trans-unit id="9d68e0ad84b52240f2e76d776405ad96e1165a01" translate="yes" xml:space="preserve">
          <source>Time measurement with garbage collectors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98089835cc8515ca7a14ba6cd9c114f2b93470b4" translate="yes" xml:space="preserve">
          <source>TimeInterval</source>
          <target state="translated">TimeInterval</target>
        </trans-unit>
        <trans-unit id="f4fb52fb2152cd12040e0a822c3f35572a335a53" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;d&lt;/code&gt; days.</source>
          <target state="translated">TimeInterval &lt;code&gt;d&lt;/code&gt; дней.</target>
        </trans-unit>
        <trans-unit id="45493a2f2864af1ad59f4e6002d36f0afb4f0012" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;h&lt;/code&gt; hours.</source>
          <target state="translated">TimeInterval &lt;code&gt;h&lt;/code&gt; часов.</target>
        </trans-unit>
        <trans-unit id="48a2bec4e7d8f08615b4a69538e1d873fd8cabd4" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;m&lt;/code&gt; minutes.</source>
          <target state="translated">TimeInterval &lt;code&gt;m&lt;/code&gt; минут.</target>
        </trans-unit>
        <trans-unit id="fd8b1b84cf164e73ebf16147dec8fe94eb87b149" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;m&lt;/code&gt; months.</source>
          <target state="translated">TimeInterval &lt;code&gt;m&lt;/code&gt; месяцев.</target>
        </trans-unit>
        <trans-unit id="2e35c45093c4c75c76cc0ad1730384cf89bc1aab" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;micros&lt;/code&gt; microseconds.</source>
          <target state="translated">TimeInterval из &lt;code&gt;micros&lt;/code&gt; микросекунд.</target>
        </trans-unit>
        <trans-unit id="571851bb6763be044dfb20a43ad6453fa502f0ca" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;ms&lt;/code&gt; milliseconds.</source>
          <target state="translated">TimeInterval &lt;code&gt;ms&lt;/code&gt; миллисекунд.</target>
        </trans-unit>
        <trans-unit id="a0a7b6a6e6dabdcbf91694569154f0821829247a" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;nanos&lt;/code&gt; nanoseconds.</source>
          <target state="translated">TimeInterval из &lt;code&gt;nanos&lt;/code&gt; наносекунд.</target>
        </trans-unit>
        <trans-unit id="843631ff0523a6f86df81cbca0448371ae88177c" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;s&lt;/code&gt; seconds.</source>
          <target state="translated">TimeInterval &lt;code&gt;s&lt;/code&gt; секунд.</target>
        </trans-unit>
        <trans-unit id="bdc17d9ec9d80bdf5f4294a7ade05be0d237182e" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;w&lt;/code&gt; weeks.</source>
          <target state="translated">TimeInterval &lt;code&gt;w&lt;/code&gt; недель.</target>
        </trans-unit>
        <trans-unit id="77b05f6f1a5def9a860eb63a1be452d2e901c363" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;y&lt;/code&gt; years.</source>
          <target state="translated">TimeInterval &lt;code&gt;y&lt;/code&gt; лет.</target>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="f7ce4ce477d909626616b9bc1923c16e96624252" translate="yes" xml:space="preserve">
          <source>Timer support for the realtime GC. Based on &lt;a href=&quot;https://github.com/jckarter/clay/blob/master/compiler/hirestimer.cpp&quot;&gt;https://github.com/jckarter/clay/blob/master/compiler/hirestimer.cpp&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbd71a2dd6f5fad9c94891375be2effb56321a4" translate="yes" xml:space="preserve">
          <source>Timezone interface for supporting &lt;a href=&quot;#DateTime&quot;&gt;DateTime&lt;/a&gt;s of arbitrary timezones. The &lt;code&gt;times&lt;/code&gt; module only supplies implementations for the systems local time and UTC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49563f216566fe13f36b6d6f96d904d2f0012073" translate="yes" xml:space="preserve">
          <source>Timezone interface for supporting &lt;code&gt;DateTime&lt;/code&gt;'s of arbritary timezones. The &lt;code&gt;times&lt;/code&gt; module only supplies implementations for the systems local time and UTC.</source>
          <target state="translated">Интерфейс часового пояса для поддержки &lt;code&gt;DateTime&lt;/code&gt; произвольных часовых поясов. Модуль &lt;code&gt;times&lt;/code&gt; только реализации для системного местного времени и UTC.</target>
        </trans-unit>
        <trans-unit id="005f759cb3d18c4ae00a285a0712a53038aa8ad6" translate="yes" xml:space="preserve">
          <source>To &lt;em&gt;invoke&lt;/em&gt; a template, call it like a procedure.</source>
          <target state="translated">Чтобы &lt;em&gt;вызвать&lt;/em&gt; шаблон, вызовите его как процедуру.</target>
        </trans-unit>
        <trans-unit id="6ce1339a3fbb20d91263c5b8ca905cfc7af9e20c" translate="yes" xml:space="preserve">
          <source>To access multiple values of a key, use the overloaded &lt;code&gt;[]&lt;/code&gt; below or to get all of them access the &lt;code&gt;table&lt;/code&gt; field directly.</source>
          <target state="translated">Чтобы получить доступ к нескольким значениям ключа, используйте перегруженный &lt;code&gt;[]&lt;/code&gt; ниже или чтобы все они напрямую &lt;code&gt;table&lt;/code&gt; полю таблицы .</target>
        </trans-unit>
        <trans-unit id="1a8854509b79b921922ff284c021ca2226c66887" translate="yes" xml:space="preserve">
          <source>To allocate a new traced object, the built-in procedure &lt;code&gt;new&lt;/code&gt; has to be used. To deal with untraced memory, the procedures &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt; and &lt;code&gt;realloc&lt;/code&gt; can be used. The documentation of the system module contains further information.</source>
          <target state="translated">Чтобы выделить новый отслеживаемый объект, необходимо использовать встроенную процедуру &lt;code&gt;new&lt;/code&gt; . Для работы с неотслеживаемой памятью можно использовать процедуры &lt;code&gt;alloc&lt;/code&gt; , &lt;code&gt;dealloc&lt;/code&gt; и &lt;code&gt;realloc&lt;/code&gt; . Документация к системному модулю содержит дополнительную информацию.</target>
        </trans-unit>
        <trans-unit id="74b75bdb6d108ccec959da5a9406fd4ee6f129b2" translate="yes" xml:space="preserve">
          <source>To allocate a new traced object, the built-in procedure &lt;code&gt;new&lt;/code&gt; must be used. To deal with untraced memory, the procedures &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt; and &lt;code&gt;realloc&lt;/code&gt; can be used. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module's documentation contains further details.</source>
          <target state="translated">Чтобы выделить новый отслеживаемый объект, необходимо использовать встроенную процедуру &lt;code&gt;new&lt;/code&gt; . Для работы с неотслеживаемой памятью можно использовать процедуры &lt;code&gt;alloc&lt;/code&gt; , &lt;code&gt;dealloc&lt;/code&gt; и &lt;code&gt;realloc&lt;/code&gt; . Документация по &lt;a href=&quot;system&quot;&gt;системному&lt;/a&gt; модулю содержит дополнительную информацию.</target>
        </trans-unit>
        <trans-unit id="e078eeb299e1530ea0a1c7ae42a41d998f5aecf7" translate="yes" xml:space="preserve">
          <source>To be documented.</source>
          <target state="translated">Для документирования.</target>
        </trans-unit>
        <trans-unit id="00e012bc8e89aa9418caf9860b1e2d2f2d1a0432" translate="yes" xml:space="preserve">
          <source>To be the most efficient, make sure &lt;code&gt;s&lt;/code&gt; is preallocated with an additional amount equal to the byte length of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4aa18bea852a508605d53caeef9c5f926d90dc" translate="yes" xml:space="preserve">
          <source>To be the most efficient, make sure &lt;em&gt;s&lt;/em&gt; is preallocated with an additional amount equal to the byte length of &lt;em&gt;c&lt;/em&gt;.</source>
          <target state="translated">Чтобы быть наиболее эффективным, убедитесь, что &lt;em&gt;s&lt;/em&gt; предварительно выделен дополнительным количеством, равным длине байта &lt;em&gt;c&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e8cced600feca55a223908d10e5130220dfada" translate="yes" xml:space="preserve">
          <source>To be used when diffing times. Consider using &lt;em&gt;between&lt;/em&gt; instead.</source>
          <target state="translated">Используется при разнице времени. Вместо этого рассмотрите возможность использования &lt;em&gt;между&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9599c6de97f8d0342f31be2e0d82a6fa8e679162" translate="yes" xml:space="preserve">
          <source>To be written.</source>
          <target state="translated">Чтобы быть написанным.</target>
        </trans-unit>
        <trans-unit id="11e63287bf2192ba9bdf47d785bd859bfea604a0" translate="yes" xml:space="preserve">
          <source>To call a procedure that returns a value just for its side effects and ignoring its return value, a &lt;code&gt;discard&lt;/code&gt; statement &lt;strong&gt;must&lt;/strong&gt; be used. Nim does not allow silently throwing away a return value:</source>
          <target state="translated">Чтобы вызвать процедуру, которая возвращает значение только для своих побочных эффектов и игнорирует его возвращаемое значение, &lt;strong&gt;необходимо&lt;/strong&gt; использовать оператор &lt;code&gt;discard&lt;/code&gt; . Ним не позволяет молча выбросить возвращаемое значение:&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cbd6812cedca0f8d3ecee1c4880b1874c327d444" translate="yes" xml:space="preserve">
          <source>To change the compiler from the default compiler (at the command line):</source>
          <target state="translated">Изменить компилятор с компилятора по умолчанию (в командной строке):</target>
        </trans-unit>
        <trans-unit id="1d675135247ec07f554ba8d3985a64fe7d37897a" translate="yes" xml:space="preserve">
          <source>To choose the memory management strategy use the &lt;code&gt;--gc:&lt;/code&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0088b38a72221b3666a3e4577722f03717e36918" translate="yes" xml:space="preserve">
          <source>To compensate, the standard library has modules &lt;a href=&quot;lib#pure-libraries-modules-for-js-backend&quot;&gt;catered to the JS backend&lt;/a&gt; and more support will come in the future (for instance, Node.js bindings to get OS info).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19383e7fc36ba5267d99a080abfc1737c7f18bc" translate="yes" xml:space="preserve">
          <source>To compile a &lt;span id=&quot;dangerous-release-build_1&quot;&gt;dangerous release build&lt;/span&gt; define the &lt;code&gt;danger&lt;/code&gt; symbol:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e14482cffd7a387356de093fd85fe0f7385173" translate="yes" xml:space="preserve">
          <source>To compile a Nim module into a &lt;code&gt;.js&lt;/code&gt; file use the &lt;code&gt;js&lt;/code&gt; command; the default is a &lt;code&gt;.js&lt;/code&gt; file that is supposed to be referenced in an &lt;code&gt;.html&lt;/code&gt; file. However, you can also run the code with &lt;span id=&quot;nodejs_1&quot;&gt;nodejs&lt;/span&gt; (&lt;a href=&quot;http://nodejs.org&quot;&gt;http://nodejs.org&lt;/a&gt;):</source>
          <target state="translated">Чтобы скомпилировать модуль Nim в файл &lt;code&gt;.js&lt;/code&gt; , используйте команду &lt;code&gt;js&lt;/code&gt; ; по умолчанию используется файл &lt;code&gt;.js&lt;/code&gt; ,на который предполагается ссылаться в файле &lt;code&gt;.html&lt;/code&gt; . Однако вы также можете запустить код с помощью &lt;span id=&quot;nodejs_1&quot;&gt;nodejs&lt;/span&gt; ( &lt;a href=&quot;http://nodejs.org&quot;&gt;http://nodejs.org&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="7758368cb3a773f3da9fe616920e0dd3ddaf93c9" translate="yes" xml:space="preserve">
          <source>To compile a Nim module into a &lt;code&gt;.js&lt;/code&gt; file use the &lt;code&gt;js&lt;/code&gt; command; the default is a &lt;code&gt;.js&lt;/code&gt; file that is supposed to be referenced in an &lt;code&gt;.html&lt;/code&gt; file. However, you can also run the code with &lt;span id=&quot;nodejs_1&quot;&gt;nodejs&lt;/span&gt; (&lt;a href=&quot;https://nodejs.org&quot;&gt;http://nodejs.org&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b72107dca9af29a5cf8e0cbfd67507a7bbcd4c" translate="yes" xml:space="preserve">
          <source>To compile a release version use:</source>
          <target state="translated">Чтобы скомпилировать релизную версию использовать:</target>
        </trans-unit>
        <trans-unit id="9f801814ad063fdd28a5552ef1cb208d05b01510" translate="yes" xml:space="preserve">
          <source>To compute power between integers (e.g. 2^6), use &lt;a href=&quot;#%5E,T,Natural&quot;&gt;^ proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dace50e38237573560e76fd9fe662d2da1a4dc" translate="yes" xml:space="preserve">
          <source>To compute power between integers, use &lt;em&gt;^&lt;/em&gt; e.g. 2 ^ 6</source>
          <target state="translated">Чтобы вычислить степень между целыми числами, используйте &lt;em&gt;^&lt;/em&gt; например 2 ^ 6</target>
        </trans-unit>
        <trans-unit id="4e1e5cf85172e7687329245173ff57b79c54d5ed" translate="yes" xml:space="preserve">
          <source>To create a new &lt;code&gt;Duration&lt;/code&gt;, use &lt;a href=&quot;#initDuration,int64,int64,int64,int64,int64,int64,int64,int64&quot;&gt;initDuration proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfec38068b998d71adfbd1d224349d1732adf770" translate="yes" xml:space="preserve">
          <source>To create a new &lt;code&gt;TimeFormat&lt;/code&gt; use &lt;a href=&quot;#initTimeFormat,string&quot;&gt;initTimeFormat proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d351e4cf238073c675c29349e5026ed8e407aa" translate="yes" xml:space="preserve">
          <source>To create a new compiler for each run, use &lt;code&gt;koch temp&lt;/code&gt;:</source>
          <target state="translated">Чтобы создать новый компилятор для каждого запуска, используйте &lt;code&gt;koch temp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55053d7dbb6eec73712afca1d06925e6eb2fac3c" translate="yes" xml:space="preserve">
          <source>To cross compile, use for example:</source>
          <target state="translated">Для перекрестной компиляции используйте,например:</target>
        </trans-unit>
        <trans-unit id="11a7709cee7ccc11aa34460a13e3a236b452d950" translate="yes" xml:space="preserve">
          <source>To cross-compile for Windows from Linux or macOS using the MinGW-w64 toolchain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f91945ed5921e2c3fd56557cac05da24a1e0e3" translate="yes" xml:space="preserve">
          <source>To cross-compile for iOS you need to be on a macOS computer and use XCode. Normal languages for iOS development are Swift and Objective C. Both of these use LLVM and can be compiled into object files linked together with C, C++ or Objective C code produced by Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e0b2d9936526053d98cae64c97e80a452c5953" translate="yes" xml:space="preserve">
          <source>To decode a base64 encoded data string simply call the &lt;code&gt;decode&lt;/code&gt; procedure:</source>
          <target state="translated">Чтобы декодировать строку данных в кодировке base64, просто вызовите процедуру &lt;code&gt;decode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff5be3702ce16d9f83c4069146c2c5cbe57cdba3" translate="yes" xml:space="preserve">
          <source>To define a new operator enclose the operator in backticks &quot;``&quot;:</source>
          <target state="translated">Определить оператор new,вложить оператор в бэк-клейки &quot;``&quot;:</target>
        </trans-unit>
        <trans-unit id="bb15e30b9d578a4da7a5878df01aeed724c88088" translate="yes" xml:space="preserve">
          <source>To define new commands like &lt;a href=&quot;system#echo&quot;&gt;echo&lt;/a&gt; and &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; in the examples, the concept of a &lt;em&gt;procedure&lt;/em&gt; is needed. (Some languages call them &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;functions&lt;/em&gt;.) In Nim new procedures are defined with the &lt;code&gt;proc&lt;/code&gt; keyword:</source>
          <target state="translated">Для определения новых команд, таких как &lt;a href=&quot;system#echo&quot;&gt;echo&lt;/a&gt; и &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; в примерах, необходима концепция &lt;em&gt;процедуры&lt;/em&gt; . (Некоторые языки называют их &lt;em&gt;методами&lt;/em&gt; или &lt;em&gt;функциями&lt;/em&gt; .) В Nim новые процедуры определяются с помощью ключевого слова &lt;code&gt;proc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ffd042c88fd638ec0eb1bc11b67961325aa17c18" translate="yes" xml:space="preserve">
          <source>To differentiate between a documentation and API file a convention is used: indices which contain one entry without the HTML hash character (#) will be considered &lt;code&gt;documentation&lt;/code&gt;, since this hash-less entry is the explicit title of the document. Indices without this explicit entry will be considered &lt;code&gt;generated API&lt;/code&gt; extracted out of a source &lt;code&gt;.nim&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb3cbb5f800fd3864fa68084a11d47c5e74ac25" translate="yes" xml:space="preserve">
          <source>To differentiate between a documentation and API file a convention is used: indices which contain one entry without the HTML hash character (#) will be considered &lt;em&gt;documentation&lt;/em&gt;, since this hash-less entry is the explicit title of the document. Indices without this explicit entry will be considered &lt;em&gt;generated API&lt;/em&gt; extracted out of a source &lt;code&gt;.nim&lt;/code&gt; file.</source>
          <target state="translated">Чтобы различать документацию и файл API, используется соглашение: индексы, содержащие одну запись без символа решетки HTML (#), будут считаться &lt;em&gt;документацией&lt;/em&gt; , поскольку эта запись без хеша является явным заголовком документа. Индексы без этой явной записи будут считаться &lt;em&gt;сгенерированными API,&lt;/em&gt; извлеченными из исходного файла &lt;code&gt;.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42c41b02b95231a84de881a8a918eb15cfd5edbe" translate="yes" xml:space="preserve">
          <source>To differentiate both types (documents and APIs), the index generator will add to the index of documents an entry with the title of the document. Since the title is the topmost element, it will be added with a second field containing just the filename without any HTML anchor. By convention this entry without anchor is the &lt;em&gt;title entry&lt;/em&gt;, and since entries in the index file are added as they are scanned, the title entry will be the first line. The title for APIs is not present because it can be generated concatenating the name of the file to the word &lt;strong&gt;Module&lt;/strong&gt;.</source>
          <target state="translated">Чтобы различать оба типа (документы и API), генератор индекса добавит в индекс документов запись с заголовком документа. Поскольку заголовок является самым верхним элементом, к нему будет добавлено второе поле, содержащее только имя файла без привязки HTML. По соглашению эта запись без привязки является &lt;em&gt;записью заголовка&lt;/em&gt; , и, поскольку записи в индексном файле добавляются по мере сканирования, запись заголовка будет первой строкой. Заголовок для API отсутствует, потому что он может быть сгенерирован путем объединения имени файла со словом &lt;strong&gt;Module&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bef5a818796377280bc3642d6382ec51f107837f" translate="yes" xml:space="preserve">
          <source>To enable it for a section of code, one can use &lt;code&gt;{.push sinkInference: on.}&lt;/code&gt;...`{.pop.}`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43995c5af49127cb76e1c6ca0a761449448d15fe" translate="yes" xml:space="preserve">
          <source>To enable real-time support, the symbol &lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt; needs to be defined via &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; (you can put this into your config file as well). With this switch the garbage collector supports the following operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee4e0702447b58e78b6bb613d5d237b6836e9f3" translate="yes" xml:space="preserve">
          <source>To enable realtime support, the symbol &lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt; needs to be defined via &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; (you can put this into your config file as well). With this switch the GC supports the following operations:</source>
          <target state="translated">Чтобы включить поддержку в реальном времени, символ &lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt; должен быть определен с помощью &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; (вы также можете поместить его в свой файл конфигурации). С этим переключателем ГХ поддерживает следующие операции:</target>
        </trans-unit>
        <trans-unit id="7636be4ab67a90f1533c1be5ea8689d1d192cf03" translate="yes" xml:space="preserve">
          <source>To enable thread support the &lt;code&gt;--threads:on&lt;/code&gt; command line switch needs to be used. The &lt;code&gt;system&lt;/code&gt; module then contains several threading primitives. See the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;channels&quot;&gt;channels&lt;/a&gt; modules for the low level thread API. There are also high level parallelism constructs available. See &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for further details.</source>
          <target state="translated">Чтобы включить поддержку потоков, необходимо использовать параметр &lt;code&gt;--threads:on&lt;/code&gt; командной строке. Затем &lt;code&gt;system&lt;/code&gt; модуль содержит несколько примитивов потоковой передачи. См. Модули &lt;a href=&quot;threads&quot;&gt;потоков&lt;/a&gt; и &lt;a href=&quot;channels&quot;&gt;каналов&lt;/a&gt; для API потоков низкого уровня. Также доступны конструкции параллелизма высокого уровня. Смотрите &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="8db9266812e26b3af9d81dc1d4af73baeb7b7a0b" translate="yes" xml:space="preserve">
          <source>To enable thread support the &lt;code&gt;--threads:on&lt;/code&gt; command-line switch needs to be used. The &lt;code&gt;system&lt;/code&gt; module then contains several threading primitives. See the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;channels&quot;&gt;channels&lt;/a&gt; modules for the low-level thread API. There are also high-level parallelism constructs available. See &lt;a href=&quot;manual_experimental#parallel-amp-spawn&quot;&gt;spawn&lt;/a&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f67214a98c7af6393e104288de7c2a4eb6ee46" translate="yes" xml:space="preserve">
          <source>To execute a program without having a shell involved, use &lt;a href=&quot;osproc#execProcess,string,string,openArray%5Bstring%5D,StringTableRef,set%5BProcessOption%5D&quot;&gt;osproc.execProcess proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0f5e0bd57a707dc272d6bdaa13536fe61b6dd8" translate="yes" xml:space="preserve">
          <source>To find the name of a nimble package the compiler searches for a &lt;code&gt;*.nimble&lt;/code&gt; file in the parent directory hierarchy of whatever module you are compiling. Even if you are in a subdirectory of your project, a parent &lt;code&gt;*.nimble&lt;/code&gt; file will influence the naming of the nimcache name. This means that on Unix systems creating the file &lt;code&gt;~/foo.nimble&lt;/code&gt; will automatically prefix all nimcache files not part of another package with the string &lt;code&gt;foo_&lt;/code&gt;.</source>
          <target state="translated">Чтобы найти имя гибкого пакета, компилятор ищет файл &lt;code&gt;*.nimble&lt;/code&gt; в иерархии родительских каталогов любого модуля, который вы компилируете. Даже если вы находитесь в подкаталоге вашего проекта, родительский файл &lt;code&gt;*.nimble&lt;/code&gt; будет влиять на присвоение имени nimcache. Это означает, что в системах Unix создание файла &lt;code&gt;~/foo.nimble&lt;/code&gt; будет автоматически префикс всех файлов nimcache, не являющихся частью другого пакета, строкой &lt;code&gt;foo_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ab93f39bb400a5b2494d8a733289a48baa43e8f" translate="yes" xml:space="preserve">
          <source>To force a full collection call &lt;code&gt;GC_fullCollect&lt;/code&gt;. Note that it is generally better to let the GC do its work and not enforce a full collection.</source>
          <target state="translated">Чтобы вызвать полную коллекцию, вызовите &lt;code&gt;GC_fullCollect&lt;/code&gt; . Обратите внимание, что обычно лучше позволить сборщику мусора выполнять свою работу, а не обеспечивать полную коллекцию.</target>
        </trans-unit>
        <trans-unit id="83582671ff318357a306f2d73afcc6c6193db0e5" translate="yes" xml:space="preserve">
          <source>To generate an AST we would need to intimately know the structures used by the Nim compiler exposed in the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt;, which at first look seems a daunting task. But we can use as helper shortcut the &lt;a href=&quot;macros#dumpTree&quot;&gt;dumpTree macro&lt;/a&gt;, which is used as a statement macro instead of an expression macro. Since we know that we want to generate a bunch of &lt;code&gt;const&lt;/code&gt; symbols we can create the following source file and compile it to see what the compiler &lt;em&gt;expects&lt;/em&gt; from us:</source>
          <target state="translated">Чтобы сгенерировать AST, нам нужно хорошо знать структуры, используемые компилятором Nim, представленным в &lt;a href=&quot;macros&quot;&gt;модуле макросов&lt;/a&gt; , что на первый взгляд кажется сложной задачей. Но мы можем использовать в качестве вспомогательного ярлыка &lt;a href=&quot;macros#dumpTree&quot;&gt;макрос dumpTree&lt;/a&gt; , который используется как макрос оператора вместо макроса выражения. Поскольку мы знаем, что хотим сгенерировать набор &lt;code&gt;const&lt;/code&gt; символов, мы можем создать следующий исходный файл и скомпилировать его, чтобы увидеть, что компилятор &lt;em&gt;ожидает&lt;/em&gt; от нас:</target>
        </trans-unit>
        <trans-unit id="48e80bf64e7a28669c506f4ab558d9ed800f9037" translate="yes" xml:space="preserve">
          <source>To get rid of hygiene in templates, one can use the &lt;span id=&quot;dirty_1&quot;&gt;dirty&lt;/span&gt; pragma for a template. &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; have no effect in &lt;code&gt;dirty&lt;/code&gt; templates.</source>
          <target state="translated">Чтобы избавиться от гигиены в шаблонах, можно использовать прагму &lt;span id=&quot;dirty_1&quot;&gt;dirty&lt;/span&gt; для шаблона. &lt;code&gt;inject&lt;/code&gt; и &lt;code&gt;gensym&lt;/code&gt; не действуют в &lt;code&gt;dirty&lt;/code&gt; шаблонах.</target>
        </trans-unit>
        <trans-unit id="58450466735ada0fbb487e804b99bbb91cc0bc78" translate="yes" xml:space="preserve">
          <source>To get started, first create a logger:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880901e6af0187dc97108dbae586cf60f49f512f" translate="yes" xml:space="preserve">
          <source>To get started, here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185ba609c2d82dc814e3d0e957a35bb0c0f0e77b" translate="yes" xml:space="preserve">
          <source>To get the directory containing the current source, use it with &lt;a href=&quot;os#parentDir%2Cstring&quot;&gt;os.parentDir()&lt;/a&gt; as &lt;code&gt;currentSourcePath.parentDir()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825f3a2ffb603c43346bb1ea2785b67acec3d702" translate="yes" xml:space="preserve">
          <source>To give a footstart to writing macros we will show now how to turn your typical dynamic code into something that compiles statically. For the exercise we will use the following snippet of code as the starting point:</source>
          <target state="translated">Чтобы дать старт написанию макросов,мы покажем,как превратить ваш типичный динамический код во что-то,что компилируется статически.В качестве отправной точки для упражнения мы будем использовать следующий фрагмент кода:</target>
        </trans-unit>
        <trans-unit id="d4d17c22610a24b1162bf0c1482d2f125036d28e" translate="yes" xml:space="preserve">
          <source>To give an example, when &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;Table&lt;/code&gt;, then &lt;code&gt;var b = a&lt;/code&gt; gives &lt;code&gt;b&lt;/code&gt; as a new independent table. &lt;code&gt;b&lt;/code&gt; is initialised with the contents of &lt;code&gt;a&lt;/code&gt;. Changing &lt;code&gt;b&lt;/code&gt; does not affect &lt;code&gt;a&lt;/code&gt; and vice versa:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961c6551432a67ce81ead4213eeed93dc039ac98" translate="yes" xml:space="preserve">
          <source>To implement bit fields with enums see &lt;a href=&quot;#set-type-bit-fields&quot;&gt;Bit fields&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045da0daa554f9ba7ddd34e0914b0a8dec5e90c2" translate="yes" xml:space="preserve">
          <source>To initialize an empty deque use &lt;a href=&quot;#initDeque,int&quot;&gt;initDeque proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d0e681756bb835e0d6abe73186f21ddc912c3a" translate="yes" xml:space="preserve">
          <source>To initialize it, use the &lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdd15dad6acf9a5da0ded8e85b664281b70e46a" translate="yes" xml:space="preserve">
          <source>To learn about scripting in Nim see &lt;a href=&quot;nims&quot;&gt;NimScript&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43c2e67d28904d49b05aaa4ea39706b64637dec" translate="yes" xml:space="preserve">
          <source>To learn how to compile Nim programs and generate documentation see &lt;a href=&quot;nimc&quot;&gt;Compiler User Guide&lt;/a&gt; and &lt;a href=&quot;https://nim-lang.org/docs/docgen.html&quot;&gt;DocGen Tools Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a57ad28acbc5e4b10960f2e801cd4aa99747b3" translate="yes" xml:space="preserve">
          <source>To link against &lt;code&gt;nimrtl.dll&lt;/code&gt; use the command:</source>
          <target state="translated">Для линковки с &lt;code&gt;nimrtl.dll&lt;/code&gt; используйте команду:</target>
        </trans-unit>
        <trans-unit id="2039b927dcf641bab171f78845015d45672f1c9e" translate="yes" xml:space="preserve">
          <source>To make the &lt;code&gt;createWindow&lt;/code&gt; proc easier to use it should provide &lt;em&gt;default values&lt;/em&gt;; these are values that are used as arguments if the caller does not specify them:</source>
          <target state="translated">Чтобы упростить использование процедуры &lt;code&gt;createWindow&lt;/code&gt; , она должна предоставлять &lt;em&gt;значения по умолчанию&lt;/em&gt; ; это значения, которые используются в качестве аргументов, если вызывающий не указывает их:</target>
        </trans-unit>
        <trans-unit id="f8a5b8288b3fecf0f566c82b883159042530cd8e" translate="yes" xml:space="preserve">
          <source>To make the compiler output code for a 16bit target use the &lt;code&gt;--cpu:avr&lt;/code&gt; target.</source>
          <target state="translated">Чтобы сделать код вывода компилятора для 16-битной цели, используйте цель &lt;code&gt;--cpu:avr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70e565fb479983d4033bbd0b16c4058d64c2d84c" translate="yes" xml:space="preserve">
          <source>To move a variable into a collection usually &lt;code&gt;sink&lt;/code&gt; parameters are involved. A location that is passed to a &lt;code&gt;sink&lt;/code&gt; parameter should not be used afterward. This is ensured by a static analysis over a control flow graph. If it cannot be proven to be the last usage of the location, a copy is done instead and this copy is then passed to the sink parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42baf71f77a71d00884ecfeb14a9f68b623bec2c" translate="yes" xml:space="preserve">
          <source>To override the compiler's gcsafety analysis a &lt;code&gt;{.cast(gcsafe).}&lt;/code&gt; pragma block can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50bfd9dce33230fbb2c8127c3c5a8cde5dbf040a" translate="yes" xml:space="preserve">
          <source>To override the compiler's gcsafety analysis a &lt;code&gt;{.gcsafe.}&lt;/code&gt; pragma block can be used:</source>
          <target state="translated">Чтобы переопределить анализ gcsafety компилятором, можно использовать блок &lt;code&gt;{.gcsafe.}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aec136682e26157ec999d8bfed82c55af3e94bc3" translate="yes" xml:space="preserve">
          <source>To override the compiler's side effect analysis a &lt;code&gt;{.noSideEffect.}&lt;/code&gt;&lt;code&gt;cast&lt;/code&gt; pragma block can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd77706967ab0eca2f0aba7e8dc6a7369cc5358" translate="yes" xml:space="preserve">
          <source>To pass a block of statements to a template, use 'untyped' for the last parameter:</source>
          <target state="translated">Для передачи блока операторов в шаблон используйте 'unyped' для последнего параметра:</target>
        </trans-unit>
        <trans-unit id="ae1d6bbadfa15e666e4a5bc97ac5b074bba176ef" translate="yes" xml:space="preserve">
          <source>To prevent confusing code there is a parsing limitation; if the &lt;code&gt;try&lt;/code&gt; follows a &lt;code&gt;(&lt;/code&gt; it has to be written as a one liner:</source>
          <target state="translated">Чтобы избежать путаницы в коде, существует ограничение на синтаксический анализ; если &lt;code&gt;try&lt;/code&gt; следует за &lt;code&gt;(&lt;/code&gt; она должна быть записана как однострочный:</target>
        </trans-unit>
        <trans-unit id="cee8374e17ee5570d2e73eb9424e263793331053" translate="yes" xml:space="preserve">
          <source>To produce a single &lt;code&gt;&quot;&lt;/code&gt; within a raw string literal, it has to be doubled:</source>
          <target state="translated">Чтобы создать единичный символ &lt;code&gt;&quot;&lt;/code&gt; внутри необработанного строкового литерала&quot;, его нужно удвоить:</target>
        </trans-unit>
        <trans-unit id="a67c70af6b5e6b03d2581b5a5c05f83968ba3a74" translate="yes" xml:space="preserve">
          <source>To produce a single substitution character it has to be doubled: &lt;code&gt;$$&lt;/code&gt; produces &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">Чтобы получить один символ замены, его нужно удвоить: &lt;code&gt;$$&lt;/code&gt; производит &lt;code&gt;$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6149c77815fef9fc27e4a6217efcefadefe95220" translate="yes" xml:space="preserve">
          <source>To remove this event you should use the &lt;code&gt;delHandleWrite&lt;/code&gt; function. It is advised to use that function instead of just setting the event to &lt;code&gt;proc (s: AsyncSocket) = nil&lt;/code&gt; as that would mean that that function would be called constantly.</source>
          <target state="translated">Чтобы удалить это событие, вы должны использовать функцию &lt;code&gt;delHandleWrite&lt;/code&gt; . Рекомендуется использовать эту функцию вместо того, чтобы просто устанавливать для события &lt;code&gt;proc (s: AsyncSocket) = nil&lt;/code&gt; поскольку это будет означать, что эта функция будет вызываться постоянно.</target>
        </trans-unit>
        <trans-unit id="f4dc2bd124108bb715e2125357f3ca8cff675a9b" translate="yes" xml:space="preserve">
          <source>To retrieve the value of &lt;code&gt;&quot;key&quot;&lt;/code&gt; you can do the following:</source>
          <target state="translated">Чтобы получить значение &lt;code&gt;&quot;key&quot;&lt;/code&gt; вы можете сделать следующее:</target>
        </trans-unit>
        <trans-unit id="9c2272069ae83ac24e5887939db19d33d7075a38" translate="yes" xml:space="preserve">
          <source>To see a list of Nimble's packages, check out &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; or the &lt;a href=&quot;https://github.com/nim-lang/packages&quot;&gt;packages repos&lt;/a&gt; on GitHub.</source>
          <target state="translated">Чтобы увидеть список пакетов Nimble, посетите &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; или &lt;a href=&quot;https://github.com/nim-lang/packages&quot;&gt;репозитории пакетов&lt;/a&gt; на GitHub.</target>
        </trans-unit>
        <trans-unit id="8c36f079cdcdbec7456a7ff4487e0a0d41d8fc11" translate="yes" xml:space="preserve">
          <source>To see how and when we can do that, think about this question: In &lt;code&gt;dest = src&lt;/code&gt; when do we really have to &lt;em&gt;materialize&lt;/em&gt; the full copy? - Only if &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; are mutated afterward. If &lt;code&gt;dest&lt;/code&gt; is a local variable that is simple to analyze. And if &lt;code&gt;src&lt;/code&gt; is a location derived from a formal parameter, we also know it is not mutated! In other words, we do a compile-time copy-on-write analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4bb591463a2bf5bfe74be5c756dd27d755e4b62" translate="yes" xml:space="preserve">
          <source>To specify the AST for the different Nim constructs, the notation &lt;code&gt;nodekind(son1, son2, ...)&lt;/code&gt; or &lt;code&gt;nodekind(value)&lt;/code&gt; or &lt;code&gt;nodekind(field=value)&lt;/code&gt; is used.</source>
          <target state="translated">Чтобы указать AST для различных конструкций Nim, обозначение &lt;code&gt;nodekind(son1, son2, ...)&lt;/code&gt; или &lt;code&gt;nodekind(value)&lt;/code&gt; или &lt;code&gt;nodekind(field=value)&lt;/code&gt; используется.</target>
        </trans-unit>
        <trans-unit id="e0d95ec7d1bdea5264d30098e88834030ad1102b" translate="yes" xml:space="preserve">
          <source>To stream files from disk when performing the request, use &lt;code&gt;addFiles&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23947ec0494a83fa76619311a6fe3ef2b338db4" translate="yes" xml:space="preserve">
          <source>To the end of the tuple/object definition.</source>
          <target state="translated">До конца определения кортежа/объекта.</target>
        </trans-unit>
        <trans-unit id="9f79e9096a797c7afc08420ab23a519537e4fb67" translate="yes" xml:space="preserve">
          <source>To understand some of the different ways of specifying the indices of strings, arrays, sequences, etc., it must be remembered that Nim uses zero-based indices.</source>
          <target state="translated">Чтобы понять некоторые из различных способов указания индексов строк,массивов,последовательностей и т.д.,необходимо помнить,что Nim использует нулевые индексы.</target>
        </trans-unit>
        <trans-unit id="596784d34744359d8630e6bf6d5a5b5ef239775c" translate="yes" xml:space="preserve">
          <source>To unpack raw bytes look at the &lt;a href=&quot;streams&quot;&gt;streams&lt;/a&gt; module.</source>
          <target state="translated">Чтобы распаковать необработанные байты, посмотрите модуль &lt;a href=&quot;streams&quot;&gt;потоков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9dd0e4773e807b447d8759bcce32b13725171fb1" translate="yes" xml:space="preserve">
          <source>To use</source>
          <target state="translated">Для использования</target>
        </trans-unit>
        <trans-unit id="de696deb8ffc9ecc04b7f3951a9928d4cb92e1a3" translate="yes" xml:space="preserve">
          <source>To use Unix sockets with &lt;code&gt;db_postgres&lt;/code&gt;, change the server address to the socket file path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="142355009167cc6a95bc27c6846c8bb91aa3b8b9" translate="yes" xml:space="preserve">
          <source>To use a &lt;code&gt;HeapQueue&lt;/code&gt; with a custom object, the &lt;code&gt;&amp;lt;&lt;/code&gt; operator must be implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fa9c66bf6fe6910167c4b6d93b8e2ef5d6e2c3" translate="yes" xml:space="preserve">
          <source>To use a filter for a source file the &lt;code&gt;#?&lt;/code&gt; notation is used:</source>
          <target state="translated">Чтобы использовать фильтр для исходного файла, &lt;code&gt;#?&lt;/code&gt; используется обозначение:</target>
        </trans-unit>
        <trans-unit id="04e302c6728e7a9bb5aad8c6631a551defc4ffef" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;CC&lt;/code&gt; environment variable, use &lt;code&gt;nim c --cc:env myfile.nim&lt;/code&gt;. To use the &lt;code&gt;CXX&lt;/code&gt; environment variable, use &lt;code&gt;nim cpp --cc:env myfile.nim&lt;/code&gt;. &lt;code&gt;--cc:env&lt;/code&gt; is available since Nim version 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd3786ffe14095836ecde08c5a7353e00f84790" translate="yes" xml:space="preserve">
          <source>To use threadsafe version of this module, it needs to be compiled with both &lt;code&gt;-d:threadsafe&lt;/code&gt; and &lt;code&gt;--threads:on&lt;/code&gt; options.</source>
          <target state="translated">Чтобы использовать поточно-безопасную версию этого модуля, он должен быть скомпилирован с параметрами &lt;code&gt;-d:threadsafe&lt;/code&gt; и &lt;code&gt;--threads:on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31052631155b690d2c6d4d6d38ee09a1e1936e39" translate="yes" xml:space="preserve">
          <source>To verify that idetools is working properly there are files in the &lt;code&gt;tests/caas/&lt;/code&gt; directory which provide unit testing. If you find odd idetools behaviour and are able to reproduce it, you are welcome to report it as a bug and add a test to the suite to avoid future regressions.</source>
          <target state="translated">Чтобы убедиться, что idetools работает правильно, в каталоге &lt;code&gt;tests/caas/&lt;/code&gt; есть файлы, которые обеспечивают модульное тестирование. Если вы обнаружите странное поведение idetools и сможете его воспроизвести, вы можете сообщить об этом как об ошибке и добавить тест в набор, чтобы избежать регрессии в будущем.</target>
        </trans-unit>
        <trans-unit id="93e9f1bbe8f37ac15cd7d8886750a127655bd140" translate="yes" xml:space="preserve">
          <source>To wrap native code, take a look at the &lt;a href=&quot;c2nim&quot;&gt;c2nim tool&lt;/a&gt; which helps with the process of scanning and transforming header files into a Nim interface.</source>
          <target state="translated">Чтобы обернуть собственный код, взгляните на &lt;a href=&quot;c2nim&quot;&gt;инструмент c2nim,&lt;/a&gt; который помогает в процессе сканирования и преобразования файлов заголовков в интерфейс Nim.</target>
        </trans-unit>
        <trans-unit id="b9f9c53a4e3a6ac9348d14114004e52bdf2eb009" translate="yes" xml:space="preserve">
          <source>To wrap native code, take a look at the &lt;a href=&quot;https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst&quot;&gt;c2nim tool&lt;/a&gt; which helps with the process of scanning and transforming header files into a Nim interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b661fcccef784df68a5a22da94f9a1df408bd3" translate="yes" xml:space="preserve">
          <source>To write macros, one needs to know how the Nim concrete syntax is converted to an AST.</source>
          <target state="translated">Для написания макросов необходимо знать,как конкретный синтаксис Nim преобразуется в AST.</target>
        </trans-unit>
        <trans-unit id="2f549b2a892218558d523d98dae57570829a8f93" translate="yes" xml:space="preserve">
          <source>TokType.tkAccent</source>
          <target state="translated">TokType.tkAccent</target>
        </trans-unit>
        <trans-unit id="833b136eeb7b71ba6135f430bf1f1340bb500f57" translate="yes" xml:space="preserve">
          <source>TokType.tkAddr</source>
          <target state="translated">TokType.tkAddr</target>
        </trans-unit>
        <trans-unit id="489a603081fd6b748fae558121aa7f4f61658c4a" translate="yes" xml:space="preserve">
          <source>TokType.tkAnd</source>
          <target state="translated">TokType.tkAnd</target>
        </trans-unit>
        <trans-unit id="94b4a65e0bedbd02e98c807ebade522187aaa19d" translate="yes" xml:space="preserve">
          <source>TokType.tkAs</source>
          <target state="translated">TokType.tkAs</target>
        </trans-unit>
        <trans-unit id="8978a3df45f0f0c1280d12531bc2f625112ac39d" translate="yes" xml:space="preserve">
          <source>TokType.tkAsm</source>
          <target state="translated">TokType.tkAsm</target>
        </trans-unit>
        <trans-unit id="6e6e12af7c053f49bd6c1c695636733d2e8539a3" translate="yes" xml:space="preserve">
          <source>TokType.tkBind</source>
          <target state="translated">TokType.tkBind</target>
        </trans-unit>
        <trans-unit id="a9c054648356a5ec5e40c7f127bf578c4288c552" translate="yes" xml:space="preserve">
          <source>TokType.tkBlock</source>
          <target state="translated">TokType.tkBlock</target>
        </trans-unit>
        <trans-unit id="799e59cf0082e0e4c7375f1a4e4937227bc944da" translate="yes" xml:space="preserve">
          <source>TokType.tkBracketDotLe</source>
          <target state="translated">TokType.tkBracketDotLe</target>
        </trans-unit>
        <trans-unit id="d579d9f7a587e27b121abe68fa54484aa2b465e6" translate="yes" xml:space="preserve">
          <source>TokType.tkBracketDotRi</source>
          <target state="translated">TokType.tkBracketDotRi</target>
        </trans-unit>
        <trans-unit id="aec7469553259228c2e655b2f774e9098c73bc7f" translate="yes" xml:space="preserve">
          <source>TokType.tkBracketLe</source>
          <target state="translated">TokType.tkBracketLe</target>
        </trans-unit>
        <trans-unit id="3f63d6eac226a1be137b7031a8785f893f5a495f" translate="yes" xml:space="preserve">
          <source>TokType.tkBracketLeColon</source>
          <target state="translated">TokType.tkBracketLeColon</target>
        </trans-unit>
        <trans-unit id="f5608001df1c7ece8b568bd999c86c4a07fcfee6" translate="yes" xml:space="preserve">
          <source>TokType.tkBracketRi</source>
          <target state="translated">TokType.tkBracketRi</target>
        </trans-unit>
        <trans-unit id="bd6c5a59b7780d71184d650a75030a393e821833" translate="yes" xml:space="preserve">
          <source>TokType.tkBreak</source>
          <target state="translated">TokType.tkBreak</target>
        </trans-unit>
        <trans-unit id="70336fae723b490f3d259d55b94c13671027bb61" translate="yes" xml:space="preserve">
          <source>TokType.tkCase</source>
          <target state="translated">TokType.tkCase</target>
        </trans-unit>
        <trans-unit id="8dc6f35ba845aa81f4f5f622e37c43f0e79f01ea" translate="yes" xml:space="preserve">
          <source>TokType.tkCast</source>
          <target state="translated">TokType.tkCast</target>
        </trans-unit>
        <trans-unit id="f020bdb6e98b4892b67745a64d132ebdcfece0a9" translate="yes" xml:space="preserve">
          <source>TokType.tkCharLit</source>
          <target state="translated">TokType.tkCharLit</target>
        </trans-unit>
        <trans-unit id="f570a44feb96040aa0cf36964543ce010ead0207" translate="yes" xml:space="preserve">
          <source>TokType.tkColon</source>
          <target state="translated">TokType.tkColon</target>
        </trans-unit>
        <trans-unit id="ac4dbb39702d0085d09e81886b42d3a0dafd5bda" translate="yes" xml:space="preserve">
          <source>TokType.tkColonColon</source>
          <target state="translated">TokType.tkColonColon</target>
        </trans-unit>
        <trans-unit id="3017c21990854b2405655e1c23fd5134ba8297f9" translate="yes" xml:space="preserve">
          <source>TokType.tkComma</source>
          <target state="translated">TokType.tkComma</target>
        </trans-unit>
        <trans-unit id="8ce94490aca0297f31abb207a0b70a7b70791e95" translate="yes" xml:space="preserve">
          <source>TokType.tkComment</source>
          <target state="translated">TokType.tkComment</target>
        </trans-unit>
        <trans-unit id="b16b7d6ecc33bd18d836a0e7e87f0d81d81c258e" translate="yes" xml:space="preserve">
          <source>TokType.tkConcept</source>
          <target state="translated">TokType.tkConcept</target>
        </trans-unit>
        <trans-unit id="7995c63d3c8383418a7b5f2752499cfc560e551d" translate="yes" xml:space="preserve">
          <source>TokType.tkConst</source>
          <target state="translated">TokType.tkConst</target>
        </trans-unit>
        <trans-unit id="b82e96e5b46e99566ea1b135f67b86a58cd09971" translate="yes" xml:space="preserve">
          <source>TokType.tkContinue</source>
          <target state="translated">TokType.tkContinue</target>
        </trans-unit>
        <trans-unit id="5f5f3d3eaa7b5aa9e659eb6b5e38250fb65cf833" translate="yes" xml:space="preserve">
          <source>TokType.tkConverter</source>
          <target state="translated">TokType.tkConverter</target>
        </trans-unit>
        <trans-unit id="9876d6456204358b4d82d8ede84e3bc570caff57" translate="yes" xml:space="preserve">
          <source>TokType.tkCurlyDotLe</source>
          <target state="translated">TokType.tkCurlyDotLe</target>
        </trans-unit>
        <trans-unit id="3140a2f9479c230fecac5cda2b3819643802aa1d" translate="yes" xml:space="preserve">
          <source>TokType.tkCurlyDotRi</source>
          <target state="translated">TokType.tkCurlyDotRi</target>
        </trans-unit>
        <trans-unit id="0b8e92e90ebd362d3f261b33460785178a3438e8" translate="yes" xml:space="preserve">
          <source>TokType.tkCurlyLe</source>
          <target state="translated">TokType.tkCurlyLe</target>
        </trans-unit>
        <trans-unit id="6c872b5900732c711099c764c44fd40f8639a93b" translate="yes" xml:space="preserve">
          <source>TokType.tkCurlyRi</source>
          <target state="translated">TokType.tkCurlyRi</target>
        </trans-unit>
        <trans-unit id="278e1aefae81581962fcb14f20c027c65b217564" translate="yes" xml:space="preserve">
          <source>TokType.tkDefer</source>
          <target state="translated">TokType.tkDefer</target>
        </trans-unit>
        <trans-unit id="a0b37a18ffee5487dd9dd4008308703b3647c0ac" translate="yes" xml:space="preserve">
          <source>TokType.tkDiscard</source>
          <target state="translated">TokType.tkDiscard</target>
        </trans-unit>
        <trans-unit id="629d8184f142fa861965b6c3c4f034dc2cd1bd12" translate="yes" xml:space="preserve">
          <source>TokType.tkDistinct</source>
          <target state="translated">TokType.tkDistinct</target>
        </trans-unit>
        <trans-unit id="3ea505d47e347a086d25f28bf4603ca7947b1ed9" translate="yes" xml:space="preserve">
          <source>TokType.tkDiv</source>
          <target state="translated">TokType.tkDiv</target>
        </trans-unit>
        <trans-unit id="1d340ea17fa45033ea175e4770eabeaecbad72ba" translate="yes" xml:space="preserve">
          <source>TokType.tkDo</source>
          <target state="translated">TokType.tkDo</target>
        </trans-unit>
        <trans-unit id="b90b8328ec3252a655efd56f5224038d5478d18c" translate="yes" xml:space="preserve">
          <source>TokType.tkDot</source>
          <target state="translated">TokType.tkDot</target>
        </trans-unit>
        <trans-unit id="2004458b042724837f22397f308b5f8b307d0ebb" translate="yes" xml:space="preserve">
          <source>TokType.tkDotDot</source>
          <target state="translated">TokType.tkDotDot</target>
        </trans-unit>
        <trans-unit id="7783ac35cb2e808bbad9d0e1f16379e4b0ec15c1" translate="yes" xml:space="preserve">
          <source>TokType.tkElif</source>
          <target state="translated">TokType.tkElif</target>
        </trans-unit>
        <trans-unit id="acb1195127603d466c0e119e8e5aff4bc77c55f5" translate="yes" xml:space="preserve">
          <source>TokType.tkElse</source>
          <target state="translated">TokType.tkElse</target>
        </trans-unit>
        <trans-unit id="3b9c80840fbc903249e7fec67e07f673c46ad5d2" translate="yes" xml:space="preserve">
          <source>TokType.tkEnd</source>
          <target state="translated">TokType.tkEnd</target>
        </trans-unit>
        <trans-unit id="73fef38d6b1d7b254cf5006fd374c48677312c39" translate="yes" xml:space="preserve">
          <source>TokType.tkEnum</source>
          <target state="translated">TokType.tkEnum</target>
        </trans-unit>
        <trans-unit id="e6965ef3ef17e34a49d9fb943a50e15c77bf9e15" translate="yes" xml:space="preserve">
          <source>TokType.tkEof</source>
          <target state="translated">TokType.tkEof</target>
        </trans-unit>
        <trans-unit id="c6b8aa3483ae8cfb176381d143be9012f8c644d5" translate="yes" xml:space="preserve">
          <source>TokType.tkEquals</source>
          <target state="translated">TokType.tkEquals</target>
        </trans-unit>
        <trans-unit id="1bfce305d9f664de95721359feb9f16c2ca69df9" translate="yes" xml:space="preserve">
          <source>TokType.tkExcept</source>
          <target state="translated">TokType.tkExcept</target>
        </trans-unit>
        <trans-unit id="c532476f9950e5f7bc1d47975766004ca0788a35" translate="yes" xml:space="preserve">
          <source>TokType.tkExport</source>
          <target state="translated">TokType.tkExport</target>
        </trans-unit>
        <trans-unit id="9e0c512a9e26612ffad2cc71d6cec952bf187a1b" translate="yes" xml:space="preserve">
          <source>TokType.tkFinally</source>
          <target state="translated">TokType.tkFinally</target>
        </trans-unit>
        <trans-unit id="738c8281635f8f6f3bf4474f2d57cd7fdc75ee1d" translate="yes" xml:space="preserve">
          <source>TokType.tkFloat128Lit</source>
          <target state="translated">TokType.tkFloat128Lit</target>
        </trans-unit>
        <trans-unit id="06388573c31a5cbd43b0f7ffe62af7c5b0358dd9" translate="yes" xml:space="preserve">
          <source>TokType.tkFloat32Lit</source>
          <target state="translated">TokType.tkFloat32Lit</target>
        </trans-unit>
        <trans-unit id="ad31d1c1449a83a8c103f06d0fc23e86c9dd14ab" translate="yes" xml:space="preserve">
          <source>TokType.tkFloat64Lit</source>
          <target state="translated">TokType.tkFloat64Lit</target>
        </trans-unit>
        <trans-unit id="2c660aae5c634bc997bfac8609ec9ee4ae1eb395" translate="yes" xml:space="preserve">
          <source>TokType.tkFloatLit</source>
          <target state="translated">TokType.tkFloatLit</target>
        </trans-unit>
        <trans-unit id="6b9f4ccdf4113bb7905eb1ab596947e522fda2fa" translate="yes" xml:space="preserve">
          <source>TokType.tkFor</source>
          <target state="translated">TokType.tkFor</target>
        </trans-unit>
        <trans-unit id="ece859e80c67a4ac071de48e1023901d560c656a" translate="yes" xml:space="preserve">
          <source>TokType.tkFrom</source>
          <target state="translated">TokType.tkFrom</target>
        </trans-unit>
        <trans-unit id="ce742ed274f4122583fc65cec0c0f6dd54b7a765" translate="yes" xml:space="preserve">
          <source>TokType.tkFunc</source>
          <target state="translated">TokType.tkFunc</target>
        </trans-unit>
        <trans-unit id="ff2f32e5ecca86e0c97c8bbabcb2e4b31d4fe2da" translate="yes" xml:space="preserve">
          <source>TokType.tkGStrLit</source>
          <target state="translated">TokType.tkGStrLit</target>
        </trans-unit>
        <trans-unit id="6c1a0ae6c63b05ac5b31dd72bdbd4f90d91b9561" translate="yes" xml:space="preserve">
          <source>TokType.tkGTripleStrLit</source>
          <target state="translated">TokType.tkGTripleStrLit</target>
        </trans-unit>
        <trans-unit id="271e5dc7a48fe13922aac2398d53b7c54b4744a6" translate="yes" xml:space="preserve">
          <source>TokType.tkIf</source>
          <target state="translated">TokType.tkIf</target>
        </trans-unit>
        <trans-unit id="575e4aeda974ae70cf93a71e377557bd8e72342f" translate="yes" xml:space="preserve">
          <source>TokType.tkImport</source>
          <target state="translated">TokType.tkImport</target>
        </trans-unit>
        <trans-unit id="88763a2b67947d2ed05c26b489efa287d3a369ac" translate="yes" xml:space="preserve">
          <source>TokType.tkIn</source>
          <target state="translated">TokType.tkIn</target>
        </trans-unit>
        <trans-unit id="065b5c379ddc0dd3fd8118403edf454bb6ceb110" translate="yes" xml:space="preserve">
          <source>TokType.tkInclude</source>
          <target state="translated">TokType.tkInclude</target>
        </trans-unit>
        <trans-unit id="c722ffd4f4df7c6836676daa4492d6bb38443d6a" translate="yes" xml:space="preserve">
          <source>TokType.tkInfixOpr</source>
          <target state="translated">TokType.tkInfixOpr</target>
        </trans-unit>
        <trans-unit id="d7e34ebd8f00c7f75979d6c4958cc3a9b388306d" translate="yes" xml:space="preserve">
          <source>TokType.tkInt16Lit</source>
          <target state="translated">TokType.tkInt16Lit</target>
        </trans-unit>
        <trans-unit id="ff7ad1e42476da2e25e2cc6fdc600fc1028c2f55" translate="yes" xml:space="preserve">
          <source>TokType.tkInt32Lit</source>
          <target state="translated">TokType.tkInt32Lit</target>
        </trans-unit>
        <trans-unit id="3da5dd9fe852a4aa31ef4de610e752548fb1fb2a" translate="yes" xml:space="preserve">
          <source>TokType.tkInt64Lit</source>
          <target state="translated">TokType.tkInt64Lit</target>
        </trans-unit>
        <trans-unit id="8d8ad3d9ba8153046c3a61d28a31075f291ec4a3" translate="yes" xml:space="preserve">
          <source>TokType.tkInt8Lit</source>
          <target state="translated">TokType.tkInt8Lit</target>
        </trans-unit>
        <trans-unit id="311b6ea614ffd85b191d1fee73ff2961444b3968" translate="yes" xml:space="preserve">
          <source>TokType.tkIntLit</source>
          <target state="translated">TokType.tkIntLit</target>
        </trans-unit>
        <trans-unit id="5708e6732566f8da68ce71c8f52a71a33dee7bdc" translate="yes" xml:space="preserve">
          <source>TokType.tkInterface</source>
          <target state="translated">TokType.tkInterface</target>
        </trans-unit>
        <trans-unit id="6b88324d5a5c439840eb4efdcf19beb3be9c173e" translate="yes" xml:space="preserve">
          <source>TokType.tkInvalid</source>
          <target state="translated">TokType.tkInvalid</target>
        </trans-unit>
        <trans-unit id="2e789e65b0db1b238a7905afec1bd4686d84de69" translate="yes" xml:space="preserve">
          <source>TokType.tkIs</source>
          <target state="translated">TokType.tkIs</target>
        </trans-unit>
        <trans-unit id="f92fb5f0d067b72bf463d3b45ba05d8f8cef9d90" translate="yes" xml:space="preserve">
          <source>TokType.tkIsnot</source>
          <target state="translated">TokType.tkIsnot</target>
        </trans-unit>
        <trans-unit id="bfdc015ae6704f5464684b15cfdb1598a470a209" translate="yes" xml:space="preserve">
          <source>TokType.tkIterator</source>
          <target state="translated">TokType.tkIterator</target>
        </trans-unit>
        <trans-unit id="1d8f3cde1b5f33caf2cadb92bbe5a3dd1dcd0429" translate="yes" xml:space="preserve">
          <source>TokType.tkLet</source>
          <target state="translated">TokType.tkLet</target>
        </trans-unit>
        <trans-unit id="0fc10e428188bbff220afee5438329764b4b6fad" translate="yes" xml:space="preserve">
          <source>TokType.tkMacro</source>
          <target state="translated">TokType.tkMacro</target>
        </trans-unit>
        <trans-unit id="e007679f5686fe51a42063b11bd4c57ff8f792a4" translate="yes" xml:space="preserve">
          <source>TokType.tkMethod</source>
          <target state="translated">TokType.tkMethod</target>
        </trans-unit>
        <trans-unit id="75b2a89b430c78e8ae4147898b037ccf2befee64" translate="yes" xml:space="preserve">
          <source>TokType.tkMixin</source>
          <target state="translated">TokType.tkMixin</target>
        </trans-unit>
        <trans-unit id="0a7722f0e23e54a8fa1e0ba72602ec02c7e47051" translate="yes" xml:space="preserve">
          <source>TokType.tkMod</source>
          <target state="translated">TokType.tkMod</target>
        </trans-unit>
        <trans-unit id="d6fe6afa97e9092dc4570b4f4df3d8ebc2f309cf" translate="yes" xml:space="preserve">
          <source>TokType.tkNil</source>
          <target state="translated">TokType.tkNil</target>
        </trans-unit>
        <trans-unit id="3ff52598e52be03db3a473c0eb62c1f368b5b15d" translate="yes" xml:space="preserve">
          <source>TokType.tkNot</source>
          <target state="translated">TokType.tkNot</target>
        </trans-unit>
        <trans-unit id="caef4ae846b11c8164f2f09a338dd76a7f4fca74" translate="yes" xml:space="preserve">
          <source>TokType.tkNotin</source>
          <target state="translated">TokType.tkNotin</target>
        </trans-unit>
        <trans-unit id="0590b10afb9128c28b3fd5fd41edacd63de74f41" translate="yes" xml:space="preserve">
          <source>TokType.tkObject</source>
          <target state="translated">TokType.tkObject</target>
        </trans-unit>
        <trans-unit id="83ec18aeb378ffa5c9ec8cc024fe7ec2173128bb" translate="yes" xml:space="preserve">
          <source>TokType.tkOf</source>
          <target state="translated">TokType.tkOf</target>
        </trans-unit>
        <trans-unit id="ffd6523d8240fd35c99aa22196c5b35bb9d4d0aa" translate="yes" xml:space="preserve">
          <source>TokType.tkOpr</source>
          <target state="translated">TokType.tkOpr</target>
        </trans-unit>
        <trans-unit id="931dfd4097f801bc1c9c1d82f244816f2bc5ca36" translate="yes" xml:space="preserve">
          <source>TokType.tkOr</source>
          <target state="translated">TokType.tkOr</target>
        </trans-unit>
        <trans-unit id="7eacf1f5a223853dc4c380f703b802c3d18a68a5" translate="yes" xml:space="preserve">
          <source>TokType.tkOut</source>
          <target state="translated">TokType.tkOut</target>
        </trans-unit>
        <trans-unit id="81c5ba52456d16dd63ee37bb9c884854fb002380" translate="yes" xml:space="preserve">
          <source>TokType.tkParDotLe</source>
          <target state="translated">TokType.tkParDotLe</target>
        </trans-unit>
        <trans-unit id="40b6dbedcdeaf10d112bc3dd7120c51df6eb3505" translate="yes" xml:space="preserve">
          <source>TokType.tkParDotRi</source>
          <target state="translated">TokType.tkParDotRi</target>
        </trans-unit>
        <trans-unit id="38b6bd25f440de0eeee800b517e9f4dd82eec1a9" translate="yes" xml:space="preserve">
          <source>TokType.tkParLe</source>
          <target state="translated">TokType.tkParLe</target>
        </trans-unit>
        <trans-unit id="dcc8c3203a3a310ad350eefc8044a6612f585985" translate="yes" xml:space="preserve">
          <source>TokType.tkParRi</source>
          <target state="translated">TokType.tkParRi</target>
        </trans-unit>
        <trans-unit id="7656a02536e6370b226dfd1985e0854b8ff34dc5" translate="yes" xml:space="preserve">
          <source>TokType.tkPostfixOpr</source>
          <target state="translated">TokType.tkPostfixOpr</target>
        </trans-unit>
        <trans-unit id="f88529421ab0eaa4346de1c92ed0cbf614bf5e73" translate="yes" xml:space="preserve">
          <source>TokType.tkPrefixOpr</source>
          <target state="translated">TokType.tkPrefixOpr</target>
        </trans-unit>
        <trans-unit id="733242cd0f33b8839aca02409ffe08c0b8befbc5" translate="yes" xml:space="preserve">
          <source>TokType.tkProc</source>
          <target state="translated">TokType.tkProc</target>
        </trans-unit>
        <trans-unit id="b62ce3689ea3fb22a978318effd11684c6589e5e" translate="yes" xml:space="preserve">
          <source>TokType.tkPtr</source>
          <target state="translated">TokType.tkPtr</target>
        </trans-unit>
        <trans-unit id="15518423eb969fe135a9589dd520a96d2ef908c8" translate="yes" xml:space="preserve">
          <source>TokType.tkRStrLit</source>
          <target state="translated">TokType.tkRStrLit</target>
        </trans-unit>
        <trans-unit id="472312b9a8e3cb57b034bc27016c1e68fc3da49c" translate="yes" xml:space="preserve">
          <source>TokType.tkRaise</source>
          <target state="translated">TokType.tkRaise</target>
        </trans-unit>
        <trans-unit id="22e4fdcee6b54d717f30eddcf95808e28a717636" translate="yes" xml:space="preserve">
          <source>TokType.tkRef</source>
          <target state="translated">TokType.tkRef</target>
        </trans-unit>
        <trans-unit id="0456d086f77971a9666cb1842e1d8e6602f84998" translate="yes" xml:space="preserve">
          <source>TokType.tkReturn</source>
          <target state="translated">TokType.tkReturn</target>
        </trans-unit>
        <trans-unit id="72d18684d6c011c529065e3856024bec0ba2c884" translate="yes" xml:space="preserve">
          <source>TokType.tkSemiColon</source>
          <target state="translated">TokType.tkSemiColon</target>
        </trans-unit>
        <trans-unit id="68dd5afb9f257e8a09828abe98617ae0b556f528" translate="yes" xml:space="preserve">
          <source>TokType.tkShl</source>
          <target state="translated">TokType.tkShl</target>
        </trans-unit>
        <trans-unit id="adce6edbf7a09830e6aea09b00e51103bcdd8c69" translate="yes" xml:space="preserve">
          <source>TokType.tkShr</source>
          <target state="translated">TokType.tkShr</target>
        </trans-unit>
        <trans-unit id="a7e0ce692e8eef9620693f8d1686107af11d3621" translate="yes" xml:space="preserve">
          <source>TokType.tkSpaces</source>
          <target state="translated">TokType.tkSpaces</target>
        </trans-unit>
        <trans-unit id="8ede613d2b8a8c0925955c215d72651d2d1fe100" translate="yes" xml:space="preserve">
          <source>TokType.tkStatic</source>
          <target state="translated">TokType.tkStatic</target>
        </trans-unit>
        <trans-unit id="3e1f802b0766e1d896f407432018cfcf714b0074" translate="yes" xml:space="preserve">
          <source>TokType.tkStrLit</source>
          <target state="translated">TokType.tkStrLit</target>
        </trans-unit>
        <trans-unit id="e533a04ad49883518c5569b7942f4720930b22fd" translate="yes" xml:space="preserve">
          <source>TokType.tkSymbol</source>
          <target state="translated">TokType.tkSymbol</target>
        </trans-unit>
        <trans-unit id="5dfe431832d87861aef40ed981f51aa72acd6be1" translate="yes" xml:space="preserve">
          <source>TokType.tkTemplate</source>
          <target state="translated">TokType.tkTemplate</target>
        </trans-unit>
        <trans-unit id="b5fdc9e9a791e7e6914796f66c2b4b31637f0f5f" translate="yes" xml:space="preserve">
          <source>TokType.tkTripleStrLit</source>
          <target state="translated">TokType.tkTripleStrLit</target>
        </trans-unit>
        <trans-unit id="db8110eca97c7cfaa37bf7fa24e13537979a4829" translate="yes" xml:space="preserve">
          <source>TokType.tkTry</source>
          <target state="translated">TokType.tkTry</target>
        </trans-unit>
        <trans-unit id="6a6b802dc1cc093d4926740ac2b4c6c5040906c7" translate="yes" xml:space="preserve">
          <source>TokType.tkTuple</source>
          <target state="translated">TokType.tkTuple</target>
        </trans-unit>
        <trans-unit id="3ca68e6d27fa575abe34e5ca00ac1d61f7da1f65" translate="yes" xml:space="preserve">
          <source>TokType.tkType</source>
          <target state="translated">TokType.tkType</target>
        </trans-unit>
        <trans-unit id="ce40c933fe6843eaf07c490f2a9366ae2ebefa8d" translate="yes" xml:space="preserve">
          <source>TokType.tkUInt16Lit</source>
          <target state="translated">TokType.tkUInt16Lit</target>
        </trans-unit>
        <trans-unit id="8e7c763326c2c45bff5836760724b3710c13bd20" translate="yes" xml:space="preserve">
          <source>TokType.tkUInt32Lit</source>
          <target state="translated">TokType.tkUInt32Lit</target>
        </trans-unit>
        <trans-unit id="72334b652ed7e35758949ef493f7d2943cb84b7c" translate="yes" xml:space="preserve">
          <source>TokType.tkUInt64Lit</source>
          <target state="translated">TokType.tkUInt64Lit</target>
        </trans-unit>
        <trans-unit id="cc5bc533909e3a2281f243d22474cadf11e06e43" translate="yes" xml:space="preserve">
          <source>TokType.tkUInt8Lit</source>
          <target state="translated">TokType.tkUInt8Lit</target>
        </trans-unit>
        <trans-unit id="27574dc7c60e8440a7e378a0a73b5ef43e381826" translate="yes" xml:space="preserve">
          <source>TokType.tkUIntLit</source>
          <target state="translated">TokType.tkUIntLit</target>
        </trans-unit>
        <trans-unit id="f57c8920a4bc0b0a15fbeb713b25f13cde39cb36" translate="yes" xml:space="preserve">
          <source>TokType.tkUsing</source>
          <target state="translated">TokType.tkUsing</target>
        </trans-unit>
        <trans-unit id="87240d73886341c28e34fbdaca7b8d2e99da415b" translate="yes" xml:space="preserve">
          <source>TokType.tkVar</source>
          <target state="translated">TokType.tkVar</target>
        </trans-unit>
        <trans-unit id="737b654200742d4bf4060f9449a7fa8328111ac3" translate="yes" xml:space="preserve">
          <source>TokType.tkWhen</source>
          <target state="translated">TokType.tkWhen</target>
        </trans-unit>
        <trans-unit id="8643ea2504e09c98a8baaa8319d4dd9f0d4b5f7d" translate="yes" xml:space="preserve">
          <source>TokType.tkWhile</source>
          <target state="translated">TokType.tkWhile</target>
        </trans-unit>
        <trans-unit id="b918ba580d455cae98401f54ebc3dec2d8285d7c" translate="yes" xml:space="preserve">
          <source>TokType.tkXor</source>
          <target state="translated">TokType.tkXor</target>
        </trans-unit>
        <trans-unit id="cddea888d26bf5d77691d54dc6f57715b25a035e" translate="yes" xml:space="preserve">
          <source>TokType.tkYield</source>
          <target state="translated">TokType.tkYield</target>
        </trans-unit>
        <trans-unit id="15a9c6fe569a4d59b6c4eba1d897854c5fb808d8" translate="yes" xml:space="preserve">
          <source>TokType:</source>
          <target state="translated">TokType:</target>
        </trans-unit>
        <trans-unit id="362082473cde64c91141d06ca89885d3fc43e871" translate="yes" xml:space="preserve">
          <source>TokTypes:</source>
          <target state="translated">TokTypes:</target>
        </trans-unit>
        <trans-unit id="717e44080c0f9b1316356858fca76eee0fd0dbd5" translate="yes" xml:space="preserve">
          <source>Token:</source>
          <target state="translated">Token:</target>
        </trans-unit>
        <trans-unit id="e343b4c58f98bfc11776b6a5f56d3141edf483c2" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;code&gt;s&lt;/code&gt; into substrings for interpolation purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f059218a4518a885adf6307ec93a797dedad724" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;code&gt;s&lt;/code&gt; into substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b94544fc25d4f617242b0db05703f0c24a3b42d" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;em&gt;s&lt;/em&gt; into substrings for interpolation purposes.</source>
          <target state="translated">Токенизирует строку &lt;em&gt;s&lt;/em&gt; в подстроки для целей интерполяции.</target>
        </trans-unit>
        <trans-unit id="9dabecffbc85d3462b703f6f51a8d742d3888dc3" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;em&gt;s&lt;/em&gt; into substrings.</source>
          <target state="translated">Токенизирует строку &lt;em&gt;s&lt;/em&gt; на подстроки.</target>
        </trans-unit>
        <trans-unit id="4df68215c8e8bc621359763d151b72a86c6da974" translate="yes" xml:space="preserve">
          <source>Tools available with Nim</source>
          <target state="translated">Инструменты,доступные с Nim</target>
        </trans-unit>
        <trans-unit id="58446c7f2b2e4db0f99d43b03101c0a822d287a4" translate="yes" xml:space="preserve">
          <source>Tools documentation</source>
          <target state="translated">Документация по инструментам</target>
        </trans-unit>
        <trans-unit id="1fe5db2636efc921cd0bb4e6546d660babab9b05" translate="yes" xml:space="preserve">
          <source>Top level &lt;code&gt;defer&lt;/code&gt; statements are not supported since it's unclear what such a statement should refer to.</source>
          <target state="translated">Операторы &lt;code&gt;defer&lt;/code&gt; верхнего уровня не поддерживаются, так как неясно, на что должен ссылаться такой оператор.</target>
        </trans-unit>
        <trans-unit id="cb14fa6e0884cf02668ea33f83561399f74d1358" translate="yes" xml:space="preserve">
          <source>Top level accesses to &lt;code&gt;gdata&lt;/code&gt; are always allowed so that it can be initialized conveniently. It is &lt;em&gt;assumed&lt;/em&gt; (but not enforced) that every top level statement is executed before any concurrent action happens.</source>
          <target state="translated">&lt;code&gt;gdata&lt;/code&gt; верхнего уровня к gdata всегда разрешен, чтобы его можно было удобно инициализировать. Это &lt;em&gt;предполагается&lt;/em&gt; (но не соблюдается) , что каждое утверждение верхнего уровня выполняется до любого параллельного действия происходит.</target>
        </trans-unit>
        <trans-unit id="eddf8fc4150fb378c850cd2207e5cd6cdfec3026" translate="yes" xml:space="preserve">
          <source>Top-level &lt;code&gt;defer&lt;/code&gt; statements are not supported since it's unclear what such a statement should refer to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1df960d5a8bc3c6b227df69c648f6de356c26d" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword, untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword. In general, a &lt;code&gt;ptr T&lt;/code&gt; is implicitly convertible to the &lt;code&gt;pointer&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aac1979dafc6f8136821295c2c76ca0331a0e00" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword, untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword. In general, a &lt;em&gt;ptr T&lt;/em&gt; is implicitly convertible to the &lt;em&gt;pointer&lt;/em&gt; type.</source>
          <target state="translated">Отслеживаемые ссылки объявляются с помощью ключевого слова &lt;strong&gt;ref&lt;/strong&gt; , неотслеживаемые ссылки объявляются с помощью ключевого слова &lt;strong&gt;ptr&lt;/strong&gt; . В общем, &lt;em&gt;ptr T&lt;/em&gt; неявно преобразуется в тип &lt;em&gt;указателя&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0e0c2775cf7c51f8a1bb67ce0e0ab81a950538e4" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword; untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword.</source>
          <target state="translated">Прослеживаемые ссылки объявляются с ключевым словом &lt;strong&gt;ref&lt;/strong&gt; ; неотслеживаемые ссылки объявляются с ключевым словом &lt;strong&gt;ptr&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a1fc498182e45877c7d386bad77456516385d934" translate="yes" xml:space="preserve">
          <source>Traditional select function. This function will return the number of sockets that are ready to be read from, written to, or which have errors. If there are none; 0 is returned. &lt;code&gt;Timeout&lt;/code&gt; is in milliseconds and -1 can be specified for no timeout.</source>
          <target state="translated">Традиционная функция выбора. Эта функция вернет количество сокетов, которые готовы к чтению, записи или с ошибками. Если их нет; 0 возвращается. &lt;code&gt;Timeout&lt;/code&gt; указывается в миллисекундах, и -1 может быть указан без тайм-аута.</target>
        </trans-unit>
        <trans-unit id="3b6a1b2ac3012e50748232ba8eb954103f97ad1c" translate="yes" xml:space="preserve">
          <source>Transformation:</source>
          <target state="translated">Transformation:</target>
        </trans-unit>
        <trans-unit id="b166fd2494951b4a9dd6614893d73631313e5287" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;x&lt;/code&gt; in-place (must be declared as &lt;code&gt;var&lt;/code&gt;) into its cumulative (aka prefix) summation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee891e5e3e3894f6430c52409c74a31424cf68c" translate="yes" xml:space="preserve">
          <source>Transforms any iterable (anything that can be iterated over, e.g. with a for-loop) into a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7b92acc9a145b44981e2aafa578d392367d9b9" translate="yes" xml:space="preserve">
          <source>Transforms any iterator into a sequence.</source>
          <target state="translated">Преобразовывает любой итератор в последовательность.</target>
        </trans-unit>
        <trans-unit id="06d8c014bbeddfd36b3452bacbcdbea84d51a7e7" translate="yes" xml:space="preserve">
          <source>Translates words in a string using the &lt;code&gt;replacements&lt;/code&gt; proc to substitute words inside &lt;code&gt;s&lt;/code&gt; with their replacements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab31ee25d07a8f9d5ddc9927e74c06ef43d27b4f" translate="yes" xml:space="preserve">
          <source>Translates words in a string using the &lt;em&gt;replacements&lt;/em&gt; proc to substitute words inside &lt;em&gt;s&lt;/em&gt; with their replacements</source>
          <target state="translated">Переводит слова в строке, используя процедуру &lt;em&gt;замены&lt;/em&gt; для замены слов внутри &lt;em&gt;s&lt;/em&gt; их заменами</target>
        </trans-unit>
        <trans-unit id="a7c36d78b13e6dda8f6d500d67c359740cbced46" translate="yes" xml:space="preserve">
          <source>Traverses the node and gets the given value. If any of the indexes do not exist, returns &lt;code&gt;nil&lt;/code&gt;. Also returns &lt;code&gt;nil&lt;/code&gt; if one of the intermediate data structures is not an array.</source>
          <target state="translated">Обходит узел и получает заданное значение. Если какой-либо из индексов не существует, возвращает &lt;code&gt;nil&lt;/code&gt; . Также возвращает &lt;code&gt;nil&lt;/code&gt; , если одна из промежуточных структур данных не является массивом.</target>
        </trans-unit>
        <trans-unit id="3793e0cbf6a67e24ccddc9cfe73cf06db3bff8f2" translate="yes" xml:space="preserve">
          <source>Traverses the node and gets the given value. If any of the keys do not exist, returns &lt;code&gt;nil&lt;/code&gt;. Also returns &lt;code&gt;nil&lt;/code&gt; if one of the intermediate data structures is not an object.</source>
          <target state="translated">Обходит узел и получает заданное значение. Если какой-либо из ключей не существует, возвращается &lt;code&gt;nil&lt;/code&gt; . Также возвращает &lt;code&gt;nil&lt;/code&gt; , если одна из промежуточных структур данных не является объектом.</target>
        </trans-unit>
        <trans-unit id="9165124d411bbca6b0b36e2cf0040381f82a3771" translate="yes" xml:space="preserve">
          <source>Traverses the node and tries to set the value at the given location to &lt;code&gt;value&lt;/code&gt;. If any of the keys are missing, they are added.</source>
          <target state="translated">Траверсы узла и пытается установить значение в заданном месте к &lt;code&gt;value&lt;/code&gt; . Если какой-либо из ключей отсутствует, они добавляются.</target>
        </trans-unit>
        <trans-unit id="bdaad0ebd0308235ded505de3934e9cc0046795a" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and adds them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9ed1decb50308f5e6aa06d20161f00ecb9ca93" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and compares them. Returns true if &lt;code&gt;unsigned(x) &amp;gt; unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c48e0fdd0ebc4b2891001348bd40e23a61cf6c0" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and compares them. Returns true if &lt;code&gt;unsigned(x) &amp;gt;= unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b683e854fa9bdd3e32c9c74b2f4273e5c40e4565" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and compares them. Returns true if &lt;code&gt;unsigned(x) &amp;lt; unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3499bddf2f40a8fa9694d375c62bdc702ba8be5" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and compares them. Returns true if &lt;code&gt;unsigned(x) &amp;lt;= unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363b3a920ec3ebefa623919736db3dc30615daad" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and compute the modulo of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1379c334be5ee52f0718ac9b9e84741f86f51f0c" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and divides them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb7930e147b0baa66f7cc291fe453c89d88037d" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and multiplies them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9065cd842104ab82e826f5e260486a20aa1973e4" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and subtracts them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be21b1bce2de067bd3e786afad75fd72756bccb7" translate="yes" xml:space="preserve">
          <source>Tries to acquire the given lock. Returns &lt;code&gt;true&lt;/code&gt; on success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156e25a6b8cf8a864963e049e7d35bac34d38d59" translate="yes" xml:space="preserve">
          <source>Tries to acquire the given lock. Returns &lt;em&gt;true&lt;/em&gt; on success.</source>
          <target state="translated">Пытается получить данную блокировку. В &lt;em&gt;случае&lt;/em&gt; успеха возвращает &lt;em&gt;true&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="052b52ab3d9fabc546aeeb6ac42140e3b6adb0d3" translate="yes" xml:space="preserve">
          <source>Tries to execute the query and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468da52d5869ae376d9b95725718bd6ff03dd727" translate="yes" xml:space="preserve">
          <source>Tries to execute the query and returns true if successful, false otherwise.</source>
          <target state="translated">Пытается выполнить запрос и возвращает true в случае успеха,false в противном случае.</target>
        </trans-unit>
        <trans-unit id="43cd3232070ab3327532d46fceeb76f1a6c24cef" translate="yes" xml:space="preserve">
          <source>Tries to receive a message from the channel &lt;code&gt;c&lt;/code&gt;, but this can fail for all sort of reasons, including contention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f0489b14e1e492e61e5c98226d96a5ae8a905f" translate="yes" xml:space="preserve">
          <source>Tries to receive a message from the channel &lt;em&gt;c&lt;/em&gt;, but this can fail for all sort of reasons, including contention. If it fails, it returns &lt;code&gt;(false, default(msg))&lt;/code&gt; otherwise it returns &lt;code&gt;(true, msg)&lt;/code&gt;.</source>
          <target state="translated">Пытается получить сообщение из канала &lt;em&gt;c&lt;/em&gt; , но это может не получиться по разным причинам, включая конфликт. В случае неудачи он возвращает &lt;code&gt;(false, default(msg))&lt;/code&gt; противном случае возвращает &lt;code&gt;(true, msg)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b8e54d5c6c55af29c2af25e91a4e9b9de9368ad" translate="yes" xml:space="preserve">
          <source>Tries to reset browser state and writes &lt;code&gt;data&lt;/code&gt; to stdout in &amp;lt;plaintext&amp;gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e8185659254fff6635dee26e78e5d85bff42cc" translate="yes" xml:space="preserve">
          <source>Tries to reset browser state and writes &lt;em&gt;data&lt;/em&gt; to stdout in &amp;lt;plaintext&amp;gt; tag.</source>
          <target state="translated">Пытается сбросить состояние браузера и записывает &lt;em&gt;данные&lt;/em&gt; в стандартный вывод в теге &amp;lt;plaintext&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="fe1371bcbeb7e55667bc32ef0a2f430e58ebcb67" translate="yes" xml:space="preserve">
          <source>Tries to send a message to a thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1f450205803ed460a630c26002dda1d5353960" translate="yes" xml:space="preserve">
          <source>Tries to send a message to a thread. &lt;em&gt;msg&lt;/em&gt; is deeply copied. Doesn't block. Returns &lt;em&gt;false&lt;/em&gt; if the message was not sent because number of pending items in the channel exceeded &lt;em&gt;maxItems&lt;/em&gt;.</source>
          <target state="translated">Пытается отправить сообщение в тему. &lt;em&gt;msg&lt;/em&gt; глубоко скопировано. Не блокирует. Возвращает &lt;em&gt;false,&lt;/em&gt; если сообщение не было отправлено, так как количество ожидающих элементов в канале превышает &lt;em&gt;maxItems&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8c7db82aabe0ec4b37ab6dba207f6dfa98f250d7" translate="yes" xml:space="preserve">
          <source>Trigger event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">Триггерное событие &lt;code&gt;ev&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3c207482b9595dc0f6457a13d2f1e61c56e381" translate="yes" xml:space="preserve">
          <source>Trim trailing zeros from a formatted floating point value (&lt;em&gt;x&lt;/em&gt;). Modifies the passed value.</source>
          <target state="translated">Обрезать конечные нули из форматированного значения с плавающей запятой ( &lt;em&gt;x&lt;/em&gt; ). Изменяет переданное значение.</target>
        </trans-unit>
        <trans-unit id="dfc10a85898402be5a0dc29ff3a151acbc0ec82c" translate="yes" xml:space="preserve">
          <source>Trim trailing zeros from a formatted floating point value &lt;code&gt;x&lt;/code&gt; (must be declared as &lt;code&gt;var&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afddc6dcc2da91db52e6db34c078cda6ecf5a529" translate="yes" xml:space="preserve">
          <source>Triple quoted string literals</source>
          <target state="translated">Тройные строковые литералы</target>
        </trans-unit>
        <trans-unit id="ece7dfe6456e82fc094101afe039e9008b540f9c" translate="yes" xml:space="preserve">
          <source>True if the file system is case sensitive, false otherwise. Used by &lt;a href=&quot;#cmpPaths,string,string&quot;&gt;cmpPaths proc&lt;/a&gt; to compare filenames properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12506a0b7ae22bbc9eda9b9dbf90cd45acb51a13" translate="yes" xml:space="preserve">
          <source>True only when accessed in the main module. This works thanks to compiler magic. It is useful to embed testing code in a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052493e1431b2d637a77a0276e53ee054de7f589" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;x&lt;/code&gt; to the decimal point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245ceee2586082dc5a73679c70b42d08a85510ee" translate="yes" xml:space="preserve">
          <source>Truncates &lt;em&gt;x&lt;/em&gt; to the decimal point</source>
          <target state="translated">Обрезает &lt;em&gt;x&lt;/em&gt; до десятичной точки</target>
        </trans-unit>
        <trans-unit id="02715c4b7ff15274f4612905c77b4bda81876e45" translate="yes" xml:space="preserve">
          <source>Try can also be used as an expression; the type of the &lt;code&gt;try&lt;/code&gt; branch then needs to fit the types of &lt;code&gt;except&lt;/code&gt; branches, but the type of the &lt;code&gt;finally&lt;/code&gt; branch always has to be &lt;code&gt;void&lt;/code&gt;:</source>
          <target state="translated">Попробуйте также использовать как выражение; тогда тип ветви &lt;code&gt;try&lt;/code&gt; должен соответствовать типам ветвей &lt;code&gt;except&lt;/code&gt; , но тип ветви &lt;code&gt;finally&lt;/code&gt; всегда должен быть &lt;code&gt;void&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a7af062d7b75f8335dbdc49667ebc20f3bbd46f5" translate="yes" xml:space="preserve">
          <source>Try expression</source>
          <target state="translated">Попробуйте выразить себя</target>
        </trans-unit>
        <trans-unit id="f526bd18e3a74520efcc9c43abfaeabfe401e20b" translate="yes" xml:space="preserve">
          <source>Try statement</source>
          <target state="translated">Попробуйте сделать заявление</target>
        </trans-unit>
        <trans-unit id="282a53848958015adde9657c323c058f36bbfd19" translate="yes" xml:space="preserve">
          <source>Tuple access &lt;code&gt;e[0]&lt;/code&gt; is a path expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb959bb7d8da3f5b1a99088eb043845c557941e" translate="yes" xml:space="preserve">
          <source>Tuple or object scope</source>
          <target state="translated">Кортеж или объект</target>
        </trans-unit>
        <trans-unit id="3f99aa09c1ddebfc55f57b61f023038ddf8cd672" translate="yes" xml:space="preserve">
          <source>Tuple unpacking</source>
          <target state="translated">Распаковка кортежей</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="b3e2bebd3f6bc134f276b0e73ccd708819d73bd3" translate="yes" xml:space="preserve">
          <source>Tuples and object types</source>
          <target state="translated">Кортежи и типы объектов</target>
        </trans-unit>
        <trans-unit id="4591fb7e2e6af521b3d77017031f788c69e63561" translate="yes" xml:space="preserve">
          <source>Tuples can be &lt;em&gt;unpacked&lt;/em&gt; during variable assignment (and only then!). This can be handy to assign directly the fields of the tuples to individually named variables. An example of this is the &lt;a href=&quot;os#splitFile&quot;&gt;splitFile&lt;/a&gt; proc from the &lt;a href=&quot;os&quot;&gt;os module&lt;/a&gt; which returns the directory, name and extension of a path at the same time. For tuple unpacking to work you must use parentheses around the values you want to assign the unpacking to, otherwise you will be assigning the same value to all the individual variables! For example:</source>
          <target state="translated">Кортежи можно &lt;em&gt;распаковывать&lt;/em&gt; во время присваивания переменной (и только тогда!). Это может быть удобно для непосредственного присвоения полей кортежей индивидуально именованным переменным. Примером этого является процедура &lt;a href=&quot;os#splitFile&quot;&gt;splitFile&lt;/a&gt; из &lt;a href=&quot;os&quot;&gt;модуля os,&lt;/a&gt; которая одновременно возвращает каталог, имя и расширение пути. Чтобы распаковка кортежей работала, вы должны использовать круглые скобки вокруг значений, которым вы хотите назначить распаковку, иначе вы будете присваивать одно и то же значение всем отдельным переменным! Например:</target>
        </trans-unit>
        <trans-unit id="8352a113514bb2d5c1a998e7f4b0ab2c15a44826" translate="yes" xml:space="preserve">
          <source>Tuples which are longer than one line should indent their parameters to align with the parameters above it.</source>
          <target state="translated">Кортежи,которые длиннее одной строки,должны отступать от своих параметров,чтобы выровнять их с параметрами,указанными выше.</target>
        </trans-unit>
        <trans-unit id="9b346e4953356d44049c162bd3c503c985bc5b32" translate="yes" xml:space="preserve">
          <source>Turn a deque into its string representation.</source>
          <target state="translated">Поверните деку в его строковое представление.</target>
        </trans-unit>
        <trans-unit id="8743e385990daa129ed7fd77c0aab253383cfcf0" translate="yes" xml:space="preserve">
          <source>Turn a rational number into a string.</source>
          <target state="translated">Превратите рациональное число в строку.</target>
        </trans-unit>
        <trans-unit id="b2da04eb9b0e013eba1b39577106beaef7dc951b" translate="yes" xml:space="preserve">
          <source>Turn an array into a sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6530f1075ffd79f7adf57fbf48c454fea802b4a4" translate="yes" xml:space="preserve">
          <source>Turning the &lt;code&gt;log&lt;/code&gt; proc into a template solves this problem:</source>
          <target state="translated">Превращение процедуры &lt;code&gt;log&lt;/code&gt; в шаблон решает эту проблему:</target>
        </trans-unit>
        <trans-unit id="6b5850fb86ac4e5bc322e41268cc7861df7f4a1d" translate="yes" xml:space="preserve">
          <source>Turns (value) into (let tmp = value; tmp) so that 'value' can be re-used freely, multiple times. This is frequently required and such a builtin would also be handy to have in macros.nim. The value that can be reused is 'result.lastSon'!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce023416124f914bcf593ab1171ad47e64ee136f" translate="yes" xml:space="preserve">
          <source>Turns &lt;code&gt;c&lt;/code&gt; into a string representation. Example outputs: &lt;code&gt;{keyA: value, keyB: value}&lt;/code&gt;, &lt;code&gt;{:}&lt;/code&gt; If &lt;code&gt;T&lt;/code&gt; is void the outputs look like: &lt;code&gt;{keyA, keyB}&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5c445f42d980d9d76e1b24ead074b3acaa5bae" translate="yes" xml:space="preserve">
          <source>Turns a deque into its string representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87914654685c51bf6075828a3fc05f1ffba0dd2" translate="yes" xml:space="preserve">
          <source>Turns a heap into its string representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8592a9737bc490409f41923903054f7ad13a61" translate="yes" xml:space="preserve">
          <source>Turns a list into its string representation for logging and printing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a894b4e80dd8a689f15cb3cdb75de82b7974cfe0" translate="yes" xml:space="preserve">
          <source>Turns a regular function call into an invocation of the JavaScript's &lt;code&gt;new&lt;/code&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcf0ab5d7d983b90173092de9a62442f37e633f" translate="yes" xml:space="preserve">
          <source>Turns a regular function call into an invocation of the JavaScript's &lt;em&gt;new&lt;/em&gt; operator</source>
          <target state="translated">Превращает обычный вызов функции в вызов &lt;em&gt;нового&lt;/em&gt; оператора JavaScript.</target>
        </trans-unit>
        <trans-unit id="410075e7c67c71aa15636d4a25f20948e3529970" translate="yes" xml:space="preserve">
          <source>Turns an &lt;em&gt;openArray&lt;/em&gt; into a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a68ab01e5fdf86eb4cc6a9e499aac1727c22cce" translate="yes" xml:space="preserve">
          <source>Turns an &lt;span id=&quot;inminusplace_1&quot;&gt;in-place&lt;/span&gt; algorithm into one that works on a copy and returns this copy, without modifying its input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292edd42e18453646e66461a30abbc138ecc6f39" translate="yes" xml:space="preserve">
          <source>Turns an array into a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991bb0cdd074717a07e7eda33f5d12a9f36f5c9e" translate="yes" xml:space="preserve">
          <source>Turns multiple slashes into single slashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38263a1e88c596b067b79f85537502d7865f6da" translate="yes" xml:space="preserve">
          <source>Turns off all runtime checks and turns on the optimizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4a9c5e9fbeb1731e11e217df10a5e9df4c2462" translate="yes" xml:space="preserve">
          <source>Turns off runtime checks and turns on the optimizer.</source>
          <target state="translated">Отключает проверку времени работы и включает оптимизатор.</target>
        </trans-unit>
        <trans-unit id="b70652e73562b96df645462aed3ab29925d1a6e7" translate="yes" xml:space="preserve">
          <source>Turns on the optimizer. More aggressive optimizations are possible, e.g.: &lt;code&gt;--passC:-ffast-math&lt;/code&gt; (but see issue #10305)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f84b7302f8b2c0acedd7493fcbdb678ea820d7e" translate="yes" xml:space="preserve">
          <source>Turns the code generation for all runtime checks on or off.</source>
          <target state="translated">Включает или выключает генерацию кода для всех проверок во время выполнения.</target>
        </trans-unit>
        <trans-unit id="8359c50c168a0d32c1676689b7b9be53909574c9" translate="yes" xml:space="preserve">
          <source>Turns the code generation for array bound checks on or off.</source>
          <target state="translated">Включает или выключает генерацию кода для проверки связанных массивов.</target>
        </trans-unit>
        <trans-unit id="78de984f73e6a96b608abf84f509342b6416676c" translate="yes" xml:space="preserve">
          <source>Turns the code generation for assertions on or off.</source>
          <target state="translated">Включает или выключает генерацию кода для утверждений.</target>
        </trans-unit>
        <trans-unit id="f85728da201c7e87406c7977edcd7efb848370e2" translate="yes" xml:space="preserve">
          <source>Turns the code generation for nil pointer checks on or off.</source>
          <target state="translated">Включает или выключает генерацию кода для проверки нулевого указателя.</target>
        </trans-unit>
        <trans-unit id="7443a6fe5c166cf5312e85d734da57674e23a9ea" translate="yes" xml:space="preserve">
          <source>Turns the code generation for over- or underflow checks on or off.</source>
          <target state="translated">Включает или выключает генерацию кода для проверки переполнения или недополнения.</target>
        </trans-unit>
        <trans-unit id="634d9e7817c9bcc8bdbbd8305a699f04a3c9ba2f" translate="yes" xml:space="preserve">
          <source>Turns the hint messages of the compiler on or off.</source>
          <target state="translated">Включает или выключает подсказки компилятора.</target>
        </trans-unit>
        <trans-unit id="96dcbf296f2f4c34221163dd4a790e8efb28f099" translate="yes" xml:space="preserve">
          <source>Turns the term rewriting templates/macros on or off.</source>
          <target state="translated">Включает или выключает термин переписывание шаблонов/макросов.</target>
        </trans-unit>
        <trans-unit id="f31cc462c8ec7105eb07e2c1b5bb943c21db3b4d" translate="yes" xml:space="preserve">
          <source>Turns the warning messages of the compiler on or off.</source>
          <target state="translated">Включает или выключает предупреждающие сообщения компилятора.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="779de5f9680bb0a0d05277f00d89d734c054b346" translate="yes" xml:space="preserve">
          <source>Tutorial (part I)</source>
          <target state="translated">Учебное пособие (часть I)</target>
        </trans-unit>
        <trans-unit id="e8a76eed53f23547280f2ddf6517628c83064326" translate="yes" xml:space="preserve">
          <source>Tutorial (part II)</source>
          <target state="translated">Учебное пособие (часть II)</target>
        </trans-unit>
        <trans-unit id="12eddb48c045f6baba27243ad34ddf90603d7edf" translate="yes" xml:space="preserve">
          <source>Tutorial (part III)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5778f261d1733e81971ab8e088ac48fafe7c0eb" translate="yes" xml:space="preserve">
          <source>Tweaking the GC</source>
          <target state="translated">Тонкая настройка ГК</target>
        </trans-unit>
        <trans-unit id="04c56f6663c1accf7ccbcdda0087beb3f2683037" translate="yes" xml:space="preserve">
          <source>Tweaking the garbage collector</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfc4e5ee613e56b16e91f9c1891af1bb27a177f" translate="yes" xml:space="preserve">
          <source>Tweaking the refc GC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778080b9d6142ab857443b50014ddb8d3ccd44e2" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Timezone&lt;/code&gt;'s are considered equal if their name is equal.</source>
          <target state="translated">Два &lt;code&gt;Timezone&lt;/code&gt; считаются равными, если их имена совпадают.</target>
        </trans-unit>
        <trans-unit id="6a865c6e91cc1b9c8041b930bdded2be0556b0e5" translate="yes" xml:space="preserve">
          <source>Two identifiers are considered equal if the following algorithm returns true:</source>
          <target state="translated">Два идентификатора считаются равными,если следующий алгоритм возвращает true:</target>
        </trans-unit>
        <trans-unit id="24954bd408579a9efa899f397b4b12b6c9f4f267" translate="yes" xml:space="preserve">
          <source>Two output parameters should never be aliased.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6298e080874877d7a98b594edb938f20831dfff6" translate="yes" xml:space="preserve">
          <source>Two spaces should be used for indentation of blocks; tabstops are not allowed (the compiler enforces this). Using spaces means that the appearance of code is more consistent across editors. Unlike spaces, tabstop width varies across editors, and not all editors provide means of changing this width.</source>
          <target state="translated">Для отступов блоков следует использовать два пробела;табстопы не допускаются (компилятор это обеспечивает).Использование пробелов означает,что внешний вид кода более согласованен между редакторами.В отличие от пробелов,ширина табстопа различается в разных редакторах,и не все редакторы предоставляют средства для изменения этой ширины.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="04ebb4da7a084030b721611207edce2d27a82c1d" translate="yes" xml:space="preserve">
          <source>Type Class representing valid types for use with atomic procs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4286f84aa2ec1726d2f29d48fef0c9bf605e85" translate="yes" xml:space="preserve">
          <source>Type Classes</source>
          <target state="translated">Классы типа</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="translated">Преобразование типа</target>
        </trans-unit>
        <trans-unit id="c0eb387e477546545eec601f050672bd06c02038" translate="yes" xml:space="preserve">
          <source>Type Suffix</source>
          <target state="translated">Тип суффикса</target>
        </trans-unit>
        <trans-unit id="517963ffe8430bed0d4f132dcd51c0d4eb3001b7" translate="yes" xml:space="preserve">
          <source>Type bound operations</source>
          <target state="translated">Операции по привязке к типу</target>
        </trans-unit>
        <trans-unit id="b2ce942200cd4ed497c93d87123ffa3584d50070" translate="yes" xml:space="preserve">
          <source>Type casts</source>
          <target state="translated">Типовые отливки</target>
        </trans-unit>
        <trans-unit id="bf3e880739673e946c25d0dedcde2653a7c48216" translate="yes" xml:space="preserve">
          <source>Type casts are a crude mechanism to interpret the bit pattern of an expression as if it would be of another type. Type casts are only needed for low-level programming and are inherently unsafe.</source>
          <target state="translated">Приведение типов-это грубый механизм интерпретации битового паттерна выражения,как если бы оно было другого типа.Приведение типов необходимо только для низкоуровневого программирования и по своей природе небезопасно.</target>
        </trans-unit>
        <trans-unit id="dcb23833423a0c957ef8e5ee3ce4a0cc20e63ea9" translate="yes" xml:space="preserve">
          <source>Type casts should not be confused with &lt;em&gt;type conversions,&lt;/em&gt; as mentioned in the prior section. Unlike type conversions, a type cast cannot change the underlying bit pattern of the data being casted (aside from that the size of the target type may differ from the source type). Casting resembles &lt;em&gt;type punning&lt;/em&gt; in other languages or C++'s &lt;code&gt;reinterpret_cast&lt;/code&gt; and &lt;code&gt;bit_cast&lt;/code&gt; features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25c1533427c8ff248b8fa04b1c204166e4d6cfb" translate="yes" xml:space="preserve">
          <source>Type class matching all floating point number types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8994b5555953cecba5cb081c02065f691c4aade1" translate="yes" xml:space="preserve">
          <source>Type class matching all integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1410da13aa78eef42cd75e9aef9e7ae941423f0" translate="yes" xml:space="preserve">
          <source>Type class matching all number types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7e962b06f2dac22d8ef78d4c96b0beac2ff0ac" translate="yes" xml:space="preserve">
          <source>Type class matching all ordinal types; however this includes enums with holes. See also &lt;code&gt;Ordinal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565f4c82db0ce42bc5ab6b923e5ac75a404d5a81" translate="yes" xml:space="preserve">
          <source>Type class matching all signed integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740183d28c2d3d07b55c914d92dfe4035410fee0" translate="yes" xml:space="preserve">
          <source>Type class matching all unsigned integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21eb352df05ecea6a3a588dc0c8590e21dbccc2" translate="yes" xml:space="preserve">
          <source>Type classes can be combined using the standard boolean operators to form more complex type classes:</source>
          <target state="translated">Классы типов могут быть объединены с помощью стандартных булевых операторов для формирования более сложных классов типов:</target>
        </trans-unit>
        <trans-unit id="27c79e908c3824182db454f062b8835b391eaee1" translate="yes" xml:space="preserve">
          <source>Type conversion can also be used to disambiguate overloaded routines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d7f20ec3a1f2c32685f21a24578ef7bfd33afb" translate="yes" xml:space="preserve">
          <source>Type conversions</source>
          <target state="translated">Преобразование типов</target>
        </trans-unit>
        <trans-unit id="7893cb518df1f3e86b37b8f2c89bf262fddc71ea" translate="yes" xml:space="preserve">
          <source>Type conversions are a much more polite way to convert a type into another: They preserve the abstract &lt;em&gt;value&lt;/em&gt;, not necessarily the &lt;em&gt;bit-pattern&lt;/em&gt;. If a type conversion is not possible, the compiler complains or an exception is raised.</source>
          <target state="translated">Преобразование типов - это гораздо более вежливый способ преобразования одного типа в другой: они сохраняют абстрактное &lt;em&gt;значение&lt;/em&gt; , не обязательно &lt;em&gt;битовый шаблон&lt;/em&gt; . Если преобразование типа невозможно, компилятор жалуется или возникает исключение.</target>
        </trans-unit>
        <trans-unit id="d227e4926b1f493d28e95f292386e3a242d08693" translate="yes" xml:space="preserve">
          <source>Type conversions are compile-time computable.</source>
          <target state="translated">Приводы типов являются вычисляемыми во время компиляции.</target>
        </trans-unit>
        <trans-unit id="bdf318c64b4a51210846dda92e239137e03f96fe" translate="yes" xml:space="preserve">
          <source>Type describing the endianness of a processor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">Равенство типов</target>
        </trans-unit>
        <trans-unit id="ad5ad7af6975f8633efeb665458c5b9ad70586b8" translate="yes" xml:space="preserve">
          <source>Type equality modulo type distinction</source>
          <target state="translated">Типовое равенство по модулю Типовое различие</target>
        </trans-unit>
        <trans-unit id="c5a4537d409bc84d0e6885dd98224efa069a4125" translate="yes" xml:space="preserve">
          <source>Type identifiers should be in PascalCase. All other identifiers should be in camelCase with the exception of constants which &lt;strong&gt;may&lt;/strong&gt; use PascalCase but are not required to.</source>
          <target state="translated">Идентификаторы типа должны быть в PascalCase. Все остальные идентификаторы должны быть в camelCase, за исключением констант, которые &lt;strong&gt;могут&lt;/strong&gt; использовать PascalCase, но не обязательны.</target>
        </trans-unit>
        <trans-unit id="6cdb48b9a7ae81b2d7e34e795c5ca9c78816283e" translate="yes" xml:space="preserve">
          <source>Type info generation for the JS backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f50bbe8baba25a1929146d13b1d95279794e199" translate="yes" xml:space="preserve">
          <source>Type of the symbol. This can be &lt;code&gt;skProc&lt;/code&gt;, &lt;code&gt;skLet&lt;/code&gt;, and just about any of the enums defined in the module &lt;code&gt;compiler/ast.nim&lt;/code&gt;.</source>
          <target state="translated">Тип символа. Это может быть &lt;code&gt;skProc&lt;/code&gt; , &lt;code&gt;skLet&lt;/code&gt; и практически любое из перечислений, определенных в модуле &lt;code&gt;compiler/ast.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbabd93da3123882a924672c6250533f840354ef" translate="yes" xml:space="preserve">
          <source>Type relations</source>
          <target state="translated">Типовые отношения</target>
        </trans-unit>
        <trans-unit id="f8b2d40508694dd4577a697d9c6b4c5f2e3511da" translate="yes" xml:space="preserve">
          <source>Type section</source>
          <target state="translated">Типовой раздел</target>
        </trans-unit>
        <trans-unit id="19ed3f78d17ddb423376e5e7d24d9be0086053f6" translate="yes" xml:space="preserve">
          <source>Type sections</source>
          <target state="translated">Секции типа</target>
        </trans-unit>
        <trans-unit id="caebdb05624ce558cc24e284e7ee360a137ea7d2" translate="yes" xml:space="preserve">
          <source>Type that can hold a single Unicode code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a919a22549142ebb39423637cf5e8cc1b5dc6cbb" translate="yes" xml:space="preserve">
          <source>Type that describes &quot;standard format specifiers&quot;.</source>
          <target state="translated">Тип,описывающий &quot;спецификаторы стандартного формата&quot;.</target>
        </trans-unit>
        <trans-unit id="14b70f38880bb4c9b3736c428ce15bf9ddfdfa1b" translate="yes" xml:space="preserve">
          <source>Type that is constructed by &lt;code&gt;^&lt;/code&gt; for reversed array accesses. (See &lt;a href=&quot;#%5E.t,int&quot;&gt;^ template&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032fbf901a92d8ba594b05e679993e6b981d225b" translate="yes" xml:space="preserve">
          <source>Type union representing &lt;code&gt;HashSet&lt;/code&gt; or &lt;code&gt;OrderedSet&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ed1febf2dc93666a9e94d3bca2653e2f2eba89" translate="yes" xml:space="preserve">
          <source>Type/signature. For variables and enums this will contain the type of the symbol, for procs, methods and templates this will contain the full unique signature (e.g. &lt;code&gt;proc (File)&lt;/code&gt;).</source>
          <target state="translated">Тип / подпись. Для переменных и перечислений он будет содержать тип символа, для процедур, методов и шаблонов он будет содержать полную уникальную подпись (например, &lt;code&gt;proc (File)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1afd965c71f69efe092cfb0d0da2e47e018c1458" translate="yes" xml:space="preserve">
          <source>TypeCache:</source>
          <target state="translated">TypeCache:</target>
        </trans-unit>
        <trans-unit id="0aa83d8e7bf39f57f10caf572c84d7e435d76d43" translate="yes" xml:space="preserve">
          <source>TypeCacheWithOwner:</source>
          <target state="translated">TypeCacheWithOwner:</target>
        </trans-unit>
        <trans-unit id="5204c9867a362caf0bea9525b902dfe2dc066c0b" translate="yes" xml:space="preserve">
          <source>Typed future.</source>
          <target state="translated">Типичное будущее.</target>
        </trans-unit>
        <trans-unit id="a1cf3d18ff7e16dcb6cdb495e43f6f5c061a5575" translate="yes" xml:space="preserve">
          <source>Typed vs untyped parameters</source>
          <target state="translated">Типизированные и не типизированные параметры</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="a4d826f2d99cd7f5fe802f315c32dc5f53188f2d" translate="yes" xml:space="preserve">
          <source>Typical usage for each logging level, from lowest to highest, is described below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c69ab987059b075ca59e012555a1691460df54" translate="yes" xml:space="preserve">
          <source>UDP is a connectionless protocol, so UDP sockets don't have to explicitly call the &lt;a href=&quot;net#connect%2CSocket%2Cstring&quot;&gt;connect&lt;/a&gt; procedure. They can simply start sending data immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5720ec6d00feb96f366d8679918ecb98f50f66f7" translate="yes" xml:space="preserve">
          <source>UDP is a connectionless protocol, so UDP sockets don't have to explicitly call the &lt;code&gt;connect&lt;/code&gt; procedure. They can simply start sending data immediately.</source>
          <target state="translated">UDP - это протокол без установления соединения, поэтому сокеты UDP не должны явно вызывать процедуру &lt;code&gt;connect&lt;/code&gt; . Они могут просто немедленно начать отправку данных.</target>
        </trans-unit>
        <trans-unit id="9248393d371f6ac0d6c435085d705c597add4700" translate="yes" xml:space="preserve">
          <source>UNIX domain socket.</source>
          <target state="translated">гнездо домена UNIX.</target>
        </trans-unit>
        <trans-unit id="5994d61577cd9a76d59a20c617c73875837d1477" translate="yes" xml:space="preserve">
          <source>UNIX specific</source>
          <target state="translated">специфика UNIX</target>
        </trans-unit>
        <trans-unit id="26c859ee3fb5d4d62e0efa2847233766e5ddaefc" translate="yes" xml:space="preserve">
          <source>URL Safe Base64</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08be76278172f212466b4e4efbc9f3b81608c450" translate="yes" xml:space="preserve">
          <source>Un-necessary allocations are avoided and appropriate algorithms are used at the expense of code clarity when justified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b518ac79c337e4bc96c2923b9da28064822828b" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;+&lt;/code&gt; operator for an integer. Has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b171ced91159e0a196e56ce77416b733c4e754c" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;-&lt;/code&gt; operator for an integer. Negates &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b8776f6733aef4d62e2f6de4be839fb81aa572" translate="yes" xml:space="preserve">
          <source>Unary &lt;em&gt;+&lt;/em&gt; operator for an integer. Has no effect.</source>
          <target state="translated">Унарный оператор &lt;em&gt;+&lt;/em&gt; для целого числа. Не действует.</target>
        </trans-unit>
        <trans-unit id="eb73268790c9b1bb4d1863a2400ec7e0bd4b9f82" translate="yes" xml:space="preserve">
          <source>Unary &lt;em&gt;-&lt;/em&gt; operator for an integer. Negates &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Унарный &lt;em&gt;-&lt;/em&gt; оператор для целого числа. Отрицает &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f2efdf3396f6406dd06e7f15768f255977acfd0a" translate="yes" xml:space="preserve">
          <source>Unary &lt;span id=&quot;slice_2&quot;&gt;slice&lt;/span&gt; operator that constructs an interval &lt;code&gt;[default(int), b]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70afc8908f864590618bb835ddbe12b01425b489" translate="yes" xml:space="preserve">
          <source>Unary minus for complex numbers.</source>
          <target state="translated">Унарный минус для комплексных чисел.</target>
        </trans-unit>
        <trans-unit id="2b26f2db358e2b9c8ee6c1ec77a16447b17be07f" translate="yes" xml:space="preserve">
          <source>Unary minus for rational numbers.</source>
          <target state="translated">Унарный минус для рациональных чисел.</target>
        </trans-unit>
        <trans-unit id="26886835eb6cc81330ad426b552f908727e34bfa" translate="yes" xml:space="preserve">
          <source>Unary operators always bind stronger than any binary operator: &lt;code&gt;$a + b&lt;/code&gt; is &lt;code&gt;($a) + b&lt;/code&gt; and not &lt;code&gt;$(a + b)&lt;/code&gt;.</source>
          <target state="translated">Унарные операторы всегда связываются сильнее, чем любой бинарный оператор: &lt;code&gt;$a + b&lt;/code&gt; равно &lt;code&gt;($a) + b&lt;/code&gt; а не &lt;code&gt;$(a + b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1b9627be7abe82c7754c81d7b9ac180e552d8f7" translate="yes" xml:space="preserve">
          <source>Unbound static params will be inferred from expressions involving the &lt;code&gt;==&lt;/code&gt; operator and also when types dependent on them are being matched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15caf31c9aaa57bf878b33c847d4e21c87bdd599" translate="yes" xml:space="preserve">
          <source>Unbound static params will be inferred from expressions involving the &lt;em&gt;==&lt;/em&gt; operator and also when types dependent on them are being matched:</source>
          <target state="translated">Несвязанные статические параметры будут выведены из выражений, включающих оператор &lt;em&gt;==,&lt;/em&gt; а также при сопоставлении типов, зависящих от них:</target>
        </trans-unit>
        <trans-unit id="8c3eeb69afc01f369c316019c678b4ba126d3679" translate="yes" xml:space="preserve">
          <source>Unbound types can appear both as params to calls such as &lt;code&gt;s.push(T)&lt;/code&gt; and on the right-hand side of the &lt;code&gt;is&lt;/code&gt; operator in cases such as &lt;code&gt;x.pop is T&lt;/code&gt; and &lt;code&gt;x.data is seq[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb24ca63e88421d2f543a770d935d8deff96d75" translate="yes" xml:space="preserve">
          <source>Unbound types can appear both as params to calls such as &lt;em&gt;s.push(T)&lt;/em&gt; and on the right-hand side of the &lt;code&gt;is&lt;/code&gt; operator in cases such as &lt;em&gt;x.pop is T&lt;/em&gt; and &lt;em&gt;x.data is seq[T]&lt;/em&gt;.</source>
          <target state="translated">Несвязанные типы могут появляться как в параметрах таких вызовов, как &lt;em&gt;s.push (T), так&lt;/em&gt; и в правой части оператора &lt;code&gt;is&lt;/code&gt; в таких случаях, как &lt;em&gt;x.pop is T&lt;/em&gt; и &lt;em&gt;x.data is seq [T]&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5c3ed69a126746aabd63e358344911c553469b30" translate="yes" xml:space="preserve">
          <source>Unchecked arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a277ebe87b91b0033079926c198a2b95dd5a89ed" translate="yes" xml:space="preserve">
          <source>Unchecked pragma</source>
          <target state="translated">бесконтрольная прагма</target>
        </trans-unit>
        <trans-unit id="780b27a9e0cd026ae3df440893ad4cc13c021cef" translate="yes" xml:space="preserve">
          <source>Under Windows, &lt;code&gt;ShellExecute&lt;/code&gt; is used. Under Mac OS X the &lt;code&gt;open&lt;/code&gt; command is used. Under Unix, it is checked if &lt;code&gt;xdg-open&lt;/code&gt; exists and used if it does. Otherwise the environment variable &lt;code&gt;BROWSER&lt;/code&gt; is used to determine the default browser to use.</source>
          <target state="translated">Под Windows используется &lt;code&gt;ShellExecute&lt;/code&gt; . В Mac OS X используется команда &lt;code&gt;open&lt;/code&gt; . В Unix проверяется, существует ли &lt;code&gt;xdg-open&lt;/code&gt; , и используется ли он. В противном случае переменная среды &lt;code&gt;BROWSER&lt;/code&gt; используется для определения используемого браузера по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b4e16afd830482ab436e6b9d76d2fcedf615298d" translate="yes" xml:space="preserve">
          <source>Under the &lt;code&gt;--gc:arc|orc&lt;/code&gt; modes Nim's &lt;code&gt;ref&lt;/code&gt; type is implemented via the same runtime &quot;hooks&quot; and thus via reference counting. This means that cyclic structures cannot be freed immediately (&lt;code&gt;--gc:orc&lt;/code&gt; ships with a cycle collector). With the &lt;code&gt;.cursor&lt;/code&gt; annotation one can break up cycles declaratively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbf8b89716eab57348a639af00765efe9e3f101" translate="yes" xml:space="preserve">
          <source>Underflow: operation produces a result that is too small to be represented as a normal number, for example, MINDOUBLE * MINDOUBLE.</source>
          <target state="translated">Underflow:операция дает результат,который слишком мал,чтобы быть представленным как обычное число,например,MINDOUBLE*MINDOUBLE.</target>
        </trans-unit>
        <trans-unit id="58ba826c45dce7d957937f1e6f84d4a93f7c990b" translate="yes" xml:space="preserve">
          <source>Unequals operator. This is a shorthand for &lt;code&gt;not (x == y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e18949943f1b3a53df4651c7816095f5de22eef" translate="yes" xml:space="preserve">
          <source>Unescapes a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec38b8f74e8905e6cb3c56b8e4d8603f3e7c7d9" translate="yes" xml:space="preserve">
          <source>Unescapes a string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Отменяет экранирование строки &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b681f3dab8eeb99f700c878d07af066931b521" translate="yes" xml:space="preserve">
          <source>Unfortunately optimizations are hard to get right and even the tiny example is &lt;strong&gt;wrong&lt;/strong&gt;:</source>
          <target state="translated">К сожалению, оптимизировать сложно, и даже крошечный пример &lt;strong&gt;неверен&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="979fe2a9e37e36b1d1a6a4517ab5b601b5d48fdb" translate="yes" xml:space="preserve">
          <source>Unfortunately the semantics of the try statement may not always be correct, and occasionally the compilation may fail altogether. As such it is better to use the former style when possible.</source>
          <target state="translated">К сожалению,семантика оператора try не всегда может быть правильной,и иногда компиляция может совсем не удаться.Поэтому лучше использовать прежний стиль,когда это возможно.</target>
        </trans-unit>
        <trans-unit id="fab317435de1ae8699f1bac973f0926492ea1744" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;d + 12.Dollar&lt;/code&gt; is not allowed either, because &lt;code&gt;+&lt;/code&gt; is defined for &lt;code&gt;int&lt;/code&gt; (among others), not for &lt;code&gt;Dollar&lt;/code&gt;. So a &lt;code&gt;+&lt;/code&gt; for dollars needs to be defined:</source>
          <target state="translated">К сожалению, &lt;code&gt;d + 12.Dollar&lt;/code&gt; не допускается, потому что &lt;code&gt;+&lt;/code&gt; определен для &lt;code&gt;int&lt;/code&gt; (среди прочих), а не для &lt;code&gt;Dollar&lt;/code&gt; . Итак, необходимо определить &lt;code&gt;+&lt;/code&gt; для долларов:</target>
        </trans-unit>
        <trans-unit id="257828b764d9609e93e07a012bbe1f755b3e4143" translate="yes" xml:space="preserve">
          <source>Unicast link-local address.</source>
          <target state="translated">Одноадресная ссылка-локальный адрес.</target>
        </trans-unit>
        <trans-unit id="db89ced902c1b469d3ee6d37350cad15573da1b7" translate="yes" xml:space="preserve">
          <source>Unicast site-local address.</source>
          <target state="translated">Юникастский местный адрес.</target>
        </trans-unit>
        <trans-unit id="bad1fc2425affd686a4928faa36042363958ccf7" translate="yes" xml:space="preserve">
          <source>Unicode combining characters are correctly interpreted as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3781765e85fd98bc0b743ec878930ad45c9936e" translate="yes" xml:space="preserve">
          <source>Uniform Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20432d22d5eb062ea9c2106c1c80aefa6d897164" translate="yes" xml:space="preserve">
          <source>Unindents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">Unindents каждой строки в &lt;code&gt;s&lt;/code&gt; помощью &lt;code&gt;count&lt;/code&gt; количества &lt;code&gt;padding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c52400f9c64e17163dee3359a107d4513be811c2" translate="yes" xml:space="preserve">
          <source>Unindents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;. The only difference between this and the &lt;a href=&quot;#unindent,string,Natural,string&quot;&gt;unindent proc&lt;/a&gt; is that this by default only cuts off the amount of indentation that all lines of &lt;code&gt;s&lt;/code&gt; share as opposed to all indentation. It only supports spaces as padding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="924d62607597504901be1ad3edea9517a5c76a1f" translate="yes" xml:space="preserve">
          <source>Union pragma</source>
          <target state="translated">Союзное прагматизм</target>
        </trans-unit>
        <trans-unit id="74c7db218dedd779b36f1a6025b0a8e82da0f838" translate="yes" xml:space="preserve">
          <source>Unix Socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa0003b8a6b26c8afe5d3f50a8127082e93fdb8" translate="yes" xml:space="preserve">
          <source>Unknown file type.</source>
          <target state="translated">Неизвестный тип файла.</target>
        </trans-unit>
        <trans-unit id="5d54b46bfaf14d75428528167ddeece95ff7879d" translate="yes" xml:space="preserve">
          <source>UnknownLockLevel:</source>
          <target state="translated">UnknownLockLevel:</target>
        </trans-unit>
        <trans-unit id="166ac37560cdd4598d06f97eb16234b6f79cecbb" translate="yes" xml:space="preserve">
          <source>Unless marked with the &lt;code&gt;{.pure.}&lt;/code&gt; pragma, members of enums should have an identifying prefix, such as an abbreviation of the enum's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d54b69a2b42e57628182cdd2fb4ccd4dc4e49e" translate="yes" xml:space="preserve">
          <source>Unless marked with the &lt;em&gt;{.pure.}&lt;/em&gt; pragma, members of enums should have an identifying prefix, such as an abbreviation of the enum's name.</source>
          <target state="translated">Если члены перечислений не отмечены &lt;em&gt;прагмой {.pure.}&lt;/em&gt; , Они должны иметь идентифицирующий префикс, например аббревиатуру имени перечисления.</target>
        </trans-unit>
        <trans-unit id="c77cfc5cfbe4717f5e7654df9d751e7a64ef661c" translate="yes" xml:space="preserve">
          <source>Unless you are implementing a custom logger, there is little need to call this directly. Use either a logger's log method or one of the logging templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1db02d8fefccbf077d86e2884c344faded7045" translate="yes" xml:space="preserve">
          <source>Unless you explicitly use the &lt;code&gt;-o:filename.js&lt;/code&gt; switch as mentioned in the previous examples, the compiler will create a &lt;code&gt;filename.js&lt;/code&gt; file in the &lt;code&gt;nimcache&lt;/code&gt; directory using the name of your input nim file. There are no other temporary files generated, the output is always a single self contained &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Если вы явно не используете переключатель &lt;code&gt;-o:filename.js&lt;/code&gt; , как упоминалось в предыдущих примерах, компилятор создаст файл &lt;code&gt;filename.js&lt;/code&gt; в каталоге &lt;code&gt;nimcache&lt;/code&gt; , используя имя вашего входного файла nim. Других временных файлов не создается, на выходе всегда получается один самодостаточный файл &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="555ac3aebe10e2203997f49b6308860e82f3cf38" translate="yes" xml:space="preserve">
          <source>Unless your application has very specific requirements and solely targets JavaScript, you should be using the relevant functions in the &lt;code&gt;math&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, and &lt;code&gt;times&lt;/code&gt; stdlib modules instead.</source>
          <target state="translated">Если ваше приложение не имеет очень специфических требований и ориентировано исключительно на JavaScript, вам следует использовать соответствующие функции в модулях &lt;code&gt;math&lt;/code&gt; , &lt;code&gt;json&lt;/code&gt; и &lt;code&gt;times&lt;/code&gt; stdlib.</target>
        </trans-unit>
        <trans-unit id="0c8a103bee5df59c3c762061b4c9d13541d1ab2e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, this function will not raise an exception if the Future has not been finished.</source>
          <target state="translated">В отличие от &lt;code&gt;read&lt;/code&gt; , эта функция не вызовет исключения, если Future не завершена.</target>
        </trans-unit>
        <trans-unit id="86d3c06510e1a9b072a372d11ed5099a19477622" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;sockets.recvLine&lt;/code&gt; this function will raise an EOS or ESSL exception if an error occurs.</source>
          <target state="translated">В отличие от &lt;code&gt;sockets.recvLine&lt;/code&gt; эта функция вызовет исключение EOS или ESSL в случае возникновения ошибки.</target>
        </trans-unit>
        <trans-unit id="e750c92c37341f3392054d626734256f8a0787c9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt; in C, if your binary was called without parameters this will return zero. You can query each individual paramater with &lt;a href=&quot;#paramStr&quot;&gt;paramStr()&lt;/a&gt; or retrieve all of them in one go with &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams()&lt;/a&gt;.</source>
          <target state="translated">В отличие от &lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt; в C, если ваш двоичный файл был вызван без параметров, он вернет ноль. Вы можете запросить каждый отдельный параметр с помощью &lt;a href=&quot;#paramStr&quot;&gt;paramStr ()&lt;/a&gt; или получить их все за один раз с помощью &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c9f5fc5648b91a0ecea42942dbf604af71e575e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt; in C, if your binary was called without parameters this will return zero. You can query each individual parameter with &lt;a href=&quot;#paramStr,int&quot;&gt;paramStr proc&lt;/a&gt; or retrieve all of them in one go with &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834e7e344f224920e087953eb402fca07a2f1f3c" translate="yes" xml:space="preserve">
          <source>Unlike other IO operations this is guaranteed to be thread-safe as &lt;code&gt;echo&lt;/code&gt; is very often used for debugging convenience. If you want to use &lt;code&gt;echo&lt;/code&gt; inside a &lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;proc without side effects&lt;/a&gt; you can use &lt;a href=&quot;#debugEcho&quot;&gt;debugEcho&lt;/a&gt; instead.</source>
          <target state="translated">В отличие от других операций ввода-вывода, это гарантированно поточно-ориентированное, поскольку &lt;code&gt;echo&lt;/code&gt; очень часто используется для удобства отладки. Если вы хотите использовать &lt;code&gt;echo&lt;/code&gt; внутри процедуры &lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;без побочных эффектов,&lt;/a&gt; вы можете вместо этого использовать &lt;a href=&quot;#debugEcho&quot;&gt;debugEcho&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb1d8697e6f5b8b93bcc0fbb54b7a52aa6ab9c41" translate="yes" xml:space="preserve">
          <source>Unlike other IO operations this is guaranteed to be thread-safe as &lt;code&gt;echo&lt;/code&gt; is very often used for debugging convenience. If you want to use &lt;code&gt;echo&lt;/code&gt; inside a &lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;proc without side effects&lt;/a&gt; you can use &lt;a href=&quot;#debugEcho,varargs%5Btyped,%5D&quot;&gt;debugEcho&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a7eb1335a4c8a4d13042f64d4169aab404e95e" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;#all,openArray%5BT%5D,proc(T)&quot;&gt;all proc&lt;/a&gt;, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;allIt(&quot;abba&quot;, it == 'a')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b25e1135d73b4979029b11d846cffe0d4e62bc0" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;#any,openArray%5BT%5D,proc(T)&quot;&gt;any proc&lt;/a&gt;, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;anyIt(&quot;abba&quot;, it == 'a')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df788be57d38cfdfe8e607fa4cc3da35094447d" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;#filter,openArray%5BT%5D,proc(T)&quot;&gt;filter proc&lt;/a&gt; and &lt;a href=&quot;#filter.i,openArray%5BT%5D,proc(T)&quot;&gt;filter iterator&lt;/a&gt;, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dffcac06d6078b88787893047caf056ddba47e3" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;#keepIf,seq%5BT%5D,proc(T)&quot;&gt;keepIf proc&lt;/a&gt;, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22870d2d3c9ed068f87598a420f675c1914b8e0c" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;em&gt;proc&lt;/em&gt; version, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="translated">В отличие от версии &lt;em&gt;proc&lt;/em&gt; , предикат должен быть выражением с использованием переменной &lt;code&gt;it&lt;/code&gt; для тестирования, например: &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7abf83a8fb810b07df5666c0186be330c1d74dbb" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;em&gt;proc&lt;/em&gt; version, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="translated">В отличие от версии &lt;em&gt;proc&lt;/em&gt; , предикат должен быть выражением с использованием переменной &lt;code&gt;it&lt;/code&gt; для тестирования, например: &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea70e7b2b434633b0b06e23b1f895b37ed910c3" translate="yes" xml:space="preserve">
          <source>Unlock pages starting from a1 for a1 bytes and allow them to be swapped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1220ad1301b65c81ce9bc7668e60651b0a6e0b98" translate="yes" xml:space="preserve">
          <source>Unlocks all memory for the running process to allow swapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6fecd7c098d4594a31a6bfb718661e5d0021b5" translate="yes" xml:space="preserve">
          <source>Unmarshalling</source>
          <target state="translated">Unmarshalling</target>
        </trans-unit>
        <trans-unit id="e21aec3b4730e3f9365e0105b5ee932445d7a6ca" translate="yes" xml:space="preserve">
          <source>Unmarshalling JSON into a type</source>
          <target state="translated">Неназначение JSON на тип</target>
        </trans-unit>
        <trans-unit id="00c3031c922055e41a04fe1f36e44c0871affcd9" translate="yes" xml:space="preserve">
          <source>Unnamed procedures can be used as lambda expressions to pass into other procedures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274fd6abb97e41f164eb1ef8fe9181521b3bcfb9" translate="yes" xml:space="preserve">
          <source>Unregisters &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">Отменяет регистрацию &lt;code&gt;fd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc5d6ca9aa56c6378bdd4192beb1a23d43d8436b" translate="yes" xml:space="preserve">
          <source>Unregisters deleg &lt;code&gt;deleg&lt;/code&gt; from dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Отменяет регистрацию &lt;code&gt;deleg&lt;/code&gt; от диспетчера &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da32f8ccff4f9629c24e55368ee80c187804e943" translate="yes" xml:space="preserve">
          <source>Unregisters event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">Отменяет регистрацию события &lt;code&gt;ev&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcde071a887a5fe31b2a030c3e5fa7b13b8951b5" translate="yes" xml:space="preserve">
          <source>Unregisters file/socket descriptor &lt;code&gt;fd&lt;/code&gt; from selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Отменяет регистрацию дескриптора файла / сокета &lt;code&gt;fd&lt;/code&gt; из селектора &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="289ac9aad529193af73566b90baf875386cf6586" translate="yes" xml:space="preserve">
          <source>Unregisters user-defined event &lt;code&gt;ev&lt;/code&gt; from selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Отменяет регистрацию определенного пользователем события &lt;code&gt;ev&lt;/code&gt; из селектора &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ef917446c92814f3fe225d448c9dd016899c48e" translate="yes" xml:space="preserve">
          <source>Unsigned 16 bit integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed468bf679e5b1f5808790c2a19e95d512a2b2a8" translate="yes" xml:space="preserve">
          <source>Unsigned 32 bit integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d7e382d3bf439812e3803ec8a443a454d1726f" translate="yes" xml:space="preserve">
          <source>Unsigned 64 bit integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b11a7b01485a2c63525c49dc3fe966f7bea903" translate="yes" xml:space="preserve">
          <source>Unsigned 8 bit integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97fa8d5ff01f95267b94caf79b8f3070f72dfcf" translate="yes" xml:space="preserve">
          <source>Unsigned default integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce62d653fe1244a4a172cf34cf9ff901d873cb95" translate="yes" xml:space="preserve">
          <source>Unsigned operations all wrap around; they cannot lead to over- or under-flow errors.</source>
          <target state="translated">Беззнаковые операции обертываются вокруг пальца,они не могут привести к ошибкам переполнения или недополнения.</target>
        </trans-unit>
        <trans-unit id="793e97a099a191f13d3623cc72e9fcc4ea98314f" translate="yes" xml:space="preserve">
          <source>Unspecified address.</source>
          <target state="translated">Неопределенный адрес.</target>
        </trans-unit>
        <trans-unit id="5c457d2272b8e63c2b91ba916ee48f5876df5664" translate="yes" xml:space="preserve">
          <source>UnspecifiedLockLevel:</source>
          <target state="translated">UnspecifiedLockLevel:</target>
        </trans-unit>
        <trans-unit id="ed961fcd4c8176dc450c49284ace2318f446a007" translate="yes" xml:space="preserve">
          <source>Unstable API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6076c17bc49c0e24e74221d46dcde766430db135" translate="yes" xml:space="preserve">
          <source>Unstable API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ad21855bb503556f8c5a04db8667a68253a7e7" translate="yes" xml:space="preserve">
          <source>Untyped base class for &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2eed1f531c71d473a16fbfc4bdc992980d7fde4" translate="yes" xml:space="preserve">
          <source>Untyped future.</source>
          <target state="translated">Неопределенное будущее.</target>
        </trans-unit>
        <trans-unit id="338a06f904b267724d0e4a6607e91229e8bd5122" translate="yes" xml:space="preserve">
          <source>Unused symbols in the code.</source>
          <target state="translated">Неиспользованные символы в коде.</target>
        </trans-unit>
        <trans-unit id="b761e5e6e2982b87d1d1ce7451421af2e056fcdd" translate="yes" xml:space="preserve">
          <source>Update file/socket descriptor &lt;code&gt;fd&lt;/code&gt;, registered in selector &lt;code&gt;s&lt;/code&gt; with new events set &lt;code&gt;event&lt;/code&gt;.</source>
          <target state="translated">Обновить дескриптор файла / сокета &lt;code&gt;fd&lt;/code&gt; , зарегистрированный в селекторе &lt;code&gt;s&lt;/code&gt; , с новым &lt;code&gt;event&lt;/code&gt; набора событий .</target>
        </trans-unit>
        <trans-unit id="42cfa979c0a47064ebf21099c1cc012f9b61f497" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;MD5Context&lt;/code&gt; with the &lt;code&gt;input&lt;/code&gt; data of length &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ac74192ba332a2e96c10e6e3a98aa5ef90a38c" translate="yes" xml:space="preserve">
          <source>Uploading a new file</source>
          <target state="translated">Загрузка нового файла</target>
        </trans-unit>
        <trans-unit id="8437e83622dcd6616eee43bc0f900abcc44066bc" translate="yes" xml:space="preserve">
          <source>Uploads &lt;code&gt;file&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt; on the remote FTP server. Usage of this function asynchronously is recommended to view the progress of the download. The &lt;code&gt;EvStore&lt;/code&gt; event is passed to the specified &lt;code&gt;handleEvent&lt;/code&gt; function when the upload is finished, and the &lt;code&gt;filename&lt;/code&gt; field will be equal to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">Закачивает &lt;code&gt;file&lt;/code&gt; для &lt;code&gt;dest&lt;/code&gt; на удаленном сервере FTP. Рекомендуется использовать эту функцию в асинхронном режиме для просмотра хода загрузки. &lt;code&gt;EvStore&lt;/code&gt; событие передается указанной &lt;code&gt;handleEvent&lt;/code&gt; функции , когда загрузка будет завершена, и &lt;code&gt;filename&lt;/code&gt; поле будет равно &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="37b7ab0e221278f7b19c0e2120c647473f14e9c5" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;shallow&lt;/code&gt; is always safe once you know the string won't be modified anymore, similar to Ruby's &lt;span id=&quot;freeze_1&quot;&gt;freeze&lt;/span&gt;.</source>
          <target state="translated">Использование &lt;code&gt;shallow&lt;/code&gt; всегда безопасно, если вы знаете, что строка больше не будет изменяться, как в случае с &lt;span id=&quot;freeze_1&quot;&gt;зависанием&lt;/span&gt; в Ruby .</target>
        </trans-unit>
        <trans-unit id="6529bc139872e1326ba28cf98763fb25162be0ed" translate="yes" xml:space="preserve">
          <source>Usage with custom object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="da1aeb06d30b6fb8ade7df07c4d3ac7287c9a066" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#%5B%5D=,OrderedTable%5BA,B%5D,A,B&quot;&gt;[]= proc&lt;/a&gt; for inserting a new (key, value) pair in the table without introducing duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b385b14640b269bd61b970e50ca557ba55241410" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#%5B%5D=,OrderedTableRef%5BA,B%5D,A,B&quot;&gt;[]= proc&lt;/a&gt; for inserting a new (key, value) pair in the table without introducing duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e49ab6964399f7deaf92634bcdb57677aacec05" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#%5B%5D=,Table%5BA,B%5D,A,B&quot;&gt;[]= proc&lt;/a&gt; for inserting a new (key, value) pair in the table without introducing duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db4d600ebdba4cdb503933887336a61072892ee" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#%5B%5D=,TableRef%5BA,B%5D,A,B&quot;&gt;[]= proc&lt;/a&gt; for inserting a new (key, value) pair in the table without introducing duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d04b7b8c1cf86ab3106c3b5d5f17672b7a6b5fb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init proc&lt;/a&gt; or &lt;a href=&quot;#initHashSet,int&quot;&gt;initHashSet proc&lt;/a&gt; before calling other procs on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50c56f66708798022fbc1f1eb983ee9aeeb0b23" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; or &lt;a href=&quot;#initSet&quot;&gt;initSet[type]()&lt;/a&gt; before calling other procs on it.</source>
          <target state="translated">Используйте &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init ()&lt;/a&gt; или &lt;a href=&quot;#initSet&quot;&gt;initSet [type] ()&lt;/a&gt; перед вызовом других процедур для него.</target>
        </trans-unit>
        <trans-unit id="b9fe7a018967570be7ed52bffde1f973e6d871c2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init proc&lt;/a&gt; or &lt;a href=&quot;#initOrderedSet,int&quot;&gt;initOrderedSet proc&lt;/a&gt; before calling other procs on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b9c2cf3847d0d4137fb09319498c7a48280b4c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; or &lt;a href=&quot;#initOrderedSet&quot;&gt;initOrderedSet[type]()&lt;/a&gt; before calling other procs on it.</source>
          <target state="translated">Используйте &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init ()&lt;/a&gt; или &lt;a href=&quot;#initOrderedSet&quot;&gt;initOrderedSet [type] ()&lt;/a&gt; перед вызовом других процедур для него.</target>
        </trans-unit>
        <trans-unit id="87bb73511d0e9c5ae418b5d251233153dc842135" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#initDoublyLinkedList&quot;&gt;initDoublyLinkedList proc&lt;/a&gt; to create a new empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f182f9fe3cac0d41eb40bd94d58261ee8713fd3e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#initDoublyLinkedRing&quot;&gt;initDoublyLinkedRing proc&lt;/a&gt; to create a new empty ring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38b42887b1698bc1c4d8fcb3ff2cca4489eb861" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#initSinglyLinkedList&quot;&gt;initSinglyLinkedList proc&lt;/a&gt; to create a new empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03415c75219325917b792cada407fd71875afc67" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#initSinglyLinkedRing&quot;&gt;initSinglyLinkedRing proc&lt;/a&gt; to create a new empty ring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e3b878759b63e84ae32bbb1966962476e9a602" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#newXmlTree,string,openArray%5BXmlNode%5D,XmlAttributes&quot;&gt;newXmlTree proc&lt;/a&gt; for creating a new tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8808a38944ad2c6429fe6ee01b22a73933231013" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#toXmlAttributes,varargs%5Btuple%5Bstring,string%5D%5D&quot;&gt;toXmlAttributes proc&lt;/a&gt; to create &lt;code&gt;XmlAttributes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b04bfccbb051335b0b40343602f2f7a1105be6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;os#createDir,string&quot;&gt;os.createDir()&lt;/a&gt; and similar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad60fd229e0a543ae8f2a0fedd46081297abc08d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;#!/usr/bin/env -S nim --hints:off&lt;/code&gt; to disable hints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9918d6dedfaffdd4e2a4d97f4660d314efeecf3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--cpu:i386&lt;/code&gt; or &lt;code&gt;--cpu:amd64&lt;/code&gt; to switch the CPU architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c400bb7ca317cc76e65e260f6f0a40d428a811" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;nim c -c --cpu:arm --os:android -d:androidNDK --noMain:on&lt;/code&gt; to generate the C source files you need to include in your Android Studio project. Add the generated C files to CMake build script in your Android project. Then do the final compile with Android Studio which uses Gradle to call CMake to compile the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638e8ddcafcc7f4e68eb97d0d0f10fc49acd170f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;nim c -c --os:ios --noMain:on&lt;/code&gt; to generate C files and include them in your XCode project. Then you can use XCode to compile, link, package and sign everything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9ac410d33d9a91a19e2694390cd157758427bf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;openChar&lt;/code&gt; instead of '{' and &lt;code&gt;closeChar&lt;/code&gt; instead of '}'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96634ba03db12a7ee8aeb6e65e274aa872380712" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;subjectVerb&lt;/code&gt;, not &lt;code&gt;verbSubject&lt;/code&gt;, e.g.: &lt;code&gt;fileExists&lt;/code&gt;, not &lt;code&gt;existsFile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069c6a70b51730b216fe49517948e5c25ee3f68d" translate="yes" xml:space="preserve">
          <source>Use CamelCase, not underscored_identifiers.</source>
          <target state="translated">Используйте CamelCase,а не подчеркнутые идентификаторы.</target>
        </trans-unit>
        <trans-unit id="c0419552b8b43316dc697b19a811e19aebbdcdf2" translate="yes" xml:space="preserve">
          <source>Use a proc when possible, only using the more powerful facilities of macros, templates, iterators, and converters when necessary.</source>
          <target state="translated">Используйте proc,когда это возможно,только используя более мощные средства макросов,шаблонов,итераторов и преобразователей,когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="ee29cb81b4a1c27e3913f57892fcf63971ad6672" translate="yes" xml:space="preserve">
          <source>Use a space after a colon, but not before it.</source>
          <target state="translated">Используйте пространство после двоеточия,но не перед ним.</target>
        </trans-unit>
        <trans-unit id="91c6843062b7105452ce869cb5ff5806e5657240" translate="yes" xml:space="preserve">
          <source>Use an &lt;a href=&quot;#OptParser&quot;&gt;OptParser&lt;/a&gt; to parse command line options. It can be created with &lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser&lt;/a&gt;, and &lt;a href=&quot;#next,OptParser&quot;&gt;next&lt;/a&gt; advances the parser by one token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eaeb50702c4af6019f309c53108d48c5e121d67" translate="yes" xml:space="preserve">
          <source>Use an ordinary proc/iterator, if possible.</source>
          <target state="translated">По возможности используйте обычный прокурор/литератор.</target>
        </trans-unit>
        <trans-unit id="b8b595f99133340d0138766361433ada7a9e184d" translate="yes" xml:space="preserve">
          <source>Use bundled setjmp implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6821b710e595e256c74f90ecbec64f90226d87" translate="yes" xml:space="preserve">
          <source>Use native debugger (gdb)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d611bbc294e217a815cb04d3fa29d3d30b810658" translate="yes" xml:space="preserve">
          <source>Use regular &lt;code&gt;nim c&lt;/code&gt; inside termux to make Android terminal programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18016a67bd4f948da9845d49f07cb8371b4ab483" translate="yes" xml:space="preserve">
          <source>Use setjmp backend.</source>
          <target state="translated">Используйте бэкэнд Сетджем.</target>
        </trans-unit>
        <trans-unit id="f72ae5e3053e46a037835089c157a676efe9253b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;let&lt;/code&gt; statement (not the &lt;code&gt;var&lt;/code&gt; statement) when declaring variables that do not change within their scope. Using the &lt;code&gt;let&lt;/code&gt; statement ensures that variables remain immutable, and gives those who read the code a better idea of the code's purpose.</source>
          <target state="translated">Используйте оператор &lt;code&gt;let&lt;/code&gt; (не оператор &lt;code&gt;var&lt;/code&gt; ) при объявлении переменных, которые не изменяются в пределах своей области видимости. Использование оператора &lt;code&gt;let&lt;/code&gt; гарантирует, что переменные остаются неизменными, и дает тем, кто читает код, лучшее представление о цели кода.</target>
        </trans-unit>
        <trans-unit id="66274d10986776dc87f06f202d0f3cb8c3fe3937" translate="yes" xml:space="preserve">
          <source>Use the linenoise library for interactive mode (not needed on Windows).</source>
          <target state="translated">Используйте библиотеку линенуаза для интерактивного режима (не требуется на Windows).</target>
        </trans-unit>
        <trans-unit id="fa6549bd6999bce5cb0be51276ff5b08c60300d9" translate="yes" xml:space="preserve">
          <source>Use this if you want to use asyncio's dispatcher.</source>
          <target state="translated">Используй это,если хочешь использовать диспетчера Асинсио.</target>
        </trans-unit>
        <trans-unit id="4532086f3654531ca15b50c1e47098b39b985e32" translate="yes" xml:space="preserve">
          <source>Use this instead of &lt;code&gt;=&lt;/code&gt; for a &lt;span id=&quot;shallow-copy_1&quot;&gt;shallow copy&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cf95979f5d27ec020c489b4e3794d91e84592b" translate="yes" xml:space="preserve">
          <source>Use this on documentation name nodes to extract the &lt;em&gt;raw&lt;/em&gt; symbol name, without decorations, parameters, or anything. That can be used as the base for the HTML hyperlinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc79ccd7635f50d22e57841cdbe2adc22f78a697" translate="yes" xml:space="preserve">
          <source>Use this overload if one of the enums specified above does not contain what you need.</source>
          <target state="translated">Используйте эту перегрузку,если одно из перечислений,указанных выше,не содержит того,что вам нужно.</target>
        </trans-unit>
        <trans-unit id="865aa831216ca96d4d105c4dd19b7daa3f190a58" translate="yes" xml:space="preserve">
          <source>Use this proc to determine quickly if a 'spawn' or a direct call is preferable. If it returns 'true' a 'spawn' may make sense. In general it is not necessary to call this directly; use 'spawnX' instead.</source>
          <target state="translated">Используйте этот промежуток времени,чтобы быстро определить,предпочтительнее ли &quot;икра&quot; или прямой вызов.Если он вернет &quot;правду&quot;,то &quot;нерест&quot; может иметь смысл.Обычно нет необходимости называть это напрямую;вместо этого используйте 'spawnX'.</target>
        </trans-unit>
        <trans-unit id="2ffaf615de7e722de9c61894288fe41edf0bc0e9" translate="yes" xml:space="preserve">
          <source>Use this proc to determine quickly if a &lt;code&gt;spawn&lt;/code&gt; or a direct call is preferable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bc2b4499c7c25fe666bf75531910175755c00e" translate="yes" xml:space="preserve">
          <source>Use uClibc instead of libc. (Relevant for Unix-like OSes)</source>
          <target state="translated">Используйте uClibc вместо libc.(Это актуально для Unix-подобных ОС).</target>
        </trans-unit>
        <trans-unit id="5f211d2e480794537e3020e2cfb5c46539ca8d42" translate="yes" xml:space="preserve">
          <source>Use ucontext backend.</source>
          <target state="translated">Используй контекстный бэкэнд.</target>
        </trans-unit>
        <trans-unit id="9e128770cbe82e55e9551991395c199aea047021" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;asynchttpserver&lt;/code&gt; and &lt;code&gt;httpclient&lt;/code&gt; internally and should not be used by you.</source>
          <target state="translated">Используется &lt;code&gt;asynchttpserver&lt;/code&gt; и &lt;code&gt;httpclient&lt;/code&gt; и не должен использоваться вами.</target>
        </trans-unit>
        <trans-unit id="e1eb04a34bb0de21c4be629b42f0c67166e892ed" translate="yes" xml:space="preserve">
          <source>Used if you have a table with duplicate keys (as a result of using &lt;a href=&quot;#add,Table%5BA,B%5D,A,B&quot;&gt;add proc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8732bc6e9c0c3e17ad4cc39e7b18e2c8e01853" translate="yes" xml:space="preserve">
          <source>Used in scanp for the matching of atoms (usually chars).</source>
          <target state="translated">Используется в scanp для сопоставления атомов (обычно chars).</target>
        </trans-unit>
        <trans-unit id="9a86ce7ff320140dd835db0e2950bd610e5a8508" translate="yes" xml:space="preserve">
          <source>Used in scanp for the matching of atoms (usually chars). EOF is matched as &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7afe7ce396a5c489b0063645153c095dbf7fc11e" translate="yes" xml:space="preserve">
          <source>Used internally by the &lt;a href=&quot;#round,T,int&quot;&gt;round proc&lt;/a&gt; when the specified number of places is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a711f1f66f43620c76efb83f91a45bb11becf844" translate="yes" xml:space="preserve">
          <source>Used throughout the compiler code to test whether a type tree contains or doesn't contain a specific type/types - it is often the case that only the last child nodes of a type tree need to be searched. This is a really hot path within the compiler!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6504832c00269c338b88a50a90a3ced2d75595" translate="yes" xml:space="preserve">
          <source>Useful for &lt;code&gt;disarming&lt;/code&gt; dangling pointers explicitly for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150c36f24d07810f97e415f3dff1c4a4f82fb6da" translate="yes" xml:space="preserve">
          <source>Useful for creating &quot;2D&quot; sequences - sequences containing other sequences or to populate fields of the created sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02c3c02a1cba6f1b623a143ee4ff49577aeda10" translate="yes" xml:space="preserve">
          <source>Useful if performing parallel analysis of data series and need to re-combine parallel result sets</source>
          <target state="translated">Полезен при выполнении параллельного анализа рядов данных и необходимости перекомбинировать параллельные наборы результатов</target>
        </trans-unit>
        <trans-unit id="6287591a47bd6f7727cd724ffad351b20d4e6e8a" translate="yes" xml:space="preserve">
          <source>Useful when creating a closure in a loop to capture local loop variables by their current iteration values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51e8109e780dfdf6a418dbd0475739d284873d7" translate="yes" xml:space="preserve">
          <source>Useful when creating a closure in a loop to capture local loop variables by their current iteration values. Example:</source>
          <target state="translated">Полезно при создании замыкания в цикле для захвата локальных переменных цикла по их текущим значениям итераций.Пример:</target>
        </trans-unit>
        <trans-unit id="ffffb46bb26e51b2c63f7e473654047d3d1b549a" translate="yes" xml:space="preserve">
          <source>Useful when creating a closure in a loop to capture some local loop variables by their current iteration values. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="e62ab5dd60dc7797b971e6696b18be2c527a419c" translate="yes" xml:space="preserve">
          <source>User definable matchers</source>
          <target state="translated">определяемые пользователем матчи</target>
        </trans-unit>
        <trans-unit id="cdb81abb7fd49094ec59b4c3147077b637691ca6" translate="yes" xml:space="preserve">
          <source>User defined matcher. Uses the proc &lt;code&gt;foo&lt;/code&gt; to perform the match. See below for more details.</source>
          <target state="translated">Определенный пользователем сопоставитель. Использует proc &lt;code&gt;foo&lt;/code&gt; для сопоставления. Подробности смотрите ниже.</target>
        </trans-unit>
        <trans-unit id="b935fbc2614493a2c4b14ccf26901cbcb010eb56" translate="yes" xml:space="preserve">
          <source>User defined operators are allowed. Nothing stops you from defining your own &lt;code&gt;@!?+~&lt;/code&gt; operator, but doing so may reduce readability.</source>
          <target state="translated">Разрешены операторы, определяемые пользователем. Ничто не мешает вам определить собственный оператор &lt;code&gt;@!?+~&lt;/code&gt; , Но это может снизить удобочитаемость.</target>
        </trans-unit>
        <trans-unit id="fa8f45c91aea8077d8fc0d06a397a16ed0dc1c79" translate="yes" xml:space="preserve">
          <source>User-defined generic types may also be covariant with respect to some of their parameters. By default, all generic params are considered invariant, but you may choose the apply the prefix modifier &lt;code&gt;in&lt;/code&gt; to a parameter to make it contravariant or &lt;code&gt;out&lt;/code&gt; to make it covariant:</source>
          <target state="translated">Определяемые пользователем универсальные типы также могут быть ковариантными по некоторым своим параметрам. По умолчанию всей общая PARAMS считается инвариантным, но вы можете выбрать модификатор применить префикс &lt;code&gt;in&lt;/code&gt; параметру , чтобы сделать его контравариантным или &lt;code&gt;out&lt;/code&gt; , чтобы сделать его ковариантен:</target>
        </trans-unit>
        <trans-unit id="fe530b5d90cc0ff755c2c5978933fa9a5980a785" translate="yes" xml:space="preserve">
          <source>User-defined pragmas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce325aeace53a2b93d052357d730389323d4341" translate="yes" xml:space="preserve">
          <source>UserRaw</source>
          <target state="translated">UserRaw</target>
        </trans-unit>
        <trans-unit id="453171c4373884a1b140871f1519f0b7a2ce0a5f" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;default&lt;/code&gt; for an invalid value in &lt;code&gt;s&lt;/code&gt;. The comparison is done in a style insensitive way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d37885af11f22c8954936ebdddac6bdeacfbc6c" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;fn&lt;/code&gt; to mix the colors &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e300487a9b9ba07551dbd02395ad2f5ceb2cd7ff" translate="yes" xml:space="preserve">
          <source>Uses &lt;em&gt;default&lt;/em&gt; for an invalid value in &lt;em&gt;s&lt;/em&gt;. The comparison is done in a style insensitive way.</source>
          <target state="translated">Использует &lt;em&gt;значение&lt;/em&gt; по &lt;em&gt;умолчанию&lt;/em&gt; для недопустимого значения в &lt;em&gt;s&lt;/em&gt; . Сравнение выполняется без учета стиля.</target>
        </trans-unit>
        <trans-unit id="91247aefaea76611ed3be253ec73d5452247797e" translate="yes" xml:space="preserve">
          <source>Uses the state to compute a new &lt;code&gt;uint64&lt;/code&gt; random number.</source>
          <target state="translated">Использует состояние для вычисления нового случайного числа &lt;code&gt;uint64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82312a15160a4eb2e934bf4a7bfbfafc8e93262e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;from math as m import pow&lt;/code&gt; works identically to the &lt;code&gt;as&lt;/code&gt; modifier with the &lt;code&gt;import&lt;/code&gt; statement, but wrapped in &lt;code&gt;nnkFromStmt&lt;/code&gt;.</source>
          <target state="translated">Использование &lt;code&gt;from math as m import pow&lt;/code&gt; работает так же, &lt;code&gt;as&lt;/code&gt; модификатор as с оператором &lt;code&gt;import&lt;/code&gt; , но заключен в &lt;code&gt;nnkFromStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="434eb8681f8aae0fc0009510a5ce82ae4ac62f77" translate="yes" xml:space="preserve">
          <source>Using HTTP POST</source>
          <target state="translated">Использование HTTP POST</target>
        </trans-unit>
        <trans-unit id="ed0f47b1f4fe7cff5fa3f8cc793df2dd41f14561" translate="yes" xml:space="preserve">
          <source>Using Unix sockets instead of TCP connection can &lt;a href=&quot;https://momjian.us/main/blogs/pgblog/2012.html#June_6_2012&quot;&gt;improve performance up to 30% ~ 175% for some operations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597d5caf1abedf8be885d6b02a498c8313c21cab" translate="yes" xml:space="preserve">
          <source>Using an &lt;code&gt;enum&lt;/code&gt; is similar to using an &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="translated">Использование &lt;code&gt;enum&lt;/code&gt; аналогично использованию &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56bf266901cc02f50f464b5a26b067601243b007" translate="yes" xml:space="preserve">
          <source>Using default values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2077b1edc67aa09ddf48ed8fc866598362c96a" translate="yes" xml:space="preserve">
          <source>Using statement</source>
          <target state="translated">Использовать утверждение</target>
        </trans-unit>
        <trans-unit id="dfb7c6171f4d1e4bf5091b862fae5147fe7d176a" translate="yes" xml:space="preserve">
          <source>Usually it is advised to use &lt;a href=&quot;#spawn,typed&quot;&gt;spawn proc&lt;/a&gt; in order to not block the producer for an unknown amount of time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1d38117d85b7f952c74849e783f652c0d1186c" translate="yes" xml:space="preserve">
          <source>Usually it is not necessary to call this explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0ffb656f43cb27f5cdd45b79d0245f11508098" translate="yes" xml:space="preserve">
          <source>Usually the result of using the &lt;a href=&quot;#assert&quot;&gt;assert() template&lt;/a&gt;.</source>
          <target state="translated">Обычно результат использования &lt;a href=&quot;#assert&quot;&gt;шаблона assert ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="174b2645b450d09512ed8264a52d52439c1d6ecc" translate="yes" xml:space="preserve">
          <source>Usually the result of using the &lt;a href=&quot;assertions#assert.t,untyped,string&quot;&gt;assert() template&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b613dc5bf77d7eebd40398bbfcda8a848bcf8f" translate="yes" xml:space="preserve">
          <source>Usually to pass a block of code to a template the parameter that accepts the block needs to be of type &lt;code&gt;untyped&lt;/code&gt;. Because symbol lookups are then delayed until template instantiation time:</source>
          <target state="translated">Обычно для передачи блока кода в шаблон параметр, принимающий блок, должен иметь тип &lt;code&gt;untyped&lt;/code&gt; . Поскольку поиск символов затем откладывается до времени создания экземпляра шаблона:</target>
        </trans-unit>
        <trans-unit id="1926bc9218cc799324b71f0caa656e3d2180032c" translate="yes" xml:space="preserve">
          <source>Usually used via the &lt;code&gt;in&lt;/code&gt; operator. It is the equivalent of &lt;code&gt;deq.find(item) &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0e47d9fc2b0057aa59726a8d6d1ec706dd8492" translate="yes" xml:space="preserve">
          <source>VS Code only supports these three</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4056c9024148aba228496422c08fad4e874361b" translate="yes" xml:space="preserve">
          <source>VT:</source>
          <target state="translated">VT:</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="94caea3c7c64ca00d9ac21ea83a77703d0e697ae" translate="yes" xml:space="preserve">
          <source>Var parameters</source>
          <target state="translated">параметры Var</target>
        </trans-unit>
        <trans-unit id="f94fe3891ba9b2a70b6f7c93dcf19ff406473182" translate="yes" xml:space="preserve">
          <source>Var return type</source>
          <target state="translated">тип возврата Var</target>
        </trans-unit>
        <trans-unit id="ed0b2dfd47bbac896a3b7fa7c65e08461b5b0de0" translate="yes" xml:space="preserve">
          <source>Var section</source>
          <target state="translated">Вар-секция</target>
        </trans-unit>
        <trans-unit id="914863c14c6479013852278b1f8b3334db12b752" translate="yes" xml:space="preserve">
          <source>Var statement</source>
          <target state="translated">Варское заявление</target>
        </trans-unit>
        <trans-unit id="add491eaab149ea45f6c1fe0151b0684f58a9169" translate="yes" xml:space="preserve">
          <source>Var statements declare new local and global variables and initialize them. A comma separated list of variables can be used to specify variables of the same type:</source>
          <target state="translated">Var-операторы объявляют новые локальные и глобальные переменные и инициализируют их.Список переменных,разделенный запятыми,можно использовать для указания переменных одного типа:</target>
        </trans-unit>
        <trans-unit id="dc7189cf27aa01cb34bf0ab7fce27a6c539ba4e0" translate="yes" xml:space="preserve">
          <source>Var statements declare new local and global variables and initialize them. A comma-separated list of variables can be used to specify variables of the same type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8aad770addffb7c9ee321a2ae20d74343b6752" translate="yes" xml:space="preserve">
          <source>Varargs</source>
          <target state="translated">Varargs</target>
        </trans-unit>
        <trans-unit id="7d9fcf6d5d84f212e746c0dd60f0871afacbb237" translate="yes" xml:space="preserve">
          <source>Varargs matching</source>
          <target state="translated">сопоставление варгов</target>
        </trans-unit>
        <trans-unit id="1e1a470ac65b2238b82d8d8713eb8a548a3249ba" translate="yes" xml:space="preserve">
          <source>Varargs of untyped</source>
          <target state="translated">Варги из нетиповых</target>
        </trans-unit>
        <trans-unit id="77559312e7c433e8e5ee29c1bb6cbeca9a08ec04" translate="yes" xml:space="preserve">
          <source>Varargs pragma</source>
          <target state="translated">варварская прагма</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="805fa97816cdbe137bc65aece5e19b6969589e6d" translate="yes" xml:space="preserve">
          <source>Variables can also be reordered as well. Variables that are &lt;em&gt;initialized&lt;/em&gt; (i.e. variables that have their declaration and assignment combined in a single statement) can have their entire initialization statement reordered. Be wary of what code is executed at the top level:</source>
          <target state="translated">Переменные также можно переупорядочить. Переменные, которые &lt;em&gt;инициализируются&lt;/em&gt; (т. Е. Переменные, объявление и назначение которых объединены в одном операторе), могут иметь переупорядоченный весь оператор инициализации. Остерегайтесь того, какой код выполняется на верхнем уровне:</target>
        </trans-unit>
        <trans-unit id="f285e0b395df604d798c7e2bb2b23e2eae4f1e8f" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;recvFrom&lt;/code&gt; for non-blocking sockets. Unlike &lt;code&gt;recvFrom&lt;/code&gt;, this function will raise an EOS error whenever a socket error occurs.</source>
          <target state="translated">Вариант &lt;code&gt;recvFrom&lt;/code&gt; для неблокируемых сокетов. В отличие от &lt;code&gt;recvFrom&lt;/code&gt; , эта функция будет вызывать ошибку EOS всякий раз, когда возникает ошибка сокета.</target>
        </trans-unit>
        <trans-unit id="37a9cbeb25f6e324f126507ad323389964644919" translate="yes" xml:space="preserve">
          <source>Variant of select with only a read and write list.</source>
          <target state="translated">Вариант выбора со списком только для чтения и записи.</target>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="c0e92bae9fcb6a7281bd801df9748260bc15749f" translate="yes" xml:space="preserve">
          <source>Verbatim string match for back reference.</source>
          <target state="translated">Вербатичная строка совпадает с обратной ссылкой.</target>
        </trans-unit>
        <trans-unit id="be6cf59698ac3aaae8c44d3c15b6e3e4cda4c5a2" translate="yes" xml:space="preserve">
          <source>Verbatim string match: Use this to override a global &lt;code&gt;\i&lt;/code&gt; or &lt;code&gt;\y&lt;/code&gt; modifier.</source>
          <target state="translated">Дословное совпадение строки: используйте это, чтобы переопределить глобальный модификатор &lt;code&gt;\i&lt;/code&gt; или &lt;code&gt;\y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0f86f02d25018ae2892b7bd1afddf0b541788d2" translate="yes" xml:space="preserve">
          <source>Verbosity levels</source>
          <target state="translated">Уровни вербозности</target>
        </trans-unit>
        <trans-unit id="c12b4e999b16e9b02d25b9fcdd67d4fd655e16ae" translate="yes" xml:space="preserve">
          <source>Verify if a statement or a list of statements is true. A helpful error message and set checkpoints are printed out on failure (if &lt;code&gt;outputLevel&lt;/code&gt; is not &lt;code&gt;PRINT_NONE&lt;/code&gt;). Example:</source>
          <target state="translated">Убедитесь, что утверждение или список утверждений верны. &lt;code&gt;outputLevel&lt;/code&gt; сообщение об ошибке и установленные контрольные точки распечатываются при сбое (если outputLevel не &lt;code&gt;PRINT_NONE&lt;/code&gt; ). Пример:</target>
        </trans-unit>
        <trans-unit id="d2784d4602912caafb5ad3d11f152f082f9e1b16" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getType&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf92590226e4f935af31645efa1ac42d722021ca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getTypeImpl&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="translated">Версия &lt;code&gt;getTypeImpl&lt;/code&gt; , которая принимает &lt;code&gt;typedesc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57aa9247bf27c4880a6334aaec93af41db7006d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getTypeInst&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="translated">Версия &lt;code&gt;getTypeInst&lt;/code&gt; , которая принимает &lt;code&gt;typedesc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f49127025fb5873ad1bd738867c76e3725ffeaa" translate="yes" xml:space="preserve">
          <source>Version:</source>
          <target state="translated">Version:</target>
        </trans-unit>
        <trans-unit id="3b6698fb0fff6c21a0dacb845a8168b700a8f071" translate="yes" xml:space="preserve">
          <source>VersionAsString:</source>
          <target state="translated">VersionAsString:</target>
        </trans-unit>
        <trans-unit id="858b1e6c9eca4cf7c78fcd8fab9318b40196ab03" translate="yes" xml:space="preserve">
          <source>Viceversa, one can also use &lt;code&gt;#assumendef SYMBOL&lt;/code&gt; to declare that &lt;code&gt;SYMBOL&lt;/code&gt; should be considered not defined, and hence skip &lt;code&gt;#ifdef SYMBOL&lt;/code&gt; sections.</source>
          <target state="translated">И наоборот, можно также использовать &lt;code&gt;#assumendef SYMBOL&lt;/code&gt; , чтобы объявить, что &lt;code&gt;SYMBOL&lt;/code&gt; следует считать не определенным, и, следовательно, пропустить разделы &lt;code&gt;#ifdef SYMBOL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="446e8e3fce5e3128e133d64c529899ea1dd858b1" translate="yes" xml:space="preserve">
          <source>View types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8eef146e6b277dbe5d9e005320c3315cc7d039" translate="yes" xml:space="preserve">
          <source>ViewTypeKind.immutableView</source>
          <target state="translated">ViewTypeKind.immutableView</target>
        </trans-unit>
        <trans-unit id="dff874c131f8bb325b7f9624ec5e0a907eebf1c6" translate="yes" xml:space="preserve">
          <source>ViewTypeKind.mutableView</source>
          <target state="translated">ViewTypeKind.mutableView</target>
        </trans-unit>
        <trans-unit id="32ee0924ac03c2fd5d1496f594108118d64746e0" translate="yes" xml:space="preserve">
          <source>ViewTypeKind.noView</source>
          <target state="translated">ViewTypeKind.noView</target>
        </trans-unit>
        <trans-unit id="e1365390bd60db43644d2c7fe33cdc7c97aac284" translate="yes" xml:space="preserve">
          <source>ViewTypeKind:</source>
          <target state="translated">ViewTypeKind:</target>
        </trans-unit>
        <trans-unit id="fa3a6215333724f6e30c443dd490c943e2c34323" translate="yes" xml:space="preserve">
          <source>VmArgs:</source>
          <target state="translated">VmArgs:</target>
        </trans-unit>
        <trans-unit id="02574e1c3e8efd085f63bcb781df8802c484d8b8" translate="yes" xml:space="preserve">
          <source>VmCallback:</source>
          <target state="translated">VmCallback:</target>
        </trans-unit>
        <trans-unit id="f9b4a6297c88554060939c3b1d4cb2536eb7bee3" translate="yes" xml:space="preserve">
          <source>Void context</source>
          <target state="translated">Пустой контекст</target>
        </trans-unit>
        <trans-unit id="e8f5359cab08d3573121923f7436c0f33fc92629" translate="yes" xml:space="preserve">
          <source>Void type</source>
          <target state="translated">Тип Пустоты</target>
        </trans-unit>
        <trans-unit id="962f34b2afbbced77fbbf76af036107dbe53ad9d" translate="yes" xml:space="preserve">
          <source>Volatile pragma</source>
          <target state="translated">Летучая прагма</target>
        </trans-unit>
        <trans-unit id="a1c74f4c3dc47b71577d22318b41d7984b1abbb7" translate="yes" xml:space="preserve">
          <source>Waiting for a subprocess to finish. A subprocess can be started, but right now it can't be waited on, which sort of makes subprocesses a bit hard to use</source>
          <target state="translated">Жду завершения подпроцесса.Подпроцесс можно запустить,но сейчас его нельзя ждать,что делает подпроцессы немного сложными в использовании.</target>
        </trans-unit>
        <trans-unit id="e74d0d5b2aa91ca4f2eda490c658dd7df90ccca2" translate="yes" xml:space="preserve">
          <source>Waits for completion events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. In contrast to &lt;code&gt;poll&lt;/code&gt; this processes as many events as are available.</source>
          <target state="translated">Ожидает событий завершения и обрабатывает их. Вызывает &lt;code&gt;ValueError&lt;/code&gt; если нет ожидающих операций. В отличие от &lt;code&gt;poll&lt;/code&gt; он обрабатывает столько событий, сколько доступно.</target>
        </trans-unit>
        <trans-unit id="8c6c37027d7f2e6c6ab4b80a9728bdfd41e4de6e" translate="yes" xml:space="preserve">
          <source>Waits for completion events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. This runs the underlying OS &lt;span id=&quot;epoll_1&quot;&gt;epoll&lt;/span&gt; or &lt;span id=&quot;kqueue_1&quot;&gt;kqueue&lt;/span&gt; primitive only once.</source>
          <target state="translated">Ожидает событий завершения и обрабатывает их. Вызывает &lt;code&gt;ValueError&lt;/code&gt; если нет ожидающих операций. Это запускает базовый примитив &lt;span id=&quot;epoll_1&quot;&gt;epoll&lt;/span&gt; или &lt;span id=&quot;kqueue_1&quot;&gt;kqueue&lt;/span&gt; ОС только один раз.</target>
        </trans-unit>
        <trans-unit id="204793720c46d08681ddecb190249c9c8af8a373" translate="yes" xml:space="preserve">
          <source>Waits for completion of &lt;strong&gt;all&lt;/strong&gt; events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. In contrast to &lt;code&gt;poll&lt;/code&gt; this processes as many events as are available until the timeout has elapsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7309ba8763f2cd6a0b2e52be4a1bdf5400867492" translate="yes" xml:space="preserve">
          <source>Waits for events registered in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Ожидает событий, зарегистрированных в селекторе &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5f0c4139884d2abda2de2444e4464c33fd6fa67" translate="yes" xml:space="preserve">
          <source>Waits for every thread in &lt;code&gt;t&lt;/code&gt; to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fc9ffeaa2d05fb1d780035185e1cba8feba761" translate="yes" xml:space="preserve">
          <source>Waits for the process to finish and returns &lt;code&gt;p&lt;/code&gt;'s error code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada9df230ef438f4a792b7d49e4ffd90a8b1ec6b" translate="yes" xml:space="preserve">
          <source>Waits for the thread &lt;code&gt;t&lt;/code&gt; to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9446e39ca3b4a238ae239559d7ae690626b7ce" translate="yes" xml:space="preserve">
          <source>Waits until the value for the &lt;code&gt;fv&lt;/code&gt; arrives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14f81123dca7f0c9abebcb68de165f609c234d7" translate="yes" xml:space="preserve">
          <source>Walking is not recursive. If &lt;code&gt;relative&lt;/code&gt; is true (default: false) the resulting path is shortened to be relative to &lt;code&gt;dir&lt;/code&gt;. Example: This directory structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c69a06317f4a5f9baf9a7788e0ebd385a13e24" translate="yes" xml:space="preserve">
          <source>Walking is recursive. &lt;code&gt;followFilter&lt;/code&gt; controls the behaviour of the iterator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a009040341eedf69627aff9b5c29bf4b8425403d" translate="yes" xml:space="preserve">
          <source>Walking is recursive. &lt;em&gt;filters&lt;/em&gt; controls the behaviour of the iterator:</source>
          <target state="translated">Ходьба рекурсивна. &lt;em&gt;фильтры&lt;/em&gt; контролируют поведение итератора:</target>
        </trans-unit>
        <trans-unit id="257e0c4a2da1427367d784ff2749db7746c92812" translate="yes" xml:space="preserve">
          <source>Walks over all parent directories of a given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd311d8cb591a6fc0622efcf10ea3ea470116f2" translate="yes" xml:space="preserve">
          <source>Walks over all parent directories of a given &lt;em&gt;path&lt;/em&gt;</source>
          <target state="translated">Обходит все родительские каталоги заданного &lt;em&gt;пути&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="589a4634f66a4771a96b3527d7d465ed30a8f110" translate="yes" xml:space="preserve">
          <source>Walks over the directory &lt;code&gt;dir&lt;/code&gt; and yields for each directory or file in &lt;code&gt;dir&lt;/code&gt;. The component type and full path for each item are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f677a76b732f719f239cf0dfdab57ecc27685012" translate="yes" xml:space="preserve">
          <source>Wang Yi's hash_v1 for 8B int. &lt;a href=&quot;https://github.com/rurban/smhasher&quot;&gt;https://github.com/rurban/smhasher&lt;/a&gt; has more details. This passed all scrambling tests in Spring 2019 and is simple. NOTE: It's ok to define &lt;code&gt;proc(x: int16): Hash = hashWangYi1(Hash(x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f61ac580a8669e5f5ddb85827db56efd269d4d4" translate="yes" xml:space="preserve">
          <source>Warning: This function may block. Especially on directories with many files, because a full list of file names must be retrieved.</source>
          <target state="translated">Внимание:Эта функция может блокироваться.Особенно в каталогах с большим количеством файлов,потому что должен быть получен полный список имен файлов.</target>
        </trans-unit>
        <trans-unit id="99a2a483409f9e01cee9aa93831fe0f06d054b92" translate="yes" xml:space="preserve">
          <source>Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.</source>
          <target state="translated">Внимание:Это действительно преобразует &quot;для&quot; и разворачивает петлю.В текущей реализации также есть ошибка,которая влияет на привязку символов в теле цикла.</target>
        </trans-unit>
        <trans-unit id="7412166e831c66d50243ea6b997febce22e1c0db" translate="yes" xml:space="preserve">
          <source>Warning: URL-encoded and Unicode attempts at directory traversal are not detected. Triple dot is not handled.</source>
          <target state="translated">Внимание:Попытки обхода директории с использованием URL и Unicode не обнаружены.Тройная точка не обрабатывается.</target>
        </trans-unit>
        <trans-unit id="f0e0c14f084e128be516580f7f46caa6b881111d" translate="yes" xml:space="preserve">
          <source>We already know the type information as a graph in the compiler. Thus we need to serialize this graph as RTTI for C code generation. Look at the file &lt;code&gt;lib/system/hti.nim&lt;/code&gt; for more information.</source>
          <target state="translated">Мы уже знаем информацию о типе в виде графика в компиляторе. Таким образом, нам нужно сериализовать этот график как RTTI для генерации кода C. Посмотрите файл &lt;code&gt;lib/system/hti.nim&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7b2d825d8ef9b527c8f3ffcca749e04b73530ffc" translate="yes" xml:space="preserve">
          <source>We cache generic instantiations and need to ensure this caching works well with the incremental compilation feature. Since the cache is attached to the &lt;code&gt;PSym&lt;/code&gt; datastructure, it should work without any special logic.</source>
          <target state="translated">Мы кэшируем общие экземпляры и должны убедиться, что это кеширование хорошо работает с функцией инкрементной компиляции. Поскольку кеш привязан к структуре данных &lt;code&gt;PSym&lt;/code&gt; , он должен работать без какой-либо специальной логики.</target>
        </trans-unit>
        <trans-unit id="7bf6af0d4d4b7bb7491ad339f0cd6b4eecccde3c" translate="yes" xml:space="preserve">
          <source>We call a proc &lt;code&gt;p&lt;/code&gt;&lt;span id=&quot;gc-safe_1&quot;&gt;GC safe&lt;/span&gt; when it doesn't access any global variable that contains GC'ed memory (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt; or a closure) either directly or indirectly through a call to a GC unsafe proc.</source>
          <target state="translated">Мы называем ргос &lt;code&gt;p&lt;/code&gt; &lt;span id=&quot;gc-safe_1&quot;&gt;GC сейф&lt;/span&gt; , когда он не доступ к любой глобальной переменной , которая содержит GC'ed памяти ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;seq&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; или замыкание) либо непосредственно , либо косвенно через вызов ГХ небезопасных прок.</target>
        </trans-unit>
        <trans-unit id="ba455d231bded2509ebd8f9d1e8763309c843c4f" translate="yes" xml:space="preserve">
          <source>We can &quot;replay&quot; &lt;code&gt;stCode.add&lt;/code&gt; only if the values of &lt;code&gt;st&lt;/code&gt; and &lt;code&gt;apicall&lt;/code&gt; are known. And even then a hash table's &lt;code&gt;add&lt;/code&gt; with its hashing mechanism is too hard to replay.</source>
          <target state="translated">Мы можем &quot;воспроизвести&quot; &lt;code&gt;stCode.add&lt;/code&gt; только в том случае, если известны значения &lt;code&gt;st&lt;/code&gt; и &lt;code&gt;apicall&lt;/code&gt; . И даже тогда хэш - таблицу , в &lt;code&gt;add&lt;/code&gt; с его механизмом хеширования слишком трудно воспроизвести.</target>
        </trans-unit>
        <trans-unit id="f6c15cc4bcae38711205717122d00cbaec2e62f3" translate="yes" xml:space="preserve">
          <source>We can achieve this using the &lt;code&gt;bindMethod&lt;/code&gt; macro:</source>
          <target state="translated">&lt;code&gt;bindMethod&lt;/code&gt; можно добиться с помощью макроса bindMethod :</target>
        </trans-unit>
        <trans-unit id="31fc4caa6ec680ff0de718216907b6b39698fd69" translate="yes" xml:space="preserve">
          <source>We cannot duplicate 'a' if it denotes an expression that has a side effect! Fortunately Nim supports side effect analysis:</source>
          <target state="translated">Мы не можем дублировать 'a',если оно обозначает выражение,имеющее побочный эффект! К счастью,Nim поддерживает анализ побочных эффектов:</target>
        </trans-unit>
        <trans-unit id="cc498265cc3ceafbd88456ff11eb0a32bb180e8f" translate="yes" xml:space="preserve">
          <source>We could get rid of nesting environments by always inlining inner anon procs. More useful is escape analysis and stack allocation of the environment, however.</source>
          <target state="translated">Мы могли бы избавиться от гнездовой среды,всегда вставляя внутренние аноновые стойки.Однако более полезным является анализ эвакуации и распределение стопки среды.</target>
        </trans-unit>
        <trans-unit id="e11914dec9459002787db2ce90468c35fd15a6ab" translate="yes" xml:space="preserve">
          <source>We have already seen the simple &lt;code&gt;import&lt;/code&gt; statement that just imports all exported symbols. An alternative that only imports listed symbols is the &lt;code&gt;from import&lt;/code&gt; statement:</source>
          <target state="translated">Мы уже видели простой оператор &lt;code&gt;import&lt;/code&gt; который просто импортирует все экспортированные символы. Альтернативой, которая импортирует только перечисленные символы, является оператор &lt;code&gt;from import&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="59c4a855c5c497242383a03a1f691a7e5a85ba0a" translate="yes" xml:space="preserve">
          <source>We have to decide at runtime whether the reference is on the stack or not. The generated code looks roughly like this:</source>
          <target state="translated">Во время выполнения мы должны решить,находится ли ссылка на стеке или нет.Сгенерированный код выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="cf92005b68f4a7df3a08d2ee2fa3d3d923557d80" translate="yes" xml:space="preserve">
          <source>We need an API that hides the complex aliasing problems by not relying on Nim's global variables. The obvious solution is to use string keys instead of global variables:</source>
          <target state="translated">Нам нужен API,который скрывает сложные проблемы с алиасингом,не полагаясь на глобальные переменные Нима.Очевидным решением является использование строковых ключей вместо глобальных переменных:</target>
        </trans-unit>
        <trans-unit id="6c36085b01e4f6e8f59835097cfb83f524dc4b57" translate="yes" xml:space="preserve">
          <source>We start the tour with a modified &quot;hello world&quot; program:</source>
          <target state="translated">Мы начинаем тур с измененной программы &quot;hello world&quot;:</target>
        </trans-unit>
        <trans-unit id="41e38ed24e3a1be9264a0daea556df68c3aba5e6" translate="yes" xml:space="preserve">
          <source>We store a module's AST of a successful semantic check in a SQLite database. There are plenty of features that require a sub sequence to be re-applied, for example:</source>
          <target state="translated">Мы храним AST модуля успешной семантической проверки в базе данных SQLite.Существует множество функций,требующих,например,повторного применения подпоследовательности:</target>
        </trans-unit>
        <trans-unit id="2a8ba9ee33c2a6fb270c2b9858e20ee9e6e1de37" translate="yes" xml:space="preserve">
          <source>We use a mixture of bitset and hash table for this. The hash table maps &lt;em&gt;pages&lt;/em&gt; to a page descriptor. The page descriptor contains a bit for any possible cell address within this page. So including a cell is done as follows:</source>
          <target state="translated">Для этого мы используем смесь битового набора и хеш-таблицы. Хэш-таблица отображает &lt;em&gt;страницы&lt;/em&gt; на дескриптор страницы. Дескриптор страницы содержит бит для любого возможного адреса ячейки на этой странице. Итак, включение ячейки выполняется следующим образом:</target>
        </trans-unit>
        <trans-unit id="aab20012d1620f5b85c5c37ea977935d4f505aea" translate="yes" xml:space="preserve">
          <source>We want to generate roughly this JavaScript:</source>
          <target state="translated">Мы хотим сгенерировать примерно этот JavaScript:</target>
        </trans-unit>
        <trans-unit id="113b69b591d6182bb037d0575303c945f53858ae" translate="yes" xml:space="preserve">
          <source>What is happening here is that the types used for table keys require to have a &lt;code&gt;hash()&lt;/code&gt; proc which will convert them to a &lt;a href=&quot;hashes#Hash&quot;&gt;Hash&lt;/a&gt; value, and the compiler is listing all the hash functions it knows. Additionally there has to be a &lt;code&gt;==&lt;/code&gt; operator that provides the same semantics as its corresponding &lt;code&gt;hash&lt;/code&gt; proc.</source>
          <target state="translated">Здесь происходит то, что типы, используемые для ключей таблицы, требуют наличия процедуры &lt;code&gt;hash()&lt;/code&gt; которая преобразует их в значение &lt;a href=&quot;hashes#Hash&quot;&gt;Hash&lt;/a&gt; , а компилятор перечисляет все известные ему хеш-функции. Кроме того, должен быть оператор &lt;code&gt;==&lt;/code&gt; , который обеспечивает ту же семантику, что и соответствующий ему &lt;code&gt;hash&lt;/code&gt; процесс.</target>
        </trans-unit>
        <trans-unit id="7366e079f6ffab6bc9ad768b8631449c4256e61f" translate="yes" xml:space="preserve">
          <source>What most programming languages call &lt;span id=&quot;methods_1&quot;&gt;methods&lt;/span&gt; or &lt;span id=&quot;functions_1&quot;&gt;functions&lt;/span&gt; are called &lt;span id=&quot;procedures_1&quot;&gt;procedures&lt;/span&gt; in Nim. A procedure declaration consists of an identifier, zero or more formal parameters, a return value type and a block of code. Formal parameters are declared as a list of identifiers separated by either comma or semicolon. A parameter is given a type by &lt;code&gt;: typename&lt;/code&gt;. The type applies to all parameters immediately before it, until either the beginning of the parameter list, a semicolon separator or an already typed parameter, is reached. The semicolon can be used to make separation of types and subsequent identifiers more distinct.</source>
          <target state="translated">То, что большинство языков программирования вызывает &lt;span id=&quot;methods_1&quot;&gt;методы&lt;/span&gt; или &lt;span id=&quot;functions_1&quot;&gt;функции&lt;/span&gt; , в Nim называется &lt;span id=&quot;procedures_1&quot;&gt;процедурами&lt;/span&gt; . Объявление процедуры состоит из идентификатора, нуля или нескольких формальных параметров, типа возвращаемого значения и блока кода. Формальные параметры объявляются как список идентификаторов, разделенных запятой или точкой с запятой. Параметру присваивается тип &lt;code&gt;: typename&lt;/code&gt; . Тип применяется ко всем параметрам непосредственно перед ним, пока не будет достигнуто начало списка параметров, разделитель точки с запятой или уже введенный параметр. Точка с запятой может использоваться для более четкого разделения типов и последующих идентификаторов.</target>
        </trans-unit>
        <trans-unit id="66a8ccce98f65c3a6b48e55191a5b345ee1e0b8f" translate="yes" xml:space="preserve">
          <source>What most programming languages call &lt;span id=&quot;methods_1&quot;&gt;methods&lt;/span&gt; or &lt;span id=&quot;functions_1&quot;&gt;functions&lt;/span&gt; are called &lt;span id=&quot;procedures_1&quot;&gt;procedures&lt;/span&gt; in Nim. A procedure declaration consists of an identifier, zero or more formal parameters, a return value type and a block of code. Formal parameters are declared as a list of identifiers separated by either comma or semicolon. A parameter is given a type by &lt;code&gt;: typename&lt;/code&gt;. The type applies to all parameters immediately before it, until either the beginning of the parameter list, a semicolon separator, or an already typed parameter, is reached. The semicolon can be used to make separation of types and subsequent identifiers more distinct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcfff2350bc510e79fd004ac68bd4cb1f311382" translate="yes" xml:space="preserve">
          <source>What optimizers really need to do is a &lt;em&gt;canonicalization&lt;/em&gt;:</source>
          <target state="translated">Что действительно нужно оптимизаторам, так это &lt;em&gt;канонизация&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="93ccfee40ae325efd18fb6ffe045c18cb229f18f" translate="yes" xml:space="preserve">
          <source>What seem to be C code generation problems is often a bug resulting from not producing prototypes, so that some types default to &lt;code&gt;cint&lt;/code&gt;. Testing without the &lt;code&gt;-w&lt;/code&gt; option helps!</source>
          <target state="translated">То, что кажется проблемами генерации кода C, часто является ошибкой, возникающей из-за того, что прототипы не &lt;code&gt;cint&lt;/code&gt; , поэтому для некоторых типов по умолчанию используется cint . Помогает тестирование без опции &lt;code&gt;-w&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="da9f923a36a4b94d0ac1b66475ca125ddde61625" translate="yes" xml:space="preserve">
          <source>What to install:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f4a3ec696cf15db4c5199b757938fbcc68be19" translate="yes" xml:space="preserve">
          <source>When 0 is returned the socket's connection has been closed.</source>
          <target state="translated">При возврате 0 соединение гнезда было закрыто.</target>
        </trans-unit>
        <trans-unit id="5309ac6e6a926e840908775be647c2028a478adb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned the socket's connection has been closed.</source>
          <target state="translated">Когда &lt;code&gt;&quot;&quot;&lt;/code&gt; возвращается соединение , сокет закрыт.</target>
        </trans-unit>
        <trans-unit id="017a1cdbf43acad895afedf8019b709fbd1b8c09" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a ref type then the resulting type will be &lt;code&gt;T&lt;/code&gt;, otherwise it will be &lt;code&gt;ref T&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;T&lt;/code&gt; представляет собой порядковый тип затем полученный тип будет &lt;code&gt;T&lt;/code&gt; , в противном случае она будет &lt;code&gt;ref T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e650c5cd9ed1e1728a9de1aefd1194bac45412b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;defer&lt;/code&gt; is at the outermost scope of a template/macro, its scope extends to the block where the template is called from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e8e46dee2340d03eb3fb2d57a8748f8123b5a2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;followSymlink&lt;/code&gt; is true (default), symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec56473fcbf52718a6d7f0b9557faeb53416095" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;importc&lt;/code&gt; is applied to a &lt;code&gt;let&lt;/code&gt; statement it can omit its value which will then be expected to come from C. This can be used to import a C &lt;code&gt;const&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82a67761bf009b1ccc17019d024dead497b2c8c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;importcpp&lt;/code&gt; is applied to an enum type the numerical enum values are annotated with the C++ enum type, like in this example: &lt;code&gt;((TheCppEnum)(3))&lt;/code&gt;. (This turned out to be the simplest way to implement it.)</source>
          <target state="translated">Когда &lt;code&gt;importcpp&lt;/code&gt; применяется к типу перечисления, числовые значения перечисления аннотируются типом перечисления C ++, как в этом примере: &lt;code&gt;((TheCppEnum)(3))&lt;/code&gt; . (Это оказался самый простой способ его реализовать.)</target>
        </trans-unit>
        <trans-unit id="c0ec291075ab47c66b9aca7ce77f93fc4bdac281" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shortNoVal&lt;/code&gt; is non-empty, users are not required to separate short options and their values with a ':' or '=' since the parser knows which options accept values and which ones do not. This behavior also applies for long options if &lt;code&gt;longNoVal&lt;/code&gt; is non-empty. For short options, &lt;code&gt;-j4&lt;/code&gt; becomes supported syntax, and for long options, &lt;code&gt;--foo bar&lt;/code&gt; becomes supported. This is in addition to the &lt;a href=&quot;#supported-syntax&quot;&gt;previously mentioned syntax&lt;/a&gt;. Users can still separate options and their values with ':' or '=', but that becomes optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a139f37abab95c9bed1e71a37e9ff86bb1b47c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shortNoVal&lt;/code&gt;/&lt;code&gt;longNoVal&lt;/code&gt; are non-empty then the ':' and '=' above are still accepted, but become optional. Note that these option key sets must be updated along with the set of option keys taking no value, but keys which do take values need no special updates as their set evolves.</source>
          <target state="translated">Если значения &lt;code&gt;shortNoVal&lt;/code&gt; / &lt;code&gt;longNoVal&lt;/code&gt; не являются пустыми, то указанные выше символы ':' и '=' по-прежнему принимаются, но становятся необязательными. Обратите внимание, что эти наборы ключей параметров должны обновляться вместе с набором ключей параметров, не принимающих значения, но ключи, которые принимают значения, не нуждаются в специальных обновлениях по мере развития их набора.</target>
        </trans-unit>
        <trans-unit id="24f30d768e45c2d32aab10d32954550abeb7d4e8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;useStream&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the file will be read into memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c515c96ec96f99594496b1328f30048f3de0cd1" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;followSymlink&lt;/em&gt; is true, symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved.</source>
          <target state="translated">Когда &lt;em&gt;followSymlink&lt;/em&gt; имеет значение true, выполняется отслеживание символических ссылок, и полученная информация является информацией, относящейся к цели символической ссылки. В противном случае извлекается информация о самой символической ссылке.</target>
        </trans-unit>
        <trans-unit id="de4680275e7c901d5f3833c727cc99c5fb135e40" translate="yes" xml:space="preserve">
          <source>When Nim encounters an expression that cannot be resolved by the standard overload resolution rules, the current scope will be searched for a dot operator that can be matched against a re-written form of the expression, where the unknown field or proc name is passed to an &lt;code&gt;untyped&lt;/code&gt; parameter:</source>
          <target state="translated">Когда Nim встречает выражение, которое не может быть разрешено стандартными правилами разрешения перегрузки, в текущей области будет выполняться поиск оператора точки, который может быть сопоставлен с переписанной формой выражения, где неизвестное поле или имя процедуры передаются в &lt;code&gt;untyped&lt;/code&gt; параметр:</target>
        </trans-unit>
        <trans-unit id="e2eaaa4e3170b1469cf0690081d49d1771a1d85a" translate="yes" xml:space="preserve">
          <source>When OpenSSL is dynamically linked, the wrapper provides partial forward and backward compatibility for OpenSSL versions above and below 1.1.0</source>
          <target state="translated">Когда OpenSSL динамически связана,обертка обеспечивает частичную прямую и обратную совместимость для версий OpenSSL выше и ниже 1.1.0.</target>
        </trans-unit>
        <trans-unit id="9ae81d2c9c4d1fafceab9a15e0a86562d3247333" translate="yes" xml:space="preserve">
          <source>When a generic type is instantiated with a type class instead of a concrete type, this results in another more specific type class:</source>
          <target state="translated">Когда общий тип инстанцируется с классом типа,а не с конкретным типом,это приводит к другому,более специфическому классу типа:</target>
        </trans-unit>
        <trans-unit id="e2b7ee84914a1420903931986e31a5241d62b138" translate="yes" xml:space="preserve">
          <source>When a procedure uses the special &lt;code&gt;var&lt;/code&gt; type return variable, the result is different from that of a var section.</source>
          <target state="translated">Когда процедура использует возвращаемую переменную специального типа &lt;code&gt;var&lt;/code&gt; , результат отличается от результата раздела var.</target>
        </trans-unit>
        <trans-unit id="97b4b802a770e586e56855a558c28871a136f5e3" translate="yes" xml:space="preserve">
          <source>When a request is made by a client the specified callback will be called.</source>
          <target state="translated">Когда запрос сделан клиентом,будет вызван указанный обратный вызов.</target>
        </trans-unit>
        <trans-unit id="c1a7a3d1dd71e0b4cf302372876e2f1c5cc12058" translate="yes" xml:space="preserve">
          <source>When a request is made to a different hostname, the current connection will be closed.</source>
          <target state="translated">Когда запрос сделан на другое имя хоста,текущее соединение будет закрыто.</target>
        </trans-unit>
        <trans-unit id="c3a07f0075ab0a45bf34eaf52dac74c940e4d650" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;readfds&lt;/code&gt; is ready to be read from then a non-zero value will be returned specifying the count of the sockets which can be read from. The sockets which can be read from will also be removed from &lt;code&gt;readfds&lt;/code&gt;.</source>
          <target state="translated">Когда сокет в &lt;code&gt;readfds&lt;/code&gt; готов к чтению, тогда будет возвращено ненулевое значение, указывающее количество сокетов, из которых можно читать. Сокеты, из которых можно читать, также будут удалены из &lt;code&gt;readfds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c3e80f170b0b81a10db5a4ea99b1003d321d7c6" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;readfds&lt;/code&gt; is ready to be read from then a non-zero value will be returned specifying the count of the sockets which can be read from. The sockets which cannot be read from will also be removed from &lt;code&gt;readfds&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2377e8684393b2ce892159f2a4e80c538b1e3d8" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which &lt;strong&gt;cannot&lt;/strong&gt; be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="translated">Когда сокет в &lt;code&gt;writefds&lt;/code&gt; готов к записи, тогда будет возвращено ненулевое значение, указывающее количество сокетов, в которые можно записывать. Сокеты, в которые &lt;strong&gt;невозможно&lt;/strong&gt; выполнить запись, также будут удалены из &lt;code&gt;writefds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43add50714f33e02f97cb791ebd99cd5319627ba" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which can be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="translated">Когда сокет в &lt;code&gt;writefds&lt;/code&gt; готов к записи, тогда будет возвращено ненулевое значение, указывающее количество сокетов, в которые можно записывать. Сокеты, в которые можно записывать, также будут удалены из &lt;code&gt;writefds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a593716765a85f211ef6839461ec2eec5b0c72ee" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which cannot be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39bcbf0203513201bce5ea953d3b4e8ffa73d031" translate="yes" xml:space="preserve">
          <source>When adding a test case to the suite it is a good idea to write a few comments about what the test is meant to verify.</source>
          <target state="translated">При добавлении тестового кейса в набор хорошо написать несколько комментариев о том,что должен проверять тест.</target>
        </trans-unit>
        <trans-unit id="fc850e7757d223791640269bd02d07871233442e" translate="yes" xml:space="preserve">
          <source>When both in-place mutation and 'returns transformed copy' are available the latter is a past participle of the former:</source>
          <target state="translated">При наличии как мутаций на месте,так и &quot;возвращаемой преобразованной копии&quot;,вторым является причастие прошедшего времени первого:</target>
        </trans-unit>
        <trans-unit id="fdb02b24eb641a3d9df1e0f52c1e38d930194554" translate="yes" xml:space="preserve">
          <source>When compiled with the JS backend and executed in a browser, this proc calls &lt;code&gt;window.performance.now()&lt;/code&gt;, which is not supported by older browsers. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/now&quot;&gt;MDN&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d7871f40dcafcdf1db9af282909ed84f0a0d5c2" translate="yes" xml:space="preserve">
          <source>When expression</source>
          <target state="translated">Когда выражение</target>
        </trans-unit>
        <trans-unit id="e76302e3e95252b2019148fcb20b2d9970fedac2" translate="yes" xml:space="preserve">
          <source>When growing, the new bytes of the block is initialized with all bytes containing zero, so it is somewhat safer then reallocShared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbcf6cc45ef40cb8b09cddb917f5aa2365f97f0" translate="yes" xml:space="preserve">
          <source>When installing documentation, .idx files are not required</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a33db9dee6b5b4dcbb8428eaf86543cac8e5c6" translate="yes" xml:space="preserve">
          <source>When multiple macro pragmas are applied to the same definition, the compiler will apply them consequently from left to right. Each macro will receive as input the output of the previous one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92587e3f6b92f3a82ee328815d7af4169d33454f" translate="yes" xml:space="preserve">
          <source>When multiple threads are generating random numbers, each thread must own the &lt;a href=&quot;#Rand&quot;&gt;Rand&lt;/a&gt; state it is using so that the thread can safely obtain random numbers. However, if each thread creates its own Rand state, the subsequences of random numbers that each thread generates may overlap, even if the provided seeds are unique. This is more likely to happen as the number of threads and amount of random numbers generated increases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5390519091e9974a31ed036eaeb0253339bd37ca" translate="yes" xml:space="preserve">
          <source>When multiple type params are present, they will bind freely to different types. To force a bind-once behavior one can use an explicit generic param:</source>
          <target state="translated">При наличии нескольких параметров типа они будут свободно связываться с различными типами.Для того,чтобы форсировать поведение двоичного типа,можно использовать явный общий параметр:</target>
        </trans-unit>
        <trans-unit id="020893f63cc1aaaba0f76060df95101dd9c22483" translate="yes" xml:space="preserve">
          <source>When naming types that come in value, pointer, and reference varieties, use a regular name for the variety that is to be used the most, and add a &quot;Obj&quot;, &quot;Ref&quot;, or &quot;Ptr&quot; suffix for the other varieties. If there is no single variety that will be used the most, add the suffixes to the pointer variants only. The same applies to C/C++ wrappers.</source>
          <target state="translated">При именовании типов,которые входят в значение,указатель и ссылочные сорта,используйте обычное имя для сорта,который будет использоваться больше всего,и добавьте суффикс &quot;Объект&quot;,&quot;Отражение&quot; или &quot;Ptr&quot; для других сортов.Если нет ни одного сорта,который будет использоваться больше всего,добавьте суффиксы только к сортам указателей.То же самое относится и к обёрткам на языке Си/Си++.</target>
        </trans-unit>
        <trans-unit id="1225645594c00f94369b8ea3ee23053edbf83ba3" translate="yes" xml:space="preserve">
          <source>When nimvm statement</source>
          <target state="translated">Когда заявление о nimvm</target>
        </trans-unit>
        <trans-unit id="09a8f1f485ac1b789483ae38b3a6729e9b633fdc" translate="yes" xml:space="preserve">
          <source>When on Windows, it calls &lt;a href=&quot;#quoteShellWindows,string&quot;&gt;quoteShellWindows proc&lt;/a&gt;. Otherwise, calls &lt;a href=&quot;#quoteShellPosix,string&quot;&gt;quoteShellPosix proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda49f871e7ef45866bd4f710af7f4927e2c1a8d" translate="yes" xml:space="preserve">
          <source>When option values begin with ':' or '=' they need to be doubled up (as in &lt;code&gt;--delim::&lt;/code&gt;) or alternated (as in &lt;code&gt;--delim=:&lt;/code&gt;).</source>
          <target state="translated">Когда значения параметров начинаются с ':' или '=', их необходимо удвоить (как в &lt;code&gt;--delim::&lt;/code&gt; или чередовать (как в &lt;code&gt;--delim=:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945bbd04315e6d758eef0a07352a6c2a1e483402" translate="yes" xml:space="preserve">
          <source>When option values begin with ':' or '=', they need to be doubled up (as in &lt;code&gt;--delim::&lt;/code&gt;) or alternated (as in &lt;code&gt;--delim=:&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbb0504613b19518d968c26eceaaa8391745e36" translate="yes" xml:space="preserve">
          <source>When socket is non-blocking and no data is available on the socket, &lt;code&gt;-1&lt;/code&gt; will be returned and &lt;code&gt;data&lt;/code&gt; will be &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Когда сокет не блокируется и в нем нет данных, будет возвращено &lt;code&gt;-1&lt;/code&gt; , а &lt;code&gt;data&lt;/code&gt; будут &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c99b697aa205b3dce70845af926b4da0b0718d3" translate="yes" xml:space="preserve">
          <source>When statement</source>
          <target state="translated">Когда заявление</target>
        </trans-unit>
        <trans-unit id="bd80507fb2abefe95238353b2a9a7cfba726d9d1" translate="yes" xml:space="preserve">
          <source>When the 'returns transformed copy' version already exists like &lt;code&gt;strutils.replace&lt;/code&gt; an in-place version should get an &lt;code&gt;-In&lt;/code&gt; suffix (&lt;code&gt;replaceIn&lt;/code&gt; for this example).</source>
          <target state="translated">Когда &amp;laquo;возвращается трансформируются копия&amp;raquo; версия уже существует как &lt;code&gt;strutils.replace&lt;/code&gt; в-место версия должна получить &lt;code&gt;-In&lt;/code&gt; суффикс ( &lt;code&gt;replaceIn&lt;/code&gt; для этого примера).</target>
        </trans-unit>
        <trans-unit id="ee41ae36de358d86d21ea16751455620675ba69a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;NimMain()&lt;/code&gt; function is called Nim initializes the garbage collector to the current thread, which is usually the main thread of your application. If your C code later spawns a different thread and calls Nim code, the garbage collector will fail to work properly and you will crash.</source>
          <target state="translated">Когда &lt;code&gt;NimMain()&lt;/code&gt; функция NimMain (), Nim инициализирует сборщик мусора для текущего потока, который обычно является основным потоком вашего приложения. Если ваш код C позже порождает другой поток и вызывает код Nim, сборщик мусора не будет работать должным образом, и вы получите сбой.</target>
        </trans-unit>
        <trans-unit id="daad49e43f5115581c4b76d4a507c298160c9cb2" translate="yes" xml:space="preserve">
          <source>When the concept type is matched against a concrete type, the unbound type parameters are inferred from the body of the concept in a way that closely resembles the way generic parameters of callable symbols are inferred on call sites.</source>
          <target state="translated">Когда тип концепции сопоставляется с конкретным типом,параметры несвязанного типа выводятся из тела концепции таким образом,что они близки к тому,как общие параметры вызываемых символов выводятся на сайтах вызова.</target>
        </trans-unit>
        <trans-unit id="dc424979483c1453191890f6ad9d1875c3650e02" translate="yes" xml:space="preserve">
          <source>When the designated generic parameter is used to instantiate a pointer-like type as in the case of &lt;code&gt;AnnotatedPtr&lt;/code&gt; above, the resulting generic type will also have pointer-like covariance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd24854ac2b1bea3f20fcea6158974c3a2524eb3" translate="yes" xml:space="preserve">
          <source>When the designated generic parameter is used to instantiate a pointer-like type as in the case of &lt;em&gt;AnnotatedPtr&lt;/em&gt; above, the resulting generic type will also have pointer-like covariance:</source>
          <target state="translated">Когда назначенный универсальный параметр используется для создания экземпляра типа указателя, как в случае &lt;em&gt;AnnotatedPtr&lt;/em&gt; выше, результирующий универсальный тип также будет иметь ковариацию, подобную указателю:</target>
        </trans-unit>
        <trans-unit id="055150de9c9775f611475f63ebc0e4678ce3f168" translate="yes" xml:space="preserve">
          <source>When the exported symbol is another module, all of its definitions will be forwarded. One can use an &lt;code&gt;except&lt;/code&gt; list to exclude some of the symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c835f980849f2df2e29fb8df8dab183460e5e580" translate="yes" xml:space="preserve">
          <source>When the exported symbol is another module, all of its definitions will be forwarded. You can use an &lt;code&gt;except&lt;/code&gt; list to exclude some of the symbols.</source>
          <target state="translated">Когда экспортируемый символ является другим модулем, все его определения будут отправлены. Вы можете использовать список &lt;code&gt;except&lt;/code&gt; чтобы исключить некоторые символы.</target>
        </trans-unit>
        <trans-unit id="07201729b3d6ca0d16d967e218a5729fc461cb07" translate="yes" xml:space="preserve">
          <source>When the flag &lt;code&gt;--benchmarkVM&lt;/code&gt; is passed to the compiler, this proc is also available at compile time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668933161717cee32fe06aec026264b62ffd1bcd" translate="yes" xml:space="preserve">
          <source>When the garbage collector frees the object, &lt;code&gt;finalizer&lt;/code&gt; is called. The &lt;code&gt;finalizer&lt;/code&gt; may not keep a reference to the object pointed to by &lt;code&gt;x&lt;/code&gt;. The &lt;code&gt;finalizer&lt;/code&gt; cannot prevent the GC from freeing the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf92696d3f2ea1ae3634b81406709cbcffab8999" translate="yes" xml:space="preserve">
          <source>When the matched type within a concept is directly tested against a different concept, we say that the outer concept is a refinement of the inner concept and thus it is more-specific. When both concepts are matched in a call during overload resolution, Nim will assign a higher precedence to the most specific one. As an alternative way of defining concept refinements, you can use the object inheritance syntax involving the &lt;code&gt;of&lt;/code&gt; keyword:</source>
          <target state="translated">Когда совпадающий тип внутри концепции напрямую проверяется на соответствие другой концепции, мы говорим, что внешняя концепция является уточнением внутренней концепции и, таким образом, является более конкретной. Когда обе концепции совпадают в вызове во время разрешения перегрузки, Nim назначит более высокий приоритет наиболее конкретному. В качестве альтернативного способа определения уточнений концепции вы можете использовать синтаксис наследования объектов с использованием ключевого слова &lt;code&gt;of&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="254e2ddbd3dd05fc683e34f1716f23a33c331fe1" translate="yes" xml:space="preserve">
          <source>When the process has finished executing, cleanup related handles.</source>
          <target state="translated">Когда процесс завершится,очистите связанные с ним дескрипторы.</target>
        </trans-unit>
        <trans-unit id="efe7cb68f3a591e4c2d4dcbbc522f1614fc7e0f0" translate="yes" xml:space="preserve">
          <source>When used as a table constructor, the syntax is different.</source>
          <target state="translated">При использовании в качестве конструктора таблиц синтаксис отличается.</target>
        </trans-unit>
        <trans-unit id="aaaf6332aae7b182e062b2664c8075404ebd76b7" translate="yes" xml:space="preserve">
          <source>When used for matching, keep in mind that likewise scanf, no backtracking is performed.</source>
          <target state="translated">При использовании для сопоставления,имейте в виду,что также при сканировании не выполняется обратное сканирование.</target>
        </trans-unit>
        <trans-unit id="5f917a7650b1a36cb2a4a1c6a6acf808f3f394e5" translate="yes" xml:space="preserve">
          <source>When used within a generic proc, a separate unique global variable will be created for each instantiation of the proc. The order of initialization of the created global variables within a module is not defined, but all of them will be initialized after any top-level variables in their originating module and before any variable in a module that imports it.</source>
          <target state="translated">При использовании внутри общей proc для каждого экземпляра proc будет создана отдельная уникальная глобальная переменная.Порядок инициализации создаваемых глобальных переменных внутри модуля не определен,но все они будут инициализироваться после любых переменных верхнего уровня в модуле-инициаторе и перед любой переменной в модуле-импортере.</target>
        </trans-unit>
        <trans-unit id="d40d10962eaf620a88343cac40c78562830e1dd8" translate="yes" xml:space="preserve">
          <source>When using multiple loggers, calling the log proc for each logger can become repetitive. Instead of doing that, register each logger that will be used with the &lt;a href=&quot;#addHandler,Logger&quot;&gt;addHandler proc&lt;/a&gt;, which is demonstrated in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a843b1f225c4f364c5548dd36862fb04be3cf402" translate="yes" xml:space="preserve">
          <source>When using the style insensitive mode (&lt;code&gt;modeStyleInsensitive&lt;/code&gt;), all letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d07aa5bc818ad3ec9bad7f3accf7a490ff3025" translate="yes" xml:space="preserve">
          <source>When using types from C headers, add checks that compare what's in the Nim file with what's in the C header (requires a C compiler with _Static_assert support, like any C11 compiler)</source>
          <target state="translated">При использовании типов из заголовков C добавьте проверки,сравнивающие то,что в файле Nim с тем,что в заголовке C (требуется С-компилятор с поддержкой _Static_assert,как и любой C11-компилятор)</target>
        </trans-unit>
        <trans-unit id="781e441cbec5e078d843ea22975079918a7fc4e9" translate="yes" xml:space="preserve">
          <source>When using types from C headers, add checks that compare what's in the Nim file with what's in the C header. This may become enabled by default in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f14056818f81ec01f7058b5fdd03ac34cc67b2" translate="yes" xml:space="preserve">
          <source>When you are making an imported module accessible by modules that import yours, the &lt;code&gt;export&lt;/code&gt; syntax is pretty straightforward.</source>
          <target state="translated">Когда вы делаете импортированный модуль доступным для модулей, которые импортируют ваш, синтаксис &lt;code&gt;export&lt;/code&gt; довольно прост.</target>
        </trans-unit>
        <trans-unit id="226a5c35d585a47f9b67c9a9683d57977935ece5" translate="yes" xml:space="preserve">
          <source>When you iterate over objects with different field types you have to use the compile time &lt;code&gt;when&lt;/code&gt; instead of a runtime &lt;code&gt;if&lt;/code&gt; to select the code you want to run for each type. To perform the comparison use the &lt;a href=&quot;manual#generics-is-operator&quot;&gt;is operator&lt;/a&gt;. Another way to do the same without &lt;code&gt;when&lt;/code&gt; is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the &lt;code&gt;value&lt;/code&gt; to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08835fa964ca44a302c76938b48f30469a0f0a5b" translate="yes" xml:space="preserve">
          <source>When you iterate over objects with different field types you have to use the compile time &lt;code&gt;when&lt;/code&gt; instead of a runtime &lt;code&gt;if&lt;/code&gt; to select the code you want to run for each type. To perform the comparison use the &lt;a href=&quot;manual#generics-is-operator&quot;&gt;is operator&lt;/a&gt;. Example:</source>
          <target state="translated">Когда вы итерация над объектами с различными типами полей вы должны использовать время компиляции , &lt;code&gt;when&lt;/code&gt; вместо выполнения , &lt;code&gt;if&lt;/code&gt; выбрать код , который вы хотите запустить для каждого типа. Для сравнения используйте &lt;a href=&quot;manual#generics-is-operator&quot;&gt;оператор is&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="3c6b91dbf30c6480d506d993a62a2e5ede60b7e6" translate="yes" xml:space="preserve">
          <source>When you pass the &lt;code&gt;docSeeSrcUrl&lt;/code&gt; switch to docgen, after each documented item in your source code the hyper link &lt;em&gt;See source&lt;/em&gt; will appear pointing to the implementation of that item on a GitHub repository. You can click the link to see the implementation of the item.</source>
          <target state="translated">Когда вы передаете переключатель &lt;code&gt;docSeeSrcUrl&lt;/code&gt; в docgen, после каждого задокументированного элемента в вашем исходном коде появится гиперссылка &lt;em&gt;See source&lt;/em&gt; , указывающая на реализацию этого элемента в репозитории GitHub. Вы можете щелкнуть ссылку, чтобы увидеть реализацию элемента.</target>
        </trans-unit>
        <trans-unit id="a18a97667681fbb7bac72211a2b07123eb883bd7" translate="yes" xml:space="preserve">
          <source>When you run the &lt;code&gt;rst2html&lt;/code&gt; command, all sections in the RST document will get an anchor you can hyper link to. Usually you can guess the anchor lower casing the section title and replacing spaces with dashes, and in any case you can get it from the table of contents. But when you run the &lt;code&gt;doc&lt;/code&gt; or &lt;code&gt;doc2&lt;/code&gt; commands to generate API documentation, some symbol get one or two anchors at the same time: a numerical identifier, or a plain name plus a complex name.</source>
          <target state="translated">Когда вы запускаете команду &lt;code&gt;rst2html&lt;/code&gt; , все разделы в документе RST получат привязку, на которую вы можете сделать гиперссылку. Обычно вы можете угадать привязку к нижнему регистру заголовка раздела и замену пробелов тире, и в любом случае вы можете получить его из оглавления. Но когда вы запускаете команды &lt;code&gt;doc&lt;/code&gt; или &lt;code&gt;doc2&lt;/code&gt; для создания документации по API, некоторый символ получает одну или две привязки одновременно: числовой идентификатор или простое имя плюс сложное имя.</target>
        </trans-unit>
        <trans-unit id="1ce4c6ad2b222c2702bd12ce14dc109cc99b9422" translate="yes" xml:space="preserve">
          <source>Whenever a user creates a specialized object, implementation of this procedure provides for &lt;code&gt;string&lt;/code&gt; representation.</source>
          <target state="translated">Каждый раз, когда пользователь создает специализированный объект, реализация этой процедуры обеспечивает &lt;code&gt;string&lt;/code&gt; представление.</target>
        </trans-unit>
        <trans-unit id="2d22034a155b9699e175c8c7b19c04441bf5e978" translate="yes" xml:space="preserve">
          <source>Whenever you use any of these pragmas you need to integrate native code into your final binary. In the case of JavaScript this is no problem at all, the same HTML file which hosts the generated JavaScript will likely provide other JavaScript functions which you are importing with &lt;code&gt;importc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4cc3bb373e7618b80ba75c42e4df4653d3d72e" translate="yes" xml:space="preserve">
          <source>Whenever you use any of these pragmas you need to integrate native code into your final binary. In the case of JavaScript this is no problem at all, the same html file which hosts the generated JavaScript will likely provide other JavaScript functions which you are importing with &lt;code&gt;importc&lt;/code&gt;.</source>
          <target state="translated">Всякий раз, когда вы используете любую из этих прагм, вам необходимо интегрировать собственный код в окончательный двоичный файл. В случае с JavaScript это вообще не проблема, тот же html-файл, в котором размещен сгенерированный JavaScript, скорее всего, будет предоставлять другие функции JavaScript, которые вы импортируете с помощью &lt;code&gt;importc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df5560ebce6ac6ecfb31be9b51c86e4c7e9d1e1c" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;pathto/nim&lt;/code&gt; is any nim binary sufficiently recent (e.g. &lt;code&gt;bin/nim_cources&lt;/code&gt; built during bootstrap or &lt;code&gt;$HOME/.nimble/bin/nim&lt;/code&gt; installed by &lt;code&gt;choosenim 1.2.0&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeeaa58356082edb9c3248aa2f5880d152480e90" translate="yes" xml:space="preserve">
          <source>Where we are currently connected.</source>
          <target state="translated">Там,где мы сейчас соединены.</target>
        </trans-unit>
        <trans-unit id="46461b4ca7f105357f8fd52e913f10563d7fe3fd" translate="yes" xml:space="preserve">
          <source>Whether a checked runtime error results in an exception or in a fatal error at runtime is implementation specific. Thus the following program is always invalid:</source>
          <target state="translated">Приведет ли проверенная ошибка во время выполнения к исключению или к фатальной ошибке во время выполнения,зависит от реализации.Таким образом,следующая программа всегда является недействительной:</target>
        </trans-unit>
        <trans-unit id="b3010c5cc1d5ed1605bdeec839471bc6e04c0c36" translate="yes" xml:space="preserve">
          <source>Whether a panic results in an exception or in a fatal error is implementation specific. Thus the following program is invalid; even though the code purports to catch the &lt;code&gt;IndexDefect&lt;/code&gt; from an out-of-bounds array access, the compiler may instead choose to allow the program to die with a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7602811bf6ae08bd5e22293258701c16580af8be" translate="yes" xml:space="preserve">
          <source>Whether a symbol that is declared in a template is exposed to the instantiation scope is controlled by the &lt;span id=&quot;inject_1&quot;&gt;inject&lt;/span&gt; and &lt;span id=&quot;gensym_1&quot;&gt;gensym&lt;/span&gt; pragmas: gensym'ed symbols are not exposed but inject'ed are.</source>
          <target state="translated">Если символ , который объявлен в шаблоне подвергаются объему экземпляра контролируются &lt;span id=&quot;inject_1&quot;&gt;инъекционными&lt;/span&gt; и &lt;span id=&quot;gensym_1&quot;&gt;GENSYM&lt;/span&gt; прагмы: gensym'ed символы не подвергаются , но inject'ed есть.</target>
        </trans-unit>
        <trans-unit id="855714febc5eeb00b339faa0d12bd25d89659cb1" translate="yes" xml:space="preserve">
          <source>Whether an operator is used a prefix operator is also affected by preceding whitespace (this parsing change was introduced with version 0.13.0):</source>
          <target state="translated">Используется ли префиксный оператор,зависит и от предшествующих пробельных символов (это изменение в разборе было введено в версии 0.13.0):</target>
        </trans-unit>
        <trans-unit id="8ae21edd574f3c50f91eb00c23c59d5accbfd946" translate="yes" xml:space="preserve">
          <source>Whether an operator is used as a prefix operator is also affected by preceding whitespace (this parsing change was introduced with version 0.13.0):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102554eef2805bb3ae93fa7e9ef62d55dda0a660" translate="yes" xml:space="preserve">
          <source>Whether the message is logged depends on both the ConsoleLogger's &lt;code&gt;levelThreshold&lt;/code&gt; field and the global log filter set using the &lt;a href=&quot;#setLogFilter,Level&quot;&gt;setLogFilter proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c93dd156d356ea796a972f1b6f05d7ee3b682af" translate="yes" xml:space="preserve">
          <source>Whether the message is logged depends on both the FileLogger's &lt;code&gt;levelThreshold&lt;/code&gt; field and the global log filter set using the &lt;a href=&quot;#setLogFilter,Level&quot;&gt;setLogFilter proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7820f01afe2100f3608e67fbc46fe5d7bd0c4d71" translate="yes" xml:space="preserve">
          <source>Whether the message is logged depends on both the RollingFileLogger's &lt;code&gt;levelThreshold&lt;/code&gt; field and the global log filter set using the &lt;a href=&quot;#setLogFilter,Level&quot;&gt;setLogFilter proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d41ff5608431c17e7d0fc23a167d921f5683a39" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$p.name&lt;/code&gt; can also be used, the &lt;code&gt;$&lt;/code&gt; operation on a string does nothing. Note that we cannot rely on automatic conversion from an &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt; like we can for the &lt;code&gt;echo&lt;/code&gt; proc.</source>
          <target state="translated">Хотя &lt;code&gt;$p.name&lt;/code&gt; также может использоваться, операция &lt;code&gt;$&lt;/code&gt; над строкой ничего не делает. Обратите внимание, что мы не можем полагаться на автоматическое преобразование из &lt;code&gt;int&lt;/code&gt; в &lt;code&gt;string&lt;/code&gt; как мы можем для процедуры &lt;code&gt;echo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="837197cffaa6ba949530b17e33bcba42ef50a34d" translate="yes" xml:space="preserve">
          <source>While Nim's support for object oriented programming (OOP) is minimalistic, powerful OOP techniques can be used. OOP is seen as &lt;em&gt;one&lt;/em&gt; way to design a program, not &lt;em&gt;the only&lt;/em&gt; way. Often a procedural approach leads to simpler and more efficient code. In particular, preferring composition over inheritance is often the better design.</source>
          <target state="translated">Хотя поддержка Nim для объектно-ориентированного программирования (ООП) минималистична, можно использовать мощные методы ООП. ООП рассматривается как &lt;em&gt;один из&lt;/em&gt; способов разработки программы, а не &lt;em&gt;единственный&lt;/em&gt; . Часто процедурный подход приводит к более простому и эффективному коду. В частности, предпочтение композиции перед наследованием часто оказывается лучшим решением.</target>
        </trans-unit>
        <trans-unit id="3fff640cbdad99fe09274abee24df7bbf25d0561" translate="yes" xml:space="preserve">
          <source>While at the language level a method is differentiated from others by the parameters and return value, the signature of the method returned by idetools returns also the pragmas for the method.</source>
          <target state="translated">В то время как на языковом уровне метод отличается от других по параметрам и возвращаемому значению,сигнатура метода,возвращаемая idetools,возвращает также прагмы для метода.</target>
        </trans-unit>
        <trans-unit id="562bd6173e445712f1af66a953e8986ba0c2374d" translate="yes" xml:space="preserve">
          <source>While at the language level a proc is differentiated from others by the parameters and return value, the signature of the proc returned by idetools returns also the pragmas for the proc.</source>
          <target state="translated">В то время как на языковом уровне proc отличается от других по параметрам и возвращаемому значению,подпись proc,возвращаемая idetools,возвращает также pragmas для proc.</target>
        </trans-unit>
        <trans-unit id="6f559b04b89f66e7a89345b0d5c2467b3e04e5d8" translate="yes" xml:space="preserve">
          <source>While macros enable advanced compile-time code transformations, they cannot change Nim's syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daec9332bd403083c7c81ec7ddda4c8cfb83913d" translate="yes" xml:space="preserve">
          <source>While macros enable advanced compile-time code transformations, they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway.</source>
          <target state="translated">Несмотря на то,что макросы позволяют выполнять расширенные преобразования кода на этапе компиляции,они не могут изменить синтаксис Нима.Однако,это не является реальным ограничением,потому что синтаксис Нима в любом случае достаточно гибкий.</target>
        </trans-unit>
        <trans-unit id="2ec95ebb740e8da659961135df7e65656f864a68" translate="yes" xml:space="preserve">
          <source>While similar to the &lt;span id=&quot;caller-info_1&quot;&gt;caller info&lt;/span&gt; of other languages, it is determined at compile time.</source>
          <target state="translated">Хотя информация о &lt;span id=&quot;caller-info_1&quot;&gt;вызывающем абоненте&lt;/span&gt; похожа на информацию о &lt;span id=&quot;caller-info_1&quot;&gt;вызывающем абоненте&lt;/span&gt; на других языках, она определяется во время компиляции.</target>
        </trans-unit>
        <trans-unit id="ab874ba2e993f09c0db307995f9d97ec18bcd164" translate="yes" xml:space="preserve">
          <source>While statement</source>
          <target state="translated">Пока заявление</target>
        </trans-unit>
        <trans-unit id="05b23a27e685e52955f50c8053fddf88076c61de" translate="yes" xml:space="preserve">
          <source>While the default Nim configuration is targeted for optimal performance on modern PC hardware and operating systems with ample memory, it is very well possible to run Nim code and a good part of the Nim standard libraries on small embedded microprocessors with only a few kilobytes of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e660ee44904244d4ad0daaebc79a0ccc4b690ca1" translate="yes" xml:space="preserve">
          <source>Whilst the syntax of type classes appears to resemble that of ADTs/algebraic data types in ML-like languages, it should be understood that type classes are static constraints to be enforced at type instantiations. Type classes are not really types in themselves but are instead a system of providing generic &quot;checks&quot; that ultimately &lt;em&gt;resolve&lt;/em&gt; to some singular type. Type classes do not allow for runtime type dynamism, unlike object variants or methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441460d8bae7a87fe7d9e0c8e6f1dc6c4fb048ac" translate="yes" xml:space="preserve">
          <source>Whole routines (procs, iterators etc.) can also be passed to a template or a macro via the pragma notation:</source>
          <target state="translated">Целые подпрограммы (прок,итераторы и т.д.)также могут быть переданы в шаблон или макрос через прагматическую нотацию:</target>
        </trans-unit>
        <trans-unit id="455cc265958fecb1e713d605b1e591a53e7b0eb7" translate="yes" xml:space="preserve">
          <source>Whole routines can also be annotated with a &lt;code&gt;locks&lt;/code&gt; pragma that takes a lock level. This then means that the routine may acquire locks of up to this level. This is essential so that procs can be called within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">Целые подпрограммы также можно аннотировать с помощью прагмы &lt;code&gt;locks&lt;/code&gt; , которая принимает уровень блокировки. Это означает, что процедура может получить блокировки до этого уровня. Это важно для того, чтобы процессы можно было вызывать в секции &lt;code&gt;locks&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="34796431c4136a13fc1a272537e43a27d56433b1" translate="yes" xml:space="preserve">
          <source>Windows specific</source>
          <target state="translated">специфический для Windows</target>
        </trans-unit>
        <trans-unit id="d5112a64c16520957eef986a882e256783fd1b64" translate="yes" xml:space="preserve">
          <source>Windows-specific</source>
          <target state="translated">Windows-specific</target>
        </trans-unit>
        <trans-unit id="f082c74fae11cd24ce038c421b38da0f7f03aa4d" translate="yes" xml:space="preserve">
          <source>Windows: this is still supported despite Windows platform not having this convention; also, both &lt;code&gt;~/&lt;/code&gt; and &lt;code&gt;~\&lt;/code&gt; are handled.</source>
          <target state="translated">Windows: это все еще поддерживается, несмотря на то, что платформа Windows не имеет этого соглашения; также обрабатываются как &lt;code&gt;~/&lt;/code&gt; и &lt;code&gt;~\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ff415fa045bd448401a30116ad4b171a87ce64f" translate="yes" xml:space="preserve">
          <source>With 'getType' you can access the node's &lt;span id=&quot;type_1&quot;&gt;type&lt;/span&gt;. A Nim type is mapped to a Nim AST too, so it's slightly confusing but it means the same API can be used to traverse types. Recursive types are flattened for you so there is no danger of infinite recursions during traversal. To resolve recursive types, you have to call 'getType' again. To see what kind of type it is, call &lt;code&gt;typeKind&lt;/code&gt; on getType's result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10d3f7f20c0f9046a906444b8a60a2f35498a01" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;except&lt;/code&gt;, we get &lt;code&gt;nnkImportExceptStmt&lt;/code&gt;.</source>
          <target state="translated">С помощью &lt;code&gt;except&lt;/code&gt; мы получаем &lt;code&gt;nnkImportExceptStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4974a309f4c94a4f9d5a2467682e0908cb7a682" translate="yes" xml:space="preserve">
          <source>With parenthesis and semicolons &lt;code&gt;(;)&lt;/code&gt; you can use statements where only an expression is allowed:</source>
          <target state="translated">С помощью круглых скобок и точек с запятой &lt;code&gt;(;)&lt;/code&gt; вы можете использовать операторы, где разрешено только выражение:</target>
        </trans-unit>
        <trans-unit id="6d171ddc79243587420ce2e420c38a86ca6d787e" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--run&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;switch&lt;/a&gt; Nim executes the file automatically after compilation. You can give your program command line arguments by appending them after the filename:</source>
          <target state="translated">С &lt;code&gt;--run&lt;/code&gt; &lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;переключателем&lt;/a&gt; Nim автоматически запускает файл после компиляции. Вы можете указать аргументы командной строки вашей программы, добавив их после имени файла:</target>
        </trans-unit>
        <trans-unit id="4cd482d4d9faa3aac000c3242487f0f59daaef12" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynlib&lt;/code&gt; pragma a procedure can also be exported to a dynamic library. The pragma then has no argument and has to be used in conjunction with the &lt;code&gt;exportc&lt;/code&gt; pragma:</source>
          <target state="translated">С помощью &lt;code&gt;dynlib&lt;/code&gt; процедуру также можно экспортировать в динамическую библиотеку. Тогда прагма не имеет аргументов и должна использоваться вместе с &lt;code&gt;exportc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="023454d8e1cf65bbb06463e1b3d0c36017c3e388" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynlib&lt;/code&gt; pragma a procedure or a variable can be imported from a dynamic library (&lt;code&gt;.dll&lt;/code&gt; files for Windows, &lt;code&gt;lib*.so&lt;/code&gt; files for UNIX). The non-optional argument has to be the name of the dynamic library:</source>
          <target state="translated">С помощью &lt;code&gt;dynlib&lt;/code&gt; процедуру или переменную можно импортировать из динамической библиотеки ( файлы &lt;code&gt;.dll&lt;/code&gt; для Windows, файлы &lt;code&gt;lib*.so&lt;/code&gt; для UNIX). Необязательный аргумент должен быть именем динамической библиотеки:</target>
        </trans-unit>
        <trans-unit id="94e21cefadb9559dc5ffe233e376ae6b6407e1ce" translate="yes" xml:space="preserve">
          <source>With the language mechanisms described here, a custom seq could be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ed0ac91dffc6d43c92455d3eaf4fb792201cb9" translate="yes" xml:space="preserve">
          <source>With these two files in place, you can run &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; and the Nim compiler will compile the &lt;code&gt;logic.c&lt;/code&gt; file in addition to &lt;code&gt;calculator.nim&lt;/code&gt; and link both into an executable, which outputs &lt;code&gt;10&lt;/code&gt; when run. Another way to link the C file statically and get the same effect would be remove the line with the &lt;code&gt;compile&lt;/code&gt; pragma and run the following typical Unix commands:</source>
          <target state="translated">С помощью этих двух файлов на месте, вы можете запустить &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; и компилятор Nim будет компилировать &lt;code&gt;logic.c&lt;/code&gt; файл в дополнение к &lt;code&gt;calculator.nim&lt;/code&gt; и связать как в исполняемый файл, который выводит &lt;code&gt;10&lt;/code&gt; при запуске. Другой способ связать файл C статически и получить тот же эффект - удалить строку с директивой &lt;code&gt;compile&lt;/code&gt; и выполнить следующие типичные команды Unix:</target>
        </trans-unit>
        <trans-unit id="25e2a3b917bb5d88c58d0943d534994772fafb16" translate="yes" xml:space="preserve">
          <source>With these two files in place, you can run &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; and the Nim compiler will compile the &lt;code&gt;logic.c&lt;/code&gt; file in addition to &lt;code&gt;calculator.nim&lt;/code&gt; and link both into an executable, which outputs &lt;code&gt;10&lt;/code&gt; when run. Another way to link the C file statically and get the same effect would be to remove the line with the &lt;code&gt;compile&lt;/code&gt; pragma and run the following typical Unix commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703804d49b5d6d854ebf524062c82cd68bb2640b" translate="yes" xml:space="preserve">
          <source>With this hook you can influence exception handling on a global level. If not nil, every 'raise' statement ends up calling this hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134c388489465dbdb52a685a4462b7c0722ae58b" translate="yes" xml:space="preserve">
          <source>With this hook you can influence exception handling on a thread local level. If not nil, every 'raise' statement ends up calling this hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f010be8a21b14dff05310dc71f698e090ed9c5" translate="yes" xml:space="preserve">
          <source>With this notation we can now easily define the core of the grammar: A block of statements (simplified example):</source>
          <target state="translated">С помощью этой нотации мы теперь можем легко определить ядро грамматики:блок высказываний (упрощенный пример):</target>
        </trans-unit>
        <trans-unit id="0036fe9e484a381c94e7a2817c459b4a03ab955b" translate="yes" xml:space="preserve">
          <source>With this output we have a better idea of what kind of input the compiler expects. We need to generate a list of statements. For each constant the source code generates a &lt;code&gt;ConstSection&lt;/code&gt; and a &lt;code&gt;ConstDef&lt;/code&gt;. If we were to move all the constants to a single &lt;code&gt;const&lt;/code&gt; block we would see only a single &lt;code&gt;ConstSection&lt;/code&gt; with three children.</source>
          <target state="translated">С этим выводом мы лучше понимаем, какой ввод ожидает компилятор. Нам нужно создать список утверждений. Для каждой константы исходный код генерирует &lt;code&gt;ConstSection&lt;/code&gt; и &lt;code&gt;ConstDef&lt;/code&gt; . Если бы мы переместили все константы в один блок &lt;code&gt;const&lt;/code&gt; , мы бы увидели только одну &lt;code&gt;ConstSection&lt;/code&gt; с тремя дочерними элементами .</target>
        </trans-unit>
        <trans-unit id="fae6de82250865ee469a39f7ecbc1836e2a60ef6" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;parallel&lt;/code&gt; section sometimes the &lt;code&gt;FlowVar[T]&lt;/code&gt; is eliminated to &lt;code&gt;T&lt;/code&gt;. This happens when &lt;code&gt;T&lt;/code&gt; does not contain any GC'ed memory. The compiler can ensure the location in &lt;code&gt;location = spawn f(...)&lt;/code&gt; is not read prematurely within a &lt;code&gt;parallel&lt;/code&gt; section and so there is no need for the overhead of an indirection via &lt;code&gt;FlowVar[T]&lt;/code&gt; to ensure correctness.</source>
          <target state="translated">В рамках &lt;code&gt;parallel&lt;/code&gt; секции иногда &lt;code&gt;FlowVar[T]&lt;/code&gt; устраняется с &lt;code&gt;T&lt;/code&gt; . Это происходит, когда &lt;code&gt;T&lt;/code&gt; не содержит памяти GC. Компилятор может гарантировать, что местоположение в &lt;code&gt;location = spawn f(...)&lt;/code&gt; не будет считано преждевременно в &lt;code&gt;parallel&lt;/code&gt; секции, и поэтому нет необходимости в накладных &lt;code&gt;FlowVar[T]&lt;/code&gt; косвенного обращения через FlowVar [T] для обеспечения правильности.</target>
        </trans-unit>
        <trans-unit id="b61954fea1e9977075452ce15801a081ce8368da" translate="yes" xml:space="preserve">
          <source>Within an &lt;code&gt;except&lt;/code&gt; clause it is possible to access the current exception using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f36950618b8748e3741661dd8fec794ecb08261" translate="yes" xml:space="preserve">
          <source>Within an &lt;code&gt;except&lt;/code&gt; clause, it is possible to use &lt;code&gt;getCurrentException&lt;/code&gt; to retrieve the exception that has been raised:</source>
          <target state="translated">Внутри предложения &lt;code&gt;except&lt;/code&gt; можно использовать &lt;code&gt;getCurrentException&lt;/code&gt; для извлечения возникшего исключения:</target>
        </trans-unit>
        <trans-unit id="c6ae57f97edbcd123ef0194b0d49cf9ec52d7039" translate="yes" xml:space="preserve">
          <source>Within the concept body, types can appear in positions where ordinary values and parameters are expected. This provides a more convenient way to check for the presence of callable symbols with specific signatures:</source>
          <target state="translated">В теле концепции типы могут появляться в позициях,где ожидаются обычные значения и параметры.Это обеспечивает более удобный способ проверки наличия вызываемых символов со специфическими сигнатурами:</target>
        </trans-unit>
        <trans-unit id="7765888ff783f01e496adca7f847d2e186e708cb" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;GCunref&lt;/code&gt; call the memory allocated for the &lt;code&gt;d.s&lt;/code&gt; string would never be freed. The example also demonstrates two important features for low level programming: the &lt;code&gt;sizeof&lt;/code&gt; proc returns the size of a type or value in bytes. The &lt;code&gt;cast&lt;/code&gt; operator can circumvent the type system: the compiler is forced to treat the result of the &lt;code&gt;alloc0&lt;/code&gt; call (which returns an untyped pointer) as if it would have the type &lt;code&gt;ptr Data&lt;/code&gt;. Casting should only be done if it is unavoidable: it breaks type safety and bugs can lead to mysterious crashes.</source>
          <target state="translated">Без вызова &lt;code&gt;GCunref&lt;/code&gt; память, выделенная для строки &lt;code&gt;d.s&lt;/code&gt; , никогда не будет освобождена. В этом примере также демонстрируются две важные особенности низкоуровневого программирования: &lt;code&gt;sizeof&lt;/code&gt; proc возвращает размер типа или значения в байтах. Оператор &lt;code&gt;cast&lt;/code&gt; может обойти систему типов: компилятор вынужден обрабатывать результат вызова &lt;code&gt;alloc0&lt;/code&gt; (который возвращает нетипизированный указатель), как если бы он имел тип &lt;code&gt;ptr Data&lt;/code&gt; . Приведение следует выполнять только в том случае, если его нельзя избежать: это нарушает безопасность типов, а ошибки могут привести к загадочным сбоям.</target>
        </trans-unit>
        <trans-unit id="3e4895a8f2ad8f356ca5ea9759cc4d11c134c3e8" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;reset&lt;/code&gt; call the memory allocated for the &lt;code&gt;d.s&lt;/code&gt; string would never be freed. The example also demonstrates two important features for low-level programming: the &lt;code&gt;sizeof&lt;/code&gt; proc returns the size of a type or value in bytes. The &lt;code&gt;cast&lt;/code&gt; operator can circumvent the type system: the compiler is forced to treat the result of the &lt;code&gt;alloc0&lt;/code&gt; call (which returns an untyped pointer) as if it would have the type &lt;code&gt;ptr Data&lt;/code&gt;. Casting should only be done if it is unavoidable: it breaks type safety and bugs can lead to mysterious crashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2688119cf2f2a4b43b3fc29913f8b3c9d7e8a24d" translate="yes" xml:space="preserve">
          <source>Word wraps &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a9ca07a5dddf13d83fab735c567da3357a0bf" translate="yes" xml:space="preserve">
          <source>Word wraps &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Переносы слов &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6962ff8c9e27a68a644675d133701514aae2e762" translate="yes" xml:space="preserve">
          <source>Would output:</source>
          <target state="translated">Выводит:</target>
        </trans-unit>
        <trans-unit id="3975aca436c50894cad487d4bc2ad703a4570339" translate="yes" xml:space="preserve">
          <source>Wrap pipe for reading with PipeOutStream so that you can use peek* procs and generate runtime error when setPosition/getPosition is called or write operation is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46922791e8808797fd6b6b49d2da608b707afc45" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init proc&lt;/a&gt; for initialization of hash sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9948186b583eed7e908d2b1fc1c7b13e25370f72" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init proc&lt;/a&gt; for initialization of ordered hash sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436516f371b709f69cf997c54adc4f028f9eebcd" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,TOrderedSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; for initialization of ordered hash sets.</source>
          <target state="translated">Обертка вокруг &lt;a href=&quot;#init,TOrderedSet%5BA%5D,int&quot;&gt;init ()&lt;/a&gt; для инициализации упорядоченных наборов хешей.</target>
        </trans-unit>
        <trans-unit id="aef47240f283c974795c0afe97ed4a86669acef1" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,TSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; for initialization of hash sets.</source>
          <target state="translated">Обертка вокруг &lt;a href=&quot;#init,TSet%5BA%5D,int&quot;&gt;init ()&lt;/a&gt; для инициализации наборов хешей.</target>
        </trans-unit>
        <trans-unit id="68af9e3f5b6fc9029361a1014092e5519a57f230" translate="yes" xml:space="preserve">
          <source>Wrapper for the &lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/iup&quot;&gt;IUP native GUI library&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f194a53efcd466e3ff60aa4bb858d39668b2accb" translate="yes" xml:space="preserve">
          <source>Wrapper for the &lt;code&gt;console&lt;/code&gt; object for the &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;JavaScript backend&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d365d3fa59d526a0f2809a9f61b0028c5e94b10" translate="yes" xml:space="preserve">
          <source>Wrappers</source>
          <target state="translated">Wrappers</target>
        </trans-unit>
        <trans-unit id="533cb09f4efea84d68d3be20e42d0338fe89c618" translate="yes" xml:space="preserve">
          <source>Wrapping constructors</source>
          <target state="translated">Упаковочные конструкторы</target>
        </trans-unit>
        <trans-unit id="11cdbcadb273848cfeb799098c4c21e8db2e9d40" translate="yes" xml:space="preserve">
          <source>Wrapping destructors</source>
          <target state="translated">обёрточные деструкторы</target>
        </trans-unit>
        <trans-unit id="9c3c9e84480e553d08468d0746063eeb3c7f119f" translate="yes" xml:space="preserve">
          <source>Wraps a connected socket in an SSL context. This function effectively turns &lt;code&gt;socket&lt;/code&gt; into an SSL socket. &lt;code&gt;hostname&lt;/code&gt; should be specified so that the client knows which hostname the server certificate should be validated against.</source>
          <target state="translated">Оборачивает подключенный сокет в контекст SSL. Эта функция эффективно превращает &lt;code&gt;socket&lt;/code&gt; в сокет SSL. &lt;code&gt;hostname&lt;/code&gt; должно быть указано, чтобы клиент знал, по какому имени хоста должен проверяться сертификат сервера.</target>
        </trans-unit>
        <trans-unit id="9ddc5519e19aff7c9640076ae420da42486453ed" translate="yes" xml:space="preserve">
          <source>Wraps a socket in an SSL context. This function effectively turns &lt;code&gt;socket&lt;/code&gt; into an SSL socket.</source>
          <target state="translated">Оборачивает сокет в контекст SSL. Эта функция эффективно превращает &lt;code&gt;socket&lt;/code&gt; в сокет SSL.</target>
        </trans-unit>
        <trans-unit id="02cc7fed3b72e2c8ac3c8047c2bf9e4c909ccdc0" translate="yes" xml:space="preserve">
          <source>Wraps an already initialized &lt;code&gt;Socket&lt;/code&gt; into a AsyncSocket. This is useful if you want to use an already connected Socket as an asynchronous AsyncSocket in asyncio's event loop.</source>
          <target state="translated">Оборачивает уже инициализированный &lt;code&gt;Socket&lt;/code&gt; в AsyncSocket. Это полезно, если вы хотите использовать уже подключенный Socket в качестве асинхронного AsyncSocket в цикле событий asyncio.</target>
        </trans-unit>
        <trans-unit id="396fc10d54c3cf990455330123fbffedf5d5823d" translate="yes" xml:space="preserve">
          <source>Write a varint into z. The buffer z must be at least 9 characters long to accommodate the largest possible varint. Returns the number of bytes used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bffafe37f8960be4ae464063375188b7367ce278" translate="yes" xml:space="preserve">
          <source>Write file stream example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f942433295c32b403eab1ccdf7cdbcb2774f2494" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;data&lt;/code&gt; to the file specified asynchronously.</source>
          <target state="translated">Записывает &lt;code&gt;data&lt;/code&gt; в указанный файл асинхронно.</target>
        </trans-unit>
        <trans-unit id="7c97819e5811aa1e2b05fd1d97141d7dc4900644" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;buf&lt;/code&gt; to the file specified asynchronously.</source>
          <target state="translated">Записывает байты &lt;code&gt;size&lt;/code&gt; из &lt;code&gt;buf&lt;/code&gt; в файл, указанный асинхронно.</target>
        </trans-unit>
        <trans-unit id="897e1a9e1ed791afbff422f3f8123f94d65ede78" translate="yes" xml:space="preserve">
          <source>Writes &lt;em&gt;data&lt;/em&gt; to the socket.</source>
          <target state="translated">Записывает &lt;em&gt;данные&lt;/em&gt; в сокет.</target>
        </trans-unit>
        <trans-unit id="796e89b2dfa91121c9081a71fb4dbffb2ef52227" translate="yes" xml:space="preserve">
          <source>Writes a hint message at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e02f96826ac037cab146bc6bc90e2ae64673c1" translate="yes" xml:space="preserve">
          <source>Writes a rope to a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e26a88656e91e6fb039c88ea549d3868acb5ba9" translate="yes" xml:space="preserve">
          <source>Writes a rope to a stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e5333ad312886271eeed037f50490e8ec4c73b" translate="yes" xml:space="preserve">
          <source>Writes a value to the file &lt;code&gt;f&lt;/code&gt;. May throw an IO exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e3f5c8aacd0969383d67b232c4242e0fbab6cf" translate="yes" xml:space="preserve">
          <source>Writes a value to the file &lt;em&gt;f&lt;/em&gt;. May throw an IO exception.</source>
          <target state="translated">Записывает значение в файл &lt;em&gt;f&lt;/em&gt; . Может вызвать исключение ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="ed03d9b983f99dab4aa01201c58720371e95d88f" translate="yes" xml:space="preserve">
          <source>Writes a warning message at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752d2fff4c96bf5371611ce6c8cf86108850f7b6" translate="yes" xml:space="preserve">
          <source>Writes an error message at compile time. The optional &lt;code&gt;n: NimNode&lt;/code&gt; parameter is used as the source for file and line number information in the compilation error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b82505d585d59b7b931841c5790d2d061a18cf" translate="yes" xml:space="preserve">
          <source>Writes and flushes the parameters to the standard output.</source>
          <target state="translated">Записывает и промывает параметры на стандартном выходе.</target>
        </trans-unit>
        <trans-unit id="9fe62811850204f6989910a722d883718ece800c" translate="yes" xml:space="preserve">
          <source>Writes data to the specified future stream as the file is read.</source>
          <target state="translated">Записывает данные в указанный будущий поток по мере чтения файла.</target>
        </trans-unit>
        <trans-unit id="01df58caf78b67ac5c60557abefc959157051a68" translate="yes" xml:space="preserve">
          <source>Writes given message string to stderr by default. If &lt;code&gt;--stdout&lt;/code&gt; option is given, writes to stdout instead. If message hook is present, then it is used to output message rather than stderr/stdout. This behavior can be altered by given optional flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92242dea02e29327d993eb1cc3297777dff63be" translate="yes" xml:space="preserve">
          <source>Writes into &lt;code&gt;result&lt;/code&gt; the rst ast &lt;code&gt;n&lt;/code&gt; using the &lt;code&gt;d&lt;/code&gt; configuration.</source>
          <target state="translated">Записывает в &lt;code&gt;result&lt;/code&gt; первое значение &lt;code&gt;n&lt;/code&gt; с использованием конфигурации &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dc097c5b3691675769f2dac59504815afe50f52" translate="yes" xml:space="preserve">
          <source>Writes one or more strings to the the stream &lt;code&gt;s&lt;/code&gt; followed by a new line. No length field or terminating zero is written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37126a1a008a17bc0fde47d26b420dbd7ee35bc" translate="yes" xml:space="preserve">
          <source>Writes one or more strings to the the stream. No length fields or terminating zeros are written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f25f4df96580649fbf61c73bf96f72aec9e3b5f" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to string. Note: Comment statement will be ignored.</source>
          <target state="translated">Записывает содержимое таблицы в строку.Примечание:комментарий будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="ba6e3b9c400f1eef44b307552759341bc86ee5ce" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to the specified configuration file. Note: Comment statement will be ignored.</source>
          <target state="translated">Записывает содержимое таблицы в указанный конфигурационный файл.Примечание:комментарий будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="943a3e5523074ab2149addf7bbeb0fa3c3bf1c09" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to the specified stream</source>
          <target state="translated">Записывает содержимое таблицы в указанный поток</target>
        </trans-unit>
        <trans-unit id="6cd9e881510f9be093ebe517fe9b4aa83cc82a0a" translate="yes" xml:space="preserve">
          <source>Writes the current index buffer to the specified output file.</source>
          <target state="translated">Записывает текущий индексный буфер в указанный выходной файл.</target>
        </trans-unit>
        <trans-unit id="e1de254c163d199c70c1b6b5d6c0d804cf679251" translate="yes" xml:space="preserve">
          <source>Writes the current stack trace to &lt;code&gt;stderr&lt;/code&gt;. This is only works for debug builds. Since it's usually used for debugging, this is proclaimed to have no IO effect!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd32587819be16f41963d9f477e3a15c30356f1" translate="yes" xml:space="preserve">
          <source>Writes the given RST node as JSON that is in the form</source>
          <target state="translated">Пишет заданный RST узел в виде JSON,который имеет форму</target>
        </trans-unit>
        <trans-unit id="3bbbda5ef7f0ace5ebf184908b2e7da636d8527f" translate="yes" xml:space="preserve">
          <source>Writes the list of registered foreign deps to stdout.</source>
          <target state="translated">Пишет список зарегистрированных иностранных депортаций в вентдаут.</target>
        </trans-unit>
        <trans-unit id="0cfd7a39f362d2a77758e5c07bcd311bfabd3290" translate="yes" xml:space="preserve">
          <source>Writes the specified value inside the specified future stream.</source>
          <target state="translated">Записывает указанное значение внутри указанного будущего потока.</target>
        </trans-unit>
        <trans-unit id="5c2eb2f5a72f7c3f1d91128581c5c2ff25e6b9df" translate="yes" xml:space="preserve">
          <source>Writes the string &lt;code&gt;x&lt;/code&gt; to the the stream &lt;code&gt;s&lt;/code&gt;. No length field or terminating zero is written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8255ac21cf77099d0f6ff9ac6e846fb5cdb0fda" translate="yes" xml:space="preserve">
          <source>Writes the string:</source>
          <target state="translated">Пишет строку:</target>
        </trans-unit>
        <trans-unit id="fa9e4f26c45e8a0cad793cc3ee793fe2081404dd" translate="yes" xml:space="preserve">
          <source>Writes the text &lt;code&gt;txt&lt;/code&gt; in a given &lt;code&gt;style&lt;/code&gt; to stdout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2914acbe1102d062a4f2393594889f72ba0c206e" translate="yes" xml:space="preserve">
          <source>Writes the text &lt;em&gt;txt&lt;/em&gt; in a given &lt;em&gt;style&lt;/em&gt; to stdout.</source>
          <target state="translated">Записывает текст &lt;em&gt;txt&lt;/em&gt; в заданном &lt;em&gt;стиле&lt;/em&gt; в стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="273726bd38de7eff2c09ffae11f809aa1fb0834f" translate="yes" xml:space="preserve">
          <source>Written by Philip Hazel</source>
          <target state="translated">Написан Филипом Хейзел</target>
        </trans-unit>
        <trans-unit id="f7b03e2f61abd9d04fffa15c8355e3436931a0ae" translate="yes" xml:space="preserve">
          <source>XDeclaredButNotUsed</source>
          <target state="translated">XDeclaredButNotUsed</target>
        </trans-unit>
        <trans-unit id="d647f348ffbbc7a4d48d8ae4bec579637ae0ee51" translate="yes" xml:space="preserve">
          <source>XML Processing</source>
          <target state="translated">обработка XML</target>
        </trans-unit>
        <trans-unit id="48398d8a1771285228591dd83034fba7e8e2884d" translate="yes" xml:space="preserve">
          <source>YES-cases:</source>
          <target state="translated">YES-cases:</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="d850dd17ecf96df39630839c6d073caf7cb5fb52" translate="yes" xml:space="preserve">
          <source>Yield every (position, value) of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">Доходность каждые (позиция, стоимость) &lt;em&gt;deq&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="755dd97240e42a3dc4431ff54cbcde0d38f93331" translate="yes" xml:space="preserve">
          <source>Yield every element of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Дайте&lt;/em&gt; каждому элементу &lt;em&gt;deq&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b0ca75af94090e37bbf9398ee1de83cc580bdc1c" translate="yes" xml:space="preserve">
          <source>Yield statement</source>
          <target state="translated">Отчёт о прибылях и убытках</target>
        </trans-unit>
        <trans-unit id="871ed0e0067addcd6d123efb1b36f30a773f4184" translate="yes" xml:space="preserve">
          <source>Yields all (key, value)-pairs of &lt;code&gt;c&lt;/code&gt; starting with &lt;code&gt;prefix&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411b555314d7bea23a1f5dea43d50bcf2cb6f9d5" translate="yes" xml:space="preserve">
          <source>Yields all (key, value)-pairs of &lt;code&gt;c&lt;/code&gt; starting with &lt;code&gt;prefix&lt;/code&gt;. The yielded values can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcc8e4db61e555c560cceaf1ae0fbe7dd651d9d" translate="yes" xml:space="preserve">
          <source>Yields all (key, value)-pairs of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153e16ecf7518e033c97e0e1289c930db427903e" translate="yes" xml:space="preserve">
          <source>Yields all (key, value)-pairs of &lt;code&gt;c&lt;/code&gt;. The yielded values can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c9dc8ace4645a635c6317e0a7e3490ea0317b9" translate="yes" xml:space="preserve">
          <source>Yields all keys in lexicographical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70578c25e269ef74aa752deb3a85fb90f00ed337" translate="yes" xml:space="preserve">
          <source>Yields all keys starting with &lt;code&gt;prefix&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1ac4376c91d07e7515d60a7f26a24af693a955" translate="yes" xml:space="preserve">
          <source>Yields all keys starting with &lt;code&gt;prefix&lt;/code&gt;. If &lt;code&gt;longestMatch&lt;/code&gt; is true, the longest match is returned, it doesn't have to be a complete match then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b74859a60c7beb5e048dac80c77f1ca93b2cc30" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;code&gt;substrings&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f3a56dbd00c322681bd3d8cb3a2e92bba08be1" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">Урожайность все совпадающие &lt;em&gt;подстроки&lt;/em&gt; из &lt;code&gt;s&lt;/code&gt; , которые соответствуют &lt;code&gt;pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5dbe19c48460bbfdb0a7ecb4ffe08a0ee9cd8526" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;em&gt;s&lt;/em&gt; that match &lt;em&gt;pattern&lt;/em&gt;.</source>
          <target state="translated">Урожайность все совпадающие &lt;em&gt;подстроки&lt;/em&gt; из &lt;em&gt;S&lt;/em&gt; , которые соответствуют &lt;em&gt;шаблону&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="169e24bd87b1517e6d052811177d3433fa68b902" translate="yes" xml:space="preserve">
          <source>Yields all values of &lt;code&gt;c&lt;/code&gt; in the lexicographical order of the corresponding keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e384e37f49f3071bbd9d91f79ba3ec7eaff6081a" translate="yes" xml:space="preserve">
          <source>Yields all values of &lt;code&gt;c&lt;/code&gt; in the lexicographical order of the corresponding keys. The values can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032d25dce63f802943bc4f5a82bd2715601f6348" translate="yes" xml:space="preserve">
          <source>Yields all values of &lt;code&gt;c&lt;/code&gt; starting with &lt;code&gt;prefix&lt;/code&gt; of the corresponding keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522c184791ecd24f9d68cbd3ce71cdd02c50441f" translate="yes" xml:space="preserve">
          <source>Yields all values of &lt;code&gt;c&lt;/code&gt; starting with &lt;code&gt;prefix&lt;/code&gt; of the corresponding keys. The values can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26171d2547797d7b792e1c5b0afcc0cbe263ef92" translate="yes" xml:space="preserve">
          <source>Yields each key, value pair.</source>
          <target state="translated">Дает каждый ключ,пару значений.</target>
        </trans-unit>
        <trans-unit id="b31f81b8732998c727005f0698e5647bea870a3d" translate="yes" xml:space="preserve">
          <source>Yields every (position, value) of &lt;code&gt;deq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3077cb4e1456fcbff5c2be8421c2ec48d4578f0" translate="yes" xml:space="preserve">
          <source>Yields every element of &lt;code&gt;deq&lt;/code&gt;, which can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7118acdad38de564553a07a9a5d6d15077a33629" translate="yes" xml:space="preserve">
          <source>Yields every element of &lt;code&gt;deq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac42bb6f91f9cbe0cbde4387b00af7ec5d6e7f53" translate="yes" xml:space="preserve">
          <source>Yields every value of &lt;code&gt;L&lt;/code&gt; so that you can modify it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091382909836c7d012e749cd20e26a4eb8483aad" translate="yes" xml:space="preserve">
          <source>Yields every value of &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b52ded50cecd2d2df18504d55b3b58b1a2b74ce" translate="yes" xml:space="preserve">
          <source>Yields the &lt;code&gt;keys&lt;/code&gt; in a JsAssoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625400c91d9b41d4450d5dc3e48a6585aee75eec" translate="yes" xml:space="preserve">
          <source>Yields the &lt;code&gt;names&lt;/code&gt; of each field in a JsObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3d1ffb21fc391e5830bf786e111b49811f9781" translate="yes" xml:space="preserve">
          <source>Yields the &lt;code&gt;values&lt;/code&gt; in a JsAssoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675c49cde4f31484041edd74cabab71e5878b730" translate="yes" xml:space="preserve">
          <source>Yields the &lt;code&gt;values&lt;/code&gt; of each field in a JsObject, wrapped into a JsObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d7e3fc8749812999838907214d1eb8450309265" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;keys&lt;/em&gt; in a JsAssoc.</source>
          <target state="translated">Вырабатывает &lt;em&gt;ключей&lt;/em&gt; в виде JsAssoc.</target>
        </trans-unit>
        <trans-unit id="a2417d997628d8ba1aefeea2d89fe75654c22728" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;names&lt;/em&gt; of each field in a JsObject.</source>
          <target state="translated">Выдает &lt;em&gt;имена&lt;/em&gt; каждого поля в JsObject.</target>
        </trans-unit>
        <trans-unit id="93956d196d887cc0861e43d2a531388eaa74a029" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;values&lt;/em&gt; in a JsAssoc.</source>
          <target state="translated">Вырабатывает &lt;em&gt;значения&lt;/em&gt; в виде JsAssoc.</target>
        </trans-unit>
        <trans-unit id="1f1a656995365fee941d9a0f7f934014284b0f0a" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;values&lt;/em&gt; of each field in a JsObject, wrapped into a JsObject.</source>
          <target state="translated">Выдает &lt;em&gt;значения&lt;/em&gt; каждого поля в JsObject, завернутые в JsObject.</target>
        </trans-unit>
        <trans-unit id="3fe8766634b03a0c571dde2851555af85b82423a" translate="yes" xml:space="preserve">
          <source>Yields the child nodes of a &lt;em&gt;Peg&lt;/em&gt; variant object where present.</source>
          <target state="translated">Дает дочерние узлы объекта варианта &lt;em&gt;Peg,&lt;/em&gt; если они есть.</target>
        </trans-unit>
        <trans-unit id="d8ec21b096062ab66fc1c72aaf6915c5df074b73" translate="yes" xml:space="preserve">
          <source>Yields the indices and child nodes of a &lt;em&gt;Peg&lt;/em&gt; variant object where present.</source>
          <target state="translated">Выдает индексы и дочерние узлы объекта варианта &lt;em&gt;Peg,&lt;/em&gt; если он присутствует.</target>
        </trans-unit>
        <trans-unit id="e7f74ddd7d348b61efb92c54d7525b3431582e18" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(K, V)&lt;/code&gt;, with the first entry being a &lt;code&gt;key&lt;/code&gt; in the JsAssoc and the second being its corresponding value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9787a201226a9a90fb295daca65242e9806ef392" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(K, V)&lt;/code&gt;, with the first entry being a &lt;em&gt;key&lt;/em&gt; in the JsAssoc and the second being its corresponding value.</source>
          <target state="translated">Выдает кортежи типа &lt;code&gt;(K, V)&lt;/code&gt; , причем первая запись является &lt;em&gt;ключом&lt;/em&gt; в JsAssoc, а вторая - его соответствующим значением.</target>
        </trans-unit>
        <trans-unit id="809aab236ff4a1a93f81d6d340fb24ba29fa5d00" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(cstring, JsObject)&lt;/code&gt;, with the first entry being the &lt;code&gt;name&lt;/code&gt; of a fields in the JsObject and the second being its value wrapped into a JsObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5fe99d112e72e96635690ca13742e71ee3b251" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(cstring, JsObject)&lt;/code&gt;, with the first entry being the &lt;em&gt;name&lt;/em&gt; of a fields in the JsObject and the second being its value wrapped into a JsObject.</source>
          <target state="translated">Создает кортежи типа &lt;code&gt;(cstring, JsObject)&lt;/code&gt; , причем первая запись является &lt;em&gt;именем&lt;/em&gt; поля в JsObject, а вторая - его значением, заключенным в JsObject.</target>
        </trans-unit>
        <trans-unit id="41454d09396bcb771849a87c8bc4283f5e65feb4" translate="yes" xml:space="preserve">
          <source>You can also bisect using custom options to build the compiler, for example if you don't need a debug version of the compiler (which runs slower), you can replace &lt;code&gt;./koch temp&lt;/code&gt; by explicit compilation command, see &lt;a href=&quot;intern#rebuilding-the-compiler&quot;&gt;Rebuilding the compiler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0096f64ab9c850e6d8688547c2fb784796e80a1" translate="yes" xml:space="preserve">
          <source>You can also create a &lt;code&gt;RstGenerator&lt;/code&gt; structure and populate it with the other lower level methods to finally build complete documents. This requires many options and tweaking, but you are not limited to snippets and can generate &lt;a href=&quot;https://en.wikipedia.org/wiki/LaTeX&quot;&gt;LaTeX documents&lt;/a&gt; too.</source>
          <target state="translated">Вы также можете создать структуру &lt;code&gt;RstGenerator&lt;/code&gt; и заполнить ее другими методами более низкого уровня, чтобы окончательно построить полные документы. Это требует множества опций и настроек, но вы не ограничены фрагментами и также можете создавать &lt;a href=&quot;https://en.wikipedia.org/wiki/LaTeX&quot;&gt;документы LaTeX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d188ca0a71a4ddf286451e750b7f8f446c7afd4" translate="yes" xml:space="preserve">
          <source>You can also make post requests with custom headers. This example sets &lt;code&gt;Content-Type&lt;/code&gt; to &lt;code&gt;application/json&lt;/code&gt; and uses a json object for the body</source>
          <target state="translated">Вы также можете отправлять запросы на публикацию с настраиваемыми заголовками. В этом примере задается &lt;code&gt;Content-Type&lt;/code&gt; для &lt;code&gt;application/json&lt;/code&gt; и использует объект JSON для тела</target>
        </trans-unit>
        <trans-unit id="a3c699b0079e23cf973cc2c8fc4fa4297a4a353a" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;#addEscaped,string,string&quot;&gt;addEscaped proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7714759afec1609cb47128c6129eb72d509b791d" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; together with &lt;em&gt;long string literals&lt;/em&gt; to create block comments:</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;#procedures-discard-statement&quot;&gt;оператор discard&lt;/a&gt; вместе с &lt;em&gt;длинными строковыми литералами&lt;/em&gt; для создания блочных комментариев:</target>
        </trans-unit>
        <trans-unit id="97084a1faa8455f2406ffb033740ec1bfec72684" translate="yes" xml:space="preserve">
          <source>You can also use the convenience procedures called &lt;code&gt;milliseconds&lt;/code&gt;, &lt;code&gt;seconds&lt;/code&gt;, &lt;code&gt;minutes&lt;/code&gt;, &lt;code&gt;hours&lt;/code&gt;, &lt;code&gt;days&lt;/code&gt;, &lt;code&gt;months&lt;/code&gt;, and &lt;code&gt;years&lt;/code&gt;.</source>
          <target state="translated">Вы также можете использовать удобные процедуры, называемые &lt;code&gt;milliseconds&lt;/code&gt; , &lt;code&gt;seconds&lt;/code&gt; , &lt;code&gt;minutes&lt;/code&gt; , &lt;code&gt;hours&lt;/code&gt; , &lt;code&gt;days&lt;/code&gt; , &lt;code&gt;months&lt;/code&gt; и &lt;code&gt;years&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3b8da731d961b104b75c9c69b89b7521fd2d57" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;GC_SetMaxPause&lt;/code&gt; at program startup and then each triggered GC run tries to not take longer than &lt;code&gt;maxPause&lt;/code&gt; time. However, it is possible (and common) that the work is nevertheless not evenly distributed as each call to &lt;code&gt;new&lt;/code&gt; can trigger the GC and thus take &lt;code&gt;maxPause&lt;/code&gt; time.</source>
          <target state="translated">Вы можете вызвать &lt;code&gt;GC_SetMaxPause&lt;/code&gt; при запуске программы, и тогда каждый запускаемый запуск GC пытается не занять больше времени, чем &lt;code&gt;maxPause&lt;/code&gt; . Однако возможно (и часто), что работа, тем не менее, распределяется неравномерно, поскольку каждый вызов &lt;code&gt;new&lt;/code&gt; может запускать &lt;code&gt;maxPause&lt;/code&gt; и, таким образом, принимать время maxPause .</target>
        </trans-unit>
        <trans-unit id="36174c6fb37927600d8d222f40bdfea256eae11d" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;GC_SetMaxPause&lt;/code&gt; at program startup and then each triggered garbage collector run tries to not take longer than &lt;code&gt;maxPause&lt;/code&gt; time. However, it is possible (and common) that the work is nevertheless not evenly distributed as each call to &lt;code&gt;new&lt;/code&gt; can trigger the garbage collector and thus take &lt;code&gt;maxPause&lt;/code&gt; time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d868e08bf3946c7157b73bf733855e596866fd1c" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling &lt;a href=&quot;#excl,HashSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409fedb343fbf4112734b304e207a767c54d9c6f" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; on them. Example:</source>
          <target state="translated">Вы можете вызвать эту процедуру для ранее инициализированного хеш-набора, который отбросит все его значения. Это может быть удобнее, чем перебирать существующие значения и вызывать для них &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl ()&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="b94d52a9f40f9d3456df4a8df7e7eb81a57a523b" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized ordered hash set to discard its values. At the moment this is the only proc to remove elements from an ordered hash set. Example:</source>
          <target state="translated">Вы можете вызвать этот proc на предварительно инициализированном упорядоченном хэше,чтобы отменить его значения.На данный момент это единственная функция proc,которая удаляет элементы из упорядоченного набора хэшей.Пример:</target>
        </trans-unit>
        <trans-unit id="0c9f2bb20b3a8bb8c844c809d36ed14d3101dd69" translate="yes" xml:space="preserve">
          <source>You can create your own modules to be compatible with NimScript, and check &lt;a href=&quot;https://nimble.directory&quot;&gt;Nimble&lt;/a&gt; to search for third party modules that may work on NimScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a15a89c8527958b5725cea61c34db20ebbeafb" translate="yes" xml:space="preserve">
          <source>You can find examples of client/server communication in the idetools tests found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt;.</source>
          <target state="translated">Вы можете найти примеры клиент / сервер связи в idetools тестов , найденных в &lt;a href=&quot;#test-suite&quot;&gt;Test Suite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d157a3f2f7ccab099eb8d42373b8eee643ec59fc" translate="yes" xml:space="preserve">
          <source>You can force the evaluation of a certain expression at compile-time by coercing it to a corresponding &lt;code&gt;static&lt;/code&gt; type:</source>
          <target state="translated">Вы можете принудительно вычислить определенное выражение во время компиляции, приведя его к соответствующему &lt;code&gt;static&lt;/code&gt; типу:</target>
        </trans-unit>
        <trans-unit id="0fbd4752c2519417bd7580131c8b434b52acfe30" translate="yes" xml:space="preserve">
          <source>You can generate HTML output through the convenience proc &lt;code&gt;rstToHtml&lt;/code&gt;, which provided an input string with rst markup returns a string with the generated HTML. The final output is meant to be embedded inside a full document you provide yourself, so it won't contain the usual &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; parts.</source>
          <target state="translated">Вы можете сгенерировать вывод HTML с помощью удобной процедуры &lt;code&gt;rstToHtml&lt;/code&gt; , которая предоставила входную строку с первой разметкой, возвращает строку с сгенерированным HTML. Окончательный вывод предназначен для встраивания в полный документ, который вы предоставляете сами, поэтому он не будет содержать обычные части &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db428874c2fa95de5693e83c0a003d99482e25e7" translate="yes" xml:space="preserve">
          <source>You can import the &lt;a href=&quot;rstgen&quot;&gt;packages/docutils/rstgen module&lt;/a&gt; in your programs if you want to reuse the compiler's documentation generation procs.</source>
          <target state="translated">Вы можете импортировать &lt;a href=&quot;rstgen&quot;&gt;модуль packages / documenttils / rstgen&lt;/a&gt; в свои программы, если хотите повторно использовать процессы генерации документации компилятора.</target>
        </trans-unit>
        <trans-unit id="26dd058177b18bbce0e1976ca233b4444e8bfaa9" translate="yes" xml:space="preserve">
          <source>You can inline adhoc comparison procs with the &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;do notation&lt;/a&gt;. Example:</source>
          <target state="translated">Вы можете встроить специальные процессы сравнения с &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;нотацией do&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="efd5e3f984449b138f9e80e01560768d39a51ce8" translate="yes" xml:space="preserve">
          <source>You can inline adhoc comparison procs with the &lt;a href=&quot;manual_experimental#do-notation&quot;&gt;do notation&lt;/a&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ee456de749cd07f777df2dbfca526efcaac8de" translate="yes" xml:space="preserve">
          <source>You can make one overload matching with a constraint and one without, and the one with a constraint will have precedence, and so you can handle both cases differently.</source>
          <target state="translated">Вы можете сделать одно совпадение по перегрузке с ограничением и одно без него,а одно с ограничением будет иметь приоритет,поэтому вы можете обрабатывать оба случая по-разному.</target>
        </trans-unit>
        <trans-unit id="a3e0b3e912356fd0eb7d1dfb77943e7ce6efb8f9" translate="yes" xml:space="preserve">
          <source>You can obtain the type of a given expression by constructing a &lt;code&gt;type&lt;/code&gt; value from it (in many other languages this is known as the &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; operator):</source>
          <target state="translated">Вы можете получить тип данного выражения, построив из него значение &lt;code&gt;type&lt;/code&gt; (во многих других языках это называется оператором &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; ):</target>
        </trans-unit>
        <trans-unit id="fef0a20f2b09c4d9edfa4d02db9759a10ded5a2e" translate="yes" xml:space="preserve">
          <source>You can of course use GDB or Visual Studio to debug the compiler (via &lt;code&gt;--debuginfo --lineDir:on&lt;/code&gt;). However, there are also lots of procs that aid in debugging:</source>
          <target state="translated">Конечно, вы можете использовать GDB или Visual Studio для отладки компилятора (через &lt;code&gt;--debuginfo --lineDir:on&lt;/code&gt; ). Однако есть также множество процедур, которые помогают в отладке:</target>
        </trans-unit>
        <trans-unit id="3f1dcc44050776a85f416ff13b391cd7420a7ea6" translate="yes" xml:space="preserve">
          <source>You can pass a block of statements as the last argument to a template following the special &lt;code&gt;:&lt;/code&gt; syntax:</source>
          <target state="translated">Вы можете передать блок операторов в качестве последнего аргумента шаблона следующего специальный &lt;code&gt;:&lt;/code&gt; синтаксис:</target>
        </trans-unit>
        <trans-unit id="de9943ccdfa9f733cf2cde821140c6ff9f7f54f8" translate="yes" xml:space="preserve">
          <source>You can pass any additional options such as &lt;code&gt;-d:leanCompiler&lt;/code&gt; if you don't need certain features or &lt;code&gt;-d:debug --stacktrace:on --excessiveStackTrace --stackTraceMsgs&lt;/code&gt; for debugging the compiler. See also &lt;a href=&quot;intern#debugging-the-compiler&quot;&gt;Debugging the compiler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96758067b5a0f32b36e397740ce0787c73dee231" translate="yes" xml:space="preserve">
          <source>You can peek returned stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6b44f09ab99fcb89435c32281cfd112526a80f" translate="yes" xml:space="preserve">
          <source>You can run peek operation to returned stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3235ae291f967014004169d6dd7919accac84950" translate="yes" xml:space="preserve">
          <source>You can then begin accepting connections using the &lt;code&gt;accept&lt;/code&gt; procedure.</source>
          <target state="translated">Затем вы можете начать принимать соединения, используя процедуру &lt;code&gt;accept&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="229f698a5d2a1c44c1f9b047aaac16d395d3ac54" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;#discardableprefix &quot;&quot;&lt;/code&gt; to &lt;em&gt;always&lt;/em&gt; add the &lt;code&gt;.discardable&lt;/code&gt; pragma since every name starts with the empty string prefix.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;#discardableprefix &quot;&quot;&lt;/code&gt; , чтобы &lt;em&gt;всегда&lt;/em&gt; добавлять прагму &lt;code&gt;.discardable&lt;/code&gt; , поскольку каждое имя начинается с префикса пустой строки.</target>
        </trans-unit>
        <trans-unit id="31a4b169ec568b104fcd414ec6ef62dff7bef87e" translate="yes" xml:space="preserve">
          <source>You can use NimScript to deploy to production, run tests, build projects, do benchmarks, generate documentation, and all kinds of DevOps/SysAdmin specific tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522e6e68fd4224a4e7b5d122bef202f975c7268d" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;fmt&lt;/code&gt; or the unary &lt;code&gt;&amp;amp;&lt;/code&gt; operator for formatting. The difference between them is subtle but important.</source>
          <target state="translated">Для форматирования можно использовать либо &lt;code&gt;fmt&lt;/code&gt; , либо унарный оператор &lt;code&gt;&amp;amp;&lt;/code&gt; . Разница между ними тонкая, но важная.</target>
        </trans-unit>
        <trans-unit id="2385979f1e2cb34c5a4d63322747823dfb72c102" translate="yes" xml:space="preserve">
          <source>You can use the iterators &lt;a href=&quot;#pairs.i,CountTable%5BA%5D&quot;&gt;pairs&lt;/a&gt;, &lt;a href=&quot;#keys.i,CountTable%5BA%5D&quot;&gt;keys&lt;/a&gt;, and &lt;a href=&quot;#values.i,CountTable%5BA%5D&quot;&gt;values&lt;/a&gt; to iterate over &lt;code&gt;t&lt;/code&gt; in the sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad705944ac8aba7f5b1ba7a79096cb62ea1d3012" translate="yes" xml:space="preserve">
          <source>You can use the iterators &lt;a href=&quot;#pairs.i,CountTableRef%5BA%5D&quot;&gt;pairs&lt;/a&gt;, &lt;a href=&quot;#keys.i,CountTableRef%5BA%5D&quot;&gt;keys&lt;/a&gt;, and &lt;a href=&quot;#values.i,CountTableRef%5BA%5D&quot;&gt;values&lt;/a&gt; to iterate over &lt;code&gt;t&lt;/code&gt; in the sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6db4f8bc927328b58f5dd31eba7cffedc758cc6" translate="yes" xml:space="preserve">
          <source>You can use this as a tool to explore the Nim's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.</source>
          <target state="translated">Вы можете использовать это в качестве инструмента для изучения абстрактного синтаксического дерева Nim и определения того,какие узлы должны быть созданы для представления определенного выражения/выражения.</target>
        </trans-unit>
        <trans-unit id="0ddf568174dd61d7a80305dc0a3e7df19330c174" translate="yes" xml:space="preserve">
          <source>You can use this as a tool to write macros quicker by writing example outputs and then copying the snippets into the macro for modification.</source>
          <target state="translated">Вы можете использовать его в качестве инструмента для более быстрого написания макросов,записывая примеры,а затем копируя фрагменты в макрос для модификации.</target>
        </trans-unit>
        <trans-unit id="d1c2d59459a913b746b98925a2a3fc29f24dc533" translate="yes" xml:space="preserve">
          <source>You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</source>
          <target state="translated">Вы можете использовать эту просрочку,чтобы украсить состояние отделения.На некоторых платформах это может помочь процессору лучше предсказать,какая ветка будет запущена.Пример:</target>
        </trans-unit>
        <trans-unit id="a6cd8fbf55f404670383a401ae7b6bcd1b50acf2" translate="yes" xml:space="preserve">
          <source>You can use this proc to transform the elements from a set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34048e340fae2cd8a9b340afd693e3e0e20b294" translate="yes" xml:space="preserve">
          <source>You can use this proc to transform the elements from a set. Example:</source>
          <target state="translated">Вы можете использовать эту proc для преобразования элементов из набора.Пример:</target>
        </trans-unit>
        <trans-unit id="a91b944ee43ceb5d18d013c159338cbb935b2855" translate="yes" xml:space="preserve">
          <source>You can use this template to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</source>
          <target state="translated">Вы можете использовать этот шаблон для украшения состояния ветки.На некоторых платформах это может помочь процессору лучше предсказать,какая ветка будет запущена.Пример:</target>
        </trans-unit>
        <trans-unit id="9e058274075398cc26b01a6b7ed794f3e1a26b4c" translate="yes" xml:space="preserve">
          <source>You can use this to build your own syntax highlighting, check this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786f4a9c940aa7c5a0838e96623ddf57a6935a80" translate="yes" xml:space="preserve">
          <source>You can verify this yourself adding the line &lt;code&gt;echo source&lt;/code&gt; somewhere at the end of the macro and compiling the program. Another difference is that instead of calling the usual &lt;a href=&quot;system#quit&quot;&gt;quit proc&lt;/a&gt; to abort (which we could still call) this version calls the &lt;a href=&quot;macros#error&quot;&gt;error proc&lt;/a&gt; (line 14). The &lt;code&gt;error&lt;/code&gt; proc has the same behavior as &lt;code&gt;quit&lt;/code&gt; but will dump also the source and file line information where the error happened, making it easier for the programmer to find where compilation failed. In this situation it would point to the line invoking the macro, but &lt;strong&gt;not&lt;/strong&gt; the line of &lt;code&gt;data.cfg&lt;/code&gt; we are processing, that's something the macro itself would need to control.</source>
          <target state="translated">Вы можете убедиться в этом сами, добавив &lt;code&gt;echo source&lt;/code&gt; строчного эха где-нибудь в конце макроса и скомпилировав программу. Другое отличие состоит в том, что вместо вызова обычной процедуры &lt;a href=&quot;system#quit&quot;&gt;выхода&lt;/a&gt; для прерывания (которую мы все еще можем вызвать) эта версия вызывает процедуру &lt;a href=&quot;macros#error&quot;&gt;ошибки&lt;/a&gt; (строка 14). Процедура &lt;code&gt;error&lt;/code&gt; имеет то же поведение, что и &lt;code&gt;quit&lt;/code&gt; , но также выводит информацию об источнике и строке файла, где произошла ошибка, что упрощает программисту поиск места сбоя компиляции. В этой ситуации он будет указывать на строку, вызывающую макрос, но &lt;strong&gt;не&lt;/strong&gt; на строку &lt;code&gt;data.cfg&lt;/code&gt; ,которую мы обрабатываем, это то, чем должен управлять сам макрос.</target>
        </trans-unit>
        <trans-unit id="92f1ea59a6005fb17221b573220c7eb96afe4382" translate="yes" xml:space="preserve">
          <source>You cannot perform peek/write/setOption operations to this stream. Use &lt;a href=&quot;#peekableErrorStream,Process&quot;&gt;peekableErrorStream proc&lt;/a&gt; if you need to peek stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a55706dc42f105735697061fa660a19336cf0e" translate="yes" xml:space="preserve">
          <source>You cannot perform peek/write/setOption operations to this stream. Use &lt;a href=&quot;#peekableOutputStream,Process&quot;&gt;peekableOutputStream proc&lt;/a&gt; if you need to peek stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1927317fdc7e6a2effb5166b6eaa7c316bb014" translate="yes" xml:space="preserve">
          <source>You may add a constraint to the resulting type to trigger a compile-time error if the expression doesn't have the expected type:</source>
          <target state="translated">Если выражение не имеет ожидаемого типа,можно добавить ограничение на результирующий тип,чтобы спровоцировать ошибку компиляции:</target>
        </trans-unit>
        <trans-unit id="2ca8ec20025fee9a409388762110a23a28945941" translate="yes" xml:space="preserve">
          <source>You may also find it useful to use this &lt;a href=&quot;https://github.com/dom96/prometheus&quot;&gt;prometheus package&lt;/a&gt; which will log the pending futures into prometheus, allowing you to analyse them via a nice graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f30ee997aa1c1a9a827cafb053cce15b31f0463" translate="yes" xml:space="preserve">
          <source>You may specify a callback procedure to be called during an HTTP request. This callback will be executed every second with information about the progress of the HTTP request.</source>
          <target state="translated">Вы можете указать процедуру обратного вызова,которая будет вызвана во время HTTP-запроса.Этот обратный вызов будет выполняться каждую секунду с информацией о ходе выполнения HTTP-запроса.</target>
        </trans-unit>
        <trans-unit id="5dd8d98d03acf607976a61f844d04f595a458ee9" translate="yes" xml:space="preserve">
          <source>You must create a new SSL context with the &lt;code&gt;newContext&lt;/code&gt; function defined in the &lt;code&gt;net&lt;/code&gt; module. You may then call &lt;code&gt;wrapSocket&lt;/code&gt; on your socket using the newly created SSL context to get an SSL socket.</source>
          <target state="translated">Вы должны создать новый контекст SSL с &lt;code&gt;newContext&lt;/code&gt; функции newContext, определенной в модуле &lt;code&gt;net&lt;/code&gt; . Затем вы можете вызвать &lt;code&gt;wrapSocket&lt;/code&gt; в своем сокете, используя только что созданный контекст SSL, чтобы получить сокет SSL.</target>
        </trans-unit>
        <trans-unit id="536dd70e47958cfa1309fb9e5c1a1f72e1c1ece3" translate="yes" xml:space="preserve">
          <source>You need to &lt;a href=&quot;#close,Process&quot;&gt;close&lt;/a&gt; the process when done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f02dcaa349af52efc752e41b14a80f4aa7a8f58" translate="yes" xml:space="preserve">
          <source>You need to call this before using a &lt;code&gt;RstGenerator&lt;/code&gt; with any other procs in this module. Pass a non &lt;code&gt;nil&lt;/code&gt;&lt;code&gt;StringTableRef&lt;/code&gt; value as &lt;code&gt;config&lt;/code&gt; with parameters used by the HTML output generator. If you don't know what to use, pass the results of the &lt;code&gt;defaultConfig() &amp;lt;#defaultConfig&amp;gt;_&lt;/code&gt; proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36e9e49af8f68c7f3865ace300bab1eeae94fdd" translate="yes" xml:space="preserve">
          <source>You need to call this before using a &lt;code&gt;RstGenerator&lt;/code&gt; with any other procs in this module. Pass a non &lt;code&gt;nil&lt;/code&gt;&lt;code&gt;StringTableRef&lt;/code&gt; value as &lt;em&gt;config&lt;/em&gt; with parameters used by the HTML output generator. If you don't know what to use, pass the results of the &lt;em&gt;defaultConfig() &amp;lt;#defaultConfig&amp;gt;_&lt;/em&gt; proc.</source>
          <target state="translated">Вам необходимо вызвать это перед использованием &lt;code&gt;RstGenerator&lt;/code&gt; с любыми другими процессами в этом модуле. Передайте значение &lt;code&gt;StringTableRef&lt;/code&gt; ,отличное от &lt;code&gt;nil&lt;/code&gt; ,в качестве &lt;em&gt;конфигурации&lt;/em&gt; с параметрами, используемыми генератором вывода HTML. Если вы не знаете, что использовать, передайте результаты &lt;em&gt;defaultConfig () &amp;lt;#defaultConfig&amp;gt; _&lt;/em&gt; proc.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e99014be72901d30cf9903b89e767bc47ddd9adc" translate="yes" xml:space="preserve">
          <source>You need to make sure that &lt;code&gt;fromAddr&lt;/code&gt; and &lt;code&gt;toAddrs&lt;/code&gt; don't contain any newline characters. Failing to do so will raise &lt;code&gt;AssertionDefect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628b0c494a0fc9a208f986729cf9af920542035a" translate="yes" xml:space="preserve">
          <source>You need to make sure that &lt;code&gt;mSubject&lt;/code&gt;, &lt;code&gt;mTo&lt;/code&gt; and &lt;code&gt;mCc&lt;/code&gt; don't contain any newline characters. Failing to do so will raise &lt;code&gt;AssertionDefect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1815471bce16da5553a9fd3eceb5099d8be523e4" translate="yes" xml:space="preserve">
          <source>You need to make sure that the &lt;code&gt;url&lt;/code&gt; doesn't contain any newline characters. Failing to do so will raise &lt;code&gt;AssertionDefect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768d3b1f449e8e44f77a2b81c1991631053c4aa0" translate="yes" xml:space="preserve">
          <source>You need to make sure that the message &lt;code&gt;m&lt;/code&gt; doesn't contain any newline characters. Failing to do so will raise &lt;code&gt;AssertionDefect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450b5c3a1da9d0e1fa5bb777f9cd543e75eb7cd9" translate="yes" xml:space="preserve">
          <source>You need to pass at least one element or the proc will assert in debug builds and crash on release builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6aec2725098b8ffc1761bd9c7f7b9f1682bf6e2" translate="yes" xml:space="preserve">
          <source>You previously need to add entries to the index with the &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; proc. If the index is empty the file won't be created.</source>
          <target state="translated">Ранее вам нужно было добавить записи в индекс с помощью процедуры &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm ()&lt;/a&gt; . Если индекс пуст, файл не будет создан.</target>
        </trans-unit>
        <trans-unit id="441987ce595f159ce24b92f3d1cf8ed65cb9679a" translate="yes" xml:space="preserve">
          <source>You previously need to add entries to the index with the &lt;a href=&quot;#setIndexTerm,RstGenerator,string,string,string,string,string&quot;&gt;setIndexTerm()&lt;/a&gt; proc. If the index is empty the file won't be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737fc4006bdf416ca1aa1927d2320a57138985ef" translate="yes" xml:space="preserve">
          <source>You should prefer to call &lt;code&gt;acceptRequest&lt;/code&gt; instead with a custom server loop so that you're in control over the error handling and logging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d047869868e7ac2dd137df50888c63412be12d0" translate="yes" xml:space="preserve">
          <source>You should send this before sending your HTML page, for example.</source>
          <target state="translated">Например,вы должны отправить это перед отправкой HTML-страницы.</target>
        </trans-unit>
        <trans-unit id="3d103567ee18cb5218c37709ddcec0d6177298f4" translate="yes" xml:space="preserve">
          <source>You will also have to compile with &lt;code&gt;ssl&lt;/code&gt; defined like so: &lt;code&gt;nim c -d:ssl ...&lt;/code&gt;.</source>
          <target state="translated">Вы также должны собрать с помощью &lt;code&gt;ssl&lt;/code&gt; , определенной следующим образом: &lt;code&gt;nim c -d:ssl ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9c34b8df4c5ac422a24f59076119b6a4247781a" translate="yes" xml:space="preserve">
          <source>Zero and negative numbers are not a power of two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9eb3bc3ec64f5874a762feb41843df520cfd18d" translate="yes" xml:space="preserve">
          <source>Zero and negative numbers get rounded up to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058062ffe3d7415398c63db4c4c474b3de0c89a9" translate="yes" xml:space="preserve">
          <source>Zero or One</source>
          <target state="translated">Ноль или один</target>
        </trans-unit>
        <trans-unit id="42ff50143f9dda79f19f7750e8d1e6ebfb6a9117" translate="yes" xml:space="preserve">
          <source>Zero or more</source>
          <target state="translated">Ноль или более</target>
        </trans-unit>
        <trans-unit id="225c32bbd814f50677575343a2af6f98ab452cb4" translate="yes" xml:space="preserve">
          <source>Zero or more: Apply expression &lt;code&gt;E&lt;/code&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any). Always indicate success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0e6558a1175af4a938d82662dd24b2fa417681" translate="yes" xml:space="preserve">
          <source>Zero or more: Apply expression &lt;em&gt;E&lt;/em&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any). Always indicate success.</source>
          <target state="translated">Ноль или более: многократно применяйте выражение &lt;em&gt;E,&lt;/em&gt; чтобы соответствовать тексту впереди, если оно будет успешным. Использовать совпавший текст (если есть). Всегда указывайте на успех.</target>
        </trans-unit>
        <trans-unit id="e13005fad6e40191c809667ff4527563540506f8" translate="yes" xml:space="preserve">
          <source>Zero or one: If expression &lt;code&gt;E&lt;/code&gt; matches the text ahead, consume it. Always indicate success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a721c45ae571dec5e2aa89e2c4b85966c95f70" translate="yes" xml:space="preserve">
          <source>Zero or one: If expression &lt;em&gt;E&lt;/em&gt; matches the text ahead, consume it. Always indicate success.</source>
          <target state="translated">Ноль или один: если выражение &lt;em&gt;E&lt;/em&gt; соответствует тексту впереди, используйте его. Всегда указывайте на успех.</target>
        </trans-unit>
        <trans-unit id="2af78455018bdfce1224f9a413429c8d1cf682b3" translate="yes" xml:space="preserve">
          <source>Zero value for durations. Useful for comparisons.</source>
          <target state="translated">Нулевое значение для продолжительности.Полезно для сравнения.</target>
        </trans-unit>
        <trans-unit id="6060a4786b6be76ff108ebceec44d2daa4c15f06" translate="yes" xml:space="preserve">
          <source>Zero-indexed counting have two shortcuts &lt;code&gt;..&amp;lt;&lt;/code&gt; and &lt;code&gt;..^&lt;/code&gt; to simplify counting to one less than the higher index:</source>
          <target state="translated">У подсчета с нулевым индексом есть два ярлыка &lt;code&gt;..&amp;lt;&lt;/code&gt; и &lt;code&gt;..^&lt;/code&gt; , чтобы упростить подсчет до одного меньшего, чем более высокий индекс:</target>
        </trans-unit>
        <trans-unit id="20c04b19973470d92242f49b06eef1b73f56d44e" translate="yes" xml:space="preserve">
          <source>Zero:</source>
          <target state="translated">Zero:</target>
        </trans-unit>
        <trans-unit id="8b89c7935e4227693c26bb38dab6ce4cc59d630c" translate="yes" xml:space="preserve">
          <source>[] proc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54bc76320ca46951b95cdd0ab681cbf780a7c2e" translate="yes" xml:space="preserve">
          <source>[]= proc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be19fd422dffae7a0636938f97b2aa24b5cb13a9" translate="yes" xml:space="preserve">
          <source>[default(T), ...]</source>
          <target state="translated">[по умолчанию (T), ...]</target>
        </trans-unit>
        <trans-unit id="725341cb2d0f3c779b1327977070fadc20557a50" translate="yes" xml:space="preserve">
          <source>[deprecated] Start types with a capital &lt;code&gt;T&lt;/code&gt;, unless they are pointers/references which start with &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c1c85e428b2e6ebcfe53d58ea3210e8ab6cc25" translate="yes" xml:space="preserve">
          <source>^ proc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371ecc3918ac9832694f112b1cde6b20c8008173" translate="yes" xml:space="preserve">
          <source>`$`:</source>
          <target state="translated">`$`:</target>
        </trans-unit>
        <trans-unit id="11ee73713a5957d1c36553f7b429779054fa253e" translate="yes" xml:space="preserve">
          <source>`%`:</source>
          <target state="translated">`%`:</target>
        </trans-unit>
        <trans-unit id="41545b1430077baa11ec6fa83c225da8abe403ed" translate="yes" xml:space="preserve">
          <source>`&amp;amp;`:</source>
          <target state="translated">`&amp;amp;`:</target>
        </trans-unit>
        <trans-unit id="d8f7ea3a6b1c4c48cd7a700315a88ee7bc6a687f" translate="yes" xml:space="preserve">
          <source>`&amp;lt;=`:</source>
          <target state="translated">`&amp;lt;=`:</target>
        </trans-unit>
        <trans-unit id="976d0279af4eea7fb942f226e53f3f50881762b8" translate="yes" xml:space="preserve">
          <source>`&amp;lt;`:</source>
          <target state="translated">`&amp;lt;`:</target>
        </trans-unit>
        <trans-unit id="847e31187f83a3335456a3f40b8940007dd68407" translate="yes" xml:space="preserve">
          <source>`*=`:</source>
          <target state="translated">`*=`:</target>
        </trans-unit>
        <trans-unit id="5bc553896438f181cc7995e4eb398d952e01fdf4" translate="yes" xml:space="preserve">
          <source>`*`:</source>
          <target state="translated">`*`:</target>
        </trans-unit>
        <trans-unit id="e3953df9a5db82ff4ece5adbb279d2c461636172" translate="yes" xml:space="preserve">
          <source>`+=`:</source>
          <target state="translated">`+=`:</target>
        </trans-unit>
        <trans-unit id="44b4104641bfde4f4384922de79c977971467dcb" translate="yes" xml:space="preserve">
          <source>`+`:</source>
          <target state="translated">`+`:</target>
        </trans-unit>
        <trans-unit id="0ff5ae87fb15c748cc5a95c88a16a2e7a8fbceb0" translate="yes" xml:space="preserve">
          <source>`-=`:</source>
          <target state="translated">`-=`:</target>
        </trans-unit>
        <trans-unit id="5e0d3b10f837f56a00e6f74eaea4d2e410c02da6" translate="yes" xml:space="preserve">
          <source>`-`:</source>
          <target state="translated">`-`:</target>
        </trans-unit>
        <trans-unit id="6b2df1d06dbd13007c498d563bb9319e30e79789" translate="yes" xml:space="preserve">
          <source>`/`:</source>
          <target state="translated">`/`:</target>
        </trans-unit>
        <trans-unit id="a702c9636ffdac06c22c5fcaccae945de70590ef" translate="yes" xml:space="preserve">
          <source>`==`:</source>
          <target state="translated">`==`:</target>
        </trans-unit>
        <trans-unit id="c532728e4314439eba81ce91aae1705cd2f0d283" translate="yes" xml:space="preserve">
          <source>`??`:</source>
          <target state="translated">`??`:</target>
        </trans-unit>
        <trans-unit id="4d6cdbc688fe70cc00178dec81d57b0a392370ef" translate="yes" xml:space="preserve">
          <source>`[]=`:</source>
          <target state="translated">`[]=`:</target>
        </trans-unit>
        <trans-unit id="1be0b27d1fc97bd5cb1ec8d4ebfb2a55addb15f2" translate="yes" xml:space="preserve">
          <source>`[]`:</source>
          <target state="translated">`[]`:</target>
        </trans-unit>
        <trans-unit id="586638f457645338d33d63761281c221a23a1f55" translate="yes" xml:space="preserve">
          <source>`div`:</source>
          <target state="translated">`div`:</target>
        </trans-unit>
        <trans-unit id="c381745b80f7dcd1a8969b63f332aae419494122" translate="yes" xml:space="preserve">
          <source>`mod`:</source>
          <target state="translated">`mod`:</target>
        </trans-unit>
        <trans-unit id="7749321cac8293dfb4116f22eb6fcf0c9d4c4765" translate="yes" xml:space="preserve">
          <source>`shl`:</source>
          <target state="translated">`shl`:</target>
        </trans-unit>
        <trans-unit id="fdf5b59f33b1c6600da8344413c66e95fe677d26" translate="yes" xml:space="preserve">
          <source>`shr`:</source>
          <target state="translated">`shr`:</target>
        </trans-unit>
        <trans-unit id="1017c901abb02f8893c41373551fbb054bdde2c5" translate="yes" xml:space="preserve">
          <source>`|*|`:</source>
          <target state="translated">`|*|`:</target>
        </trans-unit>
        <trans-unit id="121541bf72dab89f27211a54be372b6f9975dc37" translate="yes" xml:space="preserve">
          <source>`|+|`:</source>
          <target state="translated">`|+|`:</target>
        </trans-unit>
        <trans-unit id="37999d7d1ef6f471b5c0d50acf800904aa2fa893" translate="yes" xml:space="preserve">
          <source>`|-|`:</source>
          <target state="translated">`|-|`:</target>
        </trans-unit>
        <trans-unit id="c733403d0e712203c63fa82e7f7135997be2918a" translate="yes" xml:space="preserve">
          <source>`|abs|`:</source>
          <target state="translated">`|abs|`:</target>
        </trans-unit>
        <trans-unit id="326c5eeec777158d2150463ba65036b7c861a93d" translate="yes" xml:space="preserve">
          <source>`|div|`:</source>
          <target state="translated">`|div|`:</target>
        </trans-unit>
        <trans-unit id="73a677eb50a90a7dc1cd484584bc13523f3e0505" translate="yes" xml:space="preserve">
          <source>`|mod|`:</source>
          <target state="translated">`|mod|`:</target>
        </trans-unit>
        <trans-unit id="3260d07b4b25223a8645751735794410787c060e" translate="yes" xml:space="preserve">
          <source>`~`:</source>
          <target state="translated">`~`:</target>
        </trans-unit>
        <trans-unit id="e5176dbef42a406c169d587b0655624ce1159b6a" translate="yes" xml:space="preserve">
          <source>a &amp;amp; b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37f6cc195c1e8086901c5a7d04cf29e2f0b24fc" translate="yes" xml:space="preserve">
          <source>a &amp;lt; b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76bcb53e7fa75d08af319378fe95ba44e0341af6" translate="yes" xml:space="preserve">
          <source>a * b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e17da83cb99df2cd97660136aec7f67a2a9d641" translate="yes" xml:space="preserve">
          <source>a + b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278f96e8954808de5c6166fde0ae0b15f4876a3c" translate="yes" xml:space="preserve">
          <source>a - b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ca1dd1bea0541c6a3a1ff782308757b21ca927" translate="yes" xml:space="preserve">
          <source>a .. b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849f46055dbfb5ab989b68969bf5c16c1eeeda04" translate="yes" xml:space="preserve">
          <source>a ..&amp;lt; b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e6b28f1c2dc315223c6c96b4dcd47b8339bd9c" translate="yes" xml:space="preserve">
          <source>a ..^ b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6181759dbfbc1d13cea8897bba860e1cd1f1b7f" translate="yes" xml:space="preserve">
          <source>a channel for thread communication</source>
          <target state="translated">канал речевой связи</target>
        </trans-unit>
        <trans-unit id="ceb1c4b07f128179a3a629f3d8297730fe20d8c2" translate="yes" xml:space="preserve">
          <source>a color stored as RGB</source>
          <target state="translated">цвет,сохранённый в RGB</target>
        </trans-unit>
        <trans-unit id="d0b439a1db8b1636f87a882db4e959779e8dfe6b" translate="yes" xml:space="preserve">
          <source>a compiled regular expression</source>
          <target state="translated">скомпилированное регулярное выражение</target>
        </trans-unit>
        <trans-unit id="446a499c83ee189e881728b9614bb1c610b42820" translate="yes" xml:space="preserve">
          <source>a complex number, consisting of a real and an imaginary part</source>
          <target state="translated">комплексное число,состоящее из реальной и воображаемой части.</target>
        </trans-unit>
        <trans-unit id="d4c0dd8cbb911234aafd65e42ebe2e16d8dd9a13" translate="yes" xml:space="preserve">
          <source>a convenience proc that runs the &lt;em&gt;command&lt;/em&gt;, grabs all its output and exit code and returns both.</source>
          <target state="translated">удобный процесс , который запускает &lt;em&gt;команду&lt;/em&gt; , берет весь ее вывод и код выхода и возвращает оба.</target>
        </trans-unit>
        <trans-unit id="3d1d312821fd56659d05a796c0721e1a9ac1ecd1" translate="yes" xml:space="preserve">
          <source>a convenience procedure for:</source>
          <target state="translated">удобная процедура для:</target>
        </trans-unit>
        <trans-unit id="697ab90ee8ea779b4e9d7e4d582cc0de7bbcb857" translate="yes" xml:space="preserve">
          <source>a data flow variable</source>
          <target state="translated">переменная потока данных</target>
        </trans-unit>
        <trans-unit id="236302a21803b39674181eb1c1e1dad827d987da" translate="yes" xml:space="preserve">
          <source>a distinct string type that is &lt;span id=&quot;tainted_1&quot;&gt;tainted&lt;/span&gt;, see &lt;a href=&quot;manual#taint-mode&quot;&gt;taint mode&lt;/a&gt; for details. It is an alias for &lt;code&gt;string&lt;/code&gt; if the taint mode is not turned on.</source>
          <target state="translated">отдельный тип строки, который &lt;span id=&quot;tainted_1&quot;&gt;испорчен&lt;/span&gt; , подробности см. в &lt;a href=&quot;manual#taint-mode&quot;&gt;режиме taint&lt;/a&gt; . Это псевдоним для &lt;code&gt;string&lt;/code&gt; если режим заражения не включен.</target>
        </trans-unit>
        <trans-unit id="24c60b77672236b3310392791c9159e7da691559" translate="yes" xml:space="preserve">
          <source>a doubly linked list</source>
          <target state="translated">двойной список</target>
        </trans-unit>
        <trans-unit id="92f8d2cb7eddeae18a8926cceebe9ab14e904d46" translate="yes" xml:space="preserve">
          <source>a doubly linked ring</source>
          <target state="translated">двойное кольцо</target>
        </trans-unit>
        <trans-unit id="9667a5641fafbc88c7babe208bd484588610acb6" translate="yes" xml:space="preserve">
          <source>a handle that can be</source>
          <target state="translated">ручка,которая может быть</target>
        </trans-unit>
        <trans-unit id="c673f94589cd025a94f4df85ea7cbc620e46a6b6" translate="yes" xml:space="preserve">
          <source>a handle that can be used to get a row's column text on demand</source>
          <target state="translated">рукоятка,которая может быть использована для получения текста столбца строки по требованию.</target>
        </trans-unit>
        <trans-unit id="9e35a0ed419e04673fabc57db7de755c9a5158d9" translate="yes" xml:space="preserve">
          <source>a handle to a dynamically loaded library</source>
          <target state="translated">ручка к динамически загружаемой библиотеке</target>
        </trans-unit>
        <trans-unit id="727eb5fb1890186a7705b301c37bcb5a3a011c04" translate="yes" xml:space="preserve">
          <source>a hash value; hash tables using these values should always have a size of a power of two and can use the &lt;code&gt;and&lt;/code&gt; operator instead of &lt;code&gt;mod&lt;/code&gt; for truncation of the hash value.</source>
          <target state="translated">хеш-значение; хэш-таблицы, использующие эти значения, всегда должны иметь размер, равный степени двойки, и могут использовать оператор &lt;code&gt;and&lt;/code&gt; вместо &lt;code&gt;mod&lt;/code&gt; для усечения хеш-значения.</target>
        </trans-unit>
        <trans-unit id="fb7c3a20e1c58ee4786768f999120ebe9f74132e" translate="yes" xml:space="preserve">
          <source>a identifier for the prepared queries</source>
          <target state="translated">идентификатор подготовленных запросов</target>
        </trans-unit>
        <trans-unit id="e15266dcad2adbaa4f2ad63108ef729cf76beda5" translate="yes" xml:space="preserve">
          <source>a node a doubly linked list consists of</source>
          <target state="translated">узел двойного списка состоит из</target>
        </trans-unit>
        <trans-unit id="5ba782577875c08c01d890dce7e8dd4aecffd0bd" translate="yes" xml:space="preserve">
          <source>a node a singly linked list consists of</source>
          <target state="translated">узел единственно связанного списка состоит из</target>
        </trans-unit>
        <trans-unit id="c5092df10e1c3e85e7d83e22f3d8ff19de9aee98" translate="yes" xml:space="preserve">
          <source>a parallel section can be used to execute a block in parallel. &lt;code&gt;body&lt;/code&gt; has to be in a DSL that is a particular subset of the language. Please refer to the manual for further information.</source>
          <target state="translated">параллельная секция может использоваться для параллельного выполнения блока. &lt;code&gt;body&lt;/code&gt; должно быть в DSL, который является определенным подмножеством языка. Пожалуйста, обратитесь к руководству для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b464620548b26647c2039d50b3534a202b2e5405" translate="yes" xml:space="preserve">
          <source>a rational number, consisting of a numerator and denominator</source>
          <target state="translated">рациональное число,состоящее из числителя и знаменателя</target>
        </trans-unit>
        <trans-unit id="69540ea7fe9bd9fdc5e24939d260de6bfcf3083e" translate="yes" xml:space="preserve">
          <source>a row in a CSV file</source>
          <target state="translated">строка в CSV-файле</target>
        </trans-unit>
        <trans-unit id="a5ec37625145ddf6373e511cf4b862af7fe73b7a" translate="yes" xml:space="preserve">
          <source>a row of a dataset. NULL database values will be converted to nil.</source>
          <target state="translated">ряд данных.Значения NULL базы данных будут преобразованы в ноль.</target>
        </trans-unit>
        <trans-unit id="f0a9a46cf5d23594a7585e289276bf5ca00498ca" translate="yes" xml:space="preserve">
          <source>a set of files and directories from the &lt;a href=&quot;ssl_certs&quot;&gt;ssl_certs&lt;/a&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9fa41fb39e8c2391daf5b73b38611f05be5128" translate="yes" xml:space="preserve">
          <source>a shortcut for '.. ^' to avoid the common gotcha that a space between '..' and '^' is required.</source>
          <target state="translated">ярлык для &quot;...^',чтобы избежать общей точки зрения,что требуется пробел между &quot;...&quot; и '^'.</target>
        </trans-unit>
        <trans-unit id="302bd8c00ad8f3e86bc63558821e98698620a746" translate="yes" xml:space="preserve">
          <source>a shortcut for 'a .. (when b is BackwardsIndex: succ(b) else: pred(b))'.</source>
          <target state="translated">ярлык для 'a ...(когда b-BackwardsIndex:succ(b)else:pre(b))'.</target>
        </trans-unit>
        <trans-unit id="440e2c2edfe2d93548694539384ebaec70e26a08" translate="yes" xml:space="preserve">
          <source>a shorthand for &lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt;.</source>
          <target state="translated">сокращение от &lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1ea92069e80f9a3e02b527138ba54f9fbd0ee56" translate="yes" xml:space="preserve">
          <source>a simple barrier to wait for all spawn'ed tasks. If you need more elaborate waiting, you have to use an explicit barrier.</source>
          <target state="translated">простой барьер,чтобы ждать всех нерестовых заданий.Если вам нужно более тщательное ожидание,вы должны использовать явный барьер.</target>
        </trans-unit>
        <trans-unit id="0c6d3caa14558753d210d77ea2d36fd6a1513d28" translate="yes" xml:space="preserve">
          <source>a single backslash</source>
          <target state="translated">один обратный слеш</target>
        </trans-unit>
        <trans-unit id="837f51c3591f8b2d4452f90b5ddbc53e912a5c22" translate="yes" xml:space="preserve">
          <source>a singly linked list</source>
          <target state="translated">единый список</target>
        </trans-unit>
        <trans-unit id="216912de21be007513f346fea51719c0bc9710bb" translate="yes" xml:space="preserve">
          <source>a singly linked ring</source>
          <target state="translated">единственное связанное кольцо</target>
        </trans-unit>
        <trans-unit id="fca33daf462dcc183c16697e01011fdb26d89e19" translate="yes" xml:space="preserve">
          <source>a standard ASCII identifier: &lt;code&gt;[a-zA-Z_][a-zA-Z_0-9]*&lt;/code&gt;</source>
          <target state="translated">стандартный идентификатор ASCII: &lt;code&gt;[a-zA-Z_][a-zA-Z_0-9]*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e234deb8ba8a81933c4f81a3052a4d28e6cd985e" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a &lt;code&gt;MemFile&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
