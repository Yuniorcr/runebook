<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="1e8e7ed4df7e1d79df73533103355f606bd486f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allowRemap&lt;/code&gt; only needs to be true if you want to call &lt;code&gt;mapMem&lt;/code&gt; on the resulting MemFile; else file handles are not kept open.</source>
          <target state="translated">&lt;code&gt;allowRemap&lt;/code&gt; должен быть истинным только в том случае, если вы хотите вызвать &lt;code&gt;mapMem&lt;/code&gt; для полученного MemFile; иначе дескрипторы файлов не остаются открытыми.</target>
        </trans-unit>
        <trans-unit id="51fff43aca9a3f3d76b1af35103a5af6f22e4951" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asyncdispatch&lt;/code&gt; module (event loop)</source>
          <target state="translated">&lt;code&gt;asyncdispatch&lt;/code&gt; модуль asyncdispatch (цикл событий)</target>
        </trans-unit>
        <trans-unit id="8fee4462a1fc6f7ca065434924f5269dc4e549ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asyncnet&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;asyncnet&lt;/code&gt; модуль asyncnet</target>
        </trans-unit>
        <trans-unit id="498123f82aff644359d1fd4cd6bfb34e823defde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b[11..^2]&lt;/code&gt; is the portion &quot;useless&quot;, and &lt;code&gt;b[11..^2] = &quot;useful&quot;&lt;/code&gt; replaces the &quot;useless&quot; portion with &quot;useful&quot;, giving the result &quot;Slices are useful.&quot;</source>
          <target state="translated">&lt;code&gt;b[11..^2]&lt;/code&gt; - это часть &amp;laquo;бесполезная&amp;raquo;, а &lt;code&gt;b[11..^2] = &quot;useful&quot;&lt;/code&gt; заменяет &amp;laquo;бесполезную&amp;raquo; часть на &amp;laquo;полезную&amp;raquo;, давая результат &amp;laquo;Срезы полезны&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d2ea31cf1c26dd26b1244e5ffea23471a18ded80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cast[T](x)&lt;/code&gt; in JavaScript is translated to &lt;code&gt;(x)&lt;/code&gt;, except for casting between signed/unsigned ints, in which case it behaves as static cast in C language.</source>
          <target state="translated">&lt;code&gt;cast[T](x)&lt;/code&gt; в JavaScript преобразуется в &lt;code&gt;(x)&lt;/code&gt; , за исключением преобразования между целыми числами со знаком / без знака, и в этом случае он ведет себя как статическое приведение в языке C.</target>
        </trans-unit>
        <trans-unit id="78e583a6ca5943602d2fea749731670fb16ec519" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const NimVersion = &quot;0.0.0&quot;&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#NimVersion&quot;&gt;#NimVersion&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;const NimVersion = &quot;0.0.0&quot;&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#NimVersion&quot;&gt;#NimVersion&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61889a3978487883ade1aa88a933aede33e10d71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cstring&lt;/code&gt; in JavaScript means JavaScript string. It is a good practice to use &lt;code&gt;cstring&lt;/code&gt; only when it is semantically appropriate. E.g. don't use &lt;code&gt;cstring&lt;/code&gt; as a binary data buffer.</source>
          <target state="translated">&lt;code&gt;cstring&lt;/code&gt; в JavaScript означает строку JavaScript. Рекомендуется использовать &lt;code&gt;cstring&lt;/code&gt; только тогда, когда это семантически приемлемо. Например, не используйте &lt;code&gt;cstring&lt;/code&gt; в качестве буфера двоичных данных.</target>
        </trans-unit>
        <trans-unit id="ac407e594720119511a2dff99e2c8cb540795818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt; is written after the parentheses enclosing the regular proc params. The proc expression represented by the do block is appended to them. In calls using the command syntax, the do block will bind to the immediately preceeding expression, transforming it in a call.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; пишется после круглых скобок, заключающих обычные параметры процедуры. К ним добавляется выражение proc, представленное блоком do. В вызовах, использующих синтаксис команды, блок do будет связываться с непосредственно предшествующим выражением, преобразовывая его в вызов.</target>
        </trans-unit>
        <trans-unit id="560a65c3942b87610678dbe71906d997387954ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt; with parentheses is an anonymous &lt;code&gt;proc&lt;/code&gt;; however a &lt;code&gt;do&lt;/code&gt; without parentheses is just a block of code. The &lt;code&gt;do&lt;/code&gt; notation can be used to pass multiple blocks to a macro:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; с помощью скобок является анонимным &lt;code&gt;proc&lt;/code&gt; ; однако &lt;code&gt;do&lt;/code&gt; без круглых скобок - это всего лишь блок кода. &lt;code&gt;do&lt;/code&gt; обозначение может использоваться для передачи несколько блоков в макрос:</target>
        </trans-unit>
        <trans-unit id="f8bfd3653988749a0a70c5e576012e23dd595dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; must be &lt;code&gt;gcsafe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; должен быть &lt;code&gt;gcsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d47873c2e8cae488fed6cb4e83f288d75cc0a265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; must not have the calling convention &lt;code&gt;closure&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; не должно иметь &lt;code&gt;closure&lt;/code&gt; соглашения о вызовах .</target>
        </trans-unit>
        <trans-unit id="0fc4e09f9db81a165920ce36aaee0a3d848f2fbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;'s parameters may not be of type &lt;code&gt;var&lt;/code&gt;. This means one has to use raw &lt;code&gt;ptr&lt;/code&gt;'s for data passing reminding the programmer to be careful.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; Параметры f не могут быть типа &lt;code&gt;var&lt;/code&gt; . Это означает, что для передачи данных необходимо использовать необработанные &lt;code&gt;ptr&lt;/code&gt; , напоминающие программисту о необходимости быть осторожными.</target>
        </trans-unit>
        <trans-unit id="a0a3e940e2d69b10dcd7b011d95e7e271faec390" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findFile&lt;/code&gt; is a proc used by the rst &lt;code&gt;include&lt;/code&gt; directive among others. The purpose of this proc is to mangle or filter paths. It receives paths specified in the rst document and has to return a valid path to existing files or the empty string otherwise. If you pass &lt;code&gt;nil&lt;/code&gt;, a default proc will be used which given a path returns the input path only if the file exists. One use for this proc is to transform relative paths found in the document to absolute path, useful if the rst file and the resources it references are not in the same directory as the current working directory.</source>
          <target state="translated">&lt;code&gt;findFile&lt;/code&gt; - это процедура, используемая, среди прочего, первой директивой &lt;code&gt;include&lt;/code&gt; . Цель этой процедуры - искажать или фильтровать пути. Он получает пути, указанные в первом документе, и должен возвращать действительный путь к существующим файлам или в противном случае пустую строку. Если вы передадите &lt;code&gt;nil&lt;/code&gt; , будет использоваться процедура по умолчанию, которая при заданном пути возвращает входной путь, только если файл существует. Одним из способов использования этой процедуры является преобразование относительных путей, найденных в документе, в абсолютные пути, что полезно, если первый файл и ресурсы, на которые он ссылается, находятся не в том же каталоге, что и текущий рабочий каталог.</target>
        </trans-unit>
        <trans-unit id="8300161461027b1d236fc8fcb5051bea30977ff2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fmt&lt;/code&gt; vs. &lt;code&gt;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fmt&lt;/code&gt; vs. &lt;code&gt;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7037da41cd9a367dd5a1197389e84235b7fd299" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; is syntactic sugar for a proc with no side effects:</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; - это синтаксический сахар для процедуры без побочных эффектов:</target>
        </trans-unit>
        <trans-unit id="924aa797cc590677bd14ef7705744856d8172a99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getTime&lt;/code&gt; should generally be prefered over this proc.</source>
          <target state="translated">&lt;code&gt;getTime&lt;/code&gt; обычно следует предпочесть этой процедуре.</target>
        </trans-unit>
        <trans-unit id="d638e902f126f0c7aa4a0463f14fc91aa6e101cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gettimeofday&lt;/code&gt; on Posix systems.</source>
          <target state="translated">&lt;code&gt;gettimeofday&lt;/code&gt; в системах Posix.</target>
        </trans-unit>
        <trans-unit id="d5b46867399a3ebc590baf66c27020db2279084c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash(myBuf, 0, myBuf.high)&lt;/code&gt; is equivalent to &lt;code&gt;hash(myBuf)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hash(myBuf, 0, myBuf.high)&lt;/code&gt; эквивалентен &lt;code&gt;hash(myBuf)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45dddddd2bbfedd088d7b3c125dbef25e0d38ba5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash(myStr, 0, myStr.high)&lt;/code&gt; is equivalent to &lt;code&gt;hash(myStr)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hash(myStr, 0, myStr.high)&lt;/code&gt; эквивалентен &lt;code&gt;hash(myStr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d09d0789db01f5a9c05f92add326a6c6418fad63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashIgnoreCase(myBuf, 0, myBuf.high)&lt;/code&gt; is equivalent to &lt;code&gt;hashIgnoreCase(myBuf)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hashIgnoreCase(myBuf, 0, myBuf.high)&lt;/code&gt; эквивалентен &lt;code&gt;hashIgnoreCase(myBuf)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="539893790133747c72f0c3d326648e951cd62455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashIgnoreStyle(myBuf, 0, myBuf.high)&lt;/code&gt; is equivalent to &lt;code&gt;hashIgnoreStyle(myBuf)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hashIgnoreStyle(myBuf, 0, myBuf.high)&lt;/code&gt; эквивалентен &lt;code&gt;hashIgnoreStyle(myBuf)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a6dad588628bbfdda78e877da81dc4063efbca4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;httpMethod&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;httpMethod&lt;/code&gt; Параметр httpMethod .</target>
        </trans-unit>
        <trans-unit id="446c4e7001b764a870cc632382c962e1c7846115" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&lt;/code&gt; is used to create a value type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; используется для создания значения типа &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bac1f760d92cd7667c1edcfeeb152b5ca3e42fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int8&lt;/code&gt;-&lt;code&gt;int16&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int8&lt;/code&gt;-&lt;code&gt;int16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f4bbdf85817b62fc87718830d3fcc8142efb089" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;items&lt;/code&gt; and &lt;code&gt;mitems&lt;/code&gt;, which provides immutable and mutable elements respectively, and</source>
          <target state="translated">&lt;code&gt;items&lt;/code&gt; и &lt;code&gt;mitems&lt;/code&gt; , который предоставляет неизменяемые и изменяемые элементы соответственно, и</target>
        </trans-unit>
        <trans-unit id="d080c7c8dc2ed97f395585da2bba25e2810e6a4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator pairs[T](a: seq[T]): tuple[key: int, val: T] {.inline.}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;#pairs.i,seq[T]&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;iterator pairs[T](a: seq[T]): tuple[key: int, val: T] {.inline.}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;# pair.i, seq [T]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db0b9a7913713991512790ae51161be2f487b7b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; - the current key, if it exists, or the key passed to &lt;code&gt;withKey&lt;/code&gt; otherwise;</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; - текущий ключ, если он существует, или ключ, переданный &lt;code&gt;withKey&lt;/code&gt; в противном случае;</target>
        </trans-unit>
        <trans-unit id="137d632b8d1a56e511b10636ac245a0a4100b468" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;koch temp&lt;/code&gt; creates a debug build of the compiler, which is useful to create stacktraces for compiler debugging.</source>
          <target state="translated">&lt;code&gt;koch temp&lt;/code&gt; создает отладочную сборку компилятора, которая полезна для создания трассировок стека для отладки компилятора.</target>
        </trans-unit>
        <trans-unit id="b79b05bec9bfe83a19a391ff0202f6c5f735d0bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;koch temp&lt;/code&gt; returns 125 as the exit code in case the compiler compilation fails. This exit code tells &lt;code&gt;git bisect&lt;/code&gt; to skip the current commit.:</source>
          <target state="translated">&lt;code&gt;koch temp&lt;/code&gt; возвращает 125 в качестве кода выхода в случае сбоя компиляции компилятора. Этот код выхода сообщает &lt;code&gt;git bisect&lt;/code&gt; пропустить текущую фиксацию .:</target>
        </trans-unit>
        <trans-unit id="1e569b2cd12fd789d91b613969201b1b396b9248" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mach_absolute_time&lt;/code&gt; on Mac OS X.</source>
          <target state="translated">&lt;code&gt;mach_absolute_time&lt;/code&gt; в Mac OS X.</target>
        </trans-unit>
        <trans-unit id="7edfc1fd9a182aafc615613438430cf9ea485a6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mappedSize&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; can be used to map only a slice of the file.</source>
          <target state="translated">&lt;code&gt;mappedSize&lt;/code&gt; и &lt;code&gt;offset&lt;/code&gt; могут использоваться для отображения только части файла.</target>
        </trans-unit>
        <trans-unit id="aa96a3fe1f430f3bd1fcff24de7ff608b318637e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mappedSize&lt;/code&gt; of &lt;code&gt;-1&lt;/code&gt; maps to the whole file, and &lt;code&gt;offset&lt;/code&gt; must be multiples of the PAGE SIZE of your OS</source>
          <target state="translated">&lt;code&gt;mappedSize&lt;/code&gt; от &lt;code&gt;-1&lt;/code&gt; сопоставляется весь файл, и &lt;code&gt;offset&lt;/code&gt; должно быть кратно размер страницы вашей ОС</target>
        </trans-unit>
        <trans-unit id="7df7743ccba4158e36f639a44a77c1c52f23d01c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;match&lt;/code&gt; macros are subject to overload resolution. First the &lt;code&gt;case&lt;/code&gt;'s selector expression is used to determine which &lt;code&gt;match&lt;/code&gt; macro to call. To this macro is then passed the complete &lt;code&gt;case&lt;/code&gt; statement body and the macro is evaluated.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; макросы подлежат разрешению перегрузки. Сначала используется выражение селектора &lt;code&gt;case&lt;/code&gt; , чтобы определить, какой макрос &lt;code&gt;match&lt;/code&gt; вызывать. Затем этому макросу передается полное тело оператора &lt;code&gt;case&lt;/code&gt; , и макрос оценивается.</target>
        </trans-unit>
        <trans-unit id="33681e35af54b0be5e86cbe9c5c3384c078bfb89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxRedirects&lt;/code&gt; specifies the maximum amount of redirects to follow, default is 5.</source>
          <target state="translated">&lt;code&gt;maxRedirects&lt;/code&gt; указывает максимальное количество перенаправлений, по умолчанию 5.</target>
        </trans-unit>
        <trans-unit id="a63e991a055d70ba87b68410a67988fbb7f80b2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; is used to create a reference type &lt;code&gt;P&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; используется для создания ссылочного типа &lt;code&gt;P&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a602be3b30c82cb1f34df2de16159935bf9ca5cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newFileSize&lt;/code&gt; can only be set if the file does not exist and is opened with write access (e.g., with fmReadWrite).</source>
          <target state="translated">&lt;code&gt;newFileSize&lt;/code&gt; может быть установлен только в том случае, если файл не существует и открыт с доступом для записи (например, с помощью fmReadWrite).</target>
        </trans-unit>
        <trans-unit id="c33624742e3075a81ef915e9323ccf924f4d420e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nim dump&lt;/code&gt; shows the contents of the PATH.</source>
          <target state="translated">&lt;code&gt;nim dump&lt;/code&gt; показывает содержимое PATH.</target>
        </trans-unit>
        <trans-unit id="1d05d87869603b415dc3e7648e8e314e881eaa16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nimvm&lt;/code&gt; is a special symbol, that may be used as expression of &lt;code&gt;when nimvm&lt;/code&gt; statement to differentiate execution path between runtime and compile time.</source>
          <target state="translated">&lt;code&gt;nimvm&lt;/code&gt; - это специальный символ, который может использоваться как выражение оператора &lt;code&gt;when nimvm&lt;/code&gt; , чтобы различать путь выполнения между временем выполнения и временем компиляции.</target>
        </trans-unit>
        <trans-unit id="e6d0deed51af5627d170be866f9c9b832e859b40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nnkBracketExpr(nnkIdent(&quot;array&quot;),...&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;nnkBracketExpr(nnkIdent(&quot;array&quot;),...&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="eaef4608c727f153577ce8477a94c4a41016aa3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nnkIdentDefs&lt;/code&gt; need to have at least three children, but they can have more: first comes a list of identifiers followed by a type and value nodes. This helper proc creates a three node subtree, the first subnode being a single identifier name. Both the &lt;code&gt;kind&lt;/code&gt; node and &lt;code&gt;default&lt;/code&gt; (value) nodes may be empty depending on where the &lt;code&gt;nnkIdentDefs&lt;/code&gt; appears: tuple or object definitions will have an empty &lt;code&gt;default&lt;/code&gt; node, &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt; blocks may have an empty &lt;code&gt;kind&lt;/code&gt; node if the identifier is being assigned a value. Example:</source>
          <target state="translated">&lt;code&gt;nnkIdentDefs&lt;/code&gt; должно быть не менее трех дочерних элементов , но их может быть и больше: сначала идет список идентификаторов, за которым следуют узлы типа и значения. Этот вспомогательный процесс создает поддерево с тремя узлами, первый подузел представляет собой одно имя идентификатора. Как узел &lt;code&gt;kind&lt;/code&gt; узлы по &lt;code&gt;default&lt;/code&gt; (значение) могут быть пустыми в зависимости от того, где появляется &lt;code&gt;nnkIdentDefs&lt;/code&gt; : определения кортежей или объектов будут иметь пустой узел по &lt;code&gt;default&lt;/code&gt; , блоки &lt;code&gt;let&lt;/code&gt; или &lt;code&gt;var&lt;/code&gt; могут иметь пустой узел &lt;code&gt;kind&lt;/code&gt; если идентификатору присваивается значение. Пример:</target>
        </trans-unit>
        <trans-unit id="23cb81755297bb91f875d58a64e51a11f3bb1bba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nnkTypeClassTy&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;nnkTypeClassTy&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="d979bfd7809af3f787da470102b84296dc43dee7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notin&lt;/code&gt; and &lt;code&gt;isnot&lt;/code&gt; have the obvious meanings.</source>
          <target state="translated">&lt;code&gt;notin&lt;/code&gt; и isnot &lt;code&gt;isnot&lt;/code&gt; имеют очевидного значения.</target>
        </trans-unit>
        <trans-unit id="b733da2df93ef65b306bd9461fe3ea6457795e78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offset&lt;/code&gt; must be multiples of the PAGE SIZE of your OS (usually 4K or 8K but is unique to your OS)</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; должно быть кратно РАЗМЕРУ СТРАНИЦЫ вашей ОС (обычно 4 КБ или 8 КБ, но уникально для вашей ОС)</target>
        </trans-unit>
        <trans-unit id="8fb1b7b67c3dc439712f44d89e4d717f52f04357" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairExists&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; if the key exists, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;pairExists&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; , если ключ существует, иначе &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e50d29d3877d70186a81b4d6f92422034d6a8bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; and &lt;code&gt;mpairs&lt;/code&gt; which provides the element and an index number (immutable and mutable respectively)</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; и &lt;code&gt;mpairs&lt;/code&gt; , которые предоставляют элемент и номер индекса (неизменяемый и изменяемый соответственно)</target>
        </trans-unit>
        <trans-unit id="46fd512967085e03b5725fc1b1c542ab6c02be40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proc getTotalMem(): int {.rtl, raises: [], tags: [].}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#getTotalMem,&quot;&gt;#getTotalMem,&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;proc getTotalMem(): int {.rtl, raises: [], tags: [].}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#getTotalMem,&quot;&gt;#getTotalMem,&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="196f6343dc5b835d948b2f0d904b1e516670f218" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proc len[T](x: seq[T]): int {.magic: &quot;LengthSeq&quot;, noSideEffect.}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#len,seq%5BT%5D&quot;&gt;#len,seq[T]&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;proc len[T](x: seq[T]): int {.magic: &quot;LengthSeq&quot;, noSideEffect.}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#len,seq%5BT%5D&quot;&gt;# len, seq [T]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5660e0b3db81a363a41e94bcdc8ef2c68d94a1ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proc&lt;/code&gt; types are currently always invariant, but future versions of Nim may relax this rule.</source>
          <target state="translated">&lt;code&gt;proc&lt;/code&gt; Типы proc в настоящее время всегда инвариантны, но в будущих версиях Nim это правило может быть ослаблено.</target>
        </trans-unit>
        <trans-unit id="028210015ead3722db469fae99b22a73fd0cebdf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy&lt;/code&gt; specifies an HTTP proxy to use for this HTTP client's connections.</source>
          <target state="translated">&lt;code&gt;proxy&lt;/code&gt; указывает прокси-сервер HTTP, который будет использоваться для подключений этого клиента HTTP.</target>
        </trans-unit>
        <trans-unit id="4959eb23bdd78e53cb8af81bc9bb9ebcd2e0f5fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&quot;&quot;&quot;&quot;&lt;/code&gt; is not possible with this notation, because the three leading quotes introduce a triple quoted string literal. &lt;code&gt;r&quot;&quot;&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; since triple quoted string literals do not interpret escape sequences either.</source>
          <target state="translated">&lt;code&gt;r&quot;&quot;&quot;&quot;&lt;/code&gt; невозможно с этой нотацией, потому что три ведущие кавычки вводят строковый литерал в тройных кавычках. &lt;code&gt;r&quot;&quot;&quot;&lt;/code&gt; то же самое, что и &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; поскольку строковые литералы в тройных кавычках также не интерпретируют escape-последовательности.</target>
        </trans-unit>
        <trans-unit id="2b075aac17257f2359ad806b6183d04e910a5afb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; parameters are deeply copied which is a subtle semantic change and can cause performance problems but ensures memory safety. This deep copy is performed via &lt;code&gt;system.deepCopy&lt;/code&gt; and so can be overridden.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; Параметры ref глубоко копируются, что является незначительным семантическим изменением и может вызвать проблемы с производительностью, но обеспечивает безопасность памяти. Эта глубокая копия выполняется через &lt;code&gt;system.deepCopy&lt;/code&gt; , поэтому ее можно переопределить.</target>
        </trans-unit>
        <trans-unit id="35d9f8b60195dac2076797c209d92497e8a52809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; is allowed in a closure iterator (but rarely useful) and ends iteration.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; разрешен в итераторе закрытия (но редко бывает полезен) и завершает итерацию.</target>
        </trans-unit>
        <trans-unit id="c6eb664148a5a03959b583e8dd19730950f68b68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; without an expression is a short notation for &lt;code&gt;return result&lt;/code&gt; if the proc has a return type. The &lt;span id=&quot;result_1&quot;&gt;result&lt;/span&gt; variable is always the return value of the procedure. It is automatically declared by the compiler. As all variables, &lt;code&gt;result&lt;/code&gt; is initialized to (binary) zero:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; без выражения - это краткое обозначение &lt;code&gt;return result&lt;/code&gt; если процедура имеет тип возврата. &lt;span id=&quot;result_1&quot;&gt;Результат&lt;/span&gt; переменной всегда возвращаемое значение процедуры. Он автоматически объявляется компилятором. Как и все переменные, &lt;code&gt;result&lt;/code&gt; инициализируется (двоичным) нулем:</target>
        </trans-unit>
        <trans-unit id="113c74a3fd2826389685dc9b0cc688a75bb22a6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scanf&lt;/code&gt; returns true if the input string &lt;strong&gt;starts with&lt;/strong&gt; the specified pattern. If instead it should only return true if there is also nothing left in the input, append &lt;code&gt;$.&lt;/code&gt; to your pattern.</source>
          <target state="translated">&lt;code&gt;scanf&lt;/code&gt; возвращает истину, если входная строка &lt;strong&gt;начинается с&lt;/strong&gt; указанного шаблона. Если вместо этого он должен возвращать истину, только если во входных данных ничего не осталось, добавьте &lt;code&gt;$.&lt;/code&gt; к вашему выкройке.</target>
        </trans-unit>
        <trans-unit id="b10ad8ca26a39b5bc50703ca1825380095c2b3f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;selectors&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;selectors&lt;/code&gt; модуль селекторов</target>
        </trans-unit>
        <trans-unit id="414b4c694a3b05d8c88e89f76d20d0406356c388" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; must be of exactly the size that was requested via &lt;code&gt;mapMem&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; должен быть точно такого же размера, который был запрошен через &lt;code&gt;mapMem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7428fa040024da68196dbad3f187333725a9111f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn&lt;/code&gt; executes the passed expression on the thread pool and returns a &lt;span id=&quot;data-flow-variable_1&quot;&gt;data flow variable&lt;/span&gt;&lt;code&gt;FlowVar[T]&lt;/code&gt; that can be read from. The reading with the &lt;code&gt;^&lt;/code&gt; operator is &lt;strong&gt;blocking&lt;/strong&gt;. However, one can use &lt;code&gt;blockUntilAny&lt;/code&gt; to wait on multiple flow variables at the same time:</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; выполняет переданное выражение в пуле потоков и возвращает &lt;span id=&quot;data-flow-variable_1&quot;&gt;переменную потока данных &lt;/span&gt; &lt;code&gt;FlowVar[T]&lt;/code&gt; которой можно читать. Чтение с оператором &lt;code&gt;^&lt;/code&gt; &lt;strong&gt;блокируется&lt;/strong&gt; . Однако можно использовать &lt;code&gt;blockUntilAny&lt;/code&gt; для одновременного ожидания нескольких переменных потока:</target>
        </trans-unit>
        <trans-unit id="d6a078341ec3b81c9830d57f0b0899663805e59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn&lt;/code&gt; within a &lt;code&gt;parallel&lt;/code&gt; section has special semantics.</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; в &lt;code&gt;parallel&lt;/code&gt; разделе имеет особую семантику.</target>
        </trans-unit>
        <trans-unit id="0a237f056e6830032577998fb90190fdcae2b2f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sslContext&lt;/code&gt; specifies the SSL context to use for HTTPS requests.</source>
          <target state="translated">&lt;code&gt;sslContext&lt;/code&gt; указывает контекст SSL для использования для запросов HTTPS.</target>
        </trans-unit>
        <trans-unit id="14ce006a57832b51af0da0a7cc6741ef70d10283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stackTrace&lt;/code&gt; is provided only if the failure occurred due to an exception. &lt;code&gt;checkpoints&lt;/code&gt; is never &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stackTrace&lt;/code&gt; предоставляется, только если сбой произошел из-за исключения. &lt;code&gt;checkpoints&lt;/code&gt; никогда не &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb4fe14b57e46dc6a68b8b91ce1197bfba9b9fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; may be overriden, i.e. if &lt;code&gt;sock&lt;/code&gt; is not connected it should be adjusted properly. By default it will be assumed that the socket is connected. Please note this is only applicable to TCP client sockets, if &lt;code&gt;sock&lt;/code&gt; is a different type of socket &lt;code&gt;state&lt;/code&gt; needs to be adjusted!!!</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; может быть изменено, т.е. если &lt;code&gt;sock&lt;/code&gt; не подключен, его следует отрегулировать должным образом. По умолчанию предполагается, что сокет подключен. Пожалуйста , обратите внимание , что это применимо только к клиентским сокетам TCP, если &lt;code&gt;sock&lt;/code&gt; является другим типом сокета &lt;code&gt;state&lt;/code&gt; нужд , чтобы отрегулировать !!!</target>
        </trans-unit>
        <trans-unit id="e674b50eb18e2a7db0371aad81cb1f5762665b1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template newException[](exceptn: type; message: string): expr&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#newException.t,type,string&quot;&gt;#newException.t,type,string&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;template newException[](exceptn: type; message: string): expr&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#newException.t,type,string&quot;&gt;# newException.t, type, string&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2bb140ccbc87a6b939e9e3439c2e3cc8632b83d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; - timeout value in milliseconds.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; - значение тайм- аута в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="96b9adea7cc07edd40eb34f2988f6e65b0f32008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is specified in milliseconds and &lt;code&gt;-1&lt;/code&gt; can be specified for an unlimited time.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; указывается в миллисекундах, а &lt;code&gt;-1&lt;/code&gt; можно указывать неограниченное время.</target>
        </trans-unit>
        <trans-unit id="bd67e5934c954c7a83cd4b013bf93f8697e48fe3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is specified in milliseconds and &lt;code&gt;-1&lt;/code&gt; can be specified for an unlimited time. &lt;strong&gt;Warning:&lt;/strong&gt; This is deprecated since version 0.16.2. Use the &lt;code&gt;selectRead&lt;/code&gt; procedure instead.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; указывается в миллисекундах, а &lt;code&gt;-1&lt;/code&gt; можно указывать неограниченное время. &lt;strong&gt;Предупреждение:&lt;/strong&gt; это не рекомендуется, начиная с версии 0.16.2. Используйте &lt;code&gt;selectRead&lt;/code&gt; вместо процедуры.</target>
        </trans-unit>
        <trans-unit id="47d67af238e56b35260c7cf302090a09b5d4e74c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; specifies the number of milliseconds to allow before a &lt;code&gt;TimeoutError&lt;/code&gt; is raised.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; указывает количество миллисекунд, которое необходимо до возникновения &lt;code&gt;TimeoutError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a3d983ab412f774a2d43a7773e59264a9986835" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type SignedInt = int | int8 | int16 | int32 | int64&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#SignedInt&quot;&gt;#SignedInt&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;type SignedInt = int | int8 | int16 | int32 | int64&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#SignedInt&quot;&gt;#SignedInt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36800177ee2b92e4b74725a1b76cc86e80ecbacc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; acts like a generic type. For instance, the type of the symbol &lt;code&gt;int&lt;/code&gt; is &lt;code&gt;type[int]&lt;/code&gt;. Just like with regular generic types, when the generic param is ommited, &lt;code&gt;type&lt;/code&gt; denotes the type class of all types. As a syntactic convenience, you can also use &lt;code&gt;type&lt;/code&gt; as a modifier. &lt;code&gt;type int&lt;/code&gt; is considered the same as &lt;code&gt;type[int]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; действует как универсальный тип. Например, тип символа &lt;code&gt;int&lt;/code&gt; - это &lt;code&gt;type[int]&lt;/code&gt; . Как и в случае с обычными универсальными типами, когда общий параметр опущен, &lt;code&gt;type&lt;/code&gt; обозначает класс типа для всех типов. Для удобства синтаксиса вы также можете использовать &lt;code&gt;type&lt;/code&gt; в качестве модификатора. &lt;code&gt;type int&lt;/code&gt; считается тем же, что и &lt;code&gt;type[int]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad64a4834d20179ee6e4e81e9e9cec9447164baf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint8&lt;/code&gt;/&lt;code&gt;byte&lt;/code&gt;-&lt;code&gt;uint16&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;uint8&lt;/code&gt;/&lt;code&gt;byte&lt;/code&gt;-&lt;code&gt;uint16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5524951be56e32fd2f7b7e27e9fb8dc263ca8215" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;untyped&lt;/code&gt; and &lt;code&gt;varargs[untyped]&lt;/code&gt; are the only metatype that are lazy in this sense, the other metatypes &lt;code&gt;typed&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; are not lazy.</source>
          <target state="translated">&lt;code&gt;untyped&lt;/code&gt; и &lt;code&gt;varargs[untyped]&lt;/code&gt; - единственный метатип, который ленив в этом смысле, другие метатипы &lt;code&gt;typed&lt;/code&gt; и &lt;code&gt;type&lt;/code&gt; не ленивы.</target>
        </trans-unit>
        <trans-unit id="dd2e83eaaa4d30da3388fb06180b2d9cdc38b178" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;userAgent&lt;/code&gt; specifies the user agent that will be used when making requests.</source>
          <target state="translated">&lt;code&gt;userAgent&lt;/code&gt; указывает агент пользователя, который будет использоваться при выполнении запросов.</target>
        </trans-unit>
        <trans-unit id="6e8057947b214078488d318b597d51c19c74bced" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;val&lt;/code&gt; - the current value, if the key exists, or default value of the type otherwise;</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; - текущее значение, если ключ существует, иначе значение типа по умолчанию;</target>
        </trans-unit>
        <trans-unit id="70bd849b02a91f69a4faafb3130dd3312083ca7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var globalRaiseHook: proc (e: ref E_Base): bool {.nimcall.}&lt;/code&gt;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&lt;a href=&quot;system#globalRaiseHook&quot;&gt;#globalRaiseHook&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;var globalRaiseHook: proc (e: ref E_Base): bool {.nimcall.}&lt;/code&gt; &lt;strong&gt;=&amp;gt; &lt;/strong&gt;&lt;a href=&quot;system#globalRaiseHook&quot;&gt;#globalRaiseHook&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fa91fdb54c79794b9a602441c5470976dba8159" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;varargs[typed]&lt;/code&gt; is treated specially: It matches a variable list of arguments of arbitrary type but &lt;em&gt;always&lt;/em&gt; constructs an implicit array. This is required so that the builtin &lt;code&gt;echo&lt;/code&gt; proc does what is expected:</source>
          <target state="translated">&lt;code&gt;varargs[typed]&lt;/code&gt; обрабатывается особым образом: он соответствует списку переменных аргументов произвольного типа, но &lt;em&gt;всегда&lt;/em&gt; создает неявный массив. Это необходимо для того, чтобы встроенный &lt;code&gt;echo&lt;/code&gt; процесс делал то, что ожидалось:</target>
        </trans-unit>
        <trans-unit id="cfb3b8046a3ab81ffe6881ac3de26835854c0b13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when nimvm&lt;/code&gt; statement must meet the following requirements:</source>
          <target state="translated">&lt;code&gt;when nimvm&lt;/code&gt; инструкция nimvm должна соответствовать следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="67ac27b54addce5df88f6ce1de6ac4b1806d80c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; in a closure iterator can not occur in a &lt;code&gt;try&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; в итераторе закрытия не может встречаться в операторе &lt;code&gt;try&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b17d688332fc513102b8bb34b3b994661a671d9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zonedTimeFromTimeImpl&lt;/code&gt; and &lt;code&gt;zonedTimeFromAdjTimeImpl&lt;/code&gt; is used as the underlying implementations for &lt;code&gt;zonedTimeFromTime&lt;/code&gt; and &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;zonedTimeFromTimeImpl&lt;/code&gt; и &lt;code&gt;zonedTimeFromAdjTimeImpl&lt;/code&gt; используются в качестве базовых реализаций для &lt;code&gt;zonedTimeFromTime&lt;/code&gt; и &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7de7681dca8728ba640e9addf663d66eea92586e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%&lt;/em&gt; substitution operator for ropes. Does not support the &lt;code&gt;$identifier&lt;/code&gt; nor &lt;code&gt;${identifier}&lt;/code&gt; notations.</source>
          <target state="translated">&lt;em&gt;%&lt;/em&gt; подстановки оператора для канатов. Не поддерживает обозначения &lt;code&gt;$identifier&lt;/code&gt; и &lt;code&gt;${identifier}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="703376a559c520d84ae5746f8f84e6453c7ecbf2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deprecated since version 0.18.1&lt;/em&gt;: No good usages of this feature are known.</source>
          <target state="translated">&lt;em&gt;Не рекомендуется, начиная с версии 0.18.1&lt;/em&gt; : нет &lt;em&gt;сведений о&lt;/em&gt; правильном использовании этой функции.</target>
        </trans-unit>
        <trans-unit id="a2e021efea2e75524a8b29d10b025f45cf8dcb6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Expressions&lt;/em&gt; are parts of a statement which usually result in a value. The condition in an if statement is an example for an expression. Expressions can contain indentation at certain places for better readability:</source>
          <target state="translated">&lt;em&gt;Выражения&lt;/em&gt; - это части утверждения, которые обычно приводят к значению. Условие в операторе if является примером выражения. Выражения могут содержать отступы в определенных местах для лучшей читаемости:</target>
        </trans-unit>
        <trans-unit id="2e3cb0560107f66918fa3aedb67fc091d9d49443" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ext&lt;/em&gt; should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</source>
          <target state="translated">&lt;em&gt;Ext&lt;/em&gt; следует указывать без начального символа '.', Потому что некоторые файловые системы могут использовать другой символ. (Хотя я не знаю такого зверя.)</target>
        </trans-unit>
        <trans-unit id="00e5801a705eb26208dbadfb059011bb00f52b91" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Runtime type information&lt;/em&gt; (RTTI) is needed for several aspects of the Nim programming language:</source>
          <target state="translated">&lt;em&gt;Информация о типе среды выполнения&lt;/em&gt; (RTTI) необходима для нескольких аспектов языка программирования Nim:</target>
        </trans-unit>
        <trans-unit id="17f8a43b2c8fe38ae5080e22a567a4a144d535c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;arrow like operator&lt;/em&gt; (like &lt;code&gt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;=&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;em&gt;стрелка как оператор&lt;/em&gt; (вроде &lt;code&gt;-&amp;gt;&lt;/code&gt; , &lt;code&gt;=&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cd27f1fe3eae5b9a898f8a1ee22d88a9fa597511" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;assignment operator&lt;/em&gt; (like &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;)</source>
          <target state="translated">&lt;em&gt;оператор присваивания&lt;/em&gt; (например, &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f7455f98c99e60e6bbeb9b3baae8878c758ba3c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmp&lt;/em&gt; is the comparator function to use, the expected return values are the same as that of system.cmp.</source>
          <target state="translated">&lt;em&gt;cmp&lt;/em&gt; - это функция компаратора, ожидаемые возвращаемые значения такие же, как и у system.cmp.</target>
        </trans-unit>
        <trans-unit id="d07d1bc0c8a2aa1948c3ee05610a44eaacab87f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;decimalSep&lt;/em&gt; is used as the decimal separator.</source>
          <target state="translated">&lt;em&gt;decimalSep&lt;/em&gt; используется как десятичный разделитель.</target>
        </trans-unit>
        <trans-unit id="92cefe4d7882c47f6678d2ec5886a3672b587367" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;empty string&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;пустая строка&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8f65828700fd66a8e7a7fd5be187238ed98013b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;escape&lt;/em&gt;: removes any special meaning from the following character; '0' disables escaping; if escaping is disabled and &lt;em&gt;quote&lt;/em&gt; is not '0', two &lt;em&gt;quote&lt;/em&gt; characters are parsed one literal &lt;em&gt;quote&lt;/em&gt; character.</source>
          <target state="translated">&lt;em&gt;escape&lt;/em&gt; : удаляет любое специальное значение из следующего символа; '0' отключает экранирование; если экранирование отключено и &lt;em&gt;кавычка&lt;/em&gt; не равна '0', два символа &lt;em&gt;кавычек&lt;/em&gt; анализируются одним буквальным символом &lt;em&gt;кавычки&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="db614d277a70f95c2f6d4d36c543390ce136c5ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;false&lt;/em&gt; - generate timeout events periodically</source>
          <target state="translated">&lt;em&gt;false&lt;/em&gt; - периодически генерировать события тайм-аута</target>
        </trans-unit>
        <trans-unit id="8e307a213a9d0cd9087e4fab61d048d2e75d42ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;i&lt;/em&gt; should be in the range &lt;em&gt;1..paramCount()&lt;/em&gt;, the &lt;em&gt;IndexError&lt;/em&gt; exception will be raised for invalid values. Instead of iterating over &lt;a href=&quot;#paramCount&quot;&gt;paramCount()&lt;/a&gt; with this proc you can call the convenience &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;i&lt;/em&gt; должен быть в диапазоне &lt;em&gt;1..paramCount ()&lt;/em&gt; , исключение &lt;em&gt;IndexError&lt;/em&gt; будет &lt;em&gt;вызвано&lt;/em&gt; для недопустимых значений. Вместо того, чтобы &lt;a href=&quot;#paramCount&quot;&gt;повторять paramCount () в&lt;/a&gt; этой процедуре, вы можете вызвать удобную команду &lt;a href=&quot;#commandLineParams&quot;&gt;LineParams ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f4bf9334d2490f523b663af6901783da21ac6a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;includeSpace&lt;/em&gt; can be set to true to include the (SI preferred) space between the number and the unit (e.g. 1 KiB).</source>
          <target state="translated">&lt;em&gt;Для includeSpace&lt;/em&gt; можно задать значение true, чтобы включить пробел (предпочтительно в системе СИ) между числом и единицей (например, 1 КиБ).</target>
        </trans-unit>
        <trans-unit id="e71266691c1695dc862a4187873f4eb27e421c29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module or the &lt;code&gt;rightSize&lt;/code&gt; method in this module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; должен быть степенью двойки. Если вам нужно принять для этого значения времени выполнения, вы можете использовать процедуру &lt;code&gt;nextPowerOfTwo&lt;/code&gt; из &lt;a href=&quot;math&quot;&gt;математического&lt;/a&gt; модуля или метод &lt;code&gt;rightSize&lt;/code&gt; в этом модуле.</target>
        </trans-unit>
        <trans-unit id="00959dbd3dd10aad40ca8d5088bb831b41a7779c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module or the &lt;code&gt;rightSize&lt;/code&gt; proc from this module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; должен быть степенью двойки. Если вам нужно принять для этого значения времени выполнения, вы можете использовать процедуру &lt;code&gt;nextPowerOfTwo&lt;/code&gt; из &lt;a href=&quot;math&quot;&gt;математического&lt;/a&gt; модуля или процедуру &lt;code&gt;rightSize&lt;/code&gt; из этого модуля.</target>
        </trans-unit>
        <trans-unit id="ea4791fbf3e42731dc51d96cd68f2db285a8f167" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module or the &lt;code&gt;rightSize&lt;/code&gt; proc in this module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; должен быть степенью двойки. Если вам нужно принять для этого значения времени выполнения, вы можете использовать процедуру &lt;code&gt;nextPowerOfTwo&lt;/code&gt; из &lt;a href=&quot;math&quot;&gt;математического&lt;/a&gt; модуля или процедуру &lt;code&gt;rightSize&lt;/code&gt; в этом модуле.</target>
        </trans-unit>
        <trans-unit id="9a840e66e23dce5bbe529077fe70ae32ae27b78c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;initialSize&lt;/em&gt; needs to be a power of two. If you need to accept runtime values for this you could use the &lt;code&gt;nextPowerOfTwo&lt;/code&gt; proc from the &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt; module.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt; должен быть степенью двойки. Если вам нужно принять для этого значения времени выполнения, вы можете использовать процедуру &lt;code&gt;nextPowerOfTwo&lt;/code&gt; из &lt;a href=&quot;math&quot;&gt;математического&lt;/a&gt; модуля.</target>
        </trans-unit>
        <trans-unit id="7472432b84a3a2eab38f2db62373daa9e022086e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;isNil&lt;/em&gt; for an any &lt;em&gt;x&lt;/em&gt; that represents a sequence, string, cstring, proc or some pointer type.</source>
          <target state="translated">&lt;em&gt;isNil&lt;/em&gt; для любого &lt;em&gt;x,&lt;/em&gt; который представляет последовательность, строку, cstring, proc или некоторый тип указателя.</target>
        </trans-unit>
        <trans-unit id="f70ae80be2c58fd29de80509ed00d5e2c9f1f429" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;padding&lt;/em&gt; characters (by default spaces) are added after &lt;em&gt;s&lt;/em&gt; resulting in left alignment. If &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt;, no spaces are added and &lt;em&gt;s&lt;/em&gt; is returned unchanged. If you need to right align a string use the &lt;a href=&quot;#align&quot;&gt;align proc&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;символы &lt;em&gt;заполнения&lt;/em&gt; (по умолчанию пробелы) добавляются после &lt;em&gt;s, что&lt;/em&gt; приводит к выравниванию по левому краю. Если &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt; , пробелы не добавляются и &lt;em&gt;s&lt;/em&gt; возвращается без изменений. Если вам нужно выровнять строку по правому краю, используйте функцию &lt;a href=&quot;#align&quot;&gt;align&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="8672d4b2f28ca97d242b9f9940ce8d1789ba04fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;padding&lt;/em&gt; characters (by default spaces) are added before &lt;em&gt;s&lt;/em&gt; resulting in right alignment. If &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt;, no spaces are added and &lt;em&gt;s&lt;/em&gt; is returned unchanged. If you need to left align a string use the &lt;a href=&quot;#alignLeft&quot;&gt;alignLeft proc&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;символы &lt;em&gt;заполнения&lt;/em&gt; (по умолчанию пробелы) добавляются перед &lt;em&gt;s, что&lt;/em&gt; приводит к выравниванию по правому краю. Если &lt;code&gt;s.len &amp;gt;= count&lt;/code&gt; , пробелы не добавляются и &lt;em&gt;s&lt;/em&gt; возвращается без изменений. Если вам нужно выровнять строку по &lt;a href=&quot;#alignLeft&quot;&gt;левому краю,&lt;/a&gt; используйте функцию alignLeft . Пример:</target>
        </trans-unit>
        <trans-unit id="8247e0fd6fcaa06e3944fbde836de9960b4b141c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;pattern&lt;/em&gt; is OS dependent, but at least the &quot;*.ext&quot; notation is supported.</source>
          <target state="translated">&lt;em&gt;шаблон&lt;/em&gt; зависит от ОС, но, по крайней мере, поддерживается нотация &amp;laquo;* .ext&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="75461844b2cd9f0f721ba3326b4f70c797e25d69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;precision&lt;/em&gt; can be used to set the number of digits to be shown after the decimal point or (if &lt;em&gt;trim&lt;/em&gt; is true) the maximum number of digits to be shown.</source>
          <target state="translated">&lt;em&gt;точность&lt;/em&gt; может использоваться для установки количества цифр, которые будут отображаться после десятичной точки, или (если &lt;em&gt;обрезка&lt;/em&gt; истинна) максимального количества цифр, которые будут отображаться.</target>
        </trans-unit>
        <trans-unit id="617209c0ac1f0365ddc9daa8adb400efad149a99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;quote&lt;/em&gt;: Used to quote fields containing special characters like &lt;em&gt;separator&lt;/em&gt;, &lt;em&gt;quote&lt;/em&gt; or new-line characters. '0' disables the parsing of quotes.</source>
          <target state="translated">&lt;em&gt;quote&lt;/em&gt; : используется для заключения в кавычки полей, содержащих специальные символы, такие как &lt;em&gt;разделитель&lt;/em&gt; , &lt;em&gt;кавычки&lt;/em&gt; или символы новой строки. &amp;laquo;0&amp;raquo; отключает парсинг кавычек.</target>
        </trans-unit>
        <trans-unit id="f3dae05aba49b918194a9396a45aa3565615f037" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;replacements&lt;/em&gt; is any proc that takes a word and returns a new word to fill it's place.</source>
          <target state="translated">&lt;em&gt;замены&lt;/em&gt; - это любой процесс, который берет слово и возвращает новое слово, чтобы заполнить его.</target>
        </trans-unit>
        <trans-unit id="fbc817a3080e1b6882164dc8caf322799358d878" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;select&lt;/em&gt; with a sensible Nim interface. &lt;em&gt;timeout&lt;/em&gt; is in milliseconds. Specify -1 for no timeout. Returns the number of processes that are ready to read from. The processes that are ready to be read from are removed from &lt;em&gt;readfds&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;выберите&lt;/em&gt; с разумным интерфейсом Nim. &lt;em&gt;время ожидания&lt;/em&gt; в миллисекундах. Укажите -1 для отсутствия тайм-аута. Возвращает количество процессов, готовых к чтению. Готовые к чтению процессы удаляются из &lt;em&gt;readfds&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d7f259f2477167c821ca25fa51730ed7960a70b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;separator&lt;/em&gt;: character used to separate fields</source>
          <target state="translated">&lt;em&gt;разделитель&lt;/em&gt; : символ, используемый для разделения полей</target>
        </trans-unit>
        <trans-unit id="208edbd229c8eae9f5eb36df289548d5304b4d7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;skipInitialSpace&lt;/em&gt;: If true, whitespace immediately following the &lt;em&gt;separator&lt;/em&gt; is ignored.</source>
          <target state="translated">&lt;em&gt;skipInitialSpace&lt;/em&gt; : если true, пробелы сразу после &lt;em&gt;разделителя&lt;/em&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="273a15cf374a6c4f49fed8d98b7d8b9586b0faaf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;true&lt;/em&gt; - generate only one timeout event</source>
          <target state="translated">&lt;em&gt;true&lt;/em&gt; - генерировать только одно событие тайм-аута</target>
        </trans-unit>
        <trans-unit id="14ee562aca33dc19b06533f7cf5920a2b50148e9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are converted to &lt;code&gt;float&lt;/code&gt; and the other push operation is called.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; и &lt;em&gt;y&lt;/em&gt; преобразуются в &lt;code&gt;float&lt;/code&gt; , и вызывается другая операция push.</target>
        </trans-unit>
        <trans-unit id="783ab28443368da5d8b24739fb4554949b0f9f72" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt; is simply converted to &lt;code&gt;float&lt;/code&gt; and the other push operation is called.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; просто преобразуется в &lt;code&gt;float&lt;/code&gt; и вызывается другая операция push.</target>
        </trans-unit>
        <trans-unit id="fae64b6ebd8e2c7bcc575d125a2000abb729e3ca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x&lt;/em&gt; raised to the power &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; в степени &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="12323c312fd7de0e4ef8b6a4ab533d557d68adc8" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;alert_1&quot;&gt;alert&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;alert_1&quot;&gt;alert&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="56d285c47b35312e64820df42bf3a87fd1b7b319" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;alert_2&quot;&gt;alert&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;alert_2&quot;&gt;alert&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="dc8e48b403bc73650b187c7f7e7ea88d6cb233c6" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;apostrophe_1&quot;&gt;apostrophe&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;apostrophe_1&quot;&gt;apostrophe&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="aa4c0ec53f4daba1b0ecbab22044a4b311fd35ea" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;apostrophe_2&quot;&gt;apostrophe&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;apostrophe_2&quot;&gt;apostrophe&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="489a12332aa212cc707a62ebb576449c73813d0c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;automatic-type-conversion_1&quot;&gt;Automatic type conversion&lt;/span&gt; is performed in expressions where different kinds of integer types are used: the smaller type is converted to the larger.</source>
          <target state="translated">&lt;span id=&quot;automatic-type-conversion_1&quot;&gt;Автоматическое преобразование типов&lt;/span&gt; выполняется в выражениях, в которых используются различные типы целочисленных типов: меньший тип преобразуется в больший.</target>
        </trans-unit>
        <trans-unit id="ef114326cdf7ec64073b8d5c70949a59e4d16784" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="654a8f7f92faee492756a045bc4a4f5716bafc9a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backslash_2&quot;&gt;backslash&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backslash_2&quot;&gt;backslash&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="b344cba5f1b85d441c18840ce9f4242eff677927" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backspace_1&quot;&gt;backspace&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backspace_1&quot;&gt;backspace&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="3ef60dc7d037ac085bdffe500a7612d735b0c712" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;backspace_2&quot;&gt;backspace&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;backspace_2&quot;&gt;backspace&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="fc49500076e57365e635056cd3b75868d666ab71" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;carriage-return_1&quot;&gt;carriage return&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;carriage-return_1&quot;&gt;возврат каретки&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8ab206963e8b4940d40701cfc51c0f7e1851ffeb" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;carriage-return_2&quot;&gt;carriage return&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;carriage-return_2&quot;&gt;возврат каретки&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="1cf7c76a0ff63e90fbc9727aa4db16092702311a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;cdecl_1&quot;&gt;cdecl&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;cdecl_1&quot;&gt;cdecl&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0733a6e3e51ba48347bd816e4d97acf3dbb10225" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-decimal-value-d_1&quot;&gt;character with decimal value d&lt;/span&gt;; all decimal digits directly following are used for the character</source>
          <target state="translated">&lt;span id=&quot;character-with-decimal-value-d_1&quot;&gt;символ с десятичным значением d&lt;/span&gt; ; все следующие десятичные цифры используются для символа</target>
        </trans-unit>
        <trans-unit id="d33b972e48200cc4a6a49329f9bd2b0b86e9d179" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-decimal-value-d_2&quot;&gt;character with decimal value d&lt;/span&gt;; all decimal digits directly following are used for the character</source>
          <target state="translated">&lt;span id=&quot;character-with-decimal-value-d_2&quot;&gt;символ с десятичным значением d&lt;/span&gt; ; все следующие десятичные цифры используются для символа</target>
        </trans-unit>
        <trans-unit id="598b3bddfa5c5d0fa5a106b08f17b0cd0a6928c4" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-hex-value-hh_1&quot;&gt;character with hex value HH&lt;/span&gt;; exactly two hex digits are allowed</source>
          <target state="translated">&lt;span id=&quot;character-with-hex-value-hh_1&quot;&gt;символ с шестнадцатеричным значением HH&lt;/span&gt; ; допускается ровно две шестнадцатеричные цифры</target>
        </trans-unit>
        <trans-unit id="899d46bdef3da49bf9a47052252021471e9deca1" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;character-with-hex-value-hh_2&quot;&gt;character with hex value HH&lt;/span&gt;; exactly two hex digits are allowed</source>
          <target state="translated">&lt;span id=&quot;character-with-hex-value-hh_2&quot;&gt;символ с шестнадцатеричным значением HH&lt;/span&gt; ; допускается ровно две шестнадцатеричные цифры</target>
        </trans-unit>
        <trans-unit id="06eb32c5efe204f53b8a3e469a651a6422b0ecef" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;closure_1&quot;&gt;closure&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;closure_1&quot;&gt;closure&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="69035165c7fe56ca0f544baab5f7ca6b3bb23e5f" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;constants_1&quot;&gt;Constants&lt;/span&gt; are symbols which are bound to a value. The constant's value cannot change. The compiler must be able to evaluate the expression in a constant declaration at compile time.</source>
          <target state="translated">&lt;span id=&quot;constants_1&quot;&gt;Константы&lt;/span&gt; - это символы, привязанные к значению. Значение константы не может измениться. Компилятор должен иметь возможность оценивать выражение в объявлении константы во время компиляции.</target>
        </trans-unit>
        <trans-unit id="bc7dc406312d3d989f8fded7366dc2a2ca439dfc" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;documentation-comments_1&quot;&gt;Documentation comments&lt;/span&gt; are comments that start with two &lt;code&gt;##&lt;/code&gt;. Documentation comments are tokens; they are only allowed at certain places in the input file as they belong to the syntax tree!</source>
          <target state="translated">&lt;span id=&quot;documentation-comments_1&quot;&gt;Комментарии к документации&lt;/span&gt; - это комментарии, начинающиеся с двух &lt;code&gt;##&lt;/code&gt; . Комментарии к документации являются токенами; они разрешены только в определенных местах входного файла, так как они принадлежат синтаксическому дереву!</target>
        </trans-unit>
        <trans-unit id="c983afd465ba80d2147e0b70ee70ed5b594ffd0c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;escape_1&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_1&quot;&gt;[ESC]&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;escape_1&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_1&quot;&gt;[ESC]&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="23e3ae456032cf7bfe12b54d4c30ef515b7e5769" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;escape_2&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_2&quot;&gt;[ESC]&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;escape_2&quot;&gt;escape&lt;/span&gt;&lt;span id=&quot;esc_2&quot;&gt;[ESC]&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="1f0669c885766923e22bc3a0cf1a25ecf09a7e71" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;fastcall_1&quot;&gt;fastcall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;fastcall_1&quot;&gt;fastcall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="61df4a1c082aef5508a11aa5f32360878c832316" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;form-feed_1&quot;&gt;form feed&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;form-feed_1&quot;&gt;подача формы&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c83e42d1968c9f81163b17f1f1a97a7f750bcc7b" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;form-feed_2&quot;&gt;form feed&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;form-feed_2&quot;&gt;подача формы&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="24ef9584feba6e596a828184a0614706f20342a7" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;inline_1&quot;&gt;inline&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;inline_1&quot;&gt;inline&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="97eb508c4f7e0532dda34314f3114ac62db38999" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;intdefine_1&quot;&gt;intdefine&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;intdefine_1&quot;&gt;intdefine&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="bf681f8157045b76a5b5cca6556c710b3d31af04" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;line-feed_1&quot;&gt;line feed&lt;/span&gt; (often called &lt;span id=&quot;newline_1&quot;&gt;newline&lt;/span&gt;)</source>
          <target state="translated">&lt;span id=&quot;line-feed_1&quot;&gt;перевод строки&lt;/span&gt; (часто называемый &lt;span id=&quot;newline_1&quot;&gt;новой &lt;/span&gt;&lt;span id=&quot;line-feed_1&quot;&gt;строкой&lt;/span&gt; )</target>
        </trans-unit>
        <trans-unit id="f069e5dc4bd5128fe57f984b98f0d1df33905e6c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;line-feed_2&quot;&gt;line feed&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;line-feed_2&quot;&gt;перевод строки&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="370fea44cd56e7d13668a1518c6ed3e2793cd844" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;nimcall_1&quot;&gt;nimcall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;nimcall_1&quot;&gt;nimcall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="386493dc5a93f6552eed5a0c301e509bae171c3a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;noconv_1&quot;&gt;noconv&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;noconv_1&quot;&gt;noconv&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0d18cc4b434985ecdfad600d62beb278d037bd02" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;operators_1&quot;&gt;Operators&lt;/span&gt; are procedures with a special operator symbol as identifier:</source>
          <target state="translated">&lt;span id=&quot;operators_1&quot;&gt;Операторы&lt;/span&gt; - это процедуры со специальным символом оператора в качестве идентификатора:</target>
        </trans-unit>
        <trans-unit id="dd7a03ff3abf42e8baa1ecc1fffb484ad21a23af" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;quotation-mark_1&quot;&gt;quotation mark&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;quotation-mark_1&quot;&gt;кавычка&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c6aabef76f9a817672169780852e677ea046add2" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;quotation-mark_2&quot;&gt;quotation mark&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;quotation-mark_2&quot;&gt;кавычка&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c37b02a49dcefbd3153898422e9bb9a58594c0f5" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;safecall_1&quot;&gt;safecall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;safecall_1&quot;&gt;safecall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9075773ca58649470612eb72f9b476282ba11426" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;spawn_1&quot;&gt;spawn&lt;/span&gt; can be used to pass a task to the thread pool:</source>
          <target state="translated">&lt;span id=&quot;spawn_1&quot;&gt;spawn&lt;/span&gt; можно использовать для передачи задачи в пул потоков:</target>
        </trans-unit>
        <trans-unit id="f768c26556a449ea02596d87572b18bde70355d0" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;stdcall_1&quot;&gt;stdcall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;stdcall_1&quot;&gt;stdcall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="459d1365b562550b27ebf6a8974dd5ae8b46a70a" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;strdefine_1&quot;&gt;strdefine&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;strdefine_1&quot;&gt;strdefine&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="f2149f636a8a39166b70a1e1b85797ae880037d8" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;structured_1&quot;&gt;Structured&lt;/span&gt; parallelism via the &lt;code&gt;parallel&lt;/code&gt; statement.</source>
          <target state="translated">&lt;span id=&quot;structured_1&quot;&gt;Структурированный&lt;/span&gt; параллелизм через оператор &lt;code&gt;parallel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906052db691f512b87e944c4fa7ae79175ea0c21" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;syscall_1&quot;&gt;syscall&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;syscall_1&quot;&gt;syscall&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="2fce4fa4dbb6e8e47310c53145477e8e7e68ebe3" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;tabulator_1&quot;&gt;tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;tabulator_1&quot;&gt;tabulator&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="b6b9690fa127b5c41c7a6608abe780996467b339" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;tabulator_2&quot;&gt;tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;tabulator_2&quot;&gt;tabulator&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a0e78449bd2f86ea69106414c3a2d0d1430a9b77" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;unmarshals_1&quot;&gt;Unmarshals&lt;/span&gt; the specified node into the object type specified.</source>
          <target state="translated">&lt;span id=&quot;unmarshals_1&quot;&gt;Неупорядочивает&lt;/span&gt; указанный узел в указанный тип объекта.</target>
        </trans-unit>
        <trans-unit id="daac7f50d202881a5d6ee0367a0863d7aebf95c3" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;unstructured_1&quot;&gt;Unstructured&lt;/span&gt; parallelism via the standalone &lt;code&gt;spawn&lt;/code&gt; statement.</source>
          <target state="translated">&lt;span id=&quot;unstructured_1&quot;&gt;Неструктурированный&lt;/span&gt; параллелизм с помощью автономного оператора &lt;code&gt;spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d57fe270428bde77daa75ade4ed835d70900fc90" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;vertical-tabulator_1&quot;&gt;vertical tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;vertical-tabulator_1&quot;&gt;вертикальный табулятор&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9cc1eadaa9721d4034ad25e0a89c479254a832df" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;vertical-tabulator_2&quot;&gt;vertical tabulator&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;vertical-tabulator_2&quot;&gt;вертикальный табулятор&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="162d657293056b3b52f778e7e2ab66fe5d304524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;$MODULE&lt;/strong&gt;: like $TESTNIM but without extension, useful for expected output.</source>
          <target state="translated">&lt;strong&gt;$ MODULE&lt;/strong&gt; : как $ TESTNIM, но без расширения, полезно для ожидаемого вывода.</target>
        </trans-unit>
        <trans-unit id="0f7f0e7e27fe39d47b743d1865954b56a2c07fd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;$TESTNIM&lt;/strong&gt;: filename specified in the first line of the script.</source>
          <target state="translated">&lt;strong&gt;$ TESTNIM&lt;/strong&gt; : имя файла, указанное в первой строке скрипта.</target>
        </trans-unit>
        <trans-unit id="a839ade11ae6dd196f2a9173f8f1d634964f9d53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Availability&lt;/strong&gt;: On Posix there is no portable way to get the command line from a DLL and thus the proc isn't defined in this environment. You can test for its availability with &lt;a href=&quot;system#declared&quot;&gt;declared()&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;strong&gt;Доступность&lt;/strong&gt; : в Posix нет переносимого способа получить командную строку из DLL, поэтому процедура не определена в этой среде. Вы можете проверить его доступность с помощью &lt;a href=&quot;system#declared&quot;&gt;declare ()&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="654a21dac651772b23f95ecd2222feacad79471f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Availability&lt;/strong&gt;: When generating a dynamic library (see --app:lib) on Posix this proc is not defined. Test for availability using &lt;a href=&quot;system#declared&quot;&gt;declared()&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;strong&gt;Доступность&lt;/strong&gt; : при создании динамической библиотеки (см. --App: lib) в Posix этот процесс не определен. Проверьте доступность с помощью &lt;a href=&quot;system#declared&quot;&gt;объявленного ()&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="fcbe823732d2c9972cd2868d10967de104d96e54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Blocks&lt;/strong&gt; the current thread until the specified future completes.</source>
          <target state="translated">&lt;strong&gt;Блокирует&lt;/strong&gt; текущий поток, пока не завершится указанное будущее.</target>
        </trans-unit>
        <trans-unit id="ade01956444b2bedb6ba0ce473524e122c45ab36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DEPRECATED&lt;/strong&gt; as it was confused for shell quoting function. For this application use &lt;a href=&quot;osproc#quoteShell&quot;&gt;osproc.quoteShell&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;УСТАРЕЛО,&lt;/strong&gt; поскольку его путали с функцией цитирования оболочки. Для этого приложения используйте &lt;a href=&quot;osproc#quoteShell&quot;&gt;osproc.quoteShell&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f9bcec4d297aa8b62e7707f49f12d5b91ee3e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since 0.9.6&lt;/strong&gt;: Use &lt;code&gt;Uri&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.9.6&lt;/strong&gt; : используйте вместо этого &lt;code&gt;Uri&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0edc0ae576cbf1405d25d406473d00a29f1efad5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.14.0:&lt;/strong&gt; use &lt;code&gt;toTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с v0.14.0:&lt;/strong&gt; используйте вместо этого &lt;code&gt;toTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64a9b956a337527118896d06cbe9ae7f050d636f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.14.0:&lt;/strong&gt; use &lt;code&gt;toTimeInterval&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с v0.14.0:&lt;/strong&gt; используйте вместо этого &lt;code&gt;toTimeInterval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d42b15a342ba8260b2d18fb84c9410a31da17af0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;createNativeSocket&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.18.0:&lt;/strong&gt; используйте &lt;code&gt;createNativeSocket&lt;/code&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="07e0d4b10a5b7a0a71d906084234d0680ca5563e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;registerHandle&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.18.0:&lt;/strong&gt; используйте вместо него &lt;code&gt;registerHandle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1129f505c350479aaa022b8a8003b02d2ff1812a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;trigger&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.18.0:&lt;/strong&gt; используйте &lt;code&gt;trigger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df4c00b11b4bf37dc2f6430219a81fef666c3077" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; Use &lt;code&gt;updateHandle&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.18.0:&lt;/strong&gt; используйте &lt;code&gt;updateHandle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fd9c517dc50477a5fbd53eadca39aa342cacc15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;fromUnix&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.18.0:&lt;/strong&gt; используйте &lt;code&gt;fromUnix&lt;/code&gt; вместо</target>
        </trans-unit>
        <trans-unit id="cb78393c2152a466222fd3a7fb4214ff908ccea1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;getDayOfWeek(monthday: MonthdayRange; month: Month; year: int)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.18.0: вместо этого&lt;/strong&gt; используйте &lt;code&gt;getDayOfWeek(monthday: MonthdayRange; month: Month; year: int)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a648b574225c4c5297a7b9e6a179de1fa70405ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;initTimeInterval&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с v0.18.0:&lt;/strong&gt; используйте вместо него &lt;code&gt;initTimeInterval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b650e97ba36dce981193da56e9d3e90303aa2415" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;local&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с v0.18.0:&lt;/strong&gt; используйте вместо этого &lt;code&gt;local&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be21164252193e55e3a53ee4fd307e3bd091719f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;now().utcOffset&lt;/code&gt; to get the current utc offset (including DST).</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с v0.18.0:&lt;/strong&gt; используйте &lt;code&gt;now().utcOffset&lt;/code&gt; для получения текущего смещения utc (включая DST).</target>
        </trans-unit>
        <trans-unit id="7093a6b25b775ae7f81736fede1917ea4a624cb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;toUnix&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с v0.18.0:&lt;/strong&gt; вместо этого используйте &lt;code&gt;toUnix&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bfa49165457523fa77a7619996190f331b5e0fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.0:&lt;/strong&gt; use &lt;code&gt;utc&lt;/code&gt; instead</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с v0.18.0:&lt;/strong&gt; используйте вместо этого &lt;code&gt;utc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2f96fe2ad51bd3c2f12b80acad9b57384ced284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.2:&lt;/strong&gt; use &lt;code&gt;getBool&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с v0.18.2:&lt;/strong&gt; используйте вместо этого &lt;code&gt;getBool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df0e7fcddc8c3387b9579f61dc61f253f5817870" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.2:&lt;/strong&gt; use &lt;code&gt;getFloat&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.18.2:&lt;/strong&gt; используйте вместо этого &lt;code&gt;getFloat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1b0c3af938100bdf91557ac9b93edb506162843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.18.2:&lt;/strong&gt; use &lt;code&gt;getInt&lt;/code&gt; or &lt;code&gt;getBiggestInt&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.18.2:&lt;/strong&gt; используйте вместо них &lt;code&gt;getInt&lt;/code&gt; или &lt;code&gt;getBiggestInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff84ca124aa9ac594837f7d32a1435e66e43f038" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.19.0:&lt;/strong&gt; use &lt;code&gt;zonedTimeFromTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с v0.19.0:&lt;/strong&gt; используйте вместо этого &lt;code&gt;zonedTimeFromTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="595283a18cec59736002f87447f03a29696e5825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.19.0:&lt;/strong&gt; use the &lt;code&gt;time&lt;/code&gt; field instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с v0.19.0:&lt;/strong&gt; используйте вместо этого поле &lt;code&gt;time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5295b91fb2f0e30f39313327d56ecb8a32c45919" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.19.0:&lt;/strong&gt; use the &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии v0.19.0:&lt;/strong&gt; используйте вместо этого &lt;code&gt;zonedTimeFromAdjTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abdd1f4767c098ae47e6067b7b37ea7d137a5e30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since v0.8.10:&lt;/strong&gt; use &lt;code&gt;epochTime&lt;/code&gt; or &lt;code&gt;cpuTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.8.10:&lt;/strong&gt; используйте вместо этого &lt;code&gt;epochTime&lt;/code&gt; или &lt;code&gt;cpuTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baa9f17ac8b7f5e394f4f3c35b922f174fd2bf83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.12.0:&lt;/strong&gt; Use the &lt;code&gt;apply&lt;/code&gt; proc instead.</source>
          <target state="translated">&lt;strong&gt;Устаревший начиная с версии 0.12.0:&lt;/strong&gt; Используйте &lt;code&gt;apply&lt;/code&gt; процедурный вместо этого.</target>
        </trans-unit>
        <trans-unit id="813f61ed56bd8727049251f3d658b7107660c2bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.12.0:&lt;/strong&gt; Use the &lt;code&gt;mapIt(seq1, op)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.12.0:&lt;/strong&gt; используйте &lt;code&gt;mapIt(seq1, op)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f28367f57c9f2614afb958138d03a3bf3142b6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: Use &lt;code&gt;asyncnet.recvLine()&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.15.0&lt;/strong&gt; : используйте вместо него &lt;code&gt;asyncnet.recvLine()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2d7de988f2acf5e38494443df673fdfae41dc37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.get&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.15.0&lt;/strong&gt; : используйте вместо него &lt;code&gt;HttpClient.get&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="299961d38c046d81a057b39c87e1ea3541f2bbbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.getContent&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.15.0&lt;/strong&gt; : используйте вместо него &lt;code&gt;HttpClient.getContent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ec41efadd97988380f7499bf68d5ceb1b22a59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.post&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.15.0&lt;/strong&gt; : используйте вместо него &lt;code&gt;HttpClient.post&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c32a49f3f9d3f8d7e600b14dd15502686a235da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.postContent&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.15.0&lt;/strong&gt; : используйте вместо него &lt;code&gt;HttpClient.postContent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed96372a5060ce286aef82b0d3c6ae674a124053" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.15.0&lt;/strong&gt;: use &lt;code&gt;HttpClient.request&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.15.0&lt;/strong&gt; : используйте вместо него &lt;code&gt;HttpClient.request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="813b7f383169e8184fc6c9b0e28773046ac68201" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.16.2&lt;/strong&gt;: use &lt;code&gt;HttpClient.downloadFile&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.16.2&lt;/strong&gt; : используйте вместо него &lt;code&gt;HttpClient.downloadFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23834ea822e2c6d9726d7ec8d8695d7fb373d3c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.17.0&lt;/strong&gt;: This procedure isn't cross-platform and so should not be used in newly written code.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.17.0&lt;/strong&gt; : эта процедура не является кроссплатформенной, поэтому ее не следует использовать во вновь написанном коде.</target>
        </trans-unit>
        <trans-unit id="4df24020923200ebb62009aa073b6e02140c4500" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.0&lt;/strong&gt;. For the common excluding range write &lt;code&gt;0 ..&amp;lt; 10&lt;/code&gt; instead of &lt;code&gt;0 .. &amp;lt; 10&lt;/code&gt; (look at the spacing). For &lt;code&gt;&amp;lt;x&lt;/code&gt; write &lt;code&gt;pred(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.18.0&lt;/strong&gt; . Для общего диапазона исключения напишите &lt;code&gt;0 ..&amp;lt; 10&lt;/code&gt; вместо &lt;code&gt;0 .. &amp;lt; 10&lt;/code&gt; (посмотрите на интервал). Для &lt;code&gt;&amp;lt;x&lt;/code&gt; напишите &lt;code&gt;pred(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c7818b422a258b46806f0eafceaa44f6c79aeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;. Use len() instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.18.1&lt;/strong&gt; . Вместо этого используйте len ().</target>
        </trans-unit>
        <trans-unit id="7ef1cf4f5f7fc799e0b35914ada5c795f1cd5725" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; All functionality is defined on &lt;code&gt;NimNode&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.18.1&lt;/strong&gt; ; Вся функциональность определяется на &lt;code&gt;NimNode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e84173b0ac9d2fd4420a0991936918f4ee1a8ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Generate a new &lt;code&gt;NimNode&lt;/code&gt; with &lt;code&gt;genSym&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.18.1&lt;/strong&gt; ; &lt;code&gt;genSym&lt;/code&gt; этого сгенерируйте новый &lt;code&gt;NimNode&lt;/code&gt; с помощью genSym .</target>
        </trans-unit>
        <trans-unit id="16653bf53256723a0cc8002763700158bb2a42ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Generate a new &lt;code&gt;NimNode&lt;/code&gt; with &lt;code&gt;ident(string)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.18.1&lt;/strong&gt; ; &lt;code&gt;NimNode&lt;/code&gt; новый NimNode с &lt;code&gt;ident(string)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7fca1a76838f997b6b479a7049316d7b71e5d23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use &lt;code&gt;binarySearch&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.18.1&lt;/strong&gt; ; &lt;code&gt;binarySearch&lt;/code&gt; этого используйте binarySearch .</target>
        </trans-unit>
        <trans-unit id="07febc28bfa9d03d0fa4ee192105ba5a7d71b5d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.18.1&lt;/strong&gt;; Use one of &lt;code&gt;nestList(NimNode, ...)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.18.1&lt;/strong&gt; ; &lt;code&gt;nestList(NimNode, ...)&lt;/code&gt; используйте один из nestList (NimNode, ...) .</target>
        </trans-unit>
        <trans-unit id="4b359efb52a169b0f8e2ad570667904d89cf4c23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.8.12&lt;/strong&gt;: Use &lt;code&gt;parseWhile&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.8.12&lt;/strong&gt; : вместо этого используйте &lt;code&gt;parseWhile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd66fa6e9cfcab65583dfb8b55c8ca91df2a0525" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.0:&lt;/strong&gt; Please use &lt;code&gt;existsFile&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.9.0:&lt;/strong&gt; используйте &lt;code&gt;existsFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c46f664e9ddbfa0ff79f37fc44b94ec7d81f29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.0:&lt;/strong&gt; Please use the function above.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.9.0:&lt;/strong&gt; используйте указанную выше функцию.</target>
        </trans-unit>
        <trans-unit id="97dff7a47c48bdad8d984c2e2262de3696009ba8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function has been deprecated in favour of readLine.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.9.2&lt;/strong&gt; : эта функция устарела и &lt;strong&gt;заменена&lt;/strong&gt; на readLine.</target>
        </trans-unit>
        <trans-unit id="5f68edfa8278ec5885de09d908256c4b49e8634f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function has been deprecated in favour of readLineAsync.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется с версии 0.9.2&lt;/strong&gt; : эта функция устарела и &lt;strong&gt;заменена&lt;/strong&gt; на readLineAsync.</target>
        </trans-unit>
        <trans-unit id="c4af36b03e871c9cae4428903b9bca8534e6953e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated since version 0.9.2&lt;/strong&gt;: This function is not safe for use.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется, начиная с версии 0.9.2&lt;/strong&gt; : эта функция небезопасна для использования.</target>
        </trans-unit>
        <trans-unit id="fface47b088c778a2f4e77c02bf19ee55d18a8e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;fromWinTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется:&lt;/strong&gt; используйте &lt;code&gt;fromWinTime&lt;/code&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="06ec99b3afe2ae2cbe0edda32125eccea758f261" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;toWinTime&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;code&gt;toWinTime&lt;/code&gt; instead.</target>
        </trans-unit>
        <trans-unit id="3a884be761dae54201f8aa530278b417918acce3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; use &lt;em&gt;hasKey&lt;/em&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Не рекомендуется:&lt;/strong&gt; вместо этого используйте &lt;em&gt;hasKey&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a22c0c29442195e4011e17d60edeee2f5d85fcea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</source>
          <target state="translated">&lt;strong&gt;Отказ от ответственности&lt;/strong&gt; : этот код плохо протестирован, может быть очень небезопасным и подвержен уязвимостям безопасности.</target>
        </trans-unit>
        <trans-unit id="6ffe4dc5c4fc52ea3ea1e3a20dd64567380feece" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not use this module for cryptographic purposes!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Не используйте этот модуль в криптографических целях!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f928ed32bee5c29af52b00bc30f99ce156242335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docstring&lt;/strong&gt;: always the empty string.</source>
          <target state="translated">&lt;strong&gt;Строка документации&lt;/strong&gt; : всегда пустая строка.</target>
        </trans-unit>
        <trans-unit id="d4209dbb40d9185067bcb8ce189cd1c6eed7f25e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Docstring&lt;/strong&gt;: docstring if available.</source>
          <target state="translated">&lt;strong&gt;Строка документации&lt;/strong&gt; : &lt;strong&gt;строка&lt;/strong&gt; документации, если таковая имеется.</target>
        </trans-unit>
        <trans-unit id="1bc0a5d67820f61786ae04d054caabfe5bd3f6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73e5c6a20cafb8203519ae745e546e8bb3f10e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: always the empty string.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : всегда пустая строка.</target>
        </trans-unit>
        <trans-unit id="160ef9d36bed422272b88e68bd931cde20c08000" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: enum type grouping other enum fields.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : тип перечисления, объединяющий другие поля перечисления.</target>
        </trans-unit>
        <trans-unit id="be7ebe20c5b6aef98f77a13140c9b09bb67359f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the iterator including return type.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : подпись итератора, включая тип возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="c6c20f7dbb204753d2338c8585a984c7c7fa8c25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the macro including return type.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : подпись макроса, включая тип возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="b6771fb30bab96fd8cf5d95cfd5b7411f13b3c15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the method including return type.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : подпись метода, включая тип возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="8779f27a30500300592c1fbc44c5a869259d7284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the proc including return type.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : подпись процедуры, включая тип возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="5b4c52d33a04c0f32a87d9b5783e815726a1d81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: signature of the template including return type.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : подпись шаблона, включая тип возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="4dfd102fd6fbe96ece65dd9c1d384e0f16912006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the const value.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : тип значения const.</target>
        </trans-unit>
        <trans-unit id="63fb555122e12cadcd219b4c04854752ec0ed9fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the let variable.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : тип переменной let.</target>
        </trans-unit>
        <trans-unit id="20edb7c031a399a27ff6ff092cecc38f0cd151a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the parameter.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : тип параметра.</target>
        </trans-unit>
        <trans-unit id="d1c0d7dfb4af3e8e26314132e3d53473279ebfe5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the result.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : тип результата.</target>
        </trans-unit>
        <trans-unit id="c558e48e401e6265a17ebeab90f8b20f1f7e1e47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type of the var.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : тип var.</target>
        </trans-unit>
        <trans-unit id="9384cc6e440487319d842110001333299d831093" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: the type.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : тип.</target>
        </trans-unit>
        <trans-unit id="329b7e3326c98503c949ca9d39330b0e1c6794bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fourth column&lt;/strong&gt;: type of the var.</source>
          <target state="translated">&lt;strong&gt;Четвертый столбец&lt;/strong&gt; : тип вар.</target>
        </trans-unit>
        <trans-unit id="978f10cfc82df92effeee967159555f49c21c819" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: GC'ed memory should be allowed in unchecked arrays and there should be an explicit annotation of how the GC is to determine the runtime size of the array.</source>
          <target state="translated">&lt;strong&gt;Направления на будущее&lt;/strong&gt; : следует разрешить использование памяти GC в непроверенных массивах и должна быть явная аннотация того, как GC должен определять размер массива во время выполнения.</target>
        </trans-unit>
        <trans-unit id="150871409dc1ef45a59e74d4be5900fd8cf45ddc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: GC'ed memory should be allowed in unions and the GC should scan unions conservatively.</source>
          <target state="translated">&lt;strong&gt;Направления на будущее&lt;/strong&gt; : память с GC должна быть разрешена в объединениях, и GC должен сканировать объединения консервативно.</target>
        </trans-unit>
        <trans-unit id="5f1330a349c9dedfd2b8b17d35746d232592d00d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: The &lt;code&gt;acyclic&lt;/code&gt; pragma may become a property of a &lt;code&gt;ref&lt;/code&gt; type:</source>
          <target state="translated">&lt;strong&gt;Направления на будущее&lt;/strong&gt; : &lt;code&gt;acyclic&lt;/code&gt; прагма может стать свойством типа &lt;code&gt;ref&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="75d19ae59ec3e06e328ace922bad09261db8a6c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Future directions&lt;/strong&gt;: Using GC'ed memory in packed pragma will result in compile-time error. Usage with inheritance should be defined and documented.</source>
          <target state="translated">&lt;strong&gt;Направления на будущее&lt;/strong&gt; : использование памяти GC в пакете прагмы приведет к ошибке времени компиляции. Использование с наследованием должно быть определено и задокументировано.</target>
        </trans-unit>
        <trans-unit id="b59417140c3fc6f7e2c17f2c777a2f509360e62e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hint:&lt;/strong&gt; With &lt;code&gt;--hint[codeBegin]:on```or ``--verbosity:2&lt;/code&gt; (or higher) Nim lists the processed code after each filter application.</source>
          <target state="translated">&lt;strong&gt;Подсказка: с&lt;/strong&gt; помощью &lt;code&gt;--hint[codeBegin]:on```or ``--verbosity:2&lt;/code&gt; (или выше) Nim выводит обработанный код после каждого применения фильтра.</target>
        </trans-unit>
        <trans-unit id="f555042911466061dac7f6fee69c396fc92108dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Known limitations:&lt;/strong&gt; In the JavaScript target, global variables using the &lt;code&gt;codegenDecl&lt;/code&gt; pragma will be re-initialized on each reload. Please guard the initialization with a &lt;em&gt;once&lt;/em&gt; block to work-around this.</source>
          <target state="translated">&lt;strong&gt;Известные ограничения:&lt;/strong&gt; в цели JavaScript глобальные переменные, использующие прагму &lt;code&gt;codegenDecl&lt;/code&gt; , будут повторно инициализироваться при каждой перезагрузке. Пожалуйста , храните инициализацию с &lt;em&gt;разом&lt;/em&gt; блоком для работы вокруг этого.</target>
        </trans-unit>
        <trans-unit id="5911ff88eb68bebee7d71b3a0d7b01ad6e208cea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Nim currently does not detect these!</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; : в настоящее время Nim их не обнаруживает!</target>
        </trans-unit>
        <trans-unit id="140047e96ac4c58f01e73270812c9a51624feb38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; At the moment hot code reloading is supported only in JavaScript projects.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; на данный момент горячая перезагрузка кода поддерживается только в проектах JavaScript.</target>
        </trans-unit>
        <trans-unit id="a5ae990ae2793f586640459d0853bfff28f07ff8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Comment statement will be ignored.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Комментарий будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="d4b69032440a3760c06332bd2946743c6dc04769" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Each delegate has a task associated with it. This gets called after each select() call, if you set timeout to &lt;code&gt;-1&lt;/code&gt; the tasks will only be executed after one or more file descriptors becomes readable or writeable.</source>
          <target state="translated">&lt;strong&gt;Примечание. С&lt;/strong&gt; каждым делегатом связана задача. Он вызывается после каждого вызова select (), если вы установите тайм-аут на &lt;code&gt;-1&lt;/code&gt; , задачи будут выполняться только после того, как один или несколько файловых дескрипторов станут доступными для чтения или записи.</target>
        </trans-unit>
        <trans-unit id="7f378938581797df4e574611774903888f75a977" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For leap years, start date is assumed to be 1 AD. counts the number of leap years up to January 1st of a given year. Keep in mind that if specified year is a leap year, the leap day has not happened before January 1st of that year.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Для високосных лет датой начала считается 1 год нашей эры. подсчитывает количество високосных лет до 1 января данного года. Имейте в виду, что если указанный год является високосным, високосный день не наступил до 1 января этого года.</target>
        </trans-unit>
        <trans-unit id="8234ec32d945f2b0f03239d1b0eaae84f70df2af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want to provide async ability to your module please do not use the &lt;code&gt;Delegate&lt;/code&gt; object, instead use &lt;code&gt;AsyncSocket&lt;/code&gt;. It is possible that in the future this type's fields will not be exported therefore breaking your code.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Если вы хотите предоставить своему модулю возможность асинхронной обработки, не используйте объект &lt;code&gt;Delegate&lt;/code&gt; , а используйте &lt;code&gt;AsyncSocket&lt;/code&gt; . Возможно, что в будущем поля этого типа не будут экспортироваться, что нарушит ваш код.</target>
        </trans-unit>
        <trans-unit id="6066c5e1dbc1c07031004fde7afa16f36e8afe0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Most modules have tasks which need to be ran regularly, this is why you should not call &lt;code&gt;poll&lt;/code&gt; with a infinite timeout, or even a very long one. In most cases the default timeout is fine.</source>
          <target state="translated">&lt;strong&gt;Примечание: у&lt;/strong&gt; большинства модулей есть задачи, которые необходимо запускать регулярно, поэтому вы не должны вызывать &lt;code&gt;poll&lt;/code&gt; с бесконечным таймаутом или даже очень длинным. В большинстве случаев тайм-аут по умолчанию подходит.</target>
        </trans-unit>
        <trans-unit id="4f92aa536204e6eaef641a2e69451b390e74e1bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;em&gt;project file name&lt;/em&gt; is the name of the &lt;code&gt;.nim&lt;/code&gt; file that is passed as a command line argument to the compiler.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Имя &lt;em&gt;файла проекта&lt;/em&gt; - это имя файла &lt;code&gt;.nim&lt;/code&gt; , который передается компилятору в качестве аргумента командной строки.</target>
        </trans-unit>
        <trans-unit id="2a72b0f5ef54ecdf16cb26a40bdbef5872800692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The API of FutureStream is still new and so has a higher likelihood of changing in the future.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . API FutureStream все еще новый, поэтому вероятность его изменения в будущем выше.</target>
        </trans-unit>
        <trans-unit id="fe5b130db131453d8df37e590c01fe6f08bec9e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The behaviour of this procedure changed in version 0.14.0. To get a list of usages and to restore the old behaviour of this procedure, compile with the &lt;code&gt;-d:nimJsonGet&lt;/code&gt; flag.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Поведение этой процедуры изменилось в версии 0.14.0. Чтобы получить список использований и восстановить прежнее поведение этой процедуры, &lt;code&gt;-d:nimJsonGet&lt;/code&gt; компиляцию с флагом -d: nimJsonGet .</target>
        </trans-unit>
        <trans-unit id="c072da5e00ce440c3b93018b2a1ef17e9ee5503c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of message passing does not work with cyclic data structures. &lt;strong&gt;Note:&lt;/strong&gt; Channels cannot be passed between threads. Use globals or pass them by &lt;em&gt;ptr&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Текущая реализация передачи сообщений не работает с циклическими структурами данных. &lt;strong&gt;Примечание.&lt;/strong&gt; Каналы нельзя передавать между потоками. Используйте глобальные переменные или передавайте их через &lt;em&gt;ptr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b999dbe7ed39e219e124bd0949367e2e3d56fe13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The resulting &lt;code&gt;XmlNode&lt;/code&gt; already uses the &lt;code&gt;clientData&lt;/code&gt; field, so it cannot be used by clients of this library.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Результирующий &lt;code&gt;XmlNode&lt;/code&gt; уже использует поле &lt;code&gt;clientData&lt;/code&gt; , поэтому он не может использоваться клиентами этой библиотеки.</target>
        </trans-unit>
        <trans-unit id="eb469a558a1fb80f9ffa7a37d87dd2f9adc314d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The server may return multiple lines of coded replies.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Сервер может возвращать несколько строк закодированных ответов.</target>
        </trans-unit>
        <trans-unit id="0d1eacb2a91de8906a2993f50f4d1523095b2af2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; There are no postfix operators in Nim. However, the &lt;code&gt;nnkPostfix&lt;/code&gt; node is used for the &lt;em&gt;asterisk export marker&lt;/em&gt;&lt;code&gt;*&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; В Nim нет постфиксных операторов. Однако узел &lt;code&gt;nnkPostfix&lt;/code&gt; используется для &lt;em&gt;маркера экспорта звездочки &lt;/em&gt; &lt;code&gt;*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f905a6d385133393b2c96347260edc54f46375a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This does not preserve the new line characters used in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Это не сохраняет символы новой строки, используемые в &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7811fa53cf7abdc675dfee2447ec973dd431ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is not supported on &lt;code&gt;Windows&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Эта функция не поддерживается в &lt;code&gt;Windows&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10e606a3da78b8e2b189b92aa03f1f5e54c1d549" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is supported only by BSD and MacOSX.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Эта функция поддерживается только BSD и MacOSX.</target>
        </trans-unit>
        <trans-unit id="b24c06d6eed7edbd4cef00490b4db7c0ca199c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This module currently only supports select(), this is limited by FD_SETSIZE, which is usually 1024. So you may only be able to use 1024 sockets at a time.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; этот модуль в настоящее время поддерживает только select (), это ограничено FD_SETSIZE, которое обычно равно 1024. Таким образом, вы можете использовать только 1024 сокета одновременно.</target>
        </trans-unit>
        <trans-unit id="be757c0b40131a488a140d8d6a5f654644bde753" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This proc is not available for SSL sockets.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Эта процедура недоступна для сокетов SSL.</target>
        </trans-unit>
        <trans-unit id="8996a73c32006599330b4aacfeffcd8eabd847e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Under POSIX OS's, the returned time may actually be the time at which the file's attribute's were last modified. See &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1058&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; В операционных системах POSIX возвращаемое время может фактически быть временем последнего изменения атрибутов файла. Подробности смотрите &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1058&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4326e562047392c7a998b1d78e1b1453866d2345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You may wish to use the high-level version of this function which is defined below.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; вы можете захотеть использовать высокоуровневую версию этой функции, которая определена ниже.</target>
        </trans-unit>
        <trans-unit id="18f7852fedb7919a22f8ce639864908dfafb58b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You will need to run asynchronous examples in an async proc otherwise you will get an &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; error.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; вам нужно будет запустить асинхронные примеры в асинхронной процедуре, иначе вы получите &lt;code&gt;Undeclared identifier: 'await'&lt;/code&gt; ошибка 'await' .</target>
        </trans-unit>
        <trans-unit id="e153549d82bb0553e51565bc85af72f16648f194" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;c2nim&quot;&gt;c2nim&lt;/a&gt; can parse a large subset of C++ and knows about the &lt;code&gt;importcpp&lt;/code&gt; pragma pattern language. It is not necessary to know all the details described here.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : &lt;a href=&quot;c2nim&quot;&gt;c2nim&lt;/a&gt; может анализировать большое количество языков C ++ и знает язык &lt;code&gt;importcpp&lt;/code&gt; . Необязательно знать все подробности, описанные здесь.</target>
        </trans-unit>
        <trans-unit id="752ddb5d050c961f8013cbe90d4ad9d26a7ee13a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;client&lt;/code&gt; must be initialised (with &lt;code&gt;new&lt;/code&gt;), this function makes no effort to initialise the &lt;code&gt;client&lt;/code&gt; variable.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : &lt;code&gt;client&lt;/code&gt; должен быть инициализирован (с &lt;code&gt;new&lt;/code&gt; ), эта функция не предпринимает никаких усилий для инициализации переменной &lt;code&gt;client&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="449eaada440261e910e8e598da9c4ed1cfb68e61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;client&lt;/code&gt; needs to be initialised.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : &lt;code&gt;client&lt;/code&gt; должен быть инициализирован.</target>
        </trans-unit>
        <trans-unit id="ed6c907ecc726f3524b1431bfea1378d7d591f2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;data&lt;/code&gt; must be initialised.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : &lt;code&gt;data&lt;/code&gt; должны быть инициализированы.</target>
        </trans-unit>
        <trans-unit id="79f23d79481e20b54cf233e31f8767bbf0d80411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;var&lt;/code&gt; parameters are never necessary for efficient parameter passing. Since non-var parameters cannot be modified the compiler is always free to pass arguments by reference if it considers it can speed up execution.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : параметры &lt;code&gt;var&lt;/code&gt; никогда не нужны для эффективной передачи параметров. Поскольку параметры, не являющиеся переменными, не могут быть изменены, компилятор всегда может передавать аргументы по ссылке, если считает, что это может ускорить выполнение.</target>
        </trans-unit>
        <trans-unit id="917b6bc95e7e2268d07e2f344f8fb05732bc1b22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A &lt;code&gt;dynlib&lt;/code&gt; import can be overridden with the &lt;code&gt;--dynlibOverride:name&lt;/code&gt; command line option. The Compiler User Guide contains further information.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Импорт &lt;code&gt;dynlib&lt;/code&gt; можно переопределить с помощью &lt;code&gt;--dynlibOverride:name&lt;/code&gt; командной строки --dynlibOverride: name . Руководство пользователя компилятора содержит дополнительную информацию.</target>
        </trans-unit>
        <trans-unit id="a4c0c0109f9323e091c1b8f19f86e88886ea759e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: An &lt;span id=&quot;unresolved_1&quot;&gt;unresolved&lt;/span&gt; expression is an expression for which no symbol lookups and no type checking have been performed.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . &lt;span id=&quot;unresolved_1&quot;&gt;Неразрешенное&lt;/span&gt; выражение - это выражение, для которого не выполнялся поиск символов и проверка типа.</target>
        </trans-unit>
        <trans-unit id="19158a8ced28ef096d6d098faea99e938f8aea45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: As a special syntactic extension if the whole PEG is only a single expression, identifiers are not interpreted as non-terminals, but are interpreted as verbatim string:</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . В качестве специального синтаксического расширения, если весь PEG представляет собой только одно выражение, идентификаторы не интерпретируются как нетерминальные, а интерпретируются как дословная строка:</target>
        </trans-unit>
        <trans-unit id="394b8821bf33b16092eceec91b4261c0182b2ffd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Code reordering is experimental and must be enabled via the &lt;code&gt;{.experimental.}&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;strong&gt;Примечание. &lt;/strong&gt; &lt;code&gt;{.experimental.}&lt;/code&gt; кода является экспериментальным и должно быть разрешено с помощью прагмы {.experimental.} .</target>
        </trans-unit>
        <trans-unit id="15d3410cbe9aaa0f2ff2edaf757af2c7376b1329" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Compile time evaluation is not (yet) supported for methods.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Оценка времени компиляции (пока) не поддерживается для методов.</target>
        </trans-unit>
        <trans-unit id="1ec4927b4c9fc829236a51cac7723591db8396a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Composition (&lt;em&gt;has-a&lt;/em&gt; relation) is often preferable to inheritance (&lt;em&gt;is-a&lt;/em&gt; relation) for simple code reuse. Since objects are value types in Nim, composition is as efficient as inheritance.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Для простого повторного использования кода композиция ( &lt;em&gt;есть-&lt;/em&gt; отношение) часто предпочтительнее наследования ( &lt;em&gt;есть-&lt;/em&gt; отношение). Поскольку объекты в Nim являются типами значений, композиция столь же эффективна, как и наследование.</target>
        </trans-unit>
        <trans-unit id="0f588e4000ab499174937baf99ba9de907f81477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Concepts are still in development.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : концепции все еще находятся в разработке.</target>
        </trans-unit>
        <trans-unit id="af0cb2698b6f62001c812557400b5666b24c541b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently exceptions are not propagated between &lt;code&gt;spawn&lt;/code&gt;'ed tasks!</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : в настоящее время исключения не распространяются между &lt;code&gt;spawn&lt;/code&gt; задачами!</target>
        </trans-unit>
        <trans-unit id="e593de705b48a873244d353e72e0630bbbf7e8ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the compiler recognizes but ignores this pragma.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . В настоящее время компилятор распознает, но игнорирует эту прагму.</target>
        </trans-unit>
        <trans-unit id="1b2d5b76dbe4b87b85248e2c9cb6a142ec8c770f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently the creation of &lt;code&gt;nimrtl.dll&lt;/code&gt; with thread support has never been tested and is unlikely to work!</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . В настоящее время создание &lt;code&gt;nimrtl.dll&lt;/code&gt; с поддержкой потоков никогда не тестировалось и вряд ли будет работать!</target>
        </trans-unit>
        <trans-unit id="fb2822c93615d44b3b3cc5966ff533ff418b8724" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Destructors are still experimental and the spec might change significantly in order to incorporate an escape analysis.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : деструкторы все еще являются экспериментальными, и спецификация может значительно измениться, чтобы включить анализ побега.</target>
        </trans-unit>
        <trans-unit id="ee1ed6db845c184364f8097a01163d56d39e9c4d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Dot operators are still experimental and so need to be enabled via &lt;code&gt;{.experimental: &quot;dotOperators&quot;.}&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Операторы точки все еще являются экспериментальными, поэтому их необходимо включить с помощью &lt;code&gt;{.experimental: &quot;dotOperators&quot;.}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76687951273781b82f6f05a64604534fc897b54a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For SSL sockets, the &lt;code&gt;handshake&lt;/code&gt; procedure must be called whenever the socket successfully connects to a server.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Для сокетов SSL процедура &lt;code&gt;handshake&lt;/code&gt; должна вызываться всякий раз, когда сокет успешно подключается к серверу.</target>
        </trans-unit>
        <trans-unit id="91e3db899bae0bbfb9a7d3d39b2d7c168b6e2d11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;stmt&lt;/code&gt; is an alias for &lt;code&gt;typed&lt;/code&gt; and &lt;code&gt;expr&lt;/code&gt; an alias for &lt;code&gt;untyped&lt;/code&gt;, but new code should use the newer, clearer names.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . По историческим причинам &lt;code&gt;stmt&lt;/code&gt; является псевдонимом для &lt;code&gt;typed&lt;/code&gt; и &lt;code&gt;expr&lt;/code&gt; псевдонимом для &lt;code&gt;untyped&lt;/code&gt; , но новый код должен использовать более новые и понятные имена.</target>
        </trans-unit>
        <trans-unit id="35fa8c02b68bd348136724f65366d5d42363838f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For historical reasons &lt;code&gt;varargs[expr]&lt;/code&gt; is not equivalent to &lt;code&gt;varargs[untyped]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . По историческим причинам &lt;code&gt;varargs[expr]&lt;/code&gt; не эквивалентен &lt;code&gt;varargs[untyped]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc5314fa7beb1755c498007976fd6bffd4a8741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Nim computes a SHA1 checksum and only recompiles the file if it has changed. You can use the &lt;code&gt;-f&lt;/code&gt; command line option to force recompilation of the file.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : Nim вычисляет контрольную сумму SHA1 и перекомпилирует файл только в том случае, если он был изменен. Вы можете использовать параметр командной строки &lt;code&gt;-f&lt;/code&gt; , чтобы принудительно перекомпилировать файл.</target>
        </trans-unit>
        <trans-unit id="1271bb2722e7587eff37d0ec7806e796871dfb12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Openarrays can only be used for parameters.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : Openarrays можно использовать только для параметров.</target>
        </trans-unit>
        <trans-unit id="69090e5eea8eeff4b4d6ed39bda4ed8ea1e00303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Passing variables to the &lt;code&gt;dynlib&lt;/code&gt; pragma will fail at runtime because of order of initialization problems.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Передача переменных в прагму &lt;code&gt;dynlib&lt;/code&gt; завершится ошибкой во время выполнения из-за проблем с порядком инициализации.</target>
        </trans-unit>
        <trans-unit id="3d949419e5e8c75fc524d73127b46fd0d96b06e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Patterns like &lt;code&gt;libtcl(|8.5|8.4).so&lt;/code&gt; are only supported in constant strings, because they are precompiled.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Такие шаблоны, как &lt;code&gt;libtcl(|8.5|8.4).so&lt;/code&gt; , поддерживаются только в постоянных строках, поскольку они предварительно скомпилированы.</target>
        </trans-unit>
        <trans-unit id="5c87c54173a7af7c54802abf0f3667ebc67c0bd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Read/write tracking is not yet implemented!</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : отслеживание чтения / записи еще не реализовано!</target>
        </trans-unit>
        <trans-unit id="935e75468fab30bc8f181842cd16bcdfa062c5e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;.this&lt;/code&gt; pragma is deprecated and should not be used anymore.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . &lt;code&gt;.this&lt;/code&gt; .this устарела и больше не должна использоваться.</target>
        </trans-unit>
        <trans-unit id="e111e86a91d15663eda5e4e58e22260484c13d8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; operations are available at compile-time!</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Операции &lt;code&gt;to&lt;/code&gt; и &lt;code&gt;$$&lt;/code&gt; доступны во время компиляции!</target>
        </trans-unit>
        <trans-unit id="1f9fdb234ef8ab9ea0cd0ee243a725c77f4c3646" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The asynchronous implementation is only asynchronous for long file transfers, calls to functions which use the command socket will block.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Асинхронная реализация является асинхронной только для передачи длинных файлов, вызовы функций, использующих командный сокет, будут блокироваться.</target>
        </trans-unit>
        <trans-unit id="21b5006b1c5b3e0551182aafd1ac04017eed31d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The data types declared here have &lt;em&gt;value semantics&lt;/em&gt;: This means that &lt;code&gt;=&lt;/code&gt; performs a copy of the set.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Объявленные здесь типы данных имеют &lt;em&gt;семантику значений&lt;/em&gt; : это означает, что &lt;code&gt;=&lt;/code&gt; выполняет копию набора.</target>
        </trans-unit>
        <trans-unit id="280898b023d47a8c9d92f2a9764ba5070e544d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example only works because the memory is initialized to zero (&lt;code&gt;alloc0&lt;/code&gt; instead of &lt;code&gt;alloc&lt;/code&gt; does this): &lt;code&gt;d.s&lt;/code&gt; is thus initialized to binary zero which the string assignment can handle. One needs to know low level details like this when mixing garbage collected data with unmanaged memory.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : Этот пример работает только потому , что память инициализируется в нуль ( &lt;code&gt;alloc0&lt;/code&gt; вместо &lt;code&gt;alloc&lt;/code&gt; делает это): &lt;code&gt;d.s&lt;/code&gt; , таким образом , чтобы инициализировать двоичный ноль, когда присвоение строка может обрабатывать. При смешивании данных, собранных с помощью мусора, с неуправляемой памятью необходимо знать подробности низкого уровня.</target>
        </trans-unit>
        <trans-unit id="47964f4e63f9364071ab4aeb6d699ff7f8c08bcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--assumedef&lt;/code&gt; and &lt;code&gt;--assumendef&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Существуют также &lt;code&gt;--assumedef&lt;/code&gt; командной строки --assumedef и &lt;code&gt;--assumendef&lt;/code&gt; , которые можно использовать для той же цели.</target>
        </trans-unit>
        <trans-unit id="beec5a850cfc6f7745e1b0ecb5a58d4d3717ffad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--prefix&lt;/code&gt; and &lt;code&gt;--suffix&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Существуют также &lt;code&gt;--suffix&lt;/code&gt; командной строки &lt;code&gt;--prefix&lt;/code&gt; и --suffix , которые можно использовать с той же целью.</target>
        </trans-unit>
        <trans-unit id="69ba15cf193dfbb62171a2742d239684c78daa69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are also &lt;code&gt;--stdcall&lt;/code&gt; and &lt;code&gt;--cdecl&lt;/code&gt; command line options that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Существуют также &lt;code&gt;--stdcall&lt;/code&gt; командной строки --stdcall и &lt;code&gt;--cdecl&lt;/code&gt; , которые можно использовать для той же цели.</target>
        </trans-unit>
        <trans-unit id="6eae5a3b83fbed6b6c57ab8bbef30bd246b16faa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There are two approaches to parameter substitution support by this module.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Этот модуль предлагает два подхода к поддержке подстановки параметров.</target>
        </trans-unit>
        <trans-unit id="a5a42997a6733b871213621a8b95f824a807c7b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--dynlib&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Существует также &lt;code&gt;--dynlib&lt;/code&gt; командной строки --dynlib, который можно использовать для той же цели.</target>
        </trans-unit>
        <trans-unit id="7af996a9b1410d0551b826fcf6f31d2982be4597" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--header&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Существует также &lt;code&gt;--header&lt;/code&gt; командной строки --header, который можно использовать для той же цели.</target>
        </trans-unit>
        <trans-unit id="0f6e6a5551e301a9206be409821f73e8efe724ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--skipcomments&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Существует также &lt;code&gt;--skipcomments&lt;/code&gt; командной строки --skipcomments, который можно использовать для той же цели.</target>
        </trans-unit>
        <trans-unit id="24001770e3fa5f62c6de4221e4016da922b0b6b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--skipinclude&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Существует также &lt;code&gt;--skipinclude&lt;/code&gt; командной строки --skipinclude, который можно использовать для той же цели.</target>
        </trans-unit>
        <trans-unit id="2a3d0067cf0a534d5914217a3b18410a03771aa4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: There is also a &lt;code&gt;--typeprefixes&lt;/code&gt; command line option that can be used for the same purpose.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Существует также &lt;code&gt;--typeprefixes&lt;/code&gt; командной строки --typeprefixes, который можно использовать для той же цели.</target>
        </trans-unit>
        <trans-unit id="e18e21cf48841adbc9777187ae8968f7fba53e98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This document is a draft! Several of Nim's features may need more precise wording. This manual is constantly evolving into a proper specification.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : этот документ является черновиком! Некоторые функции Nim могут нуждаться в более точных формулировках. Это руководство постоянно развивается в надлежащую спецификацию.</target>
        </trans-unit>
        <trans-unit id="054e7ea2fe4b0d2089c5eb61f38663920957149a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a low-level function, you may be interested in the higher level versions of this function which are also named &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : это функция низкого уровня, вас могут заинтересовать версии этой функции более высокого уровня, которые также называются &lt;code&gt;recv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5282ba94e7660dfc3a29bcd1eed3c48d245d27d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is a low-level version of &lt;code&gt;send&lt;/code&gt;. You likely should use the version below.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Это низкоуровневая версия &lt;code&gt;send&lt;/code&gt; . Вероятно, вам следует использовать версию ниже.</target>
        </trans-unit>
        <trans-unit id="a69e35e7b9f3081695456106f46697c03ffedd82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This module is deprecated since version 0.11.3. You should use the async version of this module &lt;a href=&quot;asyncftpclient&quot;&gt;asyncftpclient&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Этот модуль считается устаревшим, начиная с версии 0.11.3. Вы должны использовать асинхронную версию этого модуля &lt;a href=&quot;asyncftpclient&quot;&gt;asyncftpclient&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2aa27f677d4a034cdeb59f9e8f5be392614db71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This pragma should only be used by procs which consist solely of assembler statements.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Эта прагма должна использоваться только процедурами, состоящими исключительно из операторов ассемблера.</target>
        </trans-unit>
        <trans-unit id="c3942176661636505e686cd1e170c9c2c66c7838" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This pragma will not exist for the LLVM backend.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Эта прагма не будет существовать для серверной части LLVM.</target>
        </trans-unit>
        <trans-unit id="e370238e58db64e0d5e09298f252112f6df12b8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This procedure is mostly used for testing. You likely want to use &lt;code&gt;asyncnet.recvLine&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : эта процедура в основном используется для тестирования. Скорее всего, вы захотите использовать вместо него &lt;code&gt;asyncnet.recvLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="322b2c09d6ee80b4e8d9ee5e387bb8ede9f8c9b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This procedure will &lt;strong&gt;NOT&lt;/strong&gt; register &lt;code&gt;fd&lt;/code&gt; with the global async dispatcher. You need to do this manually. If you have used &lt;code&gt;newAsyncNativeSocket&lt;/code&gt; to create &lt;code&gt;fd&lt;/code&gt; then it's already registered.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Эта процедура &lt;strong&gt;НЕ&lt;/strong&gt; регистрирует &lt;code&gt;fd&lt;/code&gt; в глобальном диспетчере async. Делать это нужно вручную. Если вы использовали &lt;code&gt;newAsyncNativeSocket&lt;/code&gt; для создания &lt;code&gt;fd&lt;/code&gt; , значит, он уже зарегистрирован.</target>
        </trans-unit>
        <trans-unit id="d932869f99df24b8242ec488c4a11db3770fcfc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This will not work for the LLVM backend.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : это не будет работать для серверной части LLVM.</target>
        </trans-unit>
        <trans-unit id="36372381e9ac840b308a26506bae63970c747486" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This will set &lt;code&gt;sock&lt;/code&gt; to be non-blocking.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : в этом случае &lt;code&gt;sock&lt;/code&gt; будет неблокирующим.</target>
        </trans-unit>
        <trans-unit id="1223df2703569d7a264f78da6a04381483fe3ce4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: static[T] is still in development.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : static [T] все еще находится в разработке.</target>
        </trans-unit>
        <trans-unit id="cfc7fae090374e3f5581cc6d980013b1b5608dd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this proc does not exist while using the JS backend.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : эта процедура не существует при использовании бэкэнда JS.</target>
        </trans-unit>
        <trans-unit id="3999835082895c400051c08efff687fac9d5116a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance note&lt;/strong&gt;: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.</source>
          <target state="translated">&lt;strong&gt;Замечание по производительности&lt;/strong&gt; : Nim не создает таблицу виртуальных методов, а создает деревья диспетчеризации. Это позволяет избежать дорогостоящего непрямого перехода для вызовов методов и позволяет встраивать. Однако другие оптимизации, такие как оценка времени компиляции или удаление мертвого кода, не работают с методами.</target>
        </trans-unit>
        <trans-unit id="23e826b6b4ecba08efbc3138c61cefb888e1c674" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please do not use this&lt;/strong&gt;: On Android, it currently returns &lt;code&gt;getHomeDir()&lt;/code&gt;, and on other Unix based systems it can cause security problems too. That said, you can override this implementation by adding &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; to your compiler invokation.</source>
          <target state="translated">&lt;strong&gt;Пожалуйста, не используйте это&lt;/strong&gt; : в Android он в настоящее время возвращает &lt;code&gt;getHomeDir()&lt;/code&gt; , а в других системах на базе Unix это также может вызвать проблемы с безопасностью. Тем не менее, вы можете переопределить эту реализацию, добавив &lt;code&gt;-d:tempDir=mytempname&lt;/code&gt; к вызову вашего компилятора.</target>
        </trans-unit>
        <trans-unit id="af53126db5be4c8aab90d27d5734b3708b192d3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restriction&lt;/strong&gt;: For objects their type is &lt;strong&gt;not&lt;/strong&gt; serialized. This means essentially that it does not work if the object has some other runtime type than its compiletime type:</source>
          <target state="translated">&lt;strong&gt;Ограничение&lt;/strong&gt; : Для объектов их тип &lt;strong&gt;не&lt;/strong&gt; сериализуется. По сути, это означает, что он не будет работать, если объект имеет другой тип времени выполнения, чем его тип времени компиляции:</target>
        </trans-unit>
        <trans-unit id="92e0079e41a5b0f8de60d18697948189f4c07fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Style note&lt;/strong&gt;: For code readability, it is the best idea to use the least powerful programming construct that still suffices. So the &quot;check list&quot; is:</source>
          <target state="translated">&lt;strong&gt;Примечание по стилю&lt;/strong&gt; : для удобочитаемости кода лучше всего использовать наименее мощную программную конструкцию, которой все еще достаточно. Итак, &amp;laquo;контрольный список&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="fe1515dd837d06ebdfb95963f4b433b9a9c3985a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + const name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + имя константы.</target>
        </trans-unit>
        <trans-unit id="89fa1ce97e4b1a8bbc8a7bdf79f0c84b5531d6c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + enum type + enum field name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + тип перечисления + имя поля перечисления.</target>
        </trans-unit>
        <trans-unit id="44cc69c566e0009f6ccc0fbac4d3567a0268b727" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + iterator name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + имя итератора.</target>
        </trans-unit>
        <trans-unit id="821988216adbe7cd1954ec0da5648027ef8dc44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + let name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : module + [n scope nesting] + let name.</target>
        </trans-unit>
        <trans-unit id="57a25e461776b40d157a649de93257f5fe549d65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + macro name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + имя макроса.</target>
        </trans-unit>
        <trans-unit id="3166d2d68e6f9702d538e16e0e365a37f0f31329" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + method name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + имя метода.</target>
        </trans-unit>
        <trans-unit id="061167cd91100dd105e9d11351199c7b83c16430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + имя.</target>
        </trans-unit>
        <trans-unit id="acf85825d2dfb7a2233737f8ada9679976415f1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + param name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + имя параметра.</target>
        </trans-unit>
        <trans-unit id="546e3a8202699c79b7b925592249d4072a1845aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + proc name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + имя процедуры.</target>
        </trans-unit>
        <trans-unit id="e1aaee074e6af2e4ed1a60de85b378cc36322c99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + result.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + результат.</target>
        </trans-unit>
        <trans-unit id="ca9583e48baa25b1239a744bd75804685b9425dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + template name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + имя шаблона.</target>
        </trans-unit>
        <trans-unit id="e445dd6209bef0d057963888553bf05a22332bbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + type name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + имя типа.</target>
        </trans-unit>
        <trans-unit id="0e96cb006b66e97d61d546d8e4a627270ae7af33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Third column&lt;/strong&gt;: module + [n scope nesting] + var name.</source>
          <target state="translated">&lt;strong&gt;Третий столбец&lt;/strong&gt; : модуль + [n вложенность области] + имя переменной.</target>
        </trans-unit>
        <trans-unit id="96622873fb587ed595611ae4d0e283ece6697a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is deprecated and should not be used&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Это устарело и не должно использоваться&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5a9df7eca11b12855add51f036ea9d3d1ea8ae1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage in JavaScript projects:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Использование в проектах JavaScript:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4316d6405c9f4c9d98f6e1f272b469fd25904ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: Use it with caution. If &lt;code&gt;buf&lt;/code&gt; refers to GC'ed object, you must use GC_ref/GC_unref calls to avoid early freeing of the buffer.</source>
          <target state="translated">&lt;strong&gt;ВНИМАНИЕ&lt;/strong&gt; : используйте его с осторожностью. Если &lt;code&gt;buf&lt;/code&gt; ссылается на объект с GC, вы должны использовать вызовы GC_ref / GC_unref, чтобы избежать раннего освобождения буфера.</target>
        </trans-unit>
        <trans-unit id="5f8f9514a22b55ff9c78136da9ef8a81f67b0108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the process has not finished executing, this will forcibly terminate the process. Doing so may result in zombie processes and &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;pty leaks&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; если процесс не завершился, это принудительно завершит его. Это может привести к зомби-процессам и &lt;a href=&quot;http://stackoverflow.com/questions/27021641/how-to-fix-request-failed-on-channel-0&quot;&gt;утечкам данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7648a978c3c5b08aa7a942fe439314fcbbd9e17c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; It's not recommended to use &lt;code&gt;between&lt;/code&gt; for &lt;code&gt;DateTime's&lt;/code&gt; in different &lt;code&gt;TimeZone's&lt;/code&gt;. &lt;code&gt;a + between(a, b) == b&lt;/code&gt; is only guaranteed when &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are in UTC.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; не рекомендуется использовать &lt;code&gt;between&lt;/code&gt; для &lt;code&gt;DateTime's&lt;/code&gt; в разных &lt;code&gt;TimeZone's&lt;/code&gt; . &lt;code&gt;a + between(a, b) == b&lt;/code&gt; гарантируется только тогда, когда &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; находятся в UTC.</target>
        </trans-unit>
        <trans-unit id="d0a52c8fdc83d67244f36d1e45904b31b08be93b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since version 0.10.2 this module is deprecated. Use the &lt;a href=&quot;net&quot;&gt;net&lt;/a&gt; or the &lt;a href=&quot;nativesockets&quot;&gt;nativesockets&lt;/a&gt; module instead.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; Начиная с версии 0.10.2 этот модуль устарел. Используйте &lt;a href=&quot;net&quot;&gt;сеть&lt;/a&gt; или &lt;a href=&quot;nativesockets&quot;&gt;nativesockets&lt;/a&gt; модуль вместо этого.</target>
        </trans-unit>
        <trans-unit id="9968b14e6044d19bea13d96a6048dbd5746bc726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The &lt;code&gt;total&lt;/code&gt; reported by httpclient may be 0 in some cases.</source>
          <target state="translated">&lt;strong&gt;Предупреждение: &lt;/strong&gt; &lt;code&gt;total&lt;/code&gt; сообщил HttpClient может быть в некоторых случаях 0.</target>
        </trans-unit>
        <trans-unit id="24b0c00e568f6b8e8da0f3bc2db0c76c857a200b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The API of this module is unstable, and therefore is subject to change.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; API этого модуля нестабилен и поэтому может быть изменен.</target>
        </trans-unit>
        <trans-unit id="9d0af0517916216290aedd9e00253fb0aa629d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The buffer &lt;em&gt;a&lt;/em&gt; must be pre-allocated. This can be done using, for example, &lt;code&gt;newString&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; буфер &lt;em&gt;a&lt;/em&gt; должен быть выделен заранее. Это можно сделать, например, с помощью &lt;code&gt;newString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0520baa64a72e7ee0281b0ddd067f506549b20a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The global list of handlers is a thread var, this means that the handlers must be re-added in each thread. &lt;strong&gt;Warning:&lt;/strong&gt; When logging on disk or console, only error and fatal messages are flushed out immediately. Use flushFile() where needed.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; глобальный список обработчиков представляет собой переменную потока, это означает, что обработчики должны быть повторно добавлены в каждый поток. &lt;strong&gt;Предупреждение:&lt;/strong&gt; при входе на диск или консоль сразу удаляются только сообщения об ошибках и критические сообщения. При необходимости используйте flushFile ().</target>
        </trans-unit>
        <trans-unit id="1de5e055501cd9543ed70f0688cbf30ac70cdc1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This function does not yet have a buffered implementation, so when &lt;code&gt;socket&lt;/code&gt; is buffered the non-buffered implementation will be used. Therefore if &lt;code&gt;socket&lt;/code&gt; contains something in its buffer this function will make no effort to return it.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; эта функция еще не имеет буферизованной реализации, поэтому при буферизации &lt;code&gt;socket&lt;/code&gt; будет использоваться небуферизованная реализация. Следовательно, если &lt;code&gt;socket&lt;/code&gt; содержит что-то в своем буфере, эта функция не будет пытаться вернуть это.</target>
        </trans-unit>
        <trans-unit id="854f87e513637b6e9a5ac650c51cff41b8f768e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated since version 0.10.2. Use the brand new &lt;a href=&quot;asyncdispatch&quot;&gt;asyncdispatch&lt;/a&gt; module together with the &lt;a href=&quot;asyncnet&quot;&gt;asyncnet&lt;/a&gt; module.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; этот модуль устарел, начиная с версии 0.10.2. Используйте новый модуль &lt;a href=&quot;asyncdispatch&quot;&gt;asyncdispatch&lt;/a&gt; вместе с модулем &lt;a href=&quot;asyncnet&quot;&gt;asyncnet&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0b3c2a66d1cb7f1d4a063b94c4ce6ca1f2543b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated since version 0.14.0.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; этот модуль устарел, начиная с версии 0.14.0.</target>
        </trans-unit>
        <trans-unit id="7eb0dfd155d4b6f3b53e214b0ecc3fdf13f08633" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module is deprecated, use the SSL procedures defined in the &lt;code&gt;net&lt;/code&gt; module instead.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; этот модуль устарел, используйте вместо него процедуры SSL, определенные в &lt;code&gt;net&lt;/code&gt; модуле.</target>
        </trans-unit>
        <trans-unit id="5c5666a07ce3875934c4c4fc973b2a781936f5f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; This module only supports the old asynchronous interface. You may wish to use the &lt;a href=&quot;asynchttpserver&quot;&gt;asynchttpserver&lt;/a&gt; instead for web applications.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; этот модуль поддерживает только старый асинхронный интерфейс. Вы можете вместо этого использовать &lt;a href=&quot;asynchttpserver&quot;&gt;asynchttpserver&lt;/a&gt; для веб-приложений.</target>
        </trans-unit>
        <trans-unit id="53266ecbd11ce935a7868dc21f59beb46ccb3aaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When using SSL with non-blocking sockets, it is best to use the acceptAddrSSL procedure as this procedure will most likely block.</source>
          <target state="translated">&lt;strong&gt;Предупреждение:&lt;/strong&gt; при использовании SSL с неблокирующими сокетами лучше всего использовать процедуру acceptAddrSSL, поскольку эта процедура, скорее всего, будет блокировать.</target>
        </trans-unit>
        <trans-unit id="808a8a1028dc1fed134e205c55ec27d7dd5b23fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;recvLine&lt;/code&gt; on unbuffered sockets assumes that the protocol uses &lt;code&gt;\r\L&lt;/code&gt; to delimit a new line.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : &lt;code&gt;recvLine&lt;/code&gt; на небуферизованных сокетах предполагает, что протокол использует &lt;code&gt;\r\L&lt;/code&gt; для разделения новой строки.</target>
        </trans-unit>
        <trans-unit id="ac11ca7b54f8ac76331d539b39687d412032a370" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;recvLineInto&lt;/code&gt; on unbuffered sockets assumes that the protocol uses &lt;code&gt;\r\L&lt;/code&gt; to delimit a new line.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : &lt;code&gt;recvLineInto&lt;/code&gt; на небуферизованных сокетах предполагает, что протокол использует &lt;code&gt;\r\L&lt;/code&gt; для разделения новой строки.</target>
        </trans-unit>
        <trans-unit id="5d163b20a95cadf02bed8abe7ed680f87b2b48bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Be careful when using waitForExit for processes created without poParentStreams because they may fill output buffers, causing deadlock.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : будьте осторожны при использовании waitForExit для процессов, созданных без poParentStreams, потому что они могут заполнять выходные буферы, вызывая взаимоблокировку.</target>
        </trans-unit>
        <trans-unit id="0163b79bd484845ef77cdbb23264a20232b50266" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: If &lt;code&gt;state&lt;/code&gt; is set incorrectly the resulting &lt;code&gt;AsyncSocket&lt;/code&gt; object may not work properly.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : Если &lt;code&gt;state&lt;/code&gt; установлено неправильно, результирующий объект &lt;code&gt;AsyncSocket&lt;/code&gt; может работать некорректно.</target>
        </trans-unit>
        <trans-unit id="6f6766ee200b64744878c681dde8b968c6f670b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Only the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is currently supported.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : в настоящее время поддерживается только флаг &lt;code&gt;SafeDisconn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5179a287236e2707d51c8ae92986184ef63e00df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Only use this if you know what you are doing.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : используйте это, только если знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="b8ef80f1f143a1f7de2004bb4e9cee1fed78e787" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some OS's (such as Microsoft Windows) restrict the creation of symlinks to root users (administrators).</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : Некоторые ОС (например, Microsoft Windows) ограничивают создание символических ссылок корневыми пользователями (администраторами).</target>
        </trans-unit>
        <trans-unit id="1f61c1a4fea430f13537ed29d0765d587962a8f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Some OS's restrict the creation of hard links to root users (administrators).</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : некоторые ОС ограничивают создание жестких ссылок для пользователей root (администраторов).</target>
        </trans-unit>
        <trans-unit id="f9012f1b5937f6027293c08f92583d61921af08c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;Peek&lt;/code&gt; flag is not yet implemented.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : флаг &lt;code&gt;Peek&lt;/code&gt; еще не реализован.</target>
        </trans-unit>
        <trans-unit id="e86c259d83ff7290e4d751971a6fa6a8870f2e71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;code&gt;Peek&lt;/code&gt; socket flag is not supported on Windows.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; . Флаг сокета &lt;code&gt;Peek&lt;/code&gt; не поддерживается в Windows.</target>
        </trans-unit>
        <trans-unit id="67b4583abc34f87fcf6eff4869eef2bfd28629d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The &lt;em&gt;tmpl&lt;/em&gt; argument is written to by &lt;em&gt;mkstemp&lt;/em&gt; and thus can't be a string literal. If in doubt copy the string before passing it.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : аргумент &lt;em&gt;tmpl&lt;/em&gt; записывается &lt;em&gt;mkstemp&lt;/em&gt; и поэтому не может быть строковым литералом. В случае сомнений скопируйте строку перед ее передачей.</target>
        </trans-unit>
        <trans-unit id="eae8834fd1ff75f9c078051184e01727261e31cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The resulting &lt;code&gt;ptr AddrInfo&lt;/code&gt; must be freed using &lt;code&gt;freeAddrInfo&lt;/code&gt;!</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : полученный &lt;code&gt;ptr AddrInfo&lt;/code&gt; должен быть освобожден с помощью &lt;code&gt;freeAddrInfo&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="9e788c203930a853b492baa9fb790e0baaa6f689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The returned &lt;em&gt;FileHandle&lt;/em&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : возвращенный &lt;em&gt;FileHandle&lt;/em&gt; не следует закрывать вручную, так как он закрывается при закрытии процесса &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35816baa23c24b5f9e80530b286a99de07763458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The returned &lt;em&gt;Stream&lt;/em&gt; should not be closed manually as it is closed when closing the Process &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : возвращенный &lt;em&gt;поток&lt;/em&gt; не следует закрывать вручную, так как он закрывается при закрытии процесса &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="070d8f77f83eff23785cd22229e7c7593a9f015a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This assumes that lines are delimited by &lt;code&gt;\r\L&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Внимание&lt;/strong&gt; : При этом предполагается , что строки разделяются &lt;code&gt;\r\L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9df6a23fa581b51ba2e0e996ce854f48568ec52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This function may give unexpected or completely wrong results on Windows.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : эта функция может давать неожиданные или совершенно неверные результаты в Windows.</target>
        </trans-unit>
        <trans-unit id="016fcff66b49f260c1c428fc4a770e9ba587d905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This module uses &lt;code&gt;immediate&lt;/code&gt; macros which are known to cause problems. Do yourself a favor and import the module as &lt;code&gt;from htmlgen import nil&lt;/code&gt; and then fully qualify the macros.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : этот модуль использует &lt;code&gt;immediate&lt;/code&gt; макросы, которые, как известно, вызывают проблемы. Сделайте себе одолжение и импортируйте модуль &lt;code&gt;from htmlgen import nil&lt;/code&gt; а затем полностью определите макросы.</target>
        </trans-unit>
        <trans-unit id="1ee8bac63489b4b65f1d77d36e0156115bbf2067" translate="yes" xml:space="preserve">
          <source>A &quot;word&quot; character is an underscore or any character less than 256 that is a letter or digit. The definition of letters and digits is controlled by PCRE's low-valued character tables, and may vary if locale-specific matching is taking place (see &quot;Locale support&quot; in the pcreapi page). For example, in the &quot;fr_FR&quot; (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by &lt;code&gt;\w&lt;/code&gt;.</source>
          <target state="translated">Символ &amp;laquo;слово&amp;raquo; - это подчеркивание или любой символ меньше 256, который является буквой или цифрой. Определение букв и цифр контролируется таблицами низкозначных символов PCRE и может варьироваться, если имеет место соответствие для конкретного языкового стандарта (см. &amp;laquo;Поддержка языкового стандарта&amp;raquo; на странице pcreapi). Например, в языковом стандарте &quot;fr_FR&quot; (французский) некоторые коды символов больше 128 используются для букв с диакритическими знаками, и им соответствует &lt;code&gt;\w&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaba2403682a17469ecab3c6f2cc502e7be26d2b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HttpRequestError&lt;/code&gt; will be raised if the server responds with a client error (status code 4xx) or a server error (status code 5xx).</source>
          <target state="translated">Ошибка &lt;code&gt;HttpRequestError&lt;/code&gt; возникает, если сервер отвечает ошибкой клиента (код состояния 4xx) или ошибкой сервера (код состояния 5xx).</target>
        </trans-unit>
        <trans-unit id="d81d68641d8bf3ceba1aef0cf067b5ab815956a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ValueError&lt;/code&gt; exception will be raised if the value is not an integer.</source>
          <target state="translated">&lt;code&gt;ValueError&lt;/code&gt; исключение будет повышена , если значение не является целым числом.</target>
        </trans-unit>
        <trans-unit id="49a6495aba25fcc0345009a64738a98f0c760abf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;block&lt;/code&gt; doesn't need an name, in which case &lt;code&gt;nnkEmpty&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;block&lt;/code&gt; не нужно имя, в этом случае &lt;code&gt;nnkEmpty&lt;/code&gt; используется.</target>
        </trans-unit>
        <trans-unit id="bde4d27b77941b8a2e8d7b668c0d8b482525e40c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;closure&lt;/code&gt; proc var can call ordinary procs of the default Nim calling convention. But not the other way round! A closure is implemented as a &lt;code&gt;tuple[prc, env]&lt;/code&gt;. &lt;code&gt;env&lt;/code&gt; can be nil implying a call without a closure. This means that a call through a closure generates an &lt;code&gt;if&lt;/code&gt; but the interoperability is worth the cost of the &lt;code&gt;if&lt;/code&gt;. Thunk generation would be possible too, but it's slightly more effort to implement.</source>
          <target state="translated">&lt;code&gt;closure&lt;/code&gt; прок вар может назвать обычные проки ЧПМ вызовов по умолчанию. Но не наоборот! Замыкание реализовано как &lt;code&gt;tuple[prc, env]&lt;/code&gt; . &lt;code&gt;env&lt;/code&gt; может иметь значение nil, что означает вызов без закрытия. Это означает, что вызов через закрытие генерирует &lt;code&gt;if&lt;/code&gt; , но функциональная совместимость стоит затрат &lt;code&gt;if&lt;/code&gt; . Генерация преобразователей тоже возможна, но это требует немного больше усилий для реализации.</target>
        </trans-unit>
        <trans-unit id="46ca6bf4504c12b38f73b70158bd4cc5686ceec6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;continue&lt;/code&gt; statement leads to the immediate next iteration of the surrounding loop construct. It is only allowed within a loop. A continue statement is syntactic sugar for a nested block:</source>
          <target state="translated">&lt;code&gt;continue&lt;/code&gt; выписки приводят к немедленной следующей итерации окружающей конструкции петли. Это разрешено только в пределах цикла. Оператор continue - это синтаксический сахар для вложенного блока:</target>
        </trans-unit>
        <trans-unit id="fa532fc8ce7dbe2864f24cd2a27ac73e6fc36afd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;distinct&lt;/code&gt; type is new type derived from a &lt;span id=&quot;base-type_1&quot;&gt;base type&lt;/span&gt; that is incompatible with its base type. In particular, it is an essential property of a distinct type that it &lt;strong&gt;does not&lt;/strong&gt; imply a subtype relation between it and its base type. Explicit type conversions from a distinct type to its base type and vice versa are allowed. See also &lt;code&gt;distinctBase&lt;/code&gt; to get the reverse operation.</source>
          <target state="translated">&lt;code&gt;distinct&lt;/code&gt; тип новый тип , полученный из &lt;span id=&quot;base-type_1&quot;&gt;базового типа&lt;/span&gt; , который несовместим с базовым типом. В частности, существенным свойством отдельного типа является то, что он &lt;strong&gt;не&lt;/strong&gt; подразумевает отношения подтипа между ним и его базовым типом. Разрешены явные преобразования типов из отдельного типа в его базовый и наоборот. См. Также &lt;code&gt;distinctBase&lt;/code&gt; чтобы получить обратную операцию.</target>
        </trans-unit>
        <trans-unit id="fec0b8e4f99548ff52eae3d0e8ec4be16fcde6a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;let&lt;/code&gt; statement declares new local and global &lt;span id=&quot;single-assignment_1&quot;&gt;single assignment&lt;/span&gt; variables and binds a value to them. The syntax is the same as that of the &lt;code&gt;var&lt;/code&gt; statement, except that the keyword &lt;code&gt;var&lt;/code&gt; is replaced by the keyword &lt;code&gt;let&lt;/code&gt;. Let variables are not l-values and can thus not be passed to &lt;code&gt;var&lt;/code&gt; parameters nor can their address be taken. They cannot be assigned new values.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; оператор объявляет новые локальные и глобальные &lt;span id=&quot;single-assignment_1&quot;&gt;одно назначение&lt;/span&gt; переменных и связывает значение для них. Синтаксис такой же, как у оператора &lt;code&gt;var&lt;/code&gt; , за исключением того, что ключевое слово &lt;code&gt;var&lt;/code&gt; заменено ключевым словом &lt;code&gt;let&lt;/code&gt; . Пусть переменные не являются l-значениями и, следовательно, не могут быть переданы в параметры &lt;code&gt;var&lt;/code&gt; и не могут быть взяты их адреса. Им нельзя присвоить новые значения.</target>
        </trans-unit>
        <trans-unit id="8fe78b3a2821fa1451c04e1ee9b03eb161700c9d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;raises&lt;/code&gt; list can also be attached to a proc type. This affects type compatibility:</source>
          <target state="translated">&lt;code&gt;raises&lt;/code&gt; список также может быть присоединен к типу Proc. Это влияет на совместимость типов:</target>
        </trans-unit>
        <trans-unit id="c8cb08453579d0f15d45b19ab781ad1eab51f587" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;varargs&lt;/code&gt; parameter is an openarray parameter that additionally allows to pass a variable number of arguments to a procedure. The compiler converts the list of arguments to an array implicitly:</source>
          <target state="translated">&lt;code&gt;varargs&lt;/code&gt; параметр представляет собой параметр , который openarray дополнительно позволяет передать переменное количество аргументов в процедуру. Компилятор неявно преобразует список аргументов в массив:</target>
        </trans-unit>
        <trans-unit id="9932ed67f0c5e1f713b0339fd155b7567d8b4c9b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;varargs&lt;/code&gt; parameter is like an openarray parameter. However, it is also a means to implement passing a variable number of arguments to a procedure. The compiler converts the list of arguments to an array automatically:</source>
          <target state="translated">&lt;code&gt;varargs&lt;/code&gt; параметр как параметр openarray. Однако это также средство для реализации передачи переменной количества аргументов в процедуру. Компилятор автоматически преобразует список аргументов в массив:</target>
        </trans-unit>
        <trans-unit id="e982b06375e4d6cb9864cbab229ee93da8102df8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;$&lt;/em&gt; proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt; Прок определяется для cstrings , которая возвращает строку. Таким образом, чтобы получить строку нима из cstring:</target>
        </trans-unit>
        <trans-unit id="4924981c6cf86467817a6848ae253feb1dd3d357" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Source Code Filter&lt;/em&gt; transforms the input character stream to an in-memory output stream before parsing. A filter can be used to provide templating systems or preprocessors.</source>
          <target state="translated">&lt;em&gt;Исходный код фильтр&lt;/em&gt; преобразует входной поток символов в выходном поток в памяти перед анализом. Фильтр можно использовать для создания систем шаблонов или препроцессоров.</target>
        </trans-unit>
        <trans-unit id="787f1149d9267dbcf887509536779010033aad01" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;subex&lt;/em&gt; (&lt;em&gt;Substitution Expression&lt;/em&gt;) represents an advanced string substitution. In contrast to a &lt;span id=&quot;regex_1&quot;&gt;regex&lt;/span&gt; which deals with string analysis, a &lt;em&gt;subex&lt;/em&gt; deals with string synthesis.</source>
          <target state="translated">&lt;em&gt;Subex&lt;/em&gt; ( &lt;em&gt;Замена Выражение&lt;/em&gt; ) представляет собой расширенную строку замещение. В отличие от &lt;span id=&quot;regex_1&quot;&gt;регулярного выражения,&lt;/span&gt; которое занимается анализом строк, &lt;em&gt;подвыражение&lt;/em&gt; занимается синтезом строк.</target>
        </trans-unit>
        <trans-unit id="889eb097f34d2cb2326af79e37dd19352cd4b767" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;checked-runtime-error_1&quot;&gt;checked runtime error&lt;/span&gt; is an error that the implementation detects and reports at runtime. The method for reporting such errors is via &lt;em&gt;raising exceptions&lt;/em&gt; or &lt;em&gt;dying with a fatal error&lt;/em&gt;. However, the implementation provides a means to disable these runtime checks. See the section &lt;a href=&quot;#pragmas&quot;&gt;pragmas&lt;/a&gt; for details.</source>
          <target state="translated">&lt;span id=&quot;checked-runtime-error_1&quot;&gt;Проверяется во время выполнения ошибки&lt;/span&gt; является ошибкой , что детектирует реализацию и отчеты во время выполнения. Метод сообщения о таких ошибках - &lt;em&gt;создание &lt;/em&gt;&lt;em&gt;исключений&lt;/em&gt; или &lt;em&gt;смерть с фатальной ошибкой&lt;/em&gt; . Однако реализация предоставляет средства для отключения этих проверок во время выполнения. См. Подробности в разделе &lt;a href=&quot;#pragmas&quot;&gt;прагмы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31c99118ea561948c45f870ebd2c2cce4b7b646d" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;guard_1&quot;&gt;guard&lt;/span&gt; annotation is introduced to prevent data races.</source>
          <target state="translated">&lt;span id=&quot;guard_1&quot;&gt;Охранник&lt;/span&gt; аннотацию вводится для предотвращения гонки данных.</target>
        </trans-unit>
        <trans-unit id="386e659d1429b589f185720a9d5bf0ba95205db0" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;narrowing-type-conversion_1&quot;&gt;narrowing type conversion&lt;/span&gt; converts a larger to a smaller type (for example &lt;code&gt;int32 -&amp;gt; int16&lt;/code&gt;. A &lt;span id=&quot;widening-type-conversion_1&quot;&gt;widening type conversion&lt;/span&gt; converts a smaller type to a larger type (for example &lt;code&gt;int16 -&amp;gt; int32&lt;/code&gt;). In Nim only widening type conversions are &lt;em&gt;implicit&lt;/em&gt;:</source>
          <target state="translated">&lt;span id=&quot;narrowing-type-conversion_1&quot;&gt;Преобразование типа Сужения&lt;/span&gt; преобразует большее к меньшему типу (например , &lt;code&gt;int32 -&amp;gt; int16&lt;/code&gt; а. &lt;span id=&quot;widening-type-conversion_1&quot;&gt;Расширяющее преобразование типа&lt;/span&gt; обращенных меньший типа к большему типа (например &lt;code&gt;int16 -&amp;gt; int32&lt;/code&gt; ) преобразование только расширение типа В Nim есть. &lt;em&gt;Неявное&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="387048b351545e7cdb57e945c46d2fba04806529" translate="yes" xml:space="preserve">
          <source>A &lt;span id=&quot;static-error_1&quot;&gt;static error&lt;/span&gt; is an error that the implementation detects before program execution. Unless explicitly classified, an error is a static error.</source>
          <target state="translated">&lt;span id=&quot;static-error_1&quot;&gt;Статическая ошибка&lt;/span&gt; является ошибкой , что реализация обнаруживает перед выполнением программы. Если это не классифицировано явно, ошибка является статической.</target>
        </trans-unit>
        <trans-unit id="130e98a36d1ad0d5fa779c624d02b3795704ff33" translate="yes" xml:space="preserve">
          <source>A Distinct type allows for the creation of new type that &quot;does not imply a subtype relationship between it and its base type&quot;. You must &lt;strong&gt;explicitly&lt;/strong&gt; define all behaviour for the distinct type. To help with this, both the distinct type and its base type can cast from one type to the other. Examples are provided in the &lt;a href=&quot;manual#types-distinct-type&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Тип Distinct позволяет создавать новый тип, который &amp;laquo;не подразумевает отношения подтипа между ним и его базовым типом&amp;raquo;. Вы должны &lt;strong&gt;явно&lt;/strong&gt; определить все поведение для отдельного типа. Чтобы помочь с этим, как отдельный тип, так и его базовый тип могут приводиться от одного типа к другому. Примеры приведены в &lt;a href=&quot;manual#types-distinct-type&quot;&gt;руководстве&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79b065193cd9e9953658e8235e333843b91d5cf1" translate="yes" xml:space="preserve">
          <source>A Nim &lt;code&gt;string&lt;/code&gt; is implicitly convertible to &lt;code&gt;cstring&lt;/code&gt; for convenience. If a Nim string is passed to a C-style variadic proc, it is implicitly converted to &lt;code&gt;cstring&lt;/code&gt; too:</source>
          <target state="translated">Nim &lt;code&gt;string&lt;/code&gt; неявно конвертируются в &lt;code&gt;cstring&lt;/code&gt; для удобства. Если строка Nim передается вариативной процедуре C-стиля, она также неявно конвертируется в &lt;code&gt;cstring&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="69460fedc7d49aa8bfd391ea3c8be3ae26318394" translate="yes" xml:space="preserve">
          <source>A Nim procedure is asynchronous when it includes the &lt;code&gt;{.async.}&lt;/code&gt; pragma. It should always have a &lt;code&gt;Future[T]&lt;/code&gt; return type or not have a return type at all. A &lt;code&gt;Future[void]&lt;/code&gt; return type is assumed by default.</source>
          <target state="translated">Процедура Nim является асинхронной, если включает прагму &lt;code&gt;{.async.}&lt;/code&gt; . Он всегда должен иметь возвращаемый тип &lt;code&gt;Future[T]&lt;/code&gt; или вообще не иметь возвращаемого типа. По умолчанию предполагается возвращаемый тип &lt;code&gt;Future[void]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd52730a119bb22be3969f6811e2133725811be" translate="yes" xml:space="preserve">
          <source>A Nim program specifies a computation that acts on a memory consisting of components called &lt;span id=&quot;locations_1&quot;&gt;locations&lt;/span&gt;. A variable is basically a name for a location. Each variable and location is of a certain &lt;span id=&quot;type_1&quot;&gt;type&lt;/span&gt;. The variable's type is called &lt;span id=&quot;static-type_1&quot;&gt;static type&lt;/span&gt;, the location's type is called &lt;span id=&quot;dynamic-type_1&quot;&gt;dynamic type&lt;/span&gt;. If the static type is not the same as the dynamic type, it is a super-type or subtype of the dynamic type.</source>
          <target state="translated">Программа Nim определяет вычисление, которое воздействует на память, состоящую из компонентов, называемых &lt;span id=&quot;locations_1&quot;&gt;местоположениями&lt;/span&gt; . Переменная - это, по сути, имя места. Каждая переменная и местоположение относятся к определенному &lt;span id=&quot;type_1&quot;&gt;типу&lt;/span&gt; . Тип переменной называется &lt;span id=&quot;static-type_1&quot;&gt;статическим типом&lt;/span&gt; , &lt;span id=&quot;static-type_1&quot;&gt;тип&lt;/span&gt; местоположения - &lt;span id=&quot;dynamic-type_1&quot;&gt;динамическим типом&lt;/span&gt; . Если статический тип не совпадает с динамическим типом, это супертип или подтип динамического типа.</target>
        </trans-unit>
        <trans-unit id="4d649a9b73eb1b75df006205a78131f546ab13c9" translate="yes" xml:space="preserve">
          <source>A PEG (Parsing expression grammar) is a simple deterministic grammar, that can be directly used for parsing. The current implementation has been designed as a more powerful replacement for regular expressions. UTF-8 is supported.</source>
          <target state="translated">PEG (грамматика выражения парсинга)-это простая детерминистическая грамматика,которая может быть непосредственно использована для парсинга.Текущая реализация была разработана как более мощная замена регулярным выражениям.Поддерживается UTF-8.</target>
        </trans-unit>
        <trans-unit id="33b07af826ffc1642e9db6c9aa9ff6e43b9cc68a" translate="yes" xml:space="preserve">
          <source>A application-level error condition. For example, some user input generated an exception. The application will continue to run, but functionality or data was impacted, possibly visible to users.</source>
          <target state="translated">Состояние ошибки на уровне приложения.Например,некоторый пользовательский ввод сгенерировал исключение.Приложение будет продолжать работать,но на его функциональность или данные было оказано влияние,возможно,видимое для пользователей.</target>
        </trans-unit>
        <trans-unit id="5d9beef18f6feec8ed926e501f6bc8ef50b29384" translate="yes" xml:space="preserve">
          <source>A application-level fatal condition. FATAL usually means that the application cannot go on and will exit (but this logging event will not do that for you).</source>
          <target state="translated">Смертельное состояние на уровне приложения.Фатальное состояние обычно означает,что приложение не может продолжить работу и выйдет из него (но это событие протоколирования не сделает этого за вас).</target>
        </trans-unit>
        <trans-unit id="0bc66569c7f749a991c86255655ab99ac30e86d5" translate="yes" xml:space="preserve">
          <source>A backslash followed by a letter is a built-in macro, otherwise it is used for ordinary escaping:</source>
          <target state="translated">Обратный слеш,за которым следует буква,-это встроенный макрос,в противном случае он используется для обычного побега:</target>
        </trans-unit>
        <trans-unit id="519b373c181ee8d4be473dddf120c85a8c41428c" translate="yes" xml:space="preserve">
          <source>A block can be left prematurely with a &lt;code&gt;break&lt;/code&gt; statement. The break statement can leave a &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, or a &lt;code&gt;block&lt;/code&gt; statement. It leaves the innermost construct, unless a label of a block is given:</source>
          <target state="translated">Блок можно преждевременно покинуть с помощью оператора &lt;code&gt;break&lt;/code&gt; . Оператор break может оставить оператор &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; или &lt;code&gt;block&lt;/code&gt; . Он оставляет самую внутреннюю конструкцию, если не задана метка блока:</target>
        </trans-unit>
        <trans-unit id="8018e99c199800e7c1d485e8e8e1d2de44558695" translate="yes" xml:space="preserve">
          <source>A call to an asynchronous procedure usually needs &lt;code&gt;await&lt;/code&gt; to wait for the completion of the &lt;code&gt;Future&lt;/code&gt;.</source>
          <target state="translated">Для вызова асинхронной процедуры обычно требуется &lt;code&gt;await&lt;/code&gt; , чтобы дождаться завершения &lt;code&gt;Future&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bd1dcf8b598ce13fe780f11e538b4c3679116e3" translate="yes" xml:space="preserve">
          <source>A character is not an Unicode character but a single byte. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can thus support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">Символ - это не символ Юникода, а один байт. Причина этого - эффективность: в подавляющем большинстве случаев использования результирующие программы по-прежнему будут правильно обрабатывать UTF-8, поскольку UTF-8 был специально разработан для этого. Другая причина в том, что Nim может эффективно поддерживать &lt;code&gt;array[char, int]&lt;/code&gt; или &lt;code&gt;set[char]&lt;/code&gt; поскольку многие алгоритмы полагаются на эту функцию. Тип &lt;em&gt;Rune&lt;/em&gt; используется для символов Unicode, он может представлять любой символ Unicode. &lt;code&gt;Rune&lt;/code&gt; объявлена ​​в &lt;a href=&quot;unicode&quot;&gt;модуле юникода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27a21ba557cb1102184eb887daf5fb2f0ee516b2" translate="yes" xml:space="preserve">
          <source>A compile-time error will be produced if the supplied type is not generic.</source>
          <target state="translated">Ошибка компиляции будет вызвана,если поставляемый тип не является общим.</target>
        </trans-unit>
        <trans-unit id="9e63142b740226a78a46d8a1af8bf22743ac95c8" translate="yes" xml:space="preserve">
          <source>A config file was loaded.</source>
          <target state="translated">Был загружен конфигурационный файл.</target>
        </trans-unit>
        <trans-unit id="9d676346fde6cb6856b2edfe8fcc862ca9818983" translate="yes" xml:space="preserve">
          <source>A contains element e</source>
          <target state="translated">А содержит элемент д</target>
        </trans-unit>
        <trans-unit id="cd669926d307684088d5ef478be7b22480b9a5f4" translate="yes" xml:space="preserve">
          <source>A convenience procedure that executes &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;startProcess&lt;/code&gt; and returns its output as a string. WARNING: this function uses poEvalCommand by default for backward compatibility. Make sure to pass options explicitly.</source>
          <target state="translated">Удобная процедура, которая выполняет &lt;code&gt;command&lt;/code&gt; с помощью &lt;code&gt;startProcess&lt;/code&gt; и возвращает результат в виде строки. ВНИМАНИЕ: эта функция по умолчанию использует poEvalCommand для обратной совместимости. Убедитесь, что параметры передаются явно.</target>
        </trans-unit>
        <trans-unit id="d5eda57047be93a6d8ede446c939b622a61fcad5" translate="yes" xml:space="preserve">
          <source>A convention is that exceptions should be raised in &lt;em&gt;exceptional&lt;/em&gt; cases: For example, if a file cannot be opened, this should not raise an exception since this is quite common (the file may not exist).</source>
          <target state="translated">По соглашению исключения должны создаваться в &lt;em&gt;исключительных&lt;/em&gt; случаях: например, если файл не может быть открыт, это не должно вызывать исключения, поскольку это довольно часто (файл может не существовать).</target>
        </trans-unit>
        <trans-unit id="9dc4e7e8a36779be1253db430e17a3ece42f97f6" translate="yes" xml:space="preserve">
          <source>A converter can also be explicitly invoked for improved readability. Note that implicit converter chaining is not supported: If there is a converter from type A to type B and from type B to type C the implicit conversion from A to C is not provided.</source>
          <target state="translated">Конвертер также может быть явно вызван для улучшения читабельности.Обратите внимание,что неявное преобразование цепей не поддерживается:При наличии конвертера от типа A к типу B и от типа B к типу C неявное приведение от A к C не поддерживается.</target>
        </trans-unit>
        <trans-unit id="0fabf98da32833f2ac2d72c57027f686f2dbd28b" translate="yes" xml:space="preserve">
          <source>A converter is like an ordinary proc except that it enhances the &quot;implicitly convertible&quot; type relation (see &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt;):</source>
          <target state="translated">Конвертер похож на обычный процесс, за исключением того, что он усиливает отношение типа &quot;неявно конвертируемое&quot; (см. &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Отношение &quot;Конвертируемое&quot;&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="ff0115af818672bc6f62e11d492d4642e32f4663" translate="yes" xml:space="preserve">
          <source>A converter is similar to a proc.</source>
          <target state="translated">Конвертер похож на тянучку.</target>
        </trans-unit>
        <trans-unit id="95b68e940e0a6eefa4655d5db413050f4aee06c6" translate="yes" xml:space="preserve">
          <source>A curly expression with commas in it like &lt;code&gt;{x, argA, argB}&lt;/code&gt; could be transformed to &lt;code&gt;format(x, argA, argB, res)&lt;/code&gt; in order to support formatters that do not need to parse a custom language within a custom language but instead prefer to use Nim's existing syntax. This also helps in readability since there is only so much you can cram into single letter DSLs.</source>
          <target state="translated">Фигурное выражение с запятыми в нем, например &lt;code&gt;{x, argA, argB}&lt;/code&gt; может быть преобразовано в &lt;code&gt;format(x, argA, argB, res)&lt;/code&gt; для поддержки средств форматирования, которым не нужно анализировать настраиваемый язык внутри настраиваемого языка, но вместо этого предпочитают использовать существующий синтаксис Нима. Это также помогает в удобочитаемости, поскольку в однобуквенные DSL можно втиснуть очень много текста.</target>
        </trans-unit>
        <trans-unit id="af339bf252ebc6686a22fa957452c6666fabae1d" translate="yes" xml:space="preserve">
          <source>A destructible context is currently only the following:</source>
          <target state="translated">В настоящее время разрушаемый контекст-это только следующее:</target>
        </trans-unit>
        <trans-unit id="a4828b4e1e76af08cdc61d3da41001844c8e7647" translate="yes" xml:space="preserve">
          <source>A destructor is attached to the type it destructs; expressions of this type can then only be used in &lt;em&gt;destructible contexts&lt;/em&gt; and as parameters:</source>
          <target state="translated">Деструктор привязан к типу, который он разрушает; выражения этого типа могут тогда использоваться только в &lt;em&gt;разрушаемых контекстах&lt;/em&gt; и как параметры:</target>
        </trans-unit>
        <trans-unit id="5433f8711be01e7d00dc897cddea4967983783a7" translate="yes" xml:space="preserve">
          <source>A destructor must have a single parameter with a concrete type (the name of a generic type is allowed too). The name of the destructor has to be &lt;code&gt;=destroy&lt;/code&gt;.</source>
          <target state="translated">Деструктор должен иметь единственный параметр с конкретным типом (также допускается имя универсального типа). Имя деструктора должно быть &lt;code&gt;=destroy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b51be317d37d0d9e5679921ffa2c4f39470a9227" translate="yes" xml:space="preserve">
          <source>A directory can also be a so called &quot;pseudo directory&quot;. They can be used to avoid ambiguity when there are multiple modules with the same path.</source>
          <target state="translated">Каталог также может быть так называемым &quot;псевдо-каталогом&quot;.Их можно использовать,чтобы избежать двусмысленности при наличии нескольких модулей с одним и тем же путем.</target>
        </trans-unit>
        <trans-unit id="2010acb176bc59e66e9596fccd16c6be234aa62b" translate="yes" xml:space="preserve">
          <source>A distinct type can be used to model different physical &lt;span id=&quot;units_1&quot;&gt;units&lt;/span&gt; with a numerical base type, for example. The following example models currencies.</source>
          <target state="translated">Отдельный тип можно использовать, например, для моделирования различных физических &lt;span id=&quot;units_1&quot;&gt;единиц&lt;/span&gt; с помощью числового базового типа. В следующем примере моделируются валюты.</target>
        </trans-unit>
        <trans-unit id="0dcbf503ecd251b550b20573f306de222e9f6e39" translate="yes" xml:space="preserve">
          <source>A does not contain element e</source>
          <target state="translated">A не содержит элемента e</target>
        </trans-unit>
        <trans-unit id="7339291827f4b694e439170ba77d07b22a6ba2d9" translate="yes" xml:space="preserve">
          <source>A dot following the hash &lt;code&gt;#.&lt;/code&gt; indicates that the call should use C++'s dot or arrow notation.</source>
          <target state="translated">Точка после решетки &lt;code&gt;#.&lt;/code&gt; указывает, что при вызове следует использовать нотацию точки или стрелки C ++.</target>
        </trans-unit>
        <trans-unit id="91daa2e8d1d787e2cb1cebec501d70a447fbdd47" translate="yes" xml:space="preserve">
          <source>A double quotation mark preceded by a backslash (&quot;) is interpreted as a literal double quotation mark character (&quot;).</source>
          <target state="translated">Знак двойной кавычки,которому предшествует обратный слеш (&quot;),интерпретируется как буквальный знак двойной кавычки (&quot;).</target>
        </trans-unit>
        <trans-unit id="5b983689cc856655c0945357d3fc5752f335fd52" translate="yes" xml:space="preserve">
          <source>A double-ended queue backed with a ringed seq buffer.</source>
          <target state="translated">Двухсторонняя очередь с кольцевым буфером seq.</target>
        </trans-unit>
        <trans-unit id="01ed7c56b187204e313f1f9d97ebfebcc0fecee3" translate="yes" xml:space="preserve">
          <source>A for loop variable.</source>
          <target state="translated">A для переменной цикла.</target>
        </trans-unit>
        <trans-unit id="7d654b825945bd5f2a34963e2ce499f362a2a00c" translate="yes" xml:space="preserve">
          <source>A friendlier version of &lt;em&gt;initRational&lt;/em&gt;. Example usage:</source>
          <target state="translated">Более &lt;em&gt;удобная&lt;/em&gt; версия &lt;em&gt;initRational&lt;/em&gt; . Пример использования:</target>
        </trans-unit>
        <trans-unit id="d411518da35d7d553e49043b1323d3beb87db97b" translate="yes" xml:space="preserve">
          <source>A generic hash set that remembers insertion order.</source>
          <target state="translated">Общий набор хэшей,который запоминает порядок вставки.</target>
        </trans-unit>
        <trans-unit id="e82bc7694d12c8d0a1eda93534f23d36363f6058" translate="yes" xml:space="preserve">
          <source>A generic hash set.</source>
          <target state="translated">Общий набор гашиша.</target>
        </trans-unit>
        <trans-unit id="9e98d244bf1a5c7aeeae52fd19acf41b5eb1f418" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;#&lt;/code&gt; symbol is replaced by the first or next argument.</source>
          <target state="translated">Символ решетки &lt;code&gt;#&lt;/code&gt; заменяется первым или следующим аргументом.</target>
        </trans-unit>
        <trans-unit id="a53f6ddc26d79601afed6742fbd39fc945dc2d24" translate="yes" xml:space="preserve">
          <source>A helper for wrapping callback-based functions into promises and async procedures</source>
          <target state="translated">Помощник для упаковки функций обратного вызова в обещания и асинхронные процедуры.</target>
        </trans-unit>
        <trans-unit id="8f2cac0c1f19b93707af84e96c8e8344199be1d8" translate="yes" xml:space="preserve">
          <source>A higher level &lt;em&gt;ODBC&lt;/em&gt; database wrapper.</source>
          <target state="translated">&lt;em&gt;Оболочка&lt;/em&gt; базы данных &lt;em&gt;ODBC&lt;/em&gt; более высокого уровня .</target>
        </trans-unit>
        <trans-unit id="d7086b8bccfe459c43887557d6fccf6aaa7324be" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;mysql_1&quot;&gt;mySQL&lt;/span&gt; database wrapper. The same interface is implemented for other databases too.</source>
          <target state="translated">&lt;span id=&quot;mysql_1&quot;&gt;Оболочка&lt;/span&gt; базы данных &lt;span id=&quot;mysql_1&quot;&gt;mySQL&lt;/span&gt; более высокого уровня . Такой же интерфейс реализован и для других баз данных.</target>
        </trans-unit>
        <trans-unit id="7ed449265b711e313a4301b54cee15ef550acdbf" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;postgresql_1&quot;&gt;PostgreSQL&lt;/span&gt; database wrapper. This interface is implemented for other databases also.</source>
          <target state="translated">&lt;span id=&quot;postgresql_1&quot;&gt;Оболочка&lt;/span&gt; базы данных &lt;span id=&quot;postgresql_1&quot;&gt;PostgreSQL&lt;/span&gt; более высокого уровня . Этот интерфейс реализован и для других баз данных.</target>
        </trans-unit>
        <trans-unit id="18d9c046b2d8f8fc8c6daccb16db460900a01a66" translate="yes" xml:space="preserve">
          <source>A higher level &lt;span id=&quot;sqlite_1&quot;&gt;SQLite&lt;/span&gt; database wrapper. This interface is implemented for other databases too.</source>
          <target state="translated">&lt;span id=&quot;sqlite_1&quot;&gt;Оболочка&lt;/span&gt; базы данных &lt;span id=&quot;sqlite_1&quot;&gt;SQLite&lt;/span&gt; более высокого уровня . Этот интерфейс реализован и для других баз данных.</target>
        </trans-unit>
        <trans-unit id="17cc08bc05f9e3c22bbf4a01b73d4951016af63c" translate="yes" xml:space="preserve">
          <source>A label (used in &lt;code&gt;block&lt;/code&gt; statements).</source>
          <target state="translated">Метка (используется в операторах &lt;code&gt;block&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="89265eb4f02e06930cfb5c35dd5f76b04d9c0a16" translate="yes" xml:space="preserve">
          <source>A last tip when writing a macro: if you are not sure the AST you are building looks ok, you may be tempted to use the &lt;code&gt;dumpTree&lt;/code&gt; macro. But you can't use it &lt;em&gt;inside&lt;/em&gt; the macro you are writting/debugging. Instead &lt;code&gt;echo&lt;/code&gt; the string generated by &lt;a href=&quot;macros#treeRepr&quot;&gt;treeRepr&lt;/a&gt;. If at the end of the this example you add &lt;code&gt;echo treeRepr(result)&lt;/code&gt; you should get the same output as using the &lt;code&gt;dumpTree&lt;/code&gt; macro, but of course you can call that at any point of the macro where you might be having troubles.</source>
          <target state="translated">Последний совет при написании макроса: если вы не уверены, что AST, который вы создаете, выглядит нормально, у вас может возникнуть соблазн использовать макрос &lt;code&gt;dumpTree&lt;/code&gt; . Но вы не можете использовать его &lt;em&gt;внутри&lt;/em&gt; макроса, который вы пишете / отлаживаете. Вместо того, чтобы &lt;code&gt;echo&lt;/code&gt; строку , генерируемый &lt;a href=&quot;macros#treeRepr&quot;&gt;treeRepr&lt;/a&gt; . Если в конце этого примера вы добавите &lt;code&gt;echo treeRepr(result)&lt;/code&gt; вы должны получить тот же результат, что и при использовании макроса &lt;code&gt;dumpTree&lt;/code&gt; , но, конечно, вы можете вызвать это в любой точке макроса, где могут возникнуть проблемы.</target>
        </trans-unit>
        <trans-unit id="e62c0496669da44a5936805a3cdfee1fe957384a" translate="yes" xml:space="preserve">
          <source>A leaf of the AST often corresponds to a terminal symbol in the concrete syntax. Note that the default &lt;code&gt;float&lt;/code&gt; in Nim maps to &lt;code&gt;float64&lt;/code&gt; such that the default AST for a float is &lt;code&gt;nnkFloat64Lit&lt;/code&gt; as below.</source>
          <target state="translated">Лист AST часто соответствует терминальному символу в конкретном синтаксисе. Обратите внимание, что значение с &lt;code&gt;float&lt;/code&gt; &lt;code&gt;float64&lt;/code&gt; по умолчанию в Nim сопоставляется с float64 , так что AST по умолчанию для float - &lt;code&gt;nnkFloat64Lit&lt;/code&gt; , как показано ниже.</target>
        </trans-unit>
        <trans-unit id="af284b25e3830a68d5e3016b0dc1d22187bec97a" translate="yes" xml:space="preserve">
          <source>A local variable shadows another local variable of an outer scope.</source>
          <target state="translated">Локальная переменная затеняет другую локальную переменную внешней области видимости.</target>
        </trans-unit>
        <trans-unit id="d15ac9d0ba716c535ed2ce2885c3b9d90285db47" translate="yes" xml:space="preserve">
          <source>A macro is a special function that is executed at compile-time. Normally the input for a macro is an abstract syntax tree (AST) of the code that is passed to it. The macro can then do transformations on it and return the transformed AST. The transformed AST is then passed to the compiler as if the macro invocation would have been replaced by its result in the source code. This can be used to implement &lt;span id=&quot;domain-specific-languages_1&quot;&gt;domain specific languages&lt;/span&gt;.</source>
          <target state="translated">Макрос - это специальная функция, которая выполняется во время компиляции. Обычно входными данными для макроса является абстрактное синтаксическое дерево (AST) кода, который ему передается. Затем макрос может выполнять преобразования и возвращать преобразованный AST. Преобразованный AST затем передается компилятору, как если бы вызов макроса был заменен его результатом в исходном коде. Это можно использовать для реализации &lt;span id=&quot;domain-specific-languages_1&quot;&gt;языков, специфичных&lt;/span&gt; для &lt;span id=&quot;domain-specific-languages_1&quot;&gt;предметной области&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="2320939f622f35d906ef2dffec7b8d388f8158e3" translate="yes" xml:space="preserve">
          <source>A macro that needs to be called &lt;span id=&quot;match_1&quot;&gt;match&lt;/span&gt; can be used to rewrite &lt;code&gt;case&lt;/code&gt; statements in order to implement &lt;span id=&quot;pattern-matching_1&quot;&gt;pattern matching&lt;/span&gt; for certain types. The following example implements a simplistic form of pattern matching for tuples, leveraging the existing equality operator for tuples (as provided in &lt;code&gt;system.==&lt;/code&gt;):</source>
          <target state="translated">Макрос, который необходимо вызвать &lt;span id=&quot;match_1&quot;&gt;сопоставлением,&lt;/span&gt; можно использовать для переписывания операторов &lt;code&gt;case&lt;/code&gt; , чтобы реализовать &lt;span id=&quot;pattern-matching_1&quot;&gt;сопоставление с образцом&lt;/span&gt; для определенных типов. В следующем примере реализуется упрощенная форма сопоставления с образцом для кортежей с использованием существующего оператора равенства для кортежей (как предусмотрено в &lt;code&gt;system.==&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="c4a6d2ce7ae67ff08002aecf71f9b696f9005b38" translate="yes" xml:space="preserve">
          <source>A macro that takes as its only input parameter an expression of the special type &lt;code&gt;system.ForLoopStmt&lt;/code&gt; can rewrite the entirety of a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">Макрос, который принимает в качестве единственного входного параметра выражение специального типа &lt;code&gt;system.ForLoopStmt&lt;/code&gt; может полностью переписать цикл &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d8df2d80cd89e184b1f75f28697093931c58d398" translate="yes" xml:space="preserve">
          <source>A module alias can be introduced via the &lt;code&gt;as&lt;/code&gt; keyword:</source>
          <target state="translated">Псевдоним модуля можно ввести с помощью ключевого слова &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d4afefca445f32ee9a9bac5a6c407d25bf9bc289" translate="yes" xml:space="preserve">
          <source>A module's top-level statements are executed at the start of the program. This can be used to initialize complex data structures for example.</source>
          <target state="translated">Операции верхнего уровня модуля выполняются при запуске программы.Это может быть использовано,например,для инициализации сложных структур данных.</target>
        </trans-unit>
        <trans-unit id="a99c0a025e79be3ef687fadc0cc6086e9682f6fb" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;main&lt;/code&gt; async procedure must be declared to allow the use of the &lt;code&gt;await&lt;/code&gt; keyword. The connection will complete asynchronously and the client will be connected after the &lt;code&gt;await ftp.connect()&lt;/code&gt; call.</source>
          <target state="translated">Необходимо объявить новую &lt;code&gt;main&lt;/code&gt; асинхронную процедуру, чтобы разрешить использование ключевого слова &lt;code&gt;await&lt;/code&gt; . Соединение завершится асинхронно, и клиент будет подключен после &lt;code&gt;await ftp.connect()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4f09c089b0b64dd84f87655d31d40b67c7f610c" translate="yes" xml:space="preserve">
          <source>A new entry will be added to the index using the format &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt;. The file part will come from the &lt;em&gt;htmlFile&lt;/em&gt; parameter.</source>
          <target state="translated">Новая запись будет добавлена ​​в индекс с использованием &lt;code&gt;term&amp;lt;tab&amp;gt;file#id&lt;/code&gt; в формате &amp;lt;tab&amp;gt; file # id . Файловая часть будет поступать из параметра &lt;em&gt;htmlFile&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fc67102da94ccd07b62bc7ef2e58c87c378eee76" translate="yes" xml:space="preserve">
          <source>A non-error message that may indicate a potential problem rising or impacted performance.</source>
          <target state="translated">Сообщение об отсутствии ошибок,которое может указывать на потенциальную проблему,поднимающуюся или влияющую на производительность.</target>
        </trans-unit>
        <trans-unit id="911a5ad83db128f4812253b45faa46d98027ca72" translate="yes" xml:space="preserve">
          <source>A parameter &lt;code&gt;p&lt;/code&gt; in a template is even substituted in the expression &lt;code&gt;x.p&lt;/code&gt;. Thus template arguments can be used as field names and a global symbol can be shadowed by the same argument name even when fully qualified:</source>
          <target state="translated">Параметр &lt;code&gt;p&lt;/code&gt; в шаблоне даже подставляется в выражение &lt;code&gt;x.p&lt;/code&gt; . Таким образом, аргументы шаблона можно использовать в качестве имен полей, а глобальный символ может быть затенен тем же именем аргумента, даже если он полностью определен:</target>
        </trans-unit>
        <trans-unit id="b19cf459adbb632e3345bc4ce82a5563aa028fe2" translate="yes" xml:space="preserve">
          <source>A parameter may be declared with a default value which is used if the caller does not provide a value for the argument.</source>
          <target state="translated">Параметр может быть объявлен со значением по умолчанию,которое используется,если вызывающий абонент не предоставляет значение для аргумента.</target>
        </trans-unit>
        <trans-unit id="cd0e5a46bea204df5866abc8071f4ce20c751ed1" translate="yes" xml:space="preserve">
          <source>A parameter of type &lt;code&gt;untyped&lt;/code&gt; always matches any argument (as long as there is any argument passed to it).</source>
          <target state="translated">Параметр типа &lt;code&gt;untyped&lt;/code&gt; всегда соответствует любому аргументу (если ему передан какой-либо аргумент).</target>
        </trans-unit>
        <trans-unit id="dbc7adf040bff90855d92e494801c3ab8308d57e" translate="yes" xml:space="preserve">
          <source>A pattern expression can be bound to a pattern parameter via the &lt;code&gt;expr{param}&lt;/code&gt; notation:</source>
          <target state="translated">Выражение шаблона может быть связано с параметром шаблона с помощью обозначения &lt;code&gt;expr{param}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="84dbef3c0526b967ebfd2aa664f1b6a0e87d7f54" translate="yes" xml:space="preserve">
          <source>A possible common use case for &lt;em&gt;rsplit&lt;/em&gt; is path manipulation, particularly on systems that don't use a common delimiter.</source>
          <target state="translated">Возможным распространенным вариантом использования &lt;em&gt;rsplit&lt;/em&gt; является манипулирование путями, особенно в системах, в которых не используется общий разделитель.</target>
        </trans-unit>
        <trans-unit id="468ffea579d79393dcb2eb8fd23d5f70574b0406" translate="yes" xml:space="preserve">
          <source>A proc can be marked with the &lt;code&gt;asmNoStackFrame&lt;/code&gt; pragma to tell the compiler it should not generate a stack frame for the proc. There are also no exit statements like &lt;code&gt;return result;&lt;/code&gt; generated and the generated C function is declared as &lt;code&gt;__declspec(naked)&lt;/code&gt; or &lt;code&gt;__attribute__((naked))&lt;/code&gt; (depending on the used C compiler).</source>
          <target state="translated">&lt;code&gt;asmNoStackFrame&lt;/code&gt; можно пометить с помощью прагмы asmNoStackFrame, чтобы сообщить компилятору, что он не должен генерировать кадр стека для процесса. Также нет операторов выхода, таких как &lt;code&gt;return result;&lt;/code&gt; сгенерировано, а сгенерированная функция C объявляется как &lt;code&gt;__declspec(naked)&lt;/code&gt; или &lt;code&gt;__attribute__((naked))&lt;/code&gt; (в зависимости от используемого компилятора C).</target>
        </trans-unit>
        <trans-unit id="451fbc26f5ae1ee9316fb78b0e6ca76aa2f9e794" translate="yes" xml:space="preserve">
          <source>A proc that is executed as a new thread of execution should be marked by the &lt;code&gt;thread&lt;/code&gt; pragma for reasons of readability. The compiler checks for violations of the &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;no heap sharing restriction&lt;/span&gt;: This restriction implies that it is invalid to construct a data structure that consists of memory allocated from different (thread local) heaps.</source>
          <target state="translated">Процесс, который выполняется как новый поток выполнения, должен быть помечен директивой &lt;code&gt;thread&lt;/code&gt; для удобства чтения. Компилятор проверяет наличие нарушений &lt;span id=&quot;no-heap-sharing-restriction_1&quot;&gt;ограничения отсутствия совместного использования кучи&lt;/span&gt; : это ограничение подразумевает, что недопустимо создание структуры данных, состоящей из памяти, выделенной из разных (локальных для потока) куч.</target>
        </trans-unit>
        <trans-unit id="c8f7a283eb6acfde98dfa18ad4771346a71dcb69" translate="yes" xml:space="preserve">
          <source>A proc, converter or iterator may return a &lt;code&gt;var&lt;/code&gt; type which means that the returned value is an l-value and can be modified by the caller:</source>
          <target state="translated">Процесс, преобразователь или итератор могут возвращать тип &lt;code&gt;var&lt;/code&gt; , что означает, что возвращаемое значение является l-значением и может быть изменено вызывающей стороной:</target>
        </trans-unit>
        <trans-unit id="4ba9d6d1f4765955e60cabd2afda1cfb0cacfe70" translate="yes" xml:space="preserve">
          <source>A procedural type is a (somewhat abstract) pointer to a procedure. &lt;code&gt;nil&lt;/code&gt; is an allowed value for a variable of a procedural type. Nim uses procedural types to achieve &lt;span id=&quot;functional_1&quot;&gt;functional&lt;/span&gt; programming techniques.</source>
          <target state="translated">Процедурный тип - это (несколько абстрактный) указатель на процедуру. &lt;code&gt;nil&lt;/code&gt; - допустимое значение для переменной процедурного типа. Nim использует процедурные типы для достижения техник &lt;span id=&quot;functional_1&quot;&gt;функционального&lt;/span&gt; программирования.</target>
        </trans-unit>
        <trans-unit id="dbca622df4cb9e116b8115ae0a141864eed44cd7" translate="yes" xml:space="preserve">
          <source>A procedural type is internally a pointer to a procedure. &lt;code&gt;nil&lt;/code&gt; is an allowed value for variables of a procedural type. Nim uses procedural types to achieve &lt;span id=&quot;functional_1&quot;&gt;functional&lt;/span&gt; programming techniques.</source>
          <target state="translated">Процедурный тип внутренне является указателем на процедуру. &lt;code&gt;nil&lt;/code&gt; - допустимое значение для переменных процедурного типа. Nim использует процедурные типы для достижения техник &lt;span id=&quot;functional_1&quot;&gt;функционального&lt;/span&gt; программирования.</target>
        </trans-unit>
        <trans-unit id="bf770f6e5979c1f778e9340dd0cdb848252fa2f0" translate="yes" xml:space="preserve">
          <source>A procedure may call itself recursively.</source>
          <target state="translated">Процедура может называться рекурсивной.</target>
        </trans-unit>
        <trans-unit id="198d46da979417aa29b92d0cafdd5b26b6aa26bb" translate="yes" xml:space="preserve">
          <source>A procedure that returns a value has an implicit &lt;code&gt;result&lt;/code&gt; variable declared that represents the return value. A &lt;code&gt;return&lt;/code&gt; statement with no expression is a shorthand for &lt;code&gt;return result&lt;/code&gt;. The &lt;code&gt;result&lt;/code&gt; value is always returned automatically at the end of a procedure if there is no &lt;code&gt;return&lt;/code&gt; statement at the exit.</source>
          <target state="translated">Для процедуры, возвращающей значение, объявлена ​​неявная &lt;code&gt;result&lt;/code&gt; переменная, представляющая возвращаемое значение. &lt;code&gt;return&lt;/code&gt; заявление без выражения является обобщающим для &lt;code&gt;return result&lt;/code&gt; . Значение &lt;code&gt;result&lt;/code&gt; всегда возвращается автоматически в конце процедуры, если на выходе нет оператора &lt;code&gt;return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4479e2a3631b65d0dd4c690b9db368a8f3b1652a" translate="yes" xml:space="preserve">
          <source>A project can also have a project specific configuration file named &lt;code&gt;$project.nim.cfg&lt;/code&gt; that resides in the same directory as &lt;code&gt;$project.nim&lt;/code&gt;. This file can be skipped with the &lt;code&gt;--skipProjCfg&lt;/code&gt; command line option.</source>
          <target state="translated">У проекта также может быть файл конфигурации для конкретного проекта с именем &lt;code&gt;$project.nim.cfg&lt;/code&gt; который находится в том же каталоге, что и &lt;code&gt;$project.nim&lt;/code&gt; . Этот файл можно пропустить с помощью &lt;code&gt;--skipProjCfg&lt;/code&gt; командной строки --skipProjCfg .</target>
        </trans-unit>
        <trans-unit id="e60afd1721ef96b7c6739e2759b02cb38c2c2d8c" translate="yes" xml:space="preserve">
          <source>A proxy can be specified as a param to any of the procedures defined in this module. To do this, use the &lt;code&gt;newProxy&lt;/code&gt; constructor. Unfortunately, only basic authentication is supported at the moment.</source>
          <target state="translated">Прокси-сервер может быть указан как параметр для любой из процедур, определенных в этом модуле. Для этого используйте конструктор &lt;code&gt;newProxy&lt;/code&gt; . К сожалению, на данный момент поддерживается только базовая аутентификация.</target>
        </trans-unit>
        <trans-unit id="eac1d47b4a0730fb9551845dd67bf5ea00259685" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern:</source>
          <target state="translated">Регулярное выражение-это шаблон,который сопоставляется с тематической строкой слева направо.Большинство символов стоят в шаблоне и совпадают с соответствующими символами в теме.В качестве тривиального примера-шаблон:</target>
        </trans-unit>
        <trans-unit id="5df947512d73d9e3cb7375e44d4a39fd584e964d" translate="yes" xml:space="preserve">
          <source>A routine &lt;code&gt;p&lt;/code&gt; matches better than a routine &lt;code&gt;q&lt;/code&gt; if the following algorithm returns true:</source>
          <target state="translated">Подпрограмма &lt;code&gt;p&lt;/code&gt; соответствует лучше, чем подпрограмма &lt;code&gt;q&lt;/code&gt; , если следующий алгоритм возвращает истину:</target>
        </trans-unit>
        <trans-unit id="fdff97566890f772e04c8438a24bb2cbb00af4bb" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents::</source>
          <target state="translated">Второе использование обратного слеша обеспечивает способ кодирования непечатаемых символов в шаблонах видимым образом.Нет никаких ограничений на появление непечатающихся символов,кроме бинарного нуля,который прерывает шаблон,но когда шаблон подготавливается редактированием текста,обычно проще использовать одну из следующих экранирующих последовательностей,чем бинарный символ,который он представляет::</target>
        </trans-unit>
        <trans-unit id="3eac564020abe821a021c684a0c7e182c5615b2f" translate="yes" xml:space="preserve">
          <source>A section you should use to mark &lt;span id=&quot;runnable-example_1&quot;&gt;runnable example&lt;/span&gt; code with.</source>
          <target state="translated">Раздел, который следует использовать для пометки &lt;span id=&quot;runnable-example_1&quot;&gt;исполняемого примера&lt;/span&gt; кода.</target>
        </trans-unit>
        <trans-unit id="d3b57f32de0396cba5ad9e9d00b3af349a475164" translate="yes" xml:space="preserve">
          <source>A sequence may be passed to a parameter that is of type &lt;em&gt;open array&lt;/em&gt;.</source>
          <target state="translated">Последовательность может быть передана параметру типа &lt;em&gt;открытый массив&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="42f4d3d39137f32b8ca5b909c4ff4309a61d6eac" translate="yes" xml:space="preserve">
          <source>A sequence may be passed to an openarray parameter.</source>
          <target state="translated">В параметр openarray может быть передана последовательность.</target>
        </trans-unit>
        <trans-unit id="e9939043c42e4aaaff588930f28e3fb87a4c1d18" translate="yes" xml:space="preserve">
          <source>A set with all the possible characters.</source>
          <target state="translated">Набор со всеми возможными символами.</target>
        </trans-unit>
        <trans-unit id="13fa5f0ea96be473acaa7e27bc838b91426d27e9" translate="yes" xml:space="preserve">
          <source>A shared GC'ed heap might be provided.</source>
          <target state="translated">Может быть обеспечена общая куча ГК'эд.</target>
        </trans-unit>
        <trans-unit id="af38f1c5146159966de284e8a35e5d86d3ab12b9" translate="yes" xml:space="preserve">
          <source>A shorthand for:</source>
          <target state="translated">Сокращение для:</target>
        </trans-unit>
        <trans-unit id="dac4b4b7dce5d63bf65005785b5b8b3dd2313f8a" translate="yes" xml:space="preserve">
          <source>A similar thing happens with C code invoking Nim code which returns a &lt;code&gt;cstring&lt;/code&gt;. Consider the following proc:</source>
          <target state="translated">То же самое происходит с кодом C, вызывающим код Nim, который возвращает &lt;code&gt;cstring&lt;/code&gt; . Рассмотрим следующую процедуру:</target>
        </trans-unit>
        <trans-unit id="a48f6996b6131883f1b9650bc68f70d8d02303fe" translate="yes" xml:space="preserve">
          <source>A simple XML tree. More efficient and simpler than the DOM.</source>
          <target state="translated">Простое дерево XML.Более эффективное и простое,чем DOM.</target>
        </trans-unit>
        <trans-unit id="b881695a1cfe6f9170c0ac327d2994cb87b8beb2" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;&quot;*&quot;&lt;/code&gt; can be used for globbing.</source>
          <target state="translated">Для подстановки можно использовать одиночный &lt;code&gt;&quot;*&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17eb06b5b98ef723497f736d4beb2106d493fd2b" translate="yes" xml:space="preserve">
          <source>A static statement/expression can be used to enforce compile time evaluation explicitly. Enforced compile time evaluation can even evaluate code that has side effects:</source>
          <target state="translated">Статическое заявление/выражение может быть использовано для обеспечения явно выраженной оценки времени компиляции.Насильственная оценка времени компиляции может даже оценить код,имеющий побочные эффекты:</target>
        </trans-unit>
        <trans-unit id="793061e8f68073a7cc2b6e8e7cb7430e9cb435af" translate="yes" xml:space="preserve">
          <source>A strict or proper subset &lt;em&gt;s&lt;/em&gt; has all of its members in &lt;em&gt;t&lt;/em&gt; but &lt;em&gt;t&lt;/em&gt; has more elements than &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">Строгое или собственное подмножество &lt;em&gt;s&lt;/em&gt; имеет все члены в &lt;em&gt;t,&lt;/em&gt; но &lt;em&gt;t&lt;/em&gt; имеет больше элементов, чем &lt;em&gt;s&lt;/em&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="692f4550479e6001b1a436a04309e4819905d924" translate="yes" xml:space="preserve">
          <source>A string surrounded by double quotation marks (&quot;string&quot;) is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.</source>
          <target state="translated">Строка,окруженная двойными кавычками (&quot;строка&quot;),интерпретируется как единственный аргумент,независимо от того,внутри какого пробела содержится пробел.Строка,заключенная в кавычки,может быть встроена в аргумент.</target>
        </trans-unit>
        <trans-unit id="ebec3b61b900cc32aa099451f2c6e12dd07c334c" translate="yes" xml:space="preserve">
          <source>A string variable is initialized with the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Строковая переменная инициализируется пустой строкой &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3a00e56e1710bd679d0173c57dab6fbeebbe31b" translate="yes" xml:space="preserve">
          <source>A subrange type has the same size as its base type (&lt;code&gt;int&lt;/code&gt; in the Subrange example).</source>
          <target state="translated">Тип поддиапазона имеет тот же размер, что и его базовый тип ( &lt;code&gt;int&lt;/code&gt; в примере поддиапазона ).</target>
        </trans-unit>
        <trans-unit id="7a08933979326f8850950a1173db1b99805f1785" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an integer or enumeration type (the base type). Example:</source>
          <target state="translated">Поддиапазонный тип-это диапазон значений из целого числа или перечисления (базовый тип).Пример:</target>
        </trans-unit>
        <trans-unit id="5216761dae1ae277a963814830873f1da9e08d5b" translate="yes" xml:space="preserve">
          <source>A subrange type is a range of values from an ordinal or floating point type (the base type). To define a subrange type, one must specify it's limiting values: the lowest and highest value of the type:</source>
          <target state="translated">Поддиапазонный тип-это диапазон значений от порядкового или плавающего типа (базовый тип).Чтобы определить тип поддиапазона,необходимо указать его предельные значения:самое низкое и самое высокое значение типа:</target>
        </trans-unit>
        <trans-unit id="05319ab331bb8be9fb80a1ea2da5bff936f37a01" translate="yes" xml:space="preserve">
          <source>A subset &lt;em&gt;s&lt;/em&gt; has all of its members in &lt;em&gt;t&lt;/em&gt; and &lt;em&gt;t&lt;/em&gt; doesn't necessarily have more members than &lt;em&gt;s&lt;/em&gt;. That is, &lt;em&gt;s&lt;/em&gt; can be equal to &lt;em&gt;t&lt;/em&gt;. Example:</source>
          <target state="translated">Подмножество &lt;em&gt;s&lt;/em&gt; имеет все члены в &lt;em&gt;t,&lt;/em&gt; и &lt;em&gt;t&lt;/em&gt; не обязательно имеет больше членов, чем &lt;em&gt;s&lt;/em&gt; . То есть &lt;em&gt;s&lt;/em&gt; может быть равно &lt;em&gt;t&lt;/em&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="23fcaa56fd8e693a2e943e96baf6a166ee24925f" translate="yes" xml:space="preserve">
          <source>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. As a special extension, a procedure of the calling convention &lt;code&gt;nimcall&lt;/code&gt; can be passed to a parameter that expects a proc of the calling convention &lt;code&gt;closure&lt;/code&gt;.</source>
          <target state="translated">Тонкая проблема с процедурными типами заключается в том, что соглашение о вызове процедуры влияет на совместимость типов: процедурные типы совместимы только в том случае, если они имеют одинаковое соглашение о вызове. В качестве специального расширения процедура соглашения о &lt;code&gt;nimcall&lt;/code&gt; может быть передана параметру, который ожидает процедуры &lt;code&gt;closure&lt;/code&gt; соглашения о вызовах .</target>
        </trans-unit>
        <trans-unit id="33ba9ca12af44d34318811768b34fc09edc238c4" translate="yes" xml:space="preserve">
          <source>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. The different calling conventions are listed in the &lt;a href=&quot;manual#types-procedural-type&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Тонкая проблема с процедурными типами заключается в том, что соглашение о вызове процедуры влияет на совместимость типов: процедурные типы совместимы только в том случае, если они имеют одинаковое соглашение о вызове. Различные соглашения о вызовах перечислены в &lt;a href=&quot;manual#types-procedural-type&quot;&gt;руководстве&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a98d0d55b4f56cd1973186508a85d670c67f313d" translate="yes" xml:space="preserve">
          <source>A symbol can be forced to be open by a &lt;span id=&quot;mixin_1&quot;&gt;mixin&lt;/span&gt; declaration:</source>
          <target state="translated">Символ может быть принудительно открыт с помощью объявления &lt;span id=&quot;mixin_1&quot;&gt;mixin&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="0462b1952d8449154ce73caf7ef4db9422926829" translate="yes" xml:space="preserve">
          <source>A symbol of a module &lt;em&gt;can&lt;/em&gt; be &lt;em&gt;qualified&lt;/em&gt; with the &lt;code&gt;module.symbol&lt;/code&gt; syntax. And if a symbol is ambiguous, it &lt;em&gt;must&lt;/em&gt; be qualified. A symbol is ambiguous if it is defined in two (or more) different modules and both modules are imported by a third one:</source>
          <target state="translated">Символ модуля &lt;em&gt;может&lt;/em&gt; быть &lt;em&gt;квалифицирован&lt;/em&gt; с &lt;code&gt;module.symbol&lt;/code&gt; синтаксиса. А если символ неоднозначен, его &lt;em&gt;необходимо&lt;/em&gt; квалифицировать. Символ является неоднозначным, если он определен в двух (или более) разных модулях, и оба модуля импортируются третьим:</target>
        </trans-unit>
        <trans-unit id="b3a7ad38688e4496bf760973d6609aeb8d3bfad8" translate="yes" xml:space="preserve">
          <source>A symbol which is a &lt;code&gt;let&lt;/code&gt; variable.</source>
          <target state="translated">Символ, который является переменной &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25afae3a203b27eb5151fb8ba040656c33e3555a" translate="yes" xml:space="preserve">
          <source>A symbol which is a constant.</source>
          <target state="translated">Символ,который является константой.</target>
        </trans-unit>
        <trans-unit id="18336a58e1597be288809ec54b26b76e902b5f18" translate="yes" xml:space="preserve">
          <source>A symbol which is a converter.</source>
          <target state="translated">Символ,который является конвертером.</target>
        </trans-unit>
        <trans-unit id="34e5a133463d35676b1ce7b0d26dcb4084186353" translate="yes" xml:space="preserve">
          <source>A symbol which is a field in a tuple or an object.</source>
          <target state="translated">Символ,который является полем в кортеже или объектом.</target>
        </trans-unit>
        <trans-unit id="dbc7ff0193694a8a6df3edaa4feafaf08a548d9c" translate="yes" xml:space="preserve">
          <source>A symbol which is a field in an enumeration.</source>
          <target state="translated">Символ,который является полем в перечислении.</target>
        </trans-unit>
        <trans-unit id="b0f4c02b65e3aca97fa198aef1b1d7f8f50540e1" translate="yes" xml:space="preserve">
          <source>A symbol which is a generic parameter.</source>
          <target state="translated">Символ,который является общим параметром.</target>
        </trans-unit>
        <trans-unit id="cee1e54f067d3a3df195ebd26b86fefccf9d512a" translate="yes" xml:space="preserve">
          <source>A symbol which is a macro.</source>
          <target state="translated">Символ,представляющий собой макрос.</target>
        </trans-unit>
        <trans-unit id="8ba65c84aa50b6b4fa8d3cfd3055d6bba8e59df2" translate="yes" xml:space="preserve">
          <source>A symbol which is a method.</source>
          <target state="translated">Символ,который является методом.</target>
        </trans-unit>
        <trans-unit id="397a59c937f508b55f4f508768e9f30b05e604a7" translate="yes" xml:space="preserve">
          <source>A symbol which is a module.</source>
          <target state="translated">Символ,который является модулем.</target>
        </trans-unit>
        <trans-unit id="2ebe7a11b22366113570683c1b68d2ed707218ec" translate="yes" xml:space="preserve">
          <source>A symbol which is a parameter.</source>
          <target state="translated">Символ,который является параметром.</target>
        </trans-unit>
        <trans-unit id="28496412faf0d454dab9dc1a6af576954c0a1ed5" translate="yes" xml:space="preserve">
          <source>A symbol which is a proc.</source>
          <target state="translated">Символ,который означает &quot;тянуть&quot;.</target>
        </trans-unit>
        <trans-unit id="b83a50e7c38bef4fa30f012bba6b90bc90afc9ea" translate="yes" xml:space="preserve">
          <source>A symbol which is a template.</source>
          <target state="translated">Символ,который является шаблоном.</target>
        </trans-unit>
        <trans-unit id="3462dea1dd2d1f68df6439bcca6ca7bca98f2daf" translate="yes" xml:space="preserve">
          <source>A symbol which is a type.</source>
          <target state="translated">Символ,который является типом.</target>
        </trans-unit>
        <trans-unit id="2a1357b126b87914b1b6f8a549043e8db1b4ede2" translate="yes" xml:space="preserve">
          <source>A symbol which is a variable.</source>
          <target state="translated">Символ,который является переменной.</target>
        </trans-unit>
        <trans-unit id="2d0634ee6e934140b8250f79b8ba8901843ddbb9" translate="yes" xml:space="preserve">
          <source>A symbol which is an iterator.</source>
          <target state="translated">Символ,который является итератором.</target>
        </trans-unit>
        <trans-unit id="4e393c2bf071d79fe321a01e0a6eea1010d9f40a" translate="yes" xml:space="preserve">
          <source>A system call for device-specific input/output operations and other operations which cannot be expressed by regular system calls</source>
          <target state="translated">Системный вызов операций ввода/вывода для конкретного устройства и других операций,которые не могут быть выражены обычными системными вызовами.</target>
        </trans-unit>
        <trans-unit id="fc9ce8dd56e57484f7771a0858bc6ea64b79d22b" translate="yes" xml:space="preserve">
          <source>A table constructor is syntactic sugar for an array constructor:</source>
          <target state="translated">Конструктор таблицы-синтаксический сахар для конструктора массива:</target>
        </trans-unit>
        <trans-unit id="4a7a5f8021ef6500926b1cb58e60a0f63620d3dd" translate="yes" xml:space="preserve">
          <source>A table literal can be put into a &lt;code&gt;const&lt;/code&gt; section and the compiler can easily put it into the executable's data section just like it can for arrays and the generated data section requires a minimal amount of memory.</source>
          <target state="translated">Табличный литерал может быть помещен в &lt;code&gt;const&lt;/code&gt; секцию, и компилятор может легко поместить его в секцию данных исполняемого файла так же, как и для массивов, а секция сгенерированных данных требует минимального количества памяти.</target>
        </trans-unit>
        <trans-unit id="cfef19ba2df017b1840fca787af14959a3b9fbf8" translate="yes" xml:space="preserve">
          <source>A tag has to be a type name. A &lt;code&gt;tags&lt;/code&gt; list - like a &lt;code&gt;raises&lt;/code&gt; list - can also be attached to a proc type. This affects type compatibility.</source>
          <target state="translated">Тег должен быть именем типа. Список &lt;code&gt;tags&lt;/code&gt; - как и список &lt;code&gt;raises&lt;/code&gt; - также может быть прикреплен к типу процесса. Это влияет на совместимость типов.</target>
        </trans-unit>
        <trans-unit id="c7c12a1bbcf06851adacdd13e78109f4548a353d" translate="yes" xml:space="preserve">
          <source>A template is a &lt;span id=&quot;hygienic_1&quot;&gt;hygienic&lt;/span&gt; macro and so opens a new scope. Most symbols are bound from the definition scope of the template:</source>
          <target state="translated">Шаблон - это &lt;span id=&quot;hygienic_1&quot;&gt;гигиенический&lt;/span&gt; макрос, поэтому он открывает новые возможности. Большинство символов связано с областью определения шаблона:</target>
        </trans-unit>
        <trans-unit id="3d0909aebdac7146ab483112e0cffc46ee0650d8" translate="yes" xml:space="preserve">
          <source>A template is a simple form of a macro: It is a simple substitution mechanism that operates on Nim's abstract syntax trees. It is processed in the semantic pass of the compiler.</source>
          <target state="translated">Шаблон-это простая форма макроса:Это простой механизм подстановки,который работает на абстрактных синтаксических деревьях Ним.Он обрабатывается в семантическом проходе компилятора.</target>
        </trans-unit>
        <trans-unit id="4957f2f98151d72020ad997ae5b0177dbfe8bd70" translate="yes" xml:space="preserve">
          <source>A template where every parameter is &lt;code&gt;untyped&lt;/code&gt; is called an &lt;span id=&quot;immediate_1&quot;&gt;immediate&lt;/span&gt; template. For historical reasons templates can be explicitly annotated with an &lt;code&gt;immediate&lt;/code&gt; pragma and then these templates do not take part in overloading resolution and the parameters' types are &lt;em&gt;ignored&lt;/em&gt; by the compiler. Explicit immediate templates are now deprecated.</source>
          <target state="translated">Шаблон, в котором все параметры &lt;code&gt;untyped&lt;/code&gt; , называется &lt;span id=&quot;immediate_1&quot;&gt;непосредственным&lt;/span&gt; шаблоном. По историческим причинам шаблоны могут быть явно аннотированы с помощью директивы &lt;code&gt;immediate&lt;/code&gt; и тогда эти шаблоны не участвуют в разрешении перегрузки, а типы параметров &lt;em&gt;игнорируются&lt;/em&gt; компилятором. Явные немедленные шаблоны теперь устарели.</target>
        </trans-unit>
        <trans-unit id="2c5c46bd6cd44a46ae88e10ca57070a21a6c5dbc" translate="yes" xml:space="preserve">
          <source>A test suite is a series of one or more related tests sharing a common fixture (&lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;teardown&lt;/code&gt;). The fixture is executed for EACH test.</source>
          <target state="translated">Набор тестов - это серия из одного или нескольких связанных тестов, использующих общий инструмент ( &lt;code&gt;setup&lt;/code&gt; , &lt;code&gt;teardown&lt;/code&gt; ). Приспособление выполняется для КАЖДОГО теста.</target>
        </trans-unit>
        <trans-unit id="31bf8aebbb82c9b930fd2c075ab23a6c84bd7bab" translate="yes" xml:space="preserve">
          <source>A thread proc is passed to &lt;code&gt;createThread&lt;/code&gt; or &lt;code&gt;spawn&lt;/code&gt; and invoked indirectly; so the &lt;code&gt;thread&lt;/code&gt; pragma implies &lt;code&gt;procvar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;createThread&lt;/code&gt; потока передается в createThread или &lt;code&gt;spawn&lt;/code&gt; и вызывается косвенно; поэтому прагма &lt;code&gt;thread&lt;/code&gt; подразумевает &lt;code&gt;procvar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41bb5d8b499e01e5a1190386e45f8f1ab3dfd432" translate="yes" xml:space="preserve">
          <source>A thunk would need to call 'returnsDefaultCC[i]' somehow and that would require an &lt;em&gt;additional&lt;/em&gt; closure generation... Ok, not really, but it requires to pass the function to call. So we'd end up with 2 indirect calls instead of one. Another much more severe problem which this solution is that it's not GC-safe to pass a proc pointer around via a generic &lt;code&gt;ref&lt;/code&gt; type.</source>
          <target state="translated">Преобразователь должен каким-то образом вызвать &amp;laquo;returnsDefaultCC [i]&amp;raquo;, и это потребует &lt;em&gt;дополнительной&lt;/em&gt; генерации замыкания ... Хорошо, не совсем, но для этого требуется передать функцию для вызова. Таким образом, мы получили бы 2 косвенных вызова вместо одного. Другая гораздо более серьезная проблема, связанная с этим решением, заключается в том, что передавать указатель proc через общий тип &lt;code&gt;ref&lt;/code&gt; небезопасно для сборки мусора .</target>
        </trans-unit>
        <trans-unit id="a71df16ade8aee765ef43a13e09747416cdfc482" translate="yes" xml:space="preserve">
          <source>A timeout can be specified in milliseconds, if data is not received within the specified time an ETimeout exception will be raised.</source>
          <target state="translated">Таймаут может быть указан в миллисекундах,если данные не будут получены в указанный промежуток времени,будет поднято исключение ETimeout.</target>
        </trans-unit>
        <trans-unit id="9b5284b25f36831bd8cd3b0848696b52af7ef955" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified an ETimeout exception will be raised.</source>
          <target state="translated">Таймаут может быть указан в миллисекундах,если в течение указанного времени не будет получено достаточное количество данных,то будет поднято исключение ETimeout.</target>
        </trans-unit>
        <trans-unit id="b206d5f711dced99df1aa8e9ea0d1479edc748b9" translate="yes" xml:space="preserve">
          <source>A timeout may be specified in milliseconds, if enough data is not received within the time specified an TimeoutError exception will be raised.</source>
          <target state="translated">Таймаут может быть указан в миллисекундах,если в течение указанного времени не будет получено достаточное количество данных,то будет поднято исключение TimeoutError.</target>
        </trans-unit>
        <trans-unit id="5a5e0bec046a288f45da3539bee961bd4b7e1bc5" translate="yes" xml:space="preserve">
          <source>A tuple type defines various named &lt;em&gt;fields&lt;/em&gt; and an &lt;em&gt;order&lt;/em&gt; of the fields. The constructor &lt;code&gt;()&lt;/code&gt; can be used to construct tuples. The order of the fields in the constructor must match the order in the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify fields of the same type and of the same name in the same order.</source>
          <target state="translated">Тип кортежа определяет различные именованные &lt;em&gt;поля&lt;/em&gt; и &lt;em&gt;порядок&lt;/em&gt; полей. Конструктор &lt;code&gt;()&lt;/code&gt; может использоваться для создания кортежей. Порядок полей в конструкторе должен соответствовать порядку в определении кортежа. Различные типы кортежей &lt;em&gt;эквивалентны,&lt;/em&gt; если они определяют поля одного типа и с одним и тем же именем в одном порядке.</target>
        </trans-unit>
        <trans-unit id="5e6444b3f99eb953e87888c66966bcbc524ea4f4" translate="yes" xml:space="preserve">
          <source>A tuple with one unnamed field can be constructed with the parentheses and a trailing comma:</source>
          <target state="translated">Кортеж с одним безымянным полем может быть построен с помощью круглых скобок и запятой &quot;трейлинг&quot;:</target>
        </trans-unit>
        <trans-unit id="14170c2ff1e7de54f4e2348d1e871df1403c7064" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is &lt;strong&gt;explicitly&lt;/strong&gt; convertible to type &lt;code&gt;b&lt;/code&gt; iff the following algorithm returns true:</source>
          <target state="translated">Тип является &lt;strong&gt;явно&lt;/strong&gt; преобразован в тип &lt;code&gt;b&lt;/code&gt; тогда и только тогда следующие возвратов алгоритм верных: &lt;code&gt;a&lt;/code&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e266a33b4be68e2d75b658bf09d5fcd023a82b7" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is &lt;strong&gt;implicitly&lt;/strong&gt; convertible to type &lt;code&gt;b&lt;/code&gt; iff the following algorithm returns true:</source>
          <target state="translated">Тип является &lt;strong&gt;неявно&lt;/strong&gt; преобразован в тип &lt;code&gt;b&lt;/code&gt; тогда и только тогда следующие возвратов алгоритм верных: &lt;code&gt;a&lt;/code&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="506a88b6ff206893ad4b7e57e9c4e7e99b518ff4" translate="yes" xml:space="preserve">
          <source>A type class is a special pseudo-type that can be used to match against types in the context of overload resolution or the &lt;code&gt;is&lt;/code&gt; operator. Nim supports the following built-in type classes:</source>
          <target state="translated">Класс типа - это специальный псевдотип, который можно использовать для сопоставления типов в контексте разрешения перегрузки или оператора &lt;code&gt;is&lt;/code&gt; . Nim поддерживает следующие встроенные классы типов:</target>
        </trans-unit>
        <trans-unit id="ec2661446eb8287aeb52ad012da364775c3dbaac" translate="yes" xml:space="preserve">
          <source>A type section begins with the &lt;code&gt;type&lt;/code&gt; keyword. It contains multiple type definitions. A type definition binds a type to a name. Type definitions can be recursive or even mutually recursive. Mutually recursive types are only possible within a single &lt;code&gt;type&lt;/code&gt; section. Nominal types like &lt;code&gt;objects&lt;/code&gt; or &lt;code&gt;enums&lt;/code&gt; can only be defined in a &lt;code&gt;type&lt;/code&gt; section.</source>
          <target state="translated">Раздел типа начинается с ключевого слова &lt;code&gt;type&lt;/code&gt; . Он содержит несколько определений типов. Определение типа связывает тип с именем. Определения типов могут быть рекурсивными или даже взаимно рекурсивными. Взаимно рекурсивные типы возможны только в пределах одного раздела &lt;code&gt;type&lt;/code&gt; . Номинальные типы, такие как &lt;code&gt;objects&lt;/code&gt; или &lt;code&gt;enums&lt;/code&gt; могут быть определены только в разделе &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0511cf3cc72e09256f19cf736ca74f42546431bf" translate="yes" xml:space="preserve">
          <source>A type specialized version of &lt;code&gt;..&lt;/code&gt; for convenience so that mixing integer types work better.</source>
          <target state="translated">Специализированная версия &lt;code&gt;..&lt;/code&gt; для удобства, так что смешивание целочисленных типов работает лучше.</target>
        </trans-unit>
        <trans-unit id="1aca1ed394a97d0358e43ad02e64f2e9f0dad035" translate="yes" xml:space="preserve">
          <source>A valid identifier starts with a character of the set &lt;em&gt;IdentStartChars&lt;/em&gt; and is followed by any number of characters of the set &lt;em&gt;IdentChars&lt;/em&gt;.</source>
          <target state="translated">Допустимый идентификатор начинается с символа из набора &lt;em&gt;IdentStartChars,&lt;/em&gt; за которым следует любое количество символов из набора &lt;em&gt;IdentChars&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d0abd94780a5ea8e9be893452be742a7ec90a256" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;Option[T]&lt;/code&gt; either contains a value &lt;em&gt;x&lt;/em&gt; (represented as &lt;code&gt;some(x)&lt;/code&gt;) or is empty (&lt;code&gt;none(T)&lt;/code&gt;).</source>
          <target state="translated">Значение типа &lt;code&gt;Option[T]&lt;/code&gt; либо содержит значение &lt;em&gt;x&lt;/em&gt; (представленное как &lt;code&gt;some(x)&lt;/code&gt; ), либо пустое ( &lt;code&gt;none(T)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="061691c897942e6f7639e5b9fc01836fcff953a0" translate="yes" xml:space="preserve">
          <source>A variable can be marked with the &lt;code&gt;threadvar&lt;/code&gt; pragma, which makes it a &lt;span id=&quot;threadminuslocal_1&quot;&gt;thread-local&lt;/span&gt; variable; Additionally, this implies all the effects of the &lt;code&gt;global&lt;/code&gt; pragma.</source>
          <target state="translated">Переменная может быть помечена с помощью &lt;code&gt;threadvar&lt;/code&gt; , что делает ее &lt;span id=&quot;threadminuslocal_1&quot;&gt;локальной&lt;/span&gt; переменной &lt;span id=&quot;threadminuslocal_1&quot;&gt;потока&lt;/span&gt; ; Кроме того, это подразумевает все эффекты &lt;code&gt;global&lt;/code&gt; прагмы.</target>
        </trans-unit>
        <trans-unit id="6cf2d03ae6a2d13d0af73951ec3e536467f5ec85" translate="yes" xml:space="preserve">
          <source>A variable of a structured type can hold multiple values at the same time. Structured types can be nested to unlimited levels. Arrays, sequences, tuples, objects and sets belong to the structured types.</source>
          <target state="translated">Переменная структурированного типа может содержать несколько значений одновременно.Структурные типы могут быть вложены в неограниченное количество уровней.Массивы,последовательности,кортежи,объекты и наборы принадлежат структурным типам.</target>
        </trans-unit>
        <trans-unit id="c3f3d14f490e58bdf5285ce0bef4d7745002ec1a" translate="yes" xml:space="preserve">
          <source>A variable of a tuple or object type is a heterogeneous storage container. A tuple or object defines various named &lt;em&gt;fields&lt;/em&gt; of a type. A tuple also defines an &lt;em&gt;order&lt;/em&gt; of the fields. Tuples are meant for heterogeneous storage types with no overhead and few abstraction possibilities. The constructor &lt;code&gt;()&lt;/code&gt; can be used to construct tuples. The order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are &lt;em&gt;equivalent&lt;/em&gt; if they specify the same fields of the same type in the same order. The &lt;em&gt;names&lt;/em&gt; of the fields also have to be identical.</source>
          <target state="translated">Переменная кортежа или типа объекта - это разнородный контейнер для хранения. Кортеж или объект определяют различные именованные &lt;em&gt;поля&lt;/em&gt; типа. Кортеж также определяет &lt;em&gt;порядок&lt;/em&gt; полей. Кортежи предназначены для разнородных типов хранилищ без накладных расходов и с небольшими возможностями абстракции. Конструктор &lt;code&gt;()&lt;/code&gt; может использоваться для создания кортежей. Порядок полей в конструкторе должен соответствовать порядку определения кортежа. Различные типы кортежей &lt;em&gt;эквивалентны,&lt;/em&gt; если они определяют одни и те же поля одного и того же типа в одном порядке. В &lt;em&gt;именах&lt;/em&gt; полей также должны быть идентичными.</target>
        </trans-unit>
        <trans-unit id="7bdc1f89d378b40222906883361628b1181e0aa3" translate="yes" xml:space="preserve">
          <source>A variable of an enumeration type can only be assigned one of the enumeration's specified values. These values are a set of ordered symbols. Each symbol is mapped to an integer value internally. The first symbol is represented at runtime by 0, the second by 1 and so on. For example:</source>
          <target state="translated">Переменной типа перечисления может быть присвоено только одно из указанных значений перечисления.Эти значения представляют собой набор упорядоченных символов.Каждый символ внутренне привязывается к целому значению.Первый символ отображается во время выполнения на 0,второй-на 1 и так далее.Например:</target>
        </trans-unit>
        <trans-unit id="03eb03003aebc272b7eb136b33ffcf55da04a588" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;connect&lt;/code&gt; for non-blocking sockets.</source>
          <target state="translated">Вариант &lt;code&gt;connect&lt;/code&gt; для неблокируемых розеток.</target>
        </trans-unit>
        <trans-unit id="71ed9093f7d2c5cbb9aa8a3933ec4cb522e39e48" translate="yes" xml:space="preserve">
          <source>A while (for) statement introduces an implicit block. Identifiers are only visible within the block they have been declared. The &lt;code&gt;block&lt;/code&gt; statement can be used to open a new block explicitly:</source>
          <target state="translated">Оператор while (for) вводит неявный блок. Идентификаторы видны только в том блоке, в котором они были объявлены. Оператор &lt;code&gt;block&lt;/code&gt; может использоваться для явного открытия нового блока:</target>
        </trans-unit>
        <trans-unit id="bc56783853877b4342018f4f4752a7c166237a4d" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match &lt;code&gt;\w&lt;/code&gt; or &lt;code&gt;\W&lt;/code&gt; (i.e. one matches &lt;code&gt;\w&lt;/code&gt; and the other matches &lt;code&gt;\W&lt;/code&gt;), or the start or end of the string if the first or last character matches &lt;code&gt;\w&lt;/code&gt;, respectively.</source>
          <target state="translated">Граница слова - это позиция в строке темы, в которой текущий и предыдущий символы не совпадают ни с &lt;code&gt;\w&lt;/code&gt; ни с &lt;code&gt;\W&lt;/code&gt; (т. Е. Один соответствует &lt;code&gt;\w&lt;/code&gt; а другой соответствует &lt;code&gt;\W&lt;/code&gt; ), или начало или конец строки, если первый или последний символ соответствует &lt;code&gt;\w&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="469aae2fa20a5b364724db93849620fbab87ad21" translate="yes" xml:space="preserve">
          <source>API naming design</source>
          <target state="translated">дизайн имен API</target>
        </trans-unit>
        <trans-unit id="6e86868dfa064831def0a9a32949fcd3f02c8b05" translate="yes" xml:space="preserve">
          <source>AST based overloading</source>
          <target state="translated">перегрузка на основе АСТ</target>
        </trans-unit>
        <trans-unit id="b08670d9d509dc53f0d69a06ccafcdfc0680021a" translate="yes" xml:space="preserve">
          <source>AST:</source>
          <target state="translated">AST:</target>
        </trans-unit>
        <trans-unit id="ed89ae3b78e13637e55b85c4b03f6daaccfcbc6b" translate="yes" xml:space="preserve">
          <source>Abbreviated three-letter form of the month.</source>
          <target state="translated">Сокращенная трехбуквенная форма месяца.</target>
        </trans-unit>
        <trans-unit id="02befbd420c9754ded8c9a688a174615ddafd2a6" translate="yes" xml:space="preserve">
          <source>About this document</source>
          <target state="translated">Об этом документе</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="1b33443d15e91efce2e27797d2c769792a4be765" translate="yes" xml:space="preserve">
          <source>Abstract base class for all exceptions that Nim's runtime raises but that are strictly uncatchable as they can also be mapped to a &lt;code&gt;quit&lt;/code&gt; / &lt;code&gt;trap&lt;/code&gt; / &lt;code&gt;exit&lt;/code&gt; operation.</source>
          <target state="translated">Абстрактный базовый класс для всех исключений , которые во время выполнения повышений Nim, но которые строго неуловимые , поскольку они также могут быть преобразованы в &lt;code&gt;quit&lt;/code&gt; / &lt;code&gt;trap&lt;/code&gt; / &lt;code&gt;exit&lt;/code&gt; операции.</target>
        </trans-unit>
        <trans-unit id="07ade5cd2426cf2d96d9f115a542fdf23ea73fb2" translate="yes" xml:space="preserve">
          <source>Abstract class for all exceptions that are catchable.</source>
          <target state="translated">Абстрактный класс для всех исключений,которые можно уловить.</target>
        </trans-unit>
        <trans-unit id="1cf35ec1eeb0cdf41c798e53ae7c4bdbcf3c6e03" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;astGenRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">Принимает блок кода nim и печатает проанализированное абстрактное синтаксическое дерево с &lt;em&gt;помощью&lt;/em&gt; функции &lt;em&gt;astGenRepr&lt;/em&gt; . Печать выполняется &lt;em&gt;во время компиляции&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7c6e301f36546045d51728adbff6b973b0918094" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;lispRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">Принимает блок кода нима и печатает проанализированное абстрактное синтаксическое дерево с &lt;em&gt;помощью&lt;/em&gt; функции &lt;em&gt;lispRepr&lt;/em&gt; . Печать выполняется &lt;em&gt;во время компиляции&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7eb919c05e9f3591e4b18f0af2d7cce492e0545f" translate="yes" xml:space="preserve">
          <source>Accepts a block of nim code and prints the parsed abstract syntax tree using the &lt;em&gt;treeRepr&lt;/em&gt; function. Printing is done &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">Принимает блок кода нима и печатает проанализированное абстрактное синтаксическое дерево с &lt;em&gt;помощью&lt;/em&gt; функции &lt;em&gt;treeRepr&lt;/em&gt; . Печать выполняется &lt;em&gt;во время компиляции&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ce207f0652d5a79c6fb92d9892844f64c3c7bc7f" translate="yes" xml:space="preserve">
          <source>Accepts a new client connection.</source>
          <target state="translated">Принимает новое соединение с клиентом.</target>
        </trans-unit>
        <trans-unit id="0612c97d4b20e5af1b9ee2e86992dd16c29c8cbf" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">Принимает новое соединение.Возвращает будущее,содержащее соответствующее этому соединению клиентское сокет и удаленный адрес клиента.Будущее будет завершено,когда соединение будет успешно принято.</target>
        </trans-unit>
        <trans-unit id="bb38da96bcf63ef07293cca8f7fae610327e435b" translate="yes" xml:space="preserve">
          <source>Accepts a new connection. Returns a future containing the client socket corresponding to that connection. The future will complete when the connection is successfully accepted.</source>
          <target state="translated">Принимает новое соединение.Возвращает будущее,содержащее клиентский сокет,соответствующий этому соединению.Будущее будет завершено,когда соединение будет успешно принято.</target>
        </trans-unit>
        <trans-unit id="6813381cdc37c15725205e39fd4619d20653f02f" translate="yes" xml:space="preserve">
          <source>Accepts an instantiated generic type and returns its uninstantiated form.</source>
          <target state="translated">Принимает инстанцированный родовый тип и возвращает его инстанцированную форму.</target>
        </trans-unit>
        <trans-unit id="faf4ef0e56229453f96a306fcf1a0f1923d413de" translate="yes" xml:space="preserve">
          <source>Acceses a specified &lt;em&gt;entry&lt;/em&gt; from the current row.</source>
          <target state="translated">Получает доступ к указанной &lt;em&gt;записи&lt;/em&gt; из текущей строки.</target>
        </trans-unit>
        <trans-unit id="f9e9dd7a48db03f7a1f9615c265496ab948af3da" translate="yes" xml:space="preserve">
          <source>Access the currently matched character</source>
          <target state="translated">Доступ к текущему персонажу</target>
        </trans-unit>
        <trans-unit id="9e2f25bad75994a6d0402acd174ffe98487bb1e8" translate="yes" xml:space="preserve">
          <source>Access the i-th element of &lt;em&gt;deq&lt;/em&gt; and returns a mutable reference to it.</source>
          <target state="translated">Доступ к i-му элементу &lt;em&gt;deq&lt;/em&gt; и возврат изменяемой ссылки на него.</target>
        </trans-unit>
        <trans-unit id="b235504e101d141812cbd31b5736348cbd949d54" translate="yes" xml:space="preserve">
          <source>Access the i-th element of &lt;em&gt;deq&lt;/em&gt; by order from first to last. deq[0] is the first, deq[^1] is the last.</source>
          <target state="translated">Доступ к i-му элементу &lt;em&gt;deq&lt;/em&gt; по порядку от первого до последнего. deq [0] - первое, deq [^ 1] - последнее.</target>
        </trans-unit>
        <trans-unit id="c47d1e40dccddf8bf9622ec7b3c9e44c4af97584" translate="yes" xml:space="preserve">
          <source>Accumulator</source>
          <target state="translated">Accumulator</target>
        </trans-unit>
        <trans-unit id="737a162e2ca0961109be76dcbc40928b7272da0a" translate="yes" xml:space="preserve">
          <source>Acquires the given lock and then executes the code.</source>
          <target state="translated">Приобретает заданный замок и затем выполняет код.</target>
        </trans-unit>
        <trans-unit id="e94c5bb8f50ed78a7cd750db454d2af3ae23df56" translate="yes" xml:space="preserve">
          <source>Acquires the given lock, executes the statements in body and releases the lock after the statements finish executing.</source>
          <target state="translated">Приобретает заданный замок,выполняет задания в теле и отпускает замок после завершения выполнения заданий.</target>
        </trans-unit>
        <trans-unit id="1a3e3046bdb90198f8603411233d3c6451ca3f0a" translate="yes" xml:space="preserve">
          <source>Acquires the given lock.</source>
          <target state="translated">Приобретает данный замок.</target>
        </trans-unit>
        <trans-unit id="d2f9d48fe60d96f7c86fe92fea51a30eef86ea2a" translate="yes" xml:space="preserve">
          <source>Acts in a similar fashion to the &lt;em&gt;recvLine&lt;/em&gt; in the sockets module. Returns false when no data is available to be read. &lt;em&gt;Line&lt;/em&gt; must be initialized and not nil!</source>
          <target state="translated">Действует аналогично &lt;em&gt;recvLine&lt;/em&gt; в модуле сокетов. Возвращает false, если данные недоступны для чтения. &lt;em&gt;Строка&lt;/em&gt; должна быть инициализирована, а не нулем!</target>
        </trans-unit>
        <trans-unit id="b05779dfde7404de32c688c1c9a48959dd22bdd2" translate="yes" xml:space="preserve">
          <source>Add &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Добавьте &lt;em&gt;y&lt;/em&gt; к &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4feee750a058b68182288ba271fbda6845aca1fd" translate="yes" xml:space="preserve">
          <source>Add &lt;em&gt;y&lt;/em&gt; to the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Добавьте &lt;em&gt;y&lt;/em&gt; к комплексному числу &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c680f465bd9dc1e03f6e6d6ea7255c81ff7a44a5" translate="yes" xml:space="preserve">
          <source>Add a duration of time to a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">Добавьте продолжительность времени к &lt;code&gt;Time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0329e59f93f564c5dfc0e70569d15fb9e15a73e3" translate="yes" xml:space="preserve">
          <source>Add a file to the multipart data &lt;em&gt;p&lt;/em&gt;, specifying filename, contentType and content manually.</source>
          <target state="translated">Добавьте файл к составным данным &lt;em&gt;p&lt;/em&gt; , указав имя файла, contentType и контент вручную.</target>
        </trans-unit>
        <trans-unit id="eec5847211247b4fd74ccdc819e2406c975b05b5" translate="yes" xml:space="preserve">
          <source>Add a list of multipart entries to the multipart data &lt;em&gt;p&lt;/em&gt;. All values are added without a filename and without a content type.</source>
          <target state="translated">Добавить список составных записей к составным данным &lt;em&gt;стр&lt;/em&gt; . Все значения добавляются без имени файла и без типа содержимого.</target>
        </trans-unit>
        <trans-unit id="798a336ba2abb70a55f061577e20dced31fde63c" translate="yes" xml:space="preserve">
          <source>Add a multipart entry to the multipart data &lt;em&gt;p&lt;/em&gt;. The value is added without a filename and without a content type.</source>
          <target state="translated">Добавить составную запись к составным данным &lt;em&gt;стр&lt;/em&gt; . Значение добавляется без имени файла и без типа содержимого.</target>
        </trans-unit>
        <trans-unit id="f04550fc57e117bf8d9e7db6f83bdeafaba0d38d" translate="yes" xml:space="preserve">
          <source>Add a value to the multipart data. Raises a &lt;em&gt;ValueError&lt;/em&gt; exception if &lt;em&gt;name&lt;/em&gt;, &lt;em&gt;filename&lt;/em&gt; or &lt;em&gt;contentType&lt;/em&gt; contain newline characters.</source>
          <target state="translated">Добавьте значение к составным данным. Вызывает &lt;em&gt;ValueError&lt;/em&gt; исключение , если &lt;em&gt;имя&lt;/em&gt; , &lt;em&gt;имя файла&lt;/em&gt; или &lt;em&gt;CONTENTTYPE&lt;/em&gt; содержать символы новой строки.</target>
        </trans-unit>
        <trans-unit id="772b15743a6941c602fc6966a8c9ad76de348c4b" translate="yes" xml:space="preserve">
          <source>Add an &lt;em&gt;item&lt;/em&gt; to the beginning of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">Добавьте &lt;em&gt;элемент&lt;/em&gt; в начало &lt;em&gt;deq&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2f6d2bfa601515402b5cd9a27e6de27a42f1ae49" translate="yes" xml:space="preserve">
          <source>Add an &lt;em&gt;item&lt;/em&gt; to the end of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">Добавьте &lt;em&gt;элемент&lt;/em&gt; в конец &lt;em&gt;deq&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="804dca14340f9191ea44cbc9a5b612d3b7b60531" translate="yes" xml:space="preserve">
          <source>Add complex &lt;em&gt;x&lt;/em&gt; to float &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Добавьте комплексный &lt;em&gt;x&lt;/em&gt; к float &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="91af401e69eb5db85492da365b587bfdcdd3c94f" translate="yes" xml:space="preserve">
          <source>Add files to a multipart data object. The file will be opened from your disk, read and sent with the automatically determined MIME type. Raises an &lt;em&gt;IOError&lt;/em&gt; if the file cannot be opened or reading fails. To manually specify file content, filename and MIME type, use &lt;em&gt;[]=&lt;/em&gt; instead.</source>
          <target state="translated">Добавьте файлы в составной объект данных. Файл будет открыт с вашего диска, прочитан и отправлен с автоматически определенным типом MIME. Вызывает &lt;em&gt;ошибку IOError,&lt;/em&gt; если файл не открывается или чтение не удается. Чтобы вручную указать содержимое файла, имя файла и тип MIME, используйте вместо этого &lt;em&gt;[] =&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="406ccec3a46c7096b360cd3465737a8b535aea4c" translate="yes" xml:space="preserve">
          <source>Add float &lt;em&gt;x&lt;/em&gt; to complex &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Добавьте float &lt;em&gt;x&lt;/em&gt; к комплексному &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="505c6693913fe1565ef1c731c3ebc737609d4c48" translate="yes" xml:space="preserve">
          <source>Add ident to dest if it is not present. This is intended for use with pragmas.</source>
          <target state="translated">Добавьте ident к судьбе,если его нет.Предназначен для использования с прагмами.</target>
        </trans-unit>
        <trans-unit id="b50017805b1b6fc4f451182d9127fec897f8b761" translate="yes" xml:space="preserve">
          <source>Add int &lt;em&gt;x&lt;/em&gt; to rational &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Добавьте int &lt;em&gt;x&lt;/em&gt; к рациональному &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9fd52413273ba8dedf3c71352a83c577246c8699" translate="yes" xml:space="preserve">
          <source>Add int &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Добавьте int &lt;em&gt;y&lt;/em&gt; к рациональному &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f18a8ab635db264a0fe3a0922ec6560932edcddf" translate="yes" xml:space="preserve">
          <source>Add rational &lt;em&gt;x&lt;/em&gt; to int &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Добавьте рациональный &lt;em&gt;x&lt;/em&gt; к int &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2aa6c134ddb31344adb0018507fd22c268b0cb12" translate="yes" xml:space="preserve">
          <source>Add rational &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Добавьте рациональный &lt;em&gt;y&lt;/em&gt; к рациональному &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d1747c4bec3777bff15f92b0cac11995facbb754" translate="yes" xml:space="preserve">
          <source>Add two complex numbers.</source>
          <target state="translated">Добавьте два комплексных числа.</target>
        </trans-unit>
        <trans-unit id="10e886ac53c1940ea63eb1399092efb3e0175be5" translate="yes" xml:space="preserve">
          <source>Add two durations together.</source>
          <target state="translated">Добавьте две длительности вместе.</target>
        </trans-unit>
        <trans-unit id="918bdd0b6e0ab8c7e512d1c14637656e65c676d4" translate="yes" xml:space="preserve">
          <source>Add two rational numbers.</source>
          <target state="translated">Добавьте два рациональных числа.</target>
        </trans-unit>
        <trans-unit id="f9f4e2a4ee342e53c003797651594c460da995fd" translate="yes" xml:space="preserve">
          <source>Adding a method to a class the programmer has no control over is impossible or needs ugly workarounds.</source>
          <target state="translated">Добавление метода в класс,над которым программист не имеет контроля,невозможно или требует некрасивых обходных путей.</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">Дополнительные особенности</target>
        </trans-unit>
        <trans-unit id="050d53ae9db89d00328e7590301c21bc8b18552a" translate="yes" xml:space="preserve">
          <source>Additional compilation switches</source>
          <target state="translated">Дополнительные переключатели компиляции</target>
        </trans-unit>
        <trans-unit id="40896bd1d7fb4e2d2b859f8c06ae9aa5ebd3ac5f" translate="yes" xml:space="preserve">
          <source>Additional documentation about Nim's GC and how to operate it in a</source>
          <target state="translated">Дополнительная документация о ГК Ним и как им управлять в</target>
        </trans-unit>
        <trans-unit id="a15fa56393dfeea6e8ddbb0e0c2a6f3cc24b93de" translate="yes" xml:space="preserve">
          <source>Additional resources</source>
          <target state="translated">Дополнительные ресурсы</target>
        </trans-unit>
        <trans-unit id="683593bbc9f4d0095e1a329b2a170a4f6b64749a" translate="yes" xml:space="preserve">
          <source>Additionally adds the encosed text to the index as a term. Since we are interested in different instances of the same term to have different entries, a table is used to keep track of the amount of times a term has previously appeared to give a different identifier value for each.</source>
          <target state="translated">Дополнительно добавляет в индекс в виде термина вложенный текст.Поскольку нас интересуют разные экземпляры одного и того же термина,чтобы иметь разные записи,для каждого из них используется таблица,в которой отслеживается количество раз,когда ранее появился термин,и для каждого из них задается разное значение идентификатора.</target>
        </trans-unit>
        <trans-unit id="83025bdbec6a244fe913cb7d0ff67dac39e81e46" translate="yes" xml:space="preserve">
          <source>Additionally, you may pass a value along with the symbol: &lt;code&gt;-d:x=y&lt;/code&gt; which may be used in conjunction with the &lt;a href=&quot;manual#implementation-specific-pragmas-compile-time-define-pragmas&quot;&gt;compile time define pragmas&lt;/a&gt; to override symbols during build time.</source>
          <target state="translated">Кроме того, вы можете передать значение вместе с символом: &lt;code&gt;-d:x=y&lt;/code&gt; , который может использоваться в сочетании с &lt;a href=&quot;manual#implementation-specific-pragmas-compile-time-define-pragmas&quot;&gt;директивами определения времени компиляции&lt;/a&gt; для переопределения символов во время сборки.</target>
        </trans-unit>
        <trans-unit id="c9cc91072a9c61406bb688685c655da8fcf1e11e" translate="yes" xml:space="preserve">
          <source>Addr operator</source>
          <target state="translated">оператор Аддр</target>
        </trans-unit>
        <trans-unit id="e6513e72133cdea4324350e6d4ade50552f0fa2a" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;arg&lt;/code&gt; as a &lt;code&gt;Node&lt;/code&gt; to the &lt;code&gt;NList&lt;/code&gt; If a node with the same name is already present in this map, it is replaced by the new one.</source>
          <target state="translated">Добавляет &lt;code&gt;arg&lt;/code&gt; в качестве &lt;code&gt;Node&lt;/code&gt; в &lt;code&gt;NList&lt;/code&gt; . Если узел с таким же именем уже присутствует на этой карте, он заменяется новым.</target>
        </trans-unit>
        <trans-unit id="c0973ea96bcd93e616194aea6ada7ee253f95770" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;handler&lt;/code&gt; to the list of handlers.</source>
          <target state="translated">Добавляет &lt;code&gt;handler&lt;/code&gt; в список обработчиков.</target>
        </trans-unit>
        <trans-unit id="09af7b91c6e7df51cd37d298bdc37f650d040831" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;interval&lt;/code&gt; to &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are added in the order of their size, i.e first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="translated">Добавляет &lt;code&gt;interval&lt;/code&gt; к &lt;code&gt;dt&lt;/code&gt; . Компоненты из &lt;code&gt;interval&lt;/code&gt; добавляются в порядке их размера, то есть сначала компонент &lt;code&gt;years&lt;/code&gt; , затем компонент &lt;code&gt;months&lt;/code&gt; и так далее. Возвращенный &lt;code&gt;DateTime&lt;/code&gt; будет иметь тот же часовой пояс, что и вход.</target>
        </trans-unit>
        <trans-unit id="b3703e66f4731d1cd49994e51655ed816fcd0462" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;mimetype&lt;/code&gt; to the &lt;code&gt;mimedb&lt;/code&gt;.</source>
          <target state="translated">Добавляет &lt;code&gt;mimetype&lt;/code&gt; к &lt;code&gt;mimedb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d55bd8510c4909907c3b0b1b51f22ef8bfe1dc23" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is not yet initalized; in that case, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">Добавляет &lt;code&gt;y&lt;/code&gt; к &lt;code&gt;x&lt;/code&gt; , если &lt;code&gt;x&lt;/code&gt; еще не инициализирован; в этом случае &lt;code&gt;x&lt;/code&gt; становится &lt;code&gt;y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08dd7691271b1b3cf31cdaad9abf0dd1ed892c5b" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is not yet initialized; in that case, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;@[y]&lt;/code&gt;</source>
          <target state="translated">Добавляет &lt;code&gt;y&lt;/code&gt; к &lt;code&gt;x&lt;/code&gt; , если &lt;code&gt;x&lt;/code&gt; еще не инициализирован; в этом случае &lt;code&gt;x&lt;/code&gt; становится &lt;code&gt;@[y]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="910ee17a6a799e67a937708e73b9aedb33f3b0aa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; it is initialized to &lt;code&gt;&quot;&quot;&lt;/code&gt;</source>
          <target state="translated">Добавляет &lt;code&gt;y&lt;/code&gt; к &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;nil&lt;/code&gt; он инициализируется как &lt;code&gt;&quot;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4d013d42946fcbe3af0f01b7362386e1eb7f928" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;child&lt;/em&gt; to a JArray node &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">Добавляет &lt;em&gt;ребенка&lt;/em&gt; к узлу JArray &lt;em&gt;отца&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="277d7264e0b31954fb3f91658c21ef53fbc9f98b" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;child&lt;/em&gt; to a SList node &lt;em&gt;father&lt;/em&gt;.</source>
          <target state="translated">Добавляет &lt;em&gt;потомка&lt;/em&gt; к &lt;em&gt;отцу&lt;/em&gt; узла SList .</target>
        </trans-unit>
        <trans-unit id="282a03494ac60232eca16c10011aa2a3e77244c0" translate="yes" xml:space="preserve">
          <source>Adds &lt;em&gt;interval&lt;/em&gt; to &lt;em&gt;time&lt;/em&gt;. If &lt;em&gt;interval&lt;/em&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="translated">Добавляет &lt;em&gt;интервал&lt;/em&gt; в &lt;em&gt;время&lt;/em&gt; . Если &lt;em&gt;интервал&lt;/em&gt; содержит какие-либо годы, месяцы, недели или дни, операция выполняется в местном часовом поясе.</target>
        </trans-unit>
        <trans-unit id="168959e8e3da827112e6480f035af90769452610" translate="yes" xml:space="preserve">
          <source>Adds a &lt;em&gt;term&lt;/em&gt; to the index using the specified hyperlink identifier.</source>
          <target state="translated">Добавляет &lt;em&gt;термин&lt;/em&gt; в индекс, используя указанный идентификатор гиперссылки.</target>
        </trans-unit>
        <trans-unit id="46517870669c98767730789efc1c2a63afe0fd37" translate="yes" xml:space="preserve">
          <source>Adds a char to string &lt;em&gt;s&lt;/em&gt; and applies the following escaping:</source>
          <target state="translated">Добавляет символ в строку &lt;em&gt;s&lt;/em&gt; и применяет следующее экранирование:</target>
        </trans-unit>
        <trans-unit id="1f8aac4240d0d2f3105af4d844dbcb2abbdecf97" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node, if an attribute with the localName and namespaceURI of &lt;code&gt;newAttr&lt;/code&gt; is present, it is replaced by the new one and the replaced attribute is returned, otherwise &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Добавляет новый узел атрибута, если присутствует атрибут с localName и namespaceURI &lt;code&gt;newAttr&lt;/code&gt; , он заменяется новым и возвращается замененный атрибут, в противном случае возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49966f2ea34f557267d410935160fd5454f498db" translate="yes" xml:space="preserve">
          <source>Adds a new attribute node, if an attribute with the same &lt;em&gt;nodeName&lt;/em&gt; is present, it is replaced by the new one and the replaced attribute is returned, otherwise &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Добавляет новый узел атрибута, если присутствует атрибут с тем же &lt;em&gt;именем nodeName&lt;/em&gt; , он заменяется новым и возвращается замененный атрибут, в противном случае возвращается &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d941c7f90a962f0302be00a817bf48658be8c09" translate="yes" xml:space="preserve">
          <source>Adds a new attribute, as specified by &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; If an attribute with that name is already present in the element, its value is changed to be that of the value parameter Raises the EInvalidCharacterErr if the specified &lt;code&gt;name&lt;/code&gt; contains illegal characters</source>
          <target state="translated">Добавляет новый атрибут, как указано в &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;value&lt;/code&gt; Если атрибут с таким именем уже присутствует в элементе, его значение изменяется на значение параметра значения. Поднимает EInvalidCharacterErr, если указанное &lt;code&gt;name&lt;/code&gt; содержит недопустимые символы.</target>
        </trans-unit>
        <trans-unit id="70b9921234cbd8dc467e865419512e1db5aa80e1" translate="yes" xml:space="preserve">
          <source>Adds a new attribute, as specified by &lt;code&gt;namespaceURI&lt;/code&gt;, &lt;code&gt;localName&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Добавляет новый атрибут, указанный в &lt;code&gt;namespaceURI&lt;/code&gt; , &lt;code&gt;localName&lt;/code&gt; и &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="175780a3fa3d64a9dc7aa37e3d80ca0adc76b294" translate="yes" xml:space="preserve">
          <source>Adds a node using its &lt;code&gt;namespaceURI&lt;/code&gt; and &lt;code&gt;localName&lt;/code&gt;</source>
          <target state="translated">Добавляет узел, используя его &lt;code&gt;namespaceURI&lt;/code&gt; и &lt;code&gt;localName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71b9366e5b895a616623ffad66668f7f54484c12" translate="yes" xml:space="preserve">
          <source>Adds a separator to &lt;em&gt;dest&lt;/em&gt; only if its length is bigger than &lt;em&gt;startLen&lt;/em&gt;.</source>
          <target state="translated">Добавляет разделитель в &lt;em&gt;dest,&lt;/em&gt; только если его длина больше &lt;em&gt;startLen&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="719fea5dd090dc5f35241a78b628149a3f6e753c" translate="yes" xml:space="preserve">
          <source>Adds each child of &lt;em&gt;children&lt;/em&gt; to the &lt;em&gt;father&lt;/em&gt; node. Returns the &lt;em&gt;father&lt;/em&gt; node so that calls can be nested.</source>
          <target state="translated">Добавляет каждый ребенок &lt;em&gt;детей&lt;/em&gt; к &lt;em&gt;отцу&lt;/em&gt; узла. Возвращает &lt;em&gt;родительский&lt;/em&gt; узел, чтобы вызовы могли быть вложенными.</target>
        </trans-unit>
        <trans-unit id="77594e2b861c1fa8f8e68498df51e03371d37a9b" translate="yes" xml:space="preserve">
          <source>Adds pragma to routine definition</source>
          <target state="translated">Добавляет прагматизма к определению рутины</target>
        </trans-unit>
        <trans-unit id="392b56977e8236b6698f4ca58ac6c2f28d25c68f" translate="yes" xml:space="preserve">
          <source>Adds the &lt;em&gt;child&lt;/em&gt; to the &lt;em&gt;father&lt;/em&gt; node. Returns the father node so that calls can be nested.</source>
          <target state="translated">Добавляет &lt;em&gt;дочерний&lt;/em&gt; элемент к &lt;em&gt;родительскому&lt;/em&gt; узлу. Возвращает родительский узел, чтобы вызовы могли быть вложенными.</target>
        </trans-unit>
        <trans-unit id="4be1f166b02d308f1b99389ad08b9ecee806fca1" translate="yes" xml:space="preserve">
          <source>Adds the callbacks proc to be called when the future completes.</source>
          <target state="translated">Добавляет отсрочку обратного вызова,которая будет вызвана по окончании работы в будущем.</target>
        </trans-unit>
        <trans-unit id="087cbeb9fcc85f71b469524d8a7510230c6f6abc" translate="yes" xml:space="preserve">
          <source>Adds the file extension &lt;em&gt;ext&lt;/em&gt; to &lt;em&gt;filename&lt;/em&gt;, unless &lt;em&gt;filename&lt;/em&gt; already has an extension.</source>
          <target state="translated">Добавляет расширение файла &lt;em&gt;ext&lt;/em&gt; к &lt;em&gt;имени файла&lt;/em&gt; , если &lt;em&gt;имя файла&lt;/em&gt; уже не имеет расширения.</target>
        </trans-unit>
        <trans-unit id="38e43d237023eab5acc2b848d42530e464a0a37f" translate="yes" xml:space="preserve">
          <source>Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed.</source>
          <target state="translated">Добавляет узел newChild в конец списка дочерних элементов этого узла.Если newChild уже находится в дереве,то он сначала удаляется.</target>
        </trans-unit>
        <trans-unit id="2a72a2ff357c75992d2d25db54f40e31c444189e" translate="yes" xml:space="preserve">
          <source>Adds the specified value to the specified key. Appends to any existing values associated with the key.</source>
          <target state="translated">Добавляет указанное значение к указанному ключу.Добавляет к любым существующим значениям,связанным с ключом.</target>
        </trans-unit>
        <trans-unit id="dcb76173f8b3f736f04cf7a85a76442e3061c9f2" translate="yes" xml:space="preserve">
          <source>Adds two &lt;code&gt;TimeInterval&lt;/code&gt; objects together.</source>
          <target state="translated">Добавляет два объекта &lt;code&gt;TimeInterval&lt;/code&gt; вместе.</target>
        </trans-unit>
        <trans-unit id="0cd028f03aa8100d6b3d714eae3d5348fe823a2f" translate="yes" xml:space="preserve">
          <source>Adds/registers a quit procedure.</source>
          <target state="translated">Добавляет/регистрирует процедуру увольнения.</target>
        </trans-unit>
        <trans-unit id="5090ef07df2944062324712ca6950298e056c7f1" translate="yes" xml:space="preserve">
          <source>Adopting type for gui inspector in a game engine:</source>
          <target state="translated">Принятие типа для гуи-инспектора в игровом движке:</target>
        </trans-unit>
        <trans-unit id="cd58779782de2792380285200da5a98425f86d02" translate="yes" xml:space="preserve">
          <source>Advanced command line switches are:</source>
          <target state="translated">Расширенные переключатели командной строки:</target>
        </trans-unit>
        <trans-unit id="7a3a43835953e413f721f837036117df744dbd00" translate="yes" xml:space="preserve">
          <source>Advanced commands:</source>
          <target state="translated">Расширенные команды:</target>
        </trans-unit>
        <trans-unit id="21604196a5b5f020863aebeb14786b98a2ec02e1" translate="yes" xml:space="preserve">
          <source>Advanced options:</source>
          <target state="translated">Дополнительные опции:</target>
        </trans-unit>
        <trans-unit id="f1c748b61ceca05da788dea58f761592f09389bc" translate="yes" xml:space="preserve">
          <source>Advanced types</source>
          <target state="translated">Расширенные виды</target>
        </trans-unit>
        <trans-unit id="4eaa54faaeebcdcf16ca6cecc39180523a7c29ea" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;\0&lt;/code&gt; up to two further octal digits are read. In both cases, if there are fewer than two digits, just those that are present are used. Thus the sequence &lt;code&gt;\0\x\07&lt;/code&gt; specifies two binary zeros followed by a BEL character (code value 7). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</source>
          <target state="translated">После &lt;code&gt;\0&lt;/code&gt; читаются еще до двух восьмеричных цифр. В обоих случаях, если количество цифр меньше двух, используются только те, которые присутствуют. Таким образом, последовательность &lt;code&gt;\0\x\07&lt;/code&gt; определяет два двоичных нуля, за которыми следует символ BEL (кодовое значение 7). Убедитесь, что вы указали две цифры после начального нуля, если следующий за ним символ шаблона является восьмеричной цифрой.</target>
        </trans-unit>
        <trans-unit id="c71390a639ed6627641b3cfd1f9a329a5cc9c625" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;\x&lt;/code&gt;, from zero to two hexadecimal digits are read (letters can be in upper or lower case). In UTF-8 mode, any number of hexadecimal digits may appear between &lt;code&gt;\x{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, but the value of the character code must be less than 2**31 (that is, the maximum hexadecimal value is 7FFFFFFF). If characters other than hexadecimal digits appear between &lt;code&gt;\x{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, or if there is no terminating &lt;code&gt;}&lt;/code&gt;, this form of escape is not recognized. Instead, the initial &lt;code&gt;\x&lt;/code&gt; will be interpreted as a basic hexadecimal escape, with no following digits, giving a character whose value is zero.</source>
          <target state="translated">После &lt;code&gt;\x&lt;/code&gt; читаются от нуля до двух шестнадцатеричных цифр (буквы могут быть в верхнем или нижнем регистре). В режиме UTF-8 между &lt;code&gt;\x{&lt;/code&gt; и &lt;code&gt;}&lt;/code&gt; может отображаться любое количество шестнадцатеричных цифр , но значение символьного кода должно быть меньше 2 ** 31 (то есть максимальное шестнадцатеричное значение - 7FFFFFFF). Если между &lt;code&gt;\x{&lt;/code&gt; и &lt;code&gt;}&lt;/code&gt; появляются символы, отличные от шестнадцатеричных цифр , или если нет конца &lt;code&gt;}&lt;/code&gt; , эта форма escape не распознается. Вместо этого начальный &lt;code&gt;\x&lt;/code&gt; будет интерпретироваться как базовый шестнадцатеричный escape-код без следующих цифр, что дает символ, значение которого равно нулю.</target>
        </trans-unit>
        <trans-unit id="622cf30c89947b71767229b80f2f6c86dfa76768" translate="yes" xml:space="preserve">
          <source>After a connection is made you can use the &lt;code&gt;store&lt;/code&gt; procedure to upload a new file to the FTP server. Make sure to check you are in the correct working directory before you do so with the &lt;code&gt;pwd&lt;/code&gt; procedure, you can also instead specify an absolute path.</source>
          <target state="translated">После установления соединения вы можете использовать процедуру &lt;code&gt;store&lt;/code&gt; для загрузки нового файла на FTP-сервер. Убедитесь, что вы находитесь в правильном рабочем каталоге, прежде чем делать это с помощью процедуры &lt;code&gt;pwd&lt;/code&gt; , вместо этого вы также можете указать абсолютный путь.</target>
        </trans-unit>
        <trans-unit id="f73d43ab167cd4ac21b418e91451904852662e79" translate="yes" xml:space="preserve">
          <source>After compilation is finished you will hopefully end up with the nim compiler in the &lt;code&gt;bin&lt;/code&gt; directory. You can add Nim's &lt;code&gt;bin&lt;/code&gt; directory to your &lt;code&gt;$PATH&lt;/code&gt; or use the &lt;a href=&quot;#install-command&quot;&gt;install command&lt;/a&gt; to place it where it will be found.</source>
          <target state="translated">Надеемся, что после завершения компиляции вы получите компилятор nim в каталоге &lt;code&gt;bin&lt;/code&gt; . Вы можете добавить каталог &lt;code&gt;bin&lt;/code&gt; Nim в свой &lt;code&gt;$PATH&lt;/code&gt; или использовать команду &lt;a href=&quot;#install-command&quot;&gt;установки,&lt;/a&gt; чтобы разместить его там, где он будет находиться.</target>
        </trans-unit>
        <trans-unit id="7e10a07a137ad912e35e4faef7ca70acb747eef5" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;from&lt;/code&gt; statement a module name follows followed by an &lt;code&gt;import&lt;/code&gt; to list the symbols one likes to use without explicit full qualification:</source>
          <target state="translated">После оператора &lt;code&gt;from&lt;/code&gt; следует имя модуля, за которым следует &lt;code&gt;import&lt;/code&gt; для перечисления символов, которые вам нравятся, без явной полной квалификации:</target>
        </trans-unit>
        <trans-unit id="4f797b80df1f8d64852f55b778851d191514b53d" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;import&lt;/code&gt; statement a list of module names can follow or a single module name followed by an &lt;code&gt;except&lt;/code&gt; list to prevent some symbols to be imported:</source>
          <target state="translated">После оператора &lt;code&gt;import&lt;/code&gt; может следовать список имен модулей или одно имя модуля, за которым следует список &lt;code&gt;except&lt;/code&gt; чтобы предотвратить импорт некоторых символов:</target>
        </trans-unit>
        <trans-unit id="ee8f6842719daac0ef2d06cdb2e7fa5bd3d11c84" translate="yes" xml:space="preserve">
          <source>After the execution of &lt;code&gt;handleRequest&lt;/code&gt; the client socket will be closed automatically unless it has already been closed.</source>
          <target state="translated">После выполнения &lt;code&gt;handleRequest&lt;/code&gt; клиентский сокет будет закрыт автоматически, если он еще не был закрыт.</target>
        </trans-unit>
        <trans-unit id="cf6dcadff9cc79e46d3555b76c916fb3ed022d34" translate="yes" xml:space="preserve">
          <source>After you add &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; for your custom type everything will work. Currently however &lt;code&gt;hash&lt;/code&gt; for objects is not defined, whereas &lt;code&gt;system.==&lt;/code&gt; for objects does exist and performs a &quot;deep&quot; comparison (every field is compared) which is usually what you want. So in the following example implementing only &lt;code&gt;hash&lt;/code&gt; suffices:</source>
          <target state="translated">После того, как вы добавите &lt;code&gt;hash&lt;/code&gt; и &lt;code&gt;==&lt;/code&gt; для вашего пользовательского типа, все будет работать. Однако в настоящее время &lt;code&gt;hash&lt;/code&gt; для объектов не определен, тогда как &lt;code&gt;system.==&lt;/code&gt; для объектов существует и выполняет &amp;laquo;глубокое&amp;raquo; сравнение (сравнивается каждое поле), что обычно является тем, что вы хотите. Итак, в следующем примере достаточно реализации только &lt;code&gt;hash&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c3ae9a42c0ef5d71d82ed6ff94ea44fa57d69eaa" translate="yes" xml:space="preserve">
          <source>After you create a socket with the &lt;code&gt;newSocket&lt;/code&gt; procedure, you can create a TCP server by calling the &lt;code&gt;bindAddr&lt;/code&gt; and &lt;code&gt;listen&lt;/code&gt; procedures.</source>
          <target state="translated">После создания сокета с &lt;code&gt;newSocket&lt;/code&gt; процедуры newSocket вы можете создать TCP-сервер, вызвав процедуры &lt;code&gt;bindAddr&lt;/code&gt; и &lt;code&gt;listen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19f5c4359047c1c4029762b09cefac6ce55773f8" translate="yes" xml:space="preserve">
          <source>After you create a socket with the &lt;code&gt;newSocket&lt;/code&gt; procedure, you can easily connect it to a server running at a known hostname (or IP address) and port. To do so over TCP, use the example below.</source>
          <target state="translated">После создания сокета с &lt;code&gt;newSocket&lt;/code&gt; процедуры newSocket вы можете легко подключить его к серверу, работающему с известным именем хоста (или IP-адресом) и портом. Чтобы сделать это через TCP, используйте пример ниже.</target>
        </trans-unit>
        <trans-unit id="5458c4cb0f05f3f6ed419b885d419d370bdf563e" translate="yes" xml:space="preserve">
          <source>Again, if you are wrapping a library which &lt;em&gt;mallocs&lt;/em&gt; and &lt;em&gt;frees&lt;/em&gt; data structures, you need to expose the appropriate &lt;em&gt;free&lt;/em&gt; function to Nim so you can clean it up. And of course, once cleaned you should avoid accessing it from Nim (or C for that matter). Typically C data structures have their own &lt;code&gt;malloc_structure&lt;/code&gt; and &lt;code&gt;free_structure&lt;/code&gt; specific functions, so wrapping these for the Nim side should be enough.</source>
          <target state="translated">Опять же, если вы обертываете библиотеку, которая &lt;em&gt;делает блокировку&lt;/em&gt; и &lt;em&gt;освобождает&lt;/em&gt; структуры данных, вам нужно предоставить Ниму соответствующую &lt;em&gt;бесплатную&lt;/em&gt; функцию, чтобы вы могли очистить ее. И, конечно же, после очистки вам следует избегать доступа к нему из Nim (или C, если на то пошло). Обычно структуры данных C имеют свои собственные функции, специфичные для &lt;code&gt;malloc_structure&lt;/code&gt; и &lt;code&gt;free_structure&lt;/code&gt; , поэтому их обертывания для стороны Nim должно быть достаточно.</target>
        </trans-unit>
        <trans-unit id="2def8d1f86d78a731890a66e16deb2b5e1ea4254" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#difference&quot;&gt;difference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Псевдоним для &lt;a href=&quot;#difference&quot;&gt;разницы (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a02e1746a71e7fb0864cabf7b39376b3a63a1f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#intersection&quot;&gt;intersection(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Псевдоним &lt;a href=&quot;#intersection&quot;&gt;перекрестка (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2391f38322eb20263936b3bfa8fc3471e6b69b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">Псевдоним для &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d86fe62b7538063ec7bfae9f6c08a83088df2cff" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">Псевдоним для &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41b739a23c6fc05ac36095d9dd959eb84d6a5a1f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#symmetricDifference&quot;&gt;symmetricDifference(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Псевдоним для &lt;a href=&quot;#symmetricDifference&quot;&gt;symricDifference (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3db9334116c6d200d159599181aa97f7e9eee70" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#union&quot;&gt;union(s1, s2)&lt;/a&gt;.</source>
          <target state="translated">Псевдоним для &lt;a href=&quot;#union&quot;&gt;union (s1, s2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b5be6f17bdfd8cbcd14d0c4aa54788e9e3d34a0" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;none(T)&lt;/code&gt;.</source>
          <target state="translated">Псевдоним &lt;code&gt;none(T)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="880b74f9b1a7d4cf4585f8c8f387bcb20192549a" translate="yes" xml:space="preserve">
          <source>Alias for for countSetBits (Hamming weight.)</source>
          <target state="translated">Псевдоним для CountSetBits (Вес Хамминга).</target>
        </trans-unit>
        <trans-unit id="2feaf49576ccc73f2b86d27faa6075fa943090f4" translate="yes" xml:space="preserve">
          <source>Aligns &lt;code&gt;s&lt;/code&gt; using &lt;code&gt;fill&lt;/code&gt; char. This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers.</source>
          <target state="translated">Выравнивает &lt;code&gt;s&lt;/code&gt; с помощью &lt;code&gt;fill&lt;/code&gt; char. Это интересно только в том случае, если вы хотите написать процедуру настраиваемого &lt;code&gt;format&lt;/code&gt; которая должна поддерживать спецификаторы стандартного формата.</target>
        </trans-unit>
        <trans-unit id="4a373b51ddb20415acc6f2cab49e7a886d4418f7" translate="yes" xml:space="preserve">
          <source>Aligns a string &lt;em&gt;s&lt;/em&gt; with &lt;em&gt;padding&lt;/em&gt;, so that it is of length &lt;em&gt;count&lt;/em&gt;.</source>
          <target state="translated">Выравнивает строку &lt;em&gt;s&lt;/em&gt; с &lt;em&gt;заполнением&lt;/em&gt; так, чтобы длина была &lt;em&gt;count&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="18f77fc6c5026c1d2d103f3b97daf7c1dbd054f5" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;db_*&lt;/code&gt; modules support the same form of parameter substitution. That is, using the &lt;code&gt;?&lt;/code&gt; (question mark) to signify the place where a value should be placed. For example:</source>
          <target state="translated">Все модули &lt;code&gt;db_*&lt;/code&gt; поддерживают одну и ту же форму подстановки параметров. То есть с помощью &lt;code&gt;?&lt;/code&gt; (вопросительный знак), чтобы обозначить место, где должно быть помещено значение. Например:</target>
        </trans-unit>
        <trans-unit id="9552063c6dac2a0b2b6f80dd47ebd5c82800945e" translate="yes" xml:space="preserve">
          <source>All Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported. Any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of platform.</source>
          <target state="translated">Все исходные файлы Nim находятся в кодировке UTF-8 (или его подмножество ASCII).Другие кодировки не поддерживаются.Можно использовать любую из стандартных платформенных последовательностей завершения строк-Unix-форму с использованием ASCII LF (linefeed),Windows-форму с использованием ASCII последовательности CR LF (return,за которой следует linefeed),или старую Macintosh-форму с использованием ASCII CR (return)символа.Все эти формы могут использоваться одинаково,независимо от платформы.</target>
        </trans-unit>
        <trans-unit id="2c0abd1c94e3986f0fc217d43c9ce2e325e352e8" translate="yes" xml:space="preserve">
          <source>All asynchronous functions returning a &lt;code&gt;Future&lt;/code&gt; will not block. They will not however return immediately. An asynchronous function will have code which will be executed before an asynchronous request is made, in most cases this code sets up the request.</source>
          <target state="translated">Все асинхронные функции, возвращающие &lt;code&gt;Future&lt;/code&gt; , не будут блокироваться. Однако они не вернутся немедленно. Асинхронная функция будет иметь код, который будет выполняться перед выполнением асинхронного запроса, в большинстве случаев этот код устанавливает запрос.</target>
        </trans-unit>
        <trans-unit id="987c15958bc12d3f55c911e8dc5fec4777c6bc5e" translate="yes" xml:space="preserve">
          <source>All expressions have a type which is known at compile time. Nim is statically typed. One can declare new types, which is in essence defining an identifier that can be used to denote this custom type.</source>
          <target state="translated">Все выражения имеют тип,известный во время компиляции.Ним статически набран.Можно объявить новые типы,что по сути определяет идентификатор,который может быть использован для обозначения этого пользовательского типа.</target>
        </trans-unit>
        <trans-unit id="f984cab28f61b914c2bd533b03fae6756c4294ad" translate="yes" xml:space="preserve">
          <source>All identifiers of a module are valid from the point of declaration until the end of the module. Identifiers from indirectly dependent modules are &lt;em&gt;not&lt;/em&gt; available. The &lt;span id=&quot;system_1&quot;&gt;system&lt;/span&gt; module is automatically imported in every module.</source>
          <target state="translated">Все идентификаторы модуля действительны с момента объявления до конца модуля. Идентификаторы от косвенно зависимых модулей &lt;em&gt;не&lt;/em&gt; доступны. &lt;span id=&quot;system_1&quot;&gt;Система&lt;/span&gt; модуля автоматически импортируется в каждом модуле.</target>
        </trans-unit>
        <trans-unit id="cded9aa9ab6801c06f94e1f6e9e5425ed01952a5" translate="yes" xml:space="preserve">
          <source>All of the available idetools commands require you to specify a query location through the &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--trackDirty&lt;/code&gt; switches. The general idetools invocations are:</source>
          <target state="translated">Все доступные команды idetools требуют, чтобы вы указали местоположение запроса с &lt;code&gt;--trackDirty&lt;/code&gt; переключателей &lt;code&gt;--track&lt;/code&gt; или --trackDirty . Общие вызовы idetools:</target>
        </trans-unit>
        <trans-unit id="96cbbecb3e99c48c7b4fe7081d99be9e034325bf" translate="yes" xml:space="preserve">
          <source>All string literals are of the type &lt;code&gt;string&lt;/code&gt;. A string in Nim is very similar to a sequence of characters. However, strings in Nim are both zero-terminated and have a length field. One can retrieve the length with the builtin &lt;code&gt;len&lt;/code&gt; procedure; the length never counts the terminating zero.</source>
          <target state="translated">Все строковые литералы относятся к &lt;code&gt;string&lt;/code&gt; типу . Строка в Ниме очень похожа на последовательность символов. Однако строки в Nim оканчиваются нулем и имеют поле длины. Длину можно получить с помощью встроенной процедуры &lt;code&gt;len&lt;/code&gt; ; длина никогда не учитывает завершающий ноль.</target>
        </trans-unit>
        <trans-unit id="c6b1a1f14d43339564b33e2a129f631ca1f3956e" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;tests/caas/*.txt&lt;/code&gt; files encode a session with the compiler:</source>
          <target state="translated">Все файлы &lt;code&gt;tests/caas/*.txt&lt;/code&gt; кодируют сеанс с компилятором:</target>
        </trans-unit>
        <trans-unit id="d7d265f3de6bf8deede109e19dc230beea86f266" translate="yes" xml:space="preserve">
          <source>All the characters that count as whitespace.</source>
          <target state="translated">Все символы,которые считаются пробелами.</target>
        </trans-unit>
        <trans-unit id="0858ffb5249b4b454db4fc31e3311bb8f257c071" translate="yes" xml:space="preserve">
          <source>All the comparison operators can be used with enumeration types.</source>
          <target state="translated">Все операторы сравнения могут использоваться с типами перечислений.</target>
        </trans-unit>
        <trans-unit id="6c891dcf4573456ce1e2da5262b50d0a08307027" translate="yes" xml:space="preserve">
          <source>All the operations have to perform efficiently. Because a Cellset can become huge a hash table alone is not suitable for this.</source>
          <target state="translated">Все операции должны выполняться эффективно.Потому что ячейка может стать огромным гашиш-столиком сама по себе не подходит для этого.</target>
        </trans-unit>
        <trans-unit id="d7919c15f302a782639503db1ddcfd789a925698" translate="yes" xml:space="preserve">
          <source>All the sequences that define a single byte value or a single UTF-8 character (in UTF-8 mode) can be used both inside and outside character classes. In addition, inside a character class, the sequence &lt;code&gt;\b&lt;/code&gt; is interpreted as the backspace character (hex 08), and the sequence &lt;code&gt;\X&lt;/code&gt; is interpreted as the character &quot;X&quot;. Outside a character class, these sequences have different meanings (see below).</source>
          <target state="translated">Все последовательности, определяющие однобайтовое значение или одиночный символ UTF-8 (в режиме UTF-8), могут использоваться как внутри, так и за пределами классов символов. Кроме того, внутри класса символов последовательность &lt;code&gt;\b&lt;/code&gt; интерпретируется как символ обратного пробела (шестнадцатеричный код 08), а последовательность &lt;code&gt;\X&lt;/code&gt; интерпретируется как символ &amp;laquo;X&amp;raquo;. Вне класса символов эти последовательности имеют разные значения (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="169951f4b6d1d7f1a4b31b9a082c85cf7bcb2136" translate="yes" xml:space="preserve">
          <source>All top level constants or types appearing within the concept body are accessible through the dot operator in procs where the concept was successfully matched to a concrete type:</source>
          <target state="translated">Доступ ко всем константам верхнего уровня или типам,находящимся в корпусе концепта,осуществляется через точечный оператор в профилях,где концепт был успешно согласован с конкретным типом:</target>
        </trans-unit>
        <trans-unit id="3c975cb1e2ba6e75d38b206700dca326fdb354fc" translate="yes" xml:space="preserve">
          <source>All types for that &lt;code&gt;nil&lt;/code&gt; is a valid value can be annotated to exclude &lt;code&gt;nil&lt;/code&gt; as a valid value with the &lt;code&gt;not nil&lt;/code&gt; annotation:</source>
          <target state="translated">Все типы для того, что &lt;code&gt;nil&lt;/code&gt; является допустимым значением, могут быть аннотированы, чтобы исключить &lt;code&gt;nil&lt;/code&gt; как допустимое значение с аннотацией &lt;code&gt;not nil&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="029f6357cfa5fa54f588a79c60e26072ee6dc04a" translate="yes" xml:space="preserve">
          <source>Also, you won't find raw &lt;code&gt;\n&lt;/code&gt; characters breaking the one answer per line format. Instead you will need to parse sequences in the form &lt;code&gt;\xHH&lt;/code&gt;, where &lt;em&gt;HH&lt;/em&gt; is a hexadecimal value (e.g. newlines generate the sequence &lt;code&gt;\x0A&lt;/code&gt;).</source>
          <target state="translated">Кроме того, вы не найдете необработанных символов &lt;code&gt;\n&lt;/code&gt; нарушающих формат одного ответа на строку. Вместо этого вам нужно будет анализировать последовательности в форме &lt;code&gt;\xHH&lt;/code&gt; , где &lt;em&gt;HH&lt;/em&gt; - шестнадцатеричное значение (например, &lt;code&gt;\x0A&lt;/code&gt; строки генерируют последовательность \ x0A ).</target>
        </trans-unit>
        <trans-unit id="4521b364cb9ce19f839632eb99d99bb31f52f57b" translate="yes" xml:space="preserve">
          <source>Alternate version of the above.</source>
          <target state="translated">Альтернативная версия.</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="24a6f9561b6fb31bcce22dd9eefb7cb23c8efb12" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;distinct&lt;/code&gt; type modifier can be applied to the type class to allow each param matching the type class to bind to a different type. Such type classes are called &lt;span id=&quot;bind-many_1&quot;&gt;bind many&lt;/span&gt; types.</source>
          <target state="translated">В качестве альтернативы модификатор &lt;code&gt;distinct&lt;/code&gt; типа может быть применен к классу типа, чтобы позволить каждому параметру, соответствующему классу типа, связываться с другим типом. Такие классы типов называются &lt;span id=&quot;bind-many_1&quot;&gt;связывающими многие&lt;/span&gt; типы.</target>
        </trans-unit>
        <trans-unit id="c5c9b8d75bae0a4e7883c1afe39fba029a2a402f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;em&gt;type&lt;/em&gt; operator can be used over the proc params for similar effect when anonymous or distinct type classes are used.</source>
          <target state="translated">В качестве альтернативы оператор &lt;em&gt;типа&lt;/em&gt; может использоваться в параметрах proc для аналогичного эффекта при использовании анонимных или отдельных классов типов.</target>
        </trans-unit>
        <trans-unit id="5b30b701e37924ad0c27b052555995c52f8814d1" translate="yes" xml:space="preserve">
          <source>Although Nim supports a variety of code and formatting styles, it is nevertheless beneficial that certain community efforts, such as the standard library, should follow a consistent set of style guidelines when suitable. This enhancement proposal aims to list a series of guidelines that the standard library should follow.</source>
          <target state="translated">Несмотря на то,что Nim поддерживает различные стили кода и форматирования,тем не менее,полезно,чтобы определенные усилия сообщества,такие как стандартная библиотека,следовали последовательному набору рекомендаций по стилям,когда это уместно.Это предложение по улучшению направлено на перечисление ряда руководящих принципов,которым должна следовать стандартная библиотека.</target>
        </trans-unit>
        <trans-unit id="e818f14ba9bbedb672b0a658dcc233bb37218e4d" translate="yes" xml:space="preserve">
          <source>Although the types use nanosecond time resolution, the underlying resolution used by &lt;code&gt;getTime()&lt;/code&gt; depends on the platform and backend (JS is limited to millisecond precision).</source>
          <target state="translated">Хотя типы используют наносекундное временное разрешение, базовое разрешение, используемое &lt;code&gt;getTime()&lt;/code&gt; зависит от платформы и серверной части (JS ограничивается точностью до миллисекунды).</target>
        </trans-unit>
        <trans-unit id="d3c0c9ff9b3e9a28a9649fc31261da1cd44edd57" translate="yes" xml:space="preserve">
          <source>Although use of whitespace for stylistic reasons other than the ones endorsed by this guide are allowed, careful thought should be put into such practices. Not all editors support automatic alignment of code sections, and re-aligning long sections of code by hand can quickly become tedious.</source>
          <target state="translated">Хотя использование пробела по стилистическим причинам,отличным от одобренных в данном руководстве,разрешено,следует тщательно продумать такую практику.Не все редакторы поддерживают автоматическое выравнивание секций кода,и повторное выравнивание длинных секций кода вручную может быстро стать утомительным.</target>
        </trans-unit>
        <trans-unit id="614ddcbf931903423c230b8f0212d11059c5ec82" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ValueError&lt;/code&gt; exception will be thrown if no exception exists in the specified Future.</source>
          <target state="translated">&lt;code&gt;ValueError&lt;/code&gt; будет сгенерировано исключение , если не существует исключение в указанном будущем.</target>
        </trans-unit>
        <trans-unit id="ef24e3c1b8f7b901d42c45e46f29ceddb0745dc1" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;export&lt;/code&gt; statement can be used for symbol forwarding so that client modules don't need to import a module's dependencies:</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; заявление может быть использовано для пересылки символов , так что клиентские модулям не нужно импортировать зависимости соответствующего модуля:</target>
        </trans-unit>
        <trans-unit id="73a35d34d5220f34295669a5c8b933dc1ceedeca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;untyped&lt;/code&gt; parameter means that symbol lookups and type resolution is not performed before the expression is passed to the template. This means that for example &lt;em&gt;undeclared&lt;/em&gt; identifiers can be passed to the template:</source>
          <target state="translated">An &lt;code&gt;untyped&lt;/code&gt; означает , что параметр символы поиски и разрешение типа не выполняются до того , выражение передаются в шаблон. Это означает, что, например, в шаблон можно передать &lt;em&gt;необъявленные&lt;/em&gt; идентификаторы:</target>
        </trans-unit>
        <trans-unit id="bae34c49da483225476ede34178ee0a4cd7dbb4e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;if expression&lt;/em&gt; is almost like an if statement, but it is an expression. Example:</source>
          <target state="translated">&lt;em&gt;Если выражение&lt;/em&gt; почти как если заявление, но это выражение. Пример:</target>
        </trans-unit>
        <trans-unit id="6913655373469dbc7b3bf423a90b3116ade5a64c" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;identifier_1&quot;&gt;identifier&lt;/span&gt; is a symbol declared as a name for a variable, type, procedure, etc. The region of the program over which a declaration applies is called the &lt;span id=&quot;scope_1&quot;&gt;scope&lt;/span&gt; of the declaration. Scopes can be nested. The meaning of an identifier is determined by the smallest enclosing scope in which the identifier is declared unless overloading resolution rules suggest otherwise.</source>
          <target state="translated">&lt;span id=&quot;identifier_1&quot;&gt;Идентификатор&lt;/span&gt; является символом объявлен как имя для переменной, типа, процедуры и т.д. области программы , над которой декларация применяется называется &lt;span id=&quot;scope_1&quot;&gt;сферой&lt;/span&gt; декларации. Области могут быть вложенными. Значение идентификатора определяется наименьшей охватывающей областью, в которой объявлен идентификатор, если правила разрешения перегрузки не предполагают иное.</target>
        </trans-unit>
        <trans-unit id="27d850be93dc755d2b65d8e923239958da9648c2" translate="yes" xml:space="preserve">
          <source>An &lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;unchecked runtime error&lt;/span&gt; is an error that is not guaranteed to be detected, and can cause the subsequent behavior of the computation to be arbitrary. Unchecked runtime errors cannot occur if only &lt;span id=&quot;safe_1&quot;&gt;safe&lt;/span&gt; language features are used.</source>
          <target state="translated">&lt;span id=&quot;unchecked-runtime-error_1&quot;&gt;Бесконтрольно ошибка во время выполнения&lt;/span&gt; ошибка , которая не гарантируется быть обнаружена, и может вызвать дальнейшее поведение вычисления , чтобы быть произвольными. Непроверенные ошибки времени выполнения не могут возникнуть, если используются только &lt;span id=&quot;safe_1&quot;&gt;безопасные&lt;/span&gt; языковые функции.</target>
        </trans-unit>
        <trans-unit id="d086f48ed32221353a34e9e09e19fc50d2b08517" translate="yes" xml:space="preserve">
          <source>An EOS (or ESSL if socket is an SSL socket) exception is raised if an error occurs.</source>
          <target state="translated">Исключение EOS (или ESSL,если сокет является SSL-сокетом)поднимается при возникновении ошибки.</target>
        </trans-unit>
        <trans-unit id="fad595a4ff6c034a05915aa77a9cf525f3217cd5" translate="yes" xml:space="preserve">
          <source>An EOS exception will be raised in the case of a socket error.</source>
          <target state="translated">Исключение EOS будет поднято в случае ошибки сокета.</target>
        </trans-unit>
        <trans-unit id="3690729b1f993aa06abd14818e2a3ebd8ae6f4b1" translate="yes" xml:space="preserve">
          <source>An OS-dependent trailing slash is always present at the end of the returned string; &lt;em&gt;` on Windows and `/&lt;/em&gt; on all other OSs.</source>
          <target state="translated">Конечный слеш, зависящий от ОС, всегда присутствует в конце возвращаемой строки; &lt;em&gt;`в Windows и` /&lt;/em&gt; во всех других ОС.</target>
        </trans-unit>
        <trans-unit id="cb3c7dd4ccfc76b560ed8bea7cb91f6e590b5de7" translate="yes" xml:space="preserve">
          <source>An SQL statement that is passed from Nim to an SQL database might be modelled as a string. However, using string templates and filling in the values is vulnerable to the famous &lt;span id=&quot;sql-injection-attack_1&quot;&gt;SQL injection attack&lt;/span&gt;:</source>
          <target state="translated">Оператор SQL, который передается из Nim в базу данных SQL, может быть смоделирован как строка. Однако использование строковых шаблонов и заполнение значений уязвимо для известной &lt;span id=&quot;sql-injection-attack_1&quot;&gt;атаки SQL-инъекции&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="d6b5b2a52bea6b4b6255ab33c977d4534669e142" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Псевдоним для &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="544692451d460228f4efd605a86e7c0dab8a35ee" translate="yes" xml:space="preserve">
          <source>An alias for &lt;em&gt;countup(a, b, 1)&lt;/em&gt;.</source>
          <target state="translated">Псевдоним для &lt;em&gt;countup (a, b, 1)&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="936583901537efa6474af706c7cbc7258cf9502a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;em&gt;name&lt;/em&gt;.</source>
          <target state="translated">Псевдоним для &lt;em&gt;имени&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d96ad4829046669ed22f88ed72333f46e46f422a" translate="yes" xml:space="preserve">
          <source>An alias for copyNimTree().</source>
          <target state="translated">Псевдоним для copyNimTree().</target>
        </trans-unit>
        <trans-unit id="2bb4f7d6ba1dc1ca472b28bc42274504e162f7f7" translate="yes" xml:space="preserve">
          <source>An alternative character used by the operating system to separate pathname components, or the same as &lt;em&gt;DirSep&lt;/em&gt; if only one separator character exists. This is set to '/' on Windows systems where &lt;em&gt;DirSep&lt;/em&gt; is a backslash.</source>
          <target state="translated">Альтернативный символ, используемый операционной системой для разделения компонентов имени пути, или то же самое, что и &lt;em&gt;DirSep,&lt;/em&gt; если существует только один символ-разделитель. Для этого параметра установлено значение &amp;laquo;/&amp;raquo; в системах Windows, где &lt;em&gt;DirSep&lt;/em&gt; представляет собой обратную косую черту.</target>
        </trans-unit>
        <trans-unit id="b10f9786df0315b28bef975ab41acecfb36800af" translate="yes" xml:space="preserve">
          <source>An apostrophe &lt;code&gt;'&lt;/code&gt; followed by an integer &lt;code&gt;i&lt;/code&gt; in the range 0..9 is replaced by the i'th parameter &lt;em&gt;type&lt;/em&gt;. The 0th position is the result type. This can be used to pass types to C++ function templates. Between the &lt;code&gt;'&lt;/code&gt; and the digit an asterisk can be used to get to the base type of the type. (So it &quot;takes away a star&quot; from the type; &lt;code&gt;T*&lt;/code&gt; becomes &lt;code&gt;T&lt;/code&gt;.) Two stars can be used to get to the element type of the element type etc.</source>
          <target state="translated">Апостроф &lt;code&gt;'&lt;/code&gt; , за которым следует целое число &lt;code&gt;i&lt;/code&gt; в диапазоне 0..9, заменяется параметром i-го &lt;em&gt;типа&lt;/em&gt; . Позиция 0 - это тип результата. Это можно использовать для передачи типов в шаблоны функций C ++. Между &lt;code&gt;'&lt;/code&gt; и цифрой можно использовать звездочку, чтобы перейти к базовому типу типа. (Таким образом, он &amp;laquo;убирает звезду&amp;raquo; из типа; &lt;code&gt;T*&lt;/code&gt; становится &lt;code&gt;T&lt;/code&gt; . ) Две звезды могут использоваться для перехода к типу элемента типа элемента и т. Д.</target>
        </trans-unit>
        <trans-unit id="dcf4f417901eafdc569fc787f5454f9027073421" translate="yes" xml:space="preserve">
          <source>An array is a simple fixed length container. Each element in an array has the same type. The array's index type can be any ordinal type.</source>
          <target state="translated">Массив представляет собой простой контейнер фиксированной длины.Каждый элемент массива имеет один и тот же тип.Типом индекса массива может быть любой порядковый тип.</target>
        </trans-unit>
        <trans-unit id="00d1d57ff3f35fb4d74599ef1b920f45e23521b6" translate="yes" xml:space="preserve">
          <source>An asynchronous procedure is marked using the &lt;code&gt;{.async.}&lt;/code&gt; pragma. When marking a procedure with the &lt;code&gt;{.async.}&lt;/code&gt; pragma it must have a &lt;code&gt;Future[T]&lt;/code&gt; return type or no return type at all. If you do not specify a return type then &lt;code&gt;Future[void]&lt;/code&gt; is assumed.</source>
          <target state="translated">Асинхронная процедура помечается с помощью &lt;code&gt;{.async.}&lt;/code&gt; . При &lt;code&gt;{.async.}&lt;/code&gt; процедуры прагмой {.async.} Она должна иметь возвращаемый тип &lt;code&gt;Future[T]&lt;/code&gt; или вообще не иметь возвращаемого типа. Если вы не укажете возвращаемый тип, предполагается &lt;code&gt;Future[void]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00cfb3b823850859ac087c9650335459fba3693e" translate="yes" xml:space="preserve">
          <source>An at symbol &lt;code&gt;@&lt;/code&gt; is replaced by the remaining arguments, separated by commas.</source>
          <target state="translated">Символ &lt;code&gt;@&lt;/code&gt; заменяется оставшимися аргументами, разделенными запятыми.</target>
        </trans-unit>
        <trans-unit id="e0a7ceb8146505e07f088182b71243011ca4cc3a" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;discard&lt;/code&gt; statement is often used as a null statement:</source>
          <target state="translated">Пустой оператор &lt;code&gt;discard&lt;/code&gt; часто используется как пустой оператор:</target>
        </trans-unit>
        <trans-unit id="63b984f97355b1726a5cf0fa4b3612ccc2253bdc" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;raises&lt;/code&gt; list (&lt;code&gt;raises: []&lt;/code&gt;) means that no exception may be raised:</source>
          <target state="translated">Пустой список &lt;code&gt;raises&lt;/code&gt; ( &lt;code&gt;raises: []&lt;/code&gt; ) означает, что исключение не может быть вызвано:</target>
        </trans-unit>
        <trans-unit id="03f5c98cab13364c0bdb7873271e1f3fbcb787f2" translate="yes" xml:space="preserve">
          <source>An empty subscript &lt;code&gt;[]&lt;/code&gt; notation can be used to derefer a reference, the &lt;code&gt;addr&lt;/code&gt; procedure returns the address of an item. An address is always an untraced reference. Thus the usage of &lt;code&gt;addr&lt;/code&gt; is an &lt;em&gt;unsafe&lt;/em&gt; feature.</source>
          <target state="translated">Нотация пустого индекса &lt;code&gt;[]&lt;/code&gt; может использоваться для разыменования ссылки, процедура &lt;code&gt;addr&lt;/code&gt; возвращает адрес элемента. Адрес всегда является неотслеживаемой ссылкой. Таким образом, использование &lt;code&gt;addr&lt;/code&gt; является &lt;em&gt;небезопасной&lt;/em&gt; особенностью.</target>
        </trans-unit>
        <trans-unit id="fd0163ff197f89984c82c49af75d8bfe8b3b9a66" translate="yes" xml:space="preserve">
          <source>An enum can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that it's fields are added to a special module specific hidden scope that is only queried as the last attempt. Only non-ambiguous symbols are added to this scope. But one can always access these via type qualification written as &lt;code&gt;MyEnum.value&lt;/code&gt;:</source>
          <target state="translated">Перечисление можно пометить с помощью прагмы &lt;code&gt;pure&lt;/code&gt; , чтобы его поля добавлялись в специальную скрытую область, специфичную для модуля, которая запрашивается только как последняя попытка. В эту область добавляются только однозначные символы. Но к ним всегда можно получить доступ через квалификацию типа, записанную как &lt;code&gt;MyEnum.value&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="390d5ff2cbaae78dc0fa4290b4e9610666cc8fdf" translate="yes" xml:space="preserve">
          <source>An enum type can be marked as &lt;code&gt;pure&lt;/code&gt;. Then access of its fields always requires full qualification.</source>
          <target state="translated">Тип перечисления можно пометить как &lt;code&gt;pure&lt;/code&gt; . Тогда для доступа к его полям всегда требуется полная квалификация.</target>
        </trans-unit>
        <trans-unit id="367c78270c2f231073a0357927182872afdf0f63" translate="yes" xml:space="preserve">
          <source>An enum which hold event types</source>
          <target state="translated">Перечень,в котором перечислены типы мероприятий</target>
        </trans-unit>
        <trans-unit id="4dcfd8f767ff68c968ba90d84fa6dca78b2ac575" translate="yes" xml:space="preserve">
          <source>An enumeration's symbol can be qualified to avoid ambiguities: &lt;code&gt;Direction.south&lt;/code&gt;.</source>
          <target state="translated">Чтобы избежать неоднозначности, можно указать символ перечисления: &lt;code&gt;Direction.south&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83a58494419b1a3e524ebfb95e03913553034371" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;handleAccept&lt;/code&gt; follows:</source>
          <target state="translated">Ниже &lt;code&gt;handleAccept&lt;/code&gt; пример handleAccept :</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Пример:</target>
        </trans-unit>
        <trans-unit id="993744896fbb24a8143d61db93a5b797f2af5f88" translate="yes" xml:space="preserve">
          <source>An explicit ordered enum can have &lt;em&gt;holes&lt;/em&gt;:</source>
          <target state="translated">В явном упорядоченном перечислении могут быть &lt;em&gt;дыры&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a5f3c80df868038bd59209ddaecef0136b0eb492" translate="yes" xml:space="preserve">
          <source>An exported helper proc that parses the &quot;standard format specifiers&quot;, as specified by the grammar:</source>
          <target state="translated">Экспортированный помощник proc,который разбирает &quot;спецификаторы стандартного формата&quot;,как указано в грамматике:</target>
        </trans-unit>
        <trans-unit id="129cc9980afbc0b6d02dd90e59a7e2eac8eb8d2f" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;b&lt;/code&gt; can be assigned to an expression &lt;code&gt;a&lt;/code&gt; iff &lt;code&gt;a&lt;/code&gt; is an &lt;em&gt;l-value&lt;/em&gt; and &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; holds.</source>
          <target state="translated">Выражение &lt;code&gt;b&lt;/code&gt; может быть присвоено выражению &lt;code&gt;a&lt;/code&gt; , если &lt;code&gt;a&lt;/code&gt; является &lt;em&gt;l-значением&lt;/em&gt; и &lt;code&gt;isImplicitlyConvertible(b.typ, a.typ)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d2a0ca1f92482471cb1498e046b1a61df5075bd" translate="yes" xml:space="preserve">
          <source>An expression like &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; is transformed into:</source>
          <target state="translated">Выражение типа &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; преобразуется в:</target>
        </trans-unit>
        <trans-unit id="5cf1e65690ce8b0321d174674e5faf95e0f45bd9" translate="yes" xml:space="preserve">
          <source>An expression specifies a computation that produces a value or location. Expressions that produce locations are called &lt;span id=&quot;lminusvalues_1&quot;&gt;l-values&lt;/span&gt;. An l-value can denote either a location or the value the location contains, depending on the context. Expressions whose values can be determined statically are called &lt;span id=&quot;constant-expressions_1&quot;&gt;constant expressions&lt;/span&gt;; they are never l-values.</source>
          <target state="translated">Выражение определяет вычисление, которое производит значение или местоположение. Выражения, производящие местоположения, называются &lt;span id=&quot;lminusvalues_1&quot;&gt;l-значениями&lt;/span&gt; . L-значение может обозначать либо местоположение, либо значение, которое оно содержит, в зависимости от контекста. Выражения, значения которых могут быть определены статически, называются &lt;span id=&quot;constant-expressions_1&quot;&gt;постоянными выражениями&lt;/span&gt; ; они никогда не являются l-значениями.</target>
        </trans-unit>
        <trans-unit id="1e306939f1b61ed5f05365a4a82b6e0e9f803e5d" translate="yes" xml:space="preserve">
          <source>An if expression always results in a value, so the &lt;code&gt;else&lt;/code&gt; part is required. &lt;code&gt;Elif&lt;/code&gt; parts are also allowed.</source>
          <target state="translated">Выражение if всегда приводит к значению, поэтому требуется часть &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;Elif&lt;/code&gt; детали Elif .</target>
        </trans-unit>
        <trans-unit id="55f00c59e69693d5b27bf05aeea67c1b5656b713" translate="yes" xml:space="preserve">
          <source>An implementation should always use the maximum precision available to evaluate floating pointer values at compile time; this means expressions like &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; are true.</source>
          <target state="translated">Реализация всегда должна использовать максимальную точность, доступную для оценки значений с плавающим указателем во время компиляции; это означает, что выражения вроде &lt;code&gt;0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64&lt;/code&gt; верны.</target>
        </trans-unit>
        <trans-unit id="4faf8ef86d99d8f87188a85418d2cafbed7c672a" translate="yes" xml:space="preserve">
          <source>An integer with the column you are going to query. For the compiler columns start at &lt;strong&gt;0&lt;/strong&gt;.</source>
          <target state="translated">Целое число со столбцом, который вы собираетесь запросить. Столбцы компилятора начинаются с &lt;strong&gt;0&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7140df7bbe5e3e07dff6576529cef23b438e6cf3" translate="yes" xml:space="preserve">
          <source>An integer with the column you are going to query. For the compiler columns start at zero, so the first column will be &lt;strong&gt;0&lt;/strong&gt; and the last in an 80 column terminal will be &lt;strong&gt;79&lt;/strong&gt;.</source>
          <target state="translated">Целое число со столбцом, который вы собираетесь запросить. Столбцы компилятора начинаются с нуля, поэтому первый столбец будет равен &lt;strong&gt;0,&lt;/strong&gt; а последний в терминале с 80 столбцами будет &lt;strong&gt;79&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="58c18cab7c4720f0e3aa95f69ca0b844006c41f0" translate="yes" xml:space="preserve">
          <source>An integer with the line you are going to query. For the compiler lines start at &lt;strong&gt;1&lt;/strong&gt;.</source>
          <target state="translated">Целое число со строкой, которую вы собираетесь запросить. Строки компилятора начинаются с &lt;strong&gt;1&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fd63b4dca2c3b56a63f528ea8506804126dab43c" translate="yes" xml:space="preserve">
          <source>An iterator is similar to a procedure, except that it can be called in the context of a &lt;code&gt;for&lt;/code&gt; loop. Iterators provide a way to specify the iteration over an abstract type. A key role in the execution of a &lt;code&gt;for&lt;/code&gt; loop plays the &lt;code&gt;yield&lt;/code&gt; statement in the called iterator. Whenever a &lt;code&gt;yield&lt;/code&gt; statement is reached the data is bound to the &lt;code&gt;for&lt;/code&gt; loop variables and control continues in the body of the &lt;code&gt;for&lt;/code&gt; loop. The iterator's local variables and execution state are automatically saved between calls. Example:</source>
          <target state="translated">Итератор похож на процедуру, за исключением того, что его можно вызывать в контексте цикла &lt;code&gt;for&lt;/code&gt; . Итераторы позволяют указать итерацию абстрактного типа. Ключевую роль в выполнении цикла &lt;code&gt;for&lt;/code&gt; играет оператор &lt;code&gt;yield&lt;/code&gt; в вызываемом итераторе. Когда достигается оператор &lt;code&gt;yield&lt;/code&gt; , данные привязываются к переменным цикла &lt;code&gt;for&lt;/code&gt; , и управление продолжается в теле цикла &lt;code&gt;for&lt;/code&gt; . Локальные переменные итератора и состояние выполнения автоматически сохраняются между вызовами. Пример:</target>
        </trans-unit>
        <trans-unit id="1f5ff3abd757e3cba00a39f18b56b5fb6446a8c0" translate="yes" xml:space="preserve">
          <source>An object type can be marked with the &lt;code&gt;pure&lt;/code&gt; pragma so that its type field which is used for runtime type identification is omitted. This used to be necessary for binary compatibility with other compiled languages.</source>
          <target state="translated">Тип объекта можно пометить с помощью прагмы &lt;code&gt;pure&lt;/code&gt; , так что его поле типа, которое используется для идентификации типа во время выполнения, опускается. Раньше это было необходимо для двоичной совместимости с другими компилируемыми языками.</target>
        </trans-unit>
        <trans-unit id="2e8278ca51d6d95aa64a5e6c057a546e2ca28c42" translate="yes" xml:space="preserve">
          <source>An object which holds descriptors to be checked for read/write status</source>
          <target state="translated">Объект,содержащий дескрипторы,которые необходимо проверить на статус чтения/записи.</target>
        </trans-unit>
        <trans-unit id="3274465cde86ef19fbd6e85a8dde25fac63bf653" translate="yes" xml:space="preserve">
          <source>An object which holds result for descriptor</source>
          <target state="translated">Объект,содержащий результат для дескриптора</target>
        </trans-unit>
        <trans-unit id="e62ca354a533c308819dea987dbbf454b1323735" translate="yes" xml:space="preserve">
          <source>An object which holds user defined event</source>
          <target state="translated">Объект,который содержит определенное пользователем событие</target>
        </trans-unit>
        <trans-unit id="004526c446f1ac6d78516b74ee9cfa40b5941993" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if reading from the</source>
          <target state="translated">Дополнительный таймаут может быть указан в миллисекундах,если считывание с</target>
        </trans-unit>
        <trans-unit id="be0cf6034a987ab54cdc28a91621a1407148ad61" translate="yes" xml:space="preserve">
          <source>An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified an ETimeout exception will be raised.</source>
          <target state="translated">Дополнительный таймаут может быть указан в миллисекундах,если пропускание байтов занимает больше времени,чем указанное исключение ETimeout будет поднято.</target>
        </trans-unit>
        <trans-unit id="1436ea667171f8c043927d94a1771aba02c31130" translate="yes" xml:space="preserve">
          <source>An optional type that stores its value and state separately in a boolean.</source>
          <target state="translated">Необязательный тип,который хранит свое значение и состояние отдельно в булеве.</target>
        </trans-unit>
        <trans-unit id="1492892ce7573ee3544c47d10217feac9a1ffe27" translate="yes" xml:space="preserve">
          <source>Anchor: Matches at the end of the input. No character is consumed. Same as &lt;code&gt;!.&lt;/code&gt;.</source>
          <target state="translated">Якорь: соответствует концу ввода. Никакой персонаж не потребляется. То же, что и &lt;code&gt;!.&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="28501d5ba1b7346ee45610593888631bf0f75364" translate="yes" xml:space="preserve">
          <source>Anchor: Matches at the start of the input. No character is consumed.</source>
          <target state="translated">Якорь:Спички в начале входа.Символ не расходуется.</target>
        </trans-unit>
        <trans-unit id="d5b80e8f8af7973d49e632e415ee520559b6880c" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;main&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;foo/x&lt;/code&gt; is imported. If &lt;code&gt;other&lt;/code&gt; imports &lt;code&gt;x&lt;/code&gt; then both &lt;code&gt;$lib/x.nim&lt;/code&gt; and &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; match and so the compiler should reject it. Currently however this check is not implemented and instead the first matching file is used.</source>
          <target state="translated">И &lt;code&gt;main&lt;/code&gt; импорт &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;foo/x&lt;/code&gt; импортируется. Если &lt;code&gt;other&lt;/code&gt; импортирует &lt;code&gt;x&lt;/code&gt; , то &lt;code&gt;$lib/x.nim&lt;/code&gt; и $ lib / x.nim, и &lt;code&gt;$lib/bar/x.nim&lt;/code&gt; поэтому компилятор должен отклонить его. Однако в настоящее время эта проверка не реализована, и вместо нее используется первый соответствующий файл.</target>
        </trans-unit>
        <trans-unit id="242f34bf16bfc5e83d5742e55f63b87c019f679a" translate="yes" xml:space="preserve">
          <source>And copy the executable somewhere in your &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">И скопируйте исполняемый файл где-нибудь в свой &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83dda4bc1c55dc87decca365a7ad42665d8106b1" translate="yes" xml:space="preserve">
          <source>And for a debug version compatible with GDB:</source>
          <target state="translated">А для отладочной версии,совместимой с GDB:</target>
        </trans-unit>
        <trans-unit id="4e8296500ed287ca2f86dd1c2fab187b68fe5d29" translate="yes" xml:space="preserve">
          <source>And predicate: Indicate success if expression &lt;em&gt;E&lt;/em&gt; matches the text ahead; otherwise indicate failure. Do not consume any text.</source>
          <target state="translated">И предикат: Укажите успех, если выражение &lt;em&gt;E&lt;/em&gt; соответствует тексту впереди; в противном случае указывает на отказ. Не употребляйте текст.</target>
        </trans-unit>
        <trans-unit id="dd21179e471067255e31c8a35037ea42bc51b5d1" translate="yes" xml:space="preserve">
          <source>And the following code:</source>
          <target state="translated">И следующий код:</target>
        </trans-unit>
        <trans-unit id="529975d2ca1b9c8b1f9dc8715723302d776e3685" translate="yes" xml:space="preserve">
          <source>Annotating procs with raised exceptions</source>
          <target state="translated">Аннотирование профилей с повышенными исключениями</target>
        </trans-unit>
        <trans-unit id="1372df72c3414caae306a6854fbd73da2739c232" translate="yes" xml:space="preserve">
          <source>Anonymous Procs</source>
          <target state="translated">Анонимные Прокуроры</target>
        </trans-unit>
        <trans-unit id="fc69ddcac99b9b9a8d29c74edd5dd97109c0f888" translate="yes" xml:space="preserve">
          <source>Another common example is this:</source>
          <target state="translated">Еще один распространенный пример:</target>
        </trans-unit>
        <trans-unit id="46de23dafaa5135d298c4e6932bfd58f0a55fcd3" translate="yes" xml:space="preserve">
          <source>Another way is to make Nim invoke a cross compiler toolchain:</source>
          <target state="translated">Другой способ-заставить Nim вызывать кросс-компиляторный инструментарий:</target>
        </trans-unit>
        <trans-unit id="220b3fd15cb7730c1f91330b6bd071c4acf9137b" translate="yes" xml:space="preserve">
          <source>Another way to branch is provided by the case statement. A case statement is a multi-branch:</source>
          <target state="translated">Другой путь к филиалу предусмотрен в заявлении по делу.Суть дела-многоотраслевая:</target>
        </trans-unit>
        <trans-unit id="b109a7f72d501d6581c64b2e20010ee624b143d1" translate="yes" xml:space="preserve">
          <source>Another way to do the same without &lt;code&gt;when&lt;/code&gt; is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the &lt;em&gt;value&lt;/em&gt; to.</source>
          <target state="translated">Другой способ сделать то же самое без &lt;code&gt;when&lt;/code&gt; - передать задачу выбора соответствующего кода вторичной процедуре, которую вы перегружаете для каждого типа поля и передаете &lt;em&gt;значение&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cdcc64fe4174864c656f8d5ecbd49e1c1178af4e" translate="yes" xml:space="preserve">
          <source>Another way to look at the method call syntax is that it provides the missing postfix notation.</source>
          <target state="translated">Другой способ взглянуть на синтаксис вызова метода заключается в том,что он предоставляет отсутствующую постфиксную нотацию.</target>
        </trans-unit>
        <trans-unit id="a741689c8b0db1dc353a46642a34688e7e01c9fe" translate="yes" xml:space="preserve">
          <source>Any Unicode character: If there is an UTF-8 character ahead, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">Любой символ Юникода:Если впереди символ UTF-8,используйте его и укажите на успех.В противном случае укажите на неудачу.</target>
        </trans-unit>
        <trans-unit id="5778ef8422665afffa8cd59a1ebfe6af7a70d367" translate="yes" xml:space="preserve">
          <source>Any character: If there is a character ahead, consume it and indicate success. Otherwise (that is, at the end of input) indicate failure.</source>
          <target state="translated">Любой персонаж:Если впереди есть персонаж,съешь его и укажешь на успех.Иначе (то есть в конце ввода)указывают на неудачу.</target>
        </trans-unit>
        <trans-unit id="7358bbc6ca3777f85150f64affeb40b274702a17" translate="yes" xml:space="preserve">
          <source>Any comments which are preceded by a double-hash (##), are interpreted as documentation. Comments are parsed as RST (see &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;reference&lt;/a&gt;), providing Nim module authors the ability to easily generate richly formatted documentation with only their well-documented code.</source>
          <target state="translated">Любые комментарии, которым предшествует двойной хэш (##), интерпретируются как документация. Комментарии анализируются как RST (см. &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;Справку&lt;/a&gt; ), что дает авторам модулей Nim возможность легко создавать документацию с богатым форматированием, используя только их хорошо документированный код.</target>
        </trans-unit>
        <trans-unit id="91e820fd709a7f87728034af624c9132692282ae" translate="yes" xml:space="preserve">
          <source>Any operator can be called like an ordinary proc with the '&lt;em&gt;opr&lt;/em&gt;' notation. (Thus an operator can have more than two parameters):</source>
          <target state="translated">Любой оператор может быть вызван как обычная процедура с обозначением ' &lt;em&gt;opr&lt;/em&gt; '. (Таким образом, оператор может иметь более двух параметров):</target>
        </trans-unit>
        <trans-unit id="28a8d44708b00ee5f8ab5f8950f4590e672372e9" translate="yes" xml:space="preserve">
          <source>Any previously stored value will be overwritten.</source>
          <target state="translated">Любое ранее сохраненное значение будет перезаписано.</target>
        </trans-unit>
        <trans-unit id="85cdc7b1f239ca6691d5ad4bd7ee32149be2368a" translate="yes" xml:space="preserve">
          <source>Any statements following the &lt;code&gt;defer&lt;/code&gt; in the current block will be considered to be in an implicit try block:</source>
          <target state="translated">Любые операторы, следующие за &lt;code&gt;defer&lt;/code&gt; в текущем блоке, будут считаться находящимися в неявном блоке try:</target>
        </trans-unit>
        <trans-unit id="f6cede9c40103cfeb38206a514d0e207b6286657" translate="yes" xml:space="preserve">
          <source>Any user defined destructors</source>
          <target state="translated">Любые деструкторы,определенные пользователем</target>
        </trans-unit>
        <trans-unit id="474bae604f6e9971bd49456c68cefe4610021141" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;spawn&lt;/code&gt; and &lt;code&gt;parallel&lt;/code&gt; Nim also provides all the common low level concurrency mechanisms like locks, atomic intrinsics or condition variables.</source>
          <target state="translated">Помимо &lt;code&gt;spawn&lt;/code&gt; и &lt;code&gt;parallel&lt;/code&gt; Nim также предоставляет все распространенные механизмы параллелизма на низком уровне, такие как блокировки, атомарные встроенные функции или переменные условий.</target>
        </trans-unit>
        <trans-unit id="562f1ef0862bc54a9d91c121544eee328c801e91" translate="yes" xml:space="preserve">
          <source>Apart from a few built-in keyword operators such as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, operators always consist of these characters: &lt;code&gt;+ - * \ / &amp;lt; &amp;gt; = @ $ ~ &amp;amp; % ! ? ^ . |&lt;/code&gt;</source>
          <target state="translated">Помимо нескольких встроенных ключевых слов операторов , таких как &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , операторы всегда состоят из следующих символов: &lt;code&gt;+ - * \ / &amp;lt; &amp;gt; = @ $ ~ &amp;amp; % ! ? ^ . |&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfe80b93d1b3cc277c929cdfd0838f7556135094" translate="yes" xml:space="preserve">
          <source>Apart from built-in operations like array indexing, memory allocation, etc. the &lt;code&gt;raise&lt;/code&gt; statement is the only way to raise an exception.</source>
          <target state="translated">Помимо встроенных операций, таких как индексация массивов, выделение памяти и т. Д., Оператор &lt;code&gt;raise&lt;/code&gt; - единственный способ вызвать исключение.</target>
        </trans-unit>
        <trans-unit id="7dc1626458ca624671bbd7eb79e937465433fdf8" translate="yes" xml:space="preserve">
          <source>Apart from strings you can also encode lists of integers or characters:</source>
          <target state="translated">Кроме строк можно кодировать списки целых чисел или символов:</target>
        </trans-unit>
        <trans-unit id="aafd7f63cf0cf31a35bff642569ecbe5c87f627c" translate="yes" xml:space="preserve">
          <source>Apart from the minimal syntactic sugar the language core does not need to know about tables.</source>
          <target state="translated">Кроме минимального синтаксического сахара,ядру языка не нужно знать о таблицах.</target>
        </trans-unit>
        <trans-unit id="86d0496a927c4a27939c0fe3200738c8416afc23" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;x&lt;/em&gt; to string &lt;em&gt;s&lt;/em&gt; in place, applying quoting and escaping if &lt;em&gt;x&lt;/em&gt; is a string or char. See &lt;a href=&quot;system#addEscapedChar&quot;&gt;addEscapedChar&lt;/a&gt; for the escaping scheme. When &lt;em&gt;x&lt;/em&gt; is a string, characters in the range &lt;code&gt;{\128..\255}&lt;/code&gt; are never escaped so that multibyte UTF-8 characters are untouched (note that this behavior is different from &lt;code&gt;addEscapedChar&lt;/code&gt;).</source>
          <target state="translated">Добавляет &lt;em&gt;x&lt;/em&gt; к строке &lt;em&gt;s&lt;/em&gt; на месте, применяя кавычки и экранирование, если &lt;em&gt;x&lt;/em&gt; является строкой или символом. См. &lt;a href=&quot;system#addEscapedChar&quot;&gt;AddEscapedChar&lt;/a&gt; для схемы экранирования. Когда &lt;em&gt;x&lt;/em&gt; является строкой, символы в диапазоне &lt;code&gt;{\128..\255}&lt;/code&gt; никогда не экранируются, поэтому многобайтовые символы UTF-8 остаются нетронутыми (обратите внимание, что это поведение отличается от &lt;code&gt;addEscapedChar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="646ba0c86d2da62ac809b41c7876c8d4d437f4fd" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt; in place</source>
          <target state="translated">Добавляет &lt;em&gt;y&lt;/em&gt; к &lt;em&gt;x&lt;/em&gt; на месте</target>
        </trans-unit>
        <trans-unit id="621c0cff6d7cb368d8e84f223d0bb258c1851898" translate="yes" xml:space="preserve">
          <source>Appends element y to the end of the sequence. Requires copying of the sequence</source>
          <target state="translated">Добавляет элемент y в конец последовательности.Требуется копирование последовательности</target>
        </trans-unit>
        <trans-unit id="4b93e2750d5e019c95354307daa55b9ae9ae1eb1" translate="yes" xml:space="preserve">
          <source>Appends url to url.</source>
          <target state="translated">Прикладывает урлу к урлу.</target>
        </trans-unit>
        <trans-unit id="8b39b7cf4b0a60e8defe6d54cb8868dcdb0f1e4b" translate="yes" xml:space="preserve">
          <source>Applies &lt;em&gt;op&lt;/em&gt; to every item in &lt;em&gt;s&lt;/em&gt; modifying it directly.</source>
          <target state="translated">Применяет &lt;em&gt;op&lt;/em&gt; к каждому элементу в &lt;em&gt;s,&lt;/em&gt; изменяя его напрямую.</target>
        </trans-unit>
        <trans-unit id="47c68a697222d8231db69fecdc76aa3f8118fca0" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option</source>
          <target state="translated">Применяет обратный вызов к значению в этом варианте.</target>
        </trans-unit>
        <trans-unit id="1f6c6510cdda5cd1b191679d2ebcc3574091831b" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned</source>
          <target state="translated">Применяет обратный вызов к значению в этом Опционе и возвращает опцию,содержащую новое значение.Если этот параметр равен None,то None не будет возвращен.</target>
        </trans-unit>
        <trans-unit id="4405334856a221170be55f8b9f5688d6a0be9c57" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option and returns an option containing the new value. If this option is None, None will be returned. Similar to &lt;code&gt;map&lt;/code&gt;, with the difference that the callback returns an Option, not a raw value. This allows multiple procs with a signature of &lt;code&gt;A -&amp;gt; Option[B]&lt;/code&gt; (including A = B) to be chained together.</source>
          <target state="translated">Применяет обратный вызов к значению в этом параметре и возвращает параметр, содержащий новое значение. Если для этого параметра установлено значение &amp;laquo;Нет&amp;raquo;, возвращается значение &amp;laquo;Нет&amp;raquo;. Подобно &lt;code&gt;map&lt;/code&gt; , с той разницей, что обратный вызов возвращает Option, а не исходное значение. Это позволяет объединить несколько процессов с сигнатурой &lt;code&gt;A -&amp;gt; Option[B]&lt;/code&gt; (включая A = B) вместе.</target>
        </trans-unit>
        <trans-unit id="465dd40623dd93f42a5f03dcd0c6972a66643b81" translate="yes" xml:space="preserve">
          <source>Applies a callback to the value in this Option. If the callback returns &lt;em&gt;true&lt;/em&gt;, the option is returned as a Some. If it returns false, it is returned as a None.</source>
          <target state="translated">Применяет обратный вызов к значению в этом параметре. Если обратный вызов возвращает &lt;em&gt;true&lt;/em&gt; , параметр возвращается как Some. Если он возвращает false, он возвращается как None.</target>
        </trans-unit>
        <trans-unit id="31b8834506fb3b7c5be5a3ce85e8e0c3db7c0b3f" translate="yes" xml:space="preserve">
          <source>Arguments are delimited by white space, which is either a space or a tab.</source>
          <target state="translated">Аргументы разделяются белым пробелом,который является либо пробелом,либо табуляцией.</target>
        </trans-unit>
        <trans-unit id="401bb179f3db6b973c284e019e2540619d382218" translate="yes" xml:space="preserve">
          <source>Arguments that are passed to a &lt;code&gt;varargs&lt;/code&gt; parameter are wrapped in an array constructor expression. This is why &lt;code&gt;debug&lt;/code&gt; iterates over all of &lt;code&gt;n&lt;/code&gt;'s children.</source>
          <target state="translated">Аргументы, которые передаются в параметр &lt;code&gt;varargs&lt;/code&gt; , заключаются в выражение конструктора массива. Вот почему &lt;code&gt;debug&lt;/code&gt; повторяется по всем &lt;code&gt;n&lt;/code&gt; дочерним элементам .</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="52bae2349fbad4ef35978d796cfe4b7d32461d9e" translate="yes" xml:space="preserve">
          <source>Array access operator &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">Оператор доступа к массиву &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="935c34e59be520dab8667587be24775c6b59c8e5" translate="yes" xml:space="preserve">
          <source>Array and sequence types</source>
          <target state="translated">Типы массивов и последовательностей</target>
        </trans-unit>
        <trans-unit id="b66b4ebd826229d404911b2c9ca9b59007c74879" translate="yes" xml:space="preserve">
          <source>Array with no bounds checking</source>
          <target state="translated">Массив без проверки</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="7c78840740ada4caee391a3c7d72b96b3524a2c8" translate="yes" xml:space="preserve">
          <source>Arrays are a homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length which is specified at compile time (except for open arrays). They can be indexed by any ordinal type. A parameter &lt;code&gt;A&lt;/code&gt; may be an &lt;em&gt;open array&lt;/em&gt;, in which case it is indexed by integers from 0 to &lt;code&gt;len(A)-1&lt;/code&gt;. An array expression may be constructed by the array constructor &lt;code&gt;[]&lt;/code&gt;. The element type of this array expression is inferred from the type of the first element. All other elements need to be implicitly convertable to this type.</source>
          <target state="translated">Массивы являются однородным типом, что означает, что каждый элемент в массиве имеет один и тот же тип. Массивы всегда имеют фиксированную длину, которая указывается во время компиляции (за исключением открытых массивов). Их можно индексировать по любому порядковому типу. Параметр &lt;code&gt;A&lt;/code&gt; может быть &lt;em&gt;открытым массивом&lt;/em&gt; , и в этом случае он индексируется целыми числами от 0 до &lt;code&gt;len(A)-1&lt;/code&gt; . Выражение массива может быть создано конструктором массива &lt;code&gt;[]&lt;/code&gt; . Тип элемента этого выражения массива выводится из типа первого элемента. Все остальные элементы должны быть неявно преобразованы в этот тип.</target>
        </trans-unit>
        <trans-unit id="07316b5238311cac8e4fe1961ee02c15801cb68e" translate="yes" xml:space="preserve">
          <source>Arrays are always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--boundChecks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">Границы массивов всегда проверяются (во время компиляции или во время выполнения). Эти проверки можно отключить с помощью прагм или вызова компилятора с помощью &lt;code&gt;--boundChecks:off&lt;/code&gt; командной строки --boundChecks: off .</target>
        </trans-unit>
        <trans-unit id="5f5ec03ff46845d078f8cf64b1238f79972295a5" translate="yes" xml:space="preserve">
          <source>Arrays are value types, like any other Nim type. The assignment operator copies the whole array contents.</source>
          <target state="translated">Массивы-это типы значений,как и любой другой тип Nim.Оператор присваивания копирует все содержимое массива.</target>
        </trans-unit>
        <trans-unit id="025a9e98dcb0da2dd59c51da809f12fce4980b2a" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed using &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">Массивы могут быть построены с помощью &lt;code&gt;[]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c735544485e105956e388f5a452d2502051ca6e1" translate="yes" xml:space="preserve">
          <source>Artifact being compiled.</source>
          <target state="translated">Артефакт составляется.</target>
        </trans-unit>
        <trans-unit id="2681d14f693853cb31e8a490d26bf55ce9311d0e" translate="yes" xml:space="preserve">
          <source>As a regular expression &lt;code&gt;\[.*\]&lt;/code&gt; matches the longest possible text between &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;. As a PEG it never matches anything, because a PEG is deterministic: &lt;code&gt;.*&lt;/code&gt; consumes the rest of the input, so &lt;code&gt;\]&lt;/code&gt; never matches. As a PEG this needs to be written as: &lt;code&gt;\[ ( !\] . )* \]&lt;/code&gt; (or &lt;code&gt;\[ @ \]&lt;/code&gt;).</source>
          <target state="translated">Как регулярное выражение, &lt;code&gt;\[.*\]&lt;/code&gt; Соответствует самому длинному тексту между &lt;code&gt;'['&lt;/code&gt; и &lt;code&gt;']'&lt;/code&gt; . Как PEG он никогда ни с чем не соответствует, потому что PEG детерминирован:. &lt;code&gt;.*&lt;/code&gt; Потребляет остальную часть ввода, поэтому &lt;code&gt;\]&lt;/code&gt; никогда не соответствует. Для PEG это необходимо записать как: &lt;code&gt;\[ ( !\] . )* \]&lt;/code&gt; (Или &lt;code&gt;\[ @ \]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7d98662c0a3a8c4fd899d63977fd61a1ce489676" translate="yes" xml:space="preserve">
          <source>As a result of using optimized function/intrinsics some functions can return undefined results if the input is invalid. You can use the flag &lt;em&gt;noUndefinedBitOpts&lt;/em&gt; to force predictable behaviour for all input, causing a small performance hit.</source>
          <target state="translated">В результате использования оптимизированных функций / встроенных функций некоторые функции могут возвращать неопределенные результаты, если ввод неверен. Вы можете использовать флаг &lt;em&gt;noUndefinedBitOpts,&lt;/em&gt; чтобы обеспечить предсказуемое поведение для всех входных данных, что приведет к небольшому &lt;em&gt;снижению&lt;/em&gt; производительности.</target>
        </trans-unit>
        <trans-unit id="1664c8e0b3003ab199f6ca491156febd8a7827ee" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, indentation within expressions is allowed after operators, an open parenthesis and after commas.</source>
          <target state="translated">Как правило,отступ внутри выражений допускается после операторов,открытой круглой скобки и после запятых.</target>
        </trans-unit>
        <trans-unit id="1bbf2a9820bf41bcc3ae860ff3066a54791d55a8" translate="yes" xml:space="preserve">
          <source>As a side note, if you choose to use infix operators in a prefix form, the AST behaves as a [parenthetical function call](./macros.html#calls-expressions-call-with) with &lt;code&gt;nnkAccQuoted&lt;/code&gt;, as follows:</source>
          <target state="translated">В качестве примечания: если вы решите использовать инфиксные операторы в форме префикса, AST будет вести себя как [вызов функции в скобках] (./ macros.html # calls-expressions-call-with) с &lt;code&gt;nnkAccQuoted&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="15211f47465417179a8c67c3321dc2d1d401fb39" translate="yes" xml:space="preserve">
          <source>As a special more convenient notation, proc expressions involved in procedure calls can use the &lt;code&gt;do&lt;/code&gt; keyword:</source>
          <target state="translated">В качестве специальной более удобной записи выражения proc, участвующие в вызовах процедур, могут использовать ключевое слово &lt;code&gt;do&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ce683dd181064064b72fd86d9d3e2b66acc2d7ce" translate="yes" xml:space="preserve">
          <source>As a special rule to keep backwards compatibility with older versions of the &lt;code&gt;importcpp&lt;/code&gt; pragma, if there is no special pattern character (any of &lt;code&gt;# ' @&lt;/code&gt;) at all, C++'s dot or arrow notation is assumed, so the above example can also be written as:</source>
          <target state="translated">В качестве специального правила для обеспечения обратной совместимости со старыми версиями &lt;code&gt;importcpp&lt;/code&gt; , если нет специального символа шаблона (любого из &lt;code&gt;# ' @&lt;/code&gt; ), предполагается точка или стрелка в C ++, поэтому приведенный выше пример также можно записать как :</target>
        </trans-unit>
        <trans-unit id="afa79fbae0eabebb420b9fe3f09c01088cf66351" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;decodePlus&lt;/code&gt; is true, &lt;code&gt;'+'&lt;/code&gt; characters are converted to a space.</source>
          <target state="translated">По особому правилу, когда значение &lt;code&gt;decodePlus&lt;/code&gt; истинно, символы &lt;code&gt;'+'&lt;/code&gt; преобразуются в пробел.</target>
        </trans-unit>
        <trans-unit id="1b120a7d9f07026a29d56a412d87eb19ed8fa37b" translate="yes" xml:space="preserve">
          <source>As a special rule, when the value of &lt;code&gt;usePlus&lt;/code&gt; is true, spaces are encoded as &lt;code&gt;'+'&lt;/code&gt; instead of &lt;code&gt;'%20'&lt;/code&gt;.</source>
          <target state="translated">По особому правилу, когда значение &lt;code&gt;usePlus&lt;/code&gt; истинно, пробелы кодируются как &lt;code&gt;'+'&lt;/code&gt; вместо &lt;code&gt;'%20'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="babff93920d51965108f37a93de33ae42b21d0fb" translate="yes" xml:space="preserve">
          <source>As a special semantic extension, an expression in an &lt;code&gt;of&lt;/code&gt; branch of a case statement may evaluate to a set or array constructor; the set or array is then expanded into a list of its elements:</source>
          <target state="translated">В качестве специального семантического расширения, выражение в &lt;code&gt;of&lt;/code&gt; ветви саза может оценить до заданной или массива конструкторы; затем набор или массив расширяется до списка его элементов:</target>
        </trans-unit>
        <trans-unit id="d1d6a828142c8108ac0deb4cc6c8484c64faae27" translate="yes" xml:space="preserve">
          <source>As a special semantic rule, the built-in &lt;a href=&quot;system#debugEcho&quot;&gt;debugEcho&lt;/a&gt; pretends to be free of side effects, so that it can be used for debugging routines marked as &lt;code&gt;noSideEffect&lt;/code&gt;.</source>
          <target state="translated">В качестве специального семантического правила встроенный &lt;a href=&quot;system#debugEcho&quot;&gt;debugEcho&lt;/a&gt; претендует на отсутствие побочных эффектов, поэтому его можно использовать для отладки подпрограмм, отмеченных как &lt;code&gt;noSideEffect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71489e93932a05f2ea411285eaceb3bbe24614d1" translate="yes" xml:space="preserve">
          <source>As a syntactical extension &lt;code&gt;object&lt;/code&gt; types can be anonymous if declared in a type section via the &lt;code&gt;ref object&lt;/code&gt; or &lt;code&gt;ptr object&lt;/code&gt; notations. This feature is useful if an object should only gain reference semantics:</source>
          <target state="translated">В качестве синтаксического расширения типы &lt;code&gt;object&lt;/code&gt; могут быть анонимными, если они объявлены в разделе типов через &lt;code&gt;ref object&lt;/code&gt; или &lt;code&gt;ptr object&lt;/code&gt; нотацию ptr . Эта функция полезна, если объект должен получать только ссылочную семантику:</target>
        </trans-unit>
        <trans-unit id="7859c8bf7a7bf8df21005d62f29109f1c4a9707d" translate="yes" xml:space="preserve">
          <source>As a top level statement, the experimental pragma enables a feature for the rest of the module it's enabled in. This is problematic for macro and generic instantiations that cross a module scope. Currently these usages have to be put into a &lt;code&gt;.push/pop&lt;/code&gt; environment:</source>
          <target state="translated">Как оператор верхнего уровня, экспериментальная прагма включает функцию для остальной части модуля, в которой она включена. Это проблематично для макросов и общих экземпляров, которые выходят за пределы области действия модуля. В настоящее время эти использования должны быть помещены в &lt;code&gt;.push/pop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1cc9ba3f444ef5f2a70c370287d23a7b3c9d81c8" translate="yes" xml:space="preserve">
          <source>As an example,</source>
          <target state="translated">В качестве примера,</target>
        </trans-unit>
        <trans-unit id="4faf2cad17e66616bc46eb370913033cba7d7ffe" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, C's macros with parameters are mapped to Nim's templates. This mapping is the best one can do, but it is of course not accurate: Nim's templates operate on syntax trees whereas C's macros work on the token level. c2nim cannot translate any macro that contains the &lt;code&gt;##&lt;/code&gt; token concatenation operator.</source>
          <target state="translated">Как видно из примера, макросы C с параметрами отображаются на шаблоны Nim. Это сопоставление - лучшее, что можно сделать, но оно, конечно, неточно: шаблоны Nim работают с синтаксическими деревьями, тогда как макросы C работают на уровне токенов. c2nim не может переводить ни один макрос, содержащий оператор конкатенации токенов &lt;code&gt;##&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="033710d5a2d1054844b9448ca63a783fde847ed0" translate="yes" xml:space="preserve">
          <source>As can be seen from the example, it is possible to both specify a field's ordinal value and its string value by using a tuple. It is also possible to only specify one of them.</source>
          <target state="translated">Как видно из примера,с помощью кортежа можно как указать порядковое значение поля,так и его строковое значение.Также можно указать только одно из них.</target>
        </trans-unit>
        <trans-unit id="33db679c8421cd1a5bcfed816339b58d55a90cf0" translate="yes" xml:space="preserve">
          <source>As can be seen from the examples, strings are matched verbatim except for substrings starting with &lt;code&gt;$&lt;/code&gt;. These constructions are available:</source>
          <target state="translated">Как видно из примеров, строки сопоставляются дословно, за исключением подстрок, начинающихся с &lt;code&gt;$&lt;/code&gt; . Доступны такие конструкции:</target>
        </trans-unit>
        <trans-unit id="3690ed0de51a088f748c4a5d9756e00f903b6456" translate="yes" xml:space="preserve">
          <source>As can be seen in the example, base methods have to be annotated with the &lt;span id=&quot;base_1&quot;&gt;base&lt;/span&gt; pragma. The &lt;code&gt;base&lt;/code&gt; pragma also acts as a reminder for the programmer that a base method &lt;code&gt;m&lt;/code&gt; is used as the foundation to determine all the effects that a call to &lt;code&gt;m&lt;/code&gt; might cause.</source>
          <target state="translated">Как видно из примера, базовые методы должны быть аннотированы &lt;span id=&quot;base_1&quot;&gt;базовой&lt;/span&gt; прагмой. &lt;code&gt;base&lt;/code&gt; прагма также выступает в качестве напоминания для программиста , что базовый метод &lt;code&gt;m&lt;/code&gt; используются в качестве основы для определения всех эффектов , что вызов &lt;code&gt;m&lt;/code&gt; может вызвать.</target>
        </trans-unit>
        <trans-unit id="a5a364bd18b5eaef7b5722d6cd78c85c92bfa5dd" translate="yes" xml:space="preserve">
          <source>As can be seen in the productions, numerical constants can contain underscores for readability. Integer and floating point literals may be given in decimal (no prefix), binary (prefix &lt;code&gt;0b&lt;/code&gt;), octal (prefix &lt;code&gt;0o&lt;/code&gt;) and hexadecimal (prefix &lt;code&gt;0x&lt;/code&gt;) notation.</source>
          <target state="translated">Как видно из продукции, числовые константы могут содержать символы подчеркивания для удобства чтения. Целочисленные и плавающие литералы могут быть представлены в десятичной (без префикса), двоичной (префикс &lt;code&gt;0b&lt;/code&gt; ), восьмеричной (префикс &lt;code&gt;0o&lt;/code&gt; ) и шестнадцатеричной (префикс &lt;code&gt;0x&lt;/code&gt; ) нотации.</target>
        </trans-unit>
        <trans-unit id="7dad921df2b5a3cd443f8e5461c7a9ccced2c050" translate="yes" xml:space="preserve">
          <source>As can been seen from the example, an advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">Как видно из примера,преимущество иерархии объектов состоит в том,что нет необходимости в кастинге между различными типами объектов.Тем не менее,доступ к недействительным полям объектов приводит к возникновению исключения.</target>
        </trans-unit>
        <trans-unit id="86acee0719e4df42b833d89f9ce00671880b3bee" translate="yes" xml:space="preserve">
          <source>As can been seen from the example, an advantage to an object hierarchy is that no conversion between different object types is needed. Yet, access to invalid object fields raises an exception.</source>
          <target state="translated">Как видно из примера,преимущество иерархии объектов состоит в том,что нет необходимости в преобразовании между различными типами объектов.Тем не менее,доступ к недействительным полям объектов приводит к возникновению исключения.</target>
        </trans-unit>
        <trans-unit id="8bd2dc16961a30c8b20a5aa5ef6562993b9d9ea9" translate="yes" xml:space="preserve">
          <source>As case statements perform compile-time exhaustiveness checks, the value in every &lt;code&gt;of&lt;/code&gt; branch must be known at compile time. This fact is also exploited to generate more performant code.</source>
          <target state="translated">Поскольку операторы case выполняют проверки полноты во время компиляции, значение в каждой &lt;code&gt;of&lt;/code&gt; веток должно быть известно во время компиляции. Этот факт также используется для создания более производительного кода.</target>
        </trans-unit>
        <trans-unit id="a3cf4fdd8a46537cb17ba2fc74bca88aa30a4384" translate="yes" xml:space="preserve">
          <source>As convention this proc will split index files into two categories: documentation and API. API indices will be all joined together into a single big sorted index, making the bulk of the final index. This is good for API documentation because many symbols are repated in different modules. On the other hand, documentation indices are essentially table of contents plus a few special markers. These documents will be rendered in a separate section which tries to maintain the order and hierarchy of the symbols in the index file.</source>
          <target state="translated">По соглашению этот proc разделит индексные файлы на две категории:документация и API.Все индексы API будут объединены в один большой отсортированный индекс,составляющий основную часть конечного индекса.Это хорошо для документации по API,потому что многие символы повторяются в разных модулях.С другой стороны,индексы документации-это,по сути,оглавление плюс несколько специальных маркеров.Эти документы будут представлены в отдельной секции,которая пытается поддерживать порядок и иерархию символов в индексном файле.</target>
        </trans-unit>
        <trans-unit id="e35fce15f7b6d0e8ddfe4a222398b9462fecc9a2" translate="yes" xml:space="preserve">
          <source>As in generics symbol binding can be influenced via &lt;code&gt;mixin&lt;/code&gt; or &lt;code&gt;bind&lt;/code&gt; statements.</source>
          <target state="translated">Как и в универсальных шаблонах, на привязку символов можно влиять с помощью операторов &lt;code&gt;mixin&lt;/code&gt; или &lt;code&gt;bind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0887bf802c49a565d93917f60c9350172010518c" translate="yes" xml:space="preserve">
          <source>As it can be seen, for an &lt;code&gt;of&lt;/code&gt; branch a comma separated list of values is also allowed.</source>
          <target state="translated">Как можно видеть, для &lt;code&gt;of&lt;/code&gt; ветви разделенных запятыми список значений также допускается.</target>
        </trans-unit>
        <trans-unit id="026e19060b7027adb0d7fdc31274d77b9a547e42" translate="yes" xml:space="preserve">
          <source>As long as a type &lt;code&gt;T&lt;/code&gt; is incomplete &lt;code&gt;sizeof(T)&lt;/code&gt; or &quot;runtime type information&quot; for &lt;code&gt;T&lt;/code&gt; is not available.</source>
          <target state="translated">Пока тип &lt;code&gt;T&lt;/code&gt; является неполным, &lt;code&gt;sizeof(T)&lt;/code&gt; или &amp;laquo;информация о типе времени выполнения&amp;raquo; для &lt;code&gt;T&lt;/code&gt; недоступна.</target>
        </trans-unit>
        <trans-unit id="2dca63b7a6f1fd2e2ca6e65f781d803b65614773" translate="yes" xml:space="preserve">
          <source>As long as you don't use the threadvar emulation Nim uses native thread variables, of which you get a fresh version whenever you create a thread. You can then attach a GC to this thread via</source>
          <target state="translated">До тех пор,пока Вы не используете эмуляцию threadvar,Nim использует родные переменные потока,из которых Вы получаете свежую версию всякий раз,когда создаете поток.Затем вы можете прикрепить GC к этому потоку через</target>
        </trans-unit>
        <trans-unit id="26a74fa3cef27390dd0524bd6f48c70bfa5b9b01" translate="yes" xml:space="preserve">
          <source>As many &lt;code&gt;nnkIdent&lt;/code&gt; appear as there are pragmas between &lt;code&gt;{..}&lt;/code&gt;. Note that the declaration of new pragmas is essentially the same:</source>
          <target state="translated">&lt;code&gt;nnkIdent&lt;/code&gt; столько nnkIdent, сколько прагм между &lt;code&gt;{..}&lt;/code&gt; . Обратите внимание, что объявление новых прагм по сути то же самое:</target>
        </trans-unit>
        <trans-unit id="45b0ed81197cf305d45603349a135b9f85fd6ed7" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, the built-in &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; (stringify) operator turns any basic type into a string, which you can then print to the console using the &lt;code&gt;echo&lt;/code&gt; proc. However, advanced types, and your own custom types, won't work with the &lt;code&gt;$&lt;/code&gt; operator until you define it for them. Sometimes you just want to debug the current value of a complex type without having to write its &lt;code&gt;$&lt;/code&gt; operator. You can use then the &lt;a href=&quot;system#repr&quot;&gt;repr&lt;/a&gt; proc which works with any type and even complex data graphs with cycles. The following example shows that even for basic types there is a difference between the &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;repr&lt;/code&gt; outputs:</source>
          <target state="translated">Как упоминалось ранее, встроенный оператор &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; (stringify) превращает любой базовый тип в строку, которую затем можно вывести на консоль с помощью процедуры &lt;code&gt;echo&lt;/code&gt; . Однако расширенные типы и ваши собственные типы не будут работать с оператором &lt;code&gt;$&lt;/code&gt; , пока вы не определите его для них. Иногда вы просто хотите отладить текущее значение сложного типа без необходимости писать его оператор &lt;code&gt;$&lt;/code&gt; . Затем вы можете использовать процесс &lt;a href=&quot;system#repr&quot;&gt;repr,&lt;/a&gt; который работает с любыми типами и даже со сложными графиками данных с циклами. Следующий пример показывает, что даже для базовых типов есть разница между выходными &lt;code&gt;repr&lt;/code&gt; &lt;code&gt;$&lt;/code&gt; и repr :</target>
        </trans-unit>
        <trans-unit id="5c0e6c3f6dc802ee854147fa74a0509740327d59" translate="yes" xml:space="preserve">
          <source>As seen in the above example, the case expression can also introduce side effects. When multiple statements are given for a branch, Nim will use the last expression as the result value, much like in an &lt;em&gt;expr&lt;/em&gt; template.</source>
          <target state="translated">Как видно из приведенного выше примера, выражение case также может вызывать побочные эффекты. Когда для ветки задано несколько операторов, Nim будет использовать последнее выражение в качестве значения результата, как в шаблоне &lt;em&gt;expr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="439f48dfdc54a1d1cb2592abb741204d4e9306e5" translate="yes" xml:space="preserve">
          <source>As seen in the previous example, in such instantiations, it's not necessary to supply all type parameters of the generic type, because any missing ones will be inferred to have the equivalent of the &lt;em&gt;any&lt;/em&gt; type class and thus they will match anything without discrimination.</source>
          <target state="translated">Как видно из предыдущего примера, в таких экземплярах нет необходимости предоставлять все параметры типа универсального типа, потому что любые отсутствующие параметры будут считаться эквивалентными классу &lt;em&gt;любого&lt;/em&gt; типа, и, таким образом, они будут соответствовать чему угодно без дискриминации.</target>
        </trans-unit>
        <trans-unit id="b6e6a7e96d415104630cd8f0ead0c140e77a0902" translate="yes" xml:space="preserve">
          <source>As seen in the previous examples, you can refer to generic concepts such as &lt;em&gt;Enumerable[T]&lt;/em&gt; just by their short name. Much like the regular generic types, the concept will be automatically instantiated with the bind once auto type in the place of each missing generic param.</source>
          <target state="translated">Как видно из предыдущих примеров, вы можете ссылаться на общие концепции, такие как &lt;em&gt;Enumerable [T],&lt;/em&gt; просто по их короткому имени. Как и в случае с обычными универсальными типами, концепция будет автоматически создана с привязкой после автоматического ввода вместо каждого отсутствующего универсального параметра.</target>
        </trans-unit>
        <trans-unit id="e9c1fc890399facee98adf935d7347503148926c" translate="yes" xml:space="preserve">
          <source>As such it supports a resolution of nanoseconds internally; however the API uses microseconds for convenience.</source>
          <target state="translated">Как таковой он поддерживает внутреннее разрешение в наносекундах,однако для удобства API использует микросекунды.</target>
        </trans-unit>
        <trans-unit id="01367ae653af83b7f5aec2955cfd950745102be9" translate="yes" xml:space="preserve">
          <source>As such, a check to see if the deque is empty is needed before any access, unless your program logic guarantees it indirectly.</source>
          <target state="translated">Поэтому перед любым доступом необходимо проверить,не пуст ли дека,если только ваша программная логика не гарантирует этого косвенно.</target>
        </trans-unit>
        <trans-unit id="286afc9752bec98ed25f43fb3fd09c91c5151ede" translate="yes" xml:space="preserve">
          <source>As the above example shows, Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this a special setter syntax is needed:</source>
          <target state="translated">Как показано в приведенном выше примере, Nim не нуждается в &lt;em&gt;свойствах get&lt;/em&gt; : обычные процедуры get, вызываемые с помощью &lt;em&gt;синтаксиса вызова метода,&lt;/em&gt; достигают того же. Но установка значения отличается; для этого необходим специальный синтаксис сеттера:</target>
        </trans-unit>
        <trans-unit id="e739d8d09978b2dcb0c312361958c802f83a064a" translate="yes" xml:space="preserve">
          <source>As the example demonstrates, invocation of a multi-method cannot be ambiguous: Collide 2 is preferred over collide 1 because the resolution works from left to right. Thus &lt;code&gt;Unit, Thing&lt;/code&gt; is preferred over &lt;code&gt;Thing, Unit&lt;/code&gt;.</source>
          <target state="translated">Как показывает пример, вызов нескольких методов не может быть неоднозначным: Collide 2 предпочтительнее, чем collide 1, потому что разрешение работает слева направо. Таким образом, &lt;code&gt;Unit, Thing&lt;/code&gt; предпочтительнее &lt;code&gt;Thing, Unit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4eb5ab0367cdd1ab709d3f90ffd6f79cf740c8bc" translate="yes" xml:space="preserve">
          <source>As the example shows &lt;code&gt;computedGoto&lt;/code&gt; is mostly useful for interpreters. If the underlying backend (C compiler) does not support the computed goto extension the pragma is simply ignored.</source>
          <target state="translated">Как показывает пример, &lt;code&gt;computedGoto&lt;/code&gt; в основном полезен для интерпретаторов. Если базовый сервер (компилятор C) не поддерживает вычисленное расширение goto, прагма просто игнорируется.</target>
        </trans-unit>
        <trans-unit id="aa6410949c68317244c63b45dcd8f86123a06792" translate="yes" xml:space="preserve">
          <source>As the example shows, passing arguments to a filter can be done just like an ordinary procedure call with named or positional arguments. The available parameters depend on the invoked filter. Before version 0.12.0 of the language &lt;code&gt;#!&lt;/code&gt; was used instead of &lt;code&gt;#?&lt;/code&gt;.</source>
          <target state="translated">Как показывает пример, передача аргументов фильтру может выполняться так же, как вызов обычной процедуры с именованными или позиционными аргументами. Доступные параметры зависят от активированного фильтра. До версии 0.12.0 языка &lt;code&gt;#!&lt;/code&gt; использовалось вместо &lt;code&gt;#?&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="27d5a0e7057a8c33abd1db459e64ad340a213114" translate="yes" xml:space="preserve">
          <source>As the regular expressions supported by this module are enormous, the reader is referred to &lt;a href=&quot;http://perldoc.perl.org/perlre.html&quot;&gt;http://perldoc.perl.org/perlre.html&lt;/a&gt; for the full documentation of Perl's regular expressions.</source>
          <target state="translated">Поскольку регулярные выражения, поддерживаемые этим модулем, огромны, читатель может найти полную документацию по регулярным выражениям Perl на &lt;a href=&quot;http://perldoc.perl.org/perlre.html&quot;&gt;http://perldoc.perl.org/perlre.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="868dd43083390b7b1e29d7736d8260c51c9f2330" translate="yes" xml:space="preserve">
          <source>As their name suggests, static parameters must be known at compile-time:</source>
          <target state="translated">Как следует из их названия,статические параметры должны быть известны во время компиляции:</target>
        </trans-unit>
        <trans-unit id="62dcfc00fb0387dbffe758f0f4162e7a2adedb56" translate="yes" xml:space="preserve">
          <source>As usual &lt;code&gt;locks&lt;/code&gt; is an inferred effect and there is a subtype relation: &lt;code&gt;proc () {.locks: N.}&lt;/code&gt; is a subtype of &lt;code&gt;proc () {.locks: M.}&lt;/code&gt; iff (M &amp;lt;= N).</source>
          <target state="translated">Как обычно, &lt;code&gt;locks&lt;/code&gt; - это предполагаемый эффект и существует отношение подтипа: &lt;code&gt;proc () {.locks: N.}&lt;/code&gt; - это подтип &lt;code&gt;proc () {.locks: M.}&lt;/code&gt; iff (M &amp;lt;= N).</target>
        </trans-unit>
        <trans-unit id="8a7e3825909e47cd662a1349cd9c1f9bb88f142c" translate="yes" xml:space="preserve">
          <source>Asm statement</source>
          <target state="translated">заявление Асма</target>
        </trans-unit>
        <trans-unit id="02bb6749711a6c6662b3a9fd807816e9e50ff52d" translate="yes" xml:space="preserve">
          <source>Assembler statement</source>
          <target state="translated">Ассемблерское заявление</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="d726d517f001352072c6361a864be12f97f89db4" translate="yes" xml:space="preserve">
          <source>Assignment compatibility</source>
          <target state="translated">Совместимость назначений</target>
        </trans-unit>
        <trans-unit id="d9203ef0427904fd0cb4f5281674fd37cff746c1" translate="yes" xml:space="preserve">
          <source>Assignments are not special, the left-hand-side expression is evaluated before the right-hand side:</source>
          <target state="translated">Назначения не являются специальными,левостороннее выражение оценивается перед правосторонним:</target>
        </trans-unit>
        <trans-unit id="1091ff5f3536a87992e1a98e7fdf3572d7d495bf" translate="yes" xml:space="preserve">
          <source>Associate application-defined &lt;code&gt;data&lt;/code&gt; with descriptor &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">Свяжите определяемые приложением &lt;code&gt;data&lt;/code&gt; с дескриптором &lt;code&gt;fd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="c10e87299448214997c9ba36a197edc020ad8d7c" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;a href=&quot;#readHeaderRow.CsvParser&quot;&gt;readHeaderRow&lt;/a&gt; has already been called.</source>
          <target state="translated">Предполагает, что &lt;a href=&quot;#readHeaderRow.CsvParser&quot;&gt;readHeaderRow&lt;/a&gt; уже был вызван.</target>
        </trans-unit>
        <trans-unit id="464eb5858db553f9a4e084882b2d692e14f18a75" translate="yes" xml:space="preserve">
          <source>Async IO in Nim consists of multiple layers (from highest to lowest):</source>
          <target state="translated">Async IO в Nim состоит из нескольких слоев (от высшего до низшего):</target>
        </trans-unit>
        <trans-unit id="d57562f32a2344e4a892e8ad77de461a0dddac00" translate="yes" xml:space="preserve">
          <source>Async alternative to TFTPClient.</source>
          <target state="translated">Асинхронная альтернатива TFTPClient.</target>
        </trans-unit>
        <trans-unit id="61a0af2d907e2fd6001d764ad03dc8d1c0e711f3" translate="yes" xml:space="preserve">
          <source>Async await</source>
          <target state="translated">Async ждёт</target>
        </trans-unit>
        <trans-unit id="bb9065007b1394a4c890c8c730359a31cd3d4af2" translate="yes" xml:space="preserve">
          <source>Async version of &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">Асинхронная версия &lt;code&gt;recv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48e12dfeb54ee671e650066950d5a652045b9307" translate="yes" xml:space="preserve">
          <source>AsyncDispatch</source>
          <target state="translated">AsyncDispatch</target>
        </trans-unit>
        <trans-unit id="8b371c51c3d43e683cda1ca13b2b61e13b7f6e7b" translate="yes" xml:space="preserve">
          <source>Asynchronous IO in Nim</source>
          <target state="translated">Асинхронный ввод-вывод в Ним.</target>
        </trans-unit>
        <trans-unit id="7b9ef39877db01dd17657705a2bbb4a6bc49d720" translate="yes" xml:space="preserve">
          <source>Asynchronous procedures</source>
          <target state="translated">асинхронные процедуры</target>
        </trans-unit>
        <trans-unit id="c80b1fc2540985a4b46e1a0759e789f85aac96b9" translate="yes" xml:space="preserve">
          <source>Asynchronous procedures remove the pain of working with callbacks. They do this by allowing you to write asynchronous code the same way as you would write synchronous code.</source>
          <target state="translated">Асинхронные процедуры снимают боль при работе с обратными вызовами.Они делают это,позволяя писать асинхронный код так же,как вы бы писали синхронный код.</target>
        </trans-unit>
        <trans-unit id="b4324fe839ee2fc80392c528dbb2288500cc3cc5" translate="yes" xml:space="preserve">
          <source>Asynchronous sockets</source>
          <target state="translated">асинхронные розетки</target>
        </trans-unit>
        <trans-unit id="04fc05d16ff1681dbd084361e286ad3b082b3c13" translate="yes" xml:space="preserve">
          <source>Asynchronous sockets are supported, however a better alternative is to use the &lt;a href=&quot;asyncio&quot;&gt;asyncio&lt;/a&gt; module.</source>
          <target state="translated">Поддерживаются асинхронные сокеты, однако лучшей альтернативой является использование модуля &lt;a href=&quot;asyncio&quot;&gt;asyncio&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c54cd214970569c34b0894bafdff80b326240d3" translate="yes" xml:space="preserve">
          <source>At runtime the dynamic library is searched for (in this order):</source>
          <target state="translated">Во время выполнения выполняется поиск динамической библиотеки (в таком порядке):</target>
        </trans-unit>
        <trans-unit id="1e0afa779399055030a34271b80bf03107242a5a" translate="yes" xml:space="preserve">
          <source>At the moment idetools support is still in development so the test suite is not integrated with the main test suite and you have to run it manually. First you have to compile the tester:</source>
          <target state="translated">На данный момент поддержка idetools все еще находится в разработке,поэтому тестовый набор не интегрирован с основным тестовым набором и его приходится запускать вручную.Сначала необходимо скомпилировать тестер:</target>
        </trans-unit>
        <trans-unit id="f92987b2f51905d6ac8ecf565a309b7358bafb43" translate="yes" xml:space="preserve">
          <source>At this time only &lt;em&gt;fastLog2&lt;/em&gt;, &lt;em&gt;firstSetBit, `countLeadingZeroBits&lt;/em&gt;, &lt;em&gt;countTrailingZeroBits&lt;/em&gt; may return undefined and/or platform dependant value if given invalid input.</source>
          <target state="translated">В настоящее время только &lt;em&gt;fastLog2&lt;/em&gt; , &lt;em&gt;firstSetBit, `countLeadingZeroBits&lt;/em&gt; , &lt;em&gt;countTrailingZeroBits&lt;/em&gt; могут возвращать неопределенное и / или зависящее от платформы значение, если задан неверный ввод.</target>
        </trans-unit>
        <trans-unit id="dc088b4a46ed03929326ec3129e2350a99f0a990" translate="yes" xml:space="preserve">
          <source>Auto type</source>
          <target state="translated">Автоматический тип</target>
        </trans-unit>
        <trans-unit id="9e0bd780b5a4993d6aec3f619069ec9a81419d34" translate="yes" xml:space="preserve">
          <source>Automatic dereferencing</source>
          <target state="translated">Автоматическая разыменовка</target>
        </trans-unit>
        <trans-unit id="b34f3f41021aba6582ca800065938665aaa25537" translate="yes" xml:space="preserve">
          <source>Automatic dereferencing is also performed for the first argument of a routine call. But currently this feature has to be only enabled via &lt;code&gt;{.experimental: &quot;implicitDeref&quot;.}&lt;/code&gt;:</source>
          <target state="translated">Автоматическое разыменование также выполняется для первого аргумента обычного вызова. Но в настоящее время эту функцию необходимо включать только через &lt;code&gt;{.experimental: &quot;implicitDeref&quot;.}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f2f8a2fddb2e537990a2864cb34d8eee2d1446d" translate="yes" xml:space="preserve">
          <source>Automatic self insertions</source>
          <target state="translated">Автоматические самонаводящиеся вставки</target>
        </trans-unit>
        <trans-unit id="d489cd84b7c72c977a3c1f79e61d852ca4f5fd46" translate="yes" xml:space="preserve">
          <source>Automatic type conversion in expressions with different kinds of floating point types is performed: See &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Convertible relation&lt;/a&gt; for further details. Arithmetic performed on floating point types follows the IEEE standard. Integer types are not converted to floating point types automatically and vice versa.</source>
          <target state="translated">Выполняется автоматическое преобразование типов в выражениях с различными типами типов с плавающей запятой: Подробнее см. &lt;a href=&quot;#type-relations-convertible-relation&quot;&gt;Конвертируемое отношение&lt;/a&gt; . Арифметика, выполняемая с типами с плавающей запятой, соответствует стандарту IEEE. Целочисленные типы не преобразуются в типы с плавающей запятой автоматически, и наоборот.</target>
        </trans-unit>
        <trans-unit id="b64d4599316074da7ef005b5cd10b87308f8b012" translate="yes" xml:space="preserve">
          <source>Automatic type conversion in expressions with different kinds of floating point types is performed: the smaller type is converted to the larger. Integer types are &lt;strong&gt;not&lt;/strong&gt; converted to floating point types automatically, nor vice versa. Use the &lt;a href=&quot;system#toInt&quot;&gt;toInt&lt;/a&gt; and &lt;a href=&quot;system#toFloat&quot;&gt;toFloat&lt;/a&gt; procs for these conversions.</source>
          <target state="translated">Выполняется автоматическое преобразование типов в выражениях с разными типами типов с плавающей запятой: меньший тип преобразуется в больший. Целочисленные типы &lt;strong&gt;не&lt;/strong&gt; преобразуются в типы с плавающей запятой автоматически, и наоборот. Используйте &lt;a href=&quot;system#toInt&quot;&gt;процессы toInt&lt;/a&gt; и &lt;a href=&quot;system#toFloat&quot;&gt;toFloat&lt;/a&gt; для этих преобразований.</target>
        </trans-unit>
        <trans-unit id="bc40764f7876b20ac068b0f8a1ac400c090ad482" translate="yes" xml:space="preserve">
          <source>Available filters</source>
          <target state="translated">Доступные фильтры</target>
        </trans-unit>
        <trans-unit id="48dc005192dc15899b10a69113ce172a5a8e8e1d" translate="yes" xml:space="preserve">
          <source>Avoiding SQL injection attacks</source>
          <target state="translated">Предотвращение атак SQL инъекций</target>
        </trans-unit>
        <trans-unit id="ed59754f17e7c2d9945cda54ca5d2aa1dec958df" translate="yes" xml:space="preserve">
          <source>Back reference to the &lt;code&gt;i``th capture. ``i&lt;/code&gt; counts from 1.</source>
          <target state="translated">Обратная ссылка на &lt;code&gt;i``th capture. ``i&lt;/code&gt; считаю от 1.</target>
        </trans-unit>
        <trans-unit id="c1b87da997dc3c85ddc08c2e6d0f37c746574592" translate="yes" xml:space="preserve">
          <source>Backend code calling Nim</source>
          <target state="translated">Бэкэнд код вызова Ним</target>
        </trans-unit>
        <trans-unit id="d2d1e1c764fd65afb7dd5b1cfc7187320a368f3d" translate="yes" xml:space="preserve">
          <source>Backend code can interface with Nim code exposed through the &lt;a href=&quot;manual#exportc-pragma&quot;&gt;exportc pragma&lt;/a&gt;. The &lt;code&gt;exportc&lt;/code&gt; pragma is the &lt;em&gt;generic&lt;/em&gt; way of making Nim symbols available to the backends. By default the Nim compiler will mangle all the Nim symbols to avoid any name collision, so the most significant thing the &lt;code&gt;exportc&lt;/code&gt; pragma does is maintain the Nim symbol name, or if specified, use an alternative symbol for the backend in case the symbol rules don't match.</source>
          <target state="translated">Бэкэнд-код может взаимодействовать с кодом Nim, предоставляемым с помощью &lt;a href=&quot;manual#exportc-pragma&quot;&gt;директивы exportc&lt;/a&gt; . &lt;code&gt;exportc&lt;/code&gt; Прагма является &lt;em&gt;общим&lt;/em&gt; способом создания символов Nim доступных для движков. По умолчанию компилятор Nim искажает все символы Nim, чтобы избежать конфликтов имен, поэтому самая важная вещь, которую &lt;code&gt;exportc&lt;/code&gt; прагма exportc , - это поддерживать имя символа Nim или, если указано, использовать альтернативный символ для бэкэнда в случае, если правила символов не не совпадают.</target>
        </trans-unit>
        <trans-unit id="4409ab544e7304fef23a5593b1e7c39ba4acd8f5" translate="yes" xml:space="preserve">
          <source>Backend issues</source>
          <target state="translated">Бэкэндовые проблемы</target>
        </trans-unit>
        <trans-unit id="b76b69c33162b1653a17f2c6f93e78edc8380818" translate="yes" xml:space="preserve">
          <source>Backend language options</source>
          <target state="translated">Варианты языка бэкэнда</target>
        </trans-unit>
        <trans-unit id="b3776d63ad7b7a84bfe20d9c6d4a53a2b25d0e43" translate="yes" xml:space="preserve">
          <source>Backends</source>
          <target state="translated">Backends</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="d761e5a62561f09ed0d44ad1cb46328e1f217a6f" translate="yes" xml:space="preserve">
          <source>Backslashes are interpreted literally, unless they immediately precede a double quotation mark.</source>
          <target state="translated">Пробелы интерпретируются буквально,если только они не предшествуют двойному кавычковому знаку.</target>
        </trans-unit>
        <trans-unit id="927ec03da92f02ddd56de8e2adaa715fed9bcf2d" translate="yes" xml:space="preserve">
          <source>Base class for floating point exceptions.</source>
          <target state="translated">Базовый класс для исключений с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="c01b2a5ff5b7f9aeb57693046b04a30f8f31374f" translate="yes" xml:space="preserve">
          <source>Base exception class.</source>
          <target state="translated">Класс базового исключения.</target>
        </trans-unit>
        <trans-unit id="a7eab2acbe559b446c1a8d7cd0fa8164b769b943" translate="yes" xml:space="preserve">
          <source>Base exception object for all DOM Exceptions</source>
          <target state="translated">Базовый объект исключения для всех DOM Исключений</target>
        </trans-unit>
        <trans-unit id="83973edfe760182bfdbc649edc3760f5c0702635" translate="yes" xml:space="preserve">
          <source>Base filename plus anchor hyper link (eg. &lt;code&gt;algorithm.html#*,int,SortOrder&lt;/code&gt;).</source>
          <target state="translated">Базовое имя файла плюс гиперссылка привязки (например, &lt;code&gt;algorithm.html#*,int,SortOrder&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="18bb69613ad5672181aef86b3bcfc02639a73650" translate="yes" xml:space="preserve">
          <source>Basic command line switches are:</source>
          <target state="translated">Основные переключатели командной строки:</target>
        </trans-unit>
        <trans-unit id="65e84bd37e76307cd618b3b242847f165ff6ea89" translate="yes" xml:space="preserve">
          <source>Basic math routines for Nim. This module is available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">Базовые математические процедуры для Nim. Этот модуль доступен для &lt;a href=&quot;backends#the-javascript-target&quot;&gt;цели JavaScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="translated">Основные типы</target>
        </trans-unit>
        <trans-unit id="8fc3f098aacbac78663d7394b49aef616d056323" translate="yes" xml:space="preserve">
          <source>Be aware that destructors are not called for objects allocated with &lt;code&gt;new&lt;/code&gt;. This may change in future versions of language, but for now the &lt;span id=&quot;finalizer_1&quot;&gt;finalizer&lt;/span&gt; parameter to &lt;code&gt;new&lt;/code&gt; has to be used.</source>
          <target state="translated">Имейте в виду, что деструкторы не вызываются для объектов, выделенных с помощью &lt;code&gt;new&lt;/code&gt; . Это может измениться в будущих версиях языка, но сейчас необходимо использовать параметр &lt;span id=&quot;finalizer_1&quot;&gt;финализатора&lt;/span&gt; на &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3e15a7b46caea989a1213b44375d001f13628fc" translate="yes" xml:space="preserve">
          <source>Be sure your callback &lt;code&gt;cb&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, if you want to remove watch of &lt;em&gt;read&lt;/em&gt; notifications, and &lt;code&gt;false&lt;/code&gt;, if you want to continue receiving notifications.</source>
          <target state="translated">Убедитесь, что ваш обратный вызов &lt;code&gt;cb&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , если вы хотите убрать просмотр уведомлений о &lt;em&gt;прочтении&lt;/em&gt; , и &lt;code&gt;false&lt;/code&gt; , если вы хотите продолжать получать уведомления.</target>
        </trans-unit>
        <trans-unit id="8fba0a783eb77900741ec80cede356c924d6db33" translate="yes" xml:space="preserve">
          <source>Be sure your callback &lt;code&gt;cb&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, if you want to remove watch of &lt;em&gt;write&lt;/em&gt; notifications, and &lt;code&gt;false&lt;/code&gt;, if you want to continue receiving notifications.</source>
          <target state="translated">Убедитесь, что ваш обратный вызов &lt;code&gt;cb&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , если вы хотите убрать наблюдение за уведомлениями о &lt;em&gt;записи&lt;/em&gt; , и &lt;code&gt;false&lt;/code&gt; , если вы хотите продолжать получать уведомления.</target>
        </trans-unit>
        <trans-unit id="c4102f62e5cacc86882ccbd463d607ec09aa3efa" translate="yes" xml:space="preserve">
          <source>Because the backslash &lt;code&gt;\&lt;/code&gt; is a meta character both in the Nim programming language and in regular expressions, it is strongly recommended that one uses the &lt;em&gt;raw&lt;/em&gt; strings of Nim, so that backslashes are interpreted by the regular expression engine:</source>
          <target state="translated">Поскольку обратная косая черта &lt;code&gt;\&lt;/code&gt; является метасимволом как в языке программирования Nim, так и в регулярных выражениях, настоятельно рекомендуется использовать &lt;em&gt;необработанные&lt;/em&gt; строки Nim, чтобы обратная косая черта интерпретировалась механизмом регулярных выражений:</target>
        </trans-unit>
        <trans-unit id="9712a92a80197b448150bfcf6e22b8f9c9c72490" translate="yes" xml:space="preserve">
          <source>Because the literal is a raw string literal, the &lt;code&gt;\n&lt;/code&gt; is not interpreted as an escape sequence.</source>
          <target state="translated">Поскольку литерал является необработанным строковым литералом, &lt;code&gt;\n&lt;/code&gt; не интерпретируется как escape-последовательность.</target>
        </trans-unit>
        <trans-unit id="d8fb87298b9236d186e536c812e43df39ea168a6" translate="yes" xml:space="preserve">
          <source>Because the underlying &lt;code&gt;cmp()&lt;/code&gt; is defined for tuples you can do a nested sort like in the following example:</source>
          <target state="translated">Поскольку базовый &lt;code&gt;cmp()&lt;/code&gt; определен для кортежей, вы можете выполнять вложенную сортировку, как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="d6d168f46ea8f3c36c56fc3253836f0e10427b1e" translate="yes" xml:space="preserve">
          <source>Before stopping the program the &quot;quit procedures&quot; are called in the opposite order they were added with &lt;a href=&quot;#addQuitProc&quot;&gt;addQuitProc&lt;/a&gt;. &lt;code&gt;quit&lt;/code&gt; never returns and ignores any exception that may have been raised by the quit procedures. It does &lt;em&gt;not&lt;/em&gt; call the garbage collector to free all the memory, unless a quit procedure calls &lt;a href=&quot;#GC_fullCollect&quot;&gt;GC_fullCollect&lt;/a&gt;.</source>
          <target state="translated">Перед остановкой программы вызываются &amp;laquo;процедуры выхода&amp;raquo; в обратном порядке, в котором они были добавлены с помощью &lt;a href=&quot;#addQuitProc&quot;&gt;addQuitProc&lt;/a&gt; . &lt;code&gt;quit&lt;/code&gt; никогда не возвращает и игнорирует любые исключения, которые могли быть вызваны процедурами выхода. Он &lt;em&gt;не&lt;/em&gt; вызывает сборщик мусора для освобождения всей памяти, если процедура выхода не вызывает &lt;a href=&quot;#GC_fullCollect&quot;&gt;GC_fullCollect&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43d498bdad3123202c81edb42a89596ea2e8269d" translate="yes" xml:space="preserve">
          <source>Before the line is processed as a regular expression, some basic variables are searched for and replaced in the tests. The variables which will be replaced are:</source>
          <target state="translated">Перед тем,как строка будет обработана как регулярное выражение,производится поиск и замена некоторых основных переменных в тестах.Заменяемые переменные:</target>
        </trans-unit>
        <trans-unit id="b0e4a0c03109bf4544e258937ad71acfe78c0f79" translate="yes" xml:space="preserve">
          <source>Before the thread exits, you should tear down the thread's GC to prevent memory leaks by calling</source>
          <target state="translated">Перед выходом из потока необходимо снести GC потока,чтобы предотвратить утечку памяти,позвонив по телефону</target>
        </trans-unit>
        <trans-unit id="310e2e763625e5d6d59dce2240ea063af385856f" translate="yes" xml:space="preserve">
          <source>Before using this proc you need to initialise a &lt;code&gt;RstGenerator&lt;/code&gt; with &lt;code&gt;initRstGenerator&lt;/code&gt; and parse a rst file with &lt;code&gt;rstParse&lt;/code&gt; from the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. Example:</source>
          <target state="translated">Перед использованием этой процедуры вам необходимо инициализировать &lt;code&gt;RstGenerator&lt;/code&gt; с помощью &lt;code&gt;initRstGenerator&lt;/code&gt; и проанализировать первый файл с помощью &lt;code&gt;rstParse&lt;/code&gt; из модуля &lt;a href=&quot;rst&quot;&gt;packages / documenttils / rst&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="966b254aa9447e510a7ca9c23d5f788a878f610b" translate="yes" xml:space="preserve">
          <source>Begins a never ending global dispatcher poll loop.</source>
          <target state="translated">Начинает бесконечный цикл опроса глобальных диспетчеров.</target>
        </trans-unit>
        <trans-unit id="700e73def7ceec3f6434ea58699b8763915742e0" translate="yes" xml:space="preserve">
          <source>Begins connecting &lt;code&gt;sock&lt;/code&gt; to &lt;code&gt;name&lt;/code&gt;:&lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">Начинает подключение &lt;code&gt;sock&lt;/code&gt; к &lt;code&gt;name&lt;/code&gt; : &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b6ca901e484b0f0288a15e878ab0c9feab7a2af" translate="yes" xml:space="preserve">
          <source>Behaves similar to &lt;code&gt;sockets.readLine&lt;/code&gt;, however it handles non-blocking sockets properly. This function guarantees that &lt;code&gt;line&lt;/code&gt; is a full line, if this function can only retrieve some data; it will save this data and add it to the result when a full line is retrieved, when this happens False will be returned. True will only be returned if a full line has been retrieved or the socket has been disconnected in which case &lt;code&gt;line&lt;/code&gt; will be set to &quot;&quot;.</source>
          <target state="translated">Действует аналогично &lt;code&gt;sockets.readLine&lt;/code&gt; , но правильно обрабатывает неблокирующие сокеты. Эта функция гарантирует, что &lt;code&gt;line&lt;/code&gt; является полной строкой, если эта функция может получить только некоторые данные; он сохранит эти данные и добавит их к результату, когда будет получена полная строка, когда это произойдет, будет возвращено False. Истина будет возвращена только в том случае, если была получена вся строка или сокет был отключен, и в этом случае &lt;code&gt;line&lt;/code&gt; будет установлена ​​в &quot;&quot;.</target>
        </trans-unit>
        <trans-unit id="c4326a5636a46dcb618755741f866f4b972d0a19" translate="yes" xml:space="preserve">
          <source>Behaves similar to &lt;code&gt;sockets.recvLine&lt;/code&gt;, however it handles non-blocking sockets properly. This function guarantees that &lt;code&gt;line&lt;/code&gt; is a full line, if this function can only retrieve some data; it will save this data and add it to the result when a full line is retrieved.</source>
          <target state="translated">Действует аналогично &lt;code&gt;sockets.recvLine&lt;/code&gt; , но правильно обрабатывает неблокирующие сокеты. Эта функция гарантирует, что &lt;code&gt;line&lt;/code&gt; является полной строкой, если эта функция может получить только некоторые данные; он сохранит эти данные и добавит их к результату при извлечении полной строки.</target>
        </trans-unit>
        <trans-unit id="265943f4fdc43174a25de385d384224b6714c3a1" translate="yes" xml:space="preserve">
          <source>Better serialization/deserialization control:</source>
          <target state="translated">Улучшение управления сериализацией/десериализацией:</target>
        </trans-unit>
        <trans-unit id="2f93848862aa5b35417b63e68af291d5b94657ce" translate="yes" xml:space="preserve">
          <source>Beware of nesting:</source>
          <target state="translated">Остерегайся гнездования:</target>
        </trans-unit>
        <trans-unit id="79d0274d51b13cfe02935327c0fc3f6297737534" translate="yes" xml:space="preserve">
          <source>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</source>
          <target state="translated">Берегись:Это может привести к неоптимизированному коду и медленному выполнению! Большинство проблем решаются более эффективно с помощью итератора или преобразования в seq Rune.</target>
        </trans-unit>
        <trans-unit id="07e70f2fb17a35e7addfb3cce97a4c40deb42dbf" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;*&lt;/em&gt; operator for an integer.</source>
          <target state="translated">Двоичный оператор &lt;em&gt;*&lt;/em&gt; для целого числа.</target>
        </trans-unit>
        <trans-unit id="b4d78a434e47f392f05a75db91b17acd6fe4fa07" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;*&lt;/em&gt; operator for unsigned integers.</source>
          <target state="translated">Двоичный оператор &lt;em&gt;*&lt;/em&gt; для целых чисел без знака.</target>
        </trans-unit>
        <trans-unit id="26698f4bdcaf441cc8334749d82e3e3d352fb191" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;*=&lt;/em&gt; operator for ordinals</source>
          <target state="translated">Двоичный &lt;em&gt;* =&lt;/em&gt; оператор для порядковых номеров</target>
        </trans-unit>
        <trans-unit id="330bd303262cb5101ce0efe34c05186ca99997f7" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;+&lt;/em&gt; operator for an integer.</source>
          <target state="translated">Двоичный оператор &lt;em&gt;+&lt;/em&gt; для целого числа.</target>
        </trans-unit>
        <trans-unit id="38c5372d40da823748edf7ea2383e6eece6eff5b" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;+&lt;/em&gt; operator for unsigned integers.</source>
          <target state="translated">Двоичный оператор &lt;em&gt;+&lt;/em&gt; для беззнаковых целых чисел.</target>
        </trans-unit>
        <trans-unit id="af8d9afe7721543aea25b34b98173554127fcd0b" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;-&lt;/em&gt; operator for an integer.</source>
          <target state="translated">Двоичный &lt;em&gt;-&lt;/em&gt; оператор для целого числа.</target>
        </trans-unit>
        <trans-unit id="8ccf951823bb2d33004b173d71cc94c3047b4785" translate="yes" xml:space="preserve">
          <source>Binary &lt;em&gt;-&lt;/em&gt; operator for unsigned integers.</source>
          <target state="translated">Двоичный &lt;em&gt;-&lt;/em&gt; оператор для беззнаковых целых чисел.</target>
        </trans-unit>
        <trans-unit id="560f98c3ead9f955754deb12fba064845d75b979" translate="yes" xml:space="preserve">
          <source>Binary operators whose first character is &lt;code&gt;^&lt;/code&gt; are right-associative, all other binary operators are left-associative.</source>
          <target state="translated">Бинарные операторы с первым символом &lt;code&gt;^&lt;/code&gt; являются правоассоциативными, все остальные бинарные операторы левоассоциативны.</target>
        </trans-unit>
        <trans-unit id="360d45a25b59088bfa51b40dd2c0ffd7a2333f6c" translate="yes" xml:space="preserve">
          <source>Binary. Outputs the number in base 2.</source>
          <target state="translated">Двоичная.Выводит число в базе 2.</target>
        </trans-unit>
        <trans-unit id="d087993ff800b452527c7966565ad3f6a2e4d837" translate="yes" xml:space="preserve">
          <source>Bind matching to some action</source>
          <target state="translated">Привязать соответствие к какому-либо действию</target>
        </trans-unit>
        <trans-unit id="af1a43872e0146a37b3fc6fec03f088b6f0c7d84" translate="yes" xml:space="preserve">
          <source>Bind statement</source>
          <target state="translated">Обязательное заявление</target>
        </trans-unit>
        <trans-unit id="d59366ada08751ecfdb863b4a3641304d02f31a6" translate="yes" xml:space="preserve">
          <source>BindSym</source>
          <target state="translated">BindSym</target>
        </trans-unit>
        <trans-unit id="e09df968e0a484a9efbeb94427ec16a9be185b7d" translate="yes" xml:space="preserve">
          <source>Binds &lt;code&gt;address&lt;/code&gt;:&lt;code&gt;port&lt;/code&gt; to the socket.</source>
          <target state="translated">Привязывает &lt;code&gt;address&lt;/code&gt; : &lt;code&gt;port&lt;/code&gt; к сокету.</target>
        </trans-unit>
        <trans-unit id="659ea289b78cfbcca53efa111220718b2e750524" translate="yes" xml:space="preserve">
          <source>Binds Unix socket to &lt;em&gt;path&lt;/em&gt;. This only works on Unix-style systems: Mac OS X, BSD and Linux</source>
          <target state="translated">Привязывает сокет Unix к &lt;em&gt;пути&lt;/em&gt; . Это работает только в системах в стиле Unix: Mac OS X, BSD и Linux.</target>
        </trans-unit>
        <trans-unit id="8e8aaeecce239b0f06469ead101c23881541a5d5" translate="yes" xml:space="preserve">
          <source>Bits for which fields are set</source>
          <target state="translated">Биты,для которых установлены поля</target>
        </trans-unit>
        <trans-unit id="cd3e66f022e12b57b1f5fe62492942f67ba04841" translate="yes" xml:space="preserve">
          <source>Bitsize pragma</source>
          <target state="translated">двузначная прагма</target>
        </trans-unit>
        <trans-unit id="234ac99e0a5dfd13079331f5a645966c4b4a76a7" translate="yes" xml:space="preserve">
          <source>Blank lines are skipped.</source>
          <target state="translated">Пустые строки пропущены.</target>
        </trans-unit>
        <trans-unit id="40f4277d9e2e9642b7c7082b91e613d62eab845f" translate="yes" xml:space="preserve">
          <source>Block device.</source>
          <target state="translated">Блок-устройство.</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">Блочный прицел</target>
        </trans-unit>
        <trans-unit id="d900d959e6c700afd03ab9e7a37649c54ebba876" translate="yes" xml:space="preserve">
          <source>Block statement</source>
          <target state="translated">Блок-схема</target>
        </trans-unit>
        <trans-unit id="f5b504d04d5a39d2d24b7595634cf4c7ea12b1e0" translate="yes" xml:space="preserve">
          <source>Blocks until a connection is being made from a client. When a connection is made sets &lt;code&gt;client&lt;/code&gt; to the client socket and &lt;code&gt;address&lt;/code&gt; to the address of the connecting client. If &lt;code&gt;server&lt;/code&gt; is non-blocking then this function returns immediately, and if there are no connections queued the returned socket will be &lt;code&gt;InvalidSocket&lt;/code&gt;. This function will raise EOS if an error occurs.</source>
          <target state="translated">Блокируется, пока не будет установлено соединение от клиента. Когда соединение установлено, &lt;code&gt;client&lt;/code&gt; устанавливается на клиентский сокет, а &lt;code&gt;address&lt;/code&gt; - на адрес подключающегося клиента. Если &lt;code&gt;server&lt;/code&gt; не блокирует, эта функция немедленно возвращается, а если в очереди нет соединений, возвращаемый сокет будет &lt;code&gt;InvalidSocket&lt;/code&gt; . Эта функция поднимет EOS в случае возникновения ошибки.</target>
        </trans-unit>
        <trans-unit id="6d6f90513642da6009f2dec4733272a1e46e96f3" translate="yes" xml:space="preserve">
          <source>Blocks until a connection is being made from a client. When a connection is made sets &lt;code&gt;client&lt;/code&gt; to the client socket and &lt;code&gt;address&lt;/code&gt; to the address of the connecting client. This function will raise EOS if an error occurs.</source>
          <target state="translated">Блокируется, пока не будет установлено соединение от клиента. Когда соединение установлено, &lt;code&gt;client&lt;/code&gt; устанавливается на клиентский сокет, а &lt;code&gt;address&lt;/code&gt; - на адрес подключающегося клиента. Эта функция поднимет EOS в случае возникновения ошибки.</target>
        </trans-unit>
        <trans-unit id="70bf1baa003257ad55f9ad962d42ef3e987cd33e" translate="yes" xml:space="preserve">
          <source>Boolean &lt;code&gt;and&lt;/code&gt;; returns true iff &lt;code&gt;x == y == true&lt;/code&gt;. Evaluation is lazy: if &lt;code&gt;x&lt;/code&gt; is false, &lt;code&gt;y&lt;/code&gt; will not even be evaluated.</source>
          <target state="translated">Логическое &lt;code&gt;and&lt;/code&gt; ; возвращает истину, если &lt;code&gt;x == y == true&lt;/code&gt; . Оценка ленивая: если &lt;code&gt;x&lt;/code&gt; ложно, &lt;code&gt;y&lt;/code&gt; даже не будет оцениваться.</target>
        </trans-unit>
        <trans-unit id="8a3c45029fde7152ef764416ecfd26148ba5b9ad" translate="yes" xml:space="preserve">
          <source>Boolean &lt;code&gt;or&lt;/code&gt;; returns true iff &lt;code&gt;not (not x and not y)&lt;/code&gt;. Evaluation is lazy: if &lt;code&gt;x&lt;/code&gt; is true, &lt;code&gt;y&lt;/code&gt; will not even be evaluated.</source>
          <target state="translated">Логическое &lt;code&gt;or&lt;/code&gt; ; возвращает истину, если &lt;code&gt;not (not x and not y)&lt;/code&gt; . Оценка ленивая: если &lt;code&gt;x&lt;/code&gt; истинно, &lt;code&gt;y&lt;/code&gt; даже не будет оцениваться.</target>
        </trans-unit>
        <trans-unit id="02bbffdde9a8f3f92162c50254a83eda75717823" translate="yes" xml:space="preserve">
          <source>Boolean &lt;em&gt;exclusive or&lt;/em&gt;; returns true iff &lt;code&gt;x != y&lt;/code&gt;.</source>
          <target state="translated">Логическое &lt;em&gt;исключающее или&lt;/em&gt; ; возвращает истину, если &lt;code&gt;x != y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4f6a62c295e099a6e5cc6ca486fd23a80fe9b9d" translate="yes" xml:space="preserve">
          <source>Boolean flag that indicates if the system supports nanosecond time resolution in the fields of &lt;code&gt;Stat&lt;/code&gt;. Note that the nanosecond based fields (&lt;code&gt;Stat.st_atim&lt;/code&gt;, &lt;code&gt;Stat.st_mtim&lt;/code&gt; and &lt;code&gt;Stat.st_ctim&lt;/code&gt;) can be accessed without checking this flag, because this module defines fallback procs when they are not available.</source>
          <target state="translated">Логический флаг, указывающий, поддерживает ли система наносекундное временное разрешение в полях &lt;code&gt;Stat&lt;/code&gt; . Обратите внимание, что к полям на основе наносекунд ( &lt;code&gt;Stat.st_atim&lt;/code&gt; , &lt;code&gt;Stat.st_mtim&lt;/code&gt; и &lt;code&gt;Stat.st_ctim&lt;/code&gt; ) можно получить доступ без проверки этого флага, потому что этот модуль определяет резервные процессы, когда они недоступны.</target>
        </trans-unit>
        <trans-unit id="20ba3c881998fa4098ce5ba4cafd77d368e565ad" translate="yes" xml:space="preserve">
          <source>Boolean not; returns true iff &lt;code&gt;x == false&lt;/code&gt;.</source>
          <target state="translated">Булево not; возвращает истину, если &lt;code&gt;x == false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cad44960020fa76bebce8ad95937acc2bd15d81f" translate="yes" xml:space="preserve">
          <source>Boolean socket options.</source>
          <target state="translated">Опции булевых розеток.</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">булевский тип</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="0add89edb9f4ac0882e5974a2ed406404a13002f" translate="yes" xml:space="preserve">
          <source>Bootstrapping the compiler</source>
          <target state="translated">Самая последняя версия компилятора</target>
        </trans-unit>
        <trans-unit id="bd4dea3d9dc65cab9bb66d4cc6a6ce01c2e41ab8" translate="yes" xml:space="preserve">
          <source>Both parts have the same sign as &lt;em&gt;x&lt;/em&gt;. Analogous to the &lt;em&gt;modf&lt;/em&gt; function in C.</source>
          <target state="translated">Обе части имеют тот же знак, что и &lt;em&gt;x&lt;/em&gt; . Аналогично функции &lt;em&gt;modf&lt;/em&gt; в C.</target>
        </trans-unit>
        <trans-unit id="35a56c974fb1825347f0fe1529b19d7c99f2d402" translate="yes" xml:space="preserve">
          <source>Both the multi method and the type converter problems are solved by the AST replay implementation.</source>
          <target state="translated">Как мульти-метод,так и проблемы с конвертером типов решаются реализацией повтора AST.</target>
        </trans-unit>
        <trans-unit id="19ab36d21e3e2bca80b33ef2b7f048e8235fb8c0" translate="yes" xml:space="preserve">
          <source>Brackets</source>
          <target state="translated">Brackets</target>
        </trans-unit>
        <trans-unit id="c53284da9f760cfe1b6f6b9f75108f3e5f34245e" translate="yes" xml:space="preserve">
          <source>Brackets are used as the array constructor.</source>
          <target state="translated">В качестве конструктора массивов используются скобки.</target>
        </trans-unit>
        <trans-unit id="2f1e60578f3cd76d5527fed043c9442139cd2cd3" translate="yes" xml:space="preserve">
          <source>Break statement</source>
          <target state="translated">Заявление о перерыве</target>
        </trans-unit>
        <trans-unit id="d1d87f5d380c5544ae2b99408021a09200064c57" translate="yes" xml:space="preserve">
          <source>Breaking the fastRows() iterator during a loop may cause a driver error for subsequenct queries</source>
          <target state="translated">Нарушение итератора fastRows()во время цикла может привести к ошибке драйвера для подпоследовательных запросов</target>
        </trans-unit>
        <trans-unit id="ec4a222af9465c04b4a8d052175ff58043442831" translate="yes" xml:space="preserve">
          <source>Breaking the fastRows() iterator during a loop will cause the next database query to raise a DbError exception &lt;code&gt;unable to close due to ...&lt;/code&gt;.</source>
          <target state="translated">Нарушение fastRows () итератор во время цикла вызовет следующий запрос к базе данных , чтобы вызвать исключение DbError &lt;code&gt;unable to close due to ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c7a0ef890af1a51c57cdb3dba04d6c6a9bbd34e" translate="yes" xml:space="preserve">
          <source>Breaking the fastRows() iterator during a loop will cause the next database query to raise an [EDb] exception &lt;code&gt;Commands out of sync&lt;/code&gt;.</source>
          <target state="translated">Нарушение итератора fastRows () во время цикла приведет к тому, что следующий запрос к базе данных вызовет исключение [EDb]. &lt;code&gt;Commands out of sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a9c84b3329de1f9c1a856698aa2ec5cff34e5ad" translate="yes" xml:space="preserve">
          <source>Breaks &lt;em&gt;x&lt;/em&gt; into an integral and a fractional part.</source>
          <target state="translated">Разбивает &lt;em&gt;x&lt;/em&gt; на целую и дробную части.</target>
        </trans-unit>
        <trans-unit id="8b6724e85f24d7713d447fc9d1ecbadafa7df149" translate="yes" xml:space="preserve">
          <source>Breaks this node into two nodes at the specified offset, keeping both in the tree as siblings.</source>
          <target state="translated">Разбивает этот узел на два узла с заданным смещением,сохраняя оба в дереве как братья и сестры.</target>
        </trans-unit>
        <trans-unit id="425b1ac3be0544ab3f6c956fa14370b9d4fb8322" translate="yes" xml:space="preserve">
          <source>Build and test examples:</source>
          <target state="translated">Постройте и протестируйте примеры:</target>
        </trans-unit>
        <trans-unit id="6239081298122df79f8acd6439e80ca8b6b91469" translate="yes" xml:space="preserve">
          <source>Building your first macro</source>
          <target state="translated">Создание первого макроса</target>
        </trans-unit>
        <trans-unit id="646a6e4f96059c15c08aa818c66b65c410dfb9b2" translate="yes" xml:space="preserve">
          <source>Built-in macro for a longer expression.</source>
          <target state="translated">Встроенный макрос для более длительного выражения.</target>
        </trans-unit>
        <trans-unit id="4d613da9be22e4083b43024dca2bbeaca3d83302" translate="yes" xml:space="preserve">
          <source>Built-in macros</source>
          <target state="translated">Встроенные макросы</target>
        </trans-unit>
        <trans-unit id="b5a84b589b9501cdc3df0931004c7cc42b59cde3" translate="yes" xml:space="preserve">
          <source>Builtin 'addr' operator for taking the address of a memory location. Cannot be overloaded.</source>
          <target state="translated">Сборка оператора 'addr' для получения адреса ячейки памяти.Не может быть перегружен.</target>
        </trans-unit>
        <trans-unit id="c463568500df5b37582c13d23e61bcb20c8accaa" translate="yes" xml:space="preserve">
          <source>Builtin 'addr' operator for taking the address of a memory location. This works even for &lt;code&gt;let&lt;/code&gt; variables or parameters for better interop with C and so it is considered even more unsafe than the ordinary &lt;code&gt;addr&lt;/code&gt;. When you use it to write a wrapper for a C library, you should always check that the original library does never write to data behind the pointer that is returned from this procedure. Cannot be overloaded.</source>
          <target state="translated">Встроенный оператор addr для получения адреса ячейки памяти. Это работает даже с переменными &lt;code&gt;let&lt;/code&gt; или параметрами для лучшего взаимодействия с C и поэтому считается даже более опасным, чем обычный &lt;code&gt;addr&lt;/code&gt; . Когда вы используете его для написания оболочки для библиотеки C, вы всегда должны проверять, что исходная библиотека никогда не записывает данные за указателем, возвращаемым из этой процедуры. Не может быть перегружен.</target>
        </trans-unit>
        <trans-unit id="f8ca99ea406ea54b032b966a06afdbf917b785d6" translate="yes" xml:space="preserve">
          <source>But a &lt;code&gt;bind&lt;/code&gt; is rarely useful because symbol binding from the definition scope is the default.</source>
          <target state="translated">Но &lt;code&gt;bind&lt;/code&gt; редко бывает полезной, потому что привязка символа из области определения используется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f3a68bc3de013b49eccd2fd19fb51ef8acfea012" translate="yes" xml:space="preserve">
          <source>But it seems all this boilerplate code needs to be repeated for the &lt;code&gt;Euro&lt;/code&gt; currency. This can be solved with &lt;a href=&quot;#templates&quot;&gt;templates&lt;/a&gt;.</source>
          <target state="translated">Но похоже, что весь этот шаблонный код нужно повторить для валюты &lt;code&gt;Euro&lt;/code&gt; . Это можно решить с помощью &lt;a href=&quot;#templates&quot;&gt;шаблонов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b442f85caf3d7cde4cea2e5e9eb91a280936441" translate="yes" xml:space="preserve">
          <source>But one has to watch out because other overloads might trigger the argument's resolution:</source>
          <target state="translated">Но нужно быть осторожным,потому что другие перегрузки могут вызвать разрешение аргумента:</target>
        </trans-unit>
        <trans-unit id="c53e0632274551f5aa1f6a36373db50475b33d38" translate="yes" xml:space="preserve">
          <source>But the global symbol can properly be captured by a &lt;code&gt;bind&lt;/code&gt; statement:</source>
          <target state="translated">Но глобальный символ можно правильно захватить с помощью оператора &lt;code&gt;bind&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="527742dcc91f3b4388a5222a890c0118d3a5e0d7" translate="yes" xml:space="preserve">
          <source>But this rule does not apply to procedures or iterators. Here the overloading rules apply:</source>
          <target state="translated">Но это правило не распространяется на процедуры или итераторы.Здесь применяются правила перегрузки:</target>
        </trans-unit>
        <trans-unit id="9250d320cadcddd0ef262bd8559df915bc7e0bc6" translate="yes" xml:space="preserve">
          <source>By default Nim's &lt;code&gt;dynlib&lt;/code&gt; pragma causes the compiler to generate &lt;code&gt;GetProcAddress&lt;/code&gt; (or their Unix counterparts) calls to bind to a DLL. With the &lt;code&gt;dynlibOverride&lt;/code&gt; command line switch this can be prevented and then via &lt;code&gt;--passL&lt;/code&gt; the static library can be linked against. For instance, to link statically against Lua this command might work on Linux:</source>
          <target state="translated">По умолчанию прагма Nim &lt;code&gt;dynlib&lt;/code&gt; заставляет компилятор генерировать вызовы &lt;code&gt;GetProcAddress&lt;/code&gt; (или их аналоги в Unix) для привязки к DLL. С &lt;code&gt;dynlibOverride&lt;/code&gt; командной строкой это можно предотвратить , а затем через &lt;code&gt;--passL&lt;/code&gt; библиотека статической может быть связана с. Например, для статической линковки с Lua эта команда может работать в Linux:</target>
        </trans-unit>
        <trans-unit id="d02d9c4acff9cf60b68f15e507f7e43cd5939742" translate="yes" xml:space="preserve">
          <source>By default a debug version is created, passing this option will force a release build, which is much faster and should be preferred unless you are debugging the compiler.</source>
          <target state="translated">По умолчанию создается отладочная версия,передача этой опции приведет к принудительной сборке релиза,что значительно быстрее и должно быть предпочтительнее,если только Вы не отлаживаете компилятор.</target>
        </trans-unit>
        <trans-unit id="48b684a5792df5c5364095950ec05af76390e113" translate="yes" xml:space="preserve">
          <source>By default c2nim marks every top level identifier (proc name, variable, etc.) as exported (the export marker is &lt;code&gt;*&lt;/code&gt; in Nim). With the &lt;code&gt;#private&lt;/code&gt; directive identifiers can be marked as private so that the resulting Nim module does not export them. The &lt;code&gt;#private&lt;/code&gt; directive takes a PEG pattern:</source>
          <target state="translated">По умолчанию c2nim помечает каждый идентификатор верхнего уровня (имя процедуры, переменную и т. Д.) Как экспортированный (маркер экспорта &lt;code&gt;*&lt;/code&gt; в Nim). С &lt;code&gt;#private&lt;/code&gt; директивы #private идентификаторы могут быть помечены как частные, чтобы полученный модуль Nim не экспортировал их. &lt;code&gt;#private&lt;/code&gt; директива берет образец ПЭГ:</target>
        </trans-unit>
        <trans-unit id="0de21675c01f240e6592367c51b6d906f03a3d78" translate="yes" xml:space="preserve">
          <source>By default the Nim compiler generates a large amount of runtime checks aiming for your debugging pleasure. With &lt;code&gt;-d:release&lt;/code&gt; these checks are &lt;a href=&quot;nimc#compiler-usage-compile-time-symbols&quot;&gt;turned off and optimizations are turned on&lt;/a&gt;.</source>
          <target state="translated">По умолчанию компилятор Nim генерирует большое количество проверок времени выполнения, чтобы вам было удобно отладки. С &lt;code&gt;-d:release&lt;/code&gt; эти проверки &lt;a href=&quot;nimc#compiler-usage-compile-time-symbols&quot;&gt;отключаются и включаются оптимизации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53714c20b023fb0e9acbdf38f380565e04810da2" translate="yes" xml:space="preserve">
          <source>By default the documentation will be built in parallel using the number of available CPU cores. If any documentation build sub commands fail, they will be rerun in serial fashion so that meaninful error output can be gathered for inspection. The &lt;code&gt;--parallelBuild:n&lt;/code&gt; switch or configuration option can be used to force a specific number of parallel jobs or run everything serially from the start (&lt;code&gt;n == 1&lt;/code&gt;).</source>
          <target state="translated">По умолчанию документация строится параллельно с использованием количества доступных ядер ЦП. Если какие-либо подкоманды сборки документации не работают, они будут повторно запущены в последовательном режиме, чтобы можно было собрать значимые выходные данные об ошибках для проверки. &lt;code&gt;--parallelBuild:n&lt;/code&gt; переключатель или параметр конфигурации может быть использован , чтобы заставить определенное количество параллельных заданий или запустить все последовательно с самого начала ( &lt;code&gt;n == 1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a12f023f59a39b1f378be96457f00762035b5df" translate="yes" xml:space="preserve">
          <source>By default, c2nim translates an &lt;code&gt;#include&lt;/code&gt; that is not followed by &lt;code&gt;&amp;lt;&lt;/code&gt; (like in &lt;code&gt;#include &amp;lt;stdlib&amp;gt;&lt;/code&gt;) to a Nim &lt;code&gt;import&lt;/code&gt; statement. This directive tells c2nim to just skip any &lt;code&gt;#include&lt;/code&gt;.</source>
          <target state="translated">По умолчанию c2nim переводит &lt;code&gt;#include&lt;/code&gt; , за которым не следует &lt;code&gt;&amp;lt;&lt;/code&gt; (как в &lt;code&gt;#include &amp;lt;stdlib&amp;gt;&lt;/code&gt; ), в оператор &lt;code&gt;import&lt;/code&gt; Nim . Эта директива указывает c2nim пропускать любые &lt;code&gt;#include&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fae71acbfd2891a1634971f65ec8cdeff58500b" translate="yes" xml:space="preserve">
          <source>By default, during overload resolution each named type class will bind to exactly one concrete type. We call such type classes &lt;span id=&quot;bind-once_1&quot;&gt;bind once&lt;/span&gt; types. Here is an example taken directly from the system module to illustrate this:</source>
          <target state="translated">По умолчанию во время разрешения перегрузки каждый класс именованного типа будет привязан ровно к одному конкретному типу. Мы называем такие классы типов &lt;span id=&quot;bind-once_1&quot;&gt;привязанными однажды&lt;/span&gt; типами. Вот пример, взятый непосредственно из системного модуля, чтобы проиллюстрировать это:</target>
        </trans-unit>
        <trans-unit id="73cb09bc05777230e6e5fe1e7143a2c142ee2d0d" translate="yes" xml:space="preserve">
          <source>By default, the compiler will report the matching errors in concepts only when no other overload can be selected and a normal compilation error is produced. When you need to understand why the compiler is not matching a particular concept and, as a result, a wrong overload is selected, you can apply the &lt;code&gt;explain&lt;/code&gt; pragma to either the concept body or a particular call-site.</source>
          <target state="translated">По умолчанию компилятор будет сообщать об ошибках сопоставления в концепциях только в том случае, если нельзя выбрать другую перегрузку и возникает обычная ошибка компиляции. Когда вам нужно понять, почему компилятор не соответствует определенной концепции и, как результат, выбрана неправильная перегрузка, вы можете применить прагму &lt;code&gt;explain&lt;/code&gt; либо к телу концепции, либо к конкретному сайту вызова.</target>
        </trans-unit>
        <trans-unit id="80f5e65dfa0cd584e698223d82de76d94317241e" translate="yes" xml:space="preserve">
          <source>By default, uses the IEC/ISO standard binary prefixes, so 1024 will be formatted as 1KiB. Set prefix to &lt;em&gt;bpColloquial&lt;/em&gt; to use the colloquial names from the SI standard (e.g. k for 1000 being reused as 1024).</source>
          <target state="translated">По умолчанию используются стандартные двоичные префиксы IEC / ISO, поэтому 1024 будет отформатировано как 1 КБ. Установите префикс на &lt;em&gt;bpColloquial,&lt;/em&gt; чтобы использовать разговорные имена из стандарта SI (например, k для 1000 повторно используется как 1024).</target>
        </trans-unit>
        <trans-unit id="bc61bfc923f0134f76f08848fd47d85a5225ef86" translate="yes" xml:space="preserve">
          <source>Bycopy pragma</source>
          <target state="translated">бикопическая прагма</target>
        </trans-unit>
        <trans-unit id="dc786d2e8550e65dba6f478b2c981035a039ff49" translate="yes" xml:space="preserve">
          <source>Byref pragma</source>
          <target state="translated">Байриф Прагма</target>
        </trans-unit>
        <trans-unit id="e373e36949fb915e82bd278056c90511b6ce4a56" translate="yes" xml:space="preserve">
          <source>C implementation: &lt;a href=&quot;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&quot;&gt;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&lt;/a&gt;</source>
          <target state="translated">Реализация на C: &lt;a href=&quot;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&quot;&gt;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fbf459b1966378eb6b198b4db1484574fc622a26" translate="yes" xml:space="preserve">
          <source>C invocation example</source>
          <target state="translated">пример ссылки на букву С</target>
        </trans-unit>
        <trans-unit id="cef9b186930ae3fbcdf84f2ca1df6e923c10face" translate="yes" xml:space="preserve">
          <source>C to Nim source converter. Translates C header files to Nim.</source>
          <target state="translated">Конвертер источника С-Ним.Переводит заголовочные файлы C в Nim.</target>
        </trans-unit>
        <trans-unit id="aa0b476ef445e23e653ff55250eadd2a609d86ee" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;,&lt;/code&gt; operator (comma operator) is not supported.</source>
          <target state="translated">C в &lt;code&gt;,&lt;/code&gt; оператор (оператор запятой) не поддерживается.</target>
        </trans-unit>
        <trans-unit id="6e567e8ea65384f4c7990dd6fd015e5dc179fcdc" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;union&lt;/code&gt; are translated to Nim's objects and only the first field is included in the object type. This way there is a high chance that it is binary compatible to the union.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; C транслируется в объекты Nim, и только первое поле включается в тип объекта. Таким образом, высока вероятность того, что он будет бинарно совместим с объединением.</target>
        </trans-unit>
        <trans-unit id="8f522347c60c0922b17da1143403e53d860a58d2" translate="yes" xml:space="preserve">
          <source>C2nim</source>
          <target state="translated">C2nim</target>
        </trans-unit>
        <trans-unit id="f30d6a6fe6e12777a78cd63942d1e0466d7744a4" translate="yes" xml:space="preserve">
          <source>CANNOT BE int64 BECAUSE OF ALIGNMENT</source>
          <target state="translated">НЕ МОЖЕТ БЫТЬ ИНСТРУИРОВАННЫМ В МЕЖДУ НИМЕРЕНИЕМ 64 КОЛИЧЕСТВА ВНИМАНИЯ</target>
        </trans-unit>
        <trans-unit id="c5a976de7b5231fa616fbeac8a2d2805c1e84ee2" translate="yes" xml:space="preserve">
          <source>CC</source>
          <target state="translated">CC</target>
        </trans-unit>
        <trans-unit id="dfa0a6adb0d6b924e9559526a04fdb494693340f" translate="yes" xml:space="preserve">
          <source>Calculate the arc tangent of &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">Вычислить арктангенс &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5de1a650a2f08daab441e97db705f2a8290b44f" translate="yes" xml:space="preserve">
          <source>Calculate the arc tangent of &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;. &lt;em&gt;atan2&lt;/em&gt; returns the arc tangent of &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt;; it produces correct results even when the resulting angle is near pi/2 or -pi/2 (&lt;em&gt;x&lt;/em&gt; near 0).</source>
          <target state="translated">Вычислите арктангенс &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt; . &lt;em&gt;atan2&lt;/em&gt; возвращает арктангенс &lt;em&gt;y&lt;/em&gt; / &lt;em&gt;x&lt;/em&gt; ; он дает правильные результаты, даже если результирующий угол близок к pi / 2 или -pi / 2 ( &lt;em&gt;x&lt;/em&gt; около 0).</target>
        </trans-unit>
        <trans-unit id="56ec6774caee72173cca3d600df6df4ad5cea2f4" translate="yes" xml:space="preserve">
          <source>Calculate the bit parity in integer. If number of 1-bit is odd parity is 1, otherwise 0.</source>
          <target state="translated">Вычислить битовую четность в целочисленном.Если число 1 бита-нечетная четность равна 1,иначе 0.</target>
        </trans-unit>
        <trans-unit id="24670fb674da2394dd2a0f4959fd3a294516adae" translate="yes" xml:space="preserve">
          <source>Calculate the reciprocal of &lt;em&gt;x&lt;/em&gt;. (1/x)</source>
          <target state="translated">Вычислите обратную величину &lt;em&gt;x&lt;/em&gt; . (1 / х)</target>
        </trans-unit>
        <trans-unit id="932f4eb5f8468f8594b47ae0aae880a0c60dbe3e" translate="yes" xml:space="preserve">
          <source>Calculates the best rational numerator and denominator that approximates to &lt;em&gt;x&lt;/em&gt;, where the denominator is smaller than &lt;em&gt;n&lt;/em&gt; (default is the largest possible int to give maximum resolution).</source>
          <target state="translated">Вычисляет наилучший рациональный числитель и знаменатель, который приближается к &lt;em&gt;x&lt;/em&gt; , где знаменатель меньше &lt;em&gt;n&lt;/em&gt; (по умолчанию это наибольшее возможное число int, чтобы дать максимальное разрешение).</target>
        </trans-unit>
        <trans-unit id="3010c6d2f4fa47d3ebb08435fd6265b2c82ae435" translate="yes" xml:space="preserve">
          <source>Calculates the next lexicographic permutation, directly modifying &lt;code&gt;x&lt;/code&gt;. The result is whether a permutation happened, otherwise we have reached the last-ordered permutation.</source>
          <target state="translated">Вычисляет следующую лексикографическую перестановку, напрямую изменяя &lt;code&gt;x&lt;/code&gt; . Результатом будет то, произошла ли перестановка, иначе мы достигли последней упорядоченной перестановки.</target>
        </trans-unit>
        <trans-unit id="926f466377c398ffb795b1c416217100d99d20d7" translate="yes" xml:space="preserve">
          <source>Calculates the previous lexicographic permutation, directly modifying &lt;code&gt;x&lt;/code&gt;. The result is whether a permutation happened, otherwise we have reached the first-ordered permutation.</source>
          <target state="translated">Вычисляет предыдущую лексикографическую перестановку, напрямую изменяя &lt;code&gt;x&lt;/code&gt; . Результатом будет то, произошла ли перестановка, иначе мы достигли перестановки первого порядка.</target>
        </trans-unit>
        <trans-unit id="f5b27c0795360d24a64c7b68bf2cc3b1338d3199" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;cbproc&lt;/code&gt; &quot;soon&quot;.</source>
          <target state="translated">Назовите &lt;code&gt;cbproc&lt;/code&gt; &quot;скоро&quot;.</target>
        </trans-unit>
        <trans-unit id="3ced0e76c83f56c5d573ca3272434ebf912be391" translate="yes" xml:space="preserve">
          <source>Call this if you scanned over 'L' in the buffer; it returns the the position to continue the scanning from. &lt;em&gt;pos&lt;/em&gt; must be the position of the 'L'.</source>
          <target state="translated">Вызовите это, если вы просканировали &amp;laquo;L&amp;raquo; в буфере; он возвращает позицию, с которой нужно продолжить сканирование. &lt;em&gt;pos&lt;/em&gt; должен быть позицией буквы L.</target>
        </trans-unit>
        <trans-unit id="77d5fa0614be1a0c2dc98ca10137b9644cb75099" translate="yes" xml:space="preserve">
          <source>Call this if you scanned over 'c' in the buffer; it returns the the position to continue the scanning from. &lt;em&gt;pos&lt;/em&gt; must be the position of the 'c'.</source>
          <target state="translated">Вызовите это, если вы просканировали более &amp;laquo;c&amp;raquo; в буфере; он возвращает позицию, с которой нужно продолжить сканирование. &lt;em&gt;pos&lt;/em&gt; должен быть позицией буквы &quot;c&quot;.</target>
        </trans-unit>
        <trans-unit id="1ef18f3ccda6fa4b7049be2ee5f84665bbb0ce03" translate="yes" xml:space="preserve">
          <source>Call user defined proc &lt;code&gt;foo&lt;/code&gt; to &lt;strong&gt;skip&lt;/strong&gt; some optional parts in the input string. See below for more details.</source>
          <target state="translated">Вызовите определенный пользователем proc &lt;code&gt;foo&lt;/code&gt; , чтобы &lt;strong&gt;пропустить&lt;/strong&gt; некоторые необязательные части во входной строке. Подробности смотрите ниже.</target>
        </trans-unit>
        <trans-unit id="02241663160dcc2a31527f886c0c708b65f901d7" translate="yes" xml:space="preserve">
          <source>Call with &lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">Звоните с помощью &lt;code&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da6c999c007bfe15edd1f0f081d6f9072a370ddb" translate="yes" xml:space="preserve">
          <source>Call with named arguments</source>
          <target state="translated">Вызов с именованными аргументами</target>
        </trans-unit>
        <trans-unit id="4f1be644dd81e7d1af3decb76997fc722787c242" translate="yes" xml:space="preserve">
          <source>Call with raw string literal</source>
          <target state="translated">Звонок с необработанной строкой буквально</target>
        </trans-unit>
        <trans-unit id="bfcb7c395fc4a2662bfef50abfeba239833faf54" translate="yes" xml:space="preserve">
          <source>Callable type</source>
          <target state="translated">Вызываемый тип</target>
        </trans-unit>
        <trans-unit id="d6a9bd6a90d6905593fcbe3587fd9fc40af85f67" translate="yes" xml:space="preserve">
          <source>Calling a procedure can be done in many different ways:</source>
          <target state="translated">Вызов процедуры может быть выполнен различными способами:</target>
        </trans-unit>
        <trans-unit id="f026609c17e6af082dd6bc47161a40d8bcada7a1" translate="yes" xml:space="preserve">
          <source>Calling ordinary Nim procs inside the macro is possible:</source>
          <target state="translated">Внутри макроса можно вызывать обычные Nim-профили:</target>
        </trans-unit>
        <trans-unit id="a6642199094bd906db4fb13f403e5d9864fe5992" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;styledWrite&lt;/code&gt; and appends a newline at the end.</source>
          <target state="translated">Вызывает &lt;code&gt;styledWrite&lt;/code&gt; и добавляет новую строку в конец.</target>
        </trans-unit>
        <trans-unit id="7e723e08242f8573f5209a7864aabe4641ef9035" translate="yes" xml:space="preserve">
          <source>Calls/expressions</source>
          <target state="translated">Calls/expressions</target>
        </trans-unit>
        <trans-unit id="cfe2ed24a31b4d3b922301946dba17cf4d7769e4" translate="yes" xml:space="preserve">
          <source>Can a &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; proc be written that supports this loop? Lets try:</source>
          <target state="translated">Может ли &lt;a href=&quot;system#countup&quot;&gt;подсчет&lt;/a&gt; прок быть написано , что поддерживает этот цикл? Давай попробуем:</target>
        </trans-unit>
        <trans-unit id="311200cff08c958701bc83ae616b08935d475e3d" translate="yes" xml:space="preserve">
          <source>Can be used to convert a pointer type to an option type. It converts &lt;code&gt;nil&lt;/code&gt; to the none-option.</source>
          <target state="translated">Может использоваться для преобразования типа указателя в тип параметра. Он преобразует &lt;code&gt;nil&lt;/code&gt; в none-option.</target>
        </trans-unit>
        <trans-unit id="73a3789c9cc42ae286b2bc07d22e73c5d6441a2b" translate="yes" xml:space="preserve">
          <source>CannotOpenFile</source>
          <target state="translated">CannotOpenFile</target>
        </trans-unit>
        <trans-unit id="a4b36f5e09cea9865cb6993e0accb43f1789f9cd" translate="yes" xml:space="preserve">
          <source>Capture: Apply expression &lt;em&gt;E&lt;/em&gt; and store the substring that matched &lt;em&gt;E&lt;/em&gt; into a &lt;em&gt;capture&lt;/em&gt; that can be accessed after the matching process.</source>
          <target state="translated">Захват: примените выражение &lt;em&gt;E&lt;/em&gt; и сохраните подстроку, которая соответствует &lt;em&gt;E,&lt;/em&gt; в &lt;em&gt;захват, к&lt;/em&gt; которому можно будет получить доступ после процесса сопоставления.</target>
        </trans-unit>
        <trans-unit id="dada321496f3f4fb22895c4b7cd0802a93ca5d72" translate="yes" xml:space="preserve">
          <source>Captured Search: Shorthand for &lt;code&gt;{(!E .)*} E&lt;/code&gt;. (Search loop for the pattern &lt;em&gt;E&lt;/em&gt;.) Everything until and exluding &lt;em&gt;E&lt;/em&gt; is captured.</source>
          <target state="translated">Захваченный Поиск: Стенография для &lt;code&gt;{(!E .)*} E&lt;/code&gt; . (Найдите цикл для шаблона &lt;em&gt;E.&lt;/em&gt; ) Все, кроме &lt;em&gt;E&lt;/em&gt; , захвачено.</target>
        </trans-unit>
        <trans-unit id="58721ba126309ca208430cd499d98df05aa97730" translate="yes" xml:space="preserve">
          <source>Card stands for the &lt;a href=&quot;http://en.wikipedia.org/wiki/Cardinality&quot;&gt;cardinality&lt;/a&gt; of a set.</source>
          <target state="translated">Карточка обозначает &lt;a href=&quot;http://en.wikipedia.org/wiki/Cardinality&quot;&gt;мощность&lt;/a&gt; набора.</target>
        </trans-unit>
        <trans-unit id="f3a52f7d1133fe19bed724efe1bcc5b99763e6ec" translate="yes" xml:space="preserve">
          <source>Case expression</source>
          <target state="translated">Выражение случая</target>
        </trans-unit>
        <trans-unit id="ca901f84d981e4405cbb31e5c66f958f39995d61" translate="yes" xml:space="preserve">
          <source>Case statement</source>
          <target state="translated">изложение дела</target>
        </trans-unit>
        <trans-unit id="67a5699f66f3a4d73b5d418a7b08b0c7350d984e" translate="yes" xml:space="preserve">
          <source>Case statement macros</source>
          <target state="translated">макросы для описания дела</target>
        </trans-unit>
        <trans-unit id="97ba68fc56a3efba444f7c6353ffce14d1fabcb2" translate="yes" xml:space="preserve">
          <source>Cast operator</source>
          <target state="translated">литейный оператор</target>
        </trans-unit>
        <trans-unit id="b883b50cc0a7ec97e8c1c6aa366453f73a26413f" translate="yes" xml:space="preserve">
          <source>Change current implementation of &lt;code&gt;callSoon&lt;/code&gt;. This is normally called when dispatcher from &lt;code&gt;asyncdispatcher&lt;/code&gt; is initialized.</source>
          <target state="translated">Измените текущую реализацию &lt;code&gt;callSoon&lt;/code&gt; . Обычно это вызывается при инициализации диспетчера из &lt;code&gt;asyncdispatcher&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a7e15fb6b1d9ffe60a97b971875a5fd14c3986" translate="yes" xml:space="preserve">
          <source>Change the i-th element of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">Измените i-й элемент &lt;em&gt;deq&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a378d275114814e060b77abd531dd213c169f954" translate="yes" xml:space="preserve">
          <source>Changes permission of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;permissions&lt;/code&gt;.</source>
          <target state="translated">Изменяет разрешение &lt;code&gt;path&lt;/code&gt; к &lt;code&gt;permissions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bc9d87771e5da3b869e9e85828f5d8bc801b455" translate="yes" xml:space="preserve">
          <source>Changes the current directory on the remote FTP server to &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">Изменяет текущий каталог на удаленном FTP-сервере на &lt;code&gt;dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c055bf809996f18dce65f9e3f155faf78c41dcc7" translate="yes" xml:space="preserve">
          <source>Changes the current directory to the parent of the current directory.</source>
          <target state="translated">Изменяет текущий каталог на родительский.</target>
        </trans-unit>
        <trans-unit id="a9e433ae359b493762f4f0a4bb510351b98a08de" translate="yes" xml:space="preserve">
          <source>Changes the file extension to &lt;em&gt;ext&lt;/em&gt;.</source>
          <target state="translated">Меняет расширение файла на &lt;em&gt;ext&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3ca5b74490314ec55a9cac4706975c4e89ff805e" translate="yes" xml:space="preserve">
          <source>Changing of files' permissions.</source>
          <target state="translated">Изменение прав доступа к файлам.</target>
        </trans-unit>
        <trans-unit id="419e96b941fe3d26a3baefa01150ca56eff780d7" translate="yes" xml:space="preserve">
          <source>Channel support for threads. &lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support you need to compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="translated">Поддержка каналов для потоков. &lt;strong&gt;Примечание&lt;/strong&gt; : это часть системного модуля. Не импортируйте его напрямую. Чтобы активировать поддержку потоков, вам необходимо выполнить компиляцию с параметром &lt;code&gt;--threads:on&lt;/code&gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="0abdb5ab8a3afbc3386522492aae1bd812508530" translate="yes" xml:space="preserve">
          <source>Character class: If the character ahead appears in the string &lt;em&gt;s&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">Класс символа: если впереди идущий символ появляется в строке &lt;em&gt;s&lt;/em&gt; , используйте его и обозначьте успех. В противном случае указать отказ.</target>
        </trans-unit>
        <trans-unit id="1ce4e1be05a213a12afbc5b91825b11c73d700b6" translate="yes" xml:space="preserve">
          <source>Character device.</source>
          <target state="translated">Устройство для персонажей.</target>
        </trans-unit>
        <trans-unit id="b86bbfa9fed7ada0a389375eb5146d27ca6ab1fb" translate="yes" xml:space="preserve">
          <source>Character literals</source>
          <target state="translated">Буквы персонажей</target>
        </trans-unit>
        <trans-unit id="7e96bdb902b32980dacb34ac72b2007caf92e425" translate="yes" xml:space="preserve">
          <source>Character literals are enclosed in single quotes &lt;code&gt;''&lt;/code&gt; and can contain the same escape sequences as strings - with one exception: the platform dependent &lt;span id=&quot;newline_2&quot;&gt;newline&lt;/span&gt; (&lt;code&gt;\p&lt;/code&gt;) is not allowed as it may be wider than one character (often it is the pair CR/LF for example). Here are the valid &lt;span id=&quot;escape-sequences_2&quot;&gt;escape sequences&lt;/span&gt; for character literals:</source>
          <target state="translated">Символьные литералы заключаются в одинарные кавычки &lt;code&gt;''&lt;/code&gt; и могут содержать те же escape-последовательности, что и строки, за одним исключением: зависимая от платформы &lt;span id=&quot;newline_2&quot;&gt;новая&lt;/span&gt; строка ( &lt;code&gt;\p&lt;/code&gt; ) не допускается, так как она может быть шире одного символа (часто это пара CR / LF например). Вот допустимые &lt;span id=&quot;escape-sequences_2&quot;&gt;escape-последовательности&lt;/span&gt; для символьных литералов:</target>
        </trans-unit>
        <trans-unit id="ed1a1da8d910c3e98f7e3471a4032afafec5eb29" translate="yes" xml:space="preserve">
          <source>Character range: If the character ahead is one from the range &lt;em&gt;a&lt;/em&gt; through &lt;em&gt;b&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="translated">Диапазон символов: если впереди идет персонаж из диапазона от &lt;em&gt;a&lt;/em&gt; до &lt;em&gt;b&lt;/em&gt; , поглотите его и обозначьте успех. В противном случае указать отказ.</target>
        </trans-unit>
        <trans-unit id="b6a6c483aae1575a0185147caca2a33f4a949438" translate="yes" xml:space="preserve">
          <source>Character type</source>
          <target state="translated">Тип персонажа</target>
        </trans-unit>
        <trans-unit id="d50cd4e4889823f54696871b43521ee7b2cd7335" translate="yes" xml:space="preserve">
          <source>Character with decimal code &lt;em&gt;ddd&lt;/em&gt;.</source>
          <target state="translated">Символ с десятичным кодом &lt;em&gt;ддд&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="bf30516c00576762fbbb621668144d424821087b" translate="yes" xml:space="preserve">
          <source>Chars can be compared with the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. The &lt;code&gt;$&lt;/code&gt; operator converts a &lt;code&gt;char&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt;. Chars cannot be mixed with integers; to get the ordinal value of a &lt;code&gt;char&lt;/code&gt; use the &lt;code&gt;ord&lt;/code&gt; proc. Converting from an integer to a &lt;code&gt;char&lt;/code&gt; is done with the &lt;code&gt;chr&lt;/code&gt; proc.</source>
          <target state="translated">Символы можно сравнить с операторами &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; . Оператор &lt;code&gt;$&lt;/code&gt; преобразует &lt;code&gt;char&lt;/code&gt; в &lt;code&gt;string&lt;/code&gt; . Символы нельзя смешивать с целыми числами; чтобы получить порядковый номер &lt;code&gt;char&lt;/code&gt; используйте &lt;code&gt;ord&lt;/code&gt; proc. Преобразование из целого числа в &lt;code&gt;char&lt;/code&gt; выполняется с помощью &lt;code&gt;chr&lt;/code&gt; proc.</target>
        </trans-unit>
        <trans-unit id="68664dd02e350ea5073e0ae4aa9b4b05b3c91960" translate="yes" xml:space="preserve">
          <source>Chat server</source>
          <target state="translated">Сервер чата</target>
        </trans-unit>
        <trans-unit id="929ff11e672655b0a3b8087213ef8d4a743bae97" translate="yes" xml:space="preserve">
          <source>Check if &lt;em&gt;s&lt;/em&gt; matches Nim's &quot;while&quot; keyword:</source>
          <target state="translated">Проверьте, совпадает ли &lt;em&gt;s с&lt;/em&gt; ключевым словом Нима &quot;while&quot;:</target>
        </trans-unit>
        <trans-unit id="8cf370f6b8ec38a29e2432bba075fad77aab417e" translate="yes" xml:space="preserve">
          <source>Check if a &lt;code&gt;FutureStream&lt;/code&gt; is finished. &lt;code&gt;true&lt;/code&gt; value means that no more data will be placed inside the stream _&lt;a href=&quot;#and&quot;&gt;and&lt;/a&gt; that there is no data waiting to be retrieved.</source>
          <target state="translated">Проверьте, &lt;code&gt;FutureStream&lt;/code&gt; ли FutureStream . Значение &lt;code&gt;true&lt;/code&gt; означает, что в поток _ больше не будут помещаться данные &lt;a href=&quot;#and&quot;&gt;и&lt;/a&gt; нет данных, ожидающих извлечения.</target>
        </trans-unit>
        <trans-unit id="f166d2a8f7a171d1bb127378eb23732d41da0d11" translate="yes" xml:space="preserve">
          <source>Check if a &lt;span id=&quot;directory_1&quot;&gt;directory&lt;/span&gt;&lt;em&gt;dir&lt;/em&gt; exists, and create it otherwise.</source>
          <target state="translated">Проверьте, существует ли &lt;span id=&quot;directory_1&quot;&gt;каталог &lt;/span&gt;&lt;em&gt;dir&lt;/em&gt; , в противном случае создайте его.</target>
        </trans-unit>
        <trans-unit id="984fcebb18e75b7e703ed2015d054cab99f8aaec" translate="yes" xml:space="preserve">
          <source>Check two nodes for equality</source>
          <target state="translated">Проверьте два узла на равенство</target>
        </trans-unit>
        <trans-unit id="da7416e40baa75d7c56d32d6f86dd948f4e19c78" translate="yes" xml:space="preserve">
          <source>Checking the progress of a file transfer</source>
          <target state="translated">Проверка хода передачи файлов</target>
        </trans-unit>
        <trans-unit id="132dba3d8ecc2f1b5ab2812aeccdc98f5e82e566" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;osLastError&lt;/code&gt; for a valid error. If it has been reset it uses the last error stored in the socket object.</source>
          <target state="translated">Проверяет &lt;code&gt;osLastError&lt;/code&gt; на допустимую ошибку. Если он был сброшен, он использует последнюю ошибку, сохраненную в объекте сокета.</target>
        </trans-unit>
        <trans-unit id="cc61b0718a3e619d1bd3a5d9f1cd5caf0d888789" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;bool&lt;/em&gt; variables</source>
          <target state="translated">Проверяет равенство двух переменных типа &lt;em&gt;bool&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f860c207f2a11f0e1a3d019e6937c4ffa577ce1" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;char&lt;/em&gt; variables</source>
          <target state="translated">Проверяет равенство двух &lt;em&gt;символьных&lt;/em&gt; переменных</target>
        </trans-unit>
        <trans-unit id="fb71cf56026acbd41603489b57883dd164a92da2" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;cstring&lt;/em&gt; variables.</source>
          <target state="translated">Проверяет равенство двух переменных &lt;em&gt;cstring&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6693c72afaf2ac68bebd9822b5f0ce79ca5dfcae" translate="yes" xml:space="preserve">
          <source>Checks for equality between two &lt;em&gt;string&lt;/em&gt; variables</source>
          <target state="translated">Проверяет равенство двух &lt;em&gt;строковых&lt;/em&gt; переменных</target>
        </trans-unit>
        <trans-unit id="5987179982937ecdc2f511a6d1b5e95c1f8fd6e8" translate="yes" xml:space="preserve">
          <source>Checks for equality between two variables of type &lt;em&gt;set&lt;/em&gt;</source>
          <target state="translated">Проверяет равенство между двумя переменными &lt;em&gt;набора&lt;/em&gt; типов&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99503e3efa2622079cb2940b4767dc3ac6ea82f5" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;key&lt;/em&gt; exists in &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">Проверяет, существует ли &lt;em&gt;ключ&lt;/em&gt; в &lt;em&gt;узле&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a8474632e4fae06f8ce5b7c82b1279000374e87d" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;s&lt;/em&gt; is nil or consists entirely of whitespace characters.</source>
          <target state="translated">Проверяет, равно ли &lt;em&gt;s&lt;/em&gt; нулю или полностью состоит из пробелов.</target>
        </trans-unit>
        <trans-unit id="c736c01c5bfa8a1c6f5bac3b24beb2893e45e7de" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;s&lt;/em&gt; is nil or empty.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;s&lt;/em&gt; пустым или пустым.</target>
        </trans-unit>
        <trans-unit id="59f775bd733836ecb4200f87a57e67e9cfc67799" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;val&lt;/em&gt; exists in array &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">Проверяет, существует ли &lt;em&gt;val&lt;/em&gt; в &lt;em&gt;узле&lt;/em&gt; массива .</target>
        </trans-unit>
        <trans-unit id="f46cbda82eb5e9585af47785b7a218005abe05c4" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;value&lt;/em&gt; is within the range of &lt;em&gt;s&lt;/em&gt;; returns true iff &lt;em&gt;value &amp;gt;= s.a and value &amp;lt;= s.b&lt;/em&gt;</source>
          <target state="translated">Проверяет, находится ли &lt;em&gt;значение&lt;/em&gt; в пределах диапазона &lt;em&gt;s&lt;/em&gt; ; возвращает истину, если &lt;em&gt;значение&amp;gt; = sa и значение &amp;lt;= sb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f0ff90bf51c73226b0a0ba5e93e479486fcfc7a" translate="yes" xml:space="preserve">
          <source>Checks if &lt;em&gt;x&lt;/em&gt; has a type of &lt;em&gt;y&lt;/em&gt;</source>
          <target state="translated">Проверяет, имеет ли &lt;em&gt;x&lt;/em&gt; тип &lt;em&gt;y&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="daf104d7238ae02de9f7b8d4b2ef3a9d0dd7836c" translate="yes" xml:space="preserve">
          <source>Checks if T is of the same type as S</source>
          <target state="translated">Проверяет,соответствует ли T тому же типу,что и S.</target>
        </trans-unit>
        <trans-unit id="3e2a37d26b80f14b9376ff0970807fa4ec421d07" translate="yes" xml:space="preserve">
          <source>Checks if a cookie of &lt;em&gt;name&lt;/em&gt; exists.</source>
          <target state="translated">Проверяет, существует ли файл cookie &lt;em&gt;имени&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="44e4d80ce5f7a1e55199005e073fe653afa2fabc" translate="yes" xml:space="preserve">
          <source>Checks if a string is an IP address Returns true if it is, false otherwise</source>
          <target state="translated">Проверяет,является ли строка IP-адресом Возвращает true,если да,false иначе</target>
        </trans-unit>
        <trans-unit id="91fcb8e30c84d0132cb566b30317c70326d854cb" translate="yes" xml:space="preserve">
          <source>Checks if every item fulfills the predicate.</source>
          <target state="translated">Проверяет,выполняет ли каждый предмет предикат.</target>
        </trans-unit>
        <trans-unit id="af2565e07778c49efe297f906f075760048c0b14" translate="yes" xml:space="preserve">
          <source>Checks if some item fulfills the predicate.</source>
          <target state="translated">Проверяет,выполняет ли какой-то предмет предикат.</target>
        </trans-unit>
        <trans-unit id="239c89279a3bce5516e0481e4f55258a02a144dd" translate="yes" xml:space="preserve">
          <source>Checks that two &lt;em&gt;proc&lt;/em&gt; variables refer to the same procedure</source>
          <target state="translated">Проверки , что два &lt;em&gt;Proc&lt;/em&gt; переменные относятся к той же процедуре</target>
        </trans-unit>
        <trans-unit id="ca5e50261c267853c17b8d0483f9eeeb373544ad" translate="yes" xml:space="preserve">
          <source>Checks that two &lt;em&gt;ptr&lt;/em&gt; variables refer to the same item</source>
          <target state="translated">Проверяет, что две переменные &lt;em&gt;ptr&lt;/em&gt; относятся к одному и тому же элементу</target>
        </trans-unit>
        <trans-unit id="e8feb74c6a474812ed4a3894be2a37759dfadb64" translate="yes" xml:space="preserve">
          <source>Checks that two &lt;em&gt;ref&lt;/em&gt; variables refer to the same item</source>
          <target state="translated">Проверяет, что две переменные &lt;em&gt;ref&lt;/em&gt; ссылаются на один и тот же элемент</target>
        </trans-unit>
        <trans-unit id="2efb60769de3f5e8c0d857e5d64a4a1d598026d9" translate="yes" xml:space="preserve">
          <source>Checks to see whether &lt;em&gt;a&lt;/em&gt; is already sorted in &lt;em&gt;order&lt;/em&gt; using &lt;em&gt;cmp&lt;/em&gt; for the comparison. Parameters identical to &lt;em&gt;sort&lt;/em&gt;</source>
          <target state="translated">Проверяет , является ли уже отсортированы в &lt;em&gt;порядке&lt;/em&gt; использования &lt;em&gt;CMP&lt;/em&gt; для сравнения. Параметры идентичны &lt;em&gt;сортировке&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb0fddbd515d81fc29a204bb7d47e5506b13b3dc" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;s&lt;/code&gt; is lower case.</source>
          <target state="translated">Проверяет, является ли &lt;code&gt;s&lt;/code&gt; строчными буквами.</target>
        </trans-unit>
        <trans-unit id="a95f9a2833efadf810a077d161631c3c1a37d62b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;s&lt;/code&gt; is upper case.</source>
          <target state="translated">Проверяет, является ли &lt;code&gt;s&lt;/code&gt; прописным.</target>
        </trans-unit>
        <trans-unit id="c19cc9513c0bf1c1425112be49c299ffd561ef33" translate="yes" xml:space="preserve">
          <source>Checks whether a given &lt;em&gt;path&lt;/em&gt; is a root directory</source>
          <target state="translated">Проверяет, является ли данный &lt;em&gt;путь&lt;/em&gt; корневым каталогом</target>
        </trans-unit>
        <trans-unit id="2b2e978aedf3c96424b9cc68407ee36744d6e1fe" translate="yes" xml:space="preserve">
          <source>Checks whether a given &lt;em&gt;path&lt;/em&gt; is absolute.</source>
          <target state="translated">Проверяет, является ли данный &lt;em&gt;путь&lt;/em&gt; абсолютным.</target>
        </trans-unit>
        <trans-unit id="ee4c2aa7f06d4dab8347c552766eb0e82241c0bc" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is a lower case character.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;c&lt;/em&gt; символом нижнего регистра.</target>
        </trans-unit>
        <trans-unit id="e62669610340d11599af3c49e990b8563987c907" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is a number.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;c&lt;/em&gt; числом.</target>
        </trans-unit>
        <trans-unit id="dec21879462a972a9215d78983d9622f9e614ece" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is a whitespace character.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;c&lt;/em&gt; пробельным символом.</target>
        </trans-unit>
        <trans-unit id="66ef64629cfaff59e4dda1f006a57dd1a8b7a659" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is alphabetical.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;c&lt;/em&gt; алфавитным.</target>
        </trans-unit>
        <trans-unit id="8bbff5e8bf3937ea9eac7179b7b1803460bcfd4b" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is alphanumeric.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;c&lt;/em&gt; буквенно-цифровым.</target>
        </trans-unit>
        <trans-unit id="783f60adb58a778d0bdcb0ed1f898546ed698d6c" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;c&lt;/em&gt; is an upper case character.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;c&lt;/em&gt; символом верхнего регистра.</target>
        </trans-unit>
        <trans-unit id="96e7693a15498ac9fcc81a271241dceee25a1fa0" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is a numeric value.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;s&lt;/em&gt; числовым значением.</target>
        </trans-unit>
        <trans-unit id="bdff523a789009cf024b82e48a29ed38f90b665d" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is a unicode title.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;s&lt;/em&gt; заголовком в Юникоде.</target>
        </trans-unit>
        <trans-unit id="e633a4c42c8c1c1a6b480f4086e931c947915d1a" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is alphabetical.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;s&lt;/em&gt; алфавитным.</target>
        </trans-unit>
        <trans-unit id="05a69f1cbe4ef4451b315649a574990d236315ae" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is alphanumeric.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;s&lt;/em&gt; буквенно-цифровым.</target>
        </trans-unit>
        <trans-unit id="a4cb2611d9b736cb54c98723c01635d46689fc8b" translate="yes" xml:space="preserve">
          <source>Checks whether or not &lt;em&gt;s&lt;/em&gt; is completely whitespace.</source>
          <target state="translated">Проверяет, является ли &lt;em&gt;s&lt;/em&gt; полностью пробелом.</target>
        </trans-unit>
        <trans-unit id="5589a38b0e9e9fce2e0e9bb1532225529e28fbfc" translate="yes" xml:space="preserve">
          <source>Checks whether values within the &lt;em&gt;same enum&lt;/em&gt; have the same underlying value</source>
          <target state="translated">Проверяет, имеют ли значения в &lt;em&gt;одном перечислении одно&lt;/em&gt; и то же базовое значение</target>
        </trans-unit>
        <trans-unit id="60654a8d0b43196c10e1df25c6c3376b674ea1de" translate="yes" xml:space="preserve">
          <source>Checks, whether &lt;em&gt;x&lt;/em&gt; has a property of name &lt;em&gt;prop&lt;/em&gt;.</source>
          <target state="translated">Проверяет, есть ли у &lt;em&gt;x&lt;/em&gt; свойство name &lt;em&gt;prop&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8a71440783140db7ed4f5845038e0d0ef495c4b8" translate="yes" xml:space="preserve">
          <source>Classifies a floating point value. Returns &lt;em&gt;x&lt;/em&gt;'s class as specified by &lt;em&gt;FloatClass&lt;/em&gt;.</source>
          <target state="translated">Классифицирует значение с плавающей запятой. Возвращает класс &lt;em&gt;x,&lt;/em&gt; указанный в &lt;em&gt;FloatClass&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c0676a856119b9f43d3b722b7e1f13d155840cdb" translate="yes" xml:space="preserve">
          <source>Clear the supported exceptions represented by &lt;em&gt;excepts&lt;/em&gt;.</source>
          <target state="translated">Удалите поддерживаемые исключения, представленные &lt;em&gt;исключениями&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bbdc3e1cf1b38d523d6171b4db601a4ff9f5cdbb" translate="yes" xml:space="preserve">
          <source>Clears the HashSet back to an empty state, without shrinking any of the existing storage. O(n) where n is the size of the hash bucket.</source>
          <target state="translated">Очищает HashSet обратно в пустое состояние,не сокращая ни одно из существующих хранилищ.O(n),где n-размер ведра хэша.</target>
        </trans-unit>
        <trans-unit id="500eb6a58ee99ed5a10bac0307d2399525789e8b" translate="yes" xml:space="preserve">
          <source>Clears the OrderedSet back to an empty state, without shrinking any of the existing storage. O(n) where n is the size of the hash bucket.</source>
          <target state="translated">Очищает OrderedSet обратно в пустое состояние,не сокращая ни одно из существующих хранилищ.O(n),где n-размер ведра для мусора.</target>
        </trans-unit>
        <trans-unit id="3253f000f2b69e9ea7ef993e1158952274e09f15" translate="yes" xml:space="preserve">
          <source>Clears the list of callbacks and sets the callback proc to be called when the future completes.</source>
          <target state="translated">Очищает список обратных вызовов и задает параметр &quot;Прокрутка вызова&quot;,который будет вызываться при завершении вызова в будущем.</target>
        </trans-unit>
        <trans-unit id="507ebd324f496a23794692a20495953cda164297" translate="yes" xml:space="preserve">
          <source>Clients can also use Postgres keyword/value connection strings to connect.</source>
          <target state="translated">Клиенты также могут использовать для подключения строки соединения Postgres по ключевым словам/значению.</target>
        </trans-unit>
        <trans-unit id="a9cbac01b8a8251fed166d82028202652414e266" translate="yes" xml:space="preserve">
          <source>Closes &lt;code&gt;sock&lt;/code&gt;. Terminates any current connections.</source>
          <target state="translated">Закрывает &lt;code&gt;sock&lt;/code&gt; . Завершает все текущие соединения.</target>
        </trans-unit>
        <trans-unit id="a734b28e01c24d279132bdbcfaf68f5165797f44" translate="yes" xml:space="preserve">
          <source>Closes a socket and ensures that it is unregistered.</source>
          <target state="translated">Закрывает розетку и обеспечивает ее незарегистрированность.</target>
        </trans-unit>
        <trans-unit id="caf7e77bedd43df5afff7efafdc353d87046a94d" translate="yes" xml:space="preserve">
          <source>Closes a socket.</source>
          <target state="translated">Закрывает розетку.</target>
        </trans-unit>
        <trans-unit id="1ced522c89f62b7dce08c4647da6d4cf514e789f" translate="yes" xml:space="preserve">
          <source>Closes any connections held by the HTTP client.</source>
          <target state="translated">Закрывает любые соединения,удерживаемые HTTP-клиентом.</target>
        </trans-unit>
        <trans-unit id="6e4ad07cceacc544c46a9fcbeb6a76c8d0de27a4" translate="yes" xml:space="preserve">
          <source>Closes event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">Закрывает событие &lt;code&gt;ev&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33c90fcaa7ffb78d8a27467591953ef2c7afae9a" translate="yes" xml:space="preserve">
          <source>Closes the &lt;code&gt;AsyncScgiState&lt;/code&gt;.</source>
          <target state="translated">Закрывает &lt;code&gt;AsyncScgiState&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
