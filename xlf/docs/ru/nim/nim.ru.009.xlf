<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="737a9761248665739efdb7e092488b1f4438a576" translate="yes" xml:space="preserve">
          <source>However it is not efficient to do:</source>
          <target state="translated">Однако это неэффективно:</target>
        </trans-unit>
        <trans-unit id="2cbd76edbf731ff982e8e168638d25504365da00" translate="yes" xml:space="preserve">
          <source>However later versions of the language might change this to mean &quot;infer the parameters' types from the body&quot;. Then the above &lt;code&gt;foo&lt;/code&gt; would be rejected as the parameters' types can not be inferred from an empty &lt;code&gt;discard&lt;/code&gt; statement.</source>
          <target state="translated">Однако более поздние версии языка могут изменить это значение, чтобы оно означало &amp;laquo;выводить типы параметров из тела&amp;raquo;. Тогда приведенный выше &lt;code&gt;foo&lt;/code&gt; будет отклонен, поскольку типы параметров не могут быть выведены из пустого оператора &lt;code&gt;discard&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="368170efcb2db228f96a4630432ea5c83ce54ea6" translate="yes" xml:space="preserve">
          <source>However such features are not context sensitive and work simply on string matching, which can be problematic in Nim especially due to the case insensitiveness of the language (plus underscores as separators!).</source>
          <target state="translated">Однако такие возможности не чувствительны к контексту и работают просто на согласовании строк,что может быть проблематично в Nim,особенно из-за нечувствительности языка к регистру (плюс подчеркивания в качестве разделителей!).</target>
        </trans-unit>
        <trans-unit id="c8aede1d3274012cc4621182cf281306471b02d9" translate="yes" xml:space="preserve">
          <source>However the biggest problem is that dead code elimination breaks modularity! To see why, consider this scenario: The module &lt;code&gt;G&lt;/code&gt; (for example the huge Gtk2 module...) is compiled with dead code elimination turned on. So none of &lt;code&gt;G&lt;/code&gt;'s procs is generated at all.</source>
          <target state="translated">Однако самая большая проблема в том, что устранение мертвого кода нарушает модульность! Чтобы понять, почему, рассмотрим этот сценарий: модуль &lt;code&gt;G&lt;/code&gt; (например, огромный модуль Gtk2 ...) скомпилирован с включенным устранением мертвого кода. Таким образом, ни один из процессов &lt;code&gt;G&lt;/code&gt; не генерируется вообще.</target>
        </trans-unit>
        <trans-unit id="acb7eac83c404f63f4743f9a82480d0d20a94377" translate="yes" xml:space="preserve">
          <source>However you don't need to necessarily separate format patterns, a unambiguous format string like &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; is valid too (although only for years in the range 1..9999).</source>
          <target state="translated">Однако вам не обязательно разделять шаблоны формата, также допустима однозначная строка формата, например &lt;code&gt;yyyyMMddhhmmss&lt;/code&gt; (хотя только для лет в диапазоне 1..9999).</target>
        </trans-unit>
        <trans-unit id="742bd46b7a132e000ef82d863fbcce49eb7c5b85" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;int&lt;/code&gt; literals are implicitly convertible to a smaller integer type if the literal's value fits this smaller type and such a conversion is less expensive than other implicit conversions, so &lt;code&gt;myInt16 + 34&lt;/code&gt; produces an &lt;code&gt;int16&lt;/code&gt; result.</source>
          <target state="translated">Однако литералы &lt;code&gt;int&lt;/code&gt; неявно преобразуются в меньший целочисленный тип, если значение литерала соответствует этому меньшему типу и такое преобразование менее затратно, чем другие неявные преобразования, поэтому &lt;code&gt;myInt16 + 34&lt;/code&gt; дает результат &lt;code&gt;int16&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbf8251069a2532e90f19da84e2234188384c198" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;void&lt;/code&gt; type cannot be inferred in generic code:</source>
          <target state="translated">Однако тип &lt;code&gt;void&lt;/code&gt; не может быть выведен в универсальном коде:</target>
        </trans-unit>
        <trans-unit id="4c9fbaef3ddd5b531468395ce9dec2a5ab4f5ae7" translate="yes" xml:space="preserve">
          <source>However, depending on the use case &lt;code&gt;new Foo&lt;/code&gt; can also be wrapped like this instead:</source>
          <target state="translated">Однако, в зависимости от варианта использования, &lt;code&gt;new Foo&lt;/code&gt; можно также обернуть следующим образом:</target>
        </trans-unit>
        <trans-unit id="31eaf302275d7d94ef88ad6acf5c8f08d9355de8" translate="yes" xml:space="preserve">
          <source>However, for the C like targets you need to link external code either statically or dynamically. The preferred way of integrating native code is to use dynamic linking because it allows you to compile Nim programs without the need for having the related development libraries installed. This is done through the &lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;dynlib pragma for import&lt;/a&gt;, though more specific control can be gained using the &lt;a href=&quot;dynlib&quot;&gt;dynlib module&lt;/a&gt;.</source>
          <target state="translated">Однако для целей, подобных C, вам необходимо связать внешний код статически или динамически. Предпочтительный способ интеграции машинного кода - использовать динамическое связывание, потому что он позволяет компилировать программы Nim без необходимости установки соответствующих библиотек разработки. Это делается с помощью &lt;a href=&quot;manual#dynlib-pragma-for-import&quot;&gt;прагмы dynlib для импорта&lt;/a&gt; , хотя более конкретный контроль можно получить с &lt;a href=&quot;dynlib&quot;&gt;помощью модуля dynlib&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d22d44af2cd8e5a6cc6b8f108be38e9a251be52" translate="yes" xml:space="preserve">
          <source>However, if more than a single statistical calculation is required, it is more efficient to push the data once to the RunningStat object, and call the numerous statistical procs for the RunningStat object.</source>
          <target state="translated">Однако,если требуется более одного статистического вычисления,более эффективным будет однократный перенос данных в объект RunningStat и вызов многочисленных статистических профилей для объекта RunningStat.</target>
        </trans-unit>
        <trans-unit id="a5f20f62b2a4c64e2d22b78b12676a0c62815d5f" translate="yes" xml:space="preserve">
          <source>However, it is then not an ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt;, &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;pred&lt;/code&gt; are not available for them either.</source>
          <target state="translated">Однако тогда это уже не порядковый номер, поэтому эти перечисления нельзя использовать в качестве типа индекса для массивов. Для них также недоступны процедуры &lt;code&gt;inc&lt;/code&gt; , &lt;code&gt;dec&lt;/code&gt; , &lt;code&gt;succ&lt;/code&gt; и &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7f19c857394d2f63dc7cf9130779ed557032b2a" translate="yes" xml:space="preserve">
          <source>However, since a template cannot iterate over varargs, this feature is generally much more useful for macros.</source>
          <target state="translated">Однако,так как шаблон не может выполнять итерацию через varargs,эта функция обычно гораздо более полезна для макросов.</target>
        </trans-unit>
        <trans-unit id="91f963bca7858da3bd237b4e32710ada3fd1260b" translate="yes" xml:space="preserve">
          <source>However, sometimes one has to optimize. Do it in the following order:</source>
          <target state="translated">Однако иногда приходится оптимизировать.Делайте это в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="406663563bd897705cf8a1dfd9829c366e1e27d8" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;header&lt;/code&gt; pragma is often the better alternative.</source>
          <target state="translated">Однако прагма &lt;code&gt;header&lt;/code&gt; часто является лучшей альтернативой.</target>
        </trans-unit>
        <trans-unit id="0681510216903f8e2197cf4eef03fbf990baedec" translate="yes" xml:space="preserve">
          <source>However, the above code does not compile: the reason is that you have to cover every value that &lt;code&gt;n&lt;/code&gt; may contain, but the code only handles the values &lt;code&gt;0..8&lt;/code&gt;. Since it is not very practical to list every other possible integer (though it is possible thanks to the range notation), we fix this by telling the compiler that for every other value nothing should be done:</source>
          <target state="translated">Однако приведенный выше код не компилируется: причина в том, что вам нужно охватить каждое значение, которое может содержать &lt;code&gt;n&lt;/code&gt; , но код обрабатывает только значения &lt;code&gt;0..8&lt;/code&gt; . Поскольку перечислять все другие возможные целые числа не очень практично (хотя это возможно благодаря обозначению диапазона), мы исправляем это, сообщая компилятору, что для каждого другого значения ничего делать не следует:</target>
        </trans-unit>
        <trans-unit id="fb9aeb69b131c87d8cd6853cf77ea1cf9dd6d2ce" translate="yes" xml:space="preserve">
          <source>However, the constraints &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; are not available in ordinary routines.</source>
          <target state="translated">Однако &lt;code&gt;alias&lt;/code&gt; ограничений и &lt;code&gt;noalias&lt;/code&gt; недоступны в обычных подпрограммах.</target>
        </trans-unit>
        <trans-unit id="f56c3539085a2fed48c36c5577618ef3c9427982" translate="yes" xml:space="preserve">
          <source>However, the generated C code is not platform independent. C code generated for Linux does not compile on Windows, for instance. The comment on top of the C file lists the OS, CPU and CC the file has been compiled for.</source>
          <target state="translated">Однако сгенерированный C-код не является платформонезависимым.Например,сгенерированный для Linux C-код не компилируется под Windows.В комментарии поверх C-файла перечислены операционная система,процессор и CC,для которых этот файл был скомпилирован.</target>
        </trans-unit>
        <trans-unit id="a13fe01a81aad0de40fb6ccb549edb2976ed2c1b" translate="yes" xml:space="preserve">
          <source>However, the modules &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;, &lt;a href=&quot;math&quot;&gt;math&lt;/a&gt;, and &lt;a href=&quot;times&quot;&gt;times&lt;/a&gt; are available! To access the DOM, use the &lt;a href=&quot;dom&quot;&gt;dom&lt;/a&gt; module that is only available for the JavaScript platform.</source>
          <target state="translated">Тем не менее, модули &lt;a href=&quot;strutils&quot;&gt;Strutils&lt;/a&gt; , &lt;a href=&quot;math&quot;&gt;математика&lt;/a&gt; и &lt;a href=&quot;times&quot;&gt;время&lt;/a&gt; доступны! Для доступа к DOM используйте модуль &lt;a href=&quot;dom&quot;&gt;dom,&lt;/a&gt; который доступен только для платформы JavaScript.</target>
        </trans-unit>
        <trans-unit id="94036a9c51a3400f9ddd28a5c63cabe204e0c9a5" translate="yes" xml:space="preserve">
          <source>However, the symbols &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are already bound and are not looked up again. As the example shows, &lt;code&gt;bindSym&lt;/code&gt; does work with overloaded symbols implicitly.</source>
          <target state="translated">Однако символы &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeLine&lt;/code&gt; и &lt;code&gt;stdout&lt;/code&gt; уже связаны и больше не просматриваются. Как показывает пример, &lt;code&gt;bindSym&lt;/code&gt; неявно работает с перегруженными символами.</target>
        </trans-unit>
        <trans-unit id="db3f8b29b6aa7fbf63138a0a422b4e572110ad5c" translate="yes" xml:space="preserve">
          <source>However, the values being strings/json is quite problematic: Many lookup tables that are built at compiletime embed &lt;em&gt;proc vars&lt;/em&gt; and types which have no obvious string representation... Seems like AST diffing is still the best idea as it will not require to use an alien API and works with some existing Nimble packages, at least.</source>
          <target state="translated">Однако значения, являющиеся строками / json, довольно проблематичны: многие таблицы поиска, которые создаются во время компиляции, встраивают &lt;em&gt;переменные&lt;/em&gt; и типы процедур, которые не имеют очевидного строкового представления ... Похоже, что сравнение AST по-прежнему является лучшей идеей, поскольку не требует использования чужой API и работает по крайней мере с некоторыми существующими пакетами Nimble.</target>
        </trans-unit>
        <trans-unit id="5b442e77c451b3f66ae133bcb7a6fa4d2d93f7cd" translate="yes" xml:space="preserve">
          <source>However, this does not work. The problem is that the procedure should not only &lt;code&gt;return&lt;/code&gt;, but return and &lt;strong&gt;continue&lt;/strong&gt; after an iteration has finished. This &lt;em&gt;return and continue&lt;/em&gt; is called a &lt;em&gt;yield&lt;/em&gt; statement. Now the only thing left to do is to replace the &lt;code&gt;proc&lt;/code&gt; keyword by &lt;code&gt;iterator&lt;/code&gt; and here it is - our first iterator:</source>
          <target state="translated">Однако это не работает. Проблема в том, что процедура должна не только &lt;code&gt;return&lt;/code&gt; , но и &lt;strong&gt;продолжаться&lt;/strong&gt; после завершения итерации. Этот &lt;em&gt;возврат и продолжение&lt;/em&gt; называется оператором &lt;em&gt;yield&lt;/em&gt; . Теперь осталось только заменить ключевое слово &lt;code&gt;proc&lt;/code&gt; на &lt;code&gt;iterator&lt;/code&gt; и вот он - наш первый итератор:</target>
        </trans-unit>
        <trans-unit id="11fb6436d40287c29f4518b54ff0c8803e2c0fb2" translate="yes" xml:space="preserve">
          <source>However, this is seldom needed. The most common case is to extract an error message from &lt;code&gt;e&lt;/code&gt;, and for such situations it is enough to use &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt;:</source>
          <target state="translated">Однако это требуется редко. Самый распространенный случай - извлечь сообщение об ошибке из &lt;code&gt;e&lt;/code&gt; , и для таких ситуаций достаточно использовать &lt;code&gt;getCurrentExceptionMsg&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9ae0752c04a35700e1c477d06f622ee35116b587" translate="yes" xml:space="preserve">
          <source>However, you can also use a &lt;code&gt;closure&lt;/code&gt; iterator to get a different set of restrictions. See &lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;first class iterators&lt;/a&gt; for details. Iterators can have the same name and parameters as a proc, since essentially they have their own namespaces. Therefore it is common practice to wrap iterators in procs of the same name which accumulate the result of the iterator and return it as a sequence, like &lt;code&gt;split&lt;/code&gt; from the &lt;a href=&quot;strutils&quot;&gt;strutils module&lt;/a&gt;.</source>
          <target state="translated">Однако вы также можете использовать итератор &lt;code&gt;closure&lt;/code&gt; чтобы получить другой набор ограничений. См. Подробности в &lt;a href=&quot;manual#iterators-and-the-for-statement-first-class-iterators&quot;&gt;итераторах первого класса&lt;/a&gt; . Итераторы могут иметь то же имя и параметры, что и процедура, поскольку, по сути, у них есть свои собственные пространства имен. Поэтому это обычная практика , чтобы обернуть итераторы в проках одного и то же имя, накапливающихся результат итератора и вернуть его в виде последовательности, как &lt;code&gt;split&lt;/code&gt; из &lt;a href=&quot;strutils&quot;&gt;модуля strutils&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56d4f245bec69d0b576c1bfc554101ec8df594ad" translate="yes" xml:space="preserve">
          <source>Human friendly string representation of &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Удобное для человека строковое представление &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="079d3eca7e1c9c2fd619c47e7f37d0a7860da8ba" translate="yes" xml:space="preserve">
          <source>Hygiene in templates</source>
          <target state="translated">Гигиена в шаблонах</target>
        </trans-unit>
        <trans-unit id="0fcb4de22af01003cbbe36bbdb61566a4be791e9" translate="yes" xml:space="preserve">
          <source>I use the term &lt;em&gt;cell&lt;/em&gt; here to refer to everything that is traced (sequences, refs, strings). This section describes how the GC works.</source>
          <target state="translated">Я использую здесь термин &lt;em&gt;ячейка&lt;/em&gt; для обозначения всего, что отслеживается (последовательности, ссылки, строки). В этом разделе описывается, как работает GC.</target>
        </trans-unit>
        <trans-unit id="1adbf823c203d9176878f1ea4880115650f6355a" translate="yes" xml:space="preserve">
          <source>IO effect.</source>
          <target state="translated">Эффект ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="43cbc65c44c1dc2f182c90bae6d0aeab5672e98a" translate="yes" xml:space="preserve">
          <source>IPv4 mapped address.</source>
          <target state="translated">IPv4 маппируемый адрес.</target>
        </trans-unit>
        <trans-unit id="5c90dad54fd1910854f6a4d59c28bd806cb73299" translate="yes" xml:space="preserve">
          <source>IPv4-compatible address.</source>
          <target state="translated">IPv4-совместимый адрес.</target>
        </trans-unit>
        <trans-unit id="a44628ba8c21044e8636076b5b9d6ce7f49f8e2a" translate="yes" xml:space="preserve">
          <source>Identifier Mangling</source>
          <target state="translated">Идентификация</target>
        </trans-unit>
        <trans-unit id="1c28aa3eba3eb83da8260427d9817edabf51acf1" translate="yes" xml:space="preserve">
          <source>Identifier construction</source>
          <target state="translated">Определить конструкцию</target>
        </trans-unit>
        <trans-unit id="f85967cd9bf8fa30a0c4ed8ed9689bd0527d9092" translate="yes" xml:space="preserve">
          <source>Identifier equality</source>
          <target state="translated">Равенство идентификаторов</target>
        </trans-unit>
        <trans-unit id="33920d1761007ef9f769013f951c310d3a56264f" translate="yes" xml:space="preserve">
          <source>Identifiers &amp;amp; Keywords</source>
          <target state="translated">Идентификаторы и ключевые слова</target>
        </trans-unit>
        <trans-unit id="20cd19ee47a89934f0e36a1ce365b38563d00949" translate="yes" xml:space="preserve">
          <source>Identifiers are &lt;code&gt;nnkIdent&lt;/code&gt; nodes. After the name lookup pass these nodes get transferred into &lt;code&gt;nnkSym&lt;/code&gt; nodes.</source>
          <target state="translated">Идентификаторы - &lt;code&gt;nnkIdent&lt;/code&gt; узлы nnkIdent . После прохождения поиска по имени эти узлы переводятся в узлы &lt;code&gt;nnkSym&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70f77e9cbcac065322f642e26369053cdd2f513b" translate="yes" xml:space="preserve">
          <source>Identifiers are valid from the point of their declaration until the end of the block in which the declaration occurred. The range where the identifier is known is the scope of the identifier. The exact scope of an identifier depends on the way it was declared.</source>
          <target state="translated">Идентификаторы действительны с момента их декларирования до конца блока,в котором произошло декларирование.Диапазон,в котором известен идентификатор,является областью его действия.Точная сфера применения идентификатора зависит от того,как он был объявлен.</target>
        </trans-unit>
        <trans-unit id="d92daa59c2bffaa34e4f7d06ae7114ce23760fe1" translate="yes" xml:space="preserve">
          <source>Identifiers in Nim can be any string of letters, digits and underscores, beginning with a letter. Two immediate following underscores &lt;code&gt;__&lt;/code&gt; are not allowed:</source>
          <target state="translated">Идентификаторы в Nim могут быть любой строкой букв, цифр и знаков подчеркивания, начинающейся с буквы. Два следующих символа подчеркивания &lt;code&gt;__&lt;/code&gt; не допускаются:</target>
        </trans-unit>
        <trans-unit id="952eeefab257b1dc395adc18dd057b07d99f8b74" translate="yes" xml:space="preserve">
          <source>Identifies version of block</source>
          <target state="translated">Определяет версию блока</target>
        </trans-unit>
        <trans-unit id="9041398445fc89d9adc20f2af276ac74b5c7695f" translate="yes" xml:space="preserve">
          <source>Idetools invocation</source>
          <target state="translated">Воззвание Idetools</target>
        </trans-unit>
        <trans-unit id="aa8a0ddc0c68ca8c1cc048c8fc326b77812b0717" translate="yes" xml:space="preserve">
          <source>Idetools outputs is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Вывод Idetools всегда возвращается в виде отдельных строк, разделенных символами табуляции ( &lt;code&gt;\t&lt;/code&gt; ). Значения каждого столбца:</target>
        </trans-unit>
        <trans-unit id="3d0ad0f39f445a61643d2d4071287f67b574496b" translate="yes" xml:space="preserve">
          <source>Idetools will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">Idetools всегда ответит одним определением или ни одним,если не найдет ни одного правильного символа,совпадающего с позицией запроса.</target>
        </trans-unit>
        <trans-unit id="e1275cffa883535748d5035619b8b0ef08c96ca9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;address&lt;/code&gt; is &quot;&quot; then ADDR_ANY will be bound.</source>
          <target state="translated">Если &lt;code&gt;address&lt;/code&gt; &quot;&quot;, то будет привязан ADDR_ANY.</target>
        </trans-unit>
        <trans-unit id="37372fbcdbd5728a2d0bd860fbfc0027fc538aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">Если &lt;code&gt;async&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , ошибка не будет выдана в случае, если ошибка была вызвана отсутствием данных, доступных для чтения.</target>
        </trans-unit>
        <trans-unit id="389371efa6da3c7248da8f138d099fa9af63f943" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; no error will be thrown in the case when the error was caused by no data being available to be read.</source>
          <target state="translated">Если &lt;code&gt;async&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , ошибка не будет выдана в случае, если ошибка была вызвана отсутствием данных, доступных для чтения.</target>
        </trans-unit>
        <trans-unit id="f92b13775ef5d4abd1b179130a1e53880a7cf964" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;break&lt;/code&gt; is used without a jump-to location, &lt;code&gt;nnkEmpty&lt;/code&gt; replaces &lt;code&gt;nnkIdent&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;break&lt;/code&gt; используется без места перехода, &lt;code&gt;nnkEmpty&lt;/code&gt; заменяет &lt;code&gt;nnkIdent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="307e3b5354402d4ec96fc67123487c24bedd7bdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cache&lt;/code&gt; is not empty, the results of &lt;code&gt;staticExec&lt;/code&gt; are cached within the &lt;code&gt;nimcache&lt;/code&gt; directory. Use &lt;code&gt;--forceBuild&lt;/code&gt; to get rid of this caching behaviour then. &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; (the concatenated string) is used to determine whether the entry in the cache is still valid. You can use versioning information for &lt;code&gt;cache&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;cache&lt;/code&gt; не пуст, результаты &lt;code&gt;staticExec&lt;/code&gt; кэшируются в каталоге &lt;code&gt;nimcache&lt;/code&gt; . &lt;code&gt;--forceBuild&lt;/code&gt; используйте --forceBuild, чтобы избавиться от этого поведения кеширования. &lt;code&gt;command &amp;amp; input &amp;amp; cache&lt;/code&gt; (объединенная строка) используются для определения, действительна ли запись в кэше. Вы можете использовать информацию о версиях для &lt;code&gt;cache&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b345cf9e0a07a334467009e3e58006f18498e01b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; cannot be sent immediately it will be buffered and sent when &lt;code&gt;sock&lt;/code&gt; becomes writeable (during the &lt;code&gt;handleWrite&lt;/code&gt; event). It's possible that only a part of &lt;code&gt;data&lt;/code&gt; will be sent immediately, while the rest of it will be buffered and sent later.</source>
          <target state="translated">Если &lt;code&gt;data&lt;/code&gt; не могут быть отправлены немедленно, они будут &lt;code&gt;handleWrite&lt;/code&gt; в буфер и отправлены, когда &lt;code&gt;sock&lt;/code&gt; станет доступным для записи (во время события handleWrite ). Возможно, что сразу будет отправлена только часть &lt;code&gt;data&lt;/code&gt; , а остальная часть будет буферизована и отправлена ​​позже.</target>
        </trans-unit>
        <trans-unit id="50c45493d4069c7c7e10803f397d81b028853a8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;err&lt;/code&gt; is not lower than 0 no exception will be raised.</source>
          <target state="translated">Если значение &lt;code&gt;err&lt;/code&gt; не ниже 0, исключение не возникает.</target>
        </trans-unit>
        <trans-unit id="0cf358d5e12d7a571236022c026e1ba653036067" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;biggestFloat&lt;/code&gt; type.</source>
          <target state="translated">Если &lt;code&gt;format == ffDecimal&lt;/code&gt; то точность - это количество цифр, которые должны быть напечатаны после десятичной точки. Если &lt;code&gt;format == ffScientific&lt;/code&gt; то точность - это максимальное количество значащих цифр, которые нужно напечатать. &lt;em&gt;По&lt;/em&gt; умолчанию значение &lt;em&gt;precision&lt;/em&gt; - максимальное количество значащих цифр после десятичной точки для типа Nim's &lt;code&gt;biggestFloat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54b435b8d0e06d5409c71a6bb322a443d196828c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format == ffDecimal&lt;/code&gt; then precision is the number of digits to be printed after the decimal point. If &lt;code&gt;format == ffScientific&lt;/code&gt; then precision is the maximum number of significant digits to be printed. &lt;em&gt;precision&lt;/em&gt;'s default value is the maximum number of meaningful digits after the decimal point for Nim's &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">Если &lt;code&gt;format == ffDecimal&lt;/code&gt; то точность - это количество цифр, которые должны быть напечатаны после десятичной точки. Если &lt;code&gt;format == ffScientific&lt;/code&gt; то точность - это максимальное количество значащих цифр, которые нужно напечатать. Значение по умолчанию &lt;em&gt;precision&lt;/em&gt; - максимальное количество значащих цифр после десятичной точки для типа с &lt;code&gt;float&lt;/code&gt; запятой Nim .</target>
        </trans-unit>
        <trans-unit id="5ace460fa7284386356689f6617103ecd8499358" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fut&lt;/code&gt; completes first the returned future will hold true, otherwise, if &lt;code&gt;timeout&lt;/code&gt; milliseconds has elapsed first, the returned future will hold false.</source>
          <target state="translated">Если &lt;code&gt;fut&lt;/code&gt; завершается первым, возвращаемое future будет иметь значение true, в противном случае, если время &lt;code&gt;timeout&lt;/code&gt; истекло в миллисекундах, возвращенное future будет иметь значение false.</target>
        </trans-unit>
        <trans-unit id="407f272e1c73737914b8601c245e937e7c1645a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in&lt;/code&gt; had been declared as &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; then &lt;code&gt;T&lt;/code&gt; would have been bound to &lt;code&gt;char&lt;/code&gt;. But &lt;code&gt;s&lt;/code&gt; is not compatible to type &lt;code&gt;set[char]&lt;/code&gt;! The solution is to bind &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;range['a'..'z']&lt;/code&gt;. This is achieved by reversing the parameters for &lt;code&gt;contains&lt;/code&gt;; &lt;code&gt;in&lt;/code&gt; then passes its arguments in reverse order.</source>
          <target state="translated">Если бы &lt;code&gt;in&lt;/code&gt; был объявлен как &lt;code&gt;[T](elem: T, s: set[T])&lt;/code&gt; то &lt;code&gt;T&lt;/code&gt; был бы привязан к &lt;code&gt;char&lt;/code&gt; . Но &lt;code&gt;s&lt;/code&gt; не совместим с &lt;code&gt;set[char]&lt;/code&gt; типов [char] ! Решение состоит в том, чтобы привязать &lt;code&gt;T&lt;/code&gt; к &lt;code&gt;range['a'..'z']&lt;/code&gt; . Это достигается изменением параметров для &lt;code&gt;contains&lt;/code&gt; ; Затем &lt;code&gt;in&lt;/code&gt; передает свои аргументы в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="026648ef593a1b1232f572c220366aa54c2ea801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the binary number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">Если &lt;code&gt;maxLen == 0&lt;/code&gt; длина двоичного числа не имеет верхней границы. В &lt;code&gt;start + maxLen&lt;/code&gt; анализируется не более чем start + maxLen символов, вплоть до длины строки.</target>
        </trans-unit>
        <trans-unit id="a51b764ac263fbad8833f0cd967c9d52db03faf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the hexadecimal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">Если &lt;code&gt;maxLen == 0&lt;/code&gt; длина шестнадцатеричного числа не имеет верхней границы. В &lt;code&gt;start + maxLen&lt;/code&gt; анализируется не более чем start + maxLen символов, вплоть до длины строки.</target>
        </trans-unit>
        <trans-unit id="a562677ba8a99d4d9a7cacc5ea3e9107a7861eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxLen == 0&lt;/code&gt; the length of the octal number has no upper bound. Else no more than &lt;code&gt;start + maxLen&lt;/code&gt; characters are parsed, up to the length of the string.</source>
          <target state="translated">Если &lt;code&gt;maxLen == 0&lt;/code&gt; длина восьмеричного числа не имеет верхней границы. В &lt;code&gt;start + maxLen&lt;/code&gt; анализируется не более чем start + maxLen символов, вплоть до длины строки.</target>
        </trans-unit>
        <trans-unit id="595e68e557aa9284038e74f56a160c9ff7b91ad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nested&lt;/code&gt; is true, the literals are replaced everywhere in the &lt;code&gt;constructor&lt;/code&gt; AST, otherwise only the first level is considered:</source>
          <target state="translated">Если &lt;code&gt;nested&lt;/code&gt; имеет значение true, литералы заменяются везде в &lt;code&gt;constructor&lt;/code&gt; AST, в противном случае учитывается только первый уровень:</target>
        </trans-unit>
        <trans-unit id="4f29ea9e8bc8cec92963dfa196efcc3cdd9dbf0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;oneshot&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, timer will be notified only once.</source>
          <target state="translated">Если &lt;code&gt;oneshot&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , таймер будет уведомлен только один раз.</target>
        </trans-unit>
        <trans-unit id="a70580e1cf0a168c03d50768037af1f65f6b54c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;precision == -1&lt;/code&gt;, it tries to format it nicely.</source>
          <target state="translated">Если &lt;code&gt;precision == -1&lt;/code&gt; , он пытается правильно отформатировать его.</target>
        </trans-unit>
        <trans-unit id="5bf1390f2bc8d6e9c194a681c0dcbd434ac66ce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">Если &lt;code&gt;prefix == &quot;&quot;&lt;/code&gt; возвращается истина.</target>
        </trans-unit>
        <trans-unit id="f39dfcd47dad136aebe8c56a844f53a0d8d6ae02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt;, then returns &lt;em&gt;true&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is one of the following values: &lt;code&gt;n, no, false, 0, off&lt;/code&gt;, then returns &lt;em&gt;false&lt;/em&gt;. If &lt;code&gt;s&lt;/code&gt; is something else a &lt;code&gt;ValueError&lt;/code&gt; exception is raised.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; - одно из следующих значений: &lt;code&gt;y, yes, true, 1, on&lt;/code&gt; , то возвращает &lt;em&gt;true&lt;/em&gt; . Если &lt;code&gt;s&lt;/code&gt; - одно из следующих значений: &lt;code&gt;n, no, false, 0, off&lt;/code&gt; , то возвращает &lt;em&gt;false&lt;/em&gt; . Если &lt;code&gt;s&lt;/code&gt; - это что-то еще, возникает исключение &lt;code&gt;ValueError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="010a71c05f1179f8db0658264d0a7a515cb8b523" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; имеет значение false, возвращает true, только если все символы в &lt;code&gt;s&lt;/code&gt; являются алфавитными и строчными.</target>
        </trans-unit>
        <trans-unit id="4f5851e215627025c8523ee634c01c31772cd434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all characters in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; имеет значение false, возвращает true, только если все символы в &lt;code&gt;s&lt;/code&gt; являются алфавитными и прописными.</target>
        </trans-unit>
        <trans-unit id="a9ffc30f44ce015254cb84f1d8acff12890af1cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and lower case.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; имеет значение false, возвращает true, только если все руны в &lt;code&gt;s&lt;/code&gt; являются алфавитными и строчными.</target>
        </trans-unit>
        <trans-unit id="8c1ee7df97e960b64a9a34fca52a4ee613463ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is false, returns true only if all runes in &lt;code&gt;s&lt;/code&gt; are alphabetical and upper case.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; имеет значение false, возвращает true, только если все руны в &lt;code&gt;s&lt;/code&gt; являются алфавитными и прописными.</target>
        </trans-unit>
        <trans-unit id="d7daf16ddab2ec83f10b25fc93d560bdca6cc331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; истинно, возвращает истину, если все алфавитные символы в &lt;code&gt;s&lt;/code&gt; строчные. Возвращает false, если ни один из символов в &lt;code&gt;s&lt;/code&gt; не является алфавитным.</target>
        </trans-unit>
        <trans-unit id="5690821da9c726f211bd0d9f591332cb14d7d459" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical characters in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the characters in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; истинно, возвращает истину, если все буквенные символы в &lt;code&gt;s&lt;/code&gt; являются прописными. Возвращает false, если ни один из символов в &lt;code&gt;s&lt;/code&gt; не является алфавитным.</target>
        </trans-unit>
        <trans-unit id="317dfb0d58e9180509c313e714059b2f64b10411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are lower case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; истинно, возвращает истину, если все алфавитные руны в &lt;code&gt;s&lt;/code&gt; строчные. Возвращает false, если ни одна из рун в &lt;code&gt;s&lt;/code&gt; не является алфавитной.</target>
        </trans-unit>
        <trans-unit id="ed588c14681cc5f1a8b51d3a7fac0541af404239" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipNonAlpha&lt;/code&gt; is true, returns true if all alphabetical runes in &lt;code&gt;s&lt;/code&gt; are upper case. Returns false if none of the runes in &lt;code&gt;s&lt;/code&gt; are alphabetical.</source>
          <target state="translated">Если &lt;code&gt;skipNonAlpha&lt;/code&gt; истинно, возвращает истину, если все алфавитные руны в &lt;code&gt;s&lt;/code&gt; написаны в верхнем регистре. Возвращает false, если ни одна из рун в &lt;code&gt;s&lt;/code&gt; не является алфавитной.</target>
        </trans-unit>
        <trans-unit id="046a824089b8e2afbd1bb54bbb407aa442933340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;socket&lt;/code&gt; is an SSL socket a handshake will be automatically performed.</source>
          <target state="translated">Если &lt;code&gt;socket&lt;/code&gt; является SSL-сокетом, подтверждение будет выполнено автоматически.</target>
        </trans-unit>
        <trans-unit id="c110971e46a836dd2629952749afa315b2670098" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">Если &lt;code&gt;substr == &quot;&quot;&lt;/code&gt; возвращается истина.</target>
        </trans-unit>
        <trans-unit id="d757e24742c24af41e66e6d5cd0f46d4cd8adcb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; true is returned.</source>
          <target state="translated">Если &lt;code&gt;suffix == &quot;&quot;&lt;/code&gt; возвращается истина.</target>
        </trans-unit>
        <trans-unit id="b73051fe1df0d6852ad033cd16067f76b3c7f36d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; awaiting &lt;code&gt;fv&lt;/code&gt; will not block.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , ожидание &lt;code&gt;fv&lt;/code&gt; не заблокируется.</target>
        </trans-unit>
        <trans-unit id="bc9c3ff2a3345cd590a6fedc6177790735c03231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is used to determine the result type of a proc/iterator/converter call &lt;code&gt;c(X)&lt;/code&gt; (where &lt;code&gt;X&lt;/code&gt; stands for a possibly empty list of arguments), the interpretation where &lt;code&gt;c&lt;/code&gt; is an iterator is preferred over the other interpretations:</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; используется для определения типа результата вызова процедуры / итератора / преобразователя &lt;code&gt;c(X)&lt;/code&gt; (где &lt;code&gt;X&lt;/code&gt; означает, возможно, пустой список аргументов), интерпретация, в которой &lt;code&gt;c&lt;/code&gt; является итератором, предпочтительнее других интерпретаций:</target>
        </trans-unit>
        <trans-unit id="3a2410e0f5521d539c525fb5bab4dfb899762d20" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fromRoot&lt;/em&gt; is set, the traversal will start from the file system root diretory. If &lt;em&gt;inclusive&lt;/em&gt; is set, the original argument will be included in the traversal.</source>
          <target state="translated">Если &lt;em&gt;задано fromRoot&lt;/em&gt; , обход будет начинаться с корневого каталога файловой системы. Если установлено значение &lt;em&gt;inclusive&lt;/em&gt; , исходный аргумент будет включен в обход.</target>
        </trans-unit>
        <trans-unit id="199de5473c17b3499d89cf849af056dcb7ec2a21" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;leading&lt;/em&gt; is true, leading &lt;em&gt;chars&lt;/em&gt; are stripped. If &lt;em&gt;trailing&lt;/em&gt; is true, trailing &lt;em&gt;chars&lt;/em&gt; are stripped. If both are false, the string is returned unchanged.</source>
          <target state="translated">Если значение &lt;em&gt;интерлиньяжа&lt;/em&gt; истинно, &lt;em&gt;начальные символы&lt;/em&gt; удаляются. Если &lt;em&gt;завершение&lt;/em&gt; истинно, завершающие &lt;em&gt;символы&lt;/em&gt; удаляются. Если оба значения ложны, строка возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="858dcc140fb894e0ab39988b41a394056e356424" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;linkTitle&lt;/em&gt; or &lt;em&gt;linkDesc&lt;/em&gt; are not the empty string, two additional columns with their contents will be added.</source>
          <target state="translated">Если &lt;em&gt;linkTitle&lt;/em&gt; или &lt;em&gt;linkDesc&lt;/em&gt; не является пустой строкой, будут добавлены два дополнительных столбца с их содержимым.</target>
        </trans-unit>
        <trans-unit id="4e866237eb46ef9c2e685eaa551676cfb806b047" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnElement&lt;/em&gt;, runs recursively on each child node and concatenates the results.</source>
          <target state="translated">Если &lt;em&gt;n&lt;/em&gt; равно &lt;em&gt;xnElement&lt;/em&gt; , выполняется рекурсивно на каждом дочернем узле и объединяет результаты.</target>
        </trans-unit>
        <trans-unit id="fa2323ffef001ae4f50de61394ed2c4c06dd1eef" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is &lt;em&gt;xnText&lt;/em&gt; or &lt;em&gt;xnEntity&lt;/em&gt;, returns its content.</source>
          <target state="translated">Если &lt;em&gt;n&lt;/em&gt; равно &lt;em&gt;xnText&lt;/em&gt; или &lt;em&gt;xnEntity&lt;/em&gt; , возвращает его содержимое.</target>
        </trans-unit>
        <trans-unit id="6015dc5849733f7831bc335a048414718d188cdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JArray&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">Если &lt;em&gt;n&lt;/em&gt; - &lt;em&gt;JArray&lt;/em&gt; , он возвращает количество элементов. Если &lt;em&gt;n&lt;/em&gt; - объект &lt;em&gt;JObject&lt;/em&gt; , он возвращает количество пар. В противном случае он возвращает 0.</target>
        </trans-unit>
        <trans-unit id="bd5549ec7eeae51a8cdef6008f85c363b39530b0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;SList&lt;/em&gt;, it returns the number of elements. If &lt;em&gt;n&lt;/em&gt; is a &lt;em&gt;JObject&lt;/em&gt;, it returns the number of pairs. Else it returns 0.</source>
          <target state="translated">Если &lt;em&gt;n&lt;/em&gt; - &lt;em&gt;SList&lt;/em&gt; , он возвращает количество элементов. Если &lt;em&gt;n&lt;/em&gt; - объект &lt;em&gt;JObject&lt;/em&gt; , он возвращает количество пар. В противном случае он возвращает 0.</target>
        </trans-unit>
        <trans-unit id="b5d453d0776be5e831bfbd8ed97503ad7f979cee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;path&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no directory component, &lt;em&gt;dir&lt;/em&gt; is the empty string. If &lt;em&gt;path&lt;/em&gt; has no filename component, &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;ext&lt;/em&gt; are empty strings.</source>
          <target state="translated">Если &lt;em&gt;путь&lt;/em&gt; не имеет расширения, &lt;em&gt;ext&lt;/em&gt; - это пустая строка. Если &lt;em&gt;путь&lt;/em&gt; не имеет компонента каталога, &lt;em&gt;dir&lt;/em&gt; - это пустая строка. Если &lt;em&gt;путь&lt;/em&gt; не имеет компонента &lt;em&gt;имени&lt;/em&gt; файла, &lt;em&gt;name&lt;/em&gt; и &lt;em&gt;ext&lt;/em&gt; являются пустыми строками.</target>
        </trans-unit>
        <trans-unit id="80be0c8b8f0887f6f6256d7bd08befefadc198dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;places&lt;/em&gt; is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. &lt;em&gt;round(54.5) -&amp;gt; 55.0&lt;/em&gt;). If &lt;em&gt;places&lt;/em&gt; is greater than 0, round to the given number of decimal places, e.g. &lt;em&gt;round(54.346, 2) -&amp;gt; 54.35&lt;/em&gt;. If &lt;em&gt;places&lt;/em&gt; is negative, round to the left of the decimal place, e.g. &lt;em&gt;round(537.345, -1) -&amp;gt; 540.0&lt;/em&gt;</source>
          <target state="translated">Если количество &lt;em&gt;мест&lt;/em&gt; равно 0 (или опущено), округлить до ближайшего целого значения в соответствии с обычными математическими правилами округления (например, &lt;em&gt;round (54,5) -&amp;gt; 55,0&lt;/em&gt; ). Если &lt;em&gt;разрядов&lt;/em&gt; больше 0, округлить до заданного количества десятичных знаков, например, &lt;em&gt;round (54,346, 2) -&amp;gt; 54,35&lt;/em&gt; . Если &lt;em&gt;места&lt;/em&gt; отрицательное, круглая слева от десятичной точки, например , &lt;em&gt;круглого (537.345, -1) -&amp;gt; 540,0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="85943ee873870ccb602997d1ba558ce262f536fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; contains none of the characters in &lt;em&gt;chars&lt;/em&gt;, -1 is returned.</source>
          <target state="translated">Если &lt;em&gt;s не&lt;/em&gt; содержит ни одного символа в &lt;em&gt;chars&lt;/em&gt; , возвращается -1.</target>
        </trans-unit>
        <trans-unit id="918bef596764b0dd1abc0034e3aca9f099546dd6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; does not begin with &lt;code&gt;prefix&lt;/code&gt; and end with &lt;code&gt;suffix&lt;/code&gt; a ValueError exception will be raised.</source>
          <target state="translated">Если &lt;em&gt;s&lt;/em&gt; не начинается с &lt;code&gt;prefix&lt;/code&gt; и не заканчивается &lt;code&gt;suffix&lt;/code&gt; возникает исключение ValueError.</target>
        </trans-unit>
        <trans-unit id="ffecd98c556448bc07a363bac2464a9be3914393" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid binary integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0b&lt;/code&gt;, &lt;code&gt;0B&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">Если &lt;em&gt;s&lt;/em&gt; не является допустимым двоичным целым числом, возникает &lt;em&gt;ошибка ValueError&lt;/em&gt; . &lt;em&gt;s&lt;/em&gt; может иметь один из следующих необязательных префиксов: &lt;code&gt;0b&lt;/code&gt; , &lt;code&gt;0B&lt;/code&gt; . Знаки подчеркивания в &lt;em&gt;s&lt;/em&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="22934de3f162a4b17792ea0eea7d5289abc794bc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid hex integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0X&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">Если &lt;em&gt;s&lt;/em&gt; не является допустимым шестнадцатеричным целым числом, возникает &lt;em&gt;ошибка ValueError&lt;/em&gt; . &lt;em&gt;s&lt;/em&gt; может иметь один из следующих необязательных префиксов: &lt;code&gt;0x&lt;/code&gt; , &lt;code&gt;0X&lt;/code&gt; , &lt;code&gt;#&lt;/code&gt; . Знаки подчеркивания в &lt;em&gt;s&lt;/em&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="31f1b5486de0d368adaea367eae29e732db7fbdf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid integer, &lt;em&gt;ValueError&lt;/em&gt; is raised.</source>
          <target state="translated">Если &lt;em&gt;s&lt;/em&gt; не является допустимым целым числом, возникает &lt;em&gt;ошибка ValueError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a06a939f49597f675f8bb03c0e2cb909dc45d17e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is not a valid oct integer, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;em&gt;s&lt;/em&gt; can have one of the following optional prefixes: &lt;code&gt;0o&lt;/code&gt;, &lt;code&gt;0O&lt;/code&gt;. Underscores within &lt;em&gt;s&lt;/em&gt; are ignored.</source>
          <target state="translated">Если &lt;em&gt;s&lt;/em&gt; не является допустимым целым числом &lt;em&gt;oct,&lt;/em&gt; возникает &lt;em&gt;ошибка ValueError&lt;/em&gt; . &lt;em&gt;s&lt;/em&gt; может иметь один из следующих необязательных префиксов: &lt;code&gt;0o&lt;/code&gt; , &lt;code&gt;0O&lt;/code&gt; . Знаки подчеркивания в &lt;em&gt;s&lt;/em&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="27d35434baea7af37a0b648eef07955006978983" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;siPrefix&lt;/em&gt; is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as &quot;4.1 k&quot; instead of &quot;4.1e3&quot;. Note that &lt;em&gt;u&lt;/em&gt; is used for micro- in place of the greek letter mu (&amp;mu;) as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&amp;lt;f&amp;lt;1000e18 (1a&amp;lt;f&amp;lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether &lt;em&gt;siPrefix&lt;/em&gt; is true.</source>
          <target state="translated">Если для &lt;em&gt;siPrefix&lt;/em&gt; установлено значение true, число будет отображаться с префиксом SI, соответствующим экспоненте. Например, 4100 будет отображаться как &amp;laquo;4.1 k&amp;raquo; вместо &amp;laquo;4.1e3&amp;raquo;. Обратите внимание, что &lt;em&gt;u&lt;/em&gt; используется для микро вместо греческой буквы mu (&amp;mu;) в соответствии с ISO 2955. Числа с абсолютным значением вне диапазона 1e-18 &amp;lt;f &amp;lt;1000e18 (1a &amp;lt;f &amp;lt;1000E) будут отображаться с показатель степени, а не префикс SI, независимо от того, &lt;em&gt;истинно&lt;/em&gt; ли &lt;em&gt;siPrefix&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3c153378df49ceb0514b8f9591a7fe13753328b6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spread&lt;/em&gt; is false and the length of &lt;em&gt;s&lt;/em&gt; is not a multiple of &lt;em&gt;num&lt;/em&gt;, the proc will max out the first sub sequences with &lt;code&gt;1 + len(s) div num&lt;/code&gt; entries, leaving the remainder of elements to the last sequence.</source>
          <target state="translated">Если &lt;em&gt;spread&lt;/em&gt; равен false и длина &lt;em&gt;s&lt;/em&gt; не кратна &lt;em&gt;num&lt;/em&gt; , процедура максимизирует первые подпоследовательности с помощью записей &lt;code&gt;1 + len(s) div num&lt;/code&gt; , оставив оставшиеся элементы последней последовательности.</target>
        </trans-unit>
        <trans-unit id="4775826ae44f8348308b950ee7f0228f3079a862" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;trim&lt;/em&gt; is set to true, trailing zeros will be removed; if false, the number of digits specified by &lt;em&gt;precision&lt;/em&gt; will always be shown.</source>
          <target state="translated">Если для параметра &lt;em&gt;trim&lt;/em&gt; установлено значение true, завершающие нули будут удалены; если false, всегда будет отображаться количество цифр, указанное &lt;em&gt;точностью&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3df1de57df75f3d46e50b0da67618c0e39c016" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;useUnitSpace&lt;/em&gt; is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</source>
          <target state="translated">Если &lt;em&gt;useUnitSpace&lt;/em&gt; имеет значение true, предоставленная единица измерения будет добавлена ​​к строке (с пробелом, как того требует стандарт СИ). Это поведение немного отличается от добавления единицы к результату, поскольку расположение пробела изменяется в зависимости от того, есть ли показатель степени.</target>
        </trans-unit>
        <trans-unit id="0c624e82a301cd1b0a01c9e7e8780b498a5b18ce" translate="yes" xml:space="preserve">
          <source>If a declared symbol is marked with an &lt;span id=&quot;asterisk_1&quot;&gt;asterisk&lt;/span&gt; it is exported from the current module:</source>
          <target state="translated">Если объявленный символ отмечен &lt;span id=&quot;asterisk_1&quot;&gt;звездочкой,&lt;/span&gt; он экспортируется из текущего модуля:</target>
        </trans-unit>
        <trans-unit id="10f356aa84e307221ea1ddc951ea76e3235c5f18" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;ReadFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">Если была получена вся строка; &lt;code&gt;ReadFullLine&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="f6e2de7dd3af4670ee12c88866b53b3fc6104073" translate="yes" xml:space="preserve">
          <source>If a full line has been retrieved; &lt;code&gt;RecvFullLine&lt;/code&gt; is returned.</source>
          <target state="translated">Если была получена вся строка; &lt;code&gt;RecvFullLine&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="7d4edfbe8476a0a7a39ffd09f45852fb65cecbf1" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">Если читается вся строка &lt;code&gt;\r\L&lt;/code&gt; не добавляется к &lt;code&gt;line&lt;/code&gt; , однако, если читается только &lt;code&gt;\r\L&lt;/code&gt; тогда &lt;code&gt;line&lt;/code&gt; будет установлена ​​на нее.</target>
        </trans-unit>
        <trans-unit id="c16eab689c4842392a5a11dd1c091bb5c2263373" translate="yes" xml:space="preserve">
          <source>If a full line is read &lt;code&gt;\r\L&lt;/code&gt; is not added to the result, however if solely &lt;code&gt;\r\L&lt;/code&gt; is read then the result will be set to it.</source>
          <target state="translated">Если читается полная строка, &lt;code&gt;\r\L&lt;/code&gt; не добавляется к результату, однако, если читается только &lt;code&gt;\r\L&lt;/code&gt; тогда результат будет установлен на него.</target>
        </trans-unit>
        <trans-unit id="2e37450d6f575130f1da8f99af9d57374a8a5ea4" translate="yes" xml:space="preserve">
          <source>If a full line is received &lt;code&gt;\r\L&lt;/code&gt; is not added to &lt;code&gt;line&lt;/code&gt;, however if solely &lt;code&gt;\r\L&lt;/code&gt; is received then &lt;code&gt;line&lt;/code&gt; will be set to it.</source>
          <target state="translated">Если получена полная строка, &lt;code&gt;\r\L&lt;/code&gt; не добавляется к &lt;code&gt;line&lt;/code&gt; , однако, если получена только &lt;code&gt;\r\L&lt;/code&gt; тогда &lt;code&gt;line&lt;/code&gt; будет установлена ​​на нее.</target>
        </trans-unit>
        <trans-unit id="4578160882d9270d9e934109afdfbf00113bc1cc" translate="yes" xml:space="preserve">
          <source>If a line starts with &lt;code&gt;#&lt;/code&gt; it will be ignored completely, so you can use that for comments.</source>
          <target state="translated">Если строка начинается с символа &lt;code&gt;#&lt;/code&gt; , она будет полностью проигнорирована, поэтому вы можете использовать это для комментариев.</target>
        </trans-unit>
        <trans-unit id="9bc3730afa8c59c97647c426e37011adafd8a176" translate="yes" xml:space="preserve">
          <source>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified, unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</source>
          <target state="translated">Если модуль импортирует идентификатор двумя разными модулями,каждое появление идентификатора должно быть квалифицировано,если только это не перегруженная процедура или итератор,в этом случае происходит разрешение перегрузки:</target>
        </trans-unit>
        <trans-unit id="efe916c21117e3859222aca055e9bea6cec4eac2" translate="yes" xml:space="preserve">
          <source>If a node is used in a different document than the one that created it (that doesn't support it)</source>
          <target state="translated">Если узел используется в документе,отличном от того,который его создал (который его не поддерживает)</target>
        </trans-unit>
        <trans-unit id="871e2115f882350e714e39955d71707aaebf9ba5" translate="yes" xml:space="preserve">
          <source>If a parameter or an operation is not supported by the underlying object.</source>
          <target state="translated">Если параметр или операция не поддерживаются базовым объектом.</target>
        </trans-unit>
        <trans-unit id="3086cb848c98b3dd77a110e77a2de136bf838978" translate="yes" xml:space="preserve">
          <source>If a proc is annotated with the &lt;code&gt;noinit&lt;/code&gt; pragma this refers to its implicit &lt;code&gt;result&lt;/code&gt; variable:</source>
          <target state="translated">Если процедура аннотирована &lt;code&gt;noinit&lt;/code&gt; это относится к ее неявной переменной &lt;code&gt;result&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="056e8beb820913d3d337f02913145eef09e66318" translate="yes" xml:space="preserve">
          <source>If a reference points to &lt;em&gt;nothing&lt;/em&gt;, it has the value &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если ссылка &lt;em&gt;ни&lt;/em&gt; на что &lt;em&gt;не&lt;/em&gt; указывает , она имеет значение &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ad2206a1169aba9bd7c1b09f9fb0941ea61337" translate="yes" xml:space="preserve">
          <source>If a section of code holds a lock of level &lt;code&gt;M&lt;/code&gt; than it can also acquire any lock of level &lt;code&gt;N &amp;lt; M&lt;/code&gt;. Another lock of level &lt;code&gt;M&lt;/code&gt; cannot be acquired. Locks of the same level can only be acquired &lt;em&gt;at the same time&lt;/em&gt; within a single &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">Если секция кода содержит блокировку уровня &lt;code&gt;M&lt;/code&gt; , она также может получить любую блокировку уровня &lt;code&gt;N &amp;lt; M&lt;/code&gt; . Другой замок уровня &lt;code&gt;M&lt;/code&gt; получить нельзя. Замки одного уровня могут быть получены &lt;em&gt;одновременно только в&lt;/em&gt; пределах одной секции &lt;code&gt;locks&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f883af41470e39046741ce71193805e04a0fb408" translate="yes" xml:space="preserve">
          <source>If a structured type features a field with destructable type and the user has not provided an explicit implementation, a destructor for the structured type will be automatically generated. Calls to any base class destructors in both user-defined and generated destructors will be inserted.</source>
          <target state="translated">Если в структурном типе имеется поле с деструктируемым типом и пользователь не предоставил явной реализации,то деструктор для структурного типа будет сгенерирован автоматически.Деструкторы любого базового класса будут вставляться как в деструкторы,заданные пользователем,так и в деструкторы,сгенерированные им.</target>
        </trans-unit>
        <trans-unit id="0db08f2b2e98ccda7902cf1898e764d8c7f5e868" translate="yes" xml:space="preserve">
          <source>If a type section uses generic parameters, they are treated here:</source>
          <target state="translated">Если в разделе типа используются общие параметры,то они обрабатываются здесь:</target>
        </trans-unit>
        <trans-unit id="de9d3f35f669e256aa6c736e6a1afde344da10ae" translate="yes" xml:space="preserve">
          <source>If an assertion in Nim's memory manager or GC fails, the stack trace keeps allocating memory! Thus a stack overflow may happen, hiding the real issue.</source>
          <target state="translated">Если утверждение в менеджере памяти Nim или GC не удается,трасса стека продолжает выделять память! Таким образом,может произойти переполнение стека,скрывая реальную проблему.</target>
        </trans-unit>
        <trans-unit id="995c8ccff46b0b1f2916c13247fc81cbf289033e" translate="yes" xml:space="preserve">
          <source>If an attempt is made to add an attribute that is already in use elsewhere</source>
          <target state="translated">Если предпринимается попытка добавить атрибут,который уже используется в другом месте.</target>
        </trans-unit>
        <trans-unit id="a1629656009e8137e699c56c52cd43983c5570b7" translate="yes" xml:space="preserve">
          <source>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</source>
          <target state="translated">Если предпринимается попытка создать или изменить объект некорректным с точки зрения пространств имен образом.</target>
        </trans-unit>
        <trans-unit id="7d19aea11801948c78474316888135ae6018e7ae" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify an object where modifications are not allowed</source>
          <target state="translated">Если предпринимается попытка модифицировать объект,модификация которого запрещена</target>
        </trans-unit>
        <trans-unit id="19d41b1964221f77e17c0e94a5badbf64e32ab22" translate="yes" xml:space="preserve">
          <source>If an attempt is made to modify the type of the underlying object.</source>
          <target state="translated">Если предпринимается попытка изменить тип базового объекта.</target>
        </trans-unit>
        <trans-unit id="c2268feb0b92960c8ac6e11b1ff1a253a519fe84" translate="yes" xml:space="preserve">
          <source>If an attempt is made to reference a node in a context where it does not exist</source>
          <target state="translated">Если делается попытка сослаться на узел в контексте,где его нет</target>
        </trans-unit>
        <trans-unit id="95f550c8bb30a788e989fe605398e29ff476452c" translate="yes" xml:space="preserve">
          <source>If an attempt is made to use an object that is not, or is no longer, usable.</source>
          <target state="translated">Если предпринимается попытка использовать объект,который не пригоден или больше не пригоден для использования.</target>
        </trans-unit>
        <trans-unit id="4a5a5458cfa721632e1a44b5d3d63641a792b115" translate="yes" xml:space="preserve">
          <source>If an awaited future completes with an error, then &lt;code&gt;await&lt;/code&gt; will re-raise this error. To avoid this, you can use the &lt;code&gt;yield&lt;/code&gt; keyword instead of &lt;code&gt;await&lt;/code&gt;. The following section shows different ways that you can handle exceptions in async procs.</source>
          <target state="translated">Если ожидаемое будущее завершается с ошибкой, то &lt;code&gt;await&lt;/code&gt; повторно вызовет эту ошибку. Чтобы избежать этого, вы можете использовать ключевое слово &lt;code&gt;yield&lt;/code&gt; вместо &lt;code&gt;await&lt;/code&gt; . В следующем разделе показаны различные способы обработки исключений в асинхронных процессах.</target>
        </trans-unit>
        <trans-unit id="9cfe3c7dc34bbfcf5eaa53fe4a526fe2fa04f7a3" translate="yes" xml:space="preserve">
          <source>If an error occurs EOS will be raised.</source>
          <target state="translated">При возникновении ошибки поднимается EOS.</target>
        </trans-unit>
        <trans-unit id="20075c8048a0853ffcb0c572ffb4edf2ab4dea98" translate="yes" xml:space="preserve">
          <source>If an error occurs an EOS exception will be raised. Otherwise the return value will be the length of data received.</source>
          <target state="translated">При возникновении ошибки будет поднято исключение EOS.В противном случае возвращаемым значением будет длина полученных данных.</target>
        </trans-unit>
        <trans-unit id="ee9dd9a88b7a108b3b5ddebf055242224e607202" translate="yes" xml:space="preserve">
          <source>If an error occurs an OSError exception will be raised.</source>
          <target state="translated">При возникновении ошибки будет поднято исключение OSError.</target>
        </trans-unit>
        <trans-unit id="9df3e94f40e9f0642b83425fe8366b3839215739" translate="yes" xml:space="preserve">
          <source>If an error occurs the return value will be &lt;code&gt;-1&lt;/code&gt;. Otherwise the return value will be the length of data received.</source>
          <target state="translated">В случае ошибки возвращается значение &lt;code&gt;-1&lt;/code&gt; . В противном случае возвращаемое значение будет длиной полученных данных.</target>
        </trans-unit>
        <trans-unit id="65934c6d6036cdaf55bf0800e92c5afaa296761f" translate="yes" xml:space="preserve">
          <source>If an even number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is interpreted as a string delimiter.</source>
          <target state="translated">Если четное число обратных слэшей сопровождается двойной кавычкой,то для каждой пары обратных слэшей в массив argv помещается один обратный слэш,а двойная кавычковая кавычка интерпретируется как разделитель строк.</target>
        </trans-unit>
        <trans-unit id="7464323e44d0ae19ebeba4498e456ca8adf8480b" translate="yes" xml:space="preserve">
          <source>If an initializer is given the type can be omitted: the variable is then of the same type as the initializing expression. Variables are always initialized with a default value if there is no initializing expression. The default value depends on the type and is always a zero in binary.</source>
          <target state="translated">Если задан инициализатор,то тип можно опустить:тогда переменная имеет тот же тип,что и и инициализирующее выражение.При отсутствии инициализирующего выражения переменные всегда инициализируются значением по умолчанию.Значение по умолчанию зависит от типа и всегда является нулевым в двоичном выражении.</target>
        </trans-unit>
        <trans-unit id="523ee71c788d6ee708d4f30befc0a7f2aeb4aadc" translate="yes" xml:space="preserve">
          <source>If an invalid or illegal string is specified.</source>
          <target state="translated">Если указана недействительная или незаконная строка.</target>
        </trans-unit>
        <trans-unit id="31248330f03fa20f9122a001da3f7a4b63664cf0" translate="yes" xml:space="preserve">
          <source>If an odd number of backslashes is followed by a double quotation mark, one backslash is placed in the argv array for every pair of backslashes, and the double quotation mark is &quot;escaped&quot; by the remaining backslash, causing a literal double quotation mark (&quot;) to be placed in argv.</source>
          <target state="translated">Если нечетное количество обратных слэшей сопровождается двойной кавычкой,то для каждой пары обратных слэшей в массив argv помещается один обратный слэш,а двойная кавычковая кавычка &quot;экранируется&quot; оставшимся обратным слешем,в результате чего в argv помещается буквальный знак двойной кавычки (&quot;).</target>
        </trans-unit>
        <trans-unit id="ac9b41083a3085bc3f11ff622b38e4fe8c4f414b" translate="yes" xml:space="preserve">
          <source>If an optional argument is present the following lookup algorithm is used:</source>
          <target state="translated">При наличии необязательного аргумента используется следующий алгоритм поиска:</target>
        </trans-unit>
        <trans-unit id="a9811584c6a21ee0c14d6db331e13ba352d14ad0" translate="yes" xml:space="preserve">
          <source>If an unary operator's first character is &lt;code&gt;@&lt;/code&gt; it is a &lt;span id=&quot;sigilminuslike_1&quot;&gt;sigil-like&lt;/span&gt; operator which binds stronger than a &lt;code&gt;primarySuffix&lt;/code&gt;: &lt;code&gt;@x.abc&lt;/code&gt; is parsed as &lt;code&gt;(@x).abc&lt;/code&gt; whereas &lt;code&gt;$x.abc&lt;/code&gt; is parsed as &lt;code&gt;$(x.abc)&lt;/code&gt;.</source>
          <target state="translated">Если первый символ одинарного оператора является &lt;code&gt;@&lt;/code&gt; это &lt;span id=&quot;sigilminuslike_1&quot;&gt;сигил-подобный&lt;/span&gt; оператору , который связывает сильнее , чем &lt;code&gt;primarySuffix&lt;/code&gt; : &lt;code&gt;@x.abc&lt;/code&gt; анализируются как &lt;code&gt;(@x).abc&lt;/code&gt; тогда &lt;code&gt;$x.abc&lt;/code&gt; обрабатываются как &lt;code&gt;$(x.abc)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd6f49d0dfcf12fec7bb99768e6a680d44371f26" translate="yes" xml:space="preserve">
          <source>If any node is inserted somewhere it doesn't belong</source>
          <target state="translated">Если какой-нибудь узел вставлен куда-то,то он не принадлежит</target>
        </trans-unit>
        <trans-unit id="7a913709639c29598ea85076fb70279d360292bd" translate="yes" xml:space="preserve">
          <source>If assertions are turned off, it does nothing. If assertions are turned on, later versions will check the string for valid syntax.</source>
          <target state="translated">Если утверждения выключены,это ничего не даст.Если утверждения включены,более поздние версии будут проверять строку на корректность синтаксиса.</target>
        </trans-unit>
        <trans-unit id="74b5d1a57a127216acbfd875469a1f6d6875a284" translate="yes" xml:space="preserve">
          <source>If async dispatcher is not running, &lt;code&gt;cbproc&lt;/code&gt; will be executed immediately.</source>
          <target state="translated">Если диспетчер async не запущен, &lt;code&gt;cbproc&lt;/code&gt; будет запущен немедленно.</target>
        </trans-unit>
        <trans-unit id="7eaacc538f76088f4558f36cb9f8907f19b9ce21" translate="yes" xml:space="preserve">
          <source>If async dispatcher is running, &lt;code&gt;cbproc&lt;/code&gt; will be executed during next dispatcher tick.</source>
          <target state="translated">Если асинхронный диспетчер запущен, &lt;code&gt;cbproc&lt;/code&gt; будет выполнен во время следующего тика диспетчера.</target>
        </trans-unit>
        <trans-unit id="7324648ec3da0700c798c83a7252c4467f507aa2" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;code&gt;RecvFail&lt;/code&gt; is returned.</source>
          <target state="translated">Если вызов &lt;code&gt;recv&lt;/code&gt; не удался; &lt;code&gt;RecvFail&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="71f6a401dad3e06dd5b3b05ed44e34fcc7b8ef06" translate="yes" xml:space="preserve">
          <source>If call to &lt;code&gt;recv&lt;/code&gt; failed; &lt;strong&gt;an EOS exception is raised.&lt;/strong&gt;</source>
          <target state="translated">Если вызов &lt;code&gt;recv&lt;/code&gt; не удался; &lt;strong&gt;возникает исключение EOS.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caa867aef2e9b590f00e0b0045de459f37c6f8f5" translate="yes" xml:space="preserve">
          <source>If data is specified for a node which does not support data</source>
          <target state="translated">Если данные указаны для узла,который не поддерживает данные</target>
        </trans-unit>
        <trans-unit id="e824895cdb4cef64be7375ea8413a63a868d2ccc" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; is defined, &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; or &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; (POSIX) or &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; (Windows). This file can be skipped with the &lt;code&gt;--skipUserCfg&lt;/code&gt; command line option.</source>
          <target state="translated">Если переменная среды &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; определена, &lt;code&gt;$XDG_CONFIG_HOME/nim/nim.cfg&lt;/code&gt; или &lt;code&gt;~/.config/nim/nim.cfg&lt;/code&gt; (POSIX) или &lt;code&gt;%APPDATA%/nim/nim.cfg&lt;/code&gt; (Windows). Этот файл можно пропустить с помощью &lt;code&gt;--skipUserCfg&lt;/code&gt; командной строки --skipUserCfg .</target>
        </trans-unit>
        <trans-unit id="20ac8fdf916d130ad74ee2dd25e10ce69bd5ec18" translate="yes" xml:space="preserve">
          <source>If expression</source>
          <target state="translated">Если выражение</target>
        </trans-unit>
        <trans-unit id="69dbcb321d20b0e49d118ee95433af7f3dbbbc3b" translate="yes" xml:space="preserve">
          <source>If future has already completed then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">Если future уже завершился, то немедленно будет вызван &lt;code&gt;cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d41b28de410ec7385af014da7c0540575e3aaaaf" translate="yes" xml:space="preserve">
          <source>If head is the empty string, tail is returned. If tail is the empty string, head is returned with a trailing path separator. If tail starts with a path separator it will be removed when concatenated to head. Other path separators not located on boundaries won't be modified. More examples on Unix:</source>
          <target state="translated">Если голова-пустая строка,возвращается хвост.Если хвост-пустая строка,то голова возвращается с разделителем путей.Если хвост начинается с разделителя путей,то при соединении с головой он удаляется.Другие разделители путей,не расположенные на границах,изменяться не будут.Дополнительные примеры на Unix:</target>
        </trans-unit>
        <trans-unit id="7ed9d728cd6081bbf88a148e476d401db74961e1" translate="yes" xml:space="preserve">
          <source>If in the above example module &lt;code&gt;B&lt;/code&gt; is re-compiled, but &lt;code&gt;A&lt;/code&gt; is not then &lt;code&gt;B&lt;/code&gt; needs to be aware of &lt;code&gt;toBool&lt;/code&gt; even though &lt;code&gt;toBool&lt;/code&gt; is not referenced in &lt;code&gt;B&lt;/code&gt;&lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">Если в приведенном выше примере модуль &lt;code&gt;B&lt;/code&gt; перекомпилирован, а &lt;code&gt;A&lt;/code&gt; - нет, тогда &lt;code&gt;B&lt;/code&gt; должен знать о &lt;code&gt;toBool&lt;/code&gt; , даже если &lt;code&gt;toBool&lt;/code&gt; не упоминается в &lt;code&gt;B&lt;/code&gt; &lt;em&gt;явно&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f6d860796a5fd822923ee9652b94bac30474c3be" translate="yes" xml:space="preserve">
          <source>If index or size is negative, or greater than the allowed value</source>
          <target state="translated">Если индекс или размер отрицательный или больше допустимого значения</target>
        </trans-unit>
        <trans-unit id="e39e35b0fbc867536af0e669f2cd71c2245083f7" translate="yes" xml:space="preserve">
          <source>If more items are expected to be added, simply add that expected extra amount to the parameter before calling this.</source>
          <target state="translated">Если ожидается добавление большего количества элементов,просто добавьте эту ожидаемую дополнительную сумму к параметру перед вызовом.</target>
        </trans-unit>
        <trans-unit id="053100f3c7f667ff05d2bace27aa288dee22ba26" translate="yes" xml:space="preserve">
          <source>If more precise control is needed, the apostrophe &lt;code&gt;'&lt;/code&gt; can be used in the supplied pattern to denote the concrete type parameters of the generic type. See the usage of the apostrophe operator in proc patterns for more details.</source>
          <target state="translated">Если более точный контроль необходим, апостроф &lt;code&gt;'&lt;/code&gt; может быть использован в поставляемом шаблоне для обозначения параметров типа бетона общего типа. Подробнее см. Использование оператора апострофа в шаблонах proc.</target>
        </trans-unit>
        <trans-unit id="ce96d5e60286391515a7cbb0c79e9c3bb3e9d383" translate="yes" xml:space="preserve">
          <source>If nimcache already contains compiled code from a different compiler for the same project, add the &lt;code&gt;-f&lt;/code&gt; flag to force all files to be recompiled.</source>
          <target state="translated">Если nimcache уже содержит скомпилированный код из другого компилятора для того же проекта, добавьте флаг &lt;code&gt;-f&lt;/code&gt; , чтобы принудительно перекомпилировать все файлы.</target>
        </trans-unit>
        <trans-unit id="5153d6410770a93b318a519a75636621e9c4c3aa" translate="yes" xml:space="preserve">
          <source>If no data could be retrieved; &lt;code&gt;ReadNone&lt;/code&gt; is returned.</source>
          <target state="translated">Если не удалось получить данные; &lt;code&gt;ReadNone&lt;/code&gt; не возвращается.</target>
        </trans-unit>
        <trans-unit id="ec6c8813bd137356b82ff72079b75a071a3a49ec" translate="yes" xml:space="preserve">
          <source>If no exception name is given, the current exception is &lt;span id=&quot;reminusraised_1&quot;&gt;re-raised&lt;/span&gt;. The &lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt; exception is raised if there is no exception to re-raise. It follows that the &lt;code&gt;raise&lt;/code&gt; statement &lt;em&gt;always&lt;/em&gt; raises an exception.</source>
          <target state="translated">Если имя исключения не указано, текущее исключение &lt;span id=&quot;reminusraised_1&quot;&gt;возбуждается повторно&lt;/span&gt; . &lt;span id=&quot;reraiseerror_1&quot;&gt;ReraiseError&lt;/span&gt; возбуждается исключение , если не является исключением ререйз. Отсюда следует, что оператор &lt;code&gt;raise&lt;/code&gt; &lt;em&gt;всегда&lt;/em&gt; вызывает исключение.</target>
        </trans-unit>
        <trans-unit id="bcb6340cf10c05ccf2a7bfa1e1c0783de9d0f0ba" translate="yes" xml:space="preserve">
          <source>If object &lt;code&gt;a&lt;/code&gt; inherits from &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;b&lt;/code&gt;. This subtype relation is extended to the types &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt;:</source>
          <target state="translated">Если объект &lt;code&gt;a&lt;/code&gt; наследуется от &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; является подтипом &lt;code&gt;b&lt;/code&gt; . Это отношение подтипа распространяется на типы &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ptr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="54ad6ae52f22f23880a6fa7417dc9ed9f2690573" translate="yes" xml:space="preserve">
          <source>If possible, the name parameter should match the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously can be used. Note that the timezones name is used for checking equality!</source>
          <target state="translated">Если возможно,параметр name должен совпадать с именем,используемым в БД tz.Если часовой пояс не существует в базе данных tz,или если имя часового пояса неизвестно,то можно использовать любую строку,однозначно описывающую часовой пояс.Обратите внимание,что имя часового пояса используется для проверки равенства!</target>
        </trans-unit>
        <trans-unit id="83cab258bfaceba0e5d7e569b163a43ec079fd90" translate="yes" xml:space="preserve">
          <source>If possible, the name will be the name used in the tz database. If the timezone doesn't exist in the tz database, or if the timezone name is unknown, then any string that describes the timezone unambiguously might be used. For example, the string &quot;LOCAL&quot; is used for the systems local timezone.</source>
          <target state="translated">По возможности,это имя будет именем,используемым в базе данных tz.Если часовой пояс не существует в базе данных tz,или если имя часового пояса неизвестно,то может быть использована любая строка,которая однозначно описывает часовой пояс.Например,строка &quot;LOCAL&quot; используется для системного локального часового пояса.</target>
        </trans-unit>
        <trans-unit id="7d4e5a5abdc253c34bc8994506a514f7e8a3ab93" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если сокет отключен и данные для чтения недоступны, в будущем будет указано значение &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddadec8d4ad0814aaa2791b6db2a33e17de90113" translate="yes" xml:space="preserve">
          <source>If socket is disconnected and no data is available to be read then the future will complete with a value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Если сокет отключен и данные для чтения недоступны, то будущее завершится со значением &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb3029d46833d06111b6e34f35f0929a92d0edb0" translate="yes" xml:space="preserve">
          <source>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</source>
          <target state="translated">Если розетка отсоединяется во время повторного включения,то в будущем может быть использована только часть запрашиваемых данных.</target>
        </trans-unit>
        <trans-unit id="0df46d3074a79a13b57275819c9d87a8439b076c" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;ReadPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">Если какие-то данные были получены; &lt;code&gt;ReadPartialLine&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="f385d830d03b348ca6c7d251ed0e117515ba157e" translate="yes" xml:space="preserve">
          <source>If some data has been retrieved; &lt;code&gt;RecvPartialLine&lt;/code&gt; is returned.</source>
          <target state="translated">Если какие-то данные были получены; &lt;code&gt;RecvPartialLine&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="99b6837e1f741f3a2cc549944f6142c90af6d182" translate="yes" xml:space="preserve">
          <source>If statement</source>
          <target state="translated">Если заявление</target>
        </trans-unit>
        <trans-unit id="841bf5112e092c8cd39e9d2e2357a35f6b5f6da7" translate="yes" xml:space="preserve">
          <source>If the '#' character is present, integers use the 'alternate form' for formatting. This means that binary, octal, and hexadecimal output will be prefixed with '0b', '0o', and '0x', respectively.</source>
          <target state="translated">Если присутствует символ '#',то целые числа используют 'альтернативную форму' для форматирования.Это означает,что двоичный,восьмеричный и шестнадцатеричный вывод будут префиксованы с '0b','0o' и '0x',соответственно.</target>
        </trans-unit>
        <trans-unit id="2701e9b83a0e728206e51f442c68eb180551bc76" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;experimental mode&lt;/a&gt; is active and no other match is found, the first argument &lt;code&gt;a&lt;/code&gt; is dereferenced automatically if it's a pointer type and overloading resolution is tried with &lt;code&gt;a[]&lt;/code&gt; instead.</source>
          <target state="translated">Если активен &lt;a href=&quot;#pragmas-experimental-pragma&quot;&gt;экспериментальный режим&lt;/a&gt; и не найдено других совпадений, первый аргумент &lt;code&gt;a&lt;/code&gt; разыменовывается автоматически, если это тип указателя, и вместо этого пробуется разрешение перегрузки с &lt;code&gt;a[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30f04b40fb234123c9240535d5420bf04b4bad00" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;line&lt;/code&gt; pragma is used with a parameter, the parameter needs be a &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt;. If it is used without a parameter, &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; is used.</source>
          <target state="translated">Если директива &lt;code&gt;line&lt;/code&gt; используется с параметром, параметр должен быть &lt;code&gt;tuple[filename: string, line: int]&lt;/code&gt; . Если он используется без параметра, используется &lt;code&gt;system.InstantiationInfo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc91ac0b9432830816ba69fa3ae8519ab1eeae46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;raise&lt;/code&gt; keyword is not followed by an expression, the last exception is &lt;em&gt;re-raised&lt;/em&gt;. For the purpose of avoiding repeating this common code pattern, the template &lt;code&gt;newException&lt;/code&gt; in the &lt;code&gt;system&lt;/code&gt; module can be used:</source>
          <target state="translated">Если &lt;code&gt;raise&lt;/code&gt; ключевое слово не следует выражение, последнее исключение &lt;em&gt;ререйз&lt;/em&gt; . Чтобы избежать повторения этого общего шаблона кода, можно использовать шаблон &lt;code&gt;newException&lt;/code&gt; в &lt;code&gt;system&lt;/code&gt; модуле:</target>
        </trans-unit>
        <trans-unit id="a29b5294c2d5b8f33f39477a3e8ec43eeb105639" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stackTrace&lt;/code&gt; option is turned on, the generated C contains code to ensure that proper stack traces are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">Если опция &lt;code&gt;stackTrace&lt;/code&gt; включена , сгенерированный C содержит код, обеспечивающий правильную трассировку стека в случае сбоя программы или возникновения неперехваченного исключения.</target>
        </trans-unit>
        <trans-unit id="69353978c65a0ffe1cd9e998af57fe30abaceb6d" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;filename&lt;/em&gt; has no extension, &lt;em&gt;ext&lt;/em&gt; will be added. If &lt;em&gt;ext&lt;/em&gt; == &quot;&quot; then any extension is removed. &lt;em&gt;Ext&lt;/em&gt; should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</source>
          <target state="translated">Если &lt;em&gt;имя файла&lt;/em&gt; не имеет расширения, будет добавлен &lt;em&gt;ext&lt;/em&gt; . Если &lt;em&gt;ext&lt;/em&gt; == &quot;&quot;, то любое расширение удаляется. &lt;em&gt;Ext&lt;/em&gt; следует указывать без начального символа '.', Потому что некоторые файловые системы могут использовать другой символ. (Хотя я не знаю такого зверя.)</target>
        </trans-unit>
        <trans-unit id="79ace98adbbf3c8936f6e66ea8ff73968f01fefd" translate="yes" xml:space="preserve">
          <source>If the GNU assembler is used, quotes and newlines are inserted automatically:</source>
          <target state="translated">Если используется ассемблер GNU,кавычки и новые строки вставляются автоматически:</target>
        </trans-unit>
        <trans-unit id="0f567e3c2047b434a83b4adc7353c2da45d5c2c6" translate="yes" xml:space="preserve">
          <source>If the awaited futures &lt;em&gt;are&lt;/em&gt;&lt;code&gt;Future[void]&lt;/code&gt;, this proc returns &lt;code&gt;Future[void]&lt;/code&gt;.</source>
          <target state="translated">Если ожидаемые фьючерсы &lt;em&gt;- &lt;/em&gt; &lt;code&gt;Future[void]&lt;/code&gt; , эта процедура возвращает &lt;code&gt;Future[void]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa43020aaaa8cf58315161b2bb7c7b775d6b572a" translate="yes" xml:space="preserve">
          <source>If the awaited futures are not &lt;code&gt;Future[void]&lt;/code&gt;, the returned future will hold the values of all awaited futures in a sequence.</source>
          <target state="translated">Если ожидаемые фьючерсы не являются &lt;code&gt;Future[void]&lt;/code&gt; , возвращенное будущее будет содержать значения всех ожидаемых фьючерсов в последовательности.</target>
        </trans-unit>
        <trans-unit id="5fe1d39f639c6431559fde4aae2a700b0d4ccf44" translate="yes" xml:space="preserve">
          <source>If the file does not exist &lt;em&gt;EIO&lt;/em&gt; is raised. The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">Если файл не существует, поднимается &lt;em&gt;EIO&lt;/em&gt; . Завершающие символы новой строки удаляются из повторяющихся строк. Пример:</target>
        </trans-unit>
        <trans-unit id="bafa24e01b0dca07bfac7c2248312106929d5bde" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then an empty string is returned.</source>
          <target state="translated">Если указатель на файл находится в конце файла,то возвращается пустая строка.</target>
        </trans-unit>
        <trans-unit id="76343cf0f621f6a2b7f316008b6f0e6e56f15e33" translate="yes" xml:space="preserve">
          <source>If the file pointer is past the end of the file then zero is returned and no bytes are read into &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">Если указатель файла находится за пределами конца файла, возвращается ноль и байты не читаются в &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9e8d1e3329be3b1efe953e0d47c9f6690b475b1" translate="yes" xml:space="preserve">
          <source>If the for loop expression &lt;code&gt;e&lt;/code&gt; does not denote an iterator and the for loop has exactly 1 variable, the for loop expression is rewritten to &lt;code&gt;items(e)&lt;/code&gt;; ie. an &lt;code&gt;items&lt;/code&gt; iterator is implicitly invoked:</source>
          <target state="translated">Если выражение цикла for &lt;code&gt;e&lt;/code&gt; не обозначает итератор, а цикл for имеет ровно 1 переменную, выражение цикла for перезаписывается в &lt;code&gt;items(e)&lt;/code&gt; ; то есть. &lt;code&gt;items&lt;/code&gt; итератора неявно вызывается:</target>
        </trans-unit>
        <trans-unit id="f1948e286ab2aa083c7abdf710bb8b040d1a1433" translate="yes" xml:space="preserve">
          <source>If the for loop has exactly 2 variables, a &lt;code&gt;pairs&lt;/code&gt; iterator is implicitly invoked.</source>
          <target state="translated">Если цикл имеет ровно 2 переменные, а &lt;code&gt;pairs&lt;/code&gt; итераторов неявно вызывается.</target>
        </trans-unit>
        <trans-unit id="6316f54cbdea61f6ea28df0e5d5c083559be9b99" translate="yes" xml:space="preserve">
          <source>If the formal parameter &lt;code&gt;f&lt;/code&gt; is of type &lt;code&gt;var T&lt;/code&gt; in addition to the ordinary type checking, the argument is checked to be an &lt;span id=&quot;lminusvalue_1&quot;&gt;l-value&lt;/span&gt;. &lt;code&gt;var T&lt;/code&gt; matches better than just &lt;code&gt;T&lt;/code&gt; then.</source>
          <target state="translated">Если формальный параметр &lt;code&gt;f&lt;/code&gt; имеет тип &lt;code&gt;var T&lt;/code&gt; в дополнение к обычной проверке типа, аргумент проверяется как &lt;span id=&quot;lminusvalue_1&quot;&gt;l-значение&lt;/span&gt; . Тогда &lt;code&gt;var T&lt;/code&gt; соответствует лучше, чем просто &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06c385a15682548ea060388897b3ee567fedd764" translate="yes" xml:space="preserve">
          <source>If the future stream already has data or is finished then &lt;code&gt;cb&lt;/code&gt; will be called immediately.</source>
          <target state="translated">Если в будущем потоке уже есть данные или он завершен , немедленно вызывается &lt;code&gt;cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a17c29c098e84ef9b5397d265f349b1b95a392e" translate="yes" xml:space="preserve">
          <source>If the handler does not raise an exception, ordinary control flow continues and the program is terminated.</source>
          <target state="translated">Если обработчик не поднимает исключение,обычный поток управления продолжается,и программа завершается.</target>
        </trans-unit>
        <trans-unit id="ba2e71c9350a067beb4f36ed2c2123aef7d9b604" translate="yes" xml:space="preserve">
          <source>If the implementation does not support the requested type of object or operation.</source>
          <target state="translated">Если реализация не поддерживает запрашиваемый тип объекта или операции.</target>
        </trans-unit>
        <trans-unit id="e36df26fc214c0ac51566c4f11deb9d6bc0cf23a" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the file handle is invalid, an error will be thrown.</source>
          <target state="translated">Если информация не может быть получена,например,когда файловая рукоятка недействительна,будет выброшена ошибка.</target>
        </trans-unit>
        <trans-unit id="931654e57ac7ff5e6e25ca20aeac61e7abee7076" translate="yes" xml:space="preserve">
          <source>If the information cannot be retrieved, such as when the path doesn't exist, or when permission restrictions prevent the program from retrieving file information, an error will be thrown.</source>
          <target state="translated">Если информация не может быть получена,например,когда путь не существует,или когда ограничения прав не позволяют программе получить информацию о файле,будет выдана ошибка.</target>
        </trans-unit>
        <trans-unit id="c9e1e4f07efdbdfe683f438bf843008ae55e735b" translate="yes" xml:space="preserve">
          <source>If the iterator yields a tuple, there can be as many iteration variables as there are components in the tuple. The i'th iteration variable's type is the type of the i'th component. In other words, implicit tuple unpacking in a for loop context is supported.</source>
          <target state="translated">Если итератор дает кортеж,то итерационных переменных может быть столько же,сколько и компонентов в кортеже.Тип i-й итерационной переменной-тип i-й компоненты.Другими словами,поддерживается неявная распаковка кортежа в контексте цикла for.</target>
        </trans-unit>
        <trans-unit id="6f90e673e99dd8f0b56aa326b33eb0d0306fdf75" translate="yes" xml:space="preserve">
          <source>If the operator ends with &lt;code&gt;=&lt;/code&gt; and its first character is none of &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, it is an &lt;em&gt;assignment operator&lt;/em&gt; which has the second lowest precedence.</source>
          <target state="translated">Если оператор концы с &lt;code&gt;=&lt;/code&gt; и первым символом не являются ни один из &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , это &lt;em&gt;оператор присваивания,&lt;/em&gt; имеющий второй самый низкий приоритет.</target>
        </trans-unit>
        <trans-unit id="77d5ae1836106c51a0b36a1a34e1eea987b0968e" translate="yes" xml:space="preserve">
          <source>If the proc declaration has no body, it is a &lt;span id=&quot;forward_1&quot;&gt;forward&lt;/span&gt; declaration. If the proc returns a value, the procedure body can access an implicitly declared variable named &lt;span id=&quot;result_2&quot;&gt;result&lt;/span&gt; that represents the return value. Procs can be overloaded. The overloading resolution algorithm determines which proc is the best match for the arguments. Example:</source>
          <target state="translated">Если декларация прок не имеет тела, это &lt;span id=&quot;forward_1&quot;&gt;вперед&lt;/span&gt; декларация. Если процедура возвращает значение, тело процедуры может получить доступ к неявно объявленной переменной с именем &lt;span id=&quot;result_2&quot;&gt;result,&lt;/span&gt; которая представляет возвращаемое значение. Проки могут быть перегружены. Алгоритм разрешения перегрузки определяет, какая процедура лучше всего подходит для аргументов. Пример:</target>
        </trans-unit>
        <trans-unit id="7f9553b958c19cddce23d7730df0fa25e4ae656d" translate="yes" xml:space="preserve">
          <source>If the procedure needs to modify the argument for the caller, a &lt;code&gt;var&lt;/code&gt; parameter can be used:</source>
          <target state="translated">Если процедуре необходимо изменить аргумент для вызывающей стороны, можно использовать параметр &lt;code&gt;var&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ffce8267c957e13dff8b29b02ca2b908de49e40" translate="yes" xml:space="preserve">
          <source>If the result of the future is an error then that error will be raised.</source>
          <target state="translated">Если результат будущего-ошибка,то эта ошибка будет повышена.</target>
        </trans-unit>
        <trans-unit id="16b303009a30beca5105d2aa322ae24b48a52b7d" translate="yes" xml:space="preserve">
          <source>If the resulting string is not longer than the original input string, only a single memory allocation is required.</source>
          <target state="translated">Если результирующая строка не длиннее исходной входной строки,требуется только одно выделение памяти.</target>
        </trans-unit>
        <trans-unit id="a9b83a69915f2923c508823edf191d18bfe7c62b" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;ReadDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">Если розетка была отключена; &lt;code&gt;ReadDisconnected&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="2f2159e99fd16ad61ca59fb4cff56737dc03dd06" translate="yes" xml:space="preserve">
          <source>If the socket has been disconnected; &lt;code&gt;RecvDisconnected&lt;/code&gt; is returned.</source>
          <target state="translated">Если розетка была отключена; &lt;code&gt;RecvDisconnected&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="06267d9401718740a7aedde535d821882f38a309" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected in the middle of a line (before &lt;code&gt;\r\L&lt;/code&gt; is read) then line will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;. The partial line &lt;strong&gt;will be lost&lt;/strong&gt;.</source>
          <target state="translated">Если сокет отключен в середине строки (до чтения &lt;code&gt;\r\L&lt;/code&gt; ), тогда строка будет установлена ​​на &lt;code&gt;&quot;&quot;&lt;/code&gt; . Неполная линия &lt;strong&gt;будет потеряна&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="aff4ce46ec1145925961993e78a141b3df5cdc42" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; will be returned.</source>
          <target state="translated">Если сокет отключен, &lt;code&gt;line&lt;/code&gt; будет установлена ​​в &lt;code&gt;&quot;&quot;&lt;/code&gt; и будет возвращено значение &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4152f2601369713f5b3377cbe629187b41c395fa" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, &lt;code&gt;line&lt;/code&gt; will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если розетка отключена, &lt;code&gt;line&lt;/code&gt; будет установлена ​​на &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7db7153a9dd78804e9f3e45b8ee428bd5b09802b" translate="yes" xml:space="preserve">
          <source>If the socket is disconnected, the result will be set to &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Если сокет отключен, результат будет установлен в &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d578dee840a7c31291fc81e023d496e5514d739" translate="yes" xml:space="preserve">
          <source>If the specified range of text does not fit into a DOMString Currently not used(Since DOMString is just string)</source>
          <target state="translated">Если указанный диапазон текста не помещается в DOMString,который в настоящее время не используется (поскольку DOMString-это просто строка).</target>
        </trans-unit>
        <trans-unit id="81b18a9e716c01074670be16ff9f7b2d4da9d53a" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned off, &lt;code&gt;TaintedString&lt;/code&gt; is simply an alias for &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Если режим заражения выключен, &lt;code&gt;TaintedString&lt;/code&gt; является просто псевдонимом для &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ade66f9e7d10ed2722b60a91ec1dc67330d9fa7" translate="yes" xml:space="preserve">
          <source>If the taint mode is turned on (via the &lt;code&gt;--taintMode:on&lt;/code&gt; command line option) it is a distinct string type which helps to detect input validation errors:</source>
          <target state="translated">Если режим заражения включен (с помощью параметра &lt;code&gt;--taintMode:on&lt;/code&gt; командной строки), это отдельный строковый тип, который помогает обнаруживать ошибки проверки ввода:</target>
        </trans-unit>
        <trans-unit id="9614b1e1a8be3e96f495969f1af445d51d40d1c3" translate="yes" xml:space="preserve">
          <source>If the template does not have types for its parameters, the type identifiers inside &lt;code&gt;nnkFormalParams&lt;/code&gt; just becomes &lt;code&gt;nnkEmpty&lt;/code&gt;.</source>
          <target state="translated">Если шаблон не имеет типов для своих параметров, идентификаторы типа внутри &lt;code&gt;nnkFormalParams&lt;/code&gt; просто становятся &lt;code&gt;nnkEmpty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80a4298614b1c88fcba898b49b736115a77cf332" translate="yes" xml:space="preserve">
          <source>If the template has no explicit return type, &lt;code&gt;void&lt;/code&gt; is used for consistency with procs and methods.</source>
          <target state="translated">Если шаблон не имеет явного возвращаемого типа, &lt;code&gt;void&lt;/code&gt; используется для согласованности с процедурами и методами.</target>
        </trans-unit>
        <trans-unit id="bea9fb33db15316176ec096b57a2d7c1faae43c3" translate="yes" xml:space="preserve">
          <source>If the width field is preceded by a zero ('0') character, this enables zero-padding.</source>
          <target state="translated">Если полю ширины предшествует символ нуля ('0'),то это включает нулевую подстановку.</target>
        </trans-unit>
        <trans-unit id="08e24dc66cc5899916445680c12d07116f7a31f9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;finally&lt;/code&gt; part, it is always executed after the exception handlers.</source>
          <target state="translated">Если есть часть &lt;code&gt;finally&lt;/code&gt; , она всегда выполняется после обработчиков исключений.</target>
        </trans-unit>
        <trans-unit id="5403f5f769c6890d6ee94ea9cf83af93e0867d21" translate="yes" xml:space="preserve">
          <source>If there is a &lt;span id=&quot;finally_1&quot;&gt;finally&lt;/span&gt; clause, it is always executed after the exception handlers.</source>
          <target state="translated">Если есть предложение &lt;span id=&quot;finally_1&quot;&gt;finally&lt;/span&gt; , оно всегда выполняется после обработчиков исключений.</target>
        </trans-unit>
        <trans-unit id="b016123034bebbefe22ae78b4065b8c3fdf35002" translate="yes" xml:space="preserve">
          <source>If there is no data to be read from the socket &lt;code&gt;False&lt;/code&gt; will be returned.</source>
          <target state="translated">Если нет данных для чтения из сокета, будет возвращено значение &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="675af36ecdb4bc1179580030d8540852cbfd5745" translate="yes" xml:space="preserve">
          <source>If this algorithm returns &quot;ambiguous&quot; further disambiguation is performed: If the argument &lt;code&gt;a&lt;/code&gt; matches both the parameter type &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; of &lt;code&gt;q&lt;/code&gt; via a subtyping relation, the inheritance depth is taken into account:</source>
          <target state="translated">Если этот алгоритм возвращает &quot;неоднозначный&quot;, выполняется дальнейшее устранение неоднозначности: если аргумент &lt;code&gt;a&lt;/code&gt; совпадает с типом параметра &lt;code&gt;f&lt;/code&gt; для &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;g&lt;/code&gt; для &lt;code&gt;q&lt;/code&gt; через отношение подтипов, глубина наследования принимается во внимание:</target>
        </trans-unit>
        <trans-unit id="fa135c30bca2146e78a4a18c707a6e4c9777b26c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the attributes from &lt;em&gt;source&lt;/em&gt; into &lt;em&gt;dest&lt;/em&gt;. On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. To preserve attributes recursively on these platforms use &lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions()&lt;/a&gt;.</source>
          <target state="translated">Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . На платформе Windows этот процесс скопирует атрибуты из &lt;em&gt;источника&lt;/em&gt; в &lt;em&gt;dest&lt;/em&gt; . На других платформах созданные файлы и каталоги будут наследовать разрешения по умолчанию для вновь созданного файла / каталога для пользователя. Для рекурсивного сохранения атрибутов на этих платформах используйте &lt;a href=&quot;#copyDirWithPermissions&quot;&gt;copyDirWithPermissions ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ba7406fce433f75c1da2d28edafd72b5ca2511c" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. On the Windows platform this proc will copy the source file's attributes into dest. On other platforms you need to use &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; to copy them by hand (or use the convenience &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; proc), otherwise &lt;em&gt;dest&lt;/em&gt; will inherit the default permissions of a newly created file for the user. If &lt;em&gt;dest&lt;/em&gt; already exists, the file attributes will be preserved and the content overwritten.</source>
          <target state="translated">Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . На платформе Windows этот процесс скопирует атрибуты исходного файла в dest. На других платформах вам необходимо использовать &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions ()&lt;/a&gt; и &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions (),&lt;/a&gt; чтобы скопировать их вручную (или использовать удобную процедуру &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions ()&lt;/a&gt; ), в противном случае &lt;em&gt;dest&lt;/em&gt; унаследует разрешения по умолчанию для вновь созданного файла для пользователя. Если &lt;em&gt;dest&lt;/em&gt; уже существует, атрибуты файла будут сохранены, а содержимое перезаписано.</target>
        </trans-unit>
        <trans-unit id="1c44eb8131bad6bf3fd6310d51476fb0e8f9dddf" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This does not fail if the directory never existed in the first place.</source>
          <target state="translated">Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . Это не сработает, если каталог никогда не существовал.</target>
        </trans-unit>
        <trans-unit id="b23ad4f30781ff872aab84374d7929409d46858b" translate="yes" xml:space="preserve">
          <source>If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. This is a wrapper proc around &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; and &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions()&lt;/a&gt; on non Windows platforms. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyDir&quot;&gt;copyDir()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . Это процедура-оболочка для &lt;a href=&quot;#copyDir&quot;&gt;copyDir ()&lt;/a&gt; и &lt;a href=&quot;#copyFileWithPermissions&quot;&gt;copyFileWithPermissions ()&lt;/a&gt; на платформах, отличных от Windows. В Windows этот процесс является просто оболочкой для &lt;a href=&quot;#copyDir&quot;&gt;copyDir (),&lt;/a&gt; поскольку этот процесс уже копирует атрибуты.</target>
        </trans-unit>
        <trans-unit id="c9a699519eb4bcfd6e9b388099f313da1c21a6c3" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;from ... import&lt;/code&gt;, the result is different, too.</source>
          <target state="translated">Если мы используем &lt;code&gt;from ... import&lt;/code&gt; , результат тоже будет другим.</target>
        </trans-unit>
        <trans-unit id="6d41cc53a37945c747c32e0bc6d03f91d352c9cd" translate="yes" xml:space="preserve">
          <source>If you are using simple standard types like &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt; for the keys of the table you won't have any problems, but as soon as you try to use a more complex object as a key you will be greeted by a strange compiler error:</source>
          <target state="translated">Если вы используете простые стандартные типы, такие как &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;string&lt;/code&gt; для ключей таблицы, у вас не возникнет никаких проблем, но как только вы попытаетесь использовать более сложный объект в качестве ключа, вас встретит странная ошибка компилятора:</target>
        </trans-unit>
        <trans-unit id="a61618067feb2692a61a1309fe70a37f092e0dcd" translate="yes" xml:space="preserve">
          <source>If you don't want to run all the test case files you can pass any substring as a parameter to &lt;code&gt;caasdriver&lt;/code&gt;. Only files matching the passed substring will be run. The filtering doesn't use any globbing metacharacters, it's a plain match. For example, to run only &lt;code&gt;*-compile*.txt&lt;/code&gt; tests in verbose mode:</source>
          <target state="translated">Если вы не хотите запускать все файлы тестовых примеров, вы можете передать любую подстроку в качестве параметра в &lt;code&gt;caasdriver&lt;/code&gt; . Будут запущены только файлы, соответствующие переданной подстроке. При фильтрации не используются метасимволы подстановки, это простое совпадение. Например, чтобы запустить в подробном режиме только &lt;code&gt;*-compile*.txt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3b65c5702c4312fa92bc7a7a75f7b1cedc2ffdcc" translate="yes" xml:space="preserve">
          <source>If you hyper link a plain name symbol and there are other matches on the same HTML file, most browsers will go to the first one. To differentiate the rest, you will need to use the complex name. A complex name for a callable type is made up from several parts:</source>
          <target state="translated">Если Вы гиперссылка на символ простого имени,а в том же HTML-файле есть и другие совпадения,большинство браузеров перейдут к первому.Чтобы отличить остальные,необходимо использовать сложное имя.Сложное имя для вызываемого типа состоит из нескольких частей:</target>
        </trans-unit>
        <trans-unit id="d77f4e6941e6c25de4bc7bce05e47c82dde3f100" translate="yes" xml:space="preserve">
          <source>If you know what you're doing, you can also mark single string (or sequence) objects as &lt;span id=&quot;shallow_1&quot;&gt;shallow&lt;/span&gt;:</source>
          <target state="translated">Если вы знаете, что делаете, вы также можете пометить объекты с одной строкой (или последовательностью) как &lt;span id=&quot;shallow_1&quot;&gt;мелкие&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="5c5621699cffb5f6aa7c0cfe6aad046283804e80" translate="yes" xml:space="preserve">
          <source>If you need a asynchronous server socket but you wish to process the clients synchronously then you can use the &lt;code&gt;getSocket&lt;/code&gt; converter to get a &lt;code&gt;Socket&lt;/code&gt; from the &lt;code&gt;AsyncSocket&lt;/code&gt; object, this can then be combined with &lt;code&gt;accept&lt;/code&gt; like so:</source>
          <target state="translated">Если вам нужен асинхронный серверный сокет, но вы хотите синхронно обрабатывать клиентов, вы можете использовать конвертер &lt;code&gt;getSocket&lt;/code&gt; для получения &lt;code&gt;Socket&lt;/code&gt; из объекта &lt;code&gt;AsyncSocket&lt;/code&gt; , затем это можно объединить с &lt;code&gt;accept&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="006ed832ed732b3be5a2f86089a58493d5e5cace" translate="yes" xml:space="preserve">
          <source>If you need a sequence with the keys you can use &lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq()&lt;/a&gt; on the iterator. Usage example:</source>
          <target state="translated">Если вам нужна последовательность с ключами, вы можете использовать &lt;a href=&quot;sequtils#toSeq&quot;&gt;sequtils.toSeq ()&lt;/a&gt; на итераторе. Пример использования:</target>
        </trans-unit>
        <trans-unit id="33cbb4e4f9774399c5110d17e6f93b09e6789def" translate="yes" xml:space="preserve">
          <source>If you need to &lt;em&gt;access&lt;/em&gt; the actual exception object or message inside an &lt;code&gt;except&lt;/code&gt; branch you can use the &lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException()&lt;/a&gt; and &lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg()&lt;/a&gt; procs from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Example:</source>
          <target state="translated">Если вам нужно получить &lt;em&gt;доступ&lt;/em&gt; к фактическому объекту исключения или сообщению внутри ветви &lt;code&gt;except&lt;/code&gt; , вы можете использовать процедуры &lt;a href=&quot;system#getCurrentException&quot;&gt;getCurrentException ()&lt;/a&gt; и &lt;a href=&quot;system#getCurrentExceptionMsg&quot;&gt;getCurrentExceptionMsg ()&lt;/a&gt; из &lt;a href=&quot;system&quot;&gt;системного&lt;/a&gt; модуля. Пример:</target>
        </trans-unit>
        <trans-unit id="369d846e4c1b566404807c8b598a810efa4157ad" translate="yes" xml:space="preserve">
          <source>If you need to allow the rst &lt;code&gt;include&lt;/code&gt; directive or tweak the generated output you have to create your own &lt;code&gt;RstGenerator&lt;/code&gt; with &lt;code&gt;initRstGenerator&lt;/code&gt; and related procs.</source>
          <target state="translated">Если вам нужно разрешить первую директиву &lt;code&gt;include&lt;/code&gt; или настроить сгенерированный вывод, вы должны создать свой собственный &lt;code&gt;RstGenerator&lt;/code&gt; с помощью &lt;code&gt;initRstGenerator&lt;/code&gt; и связанных процедур.</target>
        </trans-unit>
        <trans-unit id="6e0f3b7f2a6e094f5e44833f3b6b6ef4c156c0ee" translate="yes" xml:space="preserve">
          <source>If you need to create multiple identifiers you need to use the lower level &lt;code&gt;newNimNode&lt;/code&gt;:</source>
          <target state="translated">Если вам нужно создать несколько идентификаторов, вам нужно использовать &lt;code&gt;newNimNode&lt;/code&gt; более низкого уровня :</target>
        </trans-unit>
        <trans-unit id="d0579aebab140b65d01d9ce28fdabf2191699ecf" translate="yes" xml:space="preserve">
          <source>If you need to pass around memory allocated by Nim to C, you can use the procs &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; to mark objects as referenced to avoid them being freed by the GC. Other useful procs from &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; you can use to keep track of memory are:</source>
          <target state="translated">Если вам нужно передать память, выделенную Nim, C, вы можете использовать &lt;code&gt;GC_ref&lt;/code&gt; и &lt;code&gt;GC_unref&lt;/code&gt; , чтобы пометить объекты как указанные, чтобы избежать их освобождения GC. Другие полезные процедуры из &lt;a href=&quot;system&quot;&gt;системы, которые&lt;/a&gt; вы можете использовать для отслеживания памяти:</target>
        </trans-unit>
        <trans-unit id="605d3be2a51e005f46c2c854f15f5f73980b42f0" translate="yes" xml:space="preserve">
          <source>If you use Nim's flexible calling syntax (as in &lt;code&gt;x.len()&lt;/code&gt;), the result is the same as above but wrapped in an &lt;code&gt;nnkCall&lt;/code&gt;.</source>
          <target state="translated">Если вы используете гибкий синтаксис вызова Nim (как в &lt;code&gt;x.len()&lt;/code&gt; ), результат будет таким же, как и выше, но заключен в &lt;code&gt;nnkCall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaabbf0881b8169255900fc2e0a496ccef7b23be" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.recv() or asyncdispatch.accept(), because they are using IOCP, please use nativesockets.recv() and nativesockets.accept() instead.</source>
          <target state="translated">Если вы используете эту функцию,вам не нужно использовать asyncdispatch.recv()или asyncdispatch.accept(),потому что они используют IOCP,пожалуйста,используйте вместо этого nativesockets.recv()и nativesockets.accept().</target>
        </trans-unit>
        <trans-unit id="1badf00dcf0f3800f03821ebc8ea8986cacd6adb" translate="yes" xml:space="preserve">
          <source>If you use this function, you don't need to use asyncdispatch.send() or asyncdispatch.connect(), because they are using IOCP, please use nativesockets.send() and nativesockets.connect() instead.</source>
          <target state="translated">Если вы используете эту функцию,вам не нужно использовать asyncdispatch.send()или asyncdispatch.connect(),потому что они используют IOCP,пожалуйста,используйте вместо этого nativesockets.send()и nativesockets.connect().</target>
        </trans-unit>
        <trans-unit id="cac223c9791d80e68510ee018f308f5d57991c7e" translate="yes" xml:space="preserve">
          <source>If you want to add the &lt;code&gt;{.raises.}&lt;/code&gt; pragma to existing code, the compiler can also help you. You can add the &lt;code&gt;{.effects.}&lt;/code&gt; pragma statement to your proc and the compiler will output all inferred effects up to that point (exception tracking is part of Nim's effect system). Another more roundabout way to find out the list of exceptions raised by a proc is to use the Nim &lt;code&gt;doc2&lt;/code&gt; command which generates documentation for a whole module and decorates all procs with the list of raised exceptions. You can read more about Nim's &lt;a href=&quot;manual#effect-system&quot;&gt;effect system and related pragmas in the manual&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите добавить прагму &lt;code&gt;{.raises.}&lt;/code&gt; К существующему коду, компилятор также может вам помочь. Вы можете добавить &lt;code&gt;{.effects.}&lt;/code&gt; вашу процедуру, и компилятор выведет все предполагаемые эффекты до этого момента (отслеживание исключений является частью системы эффектов Nim). Другой более окольный способ узнать список исключений, созданных процедурой, - использовать команду Nim &lt;code&gt;doc2&lt;/code&gt; , которая генерирует документацию для всего модуля и украшает все процедуры списком возникших исключений. Вы можете узнать больше о системе &lt;a href=&quot;manual#effect-system&quot;&gt;эффектов&lt;/a&gt; Nim и связанных с ней прагмах в руководстве .</target>
        </trans-unit>
        <trans-unit id="d0c0f4c00b1012d51fb6739c3f68752cf2b7b509" translate="yes" xml:space="preserve">
          <source>If you want to implement hash procs for your custom types you will end up writing the following kind of skeleton of code:</source>
          <target state="translated">Если вы хотите реализовать хэш-проксы для ваших пользовательских типов,то в конечном итоге вы напишете скелет следующего вида кода:</target>
        </trans-unit>
        <trans-unit id="421d4b3269fa42e83ec4575e39cc5f8f9348120c" translate="yes" xml:space="preserve">
          <source>If you want to reset the state of a global variable on each reload, just re-assign a value anywhere within the top-level code:</source>
          <target state="translated">Если вы хотите сбрасывать состояние глобальной переменной при каждой перезагрузке,просто переназначьте значение в любом месте кода верхнего уровня:</target>
        </trans-unit>
        <trans-unit id="95147b50335541913ec2b4cdcd60beea22400d5c" translate="yes" xml:space="preserve">
          <source>If you want to reuse this feature in your own documentation you will have to modify &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; to contain a &lt;code&gt;doc.item.seesrc&lt;/code&gt; value with a hyper link to your own code repository. As you will see by the comments in that file, the value &lt;code&gt;txt&lt;/code&gt; passed on the command line will be used in the HTML template along others like &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$line&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите повторно использовать эту функцию в своей документации, вам придется изменить &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; , чтобы он содержал значение &lt;code&gt;doc.item.seesrc&lt;/code&gt; с гиперссылкой на ваш собственный репозиторий кода. Как вы увидите из комментариев в этом файле, значение &lt;code&gt;txt&lt;/code&gt; , переданное в командной строке, будет использоваться в шаблоне HTML наряду с другими, такими как &lt;code&gt;$path&lt;/code&gt; и &lt;code&gt;$line&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52843b664ac77e24f197735860350aeff2499277" translate="yes" xml:space="preserve">
          <source>If you want to start the server using stdin/stdout as communication you need to type:</source>
          <target state="translated">Если вы хотите запустить сервер,используя stdin/stdout в качестве средства связи,вам необходимо набрать код:</target>
        </trans-unit>
        <trans-unit id="5faec14ac2e7f3a0dbf5ac1fc6670f916e429298" translate="yes" xml:space="preserve">
          <source>If you want to start the server using tcp and a port, you need to type:</source>
          <target state="translated">Если вы хотите запустить сервер с помощью tcp и порта,вам нужно набрать:</target>
        </trans-unit>
        <trans-unit id="0e57ef06f554ec131431cf7cc7b3e87b3087eb9a" translate="yes" xml:space="preserve">
          <source>If you would like to remove the callback simply set it to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите удалить обратный вызов, просто установите для него значение &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af0996b6e01e303c65f963b0e8fbe7eeea90dc53" translate="yes" xml:space="preserve">
          <source>If your custom types contain fields for which there already is a hash proc, like for example objects made up of &lt;code&gt;strings&lt;/code&gt;, you can simply hash together the hash value of the individual fields:</source>
          <target state="translated">Если ваши настраиваемые типы содержат поля, для которых уже существует хэш-процедура, например, объекты, состоящие из &lt;code&gt;strings&lt;/code&gt; , вы можете просто хешировать хеш-значения отдельных полей:</target>
        </trans-unit>
        <trans-unit id="ee7d8473b3b03509d036a9e18c0f69477806dbbf" translate="yes" xml:space="preserve">
          <source>Ignoring the return value of a procedure without using a discard statement is a static error.</source>
          <target state="translated">Игнорирование возвращаемого значения процедуры без использования оператора сброса является статической ошибкой.</target>
        </trans-unit>
        <trans-unit id="234aba6f014c3210479a86e1f7e85db4fc781aa3" translate="yes" xml:space="preserve">
          <source>Implementation Specific Pragmas</source>
          <target state="translated">Реализация Конкретные прагмы</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="e4c1e2458dab48a54a1e7f70dcc8c85f1ecef51b" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;span id=&quot;deque_1&quot;&gt;deque&lt;/span&gt; (double-ended queue). The underlying implementation uses a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">Реализация &lt;span id=&quot;deque_1&quot;&gt;двусторонней очереди&lt;/span&gt; (Двухконтактные очереди). Базовая реализация использует &lt;code&gt;seq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7a46b17c56770ce055c6ddb62375ac14462a9c" translate="yes" xml:space="preserve">
          <source>Implementation of singly and doubly linked lists. Because it makes no sense to do so, the 'next' and 'prev' pointers are not hidden from you and can be manipulated directly for efficiency.</source>
          <target state="translated">Внедрение единичных и двойных связанных списков.Так как это не имеет смысла,то указатели &quot;следующий&quot; и &quot;prev&quot; не скрыты от вас и могут манипулироваться непосредственно для повышения эффективности.</target>
        </trans-unit>
        <trans-unit id="a6c736db4db506401e673a9f4f1f349ad3e618b7" translate="yes" xml:space="preserve">
          <source>Implements Nim's 'spawn'.</source>
          <target state="translated">Использует &quot;икру&quot; Нима.</target>
        </trans-unit>
        <trans-unit id="36d95a1a4e4b67185b0210fb79bcd67e7997dd49" translate="yes" xml:space="preserve">
          <source>Implict items/pairs invocations</source>
          <target state="translated">Вызовы на элементы/пары изображения</target>
        </trans-unit>
        <trans-unit id="3ed691724b16d193322f0f4e5a05ffaa21ad149b" translate="yes" xml:space="preserve">
          <source>Import section</source>
          <target state="translated">раздел импорта</target>
        </trans-unit>
        <trans-unit id="e1814134be9eb4b4edfac453d80420ef792ece15" translate="yes" xml:space="preserve">
          <source>Import statement</source>
          <target state="translated">импортная декларация</target>
        </trans-unit>
        <trans-unit id="13f50b27b1067e54a93395faae2bf7e5ac61b5af" translate="yes" xml:space="preserve">
          <source>ImportCpp pragma</source>
          <target state="translated">импортная прагма</target>
        </trans-unit>
        <trans-unit id="1a87c0305fa3a21d3483f32794feeb2ede2ded57" translate="yes" xml:space="preserve">
          <source>ImportObjC pragma</source>
          <target state="translated">ImportObjC прагма</target>
        </trans-unit>
        <trans-unit id="b131713cc5dd52d93c263e9eaa3064820c90d46d" translate="yes" xml:space="preserve">
          <source>Importc pragma</source>
          <target state="translated">импортная прагма</target>
        </trans-unit>
        <trans-unit id="26fce7795dc194794340bfe9430c05967fd0f0b6" translate="yes" xml:space="preserve">
          <source>Importcpp for enums</source>
          <target state="translated">импорт для перечислений</target>
        </trans-unit>
        <trans-unit id="13bc024961b54b45de0538df5d4d8a1057ce09e2" translate="yes" xml:space="preserve">
          <source>Importcpp for objects</source>
          <target state="translated">Импорт для объектов</target>
        </trans-unit>
        <trans-unit id="c0f89463b661b1c831d73789e1f9b7febf176bb2" translate="yes" xml:space="preserve">
          <source>Importcpp for procs</source>
          <target state="translated">Импорт для проката</target>
        </trans-unit>
        <trans-unit id="2a87ed2bec73f0f4c4783390b3b8eb37f3539383" translate="yes" xml:space="preserve">
          <source>Imported exceptions</source>
          <target state="translated">импортируемые исключения</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="651038eb78adfd6971475066b4835457bc4c8cee" translate="yes" xml:space="preserve">
          <source>Imports a node from another document to this document</source>
          <target state="translated">Импортирует узел из другого документа в этот документ.</target>
        </trans-unit>
        <trans-unit id="c57c28d05a963f62cc6e0646415b874f5ec5d460" translate="yes" xml:space="preserve">
          <source>Impure libraries</source>
          <target state="translated">Беспорядочные библиотеки</target>
        </trans-unit>
        <trans-unit id="fd75085c09d97b8e3bec53c3d230c26383e2dd2b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;if&lt;/code&gt; statements new scopes begin immediately after the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; keywords and ends after the corresponding &lt;em&gt;then&lt;/em&gt; block. For visualization purposes the scopes have been enclosed in &lt;code&gt;{| |}&lt;/code&gt; in the following example:</source>
          <target state="translated">В операторах &lt;code&gt;if&lt;/code&gt; новые области действия начинаются сразу после ключевых слов &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; и заканчиваются после соответствующего блока &lt;em&gt;then&lt;/em&gt; . Для наглядности области видимости заключены в &lt;code&gt;{| |}&lt;/code&gt; в следующем примере:</target>
        </trans-unit>
        <trans-unit id="f8b317a37aea00acb6907f904d75b22bdcc1d94d" translate="yes" xml:space="preserve">
          <source>In Nim exceptions are objects. By convention, exception types are suffixed with 'Error'. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module defines an exception hierarchy that you might want to stick to. Exceptions derive from &lt;code&gt;system.Exception&lt;/code&gt;, which provides the common interface.</source>
          <target state="translated">В Ниме исключения - это объекты. По соглашению к типам исключений добавляется суффикс &amp;laquo;Ошибка&amp;raquo;. &lt;a href=&quot;system&quot;&gt;Система&lt;/a&gt; модуль определяет иерархию исключений , которые вы могли бы хотеть придерживаться. Исключения являются производными от &lt;code&gt;system.Exception&lt;/code&gt; , который предоставляет общий интерфейс.</target>
        </trans-unit>
        <trans-unit id="bcd1f399e06fb598711f24d731eec160a7ac7612" translate="yes" xml:space="preserve">
          <source>In Nim new types can be defined within a &lt;code&gt;type&lt;/code&gt; statement:</source>
          <target state="translated">В Nim новые типы можно определять с помощью оператора &lt;code&gt;type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b627b4840bb1e194f3e870e54e41a26eeaaa32b6" translate="yes" xml:space="preserve">
          <source>In Nim the compiler cannot always know if a reference is stored on the stack or not. This is caused by var parameters. Consider this example:</source>
          <target state="translated">В Nim компилятор не всегда может знать,хранится ли ссылка в стеке или нет.Это вызвано параметрами var.Рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="3c1e31b69bdf6fd850da3e70033d8d8c55e35892" translate="yes" xml:space="preserve">
          <source>In Nim there is a distinction between &lt;em&gt;simple statements&lt;/em&gt; and &lt;em&gt;complex statements&lt;/em&gt;. &lt;em&gt;Simple statements&lt;/em&gt; cannot contain other statements: Assignment, procedure calls or the &lt;code&gt;return&lt;/code&gt; statement belong to the simple statements. &lt;em&gt;Complex statements&lt;/em&gt; like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; can contain other statements. To avoid ambiguities, complex statements must always be indented, but single simple statements do not:</source>
          <target state="translated">В Nim есть различие между &lt;em&gt;простыми&lt;/em&gt; и &lt;em&gt;сложными операторами&lt;/em&gt; . &lt;em&gt;Простые операторы&lt;/em&gt; не могут содержать другие операторы: присваивание, вызов процедур или оператор &lt;code&gt;return&lt;/code&gt; относятся к простым операторам. &lt;em&gt;Сложные операторы,&lt;/em&gt; такие как &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , могут содержать другие операторы. Чтобы избежать двусмысленности, сложные операторы всегда должны иметь отступ, а отдельные простые операторы - нет:</target>
        </trans-unit>
        <trans-unit id="36d31e1fe2a898ddbcb325dce9d25ddd964de3ec" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values greater than 128 never match &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, or &lt;code&gt;\w&lt;/code&gt;, and always match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. This is true even when Unicode character property support is available.</source>
          <target state="translated">В режиме UTF-8, символы со значениями больше 128 никогда не совпадают &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , или &lt;code&gt;\w&lt;/code&gt; , и всегда совпадают &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , и &lt;code&gt;\W&lt;/code&gt; . Это верно, даже если доступна поддержка свойств символов Юникода.</target>
        </trans-unit>
        <trans-unit id="3617947965a09e75ebe2e8b672a9f2c8fd3657b4" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; statement tuple unpacking can be performed. The special identifier &lt;code&gt;_&lt;/code&gt; can be used to ignore some parts of the tuple:</source>
          <target state="translated">В операторе &lt;code&gt;var&lt;/code&gt; или &lt;code&gt;let&lt;/code&gt; можно выполнить распаковку кортежа. Специальный идентификатор &lt;code&gt;_&lt;/code&gt; может использоваться для игнорирования некоторых частей кортежа:</target>
        </trans-unit>
        <trans-unit id="82817ac3f312f0760fba2fa577dfeca03d6206c4" translate="yes" xml:space="preserve">
          <source>In a call &lt;code&gt;p(args)&lt;/code&gt; the routine &lt;code&gt;p&lt;/code&gt; that matches best is selected. If multiple routines match equally well, the ambiguity is reported at compiletime.</source>
          <target state="translated">При вызове &lt;code&gt;p(args)&lt;/code&gt; выбирается наиболее подходящая процедура &lt;code&gt;p&lt;/code&gt; . Если несколько подпрограмм совпадают одинаково, о неоднозначности сообщается во время компиляции.</target>
        </trans-unit>
        <trans-unit id="6fc62f480a3f9078cee56fe51f6444a9d5250214" translate="yes" xml:space="preserve">
          <source>In a list of statements every expression except the last one needs to have the type &lt;code&gt;void&lt;/code&gt;. In addition to this rule an assignment to the builtin &lt;code&gt;result&lt;/code&gt; symbol also triggers a mandatory &lt;code&gt;void&lt;/code&gt; context for the subsequent expressions:</source>
          <target state="translated">В списке операторов каждое выражение, кроме последнего, должно иметь тип &lt;code&gt;void&lt;/code&gt; . В дополнение к этому правилу присвоение встроенному символу &lt;code&gt;result&lt;/code&gt; также запускает обязательный &lt;code&gt;void&lt;/code&gt; контекст для последующих выражений:</target>
        </trans-unit>
        <trans-unit id="488140be7cd1e3d7c93b424038a2aded23329152" translate="yes" xml:space="preserve">
          <source>In a multi-method all parameters that have an object type are used for the dispatching:</source>
          <target state="translated">В многометодном режиме для диспетчеризации используются все параметры,имеющие тип объекта:</target>
        </trans-unit>
        <trans-unit id="51b365021e4df4ac8585444b431ae5bb9f1b96ec" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;GC_ref&lt;/code&gt; and &lt;code&gt;GC_unref&lt;/code&gt; you can avoid the GC by manually allocating memory with procs like &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;allocShared&lt;/code&gt;, or &lt;code&gt;allocCStringArray&lt;/code&gt;. The GC won't try to free them, you need to call their respective &lt;em&gt;dealloc&lt;/em&gt; pairs when you are done with them or they will leak.</source>
          <target state="translated">В дополнении к &lt;code&gt;GC_ref&lt;/code&gt; и &lt;code&gt;GC_unref&lt;/code&gt; вы можете избежать GC вручную распределения памяти с проками как &lt;code&gt;alloc&lt;/code&gt; , &lt;code&gt;allocShared&lt;/code&gt; или &lt;code&gt;allocCStringArray&lt;/code&gt; . GC не будет пытаться освободить их, вам нужно вызвать их соответствующие &lt;em&gt;dealloc&lt;/em&gt; пары , когда вы сделали с ними , или они будут протекать.</target>
        </trans-unit>
        <trans-unit id="590bed6910696c3c90f97fbde2ce87692b87d870" translate="yes" xml:space="preserve">
          <source>In addition to fields, routine applications are also rewritten, but only if no other interpretation of the call is possible:</source>
          <target state="translated">Помимо полей,переписываются и рутинные приложения,но только в том случае,если другая интерпретация вызова невозможна:</target>
        </trans-unit>
        <trans-unit id="3c1eb48be581c9adefbce7b80eb339a9d4bdac6f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;untyped&lt;/code&gt; meta-type that prevents type checking there is also &lt;code&gt;varargs[untyped]&lt;/code&gt; so that not even the number of parameters is fixed:</source>
          <target state="translated">В дополнение к &lt;code&gt;untyped&lt;/code&gt; мета-типу, который предотвращает проверку типов, существует также &lt;code&gt;varargs[untyped]&lt;/code&gt; так что даже количество параметров не фиксируется:</target>
        </trans-unit>
        <trans-unit id="387616e73907f1f0c0f9c9b26be0a31bf6568eb0" translate="yes" xml:space="preserve">
          <source>In addition to the previous levels dumps a debug stack trace for compiler developers.</source>
          <target state="translated">В дополнение к предыдущим уровням дампы отладочного стека для разработчиков компиляторов.</target>
        </trans-unit>
        <trans-unit id="fa62a58dee28a4f60ea67a6c8e5a270a2279ae13" translate="yes" xml:space="preserve">
          <source>In addition to the usual arithmetic operators for signed and unsigned integers (&lt;code&gt;+ - *&lt;/code&gt; etc.) there are also operators that formally work on &lt;em&gt;signed&lt;/em&gt; integers but treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;: They are mostly provided for backwards compatibility with older versions of the language that lacked unsigned integer types. These unsigned operations for signed integers use the &lt;code&gt;%&lt;/code&gt; suffix as convention:</source>
          <target state="translated">В дополнении к обычным арифметическим операторам для подписанных и неподписанных чисел ( &lt;code&gt;+ - *&lt;/code&gt; и т.д.) есть также операторы , которые формально работают на &lt;em&gt;подписанных&lt;/em&gt; целыхах , но рассматривать их аргументы как &lt;em&gt;беззнаковые&lt;/em&gt; : Они в основном предназначены для обеспечения обратной совместимости с более старыми версиями языка , что не хватало беззнаковых целочисленных типов. Эти беззнаковые операции для целых чисел со знаком используют суффикс &lt;code&gt;%&lt;/code&gt; как соглашение:</target>
        </trans-unit>
        <trans-unit id="a505d4cbc395f14732ae7d9715a2d71dbaa23d6d" translate="yes" xml:space="preserve">
          <source>In all descendant types of the object type.</source>
          <target state="translated">Во всех типах объектов-потомках.</target>
        </trans-unit>
        <trans-unit id="8255fdf45779c837c0b26b5faea383860b8d458a" translate="yes" xml:space="preserve">
          <source>In both cases the server will start up and await further commands. The syntax of the commands you can now send to the server is practically the same as running the nim compiler on the commandline, you only need to remove the name of the compiler since you are already talking to it. The server will answer with as many lines of text it thinks necessary plus an empty line to indicate the end of the answer.</source>
          <target state="translated">В обоих случаях сервер запустится и будет ожидать дальнейших команд.Синтаксис команд,которые Вы теперь можете посылать на сервер,практически такой же,как и при запуске компилятора nim в командной строке,Вам нужно только удалить имя компилятора,так как Вы уже говорите с ним.Сервер ответит столько строк текста,сколько считает необходимым,плюс пустая строка,указывающая на конец ответа.</target>
        </trans-unit>
        <trans-unit id="87fcb4c9412aaaad5556b10d061891f17209ecf3" translate="yes" xml:space="preserve">
          <source>In contrast to that, a &lt;span id=&quot;closure-iterator_1&quot;&gt;closure iterator&lt;/span&gt; can be passed around more freely:</source>
          <target state="translated">В отличие от этого, &lt;span id=&quot;closure-iterator_1&quot;&gt;итератор закрытия&lt;/span&gt; можно передавать более свободно:</target>
        </trans-unit>
        <trans-unit id="d690804e9c35517f69d4546186980d7be8f2789c" translate="yes" xml:space="preserve">
          <source>In debug mode exceptions store the stack trace that led to them. A StackTraceEntry is a single entry of the stack trace.</source>
          <target state="translated">В отладочном режиме исключения хранят трассу стека,которая привела к ним.StackTraceEntry-это одиночный вход трассы стека.</target>
        </trans-unit>
        <trans-unit id="af9ba250b7498b9006c490eda9c8a41290e0b66a" translate="yes" xml:space="preserve">
          <source>In every module compilation, reset the variable to its default value.</source>
          <target state="translated">При каждой модульной компиляции необходимо сбрасывать переменную на ее значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b9d14a65a6bcb84eea05fa7cf43ef339b198f107" translate="yes" xml:space="preserve">
          <source>In fact, a trailing comma is allowed for every tuple construction.</source>
          <target state="translated">На самом деле,для каждой конструкции кортежа допускается использование трейлинговой запятой.</target>
        </trans-unit>
        <trans-unit id="d9e80bc5993cb0fc4644c16fb07461ebb339b897" translate="yes" xml:space="preserve">
          <source>In fact, this decribes how the AST should be stored in the database, as a &quot;shallow&quot; tree. Let's assume we compile module &lt;code&gt;m&lt;/code&gt; with the following contents:</source>
          <target state="translated">Фактически, это описывает, как AST должен храниться в базе данных в виде &amp;laquo;мелкого&amp;raquo; дерева. Предположим, мы компилируем модуль &lt;code&gt;m&lt;/code&gt; со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="d7200c67cd9ab4646acaefd95fd28854405ad659" translate="yes" xml:space="preserve">
          <source>In general the case statement is used for subrange types or enumerations where it is of great help that the compiler checks that you covered any possible value.</source>
          <target state="translated">В общем случае оператор используется для поддиапазонных типов или перечислений,где компилятору очень помогает проверка того,что вы покрыли любое возможное значение.</target>
        </trans-unit>
        <trans-unit id="df2250e080bf643576540d132cb54644051a2eb3" translate="yes" xml:space="preserve">
          <source>In general, declaring types mirrors this syntax (i.e., &lt;code&gt;nnkStaticTy&lt;/code&gt; for &lt;code&gt;static&lt;/code&gt;, etc.). Examples follow (exceptions marked by &lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">В общем, объявление типов отражает этот синтаксис (например, &lt;code&gt;nnkStaticTy&lt;/code&gt; для &lt;code&gt;static&lt;/code&gt; и т. Д.). Ниже приведены примеры (исключения отмечены &lt;code&gt;*&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="1393a34bf1d4daea288238586a51eb0e1faccf00" translate="yes" xml:space="preserve">
          <source>In general, importing a dynamic library does not require any special linker options or linking with import libraries. This also implies that no &lt;em&gt;devel&lt;/em&gt; packages need to be installed.</source>
          <target state="translated">В общем, импорт динамической библиотеки не требует каких-либо специальных параметров компоновщика или связывания с библиотеками импорта. Это также означает , что никакие &lt;em&gt;Devel&lt;/em&gt; пакеты не должны быть установлены.</target>
        </trans-unit>
        <trans-unit id="0d0713666c6f10149634654fda5f08d4b39e3997" translate="yes" xml:space="preserve">
          <source>In highly specific cases (a dispatch loop of a bytecode interpreter for example) it may provide benefits, though.</source>
          <target state="translated">В весьма специфических случаях (например,в случае диспетчерского цикла байткод-интерпретатора)это может дать преимущества.</target>
        </trans-unit>
        <trans-unit id="ccadb2f2afa462fe0a8e3a89f264df971c7a74b0" translate="yes" xml:space="preserve">
          <source>In many contexts, Nim allows you to treat the names of types as regular values. These values exists only during the compilation phase, but since all values must have a type, &lt;code&gt;type&lt;/code&gt; is considered their special type.</source>
          <target state="translated">Во многих случаях Nim позволяет вам обрабатывать имена типов как обычные значения. Эти значения существуют только на этапе компиляции, но поскольку все значения должны иметь тип, &lt;code&gt;type&lt;/code&gt; считается их особым типом.</target>
        </trans-unit>
        <trans-unit id="92effa90645c39523ba9f53c9bfe7bc808f9c10d" translate="yes" xml:space="preserve">
          <source>In normal debug and release builds code within a &lt;code&gt;runnableExamples&lt;/code&gt; section is ignored.</source>
          <target state="translated">В обычных сборках отладки и выпуска код в разделе &lt;code&gt;runnableExamples&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="0fce6426da4fa8e50461c5a84f0b4bb26d70a6f7" translate="yes" xml:space="preserve">
          <source>In order to begin any sort of transfer of files you must first connect to an FTP server. You can do so with the &lt;code&gt;connect&lt;/code&gt; procedure.</source>
          <target state="translated">Чтобы начать передачу файлов, вы должны сначала подключиться к FTP-серверу. Вы можете сделать это с помощью процедуры &lt;code&gt;connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0b84c550d9a8232bb0005f5c64c0b247f3554dd" translate="yes" xml:space="preserve">
          <source>In order to check for symbols accepting &lt;code&gt;type&lt;/code&gt; params, you must prefix the type with the explicit &lt;code&gt;type&lt;/code&gt; modifier. The named instance of the type, following the &lt;code&gt;concept&lt;/code&gt; keyword is also considered to have the explicit modifier and will be matched only as a type.</source>
          <target state="translated">Чтобы проверить наличие символов, принимающих параметры &lt;code&gt;type&lt;/code&gt; , вы должны указать перед типом явный модификатор &lt;code&gt;type&lt;/code&gt; . Именованный экземпляр типа, следующий за ключевым словом &lt;code&gt;concept&lt;/code&gt; , также считается имеющим явный модификатор и будет сопоставлен только как тип.</target>
        </trans-unit>
        <trans-unit id="ea6a479b9d25899b927b071796e99387ee4ff9e8" translate="yes" xml:space="preserve">
          <source>In order to compile Nim correctly, type-checking has to be separated from parsing. Otherwise generics cannot work.</source>
          <target state="translated">Чтобы правильно скомпилировать Nim,проверка типов должна быть отделена от парсинга.В противном случае генераторы не смогут работать.</target>
        </trans-unit>
        <trans-unit id="f3802bfad258aac8c84f9a57c30500e4a9483a31" translate="yes" xml:space="preserve">
          <source>In order to encode some text simply call the &lt;code&gt;encode&lt;/code&gt; procedure:</source>
          <target state="translated">Чтобы закодировать текст, просто вызовите процедуру &lt;code&gt;encode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a773d5bee7ad3c817ebe19e70c4e28c0ee6b821" translate="yes" xml:space="preserve">
          <source>In order to simplify structural type checking, recursive tuples are not valid:</source>
          <target state="translated">Для упрощения проверки типа конструкции рекурсивные кортежи недействительны:</target>
        </trans-unit>
        <trans-unit id="312ff897ae89606cffe84af5ae7f281fbffba243" translate="yes" xml:space="preserve">
          <source>In order to use the SSL procedures defined in this module, you will need to compile your application with the &lt;code&gt;-d:ssl&lt;/code&gt; flag.</source>
          <target state="translated">Чтобы использовать процедуры SSL, определенные в этом модуле, вам нужно будет скомпилировать приложение с флагом &lt;code&gt;-d:ssl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="560248995a8c3109fbb872863af1490f690d2896" translate="yes" xml:space="preserve">
          <source>In ordinary object oriented languages, procedures (also called &lt;em&gt;methods&lt;/em&gt;) are bound to a class. This has disadvantages:</source>
          <target state="translated">В обычных объектно-ориентированных языках процедуры (также называемые &lt;em&gt;методами&lt;/em&gt; ) привязаны к классу. У этого есть недостатки:</target>
        </trans-unit>
        <trans-unit id="95f94a22baed9e59f27d8a4126864041ec912710" translate="yes" xml:space="preserve">
          <source>In other words, the lifetime of what &lt;code&gt;result&lt;/code&gt; points to is attached to the lifetime of the first parameter and that is enough knowledge to verify memory safety at the callsite.</source>
          <target state="translated">Другими словами, время жизни того, на что указывает &lt;code&gt;result&lt;/code&gt; , привязано к времени жизни первого параметра, и этого достаточно, чтобы проверить безопасность памяти на сайте вызова.</target>
        </trans-unit>
        <trans-unit id="102f6667e274b32df706ad020620d76cc4f12944" translate="yes" xml:space="preserve">
          <source>In other words, the macro needs to transform the full &lt;code&gt;case&lt;/code&gt; statement but only the statement's selector expression is used to determine which macro to call.</source>
          <target state="translated">Другими словами, макрос должен преобразовать полный оператор &lt;code&gt;case&lt;/code&gt; , но только выражение селектора оператора используется для определения того, какой макрос вызывать.</target>
        </trans-unit>
        <trans-unit id="f0ffdfd405410c78e024047ef7872e44df7c644e" translate="yes" xml:space="preserve">
          <source>In practice, things are worse still, consider &lt;code&gt;someGlobal[i][j].add arg&lt;/code&gt;. We only know the root is &lt;code&gt;someGlobal&lt;/code&gt; but the concrete path to the data is unknown as is the value that is added. We could compute a &quot;diff&quot; between the global states and use that to compute a symbol patchset, but this is quite some work, expensive to do at runtime (it would need to run after every module has been compiled) and also would break for hash tables.</source>
          <target state="translated">На практике дела обстоят еще хуже, рассмотрим &lt;code&gt;someGlobal[i][j].add arg&lt;/code&gt; . Мы знаем только, что корень &lt;code&gt;someGlobal&lt;/code&gt; , но конкретный путь к данным неизвестен, как и добавленное значение. Мы могли бы вычислить &quot;разницу&quot; между глобальными состояниями и использовать ее для вычисления набора патчей символов, но это довольно сложная работа, дорогостоящая во время выполнения (ее нужно будет запускать после компиляции каждого модуля), а также она прервется на хеш-таблицы.</target>
        </trans-unit>
        <trans-unit id="b855cc2f2c105e6dd103557865ed5b380e3a2628" translate="yes" xml:space="preserve">
          <source>In raw literals the backslash is not an escape character.</source>
          <target state="translated">Обратная косая черта не является спасательным символом.</target>
        </trans-unit>
        <trans-unit id="c7f10b9ab29ce16208f7daf440d19bf68a4e424e" translate="yes" xml:space="preserve">
          <source>In templates identifiers can be constructed with the backticks notation:</source>
          <target state="translated">В шаблонах могут быть построены идентификаторы с нотацией обратных ссылок:</target>
        </trans-unit>
        <trans-unit id="b2768586236fda36fbb8835c6640e3bbf9f72b7a" translate="yes" xml:space="preserve">
          <source>In the above example, because the string ends in a period, to get the portion of the string that is &quot;useless&quot; and replace it with &quot;useful&quot;.</source>
          <target state="translated">В приведенном выше примере,потому что строка заканчивается в периоде,чтобы получить &quot;бесполезную&quot; часть строки и заменить ее на &quot;полезную&quot;.</target>
        </trans-unit>
        <trans-unit id="1c735dfcff9ac999e211c2de3309c6b523627b0e" translate="yes" xml:space="preserve">
          <source>In the above example, providing the -d flag causes the symbol &lt;code&gt;FooBar&lt;/code&gt; to be overwritten at compile time, printing out 42. If the &lt;code&gt;-d:FooBar=42&lt;/code&gt; were to be omitted, the default value of 5 would be used.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;FooBar&lt;/code&gt; флага -d приводит к перезаписи символа FooBar во время компиляции с &lt;code&gt;-d:FooBar=42&lt;/code&gt; 42. Если опустить -d: FooBar = 42, будет использовано значение по умолчанию 5.</target>
        </trans-unit>
        <trans-unit id="6ef0c534b48c5ddbaf66e5a1fa0de3c409abe7be" translate="yes" xml:space="preserve">
          <source>In the above example, the &lt;code&gt;recv&lt;/code&gt; function will return a brand new &lt;code&gt;Future&lt;/code&gt; instance once the request for data to be read from the socket is made. This &lt;code&gt;Future&lt;/code&gt; instance will complete once the requested amount of data is read, in this case it is 100 bytes. The second line sets a callback on this future which will be called once the future completes. All the callback does is write the data stored in the future to &lt;code&gt;stdout&lt;/code&gt;. The &lt;code&gt;read&lt;/code&gt; function is used for this and it checks whether the future completes with an error for you (if it did it will simply raise the error), if there is no error however it returns the value of the future.</source>
          <target state="translated">В приведенном выше примере функция &lt;code&gt;recv&lt;/code&gt; вернет новый экземпляр &lt;code&gt;Future&lt;/code&gt; после того, как будет сделан запрос данных для чтения из сокета. Этот экземпляр &lt;code&gt;Future&lt;/code&gt; завершится после того, как будет прочитан запрошенный объем данных, в данном случае это 100 байт. Вторая строка устанавливает обратный вызов для этого future-объекта, который будет вызываться после его завершения. Все, что делает обратный вызов, это записывает данные, хранящиеся в будущем, в стандартный &lt;code&gt;stdout&lt;/code&gt; . Для этого используется функция &lt;code&gt;read&lt;/code&gt; которая проверяет, завершается ли будущее с ошибкой для вас (если это так, просто вызывает ошибку), если ошибки нет, но возвращает значение будущего.</target>
        </trans-unit>
        <trans-unit id="21c40f021cb3285301a10da6c518a7dfee56f66a" translate="yes" xml:space="preserve">
          <source>In the above example, the search loop is unrolled by a factor 4. The unroll factor can be left out too; the compiler then chooses an appropriate unroll factor.</source>
          <target state="translated">В приведенном выше примере цикл поиска разворачивается с коэффициентом 4.Коэффициент разворачивания также может быть пропущен;компилятор затем выбирает соответствующий коэффициент разворачивания.</target>
        </trans-unit>
        <trans-unit id="447fba0bf5092295ea3ef5df369d20395a2954e0" translate="yes" xml:space="preserve">
          <source>In the age of HTTP, HTML, FTP, TCP, IP, UTF, WWW it is foolish to pretend these are somewhat special words requiring all uppercase. Instead treat them as what they are: Real words. So it's &lt;code&gt;parseUrl&lt;/code&gt; rather than &lt;code&gt;parseURL&lt;/code&gt;, &lt;code&gt;checkHttpHeader&lt;/code&gt; instead of &lt;code&gt;checkHTTPHeader&lt;/code&gt; etc.</source>
          <target state="translated">В эпоху HTTP, HTML, FTP, TCP, IP, UTF, WWW глупо притворяться, что это какие-то особые слова, требующие только прописных букв. Вместо этого обращайтесь с ними как с настоящими словами. Так что это &lt;code&gt;parseUrl&lt;/code&gt; , а не &lt;code&gt;parseURL&lt;/code&gt; , &lt;code&gt;checkHttpHeader&lt;/code&gt; вместо &lt;code&gt;checkHTTPHeader&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="1aaaccd5328576322733f4b1a0d0cfc0189406e9" translate="yes" xml:space="preserve">
          <source>In the case of Nim's own documentation, the &lt;code&gt;txt&lt;/code&gt; value is just a commit hash to append to a formatted URL to &lt;a href=&quot;https://github.com/Araq/Nim&quot;&gt;https://github.com/Araq/Nim&lt;/a&gt;. The &lt;code&gt;tools/nimweb.nim&lt;/code&gt; helper queries the current git commit hash during doc generation, but since you might be working on an unpublished repository, it also allows specifying a &lt;code&gt;githash&lt;/code&gt; value in &lt;code&gt;web/website.ini&lt;/code&gt; to force a specific commit in the output.</source>
          <target state="translated">В случае с собственной документацией Nim значение &lt;code&gt;txt&lt;/code&gt; - это просто хеш фиксации, который нужно добавить к отформатированному URL-адресу &lt;a href=&quot;https://github.com/Araq/Nim&quot;&gt;https://github.com/Araq/Nim&lt;/a&gt; . &lt;code&gt;tools/nimweb.nim&lt;/code&gt; помощник запрашивает текущий мерзавец совершать хэш во время генерации дока, но так как вы могли бы работать на неопубликованном хранилище, он также позволяет указать &lt;code&gt;githash&lt;/code&gt; значение в &lt;code&gt;web/website.ini&lt;/code&gt; , чтобы заставить конкретный совершить на выходе.</target>
        </trans-unit>
        <trans-unit id="222b18bf0bb9eca48a64b5eb7ba691094c380acc" translate="yes" xml:space="preserve">
          <source>In the current implementation &lt;code&gt;FloatDivByZeroError&lt;/code&gt; and &lt;code&gt;FloatInexactError&lt;/code&gt; are never raised. &lt;code&gt;FloatOverflowError&lt;/code&gt; is raised instead of &lt;code&gt;FloatDivByZeroError&lt;/code&gt;. There is also a &lt;span id=&quot;floatchecks_1&quot;&gt;floatChecks&lt;/span&gt; pragma that is a short-cut for the combination of &lt;code&gt;nanChecks&lt;/code&gt; and &lt;code&gt;infChecks&lt;/code&gt; pragmas. &lt;code&gt;floatChecks&lt;/code&gt; are turned off as default.</source>
          <target state="translated">В текущей реализации &lt;code&gt;FloatDivByZeroError&lt;/code&gt; и &lt;code&gt;FloatInexactError&lt;/code&gt; никогда не возникают. &lt;code&gt;FloatOverflowError&lt;/code&gt; возникает вместо &lt;code&gt;FloatDivByZeroError&lt;/code&gt; . Существует также прагма &lt;span id=&quot;floatchecks_1&quot;&gt;floatChecks,&lt;/span&gt; которая является сокращением для комбинации &lt;code&gt;nanChecks&lt;/code&gt; и &lt;code&gt;infChecks&lt;/code&gt; . &lt;code&gt;floatChecks&lt;/code&gt; по умолчанию отключены.</target>
        </trans-unit>
        <trans-unit id="bff2144a51b7a2c294698601ad8d94335ce9f207" translate="yes" xml:space="preserve">
          <source>In the example &lt;code&gt;name&lt;/code&gt; is instantiated with &lt;code&gt;myint&lt;/code&gt;, so `T name` becomes &lt;code&gt;Tmyint&lt;/code&gt;.</source>
          <target state="translated">В примере &lt;code&gt;name&lt;/code&gt; &lt;code&gt;myint&lt;/code&gt; с помощью myint , поэтому T name становится &lt;code&gt;Tmyint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f3d915c7fda05ffa880f1a94fe575c45d57c7e6" translate="yes" xml:space="preserve">
          <source>In the example a new pragma named &lt;code&gt;rtl&lt;/code&gt; is introduced that either imports a symbol from a dynamic library or exports the symbol for dynamic library generation.</source>
          <target state="translated">В этом примере представлена ​​новая прагма с именем &lt;code&gt;rtl&lt;/code&gt; , которая либо импортирует символ из динамической библиотеки, либо экспортирует символ для создания динамической библиотеки.</target>
        </trans-unit>
        <trans-unit id="93f65483d248fc770a9b18bebde69fbd09a74d5c" translate="yes" xml:space="preserve">
          <source>In the example a tree structure is declared with the &lt;code&gt;Node&lt;/code&gt; type. Note that the type definition is recursive and the GC has to assume that objects of this type may form a cyclic graph. The &lt;code&gt;acyclic&lt;/code&gt; pragma passes the information that this cannot happen to the GC. If the programmer uses the &lt;code&gt;acyclic&lt;/code&gt; pragma for data types that are in reality cyclic, the GC may leak memory, but nothing worse happens.</source>
          <target state="translated">В примере объявлена ​​древовидная структура с типом &lt;code&gt;Node&lt;/code&gt; . Обратите внимание, что определение типа рекурсивно, и GC должен предполагать, что объекты этого типа могут образовывать циклический граф. &lt;code&gt;acyclic&lt;/code&gt; Прагма передает информацию , что это не может произойти с GC. Если программист использует &lt;code&gt;acyclic&lt;/code&gt; прагму для типов данных, которые на самом деле являются циклическими, сборщик мусора может потерять память, но ничего хуже не произойдет.</target>
        </trans-unit>
        <trans-unit id="c223baf4c7b9145e95ff7b9ff3609cc1168a5f2c" translate="yes" xml:space="preserve">
          <source>In the example c2nim treats the declaration of &lt;code&gt;DECLARE_NO_COPY_CLASS&lt;/code&gt; as if it has been defined via &lt;code&gt;#def&lt;/code&gt;.</source>
          <target state="translated">В примере c2nim обрабатывает объявление &lt;code&gt;DECLARE_NO_COPY_CLASS&lt;/code&gt; , как если бы оно было определено через &lt;code&gt;#def&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4931fb24c88d4a3add48a67517bb1d6df1d7d83b" translate="yes" xml:space="preserve">
          <source>In the example the &lt;code&gt;kind&lt;/code&gt; field is called the &lt;span id=&quot;discriminator_1&quot;&gt;discriminator&lt;/span&gt;: For safety its address cannot be taken and assignments to it are restricted: The new value must not lead to a change of the active object branch. For an object branch switch &lt;code&gt;system.reset&lt;/code&gt; has to be used. Also, when the fields of a particular branch are specified during object construction, the correct value for the discriminator must be supplied at compile-time.</source>
          <target state="translated">В этом примере поле &lt;code&gt;kind&lt;/code&gt; называется &lt;span id=&quot;discriminator_1&quot;&gt;дискриминатором&lt;/span&gt; : в целях безопасности его адрес не может быть взят, и присвоение ему ограничено: новое значение не должно приводить к изменению ветви активного объекта. Для переключения &lt;code&gt;system.reset&lt;/code&gt; объекта необходимо использовать system.reset . Кроме того, когда поля конкретной ветви указываются во время построения объекта, правильное значение дискриминатора должно быть предоставлено во время компиляции.</target>
        </trans-unit>
        <trans-unit id="f870d1827ccced8c4dc81fc21ba54ed53d3b7fa4" translate="yes" xml:space="preserve">
          <source>In the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because they should use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">В этом примере конструкторы &lt;code&gt;newLit&lt;/code&gt; и &lt;code&gt;newPlus&lt;/code&gt; являются procs , потому что они должны использовать статическое связывание, но &lt;code&gt;eval&lt;/code&gt; - это метод, поскольку он требует динамического связывания.</target>
        </trans-unit>
        <trans-unit id="ffcf0c9fc73817d81ec1bb90e18296fae7f0e1e3" translate="yes" xml:space="preserve">
          <source>In the example the external name of &lt;code&gt;p&lt;/code&gt; is set to &lt;code&gt;prefixp&lt;/code&gt;. Only &lt;code&gt;$1&lt;/code&gt; is available and a literal dollar sign must be written as &lt;code&gt;$$&lt;/code&gt;.</source>
          <target state="translated">В этом примере для внешнего имени &lt;code&gt;p&lt;/code&gt; установлено значение &lt;code&gt;prefixp&lt;/code&gt; . Доступен только &lt;code&gt;$1&lt;/code&gt; и буквальный знак доллара должен быть записан как &lt;code&gt;$$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="207cdaa4265565920d4f81786bf2ce395e20de1e" translate="yes" xml:space="preserve">
          <source>In the example the generic &lt;code&gt;==&lt;/code&gt; for tuples (as defined in the system module) uses the &lt;code&gt;==&lt;/code&gt; operators of the tuple's components. However, the &lt;code&gt;==&lt;/code&gt; for the &lt;code&gt;Index&lt;/code&gt; type is defined &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;==&lt;/code&gt; for tuples; yet the example compiles as the instantiation takes the currently defined symbols into account too.</source>
          <target state="translated">В этом примере общий &lt;code&gt;==&lt;/code&gt; для кортежей (как определено в системном модуле) использует операторы &lt;code&gt;==&lt;/code&gt; компонентов кортежа. Тем не менее, &lt;code&gt;==&lt;/code&gt; для &lt;code&gt;Index&lt;/code&gt; типа определяется &lt;em&gt;после&lt;/em&gt; того, как в &lt;code&gt;==&lt;/code&gt; для кортежей; тем не менее, пример компилируется, поскольку создание экземпляра также принимает во внимание определенные в настоящее время символы.</target>
        </trans-unit>
        <trans-unit id="e3d09a6862f895be9685356eda8db42c91b15ade" translate="yes" xml:space="preserve">
          <source>In the example the two &lt;code&gt;writeLine&lt;/code&gt; statements are bound to the &lt;code&gt;body&lt;/code&gt; parameter. The &lt;code&gt;withFile&lt;/code&gt; template contains boilerplate code and helps to avoid a common bug: to forget to close the file. Note how the &lt;code&gt;let fn = filename&lt;/code&gt; statement ensures that &lt;code&gt;filename&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">В этом примере два оператора &lt;code&gt;writeLine&lt;/code&gt; привязаны к параметру &lt;code&gt;body&lt;/code&gt; . &lt;code&gt;withFile&lt;/code&gt; шаблон содержит шаблонный код и помогает избежать общей ошибки: забыть закрыть файл. Обратите внимание, как оператор &lt;code&gt;let fn = filename&lt;/code&gt; гарантирует, что &lt;code&gt;filename&lt;/code&gt; вычисляется только один раз.</target>
        </trans-unit>
        <trans-unit id="6e573c188d155c097bab8635e952a84f3906a513" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;res&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; are &lt;em&gt;var parameters&lt;/em&gt;. Var parameters can be modified by the procedure and the changes are visible to the caller. Note that the above example would better make use of a tuple as a return value instead of using var parameters.</source>
          <target state="translated">В этом примере &lt;code&gt;res&lt;/code&gt; и &lt;code&gt;remainder&lt;/code&gt; являются &lt;em&gt;параметрами var&lt;/em&gt; . Параметры Var могут быть изменены процедурой, и изменения видны вызывающему. Обратите внимание, что в приведенном выше примере лучше использовать кортеж в качестве возвращаемого значения вместо использования параметров var.</target>
        </trans-unit>
        <trans-unit id="e99258ef6102af84c3e85eb151f26d0965f922fd" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;res&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; are &lt;em&gt;var parameters&lt;/em&gt;. Var parameters can be modified by the procedure and the changes are visible to the caller. The argument passed to a var parameter has to be an l-value. Var parameters are implemented as hidden pointers. The above example is equivalent to:</source>
          <target state="translated">В этом примере &lt;code&gt;res&lt;/code&gt; и &lt;code&gt;remainder&lt;/code&gt; являются &lt;em&gt;параметрами var&lt;/em&gt; . Параметры Var могут быть изменены процедурой, и изменения видны вызывающему. Аргумент, передаваемый параметру var, должен быть l-значением. Параметры Var реализованы как скрытые указатели. Приведенный выше пример эквивалентен:</target>
        </trans-unit>
        <trans-unit id="2ce83aae39fe686c17231fc96b454e933bdbf835" translate="yes" xml:space="preserve">
          <source>In the example, the case branches &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are much more common than the other cases. Therefore the generated assembler code should test for these values first, so that the CPU's branch predictor has a good chance to succeed (avoiding an expensive CPU pipeline stall). The other cases might be put into a jump table for O(1) overhead, but at the cost of a (very likely) pipeline stall.</source>
          <target state="translated">В этом примере ветви &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; встречаются гораздо чаще, чем другие варианты. Поэтому сгенерированный код ассемблера должен сначала проверить эти значения, чтобы предсказатель ветвления ЦП имел хорошие шансы на успех (избегая дорогостоящей остановки конвейера ЦП). Другие случаи могут быть помещены в таблицу переходов для накладных расходов O (1), но ценой (очень вероятной) остановки конвейера.</target>
        </trans-unit>
        <trans-unit id="449891737730fed7e4e9e268f5440bde8cd00a54" translate="yes" xml:space="preserve">
          <source>In the example, the two &lt;code&gt;writeLine&lt;/code&gt; statements are bound to the &lt;code&gt;actions&lt;/code&gt; parameter.</source>
          <target state="translated">В этом примере два оператора &lt;code&gt;writeLine&lt;/code&gt; привязаны к параметру &lt;code&gt;actions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05f29e9409204f7156a8b49a6edfe66f0ff90993" translate="yes" xml:space="preserve">
          <source>In the examples, var parameters or pointers are used to provide two return values. This can be done in a cleaner way by returning a tuple:</source>
          <target state="translated">В примерах параметры var или указатели используются для получения двух возвращаемых значений.Это можно сделать более чистым способом,вернув кортеж:</target>
        </trans-unit>
        <trans-unit id="cf1b069c247f4187c31c21ebbe40e040b094bad5" translate="yes" xml:space="preserve">
          <source>In the following sections &lt;em&gt;global&lt;/em&gt; means &lt;em&gt;shared between modules&lt;/em&gt; or &lt;em&gt;property of the whole program&lt;/em&gt;.</source>
          <target state="translated">В следующих разделах &lt;em&gt;глобальные&lt;/em&gt; средства &lt;em&gt;разделяются между модулями&lt;/em&gt; или &lt;em&gt;свойство всей программы&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f42fa9bad92a4bca57282426b4b7870e70495fb5" translate="yes" xml:space="preserve">
          <source>In the previous example slices are used to modify a part of a string. The slice's bounds can hold any value supported by their type, but it is the proc using the slice object which defines what values are accepted.</source>
          <target state="translated">В предыдущем примере фрагменты используются для изменения части строки.Ограничения фрагментов могут содержать любое значение,поддерживаемое их типом,но именно proc,используя объект фрагмента,определяет,какие значения принимаются.</target>
        </trans-unit>
        <trans-unit id="d9143e669402c29ee0475ca379b33b947a4800d5" translate="yes" xml:space="preserve">
          <source>In the previous sections the &lt;code&gt;NimMain()&lt;/code&gt; function reared its head. Since JavaScript already provides automatic memory management, you can freely pass objects between the two language without problems. In C and derivate languages you need to be careful about what you do and how you share memory. The previous examples only dealt with simple scalar values, but passing a Nim string to C, or reading back a C string in Nim already requires you to be aware of who controls what to avoid crashing.</source>
          <target state="translated">В предыдущих разделах &lt;code&gt;NimMain()&lt;/code&gt; функция NimMain () . Поскольку JavaScript уже обеспечивает автоматическое управление памятью, вы можете без проблем передавать объекты между двумя языками. В языках C и производных языках нужно быть осторожным в том, что вы делаете и как распределяете память. Предыдущие примеры имели дело только с простыми скалярными значениями, но передача строки Nim в C или считывание строки C в Nim уже требует, чтобы вы знали, кто что контролирует, чтобы избежать сбоев.</target>
        </trans-unit>
        <trans-unit id="1678b121aeb51003f37c84a3a8b55dda38dde0ae" translate="yes" xml:space="preserve">
          <source>In the standard library every name of a routine that returns a &lt;code&gt;var&lt;/code&gt; type starts with the prefix &lt;code&gt;m&lt;/code&gt; per convention.</source>
          <target state="translated">В стандартной библиотеке каждое имя подпрограммы, возвращающей тип &lt;code&gt;var&lt;/code&gt; , начинается с префикса &lt;code&gt;m&lt;/code&gt; согласно соглашению.</target>
        </trans-unit>
        <trans-unit id="3573423166a3714205c4fd8df064a462e9f793fc" translate="yes" xml:space="preserve">
          <source>In this context, a line is any string seperated by a newline combination. A line can be an empty string.</source>
          <target state="translated">В данном контексте,строка-это любая строка,отделенная комбинацией новой строки.Строка может быть пустой строкой.</target>
        </trans-unit>
        <trans-unit id="f0c0be54e609e08ad5ac67f5c3b4c12362798deb" translate="yes" xml:space="preserve">
          <source>In this example &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; is applied to any argument that is passed to the parameter &lt;code&gt;a&lt;/code&gt;. Note that &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; applied to strings is a nop.</source>
          <target state="translated">В этом примере &lt;a href=&quot;system#%24&quot;&gt;$&lt;/a&gt; применяется к любому аргументу, передаваемому параметру &lt;code&gt;a&lt;/code&gt; . Обратите внимание, что &lt;a href=&quot;system#%24&quot;&gt;$,&lt;/a&gt; примененный к строкам, не является правилом.</target>
        </trans-unit>
        <trans-unit id="cd49a3b7329e865d00fe88035f180e3a31be031d" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;$&lt;/code&gt; is applied to any argument that is passed to the parameter &lt;code&gt;a&lt;/code&gt;. (Note that &lt;code&gt;$&lt;/code&gt; applied to strings is a nop.)</source>
          <target state="translated">В этом примере &lt;code&gt;$&lt;/code&gt; применяется к любому аргументу, передаваемому параметру &lt;code&gt;a&lt;/code&gt; . (Обратите внимание, что &lt;code&gt;$&lt;/code&gt; , примененный к строкам, не подходит.)</target>
        </trans-unit>
        <trans-unit id="caf41cefb1ec542e92b76fcef06da5301961d50c" translate="yes" xml:space="preserve">
          <source>In this example both macros are combined seamlessly in order to maximise efficiency and perform different checks.</source>
          <target state="translated">В данном примере оба макроса бесшовно соединяются,чтобы максимизировать эффективность и выполнять различные проверки.</target>
        </trans-unit>
        <trans-unit id="fbd15640684b666f33817b98a57e6ad3f6b44475" translate="yes" xml:space="preserve">
          <source>In this example custom pragmas are used to describe how Nim objects are mapped to the schema of the relational database. Custom pragmas can have zero or more arguments. In order to pass multiple arguments use one of template call syntaxes. All arguments are typed and follow standard overload resolution rules for templates. Therefore, it is possible to have default values for arguments, pass by name, varargs, etc.</source>
          <target state="translated">В данном примере используются пользовательские прагмы для описания того,как объекты Nim отображаются на схему реляционной базы данных.Пользовательские прагмы могут иметь нулевые и более аргументов.Для передачи нескольких аргументов используется один из синтаксисов вызова шаблонов.Все аргументы набраны и следуют стандартным правилам разрешения перегрузки для шаблонов.Таким образом,можно иметь значения по умолчанию для аргументов,передавать по имени,вараги и т.д.</target>
        </trans-unit>
        <trans-unit id="664c924f4e9ba31a6bee85a98d981b31c47a324a" translate="yes" xml:space="preserve">
          <source>In this example, we define a helper proc &lt;code&gt;someSep&lt;/code&gt; that skips some separators which we then use in our scanf pattern to help us in the matching process:</source>
          <target state="translated">В этом примере мы определяем вспомогательную процедуру &lt;code&gt;someSep&lt;/code&gt; , которая пропускает некоторые разделители, которые мы затем используем в нашем шаблоне scanf, чтобы помочь нам в процессе сопоставления:</target>
        </trans-unit>
        <trans-unit id="534570485c11beb7704f319727846b8b4f022eb5" translate="yes" xml:space="preserve">
          <source>Include statement</source>
          <target state="translated">Включить заявление</target>
        </trans-unit>
        <trans-unit id="bbc642ae58ad84741186ba01bd7a4f6256a9bccf" translate="yes" xml:space="preserve">
          <source>Includes &lt;em&gt;key&lt;/em&gt; in the set &lt;em&gt;s&lt;/em&gt; and tells if &lt;em&gt;key&lt;/em&gt; was added to &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Включает &lt;em&gt;ключ&lt;/em&gt; в набор &lt;em&gt;s&lt;/em&gt; и сообщает, был ли добавлен &lt;em&gt;ключ&lt;/em&gt; в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="64f932923a0eaeac8401c0d332e7ec2bbdcdc32c" translate="yes" xml:space="preserve">
          <source>Includes all elements from &lt;em&gt;other&lt;/em&gt; into &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Включает все элементы из &lt;em&gt;другого&lt;/em&gt; в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9a1bf1db1ba56c9fed3c108674752a59dfcd9da4" translate="yes" xml:space="preserve">
          <source>Includes an element &lt;em&gt;key&lt;/em&gt; in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Включает &lt;em&gt;ключ&lt;/em&gt; элемента в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="122d72fb5f4934f490f955173c3eef92832e3bcb" translate="yes" xml:space="preserve">
          <source>IncompleteStruct pragma</source>
          <target state="translated">НеполноеУничтожение прагмы</target>
        </trans-unit>
        <trans-unit id="e458e98e024804e2195312b10a3a11a67d6582fd" translate="yes" xml:space="preserve">
          <source>Increments an ordinal</source>
          <target state="translated">Увеличивает порядковый</target>
        </trans-unit>
        <trans-unit id="3579152b0f13082bc2ed763d516b6eeee04f5e41" translate="yes" xml:space="preserve">
          <source>Increments in place a floating point number</source>
          <target state="translated">Увеличение числа с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="3917b825256b71ec29e2860d96b9f3c57a46e2bf" translate="yes" xml:space="preserve">
          <source>Indent with two spaces.</source>
          <target state="translated">Отступ с двумя пробелами.</target>
        </trans-unit>
        <trans-unit id="c9ec7fcf0ce1c005cbdd2ae9ab39e1773e6bf368" translate="yes" xml:space="preserve">
          <source>Indentation</source>
          <target state="translated">Indentation</target>
        </trans-unit>
        <trans-unit id="3e69016e62b22706518f7fd44403f71f6f86a464" translate="yes" xml:space="preserve">
          <source>Indentation can be used after the &lt;code&gt;const&lt;/code&gt; keyword to list a whole section of constants:</source>
          <target state="translated">Отступ можно использовать после ключевого слова &lt;code&gt;const&lt;/code&gt; для перечисления всего раздела констант:</target>
        </trans-unit>
        <trans-unit id="6f45c825c4626280194b953ea0dec3e48ce7fccc" translate="yes" xml:space="preserve">
          <source>Indentation can be used after the &lt;code&gt;var&lt;/code&gt; keyword to list a whole section of variables:</source>
          <target state="translated">Отступ можно использовать после ключевого слова &lt;code&gt;var&lt;/code&gt; для перечисления целого раздела переменных:</target>
        </trans-unit>
        <trans-unit id="520792c3a2538ee8e56f0b4f71803ca37955634d" translate="yes" xml:space="preserve">
          <source>Indents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">Отступ каждая строка в &lt;code&gt;s&lt;/code&gt; помощью &lt;code&gt;count&lt;/code&gt; количества &lt;code&gt;padding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="f2171e3002af9c53c4ea2469894d127d907cca3e" translate="yes" xml:space="preserve">
          <source>Index (idx) file format</source>
          <target state="translated">Формат файла индекса (idx)</target>
        </trans-unit>
        <trans-unit id="7086b5dce7145d779101ccd8901d9bbb698cae3d" translate="yes" xml:space="preserve">
          <source>Index files are line oriented and tab separated (newline and tab characters have to be escaped). Each line represents a record with at least two fields, but can have up to four (additional columns are ignored). The content of these columns is:</source>
          <target state="translated">Индексные файлы ориентированы на строки и разделены на табуляции (символы новой строки и табуляции должны быть экранированы).Каждая строка представляет собой запись как минимум с двумя полями,но может содержать до четырех (дополнительные столбцы игнорируются).Содержание этих столбцов:</target>
        </trans-unit>
        <trans-unit id="0c5d6204871842ba1c9f7cd8b0f7f94f787509f2" translate="yes" xml:space="preserve">
          <source>Index switch</source>
          <target state="translated">Индексный переключатель</target>
        </trans-unit>
        <trans-unit id="7d2d080b9c23631882a620ee4cef31b37b3e5e98" translate="yes" xml:space="preserve">
          <source>Index the collection with the proc provided.</source>
          <target state="translated">Проиндексируй сбор с предоставленным прокурором.</target>
        </trans-unit>
        <trans-unit id="9b0343473193cfc7e99b7802a4d65dded5509d30" translate="yes" xml:space="preserve">
          <source>Indicates that a leading space should be used on positive numbers.</source>
          <target state="translated">Указывает на то,что для положительных чисел следует использовать ведущее место.</target>
        </trans-unit>
        <trans-unit id="2c549fa4a0ba269a959c6226777ab5a0b50f1df5" translate="yes" xml:space="preserve">
          <source>Indicates that a sign should be used for both positive as well as negative numbers.</source>
          <target state="translated">Указывает на то,что знак следует использовать как для положительных,так и для отрицательных чисел.</target>
        </trans-unit>
        <trans-unit id="a0c8cf09bdbe9d14558c3f28be789e07866609de" translate="yes" xml:space="preserve">
          <source>Indicates that a sign should be used only for negative numbers (this is the default behavior).</source>
          <target state="translated">Указывает на то,что знак должен использоваться только для отрицательных чисел (это поведение по умолчанию).</target>
        </trans-unit>
        <trans-unit id="02d4b08a1673b232bf3018ee2f9d0a8e9fa2025c" translate="yes" xml:space="preserve">
          <source>Inexact: operation produces a result that cannot be represented with infinite precision, for example, 2.0 / 3.0, log(1.1) and 0.1 in input.</source>
          <target state="translated">Неточно:операция дает результат,который не может быть представлен с бесконечной точностью,например,2.0/3.0,log(1.1)и 0.1 во входе.</target>
        </trans-unit>
        <trans-unit id="63d5b176942ca6a8ddb9add205f21b0d98945888" translate="yes" xml:space="preserve">
          <source>Infix operator call</source>
          <target state="translated">Вызов Infix-оператора</target>
        </trans-unit>
        <trans-unit id="eb712e4e263d88043891e59382c4f31c8c4157de" translate="yes" xml:space="preserve">
          <source>Inheritance is done with the &lt;code&gt;object of&lt;/code&gt; syntax. Multiple inheritance is currently not supported. If an object type has no suitable ancestor, &lt;code&gt;RootObj&lt;/code&gt; can be used as its ancestor, but this is only a convention. Objects that have no ancestor are implicitly &lt;code&gt;final&lt;/code&gt;. You can use the &lt;code&gt;inheritable&lt;/code&gt; pragma to introduce new object roots apart from &lt;code&gt;system.RootObj&lt;/code&gt;. (This is used in the GTK wrapper for instance.)</source>
          <target state="translated">Наследование осуществляется с помощью &lt;code&gt;object of&lt;/code&gt; синтаксиса. Множественное наследование в настоящее время не поддерживается. Если тип объекта не имеет подходящего предка, &lt;code&gt;RootObj&lt;/code&gt; может использоваться в качестве его предка, но это только соглашение. Объекты, у которых нет предка, неявно являются &lt;code&gt;final&lt;/code&gt; . Вы можете использовать &lt;code&gt;inheritable&lt;/code&gt; прагму для введения новых корней объектов помимо &lt;code&gt;system.RootObj&lt;/code&gt; . (Например, это используется в оболочке GTK.)</target>
        </trans-unit>
        <trans-unit id="862fae5c64569c192f0058ccd3bbb5d19a019f65" translate="yes" xml:space="preserve">
          <source>Inhibit dynamic method resolution via procCall</source>
          <target state="translated">Запретить динамическое разрешение метода через procCall</target>
        </trans-unit>
        <trans-unit id="5c4f1d9bb4b4c00271c428db76888f539a5526ec" translate="yes" xml:space="preserve">
          <source>Init procs must not be &quot;forgotten&quot; to be called.</source>
          <target state="translated">Нельзя &quot;забывать&quot; называть Init procs.</target>
        </trans-unit>
        <trans-unit id="e0133811d52fc5e0ce7548998427d86c5ecbabc3" translate="yes" xml:space="preserve">
          <source>Initialises an AsyncSocket object. If a socket cannot be initialised EOS is raised.</source>
          <target state="translated">Инициализирует объект AsyncSocket.Если сокет не может быть инициализирован,то EOS поднимается.</target>
        </trans-unit>
        <trans-unit id="0e8796999c73166ae179e51a98cc0d932f6227e2" translate="yes" xml:space="preserve">
          <source>Initialize SSL using OPENSSL_init_ssl for OpenSSL &amp;gt;= 1.1.0 otherwise SSL_library_init</source>
          <target state="translated">Инициализируйте SSL, используя OPENSSL_init_ssl для OpenSSL&amp;gt; = 1.1.0, иначе SSL_library_init</target>
        </trans-unit>
        <trans-unit id="881e0294c3d407bde48feb8c4affbeeef0f33574" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RstGenerator&lt;/code&gt;.</source>
          <target state="translated">Инициализирует &lt;code&gt;RstGenerator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40151f2c3d201480764280228665dd4a245cb8ae" translate="yes" xml:space="preserve">
          <source>Initializes a URI.</source>
          <target state="translated">Инициализирует УРТ.</target>
        </trans-unit>
        <trans-unit id="405224e088cd409637c05da8068dcfb0b7324f95" translate="yes" xml:space="preserve">
          <source>Initializes a hash set.</source>
          <target state="translated">Инициализирует набор хэшей.</target>
        </trans-unit>
        <trans-unit id="e84a4c040ee7b5e4ea1966bc93e94a695c273213" translate="yes" xml:space="preserve">
          <source>Initializes an ordered hash set.</source>
          <target state="translated">Инициализирует заказанный набор хэшей.</target>
        </trans-unit>
        <trans-unit id="580bcf0259f858c591c1bdfb9fe2dbcc9bf29a6d" translate="yes" xml:space="preserve">
          <source>Initializes the default random number generator with a specific seed.</source>
          <target state="translated">Инициализирует генератор случайных чисел по умолчанию с определенным посевным материалом.</target>
        </trans-unit>
        <trans-unit id="dacee3e957999d4c882a7ef1c7b8e6793e30746e" translate="yes" xml:space="preserve">
          <source>Initializes the given condition variable.</source>
          <target state="translated">Инициализирует данную переменную состояния.</target>
        </trans-unit>
        <trans-unit id="0f32d11dbd1ff544f08160af91e946d34a75cd48" translate="yes" xml:space="preserve">
          <source>Initializes the given lock.</source>
          <target state="translated">Инициализирует данный замок.</target>
        </trans-unit>
        <trans-unit id="6ede6304ec6e7bf4a6a2e3d80c6b1eeb81cc73f8" translate="yes" xml:space="preserve">
          <source>Initializes the random number generator with a &quot;random&quot; number, i.e. a tickcount. Note: Does not work for NimScript.</source>
          <target state="translated">Инициализирует генератор случайных чисел &quot;случайным&quot; числом,т.е.тиккотом.Примечание:Не работает для NimScript.</target>
        </trans-unit>
        <trans-unit id="7656a50f2e0ac5db2e06ce5648c4594fc345f831" translate="yes" xml:space="preserve">
          <source>InjectStmt pragma</source>
          <target state="translated">InjectStmt прагма</target>
        </trans-unit>
        <trans-unit id="1ee7de66fcff05572c93c829536da75cc7683b42" translate="yes" xml:space="preserve">
          <source>Input flags.</source>
          <target state="translated">Входные флаги.</target>
        </trans-unit>
        <trans-unit id="f9e1ac91d7701d8e495d0f11ba5f1b00fdf6ed7f" translate="yes" xml:space="preserve">
          <source>Insert node B into A at pos</source>
          <target state="translated">Вставить узел B в A в позиции</target>
        </trans-unit>
        <trans-unit id="2db3b3fd15b7bb4b34dad30c689dad9d16b24896" translate="yes" xml:space="preserve">
          <source>Inserting data</source>
          <target state="translated">Вставка данных</target>
        </trans-unit>
        <trans-unit id="dd923f823166b6196d06cbdd3db676002c784b17" translate="yes" xml:space="preserve">
          <source>Inserts items from &lt;em&gt;src&lt;/em&gt; into &lt;em&gt;dest&lt;/em&gt; at position &lt;em&gt;pos&lt;/em&gt;. This modifies &lt;em&gt;dest&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="translated">Вставляет элементы из &lt;em&gt;src&lt;/em&gt; в &lt;em&gt;dest&lt;/em&gt; в позиции &lt;em&gt;pos&lt;/em&gt; . Это изменяет сам &lt;em&gt;dest&lt;/em&gt; , он не возвращает копию.</target>
        </trans-unit>
        <trans-unit id="04298198949aebc6d2892e5fc955264070b8ebb9" translate="yes" xml:space="preserve">
          <source>Inserts the node &lt;code&gt;newChild&lt;/code&gt; before the existing child node &lt;code&gt;refChild&lt;/code&gt;. If &lt;code&gt;refChild&lt;/code&gt; is nil, insert &lt;code&gt;newChild&lt;/code&gt; at the end of the list of children.</source>
          <target state="translated">Вставляет узел &lt;code&gt;newChild&lt;/code&gt; перед существующим дочерним узлом &lt;code&gt;refChild&lt;/code&gt; . Если &lt;code&gt;refChild&lt;/code&gt; равен нулю, вставьте &lt;code&gt;newChild&lt;/code&gt; в конец списка дочерних элементов.</target>
        </trans-unit>
        <trans-unit id="786ea42ccb1f6bb0efafd8f2b61725cd22b7b01c" translate="yes" xml:space="preserve">
          <source>Inserts the separator &lt;em&gt;sep&lt;/em&gt; after &lt;em&gt;digits&lt;/em&gt; digits from right to left.</source>
          <target state="translated">Вставляет разделитель &lt;em&gt;sep&lt;/em&gt; после &lt;em&gt;цифр&lt;/em&gt; цифр справа налево.</target>
        </trans-unit>
        <trans-unit id="873af15bd68c477178748ca072cfddf8b2be43af" translate="yes" xml:space="preserve">
          <source>Inside a character class, or if the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand for themselves. For example:</source>
          <target state="translated">Внутри класса символов,или если десятичное число больше 9 и не было столько захватывающих подмашин,PCRE повторно считывает до трех восьмеричных цифр,следующих за обратным слешем,и генерирует один байт из наименее значимых 8 бит значения.Любые последующие цифры стоят сами за себя.Например:</target>
        </trans-unit>
        <trans-unit id="ca77b6367a8fe2f8a03241e2199780113a61f688" translate="yes" xml:space="preserve">
          <source>Inside asynchronous procedures &lt;code&gt;await&lt;/code&gt; can be used to call any procedures which return a &lt;code&gt;Future&lt;/code&gt;; this includes asynchronous procedures. When a procedure is &quot;awaited&quot;, the asynchronous procedure it is awaited in will suspend its execution until the awaited procedure's Future completes. At which point the asynchronous procedure will resume its execution. During the period when an asynchronous procedure is suspended other asynchronous procedures will be run by the dispatcher.</source>
          <target state="translated">Внутри асинхронных процедур &lt;code&gt;await&lt;/code&gt; можно использовать для вызова любых процедур, возвращающих &lt;code&gt;Future&lt;/code&gt; ; это включает асинхронные процедуры. Когда процедура находится в состоянии ожидания, асинхронная процедура, в которой она ожидается, приостанавливает свое выполнение до завершения Future ожидаемой процедуры. В этот момент асинхронная процедура возобновит выполнение. В период, когда асинхронная процедура приостановлена, диспетчером будут выполняться другие асинхронные процедуры.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="58445a9dc8fa874d6c0999c2be877243221f8374" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;#@ @#&lt;/code&gt; Nim's pragma brackets &lt;code&gt;{. .}&lt;/code&gt; can also be used, but not nested since the &lt;code&gt;.}&lt;/code&gt; doesn't have to be on a line of its own:</source>
          <target state="translated">Вместо &lt;code&gt;#@ @#&lt;/code&gt; скобок прагмы Нима &lt;code&gt;{. .}&lt;/code&gt; также можно использовать, но не вложенными, так как &lt;code&gt;.}&lt;/code&gt; не обязательно должен быть в отдельной строке:</target>
        </trans-unit>
        <trans-unit id="ed085b50e598c9e9c3c998d8d02d824b13f51bfb" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;self&lt;/code&gt; any other identifier can be used too, but &lt;code&gt;{.this: self.}&lt;/code&gt; will become the default directive for the whole language eventually.</source>
          <target state="translated">Вместо &lt;code&gt;self&lt;/code&gt; можно использовать любой другой идентификатор, но со временем &lt;code&gt;{.this: self.}&lt;/code&gt; Станет директивой по умолчанию для всего языка.</target>
        </trans-unit>
        <trans-unit id="5150cf2c23ac3058436fce11d312cb4ab7dd9726" translate="yes" xml:space="preserve">
          <source>Instead of a &lt;code&gt;try finally&lt;/code&gt; statement a &lt;code&gt;defer&lt;/code&gt; statement can be used.</source>
          <target state="translated">Вместо оператора &lt;code&gt;try finally&lt;/code&gt; можно использовать оператор &lt;code&gt;defer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03665382599317cc60a7efd5af43d25b36a35438" translate="yes" xml:space="preserve">
          <source>Instead of depending on the generation of the individual &lt;code&gt;.c&lt;/code&gt; files you can also ask the Nim compiler to generate a statically linked library:</source>
          <target state="translated">Вместо того, чтобы зависеть от создания отдельных файлов &lt;code&gt;.c&lt;/code&gt; , вы также можете попросить компилятор Nim создать статически связанную библиотеку:</target>
        </trans-unit>
        <trans-unit id="ff60c5d0007a18ea981f49f0360da2385ccc4565" translate="yes" xml:space="preserve">
          <source>Instead of keeping 2 versions of &lt;code&gt;define foo&lt;/code&gt; around, one &lt;code&gt;#def foo&lt;/code&gt; for c2nim and one ordinary &lt;code&gt;#define foo&lt;/code&gt; for C/C++, it is often more convenient to tell c2nim that &lt;code&gt;foo&lt;/code&gt; is to be interpreted as a &lt;code&gt;#def&lt;/code&gt;. This is what the &lt;code&gt;#pp&lt;/code&gt; directive accomplishes:</source>
          <target state="translated">Вместо того, чтобы хранить две версии &lt;code&gt;define foo&lt;/code&gt; , одну &lt;code&gt;#def foo&lt;/code&gt; для c2nim и одну обычную &lt;code&gt;#define foo&lt;/code&gt; для C / C ++, часто удобнее указать c2nim, что &lt;code&gt;foo&lt;/code&gt; следует интерпретировать как &lt;code&gt;#def&lt;/code&gt; . Вот что &lt;code&gt;#pp&lt;/code&gt; директива #pp :</target>
        </trans-unit>
        <trans-unit id="c7301e8180a639fec5b0ce81d171622b155df52d" translate="yes" xml:space="preserve">
          <source>Instead of removing &lt;code&gt;EXTERN()&lt;/code&gt; from the input source file (which cannot be done reliably even with a regular expression!), one can tell c2nim that &lt;code&gt;EXTERN&lt;/code&gt; is a macro that should be expanded by c2nim too:</source>
          <target state="translated">Вместо удаления &lt;code&gt;EXTERN()&lt;/code&gt; из входного исходного файла (что невозможно надежно сделать даже с помощью регулярного выражения!), Можно сказать c2nim, что &lt;code&gt;EXTERN&lt;/code&gt; - это макрос, который также должен быть расширен c2nim:</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">Вместо этого:</target>
        </trans-unit>
        <trans-unit id="84737859654b67b2b9a33e5c2db83b51683c5344" translate="yes" xml:space="preserve">
          <source>Instead this code has to be used:</source>
          <target state="translated">Вместо этого должен использоваться этот код:</target>
        </trans-unit>
        <trans-unit id="ec54b2dcce7fd1b6d6a547c96c19205ad88a3d5d" translate="yes" xml:space="preserve">
          <source>Int values of &lt;em&gt;x&lt;/em&gt; are simply converted to &lt;code&gt;float&lt;/code&gt; and the other push operation is called.</source>
          <target state="translated">Int значения &lt;em&gt;x&lt;/em&gt; просто преобразуются в &lt;code&gt;float&lt;/code&gt; и вызывается другая операция push.</target>
        </trans-unit>
        <trans-unit id="2adc71fa12ee88a61833caad8062097e6410346c" translate="yes" xml:space="preserve">
          <source>Integer division for durations.</source>
          <target state="translated">Целостное деление на длительность.</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="584a126c172b3ef1ff0c69307f68a5ebdd0d1d09" translate="yes" xml:space="preserve">
          <source>Integers, bool, characters and enumeration types (and subranges of these types) belong to ordinal types. For reasons of simplicity of implementation the types &lt;code&gt;uint&lt;/code&gt; and &lt;code&gt;uint64&lt;/code&gt; are not ordinal types.</source>
          <target state="translated">Целые числа, логические значения, символы и типы перечисления (и поддиапазоны этих типов) относятся к порядковым типам. По причинам простоты реализации типы &lt;code&gt;uint&lt;/code&gt; и &lt;code&gt;uint64&lt;/code&gt; не являются порядковыми типами.</target>
        </trans-unit>
        <trans-unit id="90c35cf1c7e9e4b6aa47b681a51fc9aa23f2f3de" translate="yes" xml:space="preserve">
          <source>Integral conversion match: &lt;code&gt;a&lt;/code&gt; is convertible to &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is some integer or floating point type.</source>
          <target state="translated">Совпадение интегрального преобразования: &lt;code&gt;a&lt;/code&gt; можно преобразовать в &lt;code&gt;f&lt;/code&gt; и &lt;code&gt;f&lt;/code&gt; , а &lt;code&gt;a&lt;/code&gt; - это целочисленный тип или тип с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="2cea7df8891dd1065020c3b86bf5bf912b6baca2" translate="yes" xml:space="preserve">
          <source>Interfacing</source>
          <target state="translated">Interfacing</target>
        </trans-unit>
        <trans-unit id="a954e42be7d65d0d68df6c2475675a3e2ab46fae" translate="yes" xml:space="preserve">
          <source>Internal documentation</source>
          <target state="translated">Внутренняя документация</target>
        </trans-unit>
        <trans-unit id="6be940d65e52db18b5d8edc969f415c8720649fa" translate="yes" xml:space="preserve">
          <source>Internal type representation</source>
          <target state="translated">Внутреннее представление типа</target>
        </trans-unit>
        <trans-unit id="664fc2f86af06c6988fa72f769d3e17fcd2731e8" translate="yes" xml:space="preserve">
          <source>Internally, we want mustRehash(rightSize(x), x) == false.</source>
          <target state="translated">Внутри мы хотим mustRehash(rightSize(x),x)==false.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="2938da18cdb579e62b1141f39929cc36fdc8e917" translate="yes" xml:space="preserve">
          <source>Internals of the Nim Compiler</source>
          <target state="translated">Внутренние компоненты компилятора Nim</target>
        </trans-unit>
        <trans-unit id="efedd1f6d18388871beb5b8937b0af027d8bf044" translate="yes" xml:space="preserve">
          <source>Internet Protocols and Support</source>
          <target state="translated">Интернет-протоколы и их поддержка</target>
        </trans-unit>
        <trans-unit id="c77102105a7e484189908c6c3aaa8b4fde6d5bd4" translate="yes" xml:space="preserve">
          <source>Interpolates a format string with the values from &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">Интерполяция формата строки со значениями из .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1a2e25ef70924b9dc72d6e9cae42a42464d5c3ae" translate="yes" xml:space="preserve">
          <source>Invalid SQL encountered</source>
          <target state="translated">Недействительный SQL,с которым столкнулся</target>
        </trans-unit>
        <trans-unit id="3579c51a9cfa004f6051766e66c67a34af9f5d6d" translate="yes" xml:space="preserve">
          <source>Invalid: operations with mathematically invalid operands, for example 0.0/0.0, sqrt(-1.0), and log(-37.8).</source>
          <target state="translated">Недействительные:операции с математически недействительными операндами,например 0.0/0.0,sqrt(-1.0),log(-37.8).</target>
        </trans-unit>
        <trans-unit id="e0c13b2efd4e2d6dec9f73473d4c5e30f853cc74" translate="yes" xml:space="preserve">
          <source>Invocation context</source>
          <target state="translated">Контекст вызова</target>
        </trans-unit>
        <trans-unit id="45e47edcb41b8a29e3a098022eba6bd2db5b9ca3" translate="yes" xml:space="preserve">
          <source>Invocation of a multi-method cannot be ambiguous: collide 2 is preferred over collide 1 because the resolution works from left to right. In the example &lt;code&gt;Unit, Thing&lt;/code&gt; is preferred over &lt;code&gt;Thing, Unit&lt;/code&gt;.</source>
          <target state="translated">Вызов мульти-метода не может быть неоднозначным: столкновение 2 предпочтительнее, чем столкновение 1, потому что разрешение работает слева направо. В примере &lt;code&gt;Unit, Thing&lt;/code&gt; предпочтительнее &lt;code&gt;Thing, Unit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">Это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="a8f35cc2588d6df7883512e310eaf3cfe55f22b5" translate="yes" xml:space="preserve">
          <source>Is operator</source>
          <target state="translated">Является ли оператором</target>
        </trans-unit>
        <trans-unit id="3bcc962b75eed7b2e391c690e8701aa2754af2d5" translate="yes" xml:space="preserve">
          <source>Is rewritten to:</source>
          <target state="translated">переписывается:</target>
        </trans-unit>
        <trans-unit id="41e7fee403015340d1195de277c32fe1acf8a866" translate="yes" xml:space="preserve">
          <source>Is short for:</source>
          <target state="translated">Сокращенно от:</target>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">это то же самое:</target>
        </trans-unit>
        <trans-unit id="ae0bcdcfc983072ff2e5010acbd964825c34f849" translate="yes" xml:space="preserve">
          <source>Is translated into:</source>
          <target state="translated">переводится:</target>
        </trans-unit>
        <trans-unit id="6f20666fec7d3538d857abddfabb7eb0323d351c" translate="yes" xml:space="preserve">
          <source>Is translated to:</source>
          <target state="translated">Переводится:</target>
        </trans-unit>
        <trans-unit id="90d19d41b3a53b1379c3459c0faab9f64cca3759" translate="yes" xml:space="preserve">
          <source>It allows programmers to mostly use their own preferred spelling style, be it humpStyle or snake_style, and libraries written by different programmers cannot use incompatible conventions. A Nim-aware editor or IDE can show the identifiers as preferred. Another advantage is that it frees the programmer from remembering the exact spelling of an identifier. The exception with respect to the first letter allows common code like &lt;code&gt;var foo: Foo&lt;/code&gt; to be parsed unambiguously.</source>
          <target state="translated">Это позволяет программистам в основном использовать свой собственный предпочтительный стиль написания, будь то humpStyle или snake_style, а библиотеки, написанные разными программистами, не могут использовать несовместимые соглашения. Редактор с поддержкой Nim или IDE может показывать идентификаторы по своему усмотрению. Еще одно преимущество состоит в том, что он освобождает программиста от запоминания точного написания идентификатора. Исключение в отношении первой буквы позволяет однозначно анализировать общий код, например &lt;code&gt;var foo: Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fe9d58777a4819a056f680773675b458bc59f43" translate="yes" xml:space="preserve">
          <source>It also possible to pass arguments to a user definable matcher:</source>
          <target state="translated">Также возможно передавать аргументы в определяемый пользователем матчер:</target>
        </trans-unit>
        <trans-unit id="4b2feef416362147669a39cf0c612de62bb2d19e" translate="yes" xml:space="preserve">
          <source>It also provides some fast iterators over lines in text files (or other &quot;line-like&quot;, variable length, delimited records).</source>
          <target state="translated">Он также предоставляет несколько быстрых итераторов над строками в текстовых файлах (или других &quot;строковых&quot;,переменной длины,разделенных записей).</target>
        </trans-unit>
        <trans-unit id="dff3ae584541038e537e5a342c1930160c45bf0a" translate="yes" xml:space="preserve">
          <source>It can also be used when defines are being referred to, as c2nim currently does not expand defines:</source>
          <target state="translated">Он также может быть использован при ссылке на определения,так как c2nim в настоящее время не расширяет определения:</target>
        </trans-unit>
        <trans-unit id="f0075f000dd30ff460292c5c1bbbe6ad98332e6c" translate="yes" xml:space="preserve">
          <source>It can be used to parse a wild HTML document and output it as valid XHTML document (well, if you are lucky):</source>
          <target state="translated">Его можно использовать для разбора дикого HTML-документа и вывода его как действительного XHTML-документа (ну,если повезет):</target>
        </trans-unit>
        <trans-unit id="589d528fa76550fcfe67d75a7cc3b724508c0925" translate="yes" xml:space="preserve">
          <source>It does not make sense to multiply a dollar with a dollar, but with a number without unit; and the same holds for division:</source>
          <target state="translated">Умножать доллар с долларом не имеет смысла,но с числом без единицы измерения;то же самое относится и к делению:</target>
        </trans-unit>
        <trans-unit id="c9187f5ee38c2d68fe98474af10e0521e2ff318b" translate="yes" xml:space="preserve">
          <source>It helps to think that the iterator actually returns a pair &lt;code&gt;(value, done)&lt;/code&gt; and &lt;code&gt;finished&lt;/code&gt; is used to access the hidden &lt;code&gt;done&lt;/code&gt; field.</source>
          <target state="translated">Это помогает думать, что итератор фактически возвращает пару &lt;code&gt;(value, done)&lt;/code&gt; а &lt;code&gt;finished&lt;/code&gt; используется для доступа к скрытому полю &lt;code&gt;done&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7934ea36bb3abaeb6de1ae68617ee4fa3e89f7c" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;not&lt;/strong&gt; safe to disable the garbage collector and enable it after the call from your background thread even if the code you are calling is short lived.</source>
          <target state="translated">Это &lt;strong&gt;не&lt;/strong&gt; безопасно отключить сборщик мусора и включить его после звонка с фоновым потоком , даже если код вы звоните в недолговечной.</target>
        </trans-unit>
        <trans-unit id="0ce32c42207b074e8614eb82e24a7a71033a751d" translate="yes" xml:space="preserve">
          <source>It is a compile time error if the implicitly introduced pointer could be used to access a location beyond its lifetime:</source>
          <target state="translated">Это ошибка времени компиляции,если неявно введенный указатель может быть использован для доступа к местоположению после окончания его жизни:</target>
        </trans-unit>
        <trans-unit id="654b26d139effb1815e88b12fee61a0a858572c0" translate="yes" xml:space="preserve">
          <source>It is also important that the replay involves the &lt;code&gt;import&lt;/code&gt; statement so that the dependencies are resolved properly.</source>
          <target state="translated">Также важно, чтобы воспроизведение включало оператор &lt;code&gt;import&lt;/code&gt; чтобы зависимости были разрешены правильно.</target>
        </trans-unit>
        <trans-unit id="2d729a9913be11aee103dc8aea1b73a4c4edcc41" translate="yes" xml:space="preserve">
          <source>It is an essential property of abstract types that they &lt;strong&gt;do not&lt;/strong&gt; imply a subtype relation between the abstract type and its base type. Explicit type conversions from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;SQL&lt;/code&gt; are allowed:</source>
          <target state="translated">Важным свойством абстрактных типов является то, что они &lt;strong&gt;не&lt;/strong&gt; подразумевают отношения подтипа между абстрактным типом и его базовым типом. Разрешены явные преобразования типов из &lt;code&gt;string&lt;/code&gt; в &lt;code&gt;SQL&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3e31fcf4a46656a66279b459e1a0815babbcc226" translate="yes" xml:space="preserve">
          <source>It is important to note that reordering &lt;em&gt;only&lt;/em&gt; works for symbols at top level scope. Therefore, the following will &lt;em&gt;fail to compile:&lt;/em&gt;</source>
          <target state="translated">Важно отметить, что переупорядочение работает &lt;em&gt;только&lt;/em&gt; для символов в области верхнего уровня. Следовательно, следующее &lt;em&gt;не скомпилируется:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eccab016e9c85070b264d0771a05edb52b43822b" translate="yes" xml:space="preserve">
          <source>It is not checked that the &lt;code&gt;except&lt;/code&gt; list is really exported from the module. This feature allows to compile against an older version of the module that does not export these identifiers.</source>
          <target state="translated">Не проверяется, действительно ли список &lt;code&gt;except&lt;/code&gt; экспортируется из модуля. Эта функция позволяет скомпилировать более старую версию модуля, которая не экспортирует эти идентификаторы.</target>
        </trans-unit>
        <trans-unit id="f56aa33e889a1d3e8b0dbe2f53303f6d1de0ebdc" translate="yes" xml:space="preserve">
          <source>It is possible to define custom typed pragmas. Custom pragmas do not effect code generation directly, but their presence can be detected by macros. Custom pragmas are defined using templates annotated with pragma &lt;code&gt;pragma&lt;/code&gt;:</source>
          <target state="translated">Можно определять прагмы с настраиваемым типом. Пользовательские прагмы не влияют на генерацию кода напрямую, но их присутствие можно обнаружить с помощью макросов. Пользовательские прагмы определяются с помощью шаблонов, аннотированных прагмой &lt;code&gt;pragma&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc420b00d95b0079b6bcd9cda3e4f93970825224" translate="yes" xml:space="preserve">
          <source>It is possible to raise/catch imported C++ exceptions. Types imported using &lt;em&gt;importcpp&lt;/em&gt; can be raised or caught. Exceptions are raised by value and caught by reference. Example:</source>
          <target state="translated">Есть возможность поднять / отловить импортированные исключения C ++. Типы, импортированные с помощью &lt;em&gt;importcpp,&lt;/em&gt; могут быть подняты или пойманы. Исключения возникают по значению и перехватываются по ссылке. Пример:</target>
        </trans-unit>
        <trans-unit id="82b23252352db8b301d0df8ca78112f74b272448" translate="yes" xml:space="preserve">
          <source>It is quite common to have arrays start at zero, so there's a shortcut syntax to specify a range from zero to the specified index minus one:</source>
          <target state="translated">Довольно часто массивы начинаются с нуля,поэтому существует краткий синтаксис для указания диапазона от нуля до указанного индекса минус один:</target>
        </trans-unit>
        <trans-unit id="82118804703a69ba666b11e8579a1411bb333d2a" translate="yes" xml:space="preserve">
          <source>It may be surprising but the function as a whole can take longer than the specified timeout, only individual internal calls on the socket are affected. In practice this means that as long as the server is sending data an exception will not be raised, if however data does not reach the client within the specified timeout a &lt;code&gt;TimeoutError&lt;/code&gt; exception will be raised.</source>
          <target state="translated">Это может быть удивительно, но функция в целом может занять больше времени, чем указанный тайм-аут, затронуты только отдельные внутренние вызовы сокета. На практике это означает, что пока сервер отправляет данные, исключение не возникает, однако, если данные не достигают клиента в течение указанного времени ожидания, будет &lt;code&gt;TimeoutError&lt;/code&gt; исключение TimeoutError .</target>
        </trans-unit>
        <trans-unit id="919d2993bd870949c788657a2aacbe74a9e6d3fc" translate="yes" xml:space="preserve">
          <source>It must be a call expression &lt;code&gt;f(a, ...)&lt;/code&gt;.</source>
          <target state="translated">Это должно быть выражение вызова &lt;code&gt;f(a, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1bdeab513f38cc4e202661fc69c3b7e5aa7c684" translate="yes" xml:space="preserve">
          <source>It must contain &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">Он должен содержать ветку &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f548d24fefd8a46690cd32590a6cce7dfd8f4a7" translate="yes" xml:space="preserve">
          <source>It must not contain &lt;code&gt;elif&lt;/code&gt; branches.</source>
          <target state="translated">Он не должен содержать веток &lt;code&gt;elif&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0657d7c3802eac9139afa1fdbbc00243500a126" translate="yes" xml:space="preserve">
          <source>It's a static error if the compiler cannot perform the evaluation at compile time.</source>
          <target state="translated">Это статическая ошибка,если компилятор не может выполнить оценку во время компиляции.</target>
        </trans-unit>
        <trans-unit id="b08a29bb41e597ad7a05123c2e5513c91c059874" translate="yes" xml:space="preserve">
          <source>It's also possible to use &lt;code&gt;from module import nil&lt;/code&gt; if one wants to import the module but wants to enforce fully qualified access to every symbol in &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">Также можно использовать &lt;code&gt;from module import nil&lt;/code&gt; , если кто-то хочет импортировать модуль, но хочет обеспечить полный доступ к каждому символу в &lt;code&gt;module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de95b4993b261b85e3332b1324f8a0290c259dec" translate="yes" xml:space="preserve">
          <source>It's recommended to use &lt;code&gt;addCallback&lt;/code&gt; or &lt;code&gt;then&lt;/code&gt; instead.</source>
          <target state="translated">Рекомендуется использовать &lt;code&gt;addCallback&lt;/code&gt; или &lt;code&gt;then&lt;/code&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="cadaa83ad0b6b331d838560da721266dc244b734" translate="yes" xml:space="preserve">
          <source>Iterate over all the directories that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">Перебрать все каталоги, соответствующие &lt;em&gt;шаблону&lt;/em&gt; . В POSIX это использует вызов &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="e75e34b52a6961303566d6b4dd5b3c4b21d77274" translate="yes" xml:space="preserve">
          <source>Iterate over all the files and directories that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">Перебрать все файлы и каталоги, соответствующие &lt;em&gt;шаблону&lt;/em&gt; . В POSIX это использует вызов &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="9d643234b1583c1062d05608e19e2329372f5e89" translate="yes" xml:space="preserve">
          <source>Iterate over all the files that match the &lt;em&gt;pattern&lt;/em&gt;. On POSIX this uses the &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; call.</source>
          <target state="translated">Перебрать все файлы, соответствующие &lt;em&gt;шаблону&lt;/em&gt; . В POSIX это использует вызов &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="584cc308ff50e7947ff5a4e8292a45088ef391f4" translate="yes" xml:space="preserve">
          <source>Iterate over any line in the file &lt;em&gt;f&lt;/em&gt;.</source>
          <target state="translated">Перебрать любую строку в файле &lt;em&gt;f&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a1c0deeb78059911d4801816fdd1f4f108e438a" translate="yes" xml:space="preserve">
          <source>Iterates over [optional &lt;em&gt;eat&lt;/em&gt;] &lt;em&gt;delim&lt;/em&gt;-delimited slices in MemFile &lt;em&gt;mfile&lt;/em&gt;.</source>
          <target state="translated">Перебирает [опционально &lt;em&gt;съесть&lt;/em&gt; ] &lt;em&gt;DELIM&lt;/em&gt; -delimited ломтики в MemFile &lt;em&gt;MFile&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="52d58a07e8a9d8fd6b99e5571402712d73dfd13e" translate="yes" xml:space="preserve">
          <source>Iterates over all the children of &lt;em&gt;n&lt;/em&gt; returning those matching &lt;em&gt;tag&lt;/em&gt;.</source>
          <target state="translated">Обходит всех дочерних элементов &lt;em&gt;n,&lt;/em&gt; возвращая соответствующий &lt;em&gt;тег&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b19228b3b231795b187dec3bdf8a6cb478e6ffc7" translate="yes" xml:space="preserve">
          <source>Iterates over any line in the file named &lt;em&gt;filename&lt;/em&gt;.</source>
          <target state="translated">Итерирует по любой строке в файле с именем &lt;em&gt;filename&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="232f547ddc65be9624e107036fe1044b4d2a410d" translate="yes" xml:space="preserve">
          <source>Iterates over any unicode character of the string &lt;code&gt;s&lt;/code&gt; returning runes</source>
          <target state="translated">Итерации над любым юникод символ строки &lt;code&gt;s&lt;/code&gt; возвращающимся рун</target>
        </trans-unit>
        <trans-unit id="8bc06e9d0c093f624eaf1ffbfc94ebe52d5cb792" translate="yes" xml:space="preserve">
          <source>Iterates over any unicode character of the string &lt;code&gt;s&lt;/code&gt; returning utf8 values</source>
          <target state="translated">Итерации над любым юникод символ строки &lt;code&gt;s&lt;/code&gt; возвращающимся значений utf8</target>
        </trans-unit>
        <trans-unit id="0388ab64e5b2bc44c4842558d16b95e6873ca62a" translate="yes" xml:space="preserve">
          <source>Iterates over every field of &lt;em&gt;x&lt;/em&gt; returning their name and value.</source>
          <target state="translated">Обходит все поля &lt;em&gt;x,&lt;/em&gt; возвращая их имя и значение.</target>
        </trans-unit>
        <trans-unit id="00e6300c1169713ff3c5939859f36401dc5c4eee" translate="yes" xml:space="preserve">
          <source>Iterates over every line in the stream. The iteration is based on &lt;code&gt;readLine&lt;/code&gt;.</source>
          <target state="translated">Обходит каждую строку в потоке. Итерация основана на &lt;code&gt;readLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d86ccc2321238c55eb2895e898e51e2cea46b931" translate="yes" xml:space="preserve">
          <source>Iterates over keys in the ordered set &lt;em&gt;s&lt;/em&gt; in insertion order.</source>
          <target state="translated">Итерация через ключи в упорядоченном множестве &lt;em&gt;х&lt;/em&gt; в порядке вставки.</target>
        </trans-unit>
        <trans-unit id="c71c7420dcf70891eaaf12e2494e2aabe991e2e1" translate="yes" xml:space="preserve">
          <source>Iterates over keys in the set &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Перебирает ключи в наборе &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="46bdee16e1d678daf2434ac56d4f6f640c4d7297" translate="yes" xml:space="preserve">
          <source>Iterates over the children of the NimNode &lt;code&gt;n&lt;/code&gt; and its indices.</source>
          <target state="translated">Обходит дочерние элементы NimNode &lt;code&gt;n&lt;/code&gt; и его индексы.</target>
        </trans-unit>
        <trans-unit id="a478441af6bfca796118a06d6ecf3801a9262e8d" translate="yes" xml:space="preserve">
          <source>Iterates over the children of the NimNode &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Обходит потомков NimNode &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="019eedce602970f3a59ce2f86870397544031ca8" translate="yes" xml:space="preserve">
          <source>Iterates through a container and checks if every item fulfills the predicate.</source>
          <target state="translated">Проходит через контейнер и проверяет,соответствует ли каждый предмет предикату.</target>
        </trans-unit>
        <trans-unit id="3501cb1c35511e4764121e28692134446b5075eb" translate="yes" xml:space="preserve">
          <source>Iterates through a container and checks if some item fulfills the predicate.</source>
          <target state="translated">Проходит через контейнер и проверяет,выполняет ли какой-то элемент предикат.</target>
        </trans-unit>
        <trans-unit id="7fbdcafeaa504e0cbb5d1d512e8dfbaba8410003" translate="yes" xml:space="preserve">
          <source>Iterates through a container and yields every item that fulfills the predicate.</source>
          <target state="translated">Итерируется через контейнер и дает каждый предмет,который выполняет предикат.</target>
        </trans-unit>
        <trans-unit id="81ad0b1b4463be831a5785f4d06c130b3622cb6b" translate="yes" xml:space="preserve">
          <source>Iterator declaration</source>
          <target state="translated">декларация об итерации</target>
        </trans-unit>
        <trans-unit id="edfa2bc8a9c8c3896d560c27f80be0217d6f76a5" translate="yes" xml:space="preserve">
          <source>Iterator for the child elements of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JObject.</source>
          <target state="translated">Итератор для дочерних элементов &lt;em&gt;узла&lt;/em&gt; . &lt;em&gt;узел&lt;/em&gt; должен быть JObject.</target>
        </trans-unit>
        <trans-unit id="7b68d08a7df61a331ce7105b12ff381cd2542871" translate="yes" xml:space="preserve">
          <source>Iterator for the child elements of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JObject. Values can be modified</source>
          <target state="translated">Итератор для дочерних элементов &lt;em&gt;узла&lt;/em&gt; . &lt;em&gt;узел&lt;/em&gt; должен быть JObject. Значения могут быть изменены</target>
        </trans-unit>
        <trans-unit id="6229022bcfa1dd29b2c2a761afb0d2b506503b49" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JArray.</source>
          <target state="translated">Итератор для элементов &lt;em&gt;узла&lt;/em&gt; . &lt;em&gt;узел&lt;/em&gt; должен быть JArray.</target>
        </trans-unit>
        <trans-unit id="937eeb4e7eb8e59ed90bf865be25f2439aa4af89" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a JArray. Items can be modified.</source>
          <target state="translated">Итератор для элементов &lt;em&gt;узла&lt;/em&gt; . &lt;em&gt;узел&lt;/em&gt; должен быть JArray. Предметы можно изменять.</target>
        </trans-unit>
        <trans-unit id="853abfbfe15cced2111de5887bb206586352e215" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a SList.</source>
          <target state="translated">Итератор для элементов &lt;em&gt;узла&lt;/em&gt; . &lt;em&gt;узел&lt;/em&gt; должен быть SList.</target>
        </trans-unit>
        <trans-unit id="cba2124d3f6e176e90018e400cd94d03ff65e532" translate="yes" xml:space="preserve">
          <source>Iterator for the items of &lt;em&gt;node&lt;/em&gt;. &lt;em&gt;node&lt;/em&gt; has to be a SList. Items can be modified.</source>
          <target state="translated">Итератор для элементов &lt;em&gt;узла&lt;/em&gt; . &lt;em&gt;узел&lt;/em&gt; должен быть SList. Предметы можно изменять.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="e0b6581a3426edca0a47a508b898e82d9d301321" translate="yes" xml:space="preserve">
          <source>Iterators and the for statement</source>
          <target state="translated">итераторы и для заявления</target>
        </trans-unit>
        <trans-unit id="c425b7e3d2bb19788f1181a2d9b7a44e6225c0c2" translate="yes" xml:space="preserve">
          <source>Iterators can only be called from for loops.</source>
          <target state="translated">Итераторы можно вызывать только для петель.</target>
        </trans-unit>
        <trans-unit id="df973b05a9a30c48e0cd32ea43a5a32471fddcf5" translate="yes" xml:space="preserve">
          <source>Iterators cannot be forward declared, because the compiler must be able to inline an iterator. (This restriction will be gone in a future version of the compiler.)</source>
          <target state="translated">Итераторы не могут быть объявлены вперед,так как компилятор должен уметь встраивать итератор.(Это ограничение будет снято в будущей версии компилятора).</target>
        </trans-unit>
        <trans-unit id="5ab10982165c8e92be42e548c908af50f06450ed" translate="yes" xml:space="preserve">
          <source>Iterators cannot contain a &lt;code&gt;return&lt;/code&gt; statement (and procs cannot contain a &lt;code&gt;yield&lt;/code&gt; statement).</source>
          <target state="translated">Итераторы не могут содержать оператор &lt;code&gt;return&lt;/code&gt; (а процедуры не могут содержать оператор &lt;code&gt;yield&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6bf87542270934bc52223ff3fd2180cee9913ce5" translate="yes" xml:space="preserve">
          <source>Iterators do not support recursion.</source>
          <target state="translated">Итераторы не поддерживают рекурсию.</target>
        </trans-unit>
        <trans-unit id="f13b815d55263a0262e1d3f448ea1ef694f0c5ac" translate="yes" xml:space="preserve">
          <source>Iterators have no implicit &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">Итераторы не имеют неявной переменной &lt;code&gt;result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="876bf01455350b312419f0cdb54d8032bb9cad66" translate="yes" xml:space="preserve">
          <source>Iterators look very similar to procedures, but there are several important differences:</source>
          <target state="translated">Итераторы выглядят очень похожими на процедуры,но есть несколько важных отличий:</target>
        </trans-unit>
        <trans-unit id="6bc9cd0b4b1a838a8dbe53e1eea311fe67780b4c" translate="yes" xml:space="preserve">
          <source>Iterators that are neither marked &lt;code&gt;{.closure.}&lt;/code&gt; nor &lt;code&gt;{.inline.}&lt;/code&gt; explicitly default to being inline, but this may change in future versions of the implementation.</source>
          <target state="translated">Итераторы, которые не отмечены ни &lt;code&gt;{.closure.}&lt;/code&gt; , Ни &lt;code&gt;{.inline.}&lt;/code&gt; Явно по умолчанию являются встроенными, но это может измениться в будущих версиях реализации.</target>
        </trans-unit>
        <trans-unit id="38589c6c98e2050e493732fa1ecf1db5355eff6a" translate="yes" xml:space="preserve">
          <source>Its expression must always be &lt;code&gt;nimvm&lt;/code&gt;. More complex expressions are not allowed.</source>
          <target state="translated">Его выражение всегда должно быть &lt;code&gt;nimvm&lt;/code&gt; . Более сложные выражения не допускаются.</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="cc51bafafaa93b2fbf580ec2042f2d93d08d2a66" translate="yes" xml:space="preserve">
          <source>JSON node</source>
          <target state="translated">узел JSON</target>
        </trans-unit>
        <trans-unit id="10e429d7ec1e1bc197f5757d96b736f7f4406dc2" translate="yes" xml:space="preserve">
          <source>JSON representation is stored in the passed &lt;em&gt;result&lt;/em&gt;</source>
          <target state="translated">Представление JSON сохраняется в переданном &lt;em&gt;результате&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d58199ede61c8be4b203d8081423f4280c50eb7c" translate="yes" xml:space="preserve">
          <source>JavaScript compatibility</source>
          <target state="translated">совместимость с JavaScript</target>
        </trans-unit>
        <trans-unit id="f916a308bc581d1790072c2938487f3e908716e7" translate="yes" xml:space="preserve">
          <source>JavaScript invocation example</source>
          <target state="translated">пример вызова JavaScript</target>
        </trans-unit>
        <trans-unit id="763eb4bbded920e91a4a60898d473e2e59d035cd" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;em&gt;delete&lt;/em&gt; operator</source>
          <target state="translated">Оператор &lt;em&gt;удаления&lt;/em&gt; JavaScript</target>
        </trans-unit>
        <trans-unit id="7069adda83e85fa6bdd1af127a53c1cd02199edc" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;em&gt;require&lt;/em&gt; function</source>
          <target state="translated">В JavaScript &lt;em&gt;требуется&lt;/em&gt; функция</target>
        </trans-unit>
        <trans-unit id="e59bd4e62783475d358a55e576f9e1db556cc458" translate="yes" xml:space="preserve">
          <source>JavaScript's __dirname pseudo-variable</source>
          <target state="translated">JavaScript __dirname псевдо-переменная</target>
        </trans-unit>
        <trans-unit id="c05cec6255459be0665ced8c38873552b1af2710" translate="yes" xml:space="preserve">
          <source>JavaScript's __filename pseudo-variable</source>
          <target state="translated">JavaScript __filename pseudo-variable</target>
        </trans-unit>
        <trans-unit id="48e39cbab3720cf60b021ee6573c7b065c55248f" translate="yes" xml:space="preserve">
          <source>JavaScript's arguments pseudo-variable</source>
          <target state="translated">аргументы JavaScript псевдо-переменные</target>
        </trans-unit>
        <trans-unit id="54d029c76d92f4b9cfa620d278a0227c9c10f25f" translate="yes" xml:space="preserve">
          <source>JavaScript's null literal</source>
          <target state="translated">нулевой буквенный JavaScript</target>
        </trans-unit>
        <trans-unit id="cf269e0f71fff143464c4dce0ba8941aff38d4fb" translate="yes" xml:space="preserve">
          <source>JavaScript's undefined literal</source>
          <target state="translated">неопределённый литературный язык JavaScript</target>
        </trans-unit>
        <trans-unit id="dcbcd7e22ce06dbd66e5b01adffbd52ed0a91c58" translate="yes" xml:space="preserve">
          <source>Joins two URLs together, separating them with / if needed.</source>
          <target state="translated">Соединяет два URL-адреса вместе,разделяя их с/при необходимости.</target>
        </trans-unit>
        <trans-unit id="6b949efa98af5de2c9a9e2aa57c0ac512664c7bb" translate="yes" xml:space="preserve">
          <source>Joins two directory names to one.</source>
          <target state="translated">Присоединяет два имени каталогов к одному.</target>
        </trans-unit>
        <trans-unit id="f916106b08687c9b3604d03769854685d4185a21" translate="yes" xml:space="preserve">
          <source>Just like an &lt;em&gt;if expression&lt;/em&gt;, but corresponding to the when statement.</source>
          <target state="translated">Точно так же, как &lt;em&gt;выражение if&lt;/em&gt; , но соответствует оператору when.</target>
        </trans-unit>
        <trans-unit id="1f5a23579b9dec30ee62832658d6b0b949930854" translate="yes" xml:space="preserve">
          <source>Just like in regular type classes, Nim discriminates between &lt;code&gt;bind once&lt;/code&gt; and &lt;code&gt;bind many&lt;/code&gt; types when matching the concept. You can add the &lt;code&gt;distinct&lt;/code&gt; modifier to any of the otherwise inferable types to get a type that will be matched without permanently inferring it. This may be useful when you need to match several procs accepting the same wide class of types:</source>
          <target state="translated">Как и в классах обычных типов, Nim различает &lt;code&gt;bind once&lt;/code&gt; и &lt;code&gt;bind many&lt;/code&gt; типов при сопоставлении концепции. Вы можете добавить &lt;code&gt;distinct&lt;/code&gt; модификатор к любому из иного выводимого типов , чтобы получить тип , который будет сопоставляться без постоянно выводя его. Это может быть полезно, когда вам нужно сопоставить несколько процессов, принимающих один и тот же широкий класс типов:</target>
        </trans-unit>
        <trans-unit id="3706f82fc751aa40a365d4e0255b0c559571efe9" translate="yes" xml:space="preserve">
          <source>Just like in this example we pass the path to the &lt;code&gt;mylib.a&lt;/code&gt; library (and we could as well pass &lt;code&gt;logic.o&lt;/code&gt;) we could be passing switches to link any other static C library.</source>
          <target state="translated">Как и в этом примере, мы передаем путь к библиотеке &lt;code&gt;mylib.a&lt;/code&gt; (и мы также &lt;code&gt;logic.o&lt;/code&gt; передать логику ), мы могли бы передавать переключатели для связывания любой другой статической библиотеки C.</target>
        </trans-unit>
        <trans-unit id="ec69238a91ddb84ddd174a422a2bc6d89e341833" translate="yes" xml:space="preserve">
          <source>Just like strings, custom data types that are to be shared between Nim and the backend will need careful consideration of who controls who. If you want to hand a Nim reference to C code, you will need to use &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; to mark the reference as used, so it does not get freed. And for the C backend you will need to expose the &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; proc to clean up this memory when it is not required any more.</source>
          <target state="translated">Подобно строкам, пользовательские типы данных, которые будут совместно использоваться Nim и серверной частью, потребуют тщательного рассмотрения того, кто кем управляет. Если вы хотите передать ссылку Nim на код C, вам нужно будет использовать &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref,&lt;/a&gt; чтобы пометить ссылку как используемую, чтобы она не была освобождена. А для бэкэнда C вам нужно будет открыть процедуру &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; для очистки этой памяти, когда она больше не требуется.</target>
        </trans-unit>
        <trans-unit id="a1934a4d1d0bfda8c814a6f373c36bed11fcc1a9" translate="yes" xml:space="preserve">
          <source>Just like with regular pointers, covariance will be enabled only for immutable values:</source>
          <target state="translated">Как и в случае с регулярными указателями,ковариация будет включена только для неизменяемых значений:</target>
        </trans-unit>
        <trans-unit id="ba04be8caff7a5b413c929b67abe644a93a8234c" translate="yes" xml:space="preserve">
          <source>Keeping track of memory</source>
          <target state="translated">Слежение за памятью</target>
        </trans-unit>
        <trans-unit id="c3cc4a28dc3c7c50a7cedf645fccd862a77c3448" translate="yes" xml:space="preserve">
          <source>Keeps the items in the passed sequence if they fulfilled the predicate. Same as the &lt;code&gt;filter&lt;/code&gt; proc, but modifies the sequence directly.</source>
          <target state="translated">Сохраняет элементы в переданной последовательности, если они выполнили предикат. То же, что и процедура &lt;code&gt;filter&lt;/code&gt; , но напрямую изменяет последовательность.</target>
        </trans-unit>
        <trans-unit id="cd0b9402bb38009f565aff1f5e64a66bff29662b" translate="yes" xml:space="preserve">
          <source>Kill the process &lt;em&gt;p&lt;/em&gt;. On Posix OSes the procedure sends &lt;code&gt;SIGKILL&lt;/code&gt; to the process. On Windows &lt;code&gt;kill()&lt;/code&gt; is simply an alias for &lt;code&gt;terminate()&lt;/code&gt;.</source>
          <target state="translated">Убейте процесс &lt;em&gt;p&lt;/em&gt; . В операционных системах Posix процедура отправляет процессу &lt;code&gt;SIGKILL&lt;/code&gt; . В Windows &lt;code&gt;kill()&lt;/code&gt; - это просто псевдоним для &lt;code&gt;terminate()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">Известные ограничения:</target>
        </trans-unit>
        <trans-unit id="71e0d9df3f621a55340e5e059ae130eb41a5eb1c" translate="yes" xml:space="preserve">
          <source>Lambda lifting is implemented as part of the &lt;code&gt;transf&lt;/code&gt; pass. The &lt;code&gt;transf&lt;/code&gt; pass generates code to setup the environment and to pass it around. However, this pass does not change the types! So we have some kind of mismatch here; on the one hand the proc expression becomes an explicit tuple, on the other hand the tyProc(ccClosure) type is not changed. For C code generation it's also important the hidden formal param is &lt;code&gt;void*&lt;/code&gt; and not something more specialized. However the more specialized env type needs to passed to the backend somehow. We deal with this by modifying &lt;code&gt;s.ast[paramPos]&lt;/code&gt; to contain the formal hidden parameter, but not &lt;code&gt;s.typ&lt;/code&gt;!</source>
          <target state="translated">Лямбда-лифтинг реализован как часть &lt;code&gt;transf&lt;/code&gt; . &lt;code&gt;transf&lt;/code&gt; проход генерирует код для настройки среды и передать его вокруг. Однако этот проход не меняет типы! Так что здесь есть какое-то несоответствие; с одной стороны, выражение proc становится явным кортежем, с другой стороны, тип tyProc (ccClosure) не изменяется. Для генерации кода C также важен скрытый формальный параметр &lt;code&gt;void*&lt;/code&gt; а не что-то более специализированное. Однако более специализированный тип env необходимо каким-то образом передать на бэкэнд. Мы справляемся с этим, изменяя &lt;code&gt;s.ast[paramPos]&lt;/code&gt; чтобы он содержал формальный скрытый параметр, но не &lt;code&gt;s.typ&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="6f81dcaf384dc8f0c6782aafff539ab7cb63534e" translate="yes" xml:space="preserve">
          <source>Language Manual</source>
          <target state="translated">Руководство по языку</target>
        </trans-unit>
        <trans-unit id="f1a81de77c30016ff417d2dc8525d90f0c658140" translate="yes" xml:space="preserve">
          <source>Large example</source>
          <target state="translated">Большой пример</target>
        </trans-unit>
        <trans-unit id="309493ddacc4fb8306467fc937e00c3cfc275435" translate="yes" xml:space="preserve">
          <source>Larger example</source>
          <target state="translated">более показательный пример</target>
        </trans-unit>
        <trans-unit id="84d8b12a98abf233ce61b735b7f623dfa748d624" translate="yes" xml:space="preserve">
          <source>Later versions of Nim can be more precise about the borrowing rule with a syntax like:</source>
          <target state="translated">Более поздние версии Nim могут быть более точными в отношении правила заимствования с подобным синтаксисом:</target>
        </trans-unit>
        <trans-unit id="b84ad3bb11b5b72ae8064b2e03ac6593bfc14c79" translate="yes" xml:space="preserve">
          <source>Later versions of the language will weaken the requirements for forward declarations.</source>
          <target state="translated">Более поздние версии языка ослабят требования к форвардным объявлениям.</target>
        </trans-unit>
        <trans-unit id="b6e6ff1bcd7ed1a5e8f4c37ec0106d2e2587cae3" translate="yes" xml:space="preserve">
          <source>Lazy type resolution for untyped</source>
          <target state="translated">Ленивое типовое разрешение для нетипизированных</target>
        </trans-unit>
        <trans-unit id="a4f7fe013eb75f3bd7abaac6e67f4376f5da9c25" translate="yes" xml:space="preserve">
          <source>Leaf nodes/Atoms</source>
          <target state="translated">Листовые узлы/доны</target>
        </trans-unit>
        <trans-unit id="a6702a5291853b1308e7bd674d53f7e0975e6409" translate="yes" xml:space="preserve">
          <source>Left-Aligns a string &lt;em&gt;s&lt;/em&gt; with &lt;em&gt;padding&lt;/em&gt;, so that it is of length &lt;em&gt;count&lt;/em&gt;.</source>
          <target state="translated">Выравнивает по левому краю строку &lt;em&gt;s&lt;/em&gt; с &lt;em&gt;заполнением&lt;/em&gt; , чтобы длина была &lt;em&gt;count&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="581f4b8c009369b50e3d9ba5325d87417e6534b8" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 16-bits value.</source>
          <target state="translated">Биты левого вращения в 16-битном значении.</target>
        </trans-unit>
        <trans-unit id="d3409f80fea6038549fe1206956266f2e8a6fbb1" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 32-bits value.</source>
          <target state="translated">Биты левого вращения в 32-битном значении.</target>
        </trans-unit>
        <trans-unit id="0aef55ce888f5b32fb20afe0a6d757edd1ce8821" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 64-bits value.</source>
          <target state="translated">Биты левого вращения в 64-битном значении.</target>
        </trans-unit>
        <trans-unit id="73e3851ee7450c9ad9c84aa2c1e0ca99eeb3856b" translate="yes" xml:space="preserve">
          <source>Left-rotate bits in a 8-bits value.</source>
          <target state="translated">Биты левого вращения в 8-битном значении.</target>
        </trans-unit>
        <trans-unit id="08b05a7cc45a3cfbb0bd52f3553051c002b98ea9" translate="yes" xml:space="preserve">
          <source>Let section</source>
          <target state="translated">Раздел Пусть</target>
        </trans-unit>
        <trans-unit id="aa344992ab3c9cce0c812154c891a2082a0f43d5" translate="yes" xml:space="preserve">
          <source>Let us look at Nim's lexical elements in more detail: like other programming languages Nim consists of (string) literals, identifiers, keywords, comments, operators, and other punctuation marks.</source>
          <target state="translated">Рассмотрим лексические элементы Nim более подробно:как и другие языки программирования,Nim состоит из (строковых)литералов,идентификаторов,ключевых слов,комментариев,операторов и других знаков препинания.</target>
        </trans-unit>
        <trans-unit id="b472892cf2e180fd60510de81af55b7e2fd6e956" translate="yes" xml:space="preserve">
          <source>Let's return to the simple counting example:</source>
          <target state="translated">Вернемся к простому примеру подсчета:</target>
        </trans-unit>
        <trans-unit id="3714e6d8f0e24eacd7b52251a4d193e3636ffbc7" translate="yes" xml:space="preserve">
          <source>Let's start with an example: a procedure that finds the index of a character in a string.</source>
          <target state="translated">Начнем с примера:процедура,которая находит индекс символа в строке.</target>
        </trans-unit>
        <trans-unit id="1be636c6149d23a6ac7030b7b471d95740b30580" translate="yes" xml:space="preserve">
          <source>Let's take a look at a procedure with a lot of interesting aspects to get a feel for how procedure calls are broken down.</source>
          <target state="translated">Давайте рассмотрим процедуру с множеством интересных аспектов,чтобы понять,как разбиваются вызовы процедур.</target>
        </trans-unit>
        <trans-unit id="f090ebad1e9028f1098a5af4e5a797eb536bf181" translate="yes" xml:space="preserve">
          <source>Lets</source>
          <target state="translated">Lets</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="0948974278e3b95cbbb246e9eab8bec6da78b254" translate="yes" xml:space="preserve">
          <source>Lexical Analysis</source>
          <target state="translated">Лексический анализ</target>
        </trans-unit>
        <trans-unit id="484504bca1de9d78289cf5ed0ff59489797fb25f" translate="yes" xml:space="preserve">
          <source>Lexical elements</source>
          <target state="translated">лексические элементы</target>
        </trans-unit>
        <trans-unit id="fd70e598fcf927041c896f6dc4b87e917b2286bf" translate="yes" xml:space="preserve">
          <source>Library documentation</source>
          <target state="translated">Документация библиотеки</target>
        </trans-unit>
        <trans-unit id="850e532a72f1397362ed6c2e2c7768467301292f" translate="yes" xml:space="preserve">
          <source>Licence of the PCRE library</source>
          <target state="translated">Лицензия библиотеки PCRE</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="7babbd6a13612f2b75fad2536bf20e3a90be6f3a" translate="yes" xml:space="preserve">
          <source>Lifting Procs</source>
          <target state="translated">Подъемные приспособления</target>
        </trans-unit>
        <trans-unit id="133720a88f4f0b2480df1a722653e8f80be2609a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;exportc&lt;/code&gt; or &lt;code&gt;importc&lt;/code&gt;, the &lt;code&gt;extern&lt;/code&gt; pragma affects name mangling. The string literal passed to &lt;code&gt;extern&lt;/code&gt; can be a format string:</source>
          <target state="translated">Как и &lt;code&gt;exportc&lt;/code&gt; или &lt;code&gt;importc&lt;/code&gt; , прагма &lt;code&gt;extern&lt;/code&gt; влияет на изменение имени. Строковый литерал, переданный в &lt;code&gt;extern&lt;/code&gt; , может быть форматной строкой:</target>
        </trans-unit>
        <trans-unit id="a89c659521de912108568798c30a4d3b9390dd11" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;return&lt;/code&gt;, but with &lt;code&gt;nnkDiscardStmt&lt;/code&gt; kind.</source>
          <target state="translated">Вроде &lt;code&gt;return&lt;/code&gt; , но с видом &lt;code&gt;nnkDiscardStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70b76be5ae3e05bda0dbd20d90abcc0ff40f9de9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;return&lt;/code&gt;, but with &lt;code&gt;nnkYieldStmt&lt;/code&gt; kind.</source>
          <target state="translated">Вроде &lt;code&gt;return&lt;/code&gt; , но с видом &lt;code&gt;nnkYieldStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cf638ae85ebba4736e92856cb8c627ef275c96" translate="yes" xml:space="preserve">
          <source>Like a plain &lt;code&gt;import&lt;/code&gt; statement but with &lt;code&gt;nnkIncludeStmt&lt;/code&gt;.</source>
          <target state="translated">Как обычный оператор &lt;code&gt;import&lt;/code&gt; но с &lt;code&gt;nnkIncludeStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63a95e62d7c911dbac4f0639f9bb4cb823deae98" translate="yes" xml:space="preserve">
          <source>Like in many other programming languages, a &lt;code&gt;continue&lt;/code&gt; statement starts the next iteration immediately:</source>
          <target state="translated">Как и во многих других языках программирования, оператор &lt;code&gt;continue&lt;/code&gt; немедленно запускает следующую итерацию:</target>
        </trans-unit>
        <trans-unit id="35a4297befbf3cbceda9715d4684f55b9e927a9e" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;if&lt;/code&gt; statement, but the root has the kind &lt;code&gt;nnkWhenStmt&lt;/code&gt;.</source>
          <target state="translated">Подобно оператору &lt;code&gt;if&lt;/code&gt; , но корень имеет вид &lt;code&gt;nnkWhenStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab04aac5a7e1d598d2f186753e388a3731d77143" translate="yes" xml:space="preserve">
          <source>Like tuples, objects are a means to pack different values together in a structured way. However, objects provide many features that tuples do not: They provide inheritance and information hiding. Because objects encapsulate data, the &lt;code&gt;T()&lt;/code&gt; object constructor should only be used internally and the programmer should provide a proc to initialize the object (this is called a &lt;em&gt;constructor&lt;/em&gt;).</source>
          <target state="translated">Как и кортежи, объекты - это средство для структурированной упаковки различных значений. Однако объекты предоставляют множество функций, которых нет в кортежах: они обеспечивают наследование и скрытие информации. Поскольку объекты инкапсулируют данные, конструктор объекта &lt;code&gt;T()&lt;/code&gt; должен использоваться только внутри, а программист должен предоставить процедуру для инициализации объекта (это называется &lt;em&gt;конструктором&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="07bc01629a98c42a6a26d28d793349cd9ddcb413" translate="yes" xml:space="preserve">
          <source>Likewise &lt;code&gt;T = ref T&lt;/code&gt; is an invalid type.</source>
          <target state="translated">Аналогично, &lt;code&gt;T = ref T&lt;/code&gt; - недопустимый тип.</target>
        </trans-unit>
        <trans-unit id="012148b3c7c09fe4183a821ac0dfc3df94a4644a" translate="yes" xml:space="preserve">
          <source>Likewise for generic matches the most specialized generic type (that still matches) is preferred:</source>
          <target state="translated">Точно так же,для соответствия дженериков предпочтительным является наиболее специализированный дженериковый тип (который все еще совпадает):</target>
        </trans-unit>
        <trans-unit id="9fe316ffb5c502363f1602369491e5771962db68" translate="yes" xml:space="preserve">
          <source>Likewise the following does not make sense as the name is &lt;code&gt;strutils&lt;/code&gt; already:</source>
          <target state="translated">Точно так же следующее не имеет смысла, поскольку имя уже имеет &lt;code&gt;strutils&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="79cb6c70879ccadb6a188effd65c3c269014aee8" translate="yes" xml:space="preserve">
          <source>Limitations of the method call syntax</source>
          <target state="translated">Ограничения синтаксиса вызова методов</target>
        </trans-unit>
        <trans-unit id="7556b5753ea0ca8128d6f780d7fa036fc5b03486" translate="yes" xml:space="preserve">
          <source>Limitations/Bugs</source>
          <target state="translated">Limitations/Bugs</target>
        </trans-unit>
        <trans-unit id="81e5623d345118d762dbee1a0e1de32ed5723969" translate="yes" xml:space="preserve">
          <source>Limitations: If used within nim VM context &lt;code&gt;sizeof&lt;/code&gt; will only work for simple types.</source>
          <target state="translated">Ограничения: при использовании в контексте виртуальной машины nim &lt;code&gt;sizeof&lt;/code&gt; будет работать только для простых типов.</target>
        </trans-unit>
        <trans-unit id="4c46adaafc40b789df2ecf20dd985f671faba467" translate="yes" xml:space="preserve">
          <source>Line exceeds the maximum length.</source>
          <target state="translated">Линия превышает максимальную длину.</target>
        </trans-unit>
        <trans-unit id="223cc1feb0fa894d9ee9937b64e7b5859c71bc96" translate="yes" xml:space="preserve">
          <source>Line where the symbol is located in the file. Lines start to count at &lt;strong&gt;1&lt;/strong&gt;.</source>
          <target state="translated">Строка, в которой находится символ в файле. Линии начинают отсчет с &lt;strong&gt;1&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6975daf276430ee5b07e3f0247df76b80c98d27d" translate="yes" xml:space="preserve">
          <source>LineDir option</source>
          <target state="translated">Опция LineDir</target>
        </trans-unit>
        <trans-unit id="268d8379173ac37e106048c36fff01d9c9b4910e" translate="yes" xml:space="preserve">
          <source>LineTooLong</source>
          <target state="translated">LineTooLong</target>
        </trans-unit>
        <trans-unit id="064387f46f31232c3427cd5f69fac7318fd9f966" translate="yes" xml:space="preserve">
          <source>LineTrace option</source>
          <target state="translated">Опция LineTrace</target>
        </trans-unit>
        <trans-unit id="ac3679d78b17b02969cddb03c164e6e2d4dc3390" translate="yes" xml:space="preserve">
          <source>Lines should be no longer than 80 characters. Limiting the amount of information present on each line makes for more readable code - the reader has smaller chunks to process.</source>
          <target state="translated">Строки не должны превышать 80 символов.Ограничение количества информации,присутствующей на каждой строке,делает код более читабельным-читателю нужно обрабатывать меньшие куски.</target>
        </trans-unit>
        <trans-unit id="b0876c4bcec0ae3cbb0d666f7829f1981ec34562" translate="yes" xml:space="preserve">
          <source>Lines starting with &lt;code&gt;&amp;gt;&lt;/code&gt; indicate a command to be sent to the compiler and the lines following a command include checks for expected or forbidden output (&lt;code&gt;!&lt;/code&gt; for forbidden).</source>
          <target state="translated">Строки, начинающиеся с &lt;code&gt;&amp;gt;&lt;/code&gt; , указывают на команду, которая должна быть отправлена ​​компилятору, а строки, следующие за командой, включают проверки ожидаемого или запрещенного вывода ( &lt;code&gt;!&lt;/code&gt; Для запрещенного).</target>
        </trans-unit>
        <trans-unit id="d0517071aa376e797705058bbad4b658954b9930" translate="yes" xml:space="preserve">
          <source>Link</source>
          <target state="translated">Link</target>
        </trans-unit>
        <trans-unit id="1c3cb2684d19be6954dbbdc4f8e73df679e8e5d0" translate="yes" xml:space="preserve">
          <source>Link pragma</source>
          <target state="translated">Связать прагму</target>
        </trans-unit>
        <trans-unit id="9da74ab1a4b986bea87990a9a620e399e5636c76" translate="yes" xml:space="preserve">
          <source>Linking phase.</source>
          <target state="translated">Фаза связи.</target>
        </trans-unit>
        <trans-unit id="29298813156f944560ccc7706430702f6f4ee582" translate="yes" xml:space="preserve">
          <source>List comprehension, returns a sequence. &lt;em&gt;comp&lt;/em&gt; is the actual list comprehension, for example &lt;code&gt;x | (x &amp;lt;- 1..10, x mod 2 == 0)&lt;/code&gt;. &lt;em&gt;typ&lt;/em&gt; is the type that will be stored inside the result seq.</source>
          <target state="translated">Понимание списка, возвращает последовательность. &lt;em&gt;comp&lt;/em&gt; - это фактическое понимание списка, например &lt;code&gt;x | (x &amp;lt;- 1..10, x mod 2 == 0)&lt;/code&gt; . &lt;em&gt;тип&lt;/em&gt; - это тип, который будет сохранен внутри результата seq.</target>
        </trans-unit>
        <trans-unit id="f8243f1d71ba9600f36e4fd5c7ce82f383a50045" translate="yes" xml:space="preserve">
          <source>List of hints</source>
          <target state="translated">Список подсказок</target>
        </trans-unit>
        <trans-unit id="5516fee04290d8fb240eb1035f9649b7af9c46bc" translate="yes" xml:space="preserve">
          <source>List of warnings</source>
          <target state="translated">Список предупреждений</target>
        </trans-unit>
        <trans-unit id="104e72166267b2e14189f97dfc051685f78e0501" translate="yes" xml:space="preserve">
          <source>Lists all files in &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;dir&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, uses the current working directory.</source>
          <target state="translated">Список всех файлов в &lt;code&gt;dir&lt;/code&gt; . Если &lt;code&gt;dir&lt;/code&gt; равен &lt;code&gt;&quot;&quot;&lt;/code&gt; , используется текущий рабочий каталог.</target>
        </trans-unit>
        <trans-unit id="1ab878ae07a9cde029575d5b2c8f1f1831aa46a7" translate="yes" xml:space="preserve">
          <source>Lists all files in &lt;code&gt;dir&lt;/code&gt;. If &lt;code&gt;dir&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, uses the current working directory. If &lt;code&gt;async&lt;/code&gt; is true, this function will return immediately and it will be your job to call asyncio's &lt;code&gt;poll&lt;/code&gt; to progress this operation.</source>
          <target state="translated">Список всех файлов в &lt;code&gt;dir&lt;/code&gt; . Если &lt;code&gt;dir&lt;/code&gt; равен &lt;code&gt;&quot;&quot;&lt;/code&gt; , используется текущий рабочий каталог. Если &lt;code&gt;async&lt;/code&gt; истинно, эта функция немедленно вернется, и ваша задача - вызвать &lt;code&gt;poll&lt;/code&gt; asyncio для выполнения этой операции.</target>
        </trans-unit>
        <trans-unit id="236263cf5e9fb34d2dba2a5c051ef5dc5349c21d" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">Буквальный &lt;code&gt;&quot;&lt;/code&gt; и др.</target>
        </trans-unit>
        <trans-unit id="b0e13df3237422a975bbec14b9ac839dee36c914" translate="yes" xml:space="preserve">
          <source>Literal match: &lt;code&gt;a&lt;/code&gt; is an integer literal of value &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a signed or unsigned integer type and &lt;code&gt;v&lt;/code&gt; is in &lt;code&gt;f&lt;/code&gt;'s range. Or: &lt;code&gt;a&lt;/code&gt; is a floating point literal of value &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a floating point type and &lt;code&gt;v&lt;/code&gt; is in &lt;code&gt;f&lt;/code&gt;'s range.</source>
          <target state="translated">Буквенный матч: представляет собой целое литерал значения &lt;code&gt;v&lt;/code&gt; и &lt;code&gt;f&lt;/code&gt; является знаком или без знака целого числа , типа и &lt;code&gt;v&lt;/code&gt; в &lt;code&gt;f&lt;/code&gt; &amp;laquo;S Range. Или: является точкой буквального значения с плавающей из &lt;code&gt;v&lt;/code&gt; и &lt;code&gt;f&lt;/code&gt; представляет собой тип с плавающей точкой и &lt;code&gt;v&lt;/code&gt; в &lt;code&gt;f&lt;/code&gt; диапазоне &amp;laquo;ы. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9727a86e89a8cbd82800b60294dabca16499a86" translate="yes" xml:space="preserve">
          <source>Literals are bounds checked so that they fit the datatype. Non base-10 literals are used mainly for flags and bit pattern representations, therefore bounds checking is done on bit width, not value range. If the literal fits in the bit width of the datatype, it is accepted. Hence: 0b10000000'u8 == 0x80'u8 == 128, but, 0b10000000'i8 == 0x80'i8 == -1 instead of causing an overflow error.</source>
          <target state="translated">Буквы проверяются на соответствие типа данных.Небазовые 10 литералы используются в основном для представления флагов и битовых паттернов,поэтому проверка границ производится по ширине бита,а не по диапазону значений.Если литерал вписывается в ширину бита типа данных,то он принимается.Следовательно:0b10000000'u8 ==0x80'u8 ==128,но,0b10000000'i8 ==0x80'i8 ==-1 вместо того,чтобы вызвать ошибку переполнения.</target>
        </trans-unit>
        <trans-unit id="8b2a6eba528cf2e8ab33fb4a2bec0b163b834789" translate="yes" xml:space="preserve">
          <source>Literals are compile-time computable.</source>
          <target state="translated">Буквы вычисляются во время компиляции.</target>
        </trans-unit>
        <trans-unit id="de51bd63110c92754499c41c1b9fc0a1062026bc" translate="yes" xml:space="preserve">
          <source>Load the specified configuration file into a new Config instance.</source>
          <target state="translated">Загрузите указанный конфигурационный файл в новый экземпляр Config.</target>
        </trans-unit>
        <trans-unit id="1a9e1513745115068212c830b486292757f91900" translate="yes" xml:space="preserve">
          <source>Load the specified configuration from stream into a new Config instance. &lt;em&gt;filename&lt;/em&gt; parameter is only used for nicer error messages.</source>
          <target state="translated">Загрузите указанную конфигурацию из потока в новый экземпляр Config. Параметр &lt;em&gt;filename&lt;/em&gt; используется только для более удобных сообщений об ошибках.</target>
        </trans-unit>
        <trans-unit id="a139e4bbf5ca5504f1d17d1d98e927f4b59c9a47" translate="yes" xml:space="preserve">
          <source>Loading a simple C function</source>
          <target state="translated">Загрузка простой функции C</target>
        </trans-unit>
        <trans-unit id="d468cd435069219754afbbe7d097d97a919d76a4" translate="yes" xml:space="preserve">
          <source>Loads and parses HTML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">Нагрузки и разбирает HTML из файла , заданных по &lt;code&gt;path&lt;/code&gt; , и возвращает &lt;code&gt;XmlNode&lt;/code&gt; . Все ошибки синтаксического анализа игнорируются.</target>
        </trans-unit>
        <trans-unit id="e13175d1bc7af2e5d6755aeb721e7338069be90d" translate="yes" xml:space="preserve">
          <source>Loads and parses HTML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;em&gt;errors&lt;/em&gt; sequence.</source>
          <target state="translated">Нагрузки и разбирает HTML из файла , заданных по &lt;code&gt;path&lt;/code&gt; , и возвращает &lt;code&gt;XmlNode&lt;/code&gt; . Каждая произошедшая ошибка синтаксического анализа добавляется в последовательность &lt;em&gt;ошибок&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4296f849be147d08fdb9d341d2ab77c8da850fd7" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">Загружает и анализирует XML из файла, указанного по &lt;code&gt;path&lt;/code&gt; , и возвращает &lt;code&gt;PDocument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26e2e2e83d566103f2e7459a72bbf8e836f49d66" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a stream specified by &lt;code&gt;stream&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">Загружает и анализирует XML из потока, указанного &lt;code&gt;stream&lt;/code&gt; , и возвращает &lt;code&gt;PDocument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="045d13349b264d2eba76a0804c08fa59e6a17cff" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from a string specified by &lt;code&gt;xml&lt;/code&gt;, and returns a &lt;code&gt;PDocument&lt;/code&gt;</source>
          <target state="translated">Загружает и анализирует XML из строки, заданной &lt;code&gt;xml&lt;/code&gt; , и возвращает &lt;code&gt;PDocument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f9e01e6b541364451c7b06cd42daa257c56a015" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are turned into an &lt;code&gt;XmlError&lt;/code&gt; exception.</source>
          <target state="translated">Загружает и анализирует XML из файла, указанного в &lt;code&gt;path&lt;/code&gt; , и возвращает &lt;code&gt;XmlNode&lt;/code&gt; . Все ошибки синтаксического анализа превращаются в исключение &lt;code&gt;XmlError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58715b2c04bf6ee07528232196803acf3ddcf9e8" translate="yes" xml:space="preserve">
          <source>Loads and parses XML from file specified by &lt;code&gt;path&lt;/code&gt;, and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;code&gt;errors&lt;/code&gt; sequence.</source>
          <target state="translated">Загружает и анализирует XML из файла, указанного в &lt;code&gt;path&lt;/code&gt; , и возвращает &lt;code&gt;XmlNode&lt;/code&gt; . Каждая произошедшая ошибка синтаксического анализа добавляется в последовательность &lt;code&gt;errors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7db461111deca6d0f8236779f0bb1263494a8e8" translate="yes" xml:space="preserve">
          <source>Lock levels</source>
          <target state="translated">Уровни блокировки</target>
        </trans-unit>
        <trans-unit id="98f1e767de995c2aa21fe38394145cda4db0f95d" translate="yes" xml:space="preserve">
          <source>Lock levels are used to enforce a global locking order in order to prevent deadlocks at compile-time. A lock level is an constant integer in the range 0..1_000. Lock level 0 means that no lock is acquired at all.</source>
          <target state="translated">Уровни блокировки используются для обеспечения соблюдения глобального порядка блокировки,чтобы предотвратить возникновение тупиковых ситуаций во время компиляции.Уровень блокировки-это постоянное целое число в диапазоне 0...1_000.Уровень блокировки 0 означает,что блокировка не приобретается вообще.</target>
        </trans-unit>
        <trans-unit id="a026b72d4824601afcdf130fca670d0c8d13f97d" translate="yes" xml:space="preserve">
          <source>Locks and routines can be annotated with &lt;span id=&quot;lock-levels_1&quot;&gt;lock levels&lt;/span&gt; to prevent deadlocks at compile time.</source>
          <target state="translated">Блокировки и подпрограммы могут быть аннотированы &lt;span id=&quot;lock-levels_1&quot;&gt;уровнями блокировки&lt;/span&gt; для предотвращения взаимоблокировок во время компиляции.</target>
        </trans-unit>
        <trans-unit id="8e5c380132554658df14cbe018d3eebcce0b49de" translate="yes" xml:space="preserve">
          <source>Logs a debug message to all registered handlers.</source>
          <target state="translated">Регистрирует отладочное сообщение для всех зарегистрированных обработчиков.</target>
        </trans-unit>
        <trans-unit id="4c7f919536de93b8ad43c3247437839e50803cac" translate="yes" xml:space="preserve">
          <source>Logs a fatal error message to all registered handlers.</source>
          <target state="translated">Регистрирует сообщение о фатальной ошибке для всех зарегистрированных обработчиков.</target>
        </trans-unit>
        <trans-unit id="5dfc8bdbe4c51442cb3331391bf133dae2303823" translate="yes" xml:space="preserve">
          <source>Logs a message to all registered handlers at the given level.</source>
          <target state="translated">Регистрирует сообщение для всех зарегистрированных обработчиков данного уровня.</target>
        </trans-unit>
        <trans-unit id="57d8e0636873737f16f4b7cc780f237140e75837" translate="yes" xml:space="preserve">
          <source>Logs a warning message to all registered handlers.</source>
          <target state="translated">Регистрирует предупреждающее сообщение для всех зарегистрированных обработчиков.</target>
        </trans-unit>
        <trans-unit id="9317adaad7621328486bdf8c1ddb1b9fc41f1e55" translate="yes" xml:space="preserve">
          <source>Logs an error message to all registered handlers.</source>
          <target state="translated">Регистрирует сообщение об ошибке для всех зарегистрированных обработчиков.</target>
        </trans-unit>
        <trans-unit id="4b60a8dc51101a47288a87fdd0bfadc5f86cbf8e" translate="yes" xml:space="preserve">
          <source>Logs an info message to all registered handlers.</source>
          <target state="translated">Регистрирует информационное сообщение для всех зарегистрированных обработчиков.</target>
        </trans-unit>
        <trans-unit id="d163792610c410f93f355f367ec68f39a5ba2888" translate="yes" xml:space="preserve">
          <source>Logs an notice message to all registered handlers.</source>
          <target state="translated">Регистрирует сообщение об уведомлении для всех зарегистрированных обработчиков.</target>
        </trans-unit>
        <trans-unit id="968b9d0e2a2ece8aa91b1cc23a28091c21b0a82f" translate="yes" xml:space="preserve">
          <source>Logs to a file using &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">Записывает в файл только с помощью &lt;code&gt;logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a9ec4044346457b95a04e72c6feb17b0ce890ff" translate="yes" xml:space="preserve">
          <source>Logs to a file using rolling &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">Регистрирует в файл только с помощью скользящего &lt;code&gt;logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50128c469a86270a2da91f8b00b431458f68392b" translate="yes" xml:space="preserve">
          <source>Logs to the console using &lt;code&gt;logger&lt;/code&gt; only.</source>
          <target state="translated">Регистрируется в консоли только с помощью &lt;code&gt;logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8ee53aa3b26fe91c5819ca15b134a56f645ac1e" translate="yes" xml:space="preserve">
          <source>Lookup rules for template parameters</source>
          <target state="translated">Правила поиска параметров шаблона</target>
        </trans-unit>
        <trans-unit id="ce44bf0dea95522d8571be7ae1c1bf020f1c61c5" translate="yes" xml:space="preserve">
          <source>Loopback address.</source>
          <target state="translated">Адрес обратного шлейфа.</target>
        </trans-unit>
        <trans-unit id="ed3b229a877674fc9085bfff9aad369487b7967d" translate="yes" xml:space="preserve">
          <source>Lossless &lt;span id=&quot;automatic-type-conversion_1&quot;&gt;Automatic type conversion&lt;/span&gt; is performed in expressions where different kinds of integer types are used. However, if the type conversion would cause loss of information, the &lt;span id=&quot;eoutofrange_1&quot;&gt;EOutOfRange&lt;/span&gt; exception is raised (if the error cannot be detected at compile time).</source>
          <target state="translated">&lt;span id=&quot;automatic-type-conversion_1&quot;&gt;Автоматическое преобразование типов&lt;/span&gt; без потерь выполняется в выражениях, в которых используются различные типы целочисленных типов. Однако, если преобразование типа приведет к потере информации, &lt;span id=&quot;eoutofrange_1&quot;&gt;возникает&lt;/span&gt; исключение &lt;span id=&quot;eoutofrange_1&quot;&gt;EOutOfRange&lt;/span&gt; (если ошибка не может быть обнаружена во время компиляции).</target>
        </trans-unit>
        <trans-unit id="5ca6f7c7b2f3fcead3d5cf315885d15734fca9dc" translate="yes" xml:space="preserve">
          <source>Lots of other small issues...</source>
          <target state="translated">Множество других мелких вопросов...</target>
        </trans-unit>
        <trans-unit id="b8a68b12b71fd0a8e62d67043581d497f4e0c387" translate="yes" xml:space="preserve">
          <source>Macro declaration</source>
          <target state="translated">Макродекларация</target>
        </trans-unit>
        <trans-unit id="d5f312834ff09b9cbab1f1a3ebc0bbe0f1a19b93" translate="yes" xml:space="preserve">
          <source>Macro which converts normal procedures into javascript-compatible async procedures</source>
          <target state="translated">Макро,который преобразует обычные процедуры в асинхронные процедуры,совместимые с JavaScript.</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="bcf4850e55a2614c2efa81a2629e41ec19afef8b" translate="yes" xml:space="preserve">
          <source>Macros as pragmas</source>
          <target state="translated">Макрос прагмы</target>
        </trans-unit>
        <trans-unit id="980cf51d761ff2e575f35b48bf655118288e07f9" translate="yes" xml:space="preserve">
          <source>Macros behave like templates, but &lt;code&gt;nnkTemplateDef&lt;/code&gt; is replaced with &lt;code&gt;nnkMacroDef&lt;/code&gt;.</source>
          <target state="translated">Макросы ведут себя как шаблоны, но &lt;code&gt;nnkTemplateDef&lt;/code&gt; заменяется на &lt;code&gt;nnkMacroDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fabe264274a80515010384b77dc0559e962ca19d" translate="yes" xml:space="preserve">
          <source>Macros enable advanced compile-time code transformations, but they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway. Macros have to be implemented in pure Nim code if the &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;foreign function interface (FFI)&lt;/a&gt; is not enabled in the compiler, but other than that restriction (which at some point in the future will go away) you can write any kind of Nim code and the compiler will run it at compile time.</source>
          <target state="translated">Макросы позволяют расширенные преобразования кода во время компиляции, но они не могут изменить синтаксис Nim. Однако это не настоящее ограничение, потому что синтаксис Nim в любом случае достаточно гибкий. Макросы должны быть реализованы в чистом коде Nim, если &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;интерфейс внешних функций (FFI)&lt;/a&gt; не включен в компиляторе, но кроме этого ограничения (которое в какой-то момент в будущем исчезнет) вы можете написать любой код Nim и компилятор запустит его во время компиляции.</target>
        </trans-unit>
        <trans-unit id="4316199fa5a1551b8a3aa00b57acfb7552982193" translate="yes" xml:space="preserve">
          <source>Macros module includes helpers which can be used to simplify custom pragma access &lt;em&gt;hasCustomPragma&lt;/em&gt;, &lt;em&gt;getCustomPragmaVal&lt;/em&gt;. Please consult macros module documentation for details. These macros are no magic, they don't do anything you cannot do yourself by walking AST object representation.</source>
          <target state="translated">Модуль макросов включает помощники, которые можно использовать для упрощения доступа к пользовательской &lt;em&gt;прагме hasCustomPragma&lt;/em&gt; , &lt;em&gt;getCustomPragmaVal&lt;/em&gt; . За подробностями обращайтесь к документации модуля макросов. Эти макросы не являются волшебством, они не делают того, что вы не можете сделать самостоятельно, просматривая представление объекта AST.</target>
        </trans-unit>
        <trans-unit id="fcb1a29368fba3810f040b19c708029e63713744" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;osproc&lt;/code&gt; use &lt;code&gt;fork&lt;/code&gt; instead of &lt;code&gt;posix_spawn&lt;/code&gt;.</source>
          <target state="translated">Заставляет &lt;code&gt;osproc&lt;/code&gt; использовать &lt;code&gt;fork&lt;/code&gt; вместо &lt;code&gt;posix_spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c651f2d69bb1c5e0aa5eb7b1418517d939a6973" translate="yes" xml:space="preserve">
          <source>Makes Nim output stacktraces to stdout, instead of server log.</source>
          <target state="translated">Заставляет Nim выводить стековые трассы в stdout,а не в лог сервера.</target>
        </trans-unit>
        <trans-unit id="499d78e3579f7c7ce46ccd08c0c7e05dcf497fe4" translate="yes" xml:space="preserve">
          <source>Makes Nim output stacktraces to stdout, instead of server log. Depracated alias for setStackTraceStdout.</source>
          <target state="translated">Заставляет Nim выводить стековые трассы в stdout,а не в лог сервера.Развернутый псевдоним для setStackTraceStdout.</target>
        </trans-unit>
        <trans-unit id="2e3d974a9298c4b4ebf6fa1f9cde4cea6a610923" translate="yes" xml:space="preserve">
          <source>Makes Nim use C's &lt;span id=&quot;malloc_1&quot;&gt;malloc&lt;/span&gt; instead of Nim's own memory manager, ableit prefixing each allocation with its size to support clearing memory on reallocation. This only works with &lt;code&gt;gc:none&lt;/code&gt;.</source>
          <target state="translated">Заставляет Nim использовать &lt;span id=&quot;malloc_1&quot;&gt;malloc&lt;/span&gt; C вместо собственного менеджера памяти Nim, позволяя добавлять префикс каждого выделения с его размером для поддержки очистки памяти при перераспределении. Это работает только с &lt;code&gt;gc:none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c24f6fa722204e68ea302ade8ca94caa0a75902" translate="yes" xml:space="preserve">
          <source>Mandatory term being indexed. Terms can include quoting according to Nim's rules (eg. `^`).</source>
          <target state="translated">Обязательный термин индексируется.Термины могут включать в себя цитирование в соответствии с правилами Ним (например,^``).</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="8b04fd7fca9bde6ca081d5a883719b86d91603ee" translate="yes" xml:space="preserve">
          <source>Manual: AST based overloading</source>
          <target state="translated">Руководство:перегрузка на основе АСТ</target>
        </trans-unit>
        <trans-unit id="defb0de64fe7ca08a6ed982374de4bb9a85c2662" translate="yes" xml:space="preserve">
          <source>Manual: Effect system</source>
          <target state="translated">Руководство:Эффектная система</target>
        </trans-unit>
        <trans-unit id="c96afc4df608947a129115509fc6ac1d02f56202" translate="yes" xml:space="preserve">
          <source>Manual: Exception handling</source>
          <target state="translated">Руководство:Обработка исключений</target>
        </trans-unit>
        <trans-unit id="ddfc1de56c3bd1d03afdd4142362226685aca4b2" translate="yes" xml:space="preserve">
          <source>Manual: Foreign function interface</source>
          <target state="translated">Руководство:Внешний интерфейс функции</target>
        </trans-unit>
        <trans-unit id="e56aa0932cbe0a4d0a9778061468fdfecc37f816" translate="yes" xml:space="preserve">
          <source>Manual: Generics</source>
          <target state="translated">Руководство:Дженерики</target>
        </trans-unit>
        <trans-unit id="5774a3094051cc1a01178d4abbdf9174054d2afa" translate="yes" xml:space="preserve">
          <source>Manual: Guards and locks</source>
          <target state="translated">Руководство:Охрана и замки</target>
        </trans-unit>
        <trans-unit id="034ba2f8aa22d8c1659925669461f5c6bb46d48d" translate="yes" xml:space="preserve">
          <source>Manual: Implementation Specific Pragmas</source>
          <target state="translated">Руководство:Реализация Конкретные прагмы</target>
        </trans-unit>
        <trans-unit id="5b04a062ff7cc9d86ce05472065106035a8097fa" translate="yes" xml:space="preserve">
          <source>Manual: Import statement Include statement Module names in imports Collective imports from a directory Pseudo import/include paths From import statement Export statement</source>
          <target state="translated">Руководство:Импорт отчёта Импорт отчёта Включить имена модулей в импорт Коллективный импорт из каталога Псевдо-импорт/включить пути Из отчёта об импорте Отчёт об импорте Отчёт об экспорте</target>
        </trans-unit>
        <trans-unit id="fd76cbedf6737eb16d94623f5ae0365ae0d604f1" translate="yes" xml:space="preserve">
          <source>Manual: Iterators and the for statement</source>
          <target state="translated">Руководство:Итераторы и для заявления</target>
        </trans-unit>
        <trans-unit id="a243b6fe56c421c23e6ef513dd30b788f1257a68" translate="yes" xml:space="preserve">
          <source>Manual: Lexical Analysis</source>
          <target state="translated">Руководство:Лексический анализ</target>
        </trans-unit>
        <trans-unit id="ed3d84a9118355ed8740c1a7b3f3b4c841535124" translate="yes" xml:space="preserve">
          <source>Manual: Macros</source>
          <target state="translated">Руководство:Макросы</target>
        </trans-unit>
        <trans-unit id="4bafc4dbfa5c0e3c58d2fb274d692bbf25d243fc" translate="yes" xml:space="preserve">
          <source>Manual: Modules</source>
          <target state="translated">Руководство:Модули</target>
        </trans-unit>
        <trans-unit id="9a290e826830f6686d0f05fcc67ab7c270d95dbb" translate="yes" xml:space="preserve">
          <source>Manual: Multi-methods</source>
          <target state="translated">Руководство:Мультиметоды</target>
        </trans-unit>
        <trans-unit id="11714535fa66e7fe2732c23bbc152d68d14f704d" translate="yes" xml:space="preserve">
          <source>Manual: Overloading resolution</source>
          <target state="translated">Руководство:Разрешение перегрузки</target>
        </trans-unit>
        <trans-unit id="856ff8f109b24f9933255ac3581aadee568cd2dc" translate="yes" xml:space="preserve">
          <source>Manual: Parallel &amp;amp; Spawn</source>
          <target state="translated">Руководство: Параллельный и Спаун</target>
        </trans-unit>
        <trans-unit id="7ec22936b55b7f305c2be8dba10aa5109567b287" translate="yes" xml:space="preserve">
          <source>Manual: Pragmas</source>
          <target state="translated">Руководство:Прагмы</target>
        </trans-unit>
        <trans-unit id="770e4cc3468cd2ab34e2292349c2fc7f1254bba1" translate="yes" xml:space="preserve">
          <source>Manual: Procedures</source>
          <target state="translated">Руководство:Процедуры</target>
        </trans-unit>
        <trans-unit id="1b494587e353e28a4fb14cede5251f048106d63a" translate="yes" xml:space="preserve">
          <source>Manual: Special Operators</source>
          <target state="translated">Руководство:Специальные операторы</target>
        </trans-unit>
        <trans-unit id="67456811ead6b001268c25ae75d8eb80bf9b78d4" translate="yes" xml:space="preserve">
          <source>Manual: Special Types</source>
          <target state="translated">Руководство:Специальные типы</target>
        </trans-unit>
        <trans-unit id="6decf7713585353b542d22a07833a9e3f4608374" translate="yes" xml:space="preserve">
          <source>Manual: Statements and expressions</source>
          <target state="translated">Руководство:Выражения и выражения</target>
        </trans-unit>
        <trans-unit id="c06b311819398e9a7a08be8caed1736017ac7522" translate="yes" xml:space="preserve">
          <source>Manual: Syntax</source>
          <target state="translated">Руководство:Синтаксис</target>
        </trans-unit>
        <trans-unit id="bacd5ce7b4fc6c233337b20743738357eb3d4917" translate="yes" xml:space="preserve">
          <source>Manual: Templates</source>
          <target state="translated">Руководство:Шаблоны</target>
        </trans-unit>
        <trans-unit id="817f3b64b7fab30fc4fa2987f47b2de7d799191c" translate="yes" xml:space="preserve">
          <source>Manual: Term rewriting macros</source>
          <target state="translated">Руководство:Макросы переписывания терминов</target>
        </trans-unit>
        <trans-unit id="cbe3bd9f8e9a36414594a7b27bafcc1a597a3da5" translate="yes" xml:space="preserve">
          <source>Manual: Threads</source>
          <target state="translated">Руководство:Нитки</target>
        </trans-unit>
        <trans-unit id="aafb451a891596fbad0f0184b0ad302e74ebffc7" translate="yes" xml:space="preserve">
          <source>Manual: Type bound operations</source>
          <target state="translated">Руководство:Операции по привязке к типу</target>
        </trans-unit>
        <trans-unit id="166a47f26935d8e4d08a27d4c17c4e1d1999f722" translate="yes" xml:space="preserve">
          <source>Manual: Type relations</source>
          <target state="translated">Руководство:Типовые отношения</target>
        </trans-unit>
        <trans-unit id="bd029877fffa549daa894766df47948479afd2f1" translate="yes" xml:space="preserve">
          <source>Manual: Types</source>
          <target state="translated">Руководство:Типы</target>
        </trans-unit>
        <trans-unit id="2a1633f65bbc398d71c3ebfc3241c0af807273d5" translate="yes" xml:space="preserve">
          <source>Mark the test as skipped. Should be used directly in case when it is not possible to perform test for reasons depending on outer environment, or certain application logic conditions or configurations. The test code is still executed.</source>
          <target state="translated">Отметьте тест как пропущенный.Следует использовать непосредственно в случае невозможности выполнения теста по причинам,зависящим от внешней среды или определенных логических условий или конфигураций приложения.Тестовый код все равно выполняется.</target>
        </trans-unit>
        <trans-unit id="1d3b7aa9b4c642f5735f40da06dfed06fbca163e" translate="yes" xml:space="preserve">
          <source>Marks &lt;code&gt;socket&lt;/code&gt; as accepting connections. &lt;code&gt;Backlog&lt;/code&gt; specifies the maximum length of the queue of pending connections.</source>
          <target state="translated">Помечает &lt;code&gt;socket&lt;/code&gt; как принимающий соединения. &lt;code&gt;Backlog&lt;/code&gt; указывает максимальную длину очереди ожидающих подключений.</target>
        </trans-unit>
        <trans-unit id="f07f226b4437e06fea4e70beb870cd20dccb2b33" translate="yes" xml:space="preserve">
          <source>Matches a binary integer. This uses &lt;code&gt;parseutils.parseBin&lt;/code&gt;.</source>
          <target state="translated">Соответствует двоичному целому числу. Это использует &lt;code&gt;parseutils.parseBin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61f72fda5d63c33af385805c251186ac41827a95" translate="yes" xml:space="preserve">
          <source>Matches a character set</source>
          <target state="translated">Совпадает с набором персонажей</target>
        </trans-unit>
        <trans-unit id="7c21df5bb89686108056b549eda7fc196d394426" translate="yes" xml:space="preserve">
          <source>Matches a decimal integer. This uses &lt;code&gt;parseutils.parseInt&lt;/code&gt;.</source>
          <target state="translated">Соответствует десятичному целому числу. Это использует &lt;code&gt;parseutils.parseInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a12cb4b049a1da7e03f068b60b69ca0670549bfd" translate="yes" xml:space="preserve">
          <source>Matches a floating pointer number. Uses &lt;code&gt;parseFloat&lt;/code&gt;.</source>
          <target state="translated">Соответствует числу с плавающим указателем. Использует &lt;code&gt;parseFloat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2464cd36660069f3fcf2e58ee0a418607e32a9bc" translate="yes" xml:space="preserve">
          <source>Matches a hex integer. This uses &lt;code&gt;parseutils.parseHex&lt;/code&gt;.</source>
          <target state="translated">Соответствует шестнадцатеричному целому числу. Это использует &lt;code&gt;parseutils.parseHex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="532fa54ee42246846545dbf2fc331f03ad0daeed" translate="yes" xml:space="preserve">
          <source>Matches a single character</source>
          <target state="translated">Совпадает с одним персонажем</target>
        </trans-unit>
        <trans-unit id="e01edc99d3df652b0b10d0cd88889a4c6db28db5" translate="yes" xml:space="preserve">
          <source>Matches a single dollar sign.</source>
          <target state="translated">Совпадает с одним знаком доллара.</target>
        </trans-unit>
        <trans-unit id="56b8550638d15898163432e2ef863037d24cf3ab" translate="yes" xml:space="preserve">
          <source>Matches a string</source>
          <target state="translated">Совпадает со струной</target>
        </trans-unit>
        <trans-unit id="2b0f27dc90ddd03570b6691c4598abffade1d014" translate="yes" xml:space="preserve">
          <source>Matches an ASCII identifier: &lt;code&gt;[A-Z-a-z_][A-Za-z_0-9]*&lt;/code&gt;.</source>
          <target state="translated">Соответствует идентификатору ASCII: &lt;code&gt;[A-Z-a-z_][A-Za-z_0-9]*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f19ab90d0dfde58576111f53aea6162591341ee" translate="yes" xml:space="preserve">
          <source>Matches an octal integer. This uses &lt;code&gt;parseutils.parseOct&lt;/code&gt;.</source>
          <target state="translated">Соответствует восьмеричному целому числу. Это использует &lt;code&gt;parseutils.parseOct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8507509e46ea139d748c7c784f7cdc32a09d48f7" translate="yes" xml:space="preserve">
          <source>Matches if the end of the input string has been reached.</source>
          <target state="translated">Совпадает,если достигнут конец входной строки.</target>
        </trans-unit>
        <trans-unit id="44e83eb14a6d865158691b6ead9b69eedf905cb4" translate="yes" xml:space="preserve">
          <source>Matches until the token following the &lt;code&gt;$*&lt;/code&gt; was found. The match is allowed to be of 0 length.</source>
          <target state="translated">Соответствует до тех пор, пока не будет найден токен, следующий за &lt;code&gt;$*&lt;/code&gt; . Матч может быть нулевой длины.</target>
        </trans-unit>
        <trans-unit id="548a91d3213ffddd1a11e82050c55439466aaf2f" translate="yes" xml:space="preserve">
          <source>Matches until the token following the &lt;code&gt;$+&lt;/code&gt; was found. The match must consist of at least one char.</source>
          <target state="translated">Соответствует до тех пор, пока не будет найден токен, следующий за &lt;code&gt;$+&lt;/code&gt; . Матч должен состоять как минимум из одного символа.</target>
        </trans-unit>
        <trans-unit id="ac458e6963c6ebdd9c5ca1f8b279a9eb42dfc913" translate="yes" xml:space="preserve">
          <source>Math libraries</source>
          <target state="translated">математические библиотеки</target>
        </trans-unit>
        <trans-unit id="6e4c4838bcc55297c563147e236843926c319da6" translate="yes" xml:space="preserve">
          <source>Max line length is 80 characters.</source>
          <target state="translated">Максимальная длина строки 80 символов.</target>
        </trans-unit>
        <trans-unit id="353de93dd15ff6db8a4b838f009f42da8fc085cc" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent for 32-bit floating-point numbers.</source>
          <target state="translated">Максимальный (положительный)экспонент для 32-битных чисел с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="1d2ac0d1ca31ee91cf5ff6056f9a16027dd8fd2a" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent for 64-bit floating-point numbers.</source>
          <target state="translated">Максимальный (положительный)экспонент для 64-битных чисел с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="8bbd4cef55a64a4e58be3f1e60ec750e94d7d807" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent in base 10 for 32-bit floating-point numbers.</source>
          <target state="translated">Максимальный (положительный)экспонент в базе 10 для 32-битных чисел с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="50184f5eb64ad277177d238e645f028ed1a230ab" translate="yes" xml:space="preserve">
          <source>Maximum (positive) exponent in base 10 for 64-bit floating-point numbers.</source>
          <target state="translated">Максимальный (положительный)экспонент в базе 10 для 64-битных чисел с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="ed71d9f1d146dd9fd80c9fea6cf2280768a6a052" translate="yes" xml:space="preserve">
          <source>Maybe you didn't notice, but in the &lt;code&gt;dumpTree&lt;/code&gt; example the first constant explicitly specifies the type of the constant. That's why in the tree output the two last constants have their second child &lt;code&gt;Empty&lt;/code&gt; but the first has a string identifier. So basically a &lt;code&gt;const&lt;/code&gt; definition is made up from an identifier, optionally a type (can be an &lt;em&gt;empty&lt;/em&gt; node) and the value. Armed with this knowledge, let's look at the finished version of the AST building macro:</source>
          <target state="translated">Возможно, вы не заметили, но в примере &lt;code&gt;dumpTree&lt;/code&gt; первая константа явно указывает тип константы. Вот почему в выводе дерева две последние константы имеют второй дочерний элемент &lt;code&gt;Empty&lt;/code&gt; , но первая имеет строковый идентификатор. Таким образом, в основном определение &lt;code&gt;const&lt;/code&gt; состоит из идентификатора, необязательно типа (может быть &lt;em&gt;пустой&lt;/em&gt; узел) и значения. Вооружившись этими знаниями, давайте посмотрим на готовую версию макроса построения AST:</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="1c5536b98ab016fe61807564b4a34c80211a7613" translate="yes" xml:space="preserve">
          <source>Memory management</source>
          <target state="translated">Управление памятью</target>
        </trans-unit>
        <trans-unit id="9baa9878dfbef1d35fc905168a10b0c4a8c0fbd9" translate="yes" xml:space="preserve">
          <source>Memory safety for returning by &lt;code&gt;var T&lt;/code&gt; is ensured by a simple borrowing rule: If &lt;code&gt;result&lt;/code&gt; does not refer to a location pointing to the heap (that is in &lt;code&gt;result = X&lt;/code&gt; the &lt;code&gt;X&lt;/code&gt; involves a &lt;code&gt;ptr&lt;/code&gt; or &lt;code&gt;ref&lt;/code&gt; access) then it has to be deviated by the routine's first parameter:</source>
          <target state="translated">Безопасность памяти для возвращения на &lt;code&gt;var T&lt;/code&gt; обеспечивается простым правилом заимствования: Если &lt;code&gt;result&lt;/code&gt; не относится к месту расположения , указывающей на куче (то есть в &lt;code&gt;result = X&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; включает в &lt;code&gt;ptr&lt;/code&gt; или &lt;code&gt;ref&lt;/code&gt; доступ) , то он должен быть отклонилась первый параметр процедуры:</target>
        </trans-unit>
        <trans-unit id="50ff34431595cf400d81245be2a86a83f82386dd" translate="yes" xml:space="preserve">
          <source>Merges all index files in &lt;em&gt;dir&lt;/em&gt; and returns the generated index as HTML.</source>
          <target state="translated">Объединяет все индексные файлы в &lt;em&gt;директории&lt;/em&gt; и возвращает сгенерированный индекс , как HTML.</target>
        </trans-unit>
        <trans-unit id="c08446305ac72d52aeff6051e72faf9d7787f9fc" translate="yes" xml:space="preserve">
          <source>Merges all separated TextNodes together, and removes any empty TextNodes</source>
          <target state="translated">Соединяет все разделенные TextNodes вместе и удаляет все пустые TextNodes.</target>
        </trans-unit>
        <trans-unit id="33ef168ac38cdf5d66a3f96ccc53c0bcb2bec97c" translate="yes" xml:space="preserve">
          <source>Messages that are generated during the normal operation of an application and are of no particular importance. Useful to aggregate for potential later analysis.</source>
          <target state="translated">Сообщения,которые генерируются во время нормальной работы приложения и не имеют особого значения.Полезны для агрегирования с целью последующего анализа.</target>
        </trans-unit>
        <trans-unit id="949ba2d44e279ebf601f54248d567bd067f76669" translate="yes" xml:space="preserve">
          <source>Messages that are useful to the application developer only and are usually turned off in release.</source>
          <target state="translated">Сообщения,которые полезны только разработчику приложения и обычно отключаются в выпуске.</target>
        </trans-unit>
        <trans-unit id="de329f9988dc07ac218d31798f3d3fb0e319aeeb" translate="yes" xml:space="preserve">
          <source>Method call syntax</source>
          <target state="translated">Синтаксис вызова метода</target>
        </trans-unit>
        <trans-unit id="b768cedc4687283126d9b1ed420f777b12a98828" translate="yes" xml:space="preserve">
          <source>Method dispatchers are global.</source>
          <target state="translated">Методические диспетчеры являются глобальными.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="3c397a7933a859382d85ab67743d94fecb8793cf" translate="yes" xml:space="preserve">
          <source>Methods and type converters</source>
          <target state="translated">Методы и преобразователи типа</target>
        </trans-unit>
        <trans-unit id="70972ae112e939ad343653a1ba078194eea37b73" translate="yes" xml:space="preserve">
          <source>Methods imply &lt;a href=&quot;tut2#dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt; and idetools performs a static analysis on the code. For this reason idetools may not return the definition of the correct method you are querying because it may be impossible to know until the code is executed. It will try to return the method which covers the most possible cases (i.e. for variations of different classes in a hierarchy it will prefer methods using the base class).</source>
          <target state="translated">Методы подразумевают &lt;a href=&quot;tut2#dynamic-dispatch&quot;&gt;динамическую отправку,&lt;/a&gt; а idetools выполняет статический анализ кода. По этой причине idetools может не возвращать определение правильного метода, который вы запрашиваете, потому что это может быть невозможно узнать, пока код не будет выполнен. Он попытается вернуть метод, который охватывает наиболее возможные случаи (т.е. для вариантов различных классов в иерархии он предпочтет методы, использующие базовый класс).</target>
        </trans-unit>
        <trans-unit id="53abbdb21e81e3f2df2cf14c89d5b6dbabdbe501" translate="yes" xml:space="preserve">
          <source>Microseconds display</source>
          <target state="translated">Микросекундный дисплей</target>
        </trans-unit>
        <trans-unit id="71a3c685e2a1c832e7011ccdc9b0d684ec6c5b11" translate="yes" xml:space="preserve">
          <source>Milliseconds display</source>
          <target state="translated">Миллисекундный дисплей</target>
        </trans-unit>
        <trans-unit id="f0ba6bd90de6cbdc1ad731d5daa371ecb83efe18" translate="yes" xml:space="preserve">
          <source>Minimal output level for the compiler.</source>
          <target state="translated">Минимальный выходной уровень для компилятора.</target>
        </trans-unit>
        <trans-unit id="011feb85fd840211ebe3cbea6d10c757384f0950" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent for 32-bit floating-point numbers.</source>
          <target state="translated">Минимальный (отрицательный)экспонент для 32-битных чисел с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="a6a8707c6b54291fbf3e81a23b30ec1365b0f17e" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent for 64-bit floating-point numbers.</source>
          <target state="translated">Минимальный (отрицательный)экспонент для 64-битных чисел с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="c80cc0223dc92abbd631516781aea6a70a2336ee" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent in base 10 for 32-bit floating-point numbers.</source>
          <target state="translated">Минимальный (отрицательный)экспонент в базе 10 для 32-битных чисел с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="8c0da4d03317d4bba985f6d156cd17b8a1e9fe83" translate="yes" xml:space="preserve">
          <source>Minimum (negative) exponent in base 10 for 64-bit floating-point numbers.</source>
          <target state="translated">Минимальный (отрицательный)экспонент в базе 10 для 64-битных чисел с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="fde8fd6d013071c5b0da03141012d8c86a59338b" translate="yes" xml:space="preserve">
          <source>Mixin statement</source>
          <target state="translated">Миксовое заявление</target>
        </trans-unit>
        <trans-unit id="54a58f4d81597ea468c275c465f53b922146c355" translate="yes" xml:space="preserve">
          <source>Mixing parameters that should use the &lt;code&gt;using&lt;/code&gt; declaration with parameters that are explicitly typed is possible and requires a semicolon between them.</source>
          <target state="translated">Возможно сочетание параметров, которые должны использовать объявление &lt;code&gt;using&lt;/code&gt; , с параметрами, которые явно типизированы, и требует между ними точки с запятой.</target>
        </trans-unit>
        <trans-unit id="e4544d11fd6da006e85425de7ccf9cc035a9102d" translate="yes" xml:space="preserve">
          <source>Modelling currencies</source>
          <target state="translated">Валюты моделирования</target>
        </trans-unit>
        <trans-unit id="aa74d48711737b61f9e3b5b05bb11e9299107ca2" translate="yes" xml:space="preserve">
          <source>Modifies the prefix of this node</source>
          <target state="translated">Изменяет префикс данного узла</target>
        </trans-unit>
        <trans-unit id="08534cfcbbc9538479a2881f8f4160931eb1a4e4" translate="yes" xml:space="preserve">
          <source>Modify &lt;code&gt;a&lt;/code&gt; in place by adding &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Измените &lt;code&gt;a&lt;/code&gt; на месте, добавив &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d316a8d9b4204cded1b078dfca344f13947d6088" translate="yes" xml:space="preserve">
          <source>Modify &lt;code&gt;a&lt;/code&gt; in place by subtracting &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Измените &lt;code&gt;a&lt;/code&gt; на месте, вычтя &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf753b23cff3eb87675698eadfe1b3df8dc21c1" translate="yes" xml:space="preserve">
          <source>Modifying a configuration file.</source>
          <target state="translated">Изменение файла конфигурации.</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="37f0da15f20ceb74b60fd308e1dca9126540cb05" translate="yes" xml:space="preserve">
          <source>Module algorithm</source>
          <target state="translated">Алгоритм модуля</target>
        </trans-unit>
        <trans-unit id="98195ccd152814f0ec7cb526f9dfddd0c0f2d040" translate="yes" xml:space="preserve">
          <source>Module asyncdispatch</source>
          <target state="translated">Модуль асинхронной рассылки</target>
        </trans-unit>
        <trans-unit id="4bc2eee542f289752eea25797a5b576fdb1f0212" translate="yes" xml:space="preserve">
          <source>Module asyncfile</source>
          <target state="translated">Асинхронный профиль модуля</target>
        </trans-unit>
        <trans-unit id="1982b034043183e25a12a7f8201ac7aedfe1337c" translate="yes" xml:space="preserve">
          <source>Module asyncftpclient</source>
          <target state="translated">Модуль asyncftpclient</target>
        </trans-unit>
        <trans-unit id="c8ecdd97327b90a5e22c271e6446280bc42a28c4" translate="yes" xml:space="preserve">
          <source>Module asyncfutures</source>
          <target state="translated">Модульная асинхронизация</target>
        </trans-unit>
        <trans-unit id="36cb7286c251d44bed6e333ac6ff256e07f23e46" translate="yes" xml:space="preserve">
          <source>Module asynchttpserver</source>
          <target state="translated">Модуль асинхронного сервера</target>
        </trans-unit>
        <trans-unit id="a17c24b3dfb9bd981141eb4c7df0cf7bc771a15a" translate="yes" xml:space="preserve">
          <source>Module asyncio</source>
          <target state="translated">Модуль асинсцио</target>
        </trans-unit>
        <trans-unit id="c68f5ddf8354a55f6684c3fbe9c3bf177423a499" translate="yes" xml:space="preserve">
          <source>Module asyncjs</source>
          <target state="translated">Модульная асинхронизация</target>
        </trans-unit>
        <trans-unit id="101489cc366780f3080d0d181d612c9897002730" translate="yes" xml:space="preserve">
          <source>Module asyncnet</source>
          <target state="translated">Модульная асинхронная сеть</target>
        </trans-unit>
        <trans-unit id="6fed8121401f7f3d76d9ac08c713d6fc1d80130c" translate="yes" xml:space="preserve">
          <source>Module asyncstreams</source>
          <target state="translated">Модульные асинхронные потоки</target>
        </trans-unit>
        <trans-unit id="7760e4149a4aa9f2f5276da9842c763efe627d2d" translate="yes" xml:space="preserve">
          <source>Module base64</source>
          <target state="translated">Модульная база64</target>
        </trans-unit>
        <trans-unit id="90d38995e07bc5f4bab2517945813fb23c0f041c" translate="yes" xml:space="preserve">
          <source>Module bitops</source>
          <target state="translated">Модульные битопы</target>
        </trans-unit>
        <trans-unit id="50eadb9d8cc85daa18b406eb03722df6d8ad89ae" translate="yes" xml:space="preserve">
          <source>Module browsers</source>
          <target state="translated">Браузеры модулей</target>
        </trans-unit>
        <trans-unit id="541c25a9eda5bd8f8b769d4123a86bdd4573b52d" translate="yes" xml:space="preserve">
          <source>Module cgi</source>
          <target state="translated">Модуль cgi</target>
        </trans-unit>
        <trans-unit id="582466c566af045f4b9e5cd6e35678516157979c" translate="yes" xml:space="preserve">
          <source>Module channels</source>
          <target state="translated">Модульные каналы</target>
        </trans-unit>
        <trans-unit id="9b8b21dabbac15d101b015114dad88029c7c9e26" translate="yes" xml:space="preserve">
          <source>Module colors</source>
          <target state="translated">Цвета модуля</target>
        </trans-unit>
        <trans-unit id="eed8ec6f020ff8aa124c5b37641c245a63ddde69" translate="yes" xml:space="preserve">
          <source>Module complex</source>
          <target state="translated">Модульный комплекс</target>
        </trans-unit>
        <trans-unit id="374208eb48a6ab162ea9a9795c69a75d26d8d0d8" translate="yes" xml:space="preserve">
          <source>Module cookies</source>
          <target state="translated">Cookie-файлы модуля</target>
        </trans-unit>
        <trans-unit id="a4721d23b264afe3adb6840e441ad673c273dbe5" translate="yes" xml:space="preserve">
          <source>Module coro</source>
          <target state="translated">Модуль коро</target>
        </trans-unit>
        <trans-unit id="0b7487264409b62ec77bc44946eb6949835043bd" translate="yes" xml:space="preserve">
          <source>Module cpuinfo</source>
          <target state="translated">Модуль cpuinfo</target>
        </trans-unit>
        <trans-unit id="65a4bb57d62e6d50e39758f49fa5d45582a06fcf" translate="yes" xml:space="preserve">
          <source>Module cpuload</source>
          <target state="translated">Купить модуль</target>
        </trans-unit>
        <trans-unit id="0eaf026ca68438c31c5ddb66759abefe57ca491a" translate="yes" xml:space="preserve">
          <source>Module critbits</source>
          <target state="translated">Модульные твари</target>
        </trans-unit>
        <trans-unit id="17fb6170e7c4b5192d13d3ef92b62003adec52ed" translate="yes" xml:space="preserve">
          <source>Module cstrutils</source>
          <target state="translated">Модуль крестиль</target>
        </trans-unit>
        <trans-unit id="dccbda4248191deb5d482692eac7fa4e615cc212" translate="yes" xml:space="preserve">
          <source>Module db_common</source>
          <target state="translated">Модуль db_common</target>
        </trans-unit>
        <trans-unit id="8d09576b4e94ea8a8b0016794ba4536d4b1759df" translate="yes" xml:space="preserve">
          <source>Module db_mysql</source>
          <target state="translated">Модуль db_mysql</target>
        </trans-unit>
        <trans-unit id="6624ca243c80fc450c0491ae2bd086e7f22e2273" translate="yes" xml:space="preserve">
          <source>Module db_odbc</source>
          <target state="translated">Модуль db_odbc</target>
        </trans-unit>
        <trans-unit id="fd6fae1e074c3591c208c14db853d9f0744b3fe6" translate="yes" xml:space="preserve">
          <source>Module db_postgres</source>
          <target state="translated">Модуль db_postgres</target>
        </trans-unit>
        <trans-unit id="b401aafda6e7b26047ce7d9b236e3e28ead3b900" translate="yes" xml:space="preserve">
          <source>Module db_sqlite</source>
          <target state="translated">Модуль db_sqlite</target>
        </trans-unit>
        <trans-unit id="a36cab96e59f81b2cfa2e287c992565577181e19" translate="yes" xml:space="preserve">
          <source>Module deques</source>
          <target state="translated">Декадные модули</target>
        </trans-unit>
        <trans-unit id="230fe8691288c49b13cd6d0d633b0aa094bba0ba" translate="yes" xml:space="preserve">
          <source>Module distros</source>
          <target state="translated">Модульные дистрибутивы</target>
        </trans-unit>
        <trans-unit id="b98b5015c00736657c4dd0da231c080c137bf240" translate="yes" xml:space="preserve">
          <source>Module docgen_sample</source>
          <target state="translated">Образец модуля docgen_sample</target>
        </trans-unit>
        <trans-unit id="9b3df8bd64b5aae95560173051cb9413193a2ac6" translate="yes" xml:space="preserve">
          <source>Module dom</source>
          <target state="translated">Модульный дом</target>
        </trans-unit>
        <trans-unit id="941b4acd398cb84658e8c03ee70acb8a6a6ad12b" translate="yes" xml:space="preserve">
          <source>Module dynlib</source>
          <target state="translated">Модуль динамический</target>
        </trans-unit>
        <trans-unit id="0b682ac70a1c85d9baf3957f2aa8f759d24240e0" translate="yes" xml:space="preserve">
          <source>Module encodings</source>
          <target state="translated">Кодировки модулей</target>
        </trans-unit>
        <trans-unit id="db5b0c91c31ae7c7d91818dc9b614356c8ac354a" translate="yes" xml:space="preserve">
          <source>Module endians</source>
          <target state="translated">Модуль эндийцев</target>
        </trans-unit>
        <trans-unit id="bd74d2f3f124ee315af73875094015c9b005becf" translate="yes" xml:space="preserve">
          <source>Module fenv</source>
          <target state="translated">Модуль фенв</target>
        </trans-unit>
        <trans-unit id="731086b25ca52f0d4ba784e9023a512802282c5d" translate="yes" xml:space="preserve">
          <source>Module for computing MD5 checksums.</source>
          <target state="translated">Модуль для вычисления контрольных сумм MD5.</target>
        </trans-unit>
        <trans-unit id="b4be1b80500b5ac048dcc726ed598ece6701931b" translate="yes" xml:space="preserve">
          <source>Module ftpclient</source>
          <target state="translated">Модуль ftpclient</target>
        </trans-unit>
        <trans-unit id="3c4f086976fa89f11b3a0b18d36e2a8854016a20" translate="yes" xml:space="preserve">
          <source>Module hashes</source>
          <target state="translated">Модульные хэши</target>
        </trans-unit>
        <trans-unit id="a2e15c184ec6f1cb32588bee5d5ccb0d11dcc6e5" translate="yes" xml:space="preserve">
          <source>Module heapqueue</source>
          <target state="translated">Модульная нагромождение</target>
        </trans-unit>
        <trans-unit id="83b2786d0af670a8727d352ab2cc17a4801a8fde" translate="yes" xml:space="preserve">
          <source>Module highlite</source>
          <target state="translated">Модуль аристократов</target>
        </trans-unit>
        <trans-unit id="68378bdbde20dbf762ba106c90a960cc76a0c343" translate="yes" xml:space="preserve">
          <source>Module htmlgen</source>
          <target state="translated">Модуль htmlgen</target>
        </trans-unit>
        <trans-unit id="11585b007040719709343df6d82764795667bb4d" translate="yes" xml:space="preserve">
          <source>Module htmlparser</source>
          <target state="translated">Модуль htmlparser</target>
        </trans-unit>
        <trans-unit id="ce266765149cfec68daffab151c2d1cbb6ebb974" translate="yes" xml:space="preserve">
          <source>Module httpclient</source>
          <target state="translated">Модуль httpclient</target>
        </trans-unit>
        <trans-unit id="ae17027dff9b5c5e08184e61c512b15de51aca77" translate="yes" xml:space="preserve">
          <source>Module httpcore</source>
          <target state="translated">Модуль httpcore</target>
        </trans-unit>
        <trans-unit id="efcdd786f2c6fa38c8e234f0d6d253c5564d8710" translate="yes" xml:space="preserve">
          <source>Module intsets</source>
          <target state="translated">Модульные вводы</target>
        </trans-unit>
        <trans-unit id="ae1f8df6d1f31431338fdcd3f32d3d351bdb0f67" translate="yes" xml:space="preserve">
          <source>Module iup</source>
          <target state="translated">Модуль iup</target>
        </trans-unit>
        <trans-unit id="8abdec2103ddf3b91238dc0ef753306e3cf948a1" translate="yes" xml:space="preserve">
          <source>Module jscore</source>
          <target state="translated">Модуль jscore</target>
        </trans-unit>
        <trans-unit id="2445c7a3a0648ca25b67b51a400e8dde36b920dc" translate="yes" xml:space="preserve">
          <source>Module jsffi</source>
          <target state="translated">Модуль jsffi</target>
        </trans-unit>
        <trans-unit id="3e231af76878f00ab682498609250b7a33902b37" translate="yes" xml:space="preserve">
          <source>Module json</source>
          <target state="translated">Модуль Джсон</target>
        </trans-unit>
        <trans-unit id="37345fc873fd9ef2206568b360b1c24cb44c6a79" translate="yes" xml:space="preserve">
          <source>Module lenientops</source>
          <target state="translated">Модульные линентопы</target>
        </trans-unit>
        <trans-unit id="580e2f376943e7c873eabc0e8de78d45329a29d4" translate="yes" xml:space="preserve">
          <source>Module lexbase</source>
          <target state="translated">Лексбаза модуля</target>
        </trans-unit>
        <trans-unit id="f7eb0bf35deb63519acf61a5dc69c51f5b06735f" translate="yes" xml:space="preserve">
          <source>Module lists</source>
          <target state="translated">Списки модулей</target>
        </trans-unit>
        <trans-unit id="5fa64d315f22284a510ec90f2b3766f8771aa4d3" translate="yes" xml:space="preserve">
          <source>Module locks</source>
          <target state="translated">Модульные замки</target>
        </trans-unit>
        <trans-unit id="d68a3f14f1246e34391c7c956005b435126a1feb" translate="yes" xml:space="preserve">
          <source>Module logging</source>
          <target state="translated">Регистрация модулей</target>
        </trans-unit>
        <trans-unit id="70e578149237a5fb397ecdf712216171be19d22c" translate="yes" xml:space="preserve">
          <source>Module macros</source>
          <target state="translated">Макросы модулей</target>
        </trans-unit>
        <trans-unit id="8e11adceffbd4622428572ca4afc35c17c825d9b" translate="yes" xml:space="preserve">
          <source>Module marshal</source>
          <target state="translated">Маршал модуля</target>
        </trans-unit>
        <trans-unit id="33c70e8cca5fc846249c996c55efdccf09fa04af" translate="yes" xml:space="preserve">
          <source>Module matchers</source>
          <target state="translated">Модульные матчи</target>
        </trans-unit>
        <trans-unit id="60528f0928b59cfa4557a3b1b994edb4024106b0" translate="yes" xml:space="preserve">
          <source>Module math</source>
          <target state="translated">Модульная математика</target>
        </trans-unit>
        <trans-unit id="56d8fbdebc1eb23f12cddf043b4f3037a450710a" translate="yes" xml:space="preserve">
          <source>Module md5</source>
          <target state="translated">Модуль md5</target>
        </trans-unit>
        <trans-unit id="bce77eb47d51483993e4fa0db56b0547cc3dd24c" translate="yes" xml:space="preserve">
          <source>Module memfiles</source>
          <target state="translated">Мемфили модулей</target>
        </trans-unit>
        <trans-unit id="20df3a115fcb30f9b530aa03bdc18faa0ae695c2" translate="yes" xml:space="preserve">
          <source>Module mersenne</source>
          <target state="translated">Модуль Мерсенн</target>
        </trans-unit>
        <trans-unit id="cc1b82bbab0603a47f41c5adca38b87a9321bee7" translate="yes" xml:space="preserve">
          <source>Module mimetypes</source>
          <target state="translated">Модульные миметипы</target>
        </trans-unit>
        <trans-unit id="6657cfabe7d07bf51cc2fb118ba722ffc96aba89" translate="yes" xml:space="preserve">
          <source>Module mysql</source>
          <target state="translated">Модуль mysql</target>
        </trans-unit>
        <trans-unit id="31d0c7d344fc5c65774ddf00049b1876645f3b19" translate="yes" xml:space="preserve">
          <source>Module names in imports</source>
          <target state="translated">Названия модулей в импорте</target>
        </trans-unit>
        <trans-unit id="30df598104815cce6ad06791aec2a9d153b164f7" translate="yes" xml:space="preserve">
          <source>Module nativesockets</source>
          <target state="translated">Модули аборигены</target>
        </trans-unit>
        <trans-unit id="a3d7a3865b172afee6c2b7c8977de511e77b6757" translate="yes" xml:space="preserve">
          <source>Module net</source>
          <target state="translated">Сеть модулей</target>
        </trans-unit>
        <trans-unit id="6c357de2b2a9a1de2189540c4281941a77608057" translate="yes" xml:space="preserve">
          <source>Module odbcsql</source>
          <target state="translated">Модуль odbcsql</target>
        </trans-unit>
        <trans-unit id="9ac9afd12fcca720ece0b72dd61269f6e7843617" translate="yes" xml:space="preserve">
          <source>Module oids</source>
          <target state="translated">Кислородные модули</target>
        </trans-unit>
        <trans-unit id="df6c016676012b7a90d7af54c2025872180c6083" translate="yes" xml:space="preserve">
          <source>Module openssl</source>
          <target state="translated">Модуль openssl</target>
        </trans-unit>
        <trans-unit id="181f431ffc709c06a61935e69331ac8e4563f46c" translate="yes" xml:space="preserve">
          <source>Module options</source>
          <target state="translated">Опции модуля</target>
        </trans-unit>
        <trans-unit id="7f661395966d22306bb86d25ec0d945d397507a0" translate="yes" xml:space="preserve">
          <source>Module os</source>
          <target state="translated">Модуль os</target>
        </trans-unit>
        <trans-unit id="dae29e69d6fcac477476832d0c04d256e4219700" translate="yes" xml:space="preserve">
          <source>Module ospaths</source>
          <target state="translated">Модульные спаты</target>
        </trans-unit>
        <trans-unit id="5395928ecc4ce4edf1eabd8f020d30b8523fd803" translate="yes" xml:space="preserve">
          <source>Module osproc</source>
          <target state="translated">Модуль оспрок</target>
        </trans-unit>
        <trans-unit id="2bfeeb302a2c2fb80d26255c95b4f0b069b97c41" translate="yes" xml:space="preserve">
          <source>Module parsecfg</source>
          <target state="translated">Модуль парсекфг</target>
        </trans-unit>
        <trans-unit id="d9ee6d4bae252aefed2ecd2ae012f67dfe339140" translate="yes" xml:space="preserve">
          <source>Module parsecsv</source>
          <target state="translated">Модуль парсексв</target>
        </trans-unit>
        <trans-unit id="348399e23d1c192b9c45e1b0c83d05337c92bf98" translate="yes" xml:space="preserve">
          <source>Module parsejson</source>
          <target state="translated">Модуль парсежон</target>
        </trans-unit>
        <trans-unit id="682e643a35975c3826db50e0bb0cd0dd5c2ca34f" translate="yes" xml:space="preserve">
          <source>Module parseopt</source>
          <target state="translated">Модуль парсеопт</target>
        </trans-unit>
        <trans-unit id="0ed92eaefc270e8b9dd075eb2dd08dbaa5b51f01" translate="yes" xml:space="preserve">
          <source>Module parsesql</source>
          <target state="translated">Модуль parsesql</target>
        </trans-unit>
        <trans-unit id="855c130387d410a61e37f5b34d034cd98d89f8d8" translate="yes" xml:space="preserve">
          <source>Module parseutils</source>
          <target state="translated">Модуль инструментов</target>
        </trans-unit>
        <trans-unit id="9371c7c885849232742553f842dca9202b5ed289" translate="yes" xml:space="preserve">
          <source>Module parsexml</source>
          <target state="translated">Модуль парсексмІ</target>
        </trans-unit>
        <trans-unit id="20024d265db3ebf3a4cb1f9d150f212626383df7" translate="yes" xml:space="preserve">
          <source>Module pcre</source>
          <target state="translated">модуль экрана</target>
        </trans-unit>
        <trans-unit id="a17a4c9cec16cef361a14841e228e5ed78a25395" translate="yes" xml:space="preserve">
          <source>Module pegs</source>
          <target state="translated">Модуль колышек</target>
        </trans-unit>
        <trans-unit id="5f3bf0ccd39bc7809674b2d661113030c738201e" translate="yes" xml:space="preserve">
          <source>Module posix</source>
          <target state="translated">Модуль Posix</target>
        </trans-unit>
        <trans-unit id="eef6ef7935050ba1da22c08049e0e742ab0545c6" translate="yes" xml:space="preserve">
          <source>Module postgres</source>
          <target state="translated">Модуль Postgres</target>
        </trans-unit>
        <trans-unit id="4c337d9754fa6144e8e8c63eb6714830a7bf2680" translate="yes" xml:space="preserve">
          <source>Module random</source>
          <target state="translated">случайный модуль</target>
        </trans-unit>
        <trans-unit id="6f3863bd09c8389a708515de060c50fe217a1fc5" translate="yes" xml:space="preserve">
          <source>Module rationals</source>
          <target state="translated">Рационы модулей</target>
        </trans-unit>
        <trans-unit id="1c6043ad9977193e14836b1453a2c14e877b9c12" translate="yes" xml:space="preserve">
          <source>Module re</source>
          <target state="translated">Модуль ре</target>
        </trans-unit>
        <trans-unit id="beb8a46432b339ddaa74839d412412426afb7728" translate="yes" xml:space="preserve">
          <source>Module rlocks</source>
          <target state="translated">Модульные замки</target>
        </trans-unit>
        <trans-unit id="373d2a7e384e4c78df72f2a532ade493280ab5b9" translate="yes" xml:space="preserve">
          <source>Module ropes</source>
          <target state="translated">Модульные канаты</target>
        </trans-unit>
        <trans-unit id="791fafc4980538594d1205be2e024d8f062a8ef6" translate="yes" xml:space="preserve">
          <source>Module rst</source>
          <target state="translated">Модуль rst</target>
        </trans-unit>
        <trans-unit id="e62ac437c8e15e65ba3f4a9ec5166f39349d24d8" translate="yes" xml:space="preserve">
          <source>Module rstast</source>
          <target state="translated">Модульное растение</target>
        </trans-unit>
        <trans-unit id="71d839f9565a57347512e1bcb1209ad6ecbd1571" translate="yes" xml:space="preserve">
          <source>Module rstgen</source>
          <target state="translated">Модуль рстгена</target>
        </trans-unit>
        <trans-unit id="64202e11eebaa8fdc9db2592feeeca4f21b321b4" translate="yes" xml:space="preserve">
          <source>Module rtarrays</source>
          <target state="translated">Модульные ртарры</target>
        </trans-unit>
        <trans-unit id="34de3c41db61af2ec348412e142cf1de55f30e2c" translate="yes" xml:space="preserve">
          <source>Module scgi</source>
          <target state="translated">Модуль scgi</target>
        </trans-unit>
        <trans-unit id="9d18a075abac676c24c84bba7822fb5ce2702cec" translate="yes" xml:space="preserve">
          <source>Module scope</source>
          <target state="translated">Область применения модуля</target>
        </trans-unit>
        <trans-unit id="b6a250923bc9b9d586fc748c435010dc3db2a298" translate="yes" xml:space="preserve">
          <source>Module segfaults</source>
          <target state="translated">Сегментация модулей</target>
        </trans-unit>
        <trans-unit id="8208cbe439f9b79060081af450aa66cdb0a714b6" translate="yes" xml:space="preserve">
          <source>Module selectors</source>
          <target state="translated">Селекторы модулей</target>
        </trans-unit>
        <trans-unit id="23026b5c559a2292c7babd2476fc9f08c5816964" translate="yes" xml:space="preserve">
          <source>Module sequtils</source>
          <target state="translated">Последовательности модулей</target>
        </trans-unit>
        <trans-unit id="c3ea468cd06b16c0644d2bacc8da61f318bab4bb" translate="yes" xml:space="preserve">
          <source>Module sets</source>
          <target state="translated">Наборы модулей</target>
        </trans-unit>
        <trans-unit id="a16a3e9b2eb88fe04764ed85fb0218873cc38566" translate="yes" xml:space="preserve">
          <source>Module sexp</source>
          <target state="translated">Модуль секс-секс</target>
        </trans-unit>
        <trans-unit id="59d0872f6bd60a77e18aa4238e904f432277b85d" translate="yes" xml:space="preserve">
          <source>Module sha1</source>
          <target state="translated">Модуль шахты1</target>
        </trans-unit>
        <trans-unit id="4ece62635ed6e99fbdb3e080b7996745d5c3b1f3" translate="yes" xml:space="preserve">
          <source>Module sharedlist</source>
          <target state="translated">Список совместно используемых модулей</target>
        </trans-unit>
        <trans-unit id="b5e68bfc8c55fb54fde0c83c3f95af5feaf92c9b" translate="yes" xml:space="preserve">
          <source>Module sharedtables</source>
          <target state="translated">Модульные общие столы</target>
        </trans-unit>
        <trans-unit id="c339964428c500099d3daed6fb8542e3b613f1ef" translate="yes" xml:space="preserve">
          <source>Module smtp</source>
          <target state="translated">Модуль smtp</target>
        </trans-unit>
        <trans-unit id="ac4edb7026adc886e3dd2c3c0e2fa6b2624eac99" translate="yes" xml:space="preserve">
          <source>Module sockets</source>
          <target state="translated">Модульные розетки</target>
        </trans-unit>
        <trans-unit id="44b9eae64da1d100a47749f8e94861aceb4e1953" translate="yes" xml:space="preserve">
          <source>Module sqlite3</source>
          <target state="translated">Модуль sqlite3</target>
        </trans-unit>
        <trans-unit id="8c907d2d3470228660aa0f1c6e876cce39cd9be0" translate="yes" xml:space="preserve">
          <source>Module ssl</source>
          <target state="translated">Модуль ssl</target>
        </trans-unit>
        <trans-unit id="5dddec2bc7b6889e3d6e4572f0e2abcd568ae642" translate="yes" xml:space="preserve">
          <source>Module stats</source>
          <target state="translated">Статус модуля</target>
        </trans-unit>
        <trans-unit id="af7ea72f6db5731696a9ec545d89e8dbf5355b5e" translate="yes" xml:space="preserve">
          <source>Module streams</source>
          <target state="translated">Потоки модулей</target>
        </trans-unit>
        <trans-unit id="d563539aac0aa375abd30d9cff848fd83c1d6b90" translate="yes" xml:space="preserve">
          <source>Module strformat</source>
          <target state="translated">Страформат модуля</target>
        </trans-unit>
        <trans-unit id="c5b35d487655735440b1511f4cbcb6212ffb09bf" translate="yes" xml:space="preserve">
          <source>Module strmisc</source>
          <target state="translated">Модуль строгий</target>
        </trans-unit>
        <trans-unit id="39a556995953f0750f993afaabbda0fb9aa0c361" translate="yes" xml:space="preserve">
          <source>Module strscans</source>
          <target state="translated">Строки модулей</target>
        </trans-unit>
        <trans-unit id="9add54a0554d7d5e3b57ccafbebed36cfff3a00a" translate="yes" xml:space="preserve">
          <source>Module strtabs</source>
          <target state="translated">Модульные пластыри</target>
        </trans-unit>
        <trans-unit id="2c2fe9377d124f6f70ba53c4aac93232b71c1394" translate="yes" xml:space="preserve">
          <source>Module strutils</source>
          <target state="translated">Модульные струты</target>
        </trans-unit>
        <trans-unit id="c427c4ed878b917bab65e9b41afb7305c3c93c47" translate="yes" xml:space="preserve">
          <source>Module subexes</source>
          <target state="translated">Подсексы модуля</target>
        </trans-unit>
        <trans-unit id="2ff9cf6c55f0b207b0fa1b96a01a770ee71c8eaa" translate="yes" xml:space="preserve">
          <source>Module sugar</source>
          <target state="translated">Модульный сахар</target>
        </trans-unit>
        <trans-unit id="de70d79767a9e812db99a7c477172374c0a8abe1" translate="yes" xml:space="preserve">
          <source>Module system</source>
          <target state="translated">Модульная система</target>
        </trans-unit>
        <trans-unit id="e9cc05615900094d98054d721ed949701ef00a47" translate="yes" xml:space="preserve">
          <source>Module tables</source>
          <target state="translated">Таблицы модулей</target>
        </trans-unit>
        <trans-unit id="12b55983071a387f9c09feaf0f6a54c990c5be1d" translate="yes" xml:space="preserve">
          <source>Module terminal</source>
          <target state="translated">Модульный терминал</target>
        </trans-unit>
        <trans-unit id="84ba9986fea98d5aed3aa1e050cd37789056e75a" translate="yes" xml:space="preserve">
          <source>Module that implements a fixed length array whose size is determined at runtime. Note: This is not ready for other people to use!</source>
          <target state="translated">Модуль,реализующий массив фиксированной длины,размер которого определяется во время выполнения.Замечание:Он не готов к использованию другими людьми!</target>
        </trans-unit>
        <trans-unit id="3b2dabb54c51f17c55a0e6927caa5f742504ae33" translate="yes" xml:space="preserve">
          <source>Module threadpool</source>
          <target state="translated">Модульная резьбовая катушка</target>
        </trans-unit>
        <trans-unit id="f92a75aeabfd1c4044569aecab8ccb991701806b" translate="yes" xml:space="preserve">
          <source>Module threads</source>
          <target state="translated">Резьба модулей</target>
        </trans-unit>
        <trans-unit id="fb3625f5ec0037d48d6c0cb336a239dd3b00b7ca" translate="yes" xml:space="preserve">
          <source>Module times</source>
          <target state="translated">Время модулей</target>
        </trans-unit>
        <trans-unit id="80fdbaacf746a3cedeab4e5928808c2384a50612" translate="yes" xml:space="preserve">
          <source>Module typeinfo</source>
          <target state="translated">Тип модуля-информация</target>
        </trans-unit>
        <trans-unit id="2b741b4fc7fd10f81b2d720dc6c96f43017249fb" translate="yes" xml:space="preserve">
          <source>Module typetraits</source>
          <target state="translated">Типтрайты модулей</target>
        </trans-unit>
        <trans-unit id="9043c86e7cedc7aab24be69a0efdba5ddf0f80e5" translate="yes" xml:space="preserve">
          <source>Module unicode</source>
          <target state="translated">Юникод модуля</target>
        </trans-unit>
        <trans-unit id="7085badef4953ee4bbceb9688b13d4140b27c724" translate="yes" xml:space="preserve">
          <source>Module unittest</source>
          <target state="translated">Блок-тест модулей</target>
        </trans-unit>
        <trans-unit id="8bbd7d4f48877a7314d216e6ebdb985da4bfafac" translate="yes" xml:space="preserve">
          <source>Module uri</source>
          <target state="translated">Модуль ури</target>
        </trans-unit>
        <trans-unit id="8a680992d6079b9c0e11b05251fd8f87bfbf1fe8" translate="yes" xml:space="preserve">
          <source>Module winlean</source>
          <target state="translated">Модуль winlean</target>
        </trans-unit>
        <trans-unit id="d8fdebbbc5615918cb9d798309cb31cd866e4994" translate="yes" xml:space="preserve">
          <source>Module xmldom</source>
          <target state="translated">Модуль xmldom</target>
        </trans-unit>
        <trans-unit id="f295719f36ed63526a4da7b30de4cad8a8999c32" translate="yes" xml:space="preserve">
          <source>Module xmldomparser</source>
          <target state="translated">Модуль xmldomparser</target>
        </trans-unit>
        <trans-unit id="634e83af2de2c8fae54f36c85ad255fa78fdc1fe" translate="yes" xml:space="preserve">
          <source>Module xmlparser</source>
          <target state="translated">Модуль xmlparser</target>
        </trans-unit>
        <trans-unit id="fffc921107774b45b37fb11a2ae26e6c1756df47" translate="yes" xml:space="preserve">
          <source>Module xmltree</source>
          <target state="translated">Модуль xmltree</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d4bb1d0c8920c90ab574ded6626feabfc7eb5056" translate="yes" xml:space="preserve">
          <source>Modules for JS backend</source>
          <target state="translated">Модули для JS-бэкэнда</target>
        </trans-unit>
        <trans-unit id="04ed0b03aed0cadb43ffc6bfd838816a8c42b369" translate="yes" xml:space="preserve">
          <source>Modules like &lt;code&gt;os&lt;/code&gt; and &lt;code&gt;osproc&lt;/code&gt; use the Ansi versions of the Windows API. The default build uses the Unicode version.</source>
          <target state="translated">Такие модули, как &lt;code&gt;os&lt;/code&gt; и &lt;code&gt;osproc&lt;/code&gt; , используют версии Ansi Windows API. В сборке по умолчанию используется версия Unicode.</target>
        </trans-unit>
        <trans-unit id="5492a7b7e10ca5189dd3f4f7cd04aaa834acbe84" translate="yes" xml:space="preserve">
          <source>More examples with custom pragmas:</source>
          <target state="translated">Больше примеров с пользовательскими прагмами:</target>
        </trans-unit>
        <trans-unit id="02e1b6aeefcbcdce8ddb030e0d03e46f8f19c14b" translate="yes" xml:space="preserve">
          <source>More information: &lt;a href=&quot;http://xoroshiro.di.unimi.it&quot;&gt;http://xoroshiro.di.unimi.it&lt;/a&gt;/</source>
          <target state="translated">Дополнительная информация: &lt;a href=&quot;http://xoroshiro.di.unimi.it&quot;&gt;http://xoroshiro.di.unimi.it&lt;/a&gt; /</target>
        </trans-unit>
        <trans-unit id="2fa11c0cc6358778587e65242e73c28f8b0ce69a" translate="yes" xml:space="preserve">
          <source>Most (if not all) modules that use asyncio provide a userArg which is passed on with the events. The type that you set userArg to must be inheriting from &lt;code&gt;RootObj&lt;/code&gt;!</source>
          <target state="translated">Большинство (если не все) модулей, использующих asyncio, предоставляют userArg, который передается вместе с событиями. Тип, который вы установили для userArg, должен быть унаследован от &lt;code&gt;RootObj&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="3a3648df8257d95dad8a542820feec7313dcffba" translate="yes" xml:space="preserve">
          <source>Most calling conventions exist only for the Windows 32-bit platform.</source>
          <target state="translated">Большинство соглашений по вызову существует только для Windows 32-битной платформы.</target>
        </trans-unit>
        <trans-unit id="d682310dcece700c3a8748a725359d19f632cdec" translate="yes" xml:space="preserve">
          <source>Most native Nim types support conversion to strings with the special &lt;code&gt;$&lt;/code&gt; proc. When calling the &lt;code&gt;echo&lt;/code&gt; proc, for example, the built-in stringify operation for the parameter is called:</source>
          <target state="translated">Большинство нативных типов Nim поддерживают преобразование в строки с помощью специальной &lt;code&gt;$&lt;/code&gt; proc. Например, при вызове процедуры &lt;code&gt;echo&lt;/code&gt; вызывается встроенная операция преобразования в строку для параметра:</target>
        </trans-unit>
        <trans-unit id="c330bf74003c40f0baff1596cb0fe1aa69f44229" translate="yes" xml:space="preserve">
          <source>Most often integers are used for counting objects that reside in memory, so &lt;code&gt;int&lt;/code&gt; has the same size as a pointer.</source>
          <target state="translated">Чаще всего для подсчета объектов, находящихся в памяти, используются целые числа, поэтому &lt;code&gt;int&lt;/code&gt; имеет тот же размер, что и указатель.</target>
        </trans-unit>
        <trans-unit id="2dcc64ab52a078dbecfc23dc0e106a84a69bd521" translate="yes" xml:space="preserve">
          <source>Most operations over an uninitialized ordered set will crash at runtime and &lt;a href=&quot;system#assert&quot;&gt;assert&lt;/a&gt; in debug builds. You can use this proc in your own procs to verify that ordered sets passed to your procs are correctly initialized. Example:</source>
          <target state="translated">Большинство операций над неинициализированным упорядоченным набором завершаются сбоем во время выполнения и &lt;a href=&quot;system#assert&quot;&gt;утверждаются&lt;/a&gt; в отладочных сборках. Вы можете использовать эту процедуру в ваших собственных процессах, чтобы убедиться, что упорядоченные наборы, переданные в ваши процессы, правильно инициализированы. Пример:</target>
        </trans-unit>
        <trans-unit id="b286a20955238c202888cbd22fcba1b32dbb5ccf" translate="yes" xml:space="preserve">
          <source>Most operations over an uninitialized set will crash at runtime and &lt;a href=&quot;system#assert&quot;&gt;assert&lt;/a&gt; in debug builds. You can use this proc in your own procs to verify that sets passed to your procs are correctly initialized. Example:</source>
          <target state="translated">Большинство операций над неинициализированным набором завершаются сбоем во время выполнения и &lt;a href=&quot;system#assert&quot;&gt;утверждаются&lt;/a&gt; в отладочных сборках. Вы можете использовать эту процедуру в своих собственных процессах, чтобы убедиться, что наборы, переданные вашим процессам, правильно инициализированы. Пример:</target>
        </trans-unit>
        <trans-unit id="40f1f54ed50170dad3e2a2e1db2410306c0d2895" translate="yes" xml:space="preserve">
          <source>Most procedures raise OSError on error, but some may return &lt;code&gt;-1&lt;/code&gt; or a boolean &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Большинство процедур вызывают ошибку OSError, но некоторые могут возвращать &lt;code&gt;-1&lt;/code&gt; или логическое значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb5ab88dfbf525d498b45d241a40f2698fed97a" translate="yes" xml:space="preserve">
          <source>Mostly used by the &lt;a href=&quot;tables&quot;&gt;tables&lt;/a&gt; module, it can also be raised by other collection modules like &lt;a href=&quot;sets&quot;&gt;sets&lt;/a&gt; or &lt;a href=&quot;strtabs&quot;&gt;strtabs&lt;/a&gt;.</source>
          <target state="translated">В основном используется модулем &lt;a href=&quot;tables&quot;&gt;таблиц&lt;/a&gt; , он также может быть &lt;a href=&quot;strtabs&quot;&gt;вызван&lt;/a&gt; другими модулями сбора, такими как &lt;a href=&quot;sets&quot;&gt;наборы&lt;/a&gt; или strtabs .</target>
        </trans-unit>
        <trans-unit id="7ff0881f9033325d1090cbf272495b3ea89cd9ef" translate="yes" xml:space="preserve">
          <source>Move optimization</source>
          <target state="translated">Оптимизация движения</target>
        </trans-unit>
        <trans-unit id="4406458901a000581b1c862bae39b54d20d9bf38" translate="yes" xml:space="preserve">
          <source>Moves a directory from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised.</source>
          <target state="translated">Перемещение каталога из &lt;em&gt;источника&lt;/em&gt; в &lt;em&gt;приемник&lt;/em&gt; . Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8a88abf00e872b645596ba5706595492621b50d3" translate="yes" xml:space="preserve">
          <source>Moves a file from &lt;em&gt;source&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt;. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. Can be used to &lt;span id=&quot;rename-files_1&quot;&gt;rename files&lt;/span&gt;</source>
          <target state="translated">Перемещение файла из &lt;em&gt;источника&lt;/em&gt; в &lt;em&gt;приемник&lt;/em&gt; . Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . Может использоваться для &lt;span id=&quot;rename-files_1&quot;&gt;переименования файлов&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8720bd922009aac72de226d7d61d6fe73ea2154f" translate="yes" xml:space="preserve">
          <source>Moves the cursor backward by &lt;em&gt;count&lt;/em&gt; columns.</source>
          <target state="translated">Перемещает курсор назад на &lt;em&gt;количество&lt;/em&gt; столбцов.</target>
        </trans-unit>
        <trans-unit id="5b4f5707c476bf0444f3d7ca4829bce587056960" translate="yes" xml:space="preserve">
          <source>Moves the cursor down by &lt;em&gt;count&lt;/em&gt; rows.</source>
          <target state="translated">Перемещает курсор вниз на &lt;em&gt;количество&lt;/em&gt; строк.</target>
        </trans-unit>
        <trans-unit id="5731b74c9a2498294ab69fa71acf35d7129365e9" translate="yes" xml:space="preserve">
          <source>Moves the cursor forward by &lt;em&gt;count&lt;/em&gt; columns.</source>
          <target state="translated">Перемещает курсор вперед на &lt;em&gt;количество&lt;/em&gt; столбцов.</target>
        </trans-unit>
        <trans-unit id="eb4d28da6332be8ce6373d9d339c7fe48fa23486" translate="yes" xml:space="preserve">
          <source>Moves the cursor up by &lt;em&gt;count&lt;/em&gt; rows.</source>
          <target state="translated">Перемещает курсор вверх на &lt;em&gt;количество&lt;/em&gt; строк.</target>
        </trans-unit>
        <trans-unit id="78732a3d2d5bc767bacb10d82e232dfa8d87404f" translate="yes" xml:space="preserve">
          <source>Much like generics, concepts are instantiated exactly once for each tested type and any static code included within the body is executed only once.</source>
          <target state="translated">Как и дженерики,концепции инстанцируются ровно один раз для каждого тестируемого типа,а любой статический код,включенный в тело,выполняется только один раз.</target>
        </trans-unit>
        <trans-unit id="1d5f2fd6e9c15080786fa9fc4a690a2cc1e48b6a" translate="yes" xml:space="preserve">
          <source>Multi-line procedure calls should continue on the same column as the opening parenthesis (like multi-line procedure declarations).</source>
          <target state="translated">Вызовы многострочных процедур должны продолжаться в том же столбце,что и открывающаяся скобка (как и объявления многострочных процедур).</target>
        </trans-unit>
        <trans-unit id="9254f56fa866823471402ac94c86d60cd0bf7ec3" translate="yes" xml:space="preserve">
          <source>Multi-methods</source>
          <target state="translated">Multi-methods</target>
        </trans-unit>
        <trans-unit id="f038ab50dbba14467b3f2d54ae4453034bd4e0b4" translate="yes" xml:space="preserve">
          <source>Multicast address.</source>
          <target state="translated">Многоадресный адрес.</target>
        </trans-unit>
        <trans-unit id="7eef768291d80681527aa60e3df38506cba1a219" translate="yes" xml:space="preserve">
          <source>Multicast global address.</source>
          <target state="translated">Многоадресный глобальный адрес.</target>
        </trans-unit>
        <trans-unit id="48369fed2a551361b8045057023eecff834b5fb1" translate="yes" xml:space="preserve">
          <source>Multicast link-local address.</source>
          <target state="translated">Многоадресная рассылка-локальный адрес.</target>
        </trans-unit>
        <trans-unit id="24dcc40f5a40c25ac2feb7b6c8089ae89a9733cc" translate="yes" xml:space="preserve">
          <source>Multicast node-local address.</source>
          <target state="translated">Многоадресный узловой адрес.</target>
        </trans-unit>
        <trans-unit id="7b7ea2cc81efabb6fd79723109a63d77b71fcdc4" translate="yes" xml:space="preserve">
          <source>Multicast organization-local address.</source>
          <target state="translated">Многоадресная организация-локальный адрес.</target>
        </trans-unit>
        <trans-unit id="3867c8b804a55ef6500439f739768f84c270b65d" translate="yes" xml:space="preserve">
          <source>Multicast site-local address.</source>
          <target state="translated">Многоадресный сайт-локальный адрес.</target>
        </trans-unit>
        <trans-unit id="d8164f83c1acb0822b6c1157de32950f13f00bf8" translate="yes" xml:space="preserve">
          <source>Multiline comments</source>
          <target state="translated">Многострочные комментарии</target>
        </trans-unit>
        <trans-unit id="64ad927c3d1f8a60b8de3a4dcfa11cb5f9ed2b35" translate="yes" xml:space="preserve">
          <source>Multiline comments are started with &lt;code&gt;#[&lt;/code&gt; and terminated with &lt;code&gt;]#&lt;/code&gt;. Multiline comments can also be nested.</source>
          <target state="translated">Многострочные комментарии начинаются с &lt;code&gt;#[&lt;/code&gt; и заканчиваются &lt;code&gt;]#&lt;/code&gt; . Многострочные комментарии также могут быть вложенными.</target>
        </trans-unit>
        <trans-unit id="51b13e7abf733936d7df1349e642855933b8c93f" translate="yes" xml:space="preserve">
          <source>Multiline comments support nesting:</source>
          <target state="translated">Многострочные комментарии поддерживают вложение:</target>
        </trans-unit>
        <trans-unit id="d8b83fc7a7727ea41499ff067b6d0dbb7149942a" translate="yes" xml:space="preserve">
          <source>Multiline documentation comments also exist and support nesting too:</source>
          <target state="translated">Имеются также комментарии к многоязычной документации,которые поддерживают вложение:</target>
        </trans-unit>
        <trans-unit id="cbf27a3ccf0fd00bcb0f6850421450358a6cae08" translate="yes" xml:space="preserve">
          <source>Multimedia support</source>
          <target state="translated">Мультимедийная поддержка</target>
        </trans-unit>
        <trans-unit id="09f3196845a8359a6ecedfa5af3141e1edccd739" translate="yes" xml:space="preserve">
          <source>Multiple arguments can be used.</source>
          <target state="translated">Можно использовать несколько аргументов.</target>
        </trans-unit>
        <trans-unit id="a89c998a8939bd86eba71a1abb06f5d85c817883" translate="yes" xml:space="preserve">
          <source>Multiplies in place a floating point number</source>
          <target state="translated">Мультилирует на месте число с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="fcd886e69a9b9ba9f155b8a7f1e41875370c7b1d" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;x&lt;/em&gt; with &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Умножьте &lt;em&gt;x&lt;/em&gt; на &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f2f1bb918524a79ef38752dea6ec686cd665c1" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Умножьте &lt;em&gt;y&lt;/em&gt; на &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cf4b7cc064435e9b222c2ae1ef88a90049e33ef7" translate="yes" xml:space="preserve">
          <source>Multiply &lt;em&gt;y&lt;/em&gt; to the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Умножьте &lt;em&gt;y&lt;/em&gt; на комплексное число &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="967a2a96e493c3fa19de6d580534df7c563be46e" translate="yes" xml:space="preserve">
          <source>Multiply a duration by some scalar.</source>
          <target state="translated">Умножьте продолжительность на скаляр.</target>
        </trans-unit>
        <trans-unit id="3992914db890fb69ae7d33ac0b14f1598d61248c" translate="yes" xml:space="preserve">
          <source>Multiply complex &lt;em&gt;x&lt;/em&gt; with float &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Умножьте комплексный &lt;em&gt;x&lt;/em&gt; на float &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1b5c2c91504b80f3c83b9e589314371f1f27f89a" translate="yes" xml:space="preserve">
          <source>Multiply float &lt;em&gt;x&lt;/em&gt; with complex &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Умножьте float &lt;em&gt;x&lt;/em&gt; на комплексный &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0476878c0b1cabcde1afe8aa70cf6a429753af27" translate="yes" xml:space="preserve">
          <source>Multiply int &lt;em&gt;x&lt;/em&gt; with rational &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Умножаем int &lt;em&gt;x&lt;/em&gt; на рациональное &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="10cf9524fcce1f51fd3027d067a68e18439d699b" translate="yes" xml:space="preserve">
          <source>Multiply int &lt;em&gt;y&lt;/em&gt; to rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Умножьте int &lt;em&gt;y&lt;/em&gt; на рациональное &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bfb40c2a917440a979a3937c83ab1838a96e6061" translate="yes" xml:space="preserve">
          <source>Multiply rational &lt;em&gt;x&lt;/em&gt; with int &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">Умножаем рациональный &lt;em&gt;x&lt;/em&gt; на int &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="be6d2d49f08d8ce52cada7a4e40308b84089a378" translate="yes" xml:space="preserve">
          <source>Multiply rationals &lt;em&gt;y&lt;/em&gt; to &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Умножьте рациональные числа &lt;em&gt;y&lt;/em&gt; на &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="407f3e6e72365b49bada1f7c9b2babeb3f8c1e8f" translate="yes" xml:space="preserve">
          <source>Multiply two rational numbers.</source>
          <target state="translated">Умножь два рациональных числа.</target>
        </trans-unit>
        <trans-unit id="57d62a44db1dbaaab6871e35242edd989b03aa79" translate="yes" xml:space="preserve">
          <source>Mutually recursive types</source>
          <target state="translated">Взаимно рекурсивные типы</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="c83bf68eaf2532d248d1885057b7fe59c910abf7" translate="yes" xml:space="preserve">
          <source>Name of the test suite that contains this test case. Can be &lt;code&gt;nil&lt;/code&gt; if the test case is not in a suite.</source>
          <target state="translated">Имя набора тестов, содержащего этот тестовый пример. Может быть &lt;code&gt;nil&lt;/code&gt; если тестовый пример не входит в комплект.</target>
        </trans-unit>
        <trans-unit id="f2ab34573e168918bf72dc73ec10c4b5b1ba3f14" translate="yes" xml:space="preserve">
          <source>Named arguments</source>
          <target state="translated">Названные аргументы</target>
        </trans-unit>
        <trans-unit id="dc74246cc093982dca8a3a3f276b5d8b65d59486" translate="yes" xml:space="preserve">
          <source>Named pipe, or FIFO.</source>
          <target state="translated">Названная труба,или FIFO.</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="translated">Конвенции по наименованию</target>
        </trans-unit>
        <trans-unit id="c6c5f0ef33b66371fc9992be0b7555afe7072e1f" translate="yes" xml:space="preserve">
          <source>Naming scheme</source>
          <target state="translated">Схема наименований</target>
        </trans-unit>
        <trans-unit id="9a732a9b195778d45aff4c029836d8016c6d092a" translate="yes" xml:space="preserve">
          <source>Nanosecond-granularity time of last access.</source>
          <target state="translated">Наносеконд-гранулярность время последнего доступа.</target>
        </trans-unit>
        <trans-unit id="44a8ea231c9b25a28c6b1bae13f6d58d8ab769bb" translate="yes" xml:space="preserve">
          <source>Nanosecond-granularity time of last data modification.</source>
          <target state="translated">Наносеконд-гранулярность времени последней модификации данных.</target>
        </trans-unit>
        <trans-unit id="ac4471c1eac2668f96fa75ca630c4f282bc0b52a" translate="yes" xml:space="preserve">
          <source>Nanoseconds display</source>
          <target state="translated">экран с наносекундами</target>
        </trans-unit>
        <trans-unit id="8b8960e4540a492b4c2ade7385f3643ce326ec71" translate="yes" xml:space="preserve">
          <source>Natural log of the gamma function</source>
          <target state="translated">Естественный журнал гамма-функции</target>
        </trans-unit>
        <trans-unit id="40ae5bdaf41bbc2df0ddd3ba6cd0e29b307d851a" translate="yes" xml:space="preserve">
          <source>Navigation through the FTP server's directories.</source>
          <target state="translated">Навигация по каталогам FTP-сервера.</target>
        </trans-unit>
        <trans-unit id="b5c25dae4dbbde41bb6194a297db2a60c41076f4" translate="yes" xml:space="preserve">
          <source>Negated version of &lt;em&gt;is&lt;/em&gt;. Equivalent to &lt;code&gt;not(x is y)&lt;/code&gt;.</source>
          <target state="translated">Отрицательная версия &lt;em&gt;есть&lt;/em&gt; . Эквивалентно &lt;code&gt;not(x is y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c0ca5089d3b83be1bafc4d4d1a8a2d03a288270" translate="yes" xml:space="preserve">
          <source>Neither inline nor closure iterators can be recursive.</source>
          <target state="translated">Ни встроенные,ни закрывающие итераторы не могут быть рекурсивными.</target>
        </trans-unit>
        <trans-unit id="0db36e51e26b9948538aa75241b28b52b8a7c448" translate="yes" xml:space="preserve">
          <source>Neither the name of the University of Cambridge nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</source>
          <target state="translated">Ни название Кембриджского университета,ни имена его участников не могут быть использованы для одобрения или продвижения продуктов,полученных с помощью этого программного обеспечения,без специального предварительного письменного разрешения.</target>
        </trans-unit>
        <trans-unit id="d050b1bc6d5102e8c3c43e52f8c2bc1d471d35c1" translate="yes" xml:space="preserve">
          <source>Network Programming and Internet Protocols</source>
          <target state="translated">Сетевое программирование и интернет-протоколы</target>
        </trans-unit>
        <trans-unit id="171eece6964ab33a2181793b80b9e480760fd86a" translate="yes" xml:space="preserve">
          <source>Never used by PCRE itself</source>
          <target state="translated">Никогда не использовался самим PCRE</target>
        </trans-unit>
        <trans-unit id="17c5fe945bffa6ac038aff7b2982abfca0575621" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;AsyncEvent&lt;/code&gt; object is not automatically registered with dispatcher like &lt;code&gt;AsyncSocket&lt;/code&gt;.</source>
          <target state="translated">Новый объект &lt;code&gt;AsyncEvent&lt;/code&gt; не регистрируется автоматически диспетчером, например &lt;code&gt;AsyncSocket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28d212a8c45cffe38583de7b76bc156d6b77f1fb" translate="yes" xml:space="preserve">
          <source>New data is written into the future stream.</source>
          <target state="translated">Новые данные записываются в будущий поток.</target>
        </trans-unit>
        <trans-unit id="567bb6ab39291d029af6c28280c594e2fe015993" translate="yes" xml:space="preserve">
          <source>New nil literal shortcut</source>
          <target state="translated">новый нулевой буквальный ярлык</target>
        </trans-unit>
        <trans-unit id="8bcd0a2c52378cf0d5699266d7e259ed99978f8c" translate="yes" xml:space="preserve">
          <source>Nim</source>
          <target state="translated">Nim</target>
        </trans-unit>
        <trans-unit id="7793ecd2f1c81dc748001f595a446d07a21dca61" translate="yes" xml:space="preserve">
          <source>Nim Backend Integration</source>
          <target state="translated">Интеграция Nim Backend</target>
        </trans-unit>
        <trans-unit id="16df2910cd311102e24b9deaaab6834d4ce68a59" translate="yes" xml:space="preserve">
          <source>Nim Compiler</source>
          <target state="translated">Компилятор Ним</target>
        </trans-unit>
        <trans-unit id="21f8909f95c6aa6f948aea798f908963482f9a9e" translate="yes" xml:space="preserve">
          <source>Nim Compiler User Guide</source>
          <target state="translated">Nim Руководство пользователя компилятора</target>
        </trans-unit>
        <trans-unit id="4e729000a4923f3f92aa9b54b57cd9d13b461a42" translate="yes" xml:space="preserve">
          <source>Nim DocGen Tools Guide</source>
          <target state="translated">Руководство по инструментам Nim DocGen</target>
        </trans-unit>
        <trans-unit id="3e73c9c60a5f0a7a9de0b9e82a823b0e9e25a26d" translate="yes" xml:space="preserve">
          <source>Nim Documentation</source>
          <target state="translated">Ним Документация</target>
        </trans-unit>
        <trans-unit id="f6faadf36850555183f2e6623ce564cd582735b7" translate="yes" xml:space="preserve">
          <source>Nim Enhancement Proposal #1</source>
          <target state="translated">Предложение по усилению Ним № 1</target>
        </trans-unit>
        <trans-unit id="a017c7a8f194b967e2353a197aaf8085c32d102d" translate="yes" xml:space="preserve">
          <source>Nim Enhancement Proposal #1 - Standard Library Style Guide</source>
          <target state="translated">Предложение по усовершенствованию Ним № 1-Стандартное руководство по библиотечному стилю</target>
        </trans-unit>
        <trans-unit id="088e91f2731d3d61908df7c6c9c0f48f04e35180" translate="yes" xml:space="preserve">
          <source>Nim IDE Integration Guide</source>
          <target state="translated">Интеграционное руководство Nim IDE</target>
        </trans-unit>
        <trans-unit id="ff5833e01f31589edf6457bc7ab5ad35afc09f25" translate="yes" xml:space="preserve">
          <source>Nim Manual</source>
          <target state="translated">Ним Инструкция</target>
        </trans-unit>
        <trans-unit id="a5cb0d9617774a42fc73cf0e3f868eb3b8c421d4" translate="yes" xml:space="preserve">
          <source>Nim OID support. An OID is a global ID that consists of a timestamp, a unique counter and a random value. This combination should suffice to produce a globally distributed unique ID. This implementation was extracted from the Mongodb interface and it thus binary compatible with a Mongo OID.</source>
          <target state="translated">Поддержка Nim OID.OID-это глобальный идентификатор,состоящий из метки времени,уникального счетчика и случайного значения.Эта комбинация должна быть достаточной для создания глобально распределенного уникального ID.Эта реализация была извлечена из интерфейса Mongodb и,таким образом,она бинарно совместима с Mongo OID.</target>
        </trans-unit>
        <trans-unit id="8afe44256c32445d4aba7446f16d139424f08995" translate="yes" xml:space="preserve">
          <source>Nim Standard Library</source>
          <target state="translated">Стандартная библиотека Ним</target>
        </trans-unit>
        <trans-unit id="322ec21475cb7cfeb95acf76114506a7658630c5" translate="yes" xml:space="preserve">
          <source>Nim Tutorial (Part I)</source>
          <target state="translated">Учебное пособие Ним (Часть I)</target>
        </trans-unit>
        <trans-unit id="e48ab7d7dac65733835e8b6fac71558fd72d4d0c" translate="yes" xml:space="preserve">
          <source>Nim Tutorial (Part II)</source>
          <target state="translated">Учебное пособие Ним (Часть II)</target>
        </trans-unit>
        <trans-unit id="ab4a51307d67466d1629dcfcafd64254208d0d47" translate="yes" xml:space="preserve">
          <source>Nim allows &lt;code&gt;.global, compiletime&lt;/code&gt; variables that can be filled by macro invokations across different modules. This feature breaks modularity in a severe way. Plenty of different solutions have been proposed:</source>
          <target state="translated">Nim допускает &lt;code&gt;.global, compiletime&lt;/code&gt; переменные времени компиляции, которые могут быть заполнены вызовами макросов в разных модулях. Эта особенность серьезно нарушает модульность. Было предложено множество различных решений:</target>
        </trans-unit>
        <trans-unit id="e7723fae5b868ab64bfd1ed4f9d563b3f719c2a6" translate="yes" xml:space="preserve">
          <source>Nim allows user defined operators. An operator is any combination of the following characters:</source>
          <target state="translated">Nim разрешает использование определенных пользователем операторов.Оператором является любая комбинация из следующих символов:</target>
        </trans-unit>
        <trans-unit id="dec77fd63ea6f3b6392da08312e8457c86c6a4ab" translate="yes" xml:space="preserve">
          <source>Nim allows user-definable operators. Binary operators have 11 different levels of precedence.</source>
          <target state="translated">Nim позволяет определять операторов.Двоичные операторы имеют 11 различных уровней приоритета.</target>
        </trans-unit>
        <trans-unit id="bb3ac87c3ce8cafa37c2ac5913d2e44f2c0fae11" translate="yes" xml:space="preserve">
          <source>Nim also allows for type classes and regular types to be specified as &lt;span id=&quot;type-constraints_1&quot;&gt;type constraints&lt;/span&gt; of the generic type parameter:</source>
          <target state="translated">Nim также позволяет указывать классы типов и обычные типы как &lt;span id=&quot;type-constraints_1&quot;&gt;ограничения&lt;/span&gt; типа для параметра универсального типа:</target>
        </trans-unit>
        <trans-unit id="c7367770c702c3c07c0edb5a157905ffed2fb24f" translate="yes" xml:space="preserve">
          <source>Nim avoids these problems by not assigning methods to a class. All methods in Nim are multi-methods. As we will see later, multi-methods are distinguished from procs only for dynamic binding purposes.</source>
          <target state="translated">Ним избегает этих проблем,не присваивая методы классу.Все методы в Nim являются мультиметодами.Как мы увидим позже,мультиметоды отличаются от procs только в целях динамического связывания.</target>
        </trans-unit>
        <trans-unit id="5fb26fe48597e8b904be37ef641797aa814138fa" translate="yes" xml:space="preserve">
          <source>Nim can also generate &lt;span id=&quot;javascript_1&quot;&gt;JavaScript&lt;/span&gt; code through the &lt;code&gt;js&lt;/code&gt; command.</source>
          <target state="translated">Nim также может генерировать код &lt;span id=&quot;javascript_1&quot;&gt;JavaScript с&lt;/span&gt; помощью команды &lt;code&gt;js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af85440d1b434e6ec278854daf1f3f305d5ad156" translate="yes" xml:space="preserve">
          <source>Nim code calling the backend</source>
          <target state="translated">Ним код,вызывающий внутреннюю часть</target>
        </trans-unit>
        <trans-unit id="6b156a5e46fd0f15d386450049ef7bee6965340f" translate="yes" xml:space="preserve">
          <source>Nim code can be compiled to JavaScript. However in order to write JavaScript-compatible code you should remember the following:</source>
          <target state="translated">Nim код может быть скомпилирован на JavaScript.Однако,чтобы написать JavaScript-совместимый код,необходимо помнить следующее:</target>
        </trans-unit>
        <trans-unit id="0c9fa29ab6035f83a6a5d536db8f22202827f364" translate="yes" xml:space="preserve">
          <source>Nim code can interface with the backend through the &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;Foreign function interface&lt;/a&gt; mainly through the &lt;a href=&quot;manual#importc-pragma&quot;&gt;importc pragma&lt;/a&gt;. The &lt;code&gt;importc&lt;/code&gt; pragma is the &lt;em&gt;generic&lt;/em&gt; way of making backend symbols available in Nim and is available in all the target backends (JavaScript too). The C++ or Objective-C backends have their respective &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp&lt;/a&gt; and &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC&lt;/a&gt; pragmas to call methods from classes.</source>
          <target state="translated">Код Nim может взаимодействовать с серверной &lt;a href=&quot;manual#importc-pragma&quot;&gt;частью&lt;/a&gt; через &lt;a href=&quot;manual#foreign-function-interface&quot;&gt;интерфейс внешней функции, в&lt;/a&gt; основном через прагму importc . &lt;code&gt;importc&lt;/code&gt; Прагма является &lt;em&gt;общим&lt;/em&gt; способом создания символов бэкэнда , доступных в Nim и доступно во всех целевых движках (JavaScript тоже). &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;Бэкэнды&lt;/a&gt; C ++ или Objective-C имеют соответствующие прагмы ImportCpp и &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC&lt;/a&gt; для вызова методов из классов.</target>
        </trans-unit>
        <trans-unit id="31a93bb37537ccf8bc65c227c96a067156777ba9" translate="yes" xml:space="preserve">
          <source>Nim code renderer (AST back to its textual form)</source>
          <target state="translated">Рендерер Nim кода (AST обратно в его текстовую форму)</target>
        </trans-unit>
        <trans-unit id="fabc8c2c3d55b64590195b71fee1f8bf15a0783b" translate="yes" xml:space="preserve">
          <source>Nim condition variable</source>
          <target state="translated">Nim условная переменная</target>
        </trans-unit>
        <trans-unit id="d2f3eed8f027ae703cfbb62e68bece8443bf88e7" translate="yes" xml:space="preserve">
          <source>Nim contains a sophisticated compile-time evaluator, so procedures which have no side-effect can be used in constant expressions too:</source>
          <target state="translated">Nim содержит сложный вычислитель времени компиляции,поэтому процедуры,не имеющие побочных эффектов,можно использовать и в константных выражениях:</target>
        </trans-unit>
        <trans-unit id="5a84a384a071f2c590cf4715be4dfac5778bd58a" translate="yes" xml:space="preserve">
          <source>Nim contains language features that are &lt;em&gt;global&lt;/em&gt;. The best example for that are multi methods: Introducing a new method with the same name and some compatible object parameter means that the method's dispatcher needs to take the new method into account. So the dispatching logic is only completely known after the whole program has been translated!</source>
          <target state="translated">Nim содержит &lt;em&gt;глобальные&lt;/em&gt; языковые функции . Лучшим примером для этого являются несколько методов: введение нового метода с тем же именем и некоторым совместимым параметром объекта означает, что диспетчер метода должен учитывать новый метод. Таким образом, логика диспетчеризации становится полностью известной только после того, как вся программа была переведена!</target>
        </trans-unit>
        <trans-unit id="fc85ea062290958c11ff84b074507e523841a2ee" translate="yes" xml:space="preserve">
          <source>Nim coroutines implementation supports several context switching methods: ucontext: available on unix and alike (default) setjmp: available on unix and alike (x86/64 only) Fibers: available and required on windows.</source>
          <target state="translated">Реализация Nim coroutines поддерживает несколько методов переключения контекста:ucontext:доступно в unix и так далее (по умолчанию)setjmp:доступно в unix и так далее (только x86/64)Fibers:доступно и требуется в окнах.</target>
        </trans-unit>
        <trans-unit id="bd26dc8c514bd37794fcd3b5dc3270d84d36b348" translate="yes" xml:space="preserve">
          <source>Nim currently generates &lt;em&gt;async/await&lt;/em&gt; JavaScript code which is supported in modern EcmaScript and most modern versions of browsers, Node.js and Electron. If you need to use this module with older versions of JavaScript, you can use a tool that backports the resulting JavaScript code, as babel.</source>
          <target state="translated">В настоящее время Nim генерирует код &lt;em&gt;async / await&lt;/em&gt; JavaScript, который поддерживается в современном EcmaScript и большинстве современных версий браузеров, Node.js и Electron. Если вам нужно использовать этот модуль со старыми версиями JavaScript, вы можете использовать инструмент, который выполняет резервное копирование результирующего кода JavaScript, как babel.</target>
        </trans-unit>
        <trans-unit id="9bb9f4917308e21a1a3ea298a44a71e622ad4adc" translate="yes" xml:space="preserve">
          <source>Nim differs from many other compilers in that it is really fast, and being so fast makes it suited to provide external queries for text editors about the source code being written. Through the &lt;code&gt;idetools&lt;/code&gt; command of &lt;a href=&quot;nimc&quot;&gt;the compiler&lt;/a&gt;, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">Nim отличается от многих других компиляторов тем, что он действительно быстр, и, будучи настолько быстрым, он подходит для предоставления внешних запросов текстовым редакторам о написанном исходном коде. С &lt;code&gt;idetools&lt;/code&gt; команды &lt;a href=&quot;nimc&quot;&gt;компилятора &lt;/a&gt;idetools любая IDE может запросить исходный файл &lt;code&gt;.nim&lt;/code&gt; и получить полезную информацию, такую ​​как определение символов или предложения для завершения.</target>
        </trans-unit>
        <trans-unit id="5f7c9cacf76b4e6e9b8bdb4149ed42fa0f2b0f03" translate="yes" xml:space="preserve">
          <source>Nim differs from many other compilers in that it is really fast, and being so fast makes it suited to provide external queries for text editors about the source code being written. Through the &lt;code&gt;nimsuggest&lt;/code&gt; tool, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">Nim отличается от многих других компиляторов тем, что он действительно быстр, и благодаря своей скорости он подходит для предоставления внешних запросов для текстовых редакторов о написанном исходном коде. С &lt;code&gt;nimsuggest&lt;/code&gt; инструмента nimsuggest любая IDE может запросить исходный файл &lt;code&gt;.nim&lt;/code&gt; и получить полезную информацию, такую ​​как определение символов или предложения для завершения.</target>
        </trans-unit>
        <trans-unit id="2086951d5e25c94d3bcd3c946d696aab645c5e42" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;traced_1&quot;&gt;traced&lt;/span&gt; and &lt;span id=&quot;untraced_1&quot;&gt;untraced&lt;/span&gt; references. Untraced references are also called &lt;em&gt;pointers&lt;/em&gt;. Traced references point to objects in a garbage collected heap, untraced references point to manually allocated objects or to objects elsewhere in memory. Thus untraced references are &lt;em&gt;unsafe&lt;/em&gt;. However for certain low-level operations (e.g., accessing the hardware), untraced references are necessary.</source>
          <target state="translated">Nim различает &lt;span id=&quot;traced_1&quot;&gt;отслеживаемые&lt;/span&gt; и &lt;span id=&quot;untraced_1&quot;&gt;неотслеживаемые&lt;/span&gt; ссылки. Не отслеживаемые ссылки также называются &lt;em&gt;указателями&lt;/em&gt; . Отслеживаемые ссылки указывают на объекты в куче со сборкой мусора, неотслеживаемые ссылки указывают на вручную выделенные объекты или на объекты в другом месте в памяти. Таким образом, неотслеживаемые ссылки &lt;em&gt;небезопасны&lt;/em&gt; . Однако для некоторых низкоуровневых операций (например, доступа к оборудованию) необходимы неотслеживаемые ссылки.</target>
        </trans-unit>
        <trans-unit id="ccd83d27c6d420699215e95b7549c5d18179dd95" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;traced_1&quot;&gt;traced&lt;/span&gt; and &lt;span id=&quot;untraced_1&quot;&gt;untraced&lt;/span&gt; references. Untraced references are also called &lt;em&gt;pointers&lt;/em&gt;. Traced references point to objects of a garbage collected heap, untraced references point to manually allocated objects or to objects somewhere else in memory. Thus untraced references are &lt;em&gt;unsafe&lt;/em&gt;. However for certain low-level operations (accessing the hardware) untraced references are unavoidable.</source>
          <target state="translated">Nim различает &lt;span id=&quot;traced_1&quot;&gt;отслеживаемые&lt;/span&gt; и &lt;span id=&quot;untraced_1&quot;&gt;неотслеживаемые&lt;/span&gt; ссылки. Не отслеживаемые ссылки также называются &lt;em&gt;указателями&lt;/em&gt; . Отслеживаемые ссылки указывают на объекты в куче со сборкой мусора, неотслеживаемые ссылки указывают на вручную выделенные объекты или на объекты где-то еще в памяти. Таким образом, неотслеживаемые ссылки &lt;em&gt;небезопасны&lt;/em&gt; . Однако для некоторых низкоуровневых операций (доступ к оборудованию) неотслеживаемые ссылки неизбежны.</target>
        </trans-unit>
        <trans-unit id="dac7bba6bc8f19f6387033c2480f36e741751cd5" translate="yes" xml:space="preserve">
          <source>Nim distinguishes between &lt;span id=&quot;type-casts_1&quot;&gt;type casts&lt;/span&gt; and &lt;span id=&quot;type-conversions_1&quot;&gt;type conversions&lt;/span&gt;. Casts are done with the &lt;code&gt;cast&lt;/code&gt; operator and force the compiler to interpret a bit pattern to be of another type.</source>
          <target state="translated">Nim различает &lt;span id=&quot;type-casts_1&quot;&gt;приведение типов&lt;/span&gt; и &lt;span id=&quot;type-conversions_1&quot;&gt;преобразование типов&lt;/span&gt; . Слепки сделаны с &lt;code&gt;cast&lt;/code&gt; оператора и заставить компилятор интерпретирует битовый шаблон быть другого типа.</target>
        </trans-unit>
        <trans-unit id="0dc26f37589711a4ebd6a75d29c4f31d6f5268ca" translate="yes" xml:space="preserve">
          <source>Nim documentation tools</source>
          <target state="translated">Инструменты документирования Nim</target>
        </trans-unit>
        <trans-unit id="32a303beaf961d29337f0ffeb398d9c829260321" translate="yes" xml:space="preserve">
          <source>Nim expression</source>
          <target state="translated">Ним выражением</target>
        </trans-unit>
        <trans-unit id="835ecda86802386305ce589edd8369f0e4a635cf" translate="yes" xml:space="preserve">
          <source>Nim file input</source>
          <target state="translated">Входной файл Ним</target>
        </trans-unit>
        <trans-unit id="07b88f09d9e474dda1eb0ea8c1cc96c629f4c605" translate="yes" xml:space="preserve">
          <source>Nim for embedded systems</source>
          <target state="translated">Ним для встраиваемых систем</target>
        </trans-unit>
        <trans-unit id="a0e42e450f6ef10bfc996fbef965403967ca2952" translate="yes" xml:space="preserve">
          <source>Nim for realtime systems</source>
          <target state="translated">Ним для систем реального времени</target>
        </trans-unit>
        <trans-unit id="ad31881a208f486ef9ab2bb940bdcd789a709ad9" translate="yes" xml:space="preserve">
          <source>Nim generates some warnings and hints (&quot;line too long&quot;) that may annoy the user. A mechanism for disabling certain messages is provided: Each hint and warning message contains a symbol in brackets. This is the message's identifier that can be used to enable or disable it:</source>
          <target state="translated">Nim генерирует некоторые предупреждения и подсказки (&quot;строка слишком длинная&quot;),которые могут раздражать пользователя.Предусмотрен механизм отключения некоторых сообщений:Каждая подсказка и предупреждение содержит символ в скобках.Это идентификатор сообщения,который может быть использован для его включения или отключения:</target>
        </trans-unit>
        <trans-unit id="956810679fde5bcd94729ea5a195b781ebc9936f" translate="yes" xml:space="preserve">
          <source>Nim has a builtin thread pool that can be used for CPU intensive tasks. For IO intensive tasks the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; features should be used instead. Both parallel and spawn need the &lt;a href=&quot;threadpool&quot;&gt;threadpool&lt;/a&gt; module to work.</source>
          <target state="translated">Nim имеет встроенный пул потоков, который можно использовать для задач, интенсивно использующих процессор. Вместо этого для задач с интенсивным &lt;code&gt;async&lt;/code&gt; &lt;code&gt;await&lt;/code&gt; следует использовать функции async и await . И parallel, и spawn нуждаются в модуле &lt;a href=&quot;threadpool&quot;&gt;threadpool&lt;/a&gt; для работы.</target>
        </trans-unit>
        <trans-unit id="8271465a18dfd05fb2b43750bb600424d58f8d93" translate="yes" xml:space="preserve">
          <source>Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this a special setter syntax is needed:</source>
          <target state="translated">Nim не нуждается в &lt;em&gt;get-свойствах&lt;/em&gt; : обычные get-процедуры, вызываемые с помощью &lt;em&gt;синтаксиса вызова методов,&lt;/em&gt; достигают того же. Но установка значения отличается; для этого необходим специальный синтаксис сеттера:</target>
        </trans-unit>
        <trans-unit id="73a3428d8f1eb98b6a56266f5afa22c38fb951ee" translate="yes" xml:space="preserve">
          <source>Nim has no separate optimizer, but the C code that is produced is very efficient. Most C compilers have excellent optimizers, so usually it is not needed to optimize one's code. Nim has been designed to encourage efficient code: The most readable code in Nim is often the most efficient too.</source>
          <target state="translated">У Nim нет отдельного оптимизатора,но создаваемый код на C очень эффективен.Большинство компиляторов Си имеют отличные оптимизаторы,поэтому,как правило,оптимизировать свой код не требуется.Nim был разработан для поощрения эффективного кода:Самый читаемый код в Nim тоже часто бывает самым эффективным.</target>
        </trans-unit>
        <trans-unit id="d4433d8ee67c60caa5f14cbc4d36fb3fc5be0287" translate="yes" xml:space="preserve">
          <source>Nim has the concept of a global search path (PATH) that is queried to determine where to find imported modules or include files. If multiple files are found an ambiguity error is produced.</source>
          <target state="translated">Nim имеет концепцию глобального пути поиска (PATH),который опрашивается,чтобы определить,где найти импортируемые модули или включаемые файлы.Если найдено несколько файлов,то возникает ошибка неоднозначности.</target>
        </trans-unit>
        <trans-unit id="01727ad8d0bbaeeea62faa6f12c71312bf1ae451" translate="yes" xml:space="preserve">
          <source>Nim has these floating point types built-in: &lt;code&gt;float float32 float64&lt;/code&gt;.</source>
          <target state="translated">В Nim есть встроенные типы с плавающей запятой: &lt;code&gt;float float32 float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3deb8348e9e32056d74290a50d876e63851d29" translate="yes" xml:space="preserve">
          <source>Nim has these integer types built-in: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt;.</source>
          <target state="translated">В Nim есть встроенные целочисленные типы: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4f95676cbff4f6b732c078d876ae2ad27f446" translate="yes" xml:space="preserve">
          <source>Nim has two flavors of parallelism:</source>
          <target state="translated">Ним имеет два вкуса параллелизма:</target>
        </trans-unit>
        <trans-unit id="dc5bf296e3c41484c147bfc3cd569c0d2a605bfb" translate="yes" xml:space="preserve">
          <source>Nim idetools integration</source>
          <target state="translated">Интеграция Nim idetools</target>
        </trans-unit>
        <trans-unit id="fde430a55fc171aea53e7cacfbb81ff6931bd1b5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from C</source>
          <target state="translated">Пример ссылки на Ним из C</target>
        </trans-unit>
        <trans-unit id="a9b0c283f30ebbd8bbc505d567707e20b58f9be5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from JavaScript</source>
          <target state="translated">Пример Nim вызова из JavaScript</target>
        </trans-unit>
        <trans-unit id="bdd28046b42c51d6419a24b949f2e431ad33feda" translate="yes" xml:space="preserve">
          <source>Nim is free software; it is licensed under the &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT License&lt;/a&gt;.</source>
          <target state="translated">Nim - бесплатное программное обеспечение; он находится под &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;лицензией MIT License&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c7393409ca98f35a585605ecd27b0ce04bc6dc" translate="yes" xml:space="preserve">
          <source>Nim lock, re-entrant</source>
          <target state="translated">Ним-блок,повторный вход</target>
        </trans-unit>
        <trans-unit id="af2f77b6798efd1fe7af2c6d48238ea2e59af4d3" translate="yes" xml:space="preserve">
          <source>Nim lock; whether this is re-entrant or not is unspecified!</source>
          <target state="translated">Ним-блок;является ли это повторный вход или нет,не определено!</target>
        </trans-unit>
        <trans-unit id="396c55174c1748ab5bec4b1cb866abf79d300e48" translate="yes" xml:space="preserve">
          <source>Nim maintenance script</source>
          <target state="translated">Скрипт обслуживания Nim</target>
        </trans-unit>
        <trans-unit id="200b4437aaf50df9807fc02a8b32574618effddb" translate="yes" xml:space="preserve">
          <source>Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.</source>
          <target state="translated">Nim предлагает специальное семейство точечных операторов,которые могут быть использованы для перехвата и перезаписи proc вызовов и попыток доступа к полям,ссылаясь на ранее незаявленные имена символов.Они могут быть использованы для обеспечения свободного интерфейса для объектов,лежащих за пределами статических границ системы типов,таких как значения из динамических языков сценариев или динамических форматов файлов,таких как JSON или XML.</target>
        </trans-unit>
        <trans-unit id="67e6a58d0659f4167e32702de63a078a70b84e7d" translate="yes" xml:space="preserve">
          <source>Nim offers bidirectional interfacing with the target backend. This means that you can call backend code from Nim and Nim code can be called by the backend code. Usually the direction of which calls which depends on your software architecture (is Nim your main program or is Nim providing a component?).</source>
          <target state="translated">Nim предлагает двунаправленную связь с бэкэндом цели.Это означает,что вы можете вызывать бэкэнд код с Nim,а Nim код может вызываться по бэкэнд коду.Обычно направление,в котором звонят,зависит от архитектуры вашего программного обеспечения (Nim-ваша основная программа или Nim предоставляет компонент?).</target>
        </trans-unit>
        <trans-unit id="893f066137f8187ed8a07f2272b19d0871bbc768" translate="yes" xml:space="preserve">
          <source>Nim produces a warning for symbols that are not exported and not used either. The &lt;code&gt;used&lt;/code&gt; pragma can be attached to a symbol to suppress this warning. This is particularly useful when the symbol was generated by a macro:</source>
          <target state="translated">Nim выдает предупреждение для символов, которые не экспортируются и не используются. &lt;code&gt;used&lt;/code&gt; прагма может быть присоединена к символу , чтобы подавить это предупреждение. Это особенно полезно, когда символ был сгенерирован макросом:</target>
        </trans-unit>
        <trans-unit id="6150bb7b7dad74d65ce46c3a55145c510735a725" translate="yes" xml:space="preserve">
          <source>Nim provides language integration with external IDEs through the idetools command. See the documentation of &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; for further information.</source>
          <target state="translated">Nim обеспечивает языковую интеграцию с внешними IDE с помощью команды idetools. См. Документацию &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="6864a9277154b157b94a761e493fbd79ef8b809c" translate="yes" xml:space="preserve">
          <source>Nim provides the &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; and &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; commands to generate HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files. Only exported symbols will appear in the output. For more details &lt;a href=&quot;docgen&quot;&gt;see the docgen documentation&lt;/a&gt;.</source>
          <target state="translated">Nim предоставляет команды &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; и &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; для создания HTML-документации из исходных файлов &lt;code&gt;.nim&lt;/code&gt; . На выходе будут отображаться только экспортированные символы. Подробнее &lt;a href=&quot;docgen&quot;&gt;см. Документацию docgen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d0f9e0827a8dbea31dc2fbe4ce37db63cfa840c" translate="yes" xml:space="preserve">
          <source>Nim provides the ability to overload procedures similar to C++:</source>
          <target state="translated">Nim предоставляет возможность перегружать процедуры,аналогичные C++:</target>
        </trans-unit>
        <trans-unit id="082cc471f7e487d0e261d56375fe2f285b9ead9d" translate="yes" xml:space="preserve">
          <source>Nim provides the pragmas &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; and &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; to control whether the IEEE exceptions are ignored or trap a Nim exception:</source>
          <target state="translated">Nim предоставляет &lt;span id=&quot;nanchecks_1&quot;&gt;прагмы nanChecks&lt;/span&gt; и &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; для управления тем, игнорируются ли исключения IEEE или перехватываются исключения Nim:</target>
        </trans-unit>
        <trans-unit id="86a99b555e8d5a547fbd7a8b6c3c5be83dc59b13" translate="yes" xml:space="preserve">
          <source>Nim search and replace utility.</source>
          <target state="translated">Поиск Ним и замена утилиты.</target>
        </trans-unit>
        <trans-unit id="cea72c6813825983207ed89ef6d7563250a6be64" translate="yes" xml:space="preserve">
          <source>Nim significantly improves on the safety of these features via additional pragmas:</source>
          <target state="translated">Nim значительно повышает безопасность этих функций благодаря дополнительным прагмам:</target>
        </trans-unit>
        <trans-unit id="13adb76d4a44fc6d0ed9557643b94613f8b29151" translate="yes" xml:space="preserve">
          <source>Nim support for &lt;span id=&quot;substitution-expressions_1&quot;&gt;substitution expressions&lt;/span&gt; (&lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt;).</source>
          <target state="translated">Nim поддерживает &lt;span id=&quot;substitution-expressions_1&quot;&gt;подстановочные выражения&lt;/span&gt; ( &lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="f308ae3443ec85df73ede4f78102be2e349b672c" translate="yes" xml:space="preserve">
          <source>Nim supports exception tracking. The &lt;span id=&quot;raises_1&quot;&gt;raises&lt;/span&gt; pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this:</source>
          <target state="translated">Nim поддерживает отслеживание исключений. &lt;span id=&quot;raises_1&quot;&gt;Повышает&lt;/span&gt; прагма может использоваться , чтобы явно определить , какие исключения прок / итератор / метод / конвертер разрешается поднять. Компилятор это проверяет:</target>
        </trans-unit>
        <trans-unit id="3f7af30571e6dd9a4e1318813044e95e94a257fb" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own &lt;span id=&quot;namespace_1&quot;&gt;namespace&lt;/span&gt;. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to symbols of another module by the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;Recursive module dependencies&lt;/span&gt; are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is &lt;code&gt;identifier.nim&lt;/code&gt;).</source>
          <target state="translated">Nim поддерживает разделение программы на части по модульной концепции. Каждый модуль должен находиться в собственном файле и иметь собственное &lt;span id=&quot;namespace_1&quot;&gt;пространство имен&lt;/span&gt; . Модули позволяют &lt;span id=&quot;information-hiding_1&quot;&gt;скрывать информацию&lt;/span&gt; и &lt;span id=&quot;separate-compilation_1&quot;&gt;раздельную компиляцию&lt;/span&gt; . Модуль может получить доступ к символам другого модуля с помощью оператора &lt;span id=&quot;import_1&quot;&gt;импорта&lt;/span&gt; . &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;Рекурсивные зависимости модуля&lt;/span&gt; разрешены, но слегка незаметны. Экспортируются только символы верхнего уровня, отмеченные звездочкой ( &lt;code&gt;*&lt;/code&gt; ). Допустимое имя модуля может быть только действительным идентификатором Nim (и, следовательно, его имя файла - &lt;code&gt;identifier.nim&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e44eef4a789fd3c119666d4ed23cb9494cb3bbf7" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces with a module concept. Each module is in its own file. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to the symbols of another module by using the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported:</source>
          <target state="translated">Nim поддерживает разделение программы на части с помощью модульной концепции. Каждый модуль находится в собственном файле. Модули позволяют &lt;span id=&quot;information-hiding_1&quot;&gt;скрыть информацию&lt;/span&gt; и &lt;span id=&quot;separate-compilation_1&quot;&gt;раздельную компиляцию&lt;/span&gt; . Модуль может получить доступ к символам другого модуля с помощью оператора &lt;span id=&quot;import_1&quot;&gt;импорта&lt;/span&gt; . Экспортируются только символы верхнего уровня, отмеченные звездочкой ( &lt;code&gt;*&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="46fdd12ce5e87d8ce22525d0fc7e670179c0d9e1" translate="yes" xml:space="preserve">
          <source>Nim supports the generation of DLLs. However, there must be only one instance of the GC per process/address space. This instance is contained in &lt;code&gt;nimrtl.dll&lt;/code&gt;. This means that every generated Nim DLL depends on &lt;code&gt;nimrtl.dll&lt;/code&gt;. To generate the &quot;nimrtl.dll&quot; file, use the command:</source>
          <target state="translated">Nim поддерживает создание библиотек DLL. Однако должен быть только один экземпляр GC на процесс / адресное пространство. Этот экземпляр содержится в &lt;code&gt;nimrtl.dll&lt;/code&gt; . Это означает, что каждая сгенерированная Nim DLL зависит от &lt;code&gt;nimrtl.dll&lt;/code&gt; . Чтобы сгенерировать файл &quot;nimrtl.dll&quot;, используйте команду:</target>
        </trans-unit>
        <trans-unit id="9716569bd8c70a883cc816b4d661c7ea0ac3b2d4" translate="yes" xml:space="preserve">
          <source>Nim supports these &lt;span id=&quot;calling-conventions_1&quot;&gt;calling conventions&lt;/span&gt;:</source>
          <target state="translated">Nim поддерживает следующие &lt;span id=&quot;calling-conventions_1&quot;&gt;соглашения о вызовах&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="abcf9d9cfc4c5456a80f226fb54d7c37497efa51" translate="yes" xml:space="preserve">
          <source>Nim targets JavaScript 1.5 which is supported by any widely used browser. Since JavaScript does not have a portable means to include another module, Nim just generates a long &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Nim нацелен на JavaScript 1.5, который поддерживается всеми широко используемыми браузерами. Поскольку в JavaScript нет переносимых средств для включения другого модуля, Nim просто генерирует длинный файл &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6334ba658939fb66c6d2eb5152d5c5e1ed6cc5c" translate="yes" xml:space="preserve">
          <source>Nim type</source>
          <target state="translated">Тип Ним</target>
        </trans-unit>
        <trans-unit id="12a335b577d343cb196e9cbe8abf689f02aa0bd4" translate="yes" xml:space="preserve">
          <source>Nim uses structural type equivalence for most types. Only for objects, enumerations and distinct types name equivalence is used. The following algorithm, &lt;em&gt;in pseudo-code&lt;/em&gt;, determines type equality:</source>
          <target state="translated">Nim использует эквивалентность структурных типов для большинства типов. Только для объектов, перечислений и различных типов используется эквивалентность имен. Следующий алгоритм &lt;em&gt;в псевдокоде&lt;/em&gt; определяет равенство типов:</target>
        </trans-unit>
        <trans-unit id="1870e8d051fa7bd2733b9612e24fa28e4e1bd585" translate="yes" xml:space="preserve">
          <source>Nim uses the classic compiler architecture: A lexer/scanner feds tokens to a parser. The parser builds a syntax tree that is used by the code generator. This syntax tree is the interface between the parser and the code generator. It is essential to understand most of the compiler's code.</source>
          <target state="translated">Ним использует классическую архитектуру компилятора:Лексер/сканер передает токены синтаксическому анализатору.Синтаксический анализатор строит синтаксическое дерево,которое используется генератором кода.Это синтаксическое дерево является интерфейсом между синтаксическим анализатором и генератором кода.Важно понимать большую часть кода компилятора.</target>
        </trans-unit>
        <trans-unit id="322b8b83d95b2969c2c0f758d4cccd2596086dda" translate="yes" xml:space="preserve">
          <source>Nim uses the common statement/expression paradigm: Statements do not produce a value in contrast to expressions. However, some expressions are statements.</source>
          <target state="translated">Ним использует общую парадигму оператора/выражения:операторы не производят значения в отличие от выражений.Однако некоторые выражения являются операторами.</target>
        </trans-unit>
        <trans-unit id="16bf12211c3e06c6eb9e50a3ff54ca759ba185c1" translate="yes" xml:space="preserve">
          <source>Nim&amp;#x27;s Garbage Collector</source>
          <target state="translated">Сборщик мусора Нима</target>
        </trans-unit>
        <trans-unit id="9e747b8df254ba8adeea93bf65d5d26fc1f7c029" translate="yes" xml:space="preserve">
          <source>Nim's &lt;code&gt;import&lt;/code&gt; statement actually takes different variations depending on what keywords are present. Let's start with the simplest form.</source>
          <target state="translated">Оператор &lt;code&gt;import&lt;/code&gt; Nim на самом деле принимает разные варианты в зависимости от того, какие ключевые слова присутствуют. Начнем с самой простой формы.</target>
        </trans-unit>
        <trans-unit id="576ef403ca389194e42a3457f0afbf3573e97c72" translate="yes" xml:space="preserve">
          <source>Nim's &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (foreign function interface) is extensive and only the parts that scale to other future backends (like the LLVM/JavaScript backends) are documented here.</source>
          <target state="translated">&lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (интерфейс внешних функций) Nim обширен, и здесь документированы только те части, которые масштабируются для других будущих бэкэндов (например, бэкэнды LLVM / JavaScript).</target>
        </trans-unit>
        <trans-unit id="b3a2a3b0146362c9c774e923c0df1b46db23ed52" translate="yes" xml:space="preserve">
          <source>Nim's Garbage Collector</source>
          <target state="translated">Мусорщик Нима</target>
        </trans-unit>
        <trans-unit id="a41682260d59280a2b3b6483204da1644fe3e4a8" translate="yes" xml:space="preserve">
          <source>Nim's boolean type is called &lt;code&gt;bool&lt;/code&gt; and consists of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in while, if, elif, and when statements must be of type bool.</source>
          <target state="translated">Логический тип Нима называется &lt;code&gt;bool&lt;/code&gt; и состоит из двух предопределенных значений &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; . Условия в операторах while, if, elif и when должны иметь тип bool.</target>
        </trans-unit>
        <trans-unit id="13ee675d367062e6a639dae94168d9a9c1a41f44" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different from other common programming languages (C, Pascal): Each thread has its own (garbage collected) heap and sharing of memory is restricted. This helps to prevent race conditions and improves efficiency. See &lt;a href=&quot;manual#threads&quot;&gt;the manual for details of this memory model&lt;/a&gt;.</source>
          <target state="translated">Модель памяти Nim для потоков сильно отличается от других распространенных языков программирования (C, Pascal): у каждого потока есть своя куча (собранная со сборкой мусора), а совместное использование памяти ограничено. Это помогает предотвратить состояние гонки и повышает эффективность. Подробную &lt;a href=&quot;manual#threads&quot;&gt;информацию об этой модели памяти&lt;/a&gt; см. В руководстве .</target>
        </trans-unit>
        <trans-unit id="e98391c7155144865c0c684166fb6f91c4167fcb" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference. Memory allocation requires no lock at all! This design easily scales to massive multicore processors that are becoming the norm.</source>
          <target state="translated">Модель памяти Nim для потоков сильно отличается от моделей других распространенных языков программирования (C,Pascal,Java):Каждый поток имеет свою собственную (собранный мусор)кучу,а совместное использование памяти ограничено глобальными переменными.Это помогает предотвратить условия гонки.Эффективность GC повышается достаточно сильно,так как GC никогда не должен останавливать другие потоки и видеть,на что они ссылаются.Распределение памяти не требует блокировки вообще! Этот дизайн легко масштабируется до массивных многоядерных процессоров,которые становятся нормой.</target>
        </trans-unit>
        <trans-unit id="9bd526290438cb61dffae2d2e60576f140904aaf" translate="yes" xml:space="preserve">
          <source>Nim's object syntax is rich. Let's take a look at an involved example in its entirety to see some of the complexities.</source>
          <target state="translated">Синтаксис объектов Нима богат.Давайте посмотрим на задействованный пример во всей его полноте,чтобы увидеть некоторые сложности.</target>
        </trans-unit>
        <trans-unit id="0d1938981c78468bfa1d2da1e306dcbcb6376cdd" translate="yes" xml:space="preserve">
          <source>Nim's parser</source>
          <target state="translated">парсер Нима</target>
        </trans-unit>
        <trans-unit id="acf2817c0d9f0b146da2d625488e15fe41115e79" translate="yes" xml:space="preserve">
          <source>Nim's standard grammar describes an &lt;span id=&quot;indentation-sensitive_1&quot;&gt;indentation sensitive&lt;/span&gt; language. This means that all the control structures are recognized by indentation. Indentation consists only of spaces; tabulators are not allowed.</source>
          <target state="translated">Стандартная грамматика Нима описывает язык, &lt;span id=&quot;indentation-sensitive_1&quot;&gt;чувствительный&lt;/span&gt; к &lt;span id=&quot;indentation-sensitive_1&quot;&gt;отступам&lt;/span&gt; . Это означает, что все управляющие структуры распознаются по отступам. Отступ состоит только из пробелов; Табуляторы не допускаются.</target>
        </trans-unit>
        <trans-unit id="1452a3d3fd11615a428ccdddc1e755ffef521766" translate="yes" xml:space="preserve">
          <source>Nim's standard random number generator. Based on the &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor/rotate/shift/rotate) library.</source>
          <target state="translated">Стандартный генератор случайных чисел Нима. На основе &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor / rotate / shift / rotate).</target>
        </trans-unit>
        <trans-unit id="ea6b14412133ed2489b730e9fc4f06291eb4e8ce" translate="yes" xml:space="preserve">
          <source>Nimble</source>
          <target state="translated">Nimble</target>
        </trans-unit>
        <trans-unit id="5e3bca65182fa05bd8858bec9a6e6900f87e2adf" translate="yes" xml:space="preserve">
          <source>Nimble is a package manager for the Nim programming language. For instructions on how to install Nimble packages see &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;its README&lt;/a&gt;.</source>
          <target state="translated">Nimble - это менеджер пакетов для языка программирования Nim. Инструкции по установке пакетов Nimble см. В &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;README&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5af01d1d4ff2ceea4a8135b93a3b16c4bb879507" translate="yes" xml:space="preserve">
          <source>Nimcache and C like targets</source>
          <target state="translated">Nimcache и C любят мишени</target>
        </trans-unit>
        <trans-unit id="d63113aa6032c199ac973f9c41b92f6b86bc69c5" translate="yes" xml:space="preserve">
          <source>Nimcache and the Javascript target</source>
          <target state="translated">Nimcache и цель Javascript</target>
        </trans-unit>
        <trans-unit id="7a7b1200d84cdfcc90e4068e405d16fe626da360" translate="yes" xml:space="preserve">
          <source>Nimcache naming logic</source>
          <target state="translated">Логика именования Nimcache</target>
        </trans-unit>
        <trans-unit id="71db390f7498c8607ecf76f70925348383f07f46" translate="yes" xml:space="preserve">
          <source>Nimgrep has particularly good support for Nim's eccentric &lt;em&gt;style insensitivity&lt;/em&gt;. Apart from that it is a generic text manipulation tool.</source>
          <target state="translated">Nimgrep особенно хорошо поддерживает &lt;em&gt;бесчувственность&lt;/em&gt; эксцентричного &lt;em&gt;стиля&lt;/em&gt; Nim . Кроме того, это универсальный инструмент для работы с текстом.</target>
        </trans-unit>
        <trans-unit id="23ef2cadfc8ec56820149ad08675af48b8c2a012" translate="yes" xml:space="preserve">
          <source>Nimgrep is a command line tool for search&amp;amp;replace tasks. It can search for regex or peg patterns and can search whole directories at once. User confirmation for every single replace operation can be requested.</source>
          <target state="translated">Nimgrep - это инструмент командной строки для поиска и замены задач. Он может искать шаблоны регулярных выражений или привязок и может искать сразу целые каталоги. Можно запросить подтверждение пользователя для каждой отдельной операции замены.</target>
        </trans-unit>
        <trans-unit id="b1cf2ee07bf536474f8a79eec9ae5297ea46f5b0" translate="yes" xml:space="preserve">
          <source>Nimsuggest for IDE support</source>
          <target state="translated">Nimsuggest для IDE поддержки</target>
        </trans-unit>
        <trans-unit id="74dadd5fc671c88eec7c8cc084b2f4492ce2f149" translate="yes" xml:space="preserve">
          <source>Nimsuggest invocation</source>
          <target state="translated">Нимсуггестское призвание</target>
        </trans-unit>
        <trans-unit id="5621d2e904ec7f4a1fa59a63968518771b43d445" translate="yes" xml:space="preserve">
          <source>Nimsuggest is part of Nim's core. Build it via:</source>
          <target state="translated">Нимсуггест-часть ядра Нима.Постройте его:</target>
        </trans-unit>
        <trans-unit id="b9338b400871e7a753e81682f58f03a8156017e7" translate="yes" xml:space="preserve">
          <source>Nimsuggest output is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Вывод Nimsuggest всегда возвращается в виде отдельных строк, разделенных символами табуляции ( &lt;code&gt;\t&lt;/code&gt; ). Значения каждого столбца:</target>
        </trans-unit>
        <trans-unit id="5372c202a30284da7742441a108b564cdbdf5739" translate="yes" xml:space="preserve">
          <source>Nimsuggest than waits for queries to process. A query consists of a cryptic 3 letter &quot;command&quot; &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;con&lt;/code&gt; or &lt;code&gt;sug&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; followed by a location. A query location consists of:</source>
          <target state="translated">Nimsuggest, чем ожидает обработки запросов. Запрос состоит из &amp;laquo;команды&amp;raquo; скрытой 3 буквы &lt;code&gt;def&lt;/code&gt; или &lt;code&gt;con&lt;/code&gt; или &lt;code&gt;sug&lt;/code&gt; или &lt;code&gt;use&lt;/code&gt; с последующим расположением. Местоположение запроса состоит из:</target>
        </trans-unit>
        <trans-unit id="95165223d15af7cefab907c1e06b8b4044d588d9" translate="yes" xml:space="preserve">
          <source>Nimsuggest will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">Nimsuggest всегда будет отвечать одним определением или ни одним,если не найдет ни одного правильного символа,совпадающего с позицией запроса.</target>
        </trans-unit>
        <trans-unit id="fb05c02eb40dd8659b5825634b0887e886c359fc" translate="yes" xml:space="preserve">
          <source>No longer actually used</source>
          <target state="translated">Больше не используется</target>
        </trans-unit>
        <trans-unit id="75b9c1b54338d8b9332efccba32605f983f91029" translate="yes" xml:space="preserve">
          <source>NoDecl pragma</source>
          <target state="translated">Прагма NoDecl</target>
        </trans-unit>
        <trans-unit id="83c63e0618d33e20ddbbc5fcacaa83b0217e5a9a" translate="yes" xml:space="preserve">
          <source>Non-default delimiters can be passed to allow iteration over other sorts of &quot;line-like&quot; variable length records. Pass eat='\0' to be strictly &lt;em&gt;delim&lt;/em&gt;-delimited. (Eating an optional prefix equal to '\0' is not supported.)</source>
          <target state="translated">Могут быть переданы не стандартные по умолчанию разделители, чтобы разрешить итерацию по другим видам &amp;laquo;строковых&amp;raquo; записей переменной длины. Проходят съедать = '\ 0' , чтобы быть строго &lt;em&gt;DELIM&lt;/em&gt; -delimited. (Использование необязательного префикса, равного '\ 0', не поддерживается.)</target>
        </trans-unit>
        <trans-unit id="51982015db8c39d38da4e016c910ad96f798d0ca" translate="yes" xml:space="preserve">
          <source>Non-printing characters</source>
          <target state="translated">Ненапечатанные символы</target>
        </trans-unit>
        <trans-unit id="418bd9eb8597b90fb89b70c50e626f53d89d17ca" translate="yes" xml:space="preserve">
          <source>Non-pure enum values should use camelCase whereas pure enum values should use PascalCase.</source>
          <target state="translated">Нечистые значения перечисления должны использовать верблюжью кость,в то время как чистые значения перечисления должны использовать PascalCase.</target>
        </trans-unit>
        <trans-unit id="f8d7bfd0d37a23478caf5e01ccd5869426102765" translate="yes" xml:space="preserve">
          <source>Non-terminals start with a lowercase letter, abstract terminal symbols are in UPPERCASE. Verbatim terminal symbols (including keywords) are quoted with &lt;code&gt;'&lt;/code&gt;. An example:</source>
          <target state="translated">Нетерминальные символы начинаются со строчной буквы, абстрактные терминальные символы - в ВЕРХНЕМ РЕГИСТРЕ. Дословные терминальные символы (включая ключевые слова) заключаются в кавычки с &lt;code&gt;'&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="461551ab6e0521d38c563c8b4f15319bef024ec5" translate="yes" xml:space="preserve">
          <source>None of the procs that get an individual value from the deque can be used on an empty deque. If compiled with &lt;em&gt;boundChecks&lt;/em&gt; option, those procs will raise an &lt;em&gt;IndexError&lt;/em&gt; on such access. This should not be relied upon, as &lt;em&gt;-d:release&lt;/em&gt; will disable those checks and may return garbage or crash the program.</source>
          <target state="translated">Ни один из процессов, которые получают индивидуальное значение из двухсторонней очереди, не может использоваться на пустой двухсторонней очереди. Если скомпилирован с опцией &lt;em&gt;boundChecks&lt;/em&gt; , эти процедуры &lt;em&gt;вызовут IndexError&lt;/em&gt; при таком доступе. На это не следует полагаться, поскольку &lt;em&gt;-d: release&lt;/em&gt; отключит эти проверки и может вернуть мусор или привести к сбою программы.</target>
        </trans-unit>
        <trans-unit id="eb4fc459eedc650eb7092ee10047a19689f0d4cd" translate="yes" xml:space="preserve">
          <source>Nonoverloadable builtins</source>
          <target state="translated">Неперегружаемые конструкции</target>
        </trans-unit>
        <trans-unit id="cb66dc661861f381636ef80a030d6e4f15642186" translate="yes" xml:space="preserve">
          <source>Normal symbols are added to the index with surrounding whitespaces removed. An exception to this are table of content (TOC) entries. TOC entries are added to the index file with their third column having as much prefix spaces as their level is in the TOC (at least 1 character). The prefix whitespace helps to filter TOC entries from API or text symbols. This is important because the amount of spaces is used to replicate the hiearchy for document TOCs in the final index, and TOC entries found in &lt;code&gt;.nim&lt;/code&gt; files are discarded.</source>
          <target state="translated">Обычные символы добавляются к индексу с удалением окружающих пробелов. Исключением являются записи в таблице содержания (TOC). Записи оглавления добавляются в индексный файл, причем их третий столбец имеет столько префиксных пробелов, сколько их уровень находится в оглавлении (не менее 1 символа). Пробел префикса помогает фильтровать записи оглавления из API или текстовых символов. Это важно, поскольку количество пробелов используется для репликации иерархии оглавлений документов в окончательном индексе, а записи оглавления, обнаруженные в файлах &lt;code&gt;.nim&lt;/code&gt; , отбрасываются.</target>
        </trans-unit>
        <trans-unit id="b2311ed7d695294572b2e47ef09cbf7395d919cc" translate="yes" xml:space="preserve">
          <source>Normalize a path.</source>
          <target state="translated">Нормализуй путь.</target>
        </trans-unit>
        <trans-unit id="cc401dc387c902dea14776d7f9bdd3484fd7eecd" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Нормализует строку &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2b87a9d966e87007d02f8daaa4c946c260411a9b" translate="yes" xml:space="preserve">
          <source>Not nil annotation</source>
          <target state="translated">Не ноль аннотация</target>
        </trans-unit>
        <trans-unit id="8e5e6194b87f5a890650f1c4bfbf0e220197df8e" translate="yes" xml:space="preserve">
          <source>Not nil annotations are not supported.</source>
          <target state="translated">Не поддерживаются ноль примечаний.</target>
        </trans-unit>
        <trans-unit id="7a8674a1a5764153c229b94ca832a584559616dd" translate="yes" xml:space="preserve">
          <source>Not predicate</source>
          <target state="translated">Не предикат</target>
        </trans-unit>
        <trans-unit id="3d01d18bf9a6daa3fb19ea60a23f7dd70f8af43a" translate="yes" xml:space="preserve">
          <source>Not predicate: Indicate failure if expression E matches the text ahead; otherwise indicate success. Do not consume any text.</source>
          <target state="translated">Не предикатно:Укажите неудачу,если выражение E совпадает с текстом впереди;в противном случае укажите успех.Не потреблять текст.</target>
        </trans-unit>
        <trans-unit id="542c73c0783f6a29758964ce1947b79cd5d16744" translate="yes" xml:space="preserve">
          <source>Not very useful by its own, you can use it to create &lt;em&gt;inverted&lt;/em&gt; sets to make the &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find() proc&lt;/a&gt; find &lt;strong&gt;invalid&lt;/strong&gt; characters in strings. Example:</source>
          <target state="translated">Сам по себе не очень полезен, вы можете использовать его для создания &lt;em&gt;инвертированных&lt;/em&gt; наборов, чтобы процедура &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find ()&lt;/a&gt; находила &lt;strong&gt;недопустимые&lt;/strong&gt; символы в строках. Пример:</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="04228ae1050018eb31f9f0fcb6a78ef941137a15" translate="yes" xml:space="preserve">
          <source>Note how the built-in &lt;code&gt;len&lt;/code&gt; proc returns only the array's first dimension length. Another way of defining the &lt;code&gt;LightTower&lt;/code&gt; to better illustrate its nested nature would be to omit the previous definition of the &lt;code&gt;LevelSetting&lt;/code&gt; type and instead write it embedded directly as the type of the first dimension:</source>
          <target state="translated">Обратите внимание, как встроенная процедура &lt;code&gt;len&lt;/code&gt; возвращает только длину первого измерения массива. Другой способ определения &lt;code&gt;LightTower&lt;/code&gt; , чтобы лучше проиллюстрировать его вложенный характер, - это опустить предыдущее определение типа &lt;code&gt;LevelSetting&lt;/code&gt; и вместо этого написать его встроенным непосредственно как тип первого измерения:</target>
        </trans-unit>
        <trans-unit id="cd3704db1df15da0eb18abb96f396dc8315f28b4" translate="yes" xml:space="preserve">
          <source>Note how the example contains extra C code to declare the &lt;code&gt;iupdll&lt;/code&gt; symbol in the generated Nim code.</source>
          <target state="translated">Обратите внимание, как в примере содержится дополнительный код C для объявления символа &lt;code&gt;iupdll&lt;/code&gt; в сгенерированном коде Nim.</target>
        </trans-unit>
        <trans-unit id="ce6b9b4ceabc50bdb117bfb8df4ea521f2a5d675" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;getCurrentException&lt;/code&gt; always returns a &lt;code&gt;ref Exception&lt;/code&gt; type. If a variable of the proper type is needed (in the example above, &lt;code&gt;IOError&lt;/code&gt;), one must convert it explicitly:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;getCurrentException&lt;/code&gt; всегда возвращает тип &lt;code&gt;ref Exception&lt;/code&gt; . Если требуется переменная правильного типа (в приведенном выше примере &lt;code&gt;IOError&lt;/code&gt; ), ее необходимо преобразовать явно:</target>
        </trans-unit>
        <trans-unit id="15f8bf07037666cd628faf3d8b1289a1ebbe6888" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import math as m&lt;/code&gt; does not use a different node; rather, we use &lt;code&gt;nnkImportStmt&lt;/code&gt; with &lt;code&gt;as&lt;/code&gt; as an infix operator.</source>
          <target state="translated">Обратите внимание, что при &lt;code&gt;import math as m&lt;/code&gt; не используется другой узел; вместо этого мы используем &lt;code&gt;nnkImportStmt&lt;/code&gt; с &lt;code&gt;as&lt;/code&gt; в качестве инфиксного оператора.</target>
        </trans-unit>
        <trans-unit id="9b5663a783c31085b10a438aaa39d48ac8ef1674" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;system.finished&lt;/code&gt; is error prone to use because it only returns &lt;code&gt;true&lt;/code&gt; one iteration after the iterator has finished:</source>
          <target state="translated">Обратите внимание, что использование &lt;code&gt;system.finished&lt;/code&gt; подвержено ошибкам, поскольку оно возвращает &lt;code&gt;true&lt;/code&gt; только на одной итерации после завершения итератора:</target>
        </trans-unit>
        <trans-unit id="d65e48edf1a92ed7ba69b341dc76ceb955ed905a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;using&lt;/code&gt; is not applied for &lt;code&gt;template&lt;/code&gt; since untyped template parameters default to the type &lt;code&gt;system.untyped&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;using&lt;/code&gt; не применяется к &lt;code&gt;template&lt;/code&gt; поскольку нетипизированные параметры шаблона по умолчанию имеют тип &lt;code&gt;system.untyped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eaa79a5d51a878bd30d77cb48d9cf5f64b35ea7" translate="yes" xml:space="preserve">
          <source>Note that Nim's extended raw string literals support the syntax &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; as a short form for &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что расширенные необработанные строковые литералы Nim поддерживают синтаксис &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; как краткую форму для &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66958a893582569a32abe154668c902b04b269b9" translate="yes" xml:space="preserve">
          <source>Note that a duration can be negative, so even if &lt;code&gt;a &amp;lt; b&lt;/code&gt; is true &lt;code&gt;a&lt;/code&gt; might represent a larger absolute duration. Use &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; to compare the absolute duration.</source>
          <target state="translated">Обратите внимание, что продолжительность может быть отрицательной, поэтому даже если &lt;code&gt;a &amp;lt; b&lt;/code&gt; истинно, &lt;code&gt;a&lt;/code&gt; может представлять большую абсолютную продолжительность. Используйте &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; для сравнения абсолютной продолжительности.</target>
        </trans-unit>
        <trans-unit id="31a61e95866e9147c08e9c2d0fd1b10e87385ea4" translate="yes" xml:space="preserve">
          <source>Note that an explicit array constructor passed to a &lt;code&gt;varargs&lt;/code&gt; parameter is not wrapped in another implicit array construction:</source>
          <target state="translated">Обратите внимание, что явный конструктор массива, переданный параметру &lt;code&gt;varargs&lt;/code&gt; , не заключен в другую неявную конструкцию массива:</target>
        </trans-unit>
        <trans-unit id="580208a43972b50356da5b1da0797b119e251075" translate="yes" xml:space="preserve">
          <source>Note that at the moment the word &lt;code&gt;proc&lt;/code&gt; is returned for the signature of the found method instead of the expected &lt;code&gt;method&lt;/code&gt;. This may change in the future.</source>
          <target state="translated">Обратите внимание, что на данный момент слово &lt;code&gt;proc&lt;/code&gt; возвращается для сигнатуры найденного метода вместо ожидаемого &lt;code&gt;method&lt;/code&gt; . Это может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="fe89c735f73e47df7589d2ce0f730288a5b272a5" translate="yes" xml:space="preserve">
          <source>Note that declaring multiple variables with a single assignment which calls a procedure can have unexpected results: the compiler will &lt;em&gt;unroll&lt;/em&gt; the assignments and end up calling the procedure several times. If the result of the procedure depends on side effects, your variables may end up having different values! For safety use side-effect free procedures if making multiple assignments.</source>
          <target state="translated">Обратите внимание, что объявление нескольких переменных с одним назначением, которое вызывает процедуру, может иметь неожиданные результаты: компилятор &lt;em&gt;развернет&lt;/em&gt; назначения и вызовет процедуру несколько раз. Если результат процедуры зависит от побочных эффектов, ваши переменные могут иметь разные значения! В целях безопасности при выполнении нескольких назначений используйте процедуры без побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="f0fc07cec95ec5e1fead7b4c0cc4bdbd5f963690" translate="yes" xml:space="preserve">
          <source>Note that either the second or third (or both) parameters above must exist, as the compiler needs to know the type somehow (which it can infer from the given assignment).</source>
          <target state="translated">Обратите внимание,что либо второй,либо третий (или оба)параметр должен существовать,так как компилятор должен как-то знать тип (который он может вывести из заданного присваивания).</target>
        </trans-unit>
        <trans-unit id="3974a69d8025c1886c72445a8fb4b0c0716b4564" translate="yes" xml:space="preserve">
          <source>Note that for systems with a continuous stack (which most systems have) the check whether the ref is on the stack is very cheap (only two comparisons).</source>
          <target state="translated">Обратите внимание,что для систем с непрерывным стеком (который есть у большинства систем)проверка наличия ссылки в стеке очень дешева (только два сравнения).</target>
        </trans-unit>
        <trans-unit id="e095193050971ff047ad4d5c8afbbc2efec37383" translate="yes" xml:space="preserve">
          <source>Note that in the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because it makes more sense for them to use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">Обратите внимание, что в этом примере конструкторы &lt;code&gt;newLit&lt;/code&gt; и &lt;code&gt;newPlus&lt;/code&gt; являются procs , потому что для них имеет смысл использовать статическое связывание, но &lt;code&gt;eval&lt;/code&gt; - это метод, поскольку он требует динамического связывания.</target>
        </trans-unit>
        <trans-unit id="11be0dfde35904fa7f02afe90c20970ebac48dfb" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;nnkTypeDef&lt;/code&gt; utilize &lt;code&gt;nnkIdent&lt;/code&gt; as their their parameter. One of the most common uses of type declarations is to work with objects.</source>
          <target state="translated">Обратите внимание, что не все &lt;code&gt;nnkTypeDef&lt;/code&gt; используют &lt;code&gt;nnkIdent&lt;/code&gt; в качестве своего параметра. Одно из наиболее распространенных применений объявлений типов - работа с объектами.</target>
        </trans-unit>
        <trans-unit id="0224a1f68a8585cd4a55cb358bf685741b3afb31" translate="yes" xml:space="preserve">
          <source>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</source>
          <target state="translated">Обратите внимание,что восьмеричные значения 100 и более не должны вводиться ведущим нулем,так как никогда не считывается не более трех восьмеричных цифр.</target>
        </trans-unit>
        <trans-unit id="cb0c14568cc44b3aa6b93616a9638e1e67aa608b" translate="yes" xml:space="preserve">
          <source>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</source>
          <target state="translated">Обратите внимание,что поскольку это итератор,вы не должны изменять строку,над которой выполняется итерация:могут случиться плохие вещи.</target>
        </trans-unit>
        <trans-unit id="5e26b1561a3f022726ef326aaca35071eca0d805" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Time&lt;/code&gt; argument does not represent a point in time, it represent a local time! E.g if &lt;code&gt;adjTime&lt;/code&gt; is &lt;code&gt;fromUnix(0)&lt;/code&gt;, it should be interpreted as 1970-01-01T00:00:00 in the &lt;code&gt;zone&lt;/code&gt; timezone, not in UTC.</source>
          <target state="translated">Обратите внимание, что аргумент &lt;code&gt;Time&lt;/code&gt; не представляет момент времени, он представляет местное время! Например, если &lt;code&gt;adjTime&lt;/code&gt; имеет значение &lt;code&gt;fromUnix(0)&lt;/code&gt; , его следует интерпретировать как 1970-01-01T00: 00: 00 в часовом &lt;code&gt;zone&lt;/code&gt; , а не в формате UTC.</target>
        </trans-unit>
        <trans-unit id="ff3153be7f62193c7a012288373ef96e64821a33" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;importcpp&lt;/code&gt; variant for procs uses a somewhat cryptic pattern language for maximum flexibility:</source>
          <target state="translated">Обратите внимание, что вариант &lt;code&gt;importcpp&lt;/code&gt; для procs использует несколько загадочный язык шаблонов для максимальной гибкости:</target>
        </trans-unit>
        <trans-unit id="f79f9b3f84579ddfcfc49f356b7732e51770554f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;jsondoc&lt;/code&gt; command outputs it's JSON without pretty-printing it, while &lt;code&gt;jsondoc0&lt;/code&gt; outputs pretty-printed JSON.</source>
          <target state="translated">Обратите внимание, что команда &lt;code&gt;jsondoc&lt;/code&gt; выводит это JSON без красивой печати, тогда как &lt;code&gt;jsondoc0&lt;/code&gt; выводит красиво напечатанный JSON.</target>
        </trans-unit>
        <trans-unit id="0657a4b90e474cfb90775d71e0fec2c9d65f4786" translate="yes" xml:space="preserve">
          <source>Note that the encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.</source>
          <target state="translated">Обратите внимание,что кодировка не может быть изменена после ее установки.Согласно документации SQLite3,любая попытка изменить кодировку после создания базы данных будет молча игнорироваться.</target>
        </trans-unit>
        <trans-unit id="9cb042b8b29c59f41b3cd0e948e779e25db65a35" translate="yes" xml:space="preserve">
          <source>Note that the module name is still &lt;code&gt;strutils&lt;/code&gt; and not &lt;code&gt;lib/pure/strutils&lt;/code&gt; and so one &lt;strong&gt;cannot&lt;/strong&gt; do:</source>
          <target state="translated">Обратите внимание, что имя модуля по-прежнему &lt;code&gt;strutils&lt;/code&gt; а не &lt;code&gt;lib/pure/strutils&lt;/code&gt; поэтому &lt;strong&gt;нельзя&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="343c37cc8e2a037df9dff1a349a478f071828d8b" translate="yes" xml:space="preserve">
          <source>Note that the pattern language naturally also covers C++'s operator overloading capabilities:</source>
          <target state="translated">Обратите внимание,что язык шаблонов естественно также охватывает возможности перегрузки операторов С++:</target>
        </trans-unit>
        <trans-unit id="8cde912a6f95d6bc0c0ad134a4919451e220d036" translate="yes" xml:space="preserve">
          <source>Note that the regular expression does not behave as intended either: in the example &lt;code&gt;*&lt;/code&gt; should not be greedy, so &lt;code&gt;\[.*?\]&lt;/code&gt; should be used instead.</source>
          <target state="translated">Обратите внимание, что регулярное выражение также ведет себя не так, как задумано: в примере &lt;code&gt;*&lt;/code&gt; не должно быть жадным, поэтому вместо него следует использовать &lt;code&gt;\[.*?\]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f120496e6d813c76cb6c4055f029e22950f8809c" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be &lt;code&gt;nil&lt;/code&gt;. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</source>
          <target state="translated">Обратите внимание, что последовательность будет заполнена обнуленными записями, что может быть проблемой для последовательностей, содержащих строки, поскольку их значение будет равно &lt;code&gt;nil&lt;/code&gt; . После создания последовательности вы должны назначить записи последовательности, а не добавлять их. Пример:</target>
        </trans-unit>
        <trans-unit id="1afc5e4454ca57a472753d975721911248348abc" translate="yes" xml:space="preserve">
          <source>Note that the trigonometric functions naturally operate on radians. The helper functions &lt;em&gt;degToRad&lt;/em&gt; and &lt;em&gt;radToDeg&lt;/em&gt; provide conversion between radians and degrees.</source>
          <target state="translated">Обратите внимание, что тригонометрические функции, естественно, работают с радианами. Вспомогательные функции &lt;em&gt;degToRad&lt;/em&gt; и &lt;em&gt;radToDeg&lt;/em&gt; обеспечивают преобразование между радианами и градусами.</target>
        </trans-unit>
        <trans-unit id="b39e62dfdcac76acc3788b0504467d241681c022" translate="yes" xml:space="preserve">
          <source>Note that there can be exceptions to these rules. Nim being as flexible as it is, there will be parts of this style guide that don't make sense in certain contexts. Furthermore, just as &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;Python's style guide&lt;/a&gt; changes over time, this style guide will too.</source>
          <target state="translated">Учтите, что из этих правил могут быть исключения. Несмотря на то, что Nim настолько гибок, в этом руководстве по стилю будут некоторые части, которые не имеют смысла в определенных контекстах. Более того, как &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;руководство по стилю Python, так и это руководство по стилю будет меняться&lt;/a&gt; со временем.</target>
        </trans-unit>
        <trans-unit id="0fed77603f9454dbdef2e75534af23ed17061d9e" translate="yes" xml:space="preserve">
          <source>Note that this is a &lt;em&gt;runtime&lt;/em&gt; call and using &lt;code&gt;quit&lt;/code&gt; inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; or &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatal&lt;/a&gt; pragmas.</source>
          <target state="translated">Обратите внимание, что это вызов &lt;em&gt;времени выполнения,&lt;/em&gt; и использование &lt;code&gt;quit&lt;/code&gt; внутри макроса не будет иметь никакого эффекта времени компиляции. Если вам нужно остановить компилятор внутри макроса, используйте прагмы &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; или &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04eea85d84506e2be9f7ff640da1764e6c3b0050" translate="yes" xml:space="preserve">
          <source>Note that this is basically the only form of type inference that exists in Nim: it is a good compromise between brevity and readability.</source>
          <target state="translated">Обратите внимание,что это,по сути,единственная форма типового вывода,которая существует в Nim:это хороший компромисс между краткостью и читабельности.</target>
        </trans-unit>
        <trans-unit id="ca57587cd09e4fd62d9d47bd97a7a8675351ea8c" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name.</source>
          <target state="translated">Обратите внимание,что эта прагма в некотором роде неправильная:Другие бэкэнды предоставляют ту же функцию под тем же именем.</target>
        </trans-unit>
        <trans-unit id="6aa0aaed3cc81e0439834c7c529aa1845e5383d7" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name. Also, if one is interfacing with C++ the &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp pragma&lt;/a&gt; and interfacing with Objective-C the &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC pragma&lt;/a&gt; can be used.</source>
          <target state="translated">Обратите внимание, что эта прагма в некоторой степени неверна: другие серверные ВМ предоставляют ту же функцию под тем же именем. Кроме того, если вы взаимодействуете с C ++, &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;прагму ImportCpp&lt;/a&gt; и взаимодействуете с Objective-C, то можно использовать &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;прагму ImportObjC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5d063d7e7c89bcb1be31e9838c1418c3a823324" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes a &lt;code&gt;var T&lt;/code&gt; type parameter.</source>
          <target state="translated">Обратите внимание, что для этого требуется, чтобы типы ввода и вывода были одинаковыми, поскольку они изменяются на месте. Функция параметра принимает параметр типа &lt;code&gt;var T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfd22634c739d8b9963ba6240e6f789a4901df14" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes and returns a &lt;code&gt;T&lt;/code&gt; type variable.</source>
          <target state="translated">Обратите внимание, что для этого требуется, чтобы типы ввода и вывода были одинаковыми, поскольку они изменяются на месте. Функция параметра принимает и возвращает переменную типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74e73723c67698a4db4dbcdaa04c4f3387732c63" translate="yes" xml:space="preserve">
          <source>Note that this version of &lt;code&gt;map&lt;/code&gt; requires your input and output types to be the same, since they are modified in-place.</source>
          <target state="translated">Обратите внимание, что эта версия &lt;code&gt;map&lt;/code&gt; требует, чтобы ваши типы ввода и вывода были одинаковыми, поскольку они изменяются на месте.</target>
        </trans-unit>
        <trans-unit id="35a43adebbe7d9517e28187d2c67478e70dbaf9e" translate="yes" xml:space="preserve">
          <source>Note that type inference works for parameters with default values; there is no need to write &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt;, for example.</source>
          <target state="translated">Обратите внимание, что вывод типа работает для параметров со значениями по умолчанию; например, не нужно писать &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="025bc18a2bc141ea4af9a1700e4ee039cbf3bd9f" translate="yes" xml:space="preserve">
          <source>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</source>
          <target state="translated">Обратите внимание,что если не задана минимальная ширина поля,то ширина поля всегда будет равна ширине заполняемых данных,так что опция выравнивания в данном случае не имеет значения.</target>
        </trans-unit>
        <trans-unit id="a4f6df5cd8b79acdb0c70f5d30510d6e8cdfa162" translate="yes" xml:space="preserve">
          <source>Note that unordered or ordered choice operators (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) are not implemented.</source>
          <target state="translated">Обратите внимание, что операторы неупорядоченного или упорядоченного выбора ( &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; ) не реализованы.</target>
        </trans-unit>
        <trans-unit id="1f37b4c7971dff9f25702efc2db169764ea60985" translate="yes" xml:space="preserve">
          <source>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to &lt;em&gt;31 October&lt;/em&gt; will result in &lt;em&gt;31 November&lt;/em&gt;, which will overflow and result in &lt;em&gt;1 December&lt;/em&gt;.</source>
          <target state="translated">Обратите внимание, что при добавлении месяцев допускается переполнение дня месяца. Это означает, что если в результирующем месяце не хватает дней, месяц будет увеличиваться, а в качестве дня месяца будет установлено количество дней, за которые произошло переполнение. Таким образом, добавление одного месяца к &lt;em&gt;31 октября&lt;/em&gt; приведет к &lt;em&gt;31 ноября&lt;/em&gt; , что приведет к переполнению и &lt;em&gt;1 декабря&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="93f7073771e81c9dae2114aa3af0598ed46cf0ad" translate="yes" xml:space="preserve">
          <source>Note that with multiple infix operators, the command is parsed by operator precedence.</source>
          <target state="translated">Обратите внимание,что при использовании нескольких инффиксных операторов команда разбирается по приоритету оператора.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
