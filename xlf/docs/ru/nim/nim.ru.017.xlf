<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="f6aed8cf30d89d1b5f778819ebedc002452ab169" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wPure</source>
          <target state="translated">TSpecialWord.wPure</target>
        </trans-unit>
        <trans-unit id="2a9b67e5059e4097ecf36898a14af806e627495c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wPush</source>
          <target state="translated">TSpecialWord.wPush</target>
        </trans-unit>
        <trans-unit id="165c068e1820e1d75b4534ad6c24dc64d16d0a36" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRaise</source>
          <target state="translated">TSpecialWord.wRaise</target>
        </trans-unit>
        <trans-unit id="5e3d248206d073353634b05ebfd99c3b0babf77c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRaises</source>
          <target state="translated">TSpecialWord.wRaises</target>
        </trans-unit>
        <trans-unit id="5a2b8c36797bc435a75f44083c6407c87375542c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRangeChecks</source>
          <target state="translated">TSpecialWord.wRangeChecks</target>
        </trans-unit>
        <trans-unit id="df27e08ee3fc7139bf78856f843294d62733b61a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReads</source>
          <target state="translated">TSpecialWord.wReads</target>
        </trans-unit>
        <trans-unit id="b5ce7ca8962a8b2d8ed038b3f6595e52dddebae2" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRef</source>
          <target state="translated">TSpecialWord.wRef</target>
        </trans-unit>
        <trans-unit id="be048d968653db1d3dc961ae8ebf53bd4c68f166" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRegister</source>
          <target state="translated">TSpecialWord.wRegister</target>
        </trans-unit>
        <trans-unit id="8b80e46864ec623fa9e8f5475e2541099b188af8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReinterpret_cast</source>
          <target state="translated">TSpecialWord.wReinterpret_cast</target>
        </trans-unit>
        <trans-unit id="7d8b98c8733ff1965441d54cd8cc78a95436d313" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReorder</source>
          <target state="translated">TSpecialWord.wReorder</target>
        </trans-unit>
        <trans-unit id="032050ad9efa5acd958a6511df599471d8cb2c74" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRequires</source>
          <target state="translated">TSpecialWord.wRequires</target>
        </trans-unit>
        <trans-unit id="d3dffc73a1d96c3d802b32eb7e39ddc139958219" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRequiresInit</source>
          <target state="translated">TSpecialWord.wRequiresInit</target>
        </trans-unit>
        <trans-unit id="543fd2e5c16f6bff5a0bb30047bfc1189d31acaf" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRestrict</source>
          <target state="translated">TSpecialWord.wRestrict</target>
        </trans-unit>
        <trans-unit id="3e374bb07c496ab290d5cebb03264be429060f1c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReturn</source>
          <target state="translated">TSpecialWord.wReturn</target>
        </trans-unit>
        <trans-unit id="cbf79c4fe8fd77f4412e027be0ff8ee2d47696e5" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSafecall</source>
          <target state="translated">TSpecialWord.wSafecall</target>
        </trans-unit>
        <trans-unit id="d24950f44da9648166edc152a3ab956b5f6f6c1a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSafecode</source>
          <target state="translated">TSpecialWord.wSafecode</target>
        </trans-unit>
        <trans-unit id="98d95ab8a2424b472a9ba50754608cd2297953b7" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShallow</source>
          <target state="translated">TSpecialWord.wShallow</target>
        </trans-unit>
        <trans-unit id="2b2a65bacbe207841c53d73ad99699011a3ae136" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShl</source>
          <target state="translated">TSpecialWord.wShl</target>
        </trans-unit>
        <trans-unit id="4a6bac00c52ffed152558dd3c086e472cf6cb3c6" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShort</source>
          <target state="translated">TSpecialWord.wShort</target>
        </trans-unit>
        <trans-unit id="dfb5bbf53d2e54bbe729b7e92403cdb823eb2b0c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShr</source>
          <target state="translated">TSpecialWord.wShr</target>
        </trans-unit>
        <trans-unit id="236e385d070b2597fdea7ced17163542a3f4d1c8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSideEffect</source>
          <target state="translated">TSpecialWord.wSideEffect</target>
        </trans-unit>
        <trans-unit id="9fa842e819283837867308a0207f383cafd19b3e" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSigned</source>
          <target state="translated">TSpecialWord.wSigned</target>
        </trans-unit>
        <trans-unit id="27a8834c59f9ad98925bf00dc917db1852a27299" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSinkInference</source>
          <target state="translated">TSpecialWord.wSinkInference</target>
        </trans-unit>
        <trans-unit id="b00ad10e6017e9de11489ae00852840ef13fd225" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSize</source>
          <target state="translated">TSpecialWord.wSize</target>
        </trans-unit>
        <trans-unit id="67cb4412a3444bae39547e9a844ef819b51e5c7d" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSizeof</source>
          <target state="translated">TSpecialWord.wSizeof</target>
        </trans-unit>
        <trans-unit id="375d1a0f39af91da2e515b2dc881cc48501d5e81" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStackTrace</source>
          <target state="translated">TSpecialWord.wStackTrace</target>
        </trans-unit>
        <trans-unit id="e5bec72d25cba4d87d2c10fecc04697e4741a3f5" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStar</source>
          <target state="translated">TSpecialWord.wStar</target>
        </trans-unit>
        <trans-unit id="fa3cff407c086fc0695af06925696dfcdc317e15" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic</source>
          <target state="translated">TSpecialWord.wStatic</target>
        </trans-unit>
        <trans-unit id="9bf7942ea69df57f385d4b9f506f1c877038b349" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStaticBoundchecks</source>
          <target state="translated">TSpecialWord.wStaticBoundchecks</target>
        </trans-unit>
        <trans-unit id="42b65dec3e989eade77bb9dafbc7c5603136b9a4" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic_assert</source>
          <target state="translated">TSpecialWord.wStatic_assert</target>
        </trans-unit>
        <trans-unit id="6671b68735c96c610635b2311938beae4174f474" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic_cast</source>
          <target state="translated">TSpecialWord.wStatic_cast</target>
        </trans-unit>
        <trans-unit id="7a3ee08adfebd48c3c46780dcafff249ba850cfa" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdErr</source>
          <target state="translated">TSpecialWord.wStdErr</target>
        </trans-unit>
        <trans-unit id="762d8648d881bf250497c16ae7ef71e0f5dc36b8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdIn</source>
          <target state="translated">TSpecialWord.wStdIn</target>
        </trans-unit>
        <trans-unit id="73aaa0ffe071ec1c213dc94616c825c8bfd89d25" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdOut</source>
          <target state="translated">TSpecialWord.wStdOut</target>
        </trans-unit>
        <trans-unit id="2c1652ef3797603ee1016b39ca7d1eaf6a994a64" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdcall</source>
          <target state="translated">TSpecialWord.wStdcall</target>
        </trans-unit>
        <trans-unit id="c84b20a5cb26b59a2c609a6aa076dc00025857ea" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStrDefine</source>
          <target state="translated">TSpecialWord.wStrDefine</target>
        </trans-unit>
        <trans-unit id="49ed6cea4f1b008c45de69c2ff5abf3cf0424c58" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStruct</source>
          <target state="translated">TSpecialWord.wStruct</target>
        </trans-unit>
        <trans-unit id="675cfe4ec331766796865804ca47bbb153bf0155" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStyleChecks</source>
          <target state="translated">TSpecialWord.wStyleChecks</target>
        </trans-unit>
        <trans-unit id="5fa5466ccba7748cd7dbda2f197138204862ea2f" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSubsChar</source>
          <target state="translated">TSpecialWord.wSubsChar</target>
        </trans-unit>
        <trans-unit id="828d45bd46fbb2489a62d5b498cf0a455bcd067b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSwitch</source>
          <target state="translated">TSpecialWord.wSwitch</target>
        </trans-unit>
        <trans-unit id="8ae17bcff106fd30cb7e44426aa7e930ae4a13bf" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSyscall</source>
          <target state="translated">TSpecialWord.wSyscall</target>
        </trans-unit>
        <trans-unit id="2c4b7ce46a5d91db3d102fe8d5a6c90ba038aac8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTags</source>
          <target state="translated">TSpecialWord.wTags</target>
        </trans-unit>
        <trans-unit id="8259d5f2948abbbddb4fd282fd77796d6a1e188b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTemplate</source>
          <target state="translated">TSpecialWord.wTemplate</target>
        </trans-unit>
        <trans-unit id="1f8ec32bd5c894b2fb69a2e65aa4eff6d85b2b2c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThis</source>
          <target state="translated">TSpecialWord.wThis</target>
        </trans-unit>
        <trans-unit id="fa09f4d08ebeaa289b05115b03460b2345c5690b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThiscall</source>
          <target state="translated">TSpecialWord.wThiscall</target>
        </trans-unit>
        <trans-unit id="710884f3ea7828d070ac0172eb890ea19137e10b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThread</source>
          <target state="translated">TSpecialWord.wThread</target>
        </trans-unit>
        <trans-unit id="a5abf2f68067daf03579eaec46403ce1d4fa3122" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThreadVar</source>
          <target state="translated">TSpecialWord.wThreadVar</target>
        </trans-unit>
        <trans-unit id="3347bce5195eab1d6dbe2e3a70137a6875a1bcd0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThread_local</source>
          <target state="translated">TSpecialWord.wThread_local</target>
        </trans-unit>
        <trans-unit id="d38d2534840f4e350de5ea3f4d4dfa93750e0e35" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThrow</source>
          <target state="translated">TSpecialWord.wThrow</target>
        </trans-unit>
        <trans-unit id="a74866bc8c91b482d6c277feb2855538288fc026" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTrMacros</source>
          <target state="translated">TSpecialWord.wTrMacros</target>
        </trans-unit>
        <trans-unit id="659906f78c39e51a41596c895c0ccd5fc9211098" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTrue</source>
          <target state="translated">TSpecialWord.wTrue</target>
        </trans-unit>
        <trans-unit id="79ea1fcf98460dbb432b5051f2024d63e01bfe2a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTry</source>
          <target state="translated">TSpecialWord.wTry</target>
        </trans-unit>
        <trans-unit id="66986335415d83d7b446a919737a7731a6b47007" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTuple</source>
          <target state="translated">TSpecialWord.wTuple</target>
        </trans-unit>
        <trans-unit id="ccf870e3f2157fa7a58f23b262338a605c4a70c3" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wType</source>
          <target state="translated">TSpecialWord.wType</target>
        </trans-unit>
        <trans-unit id="5d241960b2464b1d99ad110a5ab14d6c8c40cb1c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypedef</source>
          <target state="translated">TSpecialWord.wTypedef</target>
        </trans-unit>
        <trans-unit id="578fe1dad51eb962bc7100551c55df0d2f910a05" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypeid</source>
          <target state="translated">TSpecialWord.wTypeid</target>
        </trans-unit>
        <trans-unit id="4f7fa4c634320c3d0ac7ad82ea04ec56c867b2c0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypename</source>
          <target state="translated">TSpecialWord.wTypename</target>
        </trans-unit>
        <trans-unit id="81789f4e632314e9fc671603cc6f4504cb3d3c7e" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypeof</source>
          <target state="translated">TSpecialWord.wTypeof</target>
        </trans-unit>
        <trans-unit id="e82424012de52d35e49a0273d3bb8964198190f7" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnchecked</source>
          <target state="translated">TSpecialWord.wUnchecked</target>
        </trans-unit>
        <trans-unit id="dbc5d36cd28889beee0705d587be6e2bf5f0ba24" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUndef</source>
          <target state="translated">TSpecialWord.wUndef</target>
        </trans-unit>
        <trans-unit id="279a751e05c27d1e929e77b6e74a8f8fcd202ff3" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnion</source>
          <target state="translated">TSpecialWord.wUnion</target>
        </trans-unit>
        <trans-unit id="acd5245dafa7c73d3e19f18016ec4300935dbc52" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnroll</source>
          <target state="translated">TSpecialWord.wUnroll</target>
        </trans-unit>
        <trans-unit id="128bae39e8b7b9c9bd624e15b312f4239ed53544" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnsigned</source>
          <target state="translated">TSpecialWord.wUnsigned</target>
        </trans-unit>
        <trans-unit id="4538a950702fcf865d3ddc624772f08dc9bed770" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUsed</source>
          <target state="translated">TSpecialWord.wUsed</target>
        </trans-unit>
        <trans-unit id="d5186b721a554f2af5bc7833570447bfbaee4ffb" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUsing</source>
          <target state="translated">TSpecialWord.wUsing</target>
        </trans-unit>
        <trans-unit id="dd8d9f0aba1c048fda45ed8dd426cf658def8d93" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVar</source>
          <target state="translated">TSpecialWord.wVar</target>
        </trans-unit>
        <trans-unit id="01d3d47c3053cb3b7fb482f0e745f51c7df7a0f8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVarargs</source>
          <target state="translated">TSpecialWord.wVarargs</target>
        </trans-unit>
        <trans-unit id="85c9b1fce5be3772cd95801d5874b26567b30c50" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVirtual</source>
          <target state="translated">TSpecialWord.wVirtual</target>
        </trans-unit>
        <trans-unit id="cae380bec2b17f6a257f9414ce33fab2081ccb90" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVoid</source>
          <target state="translated">TSpecialWord.wVoid</target>
        </trans-unit>
        <trans-unit id="eaec574e0294d6f4cfe6975561364a6e8ed2ee73" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVolatile</source>
          <target state="translated">TSpecialWord.wVolatile</target>
        </trans-unit>
        <trans-unit id="ac2d56ae50a4ef8e57ef5e5be34355ca25d1e222" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarning</source>
          <target state="translated">TSpecialWord.wWarning</target>
        </trans-unit>
        <trans-unit id="815eb53d1f7c1a0ca216fd9787dd0db2ce819982" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarningAsError</source>
          <target state="translated">TSpecialWord.wWarningAsError</target>
        </trans-unit>
        <trans-unit id="e2c2ec1dda075dad3c4bc901affaf5549a2d2b75" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarnings</source>
          <target state="translated">TSpecialWord.wWarnings</target>
        </trans-unit>
        <trans-unit id="5b837dea019d23d30994653aeb2a6a8f303a568c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWchar_t</source>
          <target state="translated">TSpecialWord.wWchar_t</target>
        </trans-unit>
        <trans-unit id="f60e52204ae6220e3c6082c529bc3c10f836c8e0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWhen</source>
          <target state="translated">TSpecialWord.wWhen</target>
        </trans-unit>
        <trans-unit id="22f35857d8fff1b871e90250921bcbad022c1596" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWhile</source>
          <target state="translated">TSpecialWord.wWhile</target>
        </trans-unit>
        <trans-unit id="f7bf965945cdbc25c36d9e3dc84f071eb2b53200" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWrite</source>
          <target state="translated">TSpecialWord.wWrite</target>
        </trans-unit>
        <trans-unit id="65b8c2c53f6ca0b94c75c1d256fefa69d322b613" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWrites</source>
          <target state="translated">TSpecialWord.wWrites</target>
        </trans-unit>
        <trans-unit id="385a4cef4263d0f5309e1c0899a6b65221d03816" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wXor</source>
          <target state="translated">TSpecialWord.wXor</target>
        </trans-unit>
        <trans-unit id="d6f1af335750efb309789ef991ace31453c11f01" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wYield</source>
          <target state="translated">TSpecialWord.wYield</target>
        </trans-unit>
        <trans-unit id="e6d0cddee16c4a5b079344fd99dcab4c4d1b9e4c" translate="yes" xml:space="preserve">
          <source>TSpecialWord:</source>
          <target state="translated">TSpecialWord:</target>
        </trans-unit>
        <trans-unit id="be4d767100d61b72e964b4c9f210a5a6fe5a30b1" translate="yes" xml:space="preserve">
          <source>TSpecialWords:</source>
          <target state="translated">TSpecialWords:</target>
        </trans-unit>
        <trans-unit id="adb30911c6273d9d5b3b15cb0ce088b23e2ba860" translate="yes" xml:space="preserve">
          <source>TSrcGen:</source>
          <target state="translated">TSrcGen:</target>
        </trans-unit>
        <trans-unit id="6323d0dcdfc011e809275fb4eba73730c046c118" translate="yes" xml:space="preserve">
          <source>TStackFrame:</source>
          <target state="translated">TStackFrame:</target>
        </trans-unit>
        <trans-unit id="395d19944b46707114ce5ef88d888fc1f25becb7" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnHeap</source>
          <target state="translated">TStorageLoc.OnHeap</target>
        </trans-unit>
        <trans-unit id="a621c5b644c09975980371a6c506a414732361eb" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnStack</source>
          <target state="translated">TStorageLoc.OnStack</target>
        </trans-unit>
        <trans-unit id="d50d78116f7b907d867a6196eb491acda5ae45b3" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnStatic</source>
          <target state="translated">TStorageLoc.OnStatic</target>
        </trans-unit>
        <trans-unit id="aab718eb78528ad6e6e1c17a2c7f7fc049cb99e8" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnUnknown</source>
          <target state="translated">TStorageLoc.OnUnknown</target>
        </trans-unit>
        <trans-unit id="bcf92d0d35e49a4a230909f361cff8341d206060" translate="yes" xml:space="preserve">
          <source>TStorageLoc:</source>
          <target state="translated">TStorageLoc:</target>
        </trans-unit>
        <trans-unit id="cf7b832a47b0aa258a00e12b2bc337b5f3fbcb37" translate="yes" xml:space="preserve">
          <source>TStrTable:</source>
          <target state="translated">TStrTable:</target>
        </trans-unit>
        <trans-unit id="12d7fc329e1ae4a95222ebc188918ec1a1418652" translate="yes" xml:space="preserve">
          <source>TStringSeq:</source>
          <target state="translated">TStringSeq:</target>
        </trans-unit>
        <trans-unit id="05b487bb2b91485184c628ce10489134924aa98b" translate="yes" xml:space="preserve">
          <source>TSym:</source>
          <target state="translated">TSym:</target>
        </trans-unit>
        <trans-unit id="9330a751f32c5ee89229160cd7e81e74056f7182" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfAddrTaken</source>
          <target state="translated">TSymFlag.sfAddrTaken</target>
        </trans-unit>
        <trans-unit id="2dd6e5ad1a7670b695ce53f4d472c13e31c1b44b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfBorrow</source>
          <target state="translated">TSymFlag.sfBorrow</target>
        </trans-unit>
        <trans-unit id="a1efaba0d735377cf87b7f6858536df1dc6db3ca" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCallsite</source>
          <target state="translated">TSymFlag.sfCallsite</target>
        </trans-unit>
        <trans-unit id="edc5ff991665ff461d50658b207b93b6f8c66cda" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCompileTime</source>
          <target state="translated">TSymFlag.sfCompileTime</target>
        </trans-unit>
        <trans-unit id="582d96473a233f6d011b615d47980f8d5dd93af3" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCompilerProc</source>
          <target state="translated">TSymFlag.sfCompilerProc</target>
        </trans-unit>
        <trans-unit id="b516b17c0bde4915c66c3305e883ed517bc783fa" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfConstructor</source>
          <target state="translated">TSymFlag.sfConstructor</target>
        </trans-unit>
        <trans-unit id="298f5d1d6d6ed080d23994ae981ee6bfc36fbd59" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCursor</source>
          <target state="translated">TSymFlag.sfCursor</target>
        </trans-unit>
        <trans-unit id="bd0596035433f9c47b27e85e2a8c35f5493ebfaf" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDeprecated</source>
          <target state="translated">TSymFlag.sfDeprecated</target>
        </trans-unit>
        <trans-unit id="5f92740cada22e9ed96755b4f6d2a928a0d66889" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDiscardable</source>
          <target state="translated">TSymFlag.sfDiscardable</target>
        </trans-unit>
        <trans-unit id="6e343a45d312a4042d970d9ec4a09af5398a6b72" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDiscriminant</source>
          <target state="translated">TSymFlag.sfDiscriminant</target>
        </trans-unit>
        <trans-unit id="b1fa4f615769249576344c340b880762b76bd5b7" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDispatcher</source>
          <target state="translated">TSymFlag.sfDispatcher</target>
        </trans-unit>
        <trans-unit id="e455f5f383b9e0f6fbd1c12e034948b40017e87b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfError</source>
          <target state="translated">TSymFlag.sfError</target>
        </trans-unit>
        <trans-unit id="e1fb45f483c1d52633c02bc21bee7c53ec5788f9" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExplain</source>
          <target state="translated">TSymFlag.sfExplain</target>
        </trans-unit>
        <trans-unit id="7e4b245f8a05a920c7655f9ad1d64bf2c9e477e0" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExportc</source>
          <target state="translated">TSymFlag.sfExportc</target>
        </trans-unit>
        <trans-unit id="2f8455ceee2fc2e375778732463006731b34784a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExported</source>
          <target state="translated">TSymFlag.sfExported</target>
        </trans-unit>
        <trans-unit id="a52c7cbacb40cf2d307722b243bc58981e796eec" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfForward</source>
          <target state="translated">TSymFlag.sfForward</target>
        </trans-unit>
        <trans-unit id="1196f111e6dc3efb4835c41b10074f675c379f1d" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfFromGeneric</source>
          <target state="translated">TSymFlag.sfFromGeneric</target>
        </trans-unit>
        <trans-unit id="105365f8de9763fcf244284a5c9407c8aa4c2661" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGenSym</source>
          <target state="translated">TSymFlag.sfGenSym</target>
        </trans-unit>
        <trans-unit id="04e8b1287496c27529d274cec4f17fe9a6ba8697" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGeneratedOp</source>
          <target state="translated">TSymFlag.sfGeneratedOp</target>
        </trans-unit>
        <trans-unit id="534e05b2302e2356d51e38b679c263ef12cb5a20" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGlobal</source>
          <target state="translated">TSymFlag.sfGlobal</target>
        </trans-unit>
        <trans-unit id="533c0791334dc3ed4ded29375e0ea0e96faeeeb7" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfImportc</source>
          <target state="translated">TSymFlag.sfImportc</target>
        </trans-unit>
        <trans-unit id="330bfbc6bd478f12eab1f5558ac4bf0df5cbc25a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfInfixCall</source>
          <target state="translated">TSymFlag.sfInfixCall</target>
        </trans-unit>
        <trans-unit id="39f816cbf3f55a3030ca4c9728879a5779e2ce84" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfInjectDestructors</source>
          <target state="translated">TSymFlag.sfInjectDestructors</target>
        </trans-unit>
        <trans-unit id="b0e41681dd3772b0d00504a1f624b641a1ce3b1e" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfMainModule</source>
          <target state="translated">TSymFlag.sfMainModule</target>
        </trans-unit>
        <trans-unit id="8e8263d25bd716de09e2495e4ea8b9bad934bbc8" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfMangleCpp</source>
          <target state="translated">TSymFlag.sfMangleCpp</target>
        </trans-unit>
        <trans-unit id="d47663c51704084f8beb0d796f58a03b269273d6" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNamedParamCall</source>
          <target state="translated">TSymFlag.sfNamedParamCall</target>
        </trans-unit>
        <trans-unit id="3ec62b325c5a44dcf3588a04a6fbbe199da7fca8" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNeverRaises</source>
          <target state="translated">TSymFlag.sfNeverRaises</target>
        </trans-unit>
        <trans-unit id="6b10b09be35a82d4e4c9f714e1e485d6c74a08d4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoReturn</source>
          <target state="translated">TSymFlag.sfNoReturn</target>
        </trans-unit>
        <trans-unit id="1636d386afaa9112e3cafc2af385fef845e7f60a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoSideEffect</source>
          <target state="translated">TSymFlag.sfNoSideEffect</target>
        </trans-unit>
        <trans-unit id="277ce17ae708dd1e2e807e085e44d05628bd1cc9" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoalias</source>
          <target state="translated">TSymFlag.sfNoalias</target>
        </trans-unit>
        <trans-unit id="2d5cad3f2fc8b04bf4b9760b4ade680573ac4847" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNonReloadable</source>
          <target state="translated">TSymFlag.sfNonReloadable</target>
        </trans-unit>
        <trans-unit id="932c83b43941e8293a0c9790f9f7394ad71414e3" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfOverriden</source>
          <target state="translated">TSymFlag.sfOverriden</target>
        </trans-unit>
        <trans-unit id="71409f73c696c09edb6da3f445713c46904ca616" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfProcvar</source>
          <target state="translated">TSymFlag.sfProcvar</target>
        </trans-unit>
        <trans-unit id="76f94fff7ac23d224a5bc526747e1686feb676cb" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfPure</source>
          <target state="translated">TSymFlag.sfPure</target>
        </trans-unit>
        <trans-unit id="4fca142ba180109698776ba0a36c4f4c9002640d" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfRegister</source>
          <target state="translated">TSymFlag.sfRegister</target>
        </trans-unit>
        <trans-unit id="cfa983785f95c8ce9b0d73629a1d7067f48e010e" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfRequiresInit</source>
          <target state="translated">TSymFlag.sfRequiresInit</target>
        </trans-unit>
        <trans-unit id="5f6ecd6b6f03c52714fb8853b88eb55430032b09" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfShadowed</source>
          <target state="translated">TSymFlag.sfShadowed</target>
        </trans-unit>
        <trans-unit id="2e289288f11f81e4ac61b02d13c1fec9e78e2192" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSideEffect</source>
          <target state="translated">TSymFlag.sfSideEffect</target>
        </trans-unit>
        <trans-unit id="8d495c01577f4bf009f6865e434af0e0d8466fa6" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSingleUsedTemp</source>
          <target state="translated">TSymFlag.sfSingleUsedTemp</target>
        </trans-unit>
        <trans-unit id="7d50321a18c3926dabf7444407d02c677dbc42d4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSystemModule</source>
          <target state="translated">TSymFlag.sfSystemModule</target>
        </trans-unit>
        <trans-unit id="b56a7ace7f8cb72017ccb47cf2f59ddfa3bf7a2b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfTemplateParam</source>
          <target state="translated">TSymFlag.sfTemplateParam</target>
        </trans-unit>
        <trans-unit id="f939407b7d9d720c20e219b1739d2160b2c627de" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfThread</source>
          <target state="translated">TSymFlag.sfThread</target>
        </trans-unit>
        <trans-unit id="a32d4997116a1bb7e46d6e2074c08949f77ef009" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfUsed</source>
          <target state="translated">TSymFlag.sfUsed</target>
        </trans-unit>
        <trans-unit id="f0e174760c583a922fc6dedbb1f219b72c2ec6e4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfUsedInFinallyOrExcept</source>
          <target state="translated">TSymFlag.sfUsedInFinallyOrExcept</target>
        </trans-unit>
        <trans-unit id="82552db7e730ccc1f98ac08d01dfb4dea5d1f933" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfVolatile</source>
          <target state="translated">TSymFlag.sfVolatile</target>
        </trans-unit>
        <trans-unit id="72bdf7b7b1da7510d785d165cc71e2a29d569556" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfWasForwarded</source>
          <target state="translated">TSymFlag.sfWasForwarded</target>
        </trans-unit>
        <trans-unit id="29c7d5626ad614186f0d440855956d99d98de760" translate="yes" xml:space="preserve">
          <source>TSymFlag:</source>
          <target state="translated">TSymFlag:</target>
        </trans-unit>
        <trans-unit id="d47155ecd82d26176d884a3a5c7290848bc046d7" translate="yes" xml:space="preserve">
          <source>TSymFlags:</source>
          <target state="translated">TSymFlags:</target>
        </trans-unit>
        <trans-unit id="49a417dc99897410b26a479122d7c245c98404df" translate="yes" xml:space="preserve">
          <source>TSymKind.skAlias</source>
          <target state="translated">TSymKind.skAlias</target>
        </trans-unit>
        <trans-unit id="c76f677a9ccca1cb58417acb2f2221011359b50e" translate="yes" xml:space="preserve">
          <source>TSymKind.skConditional</source>
          <target state="translated">TSymKind.skConditional</target>
        </trans-unit>
        <trans-unit id="7dfa50d9174c876ce7d15bc1fd5aa7819f6eb7e8" translate="yes" xml:space="preserve">
          <source>TSymKind.skConst</source>
          <target state="translated">TSymKind.skConst</target>
        </trans-unit>
        <trans-unit id="919d3051204679f680a8114ed54198af8cd03508" translate="yes" xml:space="preserve">
          <source>TSymKind.skConverter</source>
          <target state="translated">TSymKind.skConverter</target>
        </trans-unit>
        <trans-unit id="57d44bfce9d934c7b94cccc0ed40283adea986f6" translate="yes" xml:space="preserve">
          <source>TSymKind.skDynLib</source>
          <target state="translated">TSymKind.skDynLib</target>
        </trans-unit>
        <trans-unit id="5a6a73a73234b278355b6d90ff6594ea1532cc5b" translate="yes" xml:space="preserve">
          <source>TSymKind.skEnumField</source>
          <target state="translated">TSymKind.skEnumField</target>
        </trans-unit>
        <trans-unit id="6b13fc9942e9012939aaa24c01ee74d54785096d" translate="yes" xml:space="preserve">
          <source>TSymKind.skField</source>
          <target state="translated">TSymKind.skField</target>
        </trans-unit>
        <trans-unit id="b42eb31691f0f152a922d109173d10452db09398" translate="yes" xml:space="preserve">
          <source>TSymKind.skForVar</source>
          <target state="translated">TSymKind.skForVar</target>
        </trans-unit>
        <trans-unit id="3c93bc5280899b1704d4939e91709f91bb81c109" translate="yes" xml:space="preserve">
          <source>TSymKind.skFunc</source>
          <target state="translated">TSymKind.skFunc</target>
        </trans-unit>
        <trans-unit id="e946aeda39742b18797afdfbc5ef7d032a114722" translate="yes" xml:space="preserve">
          <source>TSymKind.skGenericParam</source>
          <target state="translated">TSymKind.skGenericParam</target>
        </trans-unit>
        <trans-unit id="8b85c87c4b38369f835e342209e7c7ab4d80b88e" translate="yes" xml:space="preserve">
          <source>TSymKind.skIterator</source>
          <target state="translated">TSymKind.skIterator</target>
        </trans-unit>
        <trans-unit id="b9bec98f25dbc1b1c1c5bd16c387a21a1ad6a3d0" translate="yes" xml:space="preserve">
          <source>TSymKind.skLabel</source>
          <target state="translated">TSymKind.skLabel</target>
        </trans-unit>
        <trans-unit id="2b17d003c02f1eed23328282ec4b75a2c7bab33a" translate="yes" xml:space="preserve">
          <source>TSymKind.skLet</source>
          <target state="translated">TSymKind.skLet</target>
        </trans-unit>
        <trans-unit id="a8285a283b0af2c8fca7edc0b6fdc1913a6ce5b6" translate="yes" xml:space="preserve">
          <source>TSymKind.skMacro</source>
          <target state="translated">TSymKind.skMacro</target>
        </trans-unit>
        <trans-unit id="b8267d7384523a8483da02476006487bdba9d91f" translate="yes" xml:space="preserve">
          <source>TSymKind.skMethod</source>
          <target state="translated">TSymKind.skMethod</target>
        </trans-unit>
        <trans-unit id="60d683994d2f4bfd3a0468b0b5765ebadb8fd4e5" translate="yes" xml:space="preserve">
          <source>TSymKind.skModule</source>
          <target state="translated">TSymKind.skModule</target>
        </trans-unit>
        <trans-unit id="d4b3f8c98e41c6b045e0cf12b69a3c13146ded9b" translate="yes" xml:space="preserve">
          <source>TSymKind.skPackage</source>
          <target state="translated">TSymKind.skPackage</target>
        </trans-unit>
        <trans-unit id="581dde25239097be52aac3d98efd76085651c04c" translate="yes" xml:space="preserve">
          <source>TSymKind.skParam</source>
          <target state="translated">TSymKind.skParam</target>
        </trans-unit>
        <trans-unit id="d5061dd8b70ade95406188521b2aff052a2b8b76" translate="yes" xml:space="preserve">
          <source>TSymKind.skProc</source>
          <target state="translated">TSymKind.skProc</target>
        </trans-unit>
        <trans-unit id="10d6d5f68c3d570f559afef9c7d0e1c503f31c82" translate="yes" xml:space="preserve">
          <source>TSymKind.skResult</source>
          <target state="translated">TSymKind.skResult</target>
        </trans-unit>
        <trans-unit id="4b1403bed05bc383c650ebbd4da253f3677a73a7" translate="yes" xml:space="preserve">
          <source>TSymKind.skStub</source>
          <target state="translated">TSymKind.skStub</target>
        </trans-unit>
        <trans-unit id="e0042cc9bef9afa39e87b6f8dea08bedd12df156" translate="yes" xml:space="preserve">
          <source>TSymKind.skTemp</source>
          <target state="translated">TSymKind.skTemp</target>
        </trans-unit>
        <trans-unit id="baf8eeb56f3a1d01fb53ecac94f2eda78f5750d3" translate="yes" xml:space="preserve">
          <source>TSymKind.skTemplate</source>
          <target state="translated">TSymKind.skTemplate</target>
        </trans-unit>
        <trans-unit id="a4ea389dec6af0c3a90402fd6a64c460d4965315" translate="yes" xml:space="preserve">
          <source>TSymKind.skType</source>
          <target state="translated">TSymKind.skType</target>
        </trans-unit>
        <trans-unit id="e62db8421aee5327a828a735d66f7957f7d3d74f" translate="yes" xml:space="preserve">
          <source>TSymKind.skUnknown</source>
          <target state="translated">TSymKind.skUnknown</target>
        </trans-unit>
        <trans-unit id="c279ecb87280d50b68a3bd440f8e43008b19e819" translate="yes" xml:space="preserve">
          <source>TSymKind.skVar</source>
          <target state="translated">TSymKind.skVar</target>
        </trans-unit>
        <trans-unit id="36000b209f29bc98cf392b4e4456f57a84b3b59b" translate="yes" xml:space="preserve">
          <source>TSymKind:</source>
          <target state="translated">TSymKind:</target>
        </trans-unit>
        <trans-unit id="a3b25836cfbafe08072c36a3f31b50569b89cb87" translate="yes" xml:space="preserve">
          <source>TSymKinds:</source>
          <target state="translated">TSymKinds:</target>
        </trans-unit>
        <trans-unit id="40e65df88cca5769c108db4732546e9385041477" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccBcc</source>
          <target state="translated">TSystemCC.ccBcc</target>
        </trans-unit>
        <trans-unit id="6d00814fd9c17001351f26f74ecf8e0d598070b0" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccCLang</source>
          <target state="translated">TSystemCC.ccCLang</target>
        </trans-unit>
        <trans-unit id="19071fc3124e339066eeefd76c5caa5747d3b6d2" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccClangCl</source>
          <target state="translated">TSystemCC.ccClangCl</target>
        </trans-unit>
        <trans-unit id="fcb066cfa947fca39a83432714945b7e0f17d383" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccEnv</source>
          <target state="translated">TSystemCC.ccEnv</target>
        </trans-unit>
        <trans-unit id="97f6f68538eefe119e8183ea5c5e98feb0f79c6d" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccGcc</source>
          <target state="translated">TSystemCC.ccGcc</target>
        </trans-unit>
        <trans-unit id="7384f9d26bb7f0967750fd1f751e72ac5b69923c" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccIcc</source>
          <target state="translated">TSystemCC.ccIcc</target>
        </trans-unit>
        <trans-unit id="0f268723c4eae2053cac77dd39a6d770474f8223" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccIcl</source>
          <target state="translated">TSystemCC.ccIcl</target>
        </trans-unit>
        <trans-unit id="2b1588d1bf0a5cc64f3bcd66ca1d8ac7081f9e0f" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccLLVM_Gcc</source>
          <target state="translated">TSystemCC.ccLLVM_Gcc</target>
        </trans-unit>
        <trans-unit id="71239fb0d7cf2675e99b0aa8d9958cad2e7f2bc0" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccNintendoSwitch</source>
          <target state="translated">TSystemCC.ccNintendoSwitch</target>
        </trans-unit>
        <trans-unit id="41f122e6477383f472ab026e739beeca2659006d" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccNone</source>
          <target state="translated">TSystemCC.ccNone</target>
        </trans-unit>
        <trans-unit id="8e5ec951c8818fd50562a51f1771746f02dd9732" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccTcc</source>
          <target state="translated">TSystemCC.ccTcc</target>
        </trans-unit>
        <trans-unit id="d5d2fddd742551849c57359a32720a1a7c68c407" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccVcc</source>
          <target state="translated">TSystemCC.ccVcc</target>
        </trans-unit>
        <trans-unit id="e4b6b58efbe0ae82d8de0366bbeb65ef571f542b" translate="yes" xml:space="preserve">
          <source>TSystemCC:</source>
          <target state="translated">TSystemCC:</target>
        </trans-unit>
        <trans-unit id="e85203494b9cda1e361884f465c8d21638c17c47" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAVR</source>
          <target state="translated">TSystemCPU.cpuAVR</target>
        </trans-unit>
        <trans-unit id="e28d761304c4f6489545762c0b4c34008fc2245c" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAlpha</source>
          <target state="translated">TSystemCPU.cpuAlpha</target>
        </trans-unit>
        <trans-unit id="d801dcb1b7ceb4ce49f7a098ef0d8a08858eed98" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAmd64</source>
          <target state="translated">TSystemCPU.cpuAmd64</target>
        </trans-unit>
        <trans-unit id="ba596950092238df74b220c68b11c34fc419e0e0" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuArm</source>
          <target state="translated">TSystemCPU.cpuArm</target>
        </trans-unit>
        <trans-unit id="9ca4c13a0c290114fd7d1c85a30b5b41a67a5bc9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuArm64</source>
          <target state="translated">TSystemCPU.cpuArm64</target>
        </trans-unit>
        <trans-unit id="5b65105583f3819adb0632e62bb25e0a18da9bbb" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuEsp</source>
          <target state="translated">TSystemCPU.cpuEsp</target>
        </trans-unit>
        <trans-unit id="8447db6ec7fdf81f194cc4ecd1414b74f623750a" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuHppa</source>
          <target state="translated">TSystemCPU.cpuHppa</target>
        </trans-unit>
        <trans-unit id="bc456545a8d7ffa3ed8212abdb78b306dde88093" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuI386</source>
          <target state="translated">TSystemCPU.cpuI386</target>
        </trans-unit>
        <trans-unit id="c6083caa9bfe02d7c40b52f99d7b6abb8d7864f7" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuIa64</source>
          <target state="translated">TSystemCPU.cpuIa64</target>
        </trans-unit>
        <trans-unit id="3e878dd5fc4a0168ff6f7991ce1f44372aedc620" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuJS</source>
          <target state="translated">TSystemCPU.cpuJS</target>
        </trans-unit>
        <trans-unit id="76fba4bb86ffe7ff850b133c4c20c39bb685b516" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuM68k</source>
          <target state="translated">TSystemCPU.cpuM68k</target>
        </trans-unit>
        <trans-unit id="f2e8398a63ef93ff4063793c053f8dc154c4a290" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMSP430</source>
          <target state="translated">TSystemCPU.cpuMSP430</target>
        </trans-unit>
        <trans-unit id="c8a9c9af2114a96e56820717902c60073ab32b1f" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips</source>
          <target state="translated">TSystemCPU.cpuMips</target>
        </trans-unit>
        <trans-unit id="24591e6c0052949e99184099449d788dad8f29a9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips64</source>
          <target state="translated">TSystemCPU.cpuMips64</target>
        </trans-unit>
        <trans-unit id="6e85a81c06cdf314f2da1ba7bef924bc75a6edce" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips64el</source>
          <target state="translated">TSystemCPU.cpuMips64el</target>
        </trans-unit>
        <trans-unit id="1d8ab56ff314237fa81874b96bd0c570456c7697" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMipsel</source>
          <target state="translated">TSystemCPU.cpuMipsel</target>
        </trans-unit>
        <trans-unit id="1023f73aa3e9a1c6576d33e867de8b2de6ccddc1" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuNimVM</source>
          <target state="translated">TSystemCPU.cpuNimVM</target>
        </trans-unit>
        <trans-unit id="a5220471302688e090fd0384c2a6d0e2555a35dc" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuNone</source>
          <target state="translated">TSystemCPU.cpuNone</target>
        </trans-unit>
        <trans-unit id="e073cc300e253e5d6c5f43f1d40975ee3ee35f36" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc</source>
          <target state="translated">TSystemCPU.cpuPowerpc</target>
        </trans-unit>
        <trans-unit id="a0bb3fb97c3f25aa16dfdff5a063669cca1debb9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc64</source>
          <target state="translated">TSystemCPU.cpuPowerpc64</target>
        </trans-unit>
        <trans-unit id="d9b7e25410216178660f56da74dbf1b12974e3fc" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc64el</source>
          <target state="translated">TSystemCPU.cpuPowerpc64el</target>
        </trans-unit>
        <trans-unit id="3541d71f45742618d1e0853f477959e0683a8d59" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuRiscV64</source>
          <target state="translated">TSystemCPU.cpuRiscV64</target>
        </trans-unit>
        <trans-unit id="33e3b76ba433a36d3634e0f2077791506ce9b7cf" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuSparc</source>
          <target state="translated">TSystemCPU.cpuSparc</target>
        </trans-unit>
        <trans-unit id="2195ef6204df47de3f399d523e82333924ee50ee" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuSparc64</source>
          <target state="translated">TSystemCPU.cpuSparc64</target>
        </trans-unit>
        <trans-unit id="9fa0216f565e08a88e069b22b00651362a0a2abb" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuVm</source>
          <target state="translated">TSystemCPU.cpuVm</target>
        </trans-unit>
        <trans-unit id="9fb10eff42bbf00edd9d6dac15eb0b596991e106" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuWasm32</source>
          <target state="translated">TSystemCPU.cpuWasm32</target>
        </trans-unit>
        <trans-unit id="5e0590cc52dd7fd9f8c5f71948ac3e4fbb645e7d" translate="yes" xml:space="preserve">
          <source>TSystemCPU:</source>
          <target state="translated">TSystemCPU:</target>
        </trans-unit>
        <trans-unit id="0b357ac76e93964f0e9aa628cf5ff44e248e0aff" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAix</source>
          <target state="translated">TSystemOS.osAix</target>
        </trans-unit>
        <trans-unit id="57e794c9e1abb8e214350a820bef46513aa5410d" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAmiga</source>
          <target state="translated">TSystemOS.osAmiga</target>
        </trans-unit>
        <trans-unit id="139f446a98c51f26d348db327105203f84121229" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAndroid</source>
          <target state="translated">TSystemOS.osAndroid</target>
        </trans-unit>
        <trans-unit id="0601a6371692f109064f096efedf7295967e8403" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAny</source>
          <target state="translated">TSystemOS.osAny</target>
        </trans-unit>
        <trans-unit id="9ae1eebbb62dc69485803ce20300a53317d7990e" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAtari</source>
          <target state="translated">TSystemOS.osAtari</target>
        </trans-unit>
        <trans-unit id="2d7d69566045aa8beeaa3254d4276bb3fcfdef2c" translate="yes" xml:space="preserve">
          <source>TSystemOS.osDos</source>
          <target state="translated">TSystemOS.osDos</target>
        </trans-unit>
        <trans-unit id="309c21832c4018ef77f374a618bd781eea84a066" translate="yes" xml:space="preserve">
          <source>TSystemOS.osDragonfly</source>
          <target state="translated">TSystemOS.osDragonfly</target>
        </trans-unit>
        <trans-unit id="db54117145d85bc8c33b683ec9ab07263b4d6fd0" translate="yes" xml:space="preserve">
          <source>TSystemOS.osFreeRTOS</source>
          <target state="translated">TSystemOS.osFreeRTOS</target>
        </trans-unit>
        <trans-unit id="a664f10fbfe811c5a9d84bdfca93ff12f0358741" translate="yes" xml:space="preserve">
          <source>TSystemOS.osFreebsd</source>
          <target state="translated">TSystemOS.osFreebsd</target>
        </trans-unit>
        <trans-unit id="bc47a412753230d118928d7f63b36b9e6309d2c3" translate="yes" xml:space="preserve">
          <source>TSystemOS.osGenode</source>
          <target state="translated">TSystemOS.osGenode</target>
        </trans-unit>
        <trans-unit id="e940630397e431aed1fc63cca4ebe7f6fe232f0b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osHaiku</source>
          <target state="translated">TSystemOS.osHaiku</target>
        </trans-unit>
        <trans-unit id="c197905406125d16d4a6f74ab6b8199d900f4ecb" translate="yes" xml:space="preserve">
          <source>TSystemOS.osIos</source>
          <target state="translated">TSystemOS.osIos</target>
        </trans-unit>
        <trans-unit id="e57f2d8c18cd83b14c9fb9eb4ef124e0a1e3993f" translate="yes" xml:space="preserve">
          <source>TSystemOS.osIrix</source>
          <target state="translated">TSystemOS.osIrix</target>
        </trans-unit>
        <trans-unit id="1e7216ad040dd651e0cefb1f37074ad0662ffe75" translate="yes" xml:space="preserve">
          <source>TSystemOS.osJS</source>
          <target state="translated">TSystemOS.osJS</target>
        </trans-unit>
        <trans-unit id="c87dce60adfb5c9c9dc59db4d26f6b0b61fdff55" translate="yes" xml:space="preserve">
          <source>TSystemOS.osLinux</source>
          <target state="translated">TSystemOS.osLinux</target>
        </trans-unit>
        <trans-unit id="51b2d87a29af45151db0dc281d2828f8fc776f6f" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMacos</source>
          <target state="translated">TSystemOS.osMacos</target>
        </trans-unit>
        <trans-unit id="f3991a53075ffa27b2f9fe0029a6a1412cc9e393" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMacosx</source>
          <target state="translated">TSystemOS.osMacosx</target>
        </trans-unit>
        <trans-unit id="d7bc87d6f7e56f805a7e5c270db9eea5752ea7b2" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMorphos</source>
          <target state="translated">TSystemOS.osMorphos</target>
        </trans-unit>
        <trans-unit id="10192972afc69a1d3ba9c793e640fd1d96c5b030" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNetbsd</source>
          <target state="translated">TSystemOS.osNetbsd</target>
        </trans-unit>
        <trans-unit id="c20a3ae638bccfe7eadd065e638b9ad9bfa4571b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNetware</source>
          <target state="translated">TSystemOS.osNetware</target>
        </trans-unit>
        <trans-unit id="941a5d5eacc491c469cf30cfdacc174c871fce9c" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNimVM</source>
          <target state="translated">TSystemOS.osNimVM</target>
        </trans-unit>
        <trans-unit id="271c3ce037881f412f8686ade95524481697197b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNintendoSwitch</source>
          <target state="translated">TSystemOS.osNintendoSwitch</target>
        </trans-unit>
        <trans-unit id="e768046f46b0a39479496146233246e16a916c04" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNone</source>
          <target state="translated">TSystemOS.osNone</target>
        </trans-unit>
        <trans-unit id="e00eb077875a3b48219f06030696c42e78fe57a7" translate="yes" xml:space="preserve">
          <source>TSystemOS.osOpenbsd</source>
          <target state="translated">TSystemOS.osOpenbsd</target>
        </trans-unit>
        <trans-unit id="bf32d61ca1a1af77ebe67ab324a055555ee2e6d8" translate="yes" xml:space="preserve">
          <source>TSystemOS.osOs2</source>
          <target state="translated">TSystemOS.osOs2</target>
        </trans-unit>
        <trans-unit id="1de6f4e8e82651e9f443671af18e016ead98a709" translate="yes" xml:space="preserve">
          <source>TSystemOS.osPalmos</source>
          <target state="translated">TSystemOS.osPalmos</target>
        </trans-unit>
        <trans-unit id="f79e259295c14e93026df87a786a1dd63b1bede9" translate="yes" xml:space="preserve">
          <source>TSystemOS.osQnx</source>
          <target state="translated">TSystemOS.osQnx</target>
        </trans-unit>
        <trans-unit id="7cbac9d74c2ec82ad5104b2e56eb41053dacd2be" translate="yes" xml:space="preserve">
          <source>TSystemOS.osSkyos</source>
          <target state="translated">TSystemOS.osSkyos</target>
        </trans-unit>
        <trans-unit id="3281c9ed268a903d82b811ed828fc68ddfc04fd5" translate="yes" xml:space="preserve">
          <source>TSystemOS.osSolaris</source>
          <target state="translated">TSystemOS.osSolaris</target>
        </trans-unit>
        <trans-unit id="43c30ef6d951f5134eefd74464e64b290de75b49" translate="yes" xml:space="preserve">
          <source>TSystemOS.osStandalone</source>
          <target state="translated">TSystemOS.osStandalone</target>
        </trans-unit>
        <trans-unit id="0c3395ef39ac4ea1500b59f59cd08063a73bab08" translate="yes" xml:space="preserve">
          <source>TSystemOS.osVxWorks</source>
          <target state="translated">TSystemOS.osVxWorks</target>
        </trans-unit>
        <trans-unit id="f4d238b4f6b9e9640466505b29c89e6fca4fec2d" translate="yes" xml:space="preserve">
          <source>TSystemOS.osWindows</source>
          <target state="translated">TSystemOS.osWindows</target>
        </trans-unit>
        <trans-unit id="a398d417d4982e6dc512eed7c6b59f54a754c05a" translate="yes" xml:space="preserve">
          <source>TSystemOS:</source>
          <target state="translated">TSystemOS:</target>
        </trans-unit>
        <trans-unit id="5939aea9b487dbaab0cf08324f9a9a447e0900d6" translate="yes" xml:space="preserve">
          <source>TTabIter:</source>
          <target state="translated">TTabIter:</target>
        </trans-unit>
        <trans-unit id="41a2786fc2af3e24ec0db6712d87f40503eeb20a" translate="yes" xml:space="preserve">
          <source>TType:</source>
          <target state="translated">TType:</target>
        </trans-unit>
        <trans-unit id="0179cb50ac4de959ffb192e0c7cac0b96227caa5" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taConcept</source>
          <target state="translated">TTypeAllowedFlag.taConcept</target>
        </trans-unit>
        <trans-unit id="1ab466e6e741e60ca7ec60a6466864011131025b" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taField</source>
          <target state="translated">TTypeAllowedFlag.taField</target>
        </trans-unit>
        <trans-unit id="41fc7c202eebd75be3d703e98072a7e5c8a9aa2d" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taHeap</source>
          <target state="translated">TTypeAllowedFlag.taHeap</target>
        </trans-unit>
        <trans-unit id="84923533778030da718d0e06375c33a0ac63e9e2" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taIsOpenArray</source>
          <target state="translated">TTypeAllowedFlag.taIsOpenArray</target>
        </trans-unit>
        <trans-unit id="b776ebbbb740385436b4bfb8d79613dfcd7bcbb0" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taIsTemplateOrMacro</source>
          <target state="translated">TTypeAllowedFlag.taIsTemplateOrMacro</target>
        </trans-unit>
        <trans-unit id="21016ece821aa9e90d83fb2832e84a88cacbff06" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taNoUntyped</source>
          <target state="translated">TTypeAllowedFlag.taNoUntyped</target>
        </trans-unit>
        <trans-unit id="1e6587542c7ae2cb27035918684c4c8b1e6310a4" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taProcContextIsNotMacro</source>
          <target state="translated">TTypeAllowedFlag.taProcContextIsNotMacro</target>
        </trans-unit>
        <trans-unit id="0c27a5b363ed5d06f5fcff4f8f3cd0f5b9037a56" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag:</source>
          <target state="translated">TTypeAllowedFlag:</target>
        </trans-unit>
        <trans-unit id="1c785b4d25a85f7f1bd956c98d088327a638a168" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlags:</source>
          <target state="translated">TTypeAllowedFlags:</target>
        </trans-unit>
        <trans-unit id="fc314936ddd603367171fd74694532c6adab99c5" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedAsgn</source>
          <target state="translated">TTypeAttachedOp.attachedAsgn</target>
        </trans-unit>
        <trans-unit id="244a557e848e3357faa4c21471b5db088d254294" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDeepCopy</source>
          <target state="translated">TTypeAttachedOp.attachedDeepCopy</target>
        </trans-unit>
        <trans-unit id="d228ecd9ce629a0b6a2787576a6558af6f68ae3e" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDestructor</source>
          <target state="translated">TTypeAttachedOp.attachedDestructor</target>
        </trans-unit>
        <trans-unit id="f483a09d6048ebca812d1d5b4b03ae8a218b0bb1" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDispose</source>
          <target state="translated">TTypeAttachedOp.attachedDispose</target>
        </trans-unit>
        <trans-unit id="3096d633136bbc7a07581b04b5aaee8b92e9b64a" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedSink</source>
          <target state="translated">TTypeAttachedOp.attachedSink</target>
        </trans-unit>
        <trans-unit id="86d3ba82c3894d71a1b3ccc344a0436109b3a0f5" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedTrace</source>
          <target state="translated">TTypeAttachedOp.attachedTrace</target>
        </trans-unit>
        <trans-unit id="11947d14da2dcca262c11f9b632e36d5279b9394" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp:</source>
          <target state="translated">TTypeAttachedOp:</target>
        </trans-unit>
        <trans-unit id="a4777dfef03acb138ec00e5f5dac24713684c810" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.AllowCommonBase</source>
          <target state="translated">TTypeCmpFlag.AllowCommonBase</target>
        </trans-unit>
        <trans-unit id="08054a53231843d58690f59314cbbb52f2cbc9e1" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactConstraints</source>
          <target state="translated">TTypeCmpFlag.ExactConstraints</target>
        </trans-unit>
        <trans-unit id="dbd1a6dd6abd1ffaf12460691d968606f8673a65" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactGcSafety</source>
          <target state="translated">TTypeCmpFlag.ExactGcSafety</target>
        </trans-unit>
        <trans-unit id="9f819df93295a98eaeb321d4b6079aec8c164d85" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactGenericParams</source>
          <target state="translated">TTypeCmpFlag.ExactGenericParams</target>
        </trans-unit>
        <trans-unit id="e77812cda4c0753c698e8c0498f046c40895fb34" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactTypeDescValues</source>
          <target state="translated">TTypeCmpFlag.ExactTypeDescValues</target>
        </trans-unit>
        <trans-unit id="5caaebda03569c71bc228f3143586b5714b80433" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.IgnoreCC</source>
          <target state="translated">TTypeCmpFlag.IgnoreCC</target>
        </trans-unit>
        <trans-unit id="34bb7146abb78508eaa04cb5d2873ff599851422" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.IgnoreTupleFields</source>
          <target state="translated">TTypeCmpFlag.IgnoreTupleFields</target>
        </trans-unit>
        <trans-unit id="bf93f85a21ebbc559f03dc5707e37933d7b14f2d" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag:</source>
          <target state="translated">TTypeCmpFlag:</target>
        </trans-unit>
        <trans-unit id="498a511c8026855650e5a2ba2b904e6d84f82234" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlags:</source>
          <target state="translated">TTypeCmpFlags:</target>
        </trans-unit>
        <trans-unit id="d0e24d269c517c1b4bc789cfecbbd836ad6fbac9" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frEmbedded</source>
          <target state="translated">TTypeFieldResult.frEmbedded</target>
        </trans-unit>
        <trans-unit id="27e394cb11693eacb4df02e2be4fb610f74ff8c5" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frHeader</source>
          <target state="translated">TTypeFieldResult.frHeader</target>
        </trans-unit>
        <trans-unit id="c880285eca6461cf26d70962d5837af33ec7cc9c" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frNone</source>
          <target state="translated">TTypeFieldResult.frNone</target>
        </trans-unit>
        <trans-unit id="f34b70cba43b23bfa6138b86b37f9d3d7361a027" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult:</source>
          <target state="translated">TTypeFieldResult:</target>
        </trans-unit>
        <trans-unit id="07dda03b526235c5508321c7c957bd5e603ef411" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfAcyclic</source>
          <target state="translated">TTypeFlag.tfAcyclic</target>
        </trans-unit>
        <trans-unit id="492bbf177977468bf98f4d90b2c9714340f015e1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfBorrowDot</source>
          <target state="translated">TTypeFlag.tfBorrowDot</target>
        </trans-unit>
        <trans-unit id="61a1d723dd629d7b07c67072f73b46bc90f0959c" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfByCopy</source>
          <target state="translated">TTypeFlag.tfByCopy</target>
        </trans-unit>
        <trans-unit id="541fb2e55b81a6ab5f365397011759c9505ede38" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfByRef</source>
          <target state="translated">TTypeFlag.tfByRef</target>
        </trans-unit>
        <trans-unit id="9688f0415838a906d60e24908d80b68f81241882" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCapturesEnv</source>
          <target state="translated">TTypeFlag.tfCapturesEnv</target>
        </trans-unit>
        <trans-unit id="d1b4c04a78c4c7522f83770d237e4d7dfdc924c1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCheckedForDestructor</source>
          <target state="translated">TTypeFlag.tfCheckedForDestructor</target>
        </trans-unit>
        <trans-unit id="e44aebdb77c17dcb57c1d24ad8339727bf36ae48" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCompleteStruct</source>
          <target state="translated">TTypeFlag.tfCompleteStruct</target>
        </trans-unit>
        <trans-unit id="b77dcb2df70fd10ff909ff7e2dbcff5cc591dcf3" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfConceptMatchedTypeSym</source>
          <target state="translated">TTypeFlag.tfConceptMatchedTypeSym</target>
        </trans-unit>
        <trans-unit id="fefae8ad7615c4812fbb252a50d8111bf1260edb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfContravariant</source>
          <target state="translated">TTypeFlag.tfContravariant</target>
        </trans-unit>
        <trans-unit id="865ca7278467ef7c57ec318b49c36c1058995317" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCovariant</source>
          <target state="translated">TTypeFlag.tfCovariant</target>
        </trans-unit>
        <trans-unit id="7ec74d81ff75de9cfb8d82d5ab38f21444e79930" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfEnumHasHoles</source>
          <target state="translated">TTypeFlag.tfEnumHasHoles</target>
        </trans-unit>
        <trans-unit id="62891ed3c719c5f3a87e0e3b3d719a87b193e77e" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfExplicit</source>
          <target state="translated">TTypeFlag.tfExplicit</target>
        </trans-unit>
        <trans-unit id="e655c39bef25c2645747fda6be0bfd46ffb7eb95" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfExplicitCallConv</source>
          <target state="translated">TTypeFlag.tfExplicitCallConv</target>
        </trans-unit>
        <trans-unit id="2a0a3e3e399b7653b1ce51d297d01a7567960145" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfFinal</source>
          <target state="translated">TTypeFlag.tfFinal</target>
        </trans-unit>
        <trans-unit id="7efa2781c32ea8c56df82dc8fdcb82405d5e4ec3" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfFromGeneric</source>
          <target state="translated">TTypeFlag.tfFromGeneric</target>
        </trans-unit>
        <trans-unit id="c8218feacbb0d962dfc20c78f02f2f19249a2499" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfGenericTypeParam</source>
          <target state="translated">TTypeFlag.tfGenericTypeParam</target>
        </trans-unit>
        <trans-unit id="94b23fdc1f9be74a942541a44b48ace763b7eeba" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasAsgn</source>
          <target state="translated">TTypeFlag.tfHasAsgn</target>
        </trans-unit>
        <trans-unit id="340337f27d0ed433616603d9f2096f2fcc004030" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasGCedMem</source>
          <target state="translated">TTypeFlag.tfHasGCedMem</target>
        </trans-unit>
        <trans-unit id="1ef98b05e773391c3890de47fca15279f6381830" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasMeta</source>
          <target state="translated">TTypeFlag.tfHasMeta</target>
        </trans-unit>
        <trans-unit id="c76cb66820108662e672cda96558668868f0ee8d" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasOwned</source>
          <target state="translated">TTypeFlag.tfHasOwned</target>
        </trans-unit>
        <trans-unit id="2e772657dc53ed9a1620b3a0c39627b24331dc04" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasStatic</source>
          <target state="translated">TTypeFlag.tfHasStatic</target>
        </trans-unit>
        <trans-unit id="dff62e95dca9a1dc168f15021d19e34f13feb23e" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfImplicitTypeParam</source>
          <target state="translated">TTypeFlag.tfImplicitTypeParam</target>
        </trans-unit>
        <trans-unit id="4df96677e3b3240385e91807dbc9fc3358411860" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfIncompleteStruct</source>
          <target state="translated">TTypeFlag.tfIncompleteStruct</target>
        </trans-unit>
        <trans-unit id="930ccf22728f33a61ab0e9df37cdee8e9fea4d7d" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfInferrableStatic</source>
          <target state="translated">TTypeFlag.tfInferrableStatic</target>
        </trans-unit>
        <trans-unit id="3522e964b52dcccafb9e5b9278cb94ad79dae611" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfInheritable</source>
          <target state="translated">TTypeFlag.tfInheritable</target>
        </trans-unit>
        <trans-unit id="b371c0c24a850d8dea175a373e8f12f72a1bc6f9" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfIterator</source>
          <target state="translated">TTypeFlag.tfIterator</target>
        </trans-unit>
        <trans-unit id="e1ca502e9e481d427baed979cec9414f52c79127" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNeedsFullInit</source>
          <target state="translated">TTypeFlag.tfNeedsFullInit</target>
        </trans-unit>
        <trans-unit id="01077f60a85e95e4495eab0f02047407c4b30ef5" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNoSideEffect</source>
          <target state="translated">TTypeFlag.tfNoSideEffect</target>
        </trans-unit>
        <trans-unit id="79d4b029bb3501a85efe8bede40509b746b3d7a5" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNotNil</source>
          <target state="translated">TTypeFlag.tfNotNil</target>
        </trans-unit>
        <trans-unit id="cbd9ad039539212e281c90be72dca6bc97948623" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfPacked</source>
          <target state="translated">TTypeFlag.tfPacked</target>
        </trans-unit>
        <trans-unit id="458f48a3e3ae523480285d4c0ca455dc1c932287" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfPartial</source>
          <target state="translated">TTypeFlag.tfPartial</target>
        </trans-unit>
        <trans-unit id="30060e7f1dacb103767e0e3290bea2c969e2e05b" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRefsAnonObj</source>
          <target state="translated">TTypeFlag.tfRefsAnonObj</target>
        </trans-unit>
        <trans-unit id="2ce5b832b6054dca36395a8724d2b6bf08d288fd" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRequiresInit</source>
          <target state="translated">TTypeFlag.tfRequiresInit</target>
        </trans-unit>
        <trans-unit id="6cd7c314319b31e80c85e2aeaa5b6d6229861d80" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfResolved</source>
          <target state="translated">TTypeFlag.tfResolved</target>
        </trans-unit>
        <trans-unit id="57d0c1c354ebb903950e18b1ea2422f5a671ebad" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRetType</source>
          <target state="translated">TTypeFlag.tfRetType</target>
        </trans-unit>
        <trans-unit id="19da5492bd0f1c1bed7f9b0bdbb37ad9b80297f1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfShallow</source>
          <target state="translated">TTypeFlag.tfShallow</target>
        </trans-unit>
        <trans-unit id="4fbe0e2add3932e6d78c23adc9387486f4069c85" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfThread</source>
          <target state="translated">TTypeFlag.tfThread</target>
        </trans-unit>
        <trans-unit id="ab0ce2164600dc950eb2b7fb70f55a980b4758fb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfTriggersCompileTime</source>
          <target state="translated">TTypeFlag.tfTriggersCompileTime</target>
        </trans-unit>
        <trans-unit id="124971b39b855098afccb89eafe9573eb9d42cb7" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfUnresolved</source>
          <target state="translated">TTypeFlag.tfUnresolved</target>
        </trans-unit>
        <trans-unit id="1e9a1f1b732cade91b1acda56e8c05cc36b96afb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfVarIsPtr</source>
          <target state="translated">TTypeFlag.tfVarIsPtr</target>
        </trans-unit>
        <trans-unit id="63329715065a634decbbdfb21351e109a6523dbc" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfVarargs</source>
          <target state="translated">TTypeFlag.tfVarargs</target>
        </trans-unit>
        <trans-unit id="00d99459be70f9dbf6c6302eaea8bdb97e23f954" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfWeakCovariant</source>
          <target state="translated">TTypeFlag.tfWeakCovariant</target>
        </trans-unit>
        <trans-unit id="b5c1f860bd9f168e67788a1c38d26ecc09dec0fa" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfWildcard</source>
          <target state="translated">TTypeFlag.tfWildcard</target>
        </trans-unit>
        <trans-unit id="2adde959189d5b343f23cd353b4d37a83cace747" translate="yes" xml:space="preserve">
          <source>TTypeFlag:</source>
          <target state="translated">TTypeFlag:</target>
        </trans-unit>
        <trans-unit id="d59afbc89b03748b97eeb7784a6be209e4ec232e" translate="yes" xml:space="preserve">
          <source>TTypeFlags:</source>
          <target state="translated">TTypeFlags:</target>
        </trans-unit>
        <trans-unit id="0799b6844305ff658e62e4c61e62afea46cba75e" translate="yes" xml:space="preserve">
          <source>TTypeIter:</source>
          <target state="translated">TTypeIter:</target>
        </trans-unit>
        <trans-unit id="0e94930a34c36d8014636584ecef2e6f378c27d4" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAlias</source>
          <target state="translated">TTypeKind.tyAlias</target>
        </trans-unit>
        <trans-unit id="aaa78f2e3d082ce1fbd4438726f28035d92e095d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAnd</source>
          <target state="translated">TTypeKind.tyAnd</target>
        </trans-unit>
        <trans-unit id="fd91855f9e2dcde880f924d16173113e3e1b61e1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAnything</source>
          <target state="translated">TTypeKind.tyAnything</target>
        </trans-unit>
        <trans-unit id="9354bc694c58a7afeed8a1989ffdcebda8d635ba" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyArray</source>
          <target state="translated">TTypeKind.tyArray</target>
        </trans-unit>
        <trans-unit id="d683a07782061ea2f9df06f8689f622ba9454189" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyBool</source>
          <target state="translated">TTypeKind.tyBool</target>
        </trans-unit>
        <trans-unit id="4c9f258391d62b12b4667b1b42b74fb340ba6b59" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyBuiltInTypeClass</source>
          <target state="translated">TTypeKind.tyBuiltInTypeClass</target>
        </trans-unit>
        <trans-unit id="6e942a569bf365b7c45b78de9efe9f71ff40de3d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyCString</source>
          <target state="translated">TTypeKind.tyCString</target>
        </trans-unit>
        <trans-unit id="511c95f3bf2518a4a39007d083a27a85305bedc1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyChar</source>
          <target state="translated">TTypeKind.tyChar</target>
        </trans-unit>
        <trans-unit id="7742b6ae524066429ad5352a80bda321b5285f75" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyCompositeTypeClass</source>
          <target state="translated">TTypeKind.tyCompositeTypeClass</target>
        </trans-unit>
        <trans-unit id="2a784a78647c1e3e964953a212689787e672594d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyDistinct</source>
          <target state="translated">TTypeKind.tyDistinct</target>
        </trans-unit>
        <trans-unit id="18c089e63473641136815b0a6d7bf588d7d64999" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyEmpty</source>
          <target state="translated">TTypeKind.tyEmpty</target>
        </trans-unit>
        <trans-unit id="2526b0c10b2351f8dbfa6da5035a8a387fa9c777" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyEnum</source>
          <target state="translated">TTypeKind.tyEnum</target>
        </trans-unit>
        <trans-unit id="9fe7ce6fd6ca9fbd4f25ef3769702eb83ff469dd" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat</source>
          <target state="translated">TTypeKind.tyFloat</target>
        </trans-unit>
        <trans-unit id="a4769bad08648c768c93b8baf10d667c24671dad" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat128</source>
          <target state="translated">TTypeKind.tyFloat128</target>
        </trans-unit>
        <trans-unit id="137504e5db5f6079c3f46e17fdc68f112e26aa6f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat32</source>
          <target state="translated">TTypeKind.tyFloat32</target>
        </trans-unit>
        <trans-unit id="2320a8bfb8228efc60a98b1d16d14d4f0d1433c1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat64</source>
          <target state="translated">TTypeKind.tyFloat64</target>
        </trans-unit>
        <trans-unit id="90f5e7cf547d6b01512557903c89b0a2ad5c7032" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyForward</source>
          <target state="translated">TTypeKind.tyForward</target>
        </trans-unit>
        <trans-unit id="3b0b71a42c8eb3c1fdfda0933a8770612f7d08f6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFromExpr</source>
          <target state="translated">TTypeKind.tyFromExpr</target>
        </trans-unit>
        <trans-unit id="12d126b517177624b9e02b6b96c24ae10adf45eb" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericBody</source>
          <target state="translated">TTypeKind.tyGenericBody</target>
        </trans-unit>
        <trans-unit id="de845c162ecd730c92bb80e09d4bb9053e73e573" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericInst</source>
          <target state="translated">TTypeKind.tyGenericInst</target>
        </trans-unit>
        <trans-unit id="f88959f6c872ba3ea1f46dfc3561a3c5dde14c54" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericInvocation</source>
          <target state="translated">TTypeKind.tyGenericInvocation</target>
        </trans-unit>
        <trans-unit id="fbb70eb257b50185f4b954462d2ba16e53967fed" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericParam</source>
          <target state="translated">TTypeKind.tyGenericParam</target>
        </trans-unit>
        <trans-unit id="853c3eecc6fcaf56b29249082e02899201195e48" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInferred</source>
          <target state="translated">TTypeKind.tyInferred</target>
        </trans-unit>
        <trans-unit id="6404738e10ebb3dcb5589e48bb5e56bb2533caaa" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt</source>
          <target state="translated">TTypeKind.tyInt</target>
        </trans-unit>
        <trans-unit id="7c8ee29852e8351d0f1d971179082ce8cd2b0024" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt16</source>
          <target state="translated">TTypeKind.tyInt16</target>
        </trans-unit>
        <trans-unit id="b5b83741acbdbefe77c61f8a51808f3d606f63cc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt32</source>
          <target state="translated">TTypeKind.tyInt32</target>
        </trans-unit>
        <trans-unit id="123cec70680ef83da6e7a9ffb0d86468a21015be" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt64</source>
          <target state="translated">TTypeKind.tyInt64</target>
        </trans-unit>
        <trans-unit id="ac89b343111dc1fff094fe7dbcf90fdc19196e9f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt8</source>
          <target state="translated">TTypeKind.tyInt8</target>
        </trans-unit>
        <trans-unit id="76f25dd9884e161024bfa5f564f1906fa8cf619f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyLent</source>
          <target state="translated">TTypeKind.tyLent</target>
        </trans-unit>
        <trans-unit id="35cb952eb790cfb8e6a4e4aab86c688b8fa7e124" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNil</source>
          <target state="translated">TTypeKind.tyNil</target>
        </trans-unit>
        <trans-unit id="71e8edc4e61c7cdf3e4997d53132d2cda61cf5fc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNone</source>
          <target state="translated">TTypeKind.tyNone</target>
        </trans-unit>
        <trans-unit id="1369f3e3f05baa699232f96db48f89e2c5242e25" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNot</source>
          <target state="translated">TTypeKind.tyNot</target>
        </trans-unit>
        <trans-unit id="9869385fdcf65fc4a99fec4a021241c955d0aa0d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyObject</source>
          <target state="translated">TTypeKind.tyObject</target>
        </trans-unit>
        <trans-unit id="76b82e94d2b94bf82bc8e9254e91d86d17d2978c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOpenArray</source>
          <target state="translated">TTypeKind.tyOpenArray</target>
        </trans-unit>
        <trans-unit id="048e0ed42c7f4744c48765cba6ff85550d9a0211" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOptDeprecated</source>
          <target state="translated">TTypeKind.tyOptDeprecated</target>
        </trans-unit>
        <trans-unit id="18dd91d976315b46cb15e86ec56c56d374119c01" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOr</source>
          <target state="translated">TTypeKind.tyOr</target>
        </trans-unit>
        <trans-unit id="cc7bb6ded55da7fb8d1720b7046d8b4bbae4787d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOrdinal</source>
          <target state="translated">TTypeKind.tyOrdinal</target>
        </trans-unit>
        <trans-unit id="cea6fcc9a7c93c39e116e6f6c1f7689425ab37da" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOwned</source>
          <target state="translated">TTypeKind.tyOwned</target>
        </trans-unit>
        <trans-unit id="be58929a3b5905e5864a5485a037acbc879065fe" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyPointer</source>
          <target state="translated">TTypeKind.tyPointer</target>
        </trans-unit>
        <trans-unit id="67120b56f6d6aa69e8bc1107a81083dfa3ee051c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyProc</source>
          <target state="translated">TTypeKind.tyProc</target>
        </trans-unit>
        <trans-unit id="59a5014ce6420bae5c138704ad0fd1c37bcde90a" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyProxy</source>
          <target state="translated">TTypeKind.tyProxy</target>
        </trans-unit>
        <trans-unit id="057a72ed748c03837581945e869c3f0ed0e92469" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyPtr</source>
          <target state="translated">TTypeKind.tyPtr</target>
        </trans-unit>
        <trans-unit id="c8eed250118a7a9d611bef4dc76f8aaacce2fd38" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyRange</source>
          <target state="translated">TTypeKind.tyRange</target>
        </trans-unit>
        <trans-unit id="cba8b92fdb447a4f368ae8ca4e118769c1b3efbc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyRef</source>
          <target state="translated">TTypeKind.tyRef</target>
        </trans-unit>
        <trans-unit id="fa5dda72f61e0985f3c73b6f0bb85cd481daea63" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySequence</source>
          <target state="translated">TTypeKind.tySequence</target>
        </trans-unit>
        <trans-unit id="ee6ab4c13a0e2ed8b67bb350e10728fbc4cf9b33" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySet</source>
          <target state="translated">TTypeKind.tySet</target>
        </trans-unit>
        <trans-unit id="aa5a8169c7e1887deee9d36d06459624aba21871" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySink</source>
          <target state="translated">TTypeKind.tySink</target>
        </trans-unit>
        <trans-unit id="8d1466bb3d8fbc74b547dbb02f8273952a0b78af" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyStatic</source>
          <target state="translated">TTypeKind.tyStatic</target>
        </trans-unit>
        <trans-unit id="b3ef56ea678262c074740aa06af22e3a6787d993" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyString</source>
          <target state="translated">TTypeKind.tyString</target>
        </trans-unit>
        <trans-unit id="64ea2c5a8456daca800c8a3b265eba0a8ade3ce6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTuple</source>
          <target state="translated">TTypeKind.tyTuple</target>
        </trans-unit>
        <trans-unit id="88fc66a60b94046b8dcb50a75f66be0331e70f96" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTypeDesc</source>
          <target state="translated">TTypeKind.tyTypeDesc</target>
        </trans-unit>
        <trans-unit id="142da8d1e146731ca1c66fd3bcd95bba93b8fe3c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTyped</source>
          <target state="translated">TTypeKind.tyTyped</target>
        </trans-unit>
        <trans-unit id="1658fe5326db5a52a5764addf749b1e6161f0ce9" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt</source>
          <target state="translated">TTypeKind.tyUInt</target>
        </trans-unit>
        <trans-unit id="48317f7c389eeb326c561089ca5e8724017fa883" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt16</source>
          <target state="translated">TTypeKind.tyUInt16</target>
        </trans-unit>
        <trans-unit id="6238df6a06ed2f153d500aba172e98e52f860f9b" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt32</source>
          <target state="translated">TTypeKind.tyUInt32</target>
        </trans-unit>
        <trans-unit id="54b6ec0922deab6616588f895ec17ad140779038" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt64</source>
          <target state="translated">TTypeKind.tyUInt64</target>
        </trans-unit>
        <trans-unit id="a60a984a93b313cce3325fc55efa6c80fb9d3af7" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt8</source>
          <target state="translated">TTypeKind.tyUInt8</target>
        </trans-unit>
        <trans-unit id="4d387420fd3b923de5af82186671f01ffdda3b42" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUncheckedArray</source>
          <target state="translated">TTypeKind.tyUncheckedArray</target>
        </trans-unit>
        <trans-unit id="5fea571764be8dd44ae507fe59dfe65eb19a23f6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUntyped</source>
          <target state="translated">TTypeKind.tyUntyped</target>
        </trans-unit>
        <trans-unit id="2f7a5d57c0ae3f1e3072ce48e36c4dfa73af6c2d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUserTypeClass</source>
          <target state="translated">TTypeKind.tyUserTypeClass</target>
        </trans-unit>
        <trans-unit id="24264e5e4579a6ec06665830d8241dd5aa692ba3" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUserTypeClassInst</source>
          <target state="translated">TTypeKind.tyUserTypeClassInst</target>
        </trans-unit>
        <trans-unit id="9c04403a1098db54c18beaf124b6e51bee5f7895" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVar</source>
          <target state="translated">TTypeKind.tyVar</target>
        </trans-unit>
        <trans-unit id="866cab95392f4667de7ddae8e874f6986631628a" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVarargs</source>
          <target state="translated">TTypeKind.tyVarargs</target>
        </trans-unit>
        <trans-unit id="0b2d9d9a212dcc3a4f3dad5f1e7b0175893b324c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVoid</source>
          <target state="translated">TTypeKind.tyVoid</target>
        </trans-unit>
        <trans-unit id="3134e079fd35c63fb7e622ec1abdb7e40e287014" translate="yes" xml:space="preserve">
          <source>TTypeKind:</source>
          <target state="translated">TTypeKind:</target>
        </trans-unit>
        <trans-unit id="a8c405dd55f6718f5c54eeffd414bca9bafc966d" translate="yes" xml:space="preserve">
          <source>TTypeKinds:</source>
          <target state="translated">TTypeKinds:</target>
        </trans-unit>
        <trans-unit id="ae0ffc4a19658ae080fa434ffc876212d8e0d92d" translate="yes" xml:space="preserve">
          <source>TTypeMutator:</source>
          <target state="translated">TTypeMutator:</target>
        </trans-unit>
        <trans-unit id="05748a9a1a8c6a023693c76bab719c68ef5b92fd" translate="yes" xml:space="preserve">
          <source>TTypePredicate:</source>
          <target state="translated">TTypePredicate:</target>
        </trans-unit>
        <trans-unit id="c5566ac9e2bab44c01dcf254d6aee02e6b31a08b" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trBindGenericParam</source>
          <target state="translated">TTypeRelFlag.trBindGenericParam</target>
        </trans-unit>
        <trans-unit id="3e622cd2fec1785d21b7f65f5c359ac7937ffca0" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trDontBind</source>
          <target state="translated">TTypeRelFlag.trDontBind</target>
        </trans-unit>
        <trans-unit id="78c4a7d831ae9cc483125be7ce07c572063bbc4f" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trNoCovariance</source>
          <target state="translated">TTypeRelFlag.trNoCovariance</target>
        </trans-unit>
        <trans-unit id="af4b6bd841aa6a165e0d34d467927854db0bdc8a" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag:</source>
          <target state="translated">TTypeRelFlag:</target>
        </trans-unit>
        <trans-unit id="e94014289638374be4190459e1bb501dfbfe41b3" translate="yes" xml:space="preserve">
          <source>TTypeRelFlags:</source>
          <target state="translated">TTypeRelFlags:</target>
        </trans-unit>
        <trans-unit id="68cb51af66e4090ea344468d781203193c332184" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isBothMetaConvertible</source>
          <target state="translated">TTypeRelation.isBothMetaConvertible</target>
        </trans-unit>
        <trans-unit id="a2e80fd4cc56e47b80e688c235bbc805b6e28b7f" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isConvertible</source>
          <target state="translated">TTypeRelation.isConvertible</target>
        </trans-unit>
        <trans-unit id="54f04f59123456c3c8647d13c32aa81bb0bc0b52" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isEqual</source>
          <target state="translated">TTypeRelation.isEqual</target>
        </trans-unit>
        <trans-unit id="76aabe09fdc4d3bcdca6dfca911f86ac68529f00" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isFromIntLit</source>
          <target state="translated">TTypeRelation.isFromIntLit</target>
        </trans-unit>
        <trans-unit id="082a825a1a1a2a4f69e162637c5a47f9d4400e34" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isGeneric</source>
          <target state="translated">TTypeRelation.isGeneric</target>
        </trans-unit>
        <trans-unit id="72c719a9fea45aac02dd7bcd06d7c7ed7f91da1d" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isInferred</source>
          <target state="translated">TTypeRelation.isInferred</target>
        </trans-unit>
        <trans-unit id="662bc4c4df86dd8e5b1049fa1d4acfbe0e2d8265" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isInferredConvertible</source>
          <target state="translated">TTypeRelation.isInferredConvertible</target>
        </trans-unit>
        <trans-unit id="8a647b6c47b21eace0c04cd901e76cde68ae44ee" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isIntConv</source>
          <target state="translated">TTypeRelation.isIntConv</target>
        </trans-unit>
        <trans-unit id="4077456390389013fe90dba0c8bf8db83eb1972c" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isNone</source>
          <target state="translated">TTypeRelation.isNone</target>
        </trans-unit>
        <trans-unit id="4b202228dda6caf9d917364e5054857c13bc8b7c" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isSubrange</source>
          <target state="translated">TTypeRelation.isSubrange</target>
        </trans-unit>
        <trans-unit id="22c70d23f666f85e7e90ddf5522d7832f8ee4f8f" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isSubtype</source>
          <target state="translated">TTypeRelation.isSubtype</target>
        </trans-unit>
        <trans-unit id="d3d3096e711373571f5b9192698fbb731341abb9" translate="yes" xml:space="preserve">
          <source>TTypeRelation:</source>
          <target state="translated">TTypeRelation:</target>
        </trans-unit>
        <trans-unit id="bef60ed135f7ec02d27299402bbea768a713fd96" translate="yes" xml:space="preserve">
          <source>TTypeSeq:</source>
          <target state="translated">TTypeSeq:</target>
        </trans-unit>
        <trans-unit id="0424f6e7026fa4bc2c4a7043083417315113c79b" translate="yes" xml:space="preserve">
          <source>Table</source>
          <target state="translated">Table</target>
        </trans-unit>
        <trans-unit id="cb0d62cece24d665ba7c89ca01c113d1046f4bc2" translate="yes" xml:space="preserve">
          <source>Table constructor</source>
          <target state="translated">Конструктор стола</target>
        </trans-unit>
        <trans-unit id="e587514d976f1576a7f186c3a6d78f175315a9f6" translate="yes" xml:space="preserve">
          <source>Tabulator:</source>
          <target state="translated">Tabulator:</target>
        </trans-unit>
        <trans-unit id="d9afbd5c6dd4be0b038affd18116707f9d6423e7" translate="yes" xml:space="preserve">
          <source>Tag tracking</source>
          <target state="translated">Отслеживание тегов</target>
        </trans-unit>
        <trans-unit id="479ac325890826d9bc3274ae4b0deca389100a15" translate="yes" xml:space="preserve">
          <source>TagsExt:</source>
          <target state="translated">TagsExt:</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">Режим пятна</target>
        </trans-unit>
        <trans-unit id="dfaa7a1f02c7c5f9df730df7121afa459170ff28" translate="yes" xml:space="preserve">
          <source>Take special care when declaring types as &lt;code&gt;proc&lt;/code&gt;. The behavior is similar to &lt;code&gt;Procedure declaration&lt;/code&gt;, below, but does not treat &lt;code&gt;nnkGenericParams&lt;/code&gt;. Generic parameters are treated in the type, not the &lt;code&gt;proc&lt;/code&gt; itself.</source>
          <target state="translated">Будьте особенно осторожны при объявлении типов как &lt;code&gt;proc&lt;/code&gt; . Поведение аналогично &lt;code&gt;nnkGenericParams&lt;/code&gt; &lt;code&gt;Procedure declaration&lt;/code&gt; ниже, но не обрабатывает nnkGenericParams . Общие параметры рассматриваются в типе, а не &lt;code&gt;proc&lt;/code&gt; сам.</target>
        </trans-unit>
        <trans-unit id="d3177dcd252a829ea158763962a47c4a3515c7ff" translate="yes" xml:space="preserve">
          <source>Take the address of a memory location</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09ca39d193d2434090092284c392d73e10f5bf2" translate="yes" xml:space="preserve">
          <source>Take the element at the reversed index &lt;code&gt;x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25c3237baf7da022bd4ce5dd72ff7bbd7b4e0d2" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;typedesc&lt;/code&gt; as its first argument, and a series of expressions of type &lt;code&gt;key: value&lt;/code&gt;, and returns a value of the specified type with each field &lt;code&gt;key&lt;/code&gt; set to &lt;code&gt;value&lt;/code&gt;, as specified in the arguments of &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">Принимает &lt;code&gt;typedesc&lt;/code&gt; в качестве своего первого аргумента и серию выражений типа &lt;code&gt;key: value&lt;/code&gt; и возвращает значение указанного типа с каждым &lt;code&gt;key&lt;/code&gt; поля, установленным в &lt;code&gt;value&lt;/code&gt; , как указано в аргументах &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5694602502f6f1e320a5499e60e3f6eb2a597ab1" translate="yes" xml:space="preserve">
          <source>Takes a float which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">Берет поплавок,который содержит количество секунд с эпохи уникс и возвращает объект времени.</target>
        </trans-unit>
        <trans-unit id="aae55bc35eb360650aead66c4fe99a44fac76e39" translate="yes" xml:space="preserve">
          <source>Takes an int which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">Берет int,который содержит количество секунд,прошедших с эпохи unix,и возвращает объект времени.</target>
        </trans-unit>
        <trans-unit id="4bad4e5a1f77a3fa2ad87fcd6030a2fbe78305df" translate="yes" xml:space="preserve">
          <source>Takes an integer and outputs as many &quot;hello world!&quot;s</source>
          <target state="translated">Берет целое число и выводит столько же &quot;hello world!&quot; s</target>
        </trans-unit>
        <trans-unit id="c9d3b8db138f77125cd16835e385cbe69f4a0651" translate="yes" xml:space="preserve">
          <source>Takes any Nim variable and returns its string representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca4638357a681dba4149f01bff4b890bc77cb16" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence.</source>
          <target state="translated">Берет несколько элементов последовательности и возвращает их в новой последовательности.</target>
        </trans-unit>
        <trans-unit id="1d0f497b886e1c9d3d4474b4148e5709da878636" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence. All sequences must be of the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54bd658583d742b0230f0f3e91860906626fd48f" translate="yes" xml:space="preserve">
          <source>Takes the name of a procedure and wraps it into a lambda missing the first argument, which passes the JavaScript builtin &lt;code&gt;this&lt;/code&gt; as the first argument to the procedure. Returns the resulting lambda.</source>
          <target state="translated">Принимает имя процедуры и превращает его в лямбду без первого аргумента, которая передает встроенный в &lt;code&gt;this&lt;/code&gt; JavaScript в качестве первого аргумента процедуры. Возвращает полученную лямбду.</target>
        </trans-unit>
        <trans-unit id="652ac2cbbafccc62d55637f20bfa949ef565ffbd" translate="yes" xml:space="preserve">
          <source>Target:</source>
          <target state="translated">Target:</target>
        </trans-unit>
        <trans-unit id="7bb0ddf9221c03b806b03c209e8366000124aa15" translate="yes" xml:space="preserve">
          <source>Task</source>
          <target state="translated">Task</target>
        </trans-unit>
        <trans-unit id="355e12f6e10b7be272268c5408e0e1f1879ead8f" translate="yes" xml:space="preserve">
          <source>Template based implementation of singly and doubly linked lists. The involved types should have 'prev' or 'next' fields and the list header should have 'head' or 'tail' fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbcef4f12fbf3e15c5cc83ae7b0ad02579d3228" translate="yes" xml:space="preserve">
          <source>Template declaration</source>
          <target state="translated">Шаблонная декларация</target>
        </trans-unit>
        <trans-unit id="29776c1f962d7f1926246264b64cf2699a605475" translate="yes" xml:space="preserve">
          <source>Template evaluation engine. Now hygienic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6df49bcce99024a2e48ebc7e962779552b3e40" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from left to right, returning the accumulation.</source>
          <target state="translated">Шаблон для складывания последовательности слева направо,возвращая накопление.</target>
        </trans-unit>
        <trans-unit id="de22212f29283d60e7209a9a47f7c24e8243be55" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from right to left, returning the accumulation.</source>
          <target state="translated">Шаблон для складывания последовательности справа налево,возвращая накопление.</target>
        </trans-unit>
        <trans-unit id="59878defe4e964ab557114291111d6b850a911e6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;code&gt;useStdoutAsStdmsg&lt;/code&gt; compile-time switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe50b6e0ad8f81f8d1ff40ace889c5bf58be0d6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; compile-time switch.</source>
          <target state="translated">Шаблон, который расширяется до stdout или stderr в зависимости от &lt;em&gt;переключателя времени&lt;/em&gt; компиляции &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f24083e3c7410b73370a6d3df27c2a49cb0ea1cc" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt;. Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="translated">Шаблоны (а также макросы, как мы увидим) имеют немного расширенный AST по сравнению с процедурами и итераторами. Причина в [макросе перезаписи терминов] ( &lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt; . Обратите внимание на &lt;code&gt;nnkEmpty()&lt;/code&gt; как на второй аргумент для &lt;code&gt;nnkProcDef&lt;/code&gt; и &lt;code&gt;nnkIteratorDef&lt;/code&gt; выше? Вот где идут макросы перезаписи терминов.</target>
        </trans-unit>
        <trans-unit id="f36defcdec2c7464ebb1521bbe1cf9a515e6bfe9" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](manual.html#term-rewriting-macros). Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfcea00b9c87e288d0369354ff63f75a960b95b" translate="yes" xml:space="preserve">
          <source>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</source>
          <target state="translated">Шаблоны-это простой механизм подстановки,который работает на абстрактных синтаксических деревьях Nim.Шаблоны обрабатываются в семантическом проходе компилятора.Они хорошо интегрируются с остальной частью языка и не имеют недостатков препроцессорных макросов Си.</target>
        </trans-unit>
        <trans-unit id="96f5a0e5d16500060d1f7d5115cee45e47157761" translate="yes" xml:space="preserve">
          <source>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</source>
          <target state="translated">Шаблоны особенно полезны для ленивых оценок.Рассмотрим простой промежуток времени для протоколирования:</target>
        </trans-unit>
        <trans-unit id="a4ab366bab0be60e3998095c84a25a6598269dc1" translate="yes" xml:space="preserve">
          <source>Temporary storage for &lt;code&gt;readLine&lt;/code&gt;</source>
          <target state="translated">Временное хранилище для &lt;code&gt;readLine&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="436d3b3abfa26ce88c28da41a780d32ff7044d09" translate="yes" xml:space="preserve">
          <source>Ten:</source>
          <target state="translated">Ten:</target>
        </trans-unit>
        <trans-unit id="12becf9bfcde13ef359cbd10e21ac3558b60cd6c" translate="yes" xml:space="preserve">
          <source>Term rewriting macro are applied recursively, up to a limit. This means that if the result of a term rewriting macro is eligible for another rewriting, the compiler will try to perform it, and so on, until no more optimizations are applicable. To avoid putting the compiler into an infinite loop, there is a hard limit on how many times a single term rewriting macro can be applied. Once this limit has been passed, the term rewriting macro will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ead6a06ca5a06f3fd3f26aa97c8aa66bfd565e" translate="yes" xml:space="preserve">
          <source>Term rewriting macros</source>
          <target state="translated">Макросы переписывания термина</target>
        </trans-unit>
        <trans-unit id="4139a7e773cb83cc6ffda3dc77a553344908c967" translate="yes" xml:space="preserve">
          <source>Term rewriting macros and templates are currently greedy and they will rewrite as long as there is a match. There was no way to ensure some rewrite happens only once, e.g. when rewriting term to same term plus extra content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6680ab0f20ce389b5124d56dd72b741a29ed36a" translate="yes" xml:space="preserve">
          <source>Term rewriting macros are macros or templates that have not only a &lt;em&gt;name&lt;/em&gt; but also a &lt;em&gt;pattern&lt;/em&gt; that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</source>
          <target state="translated">Макросы перезаписи терминов - это макросы или шаблоны, которые имеют не только &lt;em&gt;имя,&lt;/em&gt; но и &lt;em&gt;шаблон,&lt;/em&gt; который ищется после фазы семантической проверки компилятора: это означает, что они предоставляют простой способ улучшить конвейер компиляции с помощью определенных пользователем оптимизаций:</target>
        </trans-unit>
        <trans-unit id="41291f4ae4297ee61df6a797422526ba9e83df38" translate="yes" xml:space="preserve">
          <source>Terminal symbol</source>
          <target state="translated">Символ терминала</target>
        </trans-unit>
        <trans-unit id="bef52f1c5083f29909e547fdf32cc8985b604537" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;RSTR_LIT&lt;/code&gt;.</source>
          <target state="translated">Терминальный символ в грамматике: &lt;code&gt;RSTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a8a9bac49fc0459e1510c675469f02c63be7ca" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;STR_LIT&lt;/code&gt;.</source>
          <target state="translated">Терминальный символ в грамматике: &lt;code&gt;STR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d576d491af5f274a42068737f7ccbdab6163370" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">Терминальный символ в грамматике: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e69f5068cdc01aad4375523276cb15e9d4ebbbc8" translate="yes" xml:space="preserve">
          <source>Terminal symbols in the grammar: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt;, &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">Терминальные символы в грамматике: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt; , &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="785f87cb41855c7bc99d2fd2726f808d1af1b5e6" translate="yes" xml:space="preserve">
          <source>Terminates the async http server instance.</source>
          <target state="translated">Прекращает работу асинхронного http-сервера.</target>
        </trans-unit>
        <trans-unit id="751a90a6435d21431d11cc9e3b0833f5ca5eb590" translate="yes" xml:space="preserve">
          <source>Terminates the connection to the server.</source>
          <target state="translated">Прекращает соединение с сервером.</target>
        </trans-unit>
        <trans-unit id="e3597aaf6cdfbeaf6431029759d5522ddcee7a42" translate="yes" xml:space="preserve">
          <source>Test case file format</source>
          <target state="translated">Формат файла тестового случая</target>
        </trans-unit>
        <trans-unit id="b33a4cfd962fe2b39c56b4ecde938402268b2e10" translate="yes" xml:space="preserve">
          <source>Test for a block special file.</source>
          <target state="translated">Тест на специальный файл блока.</target>
        </trans-unit>
        <trans-unit id="a9f69337598e21f93cab2ebd657596ec3df3e129" translate="yes" xml:space="preserve">
          <source>Test for a character special file.</source>
          <target state="translated">Тест на наличие специального файла для символов.</target>
        </trans-unit>
        <trans-unit id="952a8cbcb1fcde688a18a823ebbda401d701fbcd" translate="yes" xml:space="preserve">
          <source>Test for a directory.</source>
          <target state="translated">Тест на наличие каталога.</target>
        </trans-unit>
        <trans-unit id="1d54cb1533572699c4c3111108695b83f5f3b3b8" translate="yes" xml:space="preserve">
          <source>Test for a message queue.</source>
          <target state="translated">Тест на очереди сообщений.</target>
        </trans-unit>
        <trans-unit id="f90ba2506c9fa49f566e376d10a4bb5d7ba584a7" translate="yes" xml:space="preserve">
          <source>Test for a pipe or FIFO special file.</source>
          <target state="translated">Тест на трубу или специальный файл FIFO.</target>
        </trans-unit>
        <trans-unit id="f13d7458dcb8f1aa6f0b325ab968c053f51907a9" translate="yes" xml:space="preserve">
          <source>Test for a regular file.</source>
          <target state="translated">Тест на обычный файл.</target>
        </trans-unit>
        <trans-unit id="2ac777a23cc611262a8452a43aeb1f412c46ac83" translate="yes" xml:space="preserve">
          <source>Test for a semaphore.</source>
          <target state="translated">Тест на семафор.</target>
        </trans-unit>
        <trans-unit id="63a613e82f42e3dfcb1758affe0e08e5bab7c6eb" translate="yes" xml:space="preserve">
          <source>Test for a shared memory object.</source>
          <target state="translated">Тест на объект общей памяти.</target>
        </trans-unit>
        <trans-unit id="c255ce2ca23650ca45172eee903a6b011becc55e" translate="yes" xml:space="preserve">
          <source>Test for a socket.</source>
          <target state="translated">Тест на розетку.</target>
        </trans-unit>
        <trans-unit id="e7ff66eaf314a4eceeaf9ad8b6c2a819916574da" translate="yes" xml:space="preserve">
          <source>Test for a symbolic link.</source>
          <target state="translated">Тест на символическую ссылку.</target>
        </trans-unit>
        <trans-unit id="4605d91385c3aaf247a50562a412cef1a6a892ab" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;body&lt;/code&gt; raises an exception found in the passed &lt;code&gt;exceptions&lt;/code&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765e5922fa70d1f573a8d979885d6d361bb38400" translate="yes" xml:space="preserve">
          <source>Test if &lt;em&gt;body&lt;/em&gt; raises an exception found in the passed &lt;em&gt;exceptions&lt;/em&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="translated">Проверьте, вызывает ли &lt;em&gt;тело&lt;/em&gt; исключение из переданных &lt;em&gt;исключений&lt;/em&gt; . Тест считается пройденным, если возникшее исключение является частью допустимых исключений. В противном случае это не удается. Пример:</target>
        </trans-unit>
        <trans-unit id="adc4fd08a5eb9c1e704b8fb9dedc41a222765399" translate="yes" xml:space="preserve">
          <source>Test macro for a typed memory object.</source>
          <target state="translated">Тестовый макрос для типизированного объекта памяти.</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">Тестовый набор</target>
        </trans-unit>
        <trans-unit id="450392a2e8adbf4bec17df3a66d6c7ef132d0fc1" translate="yes" xml:space="preserve">
          <source>Tested on these OSes: Linux, Windows, OSX</source>
          <target state="translated">Протестировано на этих операционных системах:Linux,Windows,OSX</target>
        </trans-unit>
        <trans-unit id="dbb71175e7ed02ff6aee92d2ec95782f4f92c6f4" translate="yes" xml:space="preserve">
          <source>Tests can be nested, however failure of a nested test will not mark the parent test as failed. Setup and teardown are inherited. Setup can be overridden locally.</source>
          <target state="translated">Тесты могут быть вложенными,однако неудача вложенного теста не помечает родительский тест как неудавшийся.Установки и подсчеты наследуются.Установка может быть переопределена локально.</target>
        </trans-unit>
        <trans-unit id="47e7d34d76d0c77b4690ea7930812dcf7ab8551a" translate="yes" xml:space="preserve">
          <source>Tests matching &lt;strong&gt;any&lt;/strong&gt; of the arguments are executed.</source>
          <target state="translated">Выполняются тесты, соответствующие &lt;strong&gt;любому&lt;/strong&gt; из аргументов.</target>
        </trans-unit>
        <trans-unit id="6aab81bfaf53615e8f766c7726f5ae51db83d879" translate="yes" xml:space="preserve">
          <source>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node.</source>
          <target state="translated">Тестирует,реализует ли реализация DOM специфическую функцию,и поддерживается ли эта функция этим узлом.</target>
        </trans-unit>
        <trans-unit id="1e818cf07cf8e76c8618215a67e1d6f19768f1e0" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficial if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613d55da24ea8bd5c97f0f07cd2c9af975d55abd" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficical if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="translated">Тесты с GCC на Amd64 показали,что действительно полезно,если указатель 'environment' передается как последний аргумент,а не как первый.</target>
        </trans-unit>
        <trans-unit id="eddf3fb8e9d38e4f4520f01f09a65dc746e3f5e3" translate="yes" xml:space="preserve">
          <source>TexExt:</source>
          <target state="translated">TexExt:</target>
        </trans-unit>
        <trans-unit id="e8cdc19c721145f3b16f493ae9be16412d223832" translate="yes" xml:space="preserve">
          <source>Thankfully there is a mechanism which tracks the count of each pending future. All you need to do to enable it is compile with &lt;code&gt;-d:futureLogging&lt;/code&gt; and use the &lt;code&gt;getFuturesInProgress&lt;/code&gt; procedure to get the list of pending futures together with the stack traces to the moment of their creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd9cd67f9ffbc2e8869c9ea4ebafbfe80184633" translate="yes" xml:space="preserve">
          <source>Thanks to its conditional construct &lt;code&gt;$[0|1|2|else]&lt;/code&gt; it supports &lt;span id=&quot;internationalization_1&quot;&gt;internationalization&lt;/span&gt; of format string literals quite well.</source>
          <target state="translated">Благодаря условной конструкции &lt;code&gt;$[0|1|2|else]&lt;/code&gt; он достаточно хорошо поддерживает &lt;span id=&quot;internationalization_1&quot;&gt;интернационализацию&lt;/span&gt; строковых литералов формата.</target>
        </trans-unit>
        <trans-unit id="12b773bb24713516f53e274a95d42c996bab5cb9" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="translated">Это означает,что только первые буквы сравниваются с учетом регистра.Остальные буквы сравниваются нечувствительно к регистру в диапазоне ASCII,а знаки подчеркивания игнорируются.</target>
        </trans-unit>
        <trans-unit id="a28d5e34c7b2663c0713d2b4afa31d2e7083c425" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case-sensitive manner. Other letters are compared case-insensitively within the ASCII range and underscores are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15669c375b35911d24b624c36d00f40792243390" translate="yes" xml:space="preserve">
          <source>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</source>
          <target state="translated">Это означает преобразовать его в нижний регистр и удалить любое '_'.Это НЕ следует использовать для нормализации имен идентификаторов Nim.</target>
        </trans-unit>
        <trans-unit id="3e6b575176e4e0021d4817389fa98f764c8fefe3" translate="yes" xml:space="preserve">
          <source>That means to convert to lower case and remove any '_' on all characters except first one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff708ff6bc18720eda543fbf97c4bd701261199" translate="yes" xml:space="preserve">
          <source>That these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2158ac17be0eaafff993defade193f729c2e722f" translate="yes" xml:space="preserve">
          <source>The &quot;``&quot; notation can also be used to call an operator just like any other procedure:</source>
          <target state="translated">Нотация &quot;``&quot; также может быть использована для вызова оператора,как и любая другая процедура:</target>
        </trans-unit>
        <trans-unit id="5f2ef68a81ed2af2d4d7e3322bfe17eca009c9a5" translate="yes" xml:space="preserve">
          <source>The &quot;compiler&quot; directory contains compiler sources and should not be part of the compiler binary package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ebfc1a638cb27eb2a7bdc1bbdba99b104e75e6" translate="yes" xml:space="preserve">
          <source>The &quot;hello world&quot; program contains several identifiers that are already known to the compiler: &lt;code&gt;echo&lt;/code&gt;, &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;, etc. These built-ins are declared in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module which is implicitly imported by any other module.</source>
          <target state="translated">Программа &quot;hello world&quot; содержит несколько идентификаторов, которые уже известны компилятору: &lt;code&gt;echo&lt;/code&gt; , &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; и т. Д. Эти встроенные функции объявлены в &lt;a href=&quot;system&quot;&gt;системном&lt;/a&gt; модуле, который неявно импортируется любым другим модулем.</target>
        </trans-unit>
        <trans-unit id="4660111e8f03f55e19e040ae55e537bca96088fa" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="translated">&amp;laquo;Типы&amp;raquo; шаблоны могут быть символы &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; или &lt;code&gt;type&lt;/code&gt; . Это &amp;laquo;метатипы&amp;raquo;, их можно использовать только в определенных контекстах. Могут использоваться и обычные типы; это означает, что ожидаются &lt;code&gt;typed&lt;/code&gt; выражения.</target>
        </trans-unit>
        <trans-unit id="58575d0da306b056823523ef29ad9acd2044c039" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;typedesc&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29301d597d1872c3e865f162650568b25afe624" translate="yes" xml:space="preserve">
          <source>The 'precision' is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.</source>
          <target state="translated">Точность&quot;-это десятичное число,указывающее,сколько цифр должно отображаться после запятой при преобразовании с плавающей точкой.Для нецифровых типов в поле указывается максимальный размер поля-другими словами,сколько символов будет использовано из содержимого поля.При целочисленном преобразовании точность игнорируется.</target>
        </trans-unit>
        <trans-unit id="77bffde3bb99cdc6cc73c28c1d75251c36736508" translate="yes" xml:space="preserve">
          <source>The 'return' statement should ideally be used when its control-flow properties are required. Use a procedure's implicit 'result' variable whenever possible. This improves readability.</source>
          <target state="translated">Оператор 'return' в идеале должен использоваться,когда требуются его свойства потока управления.По возможности используйте неявную переменную 'result' процедуры.Это улучшает читабельность.</target>
        </trans-unit>
        <trans-unit id="2fffbfa23769923249ad2d3fd0e589b66b9c9408" translate="yes" xml:space="preserve">
          <source>The 'sign' option is only valid for numeric types, and can be one of the following:</source>
          <target state="translated">Опция 'Знак' действительна только для числовых типов и может быть одной из следующих:</target>
        </trans-unit>
        <trans-unit id="fa7a7006450028d34fa532dc709a868bd4924dee" translate="yes" xml:space="preserve">
          <source>The (integer) value of the radix used to represent any floating point type on the architecture used to build the program.</source>
          <target state="translated">(целое)значение радиуса,используемого для представления любого типа с плавающей точкой на архитектуре,используемой для сборки программы.</target>
        </trans-unit>
        <trans-unit id="ff8eeedfc1309560a0b81603400e43bdfaaa92e0" translate="yes" xml:space="preserve">
          <source>The .cursor annotation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb52f076b6836abd5a2c61714693f2d361382a7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;format variables&lt;/a&gt; present within &lt;code&gt;frmt&lt;/code&gt; will be replaced with the corresponding values before being prepended to &lt;code&gt;args&lt;/code&gt; and returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f1e3b636e0e7248dc7db8e6a0a959c7c1db3d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#getopt.i,OptParser&quot;&gt;getopt iterator&lt;/a&gt;, which is provided for convenience, can be used to iterate through all command line options as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab168c9fb07b629d33d94adcd06a5a7b86f04e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#nimble&quot;&gt;bottom&lt;/a&gt; of this page includes a list of 3rd party packages created by the Nim community. These packages are a useful addition to the modules in the standard library.</source>
          <target state="translated">&lt;a href=&quot;#nimble&quot;&gt;Дно&lt;/a&gt; этой страницы включает в себя список 3 - сторонних пакетов , созданных сообществом Nim. Эти пакеты являются полезным дополнением к модулям стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="2a9b60df59f882b166b262beab63215a98833664" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="translated">В &lt;a href=&quot;nimc&quot;&gt;руководстве пользователя компилятора Nim &lt;/a&gt; &lt;code&gt;.nim&lt;/code&gt; типичный вызов компилятора с использованием команды &lt;code&gt;compile&lt;/code&gt; или &lt;code&gt;c&lt;/code&gt; для преобразования файла .nim в один или несколько файлов &lt;code&gt;.c&lt;/code&gt; , которые затем компилируются с помощью компилятора C платформы в статический двоичный файл. Однако есть и другие команды для компиляции в C ++, Objective-C или JavaScript. В этом документе делается попытка сосредоточить в одном месте все параметры серверной части и интерфейса.</target>
        </trans-unit>
        <trans-unit id="8d531a309bd956c39bd6508c1a41b8169d1ae032" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However, there are other commands to compile to C++, Objective-C, or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33326c6e57348f7442036bfc7267b110b7072b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;manual#implementation-specific-pragmas-compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;manual#implementation-specific-pragmas-passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d9a77578450b8a08312f7178544f27b410a5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;nimc#compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;nimc#dynliboverride&quot;&gt;DynlibOverride&lt;/a&gt; ключ командной строки позволяет избежать динамического связывания , если вам необходимо статически - то вместо этого. Оболочки Nim, предназначенные для статической компоновки исходных файлов, могут использовать &lt;a href=&quot;nimc#compile-pragma&quot;&gt;директиву compile,&lt;/a&gt; если источников мало или предоставить их вместе с кодом Nim проще, чем использовать системную библиотеку. Библиотеки, установленные в хост-системе, могут быть связаны с &lt;a href=&quot;nimc#passl-pragma&quot;&gt;прагмой PassL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee78ba5934ab094d006d5548d674ad0a80ec7579" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system#inc&quot;&gt;inc&lt;/a&gt;, &lt;a href=&quot;system#dec&quot;&gt;dec&lt;/a&gt;, &lt;a href=&quot;system#succ&quot;&gt;succ&lt;/a&gt; and &lt;a href=&quot;system#pred&quot;&gt;pred&lt;/a&gt; operations can fail by raising an &lt;em&gt;EOutOfRange&lt;/em&gt; or &lt;em&gt;EOverflow&lt;/em&gt; exception. (If the code has been compiled with the proper runtime checks turned on.)</source>
          <target state="translated">&lt;a href=&quot;system#inc&quot;&gt;Вкл&lt;/a&gt; , &lt;a href=&quot;system#dec&quot;&gt;декабрь&lt;/a&gt; , &lt;a href=&quot;system#succ&quot;&gt;Succ&lt;/a&gt; и &lt;a href=&quot;system#pred&quot;&gt;Pred&lt;/a&gt; операции могут не путем поднимая &lt;em&gt;EOutOfRange&lt;/em&gt; или &lt;em&gt;EOVERFLOW&lt;/em&gt; исключение. (Если код был скомпилирован с включенными надлежащими проверками времени выполнения.)</target>
        </trans-unit>
        <trans-unit id="15e6a3a29797da15852fead9e28ee2b0370e150e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates:</source>
          <target state="translated">&lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; операторы фактически являются шаблонами:</target>
        </trans-unit>
        <trans-unit id="2199e698bdfaf3681a19531d523f1d0976b1bdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates: this has the benefit that if you overload the &lt;code&gt;==&lt;/code&gt; operator, the &lt;code&gt;!=&lt;/code&gt; operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</source>
          <target state="translated">&lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; операторы фактически являются шаблонами: это имеет то преимущество , что , если вы перегружать &lt;code&gt;==&lt;/code&gt; оператора, &lt;code&gt;!=&lt;/code&gt; Оператор доступен автоматически и делает правильные вещи. (За исключением чисел с плавающей запятой IEEE - NaN нарушает базовую логику.)</target>
        </trans-unit>
        <trans-unit id="094e0d63fcca9df22fc0f3fbd6b2b575dd7da3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; and the &lt;code&gt;#dynlib&lt;/code&gt; directives are mutually exclusive. A binding that uses &lt;code&gt;dynlib&lt;/code&gt; is much more preferable over one that uses &lt;code&gt;header&lt;/code&gt;! The Nim compiler might drop support for the &lt;code&gt;header&lt;/code&gt; pragma in the future as it cannot work for backends that do not generate C code.</source>
          <target state="translated">&lt;code&gt;#header&lt;/code&gt; и &lt;code&gt;#dynlib&lt;/code&gt; директивы являются взаимоисключающими. Привязка, использующая &lt;code&gt;dynlib&lt;/code&gt; , намного предпочтительнее привязки , использующей &lt;code&gt;header&lt;/code&gt; ! Компилятор Nim может отказаться от поддержки прагмы &lt;code&gt;header&lt;/code&gt; в будущем, поскольку он не может работать для бэкэндов, которые не генерируют код C.</target>
        </trans-unit>
        <trans-unit id="f43b7889013c5efda25d7e2a5951e7e48009b60a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; directive tells c2nim that it should annotate every proc that resulted from a C function prototype and every exported variable and type with the &lt;code&gt;header&lt;/code&gt; pragma:</source>
          <target state="translated">&lt;code&gt;#header&lt;/code&gt; директива говорит c2nim , что он должен аннотировать каждый прок, полученный в результате функции C прототипа и каждой экспортируемой переменной и типа с &lt;code&gt;header&lt;/code&gt; Pragma:</target>
        </trans-unit>
        <trans-unit id="8d682f6cc241d8bb6822410eaa23e70f79490caf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#skipcomments&lt;/code&gt; directive can be put into the C code to make c2nim ignore comments and not copy them into the generated Nim file.</source>
          <target state="translated">&lt;code&gt;#skipcomments&lt;/code&gt; директива может быть введена в код C , чтобы c2nim игнорировать комментарии , а не копировать их в созданный файл Nim.</target>
        </trans-unit>
        <trans-unit id="c45bd804ab79049b4d0886ddf5d109c11eb57c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#typeprefixes&lt;/code&gt; directive can be put into the C code to make c2nim generate the &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; prefix for every defined type.</source>
          <target state="translated">&lt;code&gt;#typeprefixes&lt;/code&gt; директива может быть введена в код C , чтобы генерировать c2nim &lt;code&gt;T&lt;/code&gt; или &lt;code&gt;P&lt;/code&gt; префикс для каждого определенного типа.</target>
        </trans-unit>
        <trans-unit id="6ba0d1128c367616c99c9dc0a68b1f43d686832f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator can convert any enumeration value to its name, and the &lt;code&gt;ord&lt;/code&gt; proc can convert it to its underlying integer value.</source>
          <target state="translated">Оператор &lt;code&gt;$&lt;/code&gt; может преобразовать любое значение перечисления в свое имя, а процедура &lt;code&gt;ord&lt;/code&gt; может преобразовать его в соответствующее целочисленное значение.</target>
        </trans-unit>
        <trans-unit id="95c3c3a1c938decb53d03460e20948578c7b0a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for count tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3f7201a0436a6523f0d28e1c7472c08aaccda5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for hash tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592ba1cbd0b60e530272f88b56bd19674725e88b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for int sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b4969c881c889a18fdc86d07e053ec65d62580" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for ordered hash tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87980ae4827ecb34a1ff7d3485ef0b12328b955c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for string tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2254ec838e1c34b6ee8c8791b0a6e0a4aeca15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%&lt;/code&gt; operator for string tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae68c571abf2694e7a2359e8dbac146d141b789" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; is much like the &lt;code&gt;*&lt;/code&gt; operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; очень похоже на &lt;code&gt;*&lt;/code&gt; оператор, за исключением того, что он собирает не только все аргументы, но и совпадающая операторы в обратной польской записи:</target>
        </trans-unit>
        <trans-unit id="8023e9669b603ea0fcacf9f6cda5d9d92f066b57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; оператор</target>
        </trans-unit>
        <trans-unit id="d5b2439f0e50417f5d7601f9c27477b456c09ecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; Оператор</target>
        </trans-unit>
        <trans-unit id="aef4abe76e6ffc1cb6cb1bd388d212ec07b74cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can &lt;em&gt;flatten&lt;/em&gt; a nested binary expression like &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; to &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt;:</source>
          <target state="translated">Оператор &lt;code&gt;*&lt;/code&gt; может &lt;em&gt;сгладить&lt;/em&gt; вложенное двоичное выражение, например &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; , в &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7325bb59d54b70872d714ee28dd75a93b55b1c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; option, commonly used to denote that every token that follows is an argument, is interpreted as a long option, and its name is the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6b5c181de77c676c99c40b4e5b0d932bb8b8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--context&lt;/code&gt; idetools switch is very similar to the suggestions switch, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">&lt;code&gt;--context&lt;/code&gt; переключатель idetools очень похож на предложения переключения, но вместо того , чтобы использовать после того , как пользователь напечатал точечный характер, это один предназначен для использования после того , как пользователь ввел открывающую скобку , чтобы начать параметры набора текста.</target>
        </trans-unit>
        <trans-unit id="c4b4b572ba4241498b55d821bb912dd3ce8ce04c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--def&lt;/code&gt; idetools switch performs a query about the definition of a specific symbol. If available, idetools will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">В &lt;code&gt;--def&lt;/code&gt; idetools коммутатор выполняет запрос об определении конкретного символа. Если доступно, idetools ответит типом, исходным файлом, информацией о строке / столбце и другими вспомогательными данными, если они доступны, например, строкой документации. Обладая этой информацией, IDE может предоставить типичный &lt;em&gt;переход к определению,&lt;/em&gt; когда пользователь помещает курсор на символ или использует мышь для его выбора и перенаправляется к месту, где расположен символ.</target>
        </trans-unit>
        <trans-unit id="2c77fdad272c7f83697c8335c9696141ee28e928" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;#compiler-usage-commandminusline-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3e3ce57e9aecee15d1c10869647548dba0871c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;переключатель компилятор&lt;/a&gt; может быть использован для , чтобы изменить &lt;code&gt;nimcache&lt;/code&gt; каталог.</target>
        </trans-unit>
        <trans-unit id="146fd580f174db8b693f082a350984eb09df126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--opt:size&lt;/code&gt; flag instructs Nim to optimize code generation for small size (with the help of the C compiler), the &lt;code&gt;flto&lt;/code&gt; flags enable link-time optimization in the compiler and linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fec47225002df51e5d78ab7e3be5b902b13708f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--os:any&lt;/code&gt; target makes sure Nim does not depend on any specific operating system primitives. Your platform should support only some basic ANSI C library &lt;code&gt;stdlib&lt;/code&gt; and &lt;code&gt;stdio&lt;/code&gt; functions which should be available on almost any platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788b5d4a8f1368ab06e596c6b7b65932cae8614e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--suggest&lt;/code&gt; idetools switch performs a query about possible completion symbols at some point in the file. IDEs can easily provide an autocompletion feature where the IDE scans the current file (and related ones, if it knows about the language being edited and follows includes/imports) and when the user starts typing something a completion box with different options appears.</source>
          <target state="translated">Переключатель &lt;code&gt;--suggest&lt;/code&gt; idetools выполняет запрос о возможных символах завершения в некоторой точке файла. IDE могут легко предоставить функцию автозаполнения, при которой среда IDE сканирует текущий файл (и связанные с ним, если он знает о редактируемом языке и следует включает / импортирует), и когда пользователь начинает что-то вводить, появляется окно завершения с различными параметрами.</target>
        </trans-unit>
        <trans-unit id="984ae4024ec2641122166acc2ed459d4784e8ac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--usages&lt;/code&gt; idetools switch lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time. Again, a pure string based search and replace may catch symbols out of the scope of a function/loop.</source>
          <target state="translated">Переключатель &lt;code&gt;--usages&lt;/code&gt; idetools перечисляет все случаи использования символа в позиции. IDE могут использовать это, чтобы найти все места в файле, где используется символ, и предложить пользователю переименовать его во всех местах одновременно. Опять же, поиск и замена на основе чистой строки могут перехватывать символы, выходящие за рамки функции / цикла.</target>
        </trans-unit>
        <trans-unit id="33e88f9afb7898deea226f46d03930aa92460478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-d:useMalloc&lt;/code&gt; option configures Nim to use only the standard C memory manage primitives &lt;code&gt;malloc()&lt;/code&gt;, &lt;code&gt;free()&lt;/code&gt;, &lt;code&gt;realloc()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fbc61391e1a4b2d9263d29ca29efb51c1bb5ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">Файл &lt;code&gt;.&lt;/code&gt; (доступ к оператору поля кортежа / объекта) и операторы &lt;code&gt;[]&lt;/code&gt; (оператор индекса массива / строки / последовательности) выполняют неявные операции разыменования для ссылочных типов:</target>
        </trans-unit>
        <trans-unit id="1d69f7e7cab8a172b5bea310651ee4c1dc8772c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; if both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b687c86ec2ab86619a184b73c9bb7473dd71f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56b80171a975839d82b828a2290c7051d9d6a18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6340fe457b063ff32ecbbcad36851c6c0ef42d01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; if the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4893cd5a1f2f96e22540b712be98b5f5c896cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for ordered hash tables. Returns &lt;code&gt;true&lt;/code&gt; if both the content and the order are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097201b62a35fb9d118671fbad0be2c8082835fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for ordered hash tables. Returns true if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f0325065de9343e95b504b2a34a35889dcc865" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=copy&lt;/code&gt; proc can be marked with the &lt;code&gt;{.error.}&lt;/code&gt; pragma. Then any assignment that otherwise would lead to a copy is prevented at compile-time. This looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cd0d64a2665d2e29cb96ea56b4b61eaca69557" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C2NIM&lt;/code&gt; symbol is only recognized in &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; constructs! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; work.</source>
          <target state="translated">Символ &lt;code&gt;C2NIM&lt;/code&gt; распознается только в конструкциях &lt;code&gt;#ifdef&lt;/code&gt; и &lt;code&gt;#ifndef&lt;/code&gt; ! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; делает &lt;strong&gt;не&lt;/strong&gt; работа.</target>
        </trans-unit>
        <trans-unit id="a092497804c363adf0a9b85877d3ac5364f557a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DateTime&lt;/code&gt; type can be parsed and formatted using the different &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; procedures.</source>
          <target state="translated">Тип &lt;code&gt;DateTime&lt;/code&gt; можно анализировать и форматировать с помощью различных процедур &lt;code&gt;parse&lt;/code&gt; и &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="341a37bcfc2e71e9b4ee3ff4166502922770ca31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INFO&lt;/code&gt; within the output is the result of a format string being prepended to the message, and it will differ depending on the message's level. Format strings are &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;explained in more detail here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02713e2a0c1ca4eb80a37fb1dc1324674096936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; exception is raised if &lt;code&gt;x&lt;/code&gt; is not a &lt;code&gt;Student&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InvalidObjectConversionError&lt;/code&gt; возбуждается исключение , если &lt;code&gt;x&lt;/code&gt; не &lt;code&gt;Student&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f5c304640c208580c9c382b206a712cca543ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MonoTime&lt;/code&gt; type stores the timestamp in nanosecond resolution, but note that the actual supported time resolution differs for different systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400dc7a3bd3178893b14b3f966ead94a0da3a473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RstParseOptions&lt;/code&gt;, &lt;code&gt;FindFileHandler&lt;/code&gt; and &lt;code&gt;MsgHandler&lt;/code&gt; types are defined in the the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. &lt;code&gt;options&lt;/code&gt; selects the behaviour of the rst parser.</source>
          <target state="translated">В &lt;code&gt;RstParseOptions&lt;/code&gt; , &lt;code&gt;FindFileHandler&lt;/code&gt; и &lt;code&gt;MsgHandler&lt;/code&gt; типов определены в то &lt;a href=&quot;rst&quot;&gt;/ Docutils / первый модуль пакетов&lt;/a&gt; . &lt;code&gt;options&lt;/code&gt; выбирает поведение первого парсера.</target>
        </trans-unit>
        <trans-unit id="00aa0e83fb2fddd7efccd136ea820b487d913775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; is called a &lt;span id=&quot;generic-type-parameter_1&quot;&gt;generic type parameter&lt;/span&gt; or a &lt;span id=&quot;type-variable_1&quot;&gt;type variable&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; называется &lt;span id=&quot;generic-type-parameter_1&quot;&gt;общим параметром типа&lt;/span&gt; или &lt;span id=&quot;type-variable_1&quot;&gt;тип переменной&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="550a18c4fa132b938176c8146984c85cfbb782d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TimeInterval&lt;/code&gt; type uses calendar units, and will say that exactly one day has passed. The &lt;code&gt;Duration&lt;/code&gt; type on the other hand normalizes everything to seconds, and will therefore say that 90000 seconds has passed, which is the same as 25 hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0401867a6b1c084a80db776014298aa78e4619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UncheckedArray[T]&lt;/code&gt; type is a special kind of &lt;code&gt;array&lt;/code&gt; where its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally, an unchecked array is translated into a C array of undetermined size:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab738a00bda430d5fb380595920132610b0ad705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[: ]&lt;/code&gt; notation has been designed to mitigate this issue: &lt;code&gt;x.p[:T]&lt;/code&gt; is rewritten by the parser to &lt;code&gt;p[T](x)&lt;/code&gt;, &lt;code&gt;x.p[:T](y)&lt;/code&gt; is rewritten to &lt;code&gt;p[T](x, y)&lt;/code&gt;. Note that &lt;code&gt;[: ]&lt;/code&gt; has no AST representation, the rewrite is performed directly in the parsing step.</source>
          <target state="translated">&lt;code&gt;[: ]&lt;/code&gt; Обозначение было разработано , чтобы смягчить эту проблему: &lt;code&gt;x.p[:T]&lt;/code&gt; перезаписывается с помощью синтаксического анализа для &lt;code&gt;p[T](x)&lt;/code&gt; , &lt;code&gt;x.p[:T](y)&lt;/code&gt; переписывается &lt;code&gt;p[T](x, y)&lt;/code&gt; . Обратите внимание, что &lt;code&gt;[: ]&lt;/code&gt; не имеет представления AST, перезапись выполняется непосредственно на этапе синтаксического анализа.</target>
        </trans-unit>
        <trans-unit id="2a7a43acb1307f045b6107d24a38c825385ea414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; array access operator can be overloaded to provide &lt;span id=&quot;array-properties_1&quot;&gt;array properties&lt;/span&gt;:</source>
          <target state="translated">Оператор доступа к массиву &lt;code&gt;[]&lt;/code&gt; может быть перегружен для предоставления &lt;span id=&quot;array-properties_1&quot;&gt;свойств массива&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="914a69574ba02242343d8c757f3b0950ffcaeca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist. If you wish to avoid this behaviour you can use the &lt;code&gt;{}&lt;/code&gt; operator instead, it will simply return &lt;code&gt;nil&lt;/code&gt; when the field is not found. The &lt;code&gt;get&lt;/code&gt;-family of procedures will return a default value when called on &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;[]&lt;/code&gt; вызовет исключение, если указанное поле не существует. Если вы хотите избежать такого поведения, вы можете вместо этого использовать оператор &lt;code&gt;{}&lt;/code&gt; , он просто вернет &lt;code&gt;nil&lt;/code&gt; , если поле не будет найдено. &lt;code&gt;get&lt;/code&gt; -семейством процедур будет возвращать значение по умолчанию при вызове на &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d733185fdec6756a23f89ac0039a4d5fad38bdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; subscript operator for arrays/openarrays/sequences can be overloaded.</source>
          <target state="translated">Оператор индекса &lt;code&gt;[]&lt;/code&gt; для массивов / открытых массивов / последовательностей может быть перегружен.</target>
        </trans-unit>
        <trans-unit id="208edec1bf02d3f5453b13c50f0afe4bdd7b43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between &lt;code&gt;\Z&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; is that &lt;code&gt;\Z&lt;/code&gt; matches before a newline that is the last character of the string as well as at the end of the string, whereas &lt;code&gt;\z&lt;/code&gt; matches only at the end.</source>
          <target state="translated">Утверждения &lt;code&gt;\A&lt;/code&gt; , &lt;code&gt;\Z&lt;/code&gt; и &lt;code&gt;\z&lt;/code&gt; отличаются от традиционного циркумфлекса и доллара тем, что они всегда соответствуют только в самом начале и конце строки темы, какие бы параметры не были установлены. Разница между &lt;code&gt;\Z&lt;/code&gt; и &lt;code&gt;\z&lt;/code&gt; заключается в том, что &lt;code&gt;\Z&lt;/code&gt; соответствует перед новой строкой, которая является последним символом строки, а также в конце строки, тогда как &lt;code&gt;\z&lt;/code&gt; соответствует только в конце.</target>
        </trans-unit>
        <trans-unit id="7e817ef93305a23fbf7c9a80e38b0806e7482064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; suffix is used for release builds, &lt;code&gt;_d&lt;/code&gt; is for debug builds.</source>
          <target state="translated">&lt;code&gt;_r&lt;/code&gt; суффикс используется для версии релиза, &lt;code&gt;_d&lt;/code&gt; для отладки сборки.</target>
        </trans-unit>
        <trans-unit id="07747905d782c21340b66ec287991fea62bc1650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call may result in an error if the connecting socket disconnects during the duration of the &lt;code&gt;accept&lt;/code&gt;. If the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is specified then this error will not be raised and instead accept will be called again.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; вызов может привести к ошибке , если соединительные гнезда отключаются в течение срока действия &lt;code&gt;accept&lt;/code&gt; . Если указан флаг &lt;code&gt;SafeDisconn&lt;/code&gt; , эта ошибка не будет возникать, и вместо этого снова будет вызван accept.</target>
        </trans-unit>
        <trans-unit id="94b1ebe9dc31ad8dd9efa346619cf83e23a375a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;acyclic&lt;/code&gt; pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an &lt;strong&gt;optimization&lt;/strong&gt; for the garbage collector to not consider objects of this type as part of a cycle:</source>
          <target state="translated">&lt;code&gt;acyclic&lt;/code&gt; прагма может использоваться для типов объектов , чтобы пометить их как ациклические , даже если они кажутся циклическими. Это &lt;strong&gt;оптимизация,&lt;/strong&gt; позволяющая сборщику мусора не рассматривать объекты этого типа как часть цикла:</target>
        </trans-unit>
        <trans-unit id="266af869ff6d9dd7a44657712727c1997c3421e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;addr&lt;/code&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613f12943604467ec30c9f5050f1fcb757eb0680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;em&gt;addr&lt;/em&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="translated">Оператор &lt;code&gt;addr&lt;/code&gt; возвращает адрес l-значения. Если тип местоположения является &lt;code&gt;T&lt;/code&gt; , то &lt;em&gt;адр&lt;/em&gt; результат оператора типа &lt;code&gt;ptr T&lt;/code&gt; . Адрес всегда является неотслеживаемой ссылкой. Принятие адреса объекта, который находится в стеке, &lt;strong&gt;небезопасно&lt;/strong&gt; , поскольку указатель может существовать дольше, чем объект в стеке, и, таким образом, может ссылаться на несуществующий объект. Можно получить адрес переменных, но нельзя использовать его для переменных, объявленных с помощью операторов &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bae94e7bbf49797d2a7e82b8a0df92aa58eba2b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; procedures also offer limited support for the try statement.</source>
          <target state="translated">В &lt;code&gt;async&lt;/code&gt; процедуре также предлагает ограниченную поддержку заявления попробовать.</target>
        </trans-unit>
        <trans-unit id="50db6910ce0829d49cf640239e7c5e2012608b2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; type can only be used for return types and parameters. For return types it causes the compiler to infer the type from the routine body:</source>
          <target state="translated">Тип &lt;code&gt;auto&lt;/code&gt; можно использовать только для возвращаемых типов и параметров. Для возвращаемых типов он заставляет компилятор вывести тип из тела подпрограммы:</target>
        </trans-unit>
        <trans-unit id="c935fb430329bfdcd15706ca3da9cc7d25a5deb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;await&lt;/code&gt; call may be used in many contexts. It can be used on the right hand side of a variable declaration: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt;, in which case the variable will be set to the value of the future automatically. It can be used to await a &lt;code&gt;Future&lt;/code&gt; object, and it can be used to await a procedure returning a &lt;code&gt;Future[void]&lt;/code&gt;: &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;await&lt;/code&gt; вызов может быть использован во многих контекстах. Его можно использовать в правой части объявления переменной: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt; , и в этом случае переменной будет автоматически присвоено значение future. Его можно использовать для ожидания объекта &lt;code&gt;Future&lt;/code&gt; и его можно использовать для ожидания процедуры, возвращающей &lt;code&gt;Future[void]&lt;/code&gt; : &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3034958596b82fd279a106ed77e05a13c012c241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; statement is the counterpart to the &lt;code&gt;mixin&lt;/code&gt; statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</source>
          <target state="translated">Оператор &lt;code&gt;bind&lt;/code&gt; является аналогом оператора &lt;code&gt;mixin&lt;/code&gt; . Его можно использовать для явного объявления идентификаторов, которые должны быть привязаны на ранней стадии (т.е. идентификаторы следует искать в области действия шаблона / общего определения):</target>
        </trans-unit>
        <trans-unit id="2689f22307a3f463f4d508ab1aa3def314234321" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bitsize&lt;/code&gt; pragma is for object field members. It declares the field as a bitfield in C/C++.</source>
          <target state="translated">&lt;code&gt;bitsize&lt;/code&gt; прагма для членов поля объекта. Он объявляет поле как битовое поле в C / C ++.</target>
        </trans-unit>
        <trans-unit id="3194ada345dceb4b88200e579d663c2676d8313e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;borrow&lt;/code&gt; pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.</source>
          <target state="translated">&lt;code&gt;borrow&lt;/code&gt; Прагма делает компилятор использовать ту же реализацию , как прок , что имеет дело с базовым типом особого типа, поэтому код не генерируются.</target>
        </trans-unit>
        <trans-unit id="ecd73ebdde8c6264e667c9b2e15208469fb20c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement is used to leave a block immediately. If &lt;code&gt;symbol&lt;/code&gt; is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</source>
          <target state="translated">Оператор &lt;code&gt;break&lt;/code&gt; используется для немедленного выхода из блока. Если указан &lt;code&gt;symbol&lt;/code&gt; , это имя закрывающего блока, который нужно оставить. Если его нет, остается самый внутренний блок.</target>
        </trans-unit>
        <trans-unit id="3b17893941a66444039629e3f18a21d2a35573b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bycopy&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:</source>
          <target state="translated">&lt;code&gt;bycopy&lt;/code&gt; прагма может быть применена к объекту или кортеж типа и инструктирует компилятор передать тип по значению проков:</target>
        </trans-unit>
        <trans-unit id="2cbef8ce9bc4f27aa65fea1e9689cc4a8226d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;byref&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.</source>
          <target state="translated">&lt;code&gt;byref&lt;/code&gt; прагма может быть применена к объекту или кортеж типа и инструктирует компилятор передать тип по ссылке (скрыто указатель) к прокам.</target>
        </trans-unit>
        <trans-unit id="77887b44cd49a95c9b69ac0376b1caf0f2b195c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; constraint is particularly useful to implement a move optimization for types that have copying semantics:</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; ограничение является особенно полезным для реализации оптимизации перемещения для типов , которые имеют семантику копирования:</target>
        </trans-unit>
        <trans-unit id="596c2ddba36b2be7462234bbca37dd7763734862" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case expression&lt;/code&gt; is again very similar to the case statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a107daa0b6476fd7a15fef2edb54c6f60373d558" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement doesn't produce an l-value, so the following example won't work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fe5bba83ee973b32a89460ea4507bb32681a04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword &lt;code&gt;case&lt;/code&gt; is evaluated and if its value is in a &lt;em&gt;slicelist&lt;/em&gt; the corresponding statements (after the &lt;code&gt;of&lt;/code&gt; keyword) are executed. If the value is not in any given &lt;em&gt;slicelist&lt;/em&gt; the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part and not all possible values that &lt;code&gt;expr&lt;/code&gt; can hold occur in a &lt;code&gt;slicelist&lt;/code&gt;, a static error occurs. This holds only for expressions of ordinal types. &quot;All possible values&quot; of &lt;code&gt;expr&lt;/code&gt; are determined by &lt;code&gt;expr&lt;/code&gt;'s type. To suppress the static error an &lt;code&gt;else&lt;/code&gt; part with an empty &lt;code&gt;discard&lt;/code&gt; statement should be used.</source>
          <target state="translated">Оператор &lt;code&gt;case&lt;/code&gt; аналогичен оператору if, но представляет выбор с несколькими ветвями. Выражение после ключевого слова &lt;code&gt;case&lt;/code&gt; оценивается, и если его значение находится в &lt;em&gt;списке срезов, выполняются&lt;/em&gt; соответствующие операторы (после ключевого слова &lt;code&gt;of&lt;/code&gt; ). Если значение отсутствует в каком-либо заданном &lt;em&gt;списке слайсов,&lt;/em&gt; выполняется часть &lt;code&gt;else&lt;/code&gt; . Если в &lt;code&gt;slicelist&lt;/code&gt; нет части &lt;code&gt;else&lt;/code&gt; и не все возможные значения, которые может содержать &lt;code&gt;expr&lt;/code&gt; , возникает статическая ошибка. Это справедливо только для выражений порядковых типов. &quot;Все возможные значения&quot; &lt;code&gt;expr&lt;/code&gt; определяются &lt;code&gt;expr&lt;/code&gt; типа. Чтобы подавить статическую ошибку, следует использовать часть &lt;code&gt;else&lt;/code&gt; с пустым оператором &lt;code&gt;discard&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b51cba93a6d0694db97762461996e17d9632399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cdf&lt;/code&gt; argument does not have to be normalized, and it could contain any type of elements that can be converted to a &lt;code&gt;float&lt;/code&gt;. It must be the same length as &lt;code&gt;a&lt;/code&gt;. Each element in &lt;code&gt;cdf&lt;/code&gt; should be greater than or equal to the previous element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b931d0051b260f30fa749dc3d29290c854e0e0fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;codegenDecl&lt;/code&gt; pragma can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.</source>
          <target state="translated">&lt;code&gt;codegenDecl&lt;/code&gt; прагма может быть использована непосредственно влиять на генератор кода Nim в. Он получает строку формата, которая определяет, как переменная или процедура объявляется в сгенерированном коде.</target>
        </trans-unit>
        <trans-unit id="4a60295e92762b0a268d73c57558484ce5962353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; pragma can be used to compile and link a C/C++ source file with the project:</source>
          <target state="translated">&lt;code&gt;compile&lt;/code&gt; прагма можно использовать для компиляции и компоновки исходного файла С / С ++ с проектом:</target>
        </trans-unit>
        <trans-unit id="32f5047930630f7d43dcd54eb01e5361a0735034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used at compile time only. No code will be generated for it. Compile time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;compileTime&lt;/code&gt; прагма используются для обозначения процедурного или переменного для использования только на время компиляции. Для этого не будет создан код. Процедуры времени компиляции полезны как помощники для макросов. Начиная с версии языка 0.12.0, процедура, использующая &lt;code&gt;system.NimNode&lt;/code&gt; в своих типах параметров, неявно объявляется &lt;code&gt;compileTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b1f4b5ca84c613d5f2aec3d6366c35d47c3b092" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used only during compile-time execution. No code will be generated for it. Compile-time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71c552e9eb087bf7303d12b46f93a710977aea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;computedGoto&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_2&quot;&gt;case&lt;/span&gt; in a &lt;code&gt;while true&lt;/code&gt; statement. Syntactically it has to be used as a statement inside the loop:</source>
          <target state="translated">&lt;code&gt;computedGoto&lt;/code&gt; прагма может быть использована , чтобы сообщить компилятору , как составить Nim &lt;span id=&quot;case_2&quot;&gt;случай&lt;/span&gt; в &lt;code&gt;while true&lt;/code&gt; заявление. Синтаксически он должен использоваться как оператор внутри цикла:</target>
        </trans-unit>
        <trans-unit id="13725b1c9ade232410cac093cb3d9c609f4347af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;con&lt;/code&gt; Nimsuggest command is very similar to the suggestions command, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">Команда &lt;code&gt;con&lt;/code&gt; Nimsuggest очень похожа на команду предложений, но вместо того, чтобы использоваться после того, как пользователь ввел символ точки, она предназначена для использования после того, как пользователь ввел открывающую скобку, чтобы начать ввод параметров.</target>
        </trans-unit>
        <trans-unit id="7ddeba29bb3840db26dd678de22fc2a91b2bc365" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;code&gt;compatible string&lt;/code&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible with the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4393be6b906a951ceceb50efcf150dd498771f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;em&gt;compatible string&lt;/em&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible to the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="translated">Тип &lt;code&gt;cstring&lt;/code&gt; , означающий, что &lt;em&gt;совместимая строка,&lt;/em&gt; является собственным представлением строки для серверной части компиляции. Для бэкэнда &lt;code&gt;cstring&lt;/code&gt; тип cstring представляет собой указатель на массив символов с завершающим нулем, совместимый с типом &lt;code&gt;char*&lt;/code&gt; в Ansi C. Его основная цель заключается в простом взаимодействии с C. Операция индекса &lt;code&gt;s[i]&lt;/code&gt; означает i-й &lt;em&gt;символ.&lt;/em&gt; из &lt;code&gt;s&lt;/code&gt; ; однако проверка границ для &lt;code&gt;cstring&lt;/code&gt; не выполняется, что делает операцию индекса небезопасной.</target>
        </trans-unit>
        <trans-unit id="94b4450902f6290125300edf3507775a37d2e1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when &lt;code&gt;ev&lt;/code&gt; happens.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; являются применение определенных данных, которые будут переданы , когда &lt;code&gt;ev&lt;/code&gt; происходят.</target>
        </trans-unit>
        <trans-unit id="2420343b67cf5f6d0ad1bb94f0326b094a8ab2e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when process with &lt;code&gt;pid&lt;/code&gt; has exited.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; являются применение определенных данных, которые будут переданы , когда процесс с &lt;code&gt;pid&lt;/code&gt; завершились.</target>
        </trans-unit>
        <trans-unit id="944bc8355b34d79d86a6c6b2a6eb683062d9add5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when signal raises.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; являются применение определенных данных, которые будут переданы , когда возникает сигнал.</target>
        </trans-unit>
        <trans-unit id="39620c3fad1d30f3b1f821ad058fe01edf735504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed, when the timer is triggered.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; является применение определенных данных, которые будут переданы, когда таймер запускается.</target>
        </trans-unit>
        <trans-unit id="d408a6fed5457e4eb16aefaa58b57d0d3444464a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def&lt;/code&gt; Nimsuggest command performs a query about the definition of a specific symbol. If available, Nimsuggest will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">Команда &lt;code&gt;def&lt;/code&gt; Nimsuggest выполняет запрос об определении конкретного символа. Если доступно, Nimsuggest ответит типом, исходным файлом, информацией о строке / столбце и другими дополнительными данными, если они доступны, например, строкой документации. Обладая этой информацией, IDE может предоставить типичный &lt;em&gt;переход к определению,&lt;/em&gt; когда пользователь помещает курсор на символ или использует мышь для его выбора и перенаправляется к месту, где расположен символ.</target>
        </trans-unit>
        <trans-unit id="a06a0dec2b01f32c664435ab9f31e13949ab037d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement can also be used to create block comments as described in the &lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt; section.</source>
          <target state="translated">Оператор &lt;code&gt;discard&lt;/code&gt; также может использоваться для создания блочных комментариев, как описано в разделе &amp;laquo; &lt;a href=&quot;#comments&quot;&gt;Комментарии&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="bb3b805b82d90e245faef9fdd6f1471f89c50747" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away, and should only be used when ignoring this value is known not to cause problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b91a9fbefbe79c145dec481daa3f20cf6495d82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away.</source>
          <target state="translated">Оператор &lt;code&gt;discard&lt;/code&gt; оценивает свое выражение на предмет побочных эффектов и отбрасывает результирующее значение выражения.</target>
        </trans-unit>
        <trans-unit id="e03a7cd86091bf4978da827132b8b38c56f5a7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc&lt;/code&gt; command:</source>
          <target state="translated">Команда &lt;code&gt;doc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9ca7671dacb127635569222e277ebf2ecb0f66a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; import mechanism supports a versioning scheme:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt; механизм импорта поддерживает схему управления версиями:</target>
        </trans-unit>
        <trans-unit id="cc96537bffb0b9bad329ba2a12ee9fb4ede87416" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as an argument but also string expressions in general:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711b0f2233816783424452869696407ac31e0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as argument but also string expressions in general:</source>
          <target state="translated">В &lt;code&gt;dynlib&lt;/code&gt; Pragma поддерживает не только постоянные строки в качестве аргумента , но и строковые выражения в целом:</target>
        </trans-unit>
        <trans-unit id="0a70d199da0b3634e63e2a723bfea6e65d9ac0d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;effects&lt;/code&gt; pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the &lt;code&gt;effects&lt;/code&gt;'s position:</source>
          <target state="translated">&lt;code&gt;effects&lt;/code&gt; Прагма была разработана , чтобы помочь программисту с анализом эффектов. Это утверждение , что делает вывод компилятора все предполагаемые эффекты вплоть до &lt;code&gt;effects&lt;/code&gt; положения &amp;laquo;S:</target>
        </trans-unit>
        <trans-unit id="e6f0db3ce7d6ed0afa4949c7005ccdb2e6f1d36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. So it makes your code unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="translated">&lt;code&gt;emit&lt;/code&gt; прагма может быть использована непосредственно влияет на выходе генератора кода компилятора. Таким образом, ваш код становится непереносимым для других генераторов кода / бэкэндов. Его использование крайне не рекомендуется! Однако он может быть чрезвычайно полезен для взаимодействия с кодом &lt;span id=&quot;cplusplus_1&quot;&gt;C ++&lt;/span&gt; или &lt;span id=&quot;objective-c_1&quot;&gt;Objective C.&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="1744e04ac4bf85a742e23451c47c651184464bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. The code is then unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1c7e194942108d8e21f2868b591c724f772ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; procedure takes an &lt;code&gt;openarray&lt;/code&gt; so both arrays and sequences can be passed as parameters.</source>
          <target state="translated">Процедура &lt;code&gt;encode&lt;/code&gt; принимает &lt;code&gt;openarray&lt;/code&gt; поэтому в качестве параметров можно передавать как массивы, так и последовательности.</target>
        </trans-unit>
        <trans-unit id="0be6fe6293d87b67dc2913d9bce025978f0a0479" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; прагма также может быть использована для аннотирования символа (например , итератор или Proc). &lt;em&gt;Использование&lt;/em&gt; символа затем вызывает ошибку времени компиляции. Это особенно полезно, чтобы исключить допустимую операцию из-за перегрузки и преобразования типов:</target>
        </trans-unit>
        <trans-unit id="d75f88dde94403b5fd845aa53b72776cec145bb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a static error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f57f84a99b6715a53ef1c48e22f80406dcf7a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; Прагма используется , чтобы сделать вывод компилятора сообщение об ошибке с данным содержанием. Однако компиляция не обязательно прерывается после ошибки.</target>
        </trans-unit>
        <trans-unit id="33a44bbe47b4c8fdaa3be5e19f100223278506bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. The compilation does not necessarily abort after an error though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55b4e02a1f03c12faf1b7a6871ee52b02f9e3c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errorCode&lt;/code&gt; will determine the message, &lt;a href=&quot;#osErrorMsg,OSErrorCode&quot;&gt;osErrorMsg proc&lt;/a&gt; will be used to get this message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e20ba8aa37ee9c1d06ae011187ea2193578fda3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</source>
          <target state="translated">&lt;code&gt;experimental&lt;/code&gt; Прагма позволяет экспериментальные функции языка. В зависимости от конкретной функции это означает, что функция либо считается слишком нестабильной для стабильной версии, либо ее будущее остается неопределенным (ее можно удалить в любой момент).</target>
        </trans-unit>
        <trans-unit id="2db09f750ba40a04b2a467b51764ca184871542b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature, this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed at any time).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5fb8cbfdf80872586dff5915d97b9df4693c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exportc&lt;/code&gt; pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;exportc&lt;/code&gt; прагма обеспечивает средство для экспорта типа, переменной или процедуры для C. Перечисления и константы не могут быть экспортированы. Необязательный аргумент - это строка, содержащая идентификатор C. Если аргумент отсутствует, имя C является идентификатором Nim в &lt;em&gt;точности так, как написано&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="47b24553ecff8957d4500654446c7208e0bde7f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;let x = expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; в &lt;code&gt;let x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b98b3911e1265813479591033e8dcbc4614d140" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;result = expr&lt;/code&gt; where &lt;code&gt;result&lt;/code&gt; is the special symbol introduced by the compiler.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; в &lt;code&gt;result = expr&lt;/code&gt; , где &lt;code&gt;result&lt;/code&gt; является специальным символом , введенный компилятором.</target>
        </trans-unit>
        <trans-unit id="9a1869dad0651b77d39e69eb4e5353bc58adc7c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;return expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; в &lt;code&gt;return expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78082c4233243f41109f44b1a863ec8557ffce70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;var x = expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; в &lt;code&gt;var x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ccc224f63d4c9f00b3f6c42a04670fca5ecc5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="translated">&lt;code&gt;fatal&lt;/code&gt; Прагма используется , чтобы сделать вывод компилятора сообщение об ошибке с заданным содержанием. В отличие от прагмы &lt;code&gt;error&lt;/code&gt; , эта прагма гарантирует прерывание компиляции. Пример:</target>
        </trans-unit>
        <trans-unit id="79c9a76ff3ec29ee56bce522b023152fceaf2553" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, the compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8a977747b68cc9df3227b470584d16d2fcbb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="translated">Параметра &lt;code&gt;file&lt;/code&gt; достаточно для статического анализа, но в IDE обычно есть &lt;em&gt;несохраненные буферы, в&lt;/em&gt; которых пользователь все еще может вводить строку. В таких ситуациях IDE может сохранить текущее содержимое во временный файл, а затем использовать параметр &lt;code&gt;dirtyfile.nim&lt;/code&gt; , чтобы сообщить Nimsuggest, что &lt;code&gt;foobar.nim&lt;/code&gt; следует взять из &lt;code&gt;temporary/foobar.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9509997434d269bb0f68e1b13ca2d2239ff7894" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; parameter is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f648707faaf2c971dac2bc6f092c42cb1b59e97e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;code&gt;filename&lt;/code&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overridden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32aac42cbd8ce78d102f6016c7193cba8438ab2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;final&lt;/code&gt; pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the &lt;code&gt;object of SuperType&lt;/code&gt; syntax) or that have been marked as &lt;code&gt;inheritable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; прагма может быть использована для типа объекта , чтобы указать , что он не может быть унаследован от. Обратите внимание, что наследование доступно только для объектов, которые наследуются от существующего объекта (через &lt;code&gt;object of SuperType&lt;/code&gt; синтаксиса SuperType ) или которые были помечены как &lt;code&gt;inheritable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc6920d18d66b9005034c2f565bcac18339a40f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;generalized raw string literal&lt;/a&gt;. This has some surprising effects:</source>
          <target state="translated">&lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; синтаксис более эстетично, но она скрывает небольшой Гоча. Строка - это &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;обобщенный необработанный строковый литерал&lt;/a&gt; . Это дает несколько удивительных эффектов:</target>
        </trans-unit>
        <trans-unit id="436147e1c09214f0e309d989b28b417ff7622040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</source>
          <target state="translated">Цикл &lt;code&gt;for&lt;/code&gt; объявляет переменные итерации - их область действия достигает конца тела цикла. Типы переменных итерации определяются возвращаемым типом итератора.</target>
        </trans-unit>
        <trans-unit id="d87dfe950dbe2084f156bb115bd025bb3ef4b279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. But if you use the two variable form, the first variable will hold the index position and the second variable will hold the value. Here the &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Examples:</source>
          <target state="translated">Оператор &lt;code&gt;for&lt;/code&gt; может использоваться с одной или двумя переменными при использовании с последовательностью. Когда вы используете форму с одной переменной, переменная будет содержать значение, предоставленное последовательностью. Оператор &lt;code&gt;for&lt;/code&gt; перебирает результаты итератора &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items ()&lt;/a&gt; из &lt;a href=&quot;system&quot;&gt;системного&lt;/a&gt; модуля. Но если вы используете форму с двумя переменными, первая переменная будет содержать позицию индекса, а вторая переменная будет содержать значение. Здесь оператор &lt;code&gt;for&lt;/code&gt; перебирает результаты итератора &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pair ()&lt;/a&gt; из &lt;a href=&quot;system&quot;&gt;системного&lt;/a&gt; модуля. Примеры:</target>
        </trans-unit>
        <trans-unit id="7a5f8ddc630011123a75729ce1011d437f837fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement is a construct to loop over any element an &lt;em&gt;iterator&lt;/em&gt; provides. The example uses the built-in &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; iterator:</source>
          <target state="translated">Оператор &lt;code&gt;for&lt;/code&gt; - это конструкция для перебора любого элемента, предоставляемого &lt;em&gt;итератором&lt;/em&gt; . В примере используется встроенный итератор &lt;a href=&quot;system#countup&quot;&gt;обратного&lt;/a&gt; отсчета:</target>
        </trans-unit>
        <trans-unit id="a3b3d0f268a26cc4a0699d12f685526f47dd2e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified to be used.</source>
          <target state="translated">Оператор &lt;code&gt;from&lt;/code&gt; также может принудительно определять пространство имен для символов, тем самым делая символы доступными, но при этом их необходимо уточнять для использования.</target>
        </trans-unit>
        <trans-unit id="628bb89d094225e527b7e15df6b1eb1b878153d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;func&lt;/code&gt; keyword introduces a shortcut for a &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; proc.</source>
          <target state="translated">В &lt;code&gt;func&lt;/code&gt; ключевое слово вводит ярлык для &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; Proc.</target>
        </trans-unit>
        <trans-unit id="26dd192f9577287d3ff84d0ce8f6615a75baab8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackDefect&lt;/code&gt; if there is no value. Note that &lt;code&gt;UnpackDefect&lt;/code&gt; inherits from &lt;code&gt;system.Defect&lt;/code&gt;, and should therefore never be caught. Instead, rely on checking if the option contains a value with &lt;a href=&quot;#isSome,Option%5BT%5D&quot;&gt;isSome&lt;/a&gt; and &lt;a href=&quot;#isNone,Option%5BT%5D&quot;&gt;isNone&lt;/a&gt; procs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0083ea6cc0b6494a6dbfc51aca179ac8b3c56af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackError&lt;/code&gt; if there is no value. There is another option for obtaining the value: &lt;code&gt;unsafeGet&lt;/code&gt;, but you must only use it when you are absolutely sure the value is present (e.g. after checking &lt;code&gt;isSome&lt;/code&gt;). If you do not care about the tiny overhead that &lt;code&gt;get&lt;/code&gt; causes, you should simply never use &lt;code&gt;unsafeGet&lt;/code&gt;.</source>
          <target state="translated">Операция &lt;code&gt;get&lt;/code&gt; , показанная выше, возвращает базовое значение или вызывает &lt;code&gt;UnpackError&lt;/code&gt; если значение отсутствует. Существует еще один вариант получения значения: &lt;code&gt;unsafeGet&lt;/code&gt; , но вы должны использовать его только тогда, когда вы абсолютно уверены, что значение присутствует (например, после проверки &lt;code&gt;isSome&lt;/code&gt; ). Если вы не заботитесь о крошечных накладных расходов , которые &lt;code&gt;get&lt;/code&gt; причины, вы должны просто не использовать &lt;code&gt;unsafeGet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79cc36593cae272a27774d93dd0f0cb520bc5bac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt;-family helpers also accept an additional parameter which allow you to fallback to a default value should the key's values be &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b262a4793a87dcd3423e3de392c1373594c7a80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; прагма может применяться к переменной в прок , чтобы указать компилятору , чтобы сохранить его в глобальном месте и инициализировать ее один раз при запуске программы.</target>
        </trans-unit>
        <trans-unit id="f3137d8ded88666f115e1ad63a5e346dd2aff08c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;guard&lt;/code&gt; annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</source>
          <target state="translated">&lt;code&gt;guard&lt;/code&gt; аннотаций также может быть использован для защиты полей внутри объекта. Тогда охранник должен быть другим полем в том же объекте или глобальной переменной.</target>
        </trans-unit>
        <trans-unit id="cecf91584150e32f7e14d844ab583125e19b5fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string constant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66122e0d67f678d2cd3350768f39275164af1b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string contant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; Pragma всегда ожидает постоянную строку. Строка contant содержит файл заголовка: Как обычно для C, файл заголовка системы заключен в угловые скобки: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Если угловые скобки не указаны, Nim заключает файл заголовка в &lt;code&gt;&quot;&quot;&lt;/code&gt; в сгенерированном коде C.</target>
        </trans-unit>
        <trans-unit id="0b679c76e7a9ed62a93f723575cfccef75d26424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; Pragma очень похож на &lt;code&gt;noDecl&lt;/code&gt; прагму: Он может быть применен к почти любому символу и указует , что он не должен быть объявлен и вместо того, чтобы сгенерированный код должен содержать &lt;code&gt;#include&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b72401b61f0f4d4b74ca7cd37fb890761035c656" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead, the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b64dbd148a29167eb5bce55224c93f8272a383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;heapqueue&lt;/code&gt; module implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;heap data structure&lt;/a&gt; that can be used as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Priority_queue&quot;&gt;priority queue&lt;/a&gt;. Heaps are arrays for which &lt;code&gt;a[k] &amp;lt;= a[2*k+1]&lt;/code&gt; and &lt;code&gt;a[k] &amp;lt;= a[2*k+2]&lt;/code&gt; for all &lt;code&gt;k&lt;/code&gt;, counting elements from 0. The interesting property of a heap is that &lt;code&gt;a[0]&lt;/code&gt; is always its smallest element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9ed3be3ca0ab53ad4c051a00d1adf22ed5686a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hint&lt;/code&gt; pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</source>
          <target state="translated">&lt;code&gt;hint&lt;/code&gt; прагма используется , чтобы сделать намек сообщение вывода компилятора с данным содержанием. Компиляция продолжается после подсказки.</target>
        </trans-unit>
        <trans-unit id="8ef0beadd43d9c18e85d2fbeaa068bda72ec3066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;code&gt;id&lt;/code&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes,string&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;https://nim-lang.org/docs/docgen.html#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebd6b843b12e6bfab912253ce8368ae735e6323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is a simple way to make a branch in the control flow: The expression after the keyword &lt;code&gt;if&lt;/code&gt; is evaluated, if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. Otherwise the expression after the &lt;code&gt;elif&lt;/code&gt; is evaluated (if there is an &lt;code&gt;elif&lt;/code&gt; branch), if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. This goes on until the last &lt;code&gt;elif&lt;/code&gt;. If all conditions fail, the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part, execution continues with the next statement.</source>
          <target state="translated">Оператор &lt;code&gt;if&lt;/code&gt; - это простой способ создать ветвь в потоке управления: выполняется выражение после ключевого слова &lt;code&gt;if&lt;/code&gt; , если оно истинно , выполняются соответствующие операторы после &lt;code&gt;:&lt;/code&gt; . В противном случае вычисляется выражение после &lt;code&gt;elif&lt;/code&gt; (если есть ветвь &lt;code&gt;elif&lt;/code&gt; ), если оно истинно , выполняются соответствующие операторы после &lt;code&gt;:&lt;/code&gt; . Так продолжается до последнего &lt;code&gt;elif&lt;/code&gt; . Если все условия не выполняются, выполняется часть &lt;code&gt;else&lt;/code&gt; . Если части &lt;code&gt;else&lt;/code&gt; нет , выполнение продолжается со следующего оператора.</target>
        </trans-unit>
        <trans-unit id="0003d13f41be8193835c63a646af8124f68cb7cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; statement is only allowed at the top level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9a59bb3838f7721c56dcd3c0f527061c3d17e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;importc&lt;/code&gt; pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;importc&lt;/code&gt; прагма обеспечивает средство для импорта процедурный или переменную из C. Необязательный аргумент является строкой , содержащей идентификатор C. Если аргумент отсутствует, имя C является идентификатором Nim в &lt;em&gt;точности так, как написано&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="eac30aaa2478fce31be57ea79b6cc59d42ac456c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement can be used outside of the top level, as such:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4417d81051ba2fda59de7fd41e5159b1404cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement does something fundamentally different than importing a module: it merely includes the contents of a file. The &lt;code&gt;include&lt;/code&gt; statement is useful to split up a large module into several files:</source>
          <target state="translated">Оператор &lt;code&gt;include&lt;/code&gt; выполняет нечто принципиально иное, чем импорт модуля: он просто включает содержимое файла. Оператор &lt;code&gt;include&lt;/code&gt; полезен для разделения большого модуля на несколько файлов:</target>
        </trans-unit>
        <trans-unit id="0f94857a75c9bc1979ffd9f951809e759cc263fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incompleteStruct&lt;/code&gt; pragma tells the compiler to not use the underlying C &lt;code&gt;struct&lt;/code&gt; in a &lt;code&gt;sizeof&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;incompleteStruct&lt;/code&gt; прагма сообщает компилятору , чтобы не использовать основной C - &lt;code&gt;struct&lt;/code&gt; в &lt;code&gt;sizeof&lt;/code&gt; выражении:</target>
        </trans-unit>
        <trans-unit id="7544df806eff4f7313cff76422ab23377014cb76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; proc can be called with any number of arguments, i.e. &lt;code&gt;initTable(initialSize)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf743bc2a57bf16453dba05ab29e67acdfb89a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</source>
          <target state="translated">В &lt;code&gt;inject&lt;/code&gt; и &lt;code&gt;gensym&lt;/code&gt; псевдокомментарии вторые аннотаций класса; у них нет семантики вне определения шаблона, и их нельзя абстрагировать:</target>
        </trans-unit>
        <trans-unit id="c48a2765e8c42b7c535b1be5ad5b35ddb4c24b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;injectStmt&lt;/code&gt; pragma can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:</source>
          <target state="translated">&lt;code&gt;injectStmt&lt;/code&gt; прагма может использоваться , чтобы ввести заявление перед каждым другим утверждением в текущем модуле. Его следует использовать только для отладки:</target>
        </trans-unit>
        <trans-unit id="cc7da59a3ce1987099582089c22c83123acc3457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient &lt;code&gt;int&lt;/code&gt; set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633eb4e1412a3b13001ffe18b5db908a368027e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient int set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;. &lt;strong&gt;Note&lt;/strong&gt;: Since Nim currently does not allow the assignment operator to be overloaded, &lt;code&gt;=&lt;/code&gt; for int sets performs some rather meaningless shallow copy; use &lt;code&gt;assign&lt;/code&gt; to get a deep copy.</source>
          <target state="translated">Модуль &lt;code&gt;intsets&lt;/code&gt; реализует эффективный набор int, реализованный как &lt;span id=&quot;sparse-bit-set_1&quot;&gt;разреженный набор бит&lt;/span&gt; . &lt;strong&gt;Примечание&lt;/strong&gt; . Поскольку в настоящее время Nim не позволяет перегружать оператор присваивания, &lt;code&gt;=&lt;/code&gt; для наборов int выполняет довольно бессмысленное поверхностное копирование; используйте &lt;code&gt;assign&lt;/code&gt; , чтобы получить полную копию.</target>
        </trans-unit>
        <trans-unit id="ac6a8f8a9038fd001e9bcf25c7590eeedb8367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int{lit}&lt;/code&gt; parameter pattern matches against an expression of type &lt;code&gt;int&lt;/code&gt;, but only if it's a literal.</source>
          <target state="translated">В &lt;code&gt;int{lit}&lt;/code&gt; шаблон параметров матчи против выражения типа &lt;code&gt;int&lt;/code&gt; , но только если это буквальное.</target>
        </trans-unit>
        <trans-unit id="dbcf608e730943249674bddace7178d1650d4c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator checks for type equivalence at compile time. It is therefore very useful for type specialization within generic code:</source>
          <target state="translated">Оператор &lt;code&gt;is&lt;/code&gt; проверяет эквивалентность типов во время компиляции. Поэтому это очень полезно для специализации типов в универсальном коде:</target>
        </trans-unit>
        <trans-unit id="037a846ce64ff72c6c1886c38f998c5c082548cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator is evaluated during semantic analysis to check for type equivalence. It is therefore very useful for type specialization within generic code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab0e112ac9b29f05be238eca0977fc170691191" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; type is always of the calling convention &lt;code&gt;closure&lt;/code&gt; implicitly; the following example shows how to use iterators to implement a &lt;span id=&quot;collaborative-tasking_1&quot;&gt;collaborative tasking&lt;/span&gt; system:</source>
          <target state="translated">Тип &lt;code&gt;iterator&lt;/code&gt; всегда неявно соответствует &lt;code&gt;closure&lt;/code&gt; соглашения о вызовах ; В следующем примере показано, как использовать итераторы для реализации системы &lt;span id=&quot;collaborative-tasking_1&quot;&gt;совместной работы&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="8c51c8609edeb22ed76fcbde9b258a50e77c8157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc0&lt;/code&gt; command:</source>
          <target state="translated">Команда &lt;code&gt;jsondoc0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d07ffe6edb5db09dbe2b7e3001f8af54d7978127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc&lt;/code&gt; command:</source>
          <target state="translated">Команда &lt;code&gt;jsondoc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f86e1a24462b67c7426c7b0acfee59f9a241fd55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;koch&lt;/code&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; documentation.</source>
          <target state="translated">Программа &lt;code&gt;koch&lt;/code&gt; - это сценарий обслуживания Нима. Это замена для сценариев make и оболочки с тем преимуществом, что он намного более переносим. Более подробную информацию о его опциях можно найти в документации &lt;a href=&quot;koch&quot;&gt;коч&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b2c762fac40a5608e0b7e7de49ebe36c6b608ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; statement works like the &lt;code&gt;var&lt;/code&gt; statement but the declared symbols are &lt;em&gt;single assignment&lt;/em&gt; variables: After the initialization their value cannot change:</source>
          <target state="translated">Оператор &lt;code&gt;let&lt;/code&gt; работает аналогично оператору &lt;code&gt;var&lt;/code&gt; , но объявленные символы являются &lt;em&gt;одиночными&lt;/em&gt; переменными &lt;em&gt;присваивания&lt;/em&gt; : после инициализации их значение не может измениться:</target>
        </trans-unit>
        <trans-unit id="2e8bf1e1e37d7a0035195dab30ef109a27650d29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; прагма может использоваться повлиять на информацию строки аннотированном заявления , как показано в стеке цепочек вызовов:</target>
        </trans-unit>
        <trans-unit id="8afa9eeaecb1dea09c8ad531f545e95028e51642" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement, as seen in stack backtraces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915701467dacb0f53184563a8354aa1f016b1417" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineDir&lt;/code&gt; option can be turned on or off. If turned on the generated C code contains &lt;code&gt;#line&lt;/code&gt; directives. This may be helpful for debugging with GDB.</source>
          <target state="translated">&lt;code&gt;lineDir&lt;/code&gt; опция может быть включена или выключена. Если он включен, сгенерированный код C содержит директивы &lt;code&gt;#line&lt;/code&gt; . Это может быть полезно для отладки с помощью GDB.</target>
        </trans-unit>
        <trans-unit id="8862192e862105c15d55393354d8d5087e6d99c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineInfoFrom&lt;/code&gt; parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.</source>
          <target state="translated">Параметр &lt;code&gt;lineInfoFrom&lt;/code&gt; используется для информации о строке при сбое созданного кода. Вы должны убедиться, что он установлен на узел, который вы преобразовываете.</target>
        </trans-unit>
        <trans-unit id="947951cac85d38c8083826636d24bf5d2f716054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineTrace&lt;/code&gt; option implies the &lt;code&gt;stackTrace&lt;/code&gt; option. If turned on, the generated C contains code to ensure that proper stack traces with line number information are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">Параметр &lt;code&gt;lineTrace&lt;/code&gt; подразумевает параметр &lt;code&gt;stackTrace&lt;/code&gt; . Если этот параметр включен, сгенерированный C содержит код, обеспечивающий правильную трассировку стека с информацией о номере строки, если программа дает сбой или возникает неперехваченное исключение.</target>
        </trans-unit>
        <trans-unit id="d980b3bcc3269067f6e576157b155e2551065156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_1&quot;&gt;case&lt;/span&gt; statement. Syntactically it has to be used as a statement:</source>
          <target state="translated">&lt;code&gt;linearScanEnd&lt;/code&gt; прагма может быть использована , чтобы сообщить компилятору , как составить Nim &lt;span id=&quot;case_1&quot;&gt;дела&lt;/span&gt; заявления. Синтаксически это должно использоваться как утверждение:</target>
        </trans-unit>
        <trans-unit id="81348c7397c56af7cb77770121f3f2ce241cb992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole &lt;code&gt;case&lt;/code&gt; statement, the whole &lt;code&gt;case&lt;/code&gt; statement uses linear scanning.</source>
          <target state="translated">&lt;code&gt;linearScanEnd&lt;/code&gt; прагма должна быть введена в последнюю ветвь , которая должна быть испытана в соответствии с помощью линейного сканирования. Если поместить в последнюю ветвь всего оператора &lt;code&gt;case&lt;/code&gt; , весь оператор &lt;code&gt;case&lt;/code&gt; использует линейное сканирование.</target>
        </trans-unit>
        <trans-unit id="661a3797ceadcd6fa8b44a4a0a3e4223544ab7e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; pragma can be used to link an additional file with the project:</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; прагма может использоваться , чтобы связать дополнительный файл с проектом:</target>
        </trans-unit>
        <trans-unit id="e60060003730f2db3edee6726ebcb73673ad9ecf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;localPassc&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler, but only for the C/C++ file that is produced from the Nim module the pragma resides in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23f1774076a702902344c093a45ba7378aef4c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma can also take the special value &lt;code&gt;&quot;unknown&quot;&lt;/code&gt;. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the &lt;code&gt;base&lt;/code&gt; case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling &lt;code&gt;g.testMethod&lt;/code&gt; cannot be inferred statically, leading to compiler warnings. By using &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt;, the base method can be marked explicitly as having unknown lock level as well:</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; Прагма также может принять специальное значение &lt;code&gt;&quot;unknown&quot;&lt;/code&gt; . Это полезно в контексте диспетчеризации динамических методов. В следующем примере компилятор может вывести уровень блокировки 0 для &lt;code&gt;base&lt;/code&gt; случая. Однако один из перегруженных методов вызывает procvar, потенциально блокирующий. Таким образом, уровень блокировки вызова &lt;code&gt;g.testMethod&lt;/code&gt; не может быть определен статически, что приводит к предупреждениям компилятора. Используя &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt; , Базовый метод также может быть явно отмечен как имеющий неизвестный уровень блокировки:</target>
        </trans-unit>
        <trans-unit id="d06a4c92dabcb638ee9265fba0f2704858746025" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma takes a list of lock expressions &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; in order to support &lt;em&gt;multi lock&lt;/em&gt; statements. Why these are essential is explained in the &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;lock levels&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; Прагма принимает список блокировки выражений &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; в целях поддержки &lt;em&gt;мульти блокировки&lt;/em&gt; заявлений. Почему это важно, объясняется в разделе &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;уровней блокировки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aae9f3366ca8ab53657f45e7a28b3801e912c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</source>
          <target state="translated">Раздел &lt;code&gt;locks&lt;/code&gt; намеренно выглядит некрасиво, потому что он не имеет семантики времени выполнения и не должен использоваться напрямую! Его следует использовать только в шаблонах, которые также реализуют некоторую форму блокировки во время выполнения:</target>
        </trans-unit>
        <trans-unit id="9be3a7206cb8c2fa20f67cb405592a8272cb3e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; can can modify &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;pairExists&lt;/code&gt; values to change the mapping of the key or delete it from the table. When adding a value, make sure to set &lt;code&gt;pairExists&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; along with modifying the &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; может может изменить &lt;code&gt;val&lt;/code&gt; и &lt;code&gt;pairExists&lt;/code&gt; значения , чтобы изменить отображение ключа или удалить его из таблицы. При добавлении значения, убедитесь , что установил &lt;code&gt;pairExists&lt;/code&gt; в &lt;code&gt;true&lt;/code&gt; наряду с модификацией &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7db9956ef94890909f647902398c88b4235d0a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; takes 3 arguments:</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; принимает 3 аргумента:</target>
        </trans-unit>
        <trans-unit id="e2aecc3d04e1ba9c4da69fcea31f814e198a879c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. &lt;code&gt;resString&lt;/code&gt; will be truncated after that.</source>
          <target state="translated">Параметр &lt;code&gt;maxLength&lt;/code&gt; определяет максимальное количество символов, которое можно прочитать. &lt;code&gt;resString&lt;/code&gt; этого resString будет обрезана .</target>
        </trans-unit>
        <trans-unit id="5170e2edf536777dba0d2b9cf8223c8b3f59eaa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. The result is truncated after that.</source>
          <target state="translated">Параметр &lt;code&gt;maxLength&lt;/code&gt; определяет максимальное количество символов, которое можно прочитать. После этого результат обрезается.</target>
        </trans-unit>
        <trans-unit id="12a39cee8d46eadd14d3ca1ab6f3b43021968677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msgHandler&lt;/code&gt; is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass &lt;code&gt;nil&lt;/code&gt;, a default message handler will be used which writes the messages to the standard output.</source>
          <target state="translated">&lt;code&gt;msgHandler&lt;/code&gt; является процедура используется для сообщения об ошибках пользователя. Он будет вызываться с именем файла, строкой, столбцом и типом любой ошибки, обнаруженной во время синтаксического анализа. Если вы передадите &lt;code&gt;nil&lt;/code&gt; , будет использоваться обработчик сообщений по умолчанию, который записывает сообщения в стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="65292252dedeb03bdd4cf17027914a7ac8f246a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="translated">В &lt;code&gt;nim&lt;/code&gt; файлы исполняемых процессы конфигурации в следующих каталогах (в этом порядке, а позже файлы перезаписывать предыдущие настройки):</target>
        </trans-unit>
        <trans-unit id="d1de4c15a5d4322e279af56e0f42cc33a1504497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes the &lt;code&gt;.nims&lt;/code&gt; configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b963c0905e1160ea544d741ffdbf201c3a7bf09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nimDisableCertificateValidation&lt;/code&gt; define overrides verifyMode and disables certificate verification globally!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2224eba7d666dacb73dc23680ccb160ec95313ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nnkElifBranch&lt;/code&gt; and &lt;code&gt;nnkElse&lt;/code&gt; parts may be missing.</source>
          <target state="translated">В &lt;code&gt;nnkElifBranch&lt;/code&gt; и &lt;code&gt;nnkElse&lt;/code&gt; часть может отсутствовать.</target>
        </trans-unit>
        <trans-unit id="32f208ade320ac5ce50ba89abb7bedd7b3b6454d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noDecl&lt;/code&gt; pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For example:</source>
          <target state="translated">&lt;code&gt;noDecl&lt;/code&gt; прагма может быть применена к почти любому символу (переменный, Proc, типа и т.д.) и иногда полезно для взаимодействия с C: Это говорит Nim , что он не должен генерировать заявление для символа в коде C. Например:</target>
        </trans-unit>
        <trans-unit id="5ad2ee4458517f6e547cf12f840abec614d3d433" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;out T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a70425379e8b6e57d7dbe189a2d199ed50d30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="translated">&lt;code&gt;noSideEffect&lt;/code&gt; прагма используются для обозначения процедурного / итератор , не имеет никаких побочных эффектов. Это означает, что процесс / итератор изменяет только те местоположения, которые доступны по его параметрам, а возвращаемое значение зависит только от аргументов. Если ни один из его параметров не имеют тип &lt;code&gt;var T&lt;/code&gt; или &lt;code&gt;ref T&lt;/code&gt; или &lt;code&gt;ptr T&lt;/code&gt; этого средства нет места не изменяются. Статическая ошибка отмечать процесс / итератор как не имеющий побочного эффекта, если компилятор не может это проверить.</target>
        </trans-unit>
        <trans-unit id="2f748ada5af7bcb027fed012bb10126b2e9ffdf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; pragma is used to mark a proc that never returns.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; Прагма используется для обозначения процедурного , что никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="85bb1f5f512bb1750c1a4d1ebcd22d1e74a421af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; keyword is always a unary operator, &lt;code&gt;a not b&lt;/code&gt; is parsed as &lt;code&gt;a(not b)&lt;/code&gt;, not as &lt;code&gt;(a) not (b)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1eff353ff0898aff7ebac46828c56901af2121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</source>
          <target state="translated">Параметр &lt;code&gt;operation&lt;/code&gt; должен быть выражением, которое использует переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; для каждого шага свертки. Поскольку это левая складка, для неассоциативных бинарных операций, таких как вычитание, подумайте, что последовательность чисел 1, 2 и 3 будет заключена в круглые скобки как (((1) - 2) - 3).</target>
        </trans-unit>
        <trans-unit id="cf888b143d2f4149c1d7d438f9d55fbfcce18b54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</source>
          <target state="translated">Параметр &lt;code&gt;operation&lt;/code&gt; должен быть выражением, которое использует переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; для каждого шага свертки. Поскольку это правая складка, для неассоциативных бинарных операций, таких как вычитание, подумайте, что последовательность чисел 1, 2 и 3 будет заключена в скобки как (1 - (2 - (3))).</target>
        </trans-unit>
        <trans-unit id="92b676ebe4f3f6e80af4461a2389327433cc03e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. The &lt;code&gt;first&lt;/code&gt; parameter is the start value (the first &lt;code&gt;a&lt;/code&gt;) and therefor defines the type of the result.</source>
          <target state="translated">Параметр &lt;code&gt;operation&lt;/code&gt; должен быть выражением, которое использует переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; для каждого шага свертки. &lt;code&gt;first&lt;/code&gt; параметр является начальным значением (первое &lt;code&gt;a&lt;/code&gt; ) , и для этого определяет тип результата.</target>
        </trans-unit>
        <trans-unit id="e2887106b7df244891547998dfdb11bc056b419b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optPeg&lt;/code&gt; template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global &lt;code&gt;gl&lt;/code&gt; which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</source>
          <target state="translated">&lt;code&gt;optPeg&lt;/code&gt; шаблон оптимизирует случай привязки конструктора с строковым литералом, так что образец будет проанализирован только один раз при запуске программы и сохраняется в глобальном &lt;code&gt;gl&lt;/code&gt; который затем повторно использовать. Эта оптимизация называется подъемом, потому что она сопоставима с классическим подъемом петли.</target>
        </trans-unit>
        <trans-unit id="79bf8ca22f95d3471dae0c1cf77a6259078a951a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; прагма может быть применена к любому &lt;code&gt;object&lt;/code&gt; типу. Это гарантирует, что поля объекта будут упакованы в памяти один за другим. Полезно хранить пакеты или сообщения из / в сетевые или аппаратные драйверы, а также для взаимодействия с C. Объединение упакованной прагмы с наследованием не определено, и ее не следует использовать с памятью GC (ref).</target>
        </trans-unit>
        <trans-unit id="b1e59de77052cfdd0f7bf673a9989ac1cea0fa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; массив должен начинаться с типом возвращаемого прока, а затем списком IdentDefs, устанавливающим Params.</target>
        </trans-unit>
        <trans-unit id="899485653059d1572f2f010810cdc7109336ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseJson&lt;/code&gt; procedure takes a string containing JSON and returns a &lt;code&gt;JsonNode&lt;/code&gt; object. This is an object variant and it is either a &lt;code&gt;JObject&lt;/code&gt;, &lt;code&gt;JArray&lt;/code&gt;, &lt;code&gt;JString&lt;/code&gt;, &lt;code&gt;JInt&lt;/code&gt;, &lt;code&gt;JFloat&lt;/code&gt;, &lt;code&gt;JBool&lt;/code&gt; or &lt;code&gt;JNull&lt;/code&gt;. You check the kind of this object variant by using the &lt;code&gt;kind&lt;/code&gt; accessor.</source>
          <target state="translated">Процедура &lt;code&gt;parseJson&lt;/code&gt; принимает строку, содержащую JSON, и возвращает объект &lt;code&gt;JsonNode&lt;/code&gt; . Это вариант объекта, и это либо &lt;code&gt;JObject&lt;/code&gt; , &lt;code&gt;JArray&lt;/code&gt; , &lt;code&gt;JString&lt;/code&gt; , &lt;code&gt;JInt&lt;/code&gt; , &lt;code&gt;JFloat&lt;/code&gt; , &lt;code&gt;JBool&lt;/code&gt; или &lt;code&gt;JNull&lt;/code&gt; . Вы проверяете тип этого варианта объекта, используя метод доступа &lt;code&gt;kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab71cca6be976e0916e48654c757813ac229024a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7500e4fe275240ec3e962a88617dbb075a1767f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.This is an example of how a configuration file may look like:</source>
          <target state="translated">Модуль &lt;code&gt;parsecfg&lt;/code&gt; реализует высокопроизводительный анализатор файла конфигурации. Синтаксис файла конфигурации аналогичен формату Windows &lt;code&gt;.ini&lt;/code&gt; , но гораздо более мощный, поскольку он не является анализатором на основе строк. Строковые литералы, необработанные строковые литералы и строковые литералы в тройных кавычках поддерживаются, как и в языке программирования Nim. Это пример того, как может выглядеть файл конфигурации:</target>
        </trans-unit>
        <trans-unit id="efd64c6ce1f02ecfbb0ad808048c92aad34275ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsesql&lt;/code&gt; module implements a high performance SQL file parser. It parses PostgreSQL syntax and the SQL ANSI standard.</source>
          <target state="translated">Модуль &lt;code&gt;parsesql&lt;/code&gt; реализует высокопроизводительный анализатор файлов SQL. Он анализирует синтаксис PostgreSQL и стандарт SQL ANSI.</target>
        </trans-unit>
        <trans-unit id="56d6940c534b2d5fc6c85df625e69961eee4fb6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passC&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like you would using the commandline switch &lt;code&gt;--passC&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passC&lt;/code&gt; прагма может быть использована для передачи дополнительных параметров компилятора C , как вы бы с помощью командной строки коммутатора &lt;code&gt;--passC&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a226dc1945e0a231e4a09243e7cbc55428953d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like one would be using the command-line switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c8b7f23a56b9ff37dc65de5153a5e24bf44f34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like you would using the commandline switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passL&lt;/code&gt; прагма может быть использована для передачи дополнительных параметров линкера , как вы бы с помощью командной строки коммутатора &lt;code&gt;--passL&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3d5b5550832a02a497dde295f605b34a81b96e37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passc&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like one would using the command-line switch &lt;code&gt;--passc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f85014800afa36f3b960f11ad58d019170e999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function will not, on its own, return any events. Instead an appropriate &lt;code&gt;Future&lt;/code&gt; object will be completed. A &lt;code&gt;Future&lt;/code&gt; is a type which holds a value which is not yet available, but which &lt;em&gt;may&lt;/em&gt; be available in the future. You can check whether a future is finished by using the &lt;code&gt;finished&lt;/code&gt; function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the &lt;code&gt;failed&lt;/code&gt; function.</source>
          <target state="translated">Функция &lt;code&gt;poll&lt;/code&gt; сама по себе не возвращает никаких событий. Вместо этого будет завершен соответствующий объект &lt;code&gt;Future&lt;/code&gt; . &lt;code&gt;Future&lt;/code&gt; является типом , который имеет значение , которое не является еще доступно, но которые &lt;em&gt;могут&lt;/em&gt; быть доступны в будущем. Вы можете проверить , является ли будущим закончено, используя &lt;code&gt;finished&lt;/code&gt; функцию. Когда фьючерс завершен, это означает, что либо значение, которое оно хранит, теперь доступно, либо вместо этого содержится ошибка. Последняя ситуация возникает, когда операция завершения будущего завершается неудачно с исключением. Вы можете различить две ситуации с &lt;code&gt;failed&lt;/code&gt; функцией.</target>
        </trans-unit>
        <trans-unit id="27a7881313cd70143e77c7b574a9601952ffdf78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt; прагма может использоваться для пользовательских объявить определенные прагмы. Это полезно, потому что шаблоны и макросы Nim не влияют на прагмы. Прагмы, определяемые пользователем, находятся в другой области модуля, чем все другие символы. Их нельзя импортировать из модуля.</target>
        </trans-unit>
        <trans-unit id="51885e189673cb5c6386d2e95a8b73481f631054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user-defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User-defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c3772886433492aac2ca1b4e999a7c892e1968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc will open the given filename and return a &lt;code&gt;Table&lt;/code&gt; from the &lt;a href=&quot;tables&quot;&gt;tables module&lt;/a&gt;. The parsing of the file is done (without much care for handling invalid data or corner cases) using the &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines proc from the strutils module&lt;/a&gt;. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</source>
          <target state="translated">Процесс &lt;code&gt;readCfgAtRuntime&lt;/code&gt; откроет заданное имя файла и вернет &lt;code&gt;Table&lt;/code&gt; из &lt;a href=&quot;tables&quot;&gt;модуля таблиц&lt;/a&gt; . Анализ файла выполняется (без особого внимания к недопустимым данным или угловым случаям) с использованием процедуры &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines из модуля Strutils&lt;/a&gt; . Есть много вещей, которые могут потерпеть неудачу; помните, цель состоит в том, чтобы объяснить, как выполнить этот запуск во время компиляции, а не как правильно реализовать схему DRM.</target>
        </trans-unit>
        <trans-unit id="a044506e0603eea131639eb9376dd6b5cddf2eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;register&lt;/code&gt;, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; прагма только для переменных. Он объявляет переменную как &lt;code&gt;register&lt;/code&gt; , давая компилятору подсказку, что переменная должна быть помещена в аппаратный регистр для более быстрого доступа. Компиляторы C обычно игнорируют это, и по уважительным причинам: часто они и без этого справляются лучше.</target>
        </trans-unit>
        <trans-unit id="a0902ad3f56f0d7c35a0065f78a040f1cd74c2f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; symbol of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e697c97568aeba97089d02acbf3eabde37e8d56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialised with the type's default value. Note that referential data types will be &lt;code&gt;nil&lt;/code&gt; at the start of the procedure, and thus may require manual initialisation.</source>
          <target state="translated">&lt;code&gt;result&lt;/code&gt; переменный уже неявно объявляются в начале функции, так как объявить его снова &amp;laquo;результат вара&amp;raquo;, например, будет тень его с обычным переменным с тем же именем. Переменная результата также уже инициализирована значением типа по умолчанию. Обратите внимание, что ссылочные типы данных будут &lt;code&gt;nil&lt;/code&gt; в начале процедуры, и поэтому может потребоваться ручная инициализация.</target>
        </trans-unit>
        <trans-unit id="425fcae39b623db5726296d9c803046886d46240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement ends the execution of the current procedure. It is only allowed in procedures. If there is an &lt;code&gt;expr&lt;/code&gt;, this is syntactic sugar for:</source>
          <target state="translated">Оператор &lt;code&gt;return&lt;/code&gt; завершает выполнение текущей процедуры. Это разрешено только в процедурах. Если есть &lt;code&gt;expr&lt;/code&gt; , это синтаксический сахар для:</target>
        </trans-unit>
        <trans-unit id="22be64c3baaca8bed87e9a59bcd86debbab1977d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rst2tex&lt;/code&gt; command is invoked identically to &lt;code&gt;rst2html&lt;/code&gt;, but outputs a .tex file instead of .html.</source>
          <target state="translated">Команда &lt;code&gt;rst2tex&lt;/code&gt; вызывается так же, как и &lt;code&gt;rst2html&lt;/code&gt; , но выводит файл .tex вместо .html.</target>
        </trans-unit>
        <trans-unit id="ac1c0e0c744f03f7d86ed6c0e6ccc56589352680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scanp&lt;/code&gt; maps the grammar code into Nim code that performs the parsing. The parsing is performed with the help of 3 helper templates that that can be implemented for a custom type.</source>
          <target state="translated">&lt;code&gt;scanp&lt;/code&gt; отображает грамматику код в Nim код , который выполняет синтаксический анализ. Синтаксический анализ выполняется с помощью 3 вспомогательных шаблонов, которые можно реализовать для настраиваемого типа.</target>
        </trans-unit>
        <trans-unit id="5a60747c9b966d14e1f72bd788f5ee6cfb1876ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; operation will block until number of unprocessed items is less than &lt;code&gt;maxItems&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5376cae9b12713da42c8c136f625062e3841b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sep&lt;/code&gt; (default: &lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt;) is used for the path normalizations, this can be useful to ensure the relative path only contains &lt;code&gt;'/'&lt;/code&gt; so that it can be used for URL constructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23546f4b46dd4608db4ddbed2703e5c7ee24bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sets&lt;/code&gt; module implements an efficient &lt;span id=&quot;hash-set_1&quot;&gt;hash set&lt;/span&gt; and ordered hash set.</source>
          <target state="translated">Модуль &lt;code&gt;sets&lt;/code&gt; реализует эффективный &lt;span id=&quot;hash-set_1&quot;&gt;набор хешей&lt;/span&gt; и упорядоченный набор хешей.</target>
        </trans-unit>
        <trans-unit id="e59337587ab0c8780c2022ab5a55fc7fbccf5729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shallow&lt;/code&gt; pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</source>
          <target state="translated">&lt;code&gt;shallow&lt;/code&gt; Прагма влияет на семантику типа: Компилятор разрешается сделать неполную копию. Это может вызвать серьезные семантические проблемы и нарушить безопасность памяти! Однако это может значительно ускорить назначение, потому что семантика Nim требует глубокого копирования последовательностей и строк. Это может быть дорого, особенно если для построения древовидной структуры используются последовательности:</target>
        </trans-unit>
        <trans-unit id="70490801fb19f53b61e82f0f32ef054d04c4ee37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sink&lt;/code&gt; and &lt;code&gt;lent&lt;/code&gt; annotations allow us to remove most (if not all) superfluous copies and destructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a94cc1faa9d7174f44a4b0eb96e7b131e94500a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std/monotimes&lt;/code&gt; module implements monotonic timestamps. A monotonic timestamp represents the time that has passed since some system defined point in time. The monotonic timestamps are guaranteed to always increase, meaning that that the following is guaranteed to work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0473bd0e810149a939133acc83ef43055abcf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afbb3aa2be881123747a6ecc1beb41e7bc4bafa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode. An efficient string substitution operator &lt;code&gt;%&lt;/code&gt; for the string table is also provided.</source>
          <target state="translated">Модуль &lt;code&gt;strtabs&lt;/code&gt; реализует эффективную хеш-таблицу, которая отображает строки в строки. Поддерживает режимы с учетом регистра, без учета регистра и без учета стиля. Также предоставляется эффективный оператор подстановки строк &lt;code&gt;%&lt;/code&gt; для таблицы строк.</target>
        </trans-unit>
        <trans-unit id="1bdd9a9646780d7c99c91ba808857d4c209506e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sug&lt;/code&gt; Nimsuggest command performs a query about possible completion symbols at some point in the file.</source>
          <target state="translated">Команда &lt;code&gt;sug&lt;/code&gt; Nimsuggest выполняет запрос о возможных символах завершения в некоторой точке файла.</target>
        </trans-unit>
        <trans-unit id="0ad03b44ad275fed9c4ae098f471d2c17ea38253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; модуль содержит часть RTL , которая нуждается в поддержке со стороны компилятора магии (и материал , который должен быть в этом , потому что спецификация говорит так). Генератор кода C генерирует для него код C, как и любой другой модуль. Однако вызовы некоторых процедур, таких как &lt;code&gt;addInt&lt;/code&gt; , вставляются CCG. Поэтому модуль &lt;code&gt;magicsys&lt;/code&gt; содержит таблицу ( &lt;code&gt;compilerprocs&lt;/code&gt; ) со всеми символами, которые помечены как &lt;code&gt;compilerproc&lt;/code&gt; . &lt;code&gt;compilerprocs&lt;/code&gt; необходимы генератору кода. &lt;code&gt;magic&lt;/code&gt; прок не то же самое , как &lt;code&gt;compilerproc&lt;/code&gt; : а &lt;code&gt;magic&lt;/code&gt; является прок , что потребности компилятор магии для его семантической моконтроль, &lt;code&gt;compilerproc&lt;/code&gt; - это процесс, который используется генератором кода.</target>
        </trans-unit>
        <trans-unit id="f9035ba56cfa6ab02534b3ec0d96d5eab1b2f002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it, just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ca4c72a3bc5eec2d4c6c1463c200d704c694f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module defines the important &lt;a href=&quot;system#Natural&quot;&gt;Natural&lt;/a&gt; type as &lt;code&gt;range[0..high(int)]&lt;/code&gt; (&lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often &lt;strong&gt;unwise&lt;/strong&gt;: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's &lt;code&gt;Natural&lt;/code&gt; type helps to avoid this common programming error.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; модуль определяет важный &lt;a href=&quot;system#Natural&quot;&gt;природный&lt;/a&gt; тип, &lt;code&gt;range[0..high(int)]&lt;/code&gt; ( &lt;a href=&quot;system#high&quot;&gt;высокий&lt;/a&gt; возвращает значение максимального). Другие языки программирования могут предлагать использование целых чисел без знака для натуральных чисел. Часто это &lt;strong&gt;неразумно&lt;/strong&gt; : вам не нужна беззнаковая арифметика (которая повторяется) только потому, что числа не могут быть отрицательными. Тип Нима &lt;code&gt;Natural&lt;/code&gt; помогает избежать этой распространенной ошибки программирования.</target>
        </trans-unit>
        <trans-unit id="c232a0290c3aa227f3d98a650bd1b8e5ea3f4777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14dc5a05b6b245cb0be25c1bbcfb8cbd3c4b9fb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values. &lt;code&gt;Table&lt;/code&gt; is the usual hash table, &lt;code&gt;OrderedTable&lt;/code&gt; is like &lt;code&gt;Table&lt;/code&gt; but remembers insertion order and &lt;code&gt;CountTable&lt;/code&gt; is a mapping from a key to its number of occurrences. For consistency with every other data type in Nim these have &lt;strong&gt;value&lt;/strong&gt; semantics, this means that &lt;code&gt;=&lt;/code&gt; performs a copy of the hash table. For &lt;strong&gt;reference&lt;/strong&gt; semantics use the &lt;code&gt;Ref&lt;/code&gt; variant: &lt;code&gt;TableRef&lt;/code&gt;, &lt;code&gt;OrderedTableRef&lt;/code&gt;, &lt;code&gt;CountTableRef&lt;/code&gt;. To give an example, when &lt;em&gt;a&lt;/em&gt; is a Table, then &lt;em&gt;var b = a&lt;/em&gt; gives &lt;em&gt;b&lt;/em&gt; as a new independent table. b is initialised with the contents of &lt;em&gt;a&lt;/em&gt;. Changing &lt;em&gt;b&lt;/em&gt; does not affect &lt;em&gt;a&lt;/em&gt; and vice versa:</source>
          <target state="translated">Модуль &lt;code&gt;tables&lt;/code&gt; реализует варианты эффективной &lt;span id=&quot;hash-table_1&quot;&gt;хэш-таблицы&lt;/span&gt; (также часто называемой &lt;span id=&quot;dictionary_1&quot;&gt;словарем&lt;/span&gt; в других языках программирования), которая является отображением ключей в значения. &lt;code&gt;Table&lt;/code&gt; - это обычная хэш-таблица, &lt;code&gt;OrderedTable&lt;/code&gt; похожа на &lt;code&gt;Table&lt;/code&gt; , но запоминает порядок вставки, а &lt;code&gt;CountTable&lt;/code&gt; - это отображение ключа на количество его вхождений. Для согласованности с любым другим типом данных в Nim они имеют семантику &lt;strong&gt;значений&lt;/strong&gt; , это означает, что &lt;code&gt;=&lt;/code&gt; выполняет копию хеш-таблицы. Для &lt;strong&gt;эталонной&lt;/strong&gt; семантики используйте вариант &lt;code&gt;Ref&lt;/code&gt; : &lt;code&gt;TableRef&lt;/code&gt; , &lt;code&gt;OrderedTableRef&lt;/code&gt; , &lt;code&gt;CountTableRef&lt;/code&gt; . В качестве примера, когда &lt;em&gt;a&lt;/em&gt; является таблицей, тогда &lt;em&gt;var b = a&lt;/em&gt; дает &lt;em&gt;b&lt;/em&gt; как новую независимую таблицу. b инициализируется содержимым &lt;em&gt;a&lt;/em&gt; . Изменение &lt;em&gt;b&lt;/em&gt; не влияет на &lt;em&gt;a,&lt;/em&gt; и наоборот:</target>
        </trans-unit>
        <trans-unit id="eb85eba1af50fa871f49d79336197980e95f5e88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;task&lt;/code&gt; template that the &lt;code&gt;system&lt;/code&gt; module defines allows a NimScript file to be used as a build tool. The following example defines a task &lt;code&gt;build&lt;/code&gt; that is an alias for the &lt;code&gt;c&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ae4324ab0abf484cafe035da581771b6411aae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; аргумент определяет максимальное количество миллисекунд функция будет заблокирована , если никаких событий не готовы. Указание тайм-аута &lt;code&gt;-1&lt;/code&gt; приводит к тому, что функция блокируется на неопределенный срок.</target>
        </trans-unit>
        <trans-unit id="d431b3c8673538504427a8309f89779fe91091e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely. All available events will be stored in &lt;code&gt;results&lt;/code&gt; array.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; аргумент определяет максимальное количество миллисекунд функция будет заблокирована , если никаких событий не готовы. Указание тайм-аута &lt;code&gt;-1&lt;/code&gt; приводит к тому, что функция блокируется на неопределенный срок. Все доступные события будут сохранены в массиве &lt;code&gt;results&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ecbe75d06cddb5ee3e9b9b74d9adedd1918e7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; parameter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dfd6109dacde12070a0913015e494bbf03c02d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; paremeter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="translated">Параметр &lt;code&gt;timeout&lt;/code&gt; указывает время в миллисекундах, в течение которого можно установить соединение с сервером.</target>
        </trans-unit>
        <trans-unit id="38edfa829280086eb1bbb722fc058e36f403cb03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times&lt;/code&gt; module contains routines and types for dealing with time using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;proleptic Gregorian calendar&lt;/a&gt;. It's also available for the &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551c95a5e7566f1190bf74f48e874beb433d9b64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times&lt;/code&gt; module exports two similar types that are both used to represent some amount of time: &lt;a href=&quot;#Duration&quot;&gt;Duration&lt;/a&gt; and &lt;a href=&quot;#TimeInterval&quot;&gt;TimeInterval&lt;/a&gt;. This section explains how they differ and when one should be preferred over the other (short answer: use &lt;code&gt;Duration&lt;/code&gt; unless support for months and years is needed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2168e89685d500f34305fadd8a799ea9837bc0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; statement handles exceptions:</source>
          <target state="translated">Оператор &lt;code&gt;try&lt;/code&gt; обрабатывает исключения:</target>
        </trans-unit>
        <trans-unit id="ec7d06e028291e266b3574501a3bbca632d71df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unchecked&lt;/code&gt; pragma can be used to mark a named array as &lt;code&gt;unchecked&lt;/code&gt; meaning its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:</source>
          <target state="translated">&lt;code&gt;unchecked&lt;/code&gt; прагма может быть использована для обозначения именованного массива как &lt;code&gt;unchecked&lt;/code&gt; смысл его граница не проверяется. Это часто бывает полезно для реализации настраиваемых массивов гибкого размера. Дополнительно непроверенный массив переводится в массив C неопределенного размера:</target>
        </trans-unit>
        <trans-unit id="c94b76defb11868b1ae8894e3bb63b7d8285f9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;union&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It means all of the object's fields are overlaid in memory. This produces a &lt;code&gt;union&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt; in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; прагма может быть применен к любому &lt;code&gt;object&lt;/code&gt; типа. Это означает, что все поля объекта накладываются в память. Это создает &lt;code&gt;union&lt;/code&gt; вместо &lt;code&gt;struct&lt;/code&gt; в сгенерированном коде C / C ++. В этом случае объявление объекта не должно использовать наследование или какую-либо память с GC, но это в настоящее время не проверяется.</target>
        </trans-unit>
        <trans-unit id="5512388758e298c4c26f4a165b06bea0eae327c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unroll&lt;/code&gt; pragma can be used to tell the compiler that it should unroll a &lt;span id=&quot;for_2&quot;&gt;for&lt;/span&gt; or &lt;span id=&quot;while_1&quot;&gt;while&lt;/span&gt; loop for runtime efficiency:</source>
          <target state="translated">&lt;code&gt;unroll&lt;/code&gt; прагма может быть использована , чтобы сообщить компилятору , что он должен раскатать &lt;span id=&quot;for_2&quot;&gt;для&lt;/span&gt; или во &lt;span id=&quot;while_1&quot;&gt;время&lt;/span&gt; цикла для выполнения эффективности:</target>
        </trans-unit>
        <trans-unit id="965b5f72fd2186e49462ff5ed9043780f9e1cb58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; Nimsuggest command lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time.</source>
          <target state="translated">Команда &lt;code&gt;use&lt;/code&gt; Nimsuggest перечисляет все случаи использования символа в позиции. IDE могут использовать это, чтобы найти все места в файле, где используется символ, и предложить пользователю переименовать его во всех местах одновременно.</target>
        </trans-unit>
        <trans-unit id="1841570b4e739b5943163d9b9857a19771bd7db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usePlus&lt;/code&gt; parameter is passed down to the &lt;code&gt;encodeUrl&lt;/code&gt; function that is used for the URL encoding of the string values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bded0ec11c200a51a4e6475dbab31e4355ab12d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;using&lt;/code&gt; section uses the same indentation based grouping syntax as a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; section.</source>
          <target state="translated">Раздел &lt;code&gt;using&lt;/code&gt; использует тот же синтаксис группировки на основе отступов, что и раздел &lt;code&gt;var&lt;/code&gt; или &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf32e53e4609c5f4cde4e84fe336750a3c4a317a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;varargs&lt;/code&gt; pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:</source>
          <target state="translated">&lt;code&gt;varargs&lt;/code&gt; прагма может быть применена только к процедурам (и типам процедуры). Он сообщает Nim, что процедура может принимать переменное количество параметров после последнего указанного параметра. Строковые значения NIM будут автоматически преобразованы в строки C:</target>
        </trans-unit>
        <trans-unit id="fac4b56c328a62775e81f815e78bd26e59b4f4d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type denotes the absence of any type. Parameters of type &lt;code&gt;void&lt;/code&gt; are treated as non-existent, &lt;code&gt;void&lt;/code&gt; as a return type means that the procedure does not return a value:</source>
          <target state="translated">Тип &lt;code&gt;void&lt;/code&gt; означает отсутствие какого-либо типа. Параметры типа &lt;code&gt;void&lt;/code&gt; обрабатываются как несуществующие, &lt;code&gt;void&lt;/code&gt; как возвращаемый тип означает, что процедура не возвращает значение:</target>
        </trans-unit>
        <trans-unit id="d54f05d7805d3d20206628828c5a46105e33e791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is only valid for parameters and return types; other symbols cannot have the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;void&lt;/code&gt; действителен только для параметров и возвращаемых типов; другие символы не могут иметь тип &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d46bfe15b6bb594dd4d7b4f9ac119c89f36e71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is particularly useful for generic code:</source>
          <target state="translated">Тип &lt;code&gt;void&lt;/code&gt; особенно полезен для универсального кода:</target>
        </trans-unit>
        <trans-unit id="9d170c08bbf58e946b9ec8840f5556c7094bc2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volatile&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;volatile&lt;/code&gt;, whatever that means in C/C++ (its semantics are not well defined in C/C++).</source>
          <target state="translated">&lt;code&gt;volatile&lt;/code&gt; прагма только переменные. Он объявляет переменную как &lt;code&gt;volatile&lt;/code&gt; , что бы это ни значило в C / C ++ (ее семантика плохо определена в C / C ++).</target>
        </trans-unit>
        <trans-unit id="45f140f4f01fe1213690fb05d3fda0c6d1fe6699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warning&lt;/code&gt; pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</source>
          <target state="translated">&lt;code&gt;warning&lt;/code&gt; Прагма используется , чтобы сделать вывод компилятора предупреждающее сообщение с указанным содержанием. Компиляция продолжается после предупреждения.</target>
        </trans-unit>
        <trans-unit id="9509e80840bb0f1df308f8032f3bb053eea5da51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement enables conditional compilation techniques. As a special syntactic extension, the &lt;code&gt;when&lt;/code&gt; construct is also available within &lt;code&gt;object&lt;/code&gt; definitions.</source>
          <target state="translated">Оператор &lt;code&gt;when&lt;/code&gt; включает методы условной компиляции. В качестве специального синтаксического расширения конструкция &lt;code&gt;when&lt;/code&gt; также доступна в определениях &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3923b0ea614af5c8a6acc8fd050a8e60d9177947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement with some exceptions:</source>
          <target state="translated">Оператор &lt;code&gt;when&lt;/code&gt; практически идентичен оператору &lt;code&gt;if&lt;/code&gt; за некоторыми исключениями:</target>
        </trans-unit>
        <trans-unit id="238308d0a093ac5ec92a1fb377ed60fb2c7f5746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement, but with these differences:</source>
          <target state="translated">Оператор &lt;code&gt;when&lt;/code&gt; почти идентичен оператору &lt;code&gt;if&lt;/code&gt; , но с некоторыми отличиями:</target>
        </trans-unit>
        <trans-unit id="57d001b8d7b1eb7efa8f75e5bfa898d7953ff6a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is useful for writing platform specific code, similar to the &lt;code&gt;#ifdef&lt;/code&gt; construct in the C programming language.</source>
          <target state="translated">Оператор &lt;code&gt;when&lt;/code&gt; полезен для написания кода для конкретной платформы, подобно конструкции &lt;code&gt;#ifdef&lt;/code&gt; в языке программирования C.</target>
        </trans-unit>
        <trans-unit id="f95ea01eb63a864b4f10f510dd1f071edf8bc9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;code&gt;implicit block&lt;/code&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed2216fef6cefddc51b5dfc1501acbc63519752" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;em&gt;implicit block&lt;/em&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; оператор не выполняется , пока &lt;code&gt;expr&lt;/code&gt; оценивается как ложное. Бесконечные циклы - это не ошибка. Операторы &lt;code&gt;while&lt;/code&gt; открывают &lt;em&gt;неявный блок&lt;/em&gt; , поэтому их можно оставить с оператором &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77e5c5d6d627aa54296b3870cd7922006782e15e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="translated">Оператор &lt;code&gt;yield&lt;/code&gt; используется вместо оператора &lt;code&gt;return&lt;/code&gt; в итераторах. Действует только в итераторах. Выполнение возвращается в тело цикла for, который вызвал итератор. Yield не завершает итерационный процесс, но выполнение возвращается итератору, если начинается следующая итерация. См. Раздел об итераторах ( &lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Итераторы и оператор&lt;/a&gt; for) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="74a3a7e48222419bc7a04a33163a499728766780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but the execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0694f678da714119225cabbbd0654c71587ddfa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{}&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; Оператор</target>
        </trans-unit>
        <trans-unit id="1201154eaa53a6a08247d7a1f878b08cbcc71415" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; оператор</target>
        </trans-unit>
        <trans-unit id="7b0bf905e381cc04d13b47c0b5b03f3639bd78ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator if used as infix operator creates an ordered choice:</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; оператор, если он используется как инфиксный оператор, создает упорядоченный выбор:</target>
        </trans-unit>
        <trans-unit id="64228bf590558ad4fc967418a6eab8c95681462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; symbols are used to mark alternatives and have the lowest precedence. &lt;code&gt;/&lt;/code&gt; is the ordered choice that requires the parser to try the alternatives in the given order. &lt;code&gt;/&lt;/code&gt; is often used to ensure the grammar is not ambiguous.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; , символы &lt;code&gt;/&lt;/code&gt; используются для обозначения альтернатив и имеют самый низкий приоритет. &lt;code&gt;/&lt;/code&gt; - это упорядоченный выбор, который требует, чтобы синтаксический анализатор пробовал альтернативы в заданном порядке. &lt;code&gt;/&lt;/code&gt; часто используется, чтобы гарантировать отсутствие двусмысленности в грамматике.</target>
        </trans-unit>
        <trans-unit id="c06e1a048dfb09f151ad6af04b4cc2cbab7ce373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; Оператор</target>
        </trans-unit>
        <trans-unit id="9856d0d900d79fc607cd6848700f2bafec366603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator is the &lt;strong&gt;not&lt;/strong&gt; operator in patterns:</source>
          <target state="translated">Оператор &lt;code&gt;~&lt;/code&gt; является оператором &lt;strong&gt;not&lt;/strong&gt; в шаблонах:</target>
        </trans-unit>
        <trans-unit id="6edb4e4054e37bf60483392193b7ad3441d67ddf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for count tables.</source>
          <target state="translated">Оператор &lt;em&gt;$&lt;/em&gt; для счетных таблиц.</target>
        </trans-unit>
        <trans-unit id="8c6a817abf878b263302b528ba9eba150a0b5e4f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for hash tables.</source>
          <target state="translated">Оператор &lt;em&gt;$&lt;/em&gt; для хеш-таблиц.</target>
        </trans-unit>
        <trans-unit id="21210e15f2beb096edd05ccec6e1b9573b666a36" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for int sets.</source>
          <target state="translated">Оператор &lt;em&gt;$&lt;/em&gt; для наборов int.</target>
        </trans-unit>
        <trans-unit id="6d5e46312d92579508d6c9ed937fbbd4c1df3a3a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for ordered hash tables.</source>
          <target state="translated">Оператор &lt;em&gt;$&lt;/em&gt; для упорядоченных хеш-таблиц.</target>
        </trans-unit>
        <trans-unit id="9eea65ebe90881c4414538083cd97f3fc9aef8d6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for string tables.</source>
          <target state="translated">Оператор &lt;em&gt;$&lt;/em&gt; для строковых таблиц.</target>
        </trans-unit>
        <trans-unit id="1a84d3734edf137dc85d74d27bc8c4eec4e9620e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;%&lt;/em&gt; operator for string tables.</source>
          <target state="translated">Оператор &lt;em&gt;%&lt;/em&gt; для строковых таблиц.</target>
        </trans-unit>
        <trans-unit id="42fb88e76a89671075d6dad00a270f10b9b6f1ed" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для счетных таблиц. Возвращает &lt;code&gt;true&lt;/code&gt; если обе таблицы содержат одинаковые ключи с одинаковым счетчиком. Порядок вставки не имеет значения.</target>
        </trans-unit>
        <trans-unit id="f3c437f641f31ef6a98cac2a696fbef8b9e8bc19" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для счетных таблиц. Возвращает &lt;code&gt;true&lt;/code&gt; если либо обе таблицы равны &lt;code&gt;nil&lt;/code&gt; либо ни одна из них не равна &lt;code&gt;nil&lt;/code&gt; и обе содержат одинаковые ключи с одинаковым счетчиком. Порядок вставки не имеет значения.</target>
        </trans-unit>
        <trans-unit id="65caa9363c9c4bee80ce44c109b6388268b58a9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для хеш-таблиц. Возвращает &lt;code&gt;true&lt;/code&gt; если либо обе таблицы равны &lt;code&gt;nil&lt;/code&gt; либо ни одна из них не равна &lt;code&gt;nil&lt;/code&gt; и содержимое обеих таблиц содержит одинаковые пары ключ-значение. Порядок вставки не имеет значения.</target>
        </trans-unit>
        <trans-unit id="ecfa374c36b6bffd18a0ef6cce629ecea93ec8e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для хеш-таблиц. Возвращает &lt;code&gt;true&lt;/code&gt; , если содержимое обеих таблиц содержит одинаковые пары ключ-значение. Порядок вставки не имеет значения.</target>
        </trans-unit>
        <trans-unit id="eadaefcf55fb6edbf3abdf3db98fb0843d048aaf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff both the content and the order are equal.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для упорядоченных хеш-таблиц. Возвращает true, если и содержимое, и порядок равны.</target>
        </trans-unit>
        <trans-unit id="8914eb62f26e75052b45d57bea0bc85c1277e2e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="translated">Оператор &lt;em&gt;==&lt;/em&gt; для упорядоченных хеш-таблиц. Возвращает истину, если обе таблицы равны &lt;code&gt;nil&lt;/code&gt; или ни одна из них не равна &lt;code&gt;nil&lt;/code&gt; а содержимое и порядок обеих таблиц равны.</target>
        </trans-unit>
        <trans-unit id="4d36127144c35e196b74a69bb0dd19d7650ca3b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Nim compiler&lt;/em&gt; also has support for RST (reStructuredText) files with the &lt;code&gt;rst2html&lt;/code&gt; and &lt;code&gt;rst2tex&lt;/code&gt; commands. Documents like this one are initially written in a dialect of RST which adds support for nim sourcecode highlighting with the &lt;code&gt;.. code-block:: nim&lt;/code&gt; prefix. &lt;code&gt;code-block&lt;/code&gt; also supports highlighting of C++ and some other c-like languages.</source>
          <target state="translated">&lt;em&gt;Компилятор Nim&lt;/em&gt; также имеет поддержку файлов RST (ReStructuredText) с &lt;code&gt;rst2html&lt;/code&gt; и &lt;code&gt;rst2tex&lt;/code&gt; команд. Документы, подобные этому, изначально написаны на диалекте RST, который добавляет поддержку выделения исходного &lt;code&gt;.. code-block:: nim&lt;/code&gt; префикса .. code-block :: nim . &lt;code&gt;code-block&lt;/code&gt; также поддерживает выделение C ++ и некоторых других c-подобных языков.</target>
        </trans-unit>
        <trans-unit id="64b9df197c2acb72edd07ad4070f99730861f242" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;case expression&lt;/em&gt; is again very similar to the case statement:</source>
          <target state="translated">&lt;em&gt;Выражение случая&lt;/em&gt; опять очень похоже на саз:</target>
        </trans-unit>
        <trans-unit id="dd1e3926f728dc35f509a5bf9e5f4dad82e16ce3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;character type&lt;/em&gt; is called &lt;code&gt;char&lt;/code&gt;. Its size is always one byte, so it cannot represent most UTF-8 characters; but it &lt;em&gt;can&lt;/em&gt; represent one of the bytes that makes up a multi-byte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes.</source>
          <target state="translated">Тип &lt;em&gt;символа&lt;/em&gt; называется &lt;code&gt;char&lt;/code&gt; . Его размер всегда составляет один байт, поэтому он не может отображать большинство символов UTF-8; но он &lt;em&gt;может&lt;/em&gt; представлять один из байтов, составляющих многобайтовый символ UTF-8. Причина этого - эффективность: в подавляющем большинстве случаев использования результирующие программы по-прежнему будут правильно обрабатывать UTF-8, поскольку UTF-8 был специально разработан для этого. Символьные литералы заключаются в одинарные кавычки.</target>
        </trans-unit>
        <trans-unit id="b59bbeebfabbb8d232d246b925687354b59b07ba" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;duration&lt;/em&gt; of a borrow is the span of commands beginning from the assignment to the view and ending with the last usage of the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d5db35b5bd11b522d53f5b565bc1dd579987f8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;em&gt;filename&lt;/em&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overriden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="translated">Параметр &lt;em&gt;filename&lt;/em&gt; будет использоваться для сообщения об ошибках и создания гиперссылок индекса на файл, но вы можете передать здесь пустую строку, если вы анализируете поток в памяти. Если &lt;em&gt;имя файла&lt;/em&gt; оканчивается расширением &lt;code&gt;.nim&lt;/code&gt; , заголовок документа будет установлен по умолчанию как &lt;code&gt;Module filename&lt;/code&gt; . Этот заголовок по умолчанию может быть заменен встроенным заголовком, но он помогает уточнить сгенерированный индекс, если заголовок не найден.</target>
        </trans-unit>
        <trans-unit id="edbaae9f7ab66a5f097fb8ddd27afa919150b133" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handlers&lt;/em&gt; parameter consists of code blocks for &lt;em&gt;PegKinds&lt;/em&gt;, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An &lt;em&gt;enter&lt;/em&gt; handler can access the specific PEG AST node being matched as &lt;em&gt;p&lt;/em&gt;, the entire parsed string as &lt;em&gt;s&lt;/em&gt; and the position of the matched text segment in &lt;em&gt;s&lt;/em&gt; as &lt;em&gt;start&lt;/em&gt;. A &lt;em&gt;leave&lt;/em&gt; handler can access &lt;em&gt;p&lt;/em&gt;, &lt;em&gt;s&lt;/em&gt;, &lt;em&gt;start&lt;/em&gt; and also the length of the matched text segment as &lt;em&gt;length&lt;/em&gt;. For an unsuccessful match, the &lt;em&gt;enter&lt;/em&gt; and &lt;em&gt;leave&lt;/em&gt; handlers will be executed, with &lt;em&gt;length&lt;/em&gt; set to -1.</source>
          <target state="translated">&lt;em&gt;Обработчиков&lt;/em&gt; параметров состоит из кодовых блоков для &lt;em&gt;PegKinds&lt;/em&gt; , которые определяют грамматические элементы , представляющие интерес. Каждый блок может содержать код обработчика, который будет выполняться, когда синтаксический анализатор входит и оставляет текст, соответствующий элементу грамматики. &lt;em&gt;Ввести&lt;/em&gt; обработчик может получить доступ к конкретному ПЭГУ АСТОГО узла, совпадающий , как &lt;em&gt;р&lt;/em&gt; , вся анализируемой строка как &lt;em&gt;с&lt;/em&gt; и положением согласованного текстового сегмента в &lt;em&gt;сек&lt;/em&gt; , как &lt;em&gt;начала&lt;/em&gt; . &lt;em&gt;Отпуск&lt;/em&gt; обработчика доступа может &lt;em&gt;р&lt;/em&gt; , &lt;em&gt;с&lt;/em&gt; , &lt;em&gt;начать&lt;/em&gt; , а также длину согласованного текстового сегмента в качестве &lt;em&gt;длины&lt;/em&gt; . При неудачном матче&lt;em&gt;&lt;/em&gt;Обработчики &lt;em&gt;входа&lt;/em&gt; и &lt;em&gt;выхода&lt;/em&gt; будут выполнены с &lt;em&gt;длиной,&lt;/em&gt; равной -1.</target>
        </trans-unit>
        <trans-unit id="64386956b3c73085d6328c9f138a7d8052469400" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;id&lt;/em&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;em&gt;id&lt;/em&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="translated">К &lt;em&gt;идентификатору&lt;/em&gt; будет добавлен символ решетки, только если его длина не равна нулю, в противном случае конкретная привязка не будет сгенерирована. В общем, вы должны передавать только пустое значение &lt;em&gt;id&lt;/em&gt; для заголовка автономных первых документов (они являются специальными для процедуры &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes ()&lt;/a&gt; , дополнительную информацию см. В разделе &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Формат файла индекса (idx)&lt;/a&gt; ). В отличие от других терминов указателя, записи заголовка вставляются в начало накопленного буфера для поддержания логического порядка записей.</target>
        </trans-unit>
        <trans-unit id="e7bcea88e9b3afcedaf4fe86c7903aad3e98b4fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">Параметр &lt;em&gt;initialSize&lt;/em&gt; должен быть степенью двойки. Вы можете использовать &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo ()&lt;/a&gt; или &lt;em&gt;rightSize,&lt;/em&gt; чтобы гарантировать это во время выполнения. Все переменные набора должны быть инициализированы перед использованием с другими процедурами из этого модуля, за исключением &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt; и &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e595993e5c058be0e84afb91215737952ff662f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">Параметр &lt;em&gt;initialSize&lt;/em&gt; должен быть степенью двойки. Вы можете использовать &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo ()&lt;/a&gt; или &lt;em&gt;rightSize,&lt;/em&gt; чтобы гарантировать это во время выполнения. Все переменные набора должны быть инициализированы перед использованием с другими процедурами из этого модуля, за исключением &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt; и &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c214c728d4121535b4b7a34f396ea719117cb4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</source>
          <target state="translated">Область &lt;em&gt;действия&lt;/em&gt; переменной, объявленной в части объявления блока, действительна с момента объявления до конца блока. Если блок содержит второй блок, в котором повторно объявляется идентификатор, то внутри этого блока будет действительным второе объявление. После выхода из внутреннего блока первое объявление снова становится действительным. Идентификатор не может быть переопределен в том же блоке, за исключением случаев, когда он действителен для целей перегрузки процедуры или итератора.</target>
        </trans-unit>
        <trans-unit id="31957fd1dab3297b9650262294cc9e647a86c978" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sloppy interfacing&lt;/em&gt; example uses &lt;code&gt;.emit&lt;/code&gt; to produce &lt;code&gt;using namespace&lt;/code&gt; declarations. It is usually much better to instead refer to the imported name via the &lt;code&gt;namespace::identifier&lt;/code&gt; notation:</source>
          <target state="translated">В примере с &lt;em&gt;небрежным интерфейсом &lt;/em&gt; &lt;code&gt;.emit&lt;/code&gt; используется для создания объявлений &lt;code&gt;using namespace&lt;/code&gt; . Обычно гораздо лучше вместо этого ссылаться на импортированное имя через нотацию &lt;code&gt;namespace::identifier&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da93781d112d6e740e1375bf8d057a1a694aa4d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;align_1&quot;&gt;align&lt;/span&gt; pragma is for variables and object field members. It modifies the alignment requirement of the entity being declared. The argument must be a constant power of 2. Valid non-zero alignments that are weaker than other align pragmas on the same declaration are ignored. Alignments that are weaker than the alignment requirement of the type are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5cdc44b88b5634c8f912a49a8f74da86b5d738" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt; character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">Символ &lt;span id=&quot;backslash_1&quot;&gt;обратной косой&lt;/span&gt; черты имеет несколько применений. Во-первых, если за ним следует не буквенно-цифровой символ, он удаляет любое специальное значение, которое может иметь этот символ. Такое использование обратной косой черты в качестве escape-символа применяется как внутри, так и за пределами классов символов.</target>
        </trans-unit>
        <trans-unit id="b06b473e1ee1762f517fd6999bd07dece354bc29" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;boot_1&quot;&gt;boot&lt;/span&gt; command bootstraps the compiler, and it accepts different options:</source>
          <target state="translated">Команда &lt;span id=&quot;boot_1&quot;&gt;загрузки загружает&lt;/span&gt; компилятор и принимает различные параметры:</target>
        </trans-unit>
        <trans-unit id="fe5c377ca282280b9863d88ec5a8f55bcf5f2255" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">Команда &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; создает &lt;span id=&quot;csource_1&quot;&gt;исходные коды&lt;/span&gt; C для установки. Он принимает те же параметры, которые вы передали бы команде &lt;a href=&quot;#boot-command&quot;&gt;загрузки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdaaec8473ada505740f8f1af6c125ef2f73898b" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#commands-boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53b256239da4adea364a3390858d3ee5b4d0c44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;dotnosinks_1&quot;&gt;.nosinks&lt;/span&gt; pragma can be used to disable this inference for a single routine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debca29a7a9e313a0d076cc0661ed876f0ad8d69" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; statement is an abstract mechanism to iterate over the elements of a container. It relies on an &lt;span id=&quot;iterator_1&quot;&gt;iterator&lt;/span&gt; to do so. Like &lt;code&gt;while&lt;/code&gt; statements, &lt;code&gt;for&lt;/code&gt; statements open an &lt;span id=&quot;implicit-block_1&quot;&gt;implicit block&lt;/span&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">Оператор &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; - это абстрактный механизм для перебора элементов контейнера. Для этого он полагается на &lt;span id=&quot;iterator_1&quot;&gt;итератор&lt;/span&gt; . Как &lt;code&gt;while&lt;/code&gt; операторы while, операторы &lt;code&gt;for&lt;/code&gt; открывают &lt;span id=&quot;implicit-block_1&quot;&gt;неявный блок&lt;/span&gt; , поэтому их можно оставить с оператором &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d9382afc1ab3b35fd9c7113d6add76969213268" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. &lt;code&gt;spawn&lt;/code&gt; is usually the preferable method. Either way the invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="translated">&lt;span id=&quot;gcsafe_1&quot;&gt;Gcsafe&lt;/span&gt; аннотация может быть использована для обозначения процедурного быть gcsafe, в противном случае этого свойство выводится компилятором. Обратите внимание, что &lt;code&gt;noSideEffect&lt;/code&gt; подразумевает &lt;code&gt;gcsafe&lt;/code&gt; . Единственный способ создать поток - через &lt;code&gt;spawn&lt;/code&gt; или &lt;code&gt;createThread&lt;/code&gt; . &lt;code&gt;spawn&lt;/code&gt; обычно является предпочтительным методом. В любом случае вызываемая процедура не должна использовать параметры &lt;code&gt;var&lt;/code&gt; ,и ни один из ее параметров не должен содержать тип &lt;code&gt;ref&lt;/code&gt; или &lt;code&gt;closure&lt;/code&gt; . Это приводит к &lt;em&gt;запрету совместного использования кучи&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="263dfccfb0e868076dd90d1d32172ba6edfea6cb" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. The invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91164a5c7f6c7e859655b6b6af4545842eee07d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; option enables special compilation mode where changes in the code can be applied automatically to a running program. The code reloading happens at the granularity of an individual module. When a module is reloaded, Nim will preserve the state of all global variables which are initialized with a standard variable declaration in the code. All other top level code will be executed repeatedly on each reload. If you want to prevent this behavior, you can guard a block of code with the &lt;code&gt;once&lt;/code&gt; construct:</source>
          <target state="translated">Параметр &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; включает специальный режим компиляции, в котором изменения в коде могут автоматически применяться к работающей программе. Перезагрузка кода происходит на уровне детализации отдельного модуля. Когда модуль перезагружается, Nim сохранит состояние всех глобальных переменных, которые инициализируются стандартным объявлением переменных в коде. Весь другой код верхнего уровня будет выполняться повторно при каждой перезагрузке. Если вы хотите , чтобы предотвратить такое поведение, вы можете защитить блок кода с &lt;code&gt;once&lt;/code&gt; конструкцией:</target>
        </trans-unit>
        <trans-unit id="57a3663a206275ec6b24a0d4f5e454d389b9f45f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. The word &lt;em&gt;koch&lt;/em&gt; means &lt;em&gt;cook&lt;/em&gt; in German. &lt;code&gt;koch&lt;/code&gt; is used mainly to build the Nim compiler, but it can also be used for other tasks. This document describes the supported commands and their options.</source>
          <target state="translated">Программа &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; - это сценарий обслуживания Нима. Это замена для сценариев make и оболочки с тем преимуществом, что он намного более переносим. Слово &lt;em&gt;koch в&lt;/em&gt; переводе с немецкого означает &lt;em&gt;готовить&lt;/em&gt; . &lt;code&gt;koch&lt;/code&gt; используется в основном для сборки компилятора Nim, но его также можно использовать для других задач. В этом документе описаны поддерживаемые команды и их параметры.</target>
        </trans-unit>
        <trans-unit id="a53571f24b323d265b8569c9fb2bedae1b76e3af" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="translated">&lt;span id=&quot;nimcache_1&quot;&gt;Nimcache&lt;/span&gt; каталог создается во время компиляции и будет держать либо временные или окончательные файлы в зависимости от вашей цели бэкэнда. Имя по умолчанию для каталога зависит от используемой серверной части и вашей ОС, но вы можете использовать &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;компилятора &lt;/a&gt;--nimcache, чтобы изменить его.</target>
        </trans-unit>
        <trans-unit id="92bf656e3ee386275c0b9697fe2e8bc71b022ce8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-commandminusline-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a1e48458551511422bbb61f22c648f60734046" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;parameter-constraint_1&quot;&gt;parameter constraint&lt;/span&gt; expression can use the operators &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;&amp;amp;&lt;/code&gt; (and) and &lt;code&gt;~&lt;/code&gt; (not) and the following predicates:</source>
          <target state="translated">В выражении &lt;span id=&quot;parameter-constraint_1&quot;&gt;ограничения параметра&lt;/span&gt; можно использовать операторы &lt;code&gt;|&lt;/code&gt; (или), &lt;code&gt;&amp;amp;&lt;/code&gt; (и) и &lt;code&gt;~&lt;/code&gt; (не) и следующие предикаты:</target>
        </trans-unit>
        <trans-unit id="cfa661ac5acf3812a9603d558f0cc5e9d16b725f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;pushslashpop_1&quot;&gt;push/pop&lt;/span&gt; pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</source>
          <target state="translated">В &lt;span id=&quot;pushslashpop_1&quot;&gt;нажимных / попе&lt;/span&gt; псевдокомментарии очень похож на директивы опции, но используется для переопределения настройки временно. Пример:</target>
        </trans-unit>
        <trans-unit id="87bbfad905a0fc037232436963bb95bf7f76d077" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator .. takes precedence over other tokens that contain a dot: {..} are the three tokens {, .., } and not the two tokens {., .}.</source>
          <target state="translated">Оператор &lt;span id=&quot;slice_1&quot;&gt;среза&lt;/span&gt; .. имеет приоритет над другими токенами, содержащими точку: {..} - это три токена {, ..,}, а не два токена {.,.}.</target>
        </trans-unit>
        <trans-unit id="93730bf4352ebc6a6c5b5cf40a7c97e98830ae75" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;code&gt;formatstr&lt;/code&gt; and returns a modified &lt;code&gt;formatstr&lt;/code&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af8373b9460197079b99667c8fea57ecbb59884" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">Оператор &lt;span id=&quot;substitution_1&quot;&gt;подстановки&lt;/span&gt; выполняет подстановку строк в &lt;em&gt;formatstr&lt;/em&gt; и возвращает измененный &lt;em&gt;formatstr&lt;/em&gt; . Это часто называют &lt;span id=&quot;string-interpolation_1&quot;&gt;строковой интерполяцией&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="6513fa7dcefd8fcc828e499152082db4c572537e" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_2&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_2&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">Оператор &lt;span id=&quot;substitution_2&quot;&gt;подстановки&lt;/span&gt; выполняет подстановку строк в &lt;em&gt;formatstr&lt;/em&gt; и возвращает измененный &lt;em&gt;formatstr&lt;/em&gt; . Это часто называют &lt;span id=&quot;string-interpolation_2&quot;&gt;строковой интерполяцией&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="171382137ee71e60fb08ca9fefa65698e106ef9b" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1b458b1b19b189d8e65f1668a50897e0a48f44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;tests/testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="translated">Команду &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; также можно вызывать с помощью псевдонимов &lt;code&gt;tests&lt;/code&gt; . Эта команда скомпилирует и запустит &lt;code&gt;tests/testament/tester.nim&lt;/code&gt; , который является основным драйвером набора тестов Nim. Вы можете передать параметры &lt;code&gt;test&lt;/code&gt; команде, они будут отправлены тестеру. Смотрите его исходный код для доступных опций.</target>
        </trans-unit>
        <trans-unit id="b2c15981e5e4830750c05aa5cb51e33019a0e2a4" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;web_1&quot;&gt;web&lt;/span&gt; command converts the documentation in the &lt;code&gt;doc&lt;/code&gt; directory from rst to HTML. It also repeats the same operation but places the result in the &lt;code&gt;web/upload&lt;/code&gt; which can be used to update the website at &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;.</source>
          <target state="translated">&lt;span id=&quot;web_1&quot;&gt;Веб&lt;/span&gt; - команда преобразует документы в &lt;code&gt;doc&lt;/code&gt; каталог от первого к HTML. Он также повторяет ту же операцию, но помещает результат в &lt;code&gt;web/upload&lt;/code&gt; , который можно использовать для обновления веб-сайта по адресу &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dea7302995c2fe043006be5d95cc1952f9177148" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="translated">Параметра &lt;strong&gt;FILE&lt;/strong&gt; достаточно для статического анализа, но IDE, как правило, имеют &lt;em&gt;несохраненные буферы, в&lt;/em&gt; которых пользователь все еще может печатать строку. В таких ситуациях IDE может сохранить текущее содержимое во временный файл, а затем использовать переключатель &lt;code&gt;--trackDirty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a97375906f1b0145ecfd52bd809ab81d76021e6e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; parameter is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27b669448c36c816470b9ecb178842de255828a" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action.</source>
          <target state="translated">API разработан, чтобы быть &lt;strong&gt;простым в использовании&lt;/strong&gt; и последовательным. Простота использования измеряется количеством вызовов для достижения конкретного действия высокого уровня.</target>
        </trans-unit>
        <trans-unit id="24ff78d14078efdde3aa0c8a6fca83e77761f981" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high-level action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73b5df5c651cfdc62f3ab0cb7d427e139e5b455" translate="yes" xml:space="preserve">
          <source>The API should embrace the AST diffing notion: See the module &lt;code&gt;macrocache&lt;/code&gt; for the final details.</source>
          <target state="translated">API должен охватывать понятие &lt;code&gt;macrocache&lt;/code&gt; AST: см. Макрокэш модуля для окончательных деталей.</target>
        </trans-unit>
        <trans-unit id="340251b1d9f2a716c84b7e7a92de21c0f5e2b332" translate="yes" xml:space="preserve">
          <source>The AST in Nim</source>
          <target state="translated">АСТ в Ним</target>
        </trans-unit>
        <trans-unit id="d9e072d30e620c5ec90f1b3cdaf9f07a7689786e" translate="yes" xml:space="preserve">
          <source>The C like backends will place their temporary &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files in the &lt;code&gt;nimcache&lt;/code&gt; directory. The naming of these files follows the pattern &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;nimcache&lt;/code&gt; подобные C, помещают свои временные файлы &lt;code&gt;.c&lt;/code&gt; , &lt;code&gt;.cpp&lt;/code&gt; или &lt;code&gt;.m&lt;/code&gt; в каталог nimcache . Именование этих файлов соответствует шаблону &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7c1c75d070fdb7254d04b1bbedfea64bf072a3ea" translate="yes" xml:space="preserve">
          <source>The C like targets</source>
          <target state="translated">С как мишени</target>
        </trans-unit>
        <trans-unit id="898583fdf4f7e2148aa36867bf4bb2102ecd496c" translate="yes" xml:space="preserve">
          <source>The CPU this build is running on. Can be different from &lt;code&gt;system.hostCPU&lt;/code&gt; for cross compilations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8208a944d082cd05346b5083e300cf7433b341" translate="yes" xml:space="preserve">
          <source>The CellSet data structure</source>
          <target state="translated">Структура данных CellSet</target>
        </trans-unit>
        <trans-unit id="79e6163dcab816483c82583cef72dec94ae2b158" translate="yes" xml:space="preserve">
          <source>The DOMException interface represents an abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API. Each exception has a name, which is a short &quot;CamelCase&quot; style string identifying the error or abnormal condition. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7d4429a0786a309aa9d6b7928dc3d572fde709" translate="yes" xml:space="preserve">
          <source>The Debian package ships bash and ksh completion and manpages that can be reused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed4e2479ba02a41f340ac876f235bcda842872e" translate="yes" xml:space="preserve">
          <source>The DevkitPro setup must be the same as the default with their new installer &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;here for Mac/Linux&lt;/a&gt; or &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;here for Windows&lt;/a&gt;.</source>
          <target state="translated">Настройка DevkitPro должна быть такой же, как по умолчанию, с их новым установщиком &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;здесь для Mac / Linux&lt;/a&gt; или &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;здесь для Windows&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1008adfd15b693fe20b376424382af8c8cea0aa1" translate="yes" xml:space="preserve">
          <source>The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c27958dc268e2a60ebe42e3d8ceaa6b5e10f68" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversal leads to undefined behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd5b1c0ab5a21a3d6f5ddcb44893f272563ba0a" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversation leads to undefined behaviour.</source>
          <target state="translated">&lt;code&gt;TCellSet&lt;/code&gt; зависит от чрезвычайно эффективной структуры данных для хранения набора указателей - в исходном коде это называется TCellSet . Вставка, удаление и поиск выполняются в постоянное время. Однако изменение &lt;code&gt;TCellSet&lt;/code&gt; во время обхода приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="ebc02645609d7f52fae8aedf8c4c8bf347d64250" translate="yes" xml:space="preserve">
          <source>The GC is only triggered in a memory allocation operation. It is not triggered by some timer and does not run in a background thread.</source>
          <target state="translated">ГХ запускается только в процессе выделения памяти.Он не срабатывает по какому-либо таймеру и не запускается в фоновом потоке.</target>
        </trans-unit>
        <trans-unit id="05815d59fb042a842f4d63bb24b3e64b07d2dee5" translate="yes" xml:space="preserve">
          <source>The GC's way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="translated">Метод GC для измерения времени использует (см. &lt;code&gt;lib/system/timers.nim&lt;/code&gt; в lib / system / timers.nim ):</target>
        </trans-unit>
        <trans-unit id="ea7df501b4189771d55e6aaa674cc650d42d3aa3" translate="yes" xml:space="preserve">
          <source>The Garbage Collector</source>
          <target state="translated">Мусорщик</target>
        </trans-unit>
        <trans-unit id="dcad958e2a5300a34865aa11366e580e6c78767e" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;, &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;, &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;, &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;, and &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; base class.</source>
          <target state="translated">Исключения IEEE либо игнорируются во время выполнения, либо сопоставляются с исключениями Nim: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt; , &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt; , &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt; , &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt; и &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt; . Эти исключения наследуются от базового класса &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="ffdbe4b37fb48c6e771a9c49f384954abf693614" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored during execution or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidopdefect_1&quot;&gt;FloatInvalidOpDefect&lt;/span&gt;, &lt;span id=&quot;floatdivbyzerodefect_1&quot;&gt;FloatDivByZeroDefect&lt;/span&gt;, &lt;span id=&quot;floatoverflowdefect_1&quot;&gt;FloatOverflowDefect&lt;/span&gt;, &lt;span id=&quot;floatunderflowdefect_1&quot;&gt;FloatUnderflowDefect&lt;/span&gt;, and &lt;span id=&quot;floatinexactdefect_1&quot;&gt;FloatInexactDefect&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointdefect_1&quot;&gt;FloatingPointDefect&lt;/span&gt; base class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93e53c09fc19a935940b71534b7f3d3ef1586f6" translate="yes" xml:space="preserve">
          <source>The IEEE standard defines five types of floating-point exceptions:</source>
          <target state="translated">Стандарт IEEE определяет пять типов исключений с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="3a986d0cb1d3a266cf50f1d33d468ab68b62b7e0" translate="yes" xml:space="preserve">
          <source>The JS target is actually &lt;code&gt;node.js&lt;/code&gt;.</source>
          <target state="translated">Мишень JS на самом деле &lt;code&gt;node.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6137eefe505bc68232cc4d0ce7515cc44adc09e" translate="yes" xml:space="preserve">
          <source>The JavaScript target</source>
          <target state="translated">Цель JavaScript</target>
        </trans-unit>
        <trans-unit id="4cbe26954e5cc8b26988852f379eeeef2ae7a95f" translate="yes" xml:space="preserve">
          <source>The JavaScript target doesn't have any further interfacing considerations since it also has garbage collection, but the C targets require you to initialize Nim's internals, which is done calling a &lt;code&gt;NimMain&lt;/code&gt; function. Also, C code requires you to specify a forward declaration for functions or the compiler will assume certain types for the return value and parameters which will likely make your program crash at runtime.</source>
          <target state="translated">Целевой объект JavaScript не имеет дополнительных соображений по взаимодействию, поскольку он также имеет сборку мусора, но целевые объекты C требуют, чтобы вы инициализировали внутренние &lt;code&gt;NimMain&lt;/code&gt; Nim, что выполняется с помощью функции NimMain . Кроме того, код C требует, чтобы вы указали предварительное объявление для функций, иначе компилятор примет определенные типы для возвращаемого значения и параметров, которые, вероятно, вызовут сбой вашей программы во время выполнения.</target>
        </trans-unit>
        <trans-unit id="665d7845877047d3fa57ee16acbc8e493af72754" translate="yes" xml:space="preserve">
          <source>The MinGW-w64 toolchain can be installed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c71fa4398834a6a9a72702a17c78e6eacdbf2bf6" translate="yes" xml:space="preserve">
          <source>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; string type declared in the &lt;code&gt;system&lt;/code&gt; module.</source>
          <target state="translated">Компилятор Nim и большая часть стандартной библиотеки поддерживают режим заражения. Входные строки объявляются строковым типом &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString,&lt;/span&gt; объявленным в &lt;code&gt;system&lt;/code&gt; модуле.</target>
        </trans-unit>
        <trans-unit id="def6a14c368cd75cd8626ee152affd572b2968a4" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="translated">Компилятор Nim может сгенерировать заголовок интерфейса C с помощью &lt;code&gt;--header&lt;/code&gt; командной строки --header . Сгенерированный заголовок будет содержать все экспортированные символы и процесс &lt;code&gt;NimMain&lt;/code&gt; , который вам нужно вызвать перед любым другим кодом Nim.</target>
        </trans-unit>
        <trans-unit id="fd2ac310a54aa34b040fb3ce9d0aae68630ca11b" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command-line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94228688470dadb9d05b8e3aa4652ece8f0668d5" translate="yes" xml:space="preserve">
          <source>The Nim compiler emits different kinds of messages: &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;, &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;, and &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; messages. An &lt;em&gt;error&lt;/em&gt; message is emitted if the compiler encounters any static error.</source>
          <target state="translated">Компилятор Nim выдает разные типы сообщений: &lt;span id=&quot;hint_1&quot;&gt;подсказки&lt;/span&gt; , &lt;span id=&quot;warning_1&quot;&gt;предупреждения&lt;/span&gt; и сообщения &lt;span id=&quot;error_1&quot;&gt;об&lt;/span&gt; ошибках. &lt;em&gt;Ошибка&lt;/em&gt; сообщение испускается , если компилятор встречает любую статическую ошибку.</target>
        </trans-unit>
        <trans-unit id="925789b7eec75edffc7a653892e368b900774bb2" translate="yes" xml:space="preserve">
          <source>The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.</source>
          <target state="translated">Компилятор Nim включает в себя простой решатель линейных уравнений,позволяющий делать выводы о статических параметрах в некоторых ситуациях,когда задействована целочисленная арифметика.</target>
        </trans-unit>
        <trans-unit id="580ec25bc986f0f51e4fc221c0aaeef6db0aa21e" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files that can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone Node.js program&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aad288594b7108c08933546073e4929c7d5707a" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files which can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone nodejs program&lt;/a&gt;.</source>
          <target state="translated">Компилятор Nim поддерживает в основном два семейства серверных программ: цели C, C ++ и Objective-C и цель JavaScript. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;Цели, подобные C,&lt;/a&gt; создают исходные файлы, которые могут быть скомпилированы в библиотеку или окончательный исполняемый файл. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;Целевой объект JavaScript&lt;/a&gt; может сгенерировать файл &lt;code&gt;.js&lt;/code&gt; ,на который вы ссылаетесь из файла HTML, или создать &lt;a href=&quot;http://nodejs.org&quot;&gt;автономную программу nodejs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab9acd635a298ee76edc5f11e47d2fedf88be9db" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports source code filters as a simple yet powerful builtin templating system.</source>
          <target state="translated">Компилятор Nim поддерживает фильтры исходного кода как простую,но мощную систему построения шаблонов.</target>
        </trans-unit>
        <trans-unit id="3b52099df7643f4b981a178452104474413203d0" translate="yes" xml:space="preserve">
          <source>The Nim compiler will handle linking the source files generated in the &lt;code&gt;nimcache&lt;/code&gt; directory into the &lt;code&gt;libfib.nim.a&lt;/code&gt; static library, which you can then link into your C program. Note that these commands are generic and will vary for each system. For instance, on Linux systems you will likely need to use &lt;code&gt;-ldl&lt;/code&gt; too to link in required dlopen functionality.</source>
          <target state="translated">Компилятор Nim будет обрабатывать ссылки на исходные файлы , сгенерированные в &lt;code&gt;nimcache&lt;/code&gt; директории в &lt;code&gt;libfib.nim.a&lt;/code&gt; библиотеки статической, которые затем можно связать в программу C. Обратите внимание, что эти команды являются общими и будут отличаться для каждой системы. Например, в системах Linux вам, вероятно, также потребуется использовать &lt;code&gt;-ldl&lt;/code&gt; для подключения необходимых функций dlopen.</target>
        </trans-unit>
        <trans-unit id="1fdb91e1f0e7364e6a781dd1b11345e2628e4a18" translate="yes" xml:space="preserve">
          <source>The Nim library makes heavy use of overloading - one reason for this is that each operator like &lt;code&gt;+&lt;/code&gt; is just an overloaded proc. The parser lets you use operators in &lt;em&gt;infix notation&lt;/em&gt; (&lt;code&gt;a + b&lt;/code&gt;) or &lt;em&gt;prefix notation&lt;/em&gt; (&lt;code&gt;+ a&lt;/code&gt;). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does &lt;code&gt;a @ @ b&lt;/code&gt; mean &lt;code&gt;(a) @ (@b)&lt;/code&gt; or &lt;code&gt;(a@) @ (b)&lt;/code&gt;? It always means &lt;code&gt;(a) @ (@b)&lt;/code&gt;, because there are no postfix operators in Nim.)</source>
          <target state="translated">Библиотека Nim интенсивно использует перегрузку - одна из причин этого в том, что каждый оператор, например &lt;code&gt;+&lt;/code&gt; , является просто перегруженной процедурой. Анализатор позволяет использовать операторы в &lt;em&gt;инфиксной записи&lt;/em&gt; ( &lt;code&gt;a + b&lt;/code&gt; ) или в &lt;em&gt;префиксной записи&lt;/em&gt; ( &lt;code&gt;+ a&lt;/code&gt; ). Инфиксный оператор всегда получает два аргумента, префиксный оператор всегда один. (Операторы Postfix не представляется возможным, так как это будет неоднозначным: делает &lt;code&gt;a @ @ b&lt;/code&gt; средней &lt;code&gt;(a) @ (@b)&lt;/code&gt; или &lt;code&gt;(a@) @ (b)&lt;/code&gt; это всегда означает? &lt;code&gt;(a) @ (@b)&lt;/code&gt; , потому что постфиксных операторов в ним нет.)</target>
        </trans-unit>
        <trans-unit id="b17c19d995b51a702da47a322eb14c3c3f74d169" translate="yes" xml:space="preserve">
          <source>The Nim manual is a draft that will evolve into a proper specification.</source>
          <target state="translated">Руководство по НИМ-это проект,который будет развиваться в надлежащую спецификацию.</target>
        </trans-unit>
        <trans-unit id="e4eee78d4b7b5546dac0f0bcfd4ab8e0361f503a" translate="yes" xml:space="preserve">
          <source>The Nim programming language has no concept of Posix's signal handling mechanisms. However, the standard library offers some rudimentary support for signal handling, in particular, segmentation faults are turned into fatal errors that produce a stack trace. This can be disabled with the &lt;code&gt;-d:noSignalHandler&lt;/code&gt; switch.</source>
          <target state="translated">В языке программирования Nim нет концепции механизмов обработки сигналов Posix. Однако стандартная библиотека предлагает некоторую элементарную поддержку обработки сигналов, в частности, ошибки сегментации превращаются в фатальные ошибки, приводящие к трассировке стека. Это можно отключить с &lt;code&gt;-d:noSignalHandler&lt;/code&gt; переключателя -d: noSignalHandler .</target>
        </trans-unit>
        <trans-unit id="e3345c6b8f143dcd54f42f93fcf9a202601d5fc9" translate="yes" xml:space="preserve">
          <source>The Nim project's directory structure is:</source>
          <target state="translated">Структура каталогов проекта Nim:</target>
        </trans-unit>
        <trans-unit id="f6e9fcfbb1521eca0d91e310af54c8a9ca576233" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;code&gt;addQuoted&lt;/code&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745ed56715666ebf26c03c8cf5d30717ab67de33" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;em&gt;addQuoted&lt;/em&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="translated">Стандартная библиотека Nim использует эту функцию для элементов коллекций при создании строкового представления коллекции. Рекомендуется использовать эту функцию также для пользовательских коллекций. Пользователи могут перегрузить &lt;em&gt;addQuoted&lt;/em&gt; для пользовательских (строковых) типов, если они хотят реализовать настраиваемое представление элемента.</target>
        </trans-unit>
        <trans-unit id="54b8c6d91ca6a5455af26ed86869eb5c4519994d" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part one deals with the basics.</source>
          <target state="translated">Первая часть учебника &quot;Ним&quot; посвящена основам.</target>
        </trans-unit>
        <trans-unit id="a8d8335d9b3a51e4f9b6b4bc2ad95a64b07b034f" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part three about Nim's macro system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6b7b3f497d2672fe45a7b21b92290089548d77" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part two deals with the advanced language constructs.</source>
          <target state="translated">Во второй части учебника Nim рассматриваются продвинутые языковые конструкции.</target>
        </trans-unit>
        <trans-unit id="b72a9ce64dd38ff10ea38449cca0b32423b2c372" translate="yes" xml:space="preserve">
          <source>The OS this build is running on. Can be different from &lt;code&gt;system.hostOS&lt;/code&gt; for cross compilations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83305965ac9b2ed953b344478f9a769c28c7aba" translate="yes" xml:space="preserve">
          <source>The PEG parser implements this grammar (written in PEG syntax):</source>
          <target state="translated">Парсер PEG реализует эту грамматику (написанную в синтаксисе PEG):</target>
        </trans-unit>
        <trans-unit id="31c92217046cc780ba133dace9f5c246558e7313" translate="yes" xml:space="preserve">
          <source>The SocketHandle associated with the resulting Socket will not be inheritable by child processes by default. This can be changed via the &lt;code&gt;inheritable&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ef66e58383b86b1407d1c272ce0bbbbecb587b" translate="yes" xml:space="preserve">
          <source>The SocketHandle associated with the resulting client will not be inheritable by child processes by default. This can be changed via the &lt;code&gt;inheritable&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7b54829d9f17c2be9946ef0258220a08c1d2b0" translate="yes" xml:space="preserve">
          <source>The System module imports several separate modules, and their documentation is in separate files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5ab7831528adadcc8d1ce6127667976cfbd3e6" translate="yes" xml:space="preserve">
          <source>The ability to access and modify compile-time variables adds flexibility to constant expressions that may be surprising to those coming from other statically typed languages. For example, the following code echoes the beginning of the Fibonacci series &lt;strong&gt;at compile-time&lt;/strong&gt;. (This is a demonstration of flexibility in defining constants, not a recommended style for solving this problem!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5bb6b0158c6a354819839862ad897994206f74" translate="yes" xml:space="preserve">
          <source>The ability to override a hook leads to a phase ordering problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2baf9c90ee9c6afac7ad841487341acef025679" translate="yes" xml:space="preserve">
          <source>The above &lt;code&gt;debug&lt;/code&gt; macro relies on the fact that &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka &lt;span id=&quot;symbols_1&quot;&gt;symbols&lt;/span&gt;) instead of using unbound identifiers. The &lt;code&gt;bindSym&lt;/code&gt; builtin can be used for that:</source>
          <target state="translated">Вышеупомянутый макрос &lt;code&gt;debug&lt;/code&gt; основывается на том факте, что &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeLine&lt;/code&gt; и &lt;code&gt;stdout&lt;/code&gt; объявлены в системном модуле и, следовательно, видны в контексте создания экземпляра. Есть способ использовать связанные идентификаторы (также известные как &lt;span id=&quot;symbols_1&quot;&gt;символы&lt;/span&gt; ) вместо использования несвязанных идентификаторов. Для &lt;code&gt;bindSym&lt;/code&gt; можно использовать встроенную команду bindSym :</target>
        </trans-unit>
        <trans-unit id="9a16d09084424b9bb5554f6882e18d7b658ef4d4" translate="yes" xml:space="preserve">
          <source>The above code fails with the error message that &lt;code&gt;p&lt;/code&gt; is not declared. The reason for this is that the &lt;code&gt;p()&lt;/code&gt; body is type-checked before getting passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed87b5819ca0a50089cd2bf1bad97ce7b0637b5f" translate="yes" xml:space="preserve">
          <source>The above code fails with the mysterious error message that &lt;code&gt;i&lt;/code&gt; has already been declared. The reason for this is that the &lt;code&gt;var i = ...&lt;/code&gt; bodies need to be type-checked before they are passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed &lt;code&gt;i&lt;/code&gt; needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="translated">Приведенный выше код выдает сообщение об ошибке загадочного , что &lt;code&gt;i&lt;/code&gt; уже был объявлен. Причина этого в том, что тела &lt;code&gt;var i = ...&lt;/code&gt; должны быть проверены на тип, прежде чем они будут переданы в параметр &lt;code&gt;body&lt;/code&gt; , а проверка типа в Nim подразумевает поиск символов. Для успешного поиска символов &lt;code&gt;i&lt;/code&gt; нужно добавить в текущую (т.е. внешнюю) область видимости. После проверки типа эти добавления в таблицу символов не откатываются (к лучшему или худшему). Тот же код работает с &lt;code&gt;untyped&lt;/code&gt; поскольку переданное тело не требует проверки типа:</target>
        </trans-unit>
        <trans-unit id="b3982101b8689b140d25aa17cb82ea30c138360e" translate="yes" xml:space="preserve">
          <source>The above code outputs:</source>
          <target state="translated">Вышеуказанные кодовые выходы:</target>
        </trans-unit>
        <trans-unit id="dc4bda02bd351eb1e53dd407e05088912ae083f6" translate="yes" xml:space="preserve">
          <source>The above example will fail, to ensure c2nim &lt;em&gt;processes&lt;/em&gt; these defines and expands them, use c2nim's &lt;code&gt;#def&lt;/code&gt; directive:</source>
          <target state="translated">В приведенном выше примере произойдет сбой, чтобы гарантировать, что c2nim &lt;em&gt;обрабатывает&lt;/em&gt; эти определения и расширяет их, используйте директиву c2nim &lt;code&gt;#def&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af1747a46fc4da26a624c04d36cc94dfd97e3023" translate="yes" xml:space="preserve">
          <source>The above module exports &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, but not &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Вышеупомянутый модуль экспортирует &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;*&lt;/code&gt; , но не &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2164536ddfd6de29510303b3ffa83bdfffcb08d5" translate="yes" xml:space="preserve">
          <source>The above output could be the result of a code snippet like:</source>
          <target state="translated">Вышеуказанный вывод может быть результатом такого фрагмента кода как:</target>
        </trans-unit>
        <trans-unit id="250cc0bde21eb567c889e1e1664f7d10ce17f191" translate="yes" xml:space="preserve">
          <source>The abstract base type of all loggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3921e4649d03a4f2c2e0f1f2787d19741635bd73" translate="yes" xml:space="preserve">
          <source>The access to field &lt;code&gt;x.v&lt;/code&gt; is allowed since its guard &lt;code&gt;x.L&lt;/code&gt; is active. After template expansion, this amounts to:</source>
          <target state="translated">Доступ к полю &lt;code&gt;x.v&lt;/code&gt; разрешен, так как его защита &lt;code&gt;x.L&lt;/code&gt; активна. После расширения шаблона это составляет:</target>
        </trans-unit>
        <trans-unit id="8dd5c61046585195d0c3e2c466315972a1789d8b" translate="yes" xml:space="preserve">
          <source>The addr operator</source>
          <target state="translated">Оператор аддера</target>
        </trans-unit>
        <trans-unit id="d8dbffc47ece2be660786dac5e5599bb2db4ec50" translate="yes" xml:space="preserve">
          <source>The algorithm behind this analysis is described in the &lt;a href=&quot;#view-types-algorithm&quot;&gt;view types section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c16d3733ab5de84d13321ea183405e627ced8c0" translate="yes" xml:space="preserve">
          <source>The algorithm for compiling modules is:</source>
          <target state="translated">Алгоритм компиляции модулей таков:</target>
        </trans-unit>
        <trans-unit id="7735ffef84f6b2ad890f11a7dd0ee082beb33ad5" translate="yes" xml:space="preserve">
          <source>The algorithm is based on the theory of continued fractions.</source>
          <target state="translated">Алгоритм основан на теории непрерывных дробей.</target>
        </trans-unit>
        <trans-unit id="7b81a299b4d6a7c6527f2f9089e8efaf8aa777c1" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3c558bc48c770919c504ee5c6a21e8e07e4d60" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#allocShared0,Natural&quot;&gt;allocShared0&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e743ac1a73193134433b9e2665ee58685338dd" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#createShared,typedesc&quot;&gt;createShared&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3aa58ae727a722325206dd1c096f46b46d2c14b" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c822d98d0919ddf989461e7416cedbec8f1ed4d7" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared&lt;/a&gt; to reallocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d2e95c77763501f5d08aba1067373c7bd297c8" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared&lt;/a&gt; to reallocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e814504ef907959dbfcf0c83b97cf43f9dcf6be" translate="yes" xml:space="preserve">
          <source>The amount of available functions is much larger. Use the table of contents on the left-hand side and/or &lt;code&gt;Ctrl+F&lt;/code&gt; to navigate through this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ba690f34c8a341aefa7154f4cab877c7806570" translate="yes" xml:space="preserve">
          <source>The amount of inserted spaces for each tab character is the difference between the current column number and the next tab position. Tab positions occur every &lt;code&gt;tabSize&lt;/code&gt; characters. The column number starts at 0 and is increased with every single character and inserted space, except for newline, which resets the column number back to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250c5ff56778e008023b7651ae2048c87b91ec39" translate="yes" xml:space="preserve">
          <source>The analysis is currently control flow insensitive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b75eefe3dbc4504e1b5e9c31e816f67ebe1b353" translate="yes" xml:space="preserve">
          <source>The analysis requires as much precision about mutations as is reasonably obtainable, so it is more effective with the experimental &lt;a href=&quot;#strict-funcs&quot;&gt;strict funcs&lt;/a&gt; feature. In other words &lt;code&gt;--experimental:views&lt;/code&gt; works better with &lt;code&gt;--experimental:strictFuncs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb382e7222271bd8b9818e2c22f1b22c1d23882" translate="yes" xml:space="preserve">
          <source>The assignment of a location that is derived from a local parameter to a view-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ef3590f8b622cbd763976b293e8b5be0c43bea" translate="yes" xml:space="preserve">
          <source>The assignment of a non-view-type to a view-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d614f17a9f1bd45756a257161f52b39079cec7a1" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings always copies the string. The &lt;code&gt;&amp;amp;&lt;/code&gt; operator concatenates strings.</source>
          <target state="translated">Оператор присваивания для строк всегда копирует строку. Оператор &lt;code&gt;&amp;amp;&lt;/code&gt; объединяет строки.</target>
        </trans-unit>
        <trans-unit id="7d2817b98254430aea892c64ac0086b7f62a2214" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings copies the string. You can use the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to concatenate strings and &lt;code&gt;add&lt;/code&gt; to append to a string.</source>
          <target state="translated">Оператор присваивания для строк копирует строку. Вы можете использовать оператор &lt;code&gt;&amp;amp;&lt;/code&gt; для объединения строк и &lt;code&gt;add&lt;/code&gt; для добавления к строке.</target>
        </trans-unit>
        <trans-unit id="e76741ef0154f25492ed64d08d5e8f9a5bb9a741" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described &lt;a href=&quot;manual_experimental#type-bound-operations&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb716b99b45cbb4781636530d6cc58814ca4c5cf" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described in &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt;.</source>
          <target state="translated">Оператор присваивания для кортежей копирует каждый компонент. Оператор присваивания по умолчанию для объектов копирует каждый компонент. Перегрузка оператора присваивания описана в &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad5e1062fa49239262e20658b8eefbafc9c44097" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The notation &lt;code&gt;t.field&lt;/code&gt; is used to access a tuple's field. Another notation is &lt;code&gt;t[i]&lt;/code&gt; to access the &lt;code&gt;i&lt;/code&gt;'th field. Here &lt;code&gt;i&lt;/code&gt; must be a constant integer.</source>
          <target state="translated">Оператор присваивания для кортежей копирует каждый компонент. Обозначение &lt;code&gt;t.field&lt;/code&gt; используется для доступа к полю кортежа. Другое обозначение - &lt;code&gt;t[i]&lt;/code&gt; для доступа к &lt;code&gt;i&lt;/code&gt; -му полю. Здесь &lt;code&gt;i&lt;/code&gt; должно быть постоянным целым числом.</target>
        </trans-unit>
        <trans-unit id="804f01a733a67cfcf057f33e60859ec41e2582ef" translate="yes" xml:space="preserve">
          <source>The assignment operator needs to be attached to an object or distinct type &lt;code&gt;T&lt;/code&gt;. Its signature has to be &lt;code&gt;(var T, T)&lt;/code&gt;. Example:</source>
          <target state="translated">Оператор присваивания должен быть прикреплен к объекту или отдельного типа &lt;code&gt;T&lt;/code&gt; . Его подпись должна быть &lt;code&gt;(var T, T)&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="57e23a9b21d323dac48595a4bbc01b14afe5e195" translate="yes" xml:space="preserve">
          <source>The assignment statement</source>
          <target state="translated">Заявление о назначении</target>
        </trans-unit>
        <trans-unit id="69e1ab703b32f93b8ef72d294804a9cde1a4f4f9" translate="yes" xml:space="preserve">
          <source>The assignment statement assigns a new value to a variable or more generally to a storage location:</source>
          <target state="translated">Оператор присваивания присваивает новое значение переменной или,в более общем случае,месту хранения:</target>
        </trans-unit>
        <trans-unit id="d73476dc2a350d437b107b771d2828a4abae111d" translate="yes" xml:space="preserve">
          <source>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</source>
          <target state="translated">Диспетчер по асинхронизации внедряет систему проакторов,а также осуществляет ИОКП.Он реализует проакторную модель для других ОС через модуль селекторов.Здесь также осуществляется будущее,и все процедуры возвращаются в будущее.</target>
        </trans-unit>
        <trans-unit id="b8f9435ff6dfbae860f91fa36f9f0b5fbb9f39e8" translate="yes" xml:space="preserve">
          <source>The available floating point presentation types are:</source>
          <target state="translated">Доступные типы презентаций с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="translated">Доступны целые типы представления:</target>
        </trans-unit>
        <trans-unit id="79db556b1fc1486c80abc68c65a3dd21e5851952" translate="yes" xml:space="preserve">
          <source>The backend must have some logic so that if the currently processed module is from the compilation cache, the &lt;code&gt;ast&lt;/code&gt; field is not accessed. Instead the generated C(++) for the symbol's body needs to be cached too and inserted back into the produced C file. This approach seems to deal with all the outlined problems above.</source>
          <target state="translated">Бэкэнд должен иметь некоторую логику, чтобы, если в настоящее время обрабатываемый модуль находится из кеша компиляции, доступ к полю &lt;code&gt;ast&lt;/code&gt; не выполнялся. Вместо этого сгенерированный C (++) для тела символа также необходимо кэшировать и вставлять обратно в созданный файл C. Такой подход, кажется, решает все перечисленные выше проблемы.</target>
        </trans-unit>
        <trans-unit id="ac450c1d36f3fc4bcff981788349d27816a68afe" translate="yes" xml:space="preserve">
          <source>The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.</source>
          <target state="translated">Базовый тип непроверенного массива может не содержать памяти GC'ed,но на данный момент он не проверяется.</target>
        </trans-unit>
        <trans-unit id="179771803cf0c16d91d22dfc5e7584351c3201db" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferred Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance (and easier C code generation). Cycle detection is currently done by a simple mark&amp;amp;sweep GC that has to scan the full (thread local heap). &lt;code&gt;--gc:v2&lt;/code&gt; replaces this with an incremental mark and sweep. That it is not production ready yet, however.</source>
          <target state="translated">Базовый алгоритм - &lt;em&gt;отсроченный подсчет ссылок&lt;/em&gt; с обнаружением цикла. Ссылки в стеке не учитываются для повышения производительности (и упрощения генерации кода C). Обнаружение цикла в настоящее время выполняется простым сборщиком мусора mark &amp;amp; ​​sweep, который должен сканировать всю (локальную кучу потока). &lt;code&gt;--gc:v2&lt;/code&gt; заменяет это на инкрементную метку и развертку. Однако он еще не готов к производству.</target>
        </trans-unit>
        <trans-unit id="6d21aca78505b578689d1824dee245b0be8d52e9" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferrent Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance and easier C code generation.</source>
          <target state="translated">Базовый алгоритм - &lt;em&gt;отсроченный подсчет ссылок&lt;/em&gt; с обнаружением цикла. Ссылки в стеке не учитываются для повышения производительности и упрощения генерации кода C.</target>
        </trans-unit>
        <trans-unit id="29593df455bce4317b1e8d46d66107a58482465b" translate="yes" xml:space="preserve">
          <source>The basic flow of using this module is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e318808654d94079517579df63094331b22821" translate="yes" xml:space="preserve">
          <source>The binary &lt;code&gt;^*&lt;/code&gt; operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise &lt;code&gt;^+&lt;/code&gt; means 1 or more occurrences: &lt;code&gt;a ^+ b&lt;/code&gt; is short for &lt;code&gt;a (b a)*&lt;/code&gt; and &lt;code&gt;a ^* b&lt;/code&gt; is short for &lt;code&gt;(a (b a)*)?&lt;/code&gt;. Example:</source>
          <target state="translated">Двоичный оператор &lt;code&gt;^*&lt;/code&gt; используется как сокращение для 0 или более вхождений, разделенных вторым аргументом; аналогично &lt;code&gt;^+&lt;/code&gt; означает 1 или несколько вхождений: &lt;code&gt;a ^+ b&lt;/code&gt; - сокращение от &lt;code&gt;a (b a)*&lt;/code&gt; а &lt;code&gt;a ^* b&lt;/code&gt; - сокращение от &lt;code&gt;(a (b a)*)?&lt;/code&gt; , Пример:</target>
        </trans-unit>
        <trans-unit id="838b0fbf81e65abd3b1ad6c600113a2fed59e81e" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#alloc,Natural&quot;&gt;alloc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5d0d575da00922903cac607fb2fd96251ac2cd" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3840b5815b476e7ad0468e337f35e7346b451d5" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared(block, 0)&lt;/a&gt; or &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared(block)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98353e7ce043623f414d9bb91bad41b576de19e8" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#createU,typedesc&quot;&gt;createU&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37a54c51ba932ce88795fda3d2a30d0c461cb79" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068999f6f652deacdb3f97d6673d5b7e6baf16cf" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared(block, 0)&lt;/a&gt; or &lt;a href=&quot;#freeShared,ptr.T&quot;&gt;freeShared(block)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a4b678bcf75d497dac75a45beb59d65212247d" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b5f58aae87fa158997bda888132721756d3cb4f" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47a24f074a3169393ff9b7055c7a12a147a3601" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer then realloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81438262b2b429a9e9625da21fde5d6db74d0bb7" translate="yes" xml:space="preserve">
          <source>The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ef37192c4c3ac0d1a132ff61857597f3ebc82a" translate="yes" xml:space="preserve">
          <source>The block statement is a means to group statements to a (named) &lt;code&gt;block&lt;/code&gt;. Inside the block, the &lt;code&gt;break&lt;/code&gt; statement is allowed to leave the block immediately. A &lt;code&gt;break&lt;/code&gt; statement can contain a name of a surrounding block to specify which block is to leave.</source>
          <target state="translated">Оператор блока - это средство группировки операторов в (именованный) &lt;code&gt;block&lt;/code&gt; . Внутри блока оператору &lt;code&gt;break&lt;/code&gt; разрешено немедленно покинуть блок. &lt;code&gt;break&lt;/code&gt; заявление может содержать имя окружающего блока , чтобы указать , какой блок должен уйти.</target>
        </trans-unit>
        <trans-unit id="4ac080ff8c42136d469aa9618ca8dd14a7c9497c" translate="yes" xml:space="preserve">
          <source>The block's &lt;em&gt;label&lt;/em&gt; (&lt;code&gt;myblock&lt;/code&gt; in the example) is optional.</source>
          <target state="translated">&lt;em&gt;Метка&lt;/em&gt; блока ( в примере - &lt;code&gt;myblock&lt;/code&gt; ) необязательна.</target>
        </trans-unit>
        <trans-unit id="390a433a85fe95c30ff748c4a4396344238da974" translate="yes" xml:space="preserve">
          <source>The boolean type is named &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; in Nim and can be one of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elif&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;-statements need to be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Логический тип в Nim называется &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; и может быть одним из двух предопределенных значений &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; . Условия в &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;elif&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; -statements должны быть типа &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2ce9bd7c5f1b8affcc95224634c4003923668d" translate="yes" xml:space="preserve">
          <source>The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:</source>
          <target state="translated">Прагматика заимствования может также использоваться для аннотирования особого типа,позволяющего проводить определенные строительные работы:</target>
        </trans-unit>
        <trans-unit id="be92dcebf622da6178429443f44552a8ca5101d2" translate="yes" xml:space="preserve">
          <source>The bounds &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; denote the indices of the first and last characters that shall be copied. If &lt;code&gt;last&lt;/code&gt; is omitted, it is treated as &lt;code&gt;high(s)&lt;/code&gt;. If &lt;code&gt;last &amp;gt;= s.len&lt;/code&gt;, &lt;code&gt;s.len&lt;/code&gt; is used instead: This means &lt;code&gt;substr&lt;/code&gt; can also be used to &lt;span id=&quot;cut_1&quot;&gt;cut&lt;/span&gt; or &lt;span id=&quot;limit_1&quot;&gt;limit&lt;/span&gt; a string's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f277ec78fce68a5d9247ac9d7120e37c595d4513" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc returns the array's length. &lt;a href=&quot;system#low&quot;&gt;low(a)&lt;/a&gt; returns the lowest valid index for the array &lt;em&gt;a&lt;/em&gt; and &lt;a href=&quot;system#high&quot;&gt;high(a)&lt;/a&gt; the highest valid index.</source>
          <target state="translated">Встроенная процедура &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; возвращает длину массива. &lt;a href=&quot;system#low&quot;&gt;low (a)&lt;/a&gt; возвращает самый низкий допустимый индекс для массива &lt;em&gt;a,&lt;/em&gt; а &lt;a href=&quot;system#high&quot;&gt;high (a) -&lt;/a&gt; самый высокий допустимый индекс.</target>
        </trans-unit>
        <trans-unit id="9840f844923cc10024352c7ba0b3ff45a4914dcf" translate="yes" xml:space="preserve">
          <source>The builtin 'system.locals' implemented as a plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f452d59ca97170597b758692a3b42390c25047e4" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-amp-spawn-spawn-statement&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9933530b06a29cb28167851eb7193a2ebfd89d2" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="translated">Встроенный &lt;code&gt;deepCopy&lt;/code&gt; может даже клонировать затворы и их окружение. Подробности смотрите в документации по &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18e36e8445862a6742d9876a1c8ed0b253932bec" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;system.finished&lt;/code&gt; can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</source>
          <target state="translated">Встроенный &lt;code&gt;system.finished&lt;/code&gt; может быть использовано , чтобы определить , является ли итератор закончил свою работу; при попытке вызвать итератор, который уже завершил свою работу, исключение не возникает.</target>
        </trans-unit>
        <trans-unit id="d3ed05fd4188503b5e918e419071d83535ca6d73" translate="yes" xml:space="preserve">
          <source>The builtin document generator &lt;code&gt;nim doc&lt;/code&gt; generates HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files.</source>
          <target state="translated">Встроенный генератор документов &lt;code&gt;nim doc&lt;/code&gt; генерирует HTML-документацию из исходных файлов &lt;code&gt;.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1be5bb95f8a163c45d73b2bf4f448ad5d41520b0" translate="yes" xml:space="preserve">
          <source>The cache is discarded and disabled. The GC will reuse its used memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc2df4285e7ce4148cd07c10af838b3599131c2" translate="yes" xml:space="preserve">
          <source>The caching of modules is critical for 'nimsuggest' and is tricky to get right. If module E is being edited, we need autocompletion (and type checking) for E but we don't want to recompile depending modules right away for faster turnaround times. Instead we mark the module's dependencies as 'dirty'. Let D be a dependency of E. If D is dirty, we need to recompile it and all of its dependencies that are marked as 'dirty'. 'nimsuggest sug' actually is invoked for the file being edited so we know its content changed and there is no need to compute any checksums. Instead of a recursive algorithm, we use an iterative algorithm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fee63106f29dd5e46e2f5ccdba0d7bbe8184064" translate="yes" xml:space="preserve">
          <source>The call can be made more like an inline iterator with a for loop macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f6f784af17f7bc54b3aa6aaca5046f4b889d50" translate="yes" xml:space="preserve">
          <source>The callback is also called when the future is completed. So you should use &lt;code&gt;finished&lt;/code&gt; to check whether data is available.</source>
          <target state="translated">Обратный вызов также вызывается, когда будущее завершено. Таким образом , вы должны использовать &lt;code&gt;finished&lt;/code&gt; , чтобы проверить , является ли данные.</target>
        </trans-unit>
        <trans-unit id="fda0db03a44323f53881c6ed07ea62221c4d40ac" translate="yes" xml:space="preserve">
          <source>The callback should return one of:</source>
          <target state="translated">Обратный звонок должен вернуть один из них:</target>
        </trans-unit>
        <trans-unit id="98431101a07bff81af63ae772b99a639ecfd446d" translate="yes" xml:space="preserve">
          <source>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</source>
          <target state="translated">Символ каретты (^)не распознается как экранирующий или разделительный символ.Символ полностью обрабатывается парсером командной строки в операционной системе перед передачей в массив argv в программе.</target>
        </trans-unit>
        <trans-unit id="275705377e0dee3785eb3e50c9fe458fd4e6307b" translate="yes" xml:space="preserve">
          <source>The case statement can deal with integers, other ordinal types and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:</source>
          <target state="translated">Оператор регистра может работать с целыми числами,другими порядковыми типами и строками.(То,что является порядковым типом,скоро будет объяснено.)Для целых чисел или других порядковых типов также возможны диапазоны значений:</target>
        </trans-unit>
        <trans-unit id="694081c9ba0ead71a23be29d98b9511f2e2c1da7" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under Windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb06e2eb10f97945a6a1dc769debf11f66cc02b" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="translated">Соглашение cdecl означает, что процедура должна использовать то же соглашение, что и компилятор C. В Windows сгенерированная процедура C объявляется с &lt;code&gt;__cdecl&lt;/code&gt; словом __cdecl .</target>
        </trans-unit>
        <trans-unit id="058accd23038c62c41c53cefc9d097f2c415abea" translate="yes" xml:space="preserve">
          <source>The chaining of functions is possible thanks to the &lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;method call syntax&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e298a10b48b62e2a169d6c44a14daf34ceeedd" translate="yes" xml:space="preserve">
          <source>The chaining of functions is possible thanks to the &lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;method call syntax&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08aa4b50d816fd45a3310fdfe9be5b22b53c8981" translate="yes" xml:space="preserve">
          <source>The change is permanent for the rest of the execution, since this is just a shortcut for &lt;a href=&quot;os#setCurrentDir,string&quot;&gt;os.setCurrentDir()&lt;/a&gt; . Use the &lt;a href=&quot;#withDir.t,string,untyped&quot;&gt;withDir()&lt;/a&gt; template if you want to perform a temporary change only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2d21d3ec49f1b953444178b23232a5b0355231" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as ':' for POSIX or ';' for Windows.</source>
          <target state="translated">Символ,обычно используемый операционной системой для разделения компонентов поиска заплаток (как в PATH),таких как ':' для POSIX или ';' для Windows.</target>
        </trans-unit>
        <trans-unit id="67cdf84dfd1fc80d813d4abe30055e39e2a1d442" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as &lt;code&gt;':'&lt;/code&gt; for POSIX or &lt;code&gt;';'&lt;/code&gt; for Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db4c48c729604a1469a45dd9f280c6186f2d6305" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent a UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was especially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;code&gt;Rune&lt;/code&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf14d8e5ee092bdea92e4c3639c4ffbc471a82f" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">Тип &lt;code&gt;char&lt;/code&gt; в ним называется char . Его размер - один байт. Таким образом, он не может представлять символ UTF-8, а является его частью. Причина этого - эффективность: в подавляющем большинстве случаев использования результирующие программы по-прежнему будут правильно обрабатывать UTF-8, поскольку UTF-8 был специально разработан для этого. Другая причина в том, что Nim может эффективно поддерживать &lt;code&gt;array[char, int]&lt;/code&gt; или &lt;code&gt;set[char]&lt;/code&gt; поскольку многие алгоритмы полагаются на эту функцию. Тип &lt;em&gt;Rune&lt;/em&gt; используется для символов Unicode, он может представлять любой символ Unicode. &lt;code&gt;Rune&lt;/code&gt; объявлена ​​в &lt;a href=&quot;unicode&quot;&gt;модуле юникода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="012338159832c9f5b5b221070a9909e38b48330b" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example, '/' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">Символ,используемый операционной системой для разделения патнаментных компонентов,например,'/' для POSIX или ':' для классического Macintosh.</target>
        </trans-unit>
        <trans-unit id="25e189a51726217bd10306adb62ab204d17e2719" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example: &lt;code&gt;'/'&lt;/code&gt; for POSIX, &lt;code&gt;':'&lt;/code&gt; for the classic Macintosh, and &lt;code&gt;'\'&lt;/code&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8595c8efa2aa083f52c712e47adba9de6178e714" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the '.' in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="translated">Символ, отделяющий базовое имя файла от расширения; например, &quot;.&quot; в &lt;code&gt;os.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0eb96dc2f00e727210b0dc83b639e0b79d1c8c58" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the &lt;code&gt;'.'&lt;/code&gt; in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0adad1955b78ddab6f74ee977c388f8e7ad21e" translate="yes" xml:space="preserve">
          <source>The choice of style is up to you.</source>
          <target state="translated">Выбор стиля зависит от вас.</target>
        </trans-unit>
        <trans-unit id="4f81018fe48bb50b55f71f19831d2854f946c504" translate="yes" xml:space="preserve">
          <source>The circle constant PI (Ludolph's number)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88109739e49227795120221865f1a6d8d83ffb4e" translate="yes" xml:space="preserve">
          <source>The circle constant TAU (= 2 * PI)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9025711d3d5dd3e200b0d5ab31809d3ae89c7a5" translate="yes" xml:space="preserve">
          <source>The client data field is used by the HTML parser and generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f0b6da6c7f59b81902fe7eaf3cc327e7160fa5" translate="yes" xml:space="preserve">
          <source>The closing &lt;code&gt;@#&lt;/code&gt; needs to be on a line of its own, only preceeded by optional whitespace. This way &lt;code&gt;@#&lt;/code&gt; can otherwise occur in the Nim code as the example shows.</source>
          <target state="translated">Закрывающий &lt;code&gt;@#&lt;/code&gt; должен находиться в отдельной строке, только перед ним должен стоять необязательный пробел. В противном случае &lt;code&gt;@#&lt;/code&gt; может появиться в коде Nim, как показано в примере.</target>
        </trans-unit>
        <trans-unit id="c2a6d13754b9070007f419ad05ea1ed9a30039c9" translate="yes" xml:space="preserve">
          <source>The code contains a confusing &lt;code&gt;var&lt;/code&gt; declaration.</source>
          <target state="translated">Код содержит запутанное объявление &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27b7a967cf2c61e046012b3021e3386a2439d280" translate="yes" xml:space="preserve">
          <source>The code contains an unsupported octal sequence.</source>
          <target state="translated">Код содержит неподдерживаемую восьмеричную последовательность.</target>
        </trans-unit>
        <trans-unit id="6648d68a40326bd32903c1e98c224eb206ee30b9" translate="yes" xml:space="preserve">
          <source>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</source>
          <target state="translated">Функция переупорядочивания кода может неявно переставлять определения процедур,шаблонов и макросов вместе с объявлениями переменных и инициализациями на верхнем уровне,так что программисту в значительной степени не нужно беспокоиться о правильном упорядочивании определений или быть вынужденным использовать прямые объявления для определений предисловий внутри модуля.</target>
        </trans-unit>
        <trans-unit id="fd31996b685a939214cab476b507369c2a26dbe0" translate="yes" xml:space="preserve">
          <source>The code uses a deprecated symbol.</source>
          <target state="translated">В коде используется устаревший символ.</target>
        </trans-unit>
        <trans-unit id="cadbefb6d63605ada88260c0953028138c9935e0" translate="yes" xml:space="preserve">
          <source>The coercion &lt;code&gt;type(x)&lt;/code&gt; can be used to obtain the type of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Принуждения &lt;code&gt;type(x)&lt;/code&gt; может быть использован для получения типа данного выражения &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21a01b95e07874cdea952698896961c01561234b" translate="yes" xml:space="preserve">
          <source>The collector checks whether there is still time left for its work after every &lt;code&gt;workPackage&lt;/code&gt;'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus &lt;code&gt;workPackage&lt;/code&gt; affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.</source>
          <target state="translated">После каждой &lt;code&gt;workPackage&lt;/code&gt; сборщик проверяет, осталось ли время для его работы . В настоящее время установлено значение 100, что означает, что до 100 объектов проходят и освобождаются перед повторной проверкой. Таким образом, &lt;code&gt;workPackage&lt;/code&gt; влияет на детализацию синхронизации и может потребовать настройки в узкоспециализированных средах или для более старого оборудования.</target>
        </trans-unit>
        <trans-unit id="79afdb7f6889da26e189c0f3c33044a04e18d142" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. The (&lt;a href=&quot;#do-notation&quot;&gt;do notation&lt;/a&gt;) is limited, but usable for a single proc (see the example in the corresponding section). Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</source>
          <target state="translated">Синтаксис вызова команды также не может иметь в качестве аргументов сложные выражения. Например: ( &lt;a href=&quot;#anonymous-procs&quot;&gt;анонимные процедуры&lt;/a&gt; ), &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; или &lt;code&gt;try&lt;/code&gt; . &lt;a href=&quot;#do-notation&quot;&gt;Обозначение&lt;/a&gt; ( do ) ограничено, но может использоваться для одного процесса (см. Пример в соответствующем разделе). Для вызовов функций без аргументов по-прежнему требуется (), чтобы различать вызов и саму функцию как значение первого класса.</target>
        </trans-unit>
        <trans-unit id="b7e98bb35328ac84f0a9e89f36fd4180318f1d00" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#procedures-anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. Function calls with no arguments still need () to distinguish between a call and the function itself as a first-class value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb3a5b11c8c58cd3db6e75b060c5cb1256d4072" translate="yes" xml:space="preserve">
          <source>The commands to compile to either C, C++ or Objective-C are:</source>
          <target state="translated">Команды для компиляции либо на C,либо на C++или на Objective-C:</target>
        </trans-unit>
        <trans-unit id="9147d3666608b3555f82a0b1ee6751419dc98de6" translate="yes" xml:space="preserve">
          <source>The common &lt;code&gt;--&lt;/code&gt; non-option argument delimiter appears as an empty string long option key. &lt;code&gt;OptParser.cmd&lt;/code&gt;, &lt;code&gt;OptParser.pos&lt;/code&gt;, and &lt;code&gt;os.parseCmdLine&lt;/code&gt; may be used to complete parsing in that case.</source>
          <target state="translated">Распространенный &lt;code&gt;--&lt;/code&gt; не параметр аргумент Разделитель выглядит как пустая строка ключ длинного варианта. &lt;code&gt;OptParser.cmd&lt;/code&gt; этом случае для завершения синтаксического анализа можно использовать OptParser.cmd , &lt;code&gt;OptParser.pos&lt;/code&gt; и &lt;code&gt;os.parseCmdLine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdfd6148988703a688e3c05eca6a8eff773759f" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for floats and follow the IEEE-754 standard.</source>
          <target state="translated">Общие операторы &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; Определены для чисел с плавающей запятой и соответствуют стандарту IEEE-754.</target>
        </trans-unit>
        <trans-unit id="883abbd0b16cdebab167565d80838c6044a1fcf0" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for integers. The &lt;code&gt;and or xor not&lt;/code&gt; operators are also defined for integers, and provide &lt;em&gt;bitwise&lt;/em&gt; operations. Left bit shifting is done with the &lt;code&gt;shl&lt;/code&gt;, right shifting with the &lt;code&gt;shr&lt;/code&gt; operator. Bit shifting operators always treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;. For &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;arithmetic bit shifts&lt;/span&gt; ordinary multiplication or division can be used.</source>
          <target state="translated">Общие операторы &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; Определены для целых чисел. Операторы &lt;code&gt;and or xor not&lt;/code&gt; также определены для целых чисел и обеспечивают &lt;em&gt;побитовые&lt;/em&gt; операции. Битовый сдвиг влево выполняется с &lt;code&gt;shl&lt;/code&gt; оператора shl , сдвиг вправо - с помощью оператора &lt;code&gt;shr&lt;/code&gt; . Операторы битового сдвига всегда обрабатывают свои аргументы как &lt;em&gt;беззнаковые&lt;/em&gt; . Для &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;арифметических битовых сдвигов&lt;/span&gt; можно использовать обычное умножение или деление.</target>
        </trans-unit>
        <trans-unit id="93c350055cc7a991a83791a66ef96ae8da82f094" translate="yes" xml:space="preserve">
          <source>The compiler checks that each parameter receives exactly one argument.</source>
          <target state="translated">Компилятор проверяет,что каждый параметр получает ровно один аргумент.</target>
        </trans-unit>
        <trans-unit id="124083caaf9e67c2924ff4ad019f8bdbdc5c26c4" translate="yes" xml:space="preserve">
          <source>The compiler checks the semantics and produces code &lt;em&gt;only&lt;/em&gt; for the statements that belong to the first condition that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Компилятор проверяет семантику и создает код &lt;em&gt;только&lt;/em&gt; для операторов, принадлежащих первому условию, которое оценивается как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47314c2a3c9cb869c3d9611f5dd9ca92a7d73b2a" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#cross-compilation&quot;&gt;specify additional switches for cross compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="translated">Команды компилятора выбирают целевой бэкэнд, но при необходимости вы можете &lt;a href=&quot;nimc#cross-compilation&quot;&gt;указать дополнительные переключатели для кросс-компиляции,&lt;/a&gt; чтобы выбрать целевой ЦП, операционную систему или команды компилятора / компоновщика.</target>
        </trans-unit>
        <trans-unit id="0bf4f876ba614fab0251ca447032e9c4223c202b" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#crossminuscompilation&quot;&gt;specify additional switches for cross-compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2e3df2d7fda7fee4989683f7777bad3866a03e" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93170a1da8e409d02256d9f99c47fbb958d19414" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">Компилятор зависит от системного модуля для правильной работы, а системный модуль зависит от компилятора. Большинство перечисленных здесь подпрограмм используют особую магию компилятора. Каждый модуль неявно импортирует модуль System; он не должен указываться явно. Из-за этого не может быть определяемого пользователем модуля с именем &lt;code&gt;system&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20fd635c293115e7e5e8cbd64caf63eed7e31f4f" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="translated">Компилятор гарантирует,что каждый путь кода инициализирует переменные,содержащие не нулевые указатели.Подробности данного анализа еще предстоит уточнить здесь.</target>
        </trans-unit>
        <trans-unit id="fcd92bbcd58119a3a0ac02288b0174193fcb4cee" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non-nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c9adfb2c991d20ede8d4667f6a86d41c673563e" translate="yes" xml:space="preserve">
          <source>The compiler executes the macro body (which may invoke other procs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24838b6da70bcf6db067073b75a8fadd6fa3eb45" translate="yes" xml:space="preserve">
          <source>The compiler generates code as if the programmer would have written this:</source>
          <target state="translated">Компилятор генерирует код так,как будто это написал бы программист:</target>
        </trans-unit>
        <trans-unit id="4b55dae2064aca45aa89b0fcdf2d09a19bcd4f27" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:danger&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fae9d1a9ed8aeef0ae7bee39888a86acbeeaae5" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:release&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="translated">Компилятор может вообще не сгенерировать какой-либо код для &lt;code&gt;assert&lt;/code&gt; , если это рекомендуется сделать с помощью параметров &lt;a href=&quot;nimc#command-line-switches&quot;&gt;командной строки &lt;/a&gt; &lt;code&gt;-d:release&lt;/code&gt; или &lt;code&gt;--assertions:off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db364455640be314eef1467aaec6fd2d418125f9" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate C++ (command &lt;code&gt;cpp&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;cpp&lt;/code&gt; is defined when the compiler emits C++ code.</source>
          <target state="translated">Чтобы это сработало, необходимо &lt;code&gt;cpp&lt;/code&gt; компилятору сгенерировать C ++ (команда cpp ). Условный символ &lt;code&gt;cpp&lt;/code&gt; определяется, когда компилятор генерирует код C ++.</target>
        </trans-unit>
        <trans-unit id="b07c704d05cf142e0a3e3c5f7b0076809faa6524" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate Objective C (command &lt;code&gt;objc&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;objc&lt;/code&gt; is defined when the compiler emits Objective C code.</source>
          <target state="translated">&lt;code&gt;objc&lt;/code&gt; это сработало, компилятору нужно указать, что он должен сгенерировать Objective C (команда objc ). Условный символ &lt;code&gt;objc&lt;/code&gt; определяется, когда компилятор генерирует код Objective C.</target>
        </trans-unit>
        <trans-unit id="f8805142a67c1fcd5058bf1936f838d762e70095" translate="yes" xml:space="preserve">
          <source>The compiler now rewrites &lt;code&gt;x * 2&lt;/code&gt; as &lt;code&gt;x + x&lt;/code&gt;. The code inside the curlies is the pattern to match against. The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation, so to match verbatim against &lt;code&gt;*&lt;/code&gt; the ordinary function call syntax needs to be used.</source>
          <target state="translated">Теперь компилятор переписывает &lt;code&gt;x * 2&lt;/code&gt; как &lt;code&gt;x + x&lt;/code&gt; . Код внутри фигурных скобок - это образец для сопоставления. Операторы &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; имеют особое значение в шаблонах, если они написаны в инфиксной нотации, поэтому для дословного сопоставления с &lt;code&gt;*&lt;/code&gt; необходимо использовать обычный синтаксис вызова функции.</target>
        </trans-unit>
        <trans-unit id="98ccaef8e67a887a919921b63fd9651f08d45b7b" translate="yes" xml:space="preserve">
          <source>The compiler optimizes string case statements: A hashing scheme is used for them if several different string constants are used. So code like this is reasonably efficient:</source>
          <target state="translated">Компилятор оптимизирует строковые операторы регистра:Для них используется схема хэширования,если используется несколько различных строковых констант.Таким образом,подобный код достаточно эффективен:</target>
        </trans-unit>
        <trans-unit id="eb71aee62d68e0ffc7703a0f580c4704b2a5314f" translate="yes" xml:space="preserve">
          <source>The compiler parses Nim source code into an internal data structure called the &lt;span id=&quot;abstract-syntax-tree_1&quot;&gt;abstract syntax tree&lt;/span&gt; (&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;). Then, before executing the code or compiling it into the executable, it transforms the AST through &lt;span id=&quot;semantic-analysis_1&quot;&gt;semantic analysis&lt;/span&gt;. This adds semantic information such as expression types, identifier meanings, and in some cases expression values. An error detected during semantic analysis is called a &lt;span id=&quot;static-error_1&quot;&gt;static error&lt;/span&gt;. Errors described in this manual are static errors when not otherwise specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99dc98d2e9fd018605a9070695e4f40f907e1508" translate="yes" xml:space="preserve">
          <source>The compiler produces a hint message that &lt;code&gt;IOError&lt;/code&gt; can be raised. &lt;code&gt;OSError&lt;/code&gt; is not listed as it cannot be raised in the branch the &lt;code&gt;effects&lt;/code&gt; pragma appears in.</source>
          <target state="translated">Компилятор выдает подсказку о том, что может возникнуть &lt;code&gt;IOError&lt;/code&gt; . &lt;code&gt;OSError&lt;/code&gt; не указана, поскольку ее нельзя вызвать в ветке, в которой отображается прагма &lt;code&gt;effects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e1191530a1aabbbcf17eb667a751d36496cbed2" translate="yes" xml:space="preserve">
          <source>The compiler supports the built-in stringify operator &lt;code&gt;$&lt;/code&gt; for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:</source>
          <target state="translated">Компилятор поддерживает встроенный оператор строкового преобразования &lt;code&gt;$&lt;/code&gt; для перечислений. Результатом stringify можно управлять, явно задавая используемые строковые значения:</target>
        </trans-unit>
        <trans-unit id="278d7d171283ed12aaddd7862802da6834c8c0bb" translate="yes" xml:space="preserve">
          <source>The compiler then ensures that every access of &lt;code&gt;gdata&lt;/code&gt; is within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">Затем компилятор гарантирует, что каждый доступ к &lt;code&gt;gdata&lt;/code&gt; находится в разделе &lt;code&gt;locks&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3c5f83ca8ab3660248326a08229e050f34a8a0c9" translate="yes" xml:space="preserve">
          <source>The compiler will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24434c511c9a0bbb881f927475e8de7c254d5387" translate="yes" xml:space="preserve">
          <source>The compiler will use this internally to add nodes that will be appended to the module after the sem pass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c591d42a39fa2cac9b572e36ef028dda7cec6f" translate="yes" xml:space="preserve">
          <source>The compiler's architecture</source>
          <target state="translated">Архитектура компилятора</target>
        </trans-unit>
        <trans-unit id="d997b4ac7c8e54accc0951c93c7af7ae2bdbee79" translate="yes" xml:space="preserve">
          <source>The complementary error function</source>
          <target state="translated">Функция дополнительной ошибки</target>
        </trans-unit>
        <trans-unit id="9b0073d67f30e0c2127f291bae7a611090f6e645" translate="yes" xml:space="preserve">
          <source>The complex case looks like a variant of &lt;code&gt;x = f(x)&lt;/code&gt;, we consider &lt;code&gt;x = select(rand() &amp;lt; 0.5, x, y)&lt;/code&gt; here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5846f2c1b1099d4de8d1900d6964f1db9892caf2" translate="yes" xml:space="preserve">
          <source>The complier will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="translated">Компилятор сообщит о любом отказе в оценке выражения или о возможной ошибке несоответствия типа.</target>
        </trans-unit>
        <trans-unit id="d2436daa78f5945640e1663fb72e8784ed15ea67" translate="yes" xml:space="preserve">
          <source>The concatenation operator for an openarray of ropes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf0dc092d7f032ccb25780c5ba219ec8f7f8ed1" translate="yes" xml:space="preserve">
          <source>The concatenation operator for ropes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e9c95f9ebf3625a28669e8b3ce3192da579bb4" translate="yes" xml:space="preserve">
          <source>The concept is a match if:</source>
          <target state="translated">Концепция совпадает,если:</target>
        </trans-unit>
        <trans-unit id="aaa92c15c23e4f3caae54c3381bbefb039b5333e" translate="yes" xml:space="preserve">
          <source>The concept types can be parametric just like the regular generic types:</source>
          <target state="translated">Типы концепций могут быть параметрическими так же,как и обычные общие типы:</target>
        </trans-unit>
        <trans-unit id="7ec85a5fad9202d978280705ad23fc7951fe5afb" translate="yes" xml:space="preserve">
          <source>The condition in a &lt;code&gt;do while(condition)&lt;/code&gt; statement must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Условие в операторе &lt;code&gt;do while(condition)&lt;/code&gt; должно быть &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="079ce34e8825e87b63959e1b6bb724035f09b43d" translate="yes" xml:space="preserve">
          <source>The configuration file used to generate this module: &lt;a href=&quot;https://ssl-config.mozilla.org/guidelines/5.4.json&quot;&gt;https://ssl-config.mozilla.org/guidelines/5.4.json&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df0cbf2a934ca63dd156a15c83a0955e4f3c96c" translate="yes" xml:space="preserve">
          <source>The constant character used by the operating system to refer to the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46668a8f385559561fb965d9c9162d27d76feb6a" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory.</source>
          <target state="translated">Константная строка,используемая операционной системой для ссылки на текущий каталог.</target>
        </trans-unit>
        <trans-unit id="b7d275cdb93fdbf6c6bdd566733c471d5cb82c86" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory.</source>
          <target state="translated">Константная строка,используемая операционной системой для ссылки на родительский каталог.</target>
        </trans-unit>
        <trans-unit id="2496559a72199a18b9bd92fb0f307658c3e8c8db" translate="yes" xml:space="preserve">
          <source>The constraint can be a concrete type or a type class.</source>
          <target state="translated">Ограничение может быть конкретным типом или классом.</target>
        </trans-unit>
        <trans-unit id="bdda80e1481774a2bcf89e333a8a607041b5e8d4" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; exists too. It is a shortcut for &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">Идентификатор конструкции &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; тоже существует. Это ярлык для &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b76daad7f41aa0f12c4252effb99658f3e34679b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt;, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</source>
          <target state="translated">Идентификатор конструкции &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (без пробелов между идентификатором и открывающей кавычкой) является обобщенным необработанным строковым литералом. Это ярлык для &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt; конструкции (r &amp;laquo;строковый литерал&amp;raquo;) , поэтому он обозначает вызов процедуры с необработанным строковым литералом в качестве единственного аргумента. Обобщенные необработанные строковые литералы особенно удобны для встраивания мини-языков непосредственно в Nim (например, регулярных выражений).</target>
        </trans-unit>
        <trans-unit id="15d06627966f858375d16fcd25aa9c8d53eb89d1" translate="yes" xml:space="preserve">
          <source>The contravariant parameters introduced with the &lt;code&gt;in&lt;/code&gt; modifier are currently useful only when interfacing with imported types having such semantics.</source>
          <target state="translated">Контравариантные параметры, введенные с помощью модификатора &lt;code&gt;in&lt;/code&gt; , в настоящее время полезны только при взаимодействии с импортированными типами, имеющими такую ​​семантику.</target>
        </trans-unit>
        <trans-unit id="f79116fcf17d026b0e4914fbd53c2223ebb6510b" translate="yes" xml:space="preserve">
          <source>The convertible relation can be relaxed by a user-defined type &lt;span id=&quot;converter_1&quot;&gt;converter&lt;/span&gt;.</source>
          <target state="translated">Конвертируемое отношение может быть ослаблено с помощью определяемого пользователем &lt;span id=&quot;converter_1&quot;&gt;преобразователя&lt;/span&gt; типов .</target>
        </trans-unit>
        <trans-unit id="b18a614e84b5a50fd0095d557ca3e5d6b4cdd331" translate="yes" xml:space="preserve">
          <source>The crit bit tree can either be used as a mapping from strings to some type &lt;code&gt;T&lt;/code&gt; or as a set of strings if &lt;code&gt;T&lt;/code&gt; is void.</source>
          <target state="translated">Дерево битов крита может использоваться либо как отображение строк в некоторый тип &lt;code&gt;T&lt;/code&gt; , либо как набор строк, если &lt;code&gt;T&lt;/code&gt; пусто.</target>
        </trans-unit>
        <trans-unit id="c0fa9cac7ceae42e9a66ef4fbfd5cbc0c0b98a60" translate="yes" xml:space="preserve">
          <source>The current implementation allows to switch between these different behaviors via &lt;code&gt;--panics:on|off&lt;/code&gt;. When panics are turned on, the program dies with a panic, if they are turned off the runtime errors are turned into exceptions. The benefit of &lt;code&gt;--panics:on&lt;/code&gt; is that it produces smaller binary code and the compiler has more freedom to optimize the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135086cb75d914e6f94d6cbecde1ac80f38e6fe2" translate="yes" xml:space="preserve">
          <source>The current implementation also performs &lt;code&gt;.cursor&lt;/code&gt; inference. Cursor inference is a form of copy elision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d19e0e77753e1c01e8179f867553475a7ffcd1" translate="yes" xml:space="preserve">
          <source>The current implementation can do a limited form of sink parameter inference. But it has to be enabled via &lt;code&gt;--sinkInference:on&lt;/code&gt;, either on the command line or via a &lt;code&gt;push&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5b1ca7fdfb765ee1b960287c15b23201b6d21a" translate="yes" xml:space="preserve">
          <source>The current implementation follows strategy (2). This means that resources are destroyed at the scope exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b76fe6e6adda8db66493cbcc5c7f0fd20c378ec" translate="yes" xml:space="preserve">
          <source>The current implementation poses some restrictions for compile time evaluation: Code which contains &lt;code&gt;cast&lt;/code&gt; or makes use of the foreign function interface cannot be evaluated at compile time. Later versions of Nim will support the FFI at compile time.</source>
          <target state="translated">Текущая реализация накладывает некоторые ограничения на оценку времени компиляции: код, содержащий &lt;code&gt;cast&lt;/code&gt; типов или использующий интерфейс внешней функции, не может быть оценен во время компиляции. Более поздние версии Nim будут поддерживать FFI во время компиляции.</target>
        </trans-unit>
        <trans-unit id="a6c75b39da47586f8ce3f9497858b03d9e773673" translate="yes" xml:space="preserve">
          <source>The current implementation uses a reference counting garbage collector with a seldomly run mark and sweep phase to free cycles. The mark and sweep phase may take a long time and is not needed if the application does not create cycles. Thus the mark and sweep phase can be deactivated and activated separately from the rest of the GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8021c64a5c2703296dd3be90acd92bb96fdc4cc3" translate="yes" xml:space="preserve">
          <source>The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length &lt;code&gt;a.len div 2&lt;/code&gt;. If you do not wish to provide your own &lt;code&gt;cmp&lt;/code&gt;, you may use &lt;code&gt;system.cmp&lt;/code&gt; or instead call the overloaded version of &lt;code&gt;sort&lt;/code&gt;, which uses &lt;code&gt;system.cmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baaad5708fa9cdaf05cfb4998ff219d4807eb0f6" translate="yes" xml:space="preserve">
          <source>The current version is compatible with Unicode v12.0.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a150efd164504eebf2c6ca387f4a2724cdddad5b" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the GC with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="translated">Сборщик циклов можно включить / отключить независимо от других частей GC с помощью &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; и &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba5fbe658d27b58a801cb300b7494eb040d69ce3" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the garbage collector with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8940014c2996b2e1e7db8c6a1ff0b6fea342746b" translate="yes" xml:space="preserve">
          <source>The data structures and algorithms used here are inspired by &quot;A Graph&amp;ndash;Free Approach to Data&amp;ndash;Flow Analysis&quot; by Markus Mohnen. &lt;a href=&quot;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&quot;&gt;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ac7444c3221b96debd2abc66799170ac26a58d" translate="yes" xml:space="preserve">
          <source>The date (in UTC) of compilation as a string of the form &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. This works thanks to compiler magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="940edcabe1639013ff3203ff4f55354615da8e93" translate="yes" xml:space="preserve">
          <source>The day of the month, in the range 1 to 31.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad24cee5b08e1745f4d438cfcaeb59500a70b502" translate="yes" xml:space="preserve">
          <source>The day of the week as an enum, the ordinal value is in the range 0 (monday) to 6 (sunday).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="translated">Сборка проекта по умолчанию - это &lt;span id=&quot;debug-build_1&quot;&gt;отладочная сборка&lt;/span&gt; . Чтобы скомпилировать &lt;span id=&quot;release-build_1&quot;&gt;сборку выпуска,&lt;/span&gt; определите символ &lt;code&gt;release&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="translated">Соглашение о вызовах по умолчанию - &lt;code&gt;nimcall&lt;/code&gt; , если только это не внутренняя процедура (процедура внутри процедуры). Для внутреннего процесса выполняется анализ, получает ли он доступ к своей среде. Если это так, у него есть &lt;code&gt;closure&lt;/code&gt; соглашения о вызовах , в противном случае - соглашение о &lt;code&gt;nimcall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="translated">Компилятор по умолчанию определен в верхней части &lt;code&gt;config\nim.cfg&lt;/code&gt; . Изменение этого параметра влияет на компилятор, используемый &lt;code&gt;koch&lt;/code&gt; для (пере) сборки Nim.</target>
        </trans-unit>
        <trans-unit id="e96baa512c39f7d0782817e5f034412a054f571f" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;code&gt;trim=true&lt;/code&gt; and &lt;code&gt;precision=10&lt;/code&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">Конфигурация по умолчанию ( &lt;em&gt;trim = true&lt;/em&gt; и &lt;em&gt;precision = 10&lt;/em&gt; ) показывает самую &lt;strong&gt;короткую&lt;/strong&gt; форму, которая точно (максимум до 10 знаков после запятой) отображает значение. Например, 4.100000 будет отображаться как 4.1 (что математически идентично), тогда как 4.1000003 будет отображаться как 4.1000003.</target>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="translated">По умолчанию используется тип &lt;code&gt;float&lt;/code&gt; . В текущей реализации &lt;code&gt;float&lt;/code&gt; всегда 64-битный.</target>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="translated">Значение по умолчанию для символов сущностей &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; является &lt;code&gt;gensym&lt;/code&gt; и &lt;code&gt;proc&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; , &lt;code&gt;converter&lt;/code&gt; , &lt;code&gt;template&lt;/code&gt; , &lt;code&gt;macro&lt;/code&gt; является &lt;code&gt;inject&lt;/code&gt; . Однако, если имя объекта передается в качестве параметра шаблона, это введенный символ:</target>
        </trans-unit>
        <trans-unit id="33bc5ba68d5a4770f91c0f77bf490ba64a1ebdf4" translate="yes" xml:space="preserve">
          <source>The default format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="translated">Целочисленный тип по умолчанию - &lt;code&gt;int&lt;/code&gt; . Целочисленные литералы могут иметь &lt;em&gt;суффикс типа,&lt;/em&gt; чтобы указать целочисленный тип, &lt;em&gt;отличный&lt;/em&gt; от используемого по умолчанию:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
