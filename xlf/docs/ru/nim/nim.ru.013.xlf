<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="956810679fde5bcd94729ea5a195b781ebc9936f" translate="yes" xml:space="preserve">
          <source>Nim has a builtin thread pool that can be used for CPU intensive tasks. For IO intensive tasks the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; features should be used instead. Both parallel and spawn need the &lt;a href=&quot;threadpool&quot;&gt;threadpool&lt;/a&gt; module to work.</source>
          <target state="translated">Nim имеет встроенный пул потоков, который можно использовать для задач, интенсивно использующих процессор. Вместо этого для задач с интенсивным &lt;code&gt;async&lt;/code&gt; &lt;code&gt;await&lt;/code&gt; следует использовать функции async и await . И parallel, и spawn нуждаются в модуле &lt;a href=&quot;threadpool&quot;&gt;threadpool&lt;/a&gt; для работы.</target>
        </trans-unit>
        <trans-unit id="8271465a18dfd05fb2b43750bb600424d58f8d93" translate="yes" xml:space="preserve">
          <source>Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this a special setter syntax is needed:</source>
          <target state="translated">Nim не нуждается в &lt;em&gt;get-свойствах&lt;/em&gt; : обычные get-процедуры, вызываемые с помощью &lt;em&gt;синтаксиса вызова методов,&lt;/em&gt; достигают того же. Но установка значения отличается; для этого необходим специальный синтаксис сеттера:</target>
        </trans-unit>
        <trans-unit id="2d68c150b59e057428b45d05875c0768dda6fd33" translate="yes" xml:space="preserve">
          <source>Nim has no need for &lt;em&gt;get-properties&lt;/em&gt;: Ordinary get-procedures that are called with the &lt;em&gt;method call syntax&lt;/em&gt; achieve the same. But setting a value is different; for this, a special setter syntax is needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a3428d8f1eb98b6a56266f5afa22c38fb951ee" translate="yes" xml:space="preserve">
          <source>Nim has no separate optimizer, but the C code that is produced is very efficient. Most C compilers have excellent optimizers, so usually it is not needed to optimize one's code. Nim has been designed to encourage efficient code: The most readable code in Nim is often the most efficient too.</source>
          <target state="translated">У Nim нет отдельного оптимизатора,но создаваемый код на C очень эффективен.Большинство компиляторов Си имеют отличные оптимизаторы,поэтому,как правило,оптимизировать свой код не требуется.Nim был разработан для поощрения эффективного кода:Самый читаемый код в Nim тоже часто бывает самым эффективным.</target>
        </trans-unit>
        <trans-unit id="d4433d8ee67c60caa5f14cbc4d36fb3fc5be0287" translate="yes" xml:space="preserve">
          <source>Nim has the concept of a global search path (PATH) that is queried to determine where to find imported modules or include files. If multiple files are found an ambiguity error is produced.</source>
          <target state="translated">Nim имеет концепцию глобального пути поиска (PATH),который опрашивается,чтобы определить,где найти импортируемые модули или включаемые файлы.Если найдено несколько файлов,то возникает ошибка неоднозначности.</target>
        </trans-unit>
        <trans-unit id="01727ad8d0bbaeeea62faa6f12c71312bf1ae451" translate="yes" xml:space="preserve">
          <source>Nim has these floating point types built-in: &lt;code&gt;float float32 float64&lt;/code&gt;.</source>
          <target state="translated">В Nim есть встроенные типы с плавающей запятой: &lt;code&gt;float float32 float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3deb8348e9e32056d74290a50d876e63851d29" translate="yes" xml:space="preserve">
          <source>Nim has these integer types built-in: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt;.</source>
          <target state="translated">В Nim есть встроенные целочисленные типы: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4f95676cbff4f6b732c078d876ae2ad27f446" translate="yes" xml:space="preserve">
          <source>Nim has two flavors of parallelism:</source>
          <target state="translated">Ним имеет два вкуса параллелизма:</target>
        </trans-unit>
        <trans-unit id="dc5bf296e3c41484c147bfc3cd569c0d2a605bfb" translate="yes" xml:space="preserve">
          <source>Nim idetools integration</source>
          <target state="translated">Интеграция Nim idetools</target>
        </trans-unit>
        <trans-unit id="fde430a55fc171aea53e7cacfbb81ff6931bd1b5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from C</source>
          <target state="translated">Пример ссылки на Ним из C</target>
        </trans-unit>
        <trans-unit id="a9b0c283f30ebbd8bbc505d567707e20b58f9be5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from JavaScript</source>
          <target state="translated">Пример Nim вызова из JavaScript</target>
        </trans-unit>
        <trans-unit id="bdd28046b42c51d6419a24b949f2e431ad33feda" translate="yes" xml:space="preserve">
          <source>Nim is free software; it is licensed under the &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT License&lt;/a&gt;.</source>
          <target state="translated">Nim - бесплатное программное обеспечение; он находится под &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;лицензией MIT License&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c7393409ca98f35a585605ecd27b0ce04bc6dc" translate="yes" xml:space="preserve">
          <source>Nim lock, re-entrant</source>
          <target state="translated">Ним-блок,повторный вход</target>
        </trans-unit>
        <trans-unit id="af2f77b6798efd1fe7af2c6d48238ea2e59af4d3" translate="yes" xml:space="preserve">
          <source>Nim lock; whether this is re-entrant or not is unspecified!</source>
          <target state="translated">Ним-блок;является ли это повторный вход или нет,не определено!</target>
        </trans-unit>
        <trans-unit id="396c55174c1748ab5bec4b1cb866abf79d300e48" translate="yes" xml:space="preserve">
          <source>Nim maintenance script</source>
          <target state="translated">Скрипт обслуживания Nim</target>
        </trans-unit>
        <trans-unit id="200b4437aaf50df9807fc02a8b32574618effddb" translate="yes" xml:space="preserve">
          <source>Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.</source>
          <target state="translated">Nim предлагает специальное семейство точечных операторов,которые могут быть использованы для перехвата и перезаписи proc вызовов и попыток доступа к полям,ссылаясь на ранее незаявленные имена символов.Они могут быть использованы для обеспечения свободного интерфейса для объектов,лежащих за пределами статических границ системы типов,таких как значения из динамических языков сценариев или динамических форматов файлов,таких как JSON или XML.</target>
        </trans-unit>
        <trans-unit id="67e6a58d0659f4167e32702de63a078a70b84e7d" translate="yes" xml:space="preserve">
          <source>Nim offers bidirectional interfacing with the target backend. This means that you can call backend code from Nim and Nim code can be called by the backend code. Usually the direction of which calls which depends on your software architecture (is Nim your main program or is Nim providing a component?).</source>
          <target state="translated">Nim предлагает двунаправленную связь с бэкэндом цели.Это означает,что вы можете вызывать бэкэнд код с Nim,а Nim код может вызываться по бэкэнд коду.Обычно направление,в котором звонят,зависит от архитектуры вашего программного обеспечения (Nim-ваша основная программа или Nim предоставляет компонент?).</target>
        </trans-unit>
        <trans-unit id="893f066137f8187ed8a07f2272b19d0871bbc768" translate="yes" xml:space="preserve">
          <source>Nim produces a warning for symbols that are not exported and not used either. The &lt;code&gt;used&lt;/code&gt; pragma can be attached to a symbol to suppress this warning. This is particularly useful when the symbol was generated by a macro:</source>
          <target state="translated">Nim выдает предупреждение для символов, которые не экспортируются и не используются. &lt;code&gt;used&lt;/code&gt; прагма может быть присоединена к символу , чтобы подавить это предупреждение. Это особенно полезно, когда символ был сгенерирован макросом:</target>
        </trans-unit>
        <trans-unit id="6150bb7b7dad74d65ce46c3a55145c510735a725" translate="yes" xml:space="preserve">
          <source>Nim provides language integration with external IDEs through the idetools command. See the documentation of &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; for further information.</source>
          <target state="translated">Nim обеспечивает языковую интеграцию с внешними IDE с помощью команды idetools. См. Документацию &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="6864a9277154b157b94a761e493fbd79ef8b809c" translate="yes" xml:space="preserve">
          <source>Nim provides the &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; and &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; commands to generate HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files. Only exported symbols will appear in the output. For more details &lt;a href=&quot;docgen&quot;&gt;see the docgen documentation&lt;/a&gt;.</source>
          <target state="translated">Nim предоставляет команды &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; и &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; для создания HTML-документации из исходных файлов &lt;code&gt;.nim&lt;/code&gt; . На выходе будут отображаться только экспортированные символы. Подробнее &lt;a href=&quot;docgen&quot;&gt;см. Документацию docgen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b7008b8e9d9cc2fbb71ad07b4590df2b146b1ff" translate="yes" xml:space="preserve">
          <source>Nim provides the &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; command to generate HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files. Only exported symbols will appear in the output. For more details &lt;a href=&quot;https://nim-lang.org/docs/docgen.html&quot;&gt;see the docgen documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0f9e0827a8dbea31dc2fbe4ce37db63cfa840c" translate="yes" xml:space="preserve">
          <source>Nim provides the ability to overload procedures similar to C++:</source>
          <target state="translated">Nim предоставляет возможность перегружать процедуры,аналогичные C++:</target>
        </trans-unit>
        <trans-unit id="082cc471f7e487d0e261d56375fe2f285b9ead9d" translate="yes" xml:space="preserve">
          <source>Nim provides the pragmas &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; and &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; to control whether the IEEE exceptions are ignored or trap a Nim exception:</source>
          <target state="translated">Nim предоставляет &lt;span id=&quot;nanchecks_1&quot;&gt;прагмы nanChecks&lt;/span&gt; и &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; для управления тем, игнорируются ли исключения IEEE или перехватываются исключения Nim:</target>
        </trans-unit>
        <trans-unit id="508417c4e97e2bf7456d14ecac591b4f6356c08f" translate="yes" xml:space="preserve">
          <source>Nim runs on a wide variety of platforms. Support on amd64 and i386 is tested regularly, while less popular platforms are tested by the community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a99b555e8d5a547fbd7a8b6c3c5be83dc59b13" translate="yes" xml:space="preserve">
          <source>Nim search and replace utility.</source>
          <target state="translated">Поиск Ним и замена утилиты.</target>
        </trans-unit>
        <trans-unit id="cea72c6813825983207ed89ef6d7563250a6be64" translate="yes" xml:space="preserve">
          <source>Nim significantly improves on the safety of these features via additional pragmas:</source>
          <target state="translated">Nim значительно повышает безопасность этих функций благодаря дополнительным прагмам:</target>
        </trans-unit>
        <trans-unit id="13adb76d4a44fc6d0ed9557643b94613f8b29151" translate="yes" xml:space="preserve">
          <source>Nim support for &lt;span id=&quot;substitution-expressions_1&quot;&gt;substitution expressions&lt;/span&gt; (&lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt;).</source>
          <target state="translated">Nim поддерживает &lt;span id=&quot;substitution-expressions_1&quot;&gt;подстановочные выражения&lt;/span&gt; ( &lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="f308ae3443ec85df73ede4f78102be2e349b672c" translate="yes" xml:space="preserve">
          <source>Nim supports exception tracking. The &lt;span id=&quot;raises_1&quot;&gt;raises&lt;/span&gt; pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this:</source>
          <target state="translated">Nim поддерживает отслеживание исключений. &lt;span id=&quot;raises_1&quot;&gt;Повышает&lt;/span&gt; прагма может использоваться , чтобы явно определить , какие исключения прок / итератор / метод / конвертер разрешается поднять. Компилятор это проверяет:</target>
        </trans-unit>
        <trans-unit id="3f7af30571e6dd9a4e1318813044e95e94a257fb" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own &lt;span id=&quot;namespace_1&quot;&gt;namespace&lt;/span&gt;. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to symbols of another module by the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;Recursive module dependencies&lt;/span&gt; are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is &lt;code&gt;identifier.nim&lt;/code&gt;).</source>
          <target state="translated">Nim поддерживает разделение программы на части по модульной концепции. Каждый модуль должен находиться в собственном файле и иметь собственное &lt;span id=&quot;namespace_1&quot;&gt;пространство имен&lt;/span&gt; . Модули позволяют &lt;span id=&quot;information-hiding_1&quot;&gt;скрывать информацию&lt;/span&gt; и &lt;span id=&quot;separate-compilation_1&quot;&gt;раздельную компиляцию&lt;/span&gt; . Модуль может получить доступ к символам другого модуля с помощью оператора &lt;span id=&quot;import_1&quot;&gt;импорта&lt;/span&gt; . &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;Рекурсивные зависимости модуля&lt;/span&gt; разрешены, но слегка незаметны. Экспортируются только символы верхнего уровня, отмеченные звездочкой ( &lt;code&gt;*&lt;/code&gt; ). Допустимое имя модуля может быть только действительным идентификатором Nim (и, следовательно, его имя файла - &lt;code&gt;identifier.nim&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e44eef4a789fd3c119666d4ed23cb9494cb3bbf7" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces with a module concept. Each module is in its own file. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to the symbols of another module by using the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported:</source>
          <target state="translated">Nim поддерживает разделение программы на части с помощью модульной концепции. Каждый модуль находится в собственном файле. Модули позволяют &lt;span id=&quot;information-hiding_1&quot;&gt;скрыть информацию&lt;/span&gt; и &lt;span id=&quot;separate-compilation_1&quot;&gt;раздельную компиляцию&lt;/span&gt; . Модуль может получить доступ к символам другого модуля с помощью оператора &lt;span id=&quot;import_1&quot;&gt;импорта&lt;/span&gt; . Экспортируются только символы верхнего уровня, отмеченные звездочкой ( &lt;code&gt;*&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="46fdd12ce5e87d8ce22525d0fc7e670179c0d9e1" translate="yes" xml:space="preserve">
          <source>Nim supports the generation of DLLs. However, there must be only one instance of the GC per process/address space. This instance is contained in &lt;code&gt;nimrtl.dll&lt;/code&gt;. This means that every generated Nim DLL depends on &lt;code&gt;nimrtl.dll&lt;/code&gt;. To generate the &quot;nimrtl.dll&quot; file, use the command:</source>
          <target state="translated">Nim поддерживает создание библиотек DLL. Однако должен быть только один экземпляр GC на процесс / адресное пространство. Этот экземпляр содержится в &lt;code&gt;nimrtl.dll&lt;/code&gt; . Это означает, что каждая сгенерированная Nim DLL зависит от &lt;code&gt;nimrtl.dll&lt;/code&gt; . Чтобы сгенерировать файл &quot;nimrtl.dll&quot;, используйте команду:</target>
        </trans-unit>
        <trans-unit id="9716569bd8c70a883cc816b4d661c7ea0ac3b2d4" translate="yes" xml:space="preserve">
          <source>Nim supports these &lt;span id=&quot;calling-conventions_1&quot;&gt;calling conventions&lt;/span&gt;:</source>
          <target state="translated">Nim поддерживает следующие &lt;span id=&quot;calling-conventions_1&quot;&gt;соглашения о вызовах&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="abcf9d9cfc4c5456a80f226fb54d7c37497efa51" translate="yes" xml:space="preserve">
          <source>Nim targets JavaScript 1.5 which is supported by any widely used browser. Since JavaScript does not have a portable means to include another module, Nim just generates a long &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Nim нацелен на JavaScript 1.5, который поддерживается всеми широко используемыми браузерами. Поскольку в JavaScript нет переносимых средств для включения другого модуля, Nim просто генерирует длинный файл &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6334ba658939fb66c6d2eb5152d5c5e1ed6cc5c" translate="yes" xml:space="preserve">
          <source>Nim type</source>
          <target state="translated">Тип Ним</target>
        </trans-unit>
        <trans-unit id="12a335b577d343cb196e9cbe8abf689f02aa0bd4" translate="yes" xml:space="preserve">
          <source>Nim uses structural type equivalence for most types. Only for objects, enumerations and distinct types name equivalence is used. The following algorithm, &lt;em&gt;in pseudo-code&lt;/em&gt;, determines type equality:</source>
          <target state="translated">Nim использует эквивалентность структурных типов для большинства типов. Только для объектов, перечислений и различных типов используется эквивалентность имен. Следующий алгоритм &lt;em&gt;в псевдокоде&lt;/em&gt; определяет равенство типов:</target>
        </trans-unit>
        <trans-unit id="1870e8d051fa7bd2733b9612e24fa28e4e1bd585" translate="yes" xml:space="preserve">
          <source>Nim uses the classic compiler architecture: A lexer/scanner feds tokens to a parser. The parser builds a syntax tree that is used by the code generator. This syntax tree is the interface between the parser and the code generator. It is essential to understand most of the compiler's code.</source>
          <target state="translated">Ним использует классическую архитектуру компилятора:Лексер/сканер передает токены синтаксическому анализатору.Синтаксический анализатор строит синтаксическое дерево,которое используется генератором кода.Это синтаксическое дерево является интерфейсом между синтаксическим анализатором и генератором кода.Важно понимать большую часть кода компилятора.</target>
        </trans-unit>
        <trans-unit id="322b8b83d95b2969c2c0f758d4cccd2596086dda" translate="yes" xml:space="preserve">
          <source>Nim uses the common statement/expression paradigm: Statements do not produce a value in contrast to expressions. However, some expressions are statements.</source>
          <target state="translated">Ним использует общую парадигму оператора/выражения:операторы не производят значения в отличие от выражений.Однако некоторые выражения являются операторами.</target>
        </trans-unit>
        <trans-unit id="89ee9afb771e64a1e7ce2a930130a658c6ca2c85" translate="yes" xml:space="preserve">
          <source>Nim versions before 0.20 used the wrong spelling (&quot;demon&quot;). Now &lt;code&gt;ProcessOption&lt;/code&gt; uses the correct spelling (&quot;daemon&quot;), and this is needed just for backward compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16bf12211c3e06c6eb9e50a3ff54ca759ba185c1" translate="yes" xml:space="preserve">
          <source>Nim&amp;#x27;s Garbage Collector</source>
          <target state="translated">Сборщик мусора Нима</target>
        </trans-unit>
        <trans-unit id="9e747b8df254ba8adeea93bf65d5d26fc1f7c029" translate="yes" xml:space="preserve">
          <source>Nim's &lt;code&gt;import&lt;/code&gt; statement actually takes different variations depending on what keywords are present. Let's start with the simplest form.</source>
          <target state="translated">Оператор &lt;code&gt;import&lt;/code&gt; Nim на самом деле принимает разные варианты в зависимости от того, какие ключевые слова присутствуют. Начнем с самой простой формы.</target>
        </trans-unit>
        <trans-unit id="576ef403ca389194e42a3457f0afbf3573e97c72" translate="yes" xml:space="preserve">
          <source>Nim's &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (foreign function interface) is extensive and only the parts that scale to other future backends (like the LLVM/JavaScript backends) are documented here.</source>
          <target state="translated">&lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (интерфейс внешних функций) Nim обширен, и здесь документированы только те части, которые масштабируются для других будущих бэкэндов (например, бэкэнды LLVM / JavaScript).</target>
        </trans-unit>
        <trans-unit id="0001d3798571e3724667eff0ac34ad8cc342d30f" translate="yes" xml:space="preserve">
          <source>Nim's FFI (foreign function interface) is not available in NimScript. This means that any stdlib module which relies on &lt;code&gt;importc&lt;/code&gt; can not be used in the VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a2a3b0146362c9c774e923c0df1b46db23ed52" translate="yes" xml:space="preserve">
          <source>Nim's Garbage Collector</source>
          <target state="translated">Мусорщик Нима</target>
        </trans-unit>
        <trans-unit id="9c63ed798cb14ea75cd44449159244ef1e6fa151" translate="yes" xml:space="preserve">
          <source>Nim's Memory Management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41682260d59280a2b3b6483204da1644fe3e4a8" translate="yes" xml:space="preserve">
          <source>Nim's boolean type is called &lt;code&gt;bool&lt;/code&gt; and consists of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in while, if, elif, and when statements must be of type bool.</source>
          <target state="translated">Логический тип Нима называется &lt;code&gt;bool&lt;/code&gt; и состоит из двух предопределенных значений &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; . Условия в операторах while, if, elif и when должны иметь тип bool.</target>
        </trans-unit>
        <trans-unit id="7f9bb646d70cb0b289c9556100113fa715dd573b" translate="yes" xml:space="preserve">
          <source>Nim's library is divided into &lt;em&gt;pure libraries&lt;/em&gt;, &lt;em&gt;impure libraries&lt;/em&gt;, and &lt;em&gt;wrappers&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ee675d367062e6a639dae94168d9a9c1a41f44" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different from other common programming languages (C, Pascal): Each thread has its own (garbage collected) heap and sharing of memory is restricted. This helps to prevent race conditions and improves efficiency. See &lt;a href=&quot;manual#threads&quot;&gt;the manual for details of this memory model&lt;/a&gt;.</source>
          <target state="translated">Модель памяти Nim для потоков сильно отличается от других распространенных языков программирования (C, Pascal): у каждого потока есть своя куча (собранная со сборкой мусора), а совместное использование памяти ограничено. Это помогает предотвратить состояние гонки и повышает эффективность. Подробную &lt;a href=&quot;manual#threads&quot;&gt;информацию об этой модели памяти&lt;/a&gt; см. В руководстве .</target>
        </trans-unit>
        <trans-unit id="e98391c7155144865c0c684166fb6f91c4167fcb" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference. Memory allocation requires no lock at all! This design easily scales to massive multicore processors that are becoming the norm.</source>
          <target state="translated">Модель памяти Nim для потоков сильно отличается от моделей других распространенных языков программирования (C,Pascal,Java):Каждый поток имеет свою собственную (собранный мусор)кучу,а совместное использование памяти ограничено глобальными переменными.Это помогает предотвратить условия гонки.Эффективность GC повышается достаточно сильно,так как GC никогда не должен останавливать другие потоки и видеть,на что они ссылаются.Распределение памяти не требует блокировки вообще! Этот дизайн легко масштабируется до массивных многоядерных процессоров,которые становятся нормой.</target>
        </trans-unit>
        <trans-unit id="e16beba5be23dbf120604d9eac2a0b9733124873" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap, and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd526290438cb61dffae2d2e60576f140904aaf" translate="yes" xml:space="preserve">
          <source>Nim's object syntax is rich. Let's take a look at an involved example in its entirety to see some of the complexities.</source>
          <target state="translated">Синтаксис объектов Нима богат.Давайте посмотрим на задействованный пример во всей его полноте,чтобы увидеть некоторые сложности.</target>
        </trans-unit>
        <trans-unit id="0d1938981c78468bfa1d2da1e306dcbcb6376cdd" translate="yes" xml:space="preserve">
          <source>Nim's parser</source>
          <target state="translated">парсер Нима</target>
        </trans-unit>
        <trans-unit id="acf2817c0d9f0b146da2d625488e15fe41115e79" translate="yes" xml:space="preserve">
          <source>Nim's standard grammar describes an &lt;span id=&quot;indentation-sensitive_1&quot;&gt;indentation sensitive&lt;/span&gt; language. This means that all the control structures are recognized by indentation. Indentation consists only of spaces; tabulators are not allowed.</source>
          <target state="translated">Стандартная грамматика Нима описывает язык, &lt;span id=&quot;indentation-sensitive_1&quot;&gt;чувствительный&lt;/span&gt; к &lt;span id=&quot;indentation-sensitive_1&quot;&gt;отступам&lt;/span&gt; . Это означает, что все управляющие структуры распознаются по отступам. Отступ состоит только из пробелов; Табуляторы не допускаются.</target>
        </trans-unit>
        <trans-unit id="fb3af97ac3591e9d4487efae331e1cc3fe9eed9d" translate="yes" xml:space="preserve">
          <source>Nim's standard library only covers the basics, check out &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; for a list of 3rd party packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77393f218a5f26531de32e76d9d12df341c291fa" translate="yes" xml:space="preserve">
          <source>Nim's standard random number generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1452a3d3fd11615a428ccdddc1e755ffef521766" translate="yes" xml:space="preserve">
          <source>Nim's standard random number generator. Based on the &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor/rotate/shift/rotate) library.</source>
          <target state="translated">Стандартный генератор случайных чисел Нима. На основе &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor / rotate / shift / rotate).</target>
        </trans-unit>
        <trans-unit id="e87220288cb1bb4d3284ac229d8e724411f9156a" translate="yes" xml:space="preserve">
          <source>NimCompilerApiVersion:</source>
          <target state="translated">NimCompilerApiVersion:</target>
        </trans-unit>
        <trans-unit id="035abfdda9b03c8237ac0a7feb0ced2c808a87c6" translate="yes" xml:space="preserve">
          <source>NimExt:</source>
          <target state="translated">NimExt:</target>
        </trans-unit>
        <trans-unit id="25a35361f773f4c4dde724d3ece4cf111ba2929b" translate="yes" xml:space="preserve">
          <source>NimProg:</source>
          <target state="translated">NimProg:</target>
        </trans-unit>
        <trans-unit id="8ab4b86e0c9b72c06707898687dc558effda2630" translate="yes" xml:space="preserve">
          <source>NimScript</source>
          <target state="translated">NimScript</target>
        </trans-unit>
        <trans-unit id="1060f5fe59141088954b97650581009ff437f63d" translate="yes" xml:space="preserve">
          <source>NimScript as a build tool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe85fa4503fd856c0b2c5b8e006bfb56700547e" translate="yes" xml:space="preserve">
          <source>NimScript as a configuration file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fb69363bbec3d3e7f963ac64cc9108bb1eb062" translate="yes" xml:space="preserve">
          <source>NimScript can also be used directly as a portable replacement for Bash and Batch files. Use &lt;code&gt;nim myscript.nims&lt;/code&gt; to run &lt;code&gt;myscript.nims&lt;/code&gt;. For example, installation of Nimble could be accomplished with this simple script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8119aecbfac41940b08449972bffe26657feb9" translate="yes" xml:space="preserve">
          <source>NimScript can detect on which platform, operating system, architecture, and even which Linux distribution is running on, allowing the same script to support a lot of systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f85d9adec2a4efa1b9102c81dbf387a3fb5e9d" translate="yes" xml:space="preserve">
          <source>NimScript can use Nim's templates, macros, types, concepts, effect tracking system, and more, you can create modules that work on compiled Nim and also on interpreted NimScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0d9ddce680baee1ba932a503b5444c9efc6dfe" translate="yes" xml:space="preserve">
          <source>NimScript evolves together with Nim, &lt;a href=&quot;https://github.com/nim-lang/Nim/pulls?utf8=%E2%9C%93&amp;amp;q=nimscript&quot;&gt;occasionally new features might become available on NimScript&lt;/a&gt; , adapted from compiled Nim or added as new features on both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402bcf2eebcea027b3675344e83beef6d49421ab" translate="yes" xml:space="preserve">
          <source>NimScript is subject to some limitations caused by the implementation of the VM (virtual machine):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa0a28931e2602b2a448ffe81a4e242e7826335" translate="yes" xml:space="preserve">
          <source>NimScripts also support &lt;code&gt;--&lt;/code&gt; templates for convenience, which look like command-line switches written as-is in the NimScript file. So the above example can be rewritten as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6b14412133ed2489b730e9fc4f06291eb4e8ce" translate="yes" xml:space="preserve">
          <source>Nimble</source>
          <target state="translated">Nimble</target>
        </trans-unit>
        <trans-unit id="26c03ddba53d901b234feb6fb87a68295b59cd08" translate="yes" xml:space="preserve">
          <source>Nimble integration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3bca65182fa05bd8858bec9a6e6900f87e2adf" translate="yes" xml:space="preserve">
          <source>Nimble is a package manager for the Nim programming language. For instructions on how to install Nimble packages see &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;its README&lt;/a&gt;.</source>
          <target state="translated">Nimble - это менеджер пакетов для языка программирования Nim. Инструкции по установке пакетов Nimble см. В &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;README&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5013a2b58d23844e1296b43b0dea97d39a7cb11" translate="yes" xml:space="preserve">
          <source>Nimble metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2ec20dbc771a65435e830fecd7f56d930e7e15" translate="yes" xml:space="preserve">
          <source>Nimble support: Call this to set the list of requirements of your Nimble package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b2694a8c57bd7aa2c631729dbba47d2a27cc62" translate="yes" xml:space="preserve">
          <source>Nimble support: Set this to the package name. It is usually not required to do that, nims' filename is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed05e42072d36de3ae6f98f3a205cb1e71d91ba" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's author.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d931b828c900211ecdbb0924f07616c6d6f1c2" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d6064cefa030bc1c619c0d11551a8571e5d1cc" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's binary directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d30b4bc6cc39b452f5dc2c3f197ab1449217fe" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513e69b6157a08403fb5d2ef1ef15bb2da0988fc" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's license.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72740a9f91b96fbde6c9a0fcaa67f6da285a52a" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's source directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3cd36df69ddf669e773a85de7a62c85b77a507" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af01d1d4ff2ceea4a8135b93a3b16c4bb879507" translate="yes" xml:space="preserve">
          <source>Nimcache and C like targets</source>
          <target state="translated">Nimcache и C любят мишени</target>
        </trans-unit>
        <trans-unit id="d63113aa6032c199ac973f9c41b92f6b86bc69c5" translate="yes" xml:space="preserve">
          <source>Nimcache and the Javascript target</source>
          <target state="translated">Nimcache и цель Javascript</target>
        </trans-unit>
        <trans-unit id="7a7b1200d84cdfcc90e4068e405d16fe626da360" translate="yes" xml:space="preserve">
          <source>Nimcache naming logic</source>
          <target state="translated">Логика именования Nimcache</target>
        </trans-unit>
        <trans-unit id="71db390f7498c8607ecf76f70925348383f07f46" translate="yes" xml:space="preserve">
          <source>Nimgrep has particularly good support for Nim's eccentric &lt;em&gt;style insensitivity&lt;/em&gt;. Apart from that it is a generic text manipulation tool.</source>
          <target state="translated">Nimgrep особенно хорошо поддерживает &lt;em&gt;бесчувственность&lt;/em&gt; эксцентричного &lt;em&gt;стиля&lt;/em&gt; Nim . Кроме того, это универсальный инструмент для работы с текстом.</target>
        </trans-unit>
        <trans-unit id="23ef2cadfc8ec56820149ad08675af48b8c2a012" translate="yes" xml:space="preserve">
          <source>Nimgrep is a command line tool for search&amp;amp;replace tasks. It can search for regex or peg patterns and can search whole directories at once. User confirmation for every single replace operation can be requested.</source>
          <target state="translated">Nimgrep - это инструмент командной строки для поиска и замены задач. Он может искать шаблоны регулярных выражений или привязок и может искать сразу целые каталоги. Можно запросить подтверждение пользователя для каждой отдельной операции замены.</target>
        </trans-unit>
        <trans-unit id="b1cf2ee07bf536474f8a79eec9ae5297ea46f5b0" translate="yes" xml:space="preserve">
          <source>Nimsuggest for IDE support</source>
          <target state="translated">Nimsuggest для IDE поддержки</target>
        </trans-unit>
        <trans-unit id="74dadd5fc671c88eec7c8cc084b2f4492ce2f149" translate="yes" xml:space="preserve">
          <source>Nimsuggest invocation</source>
          <target state="translated">Нимсуггестское призвание</target>
        </trans-unit>
        <trans-unit id="5621d2e904ec7f4a1fa59a63968518771b43d445" translate="yes" xml:space="preserve">
          <source>Nimsuggest is part of Nim's core. Build it via:</source>
          <target state="translated">Нимсуггест-часть ядра Нима.Постройте его:</target>
        </trans-unit>
        <trans-unit id="b9338b400871e7a753e81682f58f03a8156017e7" translate="yes" xml:space="preserve">
          <source>Nimsuggest output is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Вывод Nimsuggest всегда возвращается в виде отдельных строк, разделенных символами табуляции ( &lt;code&gt;\t&lt;/code&gt; ). Значения каждого столбца:</target>
        </trans-unit>
        <trans-unit id="5372c202a30284da7742441a108b564cdbdf5739" translate="yes" xml:space="preserve">
          <source>Nimsuggest than waits for queries to process. A query consists of a cryptic 3 letter &quot;command&quot; &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;con&lt;/code&gt; or &lt;code&gt;sug&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; followed by a location. A query location consists of:</source>
          <target state="translated">Nimsuggest, чем ожидает обработки запросов. Запрос состоит из &amp;laquo;команды&amp;raquo; скрытой 3 буквы &lt;code&gt;def&lt;/code&gt; или &lt;code&gt;con&lt;/code&gt; или &lt;code&gt;sug&lt;/code&gt; или &lt;code&gt;use&lt;/code&gt; с последующим расположением. Местоположение запроса состоит из:</target>
        </trans-unit>
        <trans-unit id="8bffa4d8fa15634e3c256a4cb41638cf0bbf6c32" translate="yes" xml:space="preserve">
          <source>Nimsuggest then waits for queries to process. A query consists of a cryptic 3 letter &quot;command&quot; &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;con&lt;/code&gt; or &lt;code&gt;sug&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; followed by a location. A query location consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95165223d15af7cefab907c1e06b8b4044d588d9" translate="yes" xml:space="preserve">
          <source>Nimsuggest will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">Nimsuggest всегда будет отвечать одним определением или ни одним,если не найдет ни одного правильного символа,совпадающего с позицией запроса.</target>
        </trans-unit>
        <trans-unit id="cd6ee0acaba1530dda97aa7b3382ff72ed9f8236" translate="yes" xml:space="preserve">
          <source>Nimterlingua</source>
          <target state="translated">Nimterlingua</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5edb935fde1ba56536daaa6b349f01597bc5f8c0" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;&amp;lt;$xml ...$&amp;gt;&lt;/code&gt; declaration is produced, so that the produced XML fragments are composable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb05c02eb40dd8659b5825634b0887e886c359fc" translate="yes" xml:space="preserve">
          <source>No longer actually used</source>
          <target state="translated">Больше не используется</target>
        </trans-unit>
        <trans-unit id="62642b3249a520b5e9ec7c96e547e3faa1827969" translate="yes" xml:space="preserve">
          <source>No traffic is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b9c1b54338d8b9332efccba32605f983f91029" translate="yes" xml:space="preserve">
          <source>NoDecl pragma</source>
          <target state="translated">Прагма NoDecl</target>
        </trans-unit>
        <trans-unit id="4170d71a9c1c5f8428ffdc4348b9e7f9ec2ac4c6" translate="yes" xml:space="preserve">
          <source>Noalias annotation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889f402d84c133d41a3ffb2515b25c4ff5b1ea38" translate="yes" xml:space="preserve">
          <source>Non-default delimiters can be passed to allow iteration over other sorts of &quot;line-like&quot; variable length records. Pass eat='\0' to be strictly &lt;code&gt;delim&lt;/code&gt;-delimited. (Eating an optional prefix equal to '\0' is not supported.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c63e0618d33e20ddbbc5fcacaa83b0217e5a9a" translate="yes" xml:space="preserve">
          <source>Non-default delimiters can be passed to allow iteration over other sorts of &quot;line-like&quot; variable length records. Pass eat='\0' to be strictly &lt;em&gt;delim&lt;/em&gt;-delimited. (Eating an optional prefix equal to '\0' is not supported.)</source>
          <target state="translated">Могут быть переданы не стандартные по умолчанию разделители, чтобы разрешить итерацию по другим видам &amp;laquo;строковых&amp;raquo; записей переменной длины. Проходят съедать = '\ 0' , чтобы быть строго &lt;em&gt;DELIM&lt;/em&gt; -delimited. (Использование необязательного префикса, равного '\ 0', не поддерживается.)</target>
        </trans-unit>
        <trans-unit id="51982015db8c39d38da4e016c910ad96f798d0ca" translate="yes" xml:space="preserve">
          <source>Non-printing characters</source>
          <target state="translated">Ненапечатанные символы</target>
        </trans-unit>
        <trans-unit id="418bd9eb8597b90fb89b70c50e626f53d89d17ca" translate="yes" xml:space="preserve">
          <source>Non-pure enum values should use camelCase whereas pure enum values should use PascalCase.</source>
          <target state="translated">Нечистые значения перечисления должны использовать верблюжью кость,в то время как чистые значения перечисления должны использовать PascalCase.</target>
        </trans-unit>
        <trans-unit id="f8d7bfd0d37a23478caf5e01ccd5869426102765" translate="yes" xml:space="preserve">
          <source>Non-terminals start with a lowercase letter, abstract terminal symbols are in UPPERCASE. Verbatim terminal symbols (including keywords) are quoted with &lt;code&gt;'&lt;/code&gt;. An example:</source>
          <target state="translated">Нетерминальные символы начинаются со строчной буквы, абстрактные терминальные символы - в ВЕРХНЕМ РЕГИСТРЕ. Дословные терминальные символы (включая ключевые слова) заключаются в кавычки с &lt;code&gt;'&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="2da5842ba2d454a52f2d4148a700d65ec1d538fd" translate="yes" xml:space="preserve">
          <source>None of the procs that get an individual value from the deque can be used on an empty deque. If compiled with &lt;code&gt;boundChecks&lt;/code&gt; option, those procs will raise an &lt;code&gt;IndexDefect&lt;/code&gt; on such access. This should not be relied upon, as &lt;code&gt;-d:danger&lt;/code&gt; or &lt;code&gt;--checks:off&lt;/code&gt; will disable those checks and may return garbage or crash the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461551ab6e0521d38c563c8b4f15319bef024ec5" translate="yes" xml:space="preserve">
          <source>None of the procs that get an individual value from the deque can be used on an empty deque. If compiled with &lt;em&gt;boundChecks&lt;/em&gt; option, those procs will raise an &lt;em&gt;IndexError&lt;/em&gt; on such access. This should not be relied upon, as &lt;em&gt;-d:release&lt;/em&gt; will disable those checks and may return garbage or crash the program.</source>
          <target state="translated">Ни один из процессов, которые получают индивидуальное значение из двухсторонней очереди, не может использоваться на пустой двухсторонней очереди. Если скомпилирован с опцией &lt;em&gt;boundChecks&lt;/em&gt; , эти процедуры &lt;em&gt;вызовут IndexError&lt;/em&gt; при таком доступе. На это не следует полагаться, поскольку &lt;em&gt;-d: release&lt;/em&gt; отключит эти проверки и может вернуть мусор или привести к сбою программы.</target>
        </trans-unit>
        <trans-unit id="c1f993e0a0dd08ee915cc3e9cf167ebefdec7aa0" translate="yes" xml:space="preserve">
          <source>None:</source>
          <target state="translated">None:</target>
        </trans-unit>
        <trans-unit id="e62990a968e72898ad2b534a5d5ef0b2768deeb2" translate="yes" xml:space="preserve">
          <source>NoneLike:</source>
          <target state="translated">NoneLike:</target>
        </trans-unit>
        <trans-unit id="eb4fc459eedc650eb7092ee10047a19689f0d4cd" translate="yes" xml:space="preserve">
          <source>Nonoverloadable builtins</source>
          <target state="translated">Неперегружаемые конструкции</target>
        </trans-unit>
        <trans-unit id="a209e6fa751d79c5e7c6b6c0069fb20b224a488a" translate="yes" xml:space="preserve">
          <source>Normal Android apps are written in Java, to use Nim inside an Android app you need a small Java stub that calls out to a native library written in Nim using the &lt;a href=&quot;https://developer.android.com/ndk&quot;&gt;NDK&lt;/a&gt;. You can also use &lt;a href=&quot;https://developer.android.com/ndk/samples/sample_na&quot;&gt;native-activity&lt;/a&gt; to have the Java stub be auto-generated for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb66dc661861f381636ef80a030d6e4f15642186" translate="yes" xml:space="preserve">
          <source>Normal symbols are added to the index with surrounding whitespaces removed. An exception to this are table of content (TOC) entries. TOC entries are added to the index file with their third column having as much prefix spaces as their level is in the TOC (at least 1 character). The prefix whitespace helps to filter TOC entries from API or text symbols. This is important because the amount of spaces is used to replicate the hiearchy for document TOCs in the final index, and TOC entries found in &lt;code&gt;.nim&lt;/code&gt; files are discarded.</source>
          <target state="translated">Обычные символы добавляются к индексу с удалением окружающих пробелов. Исключением являются записи в таблице содержания (TOC). Записи оглавления добавляются в индексный файл, причем их третий столбец имеет столько префиксных пробелов, сколько их уровень находится в оглавлении (не менее 1 символа). Пробел префикса помогает фильтровать записи оглавления из API или текстовых символов. Это важно, поскольку количество пробелов используется для репликации иерархии оглавлений документов в окончательном индексе, а записи оглавления, обнаруженные в файлах &lt;code&gt;.nim&lt;/code&gt; , отбрасываются.</target>
        </trans-unit>
        <trans-unit id="b2311ed7d695294572b2e47ef09cbf7395d919cc" translate="yes" xml:space="preserve">
          <source>Normalize a path.</source>
          <target state="translated">Нормализуй путь.</target>
        </trans-unit>
        <trans-unit id="88b967ed3ef7a6725101f93ac01771eb39040fe8" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;code&gt;s&lt;/code&gt; as a Nim identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23b19ce6bd569b872dfb26317c2ba486b398fed" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc401dc387c902dea14776d7f9bdd3484fd7eecd" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Нормализует строку &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="189e5cbc3b2e9402b7839197455dd96543d0d4ac" translate="yes" xml:space="preserve">
          <source>Not available for JS backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4111577c9d69153a097caeb5d59cb7772b3248" translate="yes" xml:space="preserve">
          <source>Not equals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b87a9d966e87007d02f8daaa4c946c260411a9b" translate="yes" xml:space="preserve">
          <source>Not nil annotation</source>
          <target state="translated">Не ноль аннотация</target>
        </trans-unit>
        <trans-unit id="8e5e6194b87f5a890650f1c4bfbf0e220197df8e" translate="yes" xml:space="preserve">
          <source>Not nil annotations are not supported.</source>
          <target state="translated">Не поддерживаются ноль примечаний.</target>
        </trans-unit>
        <trans-unit id="7a8674a1a5764153c229b94ca832a584559616dd" translate="yes" xml:space="preserve">
          <source>Not predicate</source>
          <target state="translated">Не предикат</target>
        </trans-unit>
        <trans-unit id="3d01d18bf9a6daa3fb19ea60a23f7dd70f8af43a" translate="yes" xml:space="preserve">
          <source>Not predicate: Indicate failure if expression E matches the text ahead; otherwise indicate success. Do not consume any text.</source>
          <target state="translated">Не предикатно:Укажите неудачу,если выражение E совпадает с текстом впереди;в противном случае укажите успех.Не потреблять текст.</target>
        </trans-unit>
        <trans-unit id="372ee3c9236cc0455481f60f3b86be209faab779" translate="yes" xml:space="preserve">
          <source>Not supported for JS backend, use &lt;a href=&quot;strutils#cmpIgnoreCase%2Cstring%2Cstring&quot;&gt;strutils.cmpIgnoreCase&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c6219b3ee58abf2bacef53dd21d8b78344d8d7" translate="yes" xml:space="preserve">
          <source>Not supported for JS backend, use &lt;a href=&quot;strutils#cmpIgnoreStyle%2Cstring%2Cstring&quot;&gt;strutils.cmpIgnoreStyle&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb537afc8ef61289c5a65dac8f48c5cd88026a7d" translate="yes" xml:space="preserve">
          <source>Not very useful by its own, you can use it to create &lt;em&gt;inverted&lt;/em&gt; sets to make the &lt;a href=&quot;#find,string,set%5Bchar%5D,Natural,int&quot;&gt;find proc&lt;/a&gt; find &lt;strong&gt;invalid&lt;/strong&gt; characters in strings. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542c73c0783f6a29758964ce1947b79cd5d16744" translate="yes" xml:space="preserve">
          <source>Not very useful by its own, you can use it to create &lt;em&gt;inverted&lt;/em&gt; sets to make the &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find() proc&lt;/a&gt; find &lt;strong&gt;invalid&lt;/strong&gt; characters in strings. Example:</source>
          <target state="translated">Сам по себе не очень полезен, вы можете использовать его для создания &lt;em&gt;инвертированных&lt;/em&gt; наборов, чтобы процедура &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find ()&lt;/a&gt; находила &lt;strong&gt;недопустимые&lt;/strong&gt; символы в строках. Пример:</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="04228ae1050018eb31f9f0fcb6a78ef941137a15" translate="yes" xml:space="preserve">
          <source>Note how the built-in &lt;code&gt;len&lt;/code&gt; proc returns only the array's first dimension length. Another way of defining the &lt;code&gt;LightTower&lt;/code&gt; to better illustrate its nested nature would be to omit the previous definition of the &lt;code&gt;LevelSetting&lt;/code&gt; type and instead write it embedded directly as the type of the first dimension:</source>
          <target state="translated">Обратите внимание, как встроенная процедура &lt;code&gt;len&lt;/code&gt; возвращает только длину первого измерения массива. Другой способ определения &lt;code&gt;LightTower&lt;/code&gt; , чтобы лучше проиллюстрировать его вложенный характер, - это опустить предыдущее определение типа &lt;code&gt;LevelSetting&lt;/code&gt; и вместо этого написать его встроенным непосредственно как тип первого измерения:</target>
        </trans-unit>
        <trans-unit id="cd3704db1df15da0eb18abb96f396dc8315f28b4" translate="yes" xml:space="preserve">
          <source>Note how the example contains extra C code to declare the &lt;code&gt;iupdll&lt;/code&gt; symbol in the generated Nim code.</source>
          <target state="translated">Обратите внимание, как в примере содержится дополнительный код C для объявления символа &lt;code&gt;iupdll&lt;/code&gt; в сгенерированном коде Nim.</target>
        </trans-unit>
        <trans-unit id="33e40503f2c45525bd696a9b1577019e4a6a54a7" translate="yes" xml:space="preserve">
          <source>Note how the set turns enum values into powers of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9897f075d01f2091487e98593989f12def2c9e19" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$app&lt;/code&gt;, &lt;code&gt;$appname&lt;/code&gt;, and &lt;code&gt;$appdir&lt;/code&gt; are not supported when using the JavaScript backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a791309560be143e9e6f64f7aa9877ff5cada7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TimeInterval&lt;/code&gt; doesn't represent a fixed duration of time, since the duration of some units depend on the context (e.g a year can be either 365 or 366 days long). The non-fixed time units are years, months, days and week.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94766cead949b3e8ea24b0db0a77a97e426ab4e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TimeInterval&lt;/code&gt;'s returned from the &lt;code&gt;times&lt;/code&gt; module are never normalized. If you want to normalize a time unit, &lt;a href=&quot;#Duration&quot;&gt;Duration&lt;/a&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf4a48e6d5642c56029b0227b694330e642ab42" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ashr&lt;/code&gt; is not an operator so use the normal function call syntax for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6b9b4ceabc50bdb117bfb8df4ea521f2a5d675" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;getCurrentException&lt;/code&gt; always returns a &lt;code&gt;ref Exception&lt;/code&gt; type. If a variable of the proper type is needed (in the example above, &lt;code&gt;IOError&lt;/code&gt;), one must convert it explicitly:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;getCurrentException&lt;/code&gt; всегда возвращает тип &lt;code&gt;ref Exception&lt;/code&gt; . Если требуется переменная правильного типа (в приведенном выше примере &lt;code&gt;IOError&lt;/code&gt; ), ее необходимо преобразовать явно:</target>
        </trans-unit>
        <trans-unit id="15f8bf07037666cd628faf3d8b1289a1ebbe6888" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import math as m&lt;/code&gt; does not use a different node; rather, we use &lt;code&gt;nnkImportStmt&lt;/code&gt; with &lt;code&gt;as&lt;/code&gt; as an infix operator.</source>
          <target state="translated">Обратите внимание, что при &lt;code&gt;import math as m&lt;/code&gt; не используется другой узел; вместо этого мы используем &lt;code&gt;nnkImportStmt&lt;/code&gt; с &lt;code&gt;as&lt;/code&gt; в качестве инфиксного оператора.</target>
        </trans-unit>
        <trans-unit id="3850a394097e20f4e139b6c553e491a35ada914b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;s&lt;/code&gt; must be declared as a &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5663a783c31085b10a438aaa39d48ac8ef1674" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;system.finished&lt;/code&gt; is error prone to use because it only returns &lt;code&gt;true&lt;/code&gt; one iteration after the iterator has finished:</source>
          <target state="translated">Обратите внимание, что использование &lt;code&gt;system.finished&lt;/code&gt; подвержено ошибкам, поскольку оно возвращает &lt;code&gt;true&lt;/code&gt; только на одной итерации после завершения итератора:</target>
        </trans-unit>
        <trans-unit id="bc55a86bc2176f00ed0cc4a2ced7592a3287c04a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;using&lt;/code&gt; is not applied for &lt;code&gt;template&lt;/code&gt; since the untyped template parameters default to the type &lt;code&gt;system.untyped&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65e48edf1a92ed7ba69b341dc76ceb955ed905a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;using&lt;/code&gt; is not applied for &lt;code&gt;template&lt;/code&gt; since untyped template parameters default to the type &lt;code&gt;system.untyped&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;using&lt;/code&gt; не применяется к &lt;code&gt;template&lt;/code&gt; поскольку нетипизированные параметры шаблона по умолчанию имеют тип &lt;code&gt;system.untyped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eaa79a5d51a878bd30d77cb48d9cf5f64b35ea7" translate="yes" xml:space="preserve">
          <source>Note that Nim's extended raw string literals support the syntax &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; as a short form for &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что расширенные необработанные строковые литералы Nim поддерживают синтаксис &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; как краткую форму для &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="541571b7bbe9cf9e61fcadf529c49d38c395b8d1" translate="yes" xml:space="preserve">
          <source>Note that Nim's extended raw string literals support the syntax &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; as a short form for &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt;. Also note that since this compiles the regular expression, which is expensive, you should avoid putting it directly in the arguments of the functions like the examples show below if you plan to use it a lot of times, as this will hurt performance immensely. (e.g. outside a loop, ...)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66958a893582569a32abe154668c902b04b269b9" translate="yes" xml:space="preserve">
          <source>Note that a duration can be negative, so even if &lt;code&gt;a &amp;lt; b&lt;/code&gt; is true &lt;code&gt;a&lt;/code&gt; might represent a larger absolute duration. Use &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; to compare the absolute duration.</source>
          <target state="translated">Обратите внимание, что продолжительность может быть отрицательной, поэтому даже если &lt;code&gt;a &amp;lt; b&lt;/code&gt; истинно, &lt;code&gt;a&lt;/code&gt; может представлять большую абсолютную продолжительность. Используйте &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; для сравнения абсолютной продолжительности.</target>
        </trans-unit>
        <trans-unit id="11d04164bd578d4758910d31096e77690bec376a" translate="yes" xml:space="preserve">
          <source>Note that a message's level is still checked against each handler's &lt;code&gt;levelThreshold&lt;/code&gt; and the global log filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a61e95866e9147c08e9c2d0fd1b10e87385ea4" translate="yes" xml:space="preserve">
          <source>Note that an explicit array constructor passed to a &lt;code&gt;varargs&lt;/code&gt; parameter is not wrapped in another implicit array construction:</source>
          <target state="translated">Обратите внимание, что явный конструктор массива, переданный параметру &lt;code&gt;varargs&lt;/code&gt; , не заключен в другую неявную конструкцию массива:</target>
        </trans-unit>
        <trans-unit id="580208a43972b50356da5b1da0797b119e251075" translate="yes" xml:space="preserve">
          <source>Note that at the moment the word &lt;code&gt;proc&lt;/code&gt; is returned for the signature of the found method instead of the expected &lt;code&gt;method&lt;/code&gt;. This may change in the future.</source>
          <target state="translated">Обратите внимание, что на данный момент слово &lt;code&gt;proc&lt;/code&gt; возвращается для сигнатуры найденного метода вместо ожидаемого &lt;code&gt;method&lt;/code&gt; . Это может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="24c487cedc7c752e18df39ebc5ba3ec45556047e" translate="yes" xml:space="preserve">
          <source>Note that container &lt;code&gt;s&lt;/code&gt; must be declared as a &lt;code&gt;var&lt;/code&gt; and it is required for your input and output types to be the same, since &lt;code&gt;s&lt;/code&gt; is modified in-place. The parameter function takes a &lt;code&gt;var T&lt;/code&gt; type parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a1d492f470ea3d6702b7d65ba7a1f02a7ad547" translate="yes" xml:space="preserve">
          <source>Note that container &lt;code&gt;s&lt;/code&gt; must be declared as a &lt;code&gt;var&lt;/code&gt; and it is required for your input and output types to be the same, since &lt;code&gt;s&lt;/code&gt; is modified in-place. The parameter function takes and returns a &lt;code&gt;T&lt;/code&gt; type variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe89c735f73e47df7589d2ce0f730288a5b272a5" translate="yes" xml:space="preserve">
          <source>Note that declaring multiple variables with a single assignment which calls a procedure can have unexpected results: the compiler will &lt;em&gt;unroll&lt;/em&gt; the assignments and end up calling the procedure several times. If the result of the procedure depends on side effects, your variables may end up having different values! For safety use side-effect free procedures if making multiple assignments.</source>
          <target state="translated">Обратите внимание, что объявление нескольких переменных с одним назначением, которое вызывает процедуру, может иметь неожиданные результаты: компилятор &lt;em&gt;развернет&lt;/em&gt; назначения и вызовет процедуру несколько раз. Если результат процедуры зависит от побочных эффектов, ваши переменные могут иметь разные значения! В целях безопасности при выполнении нескольких назначений используйте процедуры без побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="c80f0b7fe87a1023b9ef2a3f07090c0f9848e853" translate="yes" xml:space="preserve">
          <source>Note that due to Nim's parameter passing semantics this means that &lt;code&gt;T&lt;/code&gt; doesn't need to be copied so &lt;code&gt;awaitAndThen&lt;/code&gt; can sometimes be more efficient than &lt;a href=&quot;#%5E,FlowVar%5BT%5D&quot;&gt;^ proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fc07cec95ec5e1fead7b4c0cc4bdbd5f963690" translate="yes" xml:space="preserve">
          <source>Note that either the second or third (or both) parameters above must exist, as the compiler needs to know the type somehow (which it can infer from the given assignment).</source>
          <target state="translated">Обратите внимание,что либо второй,либо третий (или оба)параметр должен существовать,так как компилятор должен как-то знать тип (который он может вывести из заданного присваивания).</target>
        </trans-unit>
        <trans-unit id="315d31332dc9316e7f3826cb4f065e4db97ff67a" translate="yes" xml:space="preserve">
          <source>Note that even though &lt;code&gt;Any&lt;/code&gt; and its operations hide the nasty low level details from its clients, it remains inherently unsafe! Also, Nim's runtime type information will evolve and may eventually be deprecated. As an alternative approach to programmatically understanding and manipulating types, consider using the &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; package to work with the types' AST representation at compile time. See, for example, the &lt;a href=&quot;macros#getTypeImpl,NimNode&quot;&gt;getTypeImpl proc&lt;/a&gt;. As an alternative approach to storing arbitrary types at runtime, consider using generics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa4224474e4b6c80954422260464c3b4a8019a5" translate="yes" xml:space="preserve">
          <source>Note that for floats, the result cannot always be interpreted as &quot;greatest decimal &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;z*N == x and z*M == y&lt;/code&gt; where N and M are positive integers.&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3974a69d8025c1886c72445a8fb4b0c0716b4564" translate="yes" xml:space="preserve">
          <source>Note that for systems with a continuous stack (which most systems have) the check whether the ref is on the stack is very cheap (only two comparisons).</source>
          <target state="translated">Обратите внимание,что для систем с непрерывным стеком (который есть у большинства систем)проверка наличия ссылки в стеке очень дешева (только два сравнения).</target>
        </trans-unit>
        <trans-unit id="9d1f8d76ba4bd5c129c2a18a24e1dab11a14ed65" translate="yes" xml:space="preserve">
          <source>Note that in most circumstances one should only disable the mark and sweep phase with &lt;a href=&quot;#GC_disableMarkAndSweep&quot;&gt;GC_disableMarkAndSweep&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e095193050971ff047ad4d5c8afbbc2efec37383" translate="yes" xml:space="preserve">
          <source>Note that in the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because it makes more sense for them to use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">Обратите внимание, что в этом примере конструкторы &lt;code&gt;newLit&lt;/code&gt; и &lt;code&gt;newPlus&lt;/code&gt; являются procs , потому что для них имеет смысл использовать статическое связывание, но &lt;code&gt;eval&lt;/code&gt; - это метод, поскольку он требует динамического связывания.</target>
        </trans-unit>
        <trans-unit id="ba700b00e3387a40d1683b4c05ca6858e147eb43" translate="yes" xml:space="preserve">
          <source>Note that it is space sensitive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ad541deafb8f63a37e09491c7556544b9d95b3" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;nnkTypeDef&lt;/code&gt; utilize &lt;code&gt;nnkIdent&lt;/code&gt; as their parameter. One of the most common uses of type declarations is to work with objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11be0dfde35904fa7f02afe90c20970ebac48dfb" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;nnkTypeDef&lt;/code&gt; utilize &lt;code&gt;nnkIdent&lt;/code&gt; as their their parameter. One of the most common uses of type declarations is to work with objects.</source>
          <target state="translated">Обратите внимание, что не все &lt;code&gt;nnkTypeDef&lt;/code&gt; используют &lt;code&gt;nnkIdent&lt;/code&gt; в качестве своего параметра. Одно из наиболее распространенных применений объявлений типов - работа с объектами.</target>
        </trans-unit>
        <trans-unit id="0224a1f68a8585cd4a55cb358bf685741b3afb31" translate="yes" xml:space="preserve">
          <source>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</source>
          <target state="translated">Обратите внимание,что восьмеричные значения 100 и более не должны вводиться ведущим нулем,так как никогда не считывается не более трех восьмеричных цифр.</target>
        </trans-unit>
        <trans-unit id="359593d58b85b30432eb40cd29b67c1829ffd3da" translate="yes" xml:space="preserve">
          <source>Note that one can use &lt;code&gt;gorge&lt;/code&gt; from the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt; to embed parameters from an external command that will be executed during semantic analysis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0c14568cc44b3aa6b93616a9638e1e67aa608b" translate="yes" xml:space="preserve">
          <source>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</source>
          <target state="translated">Обратите внимание,что поскольку это итератор,вы не должны изменять строку,над которой выполняется итерация:могут случиться плохие вещи.</target>
        </trans-unit>
        <trans-unit id="0c6ff8ba25ceb642b409cfabb3508e2a2e6d8e4b" translate="yes" xml:space="preserve">
          <source>Note that some floating point numbers (e.g. infinity or even 1e19) cannot be accurately converted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e26b1561a3f022726ef326aaca35071eca0d805" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Time&lt;/code&gt; argument does not represent a point in time, it represent a local time! E.g if &lt;code&gt;adjTime&lt;/code&gt; is &lt;code&gt;fromUnix(0)&lt;/code&gt;, it should be interpreted as 1970-01-01T00:00:00 in the &lt;code&gt;zone&lt;/code&gt; timezone, not in UTC.</source>
          <target state="translated">Обратите внимание, что аргумент &lt;code&gt;Time&lt;/code&gt; не представляет момент времени, он представляет местное время! Например, если &lt;code&gt;adjTime&lt;/code&gt; имеет значение &lt;code&gt;fromUnix(0)&lt;/code&gt; , его следует интерпретировать как 1970-01-01T00: 00: 00 в часовом &lt;code&gt;zone&lt;/code&gt; , а не в формате UTC.</target>
        </trans-unit>
        <trans-unit id="ff3153be7f62193c7a012288373ef96e64821a33" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;importcpp&lt;/code&gt; variant for procs uses a somewhat cryptic pattern language for maximum flexibility:</source>
          <target state="translated">Обратите внимание, что вариант &lt;code&gt;importcpp&lt;/code&gt; для procs использует несколько загадочный язык шаблонов для максимальной гибкости:</target>
        </trans-unit>
        <trans-unit id="f79f9b3f84579ddfcfc49f356b7732e51770554f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;jsondoc&lt;/code&gt; command outputs it's JSON without pretty-printing it, while &lt;code&gt;jsondoc0&lt;/code&gt; outputs pretty-printed JSON.</source>
          <target state="translated">Обратите внимание, что команда &lt;code&gt;jsondoc&lt;/code&gt; выводит это JSON без красивой печати, тогда как &lt;code&gt;jsondoc0&lt;/code&gt; выводит красиво напечатанный JSON.</target>
        </trans-unit>
        <trans-unit id="e1b7da4962a08c6b2249b0042ce79badfd4c9b0e" translate="yes" xml:space="preserve">
          <source>Note that the compiler maps that to the &lt;code&gt;#pragma omp parallel for&lt;/code&gt; construct of &lt;span id=&quot;openmp_1&quot;&gt;OpenMP&lt;/span&gt; and as such isn't aware of the parallelism in your code! Be careful! Later versions of &lt;code&gt;||&lt;/code&gt; will get proper support by Nim's code generator and GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a40c5d3a6d57a617cae578c4709a1aa7f56b0c" translate="yes" xml:space="preserve">
          <source>Note that the compiler maps that to the &lt;code&gt;#pragma omp parallel for&lt;/code&gt; construct of &lt;span id=&quot;openmp_2&quot;&gt;OpenMP&lt;/span&gt; and as such isn't aware of the parallelism in your code! Be careful! Later versions of &lt;code&gt;||&lt;/code&gt; will get proper support by Nim's code generator and GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ac3d817acc6699555135aadc50a22472888948" translate="yes" xml:space="preserve">
          <source>Note that the default generator always starts in the same state. The &lt;a href=&quot;#randomize&quot;&gt;randomize proc&lt;/a&gt; can be called to initialize the default generator with a seed based on the current time, and it only needs to be called once before the first usage of procs from this module. If &lt;code&gt;randomize&lt;/code&gt; is not called, then the default generator will always produce the same results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0657a4b90e474cfb90775d71e0fec2c9d65f4786" translate="yes" xml:space="preserve">
          <source>Note that the encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.</source>
          <target state="translated">Обратите внимание,что кодировка не может быть изменена после ее установки.Согласно документации SQLite3,любая попытка изменить кодировку после создания базы данных будет молча игнорироваться.</target>
        </trans-unit>
        <trans-unit id="9cb042b8b29c59f41b3cd0e948e779e25db65a35" translate="yes" xml:space="preserve">
          <source>Note that the module name is still &lt;code&gt;strutils&lt;/code&gt; and not &lt;code&gt;lib/pure/strutils&lt;/code&gt; and so one &lt;strong&gt;cannot&lt;/strong&gt; do:</source>
          <target state="translated">Обратите внимание, что имя модуля по-прежнему &lt;code&gt;strutils&lt;/code&gt; а не &lt;code&gt;lib/pure/strutils&lt;/code&gt; поэтому &lt;strong&gt;нельзя&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="343c37cc8e2a037df9dff1a349a478f071828d8b" translate="yes" xml:space="preserve">
          <source>Note that the pattern language naturally also covers C++'s operator overloading capabilities:</source>
          <target state="translated">Обратите внимание,что язык шаблонов естественно также охватывает возможности перегрузки операторов С++:</target>
        </trans-unit>
        <trans-unit id="8cde912a6f95d6bc0c0ad134a4919451e220d036" translate="yes" xml:space="preserve">
          <source>Note that the regular expression does not behave as intended either: in the example &lt;code&gt;*&lt;/code&gt; should not be greedy, so &lt;code&gt;\[.*?\]&lt;/code&gt; should be used instead.</source>
          <target state="translated">Обратите внимание, что регулярное выражение также ведет себя не так, как задумано: в примере &lt;code&gt;*&lt;/code&gt; не должно быть жадным, поэтому вместо него следует использовать &lt;code&gt;\[.*?\]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f120496e6d813c76cb6c4055f029e22950f8809c" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be &lt;code&gt;nil&lt;/code&gt;. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</source>
          <target state="translated">Обратите внимание, что последовательность будет заполнена обнуленными записями, что может быть проблемой для последовательностей, содержащих строки, поскольку их значение будет равно &lt;code&gt;nil&lt;/code&gt; . После создания последовательности вы должны назначить записи последовательности, а не добавлять их. Пример:</target>
        </trans-unit>
        <trans-unit id="de5af658288d60206e55385523786da7d39f926a" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries. After the creation of the sequence you should assign entries to the sequence instead of adding them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2997a3fd7a7a4785860a47b62d4eebe1a899d888" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f32cf721122a35c0f4af8b0ef39f1b57a1cde09" translate="yes" xml:space="preserve">
          <source>Note that the trigonometric functions naturally operate on radians. The helper functions &lt;a href=&quot;#degToRad,T&quot;&gt;degToRad&lt;/a&gt; and &lt;a href=&quot;#radToDeg,T&quot;&gt;radToDeg&lt;/a&gt; provide conversion between radians and degrees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afc5e4454ca57a472753d975721911248348abc" translate="yes" xml:space="preserve">
          <source>Note that the trigonometric functions naturally operate on radians. The helper functions &lt;em&gt;degToRad&lt;/em&gt; and &lt;em&gt;radToDeg&lt;/em&gt; provide conversion between radians and degrees.</source>
          <target state="translated">Обратите внимание, что тригонометрические функции, естественно, работают с радианами. Вспомогательные функции &lt;em&gt;degToRad&lt;/em&gt; и &lt;em&gt;radToDeg&lt;/em&gt; обеспечивают преобразование между радианами и градусами.</target>
        </trans-unit>
        <trans-unit id="b39e62dfdcac76acc3788b0504467d241681c022" translate="yes" xml:space="preserve">
          <source>Note that there can be exceptions to these rules. Nim being as flexible as it is, there will be parts of this style guide that don't make sense in certain contexts. Furthermore, just as &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;Python's style guide&lt;/a&gt; changes over time, this style guide will too.</source>
          <target state="translated">Учтите, что из этих правил могут быть исключения. Несмотря на то, что Nim настолько гибок, в этом руководстве по стилю будут некоторые части, которые не имеют смысла в определенных контекстах. Более того, как &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;руководство по стилю Python, так и это руководство по стилю будет меняться&lt;/a&gt; со временем.</target>
        </trans-unit>
        <trans-unit id="f45c1e74fbf037d56e89d6aed23541b59684fe6f" translate="yes" xml:space="preserve">
          <source>Note that there can be exceptions to these rules. Nim being as flexible as it is, there will be parts of this style guide that don't make sense in certain contexts. Furthermore, just as &lt;a href=&quot;https://legacy.python.org/dev/peps/pep-0008/&quot;&gt;Python's style guide&lt;/a&gt; changes over time, this style guide will too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fed77603f9454dbdef2e75534af23ed17061d9e" translate="yes" xml:space="preserve">
          <source>Note that this is a &lt;em&gt;runtime&lt;/em&gt; call and using &lt;code&gt;quit&lt;/code&gt; inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; or &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatal&lt;/a&gt; pragmas.</source>
          <target state="translated">Обратите внимание, что это вызов &lt;em&gt;времени выполнения,&lt;/em&gt; и использование &lt;code&gt;quit&lt;/code&gt; внутри макроса не будет иметь никакого эффекта времени компиляции. Если вам нужно остановить компилятор внутри макроса, используйте прагмы &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; или &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04eea85d84506e2be9f7ff640da1764e6c3b0050" translate="yes" xml:space="preserve">
          <source>Note that this is basically the only form of type inference that exists in Nim: it is a good compromise between brevity and readability.</source>
          <target state="translated">Обратите внимание,что это,по сути,единственная форма типового вывода,которая существует в Nim:это хороший компромисс между краткостью и читабельности.</target>
        </trans-unit>
        <trans-unit id="58d880698f829e5e05f8d05a0d0ab0bc71e4e33a" translate="yes" xml:space="preserve">
          <source>Note that this pragma has been abused in the past to also work in the js backend for js objects and functions. : Other backends do provide the same feature under the same name. Also, when the target language is not set to C, other pragmas are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca57587cd09e4fd62d9d47bd97a7a8675351ea8c" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name.</source>
          <target state="translated">Обратите внимание,что эта прагма в некотором роде неправильная:Другие бэкэнды предоставляют ту же функцию под тем же именем.</target>
        </trans-unit>
        <trans-unit id="6aa0aaed3cc81e0439834c7c529aa1845e5383d7" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name. Also, if one is interfacing with C++ the &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp pragma&lt;/a&gt; and interfacing with Objective-C the &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC pragma&lt;/a&gt; can be used.</source>
          <target state="translated">Обратите внимание, что эта прагма в некоторой степени неверна: другие серверные ВМ предоставляют ту же функцию под тем же именем. Кроме того, если вы взаимодействуете с C ++, &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;прагму ImportCpp&lt;/a&gt; и взаимодействуете с Objective-C, то можно использовать &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;прагму ImportObjC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5d063d7e7c89bcb1be31e9838c1418c3a823324" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes a &lt;code&gt;var T&lt;/code&gt; type parameter.</source>
          <target state="translated">Обратите внимание, что для этого требуется, чтобы типы ввода и вывода были одинаковыми, поскольку они изменяются на месте. Функция параметра принимает параметр типа &lt;code&gt;var T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfd22634c739d8b9963ba6240e6f789a4901df14" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes and returns a &lt;code&gt;T&lt;/code&gt; type variable.</source>
          <target state="translated">Обратите внимание, что для этого требуется, чтобы типы ввода и вывода были одинаковыми, поскольку они изменяются на месте. Функция параметра принимает и возвращает переменную типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0ca87ec29ac7228de79e4d262997ceff6fd5ce6" translate="yes" xml:space="preserve">
          <source>Note that this rule also applies to keywords, meaning that &lt;code&gt;notin&lt;/code&gt; is the same as &lt;code&gt;notIn&lt;/code&gt; and &lt;code&gt;not_in&lt;/code&gt; (all-lowercase version (&lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt;) is the preferred way of writing keywords).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e73723c67698a4db4dbcdaa04c4f3387732c63" translate="yes" xml:space="preserve">
          <source>Note that this version of &lt;code&gt;map&lt;/code&gt; requires your input and output types to be the same, since they are modified in-place.</source>
          <target state="translated">Обратите внимание, что эта версия &lt;code&gt;map&lt;/code&gt; требует, чтобы ваши типы ввода и вывода были одинаковыми, поскольку они изменяются на месте.</target>
        </trans-unit>
        <trans-unit id="35a43adebbe7d9517e28187d2c67478e70dbaf9e" translate="yes" xml:space="preserve">
          <source>Note that type inference works for parameters with default values; there is no need to write &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt;, for example.</source>
          <target state="translated">Обратите внимание, что вывод типа работает для параметров со значениями по умолчанию; например, не нужно писать &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="025bc18a2bc141ea4af9a1700e4ee039cbf3bd9f" translate="yes" xml:space="preserve">
          <source>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</source>
          <target state="translated">Обратите внимание,что если не задана минимальная ширина поля,то ширина поля всегда будет равна ширине заполняемых данных,так что опция выравнивания в данном случае не имеет значения.</target>
        </trans-unit>
        <trans-unit id="a4f6df5cd8b79acdb0c70f5d30510d6e8cdfa162" translate="yes" xml:space="preserve">
          <source>Note that unordered or ordered choice operators (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) are not implemented.</source>
          <target state="translated">Обратите внимание, что операторы неупорядоченного или упорядоченного выбора ( &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; ) не реализованы.</target>
        </trans-unit>
        <trans-unit id="21df650805f0f9da23f06c6e6caddf7af086fddf" translate="yes" xml:space="preserve">
          <source>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to &lt;code&gt;31 October&lt;/code&gt; will result in &lt;code&gt;31 November&lt;/code&gt;, which will overflow and result in &lt;code&gt;1 December&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f37b4c7971dff9f25702efc2db169764ea60985" translate="yes" xml:space="preserve">
          <source>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to &lt;em&gt;31 October&lt;/em&gt; will result in &lt;em&gt;31 November&lt;/em&gt;, which will overflow and result in &lt;em&gt;1 December&lt;/em&gt;.</source>
          <target state="translated">Обратите внимание, что при добавлении месяцев допускается переполнение дня месяца. Это означает, что если в результирующем месяце не хватает дней, месяц будет увеличиваться, а в качестве дня месяца будет установлено количество дней, за которые произошло переполнение. Таким образом, добавление одного месяца к &lt;em&gt;31 октября&lt;/em&gt; приведет к &lt;em&gt;31 ноября&lt;/em&gt; , что приведет к переполнению и &lt;em&gt;1 декабря&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="768312a6255dc501e7c26889c546bd253fd2aec8" translate="yes" xml:space="preserve">
          <source>Note that when passing objects to procedures on another thread by pointer (for example through a thread's argument), objects created using the default allocator will use thread-local, GC-managed memory. Thus it is generally safer to store channel objects in global variables (as in the above example), in which case they will use a process-wide (thread-safe) shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4120fed8da8d3978e684516d5bde06baadb627e" translate="yes" xml:space="preserve">
          <source>Note that while the value returned is of type &lt;code&gt;var B&lt;/code&gt;, it is easy to accidentally create an copy of the value at &lt;code&gt;t[key]&lt;/code&gt;. Remember that seqs and strings are value types, and therefore cannot be copied into a separate variable for modification. See the example below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f7073771e81c9dae2114aa3af0598ed46cf0ad" translate="yes" xml:space="preserve">
          <source>Note that with multiple infix operators, the command is parsed by operator precedence.</source>
          <target state="translated">Обратите внимание,что при использовании нескольких инффиксных операторов команда разбирается по приоритету оператора.</target>
        </trans-unit>
        <trans-unit id="c76fa1132c9049877899fb2dd217fb4f9fb94f6c" translate="yes" xml:space="preserve">
          <source>Note that without the &lt;em&gt;*&lt;/em&gt; following the name of the type, the documentation for this type would not be generated. Documentation will only be generated for &lt;em&gt;exported&lt;/em&gt; types/procedures/etc.</source>
          <target state="translated">Обратите внимание, что без &lt;em&gt;*&lt;/em&gt; после имени типа документация для этого типа не будет создана. Документация будет создана только для &lt;em&gt;экспортируемых&lt;/em&gt; типов / процедур / и т. Д.</target>
        </trans-unit>
        <trans-unit id="83dc7e0556afc26215f0f05cbb05794c79af8e39" translate="yes" xml:space="preserve">
          <source>Note that you can use &lt;code&gt;gorge&lt;/code&gt; from the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt; to embed parameters from an external command at compile time:</source>
          <target state="translated">Обратите внимание, что вы можете использовать &lt;code&gt;gorge&lt;/code&gt; из &lt;a href=&quot;system&quot;&gt;системного модуля&lt;/a&gt; для внедрения параметров из внешней команды во время компиляции:</target>
        </trans-unit>
        <trans-unit id="03602da7fc5f3527dab2cb6a5e9fa3d6f417f9f6" translate="yes" xml:space="preserve">
          <source>Note that you can use this proc inside a pragma like &lt;a href=&quot;manual#implementation-specific-pragmas-passc-pragma&quot;&gt;passc&lt;/a&gt; or &lt;a href=&quot;manual#implementation-specific-pragmas-passl-pragma&quot;&gt;passl&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75dacd50fe5a788cdf642a67310a4f0cc7d7c77" translate="yes" xml:space="preserve">
          <source>Note that you can't pass any &lt;code&gt;args&lt;/code&gt; if you use the option &lt;code&gt;poEvalCommand&lt;/code&gt;, which invokes the system shell to run the specified &lt;code&gt;command&lt;/code&gt;. In this situation you have to concatenate manually the contents of &lt;code&gt;args&lt;/code&gt; to &lt;code&gt;command&lt;/code&gt; carefully escaping/quoting any special characters, since it will be passed &lt;em&gt;as is&lt;/em&gt; to the system shell. Each system/shell may feature different escaping rules, so try to avoid this kind of shell invocation if possible as it leads to non portable software.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8772d3554a687071842e284d2ee1e51238d62e" translate="yes" xml:space="preserve">
          <source>Note that you can't pass any &lt;em&gt;args&lt;/em&gt; if you use the option &lt;code&gt;poEvalCommand&lt;/code&gt;, which invokes the system shell to run the specified &lt;em&gt;command&lt;/em&gt;. In this situation you have to concatenate manually the contents of &lt;em&gt;args&lt;/em&gt; to &lt;em&gt;command&lt;/em&gt; carefully escaping/quoting any special characters, since it will be passed &lt;em&gt;as is&lt;/em&gt; to the system shell. Each system/shell may feature different escaping rules, so try to avoid this kind of shell invocation if possible as it leads to non portable software.</source>
          <target state="translated">Обратите внимание, что вы не можете передавать какие-либо &lt;em&gt;аргументы,&lt;/em&gt; если используете параметр &lt;code&gt;poEvalCommand&lt;/code&gt; , который вызывает системную оболочку для выполнения указанной &lt;em&gt;команды&lt;/em&gt; . В этой ситуации вы должны сцепить вручную содержимые &lt;em&gt;аргументы&lt;/em&gt; в &lt;em&gt;команду&lt;/em&gt; тщательно спасаясь / со ссылкой на какие - либо специальные символы, так как он будет принят &lt;em&gt;как&lt;/em&gt; к системной оболочке. Каждая система / оболочка может иметь разные правила экранирования, поэтому постарайтесь по возможности избегать такого вызова оболочки, поскольку это приводит к непереносимому программному обеспечению.</target>
        </trans-unit>
        <trans-unit id="d40b1f043c53ab114d44579b20fed14c54f78029" translate="yes" xml:space="preserve">
          <source>Note that you cannot compare a floating point value to this value and expect a reasonable result - use the &lt;code&gt;classify&lt;/code&gt; procedure in the &lt;a href=&quot;math&quot;&gt;math module&lt;/a&gt; for checking for NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5592912b54a15cb049ee1308dc422e794cf8b0" translate="yes" xml:space="preserve">
          <source>Note that, unlike tuples, objects require the field names along with their values. For a &lt;code&gt;ref object&lt;/code&gt; type &lt;code&gt;system.new&lt;/code&gt; is invoked implicitly.</source>
          <target state="translated">Обратите внимание, что, в отличие от кортежей, объектам требуются имена полей вместе со своими значениями. Для типа &lt;code&gt;ref object&lt;/code&gt; &lt;code&gt;system.new&lt;/code&gt; вызывается system.new .</target>
        </trans-unit>
        <trans-unit id="4fe2a6b6231ef8afd037c1399752e71468fb5fa7" translate="yes" xml:space="preserve">
          <source>Note, single letter options that take an argument require a colon. E.g. -p:PATH.</source>
          <target state="translated">Обратите внимание,опции с одной буквой,которые принимают аргумент,требуют двоеточия.Например,-p:PATH.</target>
        </trans-unit>
        <trans-unit id="1a7f5bb7cac3eb28fa52efeaad9afaa0e45fe5ae" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;a&lt;/code&gt; can only be part of &lt;code&gt;b&lt;/code&gt;, if &lt;code&gt;a&lt;/code&gt;'s type can be part of &lt;code&gt;b&lt;/code&gt;'s type. Since however type analysis is more expensive, we perform it only if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b4d4771d7ff34d7e5d420650862df593a32f84" translate="yes" xml:space="preserve">
          <source>Note: Ensure the original #define is not seen by c2nim (notice the #ifndef C2NIM).</source>
          <target state="translated">Примечание:Убедитесь,что исходное #define не видно c2nim (обратите внимание на #ifndef C2NIM).</target>
        </trans-unit>
        <trans-unit id="589daca808645da8bffbebba1f4a3d7ffd0724bc" translate="yes" xml:space="preserve">
          <source>Note: For inter thread communication use a &lt;a href=&quot;channels&quot;&gt;Channel&lt;/a&gt; instead.</source>
          <target state="translated">Примечание. Для межпотокового взаимодействия используйте вместо этого &lt;a href=&quot;channels&quot;&gt;канал&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c98c05550ca8db8ba1bb08e3e1cdb582a3c0958" translate="yes" xml:space="preserve">
          <source>Note: Import &lt;code&gt;std/sha1&lt;/code&gt; to use this module</source>
          <target state="translated">Примечание. Импортируйте &lt;code&gt;std/sha1&lt;/code&gt; , чтобы использовать этот модуль.</target>
        </trans-unit>
        <trans-unit id="a3380d8cd20bf5139372befec400003e462558ff" translate="yes" xml:space="preserve">
          <source>Note: In general, auto-converting from int to float loses information, which is why these operators live in a separate module. Use with care.</source>
          <target state="translated">Замечание:В общем случае автоматическое преобразование из int в float теряет информацию,поэтому эти операторы живут в отдельном модуле.Используйте с осторожностью.</target>
        </trans-unit>
        <trans-unit id="bb6ec3757cbbdd1dd0301b680ca419e74971fb18" translate="yes" xml:space="preserve">
          <source>Note: Not available for JS backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4cd3c3e2d987ccf3e1ad62f1c44f6201bc3f26" translate="yes" xml:space="preserve">
          <source>Note: The data types declared here have &lt;em&gt;value semantics&lt;/em&gt;: This means that &lt;code&gt;=&lt;/code&gt; performs a copy of the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b65c5d5f2ba33aefbd25c3c5eb32dd838fe065" translate="yes" xml:space="preserve">
          <source>Note: The pattern refers to the original C identifiers, not to the resulting identifiers after mangling!</source>
          <target state="translated">Примечание:шаблон относится к оригинальным идентификаторам C,а не к результирующим идентификаторам после искажения!</target>
        </trans-unit>
        <trans-unit id="5207456ac36fc3f9063842f9bda281784379b2c6" translate="yes" xml:space="preserve">
          <source>Note: This template may not work in some cases, use &lt;a href=&quot;sugar#capture.m,openArray%5Btyped%5D,untyped&quot;&gt;capture&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b257114cf6fc959d8954b5a66399cfa481aa015" translate="yes" xml:space="preserve">
          <source>Note: Use &lt;a href=&quot;options#Option&quot;&gt;Option&lt;/a&gt; for keys sometimes missing in json responses, and backticks around keys with a reserved keyword as name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85936911cd46420f06b600d6cad5d51acfe276f" translate="yes" xml:space="preserve">
          <source>Note: While the rules outlined below are the &lt;em&gt;current&lt;/em&gt; naming conventions, these conventions have not always been in place. Previously, the naming conventions for identifiers followed the Pascal tradition of prefixes which indicated the base type of the identifier - PFoo for pointer and reference types, TFoo for value types, EFoo for exceptions, etc. Though this has since changed, there are many places in the standard library which still use this convention. Such style remains in place purely for legacy reasons, and will be changed in the future.</source>
          <target state="translated">Примечание. Приведенные ниже правила являются &lt;em&gt;текущими&lt;/em&gt; соглашениями об именах, но они не всегда действовали. Раньше соглашения об именах для идентификаторов следовали традиции префиксов Паскаля, которые указывали базовый тип идентификатора - PFoo для типов указателей и ссылок, TFoo для типов значений, EFoo для исключений и т. Д. Хотя с тех пор это изменилось, есть много мест. в стандартной библиотеке, которые все еще используют это соглашение. Такой стиль остается в силе исключительно по причинам наследия и в будущем будет изменен.</target>
        </trans-unit>
        <trans-unit id="9778d746b0391d7bd7fd0ece0b5cbc7f2a1e15d9" translate="yes" xml:space="preserve">
          <source>Note: XCode's &quot;make clean&quot; gets confused about the generated nim.c files, so you need to clean those files manually to do a clean build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fecedf4653bc748c9340a21b565062d449db86" translate="yes" xml:space="preserve">
          <source>Note: alternate ways of writing this are &lt;code&gt;b[^8..^2] = &quot;useful&quot;&lt;/code&gt; or as &lt;code&gt;b[11..b.len-2] = &quot;useful&quot;&lt;/code&gt; or as &lt;code&gt;b[11..&amp;lt;b.len-1] = &quot;useful&quot;&lt;/code&gt;.</source>
          <target state="translated">Примечание: альтернативные способы записи: &lt;code&gt;b[^8..^2] = &quot;useful&quot;&lt;/code&gt; или как &lt;code&gt;b[11..b.len-2] = &quot;useful&quot;&lt;/code&gt; или как &lt;code&gt;b[11..&amp;lt;b.len-1] = &quot;useful&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d2a8fe03f1e52e70d949a49deffb7beaa9697e" translate="yes" xml:space="preserve">
          <source>Note: there is a speed improvement if the matches do not need to be captured.</source>
          <target state="translated">Примечание:если матчи не требуют перехвата,то скорость увеличивается.</target>
        </trans-unit>
        <trans-unit id="b66ebf38768e7530c8d492ade747b6e73d402946" translate="yes" xml:space="preserve">
          <source>Note: this could block if &lt;code&gt;input.len&lt;/code&gt; is greater than your OS's maximum pipe buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e46cb88cb285ad050ff48c315bfe537707654bcc" translate="yes" xml:space="preserve">
          <source>Note: this is mostly outdated, see instead &lt;a href=&quot;nimsuggest&quot;&gt;nimsuggest&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e84c20ada2d36c53605b5b42bec5ecb1edbb93" translate="yes" xml:space="preserve">
          <source>Note: to serialize &lt;em&gt;x&lt;/em&gt; to JSON use $(%x) from the &lt;code&gt;json&lt;/code&gt; module</source>
          <target state="translated">Примечание: для сериализации &lt;em&gt;x&lt;/em&gt; в JSON используйте $ (% x) из модуля &lt;code&gt;json&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="fedfa1aa98f87579b26f162395ec81ac6f49897e" translate="yes" xml:space="preserve">
          <source>Notes when using multiple threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d40b7a681541c6f19f485d3cc6b34540337a107" translate="yes" xml:space="preserve">
          <source>NotesVerbosity:</source>
          <target state="translated">NotesVerbosity:</target>
        </trans-unit>
        <trans-unit id="a4a2ebf22ba0a60faeb2fdc809dafca8b36c3083" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; must be of the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5815dccaa90c765a4f2404d7d1dd5b55be738f8c" translate="yes" xml:space="preserve">
          <source>Notice that when exporting, one needs to specify only the module name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb925a84b12636058c161c78db99469a750858b" translate="yes" xml:space="preserve">
          <source>Notices are semantically very similar to info messages, but they are meant to be messages that the user should be actively notified about, depending on the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c599056dda568258fe7a8884f67e29669997a74a" translate="yes" xml:space="preserve">
          <source>Now that we covered the basic control flow statements, let's return to Nim indentation rules.</source>
          <target state="translated">Теперь,когда мы рассмотрели основные утверждения о потоке управления,давайте вернемся к правилам отступов Нима.</target>
        </trans-unit>
        <trans-unit id="359cc1b4d4e1198e58400a2f6178f9956362e79d" translate="yes" xml:space="preserve">
          <source>Now that we use named arguments to call &lt;code&gt;createWindow&lt;/code&gt; the argument order does not matter anymore. Mixing named arguments with ordered arguments is also possible, but not very readable:</source>
          <target state="translated">Теперь, когда мы используем именованные аргументы для вызова &lt;code&gt;createWindow&lt;/code&gt; , порядок аргументов больше не имеет значения. Смешивание именованных аргументов с упорядоченными аргументами также возможно, но не очень читаемо:</target>
        </trans-unit>
        <trans-unit id="de073aaec09d9a82c0b5660d7283e643aafc1ad4" translate="yes" xml:space="preserve">
          <source>Now the call to &lt;code&gt;createWindow&lt;/code&gt; only needs to set the values that differ from the defaults.</source>
          <target state="translated">Теперь вызов &lt;code&gt;createWindow&lt;/code&gt; должен только установить значения, которые отличаются от значений по умолчанию.</target>
        </trans-unit>
        <trans-unit id="37e192255f51d8e35fa4d8c800cc0c72921cf379" translate="yes" xml:space="preserve">
          <source>Now the following holds:</source>
          <target state="translated">Теперь следующие приёмы:</target>
        </trans-unit>
        <trans-unit id="87081d18a9fcb6da770d34e0fe4d26d7acf23a4c" translate="yes" xml:space="preserve">
          <source>Now we have compile-time checking against SQL injection attacks. Since &lt;code&gt;&quot;&quot;.SQL&lt;/code&gt; is transformed to &lt;code&gt;SQL(&quot;&quot;)&lt;/code&gt; no new syntax is needed for nice looking &lt;code&gt;SQL&lt;/code&gt; string literals. The hypothetical &lt;code&gt;SQL&lt;/code&gt; type actually exists in the library as the &lt;a href=&quot;db_common#SqlQuery&quot;&gt;SqlQuery type&lt;/a&gt; of modules like &lt;a href=&quot;db_sqlite&quot;&gt;db_sqlite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1e7ee1876e3e297d1a65cb42dae5bbd812f819" translate="yes" xml:space="preserve">
          <source>Now we have compile-time checking against SQL injection attacks. Since &lt;code&gt;&quot;&quot;.SQL&lt;/code&gt; is transformed to &lt;code&gt;SQL(&quot;&quot;)&lt;/code&gt; no new syntax is needed for nice looking &lt;code&gt;SQL&lt;/code&gt; string literals. The hypothetical &lt;code&gt;SQL&lt;/code&gt; type actually exists in the library as the &lt;a href=&quot;db_sqlite#TSqlQuery&quot;&gt;TSqlQuery type&lt;/a&gt; of modules like &lt;a href=&quot;db_sqlite&quot;&gt;db_sqlite&lt;/a&gt;.</source>
          <target state="translated">Теперь у нас есть проверка против атак SQL-инъекций во время компиляции. Поскольку &lt;code&gt;&quot;&quot;.SQL&lt;/code&gt; преобразуется в &lt;code&gt;SQL(&quot;&quot;)&lt;/code&gt; новый синтаксис для красивых строковых литералов &lt;code&gt;SQL&lt;/code&gt; не требуется . Гипотетический тип &lt;code&gt;SQL&lt;/code&gt; фактически существует в библиотеке как &lt;a href=&quot;db_sqlite#TSqlQuery&quot;&gt;модуль типа &lt;/a&gt;&lt;a href=&quot;db_sqlite&quot;&gt;TSqlQuery,&lt;/a&gt; например db_sqlite .</target>
        </trans-unit>
        <trans-unit id="ef2111c104cca92314b6843b4983145b5795a78c" translate="yes" xml:space="preserve">
          <source>Now when &lt;code&gt;bar.nim&lt;/code&gt; is compiled directly, the &lt;code&gt;getProjectPath&lt;/code&gt; will now return the &lt;code&gt;dir2/&lt;/code&gt; path, and the &lt;code&gt;currentSourcePath&lt;/code&gt; will still return the same path, the path to the &lt;code&gt;bar.nim&lt;/code&gt; source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f6d46c0b2b46a621f9252b5aed254ec60a3b55" translate="yes" xml:space="preserve">
          <source>Now when &lt;code&gt;foo.nim&lt;/code&gt; is compiled, the &lt;code&gt;getProjectPath&lt;/code&gt; from &lt;code&gt;bar.nim&lt;/code&gt; will return the &lt;code&gt;dir1/&lt;/code&gt; path, while the &lt;code&gt;currentSourcePath&lt;/code&gt; will return the path to the &lt;code&gt;bar.nim&lt;/code&gt; source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756f1995808a7a657065d45ecdba62e1e4422db8" translate="yes" xml:space="preserve">
          <source>Now you can run the following Unix like commands to first generate C sources form the Nim code, then link them into a static binary along your main C program:</source>
          <target state="translated">Теперь вы можете запустить следующие команды Unix like,чтобы сначала сгенерировать исходные тексты на Си из Nim-кода,а затем связать их в статический двоичный файл вдоль вашей основной программы на Си:</target>
        </trans-unit>
        <trans-unit id="b395673dbacaa4ff7221cdcfe84290edc07b8bb9" translate="yes" xml:space="preserve">
          <source>Now you can run the following Unix like commands to first generate C sources from the Nim code, then link them into a static binary along your main C program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cf1586c107e2ad157be6c3699e618619c6124a" translate="yes" xml:space="preserve">
          <source>Number of decimal digits that can be represented in a 32-bit floating-point type without losing precision.</source>
          <target state="translated">Количество десятичных цифр,которые могут быть представлены в 32-битном типе с плавающей точкой без потери точности.</target>
        </trans-unit>
        <trans-unit id="f2a4cda872ca90910ea60e675f66d013e1c1c5d2" translate="yes" xml:space="preserve">
          <source>Number of decimal digits that can be represented in a 64-bit floating-point type without losing precision.</source>
          <target state="translated">Количество десятичных цифр,которые могут быть представлены в 64-битном типе с плавающей точкой без потери точности.</target>
        </trans-unit>
        <trans-unit id="1e93ac306e3ccaf06ddd125b223d48515fd601ae" translate="yes" xml:space="preserve">
          <source>Number of digits (in base &lt;code&gt;floatingPointRadix&lt;/code&gt;) in the mantissa of 32-bit floating-point numbers.</source>
          <target state="translated">Количество цифр (в основании с &lt;code&gt;floatingPointRadix&lt;/code&gt; ) в мантиссе 32-разрядных чисел с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="8d111fafd83c57aff8321d904d1159c139884ca1" translate="yes" xml:space="preserve">
          <source>Number of digits (in base &lt;code&gt;floatingPointRadix&lt;/code&gt;) in the mantissa of 64-bit floating-point numbers.</source>
          <target state="translated">Количество цифр (в базовом с &lt;code&gt;floatingPointRadix&lt;/code&gt; ) в мантиссе 64-битных чисел с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="6d57434884838acf9fbf6aa87bb099375ffa68a7" translate="yes" xml:space="preserve">
          <source>Number of whole days represented by the duration.</source>
          <target state="translated">Количество целых дней,представленных длительностью.</target>
        </trans-unit>
        <trans-unit id="bbbf1dbfdd00220f8dc094d6ec5b5e3a5b7eec35" translate="yes" xml:space="preserve">
          <source>Number of whole hours represented by the duration.</source>
          <target state="translated">Количество целых часов,представленных длительностью.</target>
        </trans-unit>
        <trans-unit id="b3416e7091156db48c9ee6ff7ce55182de3f7f47" translate="yes" xml:space="preserve">
          <source>Number of whole microseconds represented by the &lt;strong&gt;fractional&lt;/strong&gt; part of the duration.</source>
          <target state="translated">Количество целых микросекунд, представленное &lt;strong&gt;дробной&lt;/strong&gt; частью длительности.</target>
        </trans-unit>
        <trans-unit id="e7efa45f297295912fd59ed47a00f3af6bfa2ef2" translate="yes" xml:space="preserve">
          <source>Number of whole milliseconds represented by the &lt;strong&gt;fractional&lt;/strong&gt; part of the duration.</source>
          <target state="translated">Количество целых миллисекунд, представленное &lt;strong&gt;дробной&lt;/strong&gt; частью длительности.</target>
        </trans-unit>
        <trans-unit id="76ab1f8aba37163bdf200dab23553396a7d3e689" translate="yes" xml:space="preserve">
          <source>Number of whole minutes represented by the duration.</source>
          <target state="translated">Количество целых минут,представленных длительностью.</target>
        </trans-unit>
        <trans-unit id="18290aaf8138cc68a7cb85c476b2a4618ec23b5c" translate="yes" xml:space="preserve">
          <source>Number of whole nanoseconds represented by the &lt;strong&gt;fractional&lt;/strong&gt; part of the duration.</source>
          <target state="translated">Количество полных наносекунд, представленное &lt;strong&gt;дробной&lt;/strong&gt; частью длительности.</target>
        </trans-unit>
        <trans-unit id="a01af1e768fd4e093861831d977f5d94b80aa9f9" translate="yes" xml:space="preserve">
          <source>Number of whole seconds represented by the duration.</source>
          <target state="translated">Количество целых секунд,представленное длительностью.</target>
        </trans-unit>
        <trans-unit id="5019b0366e2a30d163a49d5eb75e70470ba3899e" translate="yes" xml:space="preserve">
          <source>Number of whole weeks represented by the duration.</source>
          <target state="translated">Количество целых недель,представленных длительностью.</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="6d872a21aa9a7b7fea7d5fe31a5c2025c54405e4" translate="yes" xml:space="preserve">
          <source>Numbers in of the range -1000.0&amp;lt;f&amp;lt;1000.0 will be formatted without an exponent. Numbers outside of this range will be formatted as a significand in the range -1000.0&amp;lt;f&amp;lt;1000.0 and an exponent that will always be an integer multiple of 3, corresponding with the SI prefix scale k, M, G, T etc for numbers with an absolute value greater than 1 and m, &amp;mu;, n, p etc for numbers with an absolute value less than 1.</source>
          <target state="translated">Числа в диапазоне -1000.0 &amp;lt;f &amp;lt;1000.0 будут отформатированы без экспоненты. Числа вне этого диапазона будут отформатированы как мантисса в диапазоне -1000.0 &amp;lt;f &amp;lt;1000.0 и экспонента, которая всегда будет целым числом, кратным 3, что соответствует шкале префикса SI k, M, G, T и т. Д. Для чисел с абсолютное значение больше 1 и m, &amp;mu;, n, p и т. д. для чисел с абсолютным значением меньше 1.</target>
        </trans-unit>
        <trans-unit id="76046e581003f2b0494ba6b4f5311bb28033bd96" translate="yes" xml:space="preserve">
          <source>Numeric value representing the day of the month, it will be either one or two digits long.</source>
          <target state="translated">Числовое значение,представляющее день месяца,будет либо одной,либо двухзначным.</target>
        </trans-unit>
        <trans-unit id="de117b3e0329ec2102122ec4b014ce37f5a796cb" translate="yes" xml:space="preserve">
          <source>Numerical constants</source>
          <target state="translated">числовые константы</target>
        </trans-unit>
        <trans-unit id="1e9d4ed2757d3ae1dd279289b3d36043bcba7966" translate="yes" xml:space="preserve">
          <source>Numerical constants are of a single type and have the form:</source>
          <target state="translated">Числовые константы имеют один тип и форму:</target>
        </trans-unit>
        <trans-unit id="14f53cb15d3a159e9414701d05c0d3d0e93ec666" translate="yes" xml:space="preserve">
          <source>Numerical literals are written as in most other languages. As a special twist, underscores are allowed for better readability: &lt;code&gt;1_000_000&lt;/code&gt; (one million). A number that contains a dot (or 'e' or 'E') is a floating point literal: &lt;code&gt;1.0e9&lt;/code&gt; (one billion). Hexadecimal literals are prefixed with &lt;code&gt;0x&lt;/code&gt;, binary literals with &lt;code&gt;0b&lt;/code&gt; and octal literals with &lt;code&gt;0o&lt;/code&gt;. A leading zero alone does not produce an octal.</source>
          <target state="translated">Числовые литералы записываются так же, как и в большинстве других языков. Специально для удобства чтения &lt;code&gt;1_000_000&lt;/code&gt; подчеркивания: 1_000_000 (один миллион). Число, содержащее точку (или 'e' или 'E'), является литералом с плавающей запятой: &lt;code&gt;1.0e9&lt;/code&gt; (один миллиард). Шестнадцатеричные литералы имеют префикс &lt;code&gt;0x&lt;/code&gt; , двоичные литералы - &lt;code&gt;0b&lt;/code&gt; , а восьмеричные литералы - &lt;code&gt;0o&lt;/code&gt; . Один только начальный ноль не дает восьмеричного числа.</target>
        </trans-unit>
        <trans-unit id="2c5c7f8404256e0a35e506cca1a7981e7daef170" translate="yes" xml:space="preserve">
          <source>NumericalBase.base10</source>
          <target state="translated">NumericalBase.base10</target>
        </trans-unit>
        <trans-unit id="ccf3ca1a1bb490e927ea05b6581028198ac69592" translate="yes" xml:space="preserve">
          <source>NumericalBase.base16</source>
          <target state="translated">NumericalBase.base16</target>
        </trans-unit>
        <trans-unit id="ee9048563b2785fc2b606907b0087c584930c9f9" translate="yes" xml:space="preserve">
          <source>NumericalBase.base2</source>
          <target state="translated">NumericalBase.base2</target>
        </trans-unit>
        <trans-unit id="ae0213167f6a92377ed9aad1ca56953301053e5c" translate="yes" xml:space="preserve">
          <source>NumericalBase.base8</source>
          <target state="translated">NumericalBase.base8</target>
        </trans-unit>
        <trans-unit id="3d2ccad0a41ad474c931c455f0da38d9969feacd" translate="yes" xml:space="preserve">
          <source>NumericalBase:</source>
          <target state="translated">NumericalBase:</target>
        </trans-unit>
        <trans-unit id="f49726ee7d810f57a9139d6d7df541fd9f684eaf" translate="yes" xml:space="preserve">
          <source>O(n) complexity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04cb3eb98c641516855449fcdbb36cf3f897d21" translate="yes" xml:space="preserve">
          <source>OP0</source>
          <target state="translated">OP0</target>
        </trans-unit>
        <trans-unit id="e04bcfb1ab304010d11e5f6c998c2482bd0d4128" translate="yes" xml:space="preserve">
          <source>OP1</source>
          <target state="translated">OP1</target>
        </trans-unit>
        <trans-unit id="a0f424f70ed0dceb9a4df1bcbbb44ba5f55142ae" translate="yes" xml:space="preserve">
          <source>OP10</source>
          <target state="translated">OP10</target>
        </trans-unit>
        <trans-unit id="c7235db666ae5752cda05330ea4cb5178dc33cc7" translate="yes" xml:space="preserve">
          <source>OP2</source>
          <target state="translated">OP2</target>
        </trans-unit>
        <trans-unit id="0269d7bdbba9ed5972892d3d356a1a3fac87612d" translate="yes" xml:space="preserve">
          <source>OP3</source>
          <target state="translated">OP3</target>
        </trans-unit>
        <trans-unit id="edc0331fa7efd5f99c8d4978274902462f4a77f2" translate="yes" xml:space="preserve">
          <source>OP4</source>
          <target state="translated">OP4</target>
        </trans-unit>
        <trans-unit id="1076f805e66d9538ab3ed3922addefb1313d6fee" translate="yes" xml:space="preserve">
          <source>OP5</source>
          <target state="translated">OP5</target>
        </trans-unit>
        <trans-unit id="ff32e5028e5ac9dd0850a491b15bab66a3070884" translate="yes" xml:space="preserve">
          <source>OP6</source>
          <target state="translated">OP6</target>
        </trans-unit>
        <trans-unit id="c5255cf0231d866ba6a47dd27b61007d7803323f" translate="yes" xml:space="preserve">
          <source>OP7</source>
          <target state="translated">OP7</target>
        </trans-unit>
        <trans-unit id="94fa4343a5ec0348b7ea746f38cbd00d2482ae4f" translate="yes" xml:space="preserve">
          <source>OP8</source>
          <target state="translated">OP8</target>
        </trans-unit>
        <trans-unit id="f373944b57d55ca9eddf4252a4349141943f321e" translate="yes" xml:space="preserve">
          <source>OP9</source>
          <target state="translated">OP9</target>
        </trans-unit>
        <trans-unit id="bea1b7a7bcd9663ab56444c7d74124c17a8fbbfc" translate="yes" xml:space="preserve">
          <source>ORC</source>
          <target state="translated">ORC</target>
        </trans-unit>
        <trans-unit id="99bb1a1563f4d5f5cc3004055e8ee1b82817117f" translate="yes" xml:space="preserve">
          <source>OS-Path normalization. Used by &lt;code&gt;os.nim&lt;/code&gt; but also generally useful for dealing with paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380a5dcbfa19547ee9ef2a45f62b8b54d658bbde" translate="yes" xml:space="preserve">
          <source>OS-specific operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b289714645dc080e6d028dce9288aaf44c582e6" translate="yes" xml:space="preserve">
          <source>OS:</source>
          <target state="translated">OS:</target>
        </trans-unit>
        <trans-unit id="e2e3a80c4bd8a468bcd99583c85e67abc6426be7" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming</source>
          <target state="translated">Объектно-ориентированное программирование</target>
        </trans-unit>
        <trans-unit id="228b119ddf88904b9df1033a323f6ac211450b69" translate="yes" xml:space="preserve">
          <source>Object access operator &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">Оператор доступа к объекту &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="589a18f6b8265d03c5f8516a6f333a007673bfce" translate="yes" xml:space="preserve">
          <source>Object and array construction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5558dc9f8bd66c6e283c97f8881f22188449327a" translate="yes" xml:space="preserve">
          <source>Object and array construction is treated as a function call where the function has &lt;code&gt;sink&lt;/code&gt; parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ca8083a285ad1c3815b36f3d7992ca6b703603" translate="yes" xml:space="preserve">
          <source>Object construction</source>
          <target state="translated">Строительство объекта</target>
        </trans-unit>
        <trans-unit id="28b132088e585ec3607bc5ee13d1d17885737336" translate="yes" xml:space="preserve">
          <source>Object field access &lt;code&gt;e.field&lt;/code&gt; is a path expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233bb7b76158a54f9e255a510cc28ac7b239b2dc" translate="yes" xml:space="preserve">
          <source>Object fields and global variables can be annotated via a &lt;code&gt;guard&lt;/code&gt; pragma:</source>
          <target state="translated">Поля объектов и глобальные переменные можно аннотировать с помощью прагмы &lt;code&gt;guard&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="97f4ffdb6041c29c1c6a9a1c4566f9fc24ba1904" translate="yes" xml:space="preserve">
          <source>Object fields that should be visible from outside the defining module have to be marked by &lt;code&gt;*&lt;/code&gt;. In contrast to tuples, different object types are never &lt;em&gt;equivalent&lt;/em&gt;. New object types can only be defined within a type section.</source>
          <target state="translated">Поля объектов, которые должны быть видны снаружи определяющего модуля, должны быть отмечены &lt;code&gt;*&lt;/code&gt; . В отличие от кортежей, разные типы объектов никогда не &lt;em&gt;эквивалентны&lt;/em&gt; . Новые типы объектов могут быть определены только в разделе типов.</target>
        </trans-unit>
        <trans-unit id="d5aae1485cba1ac004bf1c390547daf6751e0fcb" translate="yes" xml:space="preserve">
          <source>Object fields that should be visible from outside the defining module, have to be marked by &lt;code&gt;*&lt;/code&gt;. In contrast to tuples, different object types are never &lt;em&gt;equivalent&lt;/em&gt;, they are nominal types whereas tuples are structural. Objects that have no ancestor are implicitly &lt;code&gt;final&lt;/code&gt; and thus have no hidden type information. One can use the &lt;code&gt;inheritable&lt;/code&gt; pragma to introduce new object roots apart from &lt;code&gt;system.RootObj&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d5262dff32615f0940c3ad8ba0ac64dcad73ed" translate="yes" xml:space="preserve">
          <source>Object fields that should be visible from outside the defining module, have to be marked by &lt;code&gt;*&lt;/code&gt;. In contrast to tuples, different object types are never &lt;em&gt;equivalent&lt;/em&gt;. Objects that have no ancestor are implicitly &lt;code&gt;final&lt;/code&gt; and thus have no hidden type field. One can use the &lt;code&gt;inheritable&lt;/code&gt; pragma to introduce new object roots apart from &lt;code&gt;system.RootObj&lt;/code&gt;.</source>
          <target state="translated">Поля объектов, которые должны быть видны снаружи определяющего модуля, должны быть отмечены &lt;code&gt;*&lt;/code&gt; . В отличие от кортежей, разные типы объектов никогда не &lt;em&gt;эквивалентны&lt;/em&gt; . Объекты, не имеющие предка, неявно являются &lt;code&gt;final&lt;/code&gt; и, следовательно, не имеют поля скрытого типа. Можно использовать &lt;code&gt;inheritable&lt;/code&gt; прагму, чтобы ввести новые корни объектов помимо &lt;code&gt;system.RootObj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0978d14ec54e6881dd2800cbf0b00efa45a72d10" translate="yes" xml:space="preserve">
          <source>Object variants</source>
          <target state="translated">Варианты объектов</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="d2c0e1be93b0738e53ee9b0896c747691dcee381" translate="yes" xml:space="preserve">
          <source>Objects can also be created with an &lt;span id=&quot;object-construction-expression_1&quot;&gt;object construction expression&lt;/span&gt; that has the syntax &lt;code&gt;T(fieldA: valueA, fieldB: valueB, ...)&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is an &lt;code&gt;object&lt;/code&gt; type or a &lt;code&gt;ref object&lt;/code&gt; type:</source>
          <target state="translated">Объекты также могут быть созданы с помощью &lt;span id=&quot;object-construction-expression_1&quot;&gt;выражения построения объекта&lt;/span&gt; , имеющего синтаксис &lt;code&gt;T(fieldA: valueA, fieldB: valueB, ...)&lt;/code&gt; где &lt;code&gt;T&lt;/code&gt; - тип &lt;code&gt;object&lt;/code&gt; или тип &lt;code&gt;ref object&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ec43891abad4c5f51b9f1f5052e07c492132c2c3" translate="yes" xml:space="preserve">
          <source>Objects have access to their type at runtime. There is an &lt;code&gt;of&lt;/code&gt; operator that can be used to check the object's type:</source>
          <target state="translated">Объекты имеют доступ к своему типу во время выполнения. Есть оператор &lt;code&gt;of&lt;/code&gt; , который можно использовать для проверки типа объекта:</target>
        </trans-unit>
        <trans-unit id="4834206117cd45bf703010b173f8d2ab8b0e8785" translate="yes" xml:space="preserve">
          <source>Objects provide many features that tuples do not. Object provide inheritance and information hiding. Objects have access to their type at runtime, so that the &lt;code&gt;of&lt;/code&gt; operator can be used to determine the object's type. The &lt;code&gt;of&lt;/code&gt; operator is similar to the &lt;code&gt;instanceof&lt;/code&gt; operator in Java.</source>
          <target state="translated">Объекты предоставляют множество функций, которых нет в кортежах. Объект обеспечивает наследование и скрытие информации. Объекты имеют доступ к своему типу во время выполнения, поэтому оператор &lt;code&gt;of&lt;/code&gt; может использоваться для определения типа объекта. Оператор &lt;code&gt;of&lt;/code&gt; похож на оператор &lt;code&gt;instanceof&lt;/code&gt; в Java.</target>
        </trans-unit>
        <trans-unit id="50fbd3a1625c6e8ac6633b1b59a260ad1ef17f1e" translate="yes" xml:space="preserve">
          <source>Objects provide many features that tuples do not. Object provide inheritance and the ability to hide fields from other modules. Objects with inheritance enabled have information about their type at runtime so that the &lt;code&gt;of&lt;/code&gt; operator can be used to determine the object's type. The &lt;code&gt;of&lt;/code&gt; operator is similar to the &lt;code&gt;instanceof&lt;/code&gt; operator in Java.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b16e087c768e899a86532c722c83d0cf81e74b" translate="yes" xml:space="preserve">
          <source>Objects should inherit from &lt;code&gt;RootObj&lt;/code&gt; or one of its descendants. However, objects that have no ancestor are also allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0553672f5b32a90c8aef874a5102dc22e01f71a7" translate="yes" xml:space="preserve">
          <source>Objects that contain pointers that point to the same object are not supported by Nim's model. Otherwise swapped objects would end up in an inconsistent state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c57f97f14e60597fdfd797182b06e968256db96" translate="yes" xml:space="preserve">
          <source>Objects, tuples and references can model quite complex data structures which depend on each other; they are &lt;em&gt;mutually recursive&lt;/em&gt;. In Nim these types can only be declared within a single type section. (Anything else would require arbitrary symbol lookahead which slows down compilation.)</source>
          <target state="translated">Объекты, кортежи и ссылки могут моделировать довольно сложные структуры данных, которые зависят друг от друга; они &lt;em&gt;взаимно рекурсивны&lt;/em&gt; . В Nim эти типы могут быть объявлены только в одном разделе типов. (Для чего-то еще потребуется произвольный просмотр символа, который замедлит компиляцию.)</target>
        </trans-unit>
        <trans-unit id="71f640b46a5645b45934608435a884aa861a4b91" translate="yes" xml:space="preserve">
          <source>Obtains a sequence containing the Runes in &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">Получает последовательность, содержащую руны в &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76d03f5fe1c384210c6971da7941ee56452fb961" translate="yes" xml:space="preserve">
          <source>Obtains a sequence containing the Runes in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ad7ba4d959a6de6e644561408cd88962c2b6f5" translate="yes" xml:space="preserve">
          <source>Obtains the AST nodes returned from a macro or template invocation. Example:</source>
          <target state="translated">Получает узлы AST,возвращаемые из вызова макроса или шаблона.Пример:</target>
        </trans-unit>
        <trans-unit id="e48a55708577c922dfe1c8727c5015fe59dcd19c" translate="yes" xml:space="preserve">
          <source>Octal format. Outputs the number in base 8.</source>
          <target state="translated">Октальный формат.Выводит номер в базе 8.</target>
        </trans-unit>
        <trans-unit id="1168d0c029a48fe3aea275c0858b8d7c66a53429" translate="yes" xml:space="preserve">
          <source>OctalEscape</source>
          <target state="translated">OctalEscape</target>
        </trans-unit>
        <trans-unit id="848ceaf7c8a295c627cb93a73ac754f0130154b6" translate="yes" xml:space="preserve">
          <source>Often C and C++ code contains something like the following, where the return value is frequently ignored and so the Nim wrapper should contain a &lt;code&gt;.discardable&lt;/code&gt; pragma:</source>
          <target state="translated">Часто код C и C ++ содержит что-то вроде следующего, где возвращаемое значение часто игнорируется, и поэтому оболочка Nim должна содержать прагму &lt;code&gt;.discardable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c85c11c4b42c93c3e7a04193ab3c113033320a61" translate="yes" xml:space="preserve">
          <source>Often C code contains special macros that affect the declaration of a function prototype but confuse c2nim's parser:</source>
          <target state="translated">Часто код на Си содержит специальные макросы,которые влияют на объявление прототипа функции,но путают парсер c2nim:</target>
        </trans-unit>
        <trans-unit id="a8f42ebc1976b2a5351c29b1673e9099dfdbaca1" translate="yes" xml:space="preserve">
          <source>Often a procedure has many parameters and it is not clear in which order the parameters appear. This is especially true for procedures that construct a complex data type. Therefore the arguments to a procedure can be named, so that it is clear which argument belongs to which parameter:</source>
          <target state="translated">Часто процедура имеет много параметров,и неясно,в каком порядке они появляются.Это особенно актуально для процедур,которые строят сложный тип данных.Поэтому аргументы процедуры можно называть так,чтобы было ясно,какому аргументу какой параметр принадлежит:</target>
        </trans-unit>
        <trans-unit id="3a5f3199753bf25f09a786142eab4d142c315045" translate="yes" xml:space="preserve">
          <source>Often an object hierarchy is an overkill in certain situations where simple variant types are needed. Object variants are tagged unions discriminated via an enumerated type used for runtime type flexibility, mirroring the concepts of &lt;em&gt;sum types&lt;/em&gt; and &lt;em&gt;algebraic data types (ADTs)&lt;/em&gt; as found in other languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6395b4ee4a71999d586e3acbee700ed5ca4da87" translate="yes" xml:space="preserve">
          <source>Often an object hierarchy is overkill in certain situations where simple variant types are needed.</source>
          <target state="translated">Часто иерархия объектов перегибается в определенных ситуациях,когда необходимы простые типы вариантов.</target>
        </trans-unit>
        <trans-unit id="06ebd19cc8bc8c7150cf93f1a6c3d3c1726b3741" translate="yes" xml:space="preserve">
          <source>Often fixed size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; type allows this. Openarrays are always indexed with an &lt;code&gt;int&lt;/code&gt; starting at position 0. The &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt;, &lt;a href=&quot;system#low&quot;&gt;low&lt;/a&gt; and &lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; operations are available for open arrays too. Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter.</source>
          <target state="translated">Часто массивы фиксированного размера оказываются слишком негибкими; процедуры должны иметь возможность работать с массивами разного размера. Тип &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; позволяет это. Открытые массивы всегда индексируются с &lt;code&gt;int&lt;/code&gt; , начиная с позиции 0. Операции &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; , &lt;a href=&quot;system#low&quot;&gt;low&lt;/a&gt; и &lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; также доступны для открытых массивов. Любой массив с совместимым базовым типом может быть передан в параметр openarray, тип индекса не имеет значения.</target>
        </trans-unit>
        <trans-unit id="b72b9d6119b4da4f2df6e174e7eebce8ade809c0" translate="yes" xml:space="preserve">
          <source>Often fixed size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; type allows this; it can only be used for parameters. Openarrays are always indexed with an &lt;code&gt;int&lt;/code&gt; starting at position 0. The &lt;code&gt;len&lt;/code&gt;, &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; operations are available for open arrays too. Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter. In addition to arrays sequences can also be passed to an open array parameter.</source>
          <target state="translated">Часто массивы фиксированного размера оказываются слишком негибкими; процедуры должны иметь возможность работать с массивами разного размера. Тип &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; позволяет это; его можно использовать только для параметров. Открытые массивы всегда индексируются с &lt;code&gt;int&lt;/code&gt; , начиная с позиции 0. Операции &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;low&lt;/code&gt; и &lt;code&gt;high&lt;/code&gt; также доступны для открытых массивов. Любой массив с совместимым базовым типом может быть передан в параметр openarray, тип индекса не имеет значения. В дополнение к массивам последовательности также могут быть переданы в параметр открытого массива.</target>
        </trans-unit>
        <trans-unit id="653db7bf1a8cfcc325e38da27b77e167f0e8e1e1" translate="yes" xml:space="preserve">
          <source>Often it is unclear where the method should belong to: is &lt;code&gt;join&lt;/code&gt; a string method or an array method?</source>
          <target state="translated">Часто неясно, где должен принадлежать метод: &lt;code&gt;join&lt;/code&gt; к строковому методу или методу массива?</target>
        </trans-unit>
        <trans-unit id="c448be5e6f2f721a095ce66e4d5d6809129d6a5f" translate="yes" xml:space="preserve">
          <source>Often, you might work with callback-based API-s. You can wrap them with asynchronous procedures using promises and &lt;code&gt;newPromise&lt;/code&gt;:</source>
          <target state="translated">Часто вы можете работать с API на основе обратного вызова. Вы можете обернуть их асинхронными процедурами, используя promises и &lt;code&gt;newPromise&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="13c64dac54bbedb5367bd67136157fa1cbeaf400" translate="yes" xml:space="preserve">
          <source>Old HTML contains tags that have no end tag: &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; for example.</source>
          <target state="translated">Старый HTML содержит теги, у которых нет конечного тега: например, &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d9b2255ea4766e38b37a3d1d6acbcd79adbbee9" translate="yes" xml:space="preserve">
          <source>Oldest clients supported by this list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce7e4551854af6b06b12d4a9f13070d5030d272" translate="yes" xml:space="preserve">
          <source>On OpenSSL &amp;gt;= 1.1.0 this is on by default and cannot be disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ab671e39fd99eba628d677c2b659305d9cd016" translate="yes" xml:space="preserve">
          <source>On POSIX this uses the &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; call. &lt;code&gt;pattern&lt;/code&gt; is OS dependent, but at least the &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; notation is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d06d53900d18c0c4d19f86691434ca346457cf3" translate="yes" xml:space="preserve">
          <source>On POSIX this uses the &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; call. &lt;code&gt;pattern&lt;/code&gt; is OS dependent, but at least the &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; notation is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b962bd1576f47b7fbea68a4ac589aea607292c" translate="yes" xml:space="preserve">
          <source>On POSIX this uses the &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; call. &lt;code&gt;pattern&lt;/code&gt; is OS dependent, but at least the &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; notation is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5aa2ca373f45676714b04347619568162e21bdb" translate="yes" xml:space="preserve">
          <source>On Posix OSes the procedure sends &lt;code&gt;SIGKILL&lt;/code&gt; to the process. On Windows &lt;code&gt;kill&lt;/code&gt; is simply an alias for &lt;a href=&quot;#terminate,Process&quot;&gt;terminate()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636bb30d2edfe13bddf1cfddf99dc97b65eee8d3" translate="yes" xml:space="preserve">
          <source>On Posix OSes the procedure sends &lt;code&gt;SIGTERM&lt;/code&gt; to the process. On Windows the Win32 API function &lt;code&gt;TerminateProcess()&lt;/code&gt; is called to stop the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33123903f02b8bf587a5568b29d3def5ad6cd5c" translate="yes" xml:space="preserve">
          <source>On Posix systems, it uses the following parsing rules: Components are separated by whitespace unless the whitespace occurs within &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt; quotes.</source>
          <target state="translated">В системах Posix используются следующие правила синтаксического анализа: Компоненты разделяются пробелом, если пробел не находится в кавычках &lt;code&gt;&quot;&lt;/code&gt; или &lt;code&gt;'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="834cc319d31095e6fc7d78e7d1c9b23d8c20037d" translate="yes" xml:space="preserve">
          <source>On Unix, you can also use the shebang &lt;code&gt;#!/usr/bin/env nim&lt;/code&gt;, as long as your filename ends with &lt;code&gt;.nims&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca375d55e90a2ca9b205b82e74384bf3a49097b" translate="yes" xml:space="preserve">
          <source>On Windows adds &quot;.dll&quot; to &lt;code&gt;filename&lt;/code&gt;, on Posix produces &quot;lib$filename.so&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbafa0f673264a750ef0cf50fe66c11c098cd82" translate="yes" xml:space="preserve">
          <source>On Windows adds &quot;.exe&quot; to &lt;code&gt;filename&lt;/code&gt;, else returns &lt;code&gt;filename&lt;/code&gt; unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131615a38d5f682e627f291b00695b764612c48b" translate="yes" xml:space="preserve">
          <source>On Windows this is a noop, &lt;code&gt;symlinkPath&lt;/code&gt; is simply returned.</source>
          <target state="translated">В Windows это noop, просто возвращается &lt;code&gt;symlinkPath&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05672aecf27340137fd58647ae2456a227fa831f" translate="yes" xml:space="preserve">
          <source>On Windows this proc is just a wrapper for &lt;a href=&quot;#copyDir,string,string&quot;&gt;copyDir proc&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fa250d69a315e525601b1f7e96a5b8019564e1" translate="yes" xml:space="preserve">
          <source>On Windows this proc is just a wrapper for &lt;a href=&quot;#copyFile,string,string&quot;&gt;copyFile proc&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ce96c0b5b17afe1bacf0b1747928e53aaa71eb" translate="yes" xml:space="preserve">
          <source>On Windows, a file is hidden if the file's 'hidden' attribute is set. On Unix-like systems, a file is hidden if it starts with a '.' (period) and is not &lt;em&gt;just&lt;/em&gt; '.' or '..' ' .&quot;</source>
          <target state="translated">В Windows файл скрыт, если установлен атрибут &amp;laquo;скрытый&amp;raquo; файла. В Unix-подобных системах файл скрывается, если он начинается с символа '.' (период), а не &lt;em&gt;просто&lt;/em&gt; &quot;.&quot; или '..' ' .&quot;</target>
        </trans-unit>
        <trans-unit id="be2b5ddfadb7e844935b3f58931b5fdf015b4ffa" translate="yes" xml:space="preserve">
          <source>On Windows, ignores the read-only attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d219ef8a6a1662c16fa1ad9a9fb14a71aa03b00f" translate="yes" xml:space="preserve">
          <source>On Windows, it uses the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;following parsing rules&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e780c227d663a3ece4d9e2f1a1ef9ba70a8f3fe" translate="yes" xml:space="preserve">
          <source>On Windows, it uses the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;following parsing rules&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49455f655e6af02510b37b400ad079bda32fcf9" translate="yes" xml:space="preserve">
          <source>On Windows, it uses the following parsing rules (see &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt; ):</source>
          <target state="translated">В Windows используются следующие правила синтаксического анализа (см. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;Http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="2d9112d9c390a489d1abe81e704b96328351c744" translate="yes" xml:space="preserve">
          <source>On Windows, network paths are considered absolute too.</source>
          <target state="translated">В Windows сетевые пути тоже считаются абсолютными.</target>
        </trans-unit>
        <trans-unit id="ac5b0f8c13e69a83282367b11b7a62a054b16852" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;-d:useWinAnsi&lt;/code&gt; compilation flag can be used to make this procedure use the non-unicode Win API calls to retrieve the message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4001f01f1a00f62db5ba5d2ddb394bcb0fbc5ede" translate="yes" xml:space="preserve">
          <source>On Windows: returns true if it exists and its &quot;hidden&quot; attribute is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd69f94a373ae6ea79b01a75e59c435ad639d26" translate="yes" xml:space="preserve">
          <source>On a case-sensitive filesystem this is done case-sensitively otherwise case-insensitively. Returns:</source>
          <target state="translated">В файловой системе,чувствительной к регистру,это делается чувствительно к регистру,в противном случае-не чувствительно к регистру.Возвращает:</target>
        </trans-unit>
        <trans-unit id="c8469f270e6308a5204d808346468ba7e32ce5ba" translate="yes" xml:space="preserve">
          <source>On an UNIX system this does nothing. Else it converts '/', '.', '..' to the appropriate things.</source>
          <target state="translated">На системе UNIX это ничего не делает.Иначе это превращает '/','...','...в соответствующие вещи.</target>
        </trans-unit>
        <trans-unit id="ce6e6ab795a177a2429d9448acf045ddddf42374" translate="yes" xml:space="preserve">
          <source>On an UNIX system this does nothing. Else it converts &lt;code&gt;'/'&lt;/code&gt;, &lt;code&gt;'.'&lt;/code&gt;, &lt;code&gt;'..'&lt;/code&gt; to the appropriate things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410676d7292fbbcf827b204fd9a0c07b3ffe5980" translate="yes" xml:space="preserve">
          <source>On backends without branch prediction (JS and the nimscript VM), this template will not affect code execution.</source>
          <target state="translated">На бэкендах без предсказания ветвей (JS и VM нимскрипта)этот шаблон не повлияет на выполнение кода.</target>
        </trans-unit>
        <trans-unit id="71349d230261d02d2bc3058f2f163656370a285c" translate="yes" xml:space="preserve">
          <source>On non Windows systems permissions are copied after the file itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;em&gt;ignorePermissionErrors&lt;/em&gt; is true, errors while reading/setting file attributes will be ignored, otherwise will raise &lt;em&gt;OSError&lt;/em&gt;.</source>
          <target state="translated">В системах, отличных от Windows, разрешения копируются после копирования самого файла, что не произойдет атомарно и может привести к состоянию гонки. Если &lt;em&gt;ignorePermissionErrors&lt;/em&gt; истинно, ошибки при чтении / установке атрибутов файла будут проигнорированы, иначе вызовет &lt;em&gt;OSError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b26734ed023d711198160409aa5df1de55e088f2" translate="yes" xml:space="preserve">
          <source>On non Windows systems permissions are copied after the file or directory itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;em&gt;ignorePermissionErrors&lt;/em&gt; is true, errors while reading/setting file attributes will be ignored, otherwise will raise &lt;em&gt;OSError&lt;/em&gt;.</source>
          <target state="translated">В системах, отличных от Windows, разрешения копируются после копирования самого файла или каталога, что не произойдет атомарно и может привести к состоянию гонки. Если &lt;em&gt;ignorePermissionErrors&lt;/em&gt; истинно, ошибки при чтении / установке атрибутов файла будут игнорироваться, в противном случае возникнет &lt;em&gt;ошибка OSError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9214590a8005bcbc988e94c2ff34b8e0671fd615" translate="yes" xml:space="preserve">
          <source>On non-Windows OSs, this proc conforms to the XDG Base Directory spec. Thus, this proc returns the value of the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable if it is set, otherwise it returns the default configuration directory (&quot;~/.config/&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5345a8b53344aaa0863f04f717114c18227851" translate="yes" xml:space="preserve">
          <source>On non-Windows OSs, this proc conforms to the XDG Base Directory spec. Thus, this proc returns the value of the XDG_CONFIG_HOME environment variable if it is set, and returns the default configuration directory, &quot;~/.config/&quot;, otherwise.</source>
          <target state="translated">На операционных системах,не относящихся к Windows,этот промежуток времени соответствует спецификации XDG Base Directory.Таким образом,proc возвращает значение переменной окружения XDG_CONFIG_HOME,если она установлена,и возвращает каталог конфигурации по умолчанию &quot;~/.config/&quot;,в противном случае.</target>
        </trans-unit>
        <trans-unit id="1ef1878800148722a52d11621bb2995a19e795fa" translate="yes" xml:space="preserve">
          <source>On non-Windows systems permissions are copied after the file itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;code&gt;ignorePermissionErrors&lt;/code&gt; is true (default), errors while reading/setting file attributes will be ignored, otherwise will raise &lt;code&gt;OSError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7826bbb956520ceecb8ab7c01c0eac14d107b3b2" translate="yes" xml:space="preserve">
          <source>On non-Windows systems permissions are copied after the file or directory itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;code&gt;ignorePermissionErrors&lt;/code&gt; is true (default), errors while reading/setting file attributes will be ignored, otherwise will raise &lt;code&gt;OSError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d198733f6e75c57f15a08ce67d688e4a62009004" translate="yes" xml:space="preserve">
          <source>On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. Use &lt;a href=&quot;#copyDirWithPermissions,string,string&quot;&gt;copyDirWithPermissions proc&lt;/a&gt; to preserve attributes recursively on these platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb66bc173e5cea45d224b1d00e5c254cf51c117" translate="yes" xml:space="preserve">
          <source>On other platforms you need to use &lt;a href=&quot;#getFilePermissions,string&quot;&gt;getFilePermissions&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions,string,set%5BFilePermission%5D&quot;&gt;setFilePermissions&lt;/a&gt; procs to copy them by hand (or use the convenience &lt;a href=&quot;#copyFileWithPermissions,string,string&quot;&gt;copyFileWithPermissions proc&lt;/a&gt;), otherwise &lt;code&gt;dest&lt;/code&gt; will inherit the default permissions of a newly created file for the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898bf4553278bc34226081a98acca7cca2299308" translate="yes" xml:space="preserve">
          <source>On posix this will search through the &lt;code&gt;/etc/services&lt;/code&gt; file.</source>
          <target state="translated">В posix это будет искать в &lt;code&gt;/etc/services&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c51ed0629b09b2b1d09d42b4681c845de22a12d3" translate="yes" xml:space="preserve">
          <source>On posix, if the process has exited because of a signal, 128 + signal number will be returned.</source>
          <target state="translated">При позиционировании,если процесс завершился из-за сигнала,будет возвращено 128+номер сигнала.</target>
        </trans-unit>
        <trans-unit id="db8215b423ef9bc86e0c61cb1eee5873cfe33f7d" translate="yes" xml:space="preserve">
          <source>On posix: returns true if &lt;code&gt;lastPathPart(path)&lt;/code&gt; starts with &lt;code&gt;.&lt;/code&gt; and is not &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3c38d17d46151c5d354197efeee10f8d783f2b" translate="yes" xml:space="preserve">
          <source>On relative paths, double dot (..) sequences are collapsed if possible. On absolute paths they are always collapsed.</source>
          <target state="translated">На относительных путях двойные точечные (...)последовательности разрушаются,если это возможно.На абсолютных путях они всегда рушатся.</target>
        </trans-unit>
        <trans-unit id="3b3d50c97cdc169f61ed97cda00a458b0a518724" translate="yes" xml:space="preserve">
          <source>On relative paths, double dot (&lt;code&gt;..&lt;/code&gt;) sequences are collapsed if possible. On absolute paths they are always collapsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd0de97e21f18a70dc40d4ea02d3e032d1e6822" translate="yes" xml:space="preserve">
          <source>On systems with a concept of &quot;drives&quot;, &lt;code&gt;drive&lt;/code&gt; is used to determine which drive label to use during absolute path conversion. &lt;code&gt;drive&lt;/code&gt; defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of &quot;drives&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20fce5143547ae9c280f86e85a7f988d0055a8f" translate="yes" xml:space="preserve">
          <source>On systems with a concept of &quot;drives&quot;, &lt;em&gt;drive&lt;/em&gt; is used to determine which drive label to use during absolute path conversion. &lt;em&gt;drive&lt;/em&gt; defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of &quot;drives&quot;.</source>
          <target state="translated">В системах с концепцией &amp;laquo;диски&amp;raquo; &lt;em&gt;диск&lt;/em&gt; используется для определения, какую метку диска использовать при преобразовании абсолютного пути. &lt;em&gt;По&lt;/em&gt; умолчанию используется диск текущего рабочего каталога, и он игнорируется в системах, не имеющих понятия &amp;laquo;диски&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="919f238a50bd9c8a0b4c8aebc53de677589c1bbb" translate="yes" xml:space="preserve">
          <source>On the Windows platform this proc will copy the attributes from &lt;code&gt;source&lt;/code&gt; into &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632c6c96343e057ab2f11cb26fae25368444d555" translate="yes" xml:space="preserve">
          <source>On the Windows platform this proc will copy the source file's attributes into dest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e27ced0560e6c76c802fe94e33423bf08b2b55" translate="yes" xml:space="preserve">
          <source>On the other hand, if &lt;code&gt;spread&lt;/code&gt; is true, the proc will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3066034f3e12801386284630d4449cf120d021" translate="yes" xml:space="preserve">
          <source>On the other hand, if &lt;em&gt;spread&lt;/em&gt; is true, the proc will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage.</source>
          <target state="translated">С другой стороны, если &lt;em&gt;распространение&lt;/em&gt; истинно, процесс будет равномерно распределять остаток от деления по всем последовательностям, что делает результат более подходящим для многопоточности, когда вы передаете рабочие единицы равного размера в пул потоков и хотите максимизировать использование ядра. ,</target>
        </trans-unit>
        <trans-unit id="317e86312cac8e36e1b7e5107ff34ed5cc4b1895" translate="yes" xml:space="preserve">
          <source>On the other hand, in Nim's future I would like to replace the VM by native code. A diff algorithm wouldn't work for that. Instead the native code would work with an API like &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">С другой стороны, в будущем Нима я бы хотел заменить виртуальную машину собственным кодом. Алгоритм сравнения для этого не годится. Вместо этого собственный код будет работать с API, например &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="15cc13f1907198262a48b2f1247b799d1650a03d" translate="yes" xml:space="preserve">
          <source>On the other hand, in the &lt;code&gt;RingBuffer&lt;/code&gt; example above, the designated generic param is used to instantiate the non-pointer &lt;code&gt;seq&lt;/code&gt; type, which means that the resulting generic type will have covariance that mimics an array or sequence (i.e. it will be covariant only when instantiated with &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; types):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25df01f5e813eafaaa5663850dd783a4040697d" translate="yes" xml:space="preserve">
          <source>On the other hand, in the &lt;em&gt;RingBuffer&lt;/em&gt; example above, the designated generic param is used to instantiate the non-pointer &lt;code&gt;seq&lt;/code&gt; type, which means that the resulting generic type will have covariance that mimics an array or sequence (i.e. it will be covariant only when instantiated with &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; types):</source>
          <target state="translated">С другой стороны, в &lt;em&gt;приведенном&lt;/em&gt; выше примере &lt;em&gt;RingBuffer&lt;/em&gt; указанный универсальный параметр используется для создания экземпляра типа &lt;code&gt;seq&lt;/code&gt; без указателя , что означает, что результирующий универсальный тип будет иметь ковариацию, имитирующую массив или последовательность (т. Е. Он будет ковариантным только тогда, когда создается с типами &lt;code&gt;ptr&lt;/code&gt; и &lt;code&gt;ref&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="9c4aef9144f0f23eb3dbf979b7ad1a6367db8432" translate="yes" xml:space="preserve">
          <source>On the other hand, using &lt;code&gt;bind once&lt;/code&gt; types allows you to test for equivalent types used in multiple signatures, without actually requiring any concrete types, thus allowing you to encode implementation-defined types:</source>
          <target state="translated">С другой стороны, использование типов &lt;code&gt;bind once&lt;/code&gt; позволяет вам тестировать эквивалентные типы, используемые в нескольких сигнатурах, фактически не требуя каких-либо конкретных типов, что позволяет вам кодировать типы, определенные реализацией:</target>
        </trans-unit>
        <trans-unit id="dba138949d4841696388d7021ef9a2601c30eef7" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;TableRef&lt;/code&gt; instead, then changes to &lt;code&gt;b&lt;/code&gt; also affect &lt;code&gt;a&lt;/code&gt;. Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;&lt;strong&gt;ref&lt;/strong&gt; the same data structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13d679112fedc32342b16f2848339011424e35e" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;em&gt;a&lt;/em&gt; is a TableRef instead, then changes to &lt;em&gt;b&lt;/em&gt; also affect &lt;em&gt;a&lt;/em&gt;. Both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; reference the same data structure:</source>
          <target state="translated">С другой стороны, если вместо &lt;em&gt;a&lt;/em&gt; является TableRef, то изменение на &lt;em&gt;b&lt;/em&gt; также влияет на &lt;em&gt;a&lt;/em&gt; . И &lt;em&gt;a,&lt;/em&gt; и &lt;em&gt;b&lt;/em&gt; ссылаются на одну и ту же структуру данных:</target>
        </trans-unit>
        <trans-unit id="37d18afb7f631d26e467ad1c5e79cc58b688edd5" translate="yes" xml:space="preserve">
          <source>On top of generating libraries or standalone applications, Nim offers bidirectional interfacing with the backend targets through generic and specific pragmas.</source>
          <target state="translated">Помимо генерирования библиотек или автономных приложений,Nim предлагает двунаправленное взаимодействие с внутренними целями через общие и специфические прагмы.</target>
        </trans-unit>
        <trans-unit id="c81da6451dca2da62ae25f6caf1eff5bac5311d0" translate="yes" xml:space="preserve">
          <source>On top of that, there is also the &lt;code&gt;typ&lt;/code&gt; field for the type. It the kind of the &lt;code&gt;typ&lt;/code&gt; field can be one of the following ones, and it should be matching the literal kind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c2d48642cb046e2bbc4639d90dcf6445b4e94f" translate="yes" xml:space="preserve">
          <source>On windows, if a root of &lt;code&gt;path&lt;/code&gt; and a root of &lt;code&gt;base&lt;/code&gt; are different, returns &lt;code&gt;path&lt;/code&gt; as is because it is impossible to make a relative path. That means an absolute path can be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab18c0b5501aadd3a3af3f1ceb793c3f49cf6f2" translate="yes" xml:space="preserve">
          <source>OnHeap:</source>
          <target state="translated">OnHeap:</target>
        </trans-unit>
        <trans-unit id="568f54818fab1d16943bd423920f09da70e89138" translate="yes" xml:space="preserve">
          <source>OnStack:</source>
          <target state="translated">OnStack:</target>
        </trans-unit>
        <trans-unit id="db6805e8c7cfbc2552a2ae4ead1110380c4f8151" translate="yes" xml:space="preserve">
          <source>OnStatic:</source>
          <target state="translated">OnStatic:</target>
        </trans-unit>
        <trans-unit id="15222cc1cfca09f665b5c4bd79a604c8a5fda245" translate="yes" xml:space="preserve">
          <source>OnUnknown:</source>
          <target state="translated">OnUnknown:</target>
        </trans-unit>
        <trans-unit id="b55aab0a049cabc5b434393773f26e77af86b5f9" translate="yes" xml:space="preserve">
          <source>Once a logger has been created, call its &lt;a href=&quot;#log.e,ConsoleLogger,Level,varargs%5Bstring,%5D&quot;&gt;log proc&lt;/a&gt; to log a message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8edce91442634d7387fe386cb073a4a709ecff8" translate="yes" xml:space="preserve">
          <source>Once bound, type params can appear in the rest of the proc signature:</source>
          <target state="translated">После привязки,параметры типа могут появиться в остальной части подписи proc:</target>
        </trans-unit>
        <trans-unit id="609040b49e0851c8e7801cc6b5b773d38bc4bba4" translate="yes" xml:space="preserve">
          <source>Once declared, a constant's symbol can be used as a constant expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b47a60e99f1394d99a1c045b8c28b67a9fc8f6a" translate="yes" xml:space="preserve">
          <source>Once everything is registered in a dispatcher, you need to call the &lt;code&gt;poll&lt;/code&gt; function in a while loop.</source>
          <target state="translated">Как только все будет зарегистрировано в диспетчере, вам нужно вызвать функцию &lt;code&gt;poll&lt;/code&gt; в цикле while.</target>
        </trans-unit>
        <trans-unit id="d5654d82c2a3884c2cbc3f1c679468b9597dacae" translate="yes" xml:space="preserve">
          <source>Once index files have been generated for one or more modules, the Nim compiler command &lt;code&gt;buildIndex directory&lt;/code&gt; can be run to go over all the index files in the specified directory to generate a &lt;a href=&quot;https://nim-lang.org/docs/theindex.html&quot;&gt;theindex.html&lt;/a&gt; file.</source>
          <target state="translated">После того, как индексные файлы были сгенерированы для одного или нескольких модулей, можно запустить &lt;code&gt;buildIndex directory&lt;/code&gt; команды компилятора Nim, чтобы просмотреть все индексные файлы в указанном каталоге и сгенерировать файл &lt;a href=&quot;https://nim-lang.org/docs/theindex.html&quot;&gt;theindex.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9093fbfa7147de35adc3e237969b8a5f741293d8" translate="yes" xml:space="preserve">
          <source>Once the current log file being written to contains &lt;code&gt;maxLines&lt;/code&gt; lines, a new log file will be created, and the old log file will be renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60efbade01d07951321fcb62a711c7c0a4d46ba" translate="yes" xml:space="preserve">
          <source>Once you have a &lt;code&gt;JsonNode&lt;/code&gt;, retrieving the values can then be achieved by using one of the helper procedures, which include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba237fb6a97d475a345fe56549779371d65c0b14" translate="yes" xml:space="preserve">
          <source>Once you have code like this in place, if the list of raised exception changes the compiler will stop with an error specifying the line of the proc which stopped validating the pragma and the raised exception not being caught, along with the file and line where the uncaught exception is being raised, which may help you locate the offending code which has changed.</source>
          <target state="translated">При наличии такого кода,если список поднятых исключений изменился,компилятор остановится с ошибкой,указав строку proc,которая перестала валидировать прагму и поднятое исключение не было перехвачено,а также файл и строку,где поднято не перехваченное исключение,что может помочь обнаружить изменившийся ошибочный код.</target>
        </trans-unit>
        <trans-unit id="e837030f84dd416a1763c3313ad3b60179285a22" translate="yes" xml:space="preserve">
          <source>Once your code is compiled for hot reloading, you can use a framework such as &lt;em&gt;LiveReload &amp;lt;http://livereload.com/&amp;gt;&lt;/em&gt; or &lt;em&gt;BrowserSync &amp;lt;https://browsersync.io/&amp;gt;&lt;/em&gt; to implement the actual reloading behavior in your project.</source>
          <target state="translated">После того, как ваш код скомпилирован для горячей перезагрузки, вы можете использовать фреймворк, например &lt;em&gt;LiveReload &amp;lt;http://livereload.com/&amp;gt;&lt;/em&gt; или &lt;em&gt;BrowserSync &amp;lt;https://browsersync.io/&amp;gt;,&lt;/em&gt; чтобы реализовать фактическое поведение перезагрузки в вашем проекте.</target>
        </trans-unit>
        <trans-unit id="b2d92002386ccab2c66af44a60e6f00bc53d2d7b" translate="yes" xml:space="preserve">
          <source>Once your macro is finished, there are two ways to invoke it:</source>
          <target state="translated">После того,как макрос закончен,есть два способа вызвать его:</target>
        </trans-unit>
        <trans-unit id="c95e6032530fcbf63e3fb9d935e3a4900b15a008" translate="yes" xml:space="preserve">
          <source>One can force an expression to be evaluated at compile time as a constant expression by coercing it to a corresponding &lt;code&gt;static&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83e207267fa148c2a0ca5ddf816169f22ace210" translate="yes" xml:space="preserve">
          <source>One can obtain the type of a given expression by constructing a &lt;code&gt;typeof&lt;/code&gt; value from it (in many other languages this is known as the &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; operator):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe69f9cd71b11c831e91b58e239cae9c34d55dc8" translate="yes" xml:space="preserve">
          <source>One can pass a block of statements as the last argument to a template following the special &lt;code&gt;:&lt;/code&gt; syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2e14b82a6a078671a4c4d9c4519514eb953104" translate="yes" xml:space="preserve">
          <source>One can tell the compiler about the convention that a parameter of name &lt;code&gt;c&lt;/code&gt; should default to type &lt;code&gt;Context&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; should default to &lt;code&gt;Node&lt;/code&gt; etc.:</source>
          <target state="translated">Можно сообщить компилятору о соглашении, что параметр с именем &lt;code&gt;c&lt;/code&gt; должен по умолчанию иметь тип &lt;code&gt;Context&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; должен по умолчанию - &lt;code&gt;Node&lt;/code&gt; и т. Д .:</target>
        </trans-unit>
        <trans-unit id="b441a31745d56840471825f544c92905083aa43a" translate="yes" xml:space="preserve">
          <source>One can use &lt;span id=&quot;tuple-unpacking_1&quot;&gt;tuple unpacking&lt;/span&gt; to access the tuple's fields:</source>
          <target state="translated">Для доступа к полям кортежа можно использовать &lt;span id=&quot;tuple-unpacking_1&quot;&gt;распаковку&lt;/span&gt; кортежа:</target>
        </trans-unit>
        <trans-unit id="0aae6e8e4a31c5c278e8ef5e9e83aa14fc870267" translate="yes" xml:space="preserve">
          <source>One can use a temporary helper variable, for example instead of &lt;code&gt;x = p(8)&lt;/code&gt; use &lt;code&gt;let tmp = p(8); x = tmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6393931ab1901888c2c40493d5e9e26b0c1998b" translate="yes" xml:space="preserve">
          <source>One of Nim's cool features is pragmas, which allow fine-tuning of various aspects of the language. They come in all types, such as adorning procs and objects, but the standalone &lt;code&gt;emit&lt;/code&gt; pragma shows the basics with the AST.</source>
          <target state="translated">Одна из интересных особенностей Nim - это прагмы, которые позволяют настраивать различные аспекты языка. Они бывают разных типов, например, украшающих проки и объектов, но автономный &lt;code&gt;emit&lt;/code&gt; Pragma показывает Основы с AST.</target>
        </trans-unit>
        <trans-unit id="da1a3f527bb79b13e631a70eceb3b03667fef012" translate="yes" xml:space="preserve">
          <source>One or more</source>
          <target state="translated">Один или несколько</target>
        </trans-unit>
        <trans-unit id="2e948a81e04389675a5a97047baf132370163826" translate="yes" xml:space="preserve">
          <source>One or more: Apply expression &lt;code&gt;E&lt;/code&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any) and indicate success if there was at least one match. Otherwise indicate failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2207e76c212f3f40ba5c67c82dea4cf30adfcd7c" translate="yes" xml:space="preserve">
          <source>One or more: Apply expression &lt;em&gt;E&lt;/em&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any) and indicate success if there was at least one match. Otherwise indicate failure.</source>
          <target state="translated">Одно или несколько: многократно применяйте выражение &lt;em&gt;E&lt;/em&gt; для сопоставления текста впереди, если оно будет успешным. Использовать совпавший текст (если есть) и указать успех, если было хотя бы одно совпадение. В противном случае указать отказ.</target>
        </trans-unit>
        <trans-unit id="7580ae8512abee0f0777a780954b22b310c552f2" translate="yes" xml:space="preserve">
          <source>One problem with rules 3 and 4 is that they affect specific global or thread local variables, but Nim's effect tracking only tracks &quot;uses no global variable&quot; via &lt;code&gt;.noSideEffect&lt;/code&gt;. The rules 3 and 4 can also be approximated by a different rule:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4680ad8f0f14c282d731ada768ace3aaf946a2" translate="yes" xml:space="preserve">
          <source>One should overload this proc if one wants to overload the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcabe66eb85b400f8ef4fa596004eac08e1527ca" translate="yes" xml:space="preserve">
          <source>One should overload this proc if one wants to overload the &lt;code&gt;in&lt;/code&gt; operator. The parameters are in reverse order! &lt;code&gt;a in b&lt;/code&gt; is a template for &lt;code&gt;contains(b, a)&lt;/code&gt;. This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the &lt;code&gt;in&lt;/code&gt; operator that would be the wrong direction for this piece of code:</source>
          <target state="translated">Следует перегрузить эту процедуру, если нужно перегрузить оператор &lt;code&gt;in&lt;/code&gt; . Параметры в обратном порядке! &lt;code&gt;a in b&lt;/code&gt; - это шаблон для &lt;code&gt;contains(b, a)&lt;/code&gt; . Это связано с тем, что алгоритм унификации, который Nim использует для разрешения перегрузки, работает слева направо. Но для оператора &lt;code&gt;in&lt;/code&gt; это было бы неправильным направлением для этого фрагмента кода:</target>
        </trans-unit>
        <trans-unit id="b3ed0c36ef143962232eea5026e9f624f11115c4" translate="yes" xml:space="preserve">
          <source>One very nice advantage over regular expressions is that &lt;code&gt;scanf&lt;/code&gt; is extensible with ordinary Nim procs. The proc is either enclosed in &lt;code&gt;${}&lt;/code&gt; or in &lt;code&gt;$[]&lt;/code&gt;. &lt;code&gt;${}&lt;/code&gt; matches and binds the result to a variable (that was passed to the &lt;code&gt;scanf&lt;/code&gt; macro) while &lt;code&gt;$[]&lt;/code&gt; merely matches optional tokens without any result binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e4679df7a5cffe918b1e69c86872ec6282c2aa" translate="yes" xml:space="preserve">
          <source>One very nice advantage over regular expressions is that &lt;code&gt;scanf&lt;/code&gt; is extensible with ordinary Nim procs. The proc is either enclosed in &lt;code&gt;${}&lt;/code&gt; or in &lt;code&gt;$[]&lt;/code&gt;. &lt;code&gt;${}&lt;/code&gt; matches and binds the result to a variable (that was passed to the &lt;code&gt;scanf&lt;/code&gt; macro) while &lt;code&gt;$[]&lt;/code&gt; merely optional tokens.</source>
          <target state="translated">Одно очень приятное преимущество перед регулярными выражениями заключается в том, что &lt;code&gt;scanf&lt;/code&gt; расширяется с помощью обычных процессов Nim. Процедура либо заключена в &lt;code&gt;${}&lt;/code&gt; либо в &lt;code&gt;$[]&lt;/code&gt; . &lt;code&gt;${}&lt;/code&gt; сопоставляет и связывает результат с переменной (которая была передана в макрос &lt;code&gt;scanf&lt;/code&gt; ), а &lt;code&gt;$[]&lt;/code&gt; просто необязательные токены.</target>
        </trans-unit>
        <trans-unit id="488e4498e568d4ebdd0ca2157ae6748d000ab688" translate="yes" xml:space="preserve">
          <source>One:</source>
          <target state="translated">One:</target>
        </trans-unit>
        <trans-unit id="7aa20e42e9fac36bab86ec5c3c5c9673fd5be3ee" translate="yes" xml:space="preserve">
          <source>Only available for numbers types. Note that the sequence will be uninitialized. After the creation of the sequence you should assign entries to the sequence instead of adding them.</source>
          <target state="translated">Доступно только для типов номеров.Обратите внимание,что последовательность будет неинициализирована.После создания последовательности необходимо присваивать ей записи,а не добавлять их.</target>
        </trans-unit>
        <trans-unit id="7532cddc260a1527eb39bd5975f976f61cc3dd83" translate="yes" xml:space="preserve">
          <source>Only error and fatal messages will cause the output buffer to be flushed immediately. Use the &lt;a href=&quot;io#flushFile,File&quot;&gt;flushFile proc&lt;/a&gt; to flush the buffer manually if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc370c46bbbf0bf1dd85847affcf8aaa6e750bc" translate="yes" xml:space="preserve">
          <source>Only used in PSK ciphersuites.</source>
          <target state="translated">Используется только в шифровальных комплектах PSK.</target>
        </trans-unit>
        <trans-unit id="ceea6a715ca43640a59d2dcdf7b7681ea3882443" translate="yes" xml:space="preserve">
          <source>Only useful if set server-side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bd3d75d2161188ac0381f01f684cf113e3579e" translate="yes" xml:space="preserve">
          <source>OpChars:</source>
          <target state="translated">OpChars:</target>
        </trans-unit>
        <trans-unit id="061313292428912182098de432d58a7d8e9cc1bb" translate="yes" xml:space="preserve">
          <source>Open a parser, using the given arguments to set up its internal state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eef2b7e3d6c43c01d59bb1d06ba5236003b6a81" translate="yes" xml:space="preserve">
          <source>Open and Closed symbols</source>
          <target state="translated">Символы открытия и закрытия</target>
        </trans-unit>
        <trans-unit id="cc4d804a9a52970f4e0eefea5bf1b6f54e9967fb" translate="yes" xml:space="preserve">
          <source>Open arrays</source>
          <target state="translated">Открытые массивы</target>
        </trans-unit>
        <trans-unit id="3e4447a76d334227b53f87594f9577969a26e881" translate="yes" xml:space="preserve">
          <source>Open database connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0714f9844e88b33e62cf52d5b0d001860502d901" translate="yes" xml:space="preserve">
          <source>Open input stream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab2517dbed2bed693f918f911730ef79e6d5360" translate="yes" xml:space="preserve">
          <source>Open symbols are looked up in two different contexts: Both the context at definition and the context at instantiation are considered:</source>
          <target state="translated">Открытые символы просматриваются в двух различных контекстах:Рассматриваются как контекст при определении,так и контекст при конкретизации:</target>
        </trans-unit>
        <trans-unit id="6dc1a7bf5dd1013cab3f801ec28857dece149460" translate="yes" xml:space="preserve">
          <source>OpenMP parallel loop iterator with stepping. Same as &lt;code&gt;countup&lt;/code&gt; but the loop may run in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67376ee07cbce917e8219510219ec5b620099129" translate="yes" xml:space="preserve">
          <source>OpenMP parallel loop iterator. Same as &lt;code&gt;..&lt;/code&gt; but the loop may run in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b366a2a3d0445fcc6195c7e8bf9aa2ec87d29a" translate="yes" xml:space="preserve">
          <source>OpenSSL 0.9.8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1948a8835e811d7bb8fe3dc8f03cdae689640cb" translate="yes" xml:space="preserve">
          <source>OpenSSL 1.0.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c6ce40f6dd891b1898209548f158bde2dc23bc" translate="yes" xml:space="preserve">
          <source>OpenSSL 1.1.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d77bab6bef6033d1033ca864d642fde957a56f8" translate="yes" xml:space="preserve">
          <source>OpenSSL can also be statically linked using &lt;code&gt;--dynlibOverride:ssl&lt;/code&gt; for OpenSSL &amp;gt;= 1.1.0. If you want to statically link against OpenSSL 1.0.x, you now have to define the &lt;code&gt;openssl10&lt;/code&gt; symbol via &lt;code&gt;-d:openssl10&lt;/code&gt;.</source>
          <target state="translated">OpenSSL также можно статически связать с помощью &lt;code&gt;--dynlibOverride:ssl&lt;/code&gt; для OpenSSL&amp;gt; = 1.1.0. Если вы хотите &lt;code&gt;openssl10&lt;/code&gt; статическую ссылку на OpenSSL 1.0.x, теперь вам нужно определить символ openssl10 с помощью &lt;code&gt;-d:openssl10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0576b64464ad64eb4c53eaa5c4ef2696b5bb4d5" translate="yes" xml:space="preserve">
          <source>OpenSSL support</source>
          <target state="translated">Поддержка OpenSSL</target>
        </trans-unit>
        <trans-unit id="41785aa4105d96f7aa2063837bbf62b9d0c42838" translate="yes" xml:space="preserve">
          <source>Opening a connection to a database</source>
          <target state="translated">Открытие подключения к базе данных</target>
        </trans-unit>
        <trans-unit id="075f451d6a093e7fdd7b9ad18b76dcfe972397a7" translate="yes" xml:space="preserve">
          <source>Opens &lt;code&gt;url&lt;/code&gt; with the user's default browser. This does not block. The URL must not be empty string, to open on a blank page see &lt;code&gt;openDefaultBrowser()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d145821f017af9ef3f638af874e9b10829b0995" translate="yes" xml:space="preserve">
          <source>Opens a channel &lt;code&gt;c&lt;/code&gt; for inter thread communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b5a32312a9dd72c3dba0d99cdc13009520ada4" translate="yes" xml:space="preserve">
          <source>Opens a database connection.</source>
          <target state="translated">Открывает подключение к базе данных.</target>
        </trans-unit>
        <trans-unit id="6341a3385125d358f254687a1cf9ec666ef3ba23" translate="yes" xml:space="preserve">
          <source>Opens a database connection. Raises a &lt;code&gt;DbError&lt;/code&gt; exception if the connection could not be established.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc6b3e2b4c985f7646af8662c40813a043d8273" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;code&gt;filename&lt;/code&gt; for reading, calls &lt;a href=&quot;#readAll,File&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;system#staticRead,string&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5bedf756c39d16773af1a78426390def78e208" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;code&gt;filename&lt;/code&gt; for writing. Then writes the &lt;code&gt;content&lt;/code&gt; completely to the file and closes the file afterwards. Raises an IO exception in case of an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38b309e7cb64778d65091ba8fb43d41a2afd811" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;code&gt;filename&lt;/code&gt; with given &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d89b0ce8e9218e6fea12851e9b880be1e4997d4" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;em&gt;filename&lt;/em&gt; for reading.</source>
          <target state="translated">Открывает для чтения файл с именем &lt;em&gt;filename&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a04bc38a4be5b20cb1f277438e98d1933fa9e233" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;em&gt;filename&lt;/em&gt; for writing. Then writes the &lt;em&gt;content&lt;/em&gt; completely to the file and closes the file afterwards. Raises an IO exception in case of an error.</source>
          <target state="translated">Открывает для записи файл с именем &lt;em&gt;filename&lt;/em&gt; . Затем полностью записывает &lt;em&gt;содержимое&lt;/em&gt; в файл и после этого закрывает файл. Вызывает исключение ввода-вывода в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="eaf81cf94eccf62abfb731ae2352ef1f7afad678" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;em&gt;filename&lt;/em&gt; with given &lt;em&gt;mode&lt;/em&gt;.</source>
          <target state="translated">Открывает файл с именем &lt;em&gt;filename в&lt;/em&gt; заданном &lt;em&gt;режиме&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="14f607a4816b562ae72f4697df3c9b5d1e94db71" translate="yes" xml:space="preserve">
          <source>Opens a file specified by the path in &lt;code&gt;filename&lt;/code&gt; using the specified FileMode &lt;code&gt;mode&lt;/code&gt; asynchronously.</source>
          <target state="translated">Асинхронно открывает файл, указанный путем в &lt;code&gt;filename&lt;/code&gt; в указанном &lt;code&gt;mode&lt;/code&gt; FileMode .</target>
        </trans-unit>
        <trans-unit id="d0bbee2462ecfc98727ddc0ff7d24ba7bbb75c45" translate="yes" xml:space="preserve">
          <source>Opens the user's default browser without any &lt;code&gt;url&lt;/code&gt; (blank page). This does not block. Implements IETF RFC-6694 Section 3, &quot;about:blank&quot; must be reserved for a blank page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1668ac138ae92ffacd3116296d3548db776f14" translate="yes" xml:space="preserve">
          <source>Opera 20</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b0fc59d7aad8bc81ae95e641aa3418061b2802" translate="yes" xml:space="preserve">
          <source>Opera 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad0a017eb9f00073f41816df228a99ee3a83534" translate="yes" xml:space="preserve">
          <source>Opera 57</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="27fea8d4a592d2ef15188641818c4f50cf213496" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;mitems&lt;/code&gt; or &lt;code&gt;mpairs&lt;/code&gt; (or the now deprecated &lt;code&gt;mget&lt;/code&gt;) that allow a &lt;em&gt;mutating view&lt;/em&gt; into some data structure should start with an &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Такие операции, как &lt;code&gt;mitems&lt;/code&gt; или &lt;code&gt;mpairs&lt;/code&gt; (или теперь устаревший &lt;code&gt;mget&lt;/code&gt; ), которые позволяют изменять &lt;em&gt;представление&lt;/em&gt; в некоторой структуре данных, должны начинаться с &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="2eb04c37cf98ac30d71ff1b2f86ff1286db3a060" translate="yes" xml:space="preserve">
          <source>Operators ending in either &lt;code&gt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;~&amp;gt;&lt;/code&gt; or &lt;code&gt;=&amp;gt;&lt;/code&gt; are called &lt;span id=&quot;arrow-like_1&quot;&gt;arrow like&lt;/span&gt;, and have the lowest precedence of all operators.</source>
          <target state="translated">Операторы, оканчивающиеся на &lt;code&gt;-&amp;gt;&lt;/code&gt; , &lt;code&gt;~&amp;gt;&lt;/code&gt; или &lt;code&gt;=&amp;gt;&lt;/code&gt; , называются &lt;span id=&quot;arrow-like_1&quot;&gt;стрелочными&lt;/span&gt; и имеют самый низкий приоритет среди всех операторов.</target>
        </trans-unit>
        <trans-unit id="b9fb7505b70ebf5d6a9bf27d2cc12bbd40ee6af9" translate="yes" xml:space="preserve">
          <source>Operators with one parameter are prefix operators, operators with two parameters are infix operators. (However, the parser distinguishes these from the operator's position within an expression.) There is no way to declare postfix operators: all postfix operators are built-in and handled by the grammar explicitly.</source>
          <target state="translated">Операторы с одним параметром являются префиксными операторами,операторы с двумя параметрами-инффиксными операторами.(Однако синтаксический анализатор отличает их от позиции оператора в выражении).Объявлять постфиксные операторы невозможно:все постфиксные операторы встроены и явно обрабатываются грамматикой.</target>
        </trans-unit>
        <trans-unit id="6ff265181afd92a333026e2c5d5e199dc5da7ef8" translate="yes" xml:space="preserve">
          <source>Operators:</source>
          <target state="translated">Operators:</target>
        </trans-unit>
        <trans-unit id="4cad12b6f389d483084d0d553643ba732946936d" translate="yes" xml:space="preserve">
          <source>Optimize the code for speed or size, or disable optimization.</source>
          <target state="translated">Оптимизировать код для скорости или размера,или отключить оптимизацию.</target>
        </trans-unit>
        <trans-unit id="5bc67490a69e2f143ae9471a30d11d13f1cf0a23" translate="yes" xml:space="preserve">
          <source>Optimized version of &lt;a href=&quot;#replace,string,string&quot;&gt;replace&lt;/a&gt; for characters.</source>
          <target state="translated">Оптимизированная версия &lt;a href=&quot;#replace,string,string&quot;&gt;замены&lt;/a&gt; для персонажей.</target>
        </trans-unit>
        <trans-unit id="5a8298c3a957647aef96f07b3da793f45200cac3" translate="yes" xml:space="preserve">
          <source>Optimized version of &lt;a href=&quot;#replace,string,string,string&quot;&gt;replace&lt;/a&gt; for characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13225c7d848cc0d6dfe6ef6391b22b19c1fefb1b" translate="yes" xml:space="preserve">
          <source>Optimizer:</source>
          <target state="translated">Optimizer:</target>
        </trans-unit>
        <trans-unit id="eeaab884d147b712e7cd622a4a60b4a88154310b" translate="yes" xml:space="preserve">
          <source>Optimizing for Nim</source>
          <target state="translated">Оптимизация для Ним</target>
        </trans-unit>
        <trans-unit id="b48db209b043766c1b5804d5e27bcd73790ad927" translate="yes" xml:space="preserve">
          <source>Optimizing string handling</source>
          <target state="translated">Оптимизация обработки строк</target>
        </trans-unit>
        <trans-unit id="74b1e148d5f6b3cc16368babcbaee255c62422d6" translate="yes" xml:space="preserve">
          <source>Optional human readable string to display as hyper link. If the value is not present or is the empty string, the hyper link will be rendered using the term. Prefix whitespace indicates that this entry is not for an API symbol but for a TOC entry.</source>
          <target state="translated">Дополнительная читаемая человеком строка для отображения в виде гиперссылки.Если значение отсутствует или является пустой строкой,то гиперссылка будет отображена с использованием этого термина.Префиксный пробел означает,что эта запись предназначена не для символа API,а для записи TOC.</target>
        </trans-unit>
        <trans-unit id="d39225d11f759a6f965920f1aaea6c3af2e9f0dd" translate="yes" xml:space="preserve">
          <source>Optional title or description of the hyper link. Browsers usually display this as a tooltip after hovering a moment over the hyper link.</source>
          <target state="translated">Необязательное название или описание гиперссылки.Браузеры обычно отображают это в виде всплывающей подсказки после наведения указателя мыши на гиперссылку.</target>
        </trans-unit>
        <trans-unit id="c193b422d4cdb46518f62b1308dcbb7e534adc1e" translate="yes" xml:space="preserve">
          <source>Optionally, the initial capacity can be reserved via &lt;code&gt;initialSize&lt;/code&gt; as a performance optimization. The length of a newly created deque will still be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1957a08c23244cb7c73a47bb45230876010740d3" translate="yes" xml:space="preserve">
          <source>Optionally: manpages, documentation, shell completion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a81599fb16f88a774e6e6dde5e5c88bf3a24004" translate="yes" xml:space="preserve">
          <source>Options that can be passed to &lt;a href=&quot;#startProcess,string,string,openArray%5Bstring%5D,StringTableRef,set%5BProcessOption%5D&quot;&gt;startProcess proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd0b506837a990803d8edf137f2934329835748" translate="yes" xml:space="preserve">
          <source>Options:</source>
          <target state="translated">Options:</target>
        </trans-unit>
        <trans-unit id="81de498479269f7efcd2ce9f7789819338e86fcf" translate="yes" xml:space="preserve">
          <source>Or if we directly use a ref object:</source>
          <target state="translated">Или если мы напрямую используем объект ссылок:</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="21ab442b56e6693d449e1b3316a7c72b27f04270" translate="yes" xml:space="preserve">
          <source>Order of evaluation</source>
          <target state="translated">Порядок оценки</target>
        </trans-unit>
        <trans-unit id="6fddf2edd42bb52326d95d7ad197008a3ad3c62b" translate="yes" xml:space="preserve">
          <source>Order of evaluation is strictly left-to-right, inside-out as it is typical for most others imperative programming languages:</source>
          <target state="translated">Порядок оценки строго слева направо,изнутри,как это типично для большинства других императивных языков программирования:</target>
        </trans-unit>
        <trans-unit id="45f68e3d201980b2ce2fa3c6e8912431c529664b" translate="yes" xml:space="preserve">
          <source>Ordered choice: Apply expressions &lt;code&gt;A&lt;/code&gt;, ..., &lt;code&gt;Z&lt;/code&gt;, in this order, to the text ahead, until one of them succeeds and possibly consumes some text. Indicate success if one of expressions succeeded. Otherwise do not consume any text and indicate failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab66e435888dccd3c76f559e634b263fcd8938b5" translate="yes" xml:space="preserve">
          <source>Ordered choice: Apply expressions &lt;em&gt;A&lt;/em&gt;, ..., &lt;em&gt;Z&lt;/em&gt;, in this order, to the text ahead, until one of them succeeds and possibly consumes some text. Indicate success if one of expressions succeeded. Otherwise do not consume any text and indicate failure.</source>
          <target state="translated">Упорядоченный выбор: примените выражения &lt;em&gt;A&lt;/em&gt; , ..., &lt;em&gt;Z&lt;/em&gt; в этом порядке к тексту впереди, пока одно из них не завершится успешно и, возможно, не поглотит некоторый текст. Укажите успех, если одно из выражений выполнено успешно. В противном случае не использовать текст и указывать на сбой.</target>
        </trans-unit>
        <trans-unit id="52eba0e6519807164baca0d6b1158a8ecd7de4c9" translate="yes" xml:space="preserve">
          <source>OrderedTable</source>
          <target state="translated">OrderedTable</target>
        </trans-unit>
        <trans-unit id="bca57d661a7ac85cef723a55cd585566c9d3f621" translate="yes" xml:space="preserve">
          <source>Ordinal types</source>
          <target state="translated">Обычные типы</target>
        </trans-unit>
        <trans-unit id="3119a2318ed75057b08b3960866241e029fabd75" translate="yes" xml:space="preserve">
          <source>Ordinal types are countable and ordered. This property allows the operation of functions as &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;ord&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt; on ordinal types to be defined.</source>
          <target state="translated">Порядковые типы счетные и упорядоченные. Это свойство позволяет определять работу функций как &lt;code&gt;inc&lt;/code&gt; , &lt;code&gt;ord&lt;/code&gt; , &lt;code&gt;dec&lt;/code&gt; для порядковых типов.</target>
        </trans-unit>
        <trans-unit id="872a8c3d6d59041261f393e2e15158de859ea0da" translate="yes" xml:space="preserve">
          <source>Ordinal types have the following characteristics:</source>
          <target state="translated">Обычные типы имеют следующие характеристики:</target>
        </trans-unit>
        <trans-unit id="e629aac27b5777617cee72722956d8b340e2199c" translate="yes" xml:space="preserve">
          <source>Ordinal values have a largest possible value. Trying to count further than the largest value gives a checked runtime or static error.</source>
          <target state="translated">Обычные значения имеют наибольшую возможную величину.Попытка посчитать больше,чем наибольшее значение дает проверенное время выполнения или статическую ошибку.</target>
        </trans-unit>
        <trans-unit id="36acb83b7e99f490d0435fdeb44f36127e91db65" translate="yes" xml:space="preserve">
          <source>Ordinal values have a smallest possible value. Trying to count further down than the smallest value gives a checked runtime or static error.</source>
          <target state="translated">Заданные значения имеют наименьшее возможное значение.Попытка отсчета дальше наименьшего значения дает проверенное время выполнения или статическую ошибку.</target>
        </trans-unit>
        <trans-unit id="a3273ae720a4e64dcca9795fe755e4b9213bc669" translate="yes" xml:space="preserve">
          <source>Ordinal values have the largest possible value. Trying to count further than the largest value produces a panic or a static error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563bb5bf58644ad6723e724e397712047e75b6e7" translate="yes" xml:space="preserve">
          <source>Ordinal values have the smallest possible value. Trying to count further down than the smallest value produces a panic or a static error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa953406f4d182ae08a38375892d6aff714ff91" translate="yes" xml:space="preserve">
          <source>OrdinalType.FloatLike</source>
          <target state="translated">OrdinalType.FloatLike</target>
        </trans-unit>
        <trans-unit id="88dcff2ae87c9e99ad5c60ac3538a976e2816c25" translate="yes" xml:space="preserve">
          <source>OrdinalType.IntLike</source>
          <target state="translated">OrdinalType.IntLike</target>
        </trans-unit>
        <trans-unit id="f88d1629d2c6e62128639c388362a7be4a950f39" translate="yes" xml:space="preserve">
          <source>OrdinalType.NoneLike</source>
          <target state="translated">OrdinalType.NoneLike</target>
        </trans-unit>
        <trans-unit id="a47cfd3d99cec2694c9dbb5322d0b724efa09a94" translate="yes" xml:space="preserve">
          <source>OrdinalType:</source>
          <target state="translated">OrdinalType:</target>
        </trans-unit>
        <trans-unit id="3ed1f6c1083d3683b1c12d25ec50e612d1123f42" translate="yes" xml:space="preserve">
          <source>Ordinals</source>
          <target state="translated">Ordinals</target>
        </trans-unit>
        <trans-unit id="aa2feef9929fb50eb0970ed959dead68aeaa3fc1" translate="yes" xml:space="preserve">
          <source>Ordinary code should not use this, but the &lt;a href=&quot;typeinfo&quot;&gt;typeinfo module&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d640a1890d09eeb8ca875d238db12f1e6d3c3e8" translate="yes" xml:space="preserve">
          <source>Ordinary procs are often preferred over type conversions in Nim: For instance, &lt;code&gt;$&lt;/code&gt; is the &lt;code&gt;toString&lt;/code&gt; operator by convention and &lt;code&gt;toFloat&lt;/code&gt; and &lt;code&gt;toInt&lt;/code&gt; can be used to convert from floating point to integer or vice versa.</source>
          <target state="translated">Обычные процедуры часто предпочтительнее преобразований типов в Nim: например, &lt;code&gt;$&lt;/code&gt; является оператором &lt;code&gt;toString&lt;/code&gt; по соглашению, а &lt;code&gt;toFloat&lt;/code&gt; и &lt;code&gt;toInt&lt;/code&gt; могут использоваться для преобразования из числа с плавающей запятой в целое число или наоборот.</target>
        </trans-unit>
        <trans-unit id="0ec5421d5a04b330a5d5f07445ff5c33b2ee43c5" translate="yes" xml:space="preserve">
          <source>Ordinary procs are often preferred over type conversions in Nim: For instance, &lt;code&gt;$&lt;/code&gt; is the &lt;code&gt;toString&lt;/code&gt; operator by convention and &lt;code&gt;toFloat&lt;/code&gt; and &lt;code&gt;toInt&lt;/code&gt; can be used to convert from floating-point to integer or vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="2ff9f42e32037de9fa807030da493664b568f9f2" translate="yes" xml:space="preserve">
          <source>Other Input Formats</source>
          <target state="translated">Другие входные форматы</target>
        </trans-unit>
        <trans-unit id="43a5e3b913b70aa6bbf66b3f9a94594af1d85d6e" translate="yes" xml:space="preserve">
          <source>Other features that are &lt;em&gt;implicitly&lt;/em&gt; triggered cause problems for modularity too. Type converters fall into this category:</source>
          <target state="translated">Другие функции, которые &lt;em&gt;неявно&lt;/em&gt; запускаются, также создают проблемы для модульности. Преобразователи типов попадают в эту категорию:</target>
        </trans-unit>
        <trans-unit id="13f7dea1ee4b7cb7f096198dcfd885624c0eca95" translate="yes" xml:space="preserve">
          <source>Other languages name a type like these &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8702ae2aa93e41c74ae80da30c44c3106f145472" translate="yes" xml:space="preserve">
          <source>Other literal types, such as &lt;code&gt;uint literal(123)&lt;/code&gt; that would automatically convert to other integer types, but prefers to become a &lt;code&gt;uint&lt;/code&gt; are not part of the Nim language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb62f4ab5d15274940b6aca44c5aaa8ba4f5ebac" translate="yes" xml:space="preserve">
          <source>Other modules may provide other implementations for this standard stream interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaade51f8bd7dc897edf07f1c61fcd7a86afa793" translate="yes" xml:space="preserve">
          <source>Other parts of Nim - like scoping rules or runtime semantics are only described in the, more easily comprehensible, informal manner for now.</source>
          <target state="translated">Другие части Nim-такие,как правила определения масштаба или семантика времени исполнения-пока описываются только в,более понятной,неформальной манере.</target>
        </trans-unit>
        <trans-unit id="cd81b04823d8d098b759de332e3f37424b167edb" translate="yes" xml:space="preserve">
          <source>Other parts of Nim, like scoping rules or runtime semantics, are described informally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13760399786dc4b7c7d0f4b3dbf3b00e5ee44753" translate="yes" xml:space="preserve">
          <source>Other strings can be inserted by putting them in &lt;code&gt;''&lt;/code&gt;. For example &lt;code&gt;hh'-&amp;gt;'mm&lt;/code&gt; will give &lt;code&gt;01-&amp;gt;56&lt;/code&gt;. The following characters can be inserted without quoting them: &lt;code&gt;:&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;[&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;. A literal &lt;code&gt;'&lt;/code&gt; can be specified with &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">Другие строки можно вставить, вставив их в &lt;code&gt;''&lt;/code&gt; . Например, &lt;code&gt;hh'-&amp;gt;'mm&lt;/code&gt; даст &lt;code&gt;01-&amp;gt;56&lt;/code&gt; . Следующие символы могут быть вставлены без цитировать их: &lt;code&gt;:&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; . Литерал &lt;code&gt;'&lt;/code&gt; может быть указан с помощью &lt;code&gt;''&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db18f7107204fed8fe24c5d3014de56d0af6c5d" translate="yes" xml:space="preserve">
          <source>Other tokens</source>
          <target state="translated">Другие жетоны</target>
        </trans-unit>
        <trans-unit id="d65b86f3209b622242b01d2656aba539a4c22285" translate="yes" xml:space="preserve">
          <source>Other useful iterators for collections (like arrays and sequences) are</source>
          <target state="translated">Другими полезными итераторами для коллекций (например,массивов и последовательностей)являются</target>
        </trans-unit>
        <trans-unit id="e1ab7515d2fc3d1784934bda518727e08f8359e6" translate="yes" xml:space="preserve">
          <source>Other value-based compound types like &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;array&lt;/code&gt; are handled correspondingly. For &lt;code&gt;object&lt;/code&gt; however, the compiler-generated hooks can be overridden. This can also be important to use an alternative traversal of the involved data structure that is more efficient or in order to avoid deep recursions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2d7e0a58dc8427e382ddd731db370ec009572b" translate="yes" xml:space="preserve">
          <source>Otherwise precedence is determined by the first character.</source>
          <target state="translated">В противном случае приоритет определяется первым символом.</target>
        </trans-unit>
        <trans-unit id="21bc9e76f2a8c2a0eaf537c08d3d36f6d8085e56" translate="yes" xml:space="preserve">
          <source>Otherwise returns an empty string.</source>
          <target state="translated">В противном случае возвращает пустую строку.</target>
        </trans-unit>
        <trans-unit id="1c72b5f977bcddbc511f75e162bc5876c1a3aead" translate="yes" xml:space="preserve">
          <source>Otherwise, precedence is determined by the first character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdd4c9ffbb5fd3025e9485c4feb564db99a1d5f" translate="yes" xml:space="preserve">
          <source>Our first attempt will start by modifying the program to generate a compile time string with the &lt;em&gt;generated source code&lt;/em&gt;, which we then pass to the &lt;code&gt;parseStmt&lt;/code&gt; proc from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt;. Here is the modified source code implementing the macro:</source>
          <target state="translated">Наша первая попытка начнется с изменения программы, чтобы сгенерировать строку времени компиляции с &lt;em&gt;сгенерированным исходным кодом&lt;/em&gt; , которую мы затем передаем процедуре &lt;code&gt;parseStmt&lt;/code&gt; из &lt;a href=&quot;macros&quot;&gt;модуля макросов&lt;/a&gt; . Вот модифицированный исходный код, реализующий макрос:</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="1458e0711b267bc74f8fee698a4064944483ced7" translate="yes" xml:space="preserve">
          <source>Overflow: operation produces a result that exceeds the range of the exponent, for example MAXDOUBLE+0.0000000000001e308.</source>
          <target state="translated">Переполнение:операция дает результат,превышающий диапазон экспонента,например MAXDOUBLE+0.0000000000001e308.</target>
        </trans-unit>
        <trans-unit id="7e1b7bd0afdc5a65df37f4970df5c8e08d3dd78f" translate="yes" xml:space="preserve">
          <source>Overload resolution can be further influenced by constraining the set of types that will match the type param. This works in practice by attaching attributes to types via templates. The constraint can be a concrete type or a type class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754c102f9b75ce776185c568a14f1c8a51acdc8a" translate="yes" xml:space="preserve">
          <source>Overload resolution can be further influenced by constraining the set of types that will match the type param:</source>
          <target state="translated">На разрешение перегрузки может дополнительно влиять ограничение набора типов,которые будут соответствовать параметру типа:</target>
        </trans-unit>
        <trans-unit id="7fa7936a516e9b4405cfaaa07e91ba994298a243" translate="yes" xml:space="preserve">
          <source>Overload that validates &lt;code&gt;f&lt;/code&gt; at compile time.</source>
          <target state="translated">Перегрузка, которая проверяет &lt;code&gt;f&lt;/code&gt; во время компиляции.</target>
        </trans-unit>
        <trans-unit id="9c00e2ea8b8b406447c26bdcb6148e11ef275602" translate="yes" xml:space="preserve">
          <source>Overload that validates &lt;code&gt;format&lt;/code&gt; at compile time.</source>
          <target state="translated">Перегрузка, проверяющая &lt;code&gt;format&lt;/code&gt; во время компиляции.</target>
        </trans-unit>
        <trans-unit id="4640027ad29996563c1a87a8afddf3069ba5a1e7" translate="yes" xml:space="preserve">
          <source>OverloadableSyms:</source>
          <target state="translated">OverloadableSyms:</target>
        </trans-unit>
        <trans-unit id="084d89d78f9253e5971aa14b7a1c146ed66021d5" translate="yes" xml:space="preserve">
          <source>Overloaded procedures</source>
          <target state="translated">Перегруженные процедуры</target>
        </trans-unit>
        <trans-unit id="52682dea26ce453286dbc5b5476302bf2f155d52" translate="yes" xml:space="preserve">
          <source>Overloading based on &amp;#x27;var T&amp;#x27;</source>
          <target state="translated">Перегрузка на основе 'var T'</target>
        </trans-unit>
        <trans-unit id="fdfc3d44da0fc76ce20708147d4fa0f06487870d" translate="yes" xml:space="preserve">
          <source>Overloading based on 'var T'</source>
          <target state="translated">Перегрузка на основе &quot;var T</target>
        </trans-unit>
        <trans-unit id="3fa8556506ad2f2650ad5f0ace5f70fac3fe501b" translate="yes" xml:space="preserve">
          <source>Overloading based on 'var T' / 'out T'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376919dad96314f113fa2e51189fad0ab6b8a289" translate="yes" xml:space="preserve">
          <source>Overloading of the subscript operator</source>
          <target state="translated">Перегрузка абонентского оператора</target>
        </trans-unit>
        <trans-unit id="856f6c8643871a65621d9a78bd00b337b84e3743" translate="yes" xml:space="preserve">
          <source>Overloading resolution</source>
          <target state="translated">разрешение перегрузки</target>
        </trans-unit>
        <trans-unit id="59d786986f63a664027eb772a26d80c3f7a0abe9" translate="yes" xml:space="preserve">
          <source>Override this method in custom loggers. Default implementation does nothing.</source>
          <target state="translated">Отменить этот метод в пользовательских регистраторах.Реализация по умолчанию ничего не делает.</target>
        </trans-unit>
        <trans-unit id="6e1ae1a7c1ebfbcd4f7e403da7e822ba08800911" translate="yes" xml:space="preserve">
          <source>Override this method in custom loggers. The default implementation does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a660e603ccfc886dc9821594693be1bc0353fd" translate="yes" xml:space="preserve">
          <source>Overrides the location of a given file belonging to the passed package. If the &lt;code&gt;replacement&lt;/code&gt; is not an absolute path, the path is interpreted to be local to the Nimscript file that contains the call to &lt;code&gt;patchFile&lt;/code&gt;, Nim's &lt;code&gt;--path&lt;/code&gt; is not used at all to resolve the filename!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="b6d3fab9b4983c0a7fac72ed7d8df78bdcbf862d" translate="yes" xml:space="preserve">
          <source>Overwrites the contents of the memory at &lt;code&gt;p&lt;/code&gt; with the value 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7bf096f89a1c09f22a68174532321948a126b7a" translate="yes" xml:space="preserve">
          <source>PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.</source>
          <target state="translated">PCRE-это библиотека функций для поддержки регулярных выражений,синтаксис и семантика которых максимально приближены к синтаксису и семантике языка Perl 5.</target>
        </trans-unit>
        <trans-unit id="dbd40bd5aaef4dbeb16b94e187805c444acafbdf" translate="yes" xml:space="preserve">
          <source>PContext:</source>
          <target state="translated">PContext:</target>
        </trans-unit>
        <trans-unit id="7cacbbd17d87f4550a6720e9ec18284a7061410d" translate="yes" xml:space="preserve">
          <source>PCtx:</source>
          <target state="translated">PCtx:</target>
        </trans-unit>
        <trans-unit id="cc9a0f474ef35d5f0eb8a004093952e55059eb5c" translate="yes" xml:space="preserve">
          <source>PDoc:</source>
          <target state="translated">PDoc:</target>
        </trans-unit>
        <trans-unit id="595a895491f3a0cc703f76860a5a4b9d42a6ea7f" translate="yes" xml:space="preserve">
          <source>PEG construction</source>
          <target state="translated">строительство ПЭГ</target>
        </trans-unit>
        <trans-unit id="118ee2de963e33508b97b815b8c557728d365a9c" translate="yes" xml:space="preserve">
          <source>PEG syntax and semantics</source>
          <target state="translated">синтаксис и семантика PEG</target>
        </trans-unit>
        <trans-unit id="9bde7e84a708b95057b420b93ae5d95c394c2f01" translate="yes" xml:space="preserve">
          <source>PEG vs regular expression</source>
          <target state="translated">PEG против регулярного выражения</target>
        </trans-unit>
        <trans-unit id="9a88b7a4b3c1cc84a7c0e7df861d95ea546a29f6" translate="yes" xml:space="preserve">
          <source>PEvalContext:</source>
          <target state="translated">PEvalContext:</target>
        </trans-unit>
        <trans-unit id="d9feff605b042a276d71f7511edd02d350b336f6" translate="yes" xml:space="preserve">
          <source>PIdObj:</source>
          <target state="translated">PIdObj:</target>
        </trans-unit>
        <trans-unit id="ffab2525091289dbd9d41123e41aff716b05e503" translate="yes" xml:space="preserve">
          <source>PIdent:</source>
          <target state="translated">PIdent:</target>
        </trans-unit>
        <trans-unit id="fd7dba84795498ad0e65cc4af895fd7d829b3c54" translate="yes" xml:space="preserve">
          <source>PInstantiation:</source>
          <target state="translated">PInstantiation:</target>
        </trans-unit>
        <trans-unit id="accfd6dd76c6b8689524f104b98bddaef54a702a" translate="yes" xml:space="preserve">
          <source>PLLStream:</source>
          <target state="translated">PLLStream:</target>
        </trans-unit>
        <trans-unit id="cbeaa1d5e4e194941a961e776953a09573177112" translate="yes" xml:space="preserve">
          <source>PLib:</source>
          <target state="translated">PLib:</target>
        </trans-unit>
        <trans-unit id="fc242215607474d0c7b7da3f12b4b91f6f303f9d" translate="yes" xml:space="preserve">
          <source>PNode:</source>
          <target state="translated">PNode:</target>
        </trans-unit>
        <trans-unit id="567edf4105fe83ec09be7bbd5ad833d065991b7e" translate="yes" xml:space="preserve">
          <source>POSIX character class (only if followed by POSIX syntax)</source>
          <target state="translated">POSIX-символьный класс (только если за ним следует синтаксис POSIX)</target>
        </trans-unit>
        <trans-unit id="e3896dc47c849389aad6b68320cef38af4776a63" translate="yes" xml:space="preserve">
          <source>POSIX-compliant systems on conventional hardware are usually pretty easy to port: Add the platform to &lt;code&gt;platform&lt;/code&gt; (if it is not already listed there), check that the OS, System modules work and recompile Nim.</source>
          <target state="translated">POSIX-совместимые системы на обычном оборудовании обычно довольно легко переносить: добавьте платформу на &lt;code&gt;platform&lt;/code&gt; (если она еще не указана), убедитесь, что ОС, системные модули работают, и перекомпилируйте Nim.</target>
        </trans-unit>
        <trans-unit id="12142e28cc69313a619ae99c351fba5fe84b0a4b" translate="yes" xml:space="preserve">
          <source>POSTs &lt;code&gt;body&lt;/code&gt; to &lt;code&gt;url&lt;/code&gt; and returns the response's body as a string</source>
          <target state="translated">Отправляет &lt;code&gt;body&lt;/code&gt; на &lt;code&gt;url&lt;/code&gt; и возвращает тело ответа в виде строки</target>
        </trans-unit>
        <trans-unit id="2dbc1dded6bee0ca902ff7658892851595e373f2" translate="yes" xml:space="preserve">
          <source>POSTs &lt;code&gt;body&lt;/code&gt; to the &lt;code&gt;url&lt;/code&gt; and returns a &lt;code&gt;Response&lt;/code&gt; object.</source>
          <target state="translated">Отправляет &lt;code&gt;body&lt;/code&gt; сообщения на &lt;code&gt;url&lt;/code&gt; и возвращает объект &lt;code&gt;Response&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6aee922e510d7ec57148a12114d5593e2b06f9" translate="yes" xml:space="preserve">
          <source>POptionEntry:</source>
          <target state="translated">POptionEntry:</target>
        </trans-unit>
        <trans-unit id="671f7474c264cec8bd98b6bc369716f871230c32" translate="yes" xml:space="preserve">
          <source>PPassContext:</source>
          <target state="translated">PPassContext:</target>
        </trans-unit>
        <trans-unit id="fae5eded41aca0b332d2db1f43cc65305199884d" translate="yes" xml:space="preserve">
          <source>PProc:</source>
          <target state="translated">PProc:</target>
        </trans-unit>
        <trans-unit id="11901d272bf1a502817be89a6f84525164cfa2da" translate="yes" xml:space="preserve">
          <source>PProcCon:</source>
          <target state="translated">PProcCon:</target>
        </trans-unit>
        <trans-unit id="b4e6954da93815488c9a364b8a508b656e9a52c2" translate="yes" xml:space="preserve">
          <source>PScope:</source>
          <target state="translated">PScope:</target>
        </trans-unit>
        <trans-unit id="db62fc930ef7c90144194475b3b082dfe8559291" translate="yes" xml:space="preserve">
          <source>PStackFrame:</source>
          <target state="translated">PStackFrame:</target>
        </trans-unit>
        <trans-unit id="4500d5cdba9ccdd561ec42d814fc3287a68d4171" translate="yes" xml:space="preserve">
          <source>PSym:</source>
          <target state="translated">PSym:</target>
        </trans-unit>
        <trans-unit id="f952a66c2e11ba6f3956bcda3c808ff7a43df019" translate="yes" xml:space="preserve">
          <source>PType:</source>
          <target state="translated">PType:</target>
        </trans-unit>
        <trans-unit id="332b04a11e1cc3787447391399cd62fd1868e0c6" translate="yes" xml:space="preserve">
          <source>Package level objects</source>
          <target state="translated">Объекты пакетного уровня</target>
        </trans-unit>
        <trans-unit id="77adf05ce915bafb1957104035a50844753d37c0" translate="yes" xml:space="preserve">
          <source>Packaging Nim</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b83e85b6cee3a941fc9661251d4bdffffa5249" translate="yes" xml:space="preserve">
          <source>Packaging for Linux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55fd3d981957b0d91d11e46f1e01dfd840b2014b" translate="yes" xml:space="preserve">
          <source>Packed pragma</source>
          <target state="translated">Упакованная прагма</target>
        </trans-unit>
        <trans-unit id="eea669f22aa5d4a29c38a6b10887b380fe6f283b" translate="yes" xml:space="preserve">
          <source>Pairwise (cascade) summation of &lt;code&gt;x[i0:i0+n-1]&lt;/code&gt;, with O(log n) error growth (vs O(n) for a simple loop) with negligible performance cost if the base case is large enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5510a92cb951dc073e6190edad274f134f704fb8" translate="yes" xml:space="preserve">
          <source>Parallel &amp;amp; Spawn</source>
          <target state="translated">Параллельный и спаун</target>
        </trans-unit>
        <trans-unit id="3b1299c53c7f5cf485c6482e9c854f429e16cdd6" translate="yes" xml:space="preserve">
          <source>Parallel statement</source>
          <target state="translated">Параллельное заявление</target>
        </trans-unit>
        <trans-unit id="eec7d291b5a6446b7643c94e8e46ada61a750299" translate="yes" xml:space="preserve">
          <source>Parameter constraints</source>
          <target state="translated">Ограничения по параметрам</target>
        </trans-unit>
        <trans-unit id="6edec2e5d0a7a5dbb4aae5b4adaf9693a07b89ea" translate="yes" xml:space="preserve">
          <source>Parameter constraints can also be used for ordinary routine parameters; these constraints affect ordinary overloading resolution then:</source>
          <target state="translated">Ограничения параметров также могут быть использованы для обычных рутинных параметров;в этом случае эти ограничения влияют на обычное разрешение перегрузки:</target>
        </trans-unit>
        <trans-unit id="f1a6890392c7940ddb0108d029ad337fb538b0dc" translate="yes" xml:space="preserve">
          <source>Parameter substitution</source>
          <target state="translated">Замена параметров</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="248b028facc0fd21c2e902405b8d5a47c01d6c40" translate="yes" xml:space="preserve">
          <source>Parameters and their defaults:</source>
          <target state="translated">Параметры и их значения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="0f206e21ffd2fb787832ab9df479679c8199f0e6" translate="yes" xml:space="preserve">
          <source>Parameters are immutable in the procedure body. By default, their value cannot be changed because this allows the compiler to implement parameter passing in the most efficient way. If a mutable variable is needed inside the procedure, it has to be declared with &lt;code&gt;var&lt;/code&gt; in the procedure body. Shadowing the parameter name is possible, and actually an idiom:</source>
          <target state="translated">Параметры неизменны в теле процедуры. По умолчанию их значение нельзя изменить, потому что это позволяет компилятору реализовать передачу параметров наиболее эффективным способом. Если внутри процедуры требуется изменяемая переменная, она должна быть объявлена ​​с помощью &lt;code&gt;var&lt;/code&gt; в теле процедуры. Возможно затенение имени параметра, и собственно идиома:</target>
        </trans-unit>
        <trans-unit id="8e2f8631ccf741645c248093e0a2a666f3997d29" translate="yes" xml:space="preserve">
          <source>Parameters can be declared mutable and so allow the proc to modify those arguments, by using the type modifier &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa46df5cd24d9e242819c5e1aa5a6733dc8ec59" translate="yes" xml:space="preserve">
          <source>Parameters can be declared mutable and so allow the proc to modify those arguments, by using the type modifier &lt;em&gt;var&lt;/em&gt;.</source>
          <target state="translated">Параметры могут быть объявлены изменяемыми, что позволяет процессу изменять эти аргументы с помощью модификатора типа &lt;em&gt;var&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bb1a33ba432c2fafb1613ca7e699e06e64431463" translate="yes" xml:space="preserve">
          <source>Parameters in a pattern are type checked in the matching process. If a parameter is of the type &lt;code&gt;varargs&lt;/code&gt; it is treated specially and it can match 0 or more arguments in the AST to be matched against:</source>
          <target state="translated">Тип параметров в шаблоне проверяется в процессе сопоставления. Если параметр имеет тип &lt;code&gt;varargs&lt;/code&gt; , он обрабатывается особым образом и может соответствовать 0 или более аргументам в AST для сопоставления:</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="f9627107a88876f4aaf6d7e0b0c19984c3a631ae" translate="yes" xml:space="preserve">
          <source>Parentheses</source>
          <target state="translated">Parentheses</target>
        </trans-unit>
        <trans-unit id="127effbb71ba19570ab235baa525f232fbd22004" translate="yes" xml:space="preserve">
          <source>Parentheses for affecting operator precedence or tuple construction are built with the &lt;code&gt;nnkPar&lt;/code&gt; node.</source>
          <target state="translated">Круглые скобки, влияющие на приоритет операторов или построение кортежей, создаются с &lt;code&gt;nnkPar&lt;/code&gt; узла nnkPar .</target>
        </trans-unit>
        <trans-unit id="4d9b125022b9ee7ebf69c8a04fd096637510b142" translate="yes" xml:space="preserve">
          <source>Parse from string to &lt;code&gt;Document&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed227c288a07222d3d51a4595d3b79f52c8d03e" translate="yes" xml:space="preserve">
          <source>Parser:</source>
          <target state="translated">Parser:</target>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="fdc5c8bf9de8fe50660fbecb95450298ca04c420" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;file&lt;/code&gt; into a &lt;code&gt;JsonNode&lt;/code&gt;. If &lt;code&gt;file&lt;/code&gt; contains extra data, it will raise &lt;code&gt;JsonParsingError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c8de0d487854ee3be6455d253f7500550cee2d" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt; using the format specified by &lt;code&gt;f&lt;/code&gt;. If no UTC offset was parsed, then &lt;code&gt;input&lt;/code&gt; is assumed to be specified in the &lt;code&gt;zone&lt;/code&gt; timezone. If a UTC offset was parsed, the result will be converted to the &lt;code&gt;zone&lt;/code&gt; timezone.</source>
          <target state="translated">Анализирует &lt;code&gt;input&lt;/code&gt; как &lt;code&gt;DateTime&lt;/code&gt; , используя формат, указанный в &lt;code&gt;f&lt;/code&gt; . Если смещение UTC не было проанализировано, предполагается , что &lt;code&gt;input&lt;/code&gt; будет указан в часовом &lt;code&gt;zone&lt;/code&gt; . Если смещение UTC было проанализировано, результат будет преобразован в часовой пояс &lt;code&gt;zone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7918d77f526af521fc86e403546e7b0e219d1d4c" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;name&lt;/code&gt; to a color value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca7a029bb84bff8ec1168a8bf88514632d40ff1" translate="yes" xml:space="preserve">
          <source>Parses &lt;em&gt;file&lt;/em&gt; into a &lt;em&gt;JsonNode&lt;/em&gt;. If &lt;em&gt;file&lt;/em&gt; contains extra data, it will raise &lt;em&gt;JsonParsingError&lt;/em&gt;.</source>
          <target state="translated">Разбирает &lt;em&gt;файл&lt;/em&gt; в &lt;em&gt;JsonNode&lt;/em&gt; . Если &lt;em&gt;файл&lt;/em&gt; содержит лишние данные, он вызовет &lt;em&gt;ошибку JsonParsingError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fafedced417174aa4da9f6c5355a4f97842e0273" translate="yes" xml:space="preserve">
          <source>Parses JSON from &lt;code&gt;buffer&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; contains extra data, it will raise &lt;code&gt;JsonParsingError&lt;/code&gt;. If &lt;code&gt;rawIntegers&lt;/code&gt; is true, integer literals will not be converted to a &lt;code&gt;JInt&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;. If &lt;code&gt;rawFloats&lt;/code&gt; is true, floating point literals will not be converted to a &lt;code&gt;JFloat&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31988daf224c3e5481844d9affd370b85ab0c4b" translate="yes" xml:space="preserve">
          <source>Parses JSON from &lt;em&gt;buffer&lt;/em&gt;. If &lt;em&gt;buffer&lt;/em&gt; contains extra data, it will raise &lt;em&gt;JsonParsingError&lt;/em&gt;.</source>
          <target state="translated">Разбирает JSON из &lt;em&gt;буфера&lt;/em&gt; . Если &lt;em&gt;буфер&lt;/em&gt; содержит дополнительные данные, он вызовет &lt;em&gt;ошибку JsonParsingError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c83d8c3603707a9ecc2dd84a9a6037c204951a36" translate="yes" xml:space="preserve">
          <source>Parses Sexp from &lt;em&gt;buffer&lt;/em&gt;.</source>
          <target state="translated">Разбирает Sexp из &lt;em&gt;буфера&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ac7b270c2a1c4209369629ad62e2046102416eaf" translate="yes" xml:space="preserve">
          <source>Parses a URI and returns it.</source>
          <target state="translated">Анализирует УРТ и возвращает его.</target>
        </trans-unit>
        <trans-unit id="ad45644f553663f9d257789c054572a54266f47c" translate="yes" xml:space="preserve">
          <source>Parses a URI. The &lt;code&gt;result&lt;/code&gt; variable will be cleared before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec7d8bb1b5440dcea9f8d95176ab435560994e3" translate="yes" xml:space="preserve">
          <source>Parses a URI. The &lt;em&gt;result&lt;/em&gt; variable will be cleared before.</source>
          <target state="translated">Разбирает URI. &lt;em&gt;Результат&lt;/em&gt; переменной будет очищено прежде.</target>
        </trans-unit>
        <trans-unit id="47c6be8783069edfdf34c74b669c16a0475feedb" translate="yes" xml:space="preserve">
          <source>Parses a binary integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18146fc030fe2a6ab8885a719a469a90008e5f4" translate="yes" xml:space="preserve">
          <source>Parses a binary integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Анализирует двоичное целочисленное значение, содержащееся в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb2463cc2ccaef503186bd51ebe5185565cfeb8" translate="yes" xml:space="preserve">
          <source>Parses a binary integer value from a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1930245a174e6900c3d7fb820106a1eb91eb1732" translate="yes" xml:space="preserve">
          <source>Parses a binary number and stores its value in &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092905e90e391bd9b854c24a81b158dbbe52809b" translate="yes" xml:space="preserve">
          <source>Parses a decimal floating point value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835e144c44ca9aa9a0c3bc52fffba2a23a756070" translate="yes" xml:space="preserve">
          <source>Parses a decimal floating point value contained in &lt;em&gt;s&lt;/em&gt;. If &lt;em&gt;s&lt;/em&gt; is not a valid floating point number, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;code&gt;NAN&lt;/code&gt;, &lt;code&gt;INF&lt;/code&gt;, &lt;code&gt;-INF&lt;/code&gt; are also supported (case insensitive comparison).</source>
          <target state="translated">Анализирует десятичное значение &lt;em&gt;с&lt;/em&gt; плавающей запятой, содержащееся в &lt;em&gt;s&lt;/em&gt; . Если &lt;em&gt;s&lt;/em&gt; не является допустимым числом с плавающей запятой, возникает &lt;em&gt;ошибка ValueError&lt;/em&gt; . Также поддерживаются &lt;code&gt;NAN&lt;/code&gt; , &lt;code&gt;INF&lt;/code&gt; , &lt;code&gt;-INF&lt;/code&gt; (сравнение без учета регистра).</target>
        </trans-unit>
        <trans-unit id="426b331688624b96220a72237b41278b8789b32f" translate="yes" xml:space="preserve">
          <source>Parses a decimal integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95acbbe3645191c11345e3af876888af39d5fe0a" translate="yes" xml:space="preserve">
          <source>Parses a decimal integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Анализирует десятичное целочисленное значение, содержащееся в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="50fee93e276e7a265a8ffb848b200df570c8c778" translate="yes" xml:space="preserve">
          <source>Parses a decimal unsigned integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0e8f3670947e2eebff34e6614bd7b5cc662d7c" translate="yes" xml:space="preserve">
          <source>Parses a decimal unsigned integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Анализирует десятичное целое число без знака, содержащееся в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bd85b664c039d20903a1b3a0d045b4bbde454585" translate="yes" xml:space="preserve">
          <source>Parses a float starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. Result is the number of processed chars or 0 if a parsing error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685445d7be6759190f48fa0f51a191e497d2eba9" translate="yes" xml:space="preserve">
          <source>Parses a float starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. Result is the number of processed chars or 0 if there occurred a parsing error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db44b06c6474e1abe579f57d2b9fb8d598fb0d1" translate="yes" xml:space="preserve">
          <source>Parses a hex integer value from a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27840da795a5763a32afb1c0666c8f210e80f391" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2552cef1d7b2fd79db3dae66bea932dea01f7f48" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Анализирует шестнадцатеричное целочисленное значение, содержащееся в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2488ed821276fa08bab01cec3a67e70fc3f6f8" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal number and stores its value in &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Анализирует шестнадцатеричное число и сохраняет его значение в виде &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb54921c8152e46b53bfa74a90daf66afa228f80" translate="yes" xml:space="preserve">
          <source>Parses a natural number into &lt;code&gt;b&lt;/code&gt;. This cannot raise an overflow error. &lt;code&gt;high(int)&lt;/code&gt; is returned for an overflow. The number of processed character is returned. This is usually what you really want to use instead of &lt;span id=&quot;parseint_1&quot;&gt;parseInt&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52772096a4233cc51e1600d105de8977b1778a95" translate="yes" xml:space="preserve">
          <source>Parses a single raw header HTTP line into key value pairs.</source>
          <target state="translated">Разбирает одну строку HTTP-заголовка в пары значений ключей.</target>
        </trans-unit>
        <trans-unit id="95b650c6035e72c967c98b41c7ebcc9dd65e6d54" translate="yes" xml:space="preserve">
          <source>Parses a string into an AST, returning the top node. &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;, although optional, provide info so that the compiler can generate correct error messages referring to the original source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c701c28b798a044aaf1117a96e54a0c2d5f2da3" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that comes before the &lt;code&gt;until&lt;/code&gt; token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36b9f501444b04abc01044f2ebfde091271a4b2" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that is not the &lt;code&gt;until&lt;/code&gt; character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d3eec3b6b0406b84be0d5701498cd7d574a854" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters in &lt;code&gt;validChars&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97d02f27717f5551aacbc5a29f3102a29c8b007" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters notin &lt;code&gt;until&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6a8d0899321496ee5b4707a4985a56d004222b" translate="yes" xml:space="preserve">
          <source>Parses a value into a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c29907580552c41f83b6dee8503b24b04303ca" translate="yes" xml:space="preserve">
          <source>Parses a value into a &lt;em&gt;bool&lt;/em&gt;.</source>
          <target state="translated">Преобразует значение в &lt;em&gt;логическое значение&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="410e8b23cd46010b49b0dd0e3914dc4ecc9e1ca5" translate="yes" xml:space="preserve">
          <source>Parses an IP address Raises EInvalidValue on error</source>
          <target state="translated">Обработка IP-адреса повышает EInvalidValue на ошибку</target>
        </trans-unit>
        <trans-unit id="3868d092804175ec95080b3c3f82ec8e767af1ea" translate="yes" xml:space="preserve">
          <source>Parses an IP address Raises ValueError on error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a6850ab1bcfc38172914099c85e87137a9e1a8e" translate="yes" xml:space="preserve">
          <source>Parses an binary number and stores its value in &lt;code&gt;number&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error.</source>
          <target state="translated">Анализирует двоичное число и сохраняет его значение в виде &lt;code&gt;number&lt;/code&gt; . Возвращает количество проанализированных символов или 0 в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="52ecab5e0e696e851dd2d8e05a4efb7aef630d77" translate="yes" xml:space="preserve">
          <source>Parses an enum &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Анализирует перечислимую &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed985855211a09c313ddd3d2ad1eecc68c677350" translate="yes" xml:space="preserve">
          <source>Parses an enum &lt;code&gt;T&lt;/code&gt;. This errors at compile time, if the given enum type contains multiple fields with the same string value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b43b85907d5ddc55c4b3714b6a9769b28c6493" translate="yes" xml:space="preserve">
          <source>Parses an identifier and returns it or an empty string in case of an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ec9442ce0c86283d4a625d404705eba967848b" translate="yes" xml:space="preserve">
          <source>Parses an identifier and stores it in &lt;code&gt;ident&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e77e0c344edc805c7867507e4487f62806f9022" translate="yes" xml:space="preserve">
          <source>Parses an integer starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. Result is the number of processed chars or 0 if there is no integer. &lt;code&gt;ValueError&lt;/code&gt; is raised if the parsed integer is out of the valid range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db59fe378bf2dcbcb71f7d850662780bf0b1cbaf" translate="yes" xml:space="preserve">
          <source>Parses an octal integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1300628673257382b63897d5a63358653f3d654e" translate="yes" xml:space="preserve">
          <source>Parses an octal integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Анализирует восьмеричное целочисленное значение, содержащееся в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8728b9534afce3f642e4b3aebeb7678eb66fd67f" translate="yes" xml:space="preserve">
          <source>Parses an octal integer value from a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7401e15eeba63dc0b50156bc802bc4478ad2f731" translate="yes" xml:space="preserve">
          <source>Parses an octal number and stores its value in &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b4c05a71f0a355fc50b443e92107cc745a1c8a" translate="yes" xml:space="preserve">
          <source>Parses an octal number and stores its value in &lt;code&gt;number&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error.</source>
          <target state="translated">Анализирует восьмеричное число и сохраняет его значение в виде &lt;code&gt;number&lt;/code&gt; . Возвращает количество проанализированных символов или 0 в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="13fd10e0aeee81890876e811b26e03b135d51ed9" translate="yes" xml:space="preserve">
          <source>Parses an unsigned integer starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. &lt;code&gt;ValueError&lt;/code&gt; is raised if the parsed integer is out of the valid range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541ca66d4dbc79404bc942d6bfb6c2be8439048d" translate="yes" xml:space="preserve">
          <source>Parses from a buffer &lt;em&gt;s&lt;/em&gt; into a &lt;em&gt;SexpNode&lt;/em&gt;.</source>
          <target state="translated">Разбирает из буфера &lt;em&gt;s&lt;/em&gt; в &lt;em&gt;SexpNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ce15ddb51f7707db52e2ae68e86add81e03689ed" translate="yes" xml:space="preserve">
          <source>Parses from a stream &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;JsonNodes&lt;/code&gt;. &lt;code&gt;filename&lt;/code&gt; is only needed for nice error messages. The JSON fragments are separated by whitespace. This can be substantially faster than the comparable loop &lt;code&gt;for x in splitWhitespace(s): yield parseJson(x)&lt;/code&gt;. This closes the stream &lt;code&gt;s&lt;/code&gt; after it's done. If &lt;code&gt;rawIntegers&lt;/code&gt; is true, integer literals will not be converted to a &lt;code&gt;JInt&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;. If &lt;code&gt;rawFloats&lt;/code&gt; is true, floating point literals will not be converted to a &lt;code&gt;JFloat&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a309dc0181d3f0cb9ac7df4853c24a9cc3a1bc" translate="yes" xml:space="preserve">
          <source>Parses from a stream &lt;code&gt;s&lt;/code&gt; into a &lt;code&gt;JsonNode&lt;/code&gt;. &lt;code&gt;filename&lt;/code&gt; is only needed for nice error messages. If &lt;code&gt;s&lt;/code&gt; contains extra data, it will raise &lt;code&gt;JsonParsingError&lt;/code&gt;. This closes the stream &lt;code&gt;s&lt;/code&gt; after it's done. If &lt;code&gt;rawIntegers&lt;/code&gt; is true, integer literals will not be converted to a &lt;code&gt;JInt&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;. If &lt;code&gt;rawFloats&lt;/code&gt; is true, floating point literals will not be converted to a &lt;code&gt;JFloat&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f09fb29abff457c84ba95e0bc8011331d06c2a" translate="yes" xml:space="preserve">
          <source>Parses from a stream &lt;em&gt;s&lt;/em&gt; into a &lt;em&gt;JsonNode&lt;/em&gt;. &lt;em&gt;filename&lt;/em&gt; is only needed for nice error messages. If &lt;em&gt;s&lt;/em&gt; contains extra data, it will raise &lt;em&gt;JsonParsingError&lt;/em&gt;.</source>
          <target state="translated">Разбирает из потока &lt;em&gt;s&lt;/em&gt; в &lt;em&gt;JsonNode&lt;/em&gt; . &lt;em&gt;filename&lt;/em&gt; нужен только для хороших сообщений об ошибках. Если &lt;em&gt;s&lt;/em&gt; содержит дополнительные данные, это вызовет &lt;em&gt;ошибку JsonParsingError&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c205fbee41ffe389bcaa089240a73bbb6a3cbbdc" translate="yes" xml:space="preserve">
          <source>Parses the HTML from stream &lt;code&gt;s&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7392bd1dfd3616a852a08b90df502af326331916" translate="yes" xml:space="preserve">
          <source>Parses the HTML from stream &lt;em&gt;s&lt;/em&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">Анализирует HTML из потока &lt;em&gt;s&lt;/em&gt; и возвращает &lt;code&gt;XmlNode&lt;/code&gt; . Все ошибки синтаксического анализа игнорируются.</target>
        </trans-unit>
        <trans-unit id="9d6b6e4325404bd4282ae6db6786d3c6cdde20d0" translate="yes" xml:space="preserve">
          <source>Parses the HTML from string &lt;code&gt;html&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">Анализирует HTML из строки &lt;code&gt;html&lt;/code&gt; и возвращает &lt;code&gt;XmlNode&lt;/code&gt; . Все ошибки синтаксического анализа игнорируются.</target>
        </trans-unit>
        <trans-unit id="1b291cc50ee23e8b1901cb7970d7d44a0a902e25" translate="yes" xml:space="preserve">
          <source>Parses the XML from stream &lt;code&gt;s&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are turned into an &lt;code&gt;XmlError&lt;/code&gt; exception.</source>
          <target state="translated">Анализирует XML из потока &lt;code&gt;s&lt;/code&gt; и возвращает &lt;code&gt;XmlNode&lt;/code&gt; . Все ошибки синтаксического анализа превращаются в исключение &lt;code&gt;XmlError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="377e589d2efc7bd7f0d783557a0305ff1980a8dc" translate="yes" xml:space="preserve">
          <source>Parses the XML from stream &lt;code&gt;s&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;code&gt;errors&lt;/code&gt; sequence.</source>
          <target state="translated">Анализирует XML из потока &lt;code&gt;s&lt;/code&gt; и возвращает &lt;code&gt;XmlNode&lt;/code&gt; . Каждая произошедшая ошибка синтаксического анализа добавляется в последовательность &lt;code&gt;errors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="693b35a301ba4a3e77a1617dfcdfe0c2eea41014" translate="yes" xml:space="preserve">
          <source>Parses the XML from stream &lt;em&gt;s&lt;/em&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;em&gt;errors&lt;/em&gt; sequence.</source>
          <target state="translated">Анализирует XML из потока &lt;em&gt;s&lt;/em&gt; и возвращает &lt;code&gt;XmlNode&lt;/code&gt; . Каждая произошедшая ошибка синтаксического анализа добавляется в последовательность &lt;em&gt;ошибок&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="000730be1a0f93678cf7000c57f6c22e66d7b0b4" translate="yes" xml:space="preserve">
          <source>Parses the XML from string &lt;code&gt;str&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are turned into an &lt;code&gt;XmlError&lt;/code&gt; exception.</source>
          <target state="translated">Анализирует XML из строки &lt;code&gt;str&lt;/code&gt; и возвращает &lt;code&gt;XmlNode&lt;/code&gt; . Все ошибки синтаксического анализа превращаются в исключение &lt;code&gt;XmlError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e94cd8428f25354a33870cff6f77b016ec0d7c9" translate="yes" xml:space="preserve">
          <source>Parses the next token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15086c718d34668e53394d9f878ee54b1f9d49b1" translate="yes" xml:space="preserve">
          <source>Parses the rest of the input stream held by the parser into a PNode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="e5e5e69e286e3687e8e65c82c15218f29cdccbe5" translate="yes" xml:space="preserve">
          <source>Parsing JSON</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f8861222174c27dc6101721594edce57bf1ada" translate="yes" xml:space="preserve">
          <source>Parsing a string into an AST which consists of &lt;code&gt;Peg&lt;/code&gt; nodes with the &lt;code&gt;peg&lt;/code&gt; proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d46a080325775ed12fd3ffd5aa0a8d40db7175c" translate="yes" xml:space="preserve">
          <source>Parsing a string into an AST which consists of &lt;em&gt;Peg&lt;/em&gt; nodes with the &lt;em&gt;peg&lt;/em&gt; proc.</source>
          <target state="translated">Разбор строки в AST, который состоит из узлов &lt;em&gt;Peg&lt;/em&gt; с процессом &lt;em&gt;привязки&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1213aa0c980986abc9cfe893f564f800d35d51" translate="yes" xml:space="preserve">
          <source>Parsing and Formatting Dates</source>
          <target state="translated">Даты парсинга и форматирования</target>
        </trans-unit>
        <trans-unit id="e8de9b67e60bfc9e5a53216bb30c98671e868ddb" translate="yes" xml:space="preserve">
          <source>Parsing idetools output</source>
          <target state="translated">Вывод иджетолов для парсинга</target>
        </trans-unit>
        <trans-unit id="1800737251d65799e8ed6a97afb24d8a2b9918ef" translate="yes" xml:space="preserve">
          <source>Parsing nimsuggest output</source>
          <target state="translated">Разобрать результаты анализа наименьших предполагаемых значений</target>
        </trans-unit>
        <trans-unit id="5a01db6f2d606f2a701b77fbab0924cc899be0e3" translate="yes" xml:space="preserve">
          <source>Part 2</source>
          <target state="translated">часть 2</target>
        </trans-unit>
        <trans-unit id="859cfaaaeaf6a8ced2a1b65b58557fb95d875c48" translate="yes" xml:space="preserve">
          <source>Part of a pattern that is in square brackets is called a &quot;character class&quot;. In a character class the only metacharacters are:</source>
          <target state="translated">Часть детали,заключенная в квадратные скобки,называется &quot;классом символов&quot;.В символьном классе находятся только мета-символы:</target>
        </trans-unit>
        <trans-unit id="9269695463c8a5faa720fae720afebc9f6ef9e73" translate="yes" xml:space="preserve">
          <source>Partial Output:</source>
          <target state="translated">Частичный выход:</target>
        </trans-unit>
        <trans-unit id="d9152c0a90009a287d69e549232b96c390e66d7e" translate="yes" xml:space="preserve">
          <source>Partial:</source>
          <target state="translated">Partial:</target>
        </trans-unit>
        <trans-unit id="d2ed3ad5db69194cd3d8766327afd474a9733e0f" translate="yes" xml:space="preserve">
          <source>Partially supported OS: Windows (only sockets and user events), Solaris (files, sockets, handles and user events). Android (files, sockets, handles and user events).</source>
          <target state="translated">Частично поддерживаемая ОС:Windows (только сокеты и пользовательские события),Solaris (файлы,сокеты,дескрипторы и пользовательские события).Android (файлы,сокеты,дескрипторы и пользовательские события).</target>
        </trans-unit>
        <trans-unit id="f8b3b0ce73b2c887fc04e170a70ba3e345ca3ea2" translate="yes" xml:space="preserve">
          <source>Partition variables into different graphs. Used for Nim's write tracking, borrow checking and also for the cursor inference. The algorithm is a reinvention / variation of Steensgaard's algorithm. The used data structure is &quot;union find&quot; with path compression.We perform two passes over the AST:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447a6d9d5a5bea5594901fb1228ca57d5eb5c3aa" translate="yes" xml:space="preserve">
          <source>Partitions:</source>
          <target state="translated">Partitions:</target>
        </trans-unit>
        <trans-unit id="8a171b6aa4025579258fcd2c8b48f01cfb4c51c1" translate="yes" xml:space="preserve">
          <source>Parts of the string that are enclosed in the curly braces are interpreted as Nim code, to escape an &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;}&lt;/code&gt; double it.</source>
          <target state="translated">Части строки, заключенные в фигурные скобки, интерпретируются как код Nim, чтобы избежать двойного символа &lt;code&gt;{&lt;/code&gt; или &lt;code&gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae5e4613a5a66f977a85dd0954ce24e4cb776f3b" translate="yes" xml:space="preserve">
          <source>Pass one (&lt;code&gt;computeLiveRanges&lt;/code&gt;): collect livetimes of local variables and whether they are potentially re-assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aca8fe67e97585de445057c4943ea7782cef87e" translate="yes" xml:space="preserve">
          <source>Pass the filename and an array of times to set the access and modification times respectively. If you pass nil as the array both attributes will be set to the current time.</source>
          <target state="translated">Передайте имя файла и массив времени для установки времени доступа и времени модификации соответственно.Если в качестве массива передать ноль,то оба атрибута будут установлены на текущее время.</target>
        </trans-unit>
        <trans-unit id="ce3232a33ee700938d89f8cd85b81c950620aef7" translate="yes" xml:space="preserve">
          <source>Pass two (&lt;code&gt;traverse&lt;/code&gt;): combine local variables to abstract &quot;graphs&quot;. Strict func checking: Ensure that graphs that are connected to const parameters are not mutated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c5b9444c85f22cfca7c6842fd1c77d3d446d19" translate="yes" xml:space="preserve">
          <source>PassC pragma</source>
          <target state="translated">Прагма PassC</target>
        </trans-unit>
        <trans-unit id="27478f48296583129eac069e5087f2d2b0da482f" translate="yes" xml:space="preserve">
          <source>PassL pragma</source>
          <target state="translated">Пассажирская прагма</target>
        </trans-unit>
        <trans-unit id="63887463770a134a992bce27e42d7f2d2c85fd99" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;typedesc&lt;/code&gt; almost identical, just with the differences that the macro is not instantiated generically. The type expression is simply passed as a &lt;code&gt;NimNode&lt;/code&gt; to the macro, like everything else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f9f364778543f2d3d56cfb6fbfab613d11d558c" translate="yes" xml:space="preserve">
          <source>Passing Channels Safely</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f8c2a994a126eaf7103a7c43409efdd75a983d" translate="yes" xml:space="preserve">
          <source>Passing a code block to a template</source>
          <target state="translated">Передача блока кода в шаблон</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="c05a7dde4e8ae01915e872a2ecdbb5cd167032f4" translate="yes" xml:space="preserve">
          <source>Path expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27560fcddb5cfbfe7af93f89dd7a53c8deb37a54" translate="yes" xml:space="preserve">
          <source>Path handling utilities for Nim. Strictly typed code in order to avoid the never ending time sink in getting path handling right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2643c3434dcb6df9c1e72e6681f1bedc8ada4a0" translate="yes" xml:space="preserve">
          <source>Path names are syntactically either Nim identifiers or string literals. If the path name is not a valid Nim identifier it needs to be a string literal:</source>
          <target state="translated">Имена путей синтаксически либо Nim идентификаторы,либо строковые литералы.Если имя пути не является допустимым Nim идентификатором,то это должен быть строковый литерал:</target>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="7b6c2f9c3abcefd6eb4c4d0a0b5007e45b97a311" translate="yes" xml:space="preserve">
          <source>Pattern operators</source>
          <target state="translated">Операторы моделирования</target>
        </trans-unit>
        <trans-unit id="b72a4aa7fcffcb55499f6f65d9d2148428770a18" translate="yes" xml:space="preserve">
          <source>Peeks a bool from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6a9eba2a7a8dfeec4fef0b5ee800ec7bce466c" translate="yes" xml:space="preserve">
          <source>Peeks a char from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred. Returns '\0' as an EOF marker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30991c6b5bff2936cbd0d88e8d9f4f17f645b52" translate="yes" xml:space="preserve">
          <source>Peeks a float32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ae27eff9b512d1dc5c6f48c66a3d7a3a0a266d" translate="yes" xml:space="preserve">
          <source>Peeks a float64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204f73ee7651322bcdfc2623d6c7a9dcb68585ef" translate="yes" xml:space="preserve">
          <source>Peeks a line from a stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82e5a058ac8dd2705ce01808437b2ad8b5084fa" translate="yes" xml:space="preserve">
          <source>Peeks a line from a stream &lt;em&gt;s&lt;/em&gt;. Note: This is not very efficient. Raises &lt;em&gt;EIO&lt;/em&gt; if an error occurred.</source>
          <target state="translated">Смотрит строку из потока &lt;em&gt;s&lt;/em&gt; . Примечание: это не очень эффективно. Повышает &lt;em&gt;EIO,&lt;/em&gt; если произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="c0f56bf840615055642d6528d6f868484cf2948c" translate="yes" xml:space="preserve">
          <source>Peeks a line of text from the stream &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;line&lt;/code&gt; must not be &lt;code&gt;nil&lt;/code&gt;! May throw an IO exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afacc1115ea965417732e73e255661db6f4983da" translate="yes" xml:space="preserve">
          <source>Peeks a string of length &lt;code&gt;length&lt;/code&gt; from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9414855f96734b147ad15c7dde82de48212d4b" translate="yes" xml:space="preserve">
          <source>Peeks an int16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296a55eb24e1b0188438c22d6c2625aee424270b" translate="yes" xml:space="preserve">
          <source>Peeks an int32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84da338eff9110ffe76ec04860083e3ad8d4fda0" translate="yes" xml:space="preserve">
          <source>Peeks an int64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a726c626471c71e2bea52828da149e79477e34db" translate="yes" xml:space="preserve">
          <source>Peeks an int8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37554e75d27de5e874212c2847da8d22976d57a3" translate="yes" xml:space="preserve">
          <source>Peeks an uint16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a11a5412c9e16f4d463046d5b50765daaf1c35b" translate="yes" xml:space="preserve">
          <source>Peeks an uint32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9288ec1fcb9b1804858ac1c31deefe90a164960" translate="yes" xml:space="preserve">
          <source>Peeks an uint64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3cd9c754a426dc765433ad7315ebfc501dfc7f" translate="yes" xml:space="preserve">
          <source>Peeks an uint8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d4c57147bf5dd3bbcaf7bdfd58b0b2226cf25d" translate="yes" xml:space="preserve">
          <source>Per convention, all strings are UTF-8 strings, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;, not the i-th &lt;em&gt;unichar&lt;/em&gt;. The iterator &lt;code&gt;runes&lt;/code&gt; from the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt; can be used for iteration over all Unicode characters.</source>
          <target state="translated">По соглашению все строки являются строками UTF-8, но это не является обязательным. Например, при чтении строк из двоичных файлов они представляют собой просто последовательность байтов. Операции индекса &lt;code&gt;s[i]&lt;/code&gt; означает , г-го &lt;em&gt;полукокс&lt;/em&gt; из &lt;code&gt;s&lt;/code&gt; , а не я-я &lt;em&gt;unichar&lt;/em&gt; . &lt;code&gt;runes&lt;/code&gt; итератора из &lt;a href=&quot;unicode&quot;&gt;модуля unicode&lt;/a&gt; могут использоваться для итерации по всем символам Unicode.</target>
        </trans-unit>
        <trans-unit id="ff72f9179ae9e4a2376a59a5c8d0eeb265a32c2e" translate="yes" xml:space="preserve">
          <source>Per default templates are &lt;span id=&quot;hygienic_2&quot;&gt;hygienic&lt;/span&gt;: Local identifiers declared in a template cannot be accessed in the instantiation context:</source>
          <target state="translated">По умолчанию шаблоны &lt;span id=&quot;hygienic_2&quot;&gt;гигиеничны&lt;/span&gt; : к локальным идентификаторам, объявленным в шаблоне, нельзя получить доступ в контексте создания экземпляра:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="231131ea1a3863240874952ad37cf345067f33f6" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;new(x)&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent a &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89cf973516a4a21e210bf15d9d57a4a7110ea58" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;newSeq(x, len)&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7013d1f7d9f5962bdcdf6809fa5ec60bd9876b80" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;setLen(x, x.len+1)&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3450f41878523c76e1512334d0b887875e232269" translate="yes" xml:space="preserve">
          <source>Performs a deep copy of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155215fde1aa26f3ee38c0933534e538b88f9ae9" translate="yes" xml:space="preserve">
          <source>Performs a deep copy of &lt;code&gt;y&lt;/code&gt; and copies it into &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cd9242728b5c1a926850fd325c67f2fc62426b" translate="yes" xml:space="preserve">
          <source>Performs a deep copy of &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">Выполняет глубокую копию &lt;em&gt;файла&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fcfc2453a55ae0dddd53cdf78d2032544f6ddc57" translate="yes" xml:space="preserve">
          <source>Performs a left rotation on a range of elements. If you want to rotate right, use a negative &lt;code&gt;dist&lt;/code&gt;. Specifically, &lt;code&gt;rotateLeft&lt;/code&gt; rotates the elements at &lt;code&gt;slice&lt;/code&gt; by &lt;code&gt;dist&lt;/code&gt; positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fc1469f461af1ae348df9943fa1632f7f69e69" translate="yes" xml:space="preserve">
          <source>Performs a left rotation on a range of elements. If you want to rotate right, use a negative &lt;code&gt;dist&lt;/code&gt;. Specifically, &lt;code&gt;rotateLeft&lt;/code&gt; rotates the elements at &lt;code&gt;slice&lt;/code&gt; by &lt;code&gt;dist&lt;/code&gt; positions. The element at index &lt;code&gt;slice.a + dist&lt;/code&gt; will be at index &lt;code&gt;slice.a&lt;/code&gt;. The element at index &lt;code&gt;slice.b&lt;/code&gt; will be at &lt;code&gt;slice.a + dist -1&lt;/code&gt;. The element at index &lt;code&gt;slice.a&lt;/code&gt; will be at &lt;code&gt;slice.b + 1 - dist&lt;/code&gt;. The element at index &lt;code&gt;slice.a + dist - 1&lt;/code&gt; will be at &lt;code&gt;slice.b&lt;/code&gt;.</source>
          <target state="translated">Выполняет левый поворот ряда элементов. Если вы хотите повернуть вправо, используйте отрицательное &lt;code&gt;dist&lt;/code&gt; . В частности, &lt;code&gt;rotateLeft&lt;/code&gt; вращает элементы в положениях &lt;code&gt;slice&lt;/code&gt; по &lt;code&gt;dist&lt;/code&gt; . Элемент с индексом &lt;code&gt;slice.a + dist&lt;/code&gt; будет с индексом &lt;code&gt;slice.a&lt;/code&gt; . Элемент с индексом &lt;code&gt;slice.b&lt;/code&gt; будет по адресу &lt;code&gt;slice.a + dist -1&lt;/code&gt; . Элемент с индексом &lt;code&gt;slice.a&lt;/code&gt; будет по адресу &lt;code&gt;slice.b + 1 - dist&lt;/code&gt; . Элемент с индексом &lt;code&gt;slice.a + dist - 1&lt;/code&gt; будет по адресу &lt;code&gt;slice.b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="547e7eb2c01a8b7516cb21056d0deeb73c558d11" translate="yes" xml:space="preserve">
          <source>PersistentNodeFlags:</source>
          <target state="translated">PersistentNodeFlags:</target>
        </trans-unit>
        <trans-unit id="fccc2964329a971b590ec4a8a9af70e6f9bbd4ae" translate="yes" xml:space="preserve">
          <source>Pins a thread to a &lt;span id=&quot;cpu_1&quot;&gt;CPU&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d668e43bf0a5743410bd7ab9e0edf6b66e6ccd9e" translate="yes" xml:space="preserve">
          <source>Pipe operator</source>
          <target state="translated">Трубный оператор</target>
        </trans-unit>
        <trans-unit id="1712134a62aaf8aeb730f1ebe5c06b3ad4796c1b" translate="yes" xml:space="preserve">
          <source>Platform specific file extension for executables. On Windows &lt;code&gt;[&quot;exe&quot;, &quot;cmd&quot;, &quot;bat&quot;]&lt;/code&gt;, on Posix &lt;code&gt;[&quot;&quot;]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9801141d70e8a14926ba6354cb8932aea11f6959" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;static T&lt;/code&gt; is just a syntactic convenience for the underlying generic type &lt;code&gt;static[T]&lt;/code&gt;. The type param can be omitted to obtain the type class of all constant expressions. A more specific type class can be created by instantiating &lt;code&gt;static&lt;/code&gt; with another type class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91502d9216b226c484d80d6fd0eebe1eb9ccca35" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;static T&lt;/code&gt; is just a syntactic convenience for the underlying generic type &lt;code&gt;static[T]&lt;/code&gt;. The type param can be omitted to obtain the type class of all values known at compile-time. A more specific type class can be created by instantiating &lt;code&gt;static&lt;/code&gt; with another type class.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;static T&lt;/code&gt; - это просто синтаксическое удобство для базового универсального типа &lt;code&gt;static[T]&lt;/code&gt; . Параметр типа можно не указывать, чтобы получить класс типа всех значений, известных во время компиляции. Более конкретный класс типа может быть создан путем создания экземпляра &lt;code&gt;static&lt;/code&gt; с другим классом типа.</target>
        </trans-unit>
        <trans-unit id="376e940c0f4ede252519f2b91f3c32d65164170e" translate="yes" xml:space="preserve">
          <source>Please note that Nim will treat the user-defined pointer-like types as proper alternatives to the built-in pointer types. That is, types such as &lt;code&gt;seq[AnnotatedPtr[T]]&lt;/code&gt; or &lt;code&gt;RingBuffer[AnnotatedPtr[T]]&lt;/code&gt; will also be considered covariant and you can create new pointer-like types by instantiating other user-defined pointer-like types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a448e8765ceed97b70d742a1fbff8cbe9813f8" translate="yes" xml:space="preserve">
          <source>Please note that Nim will treat the user-defined pointer-like types as proper alternatives to the built-in pointer types. That is, types such as &lt;em&gt;seq[AnnotatedPtr[T]]&lt;/em&gt; or &lt;em&gt;RingBuffer[AnnotatedPtr[T]]&lt;/em&gt; will also be considered covariant and you can create new pointer-like types by instantiating other user-defined pointer-like types.</source>
          <target state="translated">Обратите внимание, что Nim будет рассматривать определяемые пользователем типы, подобные указателям, как подходящую альтернативу встроенным типам указателей. То есть такие типы, как &lt;em&gt;seq [AnnotatedPtr [T]]&lt;/em&gt; или &lt;em&gt;RingBuffer [AnnotatedPtr [T]]&lt;/em&gt; также будут считаться ковариантными, и вы можете создавать новые типы, подобные указателям, создавая экземпляры других определяемых пользователем типов, подобных указателям.</target>
        </trans-unit>
        <trans-unit id="31de791033a98daa5433ce403ccf2d1db3a3ae55" translate="yes" xml:space="preserve">
          <source>Please note that generic concepts such as &lt;code&gt;Enumerable[T]&lt;/code&gt; can be matched against concrete types such as &lt;code&gt;string&lt;/code&gt;. Nim doesn't require the concept type to have the same number of parameters as the type being matched. If you wish to express a requirement towards the generic parameters of the matched type, you can use a type mapping operator such as &lt;code&gt;genericHead&lt;/code&gt; or &lt;code&gt;stripGenericParams&lt;/code&gt; within the body of the concept to obtain the uninstantiated version of the type, which you can then try to instantiate in any required way. For example, here is how one might define the classic &lt;code&gt;Functor&lt;/code&gt; concept from Haskell and then demonstrate that Nim's &lt;code&gt;Option[T]&lt;/code&gt; type is an instance of it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6121f8f77a7e5843548ab29d76b72f1fdf494af" translate="yes" xml:space="preserve">
          <source>Please note that generic concepts such as &lt;em&gt;Enumerable[T]&lt;/em&gt; can be matched against concrete types such as &lt;em&gt;string&lt;/em&gt;. Nim doesn't require the concept type to have the same number of parameters as the type being matched. If you wish to express a requirement towards the generic parameters of the matched type, you can use a type mapping operator such as &lt;em&gt;genericHead&lt;/em&gt; or &lt;em&gt;stripGenericParams&lt;/em&gt; within the body of the concept to obtain the uninstantiated version of the type, which you can then try to instantiate in any required way. For example, here is how one might define the classic &lt;em&gt;Functor&lt;/em&gt; concept from Haskell and then demonstrate that Nim's &lt;em&gt;Option[T]&lt;/em&gt; type is an instance of it:</source>
          <target state="translated">Обратите внимание, что общие концепции, такие как &lt;em&gt;Enumerable [T],&lt;/em&gt; могут быть сопоставлены с конкретными типами, такими как &lt;em&gt;строка&lt;/em&gt; . Nim не требует, чтобы у концептуального типа было такое же количество параметров, как у сопоставляемого типа. Если вы хотите выразить требование к универсальным параметрам сопоставленного типа, вы можете использовать оператор сопоставления типов, такой как &lt;em&gt;genericHead&lt;/em&gt; или &lt;em&gt;stripGenericParams&lt;/em&gt; в теле концепции, чтобы получить неустановленную версию типа, которую затем можно попытаться создать. любым необходимым способом. Например, вот как можно определить классическую концепцию &lt;em&gt;Functor&lt;/em&gt; из Haskell, а затем продемонстрировать, что тип &lt;em&gt;Option [T]&lt;/em&gt; Nim является ее экземпляром:</target>
        </trans-unit>
        <trans-unit id="f5ca38697a6a448107efa272f859558c7b3efed4" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;is&lt;/code&gt; operator allows one to easily verify the precise type signatures of the required operations, but since type inference and default parameters are still applied in the concept body, it's also possible to describe usage protocols that do not reveal implementation details.</source>
          <target state="translated">Обратите внимание, что оператор &lt;code&gt;is&lt;/code&gt; позволяет легко проверять точные сигнатуры типов требуемых операций, но, поскольку в теле концепции по-прежнему применяются параметры вывода типа и параметры по умолчанию, также можно описывать протоколы использования, которые не раскрывают детали реализации.</target>
        </trans-unit>
        <trans-unit id="84b24489b92fa55264426ed8af25adfd53357fe7" translate="yes" xml:space="preserve">
          <source>Please refer to &lt;a href=&quot;manual_experimental#parallel-amp-spawn&quot;&gt;the manual&lt;/a&gt; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57833aa974b0e7c9c5481b4733aa65f3e38c1c57" translate="yes" xml:space="preserve">
          <source>Plugin support for the Nim compiler. Right now plugins need to be built with the compiler only: plugins using DLLs or the FFI will not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc451d63fbb704536042da563053eb7ff831435" translate="yes" xml:space="preserve">
          <source>Plugin to transform an inline iterator into a data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aae53af150b3796d306eb4ef6355e27209ba89b" translate="yes" xml:space="preserve">
          <source>Plugin:</source>
          <target state="translated">Plugin:</target>
        </trans-unit>
        <trans-unit id="57941ad380b619af368380c59a568808bb67d5c6" translate="yes" xml:space="preserve">
          <source>Pointer dereference &lt;code&gt;e[]&lt;/code&gt; is a path expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e396fac5e10a7261ea311d079d21e12d48a8e32" translate="yes" xml:space="preserve">
          <source>Pop and return the current smallest value, and add the new item. This is more efficient than pop() followed by push(), and can be more appropriate when using a fixed-size heap. Note that the value returned may be larger than item! That constrains reasonable uses of this routine unless written as part of a conditional replacement:</source>
          <target state="translated">Откройте и верните текущее наименьшее значение,а также добавьте новый элемент.Это более эффективно,чем pop(),за которой следует push(),и может быть более уместно при использовании кучи фиксированного размера.Обратите внимание,что возвращаемое значение может быть больше элемента! Это ограничивает разумное использование этой рутины,если только она не написана как часть условной замены:</target>
        </trans-unit>
        <trans-unit id="7a35ff20b244cefddc1604b170c46f6cbce2de97" translate="yes" xml:space="preserve">
          <source>Pop the smallest item off the heap, maintaining the heap invariant.</source>
          <target state="translated">Спрячьте самый маленький предмет из кучи,поддерживая инвариант кучи.</target>
        </trans-unit>
        <trans-unit id="34e45af26b9cdfe158c5ff6d766e12ef85dbe2c8" translate="yes" xml:space="preserve">
          <source>Pops and returns the current smallest value, and add the new item. This is more efficient than pop() followed by push(), and can be more appropriate when using a fixed-size heap. Note that the value returned may be larger than item! That constrains reasonable uses of this routine unless written as part of a conditional replacement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb79c259d58f1d3802c82933611bcfb17f33f4a" translate="yes" xml:space="preserve">
          <source>Pops and returns the smallest item from &lt;code&gt;heap&lt;/code&gt;, maintaining the heap invariant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="62eb2d652c640374db70b913a59f5d9da34f44b1" translate="yes" xml:space="preserve">
          <source>Porting Nim to a new architecture is pretty easy, since C is the most portable programming language (within certain limits) and Nim generates C code, porting the code generator is not necessary.</source>
          <target state="translated">Перенос Nim на новую архитектуру довольно прост,так как C является наиболее переносимым языком программирования (в определенных пределах),а Nim генерирует C-код,перенос генератора кода не требуется.</target>
        </trans-unit>
        <trans-unit id="442a29f3c82b03d1fb72c4411cbd3b9a535b5dbf" translate="yes" xml:space="preserve">
          <source>Porting to new platforms</source>
          <target state="translated">Перенос на новые платформы</target>
        </trans-unit>
        <trans-unit id="96938ac778902dc9c8a77d5d10c75b74615cc812" translate="yes" xml:space="preserve">
          <source>Position relative to which seek should happen</source>
          <target state="translated">Положение,по отношению к которому поиск должен произойти</target>
        </trans-unit>
        <trans-unit id="72250df1b33b90f691fb1b3acc0b0e2ea24463ab" translate="yes" xml:space="preserve">
          <source>Position relative to which seek should happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c44413026c7a51d5c1001acf9afe19a2fa6a8a3" translate="yes" xml:space="preserve">
          <source>Possible modes of &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e892ba2967a8f941ba09b419a3743f5e7d66af16" translate="yes" xml:space="preserve">
          <source>Possible values: &lt;code&gt;&quot;i386&quot;&lt;/code&gt;, &lt;code&gt;&quot;alpha&quot;&lt;/code&gt;, &lt;code&gt;&quot;powerpc&quot;&lt;/code&gt;, &lt;code&gt;&quot;powerpc64&quot;&lt;/code&gt;, &lt;code&gt;&quot;powerpc64el&quot;&lt;/code&gt;, &lt;code&gt;&quot;sparc&quot;&lt;/code&gt;, &lt;code&gt;&quot;amd64&quot;&lt;/code&gt;, &lt;code&gt;&quot;mips&quot;&lt;/code&gt;, &lt;code&gt;&quot;mipsel&quot;&lt;/code&gt;, &lt;code&gt;&quot;arm&quot;&lt;/code&gt;, &lt;code&gt;&quot;arm64&quot;&lt;/code&gt;, &lt;code&gt;&quot;mips64&quot;&lt;/code&gt;, &lt;code&gt;&quot;mips64el&quot;&lt;/code&gt;, &lt;code&gt;&quot;riscv64&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa912531ccb34c0bee4edeab46a67bbbcf925be" translate="yes" xml:space="preserve">
          <source>Possible values: &lt;code&gt;&quot;windows&quot;&lt;/code&gt;, &lt;code&gt;&quot;macosx&quot;&lt;/code&gt;, &lt;code&gt;&quot;linux&quot;&lt;/code&gt;, &lt;code&gt;&quot;netbsd&quot;&lt;/code&gt;, &lt;code&gt;&quot;freebsd&quot;&lt;/code&gt;, &lt;code&gt;&quot;openbsd&quot;&lt;/code&gt;, &lt;code&gt;&quot;solaris&quot;&lt;/code&gt;, &lt;code&gt;&quot;aix&quot;&lt;/code&gt;, &lt;code&gt;&quot;haiku&quot;&lt;/code&gt;, &lt;code&gt;&quot;standalone&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f507f61c5144c40eeb0019cc1f801d64ef47b9b" translate="yes" xml:space="preserve">
          <source>Possibly volatile-qualified integer type of an object that can be accessed as an atomic entity, even in the presence of asynchronous interrupts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7350d4c47ea4aa0bc5e9515e97fb1d18e41403e7" translate="yes" xml:space="preserve">
          <source>Postfix operator call</source>
          <target state="translated">Вызов постфиксного оператора</target>
        </trans-unit>
        <trans-unit id="4f334f0326bbdb4bbc89a575b872446c3dde5a89" translate="yes" xml:space="preserve">
          <source>Powerful Metaprogramming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d857c4a3cba6bb11f909b140e46311890f7f21c4" translate="yes" xml:space="preserve">
          <source>Pragmas</source>
          <target state="translated">Pragmas</target>
        </trans-unit>
        <trans-unit id="5d8e7de7f25aa645cd3d52db842b4045251d9dd7" translate="yes" xml:space="preserve">
          <source>Pragmas are Nim's method to give the compiler additional information / commands without introducing a massive number of new keywords. Pragmas are processed on the fly during semantic checking. Pragmas are enclosed in the special &lt;code&gt;{.&lt;/code&gt; and &lt;code&gt;.}&lt;/code&gt; curly brackets. Pragmas are also often used as a first implementation to play with a language feature before a nicer syntax to access the feature becomes available.</source>
          <target state="translated">Прагмы - это метод Nim, позволяющий предоставить компилятору дополнительную информацию / команды без введения большого количества новых ключевых слов. Прагмы обрабатываются на лету во время семантической проверки. Прагмы заключены в специальный &lt;code&gt;{.&lt;/code&gt; и &lt;code&gt;.}&lt;/code&gt; фигурные скобки. Прагмы также часто используются в качестве первой реализации для игры с языковой функцией, прежде чем станет доступен более удобный синтаксис для доступа к этой функции.</target>
        </trans-unit>
        <trans-unit id="fe9ce5f74d6f359dacb6b5ff6609ec745d285ed1" translate="yes" xml:space="preserve">
          <source>Pragmas are Nim's method to give the compiler additional information/ commands without introducing a massive number of new keywords. Pragmas are enclosed in the special &lt;code&gt;{.&lt;/code&gt; and &lt;code&gt;.}&lt;/code&gt; curly dot brackets. This tutorial does not cover pragmas. See the &lt;a href=&quot;manual#pragmas&quot;&gt;manual&lt;/a&gt; or &lt;a href=&quot;nimc#additional-features&quot;&gt;user guide&lt;/a&gt; for a description of the available pragmas.</source>
          <target state="translated">Прагмы - это метод Nim, позволяющий предоставить компилятору дополнительную информацию / команды без введения большого количества новых ключевых слов. Прагмы заключены в специальный &lt;code&gt;{.&lt;/code&gt; и &lt;code&gt;.}&lt;/code&gt; фигурные скобки. В этом руководстве не рассматриваются прагмы. См. Описание доступных прагм в &lt;a href=&quot;manual#pragmas&quot;&gt;руководстве&lt;/a&gt; или &lt;a href=&quot;nimc#additional-features&quot;&gt;руководстве пользователя&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98fd755e5931021a9b89b9579124e072dc87d99f" translate="yes" xml:space="preserve">
          <source>Pre-defined floating point types</source>
          <target state="translated">Предварительно заданные типы с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="fb09faa048a039f6976971e21ef11f9d51c37b06" translate="yes" xml:space="preserve">
          <source>Pre-defined floating-point types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddce2e3fda9f6f78c28f745b41b5c1d94ce0affb" translate="yes" xml:space="preserve">
          <source>Pre-defined integer types</source>
          <target state="translated">Предопределенные целочисленные типы</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="e11b40e5dc046d6eacf2b9c0341a3b59b3ba5410" translate="yes" xml:space="preserve">
          <source>Precedence level</source>
          <target state="translated">Уровень приоритета</target>
        </trans-unit>
        <trans-unit id="39a03e2279ceac8cb327814928332264628e7b59" translate="yes" xml:space="preserve">
          <source>Predecessor of the value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="a0632aa9c12bfe3dcd3037995eb766aec389aa10" translate="yes" xml:space="preserve">
          <source>Predicates that share their name with a keyword have to be escaped with backticks. The &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; predicates refer not only to the matching AST, but also to every other bound parameter; syntactically they need to occur after the ordinary AST predicates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b360b99e5530a900c44998c81311dbde2b2172fa" translate="yes" xml:space="preserve">
          <source>Predicates that share their name with a keyword have to be escaped with backticks: `` &lt;em&gt;const&lt;/em&gt;&lt;code&gt;. The ``alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; predicates refer not only to the matching AST, but also to every other bound parameter; syntactically they need to occur after the ordinary AST predicates:</source>
          <target state="translated">Предикаты, имена которых совпадают с ключевым словом, должны быть экранированы обратными кавычками: `` &lt;em&gt;const &lt;/em&gt; &lt;code&gt;. The ``alias&lt;/code&gt; Предикаты alias и &lt;code&gt;noalias&lt;/code&gt; относятся не только к соответствующему AST, но и ко всем другим связанным параметрам; синтаксически они должны располагаться после обычных предикатов AST:</target>
        </trans-unit>
        <trans-unit id="2b151af2a194f19ff375b24827bd3223300579c0" translate="yes" xml:space="preserve">
          <source>Prefix operator call</source>
          <target state="translated">Вызов префикс-оператора</target>
        </trans-unit>
        <trans-unit id="fbd2682b135bba426260d1de577b0322c630062a" translate="yes" xml:space="preserve">
          <source>PrefixMatch:</source>
          <target state="translated">PrefixMatch:</target>
        </trans-unit>
        <trans-unit id="66495d0734591a26213f3a366af624feb0c83b41" translate="yes" xml:space="preserve">
          <source>Prepares a string for insertion into a XML document by escaping the XML special characters.</source>
          <target state="translated">Готовит строку для вставки в XML документ путем экранирования специальных символов XML.</target>
        </trans-unit>
        <trans-unit id="a3014e7add76fcb315acde9f61b5b3077efef0f3" translate="yes" xml:space="preserve">
          <source>Prepends (adds to the beginning) a node &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad5802802da4c948ba8d3d94e9f72f06ed26198" translate="yes" xml:space="preserve">
          <source>Prepends (adds to the beginning) a node to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6a5d3dfd1ec66e32e8f9e711f12608b4c8e461" translate="yes" xml:space="preserve">
          <source>Prepends (adds to the beginning) a value to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9650901619effd3019d005a7f0cabcb33160dd0" translate="yes" xml:space="preserve">
          <source>Prepends the element x to the beginning of the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db44386f03d5b854ad6dafaca1b1eeb202b32004" translate="yes" xml:space="preserve">
          <source>Prepends the element x to the beginning of the sequence. Requires copying of the sequence</source>
          <target state="translated">Приготовляет элемент х к началу последовательности.Требуется копирование последовательности</target>
        </trans-unit>
        <trans-unit id="e93c24da69c1700494f35fc0d6e60ad65139bd35" translate="yes" xml:space="preserve">
          <source>Preprocess table &lt;code&gt;a&lt;/code&gt; for &lt;code&gt;sub&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ecd31a75929e40768bb20c6e9a666bcfc1c0cf" translate="yes" xml:space="preserve">
          <source>Preprocess table &lt;em&gt;a&lt;/em&gt; for &lt;em&gt;sub&lt;/em&gt;.</source>
          <target state="translated">Таблица &lt;em&gt;предварительной&lt;/em&gt; обработки &lt;em&gt;a&lt;/em&gt; для &lt;em&gt;подп&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0ebd928fc5c21d8b23de923afa72f9b439e03d18" translate="yes" xml:space="preserve">
          <source>Preprocessor support</source>
          <target state="translated">Поддержка препроцессора</target>
        </trans-unit>
        <trans-unit id="78f94e0402b0663fec796a2cb153834ccd0300a2" translate="yes" xml:space="preserve">
          <source>Presumably this snippet of code could be used in a commercial software, reading a configuration file to display information about the person who bought the software. This external file would be generated by an online web shopping cart to be included along the program containing the license information:</source>
          <target state="translated">Предположительно,этот фрагмент кода может быть использован в коммерческом программном обеспечении,читая конфигурационный файл для отображения информации о человеке,купившем программное обеспечение.Этот внешний файл будет создан интернет-магазинной корзиной,которая будет включена в программу,содержащую лицензионную информацию:</target>
        </trans-unit>
        <trans-unit id="bbaacc193c8d2a284014a58127bf356addea8297" translate="yes" xml:space="preserve">
          <source>Print out the checkpoints encountered so far and quit if &lt;code&gt;abortOnError&lt;/code&gt; is true. Otherwise, erase the checkpoints and indicate the test has failed (change exit code and test status). This template is useful for debugging, but is otherwise mostly used internally. Example:</source>
          <target state="translated">Распечатайте обнаруженные контрольные точки и &lt;code&gt;abortOnError&lt;/code&gt; если abortOnError истинно. В противном случае сотрите контрольные точки и укажите, что тест не прошел (измените код выхода и статус теста). Этот шаблон полезен для отладки, но в остальном он в основном используется для внутренних целей. Пример:</target>
        </trans-unit>
        <trans-unit id="f51d4e0dcedaa3fc409bdb1e06a21dc4a5fd577e" translate="yes" xml:space="preserve">
          <source>Proc</source>
          <target state="translated">Proc</target>
        </trans-unit>
        <trans-unit id="eb113d7d8beac65e410d096bf62f5df0c3b28a3c" translate="yes" xml:space="preserve">
          <source>Procedural type</source>
          <target state="translated">процедурный тип</target>
        </trans-unit>
        <trans-unit id="9e7331be4f43593dd7df9b640d47a72f7445dbe7" translate="yes" xml:space="preserve">
          <source>Procedure calls of the form &lt;code&gt;p(X)&lt;/code&gt; are compile-time computable if &lt;code&gt;p&lt;/code&gt; is a proc without side-effects (see the &lt;a href=&quot;#pragmas-nosideeffect-pragma&quot;&gt;noSideEffect pragma&lt;/a&gt; for details) and if &lt;code&gt;X&lt;/code&gt; is a (possibly empty) list of compile-time computable arguments.</source>
          <target state="translated">Вызов процедур формы &lt;code&gt;p(X)&lt;/code&gt; вычислим во время компиляции, если &lt;code&gt;p&lt;/code&gt; - это процесс без побочных эффектов (подробности см. В &lt;a href=&quot;#pragmas-nosideeffect-pragma&quot;&gt;прагме noSideEffect&lt;/a&gt; ) и если &lt;code&gt;X&lt;/code&gt; - (возможно, пустой) список вычислимых аргументов во время компиляции.</target>
        </trans-unit>
        <trans-unit id="b8db867373f6b118d2afb0458feddadd86fe8e12" translate="yes" xml:space="preserve">
          <source>Procedure declaration</source>
          <target state="translated">Процедурная декларация</target>
        </trans-unit>
        <trans-unit id="d682fc9dab69c1d2daf94fe72d9c9c2027249415" translate="yes" xml:space="preserve">
          <source>Procedures</source>
          <target state="translated">Procedures</target>
        </trans-unit>
        <trans-unit id="c7e7f6611bf2da78f49f8e451d842d8bd7ab42ec" translate="yes" xml:space="preserve">
          <source>Procedures always use static dispatch. For dynamic dispatch replace the &lt;code&gt;proc&lt;/code&gt; keyword by &lt;code&gt;method&lt;/code&gt;:</source>
          <target state="translated">Процедуры всегда используют статическую отправку. Для динамической отправки замените ключевое слово &lt;code&gt;proc&lt;/code&gt; на &lt;code&gt;method&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f4c0de7b4c7726fec29f652686da73a3922e3fa" translate="yes" xml:space="preserve">
          <source>Procedures always use static dispatch. Methods use dynamic dispatch. For dynamic dispatch to work on an object it should be a reference type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad221890d30672f04664877c946ff70a32ff7b5" translate="yes" xml:space="preserve">
          <source>Procedures always use static dispatch. Multi-methods use dynamic dispatch. For dynamic dispatch to work on an object it should be a reference type as well.</source>
          <target state="translated">Процедуры всегда используют статическую диспетчеризацию.Мультиметоды используют динамическую диспетчерскую.Для работы динамической диспетчеризации на объекте она также должна быть эталонным типом.</target>
        </trans-unit>
        <trans-unit id="06fbd2dad7effcb2234aac62fd8428a3ba476436" translate="yes" xml:space="preserve">
          <source>Procedures can appear at the top level in a module as well as inside other scopes, in which case they are called nested procs. A nested proc can access local variables from its enclosing scope and if it does so it becomes a closure. Any captured variables are stored in a hidden additional argument to the closure (its environment) and they are accessed by reference by both the closure and its enclosing scope (i.e. any modifications made to them are visible in both places). The closure environment may be allocated on the heap or on the stack if the compiler determines that this would be safe.</source>
          <target state="translated">Процедуры могут появляться на верхнем уровне в модуле,а также внутри других диапазонов,в этом случае они называются вложенными проками.Вложенный proc может получить доступ к локальным переменным из своей области охвата,и если он это делает,то становится закрывающим.Любые захваченные переменные хранятся в скрытом дополнительном аргументе к закрытию (его окружении),и доступ к ним осуществляется по ссылке как со стороны закрывающей области видимости,так и со стороны закрывающей области видимости (т.е.любые изменения,внесенные в них,видны в обоих местах).Окружение закрытия может быть выделено на куче или на стеке,если компилятор определит,что это будет безопасно.</target>
        </trans-unit>
        <trans-unit id="e7841a99f25705b147bd34c0a1f7bb11c058cf2b" translate="yes" xml:space="preserve">
          <source>Procedures utilizing type classes in such a manner are considered to be &lt;span id=&quot;implicitly-generic_1&quot;&gt;implicitly generic&lt;/span&gt;. They will be instantiated once for each unique combination of param types used within the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d366db67df6a0b1e1efe0e08594bca71f8eee2" translate="yes" xml:space="preserve">
          <source>Procedures utilizing type classes in such manner are considered to be &lt;span id=&quot;implicitly-generic_1&quot;&gt;implicitly generic&lt;/span&gt;. They will be instantiated once for each unique combination of param types used within the program.</source>
          <target state="translated">Процедуры, использующие классы типов таким образом, считаются &lt;span id=&quot;implicitly-generic_1&quot;&gt;неявно общими&lt;/span&gt; . Они будут созданы один раз для каждой уникальной комбинации типов параметров, используемых в программе.</target>
        </trans-unit>
        <trans-unit id="77d887d3c4269645cbb00a3f203259c5546c162d" translate="yes" xml:space="preserve">
          <source>Process the closure of all inner procs in one pass and accumulate the environments. This is however not always possible.</source>
          <target state="translated">Обрабатывайте закрытие всех внутренних стоек за один проход и накапливайте окружающую среду.Однако это не всегда возможно.</target>
        </trans-unit>
        <trans-unit id="e63451d3cf90040c075dc1fe95aa1f7d7528c37f" translate="yes" xml:space="preserve">
          <source>Processing</source>
          <target state="translated">Processing</target>
        </trans-unit>
        <trans-unit id="9afbe384e2a83f2b02c509b5363d71ee79a38e3a" translate="yes" xml:space="preserve">
          <source>Procs</source>
          <target state="translated">Procs</target>
        </trans-unit>
        <trans-unit id="4311d5a41c23a4400f7edfce5e0b039536a0abc1" translate="yes" xml:space="preserve">
          <source>Procs as expressions can appear both as nested procs and inside top level executable code.</source>
          <target state="translated">Проки как выражения могут появляться как во вложенных проках,так и внутри исполняемого кода верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="3e4f503b0908900893c7de08f0c51457cc0dc892" translate="yes" xml:space="preserve">
          <source>Procs as expressions can appear both as nested procs and inside top-level executable code. The &lt;a href=&quot;sugar&quot;&gt;sugar&lt;/a&gt; module contains the &lt;code&gt;=&amp;gt;&lt;/code&gt; macro which enables a more succinct syntax for anonymous procedures resembling lambdas as they are in languages like JavaScript, C#, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1616e4bc1aa2bed912867d0902aca437b90990" translate="yes" xml:space="preserve">
          <source>Procs can also be treated as expressions, in which case it's allowed to omit the proc's name.</source>
          <target state="translated">Прокурор также может рассматриваться как выражение,в этом случае разрешается опускать имя прокурора.</target>
        </trans-unit>
        <trans-unit id="57362afa37cf6acde07ad138b615e180f8f62a5b" translate="yes" xml:space="preserve">
          <source>Procs featuring &lt;code&gt;type&lt;/code&gt; params are considered implicitly generic. They will be instantiated for each unique combination of supplied types and within the body of the proc, the name of each param will refer to the bound concrete type:</source>
          <target state="translated">Процедуры с параметрами &lt;code&gt;type&lt;/code&gt; считаются неявно общими. Они будут созданы для каждой уникальной комбинации предоставленных типов, и в теле процедуры имя каждого параметра будет относиться к связанному конкретному типу:</target>
        </trans-unit>
        <trans-unit id="d11e4ea5c4fc8b9c8ae45fea3562c69c5ec08ed3" translate="yes" xml:space="preserve">
          <source>Procs featuring &lt;code&gt;typedesc&lt;/code&gt; params are considered implicitly generic. They will be instantiated for each unique combination of supplied types and within the body of the proc, the name of each param will refer to the bound concrete type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6342d3bbf4c02568a11954f011158915db9e2356" translate="yes" xml:space="preserve">
          <source>Procs have been provided to calculate statistics on arrays and sequences.</source>
          <target state="translated">Для расчета статистики по массивам и последовательностям были предоставлены Procs.</target>
        </trans-unit>
        <trans-unit id="797173c091947a15389bb8674683086569e23428" translate="yes" xml:space="preserve">
          <source>Procs that take an &lt;code&gt;onProgressChanged&lt;/code&gt; callback will call this every &lt;code&gt;progressInterval&lt;/code&gt; milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdad80c260c1b79fcf7078364eee12ddb03d0dbf" translate="yes" xml:space="preserve">
          <source>Procs written with the implicitly generic style will often need to refer to the type parameters of the matched generic type. They can be easily accessed using the dot syntax:</source>
          <target state="translated">Продукты,написанные неявно дженериковым стилем,часто должны ссылаться на параметры типа соответствующего дженерикового типа.Они легко доступны с помощью синтаксиса точек:</target>
        </trans-unit>
        <trans-unit id="cd7ff859e3411fbc571ec4264667afa27e529104" translate="yes" xml:space="preserve">
          <source>Produce and emit the parser message &lt;code&gt;arg&lt;/code&gt; to output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417499a3e724b26a485073043202bc4249cbf19c" translate="yes" xml:space="preserve">
          <source>Produces a new boolean literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff054aee7691236a9993dec46a2130a988a71073" translate="yes" xml:space="preserve">
          <source>Produces a new call node. &lt;code&gt;theProc&lt;/code&gt; is the proc that is called with the arguments &lt;code&gt;args[0..]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622a3a47b2c474ef796d04d2baf1a3173889bd80" translate="yes" xml:space="preserve">
          <source>Produces a new character literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ae80c128f37c9e400ccceee66df439075090a4" translate="yes" xml:space="preserve">
          <source>Produces a new float literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddd5e7e89e83e960e4a8323a02eadefcf15728a" translate="yes" xml:space="preserve">
          <source>Produces a new integer literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a27d8b9701ccfc7b4ff722f94e7f83a25b94830" translate="yes" xml:space="preserve">
          <source>Produces a new node with children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b793100dbd4a4b12a262055c30b601dac0bcd2" translate="yes" xml:space="preserve">
          <source>Produces a new string literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973901b80807f5ff207e2042993c04bbe7029db8" translate="yes" xml:space="preserve">
          <source>Produces a new unsigned integer literal node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5dd73eabe0ceec3510ddd56cff50a79d0fd6a6" translate="yes" xml:space="preserve">
          <source>Produces an XML tree for:</source>
          <target state="translated">Производит дерево XML для:</target>
        </trans-unit>
        <trans-unit id="2fac879cf602e3396c116983a52de85ad6e251ad" translate="yes" xml:space="preserve">
          <source>Produces roughly this C code:</source>
          <target state="translated">Производит примерно этот код C:</target>
        </trans-unit>
        <trans-unit id="2659970d3474662f3ed922e19e08a245aa2fdc58" translate="yes" xml:space="preserve">
          <source>Produces the Cartesian product of the array. Warning: complexity may explode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960e8fddc698625d55770887235e931f448d8d54" translate="yes" xml:space="preserve">
          <source>Produces:</source>
          <target state="translated">Produces:</target>
        </trans-unit>
        <trans-unit id="2c32898c6bc516c95e3a09efcc75829d8ca400b4" translate="yes" xml:space="preserve">
          <source>ProfileData:</source>
          <target state="translated">ProfileData:</target>
        </trans-unit>
        <trans-unit id="f4cf552e1f1e8c0469d4436b64b404977bcf69c9" translate="yes" xml:space="preserve">
          <source>ProfileInfo:</source>
          <target state="translated">ProfileInfo:</target>
        </trans-unit>
        <trans-unit id="5869080be0ffd6203a367dfac147459656260124" translate="yes" xml:space="preserve">
          <source>Profiler:</source>
          <target state="translated">Profiler:</target>
        </trans-unit>
        <trans-unit id="a6d68bd4be10c0820c76fc8d06aecf226d4b6440" translate="yes" xml:space="preserve">
          <source>Program is executed.</source>
          <target state="translated">Программа выполнена.</target>
        </trans-unit>
        <trans-unit id="4f17a83cbcff788a0cad5a770a0848dad49ec175" translate="yes" xml:space="preserve">
          <source>Progress reporting</source>
          <target state="translated">Отчетность о проделанной работе</target>
        </trans-unit>
        <trans-unit id="1f2140e31dbd92836ebf9c2bfdffac3015b3027f" translate="yes" xml:space="preserve">
          <source>Project switch</source>
          <target state="translated">Коммутатор проекта</target>
        </trans-unit>
        <trans-unit id="760874ddf5afe0d82343947ffb16ccd1781c1d3b" translate="yes" xml:space="preserve">
          <source>Proper thunk generation is harder because the proc that is to wrap could stem from a complex expression:</source>
          <target state="translated">Правильное генерирование большого пальца труднее,потому что промежуток времени,который нужно обернуть,может вытекать из сложного выражения:</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="5e49b9bd99ab4bc355bcfd55bdeb30deaad41741" translate="yes" xml:space="preserve">
          <source>Protecting general locations</source>
          <target state="translated">Охрана мест общего пользования</target>
        </trans-unit>
        <trans-unit id="d8eec506723634351a9cba0d6d82397b9f72baf0" translate="yes" xml:space="preserve">
          <source>Protecting global variables</source>
          <target state="translated">Защита глобальных переменных</target>
        </trans-unit>
        <trans-unit id="157122474fc28e9dcab665a3696cb13a6fe9933e" translate="yes" xml:space="preserve">
          <source>Protocol version specifies the protocol to use. SSLv2, SSLv3, TLSv1 are available with the addition of &lt;code&gt;protSSLv23&lt;/code&gt; which allows for compatibility with all of them.</source>
          <target state="translated">Версия протокола определяет используемый протокол. SSLv2, SSLv3, TLSv1 доступны с добавлением &lt;code&gt;protSSLv23&lt;/code&gt; , что обеспечивает совместимость со всеми из них.</target>
        </trans-unit>
        <trans-unit id="e38d7d5b91755bfbdf05c15f5eb398d4e6becf82" translate="yes" xml:space="preserve">
          <source>Provide a restrictive API that can load/save the compiletime state to a file.</source>
          <target state="translated">Предоставьте ограничительный API,который может загружать/сохранять состояние компиляции в файл.</target>
        </trans-unit>
        <trans-unit id="7b940e771b06f772546586fc239edc7c0e4b029b" translate="yes" xml:space="preserve">
          <source>Provide spaces around binary operators if that enhances readability.</source>
          <target state="translated">Обеспечьте места вокруг двоичных операторов,если это повышает читабельность.</target>
        </trans-unit>
        <trans-unit id="021a736a22fb8ccb515c4ebdd3bd6f75f2aa9698" translate="yes" xml:space="preserve">
          <source>Provides access to the compiler's instantiation stack line information of a template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41454706f7a445dc20f892c59f0f20e55e32de2" translate="yes" xml:space="preserve">
          <source>Provides system information in a &lt;code&gt;Uname&lt;/code&gt; struct with sysname, nodename, release, version and machine attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cea344353e26ba6f1565ed661d94f610ce9e4f" translate="yes" xml:space="preserve">
          <source>Proxy</source>
          <target state="translated">Proxy</target>
        </trans-unit>
        <trans-unit id="8ec4b541fad1239b548ff32ef94487dec816b95b" translate="yes" xml:space="preserve">
          <source>Pseudo import/include paths</source>
          <target state="translated">Псевдо-импорт/включить пути</target>
        </trans-unit>
        <trans-unit id="e8905062c7f92650e2b49b14825d94b7e789608b" translate="yes" xml:space="preserve">
          <source>PtrLikeKinds:</source>
          <target state="translated">PtrLikeKinds:</target>
        </trans-unit>
        <trans-unit id="b3a030279e3be16bc447509ee9cb018fef87870e" translate="yes" xml:space="preserve">
          <source>Pull an identifier from prefix/postfix expressions</source>
          <target state="translated">Вытащить идентификатор из префиксных/постфиксных выражений</target>
        </trans-unit>
        <trans-unit id="ff5298d9926e7f25a3c4cd2c8956e4fd8ad809b8" translate="yes" xml:space="preserve">
          <source>Pull an identifier from prefix/postfix expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5ec8ce5c1cd610e2351c5a15b6b9c81346e199" translate="yes" xml:space="preserve">
          <source>Pure libraries</source>
          <target state="translated">Чистые библиотеки</target>
        </trans-unit>
        <trans-unit id="c6a218c1fffd61e7a4c8cd984b85f49ea6bce0e1" translate="yes" xml:space="preserve">
          <source>Pure libraries do not depend on any external &lt;code&gt;*.dll&lt;/code&gt; or &lt;code&gt;lib*.so&lt;/code&gt; binary while impure libraries do. A wrapper is an impure library that is a very low-level interface to a C library.</source>
          <target state="translated">Чистые библиотеки не зависят от каких-либо внешних двоичных &lt;code&gt;lib*.so&lt;/code&gt; &lt;code&gt;*.dll&lt;/code&gt; или lib * .so, в то время как нечистые библиотеки зависят . Обертка - это нечистая библиотека, которая представляет собой интерфейс очень низкого уровня для библиотеки C.</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="ab194e6c51955e3ece7467854fe421e48b6e4cf4" translate="yes" xml:space="preserve">
          <source>Push item onto heap, maintaining the heap invariant.</source>
          <target state="translated">Толкайте предмет в кучу,поддерживая инвариант кучу.</target>
        </trans-unit>
        <trans-unit id="de1a698df31e45a8f5f4c836ee77bd27a6716e91" translate="yes" xml:space="preserve">
          <source>Pushes &lt;code&gt;item&lt;/code&gt; onto heap, maintaining the heap invariant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03af26b6f966874b74a290186d326f05c96fece2" translate="yes" xml:space="preserve">
          <source>Put the SMTP connection in TLS (Transport Layer Security) mode. May fail with ReplyError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51a6bd4b9d6286ac6ae728ccaf7c792a9d75dc7" translate="yes" xml:space="preserve">
          <source>Puts a (key, value)-pair into &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfadf925b0a8b79995ad4896979cb346499bb036" translate="yes" xml:space="preserve">
          <source>Puts a new &lt;code&gt;(key, value)&lt;/code&gt; pair into &lt;code&gt;t&lt;/code&gt; even if &lt;code&gt;t[key]&lt;/code&gt; already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21951821226cf6b4fe9f15bee71bff72d85baae9" translate="yes" xml:space="preserve">
          <source>Quasi-quoting operator. Accepts an expression or a block and returns the AST that represents it. Within the quoted AST, you are able to interpolate NimNode expressions from the surrounding scope. If no operator is given, quoting is done using backticks. Otherwise, the given operator must be used as a prefix operator for any interpolated expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a39c27c6f3bf8974c957653b58c3fa5dc8ccf58c" translate="yes" xml:space="preserve">
          <source>Quasi-quoting operator. Accepts an expression or a block and returns the AST that represents it. Within the quoted AST, you are able to interpolate NimNode expressions from the surrounding scope. If no operator is given, quoting is done using backticks. Otherwise, the given operator must be used as a prefix operator for any interpolated expression. The original meaning of the interpolation operator may be obtained by escaping it (by prefixing it with itself): e.g. &lt;em&gt;@&lt;/em&gt; is escaped as &lt;em&gt;@@&lt;/em&gt;, &lt;em&gt;@@&lt;/em&gt; is escaped as &lt;em&gt;@@@&lt;/em&gt; and so on.</source>
          <target state="translated">Оператор квази-цитирования. Принимает выражение или блок и возвращает AST, который его представляет. В цитируемом AST вы можете интерполировать выражения NimNode из окружающей области видимости. Если оператор не указан, цитирование выполняется с помощью обратных кавычек. В противном случае данный оператор должен использоваться как префиксный оператор для любого интерполированного выражения. Исходное значение оператора интерполяции может быть получено путем экранирования его (путем добавления префикса к самому себе): например, &lt;em&gt;@&lt;/em&gt; экранируется как &lt;em&gt;@@&lt;/em&gt; , &lt;em&gt;@@&lt;/em&gt; экранируется как &lt;em&gt;@@@&lt;/em&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="a8d92791ed83ac521184aed4c28bfc51de528ba5" translate="yes" xml:space="preserve">
          <source>Quickly find the log base 2 of an integer. If &lt;code&gt;x&lt;/code&gt; is zero, when &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; is set, result is -1, otherwise result is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84df47161db68162cf2c1cf2df6862e32ae9b781" translate="yes" xml:space="preserve">
          <source>Quickly find the log base 2 of an integer. If &lt;em&gt;x&lt;/em&gt; is zero, when &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; is set, result is -1, otherwise result is undefined.</source>
          <target state="translated">Быстро найти логарифм по основанию 2 целого числа. Если &lt;em&gt;x&lt;/em&gt; равно нулю, когда установлено &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; , результат равен -1, иначе результат не определен.</target>
        </trans-unit>
        <trans-unit id="e155eddd124128a190616e7a186ae4d25f6a6ebc" translate="yes" xml:space="preserve">
          <source>QuitCalled</source>
          <target state="translated">QuitCalled</target>
        </trans-unit>
        <trans-unit id="707d835cf000590a6cbcdd3de8f6c5db75a32002" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to POSIX shell. Based on Python's &lt;code&gt;pipes.quote&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43a34ec7721112f13b97cfbb0d6e0a2ad3e3442" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to POSIX shell. Based on Python's pipes.quote</source>
          <target state="translated">Цитата &lt;code&gt;s&lt;/code&gt; , чтобы его можно было безопасно передать в оболочку POSIX. На основе Python pipe.quote</target>
        </trans-unit>
        <trans-unit id="ef5384530fb53a4b50a924b05202ea7f5c268758" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to Windows API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d08dfbd0710ec2fc6ea17808fda70dbf079d436" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to shell.</source>
          <target state="translated">Цитата &lt;code&gt;s&lt;/code&gt; , чтобы его можно было безопасно передать в оболочку.</target>
        </trans-unit>
        <trans-unit id="b5d45f4b8112546563b986e1d340a3de1ceef7ec" translate="yes" xml:space="preserve">
          <source>Quote s, so it can be safely passed to Windows API. Based on Python's subprocess.list2cmdline See &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt;</source>
          <target state="translated">Цитата s, чтобы его можно было безопасно передать в Windows API. На основе Python subprocess.list2cmdline См. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;Http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3a56dd5f4e333e6e2e0eafd9130d0884fa87aa3" translate="yes" xml:space="preserve">
          <source>RST Quick Reference</source>
          <target state="translated">RST Быстрая справка</target>
        </trans-unit>
        <trans-unit id="bcb0bbc7586f8b1cf1562ef98d5628eb03fc6223" translate="yes" xml:space="preserve">
          <source>Raise statement</source>
          <target state="translated">Заявление о повышении</target>
        </trans-unit>
        <trans-unit id="d96d8a1fbad05e28f48bbb7b60f4cc5f83489601" translate="yes" xml:space="preserve">
          <source>Raise the supported exceptions represented by &lt;code&gt;excepts&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728c44d434025a939b40fb468f6b464eb21b6d42" translate="yes" xml:space="preserve">
          <source>Raise the supported exceptions represented by &lt;em&gt;excepts&lt;/em&gt;.</source>
          <target state="translated">Поднимите поддерживаемые исключения, представленные &lt;em&gt;исключениями&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ec3240294db6590d6eb674eceefe2d3080c82d81" translate="yes" xml:space="preserve">
          <source>Raised by &lt;code&gt;0.0/0.0&lt;/code&gt;, for example.</source>
          <target state="translated">Например, повышение на &lt;code&gt;0.0/0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ad44127cead1a93b77e67eaafbb798c1b8d6a72" translate="yes" xml:space="preserve">
          <source>Raised by division by zero.</source>
          <target state="translated">Поднято на ноль.</target>
        </trans-unit>
        <trans-unit id="66d476b23e649e63bb348172beb74bbf37053e03" translate="yes" xml:space="preserve">
          <source>Raised by invalid operations according to IEEE.</source>
          <target state="translated">Воспитан в результате недействительных операций в соответствии с IEEE.</target>
        </trans-unit>
        <trans-unit id="0626d08315c63b21ae589949312963836c529522" translate="yes" xml:space="preserve">
          <source>Raised for inexact results.</source>
          <target state="translated">Воспитан для неточных результатов.</target>
        </trans-unit>
        <trans-unit id="99e5be4241e93c72cfe80efe56d3696ed1d11b32" translate="yes" xml:space="preserve">
          <source>Raised for invalid memory access errors</source>
          <target state="translated">Поднято на уровень ошибок доступа к памяти</target>
        </trans-unit>
        <trans-unit id="38c30cf567b7b9ee1eddd8acb70da472c0ad9270" translate="yes" xml:space="preserve">
          <source>Raised for overflows.</source>
          <target state="translated">Поднят на переполнение.</target>
        </trans-unit>
        <trans-unit id="dd2cdbc5b0a42dacf72096db49f963030ac2eaf1" translate="yes" xml:space="preserve">
          <source>Raised for runtime integer divide-by-zero errors.</source>
          <target state="translated">Поднимается на целочисленные ошибки деления на ноль во время выполнения.</target>
        </trans-unit>
        <trans-unit id="2c9304ac03b02da4616572280aa9bb8ab12791a0" translate="yes" xml:space="preserve">
          <source>Raised for runtime integer overflows.</source>
          <target state="translated">Повышен для целочисленных переполнений во время выполнения.</target>
        </trans-unit>
        <trans-unit id="32c28ea5c78055e8ea68515c83c3ba22b6953b99" translate="yes" xml:space="preserve">
          <source>Raised for string and object conversion errors.</source>
          <target state="translated">Повышен для ошибок преобразования строк и объектов.</target>
        </trans-unit>
        <trans-unit id="08c46d3ef782190797d8a4bd64e301f0fa063ecc" translate="yes" xml:space="preserve">
          <source>Raised for underflows.</source>
          <target state="translated">Поднят на дно.</target>
        </trans-unit>
        <trans-unit id="be95aced11bd594c29b8a4cd5b58705ab2fd7a7d" translate="yes" xml:space="preserve">
          <source>Raised for unsuccessful attempts to allocate memory.</source>
          <target state="translated">Воспитан за неудачные попытки выделения памяти.</target>
        </trans-unit>
        <trans-unit id="ec59fe758ecda80d7bef1c0104bc8498d5c4a618" translate="yes" xml:space="preserve">
          <source>Raised if a dynamic library could not be loaded.</source>
          <target state="translated">Поднята,если динамическая библиотека не может быть загружена.</target>
        </trans-unit>
        <trans-unit id="fe56f3d52954d21251fffdab96d048a6101b0e04" translate="yes" xml:space="preserve">
          <source>Raised if a key cannot be found in a table.</source>
          <target state="translated">Поднимается,если ключ не может быть найден в таблице.</target>
        </trans-unit>
        <trans-unit id="bbba70332d0c775286b48ce439b172d9ba242f8e" translate="yes" xml:space="preserve">
          <source>Raised if a range check error occurred.</source>
          <target state="translated">Повышен,если произошла ошибка проверки диапазона.</target>
        </trans-unit>
        <trans-unit id="650353b9e13b1678f3e0f946a77bce78b804cb35" translate="yes" xml:space="preserve">
          <source>Raised if a record field is not accessible because its dicriminant's value does not fit.</source>
          <target state="translated">Поднимается,если поле записи недоступно,потому что значение его дикриминанта не подходит.</target>
        </trans-unit>
        <trans-unit id="2fffcd1cf8b129cd2ba5e5e1a92281ab5c51b0fc" translate="yes" xml:space="preserve">
          <source>Raised if a record field is not accessible because its discriminant's value does not fit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad88cbc3b7ff45823f8340b1fcd5be1d429c6ad" translate="yes" xml:space="preserve">
          <source>Raised if a resource request could not be fulfilled.</source>
          <target state="translated">Поднимается,если запрос ресурса не может быть выполнен.</target>
        </trans-unit>
        <trans-unit id="cd11d72b167232b61b07884734877076a77cdc66" translate="yes" xml:space="preserve">
          <source>Raised if an IO &quot;end of file&quot; error occurred.</source>
          <target state="translated">Поднимается,если произошла ошибка ввода-вывода &quot;конец файла&quot;.</target>
        </trans-unit>
        <trans-unit id="68c91c46567b49ce511b6a68e91cd37c644d9b1b" translate="yes" xml:space="preserve">
          <source>Raised if an IO error occurred.</source>
          <target state="translated">Поднимается,если произошла ошибка ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="f68ad7db1fb95353786755c35e1d60aecfb00a29" translate="yes" xml:space="preserve">
          <source>Raised if an array index is out of bounds.</source>
          <target state="translated">Вырастает,если индекс массива выходит за рамки.</target>
        </trans-unit>
        <trans-unit id="d3ef858ef306b68c4f896a6d7c87ab203440961c" translate="yes" xml:space="preserve">
          <source>Raised if an object gets assigned to its parent's object.</source>
          <target state="translated">Выращивается,если объект присваивается его родительскому объекту.</target>
        </trans-unit>
        <trans-unit id="fdb573346d5de72dc1dc0894684d9b86b57d2d06" translate="yes" xml:space="preserve">
          <source>Raised if an object is converted to an incompatible object type. You can use &lt;code&gt;of&lt;/code&gt; operator to check if conversion will succeed.</source>
          <target state="translated">Возникает, если объект преобразован в несовместимый тип объекта. Вы можете использовать &lt;code&gt;of&lt;/code&gt; оператора , чтобы проверить , если преобразование будет успешным.</target>
        </trans-unit>
        <trans-unit id="da2633c286ea06df76a0438d7891623c292b571a" translate="yes" xml:space="preserve">
          <source>Raised if an operating system service failed.</source>
          <target state="translated">Повышается в случае сбоя в обслуживании операционной системы.</target>
        </trans-unit>
        <trans-unit id="028c1298a842b618b5e92022ea3c9cb7f8150b55" translate="yes" xml:space="preserve">
          <source>Raised if any kind of arithmetic error occurred.</source>
          <target state="translated">Поднимается,если произошла какая-либо арифметическая ошибка.</target>
        </trans-unit>
        <trans-unit id="b57acbd1eafc73247bdc8b7db4a7e36731116243" translate="yes" xml:space="preserve">
          <source>Raised if it is attempted to send a message to a dead thread.</source>
          <target state="translated">Поднимается,если пытается послать сообщение на мертвую нить.</target>
        </trans-unit>
        <trans-unit id="586536f2532bdba51684aaa2faaccf9a0ee3ad93" translate="yes" xml:space="preserve">
          <source>Raised if the hardware stack used for subroutine calls overflowed.</source>
          <target state="translated">Повышен в случае переполнения аппаратного стека,используемого для вызова подпрограмм.</target>
        </trans-unit>
        <trans-unit id="17261fb73363d2c277ed1529e2e101dd346435d0" translate="yes" xml:space="preserve">
          <source>Raised if there is no exception to reraise.</source>
          <target state="translated">Воспитан,если нет исключений для восстания.</target>
        </trans-unit>
        <trans-unit id="351c8bf075d81572768b1ca963b6bf3b6f76ed34" translate="yes" xml:space="preserve">
          <source>Raised on attempts to re-sink an already consumed &lt;code&gt;sink&lt;/code&gt; parameter.</source>
          <target state="translated">Возникает при попытках повторно погрузить уже использованный параметр &lt;code&gt;sink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3c39e104d96138eb3a3997e68ced83f3dee4e47" translate="yes" xml:space="preserve">
          <source>Raised on dereferences of &lt;code&gt;nil&lt;/code&gt; pointers.</source>
          <target state="translated">Возникает при разыменовании &lt;code&gt;nil&lt;/code&gt; указателей.</target>
        </trans-unit>
        <trans-unit id="32a2e38706f27d38537d5bf0c1530200f9030954" translate="yes" xml:space="preserve">
          <source>Raised when a tag is not properly closed</source>
          <target state="translated">Поднят,когда метка не закрыта должным образом</target>
        </trans-unit>
        <trans-unit id="42ca68196e5e694cdc0156d223a1ff6b17dcec98" translate="yes" xml:space="preserve">
          <source>Raised when an unexpected XML Parser event occurs</source>
          <target state="translated">Поднимается при неожиданном событии парсера XML.</target>
        </trans-unit>
        <trans-unit id="4d15913f72d2ca164e122d25060193477a26ffc0" translate="yes" xml:space="preserve">
          <source>Raised when assertion is proved wrong.</source>
          <target state="translated">Воспитан,когда доказано,что утверждение неверно.</target>
        </trans-unit>
        <trans-unit id="fdbcd933410345697cf76acdf9926620d94d3b8e" translate="yes" xml:space="preserve">
          <source>Raised when parsing a &lt;code&gt;TimeFormat&lt;/code&gt; string fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0c54a9ceebd56228f9e7a47a36cc438b296a4a" translate="yes" xml:space="preserve">
          <source>Raised when parsing input using a &lt;code&gt;TimeFormat&lt;/code&gt; fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94babf1279c76282aa7e3b74b85ba454ebe03766" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionDefect&lt;/code&gt; if specified &lt;code&gt;code&lt;/code&gt; does not raise the specified exception. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdd67ba0a2ee1b9a768b23962088796764a4478" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionDefect&lt;/code&gt; with &lt;code&gt;msg&lt;/code&gt; if &lt;code&gt;cond&lt;/code&gt; is false. Note that &lt;code&gt;AssertionDefect&lt;/code&gt; is hidden from the effect system, so it doesn't produce &lt;code&gt;{.raises: [AssertionDefect].}&lt;/code&gt;. This exception is only supposed to be caught by unit testing frameworks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91029130d53f12dffcfc80d43ea48134c5d69fcf" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionError&lt;/code&gt; if specified &lt;code&gt;code&lt;/code&gt; does not raise the specified exception. Example:</source>
          <target state="translated">Вызывает &lt;code&gt;AssertionError&lt;/code&gt; , если указанный &lt;code&gt;code&lt;/code&gt; не вызывает указанное исключение. Пример:</target>
        </trans-unit>
        <trans-unit id="567f8f001d78a8e744cdf6369fc805b49aa2b893" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionError&lt;/code&gt; with &lt;em&gt;msg&lt;/em&gt; if &lt;em&gt;cond&lt;/em&gt; is false. Note that &lt;code&gt;AssertionError&lt;/code&gt; is hidden from the effect system, so it doesn't produce &lt;code&gt;{.raises: [AssertionError].}&lt;/code&gt;. This exception is only supposed to be caught by unit testing frameworks.</source>
          <target state="translated">Вызывает ошибку &lt;code&gt;AssertionError&lt;/code&gt; с &lt;em&gt;сообщением,&lt;/em&gt; если &lt;em&gt;cond&lt;/em&gt; ложно. Обратите внимание, что &lt;code&gt;AssertionError&lt;/code&gt; скрыт от системы эффектов, поэтому он не создает &lt;code&gt;{.raises: [AssertionError].}&lt;/code&gt; . Это исключение должно быть обнаружено только фреймворками модульного тестирования.</target>
        </trans-unit>
        <trans-unit id="83faa64f0dc51236f90a868139ec38fb95462791" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;EDb&lt;/code&gt; if the connection could not be established.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66f8302c80cace007ec26b7dd8b0079cd5a50b0" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred. Returns '\0' as an EOF marker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6894f48a57ffed3e94bbf7818467bd56356354ec" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;OSError&lt;/code&gt; if any of the files does not exist or information about it can not be obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d275297cc16ea24212ee08bfe9169118ebac459" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;OSError&lt;/code&gt; in case of an error. Follows symlinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cc1c9996322f8cc38f559f2584b50f088e6996" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;ValueError&lt;/code&gt; for an invalid hex values. The comparison is case-insensitive.</source>
          <target state="translated">Вызывает &lt;code&gt;ValueError&lt;/code&gt; для недопустимого шестнадцатеричного значения. При сравнении регистр не учитывается.</target>
        </trans-unit>
        <trans-unit id="3b3e8ef72efa78e2c5caac2a7c250a94e659a2c7" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;ValueError&lt;/code&gt; for an invalid value in &lt;code&gt;s&lt;/code&gt;. The comparison is done in a style insensitive way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22f12804c795d88ca74f939ddf08aea8931971a" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;ValueError&lt;/code&gt; for an invalid value in &lt;em&gt;s&lt;/em&gt;. The comparison is done in a style insensitive way.</source>
          <target state="translated">Вызывает &lt;code&gt;ValueError&lt;/code&gt; для недопустимого значения в &lt;em&gt;s&lt;/em&gt; . Сравнение выполняется без учета стиля.</target>
        </trans-unit>
        <trans-unit id="2d4578456b5ba2f01543ab1822189b16a39fba87" translate="yes" xml:space="preserve">
          <source>Raises &lt;em&gt;EDb&lt;/em&gt; if the connection could not be established.</source>
          <target state="translated">Поднимает &lt;em&gt;EDb,&lt;/em&gt; если соединение не может быть установлено.</target>
        </trans-unit>
        <trans-unit id="09f056dbb100b1c839a4625115b8a60c96d1a0e6" translate="yes" xml:space="preserve">
          <source>Raises EInvalidValue in case of an error.</source>
          <target state="translated">Повышает EInvalidValue в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="e0bebaa2403bca683eb4d2b3f51753adb492d176" translate="yes" xml:space="preserve">
          <source>Raises EOS on error.</source>
          <target state="translated">Поднимает EOS на ошибку.</target>
        </trans-unit>
        <trans-unit id="3094065727173e7ff0610b2ec2f7fa1c58ae43f7" translate="yes" xml:space="preserve">
          <source>Raises KeyError if the set &lt;code&gt;s&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80f698527275363029eae2721df321a059387f0" translate="yes" xml:space="preserve">
          <source>Raises KeyError if the set &lt;em&gt;s&lt;/em&gt; is empty.</source>
          <target state="translated">Поднимает KeyError если множество &lt;em&gt;s&lt;/em&gt; пусто.</target>
        </trans-unit>
        <trans-unit id="dc121ba0d8a6bbb1d7c05a5c564231baa3ad236b" translate="yes" xml:space="preserve">
          <source>Raises OSError on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1994fdf951fcefef8875ee783032c923a838b8c1" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;DbError&lt;/code&gt; exception when failed to insert row. For Postgre this adds &lt;code&gt;RETURNING id&lt;/code&gt; to the query, so it only works if your primary key is named &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a13ee0841c3615288bf2501646fe81c56c819e" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;DbError&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bcb2956d86cad57b8ce1d8879b7ac38c45bebf8" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;ValueError&lt;/code&gt; exception if &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;contentType&lt;/code&gt; contain newline characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8600b37550ccb497a4af5ce01a4410e73d0d2b" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;ValueError&lt;/code&gt; if the parsing fails or the value is not a correctly formatted time.</source>
          <target state="translated">Вызывает &lt;code&gt;ValueError&lt;/code&gt; если синтаксический анализ завершается неудачно или значение не является правильно отформатированным временем.</target>
        </trans-unit>
        <trans-unit id="276b555f70ce184a6b1f8f69f1b6bd8354a1579b" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;ValueError&lt;/code&gt; if the response's &lt;code&gt;status&lt;/code&gt; does not have a corresponding &lt;code&gt;HttpCode&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;ValueError&lt;/code&gt; если ответ в &lt;code&gt;status&lt;/code&gt; не имеет соответствующего &lt;code&gt;HttpCode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="307a090405fae28bbe37ae495085d4fc3467fca3" translate="yes" xml:space="preserve">
          <source>Raises a new SSL error.</source>
          <target state="translated">Поднимает новую ошибку SSL.</target>
        </trans-unit>
        <trans-unit id="4058e50bf03acedae079d451577c7b21d4279856" translate="yes" xml:space="preserve">
          <source>Raises an &lt;a href=&quot;system#OSError&quot;&gt;OSError exception&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be1df9024700353ee279a033c20b43e611103d1" translate="yes" xml:space="preserve">
          <source>Raises an &lt;code&gt;[DbError]&lt;/code&gt; exception with ODBC error information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b8735df78acafac0305b07c45583c0f5e06188" translate="yes" xml:space="preserve">
          <source>Raises an &lt;em&gt;[DbError]&lt;/em&gt; exception with ODBC error information</source>
          <target state="translated">Вызывает &lt;em&gt;[DbError]&lt;/em&gt; исключение с информацией об ошибке ODBC</target>
        </trans-unit>
        <trans-unit id="172a8dadd8dd7c12c87a018821e520f360bdd00c" translate="yes" xml:space="preserve">
          <source>Raises an EOS error upon failure.</source>
          <target state="translated">Повышает ошибку EOS при отказе.</target>
        </trans-unit>
        <trans-unit id="524595e54374e963ef480df057abcc139126f7c3" translate="yes" xml:space="preserve">
          <source>Raises an IO exception in case of an error. It is an error if the current file position is not at the beginning of the file.</source>
          <target state="translated">Повышает исключение ввода-вывода в случае ошибки.Это ошибка,если текущая позиция файла не находится в начале файла.</target>
        </trans-unit>
        <trans-unit id="6ab99fafbb1c01fadc221231a21a65c013cfa660" translate="yes" xml:space="preserve">
          <source>Raises an OSError based on the error code returned by &lt;code&gt;SSLGetError&lt;/code&gt; (for SSL sockets) and &lt;code&gt;osLastError&lt;/code&gt; otherwise.</source>
          <target state="translated">Вызывает OSError на основе кода ошибки, возвращаемого &lt;code&gt;SSLGetError&lt;/code&gt; (для сокетов SSL), в противном случае - &lt;code&gt;osLastError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06bc197d01299cedae87da2f96f00c76ba39cb84" translate="yes" xml:space="preserve">
          <source>Raises an OSError based on the error code returned by &lt;code&gt;SSL_get_error&lt;/code&gt; (for SSL sockets) and &lt;code&gt;osLastError&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981040978083ddb6aedc722b391b33e2f5b4fa72" translate="yes" xml:space="preserve">
          <source>Raises an OSError error upon failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ebae0e4f71b7a4be2a66964668697eb30ea1dc" translate="yes" xml:space="preserve">
          <source>Raises exceptions for the status codes &lt;code&gt;4xx&lt;/code&gt; and &lt;code&gt;5xx&lt;/code&gt;</source>
          <target state="translated">Вызывает исключения для кодов состояния &lt;code&gt;4xx&lt;/code&gt; и &lt;code&gt;5xx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bbcfba3180974b175ec29f25aedc4af60fbde06f" translate="yes" xml:space="preserve">
          <source>Raises proper errors based on return values of &lt;code&gt;recv&lt;/code&gt; functions.</source>
          <target state="translated">Вызывает правильные ошибки на основе возвращаемых значений функций &lt;code&gt;recv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2208414278b65730f3d9e753c0bd6120a6090206" translate="yes" xml:space="preserve">
          <source>Raising an exception is done with the &lt;code&gt;raise&lt;/code&gt; statement:</source>
          <target state="translated">Вызов исключения выполняется с помощью оператора &lt;code&gt;raise&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d5fda95e3940bc09dc1ccc22666813c0b54f73d" translate="yes" xml:space="preserve">
          <source>Ranges</source>
          <target state="translated">Ranges</target>
        </trans-unit>
        <trans-unit id="39db0baa12271196bc8f4503eccfe33d8bedd2cf" translate="yes" xml:space="preserve">
          <source>Ranges occur in set constructors, case statement branches, or array slices. Internally, the node kind &lt;code&gt;nnkRange&lt;/code&gt; is used, but when constructing the AST, construction with &lt;code&gt;..&lt;/code&gt; as an infix operator should be used instead.</source>
          <target state="translated">Диапазоны встречаются в конструкторах множеств, ветвях оператора case или срезах массива. Внутри используется тип узла &lt;code&gt;nnkRange&lt;/code&gt; , но при построении AST вместо этого следует использовать конструкцию с &lt;code&gt;..&lt;/code&gt; в качестве инфиксного оператора.</target>
        </trans-unit>
        <trans-unit id="0a6d74fbec021ac49e6d5b9824dc9112431d3fb1" translate="yes" xml:space="preserve">
          <source>Rationale: Consistency with overloaded assignment or assignment-like operations, &lt;code&gt;a = b&lt;/code&gt; can be read as &lt;code&gt;performSomeCopy(a, b)&lt;/code&gt;.</source>
          <target state="translated">Обоснование: согласованность с перегруженными присваиваниями или операциями, подобными присваиванию, &lt;code&gt;a = b&lt;/code&gt; можно читать как &lt;code&gt;performSomeCopy(a, b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab08d8a4461364c6af80c6c7c98c0b2b7dab27a7" translate="yes" xml:space="preserve">
          <source>Rationale: This is far easier to implement than hypothetical alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9a4a772a88d49b6a63f78245488ac96b3f98ab" translate="yes" xml:space="preserve">
          <source>Raw string literals</source>
          <target state="translated">литералы в виде необработанных строк</target>
        </trans-unit>
        <trans-unit id="386ba29889d0288988970831100059ae32e75da0" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;size&lt;/code&gt; bytes from the specified file asynchronously starting at the current position of the file pointer.</source>
          <target state="translated">Чтение &lt;code&gt;size&lt;/code&gt; байтов из указанного файла асинхронно , начиная с текущей позиции указателя файла.</target>
        </trans-unit>
        <trans-unit id="7ae2849845c6540687653cb08ca1d61f314e6677" translate="yes" xml:space="preserve">
          <source>Read CGI data from a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9e33ecea7657999c83b3f119c92f8cdd6252a4" translate="yes" xml:space="preserve">
          <source>Read CGI data. If the client does not use a method listed in the &lt;code&gt;allowedMethods&lt;/code&gt; set, an &lt;code&gt;ECgi&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6837b052d9e0068e0b32c146cb0a7341a45c3d40" translate="yes" xml:space="preserve">
          <source>Read CGI data. If the client does not use a method listed in the &lt;em&gt;allowedMethods&lt;/em&gt; set, an &lt;em&gt;ECgi&lt;/em&gt; exception is raised.</source>
          <target state="translated">Чтение данных CGI. Если клиент не использует метод, указанный в наборе &lt;em&gt;allowedMethods&lt;/em&gt; , &lt;em&gt;возникает&lt;/em&gt; исключение &lt;em&gt;ECgi&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cec1fd33cb854b699cea99a9f755995756d5ee2f" translate="yes" xml:space="preserve">
          <source>Read a single character from the terminal, blocking until it is entered. The character is not printed to the terminal.</source>
          <target state="translated">Считайте с клеммы один символ,блокируя его до тех пор,пока он не будет введен.Символ не выводится на клемму.</target>
        </trans-unit>
        <trans-unit id="58a1329fd636aaedc19278e8f118476d716ed20a" translate="yes" xml:space="preserve">
          <source>Read file stream example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ae5075e8a76e1e3bf797c3ca0f0105038061c6" translate="yes" xml:space="preserve">
          <source>Read or write stream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88bf8c215b46559275a409fea6da7ac855220c7" translate="yes" xml:space="preserve">
          <source>Read the description of the &lt;a href=&quot;#newOSError,OSErrorCode,string&quot;&gt;newOSError proc&lt;/a&gt; to learn how the exception object is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1f949ee6094b79d43e6d504438e7f6f64c9ab8" translate="yes" xml:space="preserve">
          <source>Read this &lt;a href=&quot;apis&quot;&gt;document&lt;/a&gt; for a quick overview of the API design.</source>
          <target state="translated">Прочтите этот &lt;a href=&quot;apis&quot;&gt;документ,&lt;/a&gt; чтобы получить краткий обзор дизайна API.</target>
        </trans-unit>
        <trans-unit id="e12115c2336394c1a363bbc5f4d2a10707e72fdd" translate="yes" xml:space="preserve">
          <source>Read/Write tracking</source>
          <target state="translated">Отслеживание прочтения/записи</target>
        </trans-unit>
        <trans-unit id="7bad437b94c79808d48551fc7876a886aeec220d" translate="yes" xml:space="preserve">
          <source>Reading a configuration file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24620e210d243aab2166090142b8a7d92b8f8897" translate="yes" xml:space="preserve">
          <source>Reading a configuration file.</source>
          <target state="translated">Чтение файла конфигурации.</target>
        </trans-unit>
        <trans-unit id="7421207f915a61053be48ee1f81c1396400af83a" translate="yes" xml:space="preserve">
          <source>Reading values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5a5f0d0a31292a7e615d242d5373135350e488" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;buf&lt;/code&gt;, which must at least be of that size. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Считывает байты &lt;strong&gt;до &lt;/strong&gt; &lt;code&gt;size&lt;/code&gt; из &lt;code&gt;socket&lt;/code&gt; в &lt;code&gt;buf&lt;/code&gt; , который должен иметь как минимум этот размер. Возвращенное future будет завершено после того, как будут прочитаны все запрошенные данные, прочитана часть данных или сокет отключен, и в этом случае future завершится со значением &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e7c0e94dad43b7d156eb9468f3ce53d820c8c1b" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Считывает байты &lt;strong&gt;до &lt;/strong&gt; &lt;code&gt;size&lt;/code&gt; из &lt;code&gt;socket&lt;/code&gt; в &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33491ee917470d5dff9cb97340d439812d5536b8" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="translated">Читает &lt;strong&gt;до &lt;/strong&gt; &lt;code&gt;size&lt;/code&gt; байтов из &lt;code&gt;socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77c0df6a022c05feac3496fef62e568dec0833b2" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt;. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Читает &lt;strong&gt;до &lt;/strong&gt; &lt;code&gt;size&lt;/code&gt; байтов из &lt;code&gt;socket&lt;/code&gt; . Возвращенное future будет завершено после того, как будут прочитаны все запрошенные данные, прочитана часть данных или сокет отключен, и в этом случае future завершится со значением &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="978c556c2dd2a7521290801e2dc3c34fa4b57db4" translate="yes" xml:space="preserve">
          <source>Reads a &lt;em&gt;password&lt;/em&gt; from stdin without printing it. &lt;em&gt;password&lt;/em&gt; must not be &lt;code&gt;nil&lt;/code&gt;! Returns &lt;code&gt;false&lt;/code&gt; if the end of the file has been reached, &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">Читает &lt;em&gt;пароль&lt;/em&gt; со стандартного ввода без печати. &lt;em&gt;пароль&lt;/em&gt; не должен быть &lt;code&gt;nil&lt;/code&gt; ! Возвращает &lt;code&gt;false&lt;/code&gt; , если достигнут конец файла, в противном случае - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce48b1b4358052432406e956566fc0d7c5a91157" translate="yes" xml:space="preserve">
          <source>Reads a bool from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db9e9c7c5aa541797e5f1778ae04def378cc0ce" translate="yes" xml:space="preserve">
          <source>Reads a char from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444646cd8abc01e30ae794dcda8cbbdb2222593d" translate="yes" xml:space="preserve">
          <source>Reads a float32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d61cabb21cb1835fe80bb50992fd3d84a2ca59" translate="yes" xml:space="preserve">
          <source>Reads a float64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2d32cde52d11c29e47f77d0e5566b28e25896c" translate="yes" xml:space="preserve">
          <source>Reads a line from a stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c7c69f0a4086f87414fa84f0850e98e826f6a2" translate="yes" xml:space="preserve">
          <source>Reads a line from a stream &lt;em&gt;s&lt;/em&gt;. Note: This is not very efficient. Raises &lt;em&gt;EIO&lt;/em&gt; if an error occurred.</source>
          <target state="translated">Читает строку из потока &lt;em&gt;s&lt;/em&gt; . Примечание: это не очень эффективно. Повышает &lt;em&gt;EIO,&lt;/em&gt; если произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="603f08eff7888543b9965532d75111a52efffb42" translate="yes" xml:space="preserve">
          <source>Reads a line of data from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;resString&lt;/code&gt;.</source>
          <target state="translated">Считывает строку данных из &lt;code&gt;socket&lt;/code&gt; в &lt;code&gt;resString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f939728ad91b0c6736db56d252e3d56ef5aac62" translate="yes" xml:space="preserve">
          <source>Reads a line of data from &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="translated">Читает строку данных из &lt;code&gt;socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9683a6732a76c35b64fa9e3a0d7661b3a22d384" translate="yes" xml:space="preserve">
          <source>Reads a line of data from &lt;code&gt;socket&lt;/code&gt;. Returned future will complete once a full line is read or an error occurs.</source>
          <target state="translated">Читает строку данных из &lt;code&gt;socket&lt;/code&gt; . Возвращенное future будет завершено, когда будет прочитана вся строка или возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="3847b584349df73d4d611006c26414caaf93bd15" translate="yes" xml:space="preserve">
          <source>Reads a line of data from stdin - blocks until n or EOF which happens when stdin is closed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aecd3b8f1dea16d09efe88e1e8d84722091e2e7" translate="yes" xml:space="preserve">
          <source>Reads a line of text from the stream &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;line&lt;/code&gt; must not be &lt;code&gt;nil&lt;/code&gt;! May throw an IO exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512f7f707ed82b2a4fb989d157a70b5d69b30b07" translate="yes" xml:space="preserve">
          <source>Reads a password from stdin without printing it.</source>
          <target state="translated">Читает пароль из stdin без печати.</target>
        </trans-unit>
        <trans-unit id="3a565e53f76c99ac01c6e7755400b49c72fd17b5" translate="yes" xml:space="preserve">
          <source>Reads a single character from the stream &lt;code&gt;f&lt;/code&gt;. Should not be used in performance sensitive code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f82d6c2b3adf0dd37525a198d9bcda0bb8916c" translate="yes" xml:space="preserve">
          <source>Reads a single character from the stream &lt;em&gt;f&lt;/em&gt;. Should not be used in performance sensitive code.</source>
          <target state="translated">Читает один символ из потока &lt;em&gt;f&lt;/em&gt; . Не следует использовать в коде, чувствительном к производительности.</target>
        </trans-unit>
        <trans-unit id="4ad562c998d7d33d16f2d35016ec8f1190aaf424" translate="yes" xml:space="preserve">
          <source>Reads a single line from the specified file asynchronously.</source>
          <target state="translated">Читает одну строку из указанного файла асинхронно.</target>
        </trans-unit>
        <trans-unit id="e6392a2ce7ba8c43bede495139762911cf43dab7" translate="yes" xml:space="preserve">
          <source>Reads a string of length &lt;code&gt;length&lt;/code&gt; from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45c699410e48af3598ad0ffd48f49477789d869" translate="yes" xml:space="preserve">
          <source>Reads all available data.</source>
          <target state="translated">Читает все доступные данные.</target>
        </trans-unit>
        <trans-unit id="2fd12af609f6c0c44ecea736f73e6dced25a94f4" translate="yes" xml:space="preserve">
          <source>Reads all data from stdin - blocks until EOF which happens when stdin is closed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8cdad2cd8286acdfd0d66e63f133bab5192a3c" translate="yes" xml:space="preserve">
          <source>Reads all data from the specified file.</source>
          <target state="translated">Считывает все данные из указанного файла.</target>
        </trans-unit>
        <trans-unit id="607456770984494827062ec12a94f5f8805c30aa" translate="yes" xml:space="preserve">
          <source>Reads all data from the stream &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c0c9eac2fafeeecf77fef0fbd118a7d5fe097d" translate="yes" xml:space="preserve">
          <source>Reads all data from the stream &lt;em&gt;file&lt;/em&gt;.</source>
          <target state="translated">Читает все данные из &lt;em&gt;файла&lt;/em&gt; потока .</target>
        </trans-unit>
        <trans-unit id="a7a03269d18b195e925ad9c77002d605c67ad1ac" translate="yes" xml:space="preserve">
          <source>Reads an int16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da7f67b91586db02c5b853ed490a5b2b0ce65ac" translate="yes" xml:space="preserve">
          <source>Reads an int32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6198aa8906f011e979ffbd40950dff7b0b296ef" translate="yes" xml:space="preserve">
          <source>Reads an int64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71175b4a24a11e531a6e13b456559b45b07beffd" translate="yes" xml:space="preserve">
          <source>Reads an int8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4636e7a0ee095ed96e677e732b5563936ba23cd0" translate="yes" xml:space="preserve">
          <source>Reads an uint16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab8c1e7be4b6116cc56b4597be1df909a24bbb2" translate="yes" xml:space="preserve">
          <source>Reads an uint32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1ee6f7d57815e3a9aeeb3c2780f23d6024cab6" translate="yes" xml:space="preserve">
          <source>Reads an uint64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b50c7fc4493290e27785f0bddc497b8082c478" translate="yes" xml:space="preserve">
          <source>Reads an uint8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16aa2b06a9fd45fdc5177ba0791c46e2186fefff" translate="yes" xml:space="preserve">
          <source>Reads and decodes CGI data and yields the (name, value) pairs the data consists of.</source>
          <target state="translated">Считывает и декодирует данные CGI и выдает пары (имя,значение),из которых состоят данные.</target>
        </trans-unit>
        <trans-unit id="d02b91ef117c2e1852e6fa0ea5eaaaa055755450" translate="yes" xml:space="preserve">
          <source>Reads and decodes CGI data and yields the (name, value) pairs the data consists of. If the client does not use a method listed in the &lt;code&gt;allowedMethods&lt;/code&gt; set, an &lt;code&gt;ECgi&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f08e1736fd8ee6f6e4264f9ba880fc2692403ee" translate="yes" xml:space="preserve">
          <source>Reads and decodes CGI data and yields the (name, value) pairs the data consists of. If the client does not use a method listed in the &lt;em&gt;allowedMethods&lt;/em&gt; set, an &lt;em&gt;ECgi&lt;/em&gt; exception is raised.</source>
          <target state="translated">Считывает и декодирует данные CGI и выдает пары (имя, значение), из которых состоят данные. Если клиент не использует метод, указанный в наборе &lt;em&gt;allowedMethods&lt;/em&gt; , &lt;em&gt;возникает&lt;/em&gt; исключение &lt;em&gt;ECgi&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b51006412d40deb76f46a9f4cf49b32d91c5577f" translate="yes" xml:space="preserve">
          <source>Reads data and transforms it to a type &lt;code&gt;T&lt;/code&gt; (deserialization, unmarshalling).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd580d77db8229465ebeb4157251802035fe7ba1" translate="yes" xml:space="preserve">
          <source>Reads data from the specified future stream until it is completed. The data which is read is written to the file immediately and freed from memory.</source>
          <target state="translated">Читает данные из указанного будущего потока до тех пор,пока он не будет завершен.Считанные данные сразу же записываются в файл и освобождаются из памяти.</target>
        </trans-unit>
        <trans-unit id="6453f710c400a1bd3088d85ace46f2b0c556b4f3" translate="yes" xml:space="preserve">
          <source>Reads in a build-time define as a bool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595d56d3e18b21c18bca00840423ca2ea7fc2a5e" translate="yes" xml:space="preserve">
          <source>Reads in a build-time define as a string</source>
          <target state="translated">Читается во время сборки,определяется как строка</target>
        </trans-unit>
        <trans-unit id="e8adc86af0b87b9e44aebe3a30de9bd18fc60874" translate="yes" xml:space="preserve">
          <source>Reads in a build-time define as an integer</source>
          <target state="translated">Читается во времени сборки,определяется как целое число.</target>
        </trans-unit>
        <trans-unit id="4598472634a594f3ffeff8206db9ccc9d9d0f85d" translate="yes" xml:space="preserve">
          <source>Reads the first row and creates a look-up table for column numbers See also &lt;a href=&quot;#rowEntry.CsvParser.string&quot;&gt;rowEntry&lt;/a&gt;.</source>
          <target state="translated">Считывает первую строку и создает таблицу поиска для номеров столбцов. См. Также &lt;a href=&quot;#rowEntry.CsvParser.string&quot;&gt;rowEntry&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc93c75abc8e47d3649940dfe86c4205db62db9" translate="yes" xml:space="preserve">
          <source>Reads the first row and creates a look-up table for column numbers See also:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c75a689c79c66c1db3b8b33ba096a09aab5fb43" translate="yes" xml:space="preserve">
          <source>Reads the next row; if &lt;code&gt;columns&lt;/code&gt; &amp;gt; 0, it expects the row to have exactly this many columns. Returns false if the end of the file has been encountered else true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494c153aaf278be23e83188e46e8ae53c00137ae" translate="yes" xml:space="preserve">
          <source>Reads the response's body and caches it. The read is performed only once.</source>
          <target state="translated">Читает тело ответа и кэширует его.Чтение выполняется только один раз.</target>
        </trans-unit>
        <trans-unit id="c09ea5f583e17a92aa05d2a79d90d53798b88bd5" translate="yes" xml:space="preserve">
          <source>Realtime support</source>
          <target state="translated">Поддержка в режиме реального времени</target>
        </trans-unit>
        <trans-unit id="0a4f8939ec5010f9c8a6d335f9942ba0998f0630" translate="yes" xml:space="preserve">
          <source>Reborrows</source>
          <target state="translated">Reborrows</target>
        </trans-unit>
        <trans-unit id="4818f606d1ff08f9655a082b5139170b1f1676b8" translate="yes" xml:space="preserve">
          <source>Rebuilding the compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a26b1287f5ff59f6b29334f315518ff72b9960f" translate="yes" xml:space="preserve">
          <source>Receive a line of data from &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="translated">Получите строку данных из &lt;code&gt;socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45ba1787b19136d286049145b2a0b743a6c33a76" translate="yes" xml:space="preserve">
          <source>Receives a datagram data from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;buf&lt;/code&gt;, which must be at least of size &lt;code&gt;size&lt;/code&gt;, address of datagram's sender will be stored into &lt;code&gt;saddr&lt;/code&gt; and &lt;code&gt;saddrLen&lt;/code&gt;. Returned future will complete once one datagram has been received, and will return size of packet received.</source>
          <target state="translated">Получает данные дейтаграммы из &lt;code&gt;socket&lt;/code&gt; в &lt;code&gt;buf&lt;/code&gt; , который должен быть не меньше &lt;code&gt;size&lt;/code&gt; , адрес отправителя дейтаграммы будет сохранен в &lt;code&gt;saddr&lt;/code&gt; и &lt;code&gt;saddrLen&lt;/code&gt; . Возвращенное будущее завершится после получения одной дейтаграммы и вернет размер полученного пакета.</target>
        </trans-unit>
        <trans-unit id="08a1c7a9c8b11f0330e062d3a219827691a2ced9" translate="yes" xml:space="preserve">
          <source>Receives a datagram data from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;data&lt;/code&gt;, which must be at least of size &lt;code&gt;size&lt;/code&gt;. The address and port of datagram's sender will be stored into &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, respectively. Returned future will complete once one datagram has been received, and will return size of packet received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035642ed262c167867946bf47a15f8d3cd74423d" translate="yes" xml:space="preserve">
          <source>Receives a datagram data from &lt;code&gt;socket&lt;/code&gt;, which must be at least of size &lt;code&gt;size&lt;/code&gt;. Returned future will complete once one datagram has been received and will return tuple with: data of packet received; and address and port of datagram's sender.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cd4737c50ee8048cd8ba70ef02d69e328a1eaf" translate="yes" xml:space="preserve">
          <source>Receives a line of data from the socket connected to the SMTP server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e06d171d56b86b84dc6f8e208bc7ee0606c281" translate="yes" xml:space="preserve">
          <source>Receives a message from the channel &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc62c15428d535855ae8065d053fb9f3dae416a2" translate="yes" xml:space="preserve">
          <source>Receives data from &lt;code&gt;socket&lt;/code&gt;. This function should normally be used with connection-less sockets (UDP sockets).</source>
          <target state="translated">Получает данные из &lt;code&gt;socket&lt;/code&gt; . Эта функция обычно должна использоваться с сокетами без подключения (сокеты UDP).</target>
        </trans-unit>
        <trans-unit id="fde44220b1eb77eb349f04d90b283dec9ec8fc18" translate="yes" xml:space="preserve">
          <source>Receives data from a socket.</source>
          <target state="translated">Получает данные из розетки.</target>
        </trans-unit>
        <trans-unit id="38611008bdc8b293ba57958ff7e53cb4f0c593ef" translate="yes" xml:space="preserve">
          <source>Recursively clears all children of an XmlNode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cfde3be5404be7accf4a0a658b02ee7896180d" translate="yes" xml:space="preserve">
          <source>Recursively walks over the directory &lt;code&gt;dir&lt;/code&gt; and yields for each file or directory in &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a29f5764a54e8058c540d4730c0a945d240f1f8" translate="yes" xml:space="preserve">
          <source>Recursively walks over the directory &lt;em&gt;dir&lt;/em&gt; and yields for each file or directory in &lt;em&gt;dir&lt;/em&gt;. The full path for each file or directory is returned. &lt;strong&gt;Warning&lt;/strong&gt;: Modifying the directory structure while the iterator is traversing may result in undefined behavior!</source>
          <target state="translated">Рекурсивный подходит каталог &lt;em&gt;реж&lt;/em&gt; и выходов для каждого файла или каталога в &lt;em&gt;директории&lt;/em&gt; . Возвращается полный путь для каждого файла или каталога. &lt;strong&gt;Предупреждение&lt;/strong&gt; : изменение структуры каталогов во время обхода итератора может привести к неопределенному поведению!</target>
        </trans-unit>
        <trans-unit id="fcf937319f333e7df4ec12406025be63bde6549b" translate="yes" xml:space="preserve">
          <source>Redirects</source>
          <target state="translated">Redirects</target>
        </trans-unit>
        <trans-unit id="c20bb0f7c4d78b01fa838319a2981e9b417f1f05" translate="yes" xml:space="preserve">
          <source>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</source>
          <target state="translated">Перераспределение и использование в исходной и двоичной форме,с изменениями или без них,разрешается при соблюдении следующих условий:</target>
        </trans-unit>
        <trans-unit id="57ec4bae787e02e75ae9439f5fbfc851c887f70f" translate="yes" xml:space="preserve">
          <source>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</source>
          <target state="translated">Передачи в двоичной форме должны воспроизводить вышеуказанное уведомление об авторских правах,этот список условий и следующий отказ от ответственности в документации и/или других материалах,предоставляемых вместе с передачей.</target>
        </trans-unit>
        <trans-unit id="b7338b5245c44e48d0d288fd4ec6f22445873f8e" translate="yes" xml:space="preserve">
          <source>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</source>
          <target state="translated">При распространении исходных текстов должны сохраняться вышеуказанное уведомление об авторских правах,этот список условий и следующий отказ от ответственности.</target>
        </trans-unit>
        <trans-unit id="ded5e6e7aa2ed376f64f1a24730ee173d5155d3a" translate="yes" xml:space="preserve">
          <source>Reduce rational &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a93873a7ac8bb5a91e249745de2599e8d65fd26" translate="yes" xml:space="preserve">
          <source>Reduce rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">Уменьшить рациональный &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7693e4045bbbda8ba2d5c3ae273859b958bb1b40" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;a&lt;/code&gt; by &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259516f23573e881a917050af2115d65af6da166" translate="yes" xml:space="preserve">
          <source>Ref objects should be used whenever inheritance is used. It isn't strictly necessary, but with non-ref objects assignments such as &lt;code&gt;let person: Person = Student(id: 123)&lt;/code&gt; will truncate subclass fields.</source>
          <target state="translated">Объекты Ref следует использовать всякий раз, когда используется наследование. В этом нет строгой необходимости, но при назначении объектов без ссылки, например &lt;code&gt;let person: Person = Student(id: 123)&lt;/code&gt; будут обрезаться поля подкласса.</target>
        </trans-unit>
        <trans-unit id="6e957d91a2e6412d9c92ab3070be12e1aa4ce4ab" translate="yes" xml:space="preserve">
          <source>Ref version of &lt;a href=&quot;#CountTable&quot;&gt;CountTable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1e817109e090abbcfa757ded0f90d1a5753425" translate="yes" xml:space="preserve">
          <source>Ref version of &lt;a href=&quot;#OrderedTable&quot;&gt;OrderedTable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4ec7a15678a29e4afdf3478e19f787f13e2172" translate="yes" xml:space="preserve">
          <source>Ref version of &lt;a href=&quot;#Table&quot;&gt;Table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87798bcee18d1436b909618b352c96cf831e7971" translate="yes" xml:space="preserve">
          <source>RefC</source>
          <target state="translated">RefC</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="5af3748c63858d0b4874cf01bae4e3756fad9124" translate="yes" xml:space="preserve">
          <source>Reference Cycles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960faca00a2ea60fd367da06c6a9cf388e7dc545" translate="yes" xml:space="preserve">
          <source>Reference and pointer types</source>
          <target state="translated">Ссылочный и указательный типы</target>
        </trans-unit>
        <trans-unit id="5ac8f6bcbc2bb32b6f7eada152e718040b0ff894" translate="yes" xml:space="preserve">
          <source>Reference to &lt;code&gt;RootObj&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="170afdf8e2efc163d33d771c752badc8b632f258" translate="yes" xml:space="preserve">
          <source>References (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory (also called &lt;span id=&quot;aliasing_1&quot;&gt;aliasing&lt;/span&gt;).</source>
          <target state="translated">Ссылки (аналогичные указателям в других языках программирования) - это способ представить отношения &amp;laquo;многие к одному&amp;raquo;. Это означает, что разные ссылки могут указывать и изменять одно и то же место в памяти (также называемое &lt;span id=&quot;aliasing_1&quot;&gt;псевдонимом&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="02069e24e1a9efdb72de58330148c041dfc9b7b2" translate="yes" xml:space="preserve">
          <source>References (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory.</source>
          <target state="translated">Ссылки (аналогичные указателям на других языках программирования)-это способ введения многозначных отношений.Это означает,что различные ссылки могут указывать на одно и то же место в памяти и изменять его.</target>
        </trans-unit>
        <trans-unit id="21261db724edbd03f7602d59e2bb7a253492652e" translate="yes" xml:space="preserve">
          <source>Regarding binary comparison, this module only provides unequal operators. The equality operator &lt;code&gt;==&lt;/code&gt; is omitted, because depending on the use case either casting to float or rounding to int might be preferred, and users should make an explicit choice.</source>
          <target state="translated">Что касается двоичного сравнения, этот модуль предоставляет только неравные операторы. Оператор равенства &lt;code&gt;==&lt;/code&gt; опускается, потому что в зависимости от варианта использования может быть предпочтительнее приведение к типу float или округление до int, и пользователи должны сделать явный выбор.</target>
        </trans-unit>
        <trans-unit id="e68ebd1d4ba803b29c2b4073e01cb0c6ecc77d97" translate="yes" xml:space="preserve">
          <source>Registers 'foreignPackageName' to the internal list of foreign deps. It is your job to ensure the package name</source>
          <target state="translated">Зарегистрировать &quot;ForeignPackageName&quot; во внутреннем списке иностранных депо.Ваша работа заключается в том,чтобы гарантировать,что название пакета</target>
        </trans-unit>
        <trans-unit id="dba53deed8138d1e437d395564bccc72d2fe91e1" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;fd&lt;/code&gt; with the dispatcher.</source>
          <target state="translated">Регистрирует &lt;code&gt;fd&lt;/code&gt; в диспетчере.</target>
        </trans-unit>
        <trans-unit id="bb5bd595db3b7cfbb12cdce72914e82c34cdf5db" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;ftp&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Регистрирует &lt;code&gt;ftp&lt;/code&gt; в диспетчере &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbabe5b470b654e5897fc52c60eed8e57b18f5cc" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;s&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Регистрирует &lt;code&gt;s&lt;/code&gt; в диспетчере &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ac05ff3f5dcfa293b9d59ad4d7bb0664b1aef3f" translate="yes" xml:space="preserve">
          <source>Registers Unix signal notification with &lt;code&gt;signal&lt;/code&gt; to selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Регистрирует уведомление о &lt;code&gt;signal&lt;/code&gt; Unix с сигналом для селектора &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="800f133d28b9b2c3e359d4dbbeb9ddbccf642485" translate="yes" xml:space="preserve">
          <source>Registers a &lt;em&gt;thread local&lt;/em&gt; handler that is called at the thread's destruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac28cb53181efd36c017064827507024c32b8745" translate="yes" xml:space="preserve">
          <source>Registers a &lt;em&gt;thread local&lt;/em&gt; handler that is called at the thread's destruction. A thread is destructed when the &lt;code&gt;.thread&lt;/code&gt; proc returns normally or when it raises an exception. Note that unhandled exceptions in a thread nevertheless cause the whole process to die.</source>
          <target state="translated">Регистрирует &lt;em&gt;локальный&lt;/em&gt; обработчик &lt;em&gt;потока,&lt;/em&gt; который вызывается при уничтожении потока. &lt;code&gt;.thread&lt;/code&gt; разрушается, когда процедура .thread возвращается в обычном режиме или вызывает исключение. Обратите внимание, что необработанные исключения в потоке, тем не менее, приводят к смерти всего процесса.</target>
        </trans-unit>
        <trans-unit id="3deac7496ef34d80158290e83f7f14ef92d45c58" translate="yes" xml:space="preserve">
          <source>Registers a foreign command to the intern list of commands that can be queried later.</source>
          <target state="translated">Регистрирует иностранную команду в списке внутренних команд,которые могут быть опрашиваемы позже.</target>
        </trans-unit>
        <trans-unit id="f6b6982c4f6e50fc17a208315b2726e3bf92e0ac" translate="yes" xml:space="preserve">
          <source>Registers a process id (pid) notification (when process has exited) in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Регистрирует уведомление об идентификаторе процесса (pid) (когда процесс завершился) в селекторе &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e6ab3c2650ac19e734751307d1c267db478032" translate="yes" xml:space="preserve">
          <source>Registers async socket &lt;code&gt;sock&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Регистры асинхронной сокет &lt;code&gt;sock&lt;/code&gt; с диспетчером &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d5e51b21a074f3910595269ee7ab90c19c97cbb" translate="yes" xml:space="preserve">
          <source>Registers callback &lt;code&gt;cb&lt;/code&gt; to be called when &lt;code&gt;ev&lt;/code&gt; will be signaled</source>
          <target state="translated">Регистрирует callback &lt;code&gt;cb&lt;/code&gt; , который будет вызываться, когда &lt;code&gt;ev&lt;/code&gt; будет сигнализирован</target>
        </trans-unit>
        <trans-unit id="31450955f986e0842dc1c13efe0a244827237e9d" translate="yes" xml:space="preserve">
          <source>Registers callback &lt;code&gt;cb&lt;/code&gt; to be called when process with process ID &lt;code&gt;pid&lt;/code&gt; exited.</source>
          <target state="translated">Регистрирует callback &lt;code&gt;cb&lt;/code&gt; , который будет вызываться при выходе из процесса с идентификатором процесса &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6471db9bd2a705c0ad2173f10920c7b023bff08" translate="yes" xml:space="preserve">
          <source>Registers callback &lt;code&gt;cb&lt;/code&gt; to be called when timer expired.</source>
          <target state="translated">Регистрирует callback &lt;code&gt;cb&lt;/code&gt; , который будет вызываться по истечении таймера.</target>
        </trans-unit>
        <trans-unit id="337e6b2b0028085b3fcc713332555d1608d2e3ce" translate="yes" xml:space="preserve">
          <source>Registers delegate &lt;code&gt;deleg&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Регистрирует делегата- &lt;code&gt;deleg&lt;/code&gt; с помощью диспетчера &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0836d5ff61abf1d138e16122f0ec0c79c61d80e8" translate="yes" xml:space="preserve">
          <source>Registers file/socket descriptor &lt;code&gt;fd&lt;/code&gt; to selector &lt;code&gt;s&lt;/code&gt; with events set in &lt;code&gt;events&lt;/code&gt;. The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when an event is triggered.</source>
          <target state="translated">Регистры файл / дескриптор сокета &lt;code&gt;fd&lt;/code&gt; для Селектор &lt;code&gt;s&lt;/code&gt; событиями , установленными в &lt;code&gt;events&lt;/code&gt; . &lt;code&gt;data&lt;/code&gt; являются применение определенных данных, которые будут переданы , когда событие происходит.</target>
        </trans-unit>
        <trans-unit id="43e16ff873d5de584458f76ad72d9537d10683d7" translate="yes" xml:space="preserve">
          <source>Registers selector BSD/MacOSX specific vnode events for file descriptor &lt;code&gt;fd&lt;/code&gt; and events &lt;code&gt;events&lt;/code&gt;. &lt;code&gt;data&lt;/code&gt; application-defined data, which to be passed, when vnode event happens.</source>
          <target state="translated">Регистрирует события vnode селектора BSD / MacOSX для файлового дескриптора &lt;code&gt;fd&lt;/code&gt; и событий &lt;code&gt;events&lt;/code&gt; . &lt;code&gt;data&lt;/code&gt; данные, определяемые приложением, которые должны быть переданы при возникновении события vnode.</target>
        </trans-unit>
        <trans-unit id="2199311ef193878f7d6db4d7b746d800cbc0159f" translate="yes" xml:space="preserve">
          <source>Registers selector event &lt;code&gt;ev&lt;/code&gt; in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Регистрирует событие селектора &lt;code&gt;ev&lt;/code&gt; в селекторе &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b636a5c4fface43e127ecfee78ea1a0d490a11bb" translate="yes" xml:space="preserve">
          <source>Registers timer notification with &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) to selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Регистрирует уведомление таймера с &lt;code&gt;timeout&lt;/code&gt; (в миллисекундах) для селектора &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="136039c2b54f04914b3cfa5a13100aef989f0ca7" translate="yes" xml:space="preserve">
          <source>Regular expression support for Nim.</source>
          <target state="translated">Регулярная поддержка Ним.</target>
        </trans-unit>
        <trans-unit id="dc6d5a0c3dd27227e0ade1d680a1afafeb5cd176" translate="yes" xml:space="preserve">
          <source>Regular expression syntax and semantics</source>
          <target state="translated">Синтаксис и семантика регулярных выражений</target>
        </trans-unit>
        <trans-unit id="3172c4ae8fee97c04bb506eac2e6f47443f5a679" translate="yes" xml:space="preserve">
          <source>Regular expressions</source>
          <target state="translated">Регулярные выражения</target>
        </trans-unit>
        <trans-unit id="632284d6d44cd285a0879407d2b79c59fd92e9cc" translate="yes" xml:space="preserve">
          <source>Regular file.</source>
          <target state="translated">Обычная папка.</target>
        </trans-unit>
        <trans-unit id="c73e7346189862b7e0f60858180cc71c17d6472c" translate="yes" xml:space="preserve">
          <source>Related Options</source>
          <target state="translated">Связанные опции</target>
        </trans-unit>
        <trans-unit id="c87655c3652d2c8b712e2ae3b2ceb5122f8a4e27" translate="yes" xml:space="preserve">
          <source>Relative paths won't be expanded by this iterator. Instead, it will traverse only the directories appearing in the relative path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eeef2cf95f50c40792682050928f40e5526ea33" translate="yes" xml:space="preserve">
          <source>Relative paths won't be expanded by this proc. Instead, it will traverse only the directories appearing in the relative path.</source>
          <target state="translated">Относительные пути не будут расширены этим промежутком времени.Вместо этого,он будет пересекать только те каталоги,которые появляются в относительном пути.</target>
        </trans-unit>
        <trans-unit id="682eef8fa79929553cfba1c728611c096b679fb2" translate="yes" xml:space="preserve">
          <source>RelativeDir:</source>
          <target state="translated">RelativeDir:</target>
        </trans-unit>
        <trans-unit id="b960d2de95c213b0c091babc3388bfd26b6a65b1" translate="yes" xml:space="preserve">
          <source>RelativeFile:</source>
          <target state="translated">RelativeFile:</target>
        </trans-unit>
        <trans-unit id="7bbbb9e16a836cdff3a094ab77249ddd20e70760" translate="yes" xml:space="preserve">
          <source>Releases the given lock.</source>
          <target state="translated">Освобождает данный замок.</target>
        </trans-unit>
        <trans-unit id="154465987117610232e8996850d08335b4100707" translate="yes" xml:space="preserve">
          <source>Remove &lt;em&gt;fromFirst&lt;/em&gt; elements from the front of the deque and &lt;em&gt;fromLast&lt;/em&gt; elements from the back. If the supplied number of elements exceeds the total number of elements in the deque, the deque will remain empty.</source>
          <target state="translated">Удалите элементы &lt;em&gt;fromFirst&lt;/em&gt; с передней части &lt;em&gt;двухсторонней очереди и&lt;/em&gt; элементы &lt;em&gt;fromLast&lt;/em&gt; с задней стороны. Если предоставленное количество элементов превышает общее количество элементов в двухсторонней очереди, двухсторонняя очередь останется пустой.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
