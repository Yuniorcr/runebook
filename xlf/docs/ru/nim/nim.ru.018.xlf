<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="translated">Сборка проекта по умолчанию - это &lt;span id=&quot;debug-build_1&quot;&gt;отладочная сборка&lt;/span&gt; . Чтобы скомпилировать &lt;span id=&quot;release-build_1&quot;&gt;сборку выпуска,&lt;/span&gt; определите символ &lt;code&gt;release&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="translated">Соглашение о вызовах по умолчанию - &lt;code&gt;nimcall&lt;/code&gt; , если только это не внутренняя процедура (процедура внутри процедуры). Для внутреннего процесса выполняется анализ, получает ли он доступ к своей среде. Если это так, у него есть &lt;code&gt;closure&lt;/code&gt; соглашения о вызовах , в противном случае - соглашение о &lt;code&gt;nimcall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="translated">Компилятор по умолчанию определен в верхней части &lt;code&gt;config\nim.cfg&lt;/code&gt; . Изменение этого параметра влияет на компилятор, используемый &lt;code&gt;koch&lt;/code&gt; для (пере) сборки Nim.</target>
        </trans-unit>
        <trans-unit id="e96baa512c39f7d0782817e5f034412a054f571f" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;code&gt;trim=true&lt;/code&gt; and &lt;code&gt;precision=10&lt;/code&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">Конфигурация по умолчанию ( &lt;em&gt;trim = true&lt;/em&gt; и &lt;em&gt;precision = 10&lt;/em&gt; ) показывает самую &lt;strong&gt;короткую&lt;/strong&gt; форму, которая точно (максимум до 10 знаков после запятой) отображает значение. Например, 4.100000 будет отображаться как 4.1 (что математически идентично), тогда как 4.1000003 будет отображаться как 4.1000003.</target>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="translated">По умолчанию используется тип &lt;code&gt;float&lt;/code&gt; . В текущей реализации &lt;code&gt;float&lt;/code&gt; всегда 64-битный.</target>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="translated">Значение по умолчанию для символов сущностей &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; является &lt;code&gt;gensym&lt;/code&gt; и &lt;code&gt;proc&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; , &lt;code&gt;converter&lt;/code&gt; , &lt;code&gt;template&lt;/code&gt; , &lt;code&gt;macro&lt;/code&gt; является &lt;code&gt;inject&lt;/code&gt; . Однако, если имя объекта передается в качестве параметра шаблона, это введенный символ:</target>
        </trans-unit>
        <trans-unit id="33bc5ba68d5a4770f91c0f77bf490ba64a1ebdf4" translate="yes" xml:space="preserve">
          <source>The default format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="translated">Целочисленный тип по умолчанию - &lt;code&gt;int&lt;/code&gt; . Целочисленные литералы могут иметь &lt;em&gt;суффикс типа,&lt;/em&gt; чтобы указать целочисленный тип, &lt;em&gt;отличный&lt;/em&gt; от используемого по умолчанию:</target>
        </trans-unit>
        <trans-unit id="d7d511fa0f4131e89caffa53b1340e8da32540ee" translate="yes" xml:space="preserve">
          <source>The default is to write a stacktrace to &lt;code&gt;stderr&lt;/code&gt; and then call &lt;code&gt;quit(1)&lt;/code&gt;. Unstable API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de79cd39665eebcab7f9383b18124da290c9e6c" translate="yes" xml:space="preserve">
          <source>The default mode is case sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a938a7c0d5ddba81851d8d833ea57ac0a05a8458" translate="yes" xml:space="preserve">
          <source>The deprecated pragma is used to mark a symbol as deprecated:</source>
          <target state="translated">Устаревшая прагма используется для обозначения символа как устаревшего:</target>
        </trans-unit>
        <trans-unit id="762aa45b2aaec5e503b1dacdc6bb91a55cf5531c" translate="yes" xml:space="preserve">
          <source>The details of the inference algorithm are currently undocumented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e221c70b35d4c508839b98e3971cbeac27b698e" translate="yes" xml:space="preserve">
          <source>The detected command line token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86d1f1124b9d68611440bacc4bff7bcfe2f6e0a" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">Разница между 1.0 и наименьшим числом больше 1.0,которое может быть представлено в 32-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="afc1aa22832c69c45d0caa9362039ca2a87d5b07" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">Разница между 1.0 и наименьшим числом больше 1.0,которое может быть представлено в 64-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="8d3ea0a55b18000a3ec2d6587062c904d3e896cd" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is: &lt;code&gt;let&lt;/code&gt; introduces a variable that can not be re-assigned, &lt;code&gt;const&lt;/code&gt; means &quot;enforce compile time evaluation and put it into a data section&quot;:</source>
          <target state="translated">Разница между &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; заключается в следующем: &lt;code&gt;let&lt;/code&gt; вводит переменную, которую нельзя переназначить, &lt;code&gt;const&lt;/code&gt; означает &amp;laquo;принудительно выполнить оценку времени компиляции и поместить ее в раздел данных&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="0a74b6801170bf0f38a336281fab4bfa8303a82a" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and not members of &lt;em&gt;s2&lt;/em&gt;. Example:</source>
          <target state="translated">Разница между двумя наборами математически представлена ​​как &lt;em&gt;AB&lt;/em&gt; и представляет собой набор всех объектов, которые являются членами &lt;em&gt;s1,&lt;/em&gt; но не членами &lt;em&gt;s2&lt;/em&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="5d27f497247a1d668b9eedd90ebdd41b0705bd43" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A ∖ B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt; and not members of &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bfc8212e64434b0ef38e7d2b1ac70082312d54c" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,HashSet%5BA%5D,A&quot;&gt;excl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was missing from &lt;code&gt;s&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was in &lt;code&gt;s&lt;/code&gt; and it was removed during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37119833f19f914acaa770542dc626979be221e3" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,IntSet,int&quot;&gt;excl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was missing from &lt;code&gt;s&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was in &lt;code&gt;s&lt;/code&gt; and it was removed during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1b787f9dec43bac1fc4feaec6e737341d9ef05" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,OrderedSet%5BA%5D,A&quot;&gt;excl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was missing from &lt;code&gt;s&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was in &lt;code&gt;s&lt;/code&gt; and it was removed during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0c41b3f142cacbbcc66573b8adaf31d489334d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">Разница в отношении процедуры &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl ()&lt;/a&gt; заключается в том, что эта процедура возвращает &lt;em&gt;истину,&lt;/em&gt; если &lt;em&gt;ключ&lt;/em&gt; не указан в &lt;em&gt;s&lt;/em&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="d1de829e0ca997f038aa2fbccf312c02165e0cb7" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">Разница в отношении процедуры &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl ()&lt;/a&gt; заключается в том, что эта процедура возвращает &lt;em&gt;истину,&lt;/em&gt; если &lt;em&gt;ключ&lt;/em&gt; не указан в &lt;em&gt;s&lt;/em&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="a71957eb2547d4bfa9f2683522934ebe61aa6db3" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,HashSet%5BA%5D,A&quot;&gt;incl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; already contained &lt;code&gt;key&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was added as a new value to &lt;code&gt;s&lt;/code&gt; during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fff35f03a020121f5216e964c1f14d3d44390d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,IntSet,int&quot;&gt;incl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; already contained &lt;code&gt;key&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was added as a new value to &lt;code&gt;s&lt;/code&gt; during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773605a369d8054b7c253cee632444088b29e946" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,OrderedSet%5BA%5D,A&quot;&gt;incl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; already contained &lt;code&gt;key&lt;/code&gt;. The proc will return false if &lt;code&gt;key&lt;/code&gt; was added as a new value to &lt;code&gt;s&lt;/code&gt; during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b21997787778562d6aa4adbaf236a4acd894b9" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">Разница в отношении процедуры &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl ()&lt;/a&gt; заключается в том, что эта процедура возвращает &lt;em&gt;истину,&lt;/em&gt; если &lt;em&gt;ключ&lt;/em&gt; уже присутствует в &lt;em&gt;s&lt;/em&gt; . Процесс вернет false, если &lt;em&gt;ключ&lt;/em&gt; был добавлен как новое значение в &lt;em&gt;s&lt;/em&gt; во время этого вызова. Пример:</target>
        </trans-unit>
        <trans-unit id="9b85f52a313da4c653da005f49f49e563663ab9e" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">Разница в отношении процедуры &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl ()&lt;/a&gt; заключается в том, что эта процедура возвращает &lt;em&gt;истину,&lt;/em&gt; если &lt;em&gt;ключ&lt;/em&gt; уже присутствует в &lt;em&gt;s&lt;/em&gt; . Процесс вернет false, если &lt;em&gt;ключ&lt;/em&gt; был добавлен как новое значение в &lt;em&gt;s&lt;/em&gt; во время этого вызова. Пример:</target>
        </trans-unit>
        <trans-unit id="220030e8b435e84f93ba209fa1bb4177a255c969" translate="yes" xml:space="preserve">
          <source>The different format patterns that are supported are documented below.</source>
          <target state="translated">Ниже описаны поддерживаемые шаблоны различных форматов.</target>
        </trans-unit>
        <trans-unit id="d7d6c6dc11f53e07d9cdc8acaebc2671f78a141c" translate="yes" xml:space="preserve">
          <source>The direct embedding of assembler code into Nim code is supported by the unsafe &lt;code&gt;asm&lt;/code&gt; statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is &lt;code&gt;'`'&lt;/code&gt;:</source>
          <target state="translated">Прямое встраивание кода ассемблера в код Nim поддерживается оператором unsafe &lt;code&gt;asm&lt;/code&gt; . Идентификаторы в коде ассемблера, которые ссылаются на идентификаторы Nim, должны быть заключены в специальный символ, который может быть указан в прагмах оператора. Специальный символ по умолчанию - &lt;code&gt;'`'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c22272ea471a90f449580f65ef97314fc75ce82" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c14e4edc4e62d3b50ec111744e90c76fe6415b" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. It does &lt;strong&gt;not&lt;/strong&gt; fail if the directory already exists because for most usages this does not indicate an error.</source>
          <target state="translated">Каталог может содержать несколько подкаталогов, которые еще не существуют. Создан полный путь. Если это не удается, &lt;em&gt;возникает ошибка OSError&lt;/em&gt; . Это &lt;strong&gt;не&lt;/strong&gt; сработает, если каталог уже существует, потому что для большинства случаев использования это не указывает на ошибку.</target>
        </trans-unit>
        <trans-unit id="3d9c316616578336f1d520853682d58bf4e6eb88" translate="yes" xml:space="preserve">
          <source>The dispatcher acts as a kind of event loop. You must call &lt;code&gt;poll&lt;/code&gt; on it (or a function which does so for you such as &lt;code&gt;waitFor&lt;/code&gt; or &lt;code&gt;runForever&lt;/code&gt;) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.</source>
          <target state="translated">Диспетчер действует как своего рода цикл событий. Вы должны вызвать для него &lt;code&gt;poll&lt;/code&gt; (или функцию, которая делает это за вас, например, &lt;code&gt;waitFor&lt;/code&gt; или &lt;code&gt;runForever&lt;/code&gt; ), чтобы опросить любые невыполненные события. Базовая реализация основана на epoll в Linux, портах завершения ввода-вывода в Windows и некоторых других операционных системах.</target>
        </trans-unit>
        <trans-unit id="2fe9a5fd03163afe0a124e1e905c51d6abb0bdfb" translate="yes" xml:space="preserve">
          <source>The distance in amount of elements that the data should be rotated. Can be negative, can be any number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad786784a7a091bc39b8e45514e333722de53121" translate="yes" xml:space="preserve">
          <source>The documentation consists of several documents:</source>
          <target state="translated">Документация состоит из нескольких документов:</target>
        </trans-unit>
        <trans-unit id="160bf45ca85f5c6209e555ecebe6d41157683d3c" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation each runnableExample is put in its own file &lt;code&gt;$file_examples$i.nim&lt;/code&gt;, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37bdec1f204951850d37528255d2ee12a6d8560b" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation the examples are put into an &lt;code&gt;$file_example.nim&lt;/code&gt; file, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="translated">Генератор документации знает об этих примерах и считает их частью комментария &lt;code&gt;##&lt;/code&gt; doc. На последнем этапе создания документации примеры помещаются в файл &lt;code&gt;$file_example.nim&lt;/code&gt; , компилируются и тестируются. Собранные примеры помещаются в отдельный модуль, чтобы гарантировать, что примеры не относятся к неэкспортированным символам.</target>
        </trans-unit>
        <trans-unit id="1d6f51cc7af628cca8e6d65688dcf5a3aea1a258" translate="yes" xml:space="preserve">
          <source>The effect system (&lt;code&gt;raises: []&lt;/code&gt;) does not work with async procedures.</source>
          <target state="translated">Система эффектов ( &lt;code&gt;raises: []&lt;/code&gt; ) не работает с асинхронными процедурами.</target>
        </trans-unit>
        <trans-unit id="1bcfc8f90f78962fe572628e18093e7b6be852bf" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.a + dist - 1&lt;/code&gt; will be at &lt;code&gt;slice.b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897357254109912a2abd5ead8a14e0dc57992f7f" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.a + dist&lt;/code&gt; will be at index &lt;code&gt;slice.a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670537769ac6c87d8dae3f8f255038a616b07e05" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.a&lt;/code&gt; will be at &lt;code&gt;slice.b + 1 - dist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b68a5f4232d630fa057b4a20b989568ebd93ae53" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.b&lt;/code&gt; will be at &lt;code&gt;slice.a + dist -1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aded9e6b8b6079e27b489e1f2a3fd8422a03e391" translate="yes" xml:space="preserve">
          <source>The employed static analysis is limited and only concerned with local variables; however, object and tuple fields are treated as separate entities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c6ad0fa17f28cab354438579a552a5a86576fc" translate="yes" xml:space="preserve">
          <source>The empty &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; is a &lt;em&gt;do nothing&lt;/em&gt; statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">Пустой &lt;a href=&quot;#procedures-discard-statement&quot;&gt;оператор сброса&lt;/a&gt; - это оператор &lt;em&gt;ничего не делать&lt;/em&gt; . Компилятор знает, что оператор case с частью else не может дать сбой, и поэтому ошибка исчезает. Обратите внимание, что невозможно охватить все возможные строковые значения: поэтому для строковых случаев всегда нужна ветвь &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d537489684ccaa630656ec96401b6693a6022d" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;[]&lt;/code&gt; subscript notation can be used to &lt;em&gt;derefer&lt;/em&gt; a reference, meaning to retrieve the item the reference points to. The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">Нотация пустого индекса &lt;code&gt;[]&lt;/code&gt; может использоваться для &lt;em&gt;разыменования&lt;/em&gt; ссылки, то есть для извлечения элемента, на который указывает ссылка. Файл &lt;code&gt;.&lt;/code&gt; (доступ к оператору поля кортежа / объекта) и операторы &lt;code&gt;[]&lt;/code&gt; (оператор индекса массива / строки / последовательности) выполняют неявные операции разыменования для ссылочных типов:</target>
        </trans-unit>
        <trans-unit id="ffc8ff3a5600abff18d1541feff45aa3dbf706b3" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;except&lt;/code&gt; part is executed if there is an exception that is not explicitly listed. It is similar to an &lt;code&gt;else&lt;/code&gt; part in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">Пустая часть &lt;code&gt;except&lt;/code&gt; выполняется, если есть исключение, которое явно не указано. Это похоже на часть &lt;code&gt;else&lt;/code&gt; в операторах &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65c91587bac500ac8c7817439d895663e0f5eef7" translate="yes" xml:space="preserve">
          <source>The empty &lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt; clause is executed if there is an exception that is not listed otherwise. It is similar to an &lt;code&gt;else&lt;/code&gt; clause in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">Предложение пустое &lt;span id=&quot;except_1&quot;&gt;исключение&lt;/span&gt; выполняется, если есть исключение, которое не указано иначе. Это похоже на предложение &lt;code&gt;else&lt;/code&gt; в операторах &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c1d4d209aa8e17c99e2eb2160eabae179a2322b" translate="yes" xml:space="preserve">
          <source>The empty table can be written &lt;code&gt;{:}&lt;/code&gt; (in contrast to the empty set which is &lt;code&gt;{}&lt;/code&gt;) which is thus another way to write as the empty array constructor &lt;code&gt;[]&lt;/code&gt;. This slightly unusual way of supporting tables has lots of advantages:</source>
          <target state="translated">Пустая таблица может быть записана &lt;code&gt;{:}&lt;/code&gt; (в отличие от пустого набора, которым является &lt;code&gt;{}&lt;/code&gt; ), что, таким образом, является другим способом записи в качестве конструктора пустого массива &lt;code&gt;[]&lt;/code&gt; . Этот несколько необычный способ поддержки таблиц имеет ряд преимуществ:</target>
        </trans-unit>
        <trans-unit id="530e09898cb17b92f8f440dddf479da4d55cb727" translate="yes" xml:space="preserve">
          <source>The endianness of the target CPU. This is a valuable piece of information for low-level code only. This works thanks to compiler magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0113abbcfc987b657ff5c91825dbc9c2097913c" translate="yes" xml:space="preserve">
          <source>The error code can be retrieved using the &lt;a href=&quot;#osLastError&quot;&gt;osLastError proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a046b2305ba9ca93a6dc63513571f740cfbd0a" translate="yes" xml:space="preserve">
          <source>The error function</source>
          <target state="translated">Функция ошибки</target>
        </trans-unit>
        <trans-unit id="07d3a0d65c780c53b944c8f6088eecf4c5ac94f3" translate="yes" xml:space="preserve">
          <source>The example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.</source>
          <target state="translated">Пример также показывает,что тело proc может состоять из одного выражения,значение которого затем возвращается неявно.</target>
        </trans-unit>
        <trans-unit id="1ee7135c60a97c9109575a0365bdcd4548a56a80" translate="yes" xml:space="preserve">
          <source>The example is silly, since a vector is better modelled by a tuple which already provides &lt;code&gt;v[]&lt;/code&gt; access.</source>
          <target state="translated">Пример глупый, поскольку вектор лучше моделируется кортежем, который уже предоставляет доступ &lt;code&gt;v[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c91aee76f225823a200aa2713bba977502db3e5" translate="yes" xml:space="preserve">
          <source>The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of &lt;code&gt;add&lt;/code&gt; is used. The built-in &lt;code&gt;add&lt;/code&gt; procedure for sequences is not hidden and is used in the &lt;code&gt;preorder&lt;/code&gt; iterator.</source>
          <target state="translated">В примере показано общее двоичное дерево. В зависимости от контекста скобки используются либо для введения параметров типа, либо для создания экземпляра универсального процесса, итератора или типа. Как показывает пример, дженерики работают с перегрузкой: используется лучшее соответствие &lt;code&gt;add&lt;/code&gt; . Встроенная процедура &lt;code&gt;add&lt;/code&gt; последовательностей не скрывается и используется в итераторе &lt;code&gt;preorder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f68d69ad3fae0ae0b097e4eebbbc1987f9438cae" translate="yes" xml:space="preserve">
          <source>The example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).</source>
          <target state="translated">В примере используется временный цикл,чтобы продолжать запрашивать у пользователей их имена до тех пор,пока пользователь ничего не набирает (только нажимает RETURN).</target>
        </trans-unit>
        <trans-unit id="9e69f04e6b758773caa47fda144764cd2b769f26" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an &lt;code&gt;except&lt;/code&gt; part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">Исключение &lt;em&gt;используется&lt;/em&gt; в части &lt;code&gt;except&lt;/code&gt; . Если исключение не обрабатывается, оно распространяется через стек вызовов. Это означает, что часто остальная часть процедуры, не входящая в предложение &lt;code&gt;finally&lt;/code&gt; , не выполняется (если возникает исключение).</target>
        </trans-unit>
        <trans-unit id="ff3ed48d6f7129871b8222e272bcbad9f0531ac9" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">Исключение &lt;em&gt;обрабатывается&lt;/em&gt; обработчиком исключений. Однако обработчик исключений может вызвать другое исключение. Если исключение не обрабатывается, оно распространяется через стек вызовов. Это означает, что часто остальная часть процедуры, не входящая в предложение &lt;code&gt;finally&lt;/code&gt; , не выполняется (если возникает исключение).</target>
        </trans-unit>
        <trans-unit id="c1d798ae9282ab3c90cac1e64ce5600a12ced505" translate="yes" xml:space="preserve">
          <source>The exception tracking is part of Nim's &lt;span id=&quot;effect-system_1&quot;&gt;effect system&lt;/span&gt;. Raising an exception is an &lt;em&gt;effect&lt;/em&gt;. Other effects can also be defined. A user defined effect is a means to &lt;em&gt;tag&lt;/em&gt; a routine and to perform checks against this tag:</source>
          <target state="translated">Отслеживание исключений - часть системы &lt;span id=&quot;effect-system_1&quot;&gt;эффектов&lt;/span&gt; Нима . Возникновение исключения - это &lt;em&gt;эффект&lt;/em&gt; . Также можно определить другие эффекты. Определяемый пользователем эффект - это средство &lt;em&gt;пометить&lt;/em&gt; процедуру и выполнить проверки по этому тегу:</target>
        </trans-unit>
        <trans-unit id="f4d218a789a1df54f173c0ece34a43f3b86bc503" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are stricly speaking not catchable as they can also be mapped to an operation that terminates the whole process. Exceptions that indicate any other runtime error that can be caught inherit from &lt;code&gt;system.CatchableError&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;).</source>
          <target state="translated">Дерево исключений определяется в &lt;a href=&quot;system&quot;&gt;системном&lt;/a&gt; модуле. Каждое исключение наследуется от &lt;code&gt;system.Exception&lt;/code&gt; . Исключения, которые указывают на программные ошибки, наследуются от &lt;code&gt;system.Defect&lt;/code&gt; (который является подтипом &lt;code&gt;Exception&lt;/code&gt; ) и, строго говоря, не поддаются улавливанию, поскольку они также могут быть сопоставлены с операцией, завершающей весь процесс. Исключения, указывающие на любую другую ошибку времени выполнения, которая может быть обнаружена, наследуются от &lt;code&gt;system.CatchableError&lt;/code&gt; (который является подтипом &lt;code&gt;Exception&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f15c73f143df8ff81817805b3e6f84eb0426975c" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are strictly speaking not catchable as they can also be mapped to an operation that terminates the whole process. If panics are turned into exceptions, these exceptions inherit from &lt;code&gt;Defect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c146fcf11a72b2f53363e7dce3057eecf8d03ff2" translate="yes" xml:space="preserve">
          <source>The expected stdlib location is /usr/lib/nim</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca7c3dc848479331fda2f9d22be2cc3a93d781c" translate="yes" xml:space="preserve">
          <source>The experimental &lt;span id=&quot;nodestroy_1&quot;&gt;nodestroy&lt;/span&gt; pragma inhibits hook injections. This can be used to specialize the object traversal in order to avoid deep recursions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb9fe59b5acee224134869a4fa8ee343bb10bba" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;x.f&lt;/code&gt; needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to &lt;code&gt;f(x)&lt;/code&gt;. Therefore the dot syntax has some limitations when it is used to invoke templates/macros:</source>
          <target state="translated">Выражение &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;x.f&lt;/code&gt; необходимо семантически проверить (что означает поиск символов и проверку типа), прежде чем можно будет решить, что его нужно переписать в &lt;code&gt;f(x)&lt;/code&gt; . Поэтому точечный синтаксис имеет некоторые ограничения, когда он используется для вызова шаблонов / макросов:</target>
        </trans-unit>
        <trans-unit id="3c2dc4422e351229d30e8efd52e83f860015cd51" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;code&gt;#&lt;/code&gt; and whitespace are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1f3451fa30a273a7f6aed76323af4d8616546f" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;em&gt;#&lt;/em&gt; and whitespace are ignored.</source>
          <target state="translated">Расширенный означает, что комментарии, начинающиеся с символа &lt;em&gt;#&lt;/em&gt; и пробела, игнорируются.</target>
        </trans-unit>
        <trans-unit id="8c41536248444b965e36bdfac662bfb214beac07" translate="yes" xml:space="preserve">
          <source>The factory &lt;code&gt;proc&lt;/code&gt;, as an ordinary procedure, can be recursive. The above macro allows such recursion to look much like a recursive iterator would. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b4cab5727b122b7b1ec87cba8d2831f9aab5a6" translate="yes" xml:space="preserve">
          <source>The field identifiers inside a tuple or object definition are valid in the following places:</source>
          <target state="translated">Идентификаторы полей внутри кортежа или определения объектов действительны в следующих местах:</target>
        </trans-unit>
        <trans-unit id="dd916f7a49d8a7ac10551fea591882cb2dbe45da" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish another simple task: To determine all the links an HTML document contains.</source>
          <target state="translated">Файл &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; демонстрирует, как использовать синтаксический анализатор XML для выполнения другой простой задачи: определения всех ссылок, содержащихся в документе HTML.</target>
        </trans-unit>
        <trans-unit id="20888f5db03e3bbd07212160a3014e7495057d4b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish a simple task: To determine the title of an HTML document.</source>
          <target state="translated">Файл &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; демонстрирует, как использовать синтаксический анализатор XML для выполнения простой задачи: определить заголовок документа HTML.</target>
        </trans-unit>
        <trans-unit id="787b89eaa57a97560754c43aa4b06898c7b48aec" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &quot;&quot; for POSIX, &quot;bat&quot; on Windows.</source>
          <target state="translated">Расширение файла скрипта.Например:&quot;&quot; для POSIX,&quot;летучая мышь&quot; для Windows.</target>
        </trans-unit>
        <trans-unit id="bd4b48d3252daafd834db9d87104d9a48291a53c" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &lt;code&gt;&quot;&quot;&lt;/code&gt; for POSIX, &lt;code&gt;&quot;bat&quot;&lt;/code&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8875b78032e0936292139b8d9ad9a639776438c6" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &quot;&quot; for POSIX, &quot;exe&quot; on Windows.</source>
          <target state="translated">Файловое расширение нативных исполняемых файлов.Например:&quot;&quot; для POSIX,&quot;exe&quot; для Windows.</target>
        </trans-unit>
        <trans-unit id="3bcdd9264e0657c8e586f2111814ceedf968b16d" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &lt;code&gt;&quot;&quot;&lt;/code&gt; for POSIX, &lt;code&gt;&quot;exe&quot;&lt;/code&gt; on Windows (without a dot).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4d66cbed56a81621a70d0c80cfeafaeea567fd" translate="yes" xml:space="preserve">
          <source>The file handle associated with &lt;code&gt;f&lt;/code&gt; won't be inheritable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185628c3622bd8c0f63cb10b192be0d0211b8807" translate="yes" xml:space="preserve">
          <source>The file handle associated with the resulting &lt;code&gt;File&lt;/code&gt; is not inheritable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1522384259bb7f728de722e2a3a3b90755fa75" translate="yes" xml:space="preserve">
          <source>The file mode when opening a file.</source>
          <target state="translated">Режим работы с файлами при открытии файла.</target>
        </trans-unit>
        <trans-unit id="b0d5634247976656f5fce2a230b840835d3dfc38" translate="yes" xml:space="preserve">
          <source>The file you want to perform the query on. Usually you will pass in the same value as &lt;strong&gt;proj.nim&lt;/strong&gt;.</source>
          <target state="translated">Файл, по которому вы хотите выполнить запрос. Обычно вы передаете то же значение, что и &lt;strong&gt;proj.nim&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d49d4484596c8b0e0159eb69ef8f9c586d3b72f8" translate="yes" xml:space="preserve">
          <source>The filter transforms this into:</source>
          <target state="translated">Фильтр превращает это в:</target>
        </trans-unit>
        <trans-unit id="ca2479d6b8b610f51a5a98ec6a8fac67b9578c0a" translate="yes" xml:space="preserve">
          <source>The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.</source>
          <target state="translated">Последний слой-это асинхронная ожидающая трансформация.Это позволяет писать асинхронный код в синхронном стиле и работает аналогично ожиданию на C#.Преобразование работает путем преобразования любых асинхронных процедур в итератор.</target>
        </trans-unit>
        <trans-unit id="92e24af529f18eee0612283d52e69f9a932a8269" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files form &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="translated">Первая команда запускает компилятор Nim с тремя специальными параметрами, чтобы избежать генерации функции &lt;code&gt;main()&lt;/code&gt; в сгенерированных файлах, избежать связывания объектных файлов с конечным двоичным файлом и явно создать файл заголовка для интеграции C. Все сгенерированные файлы помещаются в каталог &lt;code&gt;nimcache&lt;/code&gt; . Вот почему следующая команда компилирует &lt;code&gt;maths.c&lt;/code&gt; код maths.c плюс все файлы &lt;code&gt;.c&lt;/code&gt; из &lt;code&gt;nimcache&lt;/code&gt; . В дополнение к этому пути вы также должны указать компилятору C, где найти &lt;code&gt;nimbase.h&lt;/code&gt; заголовка Nimbase.h от Nim .</target>
        </trans-unit>
        <trans-unit id="341e06b43aea4d82833edd740a767d94b3ccabcf" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files from &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1aabe2958ba075f566d5962b4d499e691da35a" translate="yes" xml:space="preserve">
          <source>The first line indicates the main project file.</source>
          <target state="translated">Первая строка указывает на основной файл проекта.</target>
        </trans-unit>
        <trans-unit id="1e2c5da607ae89a09ea180cc662ffe2d3288f940" translate="yes" xml:space="preserve">
          <source>The first one is to treat Android as a simple Linux and use &lt;a href=&quot;https://wiki.termux.com&quot;&gt;Termux&lt;/a&gt; to connect and run the Nim compiler directly on android as if it was Linux. These programs are console-only programs that can't be distributed in the Play Store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d583c04d3d5573e56b1c04f936fe5a844700a2bc" translate="yes" xml:space="preserve">
          <source>The first pass over the AST computes the lifetime of each local variable based on a notion of an &quot;abstract time&quot;, in the implementation it's a simple integer that is incremented for every visited node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070b4e293fffd6ce73b8fe7be23fcf1de6e8b78b" translate="yes" xml:space="preserve">
          <source>The first program</source>
          <target state="translated">Первая программа</target>
        </trans-unit>
        <trans-unit id="d0b3d98d639136123acdde78f568ba55378801a8" translate="yes" xml:space="preserve">
          <source>The first thing to note is that all callable types have at least a comma, even if they don't have any parameters. If there are parameters, they are represented by their types and will be comma separated. To the plain symbol a suffix may be added depending on the type of the callable:</source>
          <target state="translated">Первое,что следует отметить,это то,что все вызываемые типы имеют как минимум запятую,даже если у них нет никаких параметров.Если есть параметры,то они представлены своими типами и будут разделены запятыми.К обычному символу может быть добавлен суффикс в зависимости от типа вызываемого:</target>
        </trans-unit>
        <trans-unit id="4999312ef44c80455b502761b700c78c2fa7ee69" translate="yes" xml:space="preserve">
          <source>The first thing you will always need to do in order to start using sockets, is to create a new instance of the &lt;code&gt;Socket&lt;/code&gt; type using the &lt;code&gt;newSocket&lt;/code&gt; procedure.</source>
          <target state="translated">Первое, что вам всегда нужно делать, чтобы начать использовать сокеты, - это создать новый экземпляр типа &lt;code&gt;Socket&lt;/code&gt; с &lt;code&gt;newSocket&lt;/code&gt; процедуры newSocket .</target>
        </trans-unit>
        <trans-unit id="492b47655f6079de4ef1caff7c3c1bff381df22c" translate="yes" xml:space="preserve">
          <source>The first version uses &lt;em&gt;cmp&lt;/em&gt; to compare the elements. The expected return values are the same as that of system.cmp. The second version uses the default comparison function &lt;em&gt;cmp&lt;/em&gt;.</source>
          <target state="translated">Первая версия использует &lt;em&gt;cmp&lt;/em&gt; для сравнения элементов. Ожидаемые возвращаемые значения такие же, как у system.cmp. Вторая версия использует функцию сравнения по умолчанию &lt;em&gt;cmp&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f04db68a5b3cac0d3a181a32ee15094e36574928" translate="yes" xml:space="preserve">
          <source>The following Nim code:</source>
          <target state="translated">Следующий Ним-код:</target>
        </trans-unit>
        <trans-unit id="7ffd87a515c30c8b2fec87be6689a08608b581e5" translate="yes" xml:space="preserve">
          <source>The following algorithm (in pseudo-code) determines whether two types are equal with no respect to &lt;code&gt;distinct&lt;/code&gt; types. For brevity the cycle check with an auxiliary set &lt;code&gt;s&lt;/code&gt; is omitted:</source>
          <target state="translated">Следующий алгоритм (в псевдокоде) определяет, равны ли два типа без учета &lt;code&gt;distinct&lt;/code&gt; типов. Для краткости проверка цикла с вспомогательным набором &lt;code&gt;s&lt;/code&gt; опущена:</target>
        </trans-unit>
        <trans-unit id="2b6b9f3bad755134a23b880abde4691304772a2d" translate="yes" xml:space="preserve">
          <source>The following built-in procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6090c7cb57b21b2858f8d3bdfeddde8fc3e0c835" translate="yes" xml:space="preserve">
          <source>The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="translated">Следующие встроенные профили не могут быть перегружены по причинам простоты реализации (они требуют специализированной семантической проверки):</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">Следующий код:</target>
        </trans-unit>
        <trans-unit id="9e6abf51c6a7caaa00936172c084814413d0375a" translate="yes" xml:space="preserve">
          <source>The following dot operators are available:</source>
          <target state="translated">Доступны следующие точечные операторы:</target>
        </trans-unit>
        <trans-unit id="1f9399cc07df619ba3888f0184c84cb8878ae0a4" translate="yes" xml:space="preserve">
          <source>The following example below demonstrates this pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64478c18e3d0e98035bc04ab8a881a14b95dcc0f" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a simple chat server.</source>
          <target state="translated">Следующий пример демонстрирует простой чат-сервер.</target>
        </trans-unit>
        <trans-unit id="0f231e3e3462123dc4c8a24dcb21c49c8592a8ba" translate="yes" xml:space="preserve">
          <source>The following example demonstrates loading a function called 'greet' from a library that is determined at runtime based upon a language choice. If the library fails to load or the function 'greet' is not found, it quits with a failure error code.</source>
          <target state="translated">Следующий пример демонстрирует загрузку функции под названием 'greet' из библиотеки,которая определяется во время выполнения на основе выбора языка.Если библиотека не загружается или функция 'greet' не найдена,то она завершает работу с кодом ошибки.</target>
        </trans-unit>
        <trans-unit id="1d58b86348511b493c86a97949db3309ab3fe22e" translate="yes" xml:space="preserve">
          <source>The following example demonstrates logging to three different handlers simultaneously:</source>
          <target state="translated">Следующий пример демонстрирует протоколирование трех различных обработчиков одновременно:</target>
        </trans-unit>
        <trans-unit id="eabb5a4203a8be2bb32e537097dda5d6aafcb2a1" translate="yes" xml:space="preserve">
          <source>The following example illustrates how to use format strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18893dd703fa2cec1ca572616dda266323fe737a" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between having an empty &lt;code&gt;shortNoVal&lt;/code&gt; and &lt;code&gt;longNoVal&lt;/code&gt;, which is the default, and providing arguments for those two parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3bc2b5c483a0603436689403c8ba9fb562644c" translate="yes" xml:space="preserve">
          <source>The following example implements a powerful &lt;code&gt;debug&lt;/code&gt; command that accepts a variable number of arguments:</source>
          <target state="translated">В следующем примере реализуется мощная команда &lt;code&gt;debug&lt;/code&gt; которая принимает переменное количество аргументов:</target>
        </trans-unit>
        <trans-unit id="4f734436e3f885c81c0eadfbb6a2b481609c6a63" translate="yes" xml:space="preserve">
          <source>The following example outlines a macro that generates a lexical analyzer from regular expressions:</source>
          <target state="translated">Следующий пример описывает макрос,который генерирует лексический анализатор из регулярных выражений:</target>
        </trans-unit>
        <trans-unit id="c9696dddb17da694c08a2a139f76f69dd6a84a76" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modeled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13db42d616e29834b46f311e3a54ec91b9956d97" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modelled:</source>
          <target state="translated">В следующем примере показано,как можно смоделировать общее двоичное дерево:</target>
        </trans-unit>
        <trans-unit id="873ce1a1fdbf3cb02ed243f39b15af534c75db54" translate="yes" xml:space="preserve">
          <source>The following example shows how some form of hoisting can be implemented:</source>
          <target state="translated">Следующий пример показывает,как может быть реализована та или иная форма подъема:</target>
        </trans-unit>
        <trans-unit id="a71a0ac5c57a9a249cd9d88a6571b08a6d33aaff" translate="yes" xml:space="preserve">
          <source>The following example shows how some simple partial evaluation can be implemented with term rewriting:</source>
          <target state="translated">Следующий пример показывает,как некоторые простые частичные оценки могут быть реализованы с помощью переписывания терминов:</target>
        </trans-unit>
        <trans-unit id="49a73336f3c49f017bc0c2b05195fd5ec881be73" translate="yes" xml:space="preserve">
          <source>The following examples will generate documentation for the below contrived &lt;em&gt;Nim&lt;/em&gt; module, aptly named 'sample.nim'</source>
          <target state="translated">Следующие примеры будут генерировать документацию для созданного ниже модуля &lt;em&gt;Nim&lt;/em&gt; , метко названного 'sample.nim'</target>
        </trans-unit>
        <trans-unit id="bca8bd37c432e705556c08bdad3554df72311569" translate="yes" xml:space="preserve">
          <source>The following floating point types are pre-defined:</source>
          <target state="translated">Предварительно определены следующие типы с плавающей запятой:</target>
        </trans-unit>
        <trans-unit id="be3a0eb96a85f116081ffd032fe5b5b0838714d7" translate="yes" xml:space="preserve">
          <source>The following floating-point types are pre-defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bad09cb370d8f3f8c755d03410041bf9dcfd47b" translate="yes" xml:space="preserve">
          <source>The following is a simple example of two different ways to use channels: blocking and non-blocking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e001b72ea1919b9c8b5454d3e5745443232dfc3d" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved and cannot be used as identifiers:</source>
          <target state="translated">Следующие ключевые слова зарезервированы и не могут быть использованы в качестве идентификаторов:</target>
        </trans-unit>
        <trans-unit id="7a481f800b73584de7da49ba29d51edc5e8e325d" translate="yes" xml:space="preserve">
          <source>The following nim code:</source>
          <target state="translated">Следующий ним-код:</target>
        </trans-unit>
        <trans-unit id="6a498725f77daa319527cf92f4474c6333dfd7c1" translate="yes" xml:space="preserve">
          <source>The following paragraphs are mostly a reminder for myself. Things to keep in mind:</source>
          <target state="translated">Следующие параграфы в основном напоминают мне о себе.Вещи,которые нужно иметь в виду:</target>
        </trans-unit>
        <trans-unit id="1bcea16918645347b321c14f6902806d2e446d68" translate="yes" xml:space="preserve">
          <source>The following platforms are seldomly tested:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61304b559e87418b6d1e3732c6eb734eea6a3b9b" translate="yes" xml:space="preserve">
          <source>The following section defines several relations on types that are needed to describe the type checking done by the compiler.</source>
          <target state="translated">Следующий раздел определяет несколько отношений по типам,которые необходимы для описания проверки типов,выполняемой компилятором.</target>
        </trans-unit>
        <trans-unit id="5ffd86ef8c75a76e081502cef8cf82ac80736c9f" translate="yes" xml:space="preserve">
          <source>The following section is an outline of the algorithm that the current implementation uses. The algorithm performs two traversals over the AST of the procedure or global section of code that uses a view variable. No fixpoint iterations are performed, the complexity of the analysis is O(N) where N is the number of nodes of the AST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9926ea103ae5593a38a4d6fb91b32805b8670e76" translate="yes" xml:space="preserve">
          <source>The following sections define the expected output for each kind of symbol for which idetools returns valid output.</source>
          <target state="translated">Следующие разделы определяют ожидаемый вывод для каждого типа символов,для которых idetools возвращает действительный вывод.</target>
        </trans-unit>
        <trans-unit id="6af8e1a2f34a50e4507418236b89fc3d2ccf3867" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each of the metacharacters.</source>
          <target state="translated">В следующих разделах описывается использование каждого из метасимволов.</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">Следующие строки обозначают другие жетоны:</target>
        </trans-unit>
        <trans-unit id="b83acdde1dcacc8ae9aed7b53848613c608c4a6c" translate="yes" xml:space="preserve">
          <source>The following syntax is supported when arguments for the &lt;code&gt;shortNoVal&lt;/code&gt; and &lt;code&gt;longNoVal&lt;/code&gt; parameters, which are &lt;a href=&quot;#shortnoval-and-longnoval&quot;&gt;described later&lt;/a&gt;, are not provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2286a2e09a0398e8afb0291269b5daa96c5798f3" translate="yes" xml:space="preserve">
          <source>The following variables, which must be prefixed with a dollar sign (&lt;code&gt;$&lt;/code&gt;), are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3d56eb3ea6e9604bb48a3710981f35773bad09" translate="yes" xml:space="preserve">
          <source>The format string to turn a filename into a &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; file (also called &lt;span id=&quot;shared-object_1&quot;&gt;shared object&lt;/span&gt; on some operating systems).</source>
          <target state="translated">Строка формата для преобразования имени файла в файл &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; (также называемый &lt;span id=&quot;shared-object_1&quot;&gt;общим объектом&lt;/span&gt; в некоторых операционных системах).</target>
        </trans-unit>
        <trans-unit id="addcd5e79876ecd72925b40fce572a37877dd825" translate="yes" xml:space="preserve">
          <source>The format string used by a logger can be specified by providing the &lt;code&gt;fmtStr&lt;/code&gt; argument when creating the logger or by setting its &lt;code&gt;fmtStr&lt;/code&gt; field afterward. If not specified, the &lt;a href=&quot;#defaultFmtStr&quot;&gt;default format string&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0651b47a0b75f9bee920150d8eee4c5416bccac" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the iterator is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the iterator.</source>
          <target state="translated">Четвертый столбец будет пустой строкой,если задан итератор,так как на тот момент в файле парсер еще не обработал всю строку.Сигнатура будет возвращена полной в последующих экземплярах итератора.</target>
        </trans-unit>
        <trans-unit id="44fc97c45a76e00051690505a1a829c9f330d1aa" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the macro is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the macro.</source>
          <target state="translated">Четвертый столбец будет пустой строкой,если задан макрос,так как на тот момент в файле парсер еще не обработал всю строку.Сигнатура будет возвращена полной в последующих экземплярах макроса.</target>
        </trans-unit>
        <trans-unit id="d08eba1a7248e709a58efba0473c7cce761f8eca" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the method is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the method.</source>
          <target state="translated">Четвертая колонка будет пустой строкой,если определяется метод,так как на тот момент в файле синтаксический анализатор еще не обработал всю строку.Сигнатура будет возвращена полной в последующих экземплярах метода.</target>
        </trans-unit>
        <trans-unit id="9cac080ce5d18f814923daa287cef0ac2f3d19be" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the proc is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the proc.</source>
          <target state="translated">Четвертый столбец будет пустой строкой,если определяется proc,так как на тот момент в файле синтаксический анализатор еще не обработал всю строку.Подпись будет возвращена полной в последующих экземплярах proc.</target>
        </trans-unit>
        <trans-unit id="54e7544248ea9ef4bea128a267709875e2c3f3de" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the template is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the template.</source>
          <target state="translated">Четвертая колонка будет пустой строкой,если задан шаблон,так как на тот момент в файле парсер еще не обработал всю строку.Сигнатура будет возвращена полной в последующих экземплярах шаблона.</target>
        </trans-unit>
        <trans-unit id="55c1deefa556120681916d6951582e608271f06c" translate="yes" xml:space="preserve">
          <source>The fourth use of backslash is for certain &lt;span id=&quot;simple-assertions_1&quot;&gt;simple assertions&lt;/span&gt;. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are::</source>
          <target state="translated">Четвертое использование обратной косой черты - для некоторых &lt;span id=&quot;simple-assertions_1&quot;&gt;простых утверждений&lt;/span&gt; . Утверждение определяет условие, которое должно быть выполнено в определенной точке совпадения, без использования каких-либо символов из строки темы. Использование подшаблонов для более сложных утверждений описано ниже. Утверждения с обратной косой чертой:</target>
        </trans-unit>
        <trans-unit id="870186741ca6e1d444f360ccba4f4fded87a39e7" translate="yes" xml:space="preserve">
          <source>The fractional part of duration, as a duration.</source>
          <target state="translated">Дробная часть длительности,как длительность.</target>
        </trans-unit>
        <trans-unit id="6cf4e08c8caff96d4a84112d274637767f157c27" translate="yes" xml:space="preserve">
          <source>The frame itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0be66077b85b0c6e6e17698732ef4f6a86fec6" translate="yes" xml:space="preserve">
          <source>The freed memory must belong to its allocating thread! Use &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared&lt;/a&gt; to deallocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2b0c3709a2752c88fc8474be143cd0204e9b79" translate="yes" xml:space="preserve">
          <source>The full output can be seen here: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt;. It runs after semantic checking, and includes pragmas attached implicitly by the compiler.</source>
          <target state="translated">Полный вывод можно увидеть здесь: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt; . Он запускается после семантической проверки и включает прагмы, неявно прикрепленные компилятором.</target>
        </trans-unit>
        <trans-unit id="552ab82c6faae30ed9dbac63563f851d644aaccd" translate="yes" xml:space="preserve">
          <source>The functionality implemented by &lt;code&gt;HttpClient&lt;/code&gt; and &lt;code&gt;AsyncHttpClient&lt;/code&gt; is the same, so you can use whichever one suits you best in the examples shown here.</source>
          <target state="translated">Функциональность, реализованная &lt;code&gt;HttpClient&lt;/code&gt; и &lt;code&gt;AsyncHttpClient&lt;/code&gt; , одинакова, поэтому вы можете использовать тот, который вам больше всего подходит в приведенных здесь примерах.</target>
        </trans-unit>
        <trans-unit id="59835708b577fecda7c831ca2458e4c628fc710f" translate="yes" xml:space="preserve">
          <source>The future stream is completed (this means that no more data will be written).</source>
          <target state="translated">Будущий поток завершен (это означает,что больше никаких данных не будет записываться).</target>
        </trans-unit>
        <trans-unit id="87b1c3994092b48e69bbad0698b780ef6e90d0cf" translate="yes" xml:space="preserve">
          <source>The future will complete when the connection is successfully accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be33b21289a1eef5808366623258d9dbcbaa46c" translate="yes" xml:space="preserve">
          <source>The gamma function</source>
          <target state="translated">Гамма-функция</target>
        </trans-unit>
        <trans-unit id="7a4585c32f1f4c6914153a2005cd46dd9de070e8" translate="yes" xml:space="preserve">
          <source>The gamma function &lt;strong&gt;Deprecated since version 0.19.0&lt;/strong&gt;: Use &lt;code&gt;gamma&lt;/code&gt; instead.</source>
          <target state="translated">Гамма-функция Не &lt;strong&gt;рекомендуется, начиная с версии 0.19.0&lt;/strong&gt; : используйте &lt;code&gt;gamma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15c99de4a4957bd4f07f1a6a1fb166d741fab63e" translate="yes" xml:space="preserve">
          <source>The garbage collectors' way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da16bec30ab8a97eb878d0183e447bbc8ee7a461" translate="yes" xml:space="preserve">
          <source>The general form of a standard format specifier is:</source>
          <target state="translated">Общая форма стандартного спецификатора формата:</target>
        </trans-unit>
        <trans-unit id="d90e9f49ac507c92c04a7f7808d9f7f219ca411c" translate="yes" xml:space="preserve">
          <source>The general pattern in &lt;code&gt;=copy&lt;/code&gt; looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91909254b57a3654840f57e5570e9d7ddb4f1d0c" translate="yes" xml:space="preserve">
          <source>The general pattern in &lt;code&gt;=destroy&lt;/code&gt; looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c207d0cccf70d71e7fd5c3d827d8d82b10e6a4a" translate="yes" xml:space="preserve">
          <source>The general pattern in &lt;code&gt;=sink&lt;/code&gt; looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09a581cb8f65c3c5d14cf7a67dcb119a964cc82" translate="yes" xml:space="preserve">
          <source>The generated C code will not have any explicit calling convention and thus use the C compiler's default calling convention. This is needed because Nim's default calling convention for procedures is &lt;code&gt;fastcall&lt;/code&gt; to improve speed.</source>
          <target state="translated">Сгенерированный код C не будет иметь явного соглашения о вызовах и, следовательно, будет использовать соглашение о вызовах по умолчанию компилятора C. Это необходимо, потому что стандартное соглашение о &lt;code&gt;fastcall&lt;/code&gt; Nim для процедур - fastcall для повышения скорости.</target>
        </trans-unit>
        <trans-unit id="b7379e59f2bd87fdbadd32039106a54f883a446d" translate="yes" xml:space="preserve">
          <source>The generated HTML for some of these wrappers is so huge that it is not contained in the distribution. You can then find them on the website.</source>
          <target state="translated">Сгенерированный HTML для некоторых из этих оберток настолько огромен,что не содержится в дистрибутиве.Вы можете найти их на сайте.</target>
        </trans-unit>
        <trans-unit id="7e4e87c93eeee97828c02dc3485e82bbf4f6dbd4" translate="yes" xml:space="preserve">
          <source>The generated async procedures use the &lt;code&gt;async&lt;/code&gt; macro, whereas the generated synchronous procedures simply strip off the &lt;code&gt;await&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa03edbbdb0c3d938f260d58cb5ca2f51408059e" translate="yes" xml:space="preserve">
          <source>The generated files that Nim produces all go into a subdirectory called &lt;code&gt;nimcache&lt;/code&gt;. Its full path is</source>
          <target state="translated">Все сгенерированные файлы, которые создает Nim, &lt;code&gt;nimcache&lt;/code&gt; в подкаталог с именем nimcache . Его полный путь</target>
        </trans-unit>
        <trans-unit id="4c785c59836bb83ab636f8a5d0cda606ab17c5e4" translate="yes" xml:space="preserve">
          <source>The generated index. &lt;strong&gt;Index + (Ctrl+F) == Joy&lt;/strong&gt;</source>
          <target state="translated">Сгенерированный index. &lt;strong&gt;Индекс + (Ctrl + F) == Радость&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f790d93cc82c110db5a7f7d8300334c9fc7c8808" translate="yes" xml:space="preserve">
          <source>The getrlimit() system call gets resource limits.</source>
          <target state="translated">Системный вызов getrlimit()получает лимит ресурсов.</target>
        </trans-unit>
        <trans-unit id="037ac60a6022509a63de6a9810813d645bcec667" translate="yes" xml:space="preserve">
          <source>The global log filter is actually a thread-local variable, so it needs to be set in each thread that uses this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba6185483a07591222dc085893c06cb1d77fd81" translate="yes" xml:space="preserve">
          <source>The good news is not much has changed! First, we need to change the handling of the input parameter (line 3). In the dynamic version the &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc receives a string parameter. However, in the macro version it is also declared as string, but this is the &lt;em&gt;outside&lt;/em&gt; interface of the macro. When the macro is run, it actually gets a &lt;code&gt;PNimNode&lt;/code&gt; object instead of a string, and we have to call the &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (line 5) from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt; to obtain the string being passed in to the macro.</source>
          <target state="translated">Хорошая новость: изменилось немногое! Во-первых, нам нужно изменить обработку входного параметра (строка 3). В динамической версии процедура &lt;code&gt;readCfgAtRuntime&lt;/code&gt; получает строковый параметр. Однако в версии макроса он также объявлен как строка, но это &lt;em&gt;внешний&lt;/em&gt; интерфейс макроса. Когда макрос запускается, он фактически получает объект &lt;code&gt;PNimNode&lt;/code&gt; вместо строки, и мы должны вызвать процедуру &lt;a href=&quot;macros#strVal&quot;&gt;strVal&lt;/a&gt; (строка 5) из &lt;a href=&quot;macros&quot;&gt;модуля макросов,&lt;/a&gt; чтобы получить строку, передаваемую в макрос.</target>
        </trans-unit>
        <trans-unit id="14f57dccb74a2123a9f5546e3bebaee4e90cb289" translate="yes" xml:space="preserve">
          <source>The grammar's start symbol is &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">Начальный символ грамматики - &lt;code&gt;module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6743543c75d60b9f024c8d8ce6011899979a9a7" translate="yes" xml:space="preserve">
          <source>The greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.</source>
          <target state="translated">Программа приветствий состоит из 3-х высказываний,которые выполняются последовательно.Это может сойти с рук только самым примитивным программам:разветвление и петлевание тоже необходимы.</target>
        </trans-unit>
        <trans-unit id="ac70a8fca453e797498ff8e165be78d4d719a059" translate="yes" xml:space="preserve">
          <source>The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:</source>
          <target state="translated">Охранник не обязательно должен быть какого-либо конкретного типа.Он достаточно гибкий,чтобы моделировать механизмы без замков низкого уровня:</target>
        </trans-unit>
        <trans-unit id="d0d6ece26593eceae5133245593e5e87cf3e06f3" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">Обращение с обратным слешем,за которым следует цифра,отличная от 0,является сложным.Вне класса символов PCRE считывает его и любые последующие цифры как десятичное число.Если число меньше 10,или если в выражении было,по крайней мере,так много предыдущих захватов левых круглых скобок,вся последовательность берется как обратная ссылка.Описание того,как это работает,будет дано позже,после обсуждения подмакетов в круглых скобках.</target>
        </trans-unit>
        <trans-unit id="5f48d8244b80a669bed1a5d54a7009aee304b1e6" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of the used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b88ec5fc66250e8218fe5157065e3562f9959e" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="translated">Функция дампа кучи все еще находится в зачаточном состоянии, но она уже оказалась полезной для нас, поэтому может быть полезной для вас. Чтобы получить дамп кучи, скомпилируйте с &lt;code&gt;-d:nimTypeNames&lt;/code&gt; и вызовите &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; в стратегическом месте вашей программы. Это создает список типов, используемых в вашей программе, и для каждого типа общее количество экземпляров объекта для этого типа, а также общее количество байтов, которые эти экземпляры занимают. В настоящий момент этот список не отсортирован! Вам нужно использовать взлом внешнего сценария оболочки, чтобы отсортировать его.</target>
        </trans-unit>
        <trans-unit id="50e42170b04192c54cd732656dcd94cd8243444d" translate="yes" xml:space="preserve">
          <source>The highest (absolute) return value of all processes is returned. Runs &lt;code&gt;beforeRunEvent&lt;/code&gt; before running each command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5e3bf19f9b933b2e60a2ad18d610252c1b05a5" translate="yes" xml:space="preserve">
          <source>The hooks of a tuple type &lt;code&gt;(A, B, ...)&lt;/code&gt; are generated by lifting the hooks of the involved types &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, ... to the tuple type. In other words, a copy &lt;code&gt;x = y&lt;/code&gt; is implemented as &lt;code&gt;x[0] = y[0]; x[1] = y[1]; ...&lt;/code&gt;, likewise for &lt;code&gt;=sink&lt;/code&gt; and &lt;code&gt;=destroy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddf728b23d010d05fee2b18ba2bee9bcf3ad561" translate="yes" xml:space="preserve">
          <source>The hostname of the client that made the request.</source>
          <target state="translated">Имя хоста клиента,сделавшего запрос.</target>
        </trans-unit>
        <trans-unit id="ae4bd9577099eefd3ac234c48f0755b6cae28779" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible, ranging from 0-23.</source>
          <target state="translated">Часы в одной цифре,если возможно,в диапазоне от 0 до 23.</target>
        </trans-unit>
        <trans-unit id="508ac3f8b6d5beb7c16ecbb475b705dc160e6aea" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible. Ranging from 1-12.</source>
          <target state="translated">Часы в одной цифре,если возможно.От 1 до 12.</target>
        </trans-unit>
        <trans-unit id="6e46e361665712eacbeb9a335f8ac314ff87abf9" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. 0 is prepended if the hour is one digit.</source>
          <target state="translated">Часы в двух цифрах всегда.0 предваряется,если час-одна цифра.</target>
        </trans-unit>
        <trans-unit id="35c9e4c595e71cdcb96dde240197d1b8a79fe6b5" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit 0 is prepended.</source>
          <target state="translated">Часы в двух цифрах всегда.Если час-одна цифра 0,то предваряется.</target>
        </trans-unit>
        <trans-unit id="8756b39644a0477a0c2e1fe04a5c8675b5957021" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit, 0 is prepended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9394e30e2a196f91ca01b9ff5b59502413c00a" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;code&gt;type&lt;/code&gt; modifier to create a named instance of the type itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcaf88b5d30ee42061a975ec06cd4f726da65a81" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;em&gt;type&lt;/em&gt; modifier to create a named instance of the type itself:</source>
          <target state="translated">Идентификаторы, следующие за ключевым словом &lt;code&gt;concept&lt;/code&gt; , представляют экземпляры текущего сопоставленного типа. Вы можете применить любой из стандартных модификаторов типа, таких как &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ptr&lt;/code&gt; и &lt;code&gt;static&lt;/code&gt; , для обозначения более конкретного типа экземпляра. Вы также можете применить модификатор &lt;em&gt;типа&lt;/em&gt; для создания именованного экземпляра самого типа:</target>
        </trans-unit>
        <trans-unit id="866a5085cacac6b94172240b1efcb741ff5bdf86" translate="yes" xml:space="preserve">
          <source>The identity hash. I.e. &lt;code&gt;hashIdentity(x) = x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb5916fc4882a2710c89523611ae3521f422971" translate="yes" xml:space="preserve">
          <source>The idetools command can be run as a compiler service (CAAS), where you first launch the compiler and it will stay online as a server, accepting queries in a telnet like fashion. The advantage of staying on is that for many queries the compiler can cache the results of the compilation, and subsequent queries should be fast in the millisecond range, thus being responsive enough for IDEs.</source>
          <target state="translated">Команда idetools может быть запущена как служба компиляции (CAAS),где вы сначала запустите компилятор,и он останется онлайн в качестве сервера,принимая запросы в telnet как модно.Преимущество работы в том,что для многих запросов компилятор может кэшировать результаты компиляции,а последующие запросы должны быть быстрыми в диапазоне миллисекунд,таким образом,будучи достаточно отзывчивыми для IDE.</target>
        </trans-unit>
        <trans-unit id="79d04054b05925070544c64b6a10b2d6f82716f2" translate="yes" xml:space="preserve">
          <source>The if statement is one way to branch the control flow:</source>
          <target state="translated">Если утверждение является одним из способов разветвления потока управления:</target>
        </trans-unit>
        <trans-unit id="186aff351d775e0607553eab0c0008691860c0dc" translate="yes" xml:space="preserve">
          <source>The imaginary unit. &amp;radic;-1.</source>
          <target state="translated">Мнимая единица. &amp;radic;-1.</target>
        </trans-unit>
        <trans-unit id="5e0323c86252bd503934591b5f403aa76daecc18" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#templates-typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0e8535555370a430de44e05424a154580b342b" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="translated">Непосредственная прагма устарела. См. &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Типизированные и нетипизированные параметры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc80eb338f0f7897699f01c0d17e46fc45536bb" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="translated">Реализация выравнивает поля для наилучшей производительности доступа.Выравнивание совместимо с тем,как это делает компилятор Си.</target>
        </trans-unit>
        <trans-unit id="294358e6a281776103afaeb5e6074dc4ee530170" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for the best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9335f13c424aeabf870c93de05f27167c506276" translate="yes" xml:space="preserve">
          <source>The implementation currently provides the following possible options (various others may be added later).</source>
          <target state="translated">Реализация в настоящее время предусматривает следующие возможные варианты (различные другие могут быть добавлены позже).</target>
        </trans-unit>
        <trans-unit id="c3d620a68814993a0e566de11d8cdb73db09b126" translate="yes" xml:space="preserve">
          <source>The implementation of the compilation cache is tricky: There are lots of issues to be solved for the front- and backend.</source>
          <target state="translated">Реализация кэша компиляции хитрая:для фронт-и бэкенда есть много проблем,которые необходимо решить.</target>
        </trans-unit>
        <trans-unit id="c05e5029b48899e6e6d2a69b1f77e63ebf121b7d" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="translated">Неявную инициализацию также можно предотвратить с помощью прагмы типа &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; . Компилятору требуется явная инициализация объекта и всех его полей. Однако он выполняет &lt;span id=&quot;control-flow-analysis_1&quot;&gt;анализ потока управления,&lt;/span&gt; чтобы доказать, что переменная была инициализирована, и не полагается на синтаксические свойства:</target>
        </trans-unit>
        <trans-unit id="041f7a809d44d21475e39cf4f429bf17b9449128" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However, it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bee0de5240bc2aece39314fb5444f70f1444362" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be avoided for optimization reasons with the &lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; pragma:</source>
          <target state="translated">Неявной инициализации можно избежать по причинам оптимизации с помощью &lt;span id=&quot;noinit_1&quot;&gt;прагмы noinit&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="3b7fd6facf0715e6c58bb9982e48c189f4d6d0c2" translate="yes" xml:space="preserve">
          <source>The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.</source>
          <target state="translated">Обработка отпечатков осуществляется следующим образом:Лексер аннотирует следующий токен предыдущим количеством пробелов;отступ не является отдельным токеном.Этот трюк позволяет разобрать Ним,имея только 1 токен lookahead.</target>
        </trans-unit>
        <trans-unit id="beff0881d78e8e065e276388970843e17443daff" translate="yes" xml:space="preserve">
          <source>The index generation tools try to differentiate between documentation generated from &lt;code&gt;.nim&lt;/code&gt; files and documentation generated from &lt;code&gt;.txt&lt;/code&gt; or &lt;code&gt;.rst&lt;/code&gt; files. The former are always closely related to source code and consist mainly of API entries. The latter are generic documents meant for human reading.</source>
          <target state="translated">Инструменты генерации индекса пытаются различать документацию, созданную из файлов &lt;code&gt;.nim&lt;/code&gt; , и документацию, созданную из файлов &lt;code&gt;.txt&lt;/code&gt; или &lt;code&gt;.rst&lt;/code&gt; . Первые всегда тесно связаны с исходным кодом и состоят в основном из записей API. Последние представляют собой общие документы, предназначенные для чтения человеком.</target>
        </trans-unit>
        <trans-unit id="6306cc92a3bed777b6c141274a3bc860eba5a71d" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;docgen#index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="translated">Индекс не будет записан на диск, если вы не &lt;a href=&quot;#writeIndexFile&quot;&gt;вызовете writeIndexFile ()&lt;/a&gt; . Назначение индекса задокументировано в &lt;a href=&quot;docgen#index-switch&quot;&gt;руководстве по инструментам docgen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94bc31946d2cd011244938f6920b84d9ad9961d9" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile,RstGenerator,string&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;https://nim-lang.org/docs/docgen.html#related-options-index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcd5411b31ff678f2d8be730a52fa311b3d1c92" translate="yes" xml:space="preserve">
          <source>The indices of the element range that should be rotated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7771da68e022b74bd5731922346ef2df52d2b53c" translate="yes" xml:space="preserve">
          <source>The inference for read/write tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">Вывод для отслеживания чтения/записи аналогичен выводу для отслеживания исключений.</target>
        </trans-unit>
        <trans-unit id="8d228a4803537313b1b78b37775bd1778df6dcc5" translate="yes" xml:space="preserve">
          <source>The inference for tag tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">Умозаключение для слежения за меткой аналогично умозаключению для слежения за исключением.</target>
        </trans-unit>
        <trans-unit id="f5fb44e48abd9154517dcc0228213cb6390a548c" translate="yes" xml:space="preserve">
          <source>The inline convention means the the caller should not call the procedure, but inline its code directly. Note that Nim does not inline, but leaves this to the C compiler; it generates &lt;code&gt;__inline&lt;/code&gt; procedures. This is only a hint for the compiler: it may completely ignore it and it may inline procedures that are not marked as &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">Встроенное соглашение означает, что вызывающий должен не вызывать процедуру, а напрямую встроить ее код. Обратите внимание, что Nim не встраивается, но оставляет это компилятору C; он генерирует &lt;code&gt;__inline&lt;/code&gt; процедуры. Это только подсказка для компилятора: он может полностью игнорировать его и может встроить процедуры, которые не отмечены как &lt;code&gt;inline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07ea325a19c222cc3708d3f67c25509be2bcbf07" translate="yes" xml:space="preserve">
          <source>The input containers can be of different types. If one container is shorter, the remaining items in the longer container are discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e8a627ab18ca245222565836c8b78837c0f702" translate="yes" xml:space="preserve">
          <source>The interaction between threads and exceptions is simple: A &lt;em&gt;handled&lt;/em&gt; exception in one thread cannot affect any other thread. However, an &lt;em&gt;unhandled&lt;/em&gt; exception in one thread terminates the whole &lt;em&gt;process&lt;/em&gt;!</source>
          <target state="translated">Взаимодействие между потоками и исключениями простое: &lt;em&gt;обработанное&lt;/em&gt; исключение в одном потоке не может повлиять на какой-либо другой поток. Однако &lt;em&gt;необработанное&lt;/em&gt; исключение в одном потоке завершает весь &lt;em&gt;процесс&lt;/em&gt; !</target>
        </trans-unit>
        <trans-unit id="a3f5985cf8e619dcc28842b0431cc6a248880914" translate="yes" xml:space="preserve">
          <source>The interesting thing is that our macro does not return a runtime &lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt; object. Instead, it builds up Nim source code into the &lt;code&gt;source&lt;/code&gt; variable. For each line of the configuration file a &lt;code&gt;const&lt;/code&gt; variable will be generated (line 15). To avoid conflicts we prefix these variables with &lt;code&gt;cfg&lt;/code&gt;. In essence, what the compiler is doing is replacing the line calling the macro with the following snippet of code:</source>
          <target state="translated">Интересно то, что наш макрос не возвращает объект &lt;a href=&quot;tables#Table&quot;&gt;таблицы&lt;/a&gt; времени выполнения . Вместо этого он встраивает исходный код Nim в &lt;code&gt;source&lt;/code&gt; переменную. Для каждой строки файла конфигурации &lt;code&gt;const&lt;/code&gt; переменной будет сгенерирован (строка 15). Чтобы избежать конфликтов, мы ставим перед этими переменными префикс &lt;code&gt;cfg&lt;/code&gt; . По сути, компилятор заменяет строку, вызывающую макрос, следующим фрагментом кода:</target>
        </trans-unit>
        <trans-unit id="7fda431dba2bcff15441a32a1ff7eabe4a0fcf00" translate="yes" xml:space="preserve">
          <source>The internal documentation describes how the compiler is implemented. Read this if you want to hack the compiler.</source>
          <target state="translated">Внутренняя документация описывает,как реализуется компилятор.Прочтите это,если вы хотите взломать компилятор.</target>
        </trans-unit>
        <trans-unit id="1452e6f81083a81acdb84eb68518f3f09d626249" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e39595327b5d15b7987f46c8523802d25b3413e" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and &lt;em&gt;s2&lt;/em&gt; at the same time. Example:</source>
          <target state="translated">Пересечение двух множеств математически представлено как &lt;em&gt;A &amp;cap; B&lt;/em&gt; и представляет собой множество всех объектов, которые являются членами &lt;em&gt;s1&lt;/em&gt; и &lt;em&gt;s2&lt;/em&gt; одновременно. Пример:</target>
        </trans-unit>
        <trans-unit id="0bac8e37845bee3e0695f85e57beaf804a472bb1" translate="yes" xml:space="preserve">
          <source>The jump function for the generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2460c0b5417fd480903274412d643b12ea3569" translate="yes" xml:space="preserve">
          <source>The language constructs are explained using an extended BNF, in which &lt;code&gt;(a)*&lt;/code&gt; means 0 or more &lt;code&gt;a&lt;/code&gt;'s, &lt;code&gt;a+&lt;/code&gt; means 1 or more &lt;code&gt;a&lt;/code&gt;'s, and &lt;code&gt;(a)?&lt;/code&gt; means an optional &lt;em&gt;a&lt;/em&gt;. Parentheses may be used to group elements.</source>
          <target state="translated">Языковые конструкции объясняются с использованием расширенного BNF, в котором &lt;code&gt;(a)*&lt;/code&gt; означает 0 или более &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;a+&lt;/code&gt; означает 1 или более &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;(a)?&lt;/code&gt; означает необязательный &lt;em&gt;a&lt;/em&gt; . Круглые скобки могут использоваться для группировки элементов.</target>
        </trans-unit>
        <trans-unit id="5fa17fe926761d71195e28d1150f004609551f7f" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">Наибольшее положительное число,которое может быть представлено в 32-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="df1bceb0b90a5c84eca91bbd3d5e55dc6f933514" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">Наибольшее положительное число,которое может быть представлено в 64-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="910c1473620a01923d2bc965b1cb67bc12d9a347" translate="yes" xml:space="preserve">
          <source>The last statement of &lt;code&gt;body&lt;/code&gt; has special syntax that specifies the collection's add operation. Use &lt;code&gt;{e}&lt;/code&gt; for set's &lt;code&gt;incl&lt;/code&gt;, &lt;code&gt;{k: v}&lt;/code&gt; for table's &lt;code&gt;[]=&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; for seq's &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b90ce83aefcb334988e56d2cf302f465c1ef2d" translate="yes" xml:space="preserve">
          <source>The last two digits of the year. When parsing, the current century is assumed.</source>
          <target state="translated">Последние две цифры года.При разборе подразумевается текущий век.</target>
        </trans-unit>
        <trans-unit id="cbf5dbfc21433db13ae75eecfb40f44883518b3c" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d738ffb3d9772102e7dddad8f87eb9e66e116402" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt;.</source>
          <target state="translated">Последние два параметра указывают путь к файлу сертификата и путь к файлу ключа, без них сокет сервера, скорее всего, не будет работать. Сертификаты могут быть сгенерированы с помощью следующей команды: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22883001fe945b433749aff495f00df528dc3c12" translate="yes" xml:space="preserve">
          <source>The let statement</source>
          <target state="translated">Заявление о допущении</target>
        </trans-unit>
        <trans-unit id="d0faa7666c0de3db04b2c000430e78a9499fe142" translate="yes" xml:space="preserve">
          <source>The letter 'l' should not be used as an identifier.</source>
          <target state="translated">Буква 'l' не должна использоваться в качестве идентификатора.</target>
        </trans-unit>
        <trans-unit id="e1a4f72b5fdcd674f6a9f4458b16b275e31bc2a1" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful.</source>
          <target state="translated">Библиотека использует простую схему именования,которая использует общие аббревиатуры,чтобы сохранить имена короткими,но значимыми.</target>
        </trans-unit>
        <trans-unit id="03449ea33dc1c4c4ed0647ce0ae2f4b3f5ab6c04" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful. Since version 0.8.2 many symbols have been renamed to fit this scheme. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">В библиотеке используется простая схема именования, в которой используются общие сокращения, чтобы имена были короткими, но значимыми. Начиная с версии 0.8.2 многие символы были переименованы, чтобы соответствовать этой схеме. Конечная цель состоит в том, чтобы программист мог &lt;em&gt;угадать&lt;/em&gt; имя.</target>
        </trans-unit>
        <trans-unit id="e9fa62619261048f21f9083a33a88350d8f41816" translate="yes" xml:space="preserve">
          <source>The lifetime of &lt;code&gt;v&lt;/code&gt; must not exceed &lt;code&gt;b&lt;/code&gt;'s lifetime. Note: The lifetime of a parameter is the complete proc body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b593bd8a0a8e61e207ea44310ff8458416c946da" translate="yes" xml:space="preserve">
          <source>The list of registered handlers is also a thread-local variable. If a handler will be used in multiple threads, it needs to be registered in each of those threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b15f3b8be0db527b2dd32e57b3edc710545648" translate="yes" xml:space="preserve">
          <source>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</source>
          <target state="translated">Перечисленные здесь pragmas могут быть использованы для переопределения опций генерации кода для proc/method/converter.</target>
        </trans-unit>
        <trans-unit id="c515c4489fec51db2bb23bd53fd52c5cb33b8c63" translate="yes" xml:space="preserve">
          <source>The logger that was created above logs to the console, but this module also provides loggers that log to files, such as the &lt;a href=&quot;#FileLogger&quot;&gt;FileLogger&lt;/a&gt;. Creating custom loggers is also possible by inheriting from the &lt;a href=&quot;#Logger&quot;&gt;Logger&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ba5327d8647bd7ed894bcffd2bb86402f1c550" translate="yes" xml:space="preserve">
          <source>The lower bound of an array or sequence may be received by the built-in proc &lt;code&gt;low()&lt;/code&gt;, the higher bound by &lt;code&gt;high()&lt;/code&gt;. The length may be received by &lt;code&gt;len()&lt;/code&gt;. &lt;code&gt;low()&lt;/code&gt; for a sequence or an open array always returns 0, as this is the first valid index. One can append elements to a sequence with the &lt;code&gt;add()&lt;/code&gt; proc or the &lt;code&gt;&amp;amp;&lt;/code&gt; operator, and remove (and get) the last element of a sequence with the &lt;code&gt;pop()&lt;/code&gt; proc.</source>
          <target state="translated">Нижняя граница массива или последовательности может быть получена встроенной процедурой &lt;code&gt;low()&lt;/code&gt; , верхняя граница - &lt;code&gt;high()&lt;/code&gt; . Длина может быть получена &lt;code&gt;len()&lt;/code&gt; . &lt;code&gt;low()&lt;/code&gt; для последовательности или открытого массива всегда возвращает 0, поскольку это первый допустимый индекс. Можно добавить элементы к последовательности с помощью процедуры &lt;code&gt;add()&lt;/code&gt; или оператора &lt;code&gt;&amp;amp;&lt;/code&gt; , а удалить (и получить) последний элемент последовательности с помощью процедуры &lt;code&gt;pop()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5734f010cce3ed3e6eb9ebff7381b95381124003" translate="yes" xml:space="preserve">
          <source>The macro call expands to:</source>
          <target state="translated">Макровызов расширяется:</target>
        </trans-unit>
        <trans-unit id="ba15c60c9b85487537b51042f4adcf6c970f986b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed any more. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="translated">В руководстве упоминается, что &lt;a href=&quot;manual#cstring-type&quot;&gt;строки Nim неявно конвертируются в строки cstrings,&lt;/a&gt; что обычно делает взаимодействие безболезненным. Большинству функций C, принимающих строку Nim, преобразованную в &lt;code&gt;cstring&lt;/code&gt; , скорее всего, не нужно будет хранить эту строку, и к тому времени, когда они вернут строку, она больше не понадобится. Однако в тех редких случаях, когда строку Nim необходимо сохранить и сделать доступной для бэкэнда C как &lt;code&gt;cstring&lt;/code&gt; , вам нужно будет вручную предотвратить освобождение строковых данных с помощью &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; и &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4e04e7f0f6d6096c8019755aeb455838200906b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#types-cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed anymore. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref,string&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref,string&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d055cba0dbcd824c3d51d9d663b957c1d43495ed" translate="yes" xml:space="preserve">
          <source>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</source>
          <target state="translated">Соответствующие операторы могут быть символами любого вызываемого вида (прок,шаблоны и макросы),в зависимости от желаемого эффекта:</target>
        </trans-unit>
        <trans-unit id="aa302af914c04b9a452351c8217335cf34464abe" translate="yes" xml:space="preserve">
          <source>The matching AST must be a call/apply expression.</source>
          <target state="translated">Соответствующий AST должен быть выражением вызова/приложения.</target>
        </trans-unit>
        <trans-unit id="0b44d6a083a904cecf3aef26278e11886b2e549d" translate="yes" xml:space="preserve">
          <source>The matching AST must be an lvalue.</source>
          <target state="translated">Соответствующий АСТ должен иметь значение.</target>
        </trans-unit>
        <trans-unit id="9fac33d3e99596d75ad6eeca948e5afafcf536ac" translate="yes" xml:space="preserve">
          <source>The matching AST must have a side effect.</source>
          <target state="translated">Соответствующий АСТ должен иметь побочный эффект.</target>
        </trans-unit>
        <trans-unit id="62342d8683b403d83a8513c785f6aafa6bfbd8b4" translate="yes" xml:space="preserve">
          <source>The matching AST must have no side effect.</source>
          <target state="translated">Соответствующий АСТ не должен иметь побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="5661a426b593f52c0ca7fa90eafc833175b21253" translate="yes" xml:space="preserve">
          <source>The matching AST must have the specified kind. (Example: &lt;code&gt;nkIfStmt&lt;/code&gt; denotes an &lt;code&gt;if&lt;/code&gt; statement.)</source>
          <target state="translated">Соответствующий AST должен иметь указанный вид. (Пример: &lt;code&gt;nkIfStmt&lt;/code&gt; обозначает оператор &lt;code&gt;if&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="eb0f0fe081b64818b6b3016af8a01416e217ed1f" translate="yes" xml:space="preserve">
          <source>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</source>
          <target state="translated">Сопоставление выполняется после того,как компилятор выполнил некоторые оптимизации,такие как постоянное сгибание,поэтому следующее не работает:</target>
        </trans-unit>
        <trans-unit id="25c9e6f14aaa1c25059b8a65928452c58ffeac86" translate="yes" xml:space="preserve">
          <source>The matching node has no children.</source>
          <target state="translated">У соответствующего узла нет детей.</target>
        </trans-unit>
        <trans-unit id="3bee02bd8ec9e041895cdd7f8534811610597c81" translate="yes" xml:space="preserve">
          <source>The matching node is a literal like &quot;abc&quot;, 12.</source>
          <target state="translated">Соответствующий узел буквально &quot;abc&quot;,12.</target>
        </trans-unit>
        <trans-unit id="721eb0da3439ce9f34194a03def0ba45ab30e608" translate="yes" xml:space="preserve">
          <source>The matching node must be a symbol (a bound identifier).</source>
          <target state="translated">Соответствующий узел должен быть символом (связанным идентификатором).</target>
        </trans-unit>
        <trans-unit id="be1a3bab050b769c30c8177fd935188143910209" translate="yes" xml:space="preserve">
          <source>The matching node must be an identifier (an unbound identifier).</source>
          <target state="translated">Соответствующий узел должен быть идентификатором (несвязанным идентификатором).</target>
        </trans-unit>
        <trans-unit id="4f8a620db21ad017e74d603c8e4851fa5f18d228" translate="yes" xml:space="preserve">
          <source>The maximum content-length that will be read for the body.</source>
          <target state="translated">Максимальная длина содержимого,которая будет считываться для тела.</target>
        </trans-unit>
        <trans-unit id="c950d90d5b11970c79ac7afd395e119a17d543c0" translate="yes" xml:space="preserve">
          <source>The maximum file size limit that &lt;code&gt;staticRead&lt;/code&gt; and &lt;code&gt;slurp&lt;/code&gt; can read is near or equal to the &lt;em&gt;free&lt;/em&gt; memory of the device you are using to compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddb524c9857d48d426ebc459d6731f3dbdd9f9e" translate="yes" xml:space="preserve">
          <source>The maximum redirects can be set with the &lt;code&gt;maxRedirects&lt;/code&gt; of &lt;code&gt;int&lt;/code&gt; type, it specifies the maximum amount of redirects to follow, it defaults to &lt;code&gt;5&lt;/code&gt;, you can set it to &lt;code&gt;0&lt;/code&gt; to disable redirects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ed4b73757fde9ceb2aef3183ba998698e7a6f6" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43fd98d19fce24bd57a3a5dd301ed84cfd20f560" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">Максимальное значение &lt;em&gt;x&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; должен иметь оператор &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d2d6e30267d2820d060080987be5a5b7a4f91f3" translate="yes" xml:space="preserve">
          <source>The maximum value of two integers.</source>
          <target state="translated">Максимальное значение двух целых чисел.</target>
        </trans-unit>
        <trans-unit id="ea3e62d4781ad1dfcb8a4591e57dc4622e4ae0f5" translate="yes" xml:space="preserve">
          <source>The memory management for Nim's standard &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;seq&lt;/code&gt; types as well as other standard collections is performed via so-called &quot;Lifetime-tracking hooks&quot; or &quot;type-bound operators&quot;. There are 3 different hooks for each (generic or concrete) object type &lt;code&gt;T&lt;/code&gt; (&lt;code&gt;T&lt;/code&gt; can also be a &lt;code&gt;distinct&lt;/code&gt; type) that are called implicitly by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9b388505eb1fb774570095acc72dd570fedb16" translate="yes" xml:space="preserve">
          <source>The method call syntax conflicts with explicit generic instantiations: &lt;code&gt;p[T](x)&lt;/code&gt; cannot be written as &lt;code&gt;x.p[T]&lt;/code&gt; because &lt;code&gt;x.p[T]&lt;/code&gt; is always parsed as &lt;code&gt;(x.p)[T]&lt;/code&gt;.</source>
          <target state="translated">Синтаксис вызова метода конфликтует с явными универсальными экземплярами: &lt;code&gt;p[T](x)&lt;/code&gt; нельзя записать как &lt;code&gt;x.p[T]&lt;/code&gt; потому что &lt;code&gt;x.p[T]&lt;/code&gt; всегда анализируется как &lt;code&gt;(x.p)[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e29a37d51a470bd093573ef80de02da80f8ae42c" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ef8bda90a06a0c3f6e30dace9ed42593b23481" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">Минимальное значение &lt;em&gt;x&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; должен иметь оператор &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6382aa6ed7dc87e04b1c5dfd0efac1c3cf2ff114" translate="yes" xml:space="preserve">
          <source>The minimum value of two integers.</source>
          <target state="translated">Минимальное значение двух целых чисел.</target>
        </trans-unit>
        <trans-unit id="42618bccaa1614ff3af2e91f3ca07f6ebdc8c5aa" translate="yes" xml:space="preserve">
          <source>The minutes in 1 digit if possible.</source>
          <target state="translated">Минуты в 1 цифре,если это возможно.</target>
        </trans-unit>
        <trans-unit id="8120849383a0dce81fbc77edaa154da4bae069f9" translate="yes" xml:space="preserve">
          <source>The minutes in one digit if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6835c438c5815928aa2df14ad04c857ef1631d" translate="yes" xml:space="preserve">
          <source>The module contains a default Rand state for convenience. It corresponds to the default random number generator's state. The default Rand state always starts with the same values, but the &lt;a href=&quot;#randomize&quot;&gt;randomize proc&lt;/a&gt; can be used to seed the default generator with a value based on the current time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5990e415167b1e53c0b5e58fc592b231b04e133e" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;code&gt;noIntrinsicsBitOpts&lt;/code&gt; to disable compiler intrinsics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3095d9956a51342dd5a97c0ff4d61f08e5b0b7f" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; to disable compiler intrinsics.</source>
          <target state="translated">Модуль будет использовать чистые процессы NIM, если серверная часть не поддерживается. Вы также можете использовать флаг &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; для отключения встроенных &lt;em&gt;функций&lt;/em&gt; компилятора.</target>
        </trans-unit>
        <trans-unit id="cd9fc72b4ada2f752486fbb515d1c9c09d7aa8f3" translate="yes" xml:space="preserve">
          <source>The month as an enum, the ordinal value is in the range 1 to 12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e065869153c9cf19339eeb5fe17bfa8010a6236" translate="yes" xml:space="preserve">
          <source>The month in one digit if possible.</source>
          <target state="translated">Месяц в одну цифру,если возможно.</target>
        </trans-unit>
        <trans-unit id="8ffdd973b77981374afa6bab23748caa6eb3c1fe" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended if the month value is one digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb37896b3a59b2013774ad8a8bc6115389438f2" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended.</source>
          <target state="translated">Месяц в двухзначных числах всегда.0 предоплачен.</target>
        </trans-unit>
        <trans-unit id="9b7d512c82e7ce84b958ad19e901783b62720ac2" translate="yes" xml:space="preserve">
          <source>The most important reason for RTTI. Generating traversal procedures produces bigger code and is likely to be slower on modern hardware as dynamic procedure binding is hard to predict.</source>
          <target state="translated">Самая важная причина для RTTI.Генерация процедур обхода приводит к большему объему кода и,скорее всего,будет более медленной на современном оборудовании,так как динамическое связывание процедур трудно предсказать.</target>
        </trans-unit>
        <trans-unit id="cf6c2e2953025ff455ecd8b6b1f063d8970db911" translate="yes" xml:space="preserve">
          <source>The most reliable way to handle exceptions is to use &lt;code&gt;yield&lt;/code&gt; on a future then check the future's &lt;code&gt;failed&lt;/code&gt; property. For example:</source>
          <target state="translated">Самый надежный способ обработки исключений - использовать &lt;code&gt;yield&lt;/code&gt; on a future, а затем проверять &lt;code&gt;failed&lt;/code&gt; свойство future . Например:</target>
        </trans-unit>
        <trans-unit id="abac663a9e4ad29972ddcc95fc577538bbcbd3dd" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command line invocations:</source>
          <target state="translated">Наиболее существенное различие между этими командами заключается в том, что если вы &lt;code&gt;nimcache&lt;/code&gt; каталог nimcache, вы найдете файлы &lt;code&gt;.c&lt;/code&gt; , &lt;code&gt;.cpp&lt;/code&gt; или &lt;code&gt;.m&lt;/code&gt; , кроме того, все они создадут собственный двоичный файл для вашего проекта. Это позволяет вам взять сгенерированный код и поместить его прямо в проект, используя любой из этих языков. Вот несколько типичных вызовов командной строки:</target>
        </trans-unit>
        <trans-unit id="a72f50212d0085eb823c7d6f12ded16312fb8518" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command- line invocations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f05063edc5202ee9c72c0096b575ad8468f147" translate="yes" xml:space="preserve">
          <source>The name of the timezone.</source>
          <target state="translated">Название часового пояса.</target>
        </trans-unit>
        <trans-unit id="ec06ca30d3763f24610615079488aee1dec49148" translate="yes" xml:space="preserve">
          <source>The need to check for self-assignments and also the need to destroy previous objects inside &lt;code&gt;=copy&lt;/code&gt; and &lt;code&gt;=sink&lt;/code&gt; is a strong indicator to treat &lt;code&gt;system.swap&lt;/code&gt; as a builtin primitive of its own that simply swaps every field in the involved objects via &lt;code&gt;copyMem&lt;/code&gt; or a comparable mechanism. In other words, &lt;code&gt;swap(a, b)&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; implemented as &lt;code&gt;let tmp = move(b); b = move(a); a = move(tmp)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f458d384ea0910910144b31e2bb7acec5965f32b" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;import&lt;/code&gt; statement will bring in all exported symbols. These can be limited by naming symbols which should be excluded with the &lt;code&gt;except&lt;/code&gt; qualifier.</source>
          <target state="translated">Обычный оператор &lt;code&gt;import&lt;/code&gt; вводит все экспортированные символы. Они могут быть ограничены именованием символов, которые следует исключить с помощью квалификатора &lt;code&gt;except&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="629262f7b72a57e5a72d86066221973769332f9a" translate="yes" xml:space="preserve">
          <source>The normal operation mode is called &lt;code&gt;ProcRun&lt;/code&gt; and it involves starting a process for each command or query, similar to running manually the Nim compiler from the commandline. The &lt;code&gt;CaasRun&lt;/code&gt; mode starts a server process to answer all queries. The &lt;code&gt;SymbolProcRun&lt;/code&gt; mode is used by compiler developers. This means that running all tests involves processing all &lt;code&gt;*.txt&lt;/code&gt; files three times, which can be quite time consuming.</source>
          <target state="translated">Обычный режим работы называется &lt;code&gt;ProcRun&lt;/code&gt; , и он включает запуск процесса для каждой команды или запроса, аналогично запуску компилятора Nim вручную из командной строки. Режим &lt;code&gt;CaasRun&lt;/code&gt; запускает серверный процесс для ответа на все запросы. Режим &lt;code&gt;SymbolProcRun&lt;/code&gt; используется разработчиками компилятора. Это означает, что запуск всех тестов требует трехкратной обработки всех файлов &lt;code&gt;*.txt&lt;/code&gt; , что может занять довольно много времени.</target>
        </trans-unit>
        <trans-unit id="4bae69dda155aa8a4d14da3a2fc6579a9ca759df" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; can be used to access the i-th element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Обозначение &lt;code&gt;x[i]&lt;/code&gt; может использоваться для доступа к i-му элементу &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="658eabb7c8362bd8ccc2db983d207e849c519eb7" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; is used to access the i-th element of &lt;code&gt;x&lt;/code&gt;. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--bound_checks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">Обозначение &lt;code&gt;x[i]&lt;/code&gt; используется для доступа к i-му элементу &lt;code&gt;x&lt;/code&gt; . Доступ к массиву всегда проверяется по границам (во время компиляции или во время выполнения). Эти проверки можно отключить с помощью прагм или вызвать компилятор с помощью &lt;code&gt;--bound_checks:off&lt;/code&gt; командной строки --bound_checks: off .</target>
        </trans-unit>
        <trans-unit id="84253c85ff2fe63ceae34cee869e8056c8618b6f" translate="yes" xml:space="preserve">
          <source>The notation used for a PEG is similar to that of EBNF:</source>
          <target state="translated">Обозначение,используемое для PEG,аналогично обозначению EBNF:</target>
        </trans-unit>
        <trans-unit id="35c5176abc505099c32f5f56c77ef46929971143" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to 's[i]' including following combining characters.</source>
          <target state="translated">Количество байтов,принадлежащих 's[i]',включая следующие комбинированные символы.</target>
        </trans-unit>
        <trans-unit id="0766850e8af24901ac224e38448b654947018953" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to byte index &lt;code&gt;s[i]&lt;/code&gt;, including following combining code unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a065c415acb39bca6dfbf84627b78c96bd774e" translate="yes" xml:space="preserve">
          <source>The number of days since January 1, in the range 0 to 365.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4bc3865db45d046e1df4ff74764ae23a55e1d4" translate="yes" xml:space="preserve">
          <source>The number of hours past midnight, in the range 0 to 23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52a4ac082994b235155e44e2290132cb04c90c6" translate="yes" xml:space="preserve">
          <source>The number of minutes after the hour, in the range 0 to 59.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3348856fb20c7700d32dbefabea6931ef860b4c" translate="yes" xml:space="preserve">
          <source>The number of nanoseconds after the second, in the range 0 to 999_999_999.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e92dae4acdb9d413c25e9143865ccec7ea6c1c" translate="yes" xml:space="preserve">
          <source>The number of seconds after the minute, in the range 0 to 59.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67410fb726aaa716bc56a897729095f56b009d39" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all GC heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="translated">Числа подсчитывают количество объектов во всех кучах сборщика мусора, они относятся ко всем запущенным потокам, а не только к текущему потоку. (Текущий поток будет потоком, который вызывает &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; .) Это может измениться в более поздних версиях.</target>
        </trans-unit>
        <trans-unit id="06fbf19ead5eb4522c5f0e525c80f22c80dfd57c" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all garbage collector heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943d32e77792f1b379a556185254f33101e23b55" translate="yes" xml:space="preserve">
          <source>The numerical identifier is just a random number. The number gets assigned according to the section and position of the symbol in the file being processed and you should not rely on it being constant: if you add or remove a symbol the numbers may shuffle around.</source>
          <target state="translated">Числовой идентификатор-просто случайное число.Номер присваивается в соответствии с разделом и положением символа в обрабатываемом файле,и не стоит полагаться на то,что он постоянный:при добавлении или удалении символа числа могут перемешаться.</target>
        </trans-unit>
        <trans-unit id="727a603933eb24259acf39e94c54b8c8c69ecf4d" translate="yes" xml:space="preserve">
          <source>The occasional use of idetools is acceptable for things like definitions, where the user puts the cursor on a symbol or double clicks it and after a second or two the IDE displays where that symbol is defined. Such latencies would be terrible for features like symbol suggestion, plus why wait at all if we can avoid it?</source>
          <target state="translated">Иногда использование idetools допустимо для таких вещей,как определения,когда пользователь навел курсор на символ или дважды щелкнул по нему,и через секунду или две IDE показывает,где этот символ определен.Такие задержки были бы ужасны для таких функций,как предложение символа,плюс зачем вообще ждать,если можно избежать этого?</target>
        </trans-unit>
        <trans-unit id="25d3919cb8bebc916c007785d723e89c51ae1b68" translate="yes" xml:space="preserve">
          <source>The offset in seconds west of UTC, including any offset due to DST. Note that the sign of this number is the opposite of the one in a formatted offset string like &lt;code&gt;+01:00&lt;/code&gt; (which would be equivalent to the UTC offset &lt;code&gt;-3600&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37994ecd43903ca9e4ef6ac25795c9cd0cb6d035" translate="yes" xml:space="preserve">
          <source>The only case where things aren't as easy is when the garbage collector needs some assembler tweaking to work. The standard version of the GC uses C's &lt;code&gt;setjmp&lt;/code&gt; function to store all registers on the hardware stack. It may be necessary that the new platform needs to replace this generic code by some assembler code.</source>
          <target state="translated">Единственный случай, когда все не так просто, - это когда сборщик мусора нуждается в некоторой настройке ассемблера для работы. Стандартная версия GC использует функцию C &lt;code&gt;setjmp&lt;/code&gt; для хранения всех регистров аппаратного стека. Может потребоваться, чтобы новая платформа заменила этот общий код некоторым кодом ассемблера.</target>
        </trans-unit>
        <trans-unit id="e2f49d4957d979510c6bf361e27282ecac40ce06" translate="yes" xml:space="preserve">
          <source>The only difference between the contents of that file and the values provided by this proc is the &lt;code&gt;doc.file&lt;/code&gt; variable. The &lt;code&gt;doc.file&lt;/code&gt; variable of the configuration file contains HTML to build standalone pages, while this proc returns just the content for procs like &lt;code&gt;rstToHtml&lt;/code&gt; to generate the bare minimum HTML.</source>
          <target state="translated">Единственная разница между содержимым этого файла и значениями, предоставляемыми этой процедурой, - это переменная &lt;code&gt;doc.file&lt;/code&gt; . &lt;code&gt;doc.file&lt;/code&gt; переменного конфигурационного файла содержит HTML для сборки отдельных страниц, в то время как эта процедура возвращает только контент для проков как &lt;code&gt;rstToHtml&lt;/code&gt; генерировать голый минимум HTML.</target>
        </trans-unit>
        <trans-unit id="66d1058ab09e19fbf4fbe3d6ea05970103c3b41c" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating point types.</source>
          <target state="translated">Единственные операции, на которые влияет прагма &lt;code&gt;floatChecks&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; это операторы &lt;code&gt;+&lt;/code&gt; , - , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; для типов с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="899d5fc602ad3db90bd279ddd77881c1cca58eeb" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating-point types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168d790e853cbd9034f71729f2476481319d159c" translate="yes" xml:space="preserve">
          <source>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</source>
          <target state="translated">Тип открытого массива не может быть вложен:многомерные открытые массивы не поддерживаются,так как это редко требуется и не может быть сделано эффективно.</target>
        </trans-unit>
        <trans-unit id="c4e0647a4c89f8b16abd9dcace05bac8931235f1" translate="yes" xml:space="preserve">
          <source>The operation is performed atomically and other operations on the table will be blocked while the &lt;code&gt;mapper&lt;/code&gt; is invoked, so it should be short and simple.</source>
          <target state="translated">Операция выполняется атомарно, и другие операции с таблицей будут заблокированы во время вызова &lt;code&gt;mapper&lt;/code&gt; , поэтому она должна быть короткой и простой.</target>
        </trans-unit>
        <trans-unit id="83ab7b4d2bb2233e5f2fab96873b663a53e9e12f" translate="yes" xml:space="preserve">
          <source>The operation produced a result that cannot be represented with infinite precision -- for example: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</source>
          <target state="translated">Операция дала результат, который невозможно представить с бесконечной точностью - например: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8377f7d618fcf4075ebaa21071b51f158edf57be" translate="yes" xml:space="preserve">
          <source>The operation produced a result that exceeds the range of the exponent.</source>
          <target state="translated">В результате операции был получен результат,превышающий диапазон экспонента.</target>
        </trans-unit>
        <trans-unit id="33f13b87dbb9bcf04674b0e7829c348aac46fcd6" translate="yes" xml:space="preserve">
          <source>The operation produced a result that is too small to be represented as a normal number.</source>
          <target state="translated">Результат операции оказался слишком мал,чтобы его можно было представить в виде обычного числа.</target>
        </trans-unit>
        <trans-unit id="941ce1be2e887859312d9d5ab72c51d7733f52a5" translate="yes" xml:space="preserve">
          <source>The operator's precedence is determined by its first character. The details can be found in the manual.</source>
          <target state="translated">Приоритет оператора определяется его первым символом.Подробности приведены в руководстве.</target>
        </trans-unit>
        <trans-unit id="c0e839d05d73521d7af47a856f782f7c30977b0c" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation.</source>
          <target state="translated">Операторы &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; имеют особое значение в образцах, если они записаны в инфиксной записи.</target>
        </trans-unit>
        <trans-unit id="bf012723c5a2a5eb3b690eb90475c06700cb84be" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-circuit evaluation. For example:</source>
          <target state="translated">Операторы &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; определены для типа bool. Операторы &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; выполняют оценку короткого замыкания. Например:</target>
        </trans-unit>
        <trans-unit id="5a6dbe81c71ecdddbb102d68881f2f73beabe16e" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-cut evaluation. Example:</source>
          <target state="translated">Операторы &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; определены для типа bool. Операторы &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; выполняют сокращенную оценку. Пример:</target>
        </trans-unit>
        <trans-unit id="81caedce7ab00b1fe39f7b3ec76b901fbe2f933f" translate="yes" xml:space="preserve">
          <source>The optional 'fill' character defines the character to be used to pad the field to the minimum width. The fill character, if present, must be followed by an alignment flag.</source>
          <target state="translated">Опциональный символ 'заполнение' определяет символ,который будет использоваться для заполнения поля до минимальной ширины.Символ заполнения,если он присутствует,должен сопровождаться флагом выравнивания.</target>
        </trans-unit>
        <trans-unit id="61a4c0792ebff9a51436a6a10512fd4b427609a0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;shortNoVal&lt;/code&gt; and &lt;code&gt;longNoVal&lt;/code&gt; parameters present in &lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser&lt;/a&gt; are for specifying which short and long options do not accept values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b3a59de6d012b18e22a8e7a284e6db58df1867" translate="yes" xml:space="preserve">
          <source>The optional align flag can be one of the following:</source>
          <target state="translated">Дополнительный флаг выравнивания может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="a0e3a6522c824ed95aa3e1f8fe8ce4a5f4f147b1" translate="yes" xml:space="preserve">
          <source>The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt;.</source>
          <target state="translated">Порядок &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt; (ключ, значение) сохраняется, поэтому упорядоченные словари легко поддерживать, например, с помощью {key: val} .newOrderedTable .</target>
        </trans-unit>
        <trans-unit id="429f542ce113c15e57f01af974550e0e5b305975" translate="yes" xml:space="preserve">
          <source>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</source>
          <target state="translated">Порядок замены имеет значение.Более ранние замены предпочтительнее,чем более поздние замены в списке аргументов.</target>
        </trans-unit>
        <trans-unit id="3108768a24a46c2d1623f6a7352dae8089ca7973" translate="yes" xml:space="preserve">
          <source>The ordinary assignment in Nim conceptually copies the values. The &lt;code&gt;=copy&lt;/code&gt; hook is called for assignments that couldn't be transformed into &lt;code&gt;=sink&lt;/code&gt; operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dacff1821dbef72a128b774b46c26a9e053a10c5" translate="yes" xml:space="preserve">
          <source>The original module name is then not accessible. The notations &lt;code&gt;path/to/module&lt;/code&gt; or &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; can be used to refer to a module in subdirectories:</source>
          <target state="translated">Тогда исходное имя модуля становится недоступным. Обозначения &lt;code&gt;path/to/module&lt;/code&gt; или &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; могут использоваться для ссылки на модуль в подкаталогах:</target>
        </trans-unit>
        <trans-unit id="6f7414b6f4b65521aaf6120245a6e651f68d1e5a" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;code&gt;width&lt;/code&gt; is less than or equal to &lt;code&gt;s.len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc86fbbfca2829ffbb5ee4206b27f3d101a719c7" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;em&gt;width&lt;/em&gt; is less than or equal to &lt;em&gt;s.len&lt;/em&gt;.</source>
          <target state="translated">Исходная строка возвращается, если &lt;em&gt;ширина&lt;/em&gt; меньше или равна &lt;em&gt;s.len&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="56fcfadb9f1701723ceb4fcaae9d90dddc612821" translate="yes" xml:space="preserve">
          <source>The other reason is that the dirty file can appear anywhere on disk (e.g. in tmpfs), but it must be treated as having a path matching the original module when it comes to usage of relative paths, etc. Queries, however, will refer to the dirty module name in their answers instead of the normal filename.</source>
          <target state="translated">Другая причина заключается в том,что грязный файл может появиться где угодно на диске (например,в tmpfs),но он должен рассматриваться как имеющий путь,совпадающий с исходным модулем,когда дело доходит до использования относительных путей и т.д.Запросы,однако,будут ссылаться на имя &quot;грязного&quot; модуля в своих ответах,а не на обычное имя файла.</target>
        </trans-unit>
        <trans-unit id="d25c28b6460c3b06db65db14b1f5007e28412aff" translate="yes" xml:space="preserve">
          <source>The outcome of the &lt;a href=&quot;math#cumsum,openArray%5BT%5D&quot;&gt;cumsum&lt;/a&gt; proc and the return value of the &lt;a href=&quot;math#cumsummed,openArray%5BT%5D&quot;&gt;cumsummed&lt;/a&gt; proc, which are both in the math module, can be used as the &lt;code&gt;cdf&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81362a99790f1d4f0fa145c5d4c8a309f3b532a8" translate="yes" xml:space="preserve">
          <source>The output for HTML and LaTeX comes from the &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; and &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; configuration files. You can add and modify these files to your project to change the look of docgen output.</source>
          <target state="translated">Вывод для HTML и LaTeX поступает из файлов конфигурации &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; и &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; . Вы можете добавлять и изменять эти файлы в свой проект, чтобы изменить внешний вид вывода docgen.</target>
        </trans-unit>
        <trans-unit id="5fab1111abe4336bbc798351e8ca9549d09746d9" translate="yes" xml:space="preserve">
          <source>The output is twice the input long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated.</source>
          <target state="translated">Выходной файл в два раза длиннее входного. Префикса типа &lt;code&gt;0x&lt;/code&gt; не создается.</target>
        </trans-unit>
        <trans-unit id="533631499bbd1d8be6ff4dcee292a72b882cc3f0" translate="yes" xml:space="preserve">
          <source>The output verbosity of the tests.</source>
          <target state="translated">Выходная многословие тестов.</target>
        </trans-unit>
        <trans-unit id="608798a73678f1416a011aa2b8e46d174cf55393" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked during semantic analysis to be free of data races. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461db813bbace1635974b27e6126d38b9c4ee9ad" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked to be free of data races at compile time. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="translated">Оператор parallel - предпочтительный механизм для введения параллелизма в программу Nim. Подмножество языка Nim действует в &lt;code&gt;parallel&lt;/code&gt; разделе. Это подмножество проверяется на отсутствие гонок данных во время компиляции. Утонченная &lt;span id=&quot;disjoint-checker_1&quot;&gt;непересекающихся шашка&lt;/span&gt; гарантирует , что никакие скачки данных не возможны , даже если общая память широко поддерживается!</target>
        </trans-unit>
        <trans-unit id="c93630ff32d61caf48c2f2e72e2c5aa9f904f95c" translate="yes" xml:space="preserve">
          <source>The parameters are in reverse order! &lt;code&gt;a in b&lt;/code&gt; is a template for &lt;code&gt;contains(b, a)&lt;/code&gt;. This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the &lt;code&gt;in&lt;/code&gt; operator that would be the wrong direction for this piece of code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d785f95df44f47948246d72ae65b3b0c993eb38c" translate="yes" xml:space="preserve">
          <source>The parameters' types can be ordinary types or the meta types &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt;, or &lt;code&gt;type&lt;/code&gt;. &lt;code&gt;type&lt;/code&gt; suggests that only a type symbol may be given as an argument, and &lt;code&gt;untyped&lt;/code&gt; means symbol lookups and type resolution is not performed before the expression is passed to the template.</source>
          <target state="translated">Типы параметров могут быть обычными типами или типами меты &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; , или &lt;code&gt;type&lt;/code&gt; . &lt;code&gt;type&lt;/code&gt; предполагает, что в качестве аргумента может быть задан только символ типа, а &lt;code&gt;untyped&lt;/code&gt; означает, что поиск символов и разрешение типа не выполняются до передачи выражения в шаблон.</target>
        </trans-unit>
        <trans-unit id="2bbf11b9701162a2035c4b55918733e64b1b5f9b" translate="yes" xml:space="preserve">
          <source>The parser object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b1f54dcfe838ac2e0c59b6f42dae3e0756b1fe" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="translated">Парсер использует стек уровней отступа: стек состоит из целых чисел, считая пробелы. Информация об отступах запрашивается в стратегических местах синтаксического анализатора, но в противном случае игнорируется: псевдотерминал &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; обозначает отступ, который состоит из большего количества пробелов, чем запись наверху стека; &lt;code&gt;IND{=}&lt;/code&gt; отступ с таким же количеством пробелов. &lt;code&gt;DED&lt;/code&gt; - это еще один псевдотерминал, который описывает &lt;em&gt;действие&lt;/em&gt; извлечения значения из стека, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; затем подразумевает отправку значения в стек.</target>
        </trans-unit>
        <trans-unit id="abe385c190c44ec425b363f1b29f850fc6d40616" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo-terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75d284a399469fffe0947c898a06ce009bcfbbc" translate="yes" xml:space="preserve">
          <source>The passed file handle will no longer be inheritable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9027f1cfc9029d9bab0ad3b282e7849cb03b34" translate="yes" xml:space="preserve">
          <source>The path analysis is &lt;strong&gt;currently unsound&lt;/strong&gt;, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.</source>
          <target state="translated">Анализ пути в &lt;strong&gt;настоящее время не работает&lt;/strong&gt; , но это не делает его бесполезным. Два пути считаются эквивалентными, если они синтаксически одинаковы.</target>
        </trans-unit>
        <trans-unit id="0bbaeda5d44901c81ebec10bdd7c6c2aed094901" translate="yes" xml:space="preserve">
          <source>The path returned by this proc is set at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17327de092c7c00324e920e1dec0a84488b2def" translate="yes" xml:space="preserve">
          <source>The path returned by this template is set at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21fa755d2f9dd13f4c401361fe48cbd80c4ec20" translate="yes" xml:space="preserve">
          <source>The plain name of a symbol is a simplified version of its fully exported signature. Variables or constants have the same plain name symbol as their complex name. The plain name for procs, templates, and other callable types will be their unquoted value after removing parameters, return types and pragmas. The plain name allows short and nice linking of symbols which works unless you have a module with collisions due to overloading.</source>
          <target state="translated">Обычное название символа является упрощенной версией его полностью экспортируемой подписи.Переменные или константы имеют то же самое простое имя,что и их сложное название.Обычное имя для прок,шаблонов и других вызываемых типов будет их нецитируемым значением после удаления параметров,типов возврата и прагм.Простое имя позволяет короткое и красивое связывание символов,которое работает,если только у вас нет модуля с коллизиями из-за перегрузки.</target>
        </trans-unit>
        <trans-unit id="14e09d7c794944bac489c1fb890465f3395a7739" translate="yes" xml:space="preserve">
          <source>The portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned.</source>
          <target state="translated">Часть, соответствующая &lt;code&gt;sep&lt;/code&gt; , не возвращается.</target>
        </trans-unit>
        <trans-unit id="5905889f12b10a582b5de19496532d186574a39d" translate="yes" xml:space="preserve">
          <source>The pragmas listed here can be used to optionally accept values from the -d/--define option at compile time.</source>
          <target state="translated">Перечисленные здесь прагмы могут быть использованы для опционального принятия значений из опции -d/--define во время компиляции.</target>
        </trans-unit>
        <trans-unit id="15d21bc5558df5db984c197f09719a14cdbc33c2" translate="yes" xml:space="preserve">
          <source>The predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;countIt(@[1, 2, 3], it &amp;gt; 2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c1f5ea59e38f8446c010800e904b6889b2d6f5" translate="yes" xml:space="preserve">
          <source>The problem here is that the compiler already decided that &lt;code&gt;something()&lt;/code&gt; as an iterator is not callable in this context before &lt;code&gt;toSeq&lt;/code&gt; gets its chance to convert it into a sequence.</source>
          <target state="translated">Проблема здесь в том, что компилятор уже решил, что &lt;code&gt;something()&lt;/code&gt; как итератор не может быть вызван в этом контексте, прежде чем &lt;code&gt;toSeq&lt;/code&gt; получит шанс преобразовать его в последовательность.</target>
        </trans-unit>
        <trans-unit id="9efd7fdcbe1a2580f7c97b1293f83d8747130a12" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;getSourceLanguage&lt;/code&gt; can get the language &lt;code&gt;enum&lt;/code&gt; from a string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1413d5988b205726c716a63467c96b038a113fd1" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; is called implicitly when your nim program finishes without incident for platforms where this is the expected behavior. A raised unhandled exception is equivalent to calling &lt;code&gt;quit(QuitFailure)&lt;/code&gt;.</source>
          <target state="translated">Процедура &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; вызывается неявно, когда ваша программа nim завершается без происшествий для платформ, где такое поведение является ожидаемым. &lt;code&gt;quit(QuitFailure)&lt;/code&gt; необработанное исключение эквивалентно вызову quit (QuitFailure) .</target>
        </trans-unit>
        <trans-unit id="7e2d3b14bba8ee482acb489760d42aaa50f22724" translate="yes" xml:space="preserve">
          <source>The proc is meant to parse the Cookie header set by a client, not the &quot;Set-Cookie&quot; header set by servers.</source>
          <target state="translated">Прок предназначен для разбора заголовка Cookie,установленного клиентом,а не заголовка &quot;Set-Cookie&quot;,установленного серверами.</target>
        </trans-unit>
        <trans-unit id="b711effa5493572608721c0ecb5734464843d0bf" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ebd1b54b6f7339d68d2b35085cae9b111d5bdc" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes. &lt;strong&gt;Note&lt;/strong&gt;: This is not correct for producing Ansi C code!</source>
          <target state="translated">Процедура была разработана таким образом, чтобы ее вывод можно было использовать для многих различных распространенных синтаксисов. &lt;strong&gt;Примечание&lt;/strong&gt; : это неверно для создания кода Ansi C!</target>
        </trans-unit>
        <trans-unit id="888e3f99a533bb35f9c99bb61e235d2938bc6ca0" translate="yes" xml:space="preserve">
          <source>The produced &lt;code&gt;finally&lt;/code&gt; section can be a single section that is wrapped around the complete routine body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa4a16f221969c520c65e78c146e6b52b5ba0e3" translate="yes" xml:space="preserve">
          <source>The produced &lt;code&gt;finally&lt;/code&gt; section is wrapped around the enclosing scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70d2b5b4c0766ea2a1f51de97640c064876e562" translate="yes" xml:space="preserve">
          <source>The program should output something similar to this, but keep in mind that exact results may vary in the real world:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ed2941bc29e9113b49ab22213c1bd08c56b866" translate="yes" xml:space="preserve">
          <source>The progress of either a file upload or a file download can be checked by specifying a &lt;code&gt;onProgressChanged&lt;/code&gt; procedure to the &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;retrFile&lt;/code&gt; procedures.</source>
          <target state="translated">Ход загрузки или загрузки файла можно проверить, указав процедуру &lt;code&gt;onProgressChanged&lt;/code&gt; для процедур &lt;code&gt;store&lt;/code&gt; или &lt;code&gt;retrFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f15f5453e331e56f9b69a6e72ccfba467ab59e8f" translate="yes" xml:space="preserve">
          <source>The project makes use of a deprecated config file.</source>
          <target state="translated">В проекте используется устаревший конфигурационный файл.</target>
        </trans-unit>
        <trans-unit id="c7aa2521596d9cb923517dba0d10349946353eba" translate="yes" xml:space="preserve">
          <source>The prototype of this hook for a type &lt;code&gt;T&lt;/code&gt; needs to be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620c5eb2026cba7aa4895fcb3b5e5d494f483084" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;DivByZeroDefect&lt;/code&gt; inherits from &lt;code&gt;Defect&lt;/code&gt; and with &lt;code&gt;--panics:on&lt;/code&gt; Defects become unrecoverable errors. (Since version 1.4 of the language.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93069592ba4d6f8e60f9caaf9f5719067988adf0" translate="yes" xml:space="preserve">
          <source>The reason for this is that code like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9881783f395bf3db49786bb66c14efa31cbb346" translate="yes" xml:space="preserve">
          <source>The reason is that sets are implemented as high performance bit vectors. Attempting to declare a set with a larger type will result in an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0151e7d00a06bf727dbd72da71ba5ce97b155194" translate="yes" xml:space="preserve">
          <source>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the &lt;code&gt;echo&lt;/code&gt; statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactivated with the &lt;code&gt;--patterns:off&lt;/code&gt; command line option or temporarily with the &lt;code&gt;patterns&lt;/code&gt; pragma.</source>
          <target state="translated">Причина в том, что компилятор уже преобразовал 1 в &amp;laquo;1&amp;raquo; для оператора &lt;code&gt;echo&lt;/code&gt; . Однако макрос перезаписи терминов в любом случае не должен изменять семантику. Фактически, их можно отключить с помощью &lt;code&gt;--patterns:off&lt;/code&gt; командной строки --patterns: off или временно с помощью директивы &lt;code&gt;patterns&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="944e6805f1095e70b434b5bd328b942c9eebd4e8" translate="yes" xml:space="preserve">
          <source>The reasoning is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f950b9dc37be83169d340916b25b6ad1600d2a00" translate="yes" xml:space="preserve">
          <source>The reimplementation of this code as a compile time proc will allow us to get rid of the &lt;code&gt;data.cfg&lt;/code&gt; file we would need to distribute along the binary, plus if the information is really constant, it doesn't make from a logical point of view to have it &lt;em&gt;mutable&lt;/em&gt; in a global variable, it would be better if it was a constant. Finally, and likely the most valuable feature, we can implement some verification at compile time. You could think of this as a &lt;em&gt;better unit testing&lt;/em&gt;, since it is impossible to obtain a binary unless everything is correct, preventing you to ship to users a broken program which won't start because a small critical file is missing or its contents changed by mistake to something invalid.</source>
          <target state="translated">Повторная реализация этого кода в качестве процедуры времени компиляции позволит нам избавиться от файла &lt;code&gt;data.cfg&lt;/code&gt; , который нам потребуется распространять по двоичному файлу, плюс, если информация действительно постоянна, с логической точки зрения это не делает чтобы он &lt;em&gt;изменялся&lt;/em&gt; в глобальной переменной, было бы лучше, если бы это была константа. Наконец, и это, вероятно, самая ценная функция, мы можем реализовать некоторую проверку во время компиляции. Вы можете думать об этом как о &lt;em&gt;лучшем модульном тестировании&lt;/em&gt; , поскольку невозможно получить двоичный файл, если все не правильно, что не позволяет вам отправить пользователям неработающую программу, которая не запускается из-за отсутствия небольшого критического файла или его содержимого, измененного на ошибка к чему-то недействительному.</target>
        </trans-unit>
        <trans-unit id="bd941de653f278721095a2c43367c41906f6489e" translate="yes" xml:space="preserve">
          <source>The relationship of type to suffix is made by the proc &lt;code&gt;complexName&lt;/code&gt; in the &lt;code&gt;compiler/docgen.nim&lt;/code&gt; file. Here are some examples of complex names for symbols in the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt;.</source>
          <target state="translated">Связь типа с суффиксом устанавливается параметром proc &lt;code&gt;complexName&lt;/code&gt; в файле &lt;code&gt;compiler/docgen.nim&lt;/code&gt; . Вот несколько примеров сложных имен для символов в &lt;a href=&quot;system&quot;&gt;системном модуле&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf0a82f5d893e438a2023ce750bc90f2a128096" translate="yes" xml:space="preserve">
          <source>The removal of existing files.</source>
          <target state="translated">Удаление существующих файлов.</target>
        </trans-unit>
        <trans-unit id="d6fd935f249c62b7608872cee19d42012edb0e86" translate="yes" xml:space="preserve">
          <source>The replace filter replaces substrings in each line.</source>
          <target state="translated">Заменяющий фильтр заменяет подложки в каждой строке.</target>
        </trans-unit>
        <trans-unit id="28a78280047d22a351983c3a0d358b7203f54114" translate="yes" xml:space="preserve">
          <source>The representation of the &lt;code&gt;if&lt;/code&gt; expression is subtle, but easy to traverse.</source>
          <target state="translated">Представление выражения &lt;code&gt;if&lt;/code&gt; тонкое, но легко проходимое.</target>
        </trans-unit>
        <trans-unit id="73836858e4d8022cd4c46c9283cbdf6cfe3ad8c7" translate="yes" xml:space="preserve">
          <source>The representation of the if statement is subtle, but easy to traverse. If there is no &lt;code&gt;else&lt;/code&gt; branch, no &lt;code&gt;nnkElse&lt;/code&gt; child exists.</source>
          <target state="translated">Представление оператора if тонкое, но легко проходимое. Если ветки &lt;code&gt;else&lt;/code&gt; нет, &lt;code&gt;nnkElse&lt;/code&gt; дочерний элемент nnkElse не существует.</target>
        </trans-unit>
        <trans-unit id="28c784e74f236c4964b6fd6d91fbb0a37256995f" translate="yes" xml:space="preserve">
          <source>The response's body stream is read synchronously.</source>
          <target state="translated">Поток тела ответа считывается синхронно.</target>
        </trans-unit>
        <trans-unit id="989aceedc601a5b9a5742f1d14477507d7adf53d" translate="yes" xml:space="preserve">
          <source>The rest of the line is treated as a &lt;a href=&quot;re&quot;&gt;regular expression&lt;/a&gt;, so be careful escaping metacharacters like parenthesis.</source>
          <target state="translated">Остальная часть строки рассматривается как &lt;a href=&quot;re&quot;&gt;регулярное выражение&lt;/a&gt; , поэтому будьте осторожны, избегая метасимволов, таких как скобки.</target>
        </trans-unit>
        <trans-unit id="2f33b7db5192f55bbe370f8f53fab1a2ed0374f8" translate="yes" xml:space="preserve">
          <source>The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de3479f33b83e39dae126f685d1475edff6c449" translate="yes" xml:space="preserve">
          <source>The resulting client socket is automatically registered to the dispatcher.</source>
          <target state="translated">Полученное клиентское гнездо автоматически регистрируется на диспетчере.</target>
        </trans-unit>
        <trans-unit id="e81240f3c82766aef65cfde973adbe5730fdaa4e" translate="yes" xml:space="preserve">
          <source>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</source>
          <target state="translated">Результирующий клиент унаследует любые свойства сокета сервера.Например:буферизован ли сокет или нет.</target>
        </trans-unit>
        <trans-unit id="58ccf12c816dba29cdb297d2baa539dbf718b0fd" translate="yes" xml:space="preserve">
          <source>The resulting state is independent of the default random number generator's state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9657a81f7e4e22d5602d19a05daddbb0eed4ab" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;code&gt;len&lt;/code&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10dea8f7818ed973be79228742dcbd3138884e8" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;code&gt;len&lt;/code&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0eda4f937e942666810677280a88be73c7577b" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="translated">Результирующая строка всегда имеет длину &lt;em&gt;len&lt;/em&gt; символов. Ни один ведущий &lt;code&gt;0b&lt;/code&gt; префикс не генерируется.</target>
        </trans-unit>
        <trans-unit id="ea3fa6f05db7b82f91043df8507510ba9b2c0af9" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="translated">Результирующая строка всегда имеет длину &lt;em&gt;len&lt;/em&gt; символов. Ни один ведущий &lt;code&gt;0o&lt;/code&gt; префикс не генерируется.</target>
        </trans-unit>
        <trans-unit id="098958bf62961ccbbf03810cab1ba165ee727606" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;code&gt;prefix&lt;/code&gt; and suffixed with &lt;code&gt;suffix&lt;/code&gt;. Both may be empty strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fdb218e0bbadf017f51aea11eb54c54acabed2" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;em&gt;prefix&lt;/em&gt; and suffixed with &lt;em&gt;suffix&lt;/em&gt;. Both may be empty strings.</source>
          <target state="translated">Результирующая строка имеет префикс &lt;em&gt;prefix&lt;/em&gt; и суффикс &lt;em&gt;суффикса&lt;/em&gt; . Оба могут быть пустыми строками.</target>
        </trans-unit>
        <trans-unit id="403899c0e7f32ab870cef66df940fa7e27c170e3" translate="yes" xml:space="preserve">
          <source>The resulting string may not have a leading zero. Its length is always exactly 3.</source>
          <target state="translated">Результирующая строка может не иметь ведущего нуля.Ее длина всегда равна 3.</target>
        </trans-unit>
        <trans-unit id="f871e21f4ae6359465f4618b9a615e3d90900a7c" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;code&gt;len&lt;/code&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;code&gt;x&lt;/code&gt; is treated as an unsigned value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30afb7397e54c9840f15c6ce3837b090cbb826dc" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;em&gt;len&lt;/em&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;em&gt;x&lt;/em&gt; is treated as an unsigned value.</source>
          <target state="translated">Результирующая строка будет иметь длину ровно &lt;em&gt;len&lt;/em&gt; символов. Префикса типа &lt;code&gt;0x&lt;/code&gt; не создается. &lt;em&gt;x&lt;/em&gt; рассматривается как беззнаковое значение.</target>
        </trans-unit>
        <trans-unit id="6ff39b06bbdb4341a3c2836e93082f26a34a7bb4" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;code&gt;minchars&lt;/code&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90efc9f77052cc77655df5707232ad9216984b9" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;em&gt;minchars&lt;/em&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="translated">Результирующая строка будет иметь минимальную &lt;em&gt;длину minchars&lt;/em&gt; символов. Это достигается добавлением ведущих нулей.</target>
        </trans-unit>
        <trans-unit id="a48658314c6de6bf50c3ec96a319b4bcbf46bc4f" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;code&gt;discardable&lt;/code&gt; pragma:</source>
          <target state="translated">Возвращаемое значение можно неявно игнорировать, если вызываемый proc / итератор был объявлен с помощью &lt;code&gt;discardable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="67bd9c724c4f982734f839921c898bc019482c8d" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;span id=&quot;discardable_1&quot;&gt;discardable&lt;/span&gt; pragma:</source>
          <target state="translated">Возвращаемое значение можно неявно игнорировать, если вызываемый proc / итератор был объявлен с помощью &lt;span id=&quot;discardable_1&quot;&gt;директивы discardable&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="25d8ae7e238e57b8ff1a3ae56dc183c30b437cea" translate="yes" xml:space="preserve">
          <source>The return value is represented inside the body of a routine as the special &lt;span id=&quot;result_3&quot;&gt;result&lt;/span&gt; variable. This allows for a mechanism much like C++'s &quot;named return value optimization&quot; (&lt;span id=&quot;nrvo_1&quot;&gt;NRVO&lt;/span&gt;). NRVO means that the stores to &lt;code&gt;result&lt;/code&gt; inside &lt;code&gt;p&lt;/code&gt; directly affect the destination &lt;code&gt;dest&lt;/code&gt; in &lt;code&gt;let/var dest = p(args)&lt;/code&gt; (definition of &lt;code&gt;dest&lt;/code&gt;) and also in &lt;code&gt;dest = p(args)&lt;/code&gt; (assignment to &lt;code&gt;dest&lt;/code&gt;). This is achieved by rewriting &lt;code&gt;dest = p(args)&lt;/code&gt; to &lt;code&gt;p'(args, dest)&lt;/code&gt; where &lt;code&gt;p'&lt;/code&gt; is a variation of &lt;code&gt;p&lt;/code&gt; that returns &lt;code&gt;void&lt;/code&gt; and receives a hidden mutable parameter representing &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756b0797d628461ffc91c206ce4262901afa5425" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;StringTableRef&lt;/code&gt; contains the parameters used by the HTML engine to build the final output. For information on what these parameters are and their purpose, please look up the file &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; bundled with the compiler.</source>
          <target state="translated">Возвращается &lt;code&gt;StringTableRef&lt;/code&gt; содержит параметры , используемые в HTML двигателя для создания окончательного вывода. Для получения информации об этих параметрах и их назначении, пожалуйста, посмотрите файл &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; , поставляемый с компилятором.</target>
        </trans-unit>
        <trans-unit id="6d314e6c213f7dc11b7be0a941b6f5bc49b81919" translate="yes" xml:space="preserve">
          <source>The returned Future will complete once all data has been written to the specified file.</source>
          <target state="translated">Возвращаемое будущее будет завершено,как только все данные будут записаны в указанный файл.</target>
        </trans-unit>
        <trans-unit id="08ac274d072334662c000b3093ec54665996d6d3" translate="yes" xml:space="preserve">
          <source>The returned string will have a rune-length of &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218ffc3b441a9be3f8e18751df3ec6089a753864" translate="yes" xml:space="preserve">
          <source>The root of Nim's object hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64043b281b98efb8bb51554afb42ae2b90889a5c" translate="yes" xml:space="preserve">
          <source>The rope's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d420b4d0177cf52670fb1bd5d6c63c44491d8117" translate="yes" xml:space="preserve">
          <source>The rules for compile-time computability are:</source>
          <target state="translated">Правила для вычислительной способности во время компиляции:</target>
        </trans-unit>
        <trans-unit id="698e091efe4e128cb702c79882a2f45f056f90d7" translate="yes" xml:space="preserve">
          <source>The same action can also be performed asynchronously, simply use the &lt;code&gt;AsyncHttpClient&lt;/code&gt;:</source>
          <target state="translated">То же действие можно выполнить и асинхронно, просто используйте &lt;code&gt;AsyncHttpClient&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cf055ae5d7a11813fee9e56f81604099749907aa" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#*,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 * s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57a0f5b14742d12c24988b74a643647d6e014cc" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#*,IntSet,IntSet&quot;&gt;s1 * s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59178c6fa7f1c2f8547f8456a1befc217b20ce51" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#+,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 + s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c0ab47b65053cfe4fbb0c1f52fae0d0a057a41" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#+,IntSet,IntSet&quot;&gt;s1 + s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c286bec2a1c010ec13fa9455c84850edbfabf8eb" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#-+-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 -+- s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d2fb012b48cb0f33fa8dd5795c16758b107e2e" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 - s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a04f27a87dc64a5b3af5f2bfeab96ab2befb96" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#-,IntSet,IntSet&quot;&gt;s1 - s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d403d0a3158f7f9caf11718e934542bcbbcbf185" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#escape,string&quot;&gt;result.add(escape(s))&lt;/a&gt;, but more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55203671983834678f68df32a8f13dbf4dfa1cb5" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#joinPath,string,string&quot;&gt;joinPath(head, tail) proc&lt;/a&gt;, but works with any number of directory parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a036f8c2bc8d6fd4f9810b2d917dd44dc9677256" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#joinPath,string,string&quot;&gt;joinPath(head, tail) proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8108fe45337e2b675ce1f770f1401249335850" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;add(s, formatstr % a)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">То же, что и &lt;code&gt;add(s, formatstr % a)&lt;/code&gt; , но более эффективно.</target>
        </trans-unit>
        <trans-unit id="eea3f061ff9424cd86d52bd3cac8dfd6e94a7529" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</source>
          <target state="translated">То же, что и &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4562377386ad596a9d2e194a9741b56a7124917" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt; unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="translated">То же, что и &lt;code&gt;parentDir(head) / tail&lt;/code&gt; если нет родительского каталога. Затем вместо этого выполняется &lt;code&gt;head / tail&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10d5f7b5b9b4599f963f76e595b9d0bc51dbc7a3" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt;, unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896b7a919e5c694aa0a0d238075545c1cae1c488" translate="yes" xml:space="preserve">
          <source>The same as &lt;em&gt;joinPath(head, tail)&lt;/em&gt;, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.</source>
          <target state="translated">То же, что и &lt;em&gt;joinPath (голова, хвост)&lt;/em&gt; , но работает с любым количеством частей каталога. Вам необходимо передать хотя бы один элемент, иначе процедура будет утверждена в отладочных сборках и выйдет из строя при выпуске сборок.</target>
        </trans-unit>
        <trans-unit id="25fcdd3704177b32025508d9d8dc540fb2c73caa" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;итератор rsplit&lt;/a&gt; , но это процедура, возвращающая последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="db09ba6be055ec25fc71a3c77b55d883dbb50574" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;итератор rsplit&lt;/a&gt; , но это процедура, возвращающая последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="872080f867045c7487dbf61ec0245aa4502cb8a8" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;итератор rsplit&lt;/a&gt; , но это процедура, возвращающая последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="0508e509b698b4d6f0cf31d5f5b62a59d7f990ff" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int,bool&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05c9b483502198e61912440774377608b767850" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,Rune,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488ed57d23acd7e77b2caaf8042dc1813401cb26" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5fe058f47f2922444e3cdf8a11480b26b2bdc0" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что &lt;a href=&quot;#split.i,string,char,int&quot;&gt;итератор разделения&lt;/a&gt; , но представляет собой процедуру, возвращающую последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="80aaf3a3a6c939a3044bf2ae3e445580283d1045" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,openArray%5BRune%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7e1196d1ae854b5b7db4b886b04c7902d49fd4" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55216d0743f38afb17e58bb0b29813f0ebcc2b0b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;итератор разделения&lt;/a&gt; , но представляет собой процедуру, возвращающую последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="c568df5237500459922db2d4a0ccbe43081cd83d" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6bd26725a590268da07c53a69dedbe58085e4ed" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что итератор &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; , но представляет собой процедуру, возвращающую последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="40c1516e7e4a0fb4ec604559d5cf4d9baa2aacc6" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1418168f1b08c4b0979b645260ef3e9404a43e" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155ce31bc857a624f4b637a724b282d2d7a0299b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">То же, что итератор &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; , но процедура, возвращающая последовательность подстрок.</target>
        </trans-unit>
        <trans-unit id="054a8e23aeaf85595c411958cf0af98d8322986e" translate="yes" xml:space="preserve">
          <source>The same could have been achieved by manually iterating over a container and increasing each key's value with &lt;a href=&quot;#inc,CountTable%5BA%5D,A,Positive&quot;&gt;inc proc&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f55c7794b6e447d4540977b35266563d3b8496" translate="yes" xml:space="preserve">
          <source>The same syntax applies to &lt;code&gt;iterator&lt;/code&gt; (with &lt;code&gt;nnkIteratorTy&lt;/code&gt;), but &lt;em&gt;does not&lt;/em&gt; apply to &lt;code&gt;converter&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">Тот же синтаксис применяется к &lt;code&gt;iterator&lt;/code&gt; (с &lt;code&gt;nnkIteratorTy&lt;/code&gt; ), но &lt;em&gt;не&lt;/em&gt; применяется к &lt;code&gt;converter&lt;/code&gt; или &lt;code&gt;template&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f2b58b4e423bfdce9cdf95cfb670ae8ff6353ae" translate="yes" xml:space="preserve">
          <source>The scanp macro</source>
          <target state="translated">Макрос сканирования</target>
        </trans-unit>
        <trans-unit id="f71ea994a694d8297117d2c188599f3f7350c59a" translate="yes" xml:space="preserve">
          <source>The scope of the view does not matter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f812cc23782ffcc0d24f9418349fe228156d6e09" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;code&gt;*&lt;/code&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c86c735cf43c50791d8029b9f0a87ffd482fd7f" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;em&gt;*&lt;/em&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="translated">Второй оператор &lt;em&gt;*&lt;/em&gt; должен быть параметром; он используется для сбора всех аргументов. Выражение &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; передается &lt;code&gt;optConc&lt;/code&gt; в в специальный список (благостного &lt;code&gt;nkArgList&lt;/code&gt; ) , который сглажен в выражении вызова; таким образом, вызов &lt;code&gt;optConc&lt;/code&gt; производит: &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ae0df5a264f4266cdb5160062cd0aaa33125c37" translate="yes" xml:space="preserve">
          <source>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying &lt;code&gt;operation&lt;/code&gt;.</source>
          <target state="translated">В последовательности должен быть хотя бы один элемент. В этой ситуации будут утверждены отладочные версии вашей программы, но релизные версии будут успешно реализованы. Если в последовательности есть один элемент, он будет возвращен без применения &lt;code&gt;operation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de05e83beaaac1f274966bd69ab8d48a0491b166" translate="yes" xml:space="preserve">
          <source>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:</source>
          <target state="translated">Тип набора моделирует математическое понятие набора.Базой множества может быть только порядковый тип определенного размера,а именно:</target>
        </trans-unit>
        <trans-unit id="aa01d82d61dfce28cfeda16c5bd80e4dbed31204" translate="yes" xml:space="preserve">
          <source>The setrlimit() system calls sets resource limits.</source>
          <target state="translated">Системные вызовы setrlimit()устанавливают лимиты ресурсов.</target>
        </trans-unit>
        <trans-unit id="ab78f0eb24b2a7eb5c7e5cc08857a1e481515b9a" translate="yes" xml:space="preserve">
          <source>The shallow copy only changes the semantics for sequences and strings (and types which contain those).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b11bf3cb2bd50300b9f5b036f32f39ad404f4b8" translate="yes" xml:space="preserve">
          <source>The signature has to be:</source>
          <target state="translated">Подпись должна быть:</target>
        </trans-unit>
        <trans-unit id="10ae4b49d52a242d61113b259ec4828eb2835c64" translate="yes" xml:space="preserve">
          <source>The simple case of &lt;code&gt;x = x&lt;/code&gt; cannot be turned into &lt;code&gt;=sink(x, x); wasMoved(x)&lt;/code&gt; because that would lose &lt;code&gt;x&lt;/code&gt;'s value. The solution is that simple self-assignments are simply transformed into an empty statement that does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bed7f833a05e8210ed42f0ce7ddfee8765659dd" translate="yes" xml:space="preserve">
          <source>The size of the bool type is one byte.</source>
          <target state="translated">Размер шерсти-один байт.</target>
        </trans-unit>
        <trans-unit id="d6a8c97ed2a17dc44a3f97e1801a8e2cbc5ffe6e" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">Наименьшее положительное (ненулевое)число,которое может быть представлено в 32-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="37339a476e0f2e7116d49064ea767be2f3f7d153" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">Наименьшее положительное (ненулевое)число,которое может быть представлено в 64-битном типе с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="0f3394967223653ae65cfbae0dc744d9696343e6" translate="yes" xml:space="preserve">
          <source>The socket file path is operating system specific and distribution specific, additional configuration may or may not be needed on your &lt;code&gt;postgresql.conf&lt;/code&gt;. The Postgres server must be on the same computer and only works for Unix-like operating systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5780ad9a486e96ea340daaaf93bd9d64035e65" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;strong&gt;re-play&lt;/strong&gt; the module's top level statements. This solves the problem without having to special case the logic that fills the internal seqs which are affected by the pragmas.</source>
          <target state="translated">Решение состоит в том, чтобы &lt;strong&gt;повторно воспроизвести&lt;/strong&gt; операторы верхнего уровня модуля. Это решает проблему без особого случая логики, заполняющей внутренние последовательности, на которые влияют прагмы.</target>
        </trans-unit>
        <trans-unit id="15c408b85fe2405afe9a50555d39cb72fd864c66" translate="yes" xml:space="preserve">
          <source>The solution is to define &lt;code&gt;proc `=destroy`[T](f: var Foo[T])&lt;/code&gt; before it is used. The compiler generates implicit hooks for all types in &lt;em&gt;strategic places&lt;/em&gt; so that an explicitly provided hook that comes too &quot;late&quot; can be detected reliably. These &lt;em&gt;strategic places&lt;/em&gt; have been derived from the rewrite rules and are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9449ed4a1afa5ff8ca6796adc72142c21a9e0e84" translate="yes" xml:space="preserve">
          <source>The source line that triggered a diagnostic message.</source>
          <target state="translated">Строка-источник,вызвавшая диагностическое сообщение.</target>
        </trans-unit>
        <trans-unit id="799e7aa051d179767ffba8160a4bb2cdfa09b721" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">Специальная переменная &lt;code&gt;result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68b5ebd6f219423fa1db061ea18fb296f76e1f9f" translate="yes" xml:space="preserve">
          <source>The square brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional element.</source>
          <target state="translated">Квадратные скобки &lt;code&gt;[]&lt;/code&gt; указывают на необязательный элемент.</target>
        </trans-unit>
        <trans-unit id="f2a70efe37ccaad3ecc8b9b1191dbd149f70e953" translate="yes" xml:space="preserve">
          <source>The standard distribution ships with the following tools:</source>
          <target state="translated">Стандартные распределительные суда со следующими инструментами:</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">Стандартный поток ошибок.</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">Стандартный входной поток.</target>
        </trans-unit>
        <trans-unit id="0c3f75a49135f9016942ef1a6c30dd582e32a67d" translate="yes" xml:space="preserve">
          <source>The standard library can be avoided to a point where C code generation for 16bit micro controllers is feasible. Use the &lt;span id=&quot;standalone_1&quot;&gt;standalone&lt;/span&gt; target (&lt;code&gt;--os:standalone&lt;/code&gt;) for a bare bones standard library that lacks any OS features.</source>
          <target state="translated">Стандартной библиотеки можно избежать до такой степени, что генерация кода C для 16-битных микроконтроллеров станет возможной. Используйте &lt;span id=&quot;standalone_1&quot;&gt;автономную&lt;/span&gt; цель ( &lt;code&gt;--os:standalone&lt;/code&gt; ) для простой стандартной библиотеки, в которой отсутствуют какие-либо функции ОС.</target>
        </trans-unit>
        <trans-unit id="3bbcfca9d43af60421b59aa297f2843d4ff476d7" translate="yes" xml:space="preserve">
          <source>The standard library supports a growing number of &lt;code&gt;useX&lt;/code&gt; conditional defines affecting how some features are implemented. This section tries to give a complete list.</source>
          <target state="translated">Стандартная библиотека поддерживает все большее количество условных определений &lt;code&gt;useX&lt;/code&gt; , влияющих на реализацию некоторых функций. В этом разделе делается попытка дать полный список.</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">Стандартный выходной поток.</target>
        </trans-unit>
        <trans-unit id="e587b063e208685c74c0b90958dc5ab40a14e654" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed in sequential order unless an exception &lt;code&gt;e&lt;/code&gt; is raised. If the exception type of &lt;code&gt;e&lt;/code&gt; matches any listed in an &lt;code&gt;except&lt;/code&gt; clause the corresponding statements are executed. The statements following the &lt;code&gt;except&lt;/code&gt; clauses are called &lt;span id=&quot;exception-handlers_1&quot;&gt;exception handlers&lt;/span&gt;.</source>
          <target state="translated">Операторы после &lt;code&gt;try&lt;/code&gt; выполняются в последовательном порядке, если не возникает исключение &lt;code&gt;e&lt;/code&gt; . Если тип исключения &lt;code&gt;e&lt;/code&gt; соответствует любому из перечисленных в разделе &lt;code&gt;except&lt;/code&gt; , выполняются соответствующие операторы. Операторы, следующие &lt;code&gt;except&lt;/code&gt; предложениями except , называются &lt;span id=&quot;exception-handlers_1&quot;&gt;обработчиками исключений&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="5e42bdb57f1a751ebb6ae75640b75ab4a37accc2" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed unless an exception is raised. Then the appropriate &lt;code&gt;except&lt;/code&gt; part is executed.</source>
          <target state="translated">Операторы после &lt;code&gt;try&lt;/code&gt; выполняются, если не возникает исключение. Затем выполняется соответствующая часть &lt;code&gt;except&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f3324ba035483cd423641c95748bc8274785628" translate="yes" xml:space="preserve">
          <source>The statements do not open a new scope.</source>
          <target state="translated">Эти заявления не открывают новых возможностей.</target>
        </trans-unit>
        <trans-unit id="885e9c28443dfee3e864ed46b2792fa6eef8a60c" translate="yes" xml:space="preserve">
          <source>The statements that belong to the expression that evaluated to true are translated by the compiler, the other statements are not checked for semantics! However, each condition is checked for semantics.</source>
          <target state="translated">Операции,принадлежащие выражению,которое оценивалось как истинное,транслируются компилятором,остальные операторы не проверяются на семантику! Однако каждое условие проверяется на семантику.</target>
        </trans-unit>
        <trans-unit id="e6d4574c29f988390f3a56cfec01b716ffdcfb61" translate="yes" xml:space="preserve">
          <source>The statements within a branch do not open a new scope.</source>
          <target state="translated">Заявления в филиале не открывают новой области применения.</target>
        </trans-unit>
        <trans-unit id="4e30151d5e9f17c8b266d5c2ebc2ca35ea0c04ba" translate="yes" xml:space="preserve">
          <source>The status of a test when it is done.</source>
          <target state="translated">Статус теста,когда он будет выполнен.</target>
        </trans-unit>
        <trans-unit id="fd60c4990adcd88d94b2b574d1d8c68d1fefb098" translate="yes" xml:space="preserve">
          <source>The stdlib API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">API stdlib разработан, чтобы быть &lt;strong&gt;простым в использовании&lt;/strong&gt; и последовательным. Простота использования измеряется количеством вызовов для достижения конкретного действия высокого уровня. Конечная цель состоит в том, чтобы программист мог &lt;em&gt;угадать&lt;/em&gt; имя.</target>
        </trans-unit>
        <trans-unit id="10b2a953237a037ac2265ff58952966ca750b340" translate="yes" xml:space="preserve">
          <source>The stdtmpl filter provides a simple templating engine for Nim. The filter uses a line based parser: Lines prefixed with a &lt;em&gt;meta character&lt;/em&gt; (default: &lt;code&gt;#&lt;/code&gt;) contain Nim code, other lines are verbatim. Because indentation-based parsing is not suited for a templating engine, control flow statements need &lt;code&gt;end X&lt;/code&gt; delimiters.</source>
          <target state="translated">Фильтр stdtmpl предоставляет простой движок шаблонов для Nim. Фильтр использует синтаксический анализатор на основе строк: строки с префиксом &lt;em&gt;метасимвола&lt;/em&gt; (по умолчанию: &lt;code&gt;#&lt;/code&gt; ) содержат код Nim, остальные строки дословно. Поскольку синтаксический анализ на основе отступов не подходит для механизма шаблонов, операторы потока управления нуждаются в &lt;code&gt;end X&lt;/code&gt; разделителях X.</target>
        </trans-unit>
        <trans-unit id="e5d4338933c9dd8ab3f051eed916bf14cdb0d76c" translate="yes" xml:space="preserve">
          <source>The strategy the GC should use for the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d853705ac2e16ddbf20df344526fe76e5bbe1d6b" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;exportc&lt;/code&gt; can be a format string:</source>
          <target state="translated">Строковый литерал, переданный в &lt;code&gt;exportc&lt;/code&gt; , может быть форматной строкой:</target>
        </trans-unit>
        <trans-unit id="bc021537db9d4c37bc85c30ff44582b67a30832c" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;importc&lt;/code&gt; can be a format string:</source>
          <target state="translated">Строковый литерал, переданный в &lt;code&gt;importc&lt;/code&gt; , может быть строкой формата:</target>
        </trans-unit>
        <trans-unit id="05489799940a31c90df60dd618dd0c7f6fe09df5" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2a1a53ec06666d804727e437f2a83c5ef106f3" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">Оператор строкового преобразования для аргумента CString. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в строку.</target>
        </trans-unit>
        <trans-unit id="7a06837bf4de8313fb2e9c2730a787782961e97b" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;code&gt;x&lt;/code&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c484fec0f015605339671fc06ee766d4baaf377e" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;em&gt;x&lt;/em&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="translated">Оператор строкового преобразования для логического аргумента. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в строку &amp;laquo;false&amp;raquo; или &amp;laquo;true&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="97314c01ab906677fa54e8f600a637d1ff872572" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a992e6797c902629fdda65b889cba064825234dc" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">Оператор строкового преобразования для символьного аргумента. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в строку.</target>
        </trans-unit>
        <trans-unit id="c2e8846dafca6b75fda15855933500c8558f80ec" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e3fe4dd1865173eb89990a7d7f5be7c43387f1" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">Оператор строкового преобразования для аргумента с плавающей запятой. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в десятичную строку.</target>
        </trans-unit>
        <trans-unit id="896f93db18d37ef803d588829b7730d608bde104" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;code&gt;x&lt;/code&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0db5c9df492c1a8b3dd9a2a95f9cef2f3e526af" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;em&gt;x&lt;/em&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="translated">Оператор строкового преобразования для строкового аргумента. Возвращает &lt;em&gt;x&lt;/em&gt; как есть. Этот оператор полезен для универсального кода, поэтому &lt;code&gt;$expr&lt;/code&gt; также работает, если &lt;code&gt;expr&lt;/code&gt; уже является строкой.</target>
        </trans-unit>
        <trans-unit id="d96bb71e7e76d2204fee18b469a16a8c12a66807" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee7503135fe164e7c14568404ab5024b8abba0c" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a &lt;code&gt;$&lt;/code&gt; operator for a concrete enumeration is provided, this is used instead. (In other words: &lt;em&gt;Overwriting&lt;/em&gt; is possible.)</source>
          <target state="translated">Оператор строкового преобразования для аргумента перечисления. Это работает для любого типа перечисления благодаря магии компилятора. Если для конкретного перечисления предоставляется оператор &lt;code&gt;$&lt;/code&gt; , он используется вместо него. (Другими словами: &lt;em&gt;перезапись&lt;/em&gt; возможна.)</target>
        </trans-unit>
        <trans-unit id="be489908ae882068231cbc7ae61f4debc3aca159" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df8dc0dea2441955def02eb0211ebe5babe803f" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e386bfe78072559f8bbde8532560130a6e7ea6ed" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">Оператор строкового преобразования для целочисленного аргумента. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в десятичную строку.</target>
        </trans-unit>
        <trans-unit id="606e2a47ef9a1510fef08559a8704f9cc52bd2a6" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="translated">Оператор строкового преобразования для целочисленного аргумента. Возвращает &lt;em&gt;x,&lt;/em&gt; преобразованный в десятичную строку. &lt;code&gt;$&lt;/code&gt; - это общий способ написания &lt;span id=&quot;tostring_1&quot;&gt;toString в&lt;/span&gt; Ниме .</target>
        </trans-unit>
        <trans-unit id="a3505dd46d9ecade26aad746ee7fe8677daef894" translate="yes" xml:space="preserve">
          <source>The stringify operator for an unsigned integer argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df81e6c55f80fcc8fa6ae2e9828d9cd7028b723f" translate="yes" xml:space="preserve">
          <source>The strip filter simply removes leading and trailing whitespace from each line.</source>
          <target state="translated">Полосовой фильтр просто удаляет лидирующие и скользящие пробелы из каждой линии.</target>
        </trans-unit>
        <trans-unit id="8354da2777d5d9c0570db388afcea4a685a09419" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is an optional argument passed to &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">Подвыражение после двоеточия ( &lt;code&gt;arg&lt;/code&gt; в &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; ) является необязательным аргументом, передаваемым в &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a624d4584bba9b7ac9d39da2c584be5b0d22cc6" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is optional. It will be passed as the last argument to &lt;code&gt;formatValue&lt;/code&gt;. When the colon with the subexpression it is left out, an empty string will be taken instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085f167d1954a66b4d663e11ef8c099c5beed236" translate="yes" xml:space="preserve">
          <source>The subset is in fact the full language with the following restrictions / changes:</source>
          <target state="translated">Подмножество на самом деле является полным языком со следующими ограничениями/изменениями:</target>
        </trans-unit>
        <trans-unit id="13d7858966cc6cd5e4db4c4d41318b516b21b8a4" translate="yes" xml:space="preserve">
          <source>The substitution character introduces a Nim expression &lt;em&gt;e&lt;/em&gt; within the string literal. &lt;em&gt;e&lt;/em&gt; is converted to a string with the &lt;em&gt;toString&lt;/em&gt; operation which defaults to &lt;code&gt;$&lt;/code&gt;. For strong type checking, set &lt;code&gt;toString&lt;/code&gt; to the empty string. &lt;em&gt;e&lt;/em&gt; must match this PEG pattern:</source>
          <target state="translated">Символ подстановки вводит выражение Nim &lt;em&gt;e&lt;/em&gt; в строковом литерале. &lt;em&gt;e&lt;/em&gt; преобразуется в строку с помощью операции &lt;em&gt;toString,&lt;/em&gt; которая по умолчанию равна &lt;code&gt;$&lt;/code&gt; . Для строгой проверки типов установите для параметра &lt;code&gt;toString&lt;/code&gt; пустую строку. &lt;em&gt;e&lt;/em&gt; должен соответствовать этому шаблону PEG:</target>
        </trans-unit>
        <trans-unit id="167b71fcfef3ed3730604fc6b40f66159f634c79" translate="yes" xml:space="preserve">
          <source>The substitution variables (the thing after the &lt;code&gt;$&lt;/code&gt;) are enumerated from 1 to &lt;code&gt;a.len&lt;/code&gt;. To produce a verbatim &lt;code&gt;$&lt;/code&gt;, use &lt;code&gt;$$&lt;/code&gt;. The notation &lt;code&gt;$#&lt;/code&gt; can be used to refer to the next substitution variable:</source>
          <target state="translated">Переменные подстановки (вещь после &lt;code&gt;a.len&lt;/code&gt; &lt;code&gt;$&lt;/code&gt; ) пронумерованы от 1 до a.len . Чтобы получить дословный знак &lt;code&gt;$&lt;/code&gt; , используйте &lt;code&gt;$$&lt;/code&gt; . Обозначение &lt;code&gt;$#&lt;/code&gt; может использоваться для обозначения следующей переменной подстановки:</target>
        </trans-unit>
        <trans-unit id="d363d1e70588dfd25d1127db5f03a916d9f112a5" translate="yes" xml:space="preserve">
          <source>The suite will run the individual test cases in the order in which they were listed. With default global settings the above code prints:</source>
          <target state="translated">Комплект будет выполнять отдельные тестовые случаи в том порядке,в котором они были перечислены.При глобальных настройках по умолчанию приведенный выше код распечатывается:</target>
        </trans-unit>
        <trans-unit id="58f6801df2beac64305a6335b8896742f456c35c" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;fd&lt;/code&gt;'s non-blocking state will be enabled implicitly.</source>
          <target state="translated">Неблокирующее состояние предоставленного &lt;code&gt;fd&lt;/code&gt; будет включено неявно.</target>
        </trans-unit>
        <trans-unit id="80f2150ae39427c1e80e64b88f0a9a85b61d40f9" translate="yes" xml:space="preserve">
          <source>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</source>
          <target state="translated">Правила связывания символов в дженериках несколько неуловимы:есть &quot;открытые&quot; и &quot;закрытые&quot; символы.Символ &quot;закрытый&quot; не может быть переплетен в контексте инстанцирования,символ &quot;открытый&quot; может быть переплетен.По умолчанию перегруженные символы являются открытыми,а все остальные символы закрыты.</target>
        </trans-unit>
        <trans-unit id="1b8df85fe6e5d00af794928d133e0df6b4e79a93" translate="yes" xml:space="preserve">
          <source>The symbol's &lt;code&gt;ast&lt;/code&gt; field is loaded lazily, on demand. This is where most savings come from, only the shallow outer AST is reconstructed immediately.</source>
          <target state="translated">Поле &lt;code&gt;ast&lt;/code&gt; символа загружается лениво, по запросу. Отсюда большая часть экономии, сразу реконструируется только неглубокая внешняя AST.</target>
        </trans-unit>
        <trans-unit id="7bb33000c4f3d80804f12a993711548c0361f873" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A △ B&lt;/em&gt; or &lt;em&gt;A ⊖ B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; but not both at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db37ffc32ca144aebdbca14546aec93600a111e" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A △ B&lt;/em&gt; or &lt;em&gt;A ⊖ B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; or &lt;em&gt;s2&lt;/em&gt; but not both at the same time. Example:</source>
          <target state="translated">Симметричная разность двух множеств математически представлена ​​как &lt;em&gt;A △ B&lt;/em&gt; или &lt;em&gt;A ⊖ B&lt;/em&gt; и представляет собой набор всех объектов, которые являются членами &lt;em&gt;s1&lt;/em&gt; или &lt;em&gt;s2,&lt;/em&gt; но не обоими одновременно. Пример:</target>
        </trans-unit>
        <trans-unit id="bf1dfb4076eebef85539bee43d7712db3fbf93bc" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;-d:flag&lt;/code&gt; is actually just a shortcut for &lt;code&gt;-d:flag=true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a7467e652ab7936684b0f288dffd1681193ff3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; can be used to import multiple modules from the same directory.</source>
          <target state="translated">Синтаксис &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; может использоваться для импорта нескольких модулей из одного каталога.</target>
        </trans-unit>
        <trans-unit id="b40da33c17602bee643c7f4057eb8022801e2460" translate="yes" xml:space="preserve">
          <source>The syntax for iterators is similar to procs, but with &lt;code&gt;nnkIteratorDef&lt;/code&gt; replacing &lt;code&gt;nnkProcDef&lt;/code&gt;.</source>
          <target state="translated">Синтаксис итераторов похож на procs, но &lt;code&gt;nnkIteratorDef&lt;/code&gt; заменяет &lt;code&gt;nnkProcDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e8fda84a4ffe40d2120509d7a72b690281067e4" translate="yes" xml:space="preserve">
          <source>The syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided in height levels accessed through their integer index:</source>
          <target state="translated">Синтаксис для вложенных массивов (многомерных)на других языках-это вопрос добавления дополнительных скобок,потому что обычно каждое измерение ограничено одним и тем же типом индекса,что и другие.В Nim вы можете иметь разные размеры с разными типами индексов,поэтому синтаксис вложенности немного отличается.Основываясь на предыдущем примере,где уровень определяется как массив перечислений,проиндексированных еще одним перечислением,мы можем добавить следующие строки,чтобы добавить тип световой башни,разделенный на уровни высоты,доступ к которым осуществляется через их целочисленный индекс:</target>
        </trans-unit>
        <trans-unit id="0fc163c5356858c1953a68e20f8853fbed990195" translate="yes" xml:space="preserve">
          <source>The syntax for type conversions is &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (like an ordinary call):</source>
          <target state="translated">Синтаксис преобразования типов - &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (как при обычном вызове):</target>
        </trans-unit>
        <trans-unit id="2f95970b03c93b55b855c3143404ffb154e93738" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;case&lt;/code&gt; in an object declaration follows closely the syntax of the &lt;code&gt;case&lt;/code&gt; statement: The branches in a &lt;code&gt;case&lt;/code&gt; section may be indented too.</source>
          <target state="translated">Синтаксис &lt;code&gt;case&lt;/code&gt; в объявлении объекта точно следует синтаксису оператора &lt;code&gt;case&lt;/code&gt; : ветви в разделе &lt;code&gt;case&lt;/code&gt; также могут иметь отступ.</target>
        </trans-unit>
        <trans-unit id="8df91b05c23f64188bd8503b3710389f5709acad" translate="yes" xml:space="preserve">
          <source>The syntax to &lt;em&gt;invoke&lt;/em&gt; a template is the same as calling a procedure.</source>
          <target state="translated">Синтаксис &lt;em&gt;вызова&lt;/em&gt; шаблона такой же, как и при вызове процедуры.</target>
        </trans-unit>
        <trans-unit id="379a9e1787c2fb57f06adcc397630994d8088c6e" translate="yes" xml:space="preserve">
          <source>The syntax tree</source>
          <target state="translated">Синтаксическое дерево</target>
        </trans-unit>
        <trans-unit id="f8025e01a9219586f4ea9ca1e8fe9cf0b016b7a2" translate="yes" xml:space="preserve">
          <source>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the &quot;ast&quot; module for the type definitions. The &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module contains many examples how the AST represents each syntactic structure.</source>
          <target state="translated">Синтаксическое дерево состоит из узлов, которые могут иметь произвольное количество дочерних элементов. Типы и символы представлены другими узлами, поскольку они могут содержать циклы. AST меняет свою форму после семантической проверки. Это нужно, чтобы облегчить жизнь генераторам кода. См. Модуль &quot;ast&quot; для определения типов. Модуль &lt;a href=&quot;macros&quot;&gt;макросов&lt;/a&gt; содержит множество примеров того, как AST представляет каждую синтаксическую структуру.</target>
        </trans-unit>
        <trans-unit id="6a68b38eeb844e67ce71f2a27d7dff2458540f69" translate="yes" xml:space="preserve">
          <source>The syntax, style, and rest of the ecosystem is the same as for compiled Nim, that means there is nothing new to learn, no context switch for developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46885e1cfadfc4a010003eabca5811146f7c040a" translate="yes" xml:space="preserve">
          <source>The syscall convention is the same as &lt;code&gt;__syscall&lt;/code&gt; in C. It is used for interrupts.</source>
          <target state="translated">Соглашение о системных вызовах такое же, как &lt;code&gt;__syscall&lt;/code&gt; в C. Оно используется для прерываний.</target>
        </trans-unit>
        <trans-unit id="7428da08d4a9d661f397c8cd676c7d6536a3f09d" translate="yes" xml:space="preserve">
          <source>The system module defines several common functions for working with strings, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875f0d04dda05e55df0efe79df7f90f4cebd2211" translate="yes" xml:space="preserve">
          <source>The system module defines several common functions, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc67a1994589801e1401cb7812a58cafb42f5561" translate="yes" xml:space="preserve">
          <source>The target type of a cast must be a concrete type, for instance, a target type that is a type class (which is non-concrete) would be invalid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f6bdaaf4d5477f1c500a92aa3e349f56e0070d" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">Команда temp создает компилятор Nim, но с другим окончательным именем ( &lt;code&gt;nim_temp&lt;/code&gt; ), поэтому он не перезаписывает ваш обычный компилятор. Вы можете использовать эту команду для проверки различных параметров, точно так же, как и для команды &lt;a href=&quot;#boot-command&quot;&gt;загрузки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0acf88d3c9384a4ead50fb1f94ad815480237488" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#commands-boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df22e7a1794dd0ef985c2174f0bd9d90ca21bb9" translate="yes" xml:space="preserve">
          <source>The template engine is quite flexible. It is easy to produce a procedure that writes the template code directly to a file:</source>
          <target state="translated">Двигатель шаблонов достаточно гибкий.Легко создать процедуру,которая записывает код шаблона непосредственно в файл:</target>
        </trans-unit>
        <trans-unit id="5d144a85c6f59928edd7f189f3b6401e2a927278" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression.</source>
          <target state="translated">Шаблон вводит переменную &lt;code&gt;it&lt;/code&gt; , которую вы можете использовать непосредственно в выражении.</target>
        </trans-unit>
        <trans-unit id="9b23f79ed77cf3b0ae3ac2cd0d6a1fd2ff5bea88" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. Example:</source>
          <target state="translated">Шаблон вводит переменную &lt;code&gt;it&lt;/code&gt; , которую вы можете использовать непосредственно в выражении. Пример:</target>
        </trans-unit>
        <trans-unit id="71559554774a606802fa41138d874a38d2c3c673" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating.</source>
          <target state="translated">Шаблон вводит переменную &lt;code&gt;it&lt;/code&gt; , которую вы можете использовать непосредственно в выражении. Выражение должно возвращать тот же тип, что и изменяемая последовательность.</target>
        </trans-unit>
        <trans-unit id="7e6285ee4f6bf81ff2cc725be672e1b5b5dc8943" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. You also need to pass as &lt;em&gt;typ&lt;/em&gt; the type of the expression, since the new returned sequence can have a different type than the original.</source>
          <target state="translated">Шаблон вводит переменную &lt;code&gt;it&lt;/code&gt; , которую вы можете использовать непосредственно в выражении. Кроме того, необходимо пройти как &lt;em&gt;типовой&lt;/em&gt; типа выражения, поскольку новая возвращаются последовательность может иметь различный тип , чем оригинал.</target>
        </trans-unit>
        <trans-unit id="a708a430f68cec5b9b3fed13a7aade1b333cf36a" translate="yes" xml:space="preserve">
          <source>The terminating zero cannot be accessed unless the string is converted to the &lt;code&gt;cstring&lt;/code&gt; type first. The terminating zero assures that this conversion can be done in O(1) and without any allocations.</source>
          <target state="translated">К завершающему нулю нельзя получить доступ, если сначала строка не преобразована в тип &lt;code&gt;cstring&lt;/code&gt; . Завершающий ноль гарантирует, что это преобразование может быть выполнено за O (1) и без каких-либо выделений.</target>
        </trans-unit>
        <trans-unit id="6f48e150aa0a5a53af6ca79d3b6ba9e7f7657bf6" translate="yes" xml:space="preserve">
          <source>The test status and name is printed after any output or traceback.</source>
          <target state="translated">Состояние и имя теста печатается после любого вывода или прослеживания.</target>
        </trans-unit>
        <trans-unit id="526c72c6f1f64cc3b20092dd199d521f48bbae6b" translate="yes" xml:space="preserve">
          <source>The third and last way to write string literals are &lt;em&gt;long string literals&lt;/em&gt;. They are written with three quotes: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;; they can span over multiple lines and the &lt;code&gt;\&lt;/code&gt; is not an escape character either. They are very useful for embedding HTML code templates for example.</source>
          <target state="translated">Третий и последний способ записи строковых литералов - &lt;em&gt;длинные строковые литералы&lt;/em&gt; . Они пишутся в трех кавычках: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; ; они могут занимать несколько строк, и &lt;code&gt;\&lt;/code&gt; также не является escape-символом. Они очень полезны, например, для встраивания шаблонов HTML-кода.</target>
        </trans-unit>
        <trans-unit id="c7d0bff946245f3196ff3fec3eab7b5f9ec10e1f" translate="yes" xml:space="preserve">
          <source>The third use of backslash is for specifying &lt;span id=&quot;generic-character-types_1&quot;&gt;generic character types&lt;/span&gt;. The following are always recognized:</source>
          <target state="translated">Третий вариант использования обратной косой черты - для указания &lt;span id=&quot;generic-character-types_1&quot;&gt;общих типов символов&lt;/span&gt; . Всегда признаются:</target>
        </trans-unit>
        <trans-unit id="92af40aeb29e6640bb9de3b1e1701b722a26794f" translate="yes" xml:space="preserve">
          <source>The time (in UTC) of compilation as a string of the form &lt;code&gt;HH:MM:SS&lt;/code&gt;. This works thanks to compiler magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60cef0a4060f4db69c965773dac830d6f50b6aa" translate="yes" xml:space="preserve">
          <source>The timezone represented as an implementation of &lt;code&gt;Timezone&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716122720506770b96f97a3949c5f63d216ca318" translate="yes" xml:space="preserve">
          <source>The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">Символ(и)новой строки удаляется(ются)из итерационных строк.Пример:</target>
        </trans-unit>
        <trans-unit id="088f34b2b9f2860def75b9865d8fa88192adf164" translate="yes" xml:space="preserve">
          <source>The type coercion &lt;code&gt;static(x)&lt;/code&gt; can be used to force the compile-time evaluation of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Тип принуждение &lt;code&gt;static(x)&lt;/code&gt; может использоваться для принудительной оценки времени компиляции данного выражения &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ed681a392a0c61fb28eee2975db81a956d2924e" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; holds.</source>
          <target state="translated">Преобразование типа &lt;code&gt;T(a)&lt;/code&gt; является L-значением, если &lt;code&gt;a&lt;/code&gt; является L-значением и &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b02430bf6ab116f5610a3e7f89fda5b3e78e5ab" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, typeof(a))&lt;/code&gt; holds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7007f414d9f07ec9d9545e70f77c0fb11e2655f" translate="yes" xml:space="preserve">
          <source>The type of a parameter may be prefixed with the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">Тип параметра может быть предварен ключевым словом &lt;code&gt;var&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b4149e9c761a9c5b1d817b72b94a54f51db12381" translate="yes" xml:space="preserve">
          <source>The type representing a file handle.</source>
          <target state="translated">Тип,представляющий файловую рукоятку.</target>
        </trans-unit>
        <trans-unit id="9b4854aa3e47cfa3fa7a0d71ef4763a784b0d2a7" translate="yes" xml:space="preserve">
          <source>The type suffixes are:</source>
          <target state="translated">Типы суффиксов:</target>
        </trans-unit>
        <trans-unit id="4006d5cc88fdabea98a514a10633d32480b50418" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="translated">Типы &lt;code&gt;var T&lt;/code&gt; и &lt;code&gt;typedesc[T]&lt;/code&gt; не могут быть выведены в универсальном экземпляре. Не допускается следующее:</target>
        </trans-unit>
        <trans-unit id="6068d66d8caf9d0bc5e346b69b06b7e22f85d91a" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt;, &lt;code&gt;out T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15965d3cd0f4bb804b8212dddb5431bf9b84d441" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or Javascript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">Типичное использование компилятора включает использование команды &lt;code&gt;compile&lt;/code&gt; или &lt;code&gt;c&lt;/code&gt; для преобразования файла &lt;code&gt;.nim&lt;/code&gt; в один или несколько файлов &lt;code&gt;.c&lt;/code&gt; , которые затем компилируются с помощью компилятора C платформы в статический двоичный файл. Однако есть и другие команды для компиляции в C ++, Objective-C или Javascript. Более подробную информацию можно прочитать в &lt;a href=&quot;backends&quot;&gt;документе Nim Backend Integration&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="733da35309da1a0adc926cfeed7cf9e4972229fa" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However, there are other commands to compile to C++, Objective-C, or JavaScript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0930f393d96d3e129dbb5d95324e49f12cf8fc32" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;https://nim-lang.org/docs/tut2.html#object-oriented-programming-method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc757b9810b94b3278b6f78815badc1d4f6fdea" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;https://nim-lang.org/docs/tut2.html#object-oriented-programming-method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2323beee7c184cc654539984a6ab3af180da6e48" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">Типичным сценарием использования этой опции является ее вызов после того, как пользователь набрал точку для &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;объектно-ориентированного синтаксиса вызова&lt;/a&gt; . Idetools попытается вернуть предложения, отсортированные сначала по области (от самого внутреннего до самого внешнего), а затем по имени элемента.</target>
        </trans-unit>
        <trans-unit id="b45de376a3cd2738b15e943470c78ad94bed4791" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">Типичным сценарием использования этой опции является ее вызов после того, как пользователь набрал точку для &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;объектно-ориентированного синтаксиса вызова&lt;/a&gt; . Nimsuggest попытается вернуть предложения, отсортированные сначала по области действия (от самого внутреннего до самого внешнего), а затем по имени элемента.</target>
        </trans-unit>
        <trans-unit id="22208dbaa100422606e56c7e131a653bc370939f" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; or both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bb924a06b99256d96c42fb02e7ceffd0f6c417" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt; or both. Example:</source>
          <target state="translated">Объединение двух наборов математически представляется как &lt;em&gt;A &amp;cup; B&lt;/em&gt; и представляет собой набор всех объектов, которые являются членами &lt;em&gt;s1&lt;/em&gt; , &lt;em&gt;s2&lt;/em&gt; или обоих. Пример:</target>
        </trans-unit>
        <trans-unit id="d8d1d1447b153afdb0a97fd8b87918bc4140f680" translate="yes" xml:space="preserve">
          <source>The unit of the parameters &lt;code&gt;maxPauseInUs&lt;/code&gt; and &lt;code&gt;us&lt;/code&gt; is microseconds.</source>
          <target state="translated">Единица измерения параметров &lt;code&gt;maxPauseInUs&lt;/code&gt; и &lt;code&gt;us&lt;/code&gt; - микросекунды.</target>
        </trans-unit>
        <trans-unit id="ebb55c959a3f02d3eea1dc9ff808f8bb2abaea44" translate="yes" xml:space="preserve">
          <source>The unsafeAddr operator</source>
          <target state="translated">Оператор небезопасногоAddr</target>
        </trans-unit>
        <trans-unit id="0ef21f06b17eb379f0787340a289e02dd9482513" translate="yes" xml:space="preserve">
          <source>The upload of new files.</source>
          <target state="translated">Загрузка новых файлов.</target>
        </trans-unit>
        <trans-unit id="ffb9dbd8c79b78dedb57dfcf3aa60f5d7e195511" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;concept&lt;/code&gt; (experimental) is similar to objects.</source>
          <target state="translated">Использование &lt;code&gt;concept&lt;/code&gt; (экспериментальное) аналогично объектам.</target>
        </trans-unit>
        <trans-unit id="f9c91fbc8283b9f203886fd420138f36678da171" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;{.inject.}&lt;/code&gt; here is necessary again because of template expansion order and hygienic templates. But since we generally want to keep the hygienicness of &lt;code&gt;myTemplate&lt;/code&gt;, and we do not want &lt;code&gt;arg1&lt;/code&gt; to be injected into the context where &lt;code&gt;myTemplate&lt;/code&gt; is expanded, everything is wrapped in a &lt;code&gt;block&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1da7cd5635c8ed575ed2f00199382fa74a25aa" translate="yes" xml:space="preserve">
          <source>The use of wrappers that use FFI and/or &lt;code&gt;cast&lt;/code&gt; is also disallowed. Note that these wrappers include the ones in the standard libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a559c657b3e94a5a3b4f28ede4f3e541e9898aa" translate="yes" xml:space="preserve">
          <source>The user guide lists command line arguments, special features of the compiler, etc.</source>
          <target state="translated">В руководстве пользователя перечислены аргументы командной строки,особенности компилятора и т.д.</target>
        </trans-unit>
        <trans-unit id="aec3c4c08d9fd434b6b3b95d1925acd83f75de3e" translate="yes" xml:space="preserve">
          <source>The using statement provides syntactic convenience in modules where the same parameter names and types are used over and over. Instead of:</source>
          <target state="translated">Оператор use обеспечивает синтаксическое удобство в модулях,где снова и снова используются одни и те же имена и типы параметров.Вместо:</target>
        </trans-unit>
        <trans-unit id="99d6383e434dd62dcbce9c98ef86b8da04045406" translate="yes" xml:space="preserve">
          <source>The values of the returned enum should be pretty self explanatory:</source>
          <target state="translated">Значения возвращаемого перечисления должны быть довольно понятными:</target>
        </trans-unit>
        <trans-unit id="e580cb29ada1c872bcbdfbf5d59c299cb8b1209f" translate="yes" xml:space="preserve">
          <source>The var statement</source>
          <target state="translated">Вариационное заявление</target>
        </trans-unit>
        <trans-unit id="44981de5f0080cccfda5bafeb275d3e5b51b6196" translate="yes" xml:space="preserve">
          <source>The var statement declares a new local or global variable:</source>
          <target state="translated">Оператор var объявляет новую локальную или глобальную переменную:</target>
        </trans-unit>
        <trans-unit id="a7fb42712b4a095b6edcf947d23562ccc99a3384" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;i&lt;/code&gt; is implicitly declared by the &lt;code&gt;for&lt;/code&gt; loop and has the type &lt;code&gt;int&lt;/code&gt;, because that is what &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; returns. &lt;code&gt;i&lt;/code&gt; runs through the values 1, 2, .., 10. Each value is &lt;code&gt;echo&lt;/code&gt;-ed. This code does the same:</source>
          <target state="translated">Переменная &lt;code&gt;i&lt;/code&gt; неявно объявляется циклом &lt;code&gt;for&lt;/code&gt; и имеет тип &lt;code&gt;int&lt;/code&gt; , потому что именно это возвращает &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; . &lt;code&gt;i&lt;/code&gt; пробегает значения 1, 2, .., 10. Каждое значение отображается &lt;code&gt;echo&lt;/code&gt; . Этот код делает то же самое:</target>
        </trans-unit>
        <trans-unit id="8964df6ead4489b7696bee7b0f5aec240db046f0" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;code&gt;cmpIgnoreStyle&lt;/code&gt;. &lt;code&gt;ValueError&lt;/code&gt; is raised if an ill-formed format string has been passed to the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc84debb5dc6452e51fb2c78cf8623fbed79f8ac" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;em&gt;cmpIgnoreStyle&lt;/em&gt;. &lt;em&gt;ValueError&lt;/em&gt; is raised if an ill-formed format string has been passed to the &lt;em&gt;%&lt;/em&gt; operator.</source>
          <target state="translated">Переменные сравниваются с &lt;em&gt;cmpIgnoreStyle&lt;/em&gt; . &lt;em&gt;ValueError&lt;/em&gt; возникает, если неверно сформированная строка формата была передана оператору &lt;em&gt;%&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="61b57a2d911fc71f98fcabf040635de38c8494ca" translate="yes" xml:space="preserve">
          <source>The version uses &lt;code&gt;cmp&lt;/code&gt; to compare the elements. The expected return values are the same as that of &lt;code&gt;system.cmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66e53fcdb4e533daa1d776499d5013cc08f8baa" translate="yes" xml:space="preserve">
          <source>The version uses the default comparison function &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa9f6f05c0209f1598bd49966b81632306fcee5" translate="yes" xml:space="preserve">
          <source>The while statement is a simple looping construct:</source>
          <target state="translated">В то время как утверждение является простой петлевой конструкцией:</target>
        </trans-unit>
        <trans-unit id="4123d4bcf088a88feae5646d2165ec90f62ac31f" translate="yes" xml:space="preserve">
          <source>The workaround for this is to bind the template argument to a new local variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba71dc483d2c43f3b09cfa11f1f0b476cc3d1fd" translate="yes" xml:space="preserve">
          <source>The year without any padding. Is always positive, even when the year is BC.</source>
          <target state="translated">Год без набивки.Всегда позитивен,даже когда год-это БК.</target>
        </trans-unit>
        <trans-unit id="ab38f01dd3bc85831012f0bac4816fc3e75b4486" translate="yes" xml:space="preserve">
          <source>The year without any padding. Will be negative when the year is BC.</source>
          <target state="translated">Год без набивки.Будет отрицательно когда годом будет BC.</target>
        </trans-unit>
        <trans-unit id="07d07d0ea9f8d13f35a29277409b0f19348eb8f7" translate="yes" xml:space="preserve">
          <source>The year, padded to at least four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dbc322d029aa3d6f32b6486bd07eb9329bc1da" translate="yes" xml:space="preserve">
          <source>The year, padded to at least four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b039a29b58c22bdb2915a3acea080780142c1b28" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="translated">Год,с четырьмя цифрами.Всегда положительный,даже когда год BC.Когда год больше чем 4 цифры,предварено '+'.</target>
        </trans-unit>
        <trans-unit id="2f78eca394ea113bd4e29e67d3fec4d4e88e2b66" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="translated">Год,с четырьмя цифрами.Будет отрицательно когда годом будет BC.Когда год больше чем 4 цифры,&quot;+&quot; предварено если год не BC.</target>
        </trans-unit>
        <trans-unit id="511ad266e7726ce686aa356a227a5ffd4428485f" translate="yes" xml:space="preserve">
          <source>The year, using astronomical year numbering (meaning that before year 1 is year 0, then year -1 and so on).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff8ad7505b8b464009361f8dda42aba0d8ec846" translate="yes" xml:space="preserve">
          <source>Then calls &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">Затем вызывает &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; и после этого закрывает файл. Возвращает строку. Вызывает исключение ввода-вывода в случае ошибки. Если вам нужно вызвать это внутри макроса времени компиляции, вы можете использовать &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="030aaf6f2fc0e5a5cf064da69f557632a5c59e9e" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;A&lt;/code&gt; (that depends on &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;) is compiled and &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; are left unchanged. &lt;code&gt;A&lt;/code&gt; requires &lt;code&gt;G.P2&lt;/code&gt;.</source>
          <target state="translated">Затем модуль &lt;code&gt;A&lt;/code&gt; (который зависит от &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;G&lt;/code&gt; ) компилируется, а &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;G&lt;/code&gt; остаются без изменений. &lt;code&gt;A&lt;/code&gt; требует &lt;code&gt;G.P2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ade512072594e8264ff592564aff0e3bc992458" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;B&lt;/code&gt; is compiled that requires &lt;code&gt;G.P1&lt;/code&gt;. Ok, no problem, &lt;code&gt;G.P1&lt;/code&gt; is loaded from the symbol file and &lt;code&gt;G.c&lt;/code&gt; now contains &lt;code&gt;G.P1&lt;/code&gt;.</source>
          <target state="translated">Затем компилируется модуль &lt;code&gt;B&lt;/code&gt; ,для которого требуется &lt;code&gt;G.P1&lt;/code&gt; . Хорошо, без проблем, &lt;code&gt;G.P1&lt;/code&gt; загружен из файла символов, а &lt;code&gt;G.c&lt;/code&gt; теперь содержит &lt;code&gt;G.P1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a70a722d347238a21f07b6a20009bf20f06664" translate="yes" xml:space="preserve">
          <source>Then move the C code and the compile script &lt;code&gt;compile_myproject.sh&lt;/code&gt; to your Linux i386 machine and run the script.</source>
          <target state="translated">Затем переместите код C и сценарий компиляции &lt;code&gt;compile_myproject.sh&lt;/code&gt; на компьютер с Linux i386 и запустите сценарий.</target>
        </trans-unit>
        <trans-unit id="7f5c1a564b56a99b8a9432588eb7749f18de807c" translate="yes" xml:space="preserve">
          <source>Then there is also the integer literal type. This is a specific type that is implicitly convertible into the requested type if the requested type can hold the value. For this to work, the type needs to know the concrete value of the literal. For example an expression &lt;code&gt;321&lt;/code&gt; will be of type &lt;code&gt;int literal(321)&lt;/code&gt;. This type is implicitly convertible to all integer types and ranges that contain the value &lt;code&gt;321&lt;/code&gt;. That would be all builtin integer types except &lt;code&gt;uint8&lt;/code&gt; and &lt;code&gt;int8&lt;/code&gt; where &lt;code&gt;321&lt;/code&gt; would be out of range. When this literal type is assigned to a new &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; variable, it's type will be resolved to just &lt;code&gt;int&lt;/code&gt;, not &lt;code&gt;int literal(321)&lt;/code&gt; unlike constants. A constant keeps the full &lt;code&gt;int literal(321)&lt;/code&gt; type. Here is an example where that difference matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3224338d78f50a303f4e2d270b284e3310633b0" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f5d4391872d1d0618203f6cd8356fa03af48c8" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size. Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.</source>
          <target state="translated">Есть 2 вида итераторов в Nim: &lt;em&gt;встроенная&lt;/em&gt; и &lt;em&gt;закрытие&lt;/em&gt; итераторы. Встроенный &lt;span id=&quot;inline-iterator_1&quot;&gt;итератор&lt;/span&gt; - это итератор, который всегда встроен компилятором, что приводит к нулевым накладным расходам для абстракции, но может привести к значительному увеличению размера кода. Встроенные итераторы - это граждане второго сорта; Их можно передавать как параметры только в другие средства встраивания кода, такие как шаблоны, макросы и другие встроенные итераторы.</target>
        </trans-unit>
        <trans-unit id="2204cd4df928fb544bb442ca84cde7bf3009d982" translate="yes" xml:space="preserve">
          <source>There are 3 operations that are bound to a type:</source>
          <target state="translated">Есть 3 операции,которые привязаны к типу:</target>
        </trans-unit>
        <trans-unit id="6e58d330c906290a3a72d9bf31c8b364392ece8e" translate="yes" xml:space="preserve">
          <source>There are 4 operations that are bound to a type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a602bfe3df3ce7f6d337cd11a7c7400db183b00" translate="yes" xml:space="preserve">
          <source>There are a few details to keep in mind when using this module within multiple threads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85b79c160e40ebe8ffa7f8d4d317c2a9bf28239" translate="yes" xml:space="preserve">
          <source>There are a few things that don't work because the DevkitPro libraries don't support them. They are:</source>
          <target state="translated">Есть несколько вещей,которые не работают,потому что библиотеки DevkitPro не поддерживают их.Поддерживают:</target>
        </trans-unit>
        <trans-unit id="0ab99b54c858ac8f9d51bf5e5fe33ce55f9ff7f8" translate="yes" xml:space="preserve">
          <source>There are also raw string literals that are preceded with the letter &lt;code&gt;r&lt;/code&gt; (or &lt;code&gt;R&lt;/code&gt;) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:</source>
          <target state="translated">Существуют также необработанные строковые литералы, которым предшествует буква &lt;code&gt;r&lt;/code&gt; (или &lt;code&gt;R&lt;/code&gt; ), они разделяются соответствующими двойными кавычками (как и обычные строковые литералы) и не интерпретируют escape-последовательности. Это особенно удобно для регулярных выражений или путей Windows:</target>
        </trans-unit>
        <trans-unit id="ca885d10f37134acc825e1d0fd4f729e20b0c53b" translate="yes" xml:space="preserve">
          <source>There are currently only two options for verify mode; one is &lt;code&gt;CVerifyNone&lt;/code&gt; and with it certificates will not be verified the other is &lt;code&gt;CVerifyPeer&lt;/code&gt; and certificates will be verified for it, &lt;code&gt;CVerifyPeer&lt;/code&gt; is the safest choice.</source>
          <target state="translated">В настоящее время есть только два варианта режима проверки; один - &lt;code&gt;CVerifyNone&lt;/code&gt; , и сертификаты не будут проверяться; другой - &lt;code&gt;CVerifyPeer&lt;/code&gt; , и сертификаты будут проверены для него, &lt;code&gt;CVerifyPeer&lt;/code&gt; - самый безопасный выбор.</target>
        </trans-unit>
        <trans-unit id="699fd27aa890266a888c5272db783bacf977a6e2" translate="yes" xml:space="preserve">
          <source>There are limitations on what Nim code can be executed at compile time; see &lt;a href=&quot;#restrictions-on-compileminustime-execution&quot;&gt;Restrictions on Compile-Time Execution&lt;/a&gt; for details. It's a static error if the compiler cannot execute the block at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9bd1745d20224197bc6b19e361674c1fbfbfeef" translate="yes" xml:space="preserve">
          <source>There are multiple ways to get around this, including the use of the &lt;code&gt;&amp;amp;&lt;/code&gt; operator:</source>
          <target state="translated">Есть несколько способов обойти это, включая использование оператора &lt;code&gt;&amp;amp;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dfad946c72305fa2959afdaad8dd73249e24fab2" translate="yes" xml:space="preserve">
          <source>There are no constraints for the &lt;code&gt;constructor&lt;/code&gt; AST, it works for nested tuples of arrays of sets etc.</source>
          <target state="translated">Для &lt;code&gt;constructor&lt;/code&gt; AST нет ограничений , он работает для вложенных кортежей массивов наборов и т. Д.</target>
        </trans-unit>
        <trans-unit id="cf947740d972fdc4f2ebc7b27221b71dc35fbb9e" translate="yes" xml:space="preserve">
          <source>There are no specialized &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;contains&lt;/code&gt; procedures for &lt;code&gt;seq[Rune]&lt;/code&gt; in this module because the generic variants of these procedures in the system module already work with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bda84e8a64a9ee0766ebd2e91b0b1fc8bcb50a8" translate="yes" xml:space="preserve">
          <source>There are several different types of hash tables available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9b3d4d5566426791f36142323c5dcdbd575538" translate="yes" xml:space="preserve">
          <source>There are several node kinds that are used for semantic checking or code generation. These are accessible from this module, but should not be used. Other node kinds are especially designed to make AST manipulations easier. These are explained here.</source>
          <target state="translated">Существует несколько типов узлов,которые используются для семантической проверки или генерации кода.Они доступны из этого модуля,но не должны использоваться.Другие типы узлов специально разработаны для облегчения манипуляций с AST.Они объясняются здесь.</target>
        </trans-unit>
        <trans-unit id="3dc14568c01dd285d589a27b7cb9cd2809008967" translate="yes" xml:space="preserve">
          <source>There are six logging levels: debug, info, notice, warn, error, and fatal. They are described in more detail within the &lt;a href=&quot;#Level&quot;&gt;Level enum's documentation&lt;/a&gt;. A message is logged if its level is at or above both the logger's &lt;code&gt;levelThreshold&lt;/code&gt; field and the global log filter. The latter can be changed with the &lt;a href=&quot;#setLogFilter,Level&quot;&gt;setLogFilter proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca8d001ba881fc8c54bf7d03fbbb467af017be5" translate="yes" xml:space="preserve">
          <source>There are three options for verify mode: &lt;code&gt;CVerifyNone&lt;/code&gt;: certificates are not verified; &lt;code&gt;CVerifyPeer&lt;/code&gt;: certificates are verified; &lt;code&gt;CVerifyPeerUseEnvVars&lt;/code&gt;: certificates are verified and the optional environment variables SSL_CERT_FILE and SSL_CERT_DIR are also used to locate certificates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70805ca564aa8b928a6ee8c36e9ffa0c1565c921" translate="yes" xml:space="preserve">
          <source>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">Существует два различных набора мета-символов:те,которые распознаются в любом месте образца,кроме квадратных скобок,и те,которые распознаются в квадратных скобках.За пределами квадратных скобок мета-символы распознаются следующим образом:</target>
        </trans-unit>
        <trans-unit id="9518223ac809befff3867df05b169ff12200b863" translate="yes" xml:space="preserve">
          <source>There are two pseudo directories:</source>
          <target state="translated">Есть два псевдо-каталога:</target>
        </trans-unit>
        <trans-unit id="8e9491c4554d1cf539e490b9c71cd03f4f655289" translate="yes" xml:space="preserve">
          <source>There are two ways to compile for Android: terminal programs (Termux) and with the NDK (Android Native Development Kit).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6623c5091377da7e54f379e771f12aab4eb9ebe" translate="yes" xml:space="preserve">
          <source>There are two ways to construct a PEG in Nim code:</source>
          <target state="translated">Есть два способа сконструировать PEG в Nim-коде:</target>
        </trans-unit>
        <trans-unit id="089b0a2a4fc8aac4d751cf1e71645f608e78c87d" translate="yes" xml:space="preserve">
          <source>There are two ways to invoke a macro:</source>
          <target state="translated">Есть два способа вызвать макрос:</target>
        </trans-unit>
        <trans-unit id="720936a505c479b6845bfb796080ccd89a044a7d" translate="yes" xml:space="preserve">
          <source>There are two ways to write a macro, either &lt;em&gt;generating&lt;/em&gt; Nim source code and letting the compiler parse it, or creating manually an abstract syntax tree (AST) which you feed to the compiler. In order to build the AST one needs to know how the Nim concrete syntax is converted to an abstract syntax tree (AST). The AST is documented in the &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module.</source>
          <target state="translated">Есть два способа написать макрос: либо &lt;em&gt;сгенерировать&lt;/em&gt; исходный код Nim и позволить компилятору проанализировать его, либо создать вручную абстрактное синтаксическое дерево (AST), которое вы скармливаете компилятору. Чтобы построить AST, нужно знать, как конкретный синтаксис Nim преобразуется в абстрактное синтаксическое дерево (AST). AST задокументирован в модуле &lt;a href=&quot;macros&quot;&gt;макросов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9bcbe7393ec87f587011e8d840878f558c1f97b" translate="yes" xml:space="preserve">
          <source>There can be zero or more &lt;code&gt;elif&lt;/code&gt; parts, and the &lt;code&gt;else&lt;/code&gt; part is optional. The keyword &lt;code&gt;elif&lt;/code&gt; is short for &lt;code&gt;else if&lt;/code&gt;, and is useful to avoid excessive indentation. (The &lt;code&gt;&quot;&quot;&lt;/code&gt; is the empty string. It contains no characters.)</source>
          <target state="translated">Частей &lt;code&gt;elif&lt;/code&gt; может быть ноль или более , а часть &lt;code&gt;else&lt;/code&gt; является необязательной. Ключевое слово &lt;code&gt;elif&lt;/code&gt; является сокращением от &lt;code&gt;else if&lt;/code&gt; и полезно, чтобы избежать чрезмерного отступа. ( &lt;code&gt;&quot;&quot;&lt;/code&gt; - это пустая строка. Она не содержит символов.)</target>
        </trans-unit>
        <trans-unit id="a3d437f79271578914f708f4086005edd9d04476" translate="yes" xml:space="preserve">
          <source>There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a &lt;span id=&quot;type-suffix_1&quot;&gt;type suffix&lt;/span&gt;. Literals without a type suffix are of an integer type unless the literal contains a dot or &lt;code&gt;E|e&lt;/code&gt; in which case it is of type &lt;code&gt;float&lt;/code&gt;. This integer type is &lt;code&gt;int&lt;/code&gt; if the literal is in the range &lt;code&gt;low(i32)..high(i32)&lt;/code&gt;, otherwise it is &lt;code&gt;int64&lt;/code&gt;. For notational convenience, the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating-point literals with a type suffix can be ambiguous).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cfdf22bf86043f8acee986bff271197e1936f9" translate="yes" xml:space="preserve">
          <source>There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a &lt;span id=&quot;type-suffix_1&quot;&gt;type suffix&lt;/span&gt;. Literals without a type suffix are of an integer type, unless the literal contains a dot or &lt;code&gt;E|e&lt;/code&gt; in which case it is of type &lt;code&gt;float&lt;/code&gt;. This integer type is &lt;code&gt;int&lt;/code&gt; if the literal is in the range &lt;code&gt;low(i32)..high(i32)&lt;/code&gt;, otherwise it is &lt;code&gt;int64&lt;/code&gt;. For notational convenience the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating point literals with a type suffix can be ambiguous).</source>
          <target state="translated">Для каждого определенного числового типа существует литерал. Суффикс, начинающийся с апострофа ('' '), называется &lt;span id=&quot;type-suffix_1&quot;&gt;суффиксом типа&lt;/span&gt; . Литералы без суффикса типа относятся к целочисленному типу, если литерал не содержит точку или &lt;code&gt;E|e&lt;/code&gt; в этом случае он имеет тип &lt;code&gt;float&lt;/code&gt; . Этот целочисленный тип имеет вид &lt;code&gt;int&lt;/code&gt; , если литерал находится в диапазоне &lt;code&gt;low(i32)..high(i32)&lt;/code&gt; , в противном случае это &lt;code&gt;int64&lt;/code&gt; . Для удобства записи апостроф суффикса типа является необязательным, если он не является неоднозначным (неоднозначными могут быть только шестнадцатеричные литералы с плавающей запятой с суффиксом типа).</target>
        </trans-unit>
        <trans-unit id="90fe0ee868ac44e50e7a55bf1d6f6587b14d23c1" translate="yes" xml:space="preserve">
          <source>There is a syntactic sugar for calling routines: The syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. If there are no remaining arguments, the parentheses can be omitted: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="translated">Существует синтаксический сахар для вызова подпрограмм: синтаксис &lt;code&gt;obj.method(args)&lt;/code&gt; может использоваться вместо &lt;code&gt;method(obj, args)&lt;/code&gt; . Если аргументов не осталось, скобки можно опустить: &lt;code&gt;obj.len&lt;/code&gt; (вместо &lt;code&gt;len(obj)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="809686a502cf19e841efede0ad4446dfca6c035b" translate="yes" xml:space="preserve">
          <source>There is an analysis that checks that &lt;code&gt;counters[i].L&lt;/code&gt; is the lock that corresponds to the protected location &lt;code&gt;counters[i].v&lt;/code&gt;. This analysis is called &lt;span id=&quot;path-analysis_1&quot;&gt;path analysis&lt;/span&gt; because it deals with paths to locations like &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt;.</source>
          <target state="translated">Существует анализ, который проверяет, что &lt;code&gt;counters[i].L&lt;/code&gt; - это блокировка, соответствующая &lt;code&gt;counters[i].v&lt;/code&gt; защищенного местоположения [i] .v . Этот анализ называется &lt;span id=&quot;path-analysis_1&quot;&gt;анализом пути,&lt;/span&gt; потому что он имеет дело с путями к местоположениям, например, &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9be47a2e7d24c1f78266ccdbd346bb776f9d13ab" translate="yes" xml:space="preserve">
          <source>There is another consideration. Nim has flexible type identification for its procs. Even though &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; and &lt;code&gt;proc(a, b: int)&lt;/code&gt; are equivalent in the code, the AST is a little different for the latter.</source>
          <target state="translated">Есть еще одно соображение. У Nim есть гибкая идентификация типа для своих процессов. Несмотря на то, что &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; и &lt;code&gt;proc(a, b: int)&lt;/code&gt; эквивалентны в коде, AST для последнего немного отличается.</target>
        </trans-unit>
        <trans-unit id="ef0bece8693cc3f6cf7cc996e5ec28c503f5ee8c" translate="yes" xml:space="preserve">
          <source>There is no need to check for &lt;code&gt;cmdEnd&lt;/code&gt; while iterating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a21bfca1dc8f206e73873a032f9f2495f5c004" translate="yes" xml:space="preserve">
          <source>These are the major type classes:</source>
          <target state="translated">Это основные классы типа:</target>
        </trans-unit>
        <trans-unit id="c9f26df48cd633ca6dc9c4a4cfdeb29e86e918f9" translate="yes" xml:space="preserve">
          <source>These assertions may not appear in character classes (but note that &lt;code&gt;\b&lt;/code&gt; has a different meaning, namely the backspace character, inside a character class).</source>
          <target state="translated">Эти утверждения могут не отображаться в классах символов (но обратите внимание, что &lt;code&gt;\b&lt;/code&gt; имеет другое значение, а именно символ возврата внутри класса символов).</target>
        </trans-unit>
        <trans-unit id="74dbc337c7d11370d75e44ba74f2cb86ce0accdc" translate="yes" xml:space="preserve">
          <source>These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.</source>
          <target state="translated">Эти последовательности символьных типов могут появляться как внутри,так и вне классов символов.Каждая из них соответствует одному символу соответствующего типа.Если текущая точка совпадения находится в конце тематической строки,то все они не смогут совпасть,т.к.не существует символа,который можно было бы сопоставить.</target>
        </trans-unit>
        <trans-unit id="121cd2b220ceffc68b4f037b698a6ce125bbb7d9" translate="yes" xml:space="preserve">
          <source>These directives tell c2nim that it should annotate every proc (or proc type) with the &lt;code&gt;stdcall&lt;/code&gt; / &lt;code&gt;cdecl&lt;/code&gt; calling convention.</source>
          <target state="translated">Эти директивы говорят c2nim, что он должен аннотировать каждую процедуру (или тип процедуры) с помощью &lt;code&gt;stdcall&lt;/code&gt; &lt;code&gt;cdecl&lt;/code&gt; вызовах stdcall / cdecl .</target>
        </trans-unit>
        <trans-unit id="defe996f8d7935ccd354c5fcc6274f5321b86ee2" translate="yes" xml:space="preserve">
          <source>These examples all use the default random number generator. The &lt;a href=&quot;#Rand&quot;&gt;Rand type&lt;/a&gt; represents the state of a random number generator. For convenience, this module contains a default Rand state that corresponds to the default random number generator. Most procs in this module which do not take in a Rand parameter, including those called in the above examples, use the default generator. Those procs are &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3448534ab91afc28628316690fa8a8d7be286ead" translate="yes" xml:space="preserve">
          <source>These features also work for declarations like &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; and boolean combinations of such declarations.</source>
          <target state="translated">Эти функции также работают с объявлениями типа &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; и логическими комбинациями таких объявлений.</target>
        </trans-unit>
        <trans-unit id="ac3f7d81f9ef3ace4ce8ec9e07e91300c660430c" translate="yes" xml:space="preserve">
          <source>These integer types are pre-defined:</source>
          <target state="translated">Эти целочисленные типы являются предопределенными:</target>
        </trans-unit>
        <trans-unit id="99ab24068b59d19aa34809cf736b37f6dd349129" translate="yes" xml:space="preserve">
          <source>These keywords are also operators: &lt;code&gt;and or not xor shl shr div mod in notin is isnot of as from&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55066fb4694c635ce07b74e97002d73c6ea9c5d5" translate="yes" xml:space="preserve">
          <source>These keywords are also operators: &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt;.</source>
          <target state="translated">Эти ключевые слова также являются операторами: &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38f129b5e4464e0480827e37320803bf08418860" translate="yes" xml:space="preserve">
          <source>These matching categories have a priority: An exact match is better than a literal match and that is better than a generic match etc. In the following &lt;code&gt;count(p, m)&lt;/code&gt; counts the number of matches of the matching category &lt;code&gt;m&lt;/code&gt; for the routine &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Эти категории сопоставления имеют приоритет: точное совпадение лучше, чем буквальное совпадение, и это лучше, чем общее совпадение и т. Д. В следующем &lt;code&gt;count(p, m)&lt;/code&gt; подсчитывается количество совпадений соответствующей категории &lt;code&gt;m&lt;/code&gt; для подпрограммы &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f68cbc9b1069e256838107b36cf58486fce6b38" translate="yes" xml:space="preserve">
          <source>These numbers are usually only for the running thread, not for the whole heap, with the exception of &lt;code&gt;--gc:boehm&lt;/code&gt; and &lt;code&gt;--gc:go&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6be02e33307dc5ed705daa9fb25cdf4cc144412" translate="yes" xml:space="preserve">
          <source>These operations are supported by sets:</source>
          <target state="translated">Эти операции поддерживаются множествами:</target>
        </trans-unit>
        <trans-unit id="cde2e097c323766072e20c648ae133aff15ec9e4" translate="yes" xml:space="preserve">
          <source>These operations can be &lt;em&gt;overridden&lt;/em&gt; instead of &lt;em&gt;overloaded&lt;/em&gt;. This means the implementation is automatically lifted to structured types. For instance if type &lt;code&gt;T&lt;/code&gt; has an overridden assignment operator &lt;code&gt;=&lt;/code&gt; this operator is also used for assignments of the type &lt;code&gt;seq[T]&lt;/code&gt;. Since these operations are bound to a type they have to be bound to a nominal type for reasons of simplicity of implementation: This means an overridden &lt;code&gt;deepCopy&lt;/code&gt; for &lt;code&gt;ref T&lt;/code&gt; is really bound to &lt;code&gt;T&lt;/code&gt; and not to &lt;code&gt;ref T&lt;/code&gt;. This also means that one cannot override &lt;code&gt;deepCopy&lt;/code&gt; for both &lt;code&gt;ptr T&lt;/code&gt; and &lt;code&gt;ref T&lt;/code&gt; at the same time; instead a helper distinct or object type has to be used for one pointer type.</source>
          <target state="translated">Эти операции можно &lt;em&gt;переопределить&lt;/em&gt; вместо &lt;em&gt;перегрузки&lt;/em&gt; . Это означает, что реализация автоматически переносится на структурированные типы. Например, если тип &lt;code&gt;T&lt;/code&gt; имеет переопределенный оператор присваивания &lt;code&gt;=&lt;/code&gt; , этот оператор также используется для присваиваний типа &lt;code&gt;seq[T]&lt;/code&gt; . Поскольку эти операции связаны с типом они должны быть привязаны к номинальному типа для простоты реализации: Это означает переопределяется &lt;code&gt;deepCopy&lt;/code&gt; для &lt;code&gt;ref T&lt;/code&gt; действительно связан с &lt;code&gt;T&lt;/code&gt; и не &lt;code&gt;ref T&lt;/code&gt; . Это также означает, что нельзя переопределить &lt;code&gt;deepCopy&lt;/code&gt; для &lt;code&gt;ptr T&lt;/code&gt; и &lt;code&gt;ref T&lt;/code&gt; в то же время; вместо этого для одного типа указателя должен использоваться отдельный вспомогательный или объектный тип.</target>
        </trans-unit>
        <trans-unit id="6299dd429eaf3e5782e3b62dbebbf950dd6652fe" translate="yes" xml:space="preserve">
          <source>These procs may not be imported by a module. You can import them directly for debugging:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2944d8a6fb10906fbe7ddce83dab9ed4b20716" translate="yes" xml:space="preserve">
          <source>These procs provide a &quot;best effort&quot; real-time guarantee; in particular the cycle collector is not aware of deadlines. Deactivate it to get more predictable real-time behaviour. Tests show that a 1ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d058bd216e6b19e493d9e6bac8c481c3e459bccb" translate="yes" xml:space="preserve">
          <source>These procs provide a &quot;best effort&quot; realtime guarantee; in particular the cycle collector is not aware of deadlines yet. Deactivate it to get more predictable realtime behaviour. Tests show that a 2ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).</source>
          <target state="translated">Эти прокты обеспечивают гарантию &quot;максимальных усилий&quot; в режиме реального времени;в частности,коллекционер циклов еще не знает сроков.Деактивируйте его,чтобы получить более предсказуемое поведение в режиме реального времени.Тесты показывают,что почти во всех случаях на современных процессорах (с отключенным сборщиком циклов)будет достигнуто максимальное время паузы в 2ms.</target>
        </trans-unit>
        <trans-unit id="30e9bd52ae679ca98f3066fcb8847b5f10bc445a" translate="yes" xml:space="preserve">
          <source>These rules ensure that the construction is tied to a variable and can easily be destructed at its scope exit. Later versions of the language will improve the support of destructors.</source>
          <target state="translated">Эти правила гарантируют,что конструкция привязана к переменной и может быть легко уничтожена при выходе из области видимости.Более поздние версии языка улучшат поддержку деструкторов.</target>
        </trans-unit>
        <trans-unit id="c2e945da53bb4b2f455a09e7679d83624a41491a" translate="yes" xml:space="preserve">
          <source>These rules will only be enforced for contributions to the Nim codebase and official projects, such as the Nim compiler, the standard library, and the various official tools such as C2Nim.</source>
          <target state="translated">Эти правила будут применяться только для вкладов в кодовую базу Nim и официальных проектов,таких как компилятор Nim,стандартная библиотека и различные официальные инструменты,такие как C2Nim.</target>
        </trans-unit>
        <trans-unit id="20ac174437fbb360f6e0d2c7d84e935dee5e35b6" translate="yes" xml:space="preserve">
          <source>These templates need to be named &lt;code&gt;atom&lt;/code&gt; and &lt;code&gt;nxt&lt;/code&gt;. &lt;code&gt;atom&lt;/code&gt; should be overloaded to handle both single characters and sets of character.</source>
          <target state="translated">Эти шаблоны нужно называть &lt;code&gt;atom&lt;/code&gt; и &lt;code&gt;nxt&lt;/code&gt; . &lt;code&gt;atom&lt;/code&gt; следует перегрузить, чтобы обрабатывать как отдельные символы, так и наборы символов.</target>
        </trans-unit>
        <trans-unit id="e15bd991ab50e168df4221760f8fc062679bfd84" translate="yes" xml:space="preserve">
          <source>These three kinds of tokens are enumerated in the &lt;a href=&quot;#CmdLineKind&quot;&gt;CmdLineKind enum&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feeffd43778c20cf3fc45000f1736b9d3dd71d0f" translate="yes" xml:space="preserve">
          <source>These two procs are the two modus operandi of the real-time garbage collector:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1388617e7ec8cadd15c7db56c0366fdc608c12a" translate="yes" xml:space="preserve">
          <source>These two procs are the two modus operandi of the realtime GC:</source>
          <target state="translated">Эти два прок-два способа работы ГК в реальном времени:</target>
        </trans-unit>
        <trans-unit id="fcd0654223087b53e78c4c1fc707eb12347ccb71" translate="yes" xml:space="preserve">
          <source>This HTTP server has not been designed to be used in production, but for testing applications locally. Because of this, when deploying your application in production you should use a reverse proxy (for example nginx) instead of allowing users to connect directly to this server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d97cf346f8ff44e70f702c406d7880c63dc3778" translate="yes" xml:space="preserve">
          <source>This HTTP server has not been designed to be used in production, but for testing applications locally. Because of this, when deploying your application you should use a reverse proxy (for example nginx) instead of allowing users to connect directly to this server.</source>
          <target state="translated">Этот HTTP-сервер был разработан не для использования в производстве,а для тестирования приложений локально.Поэтому при развертывании приложения вы должны использовать обратный прокси (например,nginx)вместо того,чтобы разрешать пользователям подключаться непосредственно к этому серверу.</target>
        </trans-unit>
        <trans-unit id="0ff934bf75567640acf83ce1e9399ceeeffb3152" translate="yes" xml:space="preserve">
          <source>This Module implements types and macros to facilitate the wrapping of, and interaction with JavaScript libraries. Using the provided types &lt;code&gt;JsObject&lt;/code&gt; and &lt;code&gt;JsAssoc&lt;/code&gt; together with the provided macros allows for smoother interfacing with JavaScript, allowing for example quick and easy imports of JavaScript variables:</source>
          <target state="translated">Этот модуль реализует типы и макросы для облегчения упаковки библиотек JavaScript и взаимодействия с ними. Использование предоставленных типов &lt;code&gt;JsObject&lt;/code&gt; и &lt;code&gt;JsAssoc&lt;/code&gt; вместе с предоставленными макросами позволяет более плавно взаимодействовать с JavaScript, позволяя, например, быстро и легко импортировать переменные JavaScript:</target>
        </trans-unit>
        <trans-unit id="4c9473d766d312db31a1b340bc58dd29fe1c84c3" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;in&lt;/code&gt; operator: &lt;code&gt;a.contains(item)&lt;/code&gt; is the same as &lt;code&gt;item in a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358531b90c868b5aa1914c45c295c0b938277040" translate="yes" xml:space="preserve">
          <source>This allows the GC to perform some work for up to &lt;code&gt;us&lt;/code&gt; time. This is useful to call in a main loop to ensure the GC can do its work. To bind all GC activity to a &lt;code&gt;GC_step&lt;/code&gt; call, deactivate the GC with &lt;code&gt;GC_disable&lt;/code&gt; at program startup. If &lt;code&gt;strongAdvice&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, GC will be forced to perform collection cycle. Otherwise, GC may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via &lt;code&gt;stackSize&lt;/code&gt; parameter. It can improve performance, when you know that there are no unique Nim references below certain point on the stack. Make sure the size you specify is greater than the potential worst case size.</source>
          <target state="translated">Это позволяет GC для выполнения некоторых работ до &lt;code&gt;us&lt;/code&gt; времени. Это полезно вызывать в основном цикле, чтобы гарантировать, что сборщик мусора может выполнять свою работу. Чтобы связать все действия GC с &lt;code&gt;GC_step&lt;/code&gt; , отключите GC с помощью &lt;code&gt;GC_disable&lt;/code&gt; при запуске программы. Если для &lt;code&gt;strongAdvice&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , сборщик мусора будет вынужден выполнить цикл сбора. В противном случае GC может решить ничего не делать, если мусора для сбора не так много. Вы также можете указать текущий размер стека с помощью параметра &lt;code&gt;stackSize&lt;/code&gt; . Это может улучшить производительность, если вы знаете, что ниже определенной точки в стеке нет уникальных ссылок на Nim. Убедитесь, что указанный вами размер больше потенциально худшего размера.</target>
        </trans-unit>
        <trans-unit id="2bd372177757f2122848f7b55d70ddc516c7db4f" translate="yes" xml:space="preserve">
          <source>This allows the garbage collector to perform some work for up to &lt;code&gt;us&lt;/code&gt; time. This is useful to call in the main loop to ensure the garbage collector can do its work. To bind all garbage collector activity to a &lt;code&gt;GC_step&lt;/code&gt; call, deactivate the garbage collector with &lt;code&gt;GC_disable&lt;/code&gt; at program startup. If &lt;code&gt;strongAdvice&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then the garbage collector will be forced to perform the collection cycle. Otherwise, the garbage collector may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via &lt;code&gt;stackSize&lt;/code&gt; parameter. It can improve performance when you know that there are no unique Nim references below a certain point on the stack. Make sure the size you specify is greater than the potential worst-case size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e916ac1adfc72c259e0e62a432899799f46cd9" translate="yes" xml:space="preserve">
          <source>This allows the usage of &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44902b035eecd212cbee979b0a89c76d9b13672" translate="yes" xml:space="preserve">
          <source>This also means that it is not possible to write a literal in an unchecked AST that will after sem checking just be of type &lt;code&gt;int&lt;/code&gt; and not implicitly convertible to other integer types. This only works for all integer types that are not &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992f03b78bcf1d185430a70aa05788b70938c9a1" translate="yes" xml:space="preserve">
          <source>This blocks until a message has arrived! You may use &lt;a href=&quot;#peek,Channel%5BTMsg%5D&quot;&gt;peek proc&lt;/a&gt; to avoid the blocking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b2e587ffff759ed345a7138f93f32e7018411a" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;match&lt;/code&gt; with an implicit declared &lt;code&gt;matches&lt;/code&gt; array that can be used in the scope of the &lt;code&gt;=~&lt;/code&gt; call:</source>
          <target state="translated">Это вызывает &lt;code&gt;match&lt;/code&gt; с неявным объявленным массивом &lt;code&gt;matches&lt;/code&gt; который можно использовать в области действия вызова &lt;code&gt;=~&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="91e68c05bbcd84956d6a939da42a4d1620388308" translate="yes" xml:space="preserve">
          <source>This can be accomplished with the &lt;code&gt;#discardableprefix&lt;/code&gt; directive. As its name suggests functions of the given prefix(es) that have non-void return type get annotated with &lt;code&gt;.discardable&lt;/code&gt;:</source>
          <target state="translated">Это можно сделать с &lt;code&gt;#discardableprefix&lt;/code&gt; директивы #discardableprefix . Поскольку его название предполагает, что функции данного префикса (ов), которые имеют ненулевой тип возврата, аннотируются с помощью &lt;code&gt;.discardable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="993037ecc6a7a9266978b1b72316c93245910c17" translate="yes" xml:space="preserve">
          <source>This can be avoided by distinguishing strings that contain SQL from strings that don't. Distinct types provide a means to introduce a new string type &lt;code&gt;SQL&lt;/code&gt; that is incompatible with &lt;code&gt;string&lt;/code&gt;:</source>
          <target state="translated">Этого можно избежать, отличая строки, содержащие SQL, от строк, которые не содержат. Различные типы предоставляют средства для введения нового строкового типа &lt;code&gt;SQL&lt;/code&gt; , несовместимого со &lt;code&gt;string&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e0f58418896b0318ad50111ccb458545bca077f8" translate="yes" xml:space="preserve">
          <source>This can be fixed by explicitly using &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de90335a89d6a027e12fb152c891c86ef2f05f70" translate="yes" xml:space="preserve">
          <source>This can be used to check whether a library provides a certain feature or not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a87a7c0c14223cb397afe2f968231607dd88a29" translate="yes" xml:space="preserve">
          <source>This can be useful when you have a value that can be present or not. The absence of a value is often represented by &lt;code&gt;nil&lt;/code&gt;, but it is not always available, nor is it always a good solution.</source>
          <target state="translated">Это может быть полезно, когда у вас есть значение, которое может присутствовать или нет. Отсутствие значения часто обозначается &lt;code&gt;nil&lt;/code&gt; , но оно не всегда доступно и не всегда является хорошим решением.</target>
        </trans-unit>
        <trans-unit id="3b2e2827e1dd9cc8f707a6716c04839c0c09dae0" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only.</source>
          <target state="translated">При этом проверяются только 0-9 ASCII-символов.</target>
        </trans-unit>
        <trans-unit id="b3ae4abe96c6abb652268187695385d740f80fff" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are numeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Это проверяет только символы 0&amp;ndash;9 ASCII. Возвращает истину, если все символы в &lt;em&gt;s&lt;/em&gt; являются числовыми и есть хотя бы один символ в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b117d9b50603d6a49490348238bc1594481a404a" translate="yes" xml:space="preserve">
          <source>This checks ASCII characters only.</source>
          <target state="translated">Это проверяет только ASCII-символы.</target>
        </trans-unit>
        <trans-unit id="21d99d6543b30de8fb262a673a04b6b39bf07b1e" translate="yes" xml:space="preserve">
          <source>This checks ASCII characters only. Use &lt;a href=&quot;unicode&quot;&gt;Unicode module&lt;/a&gt; for UTF-8 support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc954298ac0dfb73fe360b4e03334044ae90394" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only.</source>
          <target state="translated">Это проверяет только символы A-Z,A-Z ASCII.</target>
        </trans-unit>
        <trans-unit id="27f5c2b32f5e5afe9cd3e0adefb2a5846fa92f48" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alphabetic and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Это проверяет только символы ASCII az, AZ. Возвращает истину, если все символы в &lt;em&gt;s&lt;/em&gt; являются алфавитными и есть хотя бы один символ в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="78cfd4a754ca378bfad60ee60fd52a76f4ce74da" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only. Use &lt;a href=&quot;unicode&quot;&gt;Unicode module&lt;/a&gt; for UTF-8 support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c461ad96b6496c8497bea23444e5f754d29e62" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only.</source>
          <target state="translated">При этом проверяются только символы a-z,A-Z,0-9 ASCII.</target>
        </trans-unit>
        <trans-unit id="7dc2aa227843f2651d01fb29a6a47bedb18d9c19" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alpanumeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">Это проверяет только символы az, AZ, 0&amp;ndash;9 ASCII. Возвращает истину, если все символы в &lt;em&gt;s&lt;/em&gt; являются буквенно-цифровыми и есть хотя бы один символ в &lt;em&gt;s&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb243522dd9085ea31f048f6623532706ee946c" translate="yes" xml:space="preserve">
          <source>This code demonstrates how you can iterate over all the tags in an HTML file and write back the modified version. In this case we look for hyperlinks ending with the extension &lt;code&gt;.rst&lt;/code&gt; and convert them to &lt;code&gt;.html&lt;/code&gt;.</source>
          <target state="translated">Этот код демонстрирует, как вы можете перебирать все теги в файле HTML и записывать измененную версию. В этом случае мы ищем гиперссылки, заканчивающиеся расширением &lt;code&gt;.rst&lt;/code&gt; , и конвертируем их в &lt;code&gt;.html&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67e26f346f2ccd3c86198d382ef1609a459caeec" translate="yes" xml:space="preserve">
          <source>This code has a shortcoming: if &lt;code&gt;debug&lt;/code&gt; is set to false someday, the quite expensive &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operations are still performed! (The argument evaluation for procedures is &lt;em&gt;eager&lt;/em&gt;).</source>
          <target state="translated">У этого кода есть недостаток: если когда-нибудь для &lt;code&gt;debug&lt;/code&gt; будет установлено значение false, довольно дорогие операции &lt;code&gt;$&lt;/code&gt; и &lt;code&gt;&amp;amp;&lt;/code&gt; все равно будут выполняться! (Оценка аргументов для процедур &lt;em&gt;нетерпелива&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="ddf8456d90256ef6813274665679598a51d6b207" translate="yes" xml:space="preserve">
          <source>This complements &lt;a href=&quot;#escape&quot;&gt;escape&lt;/a&gt; as it performs the opposite operations.</source>
          <target state="translated">Это дополняет &lt;a href=&quot;#escape&quot;&gt;escape,&lt;/a&gt; поскольку выполняет противоположные операции.</target>
        </trans-unit>
        <trans-unit id="448d34e4eec8002bcc63da9cb6384f1b398a912a" translate="yes" xml:space="preserve">
          <source>This complements &lt;a href=&quot;#escape,string,string,string&quot;&gt;escape proc&lt;/a&gt; as it performs the opposite operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb30b5d51da059f03be346551003a62694c6e6c0" translate="yes" xml:space="preserve">
          <source>This condition holds:</source>
          <target state="translated">Это условие соблюдается:</target>
        </trans-unit>
        <trans-unit id="81ebbfabdc2c9ddc216dc2043c4b3f433dfa4f83" translate="yes" xml:space="preserve">
          <source>This constant is used to determine whether the destination platform is fully supported by &lt;code&gt;ioselectors&lt;/code&gt; module.</source>
          <target state="translated">Эта константа используется, чтобы определить, полностью ли платформа назначения поддерживается модулем &lt;code&gt;ioselectors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec88b8f870dd5f6a3d62cb955fdcb976315090ca" translate="yes" xml:space="preserve">
          <source>This convenience proc parses any input string using rst markup (it doesn't have to be a full document!) and returns an embeddable piece of HTML. The proc is meant to be used in &lt;em&gt;online&lt;/em&gt; environments without access to a meaningful filesystem, and therefore rst &lt;code&gt;include&lt;/code&gt; like directives won't work. For an explanation of the &lt;code&gt;config&lt;/code&gt; parameter see the &lt;code&gt;initRstGenerator&lt;/code&gt; proc. Example:</source>
          <target state="translated">Эта удобная процедура анализирует любую входную строку с использованием первой разметки (это не обязательно должен быть полный документ!) И возвращает встраиваемый фрагмент HTML. Процесс предназначен для использования в &lt;em&gt;онлайн-&lt;/em&gt; средах без доступа к значимой файловой системе, и поэтому директивы первого &lt;code&gt;include&lt;/code&gt; не будут работать. Для объяснения параметра &lt;code&gt;config&lt;/code&gt; см. &lt;code&gt;initRstGenerator&lt;/code&gt; proc. Пример:</target>
        </trans-unit>
        <trans-unit id="4f4da908d1b690f8e981e01fff23cd3d08db0df4" translate="yes" xml:space="preserve">
          <source>This creates a new &lt;a href=&quot;#OptParser&quot;&gt;OptParser&lt;/a&gt;. If no command line arguments are provided, the real command line as provided by the &lt;code&gt;os&lt;/code&gt; module is retrieved instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9772d9f40d4b88270d7bfcc87701c67c1f206a" translate="yes" xml:space="preserve">
          <source>This directive tells c2nim that it should annotate every proc that resulted from a C function prototype with the &lt;code&gt;dynlib&lt;/code&gt; pragma:</source>
          <target state="translated">Эта директива сообщает c2nim, что он должен аннотировать каждую процедуру, являющуюся результатом прототипа функции C, с помощью &lt;code&gt;dynlib&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4603ae97d0bef34ab983059dfa901c4651d6c5d6" translate="yes" xml:space="preserve">
          <source>This document aims to be a precise specification about how move semantics and destructors work in Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc11ca4313f42aaa8eb535d6e6150b0aedbf3be6" translate="yes" xml:space="preserve">
          <source>This document describes Nim's standard library.</source>
          <target state="translated">Этот документ описывает стандартную библиотеку Нима.</target>
        </trans-unit>
        <trans-unit id="344be4f4ba38b24d4eb5d528848beeb4bd8811eb" translate="yes" xml:space="preserve">
          <source>This document describes features of Nim that are to be considered experimental. Some of these are not covered by the &lt;code&gt;.experimental&lt;/code&gt; pragma or &lt;code&gt;--experimental&lt;/code&gt; switch because they are already behind a special syntax and one may want to use Nim libraries using these features without using them oneself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501826eded96f905ab59473404c85f59f07e601c" translate="yes" xml:space="preserve">
          <source>This document describes how the GC works and how to tune it for (soft) &lt;span id=&quot;realtime-systems_1&quot;&gt;realtime systems&lt;/span&gt;.</source>
          <target state="translated">В этом документе описывается, как работает сборщик мусора и как его настроить для &lt;span id=&quot;realtime-systems_1&quot;&gt;систем&lt;/span&gt; (программного) &lt;span id=&quot;realtime-systems_1&quot;&gt;реального времени&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="82487ee5532813ed5f7833504e199d69e4451b0b" translate="yes" xml:space="preserve">
          <source>This document describes how the multi-paradigm memory management strategies work. How to tune the garbage collectors for your needs, like (soft) &lt;span id=&quot;realtime-systems_1&quot;&gt;realtime systems&lt;/span&gt;, and how the memory management strategies that are not garbage collectors work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1436145ee6291786c4efda6509df54038a00ce9" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;documentation generation tools&lt;/span&gt; built into the &lt;a href=&quot;nimc&quot;&gt;Nim compiler&lt;/a&gt;, which can generate HTML and JSON output from input .nim files and projects, as well as HTML and LaTeX from input RST (reStructuredText) files. The output documentation will include module dependencies (&lt;code&gt;import&lt;/code&gt;), any top-level documentation comments (##), and exported symbols (*), including procedures, types, and variables.</source>
          <target state="translated">В этом документе описываются &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;инструменты создания документации,&lt;/span&gt; встроенные в &lt;a href=&quot;nimc&quot;&gt;компилятор Nim&lt;/a&gt; , который может генерировать выходные данные HTML и JSON из входных файлов и проектов .nim, а также HTML и LaTeX из входных файлов RST (reStructuredText). Выходная документация будет включать зависимости модулей ( &lt;code&gt;import&lt;/code&gt; ), любые комментарии документации верхнего уровня (##) и экспортированные символы (*), включая процедуры, типы и переменные.</target>
        </trans-unit>
        <trans-unit id="876d6f96c63ad0dcba59ff24b243aebd3e783be3" translate="yes" xml:space="preserve">
          <source>This document describes the lexis, the syntax, and the semantics of Nim.</source>
          <target state="translated">Этот документ описывает лексику,синтаксис и семантику Ним.</target>
        </trans-unit>
        <trans-unit id="052a5aaf43125762195ce8979a78fa337c691660" translate="yes" xml:space="preserve">
          <source>This document describes the lexis, the syntax, and the semantics of the Nim language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601f8c6b34793396897c345b490ce1360453f6a5" translate="yes" xml:space="preserve">
          <source>This document describes the upcoming Nim runtime which does not use classical GC algorithms anymore but is based on destructors and move semantics. The new runtime's advantages are that Nim programs become oblivious to the involved heap sizes and programs are easier to write to make effective use of multi-core machines. As a nice bonus, files and sockets and the like will not require manual &lt;code&gt;close&lt;/code&gt; calls anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb13f15afd5992eb20356ca76c23dc066a055b6" translate="yes" xml:space="preserve">
          <source>This document describes the usage of the &lt;em&gt;Nim compiler&lt;/em&gt; on the different supported platforms. It is not a definition of the Nim programming language (therefore is the &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;).</source>
          <target state="translated">В этом документе описывается использование &lt;em&gt;компилятора Nim&lt;/em&gt; на различных поддерживаемых платформах. Это не определение языка программирования Nim (следовательно, &lt;a href=&quot;manual&quot;&gt;руководство&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ee46bbf1bf7e5279f84d46353ef02a9266df1275" translate="yes" xml:space="preserve">
          <source>This document describes the usage of the &lt;em&gt;Nim compiler&lt;/em&gt; on the different supported platforms. It is not a definition of the Nim programming language (which is covered in the &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb274ef505ac7161b2d0c10daf0e239378a408c" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the advanced constructs of the &lt;em&gt;Nim&lt;/em&gt; programming language. &lt;strong&gt;Note that this document is somewhat obsolete as the&lt;/strong&gt;&lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;&lt;strong&gt;contains many more examples of the advanced language features.&lt;/strong&gt;</source>
          <target state="translated">Этот документ представляет собой руководство по расширенным конструкциям языка программирования &lt;em&gt;Nim&lt;/em&gt; . &lt;strong&gt;Обратите внимание, что этот документ несколько устарел, поскольку в &lt;/strong&gt;&lt;a href=&quot;manual&quot;&gt;руководстве &lt;/a&gt;&lt;strong&gt;содержится гораздо больше примеров расширенных языковых функций.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51cc327eea029a9a74f8f2656806b1a3582d4c70" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the programming language &lt;em&gt;Nim&lt;/em&gt;. This tutorial assumes that you are familiar with basic programming concepts like variables, types or statements but is kept very basic. The &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt; contains many more examples of the advanced language features. All code examples in this tutorial, as well as the ones found in the rest of Nim's documentation, follow the &lt;a href=&quot;nep1&quot;&gt;Nim style guide&lt;/a&gt;.</source>
          <target state="translated">Этот документ представляет собой учебное пособие по языку программирования &lt;em&gt;Nim&lt;/em&gt; . В этом руководстве предполагается, что вы знакомы с основными концепциями программирования, такими как переменные, типы или операторы, но при этом оно остается очень простым. В &lt;a href=&quot;manual&quot;&gt;руководстве&lt;/a&gt; есть еще много примеров расширенных языковых функций. Все примеры кода в этом руководстве, а также в остальной документации Nim, соответствуют руководству по &lt;a href=&quot;nep1&quot;&gt;стилю Nim&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc36e0a51521723c2d17399937c4b8017c6cb9b6" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of idetools support you can look at the test files found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt; or &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="translated">Этот документ проведет вас через доступные варианты. Если вы хотите ознакомиться с практическими примерами поддержки idetools, вы можете просмотреть тестовые файлы, содержащиеся в &lt;a href=&quot;#test-suite&quot;&gt;наборе тестов,&lt;/a&gt; или &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;различные&lt;/a&gt; уже доступные интеграции редактора .</target>
        </trans-unit>
        <trans-unit id="b50c7c6fe53ac393a7c7fac0b0acdac2132c3be2" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of nimsuggest support you can look at the &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="translated">Этот документ проведет вас через доступные варианты. Если вы хотите посмотреть на практические примеры поддержки nimsuggest, вы можете взглянуть на &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;различные&lt;/a&gt; уже доступные интеграции редактора .</target>
        </trans-unit>
        <trans-unit id="a42362fd0fdb024567fc8917a8d4c8e5c41a8857" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;code&gt;key&lt;/code&gt; is already in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20177f379121698f488e5c0b5ae0c546e34cb464" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;code&gt;key&lt;/code&gt; is not found in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9463da66a61d4818bd3012c1d824f16d76b55047" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is already in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">Это ничего не делает, если &lt;em&gt;ключ&lt;/em&gt; уже находится в &lt;em&gt;s&lt;/em&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="2d74bf1bd66d315281b8b850d55664417bfed9ea" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is not found in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">Это ничего не делает, если &lt;em&gt;ключ&lt;/em&gt; не найден в &lt;em&gt;s&lt;/em&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="04208e500a8d87248355c319f0fd4502fe85e0e8" translate="yes" xml:space="preserve">
          <source>This example demonstrates the usage of the W3 HTML Validator, it uses &lt;code&gt;multipart/form-data&lt;/code&gt; as the &lt;code&gt;Content-Type&lt;/code&gt; to send the HTML to be validated to the server.</source>
          <target state="translated">Этот пример демонстрирует использование W3 HTML Validator, он использует &lt;code&gt;multipart/form-data&lt;/code&gt; в качестве &lt;code&gt;Content-Type&lt;/code&gt; для отправки HTML-кода для проверки на сервер.</target>
        </trans-unit>
        <trans-unit id="dfa1b9eabc9505799b820ee46f8953f4c8f974ac" translate="yes" xml:space="preserve">
          <source>This example shows a procedure named &lt;code&gt;yes&lt;/code&gt; that asks the user a &lt;code&gt;question&lt;/code&gt; and returns true if they answered &quot;yes&quot; (or something similar) and returns false if they answered &quot;no&quot; (or something similar). A &lt;code&gt;return&lt;/code&gt; statement leaves the procedure (and therefore the while loop) immediately. The &lt;code&gt;(question: string): bool&lt;/code&gt; syntax describes that the procedure expects a parameter named &lt;code&gt;question&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; and returns a value of type &lt;code&gt;bool&lt;/code&gt;. The &lt;code&gt;bool&lt;/code&gt; type is built-in: the only valid values for &lt;code&gt;bool&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. The conditions in if or while statements must be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">В этом примере показана процедура с именем &lt;code&gt;yes&lt;/code&gt; , которая задает пользователю &lt;code&gt;question&lt;/code&gt; и возвращает true, если они ответили &amp;laquo;да&amp;raquo; (или что-то подобное), и возвращает false, если они ответили &amp;laquo;нет&amp;raquo; (или что-то подобное). &lt;code&gt;return&lt;/code&gt; заявление покидает процедуру (и , следовательно, время цикла) немедленно. &lt;code&gt;(question: string): bool&lt;/code&gt; синтаксис описывает , что процедура ожидает , что параметр с именем &lt;code&gt;question&lt;/code&gt; типа &lt;code&gt;string&lt;/code&gt; и возвращает значение типа &lt;code&gt;bool&lt;/code&gt; . Тип &lt;code&gt;bool&lt;/code&gt; является встроенным: единственные допустимые значения для &lt;code&gt;bool&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; ., Условия в операторах if или while должны иметь тип &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="419751183c50edae04b9814dec67dc7101cf22a4" translate="yes" xml:space="preserve">
          <source>This example uses HTTP GET to retrieve &lt;code&gt;http://google.com&lt;/code&gt;:</source>
          <target state="translated">В этом примере используется HTTP GET для получения &lt;code&gt;http://google.com&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c530469f8ff4d36d8c0d58dcb3d2f3b70e61c1b6" translate="yes" xml:space="preserve">
          <source>This example will create an HTTP server on port 8080. The server will respond to all requests with a &lt;code&gt;200 OK&lt;/code&gt; response code and &quot;Hello World&quot; as the response body.</source>
          <target state="translated">В этом примере создается HTTP-сервер на порту 8080. Сервер будет отвечать на все запросы кодом ответа &lt;code&gt;200 OK&lt;/code&gt; и текстом &amp;laquo;Hello World&amp;raquo; в качестве тела ответа.</target>
        </trans-unit>
        <trans-unit id="82f9bd61449ea276e7ba79a6b51086b4f68f04d2" translate="yes" xml:space="preserve">
          <source>This exception is raised when a string parameter contains an illegal character</source>
          <target state="translated">Это исключение возникает,когда строковый параметр содержит недопустимый символ</target>
        </trans-unit>
        <trans-unit id="49884cc4168ac3b56e2f36bd32448ca533036aba" translate="yes" xml:space="preserve">
          <source>This feature is still under development. In the future it will allow an IDE to evaluate an expression in the context of the currently running/debugged user project.</source>
          <target state="translated">Эта функция все еще находится в стадии разработки.В будущем она позволит IDE оценить выражение в контексте выполняемого/отлаживаемого в данный момент пользовательского проекта.</target>
        </trans-unit>
        <trans-unit id="718ecf2ca622cda3af52f68c05ddd3883f87e430" translate="yes" xml:space="preserve">
          <source>This file implements features required for IDE support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6fc55e019f2e067eb3af4f08888a5e5eab4d20" translate="yes" xml:space="preserve">
          <source>This file implements the new evaluation engine for Nim code. An instruction is 1-3 int32s in memory, it is a register based VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baae068151a80870f517a9c80fabe195a66afe5b" translate="yes" xml:space="preserve">
          <source>This function checks for events on all the delegates in the &lt;em&gt;PDispatcher&lt;/em&gt;. It then proceeds to call the correct event handler.</source>
          <target state="translated">Эта функция проверяет наличие событий для всех делегатов в &lt;em&gt;PDispatcher&lt;/em&gt; . Затем он вызывает правильный обработчик событий.</target>
        </trans-unit>
        <trans-unit id="ef0b456d31d45682c8880248481ad8c2632bf2f5" translate="yes" xml:space="preserve">
          <source>This function is NOT reliable. Floating point numbers cannot hold non integer decimals precisely. If &lt;code&gt;places&lt;/code&gt; is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. &lt;code&gt;round(54.5) -&amp;gt; 55.0&lt;/code&gt;). If &lt;code&gt;places&lt;/code&gt; is greater than 0, round to the given number of decimal places, e.g. &lt;code&gt;round(54.346, 2) -&amp;gt; 54.350000000000001421&amp;hellip;&lt;/code&gt;. If &lt;code&gt;places&lt;/code&gt; is negative, round to the left of the decimal place, e.g. &lt;code&gt;round(537.345, -1) -&amp;gt; 540.0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4a4220996badd8db70594d8b36b935a69870fd" translate="yes" xml:space="preserve">
          <source>This function is available only when &lt;code&gt;--threads:on&lt;/code&gt; and &lt;code&gt;--tlsEmulation:off&lt;/code&gt; switches are used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4390f3f69d4871fa4d3972e4b499717ab1b670b2" translate="yes" xml:space="preserve">
          <source>This function is not implemented on all platform, test for availability with &lt;code&gt;declared() &amp;lt;system.html#declared,untyped&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c640f2d135e1c682951e71cb417036f1e1dabc6c" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;True&lt;/code&gt; if there are file descriptors that are still open, otherwise &lt;code&gt;False&lt;/code&gt;. File descriptors that have been closed are immediately removed from the dispatcher automatically.</source>
          <target state="translated">Эта функция возвращает &lt;code&gt;True&lt;/code&gt; , если есть файловые дескрипторы, которые все еще открыты, в противном случае - &lt;code&gt;False&lt;/code&gt; . Дескрипторы файлов, которые были закрыты, немедленно автоматически удаляются из диспетчера.</target>
        </trans-unit>
        <trans-unit id="80da17632a4719e714bb180d2505b06fb4c81b21" translate="yes" xml:space="preserve">
          <source>This function will lookup the IP address of a hostname.</source>
          <target state="translated">Эта функция будет искать IP-адрес имени хоста.</target>
        </trans-unit>
        <trans-unit id="888f45de89db87248b6c42a8441e4fc3f923719d" translate="yes" xml:space="preserve">
          <source>This function will lookup the hostname of an IP Address.</source>
          <target state="translated">Эта функция будет искать имя хоста IP-адреса.</target>
        </trans-unit>
        <trans-unit id="9ba85512a6c5538eb44a83be7203148f1393be22" translate="yes" xml:space="preserve">
          <source>This function will raise an EOS exception when a socket error occurs.</source>
          <target state="translated">Эта функция вызывает исключение EOS при ошибке сокета.</target>
        </trans-unit>
        <trans-unit id="83d0d0f248054169b861c6becec14e8bc119b1fc" translate="yes" xml:space="preserve">
          <source>This function will remove the data that was returned from the underlying &lt;code&gt;FutureStream&lt;/code&gt;.</source>
          <target state="translated">Эта функция удалит данные, которые были возвращены из основного &lt;code&gt;FutureStream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48be562c3c3e831dca5c27c76a3332e0fe473cb4" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs.</source>
          <target state="translated">При возникновении ошибки эта функция выбросит исключение EOS.</target>
        </trans-unit>
        <trans-unit id="0d0f4a3f3c929a542ada2a33db6e38abd1059abb" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="translated">При возникновении ошибки эта функция выбросит исключение EOS.Значение ниже 0 никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="5d8f3e9799faf34cc137a492d6f553e08eafcb4b" translate="yes" xml:space="preserve">
          <source>This function will throw an OSError exception when an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125d21a7a8629f951aed2b4a51171c5e5038ef0b" translate="yes" xml:space="preserve">
          <source>This function will throw an OSError exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="translated">Эта функция будет бросать исключение OSError при возникновении ошибки.Значение ниже 0 никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="dc4ca2ac4f720e72b5b82cc411b68835f82a7af2" translate="yes" xml:space="preserve">
          <source>This happens for calculations whose results are too large to fit in the provided bits.</source>
          <target state="translated">Это происходит для вычислений,результаты которых слишком велики,чтобы поместиться в предоставленные биты.</target>
        </trans-unit>
        <trans-unit id="f7d396147bbaee5b1e555360e29d6e7950ec2165" translate="yes" xml:space="preserve">
          <source>This has NOT yet been (extensively) tested against ODBC drivers for Teradata, Oracle, Sybase, MSSqlvSvr, et. al. databases.</source>
          <target state="translated">Это еще не было проверено (в значительной степени)на драйверах ODBC для баз данных Teradata,Oracle,Sybase,MSSqlvSvr и др.</target>
        </trans-unit>
        <trans-unit id="0cd633329a7f1f5e683279f4817767b6e858402b" translate="yes" xml:space="preserve">
          <source>This has further consequences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80811f797327311abf9b8bb44734abd6ccfea15" translate="yes" xml:space="preserve">
          <source>This implementation calls &lt;code&gt;math.randomize()&lt;/code&gt; for the first call of &lt;code&gt;genOid&lt;/code&gt;.</source>
          <target state="translated">Эта реализация вызывает &lt;code&gt;math.randomize()&lt;/code&gt; для первого вызова &lt;code&gt;genOid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d16330d38656e17d5127ab390f1fa9fa82609de7" translate="yes" xml:space="preserve">
          <source>This is &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt; at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59b97830c5bd0f5ff50a358d8f4e2f7574886e8" translate="yes" xml:space="preserve">
          <source>This is &lt;strong&gt;unsafe&lt;/strong&gt; as it allocates an object of the passed &lt;code&gt;size&lt;/code&gt;. This should only be used for optimization purposes when you know what you're doing!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1152982ee72cd4dc2acc598e6a1878a3cb306d" translate="yes" xml:space="preserve">
          <source>This is a lower level proc and not something that you typically would need to call when using this module. One exception to this is if you are implementing any &lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_SMTP&quot;&gt;SMTP extensions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291d5e1a5495802c3c84e77e045ae2f53bfb5167" translate="yes" xml:space="preserve">
          <source>This is a part of &lt;code&gt;system.nim&lt;/code&gt;, you should not manually import it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58c523ddb24f9724b2d75ac0236939620e83491" translate="yes" xml:space="preserve">
          <source>This is a raw POSIX interface module. It does not not provide any convenience: cstrings are used instead of proper Nim strings and return codes indicate errors. If you want exceptions and a proper Nim-like interface, use the OS module or write a wrapper.</source>
          <target state="translated">Это необработанный POSIX-интерфейсный модуль.Он не обеспечивает никакого удобства:вместо правильных Nim-строк используются строки,а коды возврата указывают на ошибки.Если вам нужны исключения и правильный Nim-подобный интерфейс,используйте модуль операционной системы или напишите обертку.</target>
        </trans-unit>
        <trans-unit id="0e187a8e9e9b4d53c523d572ffaa0449d8fd615b" translate="yes" xml:space="preserve">
          <source>This is a simple syntactic transformation into:</source>
          <target state="translated">Это простое синтаксическое преобразование:</target>
        </trans-unit>
        <trans-unit id="baffe5aa2ca431a951c22f6627b3195c4e8e9257" translate="yes" xml:space="preserve">
          <source>This is a wrapper proc around &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt;, &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; on non Windows platform. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">Это процедура-оболочка для &lt;a href=&quot;#copyFile&quot;&gt;copyFile ()&lt;/a&gt; , &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions ()&lt;/a&gt; и &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions ()&lt;/a&gt; на платформе, отличной от Windows. В Windows этот процесс является просто оболочкой для &lt;a href=&quot;#copyFile&quot;&gt;copyFile (),&lt;/a&gt; поскольку этот процесс уже копирует атрибуты.</target>
        </trans-unit>
        <trans-unit id="e7889b59af2f2b66c7a5250872376894c99e6798" translate="yes" xml:space="preserve">
          <source>This is a wrapper proc around &lt;a href=&quot;#copyFile,string,string&quot;&gt;copyFile&lt;/a&gt;, &lt;a href=&quot;#getFilePermissions,string&quot;&gt;getFilePermissions&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions,string,set%5BFilePermission%5D&quot;&gt;setFilePermissions&lt;/a&gt; procs on non-Windows platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a603ff59d56a2ac3e9b3c36a052ac4a5c2114b5" translate="yes" xml:space="preserve">
          <source>This is all single threaded, fully non-blocking and does give you a lot of control. In theory you should be able to work with any of these layers interchangeably (as long as you only care about non-Windows platforms).</source>
          <target state="translated">Все это однопоточное,полностью неблокирующее и дающее много контроля.Теоретически,вы должны быть в состоянии работать с любым из этих слоев взаимозаменяемо (до тех пор,пока вы заботитесь только о не-Windows платформах).</target>
        </trans-unit>
        <trans-unit id="106552ab99d75903f8f7507280b5c7f154edc971" translate="yes" xml:space="preserve">
          <source>This is also used by the code generator for the implementation of &lt;code&gt;spawn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cad2e5f3a65e247d00d9f14abfba38cdd1e9778" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(1)&lt;/code&gt; operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfd16ee323a671ecdfb12c816b6de91a9a9a32f" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb775bab32177650720f4b9d9b75ca0579c501f6" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt;.</source>
          <target state="translated">Это псевдоним &lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cac9bcfc62c9f2dfc091188b39f1cd9d2776d953" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticExec,string,string,string&quot;&gt;staticExec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14a0c9a9b72673d11d5220860a7e2d032297599" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">Это псевдоним &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f27f252061898e3dc51b007922c3601c40f37b56" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticRead,string&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597d82c31bdafce1e17f3e095745fae4aa8f063d" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;uint8&lt;/code&gt;, that is an unsigned integer, 8 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39548494ffeefbdea437a44fba01f90cd710d14" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over command line arguments. This creates a new OptParser. See the above &lt;code&gt;getopt(var OptParser)&lt;/code&gt; example for using default empty &lt;code&gt;NoVal&lt;/code&gt; parameters. This example is for the same option keys as that example but here option key-value separators become optional for command users:</source>
          <target state="translated">Это удобный итератор для перебора аргументов командной строки. Это создает новый OptParser. См. &lt;code&gt;getopt(var OptParser)&lt;/code&gt; пример getopt (var OptParser) для использования пустых параметров &lt;code&gt;NoVal&lt;/code&gt; по умолчанию . Этот пример относится к тем же ключам параметров, что и этот пример, но здесь разделители ключей и значений параметров становятся необязательными для пользователей команды:</target>
        </trans-unit>
        <trans-unit id="e447530d06e7e3f0eb38b06f1ec7e2d1eabe95e8" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over the given OptParser object. Example:</source>
          <target state="translated">Это удобный итератор для итерации по заданному объекту OptParser.Пример:</target>
        </trans-unit>
        <trans-unit id="46521745d7cb0cedd54b67fe6c5b314fc7bf2b49" translate="yes" xml:space="preserve">
          <source>This is an example of a configuration file.</source>
          <target state="translated">Это пример конфигурационного файла.</target>
        </trans-unit>
        <trans-unit id="bb8b17fc24c398ee4adf40c48e79b2a6ab176591" translate="yes" xml:space="preserve">
          <source>This is an example of a third party module that uses macros and templates to translate text strings on unmodified NimScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d57d5e9e40ed277e61d9e1d580ae63f60ceef5" translate="yes" xml:space="preserve">
          <source>This is an internal helper module. Do not use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8621b33d7505ff2f752c63fce71661a8f7e46de8" translate="yes" xml:space="preserve">
          <source>This is best explained by an example:</source>
          <target state="translated">Это лучше всего объяснить на примере:</target>
        </trans-unit>
        <trans-unit id="303d755730efc75b448e0367fb111543fb211df2" translate="yes" xml:space="preserve">
          <source>This is best illustrated by an example:</source>
          <target state="translated">Это лучше всего проиллюстрировать на примере:</target>
        </trans-unit>
        <trans-unit id="46f5b0f3810fc00217f071160db6bcce0f78c6fb" translate="yes" xml:space="preserve">
          <source>This is binary compatible to the type &lt;code&gt;char**&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. The array's high value is large enough to disable bounds checking in practice. Use &lt;a href=&quot;#cstringArrayToSeq,cstringArray,Natural&quot;&gt;cstringArrayToSeq proc&lt;/a&gt; to convert it into a &lt;code&gt;seq[string]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d07b0945aa6279aac37be60460c485fcc1ff52f" translate="yes" xml:space="preserve">
          <source>This is binary compatible to the type &lt;code&gt;char**&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. The array's high value is large enough to disable bounds checking in practice. Use &lt;em&gt;cstringArrayToSeq&lt;/em&gt; to convert it into a &lt;code&gt;seq[string]&lt;/code&gt;.</source>
          <target state="translated">Это бинарная совместим с типом &lt;code&gt;char**&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; . Максимальное значение массива достаточно велико, чтобы на практике отключить проверку границ. Используйте &lt;em&gt;cstringArrayToSeq,&lt;/em&gt; чтобы преобразовать его в &lt;code&gt;seq[string]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d8e0f1f729f18e2e3789687a0b726bb73204855" translate="yes" xml:space="preserve">
          <source>This is different from the &lt;a href=&quot;system#div,int,int&quot;&gt;system.div&lt;/a&gt; operator, which is defined as &lt;code&gt;trunc(x / y)&lt;/code&gt;. That is, &lt;code&gt;div&lt;/code&gt; rounds towards &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;floorDiv&lt;/code&gt; rounds down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd38078b21b67094ebb387df8cff1e550ab3259" translate="yes" xml:space="preserve">
          <source>This is done using the &lt;code&gt;to&lt;/code&gt; macro. Take a look at &lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;its documentation&lt;/a&gt; to see an example of its use.</source>
          <target state="translated">Это делается с помощью макроса &lt;code&gt;to&lt;/code&gt; . Взгляните на &lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;его документацию,&lt;/a&gt; чтобы увидеть пример его использования.</target>
        </trans-unit>
        <trans-unit id="0e255e0fbf090e03656557a6058c22d1d0988d1e" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Length&quot; header.</source>
          <target state="translated">По сути,это значение заголовка &quot;Content-Length&quot;.</target>
        </trans-unit>
        <trans-unit id="ed8e6faffed9f4240c98845eace9c4ed1fe9f2f0" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Type&quot; header.</source>
          <target state="translated">По сути,это значение заголовка &quot;Content-Type&quot;.</target>
        </trans-unit>
        <trans-unit id="86b65d9de6d29645204c64f1e3d019cece2fb6d2" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Last-Modified&quot; header.</source>
          <target state="translated">По сути,это значение заголовка &quot;Last-Modified&quot;.</target>
        </trans-unit>
        <trans-unit id="d640ae92e84a970ee42165aaa5616bc83d8747c3" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;s = @[]; setlen(s, len)&lt;/code&gt;, but more efficient since no reallocation is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae97abc8c2bdcefb0d913bd908e2fc80b7fe31b2" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;var&lt;/code&gt;, but with &lt;code&gt;nnkLetSection&lt;/code&gt; rather than &lt;code&gt;nnkVarSection&lt;/code&gt;.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;var&lt;/code&gt; , но с &lt;code&gt;nnkLetSection&lt;/code&gt; , а не &lt;code&gt;nnkVarSection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36d6a591729274afeef549b79cbc02b07d624ba3" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt;.</source>
          <target state="translated">Это эквивалент &lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="31be46f14ea5182185d28153c71f2103de5579e6" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;.</source>
          <target state="translated">Это высокоуровневый интерфейс для &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="2074516e24b0521a08ed457d7f66ebecf4eb273e" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="translated">Это высокоуровневый интерфейс для &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="5365fcbec705681207add66f8f3d448223f0b9f4" translate="yes" xml:space="preserve">
          <source>This is intended for commands like check or parse which will work on the main project file unless explicitly given a specific file argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cca37ce9a619c91bf0a3b8b5b0129b402048ee0" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;code&gt;addRead&lt;/code&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca31998cd06c4abd11a107dae0b2105838b8be7f" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;code&gt;addWrite&lt;/code&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddf14a4425a7355cc2a2fa04844ca91c2768874" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addRead&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">Это не &lt;code&gt;pure&lt;/code&gt; механизм для портов завершения Windows (IOCP), поэтому, если вы можете этого избежать, сделайте это. Используйте &lt;em&gt;addRead&lt;/em&gt; только в том случае, если это действительно необходимо (основной вариант использования - это адаптация unix-подобных библиотек к асинхронности в Windows).</target>
        </trans-unit>
        <trans-unit id="55bde4657459bdfc7c019b27a4bfe5a2e63714bd" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addWrite&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">Это не &lt;code&gt;pure&lt;/code&gt; механизм для портов завершения Windows (IOCP), поэтому, если вы можете этого избежать, сделайте это. Используйте &lt;em&gt;addWrite&lt;/em&gt; только в том случае, если это действительно необходимо (основной вариант использования - это адаптация unix-подобных библиотек к асинхронности в Windows).</target>
        </trans-unit>
        <trans-unit id="628008d53ae8c66db6ea85a99a23fa3a10da5be9" translate="yes" xml:space="preserve">
          <source>This is not as efficient as turning a fixed length array into a sequence as it always copies every element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bb6096521d3fc312bed6cb0cb52cdf4b61e4a1" translate="yes" xml:space="preserve">
          <source>This is not guaranteed for the &lt;code&gt;times.Time&lt;/code&gt; type! This means that the &lt;code&gt;MonoTime&lt;/code&gt; should be used when measuring durations of time with high precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99100dfb2d46cb56adf22ab9dcf180bb5b0d4d9b" translate="yes" xml:space="preserve">
          <source>This is not the same AST for all uses of &lt;code&gt;var&lt;/code&gt;. See &lt;a href=&quot;macros#statements-procedure-declaration&quot;&gt;Procedure declaration&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e873a8f9ecb0f52084031638cec01f7691b7b6" translate="yes" xml:space="preserve">
          <source>This is not the same AST for all uses of &lt;code&gt;var&lt;/code&gt;. See [Procedure declaration](&lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt;) for details.</source>
          <target state="translated">Это не одно и то же AST для всех случаев использования &lt;code&gt;var&lt;/code&gt; . Подробнее см. [Объявление процедуры] ( &lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c2a7fe82c8947dd52185c1702a90b9db33146699" translate="yes" xml:space="preserve">
          <source>This is not the syntax for assignment when combined with &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, or &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">Это не синтаксис для присваивания в сочетании с &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; или &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ffa6f30e8b92ee2b75fd9ae9e7c977be41a4837" translate="yes" xml:space="preserve">
          <source>This is not to be confused with &lt;a href=&quot;system#currentSourcePath.t&quot;&gt;system.currentSourcePath&lt;/a&gt; which returns the path of the source file containing that template call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b56f8d625d177685d852e8e5c0f45517f46c5cd" translate="yes" xml:space="preserve">
          <source>This is often better than disabling all warnings at once.</source>
          <target state="translated">Часто это лучше,чем отключать все предупреждения сразу.</target>
        </trans-unit>
        <trans-unit id="8a1f35c0ffc0ce49e85232a6bb768ebe237c3d29" translate="yes" xml:space="preserve">
          <source>This is often more efficient than &lt;code&gt;tmp = a; a = b; b = tmp&lt;/code&gt;. Particularly useful for sorting algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6f926873c2b638a1222cdb189469c5136966c2" translate="yes" xml:space="preserve">
          <source>This is often the same as the &lt;code&gt;head&lt;/code&gt; result of &lt;code&gt;splitPath&lt;/code&gt;. If there is no parent, &quot;&quot; is returned.</source>
          <target state="translated">Это часто так же , как &lt;code&gt;head&lt;/code&gt; результат &lt;code&gt;splitPath&lt;/code&gt; . Если родителя нет, возвращается &quot;&quot;.</target>
        </trans-unit>
        <trans-unit id="5387b23d1544c30a7bae7f5ad7dd90a3bed36ca1" translate="yes" xml:space="preserve">
          <source>This is often useful for generating some code where the items need to be &lt;em&gt;separated&lt;/em&gt; by &lt;code&gt;sep&lt;/code&gt;. &lt;code&gt;sep&lt;/code&gt; is only added if &lt;code&gt;dest&lt;/code&gt; is longer than &lt;code&gt;startLen&lt;/code&gt;. The following example creates a string describing an array of integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b3f09919cd0742fbd659728142a828b4c8270a" translate="yes" xml:space="preserve">
          <source>This is often useful for generating some code where the items need to be &lt;em&gt;separated&lt;/em&gt; by &lt;em&gt;sep&lt;/em&gt;. &lt;em&gt;sep&lt;/em&gt; is only added if &lt;em&gt;dest&lt;/em&gt; is longer than &lt;em&gt;startLen&lt;/em&gt;. The following example creates a string describing an array of integers.</source>
          <target state="translated">Это часто полезно для создания какой - то код , где нужно быть элементы &lt;em&gt;разделены&lt;/em&gt; по &lt;em&gt;сентябрь&lt;/em&gt; . &lt;em&gt;sep&lt;/em&gt; добавляется только если &lt;em&gt;dest&lt;/em&gt; длиннее &lt;em&gt;startLen&lt;/em&gt; . В следующем примере создается строка, описывающая массив целых чисел.</target>
        </trans-unit>
        <trans-unit id="1ce17a7f7111b242071cf2276a295e1114c27396" translate="yes" xml:space="preserve">
          <source>This is only needed if you need to implement a hash proc for a new datatype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4b5a1ec53f980e2c0f3189011ffcb0ab0d3401" translate="yes" xml:space="preserve">
          <source>This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers. If &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; is true, an unknown suffix after the &lt;code&gt;type&lt;/code&gt; field is not an error.</source>
          <target state="translated">Это интересно только в том случае, если вы хотите написать процедуру настраиваемого &lt;code&gt;format&lt;/code&gt; которая должна поддерживать спецификаторы стандартного формата. Если &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; истинно, неизвестный суффикс после поля &lt;code&gt;type&lt;/code&gt; не является ошибкой.</target>
        </trans-unit>
        <trans-unit id="e9b2fa085ecd9ffb0144806ddc4d77c951b5b385" translate="yes" xml:space="preserve">
          <source>This is only raised if the &lt;a href=&quot;segfaults&quot;&gt;segfaults module&lt;/a&gt; was imported!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19846465c46a33495b53f4086a71823a95381c03" translate="yes" xml:space="preserve">
          <source>This is only raised if the &lt;code&gt;segfaults.nim&lt;/code&gt; module was imported!</source>
          <target state="translated">Это происходит только в том случае, если модуль &lt;code&gt;segfaults.nim&lt;/code&gt; был импортирован!</target>
        </trans-unit>
        <trans-unit id="fe15c448cc2638c08d44452df9bc1535305d8381" translate="yes" xml:space="preserve">
          <source>This is only used for speed hacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb1edaaf90d1400f49467187534983c2fef435b" translate="yes" xml:space="preserve">
          <source>This is only useful for optimization purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b8e0f949b1068c1e1a8a842d9da6796b501f9c" translate="yes" xml:space="preserve">
          <source>This is only useful if the program is compiled as a dynamic library via the &lt;code&gt;--app:lib&lt;/code&gt; command line option. This pragma only has an effect for the code generation on the Windows target, so when this pragma is forgotten and the dynamic library is only tested on Mac and/or Linux, there won't be an error. On Windows this pragma adds &lt;code&gt;__declspec(dllexport)&lt;/code&gt; to the function declaration.</source>
          <target state="translated">Это полезно, только если программа скомпилирована как динамическая библиотека с помощью &lt;code&gt;--app:lib&lt;/code&gt; командной строки --app: lib . Эта прагма влияет только на генерацию кода на цели Windows, поэтому, когда об этой прагме забывают и динамическая библиотека тестируется только на Mac и / или Linux, ошибки не будет. В Windows эта прагма добавляет &lt;code&gt;__declspec(dllexport)&lt;/code&gt; к объявлению функции.</target>
        </trans-unit>
        <trans-unit id="1c92294cd2a2dc37d3a8cc6e8c5557f50f24e7aa" translate="yes" xml:space="preserve">
          <source>This is only useful if the program is compiled as a dynamic library via the &lt;code&gt;--app:lib&lt;/code&gt; command-line option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d812993dd18329bdd5b49f464355b81590a6389c" translate="yes" xml:space="preserve">
          <source>This is optional.</source>
          <target state="translated">Это необязательно.</target>
        </trans-unit>
        <trans-unit id="f402c8f3279ea5adad0c54031820826de8af43c8" translate="yes" xml:space="preserve">
          <source>This is overridden by some tools (namely nimsuggest) via the &lt;code&gt;conf.prefixDir&lt;/code&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d41adf425cb818275923d0842af48d38ad37604" translate="yes" xml:space="preserve">
          <source>This is quite fast as it does not rely on any debug or runtime information. Note that in contrast to what the official signature says, the return type is &lt;em&gt;not&lt;/em&gt;&lt;code&gt;RootObj&lt;/code&gt; but a tuple of a structure that depends on the current scope. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624193289805ef01288ef5a655555f1018d6592e" translate="yes" xml:space="preserve">
          <source>This is roughly equivalent to the &lt;code&gt;async&lt;/code&gt; keyword in JavaScript code.</source>
          <target state="translated">Это примерно эквивалентно ключевому слову &lt;code&gt;async&lt;/code&gt; в коде JavaScript.</target>
        </trans-unit>
        <trans-unit id="f551bed65fae9c1f7ad990939d07645246c92238" translate="yes" xml:space="preserve">
          <source>This is roughly the same as &lt;code&gt;trunc(x/y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3575fcfddeaf3d18e36c701dd650fc2ec44479fc" translate="yes" xml:space="preserve">
          <source>This is same as &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt;. This proc behaves the same as the &lt;code&gt;%&lt;/code&gt; operator in python.</source>
          <target state="translated">Это то же самое, что и &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt; . Этот процесс ведет себя так же, как оператор &lt;code&gt;%&lt;/code&gt; в python.</target>
        </trans-unit>
        <trans-unit id="6c1d93ee2a8f74ad1e5b652d12e6c5278be5cb25" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;splitPath(path).head&lt;/code&gt; when &lt;code&gt;path&lt;/code&gt; doesn't end in a dir separator, but also takes care of path normalizations. The remainder can be obtained with &lt;a href=&quot;#lastPathPart,string&quot;&gt;lastPathPart(path) proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c992b9dfa7d27ecf9f025660223103e48bc1e8" translate="yes" xml:space="preserve">
          <source>This is synced from Nimble's version module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256bc61e58ad13a05d91f1a1bf2ae4f72005afe4" translate="yes" xml:space="preserve">
          <source>This is the concrete lookup algorithm that &lt;code&gt;&amp;amp;&lt;/code&gt; uses:</source>
          <target state="translated">Это конкретный алгоритм поиска, который &lt;code&gt;&amp;amp;&lt;/code&gt; использует:</target>
        </trans-unit>
        <trans-unit id="36c2f5442839943020ad05dd2166b1d0f12b01e5" translate="yes" xml:space="preserve">
          <source>This is the high-level version of the above &lt;code&gt;sendTo&lt;/code&gt; function.</source>
          <target state="translated">Это высокоуровневая версия вышеупомянутой функции &lt;code&gt;sendTo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97bde134c3168ba7edefb1ec35ba4786bc969108" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#+,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s + other&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4020d4e844ba19f46420bb9db474d77805335e" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#+,IntSet,IntSet&quot;&gt;s + other&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8710ddc5d8320cf19ea0e54c6b92bf35660f23f" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s - other&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37cf86ebf53b471461d913dd3976253d3ba7da4" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#-,IntSet,IntSet&quot;&gt;s - other&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4826edc58b175eebfbf7081691448d2931000418" translate="yes" xml:space="preserve">
          <source>This is the jump function for the generator. It is equivalent to 2^64 calls to next(); it can be used to generate 2^64 non-overlapping subsequences for parallel computations.</source>
          <target state="translated">Это функция прыжка для генератора.Она эквивалентна 2^64 вызовам функции next();она может быть использована для генерации 2^64 неперекрывающихся подпоследовательностей для параллельных вычислений.</target>
        </trans-unit>
        <trans-unit id="6d2f0ff4e73777d01102bb217c8397c6cddd4b22" translate="yes" xml:space="preserve">
          <source>This is the main &lt;em&gt;project&lt;/em&gt; filename. Most of the time you will pass in the same as &lt;strong&gt;FILE&lt;/strong&gt;, but for bigger projects this is the file which is used as main entry point for the program, the one which users compile to generate a final binary.</source>
          <target state="translated">Это главное имя файла &lt;em&gt;проекта&lt;/em&gt; . В большинстве случаев вы будете передавать то же самое, что и &lt;strong&gt;FILE&lt;/strong&gt; , но для более крупных проектов это файл, который используется в качестве основной точки входа для программы, тот, который пользователи компилируют для создания окончательного двоичного файла.</target>
        </trans-unit>
        <trans-unit id="60a0c5c21aaa578b306725a8da9b601c4bd7d709" translate="yes" xml:space="preserve">
          <source>This is the name of the module or include file the query refers to.</source>
          <target state="translated">Это название модуля или включаемого файла,к которому относится запрос.</target>
        </trans-unit>
        <trans-unit id="c110d8ea0aa1384440227425443ae86a6ce178fd" translate="yes" xml:space="preserve">
          <source>This is the safecall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__safecall&lt;/code&gt; keyword. The word &lt;em&gt;safe&lt;/em&gt; refers to the fact that all hardware registers shall be pushed to the hardware stack.</source>
          <target state="translated">Это соглашение о безопасном вызове, указанное Microsoft. Сгенерированная процедура C объявляется с &lt;code&gt;__safecall&lt;/code&gt; словом __safecall . Слово &amp;laquo; &lt;em&gt;безопасный&amp;raquo;&lt;/em&gt; относится к тому факту, что все аппаратные регистры должны быть помещены в аппаратный стек.</target>
        </trans-unit>
        <trans-unit id="31f95bc8194c8e476931e06554d37b68be940444" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % [a]&lt;/code&gt; (see &lt;a href=&quot;#%25,string,openArray%5Bstring%5D&quot;&gt;% proc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17370dc7ee3b0fe9dd442daf544baba9de37a9cc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % [a]&lt;/code&gt;.</source>
          <target state="translated">Это то же самое, что и &lt;code&gt;formatstr % [a]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70a3bf31e3a4defa18a1d9c74fc782d763f566f3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % a&lt;/code&gt; (see &lt;a href=&quot;#%25,string,openArray%5Bstring%5D&quot;&gt;% proc&lt;/a&gt;) except that it supports auto stringification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5ff4983f3a23d7cc3be988cf86d83e4cd1f019" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % a&lt;/code&gt; except that it supports auto stringification.</source>
          <target state="translated">Это то же самое, что и &lt;code&gt;formatstr % a&lt;/code&gt; за исключением того, что он поддерживает автоматическое преобразование строк .</target>
        </trans-unit>
        <trans-unit id="01a5b235024b77996dea512c125137d383106839" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;len(splitLines(s))&lt;/code&gt;, but much more efficient because it doesn't modify the string creating temporal objects. Every &lt;a href=&quot;manual#character-literals&quot;&gt;character literal&lt;/a&gt; newline combination (CR, LF, CR-LF) is supported.</source>
          <target state="translated">Это то же самое, что и &lt;code&gt;len(splitLines(s))&lt;/code&gt; , но гораздо более эффективно, потому что не изменяет строку, создающую временные объекты. Поддерживаются все &lt;a href=&quot;manual#character-literals&quot;&gt;символьные буквальные&lt;/a&gt; комбинации новой строки (CR, LF, CR-LF).</target>
        </trans-unit>
        <trans-unit id="8d22f203eebe945efff26b7c0264ae6e58250798" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;len(splitLines(s))&lt;/code&gt;, but much more efficient because it doesn't modify the string creating temporal objects. Every &lt;a href=&quot;manual#lexical-analysis-character-literals&quot;&gt;character literal&lt;/a&gt; newline combination (CR, LF, CR-LF) is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0badd9ad97e90a77853a8cbcdf1b0629e7129eff" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;name &amp;amp; ext&lt;/code&gt; from &lt;a href=&quot;#splitFile,string&quot;&gt;splitFile(path) proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d339aebbd92622e7b2312aac755921a2fe584d45" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;x - (x div y) * y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1888a678959ca4ae304b888c79aa8550425de069" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;x = x + {y}&lt;/code&gt;, but it might be more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae92e2d2df7af56345a63b06cbc0c4803a8fe53" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;x = x - {y}&lt;/code&gt;, but it might be more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a366ac081a365e2c46179906b192a6a0e436be" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;char&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2698b8a90aa68f611a0ef1370a3ab044cd78c8a1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;double&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="32b6f8ca0c7194eb4b06ee5d7e525de947b0dfd5" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;float&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;float&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1a9d8dde930868443d859228ae0d07c7a292dfc2" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это так же , как тип &lt;code&gt;int&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="89b75f0da7ac2537212723421db03228b32fdc6c" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. This C type is not supported by Nim's code generator.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;long double&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; . Этот тип C не поддерживается генератором кода Nim.</target>
        </trans-unit>
        <trans-unit id="a37990dbd3eb06078ca83a8a56a6c3bd79234e4f" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;long long&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1069dac8f5d3d5aa1a18361c4ff3f9b241cbf315" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;long&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7f6dc406a78e144191704d8486e22dc8fbe652f6" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как типа &lt;code&gt;short&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c3756c51223d58c50aef0d5dbf74eeee747dd1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;signed char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это же , как и тип &lt;code&gt;signed char&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf874f74960f31038430fb144d0f39aa055b895" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;size_t&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;size_t&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="df1c839c0f570919cf81eef346ac2a1dbb8ad2c9" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;unsigned char&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="32542074871fb6c497f5c1eb6606f80b3822a88a" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это так же , как тип &lt;code&gt;unsigned int&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="36b8d34561a415968642b59c4b4b326317e48753" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;unsigned long long&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0aa9bfe67b304447b5a2bcc627f38a17da1684d8" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;unsigned long&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cca46f57d68aae82238b145830c6ebed78c459d0" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">Это то же самое , как тип &lt;code&gt;unsigned short&lt;/code&gt; в &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7ec63cde9c899b1832f254d3a218fb0fdefa84a7" translate="yes" xml:space="preserve">
          <source>This is the same interface that is implemented for other databases.</source>
          <target state="translated">Это тот же самый интерфейс,который реализован для других баз данных.</target>
        </trans-unit>
        <trans-unit id="e8c042bee5c7ca8787fc37bf633177ab6f1481ae" translate="yes" xml:space="preserve">
          <source>This is the stdcall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__stdcall&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2276f3847dd82156bd01096eddf53801bbc1da1" translate="yes" xml:space="preserve">
          <source>This is thiscall calling convention as specified by Microsoft, used on C++ class member functions on the x86 architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d76cb52dda63a7debd58296187c89613b5d29c5" translate="yes" xml:space="preserve">
          <source>This is translated to a call to the &lt;code&gt;schema&lt;/code&gt; macro with a &lt;code&gt;nnkTypeDef&lt;/code&gt; AST node capturing both the left-hand side and right-hand side of the definition. The macro can return a potentially modified &lt;code&gt;nnkTypeDef&lt;/code&gt; tree which will replace the original row in the type section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b006c0a74e5f0b534a0cf75365ae7eaf0121b5e" translate="yes" xml:space="preserve">
          <source>This is translated to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39524a8c34f8678cfa0e73ee87c4662e966e0a89" translate="yes" xml:space="preserve">
          <source>This is used, for example, in the &lt;code&gt;bindSym&lt;/code&gt; examples &lt;a href=&quot;manual#macros-bindsym&quot;&gt;here&lt;/a&gt; and with &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; in the regular expression module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193cec7a7162a70eca01c095ac18043a02af9656" translate="yes" xml:space="preserve">
          <source>This is used, for example, in the &lt;code&gt;bindSym&lt;/code&gt; examples [here](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt;) and with &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; in the regular expression module.</source>
          <target state="translated">Это используется, например, в примерах &lt;code&gt;bindSym&lt;/code&gt; [здесь] ( &lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt; ) и с &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; в модуле регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="ca3384cc6ee2a6305631e3401a802d6acf72b3b1" translate="yes" xml:space="preserve">
          <source>This is useful for writing generic algorithms without performance loss. This generic implementation uses the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c869caa2cb0e2a4566d33db6c594392aa3e88fd" translate="yes" xml:space="preserve">
          <source>This is useful if you want to copy or save files across Windows, Linux, Mac, etc. You can pass full paths as argument too, but func only checks filenames. It uses &lt;code&gt;invalidFilenameChars&lt;/code&gt;, &lt;code&gt;invalidFilenames&lt;/code&gt; and &lt;code&gt;maxLen&lt;/code&gt; to verify the specified &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54a83cbed83c0f42bf0a73af1d5e007c04a1c74" translate="yes" xml:space="preserve">
          <source>This is useful when one overloaded &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; but still needs reference semantics for sharing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814be46e563ada83f9262b5e8d3fa69226b5320b" translate="yes" xml:space="preserve">
          <source>This is very fast, but potentially dangerous. Use this iterator only if you require &lt;strong&gt;ALL&lt;/strong&gt; the rows.</source>
          <target state="translated">Это очень быстро, но потенциально опасно. Используйте этот итератор, только если вам требуются &lt;strong&gt;ВСЕ&lt;/strong&gt; строки.</target>
        </trans-unit>
        <trans-unit id="134eddc978c41c43c45ed9c6b1ceb47614d9e60b" translate="yes" xml:space="preserve">
          <source>This isn't the same as &lt;code&gt;size_t&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. Don't use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0fbed086855b31d79192247a84655610b15079" translate="yes" xml:space="preserve">
          <source>This library relies on the header files of your C compiler. The resulting C code will just &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; define the symbols declared here.</source>
          <target state="translated">Эта библиотека полагается на файлы заголовков вашего компилятора C. Результирующий код C будет просто &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; и &lt;em&gt;не будет&lt;/em&gt; определять объявленные здесь символы.</target>
        </trans-unit>
        <trans-unit id="31048b78d2181ce88fb6bfd891a52408cadc9fbf" translate="yes" xml:space="preserve">
          <source>This macro also allows for (otherwise in-place) function chaining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bd537d709836e793cec8da49a638fdf122f928" translate="yes" xml:space="preserve">
          <source>This makes it easy to delete all generated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352e8583e6de97b799c5da9ed3e4a4e5b04d179b" translate="yes" xml:space="preserve">
          <source>This makes it easy to delete all generated files. Files generated in this directory follow a naming logic which you can read about in the &lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">Это упрощает удаление всех сгенерированных файлов. Файлы, созданные в этом каталоге, следуют логике именования, о которой вы можете прочитать в &lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt;документе Nim Backend Integration&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e986bf4a76bcf2a2515dce45f1d6c7ca80702bc0" translate="yes" xml:space="preserve">
          <source>This means that &quot;borrowed&quot; views can be written naturally and without explicit pointer indirections:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e5b1294716a2171951a03c64eda20f357eb30a" translate="yes" xml:space="preserve">
          <source>This means that any &lt;code&gt;%xx&lt;/code&gt; (where &lt;code&gt;xx&lt;/code&gt; denotes a hexadecimal value) are converted to the character with ordinal number &lt;code&gt;xx&lt;/code&gt;, and every other character is carried over. If &lt;code&gt;xx&lt;/code&gt; is not a valid hexadecimal value, it is left intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052067fc6ee68fa2f9dbd0b6a372e7c4df39a2b8" translate="yes" xml:space="preserve">
          <source>This means that any &lt;code&gt;'%xx'&lt;/code&gt; (where &lt;code&gt;xx&lt;/code&gt; denotes a hexadecimal value) are converted to the character with ordinal number &lt;code&gt;xx&lt;/code&gt;, and every other character is carried over.</source>
          <target state="translated">Это означает, что любые символы &lt;code&gt;'%xx'&lt;/code&gt; (где &lt;code&gt;xx&lt;/code&gt; обозначает шестнадцатеричное значение) преобразуются в символ с порядковым номером &lt;code&gt;xx&lt;/code&gt; , а все остальные символы переносятся.</target>
        </trans-unit>
        <trans-unit id="20eaeefb7ad0f37cbcfe130963c8445b739d8936" translate="yes" xml:space="preserve">
          <source>This means that characters in the set &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; are carried over to the result. All other characters are encoded as &lt;code&gt;%xx&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; denotes its hexadecimal value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a119e88cdea67075391ab49a84997ba0f8df61b5" translate="yes" xml:space="preserve">
          <source>This means that characters in the set &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; are carried over to the result. All other characters are encoded as &lt;code&gt;''%xx'&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; denotes its hexadecimal value.</source>
          <target state="translated">Это означает, что символы в наборе &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; переносятся в результат. Все остальные символы кодируются как &lt;code&gt;''%xx'&lt;/code&gt; где &lt;code&gt;xx&lt;/code&gt; обозначает его шестнадцатеричное значение.</target>
        </trans-unit>
        <trans-unit id="40b048bf83553881e511d74bd63cac489f70ae5d" translate="yes" xml:space="preserve">
          <source>This means that the slashes inside the base URI's path as well as reference URI's path affect the resulting URI.</source>
          <target state="translated">Это означает,что косые черты внутри пути базового URI,а также путь ссылочного URI влияют на результирующий URI.</target>
        </trans-unit>
        <trans-unit id="922850b50b784f0baf0fafd0fe540e7582cac936" translate="yes" xml:space="preserve">
          <source>This means that the slashes inside the base URIs path as well as reference URIs path affect the resulting URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d681cd1b517c30b7e61efd9d0f2710e753e51a4c" translate="yes" xml:space="preserve">
          <source>This means that when for some reason a procedure needs a disambiguation through the module name, the call needs to be written in function call syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef6d8c1596a849e1d58fe82a1e6a88d8d08fefb" translate="yes" xml:space="preserve">
          <source>This means the following compiles (for now) even though it really should not:</source>
          <target state="translated">Это означает,что следующие компилируют (пока),хотя на самом деле не должны:</target>
        </trans-unit>
        <trans-unit id="10445172840b8572e10f6fbc77991aa94729820e" translate="yes" xml:space="preserve">
          <source>This mechanism will be used by most data structures that support shared memory like channels to implement thread safe automatic memory management.</source>
          <target state="translated">Этот механизм будет использоваться большинством структур данных,поддерживающих общую память,таких как каналы,для реализации потокобезопасного автоматического управления памятью.</target>
        </trans-unit>
        <trans-unit id="5cce8e43b46c329ab2a3787ae9c0cae31bce9579" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used for any type:</source>
          <target state="translated">Синтаксис вызова этого метода не ограничен объектами,он может быть использован для любого типа:</target>
        </trans-unit>
        <trans-unit id="c18ebc20a57311d93348b03173ca9377d2b87fe3" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used to supply any type of first argument for procedures:</source>
          <target state="translated">Синтаксис вызова этого метода не ограничивается объектами,он может быть использован для подачи любого типа первого аргумента для процедур:</target>
        </trans-unit>
        <trans-unit id="7ec21e93e0cf3038676cfddb7994789208b8b989" translate="yes" xml:space="preserve">
          <source>This method ignores the list of registered handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86fc0ee3a63db9a4d667e5e9867b56be701b07c" translate="yes" xml:space="preserve">
          <source>This method is not available for the JavaScript backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f76b4fe4da8b8424258ff632b4b8aba97934a0" translate="yes" xml:space="preserve">
          <source>This modifies &lt;code&gt;s&lt;/code&gt; itself, it does not return a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f6408118ba81283de7ac109aa7b480ef6c069c" translate="yes" xml:space="preserve">
          <source>This modifies &lt;code&gt;x&lt;/code&gt; itself, it does not return a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a743fd1b7ce29c9eafd7535f1bcb06655400ac" translate="yes" xml:space="preserve">
          <source>This modifies &lt;em&gt;s&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="translated">Это изменяет сам &lt;em&gt;s&lt;/em&gt; , но не возвращает копию.</target>
        </trans-unit>
        <trans-unit id="399957ae50c4d50ec5409505af7d5ec3350ca32a" translate="yes" xml:space="preserve">
          <source>This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after &lt;code&gt;sort&lt;/code&gt; (in contrast to the &lt;a href=&quot;#sort,CountTable%5BA%5D&quot;&gt;sort proc&lt;/a&gt; for count tables).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2c1b5b7b769344ec6ebabe55a749624b20d2f0" translate="yes" xml:space="preserve">
          <source>This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after &lt;code&gt;sort&lt;/code&gt; (in contrast to the &lt;a href=&quot;#sort,CountTableRef%5BA%5D&quot;&gt;sort proc&lt;/a&gt; for count tables).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5bab7c7f53e383fb7fd313b6d6578109127b68" translate="yes" xml:space="preserve">
          <source>This module &lt;strong&gt;partially&lt;/strong&gt; implements an FTP client as specified by &lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959&lt;/a&gt;.</source>
          <target state="translated">Этот модуль &lt;strong&gt;частично&lt;/strong&gt; реализует FTP-клиент, как указано в &lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="353b9d1b799c5ad1bd4a492759bb6ea40d16c6be" translate="yes" xml:space="preserve">
          <source>This module allows high-level and efficient I/O multiplexing.</source>
          <target state="translated">Этот модуль обеспечивает высокоуровневое и эффективное мультиплексирование входов/выходов.</target>
        </trans-unit>
        <trans-unit id="77582b104bbd815cba00372c32475601c25cf527" translate="yes" xml:space="preserve">
          <source>This module allows you to access fields in a parsed JSON object in two different ways, one of them is described in this section.</source>
          <target state="translated">Данный модуль позволяет получить доступ к полям в разобранном JSON-объекте двумя разными способами,один из которых описан в данном разделе.</target>
        </trans-unit>
        <trans-unit id="b3498eb6ea3bb3348c1e6a56f205dc1cc756e769" translate="yes" xml:space="preserve">
          <source>This module also implements a &lt;code&gt;scanp&lt;/code&gt; macro, which syntax somewhat resembles an EBNF or PEG grammar, except that it uses Nim's expression syntax and so has to use prefix instead of postfix operators.</source>
          <target state="translated">Этот модуль также реализует макрос &lt;code&gt;scanp&lt;/code&gt; , синтаксис которого несколько напоминает грамматику EBNF или PEG, за исключением того, что он использует синтаксис выражений Nim и поэтому должен использовать префикс вместо операторов постфикса.</target>
        </trans-unit>
        <trans-unit id="ef44ae92a94357463ee874a1523c9d291e715eef" translate="yes" xml:space="preserve">
          <source>This module also implements the protocol used to format messages, as specified by RFC 2822.</source>
          <target state="translated">Данный модуль также реализует протокол,используемый для форматирования сообщений,как указано в RFC 2822.</target>
        </trans-unit>
        <trans-unit id="e13b1625e61f884e29573a44e8b33b49a44a5992" translate="yes" xml:space="preserve">
          <source>This module builds upon that, providing additional functionality in form of procedures, iterators and templates for strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cdfcb3c036a119b924e511faf70eaedadc90ee4" translate="yes" xml:space="preserve">
          <source>This module builds upon that, providing additional functionality in form of procs, iterators and templates inspired by functional programming languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47e628756db21f739b926daba1d8817fcf31162" translate="yes" xml:space="preserve">
          <source>This module can also be used to comfortably create JSON using the &lt;code&gt;%*&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5d643a068677170a94b694f4f1ab9c3fa2652e" translate="yes" xml:space="preserve">
          <source>This module can also be used to comfortably create JSON using the &lt;em&gt;%*&lt;/em&gt; operator:</source>
          <target state="translated">Этот модуль также можно использовать для удобного создания JSON с помощью оператора &lt;em&gt;% *&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="5ac6344a11b0cec8bee2e186a1f2d87c14205cf3" translate="yes" xml:space="preserve">
          <source>This module contains 'typeAllowed' and friends which check for invalid types like 'openArray[var int]'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e7d195d331b7d6c15e12922caec76c1b942621" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for locks and condition vars.</source>
          <target state="translated">Этот модуль содержит поддержку Nim's для замков и вар условий.</target>
        </trans-unit>
        <trans-unit id="762c0c406df7455c202f1f73c29bbcaf2e671b58" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for reentrant locks.</source>
          <target state="translated">Этот модуль содержит поддержку Nim's для реентерабельных замков.</target>
        </trans-unit>
        <trans-unit id="51e2b2a3ac1f926c532ebca53a22c529f45f34b9" translate="yes" xml:space="preserve">
          <source>This module contains SSL configuration parameters obtained from &lt;a href=&quot;https://wiki.mozilla.org/Security/Server_Side_TLS&quot;&gt;Mozilla OpSec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ca976fb8b35eb3df922d2b5066e9569252023d" translate="yes" xml:space="preserve">
          <source>This module contains a &lt;span id=&quot;scanf_1&quot;&gt;scanf&lt;/span&gt; macro that can be used for extracting substrings from an input string. This is often easier than regular expressions. Some examples as an appetizer:</source>
          <target state="translated">Этот модуль содержит макрос &lt;span id=&quot;scanf_1&quot;&gt;scanf,&lt;/span&gt; который можно использовать для извлечения подстрок из входной строки. Часто это проще, чем регулярные выражения. Некоторые примеры в качестве закуски:</target>
        </trans-unit>
        <trans-unit id="1489dea58f0e2e175da913a82f51d717b857c72e" translate="yes" xml:space="preserve">
          <source>This module contains a few procedures to control the &lt;em&gt;terminal&lt;/em&gt; (also called &lt;em&gt;console&lt;/em&gt;). On UNIX, the implementation simply uses ANSI escape sequences and does not depend on any other module, on Windows it uses the Windows API. Changing the style is permanent even after program termination! Use the code &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; to restore the defaults. Similarly, if you hide the cursor, make sure to unhide it with &lt;code&gt;showCursor&lt;/code&gt; before quitting.</source>
          <target state="translated">Этот модуль содержит несколько процедур для управления &lt;em&gt;терминалом&lt;/em&gt; (также называемым &lt;em&gt;консолью&lt;/em&gt; ). В UNIX реализация просто использует escape-последовательности ANSI и не зависит от каких-либо других модулей, в Windows она использует Windows API. Смена стиля сохраняется даже после выхода из программы! Используйте код &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; чтобы восстановить значения по умолчанию. Точно так же, если вы скрываете курсор, не забудьте показать его с помощью &lt;code&gt;showCursor&lt;/code&gt; перед выходом.</target>
        </trans-unit>
        <trans-unit id="7e93f8f54a9484fe22dcb778e11ee50ae595038e" translate="yes" xml:space="preserve">
          <source>This module contains a simple persistent id generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859cd9a84610a4573796c23e8584dde691268fe4" translate="yes" xml:space="preserve">
          <source>This module contains an algorithm to wordwrap a Unicode string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f440cc00bf2a40f36bf90840926be53d2b4581f" translate="yes" xml:space="preserve">
          <source>This module contains basic operating system facilities like retrieving environment variables, reading command line arguments, working with directories, running shell commands, etc.</source>
          <target state="translated">Этот модуль содержит базовые средства операционной системы,такие как получение переменных окружения,чтение аргументов командной строки,работа с каталогами,выполнение команд оболочки и т.д.</target>
        </trans-unit>
        <trans-unit id="aebeafbfc315baffdf1e6869390c403d1c5a4946" translate="yes" xml:space="preserve">
          <source>This module contains code for generating volatile loads and stores, which are useful in embedded and systems programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8484eb3bf4310e5df9a41c735476490885f266c" translate="yes" xml:space="preserve">
          <source>This module contains helpers for parsing tokens, numbers, identifiers, etc.</source>
          <target state="translated">Данный модуль содержит помощники для разбора токенов,чисел,идентификаторов и т.д.</target>
        </trans-unit>
        <trans-unit id="f6e5ce3fb2f04f76809ea7a033742e832b442a1c" translate="yes" xml:space="preserve">
          <source>This module contains helpers for parsing tokens, numbers, integers, floats, identifiers, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86de046f7b616971dd6062d8ab76fb2ee06ec285" translate="yes" xml:space="preserve">
          <source>This module contains helpers that deal with different byte orders (&lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt;).</source>
          <target state="translated">Этот модуль содержит помощников, которые работают с разным порядком байтов ( &lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="3507a070fad07c9f9b3947b600282a6e5783a4cf" translate="yes" xml:space="preserve">
          <source>This module contains procs for &lt;span id=&quot;serialization_1&quot;&gt;serialization&lt;/span&gt; and &lt;span id=&quot;deseralization_1&quot;&gt;deseralization&lt;/span&gt; of arbitrary Nim data structures. The serialization format uses &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;. Warning: The serialization format could change in future!</source>
          <target state="translated">Этот модуль содержит процедуры для &lt;span id=&quot;serialization_1&quot;&gt;сериализации&lt;/span&gt; и &lt;span id=&quot;deseralization_1&quot;&gt;десерализации&lt;/span&gt; произвольных структур данных Nim. Формат сериализации использует &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt; . Предупреждение: формат сериализации может измениться в будущем!</target>
        </trans-unit>
        <trans-unit id="5f95162e9e6ccb749f85b72f9199f205223155d1" translate="yes" xml:space="preserve">
          <source>This module contains procs for &lt;span id=&quot;serialization_1&quot;&gt;serialization&lt;/span&gt; and &lt;span id=&quot;deserialization_1&quot;&gt;deserialization&lt;/span&gt; of arbitrary Nim data structures. The serialization format uses &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371318c1a0161f22d8f2e0f2e50fa5c06ee82a39" translate="yes" xml:space="preserve">
          <source>This module contains routines and types for dealing with time using a proleptic Gregorian calendar. It's also available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">Этот модуль содержит процедуры и типы для работы со временем с использованием пролептического григорианского календаря. Он также доступен для &lt;a href=&quot;backends#the-javascript-target&quot;&gt;цели JavaScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="681edb1a4152d4c5c1a28a26efed7538442ba878" translate="yes" xml:space="preserve">
          <source>This module contains support for a &lt;span id=&quot;rope_1&quot;&gt;rope&lt;/span&gt; data type. Ropes can represent very long strings efficiently; especially concatenation is done in O(1) instead of O(n). They are essentially concatenation trees that are only flattened when converting to a native Nim string. The empty string is represented by &lt;code&gt;nil&lt;/code&gt;. Ropes are immutable and subtrees can be shared without copying. Leaves can be cached for better memory efficiency at the cost of runtime efficiency.</source>
          <target state="translated">Этот модуль поддерживает тип данных &lt;span id=&quot;rope_1&quot;&gt;веревки&lt;/span&gt; . Канаты могут эффективно представлять очень длинные струны; особенно конкатенация выполняется в O (1) вместо O (n). По сути, это деревья конкатенации, которые сглаживаются только при преобразовании в нативную строку Nim. Пустая строка представлена &lt;code&gt;nil&lt;/code&gt; . Веревки неизменяемы, и поддеревья могут использоваться совместно без копирования. Листья можно кэшировать для повышения эффективности использования памяти за счет эффективности времени выполнения.</target>
        </trans-unit>
        <trans-unit id="b376b4ebaaab23249fc9320639fee9fdc18842d7" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;code&gt;TMsgKind&lt;/code&gt; enum as well as the &lt;code&gt;TLineInfo&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8814cd36c6aae34db1d0386489c78e9dbe808ff" translate="yes" xml:space="preserve">
          <source>This module contains the data structures for the C code generation phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b114c265f10b8a271d8de9414b2aacb4dde589" translate="yes" xml:space="preserve">
          <source>This module contains the data structures for the semantic checking phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a18d40233e79f25223ec93664005a48f943242" translate="yes" xml:space="preserve">
          <source>This module contains the interface to the compiler's abstract syntax tree (&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;). Macros operate on this tree.</source>
          <target state="translated">Этот модуль содержит интерфейс к абстрактному синтаксическому дереву компилятора ( &lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt; ). Макросы работают с этим деревом.</target>
        </trans-unit>
        <trans-unit id="94973e879d7e0d952c022e954deb2fbb3c8e206b" translate="yes" xml:space="preserve">
          <source>This module contains the type definitions for the new evaluation engine. An instruction is 1-3 int32s in memory, it is a register based VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a11c4dcef359935de61e37ffe6d34cb9d89068f" translate="yes" xml:space="preserve">
          <source>This module contains various string matchers for email addresses, etc.</source>
          <target state="translated">Данный модуль содержит различные строковые матчи для email адресов и т.д.</target>
        </trans-unit>
        <trans-unit id="dc6f5f3c4d5eabca058f0bb06a0585786c4d3b49" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines that are uncommonly used in comparison to &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;.</source>
          <target state="translated">Этот модуль содержит различные служебные программы для работы со строками, которые редко используются по сравнению со &lt;a href=&quot;strutils&quot;&gt;структурами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d2fcdeecb346421f24a622468611b1e35012c38" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines. See the module &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for regular expression support. See the module &lt;a href=&quot;pegs&quot;&gt;pegs&lt;/a&gt; for PEG support. This module is available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">Этот модуль содержит различные служебные программы для работы со строками. См. Модуль &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; для поддержки регулярных выражений. См. &lt;a href=&quot;pegs&quot;&gt;Крепления&lt;/a&gt; модуля для поддержки PEG. Этот модуль доступен для &lt;a href=&quot;backends#the-javascript-target&quot;&gt;цели JavaScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47c439c96c86563186d79ec7720605588cc9ed86" translate="yes" xml:space="preserve">
          <source>This module defines compile-time reflection procs for working with types</source>
          <target state="translated">В данном модуле задаются параметры для работы с типами,отражающими время компиляции.</target>
        </trans-unit>
        <trans-unit id="60144eff5e3a9e63fbb73c5a6a2dab67f8c5d761" translate="yes" xml:space="preserve">
          <source>This module defines compile-time reflection procs for working with types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c756bd0d905b898b07e1bbf5dac867ce5994db8" translate="yes" xml:space="preserve">
          <source>This module does not implement any ORM features such as mapping the types from the schema. Instead, a &lt;code&gt;seq[string]&lt;/code&gt; is returned for each row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de4eb1c72ff111a775ba8d7bcc00cdb24085f9e" translate="yes" xml:space="preserve">
          <source>This module implements URI parsing as specified by RFC 3986.</source>
          <target state="translated">Этот модуль реализует парсинг URI в соответствии с RFC 3986.</target>
        </trans-unit>
        <trans-unit id="27f7329a9231fa9eb3dabedee0d7ec09c071c36c" translate="yes" xml:space="preserve">
          <source>This module implements XML DOM Level 2 Core specification (&lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt;)</source>
          <target state="translated">Этот модуль реализует базовую спецификацию XML DOM уровня 2 ( &lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1270c3451976ca2c6dbe064b63a8c754c870a12f" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;crit-bit-tree_1&quot;&gt;crit bit tree&lt;/span&gt; which is an efficient container for a sorted set of strings, or for a sorted mapping of strings. Based on the excellent paper by Adam Langley. (A crit bit tree is a form of &lt;span id=&quot;radix-tree_1&quot;&gt;radix tree&lt;/span&gt; or &lt;span id=&quot;patricia-trie_1&quot;&gt;patricia trie&lt;/span&gt;.)</source>
          <target state="translated">Этот модуль реализует &lt;span id=&quot;crit-bit-tree_1&quot;&gt;дерево битов крита,&lt;/span&gt; которое является эффективным контейнером для отсортированного набора строк или для отсортированного отображения строк. Основано на отличной статье Адама Лэнгли. (Дерево битов крита - это форма &lt;span id=&quot;radix-tree_1&quot;&gt;дерева счисления&lt;/span&gt; или &lt;span id=&quot;radix-tree_1&quot;&gt;дерева &lt;/span&gt;&lt;span id=&quot;patricia-trie_1&quot;&gt;патриции&lt;/span&gt; .)</target>
        </trans-unit>
        <trans-unit id="d33fc50e3ca1debee0d3e81969fe922a6c7f125b" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser. A large subset is implemented. Some features of the &lt;span id=&quot;markdown_1&quot;&gt;markdown&lt;/span&gt; wiki syntax are also supported.</source>
          <target state="translated">Этот модуль реализует парсер &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; . Реализовано большое подмножество. Также поддерживаются некоторые функции синтаксиса &lt;span id=&quot;markdown_1&quot;&gt;markdown&lt;/span&gt; wiki.</target>
        </trans-unit>
        <trans-unit id="6977f3d46bd112fbaa438f57a03c83e720c94436" translate="yes" xml:space="preserve">
          <source>This module implements a base object of a lexer with efficient buffer handling. Only at line endings checks are necessary if the buffer needs refilling.</source>
          <target state="translated">Данный модуль реализует базовый объект лексера с эффективной обработкой буфера.Проверка окончаний строк необходима только в том случае,если буфер нуждается в пополнении.</target>
        </trans-unit>
        <trans-unit id="df7211c34a2ecd3f4fc0d583c3ad6e78e895ee92" translate="yes" xml:space="preserve">
          <source>This module implements a base64 encoder and decoder.</source>
          <target state="translated">Этот модуль реализует кодировщик и декодер base64.</target>
        </trans-unit>
        <trans-unit id="6081002e18d54466e7c5566ce284e757eba696e6" translate="yes" xml:space="preserve">
          <source>This module implements a generator of HTML/Latex from &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; (see &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; for information on this markup syntax) and is used by the compiler's &lt;a href=&quot;docgen&quot;&gt;docgen tools&lt;/a&gt;.</source>
          <target state="translated">Этот модуль реализует генератор HTML / Latex из &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; (см. &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;Http://docutils.sourceforge.net/rst.html&lt;/a&gt; информацию об этом синтаксисе разметки) и используется &lt;a href=&quot;docgen&quot;&gt;инструментами docgen&lt;/a&gt; компилятора .</target>
        </trans-unit>
        <trans-unit id="17f9d509be6ad16b77fcf94001ab38bee17334b5" translate="yes" xml:space="preserve">
          <source>This module implements a generator of HTML/Latex from &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; (see &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; for information on this markup syntax) and is used by the compiler's &lt;a href=&quot;https://nim-lang.org/docs/docgen.html&quot;&gt;docgen tools&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e24ad7c182e7005c7758742478f3329d0f6132c" translate="yes" xml:space="preserve">
          <source>This module implements a helper for a thread pool to determine whether creating a thread is a good idea.</source>
          <target state="translated">Этот модуль реализует помощник для пула потоков,чтобы определить,является ли создание потока является хорошей идеей.</target>
        </trans-unit>
        <trans-unit id="454ce041e8ff19cc3f47caab96d62276cdca14fe" translate="yes" xml:space="preserve">
          <source>This module implements a high performance asynchronous HTTP server.</source>
          <target state="translated">Данный модуль реализует высокопроизводительный асинхронный HTTP-сервер.</target>
        </trans-unit>
        <trans-unit id="55bdd10c5a5f89322ba8a15e1873d103379babdc" translate="yes" xml:space="preserve">
          <source>This module implements a high-level asynchronous sockets API based on the asynchronous dispatcher defined in the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="translated">Этот модуль реализует высокоуровневый API асинхронных сокетов на основе асинхронного диспетчера, определенного в модуле &lt;code&gt;asyncdispatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="141c50103e76c15b79b0d58835babe4f607c974d" translate="yes" xml:space="preserve">
          <source>This module implements a high-level cross-platform sockets interface. The procedures implemented in this module are primarily for blocking sockets. For asynchronous non-blocking sockets use the &lt;code&gt;asyncnet&lt;/code&gt; module together with the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="translated">Этот модуль реализует высокоуровневый кроссплатформенный интерфейс сокетов. Процедуры, реализованные в этом модуле, в основном предназначены для блокировки сокетов. Для асинхронных неблокирующих сокетов используйте модуль &lt;code&gt;asyncnet&lt;/code&gt; вместе с модулем &lt;code&gt;asyncdispatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db9ba48b68fd354aaa5fc20475e579aac2d2654d" translate="yes" xml:space="preserve">
          <source>This module implements a json parser. It is used and exported by the &lt;code&gt;json&lt;/code&gt; standard library module, but can also be used in its own right.</source>
          <target state="translated">Этот модуль реализует парсер json. Он используется и экспортируется модулем стандартной библиотеки &lt;code&gt;json&lt;/code&gt; , но может использоваться и сам по себе.</target>
        </trans-unit>
        <trans-unit id="b1fdd4da540e62b9188383b60a46eeb260182e77" translate="yes" xml:space="preserve">
          <source>This module implements a low-level cross-platform sockets interface. Look at the &lt;code&gt;net&lt;/code&gt; module for the higher-level version.</source>
          <target state="translated">Этот модуль реализует низкоуровневый кроссплатформенный интерфейс сокетов. Посмотрите на &lt;code&gt;net&lt;/code&gt; модуль для версии более высокого уровня.</target>
        </trans-unit>
        <trans-unit id="ffb0db7a5f8cb3e13d15cfbadb31dc0a731e0b20" translate="yes" xml:space="preserve">
          <source>This module implements a mimetypes database</source>
          <target state="translated">Данный модуль реализует базу данных миметипов</target>
        </trans-unit>
        <trans-unit id="52c7b497a1d812a7103e93d248b7ce30058bcc07" translate="yes" xml:space="preserve">
          <source>This module implements a series of low level methods for bit manipulation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369970703d77f45ce74f0890d99dc3ad540cefb1" translate="yes" xml:space="preserve">
          <source>This module implements a series of low level methods for bit manipulation. By default, this module use compiler intrinsics to improve performance on supported compilers: &lt;code&gt;GCC&lt;/code&gt;, &lt;code&gt;LLVM_GCC&lt;/code&gt;, &lt;code&gt;CLANG&lt;/code&gt;, &lt;code&gt;VCC&lt;/code&gt;, &lt;code&gt;ICC&lt;/code&gt;.</source>
          <target state="translated">Этот модуль реализует серию низкоуровневых методов для манипулирования битами. По умолчанию этот модуль использует встроенные функции компилятора для повышения производительности на поддерживаемых компиляторах: &lt;code&gt;GCC&lt;/code&gt; , &lt;code&gt;LLVM_GCC&lt;/code&gt; , &lt;code&gt;CLANG&lt;/code&gt; , &lt;code&gt;VCC&lt;/code&gt; , &lt;code&gt;ICC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a72068a61f0ac219b08c124ba6a885d3d706a6f" translate="yes" xml:space="preserve">
          <source>This module implements a simple &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; and &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; code generator. Each commonly used HTML tag has a corresponding macro that generates a string with its HTML representation.</source>
          <target state="translated">Этот модуль реализует простой генератор кода &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; и &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; . Каждый часто используемый HTML-тег имеет соответствующий макрос, который генерирует строку с ее HTML-представлением.</target>
        </trans-unit>
        <trans-unit id="85bfb7ff9d532c8dadfbbeaebbf969dd68bafa42" translate="yes" xml:space="preserve">
          <source>This module implements a simple HTTP client that can be used to retrieve webpages and other data.</source>
          <target state="translated">Этот модуль реализует простой HTTP-клиент,который может быть использован для получения веб-страниц и других данных.</target>
        </trans-unit>
        <trans-unit id="042f483a9df711dab36503622086bf978deae7dc" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt; (&lt;span id=&quot;comma-separated-value_1&quot;&gt;comma separated value&lt;/span&gt;) parser.</source>
          <target state="translated">Этот модуль реализует простой высокопроизводительный анализатор &lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt; ( &lt;span id=&quot;comma-separated-value_1&quot;&gt;значения, разделенные запятыми&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="79501d3f5ff57c410bf937ebfdaefd4be7b9f7d2" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt; parser. JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write (unlike XML). It is easy for machines to parse and generate. JSON is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.</source>
          <target state="translated">Этот модуль реализует простой высокопроизводительный парсер &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt; . JSON (объектная нотация JavaScript) - это легкий формат обмена данными, который людям легко читать и писать (в отличие от XML). Машины легко анализируют и генерируют. JSON основан на подмножестве языка программирования JavaScript, Standard ECMA-262 3rd Edition - December 1999.</target>
        </trans-unit>
        <trans-unit id="06a978a90f444ab2e371ab0e33c92d28de7bff58" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; parser. The only encoding that is supported is UTF-8. The parser has been designed to be somewhat error correcting, so that even most &quot;wild HTML&quot; found on the web can be parsed with it. &lt;strong&gt;Note:&lt;/strong&gt; This parser does not check that each &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; has a corresponding &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt;! These checks have do be implemented by the client code for various reasons:</source>
          <target state="translated">Этот модуль реализует простой высокопроизводительный анализатор &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; . Единственная поддерживаемая кодировка - UTF-8. Синтаксический анализатор был разработан таким образом, чтобы в некоторой степени исправлять ошибки, так что с его помощью можно проанализировать даже самый &quot;дикий HTML&quot;, найденный в сети. &lt;strong&gt;Примечание.&lt;/strong&gt; Этот синтаксический анализатор не проверяет наличие у каждого &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; соответствующего &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt; ! Эти проверки должны выполняться клиентским кодом по разным причинам:</target>
        </trans-unit>
        <trans-unit id="a0c65178c960a4c67a65aebfc6e35293749e48ed" translate="yes" xml:space="preserve">
          <source>This module implements a simple logger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48947ec421a5467d0d646e322ab81e8c9a02a691" translate="yes" xml:space="preserve">
          <source>This module implements a simple logger. It has been designed to be as simple as possible to avoid bloat, if this library does not fulfill your needs, write your own.</source>
          <target state="translated">Этот модуль реализует простой регистратор.Он был разработан,чтобы быть как можно более простым,чтобы избежать раздувания,если эта библиотека не удовлетворяет вашим потребностям,пишите свои собственные.</target>
        </trans-unit>
        <trans-unit id="3dadb028527d802791d6f87341aff532946953c1" translate="yes" xml:space="preserve">
          <source>This module implements a simple proc for opening URLs with the user's default browser.</source>
          <target state="translated">В этом модуле реализована простая proc для открытия URL в браузере пользователя по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7fb049b95846bb771385f79aa14ac44a91216509" translate="yes" xml:space="preserve">
          <source>This module implements a small wrapper for some needed Win API procedures, so that the Nim compiler does not depend on the huge Windows module.</source>
          <target state="translated">Этот модуль реализует небольшую обертку для некоторых необходимых Win API процедур,чтобы компилятор Nim не зависел от огромного модуля Windows.</target>
        </trans-unit>
        <trans-unit id="5ac84b13286763d5a846ef3e91168372a188a0b8" translate="yes" xml:space="preserve">
          <source>This module implements an AST for the &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser.</source>
          <target state="translated">Этот модуль реализует AST для парсера &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="be080849cfa6c4b49c9b095ad65b6fcaae6e195d" translate="yes" xml:space="preserve">
          <source>This module implements an advanced facility for executing OS processes and process communication.</source>
          <target state="translated">В данном модуле реализован расширенный функционал для выполнения процессов и взаимодействия с операционной системой.</target>
        </trans-unit>
        <trans-unit id="0ecce61f14e63c77639e9bbde5141d17de0e240e" translate="yes" xml:space="preserve">
          <source>This module implements an algorithm to compute the &lt;span id=&quot;edit-distance_1&quot;&gt;edit distance&lt;/span&gt; between two Unicode strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4019f34ee73cf2afc6617ad82d4cc99b8a1651c5" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous FTP client. It allows you to connect to an FTP server and perform operations on it such as for example:</source>
          <target state="translated">Данный модуль реализует асинхронный FTP-клиент.Он позволяет подключаться к FTP-серверу и выполнять над ним такие операции,как,например:</target>
        </trans-unit>
        <trans-unit id="13879d8d10926994138f177a507809351445a9d4" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous event loop together with asynchronous sockets which use this event loop. It is akin to Python's asyncore module. Many modules that use sockets have an implementation for this module, those modules should all have a &lt;code&gt;register&lt;/code&gt; function which you should use to add the desired objects to a dispatcher which you created so that you can receive the events associated with that module's object.</source>
          <target state="translated">Этот модуль реализует асинхронный цикл событий вместе с асинхронными сокетами, которые используют этот цикл событий. Это похоже на модуль asyncore Python. Многие модули, использующие сокеты, имеют реализацию для этого модуля, все эти модули должны иметь функцию &lt;code&gt;register&lt;/code&gt; которую вы должны использовать для добавления желаемых объектов в созданный вами диспетчер, чтобы вы могли получать события, связанные с объектом этого модуля.</target>
        </trans-unit>
        <trans-unit id="631695dd25ee11fd41bde8946a743e509c7a762f" translate="yes" xml:space="preserve">
          <source>This module implements an interface to Nim's &lt;span id=&quot;runtime-type-information_1&quot;&gt;runtime type information&lt;/span&gt; (&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;). Note that even though &lt;code&gt;Any&lt;/code&gt; and its operations hide the nasty low level details from its clients, it remains inherently unsafe!</source>
          <target state="translated">Этот модуль реализует интерфейс к информации о &lt;span id=&quot;runtime-type-information_1&quot;&gt;типах времени выполнения&lt;/span&gt; ( &lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt; ) Nim . Обратите внимание, что даже если &lt;code&gt;Any&lt;/code&gt; и его операции скрывают неприятные подробности низкого уровня от клиентов, он остается небезопасным по своей сути!</target>
        </trans-unit>
        <trans-unit id="a745aa0375a74f7df55bc17c9183f618e2e8312e" translate="yes" xml:space="preserve">
          <source>This module implements an interface to Nim's &lt;span id=&quot;runtime-type-information_1&quot;&gt;runtime type information&lt;/span&gt; (&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;). See the &lt;a href=&quot;marshal&quot;&gt;marshal&lt;/a&gt; module for an example of what this module allows you to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743043f366d434da8a30113b7bbb02a151e1774b" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous IO. This includes a dispatcher, a &lt;code&gt;Future&lt;/code&gt; type implementation, and an &lt;code&gt;async&lt;/code&gt; macro which allows asynchronous code to be written in a synchronous style with the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">Этот модуль реализует асинхронный ввод-вывод. Сюда входят диспетчер, реализация типа &lt;code&gt;Future&lt;/code&gt; и макрос &lt;code&gt;async&lt;/code&gt; , который позволяет писать асинхронный код в синхронном стиле с ключевым словом &lt;code&gt;await&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff0fc0b254406eef01f02b40f3655696591bd82c" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous file reading and writing.</source>
          <target state="translated">Этот модуль реализует асинхронное чтение и запись файлов.</target>
        </trans-unit>
        <trans-unit id="be0a15236b06fa556c56498d41940c7197453f73" translate="yes" xml:space="preserve">
          <source>This module implements boilerplate to make unit testing easy.</source>
          <target state="translated">В этом модуле реализована шаблонная плита,которая облегчает тестирование агрегата.</target>
        </trans-unit>
        <trans-unit id="909c88835454bdf5c0519702c5f2c7e4a9275b55" translate="yes" xml:space="preserve">
          <source>This module implements code generation for methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb823571314137136b672c316a1e4f9478ba59e" translate="yes" xml:space="preserve">
          <source>This module implements color handling for Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb52bf0d87731597af09d97960c22d019bf58d4" translate="yes" xml:space="preserve">
          <source>This module implements color handling for Nim. It is used by the &lt;code&gt;graphics&lt;/code&gt; module.</source>
          <target state="translated">Этот модуль реализует обработку цвета для Nim. Он используется &lt;code&gt;graphics&lt;/code&gt; модулем.</target>
        </trans-unit>
        <trans-unit id="7b8921996b5c256e40c5e6c977e3725a0386307f" translate="yes" xml:space="preserve">
          <source>This module implements common simple lowerings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7729efb631e2eb7bcfa9fd3c15327853bf181948" translate="yes" xml:space="preserve">
          <source>This module implements complex numbers.</source>
          <target state="translated">В этом модуле реализованы комплексные номера.</target>
        </trans-unit>
        <trans-unit id="aeaf9342dd5833ed552b5a2102d34b6d6ec873cf" translate="yes" xml:space="preserve">
          <source>This module implements complex numbers. Complex numbers are currently implemented as generic on a 64-bit or 32-bit float.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fb167dafb36722d30f92f4593ecfc130a3dae2" translate="yes" xml:space="preserve">
          <source>This module implements efficient computations of hash values for diverse Nim types. All the procs are based on these two building blocks:</source>
          <target state="translated">Данный модуль реализует эффективные вычисления хэш-значений для различных типов Nim.Все проки основаны на этих двух строительных блоках:</target>
        </trans-unit>
        <trans-unit id="94a7c29bf4d442270eb47c16d094dbac2bb71a71" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for CGI applications. Example:</source>
          <target state="translated">В этом модуле реализованы вспомогательные средства для CGI-приложений.Пример:</target>
        </trans-unit>
        <trans-unit id="06e4f877dc2f02ff6d7623b1d21e1442d6e6e0aa" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for SCGI applications. Example:</source>
          <target state="translated">В этом модуле реализованы вспомогательные средства для SCGI-приложений.Пример:</target>
        </trans-unit>
        <trans-unit id="00f7e73405ca98ef55459bd8cb137c930c54ce67" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for parsing Cookies.</source>
          <target state="translated">В этом модуле реализованы вспомогательные средства для разбора Cookie-файлов.</target>
        </trans-unit>
        <trans-unit id="0d7dad71176a5274e0ff15c36d8d42475024e144" translate="yes" xml:space="preserve">
          <source>This module implements helpers for the macro cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7aa9306839a9e2f1eb10857736527eb56ecd2a" translate="yes" xml:space="preserve">
          <source>This module implements lifting for type-bound operations (&lt;code&gt;=sink&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;=destroy&lt;/code&gt;, &lt;code&gt;=deepCopy&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa51e0bbdd73802dae08d36a67835190e007e6d" translate="yes" xml:space="preserve">
          <source>This module implements nice syntactic sugar based on Nim's macro system.</source>
          <target state="translated">Этот модуль реализует приятный синтаксический сахар,основанный на макросистеме Nim.</target>
        </trans-unit>
        <trans-unit id="605fb43c6c6ebd7d6234f48fb476d48d8bab0b46" translate="yes" xml:space="preserve">
          <source>This module implements operations for the built-in &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; type which were inspired by functional programming languages.</source>
          <target state="translated">Этот модуль реализует операции для встроенного типа &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; , вдохновленные языками функционального программирования.</target>
        </trans-unit>
        <trans-unit id="03602f44dc99d2a2f1feb228793b9d5dc7bd7cfd" translate="yes" xml:space="preserve">
          <source>This module implements portable sockets, it supports a mix of different types of sockets. Sockets are buffered by default meaning that data will be received in &lt;code&gt;BufferSize&lt;/code&gt; (4000) sized chunks, buffering behaviour can be disabled by setting the &lt;code&gt;buffered&lt;/code&gt; parameter when calling the &lt;code&gt;socket&lt;/code&gt; function to &lt;em&gt;false&lt;/em&gt;. Be aware that some functions may not yet support buffered sockets (mainly the recvFrom function).</source>
          <target state="translated">Этот модуль реализует портативные сокеты, он поддерживает сочетание разных типов сокетов. По умолчанию сокеты буферизуются, что означает, что данные будут приниматься фрагментами размером &lt;code&gt;BufferSize&lt;/code&gt; (4000), поведение буферизации можно отключить, установив параметр &lt;code&gt;buffered&lt;/code&gt; при вызове функции &lt;code&gt;socket&lt;/code&gt; в значение &lt;em&gt;false&lt;/em&gt; . Имейте в виду, что некоторые функции могут еще не поддерживать буферизованные сокеты (в основном функция recvFrom).</target>
        </trans-unit>
        <trans-unit id="1e03448c70f64476d8a1af87251f0850a190b56c" translate="yes" xml:space="preserve">
          <source>This module implements procs to determine the number of CPUs / cores.</source>
          <target state="translated">В данном модуле реализованы процессоры для определения количества процессоров/ядер.</target>
        </trans-unit>
        <trans-unit id="75d697bfa5c4fe5f66a9e6c4166274beadef8e27" translate="yes" xml:space="preserve">
          <source>This module implements rational numbers, consisting of a numerator &lt;code&gt;num&lt;/code&gt; and a denominator &lt;code&gt;den&lt;/code&gt;, both of type int. The denominator can not be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b020312c18d7f1e3e79c3c6ff8a468feda67a72" translate="yes" xml:space="preserve">
          <source>This module implements rational numbers, consisting of a numerator &lt;em&gt;num&lt;/em&gt; and a denominator &lt;em&gt;den&lt;/em&gt;, both of type int. The denominator can not be 0.</source>
          <target state="translated">Этот модуль реализует рациональные числа, состоящие из числителя &lt;em&gt;num&lt;/em&gt; и знаменателя &lt;em&gt;den&lt;/em&gt; , оба типа int. Знаменатель не может быть 0.</target>
        </trans-unit>
        <trans-unit id="5cf5cab5d8bf4f6c2215c0c3d51c3ca1a3596a21" translate="yes" xml:space="preserve">
          <source>This module implements semantic checking for calls.this module does the semantic checking of statementsThis module does the semantic transformation of the fields* iterators.This module implements Nim's object construction rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fdbdda66a11d9e4dcd5f67ececbd1313751a08" translate="yes" xml:space="preserve">
          <source>This module implements some common generic algorithms.</source>
          <target state="translated">В этом модуле реализованы некоторые общие алгоритмы.</target>
        </trans-unit>
        <trans-unit id="15596de96df6a5d16f5a2c6304d05b802e3f3dd2" translate="yes" xml:space="preserve">
          <source>This module implements stream wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6360fdb1a0d14929ad9c3c0a54011a7ceeb73b7" translate="yes" xml:space="preserve">
          <source>This module implements the '.liftLocals' pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11c7939e3afe546c05d00ad6b841be9456fe883" translate="yes" xml:space="preserve">
          <source>This module implements the 'implies' relation for guards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324900edca6f658b4339cf4b65eb81ff95b693e9" translate="yes" xml:space="preserve">
          <source>This module implements the C code generator.This include file contains the logic to produce constant string and seq literals. The code here is responsible that &lt;code&gt;const x = [&quot;a&quot;, &quot;b&quot;]&lt;/code&gt; works without hidden runtime creation code. The price is that seqs and strings are not purely a library implementation.Generates traversal procs for the C backend.Code specialization instead of the old, incredibly slow 'genericReset' implementation.Thread var support for crappy architectures that lack native support for thread local storage. (&lt;strong&gt;Thank you Mac OS X!&lt;/strong&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5033575ad43160cfe00aa6032cd8e72c2229f7f9" translate="yes" xml:space="preserve">
          <source>This module implements the SMTP client protocol as specified by RFC 5321, this can be used to send mail to any SMTP Server.</source>
          <target state="translated">Этот модуль реализует протокол SMTP клиента,как указано в RFC 5321,это может быть использовано для отправки почты на любой SMTP сервер.</target>
        </trans-unit>
        <trans-unit id="0a6a93e5b19faa7bc126c3e2fc94d788bde65745" translate="yes" xml:space="preserve">
          <source>This module implements the ability to access symbols from shared libraries. On POSIX this uses the &lt;code&gt;dlsym&lt;/code&gt; mechanism, on Windows &lt;code&gt;LoadLibrary&lt;/code&gt;.</source>
          <target state="translated">Этот модуль реализует возможность доступа к символам из разделяемых библиотек. В POSIX используется механизм &lt;code&gt;dlsym&lt;/code&gt; , в Windows &lt;code&gt;LoadLibrary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3873bd4d455f4aaaae3cbab2055aa96d93f86ba" translate="yes" xml:space="preserve">
          <source>This module implements the basics for Linux distribution (&quot;distro&quot;) detection and the OS's native package manager. Its primary purpose is to produce output for Nimble packages like:</source>
          <target state="translated">В этом модуле реализованы основы определения дистрибутива Linux (&quot;distro&quot;)и нативный менеджер пакетов ОС.Его основная цель-производить вывод для Nimble-пакетов типа:</target>
        </trans-unit>
        <trans-unit id="a0923959ce15bcdc564ea4a58b3ac4fecf2023c6" translate="yes" xml:space="preserve">
          <source>This module implements the canonalization for the various caching mechanisms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07a4bf44a78d1d257e8619bf8a77573a5a9c90b" translate="yes" xml:space="preserve">
          <source>This module implements the code generator for the VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a38d94bda812e8dfd26d5856d7d5a0ebec8243b" translate="yes" xml:space="preserve">
          <source>This module implements the generation of &lt;code&gt;.ndi&lt;/code&gt; files for better debugging support of Nim code. &quot;ndi&quot; stands for &quot;Nim debug info&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6156a97839b4290df6ebce6deed6bed5a01d783" translate="yes" xml:space="preserve">
          <source>This module implements the merge operation of 2 different C files. This is needed for incremental compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10dd027360f5be6d220e9a48b8828a68cc03c43" translate="yes" xml:space="preserve">
          <source>This module implements the module graph data structure. The module graph represents a complete Nim project. Single modules can either be kept in RAM or stored in a Sqlite database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870290fb4763d9ca97f463a24d11a0f61a137a38" translate="yes" xml:space="preserve">
          <source>This module implements the passes functionality. A pass must implement the &lt;code&gt;TPass&lt;/code&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcd3512a3ab958ff6ee67f05599b41b02ebd9df" translate="yes" xml:space="preserve">
          <source>This module implements the pattern matching features for term rewriting macro support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70367e3386c4a0bfa37a82d45a19f9a7ed417f54" translate="yes" xml:space="preserve">
          <source>This module implements the signature matching for resolving the call to overloaded procs, generic procs and operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7af9f244bfd95dc4b59560e53168beb2ea1039" translate="yes" xml:space="preserve">
          <source>This module implements the style checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf87db50efeea8af15f9c9cb3ade6f25c05a723d" translate="yes" xml:space="preserve">
          <source>This module implements the symbol importing mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5c7b7b5304374db892e2c02470b732730375fb" translate="yes" xml:space="preserve">
          <source>This module implements threadpool's &lt;code&gt;spawn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b881f434ad53307745d9873f33cc83cdf48e46" translate="yes" xml:space="preserve">
          <source>This module implements types and macros for writing asynchronous code for the JS backend. It provides tools for interaction with JavaScript async API-s and libraries, writing async procedures in Nim and converting callback-based code to promises.</source>
          <target state="translated">Данный модуль реализует типы и макросы для написания асинхронного кода для JS-бекенда.Он предоставляет инструменты для взаимодействия с JavaScript async API и библиотеками,написания асинхронных процедур в Nim и преобразования кода,основанного на обратном вызове,в обещания.</target>
        </trans-unit>
        <trans-unit id="96a223a86302396be5588794d00dcc5a992fb05a" translate="yes" xml:space="preserve">
          <source>This module implements types which encapsulate an optional value.</source>
          <target state="translated">Данный модуль реализует типы,которые инкапсулируют дополнительное значение.</target>
        </trans-unit>
        <trans-unit id="8b05223d9ca6772d764f5fcaadb7295f47ed88d6" translate="yes" xml:space="preserve">
          <source>This module is a sample.</source>
          <target state="translated">Этот модуль является образцом.</target>
        </trans-unit>
        <trans-unit id="a2a203baf067681d5e0468d7220606f23e9f491a" translate="yes" xml:space="preserve">
          <source>This module is also compatible with other backends: &lt;code&gt;Javascript&lt;/code&gt;, &lt;code&gt;Nimscript&lt;/code&gt; as well as the &lt;code&gt;compiletime VM&lt;/code&gt;.</source>
          <target state="translated">Этот модуль также совместим с другими бэкэндами: &lt;code&gt;Javascript&lt;/code&gt; , &lt;code&gt;Nimscript&lt;/code&gt; , а также с &lt;code&gt;compiletime VM&lt;/code&gt; времени компиляции .</target>
        </trans-unit>
        <trans-unit id="f3531490dbe3e2f25dede9c41e4fcef79b629cad" translate="yes" xml:space="preserve">
          <source>This module is available for the &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ac486e597f76fa9f3aeade5377d8139863cf06" translate="yes" xml:space="preserve">
          <source>This module is based on Python's Unidecode module by Tomaz Solc, which in turn is based on the &lt;code&gt;Text::Unidecode&lt;/code&gt; Perl module by Sean M. Burke (&lt;a href=&quot;http://search.cpan.org/~sburke/Text-Unidecode-0.04/lib/Text/Unidecode.pm&quot;&gt;http://search.cpan.org/~sburke/Text-Unidecode-0.04/lib/Text/Unidecode.pm&lt;/a&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12453f55babdb4a27c1f7e732c0c542926e9cbdc" translate="yes" xml:space="preserve">
          <source>This module is experimental and its interface may change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcaffb7c268575c15a197b066d88f31f66ee5014" translate="yes" xml:space="preserve">
          <source>This module is for compiler internal use only. For reliable error messages and range checks, the compiler needs a data type that can hold all from &lt;code&gt;low(BiggestInt)&lt;/code&gt; to &lt;code&gt;high(BiggestUInt)&lt;/code&gt;, This type is for that purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5689b667695647b8ab8ef22840d0cdf1b5bb67f" translate="yes" xml:space="preserve">
          <source>This module is implemented by providing a wrapper around the &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE (Perl-Compatible Regular Expressions)&lt;/a&gt; C library. This means that your application will depend on the PCRE library's licence when using this module, which should not be a problem though. PCRE's licence follows:</source>
          <target state="translated">Этот модуль реализован путем предоставления оболочки для библиотеки C &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE (Perl-Compatible Regular Expressions)&lt;/a&gt; . Это означает, что ваше приложение будет зависеть от лицензии библиотеки PCRE при использовании этого модуля, что, впрочем, не должно быть проблемой. Лицензия PCRE следующая:</target>
        </trans-unit>
        <trans-unit id="edd45a27ac656172236276c240c2474c18a6f78e" translate="yes" xml:space="preserve">
          <source>This module needs the data file &quot;unidecode.dat&quot; to work: This file is embedded as a resource into your application by default. But you an also define the symbol &lt;code&gt;--define:noUnidecodeTable&lt;/code&gt; during compile time and use the &lt;code&gt;loadUnidecodeTable&lt;/code&gt; proc to initialize this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22fccb6a29ddaf211868c4b8302f35490b759841" translate="yes" xml:space="preserve">
          <source>This module offers implementations of common binary operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and comparison operations, which work for mixed float/int operands. All operations convert the integer operand into the type of the float operand. For numerical expressions, the return type is always the type of the float involved in the expression, i.e., there is no auto conversion from float32 to float64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda1d94b3b5a9dcfb70f16a91a3ec170b750b323" translate="yes" xml:space="preserve">
          <source>This module offers implementations of common binary operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and comparison operations, which work for mixed float/int operands. All operations convert the integer operand into the type of the float operand. For numerical expressions, the return type is always the type of the float involved in the expresssion, i.e., there is no auto conversion from float32 to float64.</source>
          <target state="translated">Этот модуль предлагает реализации общих двоичных операций, таких как &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; и операции сравнения, которые работают для смешанных операндов типа float / int. Все операции преобразуют целочисленный операнд в тип операнда с плавающей запятой. Для числовых выражений типом возвращаемого значения всегда является тип числа с плавающей запятой, участвующий в выражении, т. Е. Автопреобразование из float32 в float64 отсутствует.</target>
        </trans-unit>
        <trans-unit id="f3267cc83830f712bb14c086f0878bf139791739" translate="yes" xml:space="preserve">
          <source>This module only exists to generate docs for the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7396f239f24da0a4e4690ab1044ff64d650f1306" translate="yes" xml:space="preserve">
          <source>This module parses a XML Document into a XML DOM Document representation.</source>
          <target state="translated">Этот модуль анализирует XML документ в XML DOM представление документа.</target>
        </trans-unit>
        <trans-unit id="a9bcdabb8e24bc9cc089f0f13411ad03a03519bc" translate="yes" xml:space="preserve">
          <source>This module parses an HTML document and creates its XML tree representation. It is supposed to handle the &lt;em&gt;wild&lt;/em&gt; HTML the real world uses.</source>
          <target state="translated">Этот модуль анализирует документ HTML и создает его представление в виде дерева XML. Он должен обрабатывать &lt;em&gt;дикий&lt;/em&gt; HTML, который используется в реальном мире.</target>
        </trans-unit>
        <trans-unit id="6cd96ee218d8bf4a40ad0320da8cac9d72214020" translate="yes" xml:space="preserve">
          <source>This module parses an XML document and creates its XML tree representation.</source>
          <target state="translated">Этот модуль анализирует XML-документ и создает его представление в виде дерева XML.</target>
        </trans-unit>
        <trans-unit id="9092d7288554b84b5306c5e4d5f8c8a0d7f59d2c" translate="yes" xml:space="preserve">
          <source>This module provides a stream interface and two implementations thereof: the &lt;a href=&quot;#FileStream&quot;&gt;FileStream&lt;/a&gt; and the &lt;a href=&quot;#StringStream&quot;&gt;StringStream&lt;/a&gt; which implement the stream interface for Nim file objects (&lt;code&gt;File&lt;/code&gt;) and strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a07c876b6cd8245c5dfacca935fec67d4db93ff" translate="yes" xml:space="preserve">
          <source>This module provides a stream interface and two implementations thereof: the &lt;em&gt;FileStream&lt;/em&gt; and the &lt;em&gt;StringStream&lt;/em&gt; which implement the stream interface for Nim file objects (&lt;em&gt;File&lt;/em&gt;) and strings. Other modules may provide other implementations for this standard stream interface.</source>
          <target state="translated">Этот модуль предоставляет потоковый интерфейс и две его реализации: &lt;em&gt;FileStream&lt;/em&gt; и &lt;em&gt;StringStream,&lt;/em&gt; которые реализуют потоковый интерфейс для файловых объектов Nim ( &lt;em&gt;File&lt;/em&gt; ) и строк. Другие модули могут предоставлять другие реализации для этого стандартного потокового интерфейса.</target>
        </trans-unit>
        <trans-unit id="4ab8f9a52d2829796af73473cde494f332d9e364" translate="yes" xml:space="preserve">
          <source>This module provides an easy to use sockets-style nim interface to the OpenSSL library.</source>
          <target state="translated">Этот модуль предоставляет простой в использовании nim-интерфейс в стиле сокетов к библиотеке OpenSSL.</target>
        </trans-unit>
        <trans-unit id="49dbd9ba77d32ac31376544311a3b10bed584209" translate="yes" xml:space="preserve">
          <source>This module provides both a synchronous and asynchronous implementation. The asynchronous implementation requires you to use the &lt;code&gt;asyncFTPClient&lt;/code&gt; function. You are then required to register the &lt;code&gt;AsyncFTPClient&lt;/code&gt; with a asyncio dispatcher using the &lt;code&gt;register&lt;/code&gt; function. Take a look at the asyncio module documentation for more information.</source>
          <target state="translated">Этот модуль обеспечивает как синхронную, так и асинхронную реализацию. Асинхронная реализация требует использования функции &lt;code&gt;asyncFTPClient&lt;/code&gt; . Затем вам необходимо зарегистрировать &lt;code&gt;AsyncFTPClient&lt;/code&gt; с помощью диспетчера asyncio, используя функцию &lt;code&gt;register&lt;/code&gt; . Взгляните на документацию модуля asyncio для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ce590e4e5a122965a43db23fbb2cb01e20c16510" translate="yes" xml:space="preserve">
          <source>This module provides support for &lt;span id=&quot;memory-mapped-files_1&quot;&gt;memory mapped files&lt;/span&gt; (Posix's &lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt;) on the different operating systems.</source>
          <target state="translated">Этот модуль обеспечивает поддержку &lt;span id=&quot;memory-mapped-files_1&quot;&gt;файлов с отображением памяти&lt;/span&gt; (Posix &lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt; ) в различных операционных системах.</target>
        </trans-unit>
        <trans-unit id="65c4c619ae2b38e38065fa4fe9a46d6bc185ed6a" translate="yes" xml:space="preserve">
          <source>This module provides support to handle the Unicode UTF-8 encoding.</source>
          <target state="translated">Данный модуль обеспечивает поддержку кодировки Unicode UTF-8.</target>
        </trans-unit>
        <trans-unit id="f60f9e4146057e2aadde33d2726a83b70d00ccbc" translate="yes" xml:space="preserve">
          <source>This module provides the standard Nim command line parser. It supports one convenience iterator over all command line options and some lower-level features.</source>
          <target state="translated">Этот модуль предоставляет стандартный синтаксический анализатор командной строки Nim.Он поддерживает один удобный итератор над всеми опциями командной строки и некоторые функции нижнего уровня.</target>
        </trans-unit>
        <trans-unit id="be630a10c2306e1da8b699aa549bd1507ce73a7f" translate="yes" xml:space="preserve">
          <source>This module supports helper routines for working with &lt;code&gt;cstring&lt;/code&gt; without having to convert &lt;code&gt;cstring&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt; in order to save allocations.</source>
          <target state="translated">Этот модуль поддерживает вспомогательные процедуры для работы с &lt;code&gt;cstring&lt;/code&gt; без необходимости конвертировать &lt;code&gt;cstring&lt;/code&gt; в &lt;code&gt;string&lt;/code&gt; , чтобы сэкономить выделение.</target>
        </trans-unit>
        <trans-unit id="5a7ff45a67a6ab46e7d1fb35b3306305d6ba07fa" translate="yes" xml:space="preserve">
          <source>This module wraps core JavaScript functions.</source>
          <target state="translated">Этот модуль обёртывает основные JavaScript-функции.</target>
        </trans-unit>
        <trans-unit id="0f7196bd18c3887a77199794d0417e3686fb88b6" translate="yes" xml:space="preserve">
          <source>This modules registers a signal handler that turns access violations / segfaults into a &lt;code&gt;NilAccessDefect&lt;/code&gt; exception. To be able to catch a NilAccessDefect all you have to do is to import this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b840bfc815d3caad906fc572e9454af313da4d0" translate="yes" xml:space="preserve">
          <source>This modules registers a signal handler that turns access violations / segfaults into a &lt;code&gt;NilAccessError&lt;/code&gt; exception. To be able to catch a NilAccessError all you have to do is to import this module.</source>
          <target state="translated">Эти модули регистрируют обработчик сигналов, который превращает нарушения доступа / segfaults в исключение &lt;code&gt;NilAccessError&lt;/code&gt; . Все, что вам нужно сделать, чтобы поймать NilAccessError, - это импортировать этот модуль.</target>
        </trans-unit>
        <trans-unit id="fee1833b4c51904885c4305b4d12a4e1e8ea0e21" translate="yes" xml:space="preserve">
          <source>This most often useful for constructing sequences with the array constructor: &lt;code&gt;@[1, 2, 3]&lt;/code&gt; has the type &lt;code&gt;seq[int]&lt;/code&gt;, while &lt;code&gt;[1, 2, 3]&lt;/code&gt; has the type &lt;code&gt;array[0..2, int]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6390ea355bcccac1df3928830a46c0fa9200368c" translate="yes" xml:space="preserve">
          <source>This must be called on an unconnected socket; an SSL session will be started when the socket is connected.</source>
          <target state="translated">Он должен быть вызван на неподключенный сокет;SSL-сессия будет запущена,когда сокет будет подключен.</target>
        </trans-unit>
        <trans-unit id="0dc417a03ed217016727b05e73fb23e9635c5936" translate="yes" xml:space="preserve">
          <source>This needs to be called to set &lt;code&gt;x&lt;/code&gt;'s runtime object type field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08443e3f06cf9773785c99d4ad98608f4e9eebf" translate="yes" xml:space="preserve">
          <source>This operator computes the difference of two sets.</source>
          <target state="translated">Этот оператор вычисляет разницу между двумя наборами.</target>
        </trans-unit>
        <trans-unit id="f79ed7bc0326a97f82d04a96b028c6113002f150" translate="yes" xml:space="preserve">
          <source>This operator computes the intersection of two sets.</source>
          <target state="translated">Этот оператор вычисляет пересечение двух наборов.</target>
        </trans-unit>
        <trans-unit id="9a4b0639403e85faa9616f997f6d194f55eeab89" translate="yes" xml:space="preserve">
          <source>This operator computes the union of two sets.</source>
          <target state="translated">Этот оператор вычисляет объединение двух наборов.</target>
        </trans-unit>
        <trans-unit id="b046c8a4096963070b190a5e641fbd439e8358a7" translate="yes" xml:space="preserve">
          <source>This operator is the assignment operator. Note that in the contexts &lt;code&gt;result = expr&lt;/code&gt;, &lt;code&gt;parameter = defaultValue&lt;/code&gt; or for parameter passing no assignment is performed. For a type &lt;code&gt;T&lt;/code&gt; that has an overloaded assignment operator &lt;code&gt;var v = T()&lt;/code&gt; is rewritten to &lt;code&gt;var v: T; v = T()&lt;/code&gt;; in other words &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; contexts do count as assignments.</source>
          <target state="translated">Этот оператор является оператором присваивания. Обратите внимание, что в контекстах &lt;code&gt;result = expr&lt;/code&gt; , &lt;code&gt;parameter = defaultValue&lt;/code&gt; или для передачи параметров присваивание не выполняется. Для типа &lt;code&gt;T&lt;/code&gt; , который имеет перегруженный оператор присваивания, &lt;code&gt;var v = T()&lt;/code&gt; переписывается в &lt;code&gt;var v: T; v = T()&lt;/code&gt; ; другими словами, контексты &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; считаются присваиваниями.</target>
        </trans-unit>
        <trans-unit id="c815aa40abb9bedda70e19c6d2ad3999d74da028" translate="yes" xml:space="preserve">
          <source>This operator will be matched against assignments to missing fields.</source>
          <target state="translated">Этот оператор будет сопоставляться с назначениями на пропущенные поля.</target>
        </trans-unit>
        <trans-unit id="877c6b770d02ce2daf96f01b490c8ab96ed58851" translate="yes" xml:space="preserve">
          <source>This operator will be matched against both field accesses and method calls.</source>
          <target state="translated">Этот оператор будет сопоставляться как с доступом к полям,так и с вызовами методов.</target>
        </trans-unit>
        <trans-unit id="8eb5171b4785a372e6e7687e57e17ace11b78ea3" translate="yes" xml:space="preserve">
          <source>This operator will be matched exclusively against method calls. It has higher precedence than the &lt;code&gt;.&lt;/code&gt; operator and this allows one to handle expressions like &lt;code&gt;x.y&lt;/code&gt; and &lt;code&gt;x.y()&lt;/code&gt; differently if one is interfacing with a scripting language for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c71fe5d49c4e442130e8d4e9b6e7107de926b7" translate="yes" xml:space="preserve">
          <source>This operator will be matched exclusively against method calls. It has higher precedence than the &lt;em&gt;.&lt;/em&gt; operator and this allows one to handle expressions like &lt;em&gt;x.y&lt;/em&gt; and &lt;em&gt;x.y()&lt;/em&gt; differently if one is interfacing with a scripting language for example.</source>
          <target state="translated">Этот оператор будет сопоставляться исключительно с вызовами методов. Он имеет более высокий приоритет, чем &lt;em&gt;. &lt;/em&gt;Оператор, и это позволяет обрабатывать такие выражения, как &lt;em&gt;xy&lt;/em&gt; и &lt;em&gt;xy () по-&lt;/em&gt; разному, например, при взаимодействии с языком сценариев.</target>
        </trans-unit>
        <trans-unit id="fdce8c1c9dd850ca032055512e1bd9d5a06936f2" translate="yes" xml:space="preserve">
          <source>This page provide hints on distributing Nim using OS packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c195c31e5829f87707abb98358a691d8131229a7" translate="yes" xml:space="preserve">
          <source>This passes the expression &lt;code&gt;x + y * z - x&lt;/code&gt; to the &lt;code&gt;optM&lt;/code&gt; macro as an &lt;code&gt;nnkArgList&lt;/code&gt; node containing:</source>
          <target state="translated">Это передает выражение &lt;code&gt;x + y * z - x&lt;/code&gt; в макрос &lt;code&gt;optM&lt;/code&gt; как узел &lt;code&gt;nnkArgList&lt;/code&gt; , содержащий:</target>
        </trans-unit>
        <trans-unit id="779a96266029c48032a8abc57497d759ae90622e" translate="yes" xml:space="preserve">
          <source>This pragma can also take in an optional warning string to relay to developers.</source>
          <target state="translated">Эта прагма может также включать в себя дополнительную строку предупреждения для передачи разработчикам.</target>
        </trans-unit>
        <trans-unit id="b75ce5f723cf09cb35bbfecf4010bd348d284353" translate="yes" xml:space="preserve">
          <source>This pragma has no effect on the JS backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bac99517eec01add92d42595b9d17d1a79dbd9" translate="yes" xml:space="preserve">
          <source>This proc adds the necessary Content-Length header.</source>
          <target state="translated">Эта отсрочка добавляет необходимый заголовок Content-Length.</target>
        </trans-unit>
        <trans-unit id="7b6638b54fd693beeb9b92d654723a7cc066942f" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection</source>
          <target state="translated">Эта отсрочка также обрабатывает перенаправление</target>
        </trans-unit>
        <trans-unit id="bec96c78d9187ae27072063a2599e2d8041f75b3" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection.</source>
          <target state="translated">Эта затянутость также позволяет переориентироваться.</target>
        </trans-unit>
        <trans-unit id="17bc78789836f23c301ac5b842a1060d7a4db4c3" translate="yes" xml:space="preserve">
          <source>This proc behaves the same as the &lt;code&gt;%&lt;/code&gt; operator in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3938ad51042cbaba9e98c935176fa62ab2de2077" translate="yes" xml:space="preserve">
          <source>This proc can be used to create tree structures on the fly (sometimes called &lt;span id=&quot;autovivification_1&quot;&gt;autovivification&lt;/span&gt;):</source>
          <target state="translated">Этот процесс можно использовать для создания древовидных структур на лету (иногда это называется &lt;span id=&quot;autovivification_1&quot;&gt;автовивификацией&lt;/span&gt; ):</target>
        </trans-unit>
        <trans-unit id="d26c6b6b611681b46566a5e4a79f3225cadc8212" translate="yes" xml:space="preserve">
          <source>This proc doesn't perform any normalization! For example, &lt;code&gt;initTimeInterval(hours = 24)&lt;/code&gt; and &lt;code&gt;initTimeInterval(days = 1)&lt;/code&gt; are not equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3940a36413be40e433cc94d22655956da42c2d56" translate="yes" xml:space="preserve">
          <source>This proc doesn't raise an exception on error, beware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb824dcf7f8bb590cee2ba4a4f3a5cbd9ae6dff" translate="yes" xml:space="preserve">
          <source>This proc expects to be passed as &lt;code&gt;n&lt;/code&gt; the parameters of any callable. The string output is meant for the HTML renderer. If there are no parameters, the empty string is returned. The parameters will be joined by &lt;code&gt;sep&lt;/code&gt; but other characters may appear too, like &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f135f77463cef43ee9fac9055909ade3fefb1c63" translate="yes" xml:space="preserve">
          <source>This proc is equivalent to 2^64 calls to &lt;a href=&quot;#next,Rand&quot;&gt;next&lt;/a&gt;, and it can be used to generate 2^64 non-overlapping subsequences for parallel computations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350b35231bf552e3848fa0167786f99d3c79a8be" translate="yes" xml:space="preserve">
          <source>This proc is mostly useful for meta programming (eg. &lt;code&gt;assert&lt;/code&gt; template) to retrieve information about the current filename and line number. Example:</source>
          <target state="translated">Эта процедура в основном полезна для метапрограммирования (например, шаблона &lt;code&gt;assert&lt;/code&gt; ) для получения информации о текущем имени файла и номере строки. Пример:</target>
        </trans-unit>
        <trans-unit id="bf91fb862b9ad244ab7a7fe8893c5ec5d0d1450b" translate="yes" xml:space="preserve">
          <source>This proc is normally used with connectionless sockets (UDP sockets).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da63af19bd44e5c45f60183bb9599bcc8b3d3e9" translate="yes" xml:space="preserve">
          <source>This proc is wrapped by the &lt;a href=&quot;#expandTilde,string&quot;&gt;expandTilde proc&lt;/a&gt; for the convenience of processing paths coming from user configuration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc13541eec5a8625bb4f501795d54288285926d" translate="yes" xml:space="preserve">
          <source>This proc is wrapped by the expandTilde proc for the convenience of processing paths coming from user configuration files.</source>
          <target state="translated">Для удобства обработки путей,идущих от пользовательских конфигурационных файлов,эта proc обернута в ExpadTilde proc.</target>
        </trans-unit>
        <trans-unit id="5e959921234b63d76dbef4bc106055bfeccf3fc5" translate="yes" xml:space="preserve">
          <source>This proc must be called before any other usage of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad8173dbe5f7a8294af8a1a1ddc4730d7ef3e88" translate="yes" xml:space="preserve">
          <source>This proc only needs to be called once, and it should be called before the first usage of procs from this module that use the default random number generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333b238bdf3008bb02960b98a410ac4836f3911d" translate="yes" xml:space="preserve">
          <source>This proc sends &lt;code&gt;data&lt;/code&gt; to the specified &lt;code&gt;address&lt;/code&gt;, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</source>
          <target state="translated">Эта процедура отправляет &lt;code&gt;data&lt;/code&gt; на указанный &lt;code&gt;address&lt;/code&gt; , который может быть IP-адресом или именем хоста, если указано имя хоста, эта функция будет пробовать каждый IP-адрес этого имени хоста.</target>
        </trans-unit>
        <trans-unit id="938649feb3030899c2e766999d5b87bd8659f3c6" translate="yes" xml:space="preserve">
          <source>This proc sends &lt;code&gt;data&lt;/code&gt; to the specified &lt;code&gt;address&lt;/code&gt;, which may be an IP address or a hostname. If a hostname is specified this function will try each IP of that hostname. The returned future will complete once all data has been sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ed4d34f9d82a4db2eb217526e348dc0895635d" translate="yes" xml:space="preserve">
          <source>This proc uses the default random number generator. Thus, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47eaf268233c731f7c482448d362f14c34db36aa" translate="yes" xml:space="preserve">
          <source>This proc will assert if the node is not of the expected type. The empty string will be returned as a minimum. Any value in the rst will be stripped form leading/trailing whitespace.</source>
          <target state="translated">Эта проска будет утверждать,если узел не соответствует ожидаемому типу.Пустая строка будет возвращена как минимум.Любое значение в rst будет удалено из пробела.</target>
        </trans-unit>
        <trans-unit id="bdafab7045ac0766f9e79ee5dc6b8e55ba43a53a" translate="yes" xml:space="preserve">
          <source>This proc will first scan &lt;code&gt;dir&lt;/code&gt; for index files with the &lt;code&gt;.idx&lt;/code&gt; extension previously created by commands like &lt;code&gt;nim doc|rst2html&lt;/code&gt; which use the &lt;code&gt;--index:on&lt;/code&gt; switch. These index files are the result of calls to &lt;a href=&quot;#setIndexTerm,RstGenerator,string,string,string,string,string&quot;&gt;setIndexTerm()&lt;/a&gt; and &lt;a href=&quot;#writeIndexFile,RstGenerator,string&quot;&gt;writeIndexFile()&lt;/a&gt;, so they are simple tab separated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626f1119535b21954263807e2c460288c1806626" translate="yes" xml:space="preserve">
          <source>This proc will first scan &lt;em&gt;dir&lt;/em&gt; for index files with the &lt;code&gt;.idx&lt;/code&gt; extension previously created by commands like &lt;code&gt;nim doc|rst2html&lt;/code&gt; which use the &lt;code&gt;--index:on&lt;/code&gt; switch. These index files are the result of calls to &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; and &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;, so they are simple tab separated files.</source>
          <target state="translated">Эта процедура будет первым сканирование &lt;em&gt;реж&lt;/em&gt; для индексных файлов с &lt;code&gt;.idx&lt;/code&gt; расширением ранее созданного с помощью команд , как &lt;code&gt;nim doc|rst2html&lt;/code&gt; , которые используют &lt;code&gt;--index:on&lt;/code&gt; коммутаторе. Эти индексные файлы являются результатом вызовов &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm ()&lt;/a&gt; и &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile ()&lt;/a&gt; , поэтому они представляют собой простые файлы, разделенные табуляцией.</target>
        </trans-unit>
        <trans-unit id="a4394af6524fbdf2935a5287c6e403358c97c2f3" translate="yes" xml:space="preserve">
          <source>This proc will return true if given two alternative hard-linked or sym-linked paths to the same file or directory.</source>
          <target state="translated">Этот proc вернет true,если задать два альтернативных пути к одному и тому же файлу или каталогу с жесткой или сим-связанной связью.</target>
        </trans-unit>
        <trans-unit id="9fa999fcdc85222ac9f9bda4589a9a95ca91d7d4" translate="yes" xml:space="preserve">
          <source>This proc works similarly to &lt;a href=&quot;#sample,Rand,openArray%5BT%5D,openArray%5BU%5D&quot;&gt;sample[T, U](Rand, openArray[T], openArray[U])&lt;/a&gt;. See that proc's documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c1f778626a828d02676e44a9e588073cc53bdc" translate="yes" xml:space="preserve">
          <source>This procedure causes any unwritten data for that stream to be delivered to the host environment to be written to the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a80f4b7504eb42e35ef57671474e7f95b75a669" translate="yes" xml:space="preserve">
          <source>This procedure encodes a string according to MIME spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab576674f0fae9f5c2db872b47e1b80cc3065ba" translate="yes" xml:space="preserve">
          <source>This procedure encodes a string.</source>
          <target state="translated">Эта процедура кодирует строку.</target>
        </trans-unit>
        <trans-unit id="c324daca0847c9b512385b859ab2363a1841f9c6" translate="yes" xml:space="preserve">
          <source>This procedure encodes an openarray (array or sequence) of either integers or characters.</source>
          <target state="translated">Эта процедура кодирует массив (массив или последовательность),состоящий из целых чисел или символов.</target>
        </trans-unit>
        <trans-unit id="dadefb2f162797b5b8e737417830e0aaa5615a6d" translate="yes" xml:space="preserve">
          <source>This procedure exists only for optimization purposes; the same effect can be achieved with the &lt;code&gt;&amp;amp;&lt;/code&gt; operator or with &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31397687949c9dfdee06b359b12e24a49c3d9c7" translate="yes" xml:space="preserve">
          <source>This procedure is not guaranteed to be available for all platforms. Test for availability with &lt;a href=&quot;#declared&quot;&gt;declared()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4fef9f6de3ef8d675cc867d40c13213fa9353a" translate="yes" xml:space="preserve">
          <source>This procedure is not guaranteed to be available for all platforms. Test for availability with &lt;code&gt;declared() &amp;lt;system.html#declared,untyped&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebba0aeda7a3e7c849c8d97ba20a2191682f9515" translate="yes" xml:space="preserve">
          <source>This procedure is perfect for saving streamed data to a file without wasting memory.</source>
          <target state="translated">Эта процедура идеально подходит для сохранения потоковых данных в файл без потери памяти.</target>
        </trans-unit>
        <trans-unit id="d1f961f21ff0a84bd8db8e05ca89330dfa9923ef" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;Duration&lt;/code&gt; values to strings.</source>
          <target state="translated">Эта процедура полезна для преобразования значений &lt;code&gt;Duration&lt;/code&gt; в строки.</target>
        </trans-unit>
        <trans-unit id="520fb6fa62d760ce421de4aaa2f6105b1555063b" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;TimeInterval&lt;/code&gt; values to strings. E.g. then you need to implement custom interval printing</source>
          <target state="translated">Эта процедура полезна для преобразования значений &lt;code&gt;TimeInterval&lt;/code&gt; в строки. Например, вам нужно реализовать печать с индивидуальным интервалом.</target>
        </trans-unit>
        <trans-unit id="52e91210394e398f992437bda6d4effa40dcc4a1" translate="yes" xml:space="preserve">
          <source>This procedure is useful in the event when an OS call fails. In that case this procedure will return the error code describing the reason why the OS call failed. The &lt;code&gt;OSErrorMsg&lt;/code&gt; procedure can then be used to convert this code into a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70517cf24694c69da8efa582ddd657d7197346ed" translate="yes" xml:space="preserve">
          <source>This procedure uses httpClient values such as &lt;code&gt;client.maxRedirects&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0479019038d3102021d1669951bf95b837b91563" translate="yes" xml:space="preserve">
          <source>This procedure will &lt;strong&gt;not&lt;/strong&gt; close the client socket.</source>
          <target state="translated">Эта процедура &lt;strong&gt;не&lt;/strong&gt; закрывает клиентский сокет.</target>
        </trans-unit>
        <trans-unit id="2c9c22aaa48bc7cddb7839a6f9a879afc83e6b75" translate="yes" xml:space="preserve">
          <source>This procedure will also create a brand new file descriptor for this socket.</source>
          <target state="translated">Эта процедура также создаст новый файловый дескриптор для этого сокета.</target>
        </trans-unit>
        <trans-unit id="1288ff1149ba87d487f19440b9d10966e30531a7" translate="yes" xml:space="preserve">
          <source>This procedure will follow redirects up to a maximum number of redirects specified in &lt;code&gt;client.maxRedirects&lt;/code&gt;.</source>
          <target state="translated">Эта процедура будет следовать за перенаправлениями до максимального количества перенаправлений, указанного в &lt;code&gt;client.maxRedirects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5c3737642080f0e83823f3dcd1cc4baeb39760" translate="yes" xml:space="preserve">
          <source>This procedure will immediately return, it will not block until a connection is made. It is up to the caller to make sure the connection has been established by checking (using &lt;code&gt;select&lt;/code&gt;) whether the socket is writeable.</source>
          <target state="translated">Эта процедура немедленно вернется, она не заблокируется, пока не будет установлено соединение. Вызывающий абонент должен убедиться, что соединение установлено, проверив (с помощью &lt;code&gt;select&lt;/code&gt; ), доступен ли сокет для записи.</target>
        </trans-unit>
        <trans-unit id="8185dc4f223c6b697125a69fc7c20cfa4abf8f29" translate="yes" xml:space="preserve">
          <source>This procedure will resolve symlinks.</source>
          <target state="translated">Эта процедура решит проблемы с симлинками.</target>
        </trans-unit>
        <trans-unit id="014cae8b1a1962b4f1faa243de196e5e656ee26d" translate="yes" xml:space="preserve">
          <source>This provides higher efficiency than the &lt;code&gt;pretty&lt;/code&gt; procedure as it does &lt;strong&gt;not&lt;/strong&gt; attempt to format the resulting JSON to make it human readable.</source>
          <target state="translated">Это обеспечивает более высокую эффективность, чем &lt;code&gt;pretty&lt;/code&gt; процедура, поскольку &lt;strong&gt;не&lt;/strong&gt; пытается отформатировать полученный JSON, чтобы сделать его удобочитаемым.</target>
        </trans-unit>
        <trans-unit id="526a6ce57682bfa6e8b959cd6e81435a72cdfc8d" translate="yes" xml:space="preserve">
          <source>This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all &lt;code&gt;+&lt;/code&gt; for dollars should produce the same binary code as &lt;code&gt;+&lt;/code&gt; for ints. The pragma &lt;span id=&quot;borrow_1&quot;&gt;borrow&lt;/span&gt; has been designed to solve this problem; in principle it generates the above trivial implementations:</source>
          <target state="translated">Это быстро утомляет. Реализации тривиальны, и компилятор не должен генерировать весь этот код только для того, чтобы оптимизировать его позже - в конце концов, &lt;code&gt;+&lt;/code&gt; для долларов должен давать тот же двоичный код, что и &lt;code&gt;+&lt;/code&gt; для int. Прагма &lt;span id=&quot;borrow_1&quot;&gt;заимствования&lt;/span&gt; была разработана для решения этой проблемы; в принципе он генерирует указанные выше тривиальные реализации:</target>
        </trans-unit>
        <trans-unit id="77e02d73fd63a6b9ecbe38066eb72908681331b1" translate="yes" xml:space="preserve">
          <source>This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all &lt;code&gt;+&lt;/code&gt; for dollars should produce the same binary code as &lt;code&gt;+&lt;/code&gt; for ints. The pragma &lt;span id=&quot;borrow_1&quot;&gt;borrow&lt;/span&gt; has been designed to solve this problem; in principle, it generates the above trivial implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47005e240c8afd6e1584cbc26a7622dbbbd1d07" translate="yes" xml:space="preserve">
          <source>This rather unorthodox way to do identifier comparisons is called &lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;partial case insensitivity&lt;/span&gt; and has some advantages over the conventional case sensitivity:</source>
          <target state="translated">Этот довольно неортодоксальный способ сравнения идентификаторов называется &lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;частичной нечувствительностью к регистру&lt;/span&gt; и имеет некоторые преимущества по сравнению с обычной чувствительностью к регистру:</target>
        </trans-unit>
        <trans-unit id="601b78ebce6eee9b81f17aee5fe0af4dacad523a" translate="yes" xml:space="preserve">
          <source>This rather unorthodox way to do identifier comparisons is called &lt;span id=&quot;partial-caseminusinsensitivity_1&quot;&gt;partial case-insensitivity&lt;/span&gt; and has some advantages over the conventional case sensitivity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ed54e7055d8ae85d9b5529ed324762a3d069ea" translate="yes" xml:space="preserve">
          <source>This requires the OpenSSL library, fortunately it's widely used and installed on many operating systems. httpclient will use SSL automatically if you give any of the functions a url with the &lt;code&gt;https&lt;/code&gt; schema, for example: &lt;code&gt;https://github.com/&lt;/code&gt;.</source>
          <target state="translated">Для этого требуется библиотека OpenSSL, к счастью, она широко используется и устанавливается во многих операционных системах. httpclient будет использовать SSL автоматически, если вы дадите какой-либо из функций URL-адрес со схемой &lt;code&gt;https&lt;/code&gt; , например: &lt;code&gt;https://github.com/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3909002e9ad606364e490e6f4e79bacb7e050226" translate="yes" xml:space="preserve">
          <source>This retrieves ALL rows into memory before iterating through the rows. Large dataset queries will impact on memory usage.</source>
          <target state="translated">Это возвращает ВСЕ строки в память перед итерацией по строкам.Запросы больших наборов данных будут влиять на использование памяти.</target>
        </trans-unit>
        <trans-unit id="096ad9b3f2bcb1230451399427a373a8d336f90f" translate="yes" xml:space="preserve">
          <source>This returns &lt;strong&gt;only&lt;/strong&gt; the parameters. If you want to get the application executable filename, call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt;.</source>
          <target state="translated">Это возвращает &lt;strong&gt;только&lt;/strong&gt; параметры. Если вы хотите получить имя исполняемого файла приложения, вызовите &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa9d6a77d63381c1d09d47733e42419e7a92f6c1" translate="yes" xml:space="preserve">
          <source>This section can only help you with the last item.</source>
          <target state="translated">Этот раздел может помочь вам только с последним пунктом.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
