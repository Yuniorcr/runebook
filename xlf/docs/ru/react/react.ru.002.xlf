<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="679fe92462c39504c9ff9773ae608eb7389ffc9e" translate="yes" xml:space="preserve">
          <source>For a more concrete example of these concepts, let&amp;rsquo;s write a minimal wrapper for the plugin &lt;a href=&quot;https://harvesthq.github.io/chosen/&quot;&gt;Chosen&lt;/a&gt;, which augments &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; inputs.</source>
          <target state="translated">Для более конкретного примера этих концепций, давайте напишем минимальную оболочку для плагина &lt;a href=&quot;https://harvesthq.github.io/chosen/&quot;&gt;Chosen&lt;/a&gt; , которая дополняет входные данные &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e02416dec32f4ac14f5c635f846c95b0b1f3e149" translate="yes" xml:space="preserve">
          <source>For a more detailed walkthrough, check out &lt;a href=&quot;https://calibreapp.com/blog/react-performance-profiling-optimization&quot;&gt;this article by Ben Schwarz&lt;/a&gt;.</source>
          <target state="translated">Для более подробного прохождения ознакомьтесь с &lt;a href=&quot;https://calibreapp.com/blog/react-performance-profiling-optimization&quot;&gt;этой статьей Бена Шварца&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6742712e3a4c00cde6cec63fd4e900f882182503" translate="yes" xml:space="preserve">
          <source>For components defined as classes, use &lt;code&gt;this.props.children&lt;/code&gt;:</source>
          <target state="translated">Для компонентов, определенных как классы, используйте &lt;code&gt;this.props.children&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="df0460aa967c08b3c0359b521985038ac48561d5" translate="yes" xml:space="preserve">
          <source>For each particular piece of changing data, there should be just one component that &amp;ldquo;owns&amp;rdquo; it in its state. Don&amp;rsquo;t try to synchronize states of two different components. Instead, &lt;a href=&quot;lifting-state-up&quot;&gt;lift it up&lt;/a&gt; to their closest shared ancestor, and pass it down as props to both of them.</source>
          <target state="translated">Для каждой конкретной части изменяемых данных должен быть только один компонент, который &amp;laquo;владеет&amp;raquo; им в своем состоянии. Не пытайтесь синхронизировать состояния двух разных компонентов. Вместо этого &lt;a href=&quot;lifting-state-up&quot;&gt;поднесите его&lt;/a&gt; к их ближайшему общему предку и передайте им обоим в качестве опоры.</target>
        </trans-unit>
        <trans-unit id="647bc53c804dc25be5b4801130ef3922760422b8" translate="yes" xml:space="preserve">
          <source>For each piece of state in your application:</source>
          <target state="translated">Для каждого штата в вашей заявке:</target>
        </trans-unit>
        <trans-unit id="4657ab12168f0360582ae377c9a3fb4c69201085" translate="yes" xml:space="preserve">
          <source>For each test, we usually want to render our React tree to a DOM element that&amp;rsquo;s attached to &lt;code&gt;document&lt;/code&gt;. This is important so that it can receive DOM events. When the test ends, we want to &amp;ldquo;clean up&amp;rdquo; and unmount the tree from the &lt;code&gt;document&lt;/code&gt;.</source>
          <target state="translated">Для каждого теста мы обычно хотим отобразить наше дерево React в элементе DOM, прикрепленном к &lt;code&gt;document&lt;/code&gt; . Это важно, чтобы он мог получать события DOM. Когда тест закончится, мы хотим &amp;laquo;очистить&amp;raquo; и отключить дерево от &lt;code&gt;document&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d2f11c83d765d839676e4e232e576ddbe2a1a64" translate="yes" xml:space="preserve">
          <source>For example a custom Hook that returned a &lt;code&gt;Date&lt;/code&gt; value could avoid calling the &lt;code&gt;toDateString&lt;/code&gt; function unnecessarily by passing the following formatter:</source>
          <target state="translated">Например, пользовательский Hook, возвращающий значение &lt;code&gt;Date&lt;/code&gt; , может избежать &lt;code&gt;toDateString&lt;/code&gt; функции toDateString , передав следующее средство форматирования:</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="6ccd00019fe7c93727e1ee7af34a30096debfa1c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;class&lt;/code&gt; becomes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/className&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt; in JSX, and &lt;code&gt;tabindex&lt;/code&gt; becomes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex&quot;&gt;&lt;code&gt;tabIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Например, &lt;code&gt;class&lt;/code&gt; становится &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/className&quot;&gt; &lt;code&gt;className&lt;/code&gt; &lt;/a&gt; в JSX, а &lt;code&gt;tabindex&lt;/code&gt; становится &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex&quot;&gt; &lt;code&gt;tabIndex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="257bf267f4accf76b8a71c8a6fc907d879bb3b3b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;tryConvert('abc', toCelsius)&lt;/code&gt; returns an empty string, and &lt;code&gt;tryConvert('10.22', toFahrenheit)&lt;/code&gt; returns &lt;code&gt;'50.396'&lt;/code&gt;.</source>
          <target state="translated">Например, &lt;code&gt;tryConvert('abc', toCelsius)&lt;/code&gt; возвращает пустую строку, а &lt;code&gt;tryConvert('10.22', toFahrenheit)&lt;/code&gt; возвращает &lt;code&gt;'50.396'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86da3811ff28fce969e656a6a27c26d72c389972" translate="yes" xml:space="preserve">
          <source>For example, Facebook Messenger wraps content of the sidebar, the info panel, the conversation log, and the message input into separate error boundaries. If some component in one of these UI areas crashes, the rest of them remain interactive.</source>
          <target state="translated">Например,Facebook Messenger обертывает содержимое боковой панели,информационной панели,журнала разговоров и вводимого сообщения в отдельные границы ошибок.Если какой-то компонент в одной из этих областей пользовательского интерфейса выходит из строя,остальные остаются интерактивными.</target>
        </trans-unit>
        <trans-unit id="d9d8139b3a5725d0dbe39a1d636583f71febc457" translate="yes" xml:space="preserve">
          <source>For example, both of the imports are necessary in this code, even though &lt;code&gt;React&lt;/code&gt; and &lt;code&gt;CustomButton&lt;/code&gt; are not directly referenced from JavaScript:</source>
          <target state="translated">Например, в этом коде необходимы оба импорта, хотя на &lt;code&gt;React&lt;/code&gt; и &lt;code&gt;CustomButton&lt;/code&gt; нет прямых ссылок из JavaScript:</target>
        </trans-unit>
        <trans-unit id="390fb39992645b6398deff562b8f840081098a97" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;Page&lt;/code&gt; component that passes a &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt; prop several levels down so that deeply nested &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Avatar&lt;/code&gt; components can read it:</source>
          <target state="translated">Например, рассмотрим компонент &lt;code&gt;Page&lt;/code&gt; , который передает &lt;code&gt;avatarSize&lt;/code&gt; &lt;code&gt;user&lt;/code&gt; и avatarSize на несколько уровней ниже, чтобы глубоко вложенные компоненты &lt;code&gt;Link&lt;/code&gt; и &lt;code&gt;Avatar&lt;/code&gt; могли его прочитать:</target>
        </trans-unit>
        <trans-unit id="3a0f37544377fd4ba88f4814137f0c59e828e67d" translate="yes" xml:space="preserve">
          <source>For example, consider a filterable list like this:</source>
          <target state="translated">Например,рассмотрим фильтруемый список,подобный этому:</target>
        </trans-unit>
        <trans-unit id="672d122436eb70d444bbe9b6d5a7454eb80d94df" translate="yes" xml:space="preserve">
          <source>For example, consider the &lt;code&gt;useFriendStatus&lt;/code&gt; custom Hook described in &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;Building Your Own Hooks&amp;rdquo;&lt;/a&gt;:</source>
          <target state="translated">Например, рассмотрим настраиваемый крючок &lt;code&gt;useFriendStatus&lt;/code&gt; , описанный в разделе &lt;a href=&quot;hooks-custom&quot;&gt;&amp;laquo;Создание собственных хуков&amp;raquo;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="897f4de2b32102497cc28727717c94d918135994" translate="yes" xml:space="preserve">
          <source>For example, consider the following code:</source>
          <target state="translated">Например,рассмотрим следующий код:</target>
        </trans-unit>
        <trans-unit id="9050062cc798394f53d6e8b1ff9014a2612f33bb" translate="yes" xml:space="preserve">
          <source>For example, consider this &lt;code&gt;Comment&lt;/code&gt; component:</source>
          <target state="translated">Например, рассмотрим этот компонент &lt;code&gt;Comment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="17c300f11b425a9fc05f0c1272d1583ab4603762" translate="yes" xml:space="preserve">
          <source>For example, continuing with our &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component from above, if &lt;code&gt;Mouse&lt;/code&gt; were to extend &lt;code&gt;React.PureComponent&lt;/code&gt; instead of &lt;code&gt;React.Component&lt;/code&gt;, our example would look like this:</source>
          <target state="translated">Например, если продолжить с нашим компонентом &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; сверху, если &lt;code&gt;Mouse&lt;/code&gt; будет расширять &lt;code&gt;React.PureComponent&lt;/code&gt; вместо &lt;code&gt;React.Component&lt;/code&gt; , наш пример будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="20ed488706a8a3ad440cf53c3eca5d4c4ed1ad07" translate="yes" xml:space="preserve">
          <source>For example, if the Experimental channel had existed when we announced Hooks, we would have released Hooks to the Experimental channel weeks before they were available in Latest.</source>
          <target state="translated">Например,если бы Экспериментальный канал существовал,когда мы анонсировали Hooks,мы бы выпустили Hooks на Экспериментальном канале за несколько недель до того,как они появились в Latest.</target>
        </trans-unit>
        <trans-unit id="72386049d7fd0a4d1be43f2f6774c74af5948367" translate="yes" xml:space="preserve">
          <source>For example, if we enter 37 into the Celsius input, the state of the &lt;code&gt;Calculator&lt;/code&gt; component will be:</source>
          <target state="translated">Например, если мы введем 37 во входной параметр Celsius, состояние компонента &lt;code&gt;Calculator&lt;/code&gt; будет следующим:</target>
        </trans-unit>
        <trans-unit id="b9993ee38514320027480d338484992ca1feb5c6" translate="yes" xml:space="preserve">
          <source>For example, if we switch from one page to another, and none of the code or data for the next screen has loaded yet, it might be frustrating to immediately see a blank page with a loading indicator. We might prefer to stay longer on the previous screen. Implementing this pattern has historically been difficult in React. Concurrent Mode offers a new set of tools to do that.</source>
          <target state="translated">Например,если мы переключаемся с одной страницы на другую,и ни один код или данные для следующего экрана еще не загружены,то может быть обидно сразу же увидеть пустую страницу с индикатором загрузки.Возможно,мы предпочтем остаться на предыдущем экране подольше.Реализация этой закономерности исторически была трудной задачей в React.Concurrent Mode предлагает новый набор инструментов для этого.</target>
        </trans-unit>
        <trans-unit id="65295b13b97c2a6ed8a939287bfe094925fc31cc" translate="yes" xml:space="preserve">
          <source>For example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component:</source>
          <target state="translated">Например,если мы хотим записать имя в журнал предыдущего примера при его отправке,мы можем записать форму как управляемый компонент:</target>
        </trans-unit>
        <trans-unit id="a90b29303f730a5e659074ca0cb511ba946d5117" translate="yes" xml:space="preserve">
          <source>For example, if you &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract&lt;/a&gt; a &lt;code&gt;ListItem&lt;/code&gt; component, you should keep the key on the &lt;code&gt;&amp;lt;ListItem /&amp;gt;&lt;/code&gt; elements in the array rather than on the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element in the &lt;code&gt;ListItem&lt;/code&gt; itself.</source>
          <target state="translated">Например, если вы &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;извлечь&lt;/a&gt; в &lt;code&gt;ListItem&lt;/code&gt; компонент, вы должны держать ключ на &lt;code&gt;&amp;lt;ListItem /&amp;gt;&lt;/code&gt; элементов в массиве , а не на &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; элемента в &lt;code&gt;ListItem&lt;/code&gt; сам.</target>
        </trans-unit>
        <trans-unit id="4f472461a434d14b304ba318506b6c2b7dd4f729" translate="yes" xml:space="preserve">
          <source>For example, if you have the following component:</source>
          <target state="translated">Например,если у вас есть следующий компонент:</target>
        </trans-unit>
        <trans-unit id="cf9af7a91451dd9ae9a9996fb7f391bbc16ec6a4" translate="yes" xml:space="preserve">
          <source>For example, instead of exposing &lt;code&gt;open()&lt;/code&gt; and &lt;code&gt;close()&lt;/code&gt; methods on a &lt;code&gt;Dialog&lt;/code&gt; component, pass an &lt;code&gt;isOpen&lt;/code&gt; prop to it.</source>
          <target state="translated">Например, вместо того, чтобы предоставлять методы &lt;code&gt;open()&lt;/code&gt; и &lt;code&gt;close()&lt;/code&gt; в компоненте &lt;code&gt;Dialog&lt;/code&gt; , передайте ему &lt;code&gt;isOpen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8de9356ec83d73b1f5bd25ff7148e61b4571f9a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have a &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; component that renders the image of a cat chasing the mouse around the screen. We might use a &lt;code&gt;&amp;lt;Cat mouse={{ x, y }}&amp;gt;&lt;/code&gt; prop to tell the component the coordinates of the mouse so it knows where to position the image on the screen.</source>
          <target state="translated">Например, предположим, что у нас есть компонент &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; , который отображает изображение кошки, преследующей мышь по экрану. Мы могли бы использовать опору &lt;code&gt;&amp;lt;Cat mouse={{ x, y }}&amp;gt;&lt;/code&gt; чтобы сообщить компоненту координаты мыши, чтобы он знал, где разместить изображение на экране.</target>
        </trans-unit>
        <trans-unit id="ba22bdb002e0f405abcc6c642198532d39f6bf7a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have this &lt;code&gt;Counter&lt;/code&gt; component:</source>
          <target state="translated">Например, допустим, у нас есть этот компонент &lt;code&gt;Counter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6f0a42e407f76b6421f57202e0a6b998a33eea86" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have this counter component:</source>
          <target state="translated">Например, допустим, у нас есть этот компонент счетчика:</target>
        </trans-unit>
        <trans-unit id="6829043516c2d5b5543372593d5ecc18cc4a4134" translate="yes" xml:space="preserve">
          <source>For example, maybe you have a complex component that contains a lot of local state that is managed in an ad-hoc way. &lt;code&gt;useState&lt;/code&gt; doesn&amp;rsquo;t make centralizing the update logic any easier so you might prefer to write it as a &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; reducer:</source>
          <target state="translated">Например, возможно, у вас есть сложный компонент, который содержит много локальных состояний, которые управляются специальным образом. &lt;code&gt;useState&lt;/code&gt; не упрощает централизацию логики обновления, поэтому вы можете предпочесть написать ее как редуктор &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e18ae5d39ecd3952c9cebace04d8ec7b3336fb23" translate="yes" xml:space="preserve">
          <source>For example, research shows that displaying too many intermediate loading states when transitioning between screens makes a transition feel &lt;em&gt;slower&lt;/em&gt;. This is why Concurrent Mode shows new loading states on a fixed &amp;ldquo;schedule&amp;rdquo; to avoid jarring and too frequent updates.</source>
          <target state="translated">Например, исследования показывают, что отображение слишком большого количества промежуточных состояний загрузки при переходе между экранами делает переход &lt;em&gt;более медленным&lt;/em&gt; . Вот почему Concurrent Mode показывает новые состояния загрузки по фиксированному &amp;laquo;расписанию&amp;raquo;, чтобы избежать резких изменений и слишком частых обновлений.</target>
        </trans-unit>
        <trans-unit id="78683415bcaad856b1ab7dfe02f23e05fa2ced55" translate="yes" xml:space="preserve">
          <source>For example, say you have a &lt;code&gt;CommentList&lt;/code&gt; component that subscribes to an external data source to render a list of comments:</source>
          <target state="translated">Например, предположим, что у вас есть компонент &lt;code&gt;CommentList&lt;/code&gt; , который подписывается на внешний источник данных для отображения списка комментариев:</target>
        </trans-unit>
        <trans-unit id="1a1a629d470f55d2fee2000499a4cacbb9a4833a" translate="yes" xml:space="preserve">
          <source>For example, the HTML:</source>
          <target state="translated">Например,HTML:</target>
        </trans-unit>
        <trans-unit id="6ba76674660b5e537e8b2cdd0ef1d5a91df770a7" translate="yes" xml:space="preserve">
          <source>For example, the following component tracks the mouse position in a web app:</source>
          <target state="translated">Например,следующий компонент отслеживает положение мыши в веб-приложении:</target>
        </trans-unit>
        <trans-unit id="e8f359161b98ba57290664f3cc1ede81cf753231" translate="yes" xml:space="preserve">
          <source>For example, the following component will appear as &amp;rdquo;&lt;em&gt;ForwardRef&lt;/em&gt;&amp;rdquo; in the DevTools:</source>
          <target state="translated">Например, следующий компонент будет отображаться в &lt;em&gt;DevTools&lt;/em&gt; как &amp;laquo; &lt;em&gt;ForwardRef&lt;/em&gt; &amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="5c4201bd25776812cd7bc0c469c68c4fbd842451" translate="yes" xml:space="preserve">
          <source>For example, the following component will appear as MyDisplayName in the DevTools:</source>
          <target state="translated">Например,следующий компонент появится как MyDisplayName в DevTools:</target>
        </trans-unit>
        <trans-unit id="3069268548855f5d165876787923a3ea3d1da874" translate="yes" xml:space="preserve">
          <source>For example, this code accepts a single name in an uncontrolled component:</source>
          <target state="translated">Например,этот код принимает одно имя в неконтролируемом компоненте:</target>
        </trans-unit>
        <trans-unit id="2c55286e50f3215379ff426fa48eb785d76df4a7" translate="yes" xml:space="preserve">
          <source>For example, this code may fail to update the counter:</source>
          <target state="translated">Например,этот код может не обновить счетчик:</target>
        </trans-unit>
        <trans-unit id="0ccc1009af6f8f6328943760f3255e5b65c01689" translate="yes" xml:space="preserve">
          <source>For example, this code renders &amp;ldquo;Hello, Sara&amp;rdquo; on the page:</source>
          <target state="translated">Например, этот код отображает на странице &amp;laquo;Привет, Сара&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="c3a55dc4cb118bd5e2852ddf3c6b69f2d61b25ed" translate="yes" xml:space="preserve">
          <source>For example, this code will not run as expected:</source>
          <target state="translated">Например,этот код будет работать не так,как ожидалось:</target>
        </trans-unit>
        <trans-unit id="8e989a1227816ccbcfdce9a1ef1f8646c7fe3950" translate="yes" xml:space="preserve">
          <source>For example, this code written with JSX:</source>
          <target state="translated">Например,этот код,написанный с помощью JSX:</target>
        </trans-unit>
        <trans-unit id="f04fad3363acf285dbccbb82a73f5be8eb678633" translate="yes" xml:space="preserve">
          <source>For example, this component sets the document title after React updates the DOM:</source>
          <target state="translated">Например,этот компонент устанавливает заголовок документа после обновления флэш-накопителя React:</target>
        </trans-unit>
        <trans-unit id="7884e8e4fb1aae5ecf12d8317e1f6d9f4593fec2" translate="yes" xml:space="preserve">
          <source>For example, this will not re-render a component:</source>
          <target state="translated">Например,при этом не будет производиться переотправка компонента:</target>
        </trans-unit>
        <trans-unit id="20851a45788a2fdc02ea529e15ac7f8112f9de05" translate="yes" xml:space="preserve">
          <source>For example, to profile a &lt;code&gt;Navigation&lt;/code&gt; component and its descendants:</source>
          <target state="translated">Например, чтобы профилировать компонент &lt;code&gt;Navigation&lt;/code&gt; и его потомков:</target>
        </trans-unit>
        <trans-unit id="d13080b59ca5d53e0ba7b314b267e9b38197f049" translate="yes" xml:space="preserve">
          <source>For example, we can create an &lt;code&gt;App&lt;/code&gt; component that renders &lt;code&gt;Welcome&lt;/code&gt; many times:</source>
          <target state="translated">Например, мы можем создать компонент &lt;code&gt;App&lt;/code&gt; который многократно отображает &lt;code&gt;Welcome&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f1ead1eab1f84507539e34706446448f0d28e9f5" translate="yes" xml:space="preserve">
          <source>For example, we could split our component state into &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; objects, and always replace the &lt;code&gt;position&lt;/code&gt; with no need for merging:</source>
          <target state="translated">Например, мы могли бы разделить состояние нашего компонента на объекты &lt;code&gt;position&lt;/code&gt; и &lt;code&gt;size&lt;/code&gt; и всегда заменять &lt;code&gt;position&lt;/code&gt; без необходимости слияния:</target>
        </trans-unit>
        <trans-unit id="2d42c3a9b978bb53213888cf10f240637aca3105" translate="yes" xml:space="preserve">
          <source>For example, when adding an element at the end of the children, converting between these two trees works well:</source>
          <target state="translated">Например,при добавлении элемента в конце детей,преобразование между этими двумя деревьями работает хорошо:</target>
        </trans-unit>
        <trans-unit id="3142f55d25c885268e370e43896a3749c9b69c27" translate="yes" xml:space="preserve">
          <source>For example, your state may contain several independent variables:</source>
          <target state="translated">Например,ваше состояние может содержать несколько независимых переменных:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="331fc234992fd41cfe4aafa1cbadd06d8bfafb82" translate="yes" xml:space="preserve">
          <source>For modal dialogs, ensure that everyone can interact with them by following the &lt;a href=&quot;https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal&quot;&gt;WAI-ARIA Modal Authoring Practices&lt;/a&gt;.</source>
          <target state="translated">Для модальных диалогов убедитесь, что каждый может взаимодействовать с ними, следуя &lt;a href=&quot;https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal&quot;&gt;методам разработки&lt;/a&gt; модальных диалогов WAI-ARIA .</target>
        </trans-unit>
        <trans-unit id="ec096cdc71e0b7a6ca398c02cfc7d40516f822a1" translate="yes" xml:space="preserve">
          <source>For more detail, see:</source>
          <target state="translated">Подробнее см:</target>
        </trans-unit>
        <trans-unit id="8c88366a24fd2ea482dc14d0de87b283bbe87e7a" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;&lt;em&gt;Error Handling in React 16&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения см. В &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;&lt;em&gt;разделе Обработка ошибок в React 16&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db28a2392ea1b7c225c391a0872eaf779d774686" translate="yes" xml:space="preserve">
          <source>For more info, see &lt;a href=&quot;fragments&quot;&gt;the Fragments documentation&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения см. &lt;a href=&quot;fragments&quot;&gt;В документации по фрагментам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ab9916b7ffb2e490bd12d8282c8ddb3d82ffa2a" translate="yes" xml:space="preserve">
          <source>For more information about the &amp;lsquo;function as a child&amp;rsquo; pattern, see &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения о шаблоне &amp;laquo;функция как дочерний&amp;raquo; см. В разделе &amp;laquo; &lt;a href=&quot;render-props&quot;&gt;Свойства рендеринга&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="754ab305ab4f9aeec53763a39090226c0de9d63f" translate="yes" xml:space="preserve">
          <source>For more information about the onChange event, see &lt;a href=&quot;forms&quot;&gt;Forms&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения о событии onChange см . В разделе &lt;a href=&quot;forms&quot;&gt;Формы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0cba5c3c0c27cf5088d9888383d141d07a0f2491" translate="yes" xml:space="preserve">
          <source>For more information on Concurrent Mode, check out the &lt;a href=&quot;concurrent-mode-intro&quot;&gt;Concurrent Mode documentation.&lt;/a&gt;</source>
          <target state="translated">Дополнительные сведения о параллельном режиме см. В &lt;a href=&quot;concurrent-mode-intro&quot;&gt;документации&lt;/a&gt; по параллельному режиму.</target>
        </trans-unit>
        <trans-unit id="b9732d78e0ad658ec6be5aa1a8cfda86c791eaa9" translate="yes" xml:space="preserve">
          <source>For more information, check out &lt;a href=&quot;testing-recipes&quot;&gt;Testing Recipes&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации ознакомьтесь с &lt;a href=&quot;testing-recipes&quot;&gt;рецептами тестирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4a38f12036a32191520afa8a2753bdccc47eea0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;forwarding-refs&quot;&gt;forwarding refs&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;forwarding-refs&quot;&gt;Ссылки на пересылку&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5fc1e92e2c893003eb2447d228048e1a7aaf57a" translate="yes" xml:space="preserve">
          <source>For older codebases, Concurrent Mode might be a step too far. This is why we also provide a new &amp;ldquo;Blocking Mode&amp;rdquo; in the experimental React builds. You can try it by substituting &lt;code&gt;createRoot&lt;/code&gt; with &lt;code&gt;createBlockingRoot&lt;/code&gt;. It only offers a &lt;em&gt;small subset&lt;/em&gt; of the Concurrent Mode features, but it is closer to how React works today and can serve as a migration step.</source>
          <target state="translated">Для более старых кодовых баз Concurrent Mode может оказаться слишком большим шагом. Вот почему мы также предоставляем новый &amp;laquo;режим блокировки&amp;raquo; в экспериментальных сборках React. Вы можете попробовать это, заменив &lt;code&gt;createRoot&lt;/code&gt; на &lt;code&gt;createBlockingRoot&lt;/code&gt; . Он предлагает лишь &lt;em&gt;небольшое подмножество&lt;/em&gt; функций Concurrent Mode, но он ближе к тому, как работает React сегодня, и может служить этапом миграции.</target>
        </trans-unit>
        <trans-unit id="770927b3887fe0c354b4fb137b4cc1bdc30fbbb9" translate="yes" xml:space="preserve">
          <source>For other use cases, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;follow the recommendations in this blog post about derived state&lt;/a&gt;.</source>
          <target state="translated">Для других случаев использования &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;следуйте рекомендациям в этом сообщении блога о производном состоянии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b327cbe7031e739d617d4f75e12fa5fef2acc3b7" translate="yes" xml:space="preserve">
          <source>For the most efficient Browserify production build, install a few plugins:</source>
          <target state="translated">Для наиболее эффективного браузера производственного корпуса,установите несколько плагинов:</target>
        </trans-unit>
        <trans-unit id="17194133fbe1957bfdd4b741f2933c9c86f4ba6d" translate="yes" xml:space="preserve">
          <source>For the most efficient Brunch production build, install the &lt;a href=&quot;https://github.com/brunch/terser-brunch&quot;&gt;&lt;code&gt;terser-brunch&lt;/code&gt;&lt;/a&gt; plugin:</source>
          <target state="translated">Для наиболее эффективной производственной сборки Brunch установите плагин &lt;a href=&quot;https://github.com/brunch/terser-brunch&quot;&gt; &lt;code&gt;terser-brunch&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a6ce51b2f939e3558a44b1cb8fdbdf554bc07d90" translate="yes" xml:space="preserve">
          <source>For the most efficient Rollup production build, install a few plugins:</source>
          <target state="translated">Для наиболее эффективного производства Rollup установите несколько плагинов:</target>
        </trans-unit>
        <trans-unit id="7475cb5e6f5adf915c29f1cdea4e2bdc8ba92aa9" translate="yes" xml:space="preserve">
          <source>For these reasons, we reserve patch releases only for the most critical bugs and security vulnerabilities.</source>
          <target state="translated">По этим причинам мы резервируем патчи только для наиболее критичных ошибок и уязвимостей безопасности.</target>
        </trans-unit>
        <trans-unit id="faa8c036fd5e3a800041a6a85017b66c2fe68715" translate="yes" xml:space="preserve">
          <source>For this change, we&amp;rsquo;ve provided a &lt;a href=&quot;https://github.com/reactjs/react-codemod#error-boundaries&quot;&gt;codemod&lt;/a&gt; to automatically migrate your code.</source>
          <target state="translated">Для этого изменения мы предоставили &lt;a href=&quot;https://github.com/reactjs/react-codemod#error-boundaries&quot;&gt;codemod&lt;/a&gt; для автоматического переноса вашего кода.</target>
        </trans-unit>
        <trans-unit id="4e1bce685a135223c199242bc8c77e474653706f" translate="yes" xml:space="preserve">
          <source>For this reason &lt;code&gt;useDebugValue&lt;/code&gt; accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.</source>
          <target state="translated">По этой причине &lt;code&gt;useDebugValue&lt;/code&gt; принимает функцию форматирования как необязательный второй параметр. Эта функция вызывается только при проверке хуков. Он получает значение отладки в качестве параметра и должен возвращать форматированное отображаемое значение.</target>
        </trans-unit>
        <trans-unit id="d77cd5d73e371d728872a07b909df96d58e4b7b3" translate="yes" xml:space="preserve">
          <source>Forgetting to handle &lt;code&gt;componentDidUpdate&lt;/code&gt; properly is a common source of bugs in React applications.</source>
          <target state="translated">Забывание правильно обработать &lt;code&gt;componentDidUpdate&lt;/code&gt; - частый источник ошибок в приложениях React.</target>
        </trans-unit>
        <trans-unit id="7d30ae53e81b25bd47a3ef79f6270bb2aee0a4b4" translate="yes" xml:space="preserve">
          <source>Form Events</source>
          <target state="translated">События формы</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="955e3f80970e0af47e55f5200545b8b3a318bc97" translate="yes" xml:space="preserve">
          <source>Fortunately, we can explicitly forward refs to the inner &lt;code&gt;FancyButton&lt;/code&gt; component using the &lt;code&gt;React.forwardRef&lt;/code&gt; API. &lt;code&gt;React.forwardRef&lt;/code&gt; accepts a render function that receives &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; parameters and returns a React node. For example:</source>
          <target state="translated">К счастью, мы можем явно перенаправить ссылки на внутренний компонент &lt;code&gt;FancyButton&lt;/code&gt; с &lt;code&gt;React.forwardRef&lt;/code&gt; API React.forwardRef . &lt;code&gt;React.forwardRef&lt;/code&gt; принимает функцию визуализации , который принимает &lt;code&gt;props&lt;/code&gt; и &lt;code&gt;ref&lt;/code&gt; параметры и возвращает узел React. Например:</target>
        </trans-unit>
        <trans-unit id="f601df170026e953bbac95daafb8c35102220f96" translate="yes" xml:space="preserve">
          <source>Forwarding Refs</source>
          <target state="translated">Референты по перевозке</target>
        </trans-unit>
        <trans-unit id="98364eb3c7e295c55161e71c692712d164542fd6" translate="yes" xml:space="preserve">
          <source>Forwarding refs in higher-order components</source>
          <target state="translated">Пересылка ссылок в компонентах более высокого порядка</target>
        </trans-unit>
        <trans-unit id="fe54eca6f507b141b7575b8953c555c23ecbd348" translate="yes" xml:space="preserve">
          <source>Forwarding refs in higher-order-components</source>
          <target state="translated">Транспортировочные реквизиты в компонентах более высокого порядка</target>
        </trans-unit>
        <trans-unit id="ee0dcf389f3ad894e637d4cba7ff22af9df9a072" translate="yes" xml:space="preserve">
          <source>Forwarding refs to DOM components</source>
          <target state="translated">Пересылка ссылок на компоненты DOM</target>
        </trans-unit>
        <trans-unit id="d45089940ca38bf48726ea01710791bffa1dee6e" translate="yes" xml:space="preserve">
          <source>Fragments</source>
          <target state="translated">Fragments</target>
        </trans-unit>
        <trans-unit id="796f3ca672ebd9bd41a7a01b5a01b8745791f0e8" translate="yes" xml:space="preserve">
          <source>Fragments declared with the explicit &lt;code&gt;&amp;lt;React.Fragment&amp;gt;&lt;/code&gt; syntax may have keys. A use case for this is mapping a collection to an array of fragments &amp;mdash; for example, to create a description list:</source>
          <target state="translated">Фрагменты, объявленные с явным синтаксисом &lt;code&gt;&amp;lt;React.Fragment&amp;gt;&lt;/code&gt; , могут иметь ключи. Пример использования для этого - сопоставление коллекции с массивом фрагментов - например, для создания списка описания:</target>
        </trans-unit>
        <trans-unit id="8065c017db022d1f5ec110b82bbd874c082a88f9" translate="yes" xml:space="preserve">
          <source>Fragments solve this problem.</source>
          <target state="translated">Фрагменты решают эту проблему.</target>
        </trans-unit>
        <trans-unit id="3bcb0016a5230b33666fdcf36ccabf570e7de70e" translate="yes" xml:space="preserve">
          <source>Frameworks like &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt;, &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; and &lt;a href=&quot;https://www.seleniumhq.org/projects/webdriver/&quot;&gt;webdriver&lt;/a&gt; are useful for running &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;end-to-end tests&lt;/a&gt;.</source>
          <target state="translated">Такие фреймворки, как &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt; , &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; и &lt;a href=&quot;https://www.seleniumhq.org/projects/webdriver/&quot;&gt;webdriver&lt;/a&gt; , полезны для выполнения сквозных &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;тестов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf9e2789ee767980ad3bc5023d41ac7e306fd5ec" translate="yes" xml:space="preserve">
          <source>Frameworks like Jest also let you save &amp;ldquo;snapshots&amp;rdquo; of data with &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;&lt;code&gt;toMatchSnapshot&lt;/code&gt; / &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt;&lt;/a&gt;. With these, we can &amp;ldquo;save&amp;rdquo; the rendered component output and ensure that a change to it has to be explicitly committed as a change to the snapshot.</source>
          <target state="translated">Такие фреймворки, как Jest, также позволяют сохранять &amp;laquo;снимки&amp;raquo; данных с помощью &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt; &lt;code&gt;toMatchSnapshot&lt;/code&gt; / &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt; &lt;/a&gt; . С их помощью мы можем &amp;laquo;сохранить&amp;raquo; визуализированный вывод компонента и гарантировать, что его изменение должно быть явно зафиксировано как изменение снимка.</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">Часто задаваемые вопросы</target>
        </trans-unit>
        <trans-unit id="149defa1bf170ed878773e58e8f5ff8d5c8a3478" translate="yes" xml:space="preserve">
          <source>From Classes to Hooks</source>
          <target state="translated">От класса к крючкам</target>
        </trans-unit>
        <trans-unit id="bbed11ef2d053428bd9995e6dc4db90c56f977a2" translate="yes" xml:space="preserve">
          <source>From React&amp;rsquo;s point of view, a component using Hooks is just a regular component. If your testing solution doesn&amp;rsquo;t rely on React internals, testing components with Hooks shouldn&amp;rsquo;t be different from how you normally test components.</source>
          <target state="translated">С точки зрения React, компонент, использующий хуки, является обычным компонентом. Если ваше решение для тестирования не полагается на внутренние компоненты React, тестирование компонентов с помощью хуков не должно отличаться от того, как вы обычно тестируете компоненты.</target>
        </trans-unit>
        <trans-unit id="12d07daa800d296a026c49de79bda8bb9f64ea8a" translate="yes" xml:space="preserve">
          <source>From here you could start moving more logic into the component and begin adopting more common React practices. For example, in components it is best not to rely on IDs because the same component can be rendered multiple times. Instead, we will use the &lt;a href=&quot;handling-events&quot;&gt;React event system&lt;/a&gt; and register the click handler directly on the React &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">Отсюда вы можете начать вводить больше логики в компонент и начать применять более распространенные практики React. Например, в компонентах лучше не полагаться на идентификаторы, потому что один и тот же компонент может отображаться несколько раз. Вместо этого мы воспользуемся системой &lt;a href=&quot;handling-events&quot;&gt;событий React&lt;/a&gt; и зарегистрируем обработчик кликов непосредственно в элементе React &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="732afd30e77a6dc18afd55e03cd71f20b12f519d" translate="yes" xml:space="preserve">
          <source>Fully-Fledged Solutions</source>
          <target state="translated">Полнофункциональные решения</target>
        </trans-unit>
        <trans-unit id="d1ab6dc65e716361136b87c26f6834c3fa7eba19" translate="yes" xml:space="preserve">
          <source>Function and Class Components</source>
          <target state="translated">Функциональные и классовые компоненты</target>
        </trans-unit>
        <trans-unit id="fd744c2eded0413dd090011205868c3aa86df00b" translate="yes" xml:space="preserve">
          <source>Function and Class components both have some additional features that we will discuss in the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next sections&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf4dbac73be46db02a4f245d06acae861568bf3" translate="yes" xml:space="preserve">
          <source>Function component bodies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0437f301087d86e5d06d2280e2674b540deaba5" translate="yes" xml:space="preserve">
          <source>Function components are also able to reference &lt;code&gt;context&lt;/code&gt; if &lt;code&gt;contextTypes&lt;/code&gt; is defined as a property of the function. The following code shows a &lt;code&gt;Button&lt;/code&gt; component written as a function component.</source>
          <target state="translated">Компоненты функции также могут ссылаться на &lt;code&gt;context&lt;/code&gt; если &lt;code&gt;contextTypes&lt;/code&gt; определен как свойство функции. В следующем коде показан компонент &lt;code&gt;Button&lt;/code&gt; , написанный как функциональный компонент.</target>
        </trans-unit>
        <trans-unit id="73f523ab76ca84802a4f7ad409b8b8a11d5ec14d" translate="yes" xml:space="preserve">
          <source>Functional updates</source>
          <target state="translated">Функциональные обновления</target>
        </trans-unit>
        <trans-unit id="68254545bf32d5c6b80d7f1482247c069c365636" translate="yes" xml:space="preserve">
          <source>Functions as Children</source>
          <target state="translated">Функции как у детей</target>
        </trans-unit>
        <trans-unit id="1f41b572070fa59c9db0924aa546698fb57d612e" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;useState&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, or &lt;code&gt;useReducer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8b995fc31e98c113f50f1e6e4e3cd2d61d6d9d" translate="yes" xml:space="preserve">
          <source>Fundamentally, JSX just provides syntactic sugar for the &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; function. The JSX code:</source>
          <target state="translated">По сути, JSX просто предоставляет синтаксический сахар для функции &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; . Код JSX:</target>
        </trans-unit>
        <trans-unit id="4d6b62bf07d530cf7754450cf7f4baeba776dcc5" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;React.PureComponent&lt;/code&gt;&amp;rsquo;s &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; skips prop updates for the whole component subtree. Make sure all the children components are also &amp;ldquo;pure&amp;rdquo;.</source>
          <target state="translated">Кроме того, &lt;code&gt;React.PureComponent&lt;/code&gt; &amp;laquo;ы &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; пропускает проп обновления для всего компонента поддерева. Убедитесь, что все дочерние компоненты также &amp;laquo;чистые&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="96bfe330b3c43755e29748c139c92671348a757f" translate="yes" xml:space="preserve">
          <source>Gatsby</source>
          <target state="translated">Gatsby</target>
        </trans-unit>
        <trans-unit id="14837150cbbe37e0d75d8160b89e20cd804e5090" translate="yes" xml:space="preserve">
          <source>Generally speaking, no.</source>
          <target state="translated">Вообще-то,нет.</target>
        </trans-unit>
        <trans-unit id="52caaec9d0bac23a32c7ed19ebe70c6cf9d9b6ff" translate="yes" xml:space="preserve">
          <source>Generally speaking, yes, it is OK, and it is often the easiest way to pass parameters to callback functions.</source>
          <target state="translated">Вообще говоря,да,это нормально,и часто это самый простой способ передать параметры функциям обратного вызова.</target>
        </trans-unit>
        <trans-unit id="28a76c547269406d92dd91388795bcc92164307d" translate="yes" xml:space="preserve">
          <source>Generally, you don&amp;rsquo;t want to keep the generated javascript in your source control, so be sure to add the build folder to your &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">Как правило, вы не хотите хранить сгенерированный javascript в исходном элементе управления, поэтому обязательно добавьте папку сборки в свой &lt;code&gt;.gitignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b5b1a5960100dd8954a497a5206e63c5798df0" translate="yes" xml:space="preserve">
          <source>Generic Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">Начало работы</target>
        </trans-unit>
        <trans-unit id="b75a226127e3ed2978b5f42961dd98a51c54f567" translate="yes" xml:space="preserve">
          <source>Given the code below, we use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; function to take an array of &lt;code&gt;numbers&lt;/code&gt; and double their values. We assign the new array returned by &lt;code&gt;map()&lt;/code&gt; to the variable &lt;code&gt;doubled&lt;/code&gt; and log it:</source>
          <target state="translated">Учитывая приведенный ниже код, мы используем функцию &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; чтобы взять массив &lt;code&gt;numbers&lt;/code&gt; и удвоить их значения. Мы присваиваем новый массив, возвращаемый &lt;code&gt;map()&lt;/code&gt; переменной &lt;code&gt;doubled&lt;/code&gt; и регистрируем его:</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="96136d53d8b75905c13546cd90a5c916cbb29871" translate="yes" xml:space="preserve">
          <source>Glossary and FAQ</source>
          <target state="translated">Глоссарий и FAQ</target>
        </trans-unit>
        <trans-unit id="2f13a545b80f208a5c342a3f09da99fe34c3e60a" translate="yes" xml:space="preserve">
          <source>Glossary of React Terms</source>
          <target state="translated">Глоссарий реакционных терминов</target>
        </trans-unit>
        <trans-unit id="c8a8632c801140a5a9de611953f386d1dbbf8845" translate="yes" xml:space="preserve">
          <source>Go to your project folder in the terminal, and paste these two commands:</source>
          <target state="translated">Перейдите в папку проекта в терминале и вставьте эти две команды:</target>
        </trans-unit>
        <trans-unit id="d182bef8d5f2839f88903394bb60f7e51fd6c42c" translate="yes" xml:space="preserve">
          <source>Google Chromebook Help - Use the Built-in Screen Reader</source>
          <target state="translated">Google Chromebook Справка-Используйте встроенную программу чтения экрана</target>
        </trans-unit>
        <trans-unit id="bcf36c27c78804650761947c87a38f4f6e07ce7e" translate="yes" xml:space="preserve">
          <source>Gradual Adoption Strategy</source>
          <target state="translated">Стратегия постепенного принятия</target>
        </trans-unit>
        <trans-unit id="428e0a93f1ac72bcc666336cd6d935f2d9640d9e" translate="yes" xml:space="preserve">
          <source>Gradual Upgrades via Warnings</source>
          <target state="translated">Постепенное обновление через Предупреждения</target>
        </trans-unit>
        <trans-unit id="58273e47057ce993d5fd97a4eb4dface99c26929" translate="yes" xml:space="preserve">
          <source>Great! Now when we run our build script the compiler will output the generated javascript to the &lt;code&gt;build&lt;/code&gt; folder. The &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json&quot;&gt;TypeScript React Starter&lt;/a&gt; provides a &lt;code&gt;tsconfig.json&lt;/code&gt; with a good set of rules to get you started.</source>
          <target state="translated">Большой! Теперь, когда мы запускаем наш скрипт сборки, компилятор выводит сгенерированный javascript в папку &lt;code&gt;build&lt;/code&gt; . &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json&quot;&gt;Машинопись Реагировать Стартер&lt;/a&gt; обеспечивает &lt;code&gt;tsconfig.json&lt;/code&gt; с хорошим набором правил , чтобы вы начали.</target>
        </trans-unit>
        <trans-unit id="72b257d572f9de8cb600dc9ff344b295b0affeca" translate="yes" xml:space="preserve">
          <source>Grouping by features or routes</source>
          <target state="translated">Группировка по характеристикам или маршрутам</target>
        </trans-unit>
        <trans-unit id="b7fd6516d065f4d8e30a111bc4d1476d4af19bbe" translate="yes" xml:space="preserve">
          <source>Grouping by file type</source>
          <target state="translated">Группировка по типам файлов</target>
        </trans-unit>
        <trans-unit id="b02dd6f98e40fbc355cf17dc049baecc28173b57" translate="yes" xml:space="preserve">
          <source>HOCs add features to a component. They shouldn&amp;rsquo;t drastically alter its contract. It&amp;rsquo;s expected that the component returned from a HOC has a similar interface to the wrapped component.</source>
          <target state="translated">HOC добавляют функции к компоненту. Они не должны кардинально менять контракт. Ожидается, что компонент, возвращаемый из HOC, имеет интерфейс, аналогичный обернутому компоненту.</target>
        </trans-unit>
        <trans-unit id="063035c50f06bf73e08fe91d42e9d79e9dcc00b0" translate="yes" xml:space="preserve">
          <source>HOCs are common in third-party React libraries, such as Redux&amp;rsquo;s &lt;a href=&quot;https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; and Relay&amp;rsquo;s &lt;a href=&quot;http://facebook.github.io/relay/docs/en/fragment-container.html&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HOCs распространены в качестве третьей стороны Реагировать библиотеки, такие как Redux - х &lt;a href=&quot;https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; и реле &lt;a href=&quot;http://facebook.github.io/relay/docs/en/fragment-container.html&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c8962b048f87decc8156392f32206c1be5db772" translate="yes" xml:space="preserve">
          <source>HOCs should pass through props that are unrelated to its specific concern. Most HOCs contain a render method that looks something like this:</source>
          <target state="translated">HOC должны проходить через реквизит,не связанный с его конкретной задачей.Большинство HOC содержат метод рендеринга,который выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="90574747f52ec1f5009a45ed8d33cb2283639a02" translate="yes" xml:space="preserve">
          <source>HTML form elements work a little bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name:</source>
          <target state="translated">Элементы формы HTML работают немного иначе,чем другие элементы DOM в React,потому что элементы формы естественным образом сохраняют некоторое внутреннее состояние.Например,эта форма в простом HTML принимает одно имя:</target>
        </trans-unit>
        <trans-unit id="0d2d67fd740d7ec7df3d8674c33679652ab92712" translate="yes" xml:space="preserve">
          <source>Handling Errors</source>
          <target state="translated">Обработка ошибок</target>
        </trans-unit>
        <trans-unit id="d425f7e27fe0f057871c46f4c72c4a3bd2b0f136" translate="yes" xml:space="preserve">
          <source>Handling Events</source>
          <target state="translated">Обрабатывающие события</target>
        </trans-unit>
        <trans-unit id="a45618425a820085679577753f54c9b8cd00317e" translate="yes" xml:space="preserve">
          <source>Handling Multiple Inputs</source>
          <target state="translated">Обработка нескольких входов</target>
        </trans-unit>
        <trans-unit id="af96eff387bd2ffe3a5340f3ed51fac600fd535c" translate="yes" xml:space="preserve">
          <source>Handling events with React elements has some syntactic differences:</source>
          <target state="translated">Обработка событий с элементами реакции имеет некоторые синтаксические различия:</target>
        </trans-unit>
        <trans-unit id="d5e781a7966802398bc6183dffb3545a19611d53" translate="yes" xml:space="preserve">
          <source>Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:</source>
          <target state="translated">Обработка событий с помощью реактивных элементов очень похожа на обработку событий на DOM-элементах.Существуют некоторые синтаксические различия:</target>
        </trans-unit>
        <trans-unit id="47bdd35246e7567f551a4817bb36764578de248d" translate="yes" xml:space="preserve">
          <source>Handling events with React elements is very similar to handling events on DOM elements. There are some syntax differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710df444e674bad2b7f10527830ac10000028b6c" translate="yes" xml:space="preserve">
          <source>Here are some good resources for further reading on when to use &lt;code&gt;props&lt;/code&gt; vs &lt;code&gt;state&lt;/code&gt;:</source>
          <target state="translated">Вот несколько полезных ресурсов для дальнейшего чтения о том, когда использовать &lt;code&gt;props&lt;/code&gt; vs &lt;code&gt;state&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0fa9e19aaf02a489848d103e6df5f48fd01b2888" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key&quot;&gt;an example of the issues that can be caused by using indexes as keys&lt;/a&gt; on CodePen, and here is &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key&quot;&gt;an updated version of the same example showing how not using indexes as keys will fix these reordering, sorting, and prepending issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3421fa1b421c70fdf50bc5b3706d1884ec45d9" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;small demo&lt;/a&gt; to get you started. To learn more, check out &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; about data fetching with Hooks.</source>
          <target state="translated">Вот &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;небольшая демонстрация,&lt;/a&gt; чтобы вы начали. Чтобы узнать больше, ознакомьтесь с &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;этой статьей&lt;/a&gt; о получении данных с помощью хуков.</target>
        </trans-unit>
        <trans-unit id="c8317f95e08c6543e53027d145f8eddcf023d7fe" translate="yes" xml:space="preserve">
          <source>Here is a step-by-step explanation of what happens in the above example:</source>
          <target state="translated">Вот пошаговое объяснение того,что происходит в приведенном выше примере:</target>
        </trans-unit>
        <trans-unit id="10e83a22ccb4f6fc7030872a422ceee48e5b88b6" translate="yes" xml:space="preserve">
          <source>Here is an &lt;a href=&quot;reconciliation#recursing-on-children&quot;&gt;in-depth explanation about why keys are necessary&lt;/a&gt; if you&amp;rsquo;re interested in learning more.</source>
          <target state="translated">Вот &lt;a href=&quot;reconciliation#recursing-on-children&quot;&gt;подробное объяснение того, зачем нужны ключи,&lt;/a&gt; если вы хотите узнать больше.</target>
        </trans-unit>
        <trans-unit id="469c11af4fb767b071b7bc9fc6660c36d0303d75" translate="yes" xml:space="preserve">
          <source>Here is an example documenting the different validators provided:</source>
          <target state="translated">Вот пример документирования различных предоставленных валидаторов:</target>
        </trans-unit>
        <trans-unit id="dd61c330907127ed38d293d1d4af5a24b4c290e7" translate="yes" xml:space="preserve">
          <source>Here is how we can test it:</source>
          <target state="translated">Вот как мы можем это проверить:</target>
        </trans-unit>
        <trans-unit id="3102275a43d8c23e8b4c58890783bfe23456b8e1" translate="yes" xml:space="preserve">
          <source>Here is the equivalent with &lt;a href=&quot;hooks-intro&quot;&gt;Hooks&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36728af60fa3c9f7c434352505e9201caca43d44" translate="yes" xml:space="preserve">
          <source>Here we require knowledge of &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#roles&quot;&gt;ARIA Roles&lt;/a&gt; as well as &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#states_and_properties&quot;&gt;ARIA States and Properties&lt;/a&gt;. These are toolboxes filled with HTML attributes that are fully supported in JSX and enable us to construct fully accessible, highly functional React components.</source>
          <target state="translated">Здесь нам необходимо знать &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#roles&quot;&gt;роли ARIA,&lt;/a&gt; а также состояния &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#states_and_properties&quot;&gt;и свойства ARIA&lt;/a&gt; . Это наборы инструментов, заполненные атрибутами HTML, которые полностью поддерживаются в JSX и позволяют нам создавать полностью доступные, высокофункциональные компоненты React.</target>
        </trans-unit>
        <trans-unit id="dc9d8cd325a00d9730f610bfeca5652d530f0f8e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a subtree of components. For each one, &lt;code&gt;SCU&lt;/code&gt; indicates what &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned, and &lt;code&gt;vDOMEq&lt;/code&gt; indicates whether the rendered React elements were equivalent. Finally, the circle&amp;rsquo;s color indicates whether the component had to be reconciled or not.</source>
          <target state="translated">Вот поддерево компонентов. Для каждого из них &lt;code&gt;SCU&lt;/code&gt; указывает, что &lt;code&gt;shouldComponentUpdate&lt;/code&gt; возвращать shouldComponentUpdate , а &lt;code&gt;vDOMEq&lt;/code&gt; указывает, были ли обработанные элементы React эквивалентными. Наконец, цвет круга указывает, нужно ли согласовывать компонент или нет.</target>
        </trans-unit>
        <trans-unit id="3e5e88093705abf9b440083ab6665499dccb5254" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how to setup route-based code splitting into your app using libraries like &lt;a href=&quot;https://reacttraining.com/react-router/&quot;&gt;React Router&lt;/a&gt; with &lt;code&gt;React.lazy&lt;/code&gt;.</source>
          <target state="translated">Вот пример того, как настроить разбиение кода на основе маршрута в вашем приложении с помощью таких библиотек, как &lt;a href=&quot;https://reacttraining.com/react-router/&quot;&gt;React Router&lt;/a&gt; с &lt;code&gt;React.lazy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="983fc3a4301db31eed982a269174f75044f4d44b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the counter example from the &lt;a href=&quot;#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; section, rewritten to use a reducer:</source>
          <target state="translated">Вот пример счетчика из раздела &lt;a href=&quot;#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt; , переписанный для использования редуктора:</target>
        </trans-unit>
        <trans-unit id="6ccd56b3438af9572583e63a1873615e49b63ab1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what happens when we render &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; on the screen:</source>
          <target state="translated">Вот что происходит, когда мы отображаем &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; на экране:</target>
        </trans-unit>
        <trans-unit id="23a6a5eadd7c0a89a44b430f4d016d98f4bf2e1e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s where the render prop comes in: Instead of hard-coding a &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; inside a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component, and effectively changing its rendered output, we can provide &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a function prop that it uses to dynamically determine what to render&amp;ndash;a render prop.</source>
          <target state="translated">Вот где появляется свойство рендеринга: вместо жесткого кодирования &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; внутри компонента &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; и эффективного изменения его визуализированного вывода мы можем предоставить &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; опору функции, которую он использует для динамического определения того, что рендерить &amp;ndash;Рендеринг опоры.</target>
        </trans-unit>
        <trans-unit id="4fc4a89b23c19ca1c558111776c4ec5e877854de" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;e&lt;/code&gt; is a synthetic event. React defines these synthetic events according to the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C spec&lt;/a&gt;, so you don&amp;rsquo;t need to worry about cross-browser compatibility. React events do not work exactly the same as native events. See the &lt;a href=&quot;events&quot;&gt;&lt;code&gt;SyntheticEvent&lt;/code&gt;&lt;/a&gt; reference guide to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ee35e6fcb6ceeda6ad5733dbfe3081d417836a" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;e&lt;/code&gt; is a synthetic event. React defines these synthetic events according to the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C spec&lt;/a&gt;, so you don&amp;rsquo;t need to worry about cross-browser compatibility. See the &lt;a href=&quot;events&quot;&gt;&lt;code&gt;SyntheticEvent&lt;/code&gt;&lt;/a&gt; reference guide to learn more.</source>
          <target state="translated">Здесь &lt;code&gt;e&lt;/code&gt; - синтетическое событие. React определяет эти синтетические события в соответствии со &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;спецификацией W3C&lt;/a&gt; , поэтому вам не нужно беспокоиться о кросс-браузерной совместимости. См. Справочное руководство &lt;a href=&quot;events&quot;&gt; &lt;code&gt;SyntheticEvent&lt;/code&gt; ,&lt;/a&gt; чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="fc55606f595a34d3c61c69e9ffbf6a6904254c39" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;useState&lt;/code&gt; is a &lt;em&gt;Hook&lt;/em&gt; (we&amp;rsquo;ll talk about what this means in a moment). We call it inside a function component to add some local state to it. React will preserve this state between re-renders. &lt;code&gt;useState&lt;/code&gt; returns a pair: the &lt;em&gt;current&lt;/em&gt; state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It&amp;rsquo;s similar to &lt;code&gt;this.setState&lt;/code&gt; in a class, except it doesn&amp;rsquo;t merge the old and new state together. (We&amp;rsquo;ll show an example comparing &lt;code&gt;useState&lt;/code&gt; to &lt;code&gt;this.state&lt;/code&gt; in &lt;a href=&quot;hooks-state&quot;&gt;Using the State Hook&lt;/a&gt;.)</source>
          <target state="translated">Здесь &lt;code&gt;useState&lt;/code&gt; - это &lt;em&gt;хук&lt;/em&gt; (мы поговорим о том, что это означает чуть позже ). Мы вызываем его внутри функционального компонента, чтобы добавить к нему некоторое локальное состояние. React сохранит это состояние между повторными рендерингами. &lt;code&gt;useState&lt;/code&gt; возвращает пару: &lt;em&gt;текущее&lt;/em&gt; значение состояния и функцию, которая позволяет вам его обновить. Вы можете вызвать эту функцию из обработчика событий или где-нибудь еще. Он похож на &lt;code&gt;this.setState&lt;/code&gt; в классе, за исключением того, что он не объединяет старое и новое состояние вместе. (Мы покажем пример сравнения &lt;code&gt;useState&lt;/code&gt; с &lt;code&gt;this.state&lt;/code&gt; в разделе &lt;a href=&quot;hooks-state&quot;&gt;Использование &lt;/a&gt;обработчика состояния .)</target>
        </trans-unit>
        <trans-unit id="62ba3ca71c800446a468a8f1df328896c57eaf85" translate="yes" xml:space="preserve">
          <source>Here, we store the previous value of the &lt;code&gt;row&lt;/code&gt; prop in a state variable so that we can compare:</source>
          <target state="translated">Здесь мы сохраняем предыдущее значение свойства &lt;code&gt;row&lt;/code&gt; в переменной состояния, чтобы мы могли сравнить:</target>
        </trans-unit>
        <trans-unit id="694a8ab065bc1ddcb8bfd82b16d99febb5b29744" translate="yes" xml:space="preserve">
          <source>Heydon Pickering - ARIA Examples</source>
          <target state="translated">Пикеринг Хейдона-АРИА Примеры</target>
        </trans-unit>
        <trans-unit id="9949204d6ccc01e71532e6b5a07e754220b79927" translate="yes" xml:space="preserve">
          <source>Higher-Order Components</source>
          <target state="translated">Высококачественные компоненты</target>
        </trans-unit>
        <trans-unit id="020cce2b859c795f0df3f5cefeb0457647d208e5" translate="yes" xml:space="preserve">
          <source>Higher-order components come with a few caveats that aren&amp;rsquo;t immediately obvious if you&amp;rsquo;re new to React.</source>
          <target state="translated">Компоненты более высокого порядка имеют несколько недостатков, которые не сразу очевидны, если вы новичок в React.</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="5f4d9480b4df0d6e740642769da4ab963d23e1df" translate="yes" xml:space="preserve">
          <source>Hooks &lt;strong&gt;don&amp;rsquo;t&lt;/strong&gt; work inside classes. But you can use them instead of writing classes.</source>
          <target state="translated">Хуки &lt;strong&gt;не&lt;/strong&gt; работают внутри классов. Но вы можете использовать их вместо написания уроков.</target>
        </trans-unit>
        <trans-unit id="6346e065d302bd612cb57acc37b5c4b2d11b5c55" translate="yes" xml:space="preserve">
          <source>Hooks API Reference</source>
          <target state="translated">API крючков Ссылка</target>
        </trans-unit>
        <trans-unit id="83f68a3284889949ad8da40e185f437f9cd788cc" translate="yes" xml:space="preserve">
          <source>Hooks FAQ</source>
          <target state="translated">Часто задаваемые вопросы</target>
        </trans-unit>
        <trans-unit id="6741749abbd97e5aa67270b4114318826ae8ec0d" translate="yes" xml:space="preserve">
          <source>Hooks and Function Components</source>
          <target state="translated">Крючки и функциональные компоненты</target>
        </trans-unit>
        <trans-unit id="984e9f1dce4f6c473f93ec63fbba28614d61a0c3" translate="yes" xml:space="preserve">
          <source>Hooks are &lt;a href=&quot;hooks-intro#no-breaking-changes&quot;&gt;backwards-compatible&lt;/a&gt;. This page provides an overview of Hooks for experienced React users. This is a fast-paced overview. If you get confused, look for a yellow box like this:</source>
          <target state="translated">Крючки &lt;a href=&quot;hooks-intro#no-breaking-changes&quot;&gt;обратно совместимы&lt;/a&gt; . На этой странице представлен обзор хуков для опытных пользователей React. Это динамичный обзор. Если вы запутались, ищите желтую рамку вроде этого:</target>
        </trans-unit>
        <trans-unit id="de1b424d96849c452e8623c3aff21cbd2124f794" translate="yes" xml:space="preserve">
          <source>Hooks are JavaScript functions, but they impose two additional rules:</source>
          <target state="translated">Крюки-это JavaScript-функции,но они накладывают два дополнительных правила:</target>
        </trans-unit>
        <trans-unit id="c38711e94905b544d78f9780d3bf6f82e5586c52" translate="yes" xml:space="preserve">
          <source>Hooks are JavaScript functions, but you need to follow two rules when using them. We provide a &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter plugin&lt;/a&gt; to enforce these rules automatically:</source>
          <target state="translated">Хуки - это функции JavaScript, но при их использовании необходимо соблюдать два правила. Мы предоставляем &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;подключаемый модуль линтера&lt;/a&gt; для автоматического применения этих правил:</target>
        </trans-unit>
        <trans-unit id="12baa054732ac507c2f0e0ac9c1bc905d155c97a" translate="yes" xml:space="preserve">
          <source>Hooks are a more direct way to use the React features you already know &amp;mdash; such as state, lifecycle, context, and refs. They don&amp;rsquo;t fundamentally change how React works, and your knowledge of components, props, and top-down data flow is just as relevant.</source>
          <target state="translated">Хуки - это более прямой способ использования уже известных вам функций React, таких как состояние, жизненный цикл, контекст и ссылки. Они принципиально не меняют принцип работы React, и ваши знания о компонентах, свойствах и нисходящем потоке данных не менее важны.</target>
        </trans-unit>
        <trans-unit id="b3dffafdaf027921074c093681b6b2fa42d7706d" translate="yes" xml:space="preserve">
          <source>Hooks are called in the same order on every render.</source>
          <target state="translated">Крюки вызываются в одном и том же порядке на каждом рендере.</target>
        </trans-unit>
        <trans-unit id="4f6e49743738970df49a4e276c80da3002abd881" translate="yes" xml:space="preserve">
          <source>Hooks are functions that let you &amp;ldquo;hook into&amp;rdquo; React state and lifecycle features from function components. Hooks don&amp;rsquo;t work inside classes &amp;mdash; they let you use React without classes. (We &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;don&amp;rsquo;t recommend&lt;/a&gt; rewriting your existing components overnight but you can start using Hooks in the new ones if you&amp;rsquo;d like.)</source>
          <target state="translated">Хуки - это функции, которые позволяют вам &amp;laquo;подключиться&amp;raquo; к функциям состояния и жизненного цикла React из функциональных компонентов. Хуки не работают внутри классов - они позволяют использовать React без классов. (Мы &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;не рекомендуем&lt;/a&gt; переписывать существующие компоненты в одночасье, но вы можете начать использовать хуки в новых, если хотите.)</target>
        </trans-unit>
        <trans-unit id="ea0760f5cbbc31d25fdb696fae6c90d049a7e43f" translate="yes" xml:space="preserve">
          <source>Hooks at a Glance</source>
          <target state="translated">С первого взгляда</target>
        </trans-unit>
        <trans-unit id="d26a024e6656cfd225f9b3faaf69112eb79c72b0" translate="yes" xml:space="preserve">
          <source>Hooks avoid a lot of the overhead that classes require, like the cost of creating class instances and binding event handlers in the constructor.</source>
          <target state="translated">Крючки позволяют избежать больших накладных расходов,которые требуются классам,таких как расходы на создание экземпляров классов и привязку обработчиков событий в конструкторе.</target>
        </trans-unit>
        <trans-unit id="c4f46f02e8a51698c3e23f41f8d864b3b26080e0" translate="yes" xml:space="preserve">
          <source>Hooks do have a learning curve of their own. If there&amp;rsquo;s something missing in this documentation, &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;raise an issue&lt;/a&gt; and we&amp;rsquo;ll try to help.</source>
          <target state="translated">У хуков есть своя кривая обучения. Если в этой документации чего-то не хватает, &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;поднимите вопрос,&lt;/a&gt; и мы постараемся помочь.</target>
        </trans-unit>
        <trans-unit id="e78aadbe4b447f0e05b05e1acb099273d9660236" translate="yes" xml:space="preserve">
          <source>Hooks let you organize side effects in a component by what pieces are related (such as adding and removing a subscription), rather than forcing a split based on lifecycle methods.</source>
          <target state="translated">Крючки позволяют организовать побочные эффекты в компоненте по тому,с какими частями он связан (например,добавление и удаление подписки),вместо того,чтобы форсировать разделение на основе методов жизненного цикла.</target>
        </trans-unit>
        <trans-unit id="4fd8adc24c90fba774c6fae7ebe2e06da199b06e" translate="yes" xml:space="preserve">
          <source>Hooks offer a powerful and expressive new way to reuse functionality between components. &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;Building Your Own Hooks&amp;rdquo;&lt;/a&gt; provides a glimpse of what&amp;rsquo;s possible. &lt;a href=&quot;https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889&quot;&gt;This article&lt;/a&gt; by a React core team member dives deeper into the new capabilities unlocked by Hooks.</source>
          <target state="translated">Хуки предлагают новый мощный и выразительный способ повторного использования функций между компонентами. &lt;a href=&quot;hooks-custom&quot;&gt;&amp;laquo;Создание собственных крючков&amp;raquo;&lt;/a&gt; дает представление о том, что возможно. &lt;a href=&quot;https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889&quot;&gt;Эта статья&lt;/a&gt; члена основной команды React более подробно описывает новые возможности, которые открывает Hooks.</target>
        </trans-unit>
        <trans-unit id="beee8e71e8faa563add416aa12ae92953a859ef1" translate="yes" xml:space="preserve">
          <source>Hooks solve a wide variety of seemingly unconnected problems in React that we&amp;rsquo;ve encountered over five years of writing and maintaining tens of thousands of components. Whether you&amp;rsquo;re learning React, use it daily, or even prefer a different library with a similar component model, you might recognize some of these problems.</source>
          <target state="translated">Хуки решают широкий спектр кажущихся несвязанными проблем в React, с которыми мы столкнулись за пять лет написания и поддержки десятков тысяч компонентов. Независимо от того, изучаете ли вы React, используете ли вы его ежедневно или даже предпочитаете другую библиотеку с аналогичной компонентной моделью, вы можете распознать некоторые из этих проблем.</target>
        </trans-unit>
        <trans-unit id="125ff9caefd47f46f6f9836d25c8aeb5965e4029" translate="yes" xml:space="preserve">
          <source>Hooks synthesize ideas from several different sources:</source>
          <target state="translated">Крюки синтезируют идеи из нескольких разных источников:</target>
        </trans-unit>
        <trans-unit id="9ddd1c044852bd20a73c95243ed31e59f05c49ac" translate="yes" xml:space="preserve">
          <source>Hooks were designed with static typing in mind. Because they&amp;rsquo;re functions, they are easier to type correctly than patterns like higher-order components. The latest Flow and TypeScript React definitions include support for React Hooks.</source>
          <target state="translated">Хуки были разработаны с учетом статической типизации. Поскольку они являются функциями, их легче вводить правильно, чем шаблоны, такие как компоненты более высокого порядка. Последние определения Flow и TypeScript React включают поддержку React Hooks.</target>
        </trans-unit>
        <trans-unit id="3263600c56483c0a3a486401c7c00425cf496889" translate="yes" xml:space="preserve">
          <source>Hopefully, this gives you an idea of how to think about building components and applications with React. While it may be a little more typing than you&amp;rsquo;re used to, remember that code is read far more than it&amp;rsquo;s written, and it&amp;rsquo;s less difficult to read this modular, explicit code. As you start to build large libraries of components, you&amp;rsquo;ll appreciate this explicitness and modularity, and with code reuse, your lines of code will start to shrink. :)</source>
          <target state="translated">Надеюсь, это даст вам представление о том, как думать о создании компонентов и приложений с помощью React. Хотя это может быть немного больше набора текста, чем вы привыкли, помните, что код читается гораздо больше, чем он написан, и этот модульный, явный код легче читать. Когда вы начнете создавать большие библиотеки компонентов, вы оцените эту явность и модульность, а при повторном использовании кода ваши строки кода начнут сокращаться. :)</target>
        </trans-unit>
        <trans-unit id="692095ebf5adc28ef5dd43de59073c7e0f30fed7" translate="yes" xml:space="preserve">
          <source>How About Event Handlers?</source>
          <target state="translated">Как насчет организаторов мероприятий?</target>
        </trans-unit>
        <trans-unit id="cb6ede7c8218456d272e15d1df527222761a5d58" translate="yes" xml:space="preserve">
          <source>How About try/catch?</source>
          <target state="translated">Как насчет &quot;попробуй/поймай&quot;?</target>
        </trans-unit>
        <trans-unit id="10f9d04f7128ff4e06c8d87250d8e47453873aca" translate="yes" xml:space="preserve">
          <source>How Can I Learn More About Experimental Features?</source>
          <target state="translated">Как узнать больше об экспериментальных возможностях?</target>
        </trans-unit>
        <trans-unit id="6b32b4ad6bd37176faffadb32d22a8289534a746" translate="yes" xml:space="preserve">
          <source>How To Use Context</source>
          <target state="translated">Как использовать контекст</target>
        </trans-unit>
        <trans-unit id="0d3b1dc4703059a43990fb4f54a82b7ea462210e" translate="yes" xml:space="preserve">
          <source>How can I do data fetching with Hooks?</source>
          <target state="translated">Как я могу получить данные с помощью Hooks?</target>
        </trans-unit>
        <trans-unit id="5f3eb93766a70bcb23bd57b5f81706e1346cc00b" translate="yes" xml:space="preserve">
          <source>How can I make an AJAX call?</source>
          <target state="translated">Как я могу позвонить в AJAX?</target>
        </trans-unit>
        <trans-unit id="d65c5d09d6ca3b416e582fadae15682637bf85c2" translate="yes" xml:space="preserve">
          <source>How can I measure a DOM node?</source>
          <target state="translated">Как измерить DOM-узел?</target>
        </trans-unit>
        <trans-unit id="fe8a15cb87dd32841f00b87b456991b2721d9c55" translate="yes" xml:space="preserve">
          <source>How can I prevent a function from being called too quickly or too many times in a row?</source>
          <target state="translated">Как предотвратить слишком быстрый или многократный вызов функции?</target>
        </trans-unit>
        <trans-unit id="6aec71a52b9be72fd0463ec529f9c780d7f499e0" translate="yes" xml:space="preserve">
          <source>How can I write comments in JSX?</source>
          <target state="translated">Как я могу писать комментарии в JSX?</target>
        </trans-unit>
        <trans-unit id="83d4d9bc9ea4bb507420dda2c277f59106d4c62f" translate="yes" xml:space="preserve">
          <source>How do I add CSS classes to components?</source>
          <target state="translated">Как добавить CSS-классы к компонентам?</target>
        </trans-unit>
        <trans-unit id="81a15ac345101e045ea595d31734e8063db66661" translate="yes" xml:space="preserve">
          <source>How do I bind a function to a component instance?</source>
          <target state="translated">Как привязать функцию к экземпляру компонента?</target>
        </trans-unit>
        <trans-unit id="aa62b3618db8ebfa8f917b302351ed7099483e1f" translate="yes" xml:space="preserve">
          <source>How do I implement &lt;code&gt;getDerivedStateFromProps&lt;/code&gt;?</source>
          <target state="translated">Как реализовать &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d0572ad330916c3fe730299d4ede58b185b5ca13" translate="yes" xml:space="preserve">
          <source>How do I implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt;?</source>
          <target state="translated">Как реализовать &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="fb9e955accc6d91168550466054bc2a0652117d7" translate="yes" xml:space="preserve">
          <source>How do I implement getDerivedStateFromProps?</source>
          <target state="translated">Как реализовать getDerivedStateFromProps?</target>
        </trans-unit>
        <trans-unit id="e9415649ba2cf6fdc23c48d06f17328a84773eae" translate="yes" xml:space="preserve">
          <source>How do I implement shouldComponentUpdate?</source>
          <target state="translated">Как внедрить систему &quot;Обновить компоненты&quot; (shouldComponentUpdate)?</target>
        </trans-unit>
        <trans-unit id="d0ca0d1ae983bdbef86eee8bd0c53b191176837f" translate="yes" xml:space="preserve">
          <source>How do I pass a parameter to an event handler or callback?</source>
          <target state="translated">Как передать параметр обработчику события или обратный вызов?</target>
        </trans-unit>
        <trans-unit id="38b2ecaed14852353d71b3ff348314158c48bfb1" translate="yes" xml:space="preserve">
          <source>How do I pass an event handler (like onClick) to a component?</source>
          <target state="translated">Как передать обработчик события (например,onClick)компоненту?</target>
        </trans-unit>
        <trans-unit id="b0b4082736e34d847d56b0cabd7b94a845d15d06" translate="yes" xml:space="preserve">
          <source>How do I update state with values that depend on the current state?</source>
          <target state="translated">Как обновить состояние со значениями,которые зависят от текущего состояния?</target>
        </trans-unit>
        <trans-unit id="1571c2b05260a179a5c52b92711d13ace65d09c2" translate="yes" xml:space="preserve">
          <source>How do lifecycle methods correspond to Hooks?</source>
          <target state="translated">Как методы жизненного цикла соответствуют Крюкам?</target>
        </trans-unit>
        <trans-unit id="ef86d6c075ad452ca05fc6dfcb095042d6b94c62" translate="yes" xml:space="preserve">
          <source>How do we separate the Receded and the Skeleton states? The difference between them is that the &lt;strong&gt;Receded&lt;/strong&gt; state feels like &amp;ldquo;taking a step back&amp;rdquo; to the user, while the &lt;strong&gt;Skeleton&lt;/strong&gt; state feels like &amp;ldquo;taking a step forward&amp;rdquo; in our progress to show more content.</source>
          <target state="translated">Как разделить состояние &amp;laquo;Отступление&amp;raquo; и &amp;laquo;Скелет&amp;raquo;? Разница между ними заключается в том, что состояние &amp;laquo; &lt;strong&gt;Удаленный&amp;raquo;&lt;/strong&gt; воспринимается как &amp;laquo;шаг назад&amp;raquo; для пользователя, а состояние &amp;laquo; &lt;strong&gt;Скелет&amp;raquo; -&lt;/strong&gt; как &amp;laquo;шаг вперед&amp;raquo; в нашем прогрессе, чтобы показать больше контента.</target>
        </trans-unit>
        <trans-unit id="9cd07e5b2055c72f75ab42f26ab2628f05373053" translate="yes" xml:space="preserve">
          <source>How does React associate Hook calls with components?</source>
          <target state="translated">Как React связывает звонки с помощью Hook с компонентами?</target>
        </trans-unit>
        <trans-unit id="03433b6618565d81523f098fea7bbfc849e26f58" translate="yes" xml:space="preserve">
          <source>How is this different from debouncing? Our example has a fixed artificial delay (3ms for every one of 80 items), so there is always a delay, no matter how fast our computer is. However, the &lt;code&gt;useDeferredValue&lt;/code&gt; value only &amp;ldquo;lags behind&amp;rdquo; if the rendering takes a while. There is no minimal lag imposed by React. With a more realistic workload, you can expect the lag to adjust to the user&amp;rsquo;s device. On fast machines, the lag would be smaller or non-existent, and on slow machines, it would be more noticeable. In both cases, the app would remain responsive. That&amp;rsquo;s the advantage of this mechanism over debouncing or throttling, which always impose a minimal delay and can&amp;rsquo;t avoid blocking the thread while rendering.</source>
          <target state="translated">Чем это отличается от противодействия? В нашем примере есть фиксированная искусственная задержка (3 мс для каждого из 80 элементов), поэтому всегда есть задержка, независимо от того, насколько быстрым является наш компьютер. Однако значение &lt;code&gt;useDeferredValue&lt;/code&gt; &amp;laquo;отстает&amp;raquo; только в том случае, если рендеринг занимает некоторое время. React не требует минимальной задержки. При более реалистичной рабочей нагрузке можно ожидать, что задержка будет адаптироваться к устройству пользователя. На быстрых машинах задержка будет меньше или вообще не будет, а на медленных она будет более заметной. В обоих случаях приложение останется отзывчивым. В этом преимущество этого механизма по сравнению с отладкой или регулированием, которые всегда накладывают минимальную задержку и не могут избежать блокировки потока во время рендеринга.</target>
        </trans-unit>
        <trans-unit id="ef20a3ab1615429a9e3caea2dfc9283ba06feb8c" translate="yes" xml:space="preserve">
          <source>How much of my React knowledge stays relevant?</source>
          <target state="translated">Сколько моих знаний о реакции остается актуальным?</target>
        </trans-unit>
        <trans-unit id="01cf9009310d5e4e171575929c85ba93f68d8165" translate="yes" xml:space="preserve">
          <source>How to Approach the Problem</source>
          <target state="translated">Как подойти к проблеме</target>
        </trans-unit>
        <trans-unit id="772ce99a70283ae35b4e13fa8d26821113684e81" translate="yes" xml:space="preserve">
          <source>How to Read This Guide</source>
          <target state="translated">Как прочитать это руководство</target>
        </trans-unit>
        <trans-unit id="5e5bdd73691289d5424afb561fb4d4a8c352d85e" translate="yes" xml:space="preserve">
          <source>How to avoid passing callbacks down?</source>
          <target state="translated">Как избежать обратного вызова?</target>
        </trans-unit>
        <trans-unit id="e4460bb5cb239f962c6f963dd45f4bfc12fafab4" translate="yes" xml:space="preserve">
          <source>How to create expensive objects lazily?</source>
          <target state="translated">Как лениво создавать дорогие объекты?</target>
        </trans-unit>
        <trans-unit id="b8b7e53bed65fc2a70652cc57c409f8809ebddf6" translate="yes" xml:space="preserve">
          <source>How to get the previous props or state?</source>
          <target state="translated">Как получить предыдущий реквизит или штат?</target>
        </trans-unit>
        <trans-unit id="c24f12ba653d001525d8a8bd81fe1cef3fad0860" translate="yes" xml:space="preserve">
          <source>How to memoize calculations?</source>
          <target state="translated">Как запоминать расчеты?</target>
        </trans-unit>
        <trans-unit id="24fb9eef456bcd915cd5640203146790d6c28cff" translate="yes" xml:space="preserve">
          <source>How to read an often-changing value from &lt;code&gt;useCallback&lt;/code&gt;?</source>
          <target state="translated">Как прочитать часто меняющееся значение из &lt;code&gt;useCallback&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="ecc2a2a6938156221ff27517255883f6fe53d187" translate="yes" xml:space="preserve">
          <source>How to read an often-changing value from useCallback?</source>
          <target state="translated">Как прочитать часто меняющееся значение от useCallback?</target>
        </trans-unit>
        <trans-unit id="4e42ecde4eca22b2d3b189bcf068d674eeacdb8a" translate="yes" xml:space="preserve">
          <source>How to test components that use Hooks?</source>
          <target state="translated">Как протестировать компоненты,использующие крючки?</target>
        </trans-unit>
        <trans-unit id="9da64590fe0ba979539b260ad3ab00d0ecded657" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;useRef()&lt;/code&gt; is useful for more than the &lt;code&gt;ref&lt;/code&gt; attribute. It&amp;rsquo;s &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;handy for keeping any mutable value around&lt;/a&gt; similar to how you&amp;rsquo;d use instance fields in classes.</source>
          <target state="translated">Однако &lt;code&gt;useRef()&lt;/code&gt; полезен не только для атрибута &lt;code&gt;ref&lt;/code&gt; . Это &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;удобно для хранения любого изменяемого значения примерно так,&lt;/a&gt; как вы бы использовали поля экземпляра в классах.</target>
        </trans-unit>
        <trans-unit id="65f0f95f546c8a3bf04820043025e19f7a76c111" translate="yes" xml:space="preserve">
          <source>However, React also offers an option to use &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt; instead:</source>
          <target state="translated">Однако React также предлагает возможность использовать вместо этого &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3333696f448160f28cb91d4eececaddabcf02145" translate="yes" xml:space="preserve">
          <source>However, React components are declarative and specify &lt;em&gt;what&lt;/em&gt; should be rendered:</source>
          <target state="translated">Однако компоненты React декларативны и указывают, &lt;em&gt;что&lt;/em&gt; должно отображаться:</target>
        </trans-unit>
        <trans-unit id="e9b9ee92c12009c14589ca7400a64667019fa998" translate="yes" xml:space="preserve">
          <source>However, elements can also represent user-defined components:</source>
          <target state="translated">Однако элементы могут также представлять собой определяемые пользователем компоненты:</target>
        </trans-unit>
        <trans-unit id="8914df7a2751ed9a49c0a876b51e78db6ebded98" translate="yes" xml:space="preserve">
          <source>However, in Concurrent Mode there are cases where you might &lt;em&gt;want&lt;/em&gt; to &amp;ldquo;duplicate&amp;rdquo; some data in different state variables. Consider this tiny translation app:</source>
          <target state="translated">Однако в параллельном режиме есть случаи, когда вы можете &lt;em&gt;захотеть&lt;/em&gt; &amp;laquo;продублировать&amp;raquo; некоторые данные в разных переменных состояния. Рассмотрим это крошечное приложение для перевода:</target>
        </trans-unit>
        <trans-unit id="d58ece91c2a93ff8dda87d95414ebd23f4782a9c" translate="yes" xml:space="preserve">
          <source>However, it also preserves &lt;code&gt;ref&lt;/code&gt;s. This means that if you get a child with a &lt;code&gt;ref&lt;/code&gt; on it, you won&amp;rsquo;t accidentally steal it from your ancestor. You will get the same &lt;code&gt;ref&lt;/code&gt; attached to your new element.</source>
          <target state="translated">Однако он также сохраняет &lt;code&gt;ref&lt;/code&gt; . Это означает, что если у вас будет ребенок со &lt;code&gt;ref&lt;/code&gt; , вы не украдете его случайно у своего предка. Вы получите такой же &lt;code&gt;ref&lt;/code&gt; прикрепленный к вашему новому элементу.</target>
        </trans-unit>
        <trans-unit id="7dccca1546e00e09348d2ca880b503bbc3782a4f" translate="yes" xml:space="preserve">
          <source>However, it does raise the question of why these releases aren&amp;rsquo;t versioned as patches instead.</source>
          <target state="translated">Однако возникает вопрос, почему для этих выпусков не используются версии исправлений.</target>
        </trans-unit>
        <trans-unit id="f6a583f2ca74afad8b48de4866dda319994ca798" translate="yes" xml:space="preserve">
          <source>However, it misses a crucial requirement: the fact that the &lt;code&gt;Clock&lt;/code&gt; sets up a timer and updates the UI every second should be an implementation detail of the &lt;code&gt;Clock&lt;/code&gt;.</source>
          <target state="translated">Однако он пропускает важное требование: тот факт, что &lt;code&gt;Clock&lt;/code&gt; устанавливает таймер и обновляет пользовательский интерфейс каждую секунду, должен быть деталью реализации &lt;code&gt;Clock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0b55a581ed0d44371ffb07796a1f139be740fa1" translate="yes" xml:space="preserve">
          <source>However, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called &lt;a href=&quot;#uselayouteffect&quot;&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt;&lt;/a&gt;. It has the same signature as &lt;code&gt;useEffect&lt;/code&gt;, and only differs in when it is fired.</source>
          <target state="translated">Однако не все эффекты можно отложить. Например, мутация DOM, видимая пользователю, должна запускаться синхронно перед следующей отрисовкой, чтобы пользователь не почувствовал визуальную несогласованность. (Это различие концептуально похоже на пассивные и активные прослушиватели событий.) Для этих типов эффектов React предоставляет один дополнительный Hook, называемый &lt;a href=&quot;#uselayouteffect&quot;&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; &lt;/a&gt; . Он имеет ту же сигнатуру, что и &lt;code&gt;useEffect&lt;/code&gt; , и отличается только тем, когда он запускается.</target>
        </trans-unit>
        <trans-unit id="66df5c038ad97c79d198f1c4a9bcf642fe39edab" translate="yes" xml:space="preserve">
          <source>However, sometimes it might be helpful to intentionally introduce an inconsistency. We could do it manually by &amp;ldquo;splitting&amp;rdquo; the state like above, but React also offers a built-in Hook for this:</source>
          <target state="translated">Однако иногда может быть полезно намеренно внести несоответствие. Мы могли бы сделать это вручную, &amp;laquo;разделив&amp;raquo; состояние, как указано выше, но React также предлагает для этого встроенный Hook:</target>
        </trans-unit>
        <trans-unit id="684d4b7ace58812c1c1257030e5191e892f4d124" translate="yes" xml:space="preserve">
          <source>However, sometimes it&amp;rsquo;s useful to insert a child into a different location in the DOM:</source>
          <target state="translated">Однако иногда бывает полезно вставить дочерний элемент в другое место в DOM:</target>
        </trans-unit>
        <trans-unit id="7873b7f443466f38d48c121a13c985ec5c569acf" translate="yes" xml:space="preserve">
          <source>However, sometimes the same data needs to be accessible by many components in the tree, and at different nesting levels. Context lets you &amp;ldquo;broadcast&amp;rdquo; such data, and changes to it, to all components below. Common examples where using context might be simpler than the alternatives include managing the current locale, theme, or a data cache.</source>
          <target state="translated">Однако иногда одни и те же данные должны быть доступны для многих компонентов в дереве и на разных уровнях вложенности. Контекст позволяет вам &amp;laquo;транслировать&amp;raquo; такие данные и изменять их всем компонентам ниже. Распространенные примеры, когда использование контекста может быть проще, чем альтернативные варианты, включают управление текущей локалью, темой или кешем данных.</target>
        </trans-unit>
        <trans-unit id="23514e5e71b6ee6ebabf134e94bf282dd4ddd004" translate="yes" xml:space="preserve">
          <source>However, the experience feels really jarring. We were browsing a page, but it got replaced by a loading state right as we were interacting with it. It&amp;rsquo;s disorienting. &lt;strong&gt;Just like before, to avoid showing an undesirable loading state, we can wrap the state update in a transition:&lt;/strong&gt;</source>
          <target state="translated">Однако опыт действительно неприятен. Мы просматривали страницу, но она была заменена состоянием загрузки прямо тогда, когда мы с ней взаимодействовали. Это сбивает с толку. &lt;strong&gt;Как и раньше, чтобы избежать нежелательного состояния загрузки, мы можем заключить обновление состояния в переход:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b955a466dd5e01eaf645eec3e93c8799d5ab4f5" translate="yes" xml:space="preserve">
          <source>However, this may be overkill in some cases, like the subscription example from the previous section. We don&amp;rsquo;t need to create a new subscription on every update, only if the &lt;code&gt;source&lt;/code&gt; prop has changed.</source>
          <target state="translated">Однако в некоторых случаях это может быть излишним, как в примере подписки из предыдущего раздела. Нам не нужно создавать новую подписку при каждом обновлении, только если &lt;code&gt;source&lt;/code&gt; изменился.</target>
        </trans-unit>
        <trans-unit id="d54fc10053a808be02d653b28bf41ebcbb425fe4" translate="yes" xml:space="preserve">
          <source>However, this requires you to know exactly which methods need to be copied. You can use &lt;a href=&quot;https://github.com/mridgway/hoist-non-react-statics&quot;&gt;hoist-non-react-statics&lt;/a&gt; to automatically copy all non-React static methods:</source>
          <target state="translated">Однако для этого необходимо точно знать, какие методы нужно скопировать. Вы можете использовать &lt;a href=&quot;https://github.com/mridgway/hoist-non-react-statics&quot;&gt;hoist-non-react-statics&lt;/a&gt; для автоматического копирования всех статических методов, отличных от React:</target>
        </trans-unit>
        <trans-unit id="b543d8a8b990abf052de4f376f9d0b9c65f73938" translate="yes" xml:space="preserve">
          <source>However, we want these two inputs to be in sync with each other. When we update the Celsius input, the Fahrenheit input should reflect the converted temperature, and vice versa.</source>
          <target state="translated">Однако мы хотим,чтобы эти два входа синхронизировались друг с другом.Когда мы обновляем вход по Цельсию,вход по Фаренгейту должен отражать преобразованную температуру,и наоборот.</target>
        </trans-unit>
        <trans-unit id="bd3ad954f0338c11e6cda950a40addb37e02fd0f" translate="yes" xml:space="preserve">
          <source>However, you might still be wondering why React doesn&amp;rsquo;t just update &lt;code&gt;this.state&lt;/code&gt; immediately without re-rendering.</source>
          <target state="translated">Однако вам все еще может быть интересно, почему React не обновляет &lt;code&gt;this.state&lt;/code&gt; сразу без повторного рендеринга.</target>
        </trans-unit>
        <trans-unit id="1e059ed18e3f4b02238b502a8f5e588e0008af29" translate="yes" xml:space="preserve">
          <source>Ideally we want to write this once and have the &lt;code&gt;Clock&lt;/code&gt; update itself:</source>
          <target state="translated">В идеале мы хотим написать это один раз и обновить &lt;code&gt;Clock&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6a176af0e3541b91734625dec4f3b8292439dd1d" translate="yes" xml:space="preserve">
          <source>Ideas</source>
          <target state="translated">Ideas</target>
        </trans-unit>
        <trans-unit id="dbd660e2dd45612fbe7fcb2d52008460403f801b" translate="yes" xml:space="preserve">
          <source>Identify every component that renders something based on that state.</source>
          <target state="translated">Определите каждый компонент,который делает что-то,основанное на этом состоянии.</target>
        </trans-unit>
        <trans-unit id="96c7ee658b9e92f85c8bfec7b6c2a38fb96663d7" translate="yes" xml:space="preserve">
          <source>Identifying components with unsafe lifecycles</source>
          <target state="translated">Идентификация компонентов с небезопасными жизненными циклами</target>
        </trans-unit>
        <trans-unit id="634e92551f670791962e82615e588bc9e77eae60" translate="yes" xml:space="preserve">
          <source>Identifying unsafe lifecycles</source>
          <target state="translated">Выявление небезопасных жизненных циклов</target>
        </trans-unit>
        <trans-unit id="c95633762d757325e688096b23309ad6ed512c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;children&lt;/code&gt; is a &lt;code&gt;Fragment&lt;/code&gt; it will be treated as a single child and not traversed.</source>
          <target state="translated">Если &lt;code&gt;children&lt;/code&gt; это &lt;code&gt;Fragment&lt;/code&gt; будет рассматриваться как единый ребенок и не проходятся.</target>
        </trans-unit>
        <trans-unit id="d9ec8b74463d4b6788285debd449e8a36886f529" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextTypes&lt;/code&gt; is defined within a component, the following &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; will receive an additional parameter, the &lt;code&gt;context&lt;/code&gt; object:</source>
          <target state="translated">Если &lt;code&gt;contextTypes&lt;/code&gt; определен в компоненте, следующие &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;методы жизненного цикла&lt;/a&gt; получат дополнительный параметр, объект &lt;code&gt;context&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a7942ea96f993393244bb793ed3444403e13d0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextTypes&lt;/code&gt; is not defined, then &lt;code&gt;context&lt;/code&gt; will be an empty object.</source>
          <target state="translated">Если &lt;code&gt;contextTypes&lt;/code&gt; не определен, тогда &lt;code&gt;context&lt;/code&gt; будет пустым объектом.</target>
        </trans-unit>
        <trans-unit id="cb8bc3d5f6a162a81742105b7e5aa8a5814ce785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is not provided, it will be set by default to &lt;code&gt;'blue'&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;props.color&lt;/code&gt; не указан , по умолчанию будет установлено значение &lt;code&gt;'blue'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="459dd598a5e1720f34594d812d939384bffda8ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is set to &lt;code&gt;null&lt;/code&gt;, it will remain &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba93d4ea31d24880e40a17c457b5255600429f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is set to null, it will remain null:</source>
          <target state="translated">Если для &lt;code&gt;props.color&lt;/code&gt; установлено значение null, оно останется нулевым:</target>
        </trans-unit>
        <trans-unit id="a6b6d366d7013c823d86f9937f864aa2f4eb5035" translate="yes" xml:space="preserve">
          <source>If a Minor Release Includes No New Features, Why Isn&amp;rsquo;t It a Patch?</source>
          <target state="translated">Если второстепенный выпуск не содержит новых функций, почему это не патч?</target>
        </trans-unit>
        <trans-unit id="7808973984d8e4c597980af26324716a790b3eb9" translate="yes" xml:space="preserve">
          <source>If a component is using multiple mixins and several mixins define the same lifecycle method (i.e. several mixins want to do some cleanup when the component is destroyed), all of the lifecycle methods are guaranteed to be called. Methods defined on mixins run in the order mixins were listed, followed by a method call on the component.</source>
          <target state="translated">Если компонент использует несколько смесей и несколько смесей определяют один и тот же метод жизненного цикла (т.е.несколько смесей хотят провести некоторую очистку при уничтожении компонента),гарантируется,что будут вызваны все методы жизненного цикла.Методы,определенные на смесях,выполняемых в порядке их следования,перечисляются с последующим вызовом метода на компонент.</target>
        </trans-unit>
        <trans-unit id="97235b567c0265f0d9926f25dc8829579aa2e646" translate="yes" xml:space="preserve">
          <source>If a feature is not documented, they may be accompanied by an &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">Если функция не задокументирована, она может сопровождаться &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;RFC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6bc1e73352759548987f8a409ddc10869579747" translate="yes" xml:space="preserve">
          <source>If a release includes non-essential changes &amp;mdash; such as internal refactors, changes to implementation details, performance improvements, or minor bugfixes &amp;mdash; we will bump the minor version even when there are no new features.</source>
          <target state="translated">Если выпуск включает несущественные изменения, такие как внутренние рефакторы, изменения в деталях реализации, улучшения производительности или исправления мелких ошибок, мы удалим второстепенную версию, даже если в ней нет новых функций.</target>
        </trans-unit>
        <trans-unit id="b8ff55774a140aca8bdaed69bfb51da5366dacc0" translate="yes" xml:space="preserve">
          <source>If a single element&amp;rsquo;s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the warning by adding &lt;code&gt;suppressHydrationWarning={true}&lt;/code&gt; to the element. It only works one level deep, and is intended to be an escape hatch. Don&amp;rsquo;t overuse it. Unless it&amp;rsquo;s text content, React still won&amp;rsquo;t attempt to patch it up, so it may remain inconsistent until future updates.</source>
          <target state="translated">Если атрибут одного элемента или текстовое содержимое неизбежно различаются между сервером и клиентом (например, временная метка), вы можете отключить предупреждение, добавив к элементу &lt;code&gt;suppressHydrationWarning={true}&lt;/code&gt; . Он работает только на один уровень и предназначен для использования в качестве аварийного люка. Не злоупотребляйте этим. Если это не текстовое содержимое, React по-прежнему не будет пытаться исправить его, поэтому он может оставаться несогласованным до будущих обновлений.</target>
        </trans-unit>
        <trans-unit id="d556b20cb4547e127f2815074ef2fe4e41710802" translate="yes" xml:space="preserve">
          <source>If a tag is empty, you may close it immediately with &lt;code&gt;/&amp;gt;&lt;/code&gt;, like XML:</source>
          <target state="translated">Если тег пуст, вы можете сразу закрыть его с помощью &lt;code&gt;/&amp;gt;&lt;/code&gt; , например XML:</target>
        </trans-unit>
        <trans-unit id="3b320bf64ff848996f74d77101a47dfdd619e264" translate="yes" xml:space="preserve">
          <source>If after that we still don&amp;rsquo;t use any values from the component scope, it&amp;rsquo;s safe to specify &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">Если после этого мы по-прежнему не используем никаких значений из области компонента, можно безопасно указать &lt;code&gt;[]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5b6b3e11e3d3c38135418032d8908ab5281f6aca" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;bind&lt;/code&gt; annoys you, there are two ways you can get around this. If you are using the experimental &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;public class fields syntax&lt;/a&gt;, you can use class fields to correctly bind callbacks:</source>
          <target state="translated">Если вызов &lt;code&gt;bind&lt;/code&gt; вас раздражает, есть два способа обойти это. Если вы используете экспериментальный &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;синтаксис полей открытого класса&lt;/a&gt; , вы можете использовать поля класса для правильной привязки обратных вызовов:</target>
        </trans-unit>
        <trans-unit id="58ab379086a708259f83594879dae195d221ed0e" translate="yes" xml:space="preserve">
          <source>If everything passes, great! You can expect that your project will work with the next minor React release.</source>
          <target state="translated">Если все пройдет,отлично! Можно ожидать,что ваш проект будет работать со следующим минорным релизом React.</target>
        </trans-unit>
        <trans-unit id="c6bec09d61efa659eb228a4953584f79786650d2" translate="yes" xml:space="preserve">
          <source>If fetching user details takes three seconds, we&amp;rsquo;ll only &lt;em&gt;start&lt;/em&gt; fetching the posts after three seconds! That&amp;rsquo;s a &amp;ldquo;waterfall&amp;rdquo;: an unintentional &lt;em&gt;sequence&lt;/em&gt; that should have been parallelized.</source>
          <target state="translated">Если получение сведений о пользователе занимает три секунды, мы &lt;em&gt;начнем&lt;/em&gt; получать сообщения только через три секунды! Это &amp;laquo;водопад&amp;raquo;: непреднамеренная &lt;em&gt;последовательность,&lt;/em&gt; которую следовало распараллелить.</target>
        </trans-unit>
        <trans-unit id="61455d144dae27e035208c57b22d9252594b892f" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s still not clear which type of component you should use for a particular situation, you might find &lt;a href=&quot;https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/&quot;&gt;this article on controlled versus uncontrolled inputs&lt;/a&gt; to be helpful.</source>
          <target state="translated">Если все еще не ясно, какой тип компонента следует использовать в конкретной ситуации, &lt;a href=&quot;https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/&quot;&gt;эта статья о контролируемых и неконтролируемых вводах&lt;/a&gt; может оказаться полезной.</target>
        </trans-unit>
        <trans-unit id="64a099559eb261307dc775d158033df86e50e770" translate="yes" xml:space="preserve">
          <source>If no array is provided, a new value will be computed on every render.</source>
          <target state="translated">Если массив не предоставляется,то при каждом рендере будет вычисляться новое значение.</target>
        </trans-unit>
        <trans-unit id="44bfdbf92e17d273381e7b8fb1a3f01879ecf26c" translate="yes" xml:space="preserve">
          <source>If some common scenario is not covered, please let us know on the &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues&quot;&gt;issue tracker&lt;/a&gt; for the documentation website.</source>
          <target state="translated">Если какой-то распространенный сценарий не описан, сообщите нам об этом в системе &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues&quot;&gt;отслеживания&lt;/a&gt; проблем на веб-сайте документации.</target>
        </trans-unit>
        <trans-unit id="0387b7a09358144d9726581e47b1de8c8b84739d" translate="yes" xml:space="preserve">
          <source>If some component &amp;ldquo;suspends&amp;rdquo;, does the app freeze? How to avoid this?</source>
          <target state="translated">Если какой-то компонент &quot;зависает&quot;, зависает ли приложение? Как этого избежать?</target>
        </trans-unit>
        <trans-unit id="fb69be684ead34368506e903349ff51d28c48c95" translate="yes" xml:space="preserve">
          <source>If some value isn&amp;rsquo;t used for rendering or data flow (for example, a timer ID), you don&amp;rsquo;t have to put it in the state. Such values can be defined as fields on the component instance.</source>
          <target state="translated">Если какое-то значение не используется для рендеринга или потока данных (например, идентификатор таймера), вам не нужно помещать его в состояние. Такие значения могут быть определены как поля в экземпляре компонента.</target>
        </trans-unit>
        <trans-unit id="bb0fa5a864d283d560c5564be4c37fdc16ee5c7f" translate="yes" xml:space="preserve">
          <source>If something breaks unexpectedly, please let us know by &lt;a href=&quot;https://github.com/facebook/react/issues&quot;&gt;filing an issue&lt;/a&gt;.</source>
          <target state="translated">Если что-то неожиданно сломается, сообщите нам об этом, &lt;a href=&quot;https://github.com/facebook/react/issues&quot;&gt;заполнив вопрос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e81b0e7afa3fb271a0976602cc04371ca693d752" translate="yes" xml:space="preserve">
          <source>If something can be derived from either props or state, it probably shouldn&amp;rsquo;t be in the state. For example, instead of storing both &lt;code&gt;celsiusValue&lt;/code&gt; and &lt;code&gt;fahrenheitValue&lt;/code&gt;, we store just the last edited &lt;code&gt;temperature&lt;/code&gt; and its &lt;code&gt;scale&lt;/code&gt;. The value of the other input can always be calculated from them in the &lt;code&gt;render()&lt;/code&gt; method. This lets us clear or apply rounding to the other field without losing any precision in the user input.</source>
          <target state="translated">Если что-то может быть получено из props или состояния, вероятно, этого не должно быть в состоянии. Например, вместо хранения &lt;code&gt;celsiusValue&lt;/code&gt; и &lt;code&gt;fahrenheitValue&lt;/code&gt; , мы сохраняем только последнюю измененную &lt;code&gt;temperature&lt;/code&gt; и ее &lt;code&gt;scale&lt;/code&gt; . Значение другого ввода всегда можно вычислить из них в методе &lt;code&gt;render()&lt;/code&gt; . Это позволяет нам очистить или применить округление к другому полю без потери точности ввода пользователя.</target>
        </trans-unit>
        <trans-unit id="1e1eff28de072c228c3fac6f7de4af84285d52c7" translate="yes" xml:space="preserve">
          <source>If something is missing in the documentation or if you found some part confusing, please &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;file an issue for the documentation repository&lt;/a&gt; with your suggestions for improvement, or tweet at the &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs account&lt;/a&gt;. We love hearing from you!</source>
          <target state="translated">Если чего-то не хватает в документации или вы обнаружили, что какая-то часть сбивает вас с толку, сообщите &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;о проблеме в репозиторий документации&lt;/a&gt; с вашими предложениями по улучшению или &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;напишите&lt;/a&gt; в Твиттере в учетной записи @reactjs . Мы рады слышать тебя.</target>
        </trans-unit>
        <trans-unit id="9ba9933df2ec0f3c00ec311cb0e316ed0a71e056" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Calculator&lt;/code&gt; owns the shared state, it becomes the &amp;ldquo;source of truth&amp;rdquo; for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both &lt;code&gt;TemperatureInput&lt;/code&gt; components are coming from the same parent &lt;code&gt;Calculator&lt;/code&gt; component, the two inputs will always be in sync.</source>
          <target state="translated">Если &lt;code&gt;Calculator&lt;/code&gt; владеет общим состоянием, он становится &amp;laquo;источником истины&amp;raquo; для текущей температуры на обоих входах. Он может дать указание им обоим иметь ценности, согласующиеся друг с другом. Поскольку свойства обоих компонентов &lt;code&gt;TemperatureInput&lt;/code&gt; поступают из одного и того же родительского компонента &lt;code&gt;Calculator&lt;/code&gt; , два входа всегда будут синхронизированы.</target>
        </trans-unit>
        <trans-unit id="e1508d0b9f38075d8659f83a363a29e0a2c1eb40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Clock&lt;/code&gt; component is ever removed from the DOM, React calls the &lt;code&gt;componentWillUnmount()&lt;/code&gt; lifecycle method so the timer is stopped.</source>
          <target state="translated">Если компонент &lt;code&gt;Clock&lt;/code&gt; когда-либо удаляется из DOM, React вызывает метод жизненного цикла &lt;code&gt;componentWillUnmount()&lt;/code&gt; чтобы таймер остановился.</target>
        </trans-unit>
        <trans-unit id="285cc10d670d67e7a1d042087524d72b3c61948c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ref&lt;/code&gt; callback is defined as an inline function, it will get called twice during updates, first with &lt;code&gt;null&lt;/code&gt; and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. You can avoid this by defining the &lt;code&gt;ref&lt;/code&gt; callback as a bound method on the class, but note that it shouldn&amp;rsquo;t matter in most cases.</source>
          <target state="translated">Если обратный вызов &lt;code&gt;ref&lt;/code&gt; определен как встроенная функция, он будет вызываться дважды во время обновлений, сначала с &lt;code&gt;null&lt;/code&gt; а затем снова с элементом DOM. Это связано с тем, что новый экземпляр функции создается с каждым рендером, поэтому React необходимо очистить старую ссылку и настроить новую. Вы можете избежать этого, определив обратный вызов &lt;code&gt;ref&lt;/code&gt; как связанный метод в классе, но обратите внимание, что в большинстве случаев это не имеет значения.</target>
        </trans-unit>
        <trans-unit id="a11443443fa44ef2cec37924f0c1f90e49c7f394" translate="yes" xml:space="preserve">
          <source>If the React element was previously rendered into &lt;code&gt;container&lt;/code&gt;, this will perform an update on it and only mutate the DOM as necessary to reflect the latest React element.</source>
          <target state="translated">Если элемент React ранее был отображен в &lt;code&gt;container&lt;/code&gt; , это выполнит для него обновление и только при необходимости изменит DOM, чтобы отразить последний элемент React.</target>
        </trans-unit>
        <trans-unit id="f68368472358ffa4040481d1ccc81327648d3fb5" translate="yes" xml:space="preserve">
          <source>If the boilerplate code is too unattractive to you, you may enable the &lt;strong&gt;experimental&lt;/strong&gt;&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;Class Properties&lt;/a&gt; syntax proposal with Babel:</source>
          <target state="translated">Если шаблонный код кажется вам слишком непривлекательным, вы можете включить &lt;strong&gt;экспериментальное&lt;/strong&gt; предложение синтаксиса &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;свойств класса&lt;/a&gt; с помощью Babel:</target>
        </trans-unit>
        <trans-unit id="b1524d0a0bb3f485163f09431911716ee3095bb5" translate="yes" xml:space="preserve">
          <source>If the function you&amp;rsquo;re calling is a pure computation and is safe to call while rendering, you may &lt;strong&gt;call it outside of the effect instead,&lt;/strong&gt; and make the effect depend on the returned value.</source>
          <target state="translated">Если функция, которую вы вызываете, представляет собой чистое вычисление и ее можно безопасно вызывать во время рендеринга, вы можете &lt;strong&gt;вместо этого вызвать ее вне эффекта&lt;/strong&gt; и сделать эффект зависимым от возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="72c76fa2e50dee5e670f91c11fbf1264bff2a124" translate="yes" xml:space="preserve">
          <source>If the new state is computed using the previous state, you can pass a function to &lt;code&gt;setState&lt;/code&gt;. The function will receive the previous value, and return an updated value. Here&amp;rsquo;s an example of a counter component that uses both forms of &lt;code&gt;setState&lt;/code&gt;:</source>
          <target state="translated">Если новое состояние вычисляется с использованием предыдущего состояния, вы можете передать функцию в &lt;code&gt;setState&lt;/code&gt; . Функция получит предыдущее значение и вернет обновленное значение. Вот пример компонента счетчика, который использует обе формы &lt;code&gt;setState&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4d5fb4c02d4fde303749802adf11f045d7e01c08" translate="yes" xml:space="preserve">
          <source>If the only way your component ever changes is when the &lt;code&gt;props.color&lt;/code&gt; or the &lt;code&gt;state.count&lt;/code&gt; variable changes, you could have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; check that:</source>
          <target state="translated">Если единственный способ изменения вашего компонента - это изменение переменной &lt;code&gt;props.color&lt;/code&gt; или &lt;code&gt;state.count&lt;/code&gt; , вы можете использовать &lt;code&gt;shouldComponentUpdate&lt;/code&gt; для проверки того, что:</target>
        </trans-unit>
        <trans-unit id="8d4d632eeb98bbd6eb7a8cf7c7cf0db0d585a084" translate="yes" xml:space="preserve">
          <source>If the optional callback is provided, it will be executed after the component is rendered or updated.</source>
          <target state="translated">Если предусмотрен необязательный обратный вызов,то он будет выполнен после отрисовки или обновления компонента.</target>
        </trans-unit>
        <trans-unit id="9825426bb3519158f32e335335bf1288ffbb02ac" translate="yes" xml:space="preserve">
          <source>If the other module fails to load (for example, due to network failure), it will trigger an error. You can handle these errors to show a nice user experience and manage recovery with &lt;a href=&quot;error-boundaries&quot;&gt;Error Boundaries&lt;/a&gt;. Once you&amp;rsquo;ve created your Error Boundary, you can use it anywhere above your lazy components to display an error state when there&amp;rsquo;s a network error.</source>
          <target state="translated">Если другой модуль не загружается (например, из-за сбоя сети), это вызовет ошибку. Вы можете обрабатывать эти ошибки, чтобы показать удобство работы с пользователем и управлять восстановлением с помощью &lt;a href=&quot;error-boundaries&quot;&gt;границ ошибок&lt;/a&gt; . Создав границу ошибок, вы можете использовать ее в любом месте над ленивыми компонентами, чтобы отображать состояние ошибки при возникновении сетевой ошибки.</target>
        </trans-unit>
        <trans-unit id="6d645637af0f89ddb43e30926c108ad1d42dea97" translate="yes" xml:space="preserve">
          <source>If this component has been mounted into the DOM, this returns the corresponding native browser DOM element. This method is useful for reading values out of the DOM, such as form field values and performing DOM measurements. &lt;strong&gt;In most cases, you can attach a ref to the DOM node and avoid using &lt;code&gt;findDOMNode&lt;/code&gt; at all.&lt;/strong&gt;</source>
          <target state="translated">Если этот компонент был смонтирован в DOM, он возвращает соответствующий элемент DOM собственного браузера. Этот метод полезен для считывания значений из DOM, таких как значения полей формы и выполнения измерений DOM. &lt;strong&gt;В большинстве случаев вы можете прикрепить &lt;code&gt;findDOMNode&lt;/code&gt; к узлу DOM и вообще не использовать findDOMNode .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2beaac6d52020b7f238083eeeeccbf47e42f3e4b" translate="yes" xml:space="preserve">
          <source>If two or more context values are often used together, you might want to consider creating your own render prop component that provides both.</source>
          <target state="translated">Если два или более контекстных значения часто используются вместе,вы можете подумать о создании своего собственного компонента рендеринга,который предоставляет и то,и другое.</target>
        </trans-unit>
        <trans-unit id="d1f978898c43c050ba9392e9f7a52dfcd4549f6d" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want some component to delay the transition, we can wrap it in its own &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary.</source>
          <target state="translated">Если мы не хотим, чтобы какой-то компонент задерживал переход, мы можем заключить его в его собственную границу &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19013949653b81e2adb86a0553d1ff708b6beb68" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to load this component in our tests, we can mock out the dependency itself to a dummy component, and run our tests:</source>
          <target state="translated">Если мы не хотим загружать этот компонент в наши тесты, мы можем смоделировать саму зависимость от фиктивного компонента и запустить наши тесты:</target>
        </trans-unit>
        <trans-unit id="cc989df7c0d84bfb51075d6a4b04861fa37c52c1" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to stay in the Pending state for too long, our first instinct might be to set &lt;code&gt;timeoutMs&lt;/code&gt; in &lt;code&gt;useTransition&lt;/code&gt; to something smaller, like &lt;code&gt;3000&lt;/code&gt;. You can try this &lt;a href=&quot;https://codesandbox.io/s/practical-kowalevski-kpjg4&quot;&gt;here&lt;/a&gt;. This lets us escape the prolonged Pending state, but we still don&amp;rsquo;t have anything useful to show!</source>
          <target state="translated">Если мы не хотим оставаться в состоянии Pending слишком долго, нашим первым инстинктом может быть установка &lt;code&gt;timeoutMs&lt;/code&gt; in &lt;code&gt;useTransition&lt;/code&gt; на что-то меньшее, например &lt;code&gt;3000&lt;/code&gt; . Вы можете попробовать это &lt;a href=&quot;https://codesandbox.io/s/practical-kowalevski-kpjg4&quot;&gt;здесь&lt;/a&gt; . Это позволяет нам выйти из длительного состояния ожидания, но нам по-прежнему нечего показывать!</target>
        </trans-unit>
        <trans-unit id="b28361e99b6744be8efafa4d49b562aaade2f3b5" translate="yes" xml:space="preserve">
          <source>If we intentionally &lt;em&gt;want&lt;/em&gt; to show an inconsistent UI for a small period of time, can we do that?</source>
          <target state="translated">Если мы намеренно &lt;em&gt;хотим&lt;/em&gt; показать несогласованный пользовательский интерфейс в течение небольшого периода времени, можем ли мы это сделать?</target>
        </trans-unit>
        <trans-unit id="dc070f0d7e8042a80001420c3eae7347b4592739" translate="yes" xml:space="preserve">
          <source>If we just wanted to set an interval, we wouldn&amp;rsquo;t need the ref (&lt;code&gt;id&lt;/code&gt; could be local to the effect), but it&amp;rsquo;s useful if we want to clear the interval from an event handler:</source>
          <target state="translated">Если бы мы просто хотели установить интервал, нам не понадобилась бы ссылка ( &lt;code&gt;id&lt;/code&gt; может быть локальным по отношению к эффекту), но это полезно, если мы хотим очистить интервал от обработчика событий:</target>
        </trans-unit>
        <trans-unit id="10129e51e2f781d3b2a1978fc9c0500021cdb2cc" translate="yes" xml:space="preserve">
          <source>If we later edit the Fahrenheit field to be 212, the state of the &lt;code&gt;Calculator&lt;/code&gt; will be:</source>
          <target state="translated">Если позже мы изменим поле Фаренгейта на 212, состояние &lt;code&gt;Calculator&lt;/code&gt; будет следующим:</target>
        </trans-unit>
        <trans-unit id="5ef4de5727a1ae42b86ddd7ac75d5b2cb2686cbb" translate="yes" xml:space="preserve">
          <source>If we make our API responses take 5 seconds, &lt;a href=&quot;https://codesandbox.io/s/relaxed-greider-suewh&quot;&gt;we can confirm&lt;/a&gt; that now React &amp;ldquo;gives up&amp;rdquo; and transitions anyway to the next screen after 3 seconds. This is because we passed &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; to &lt;code&gt;useTransition()&lt;/code&gt;. For example, if we passed &lt;code&gt;{timeoutMs: 60000}&lt;/code&gt; instead, it would wait a whole minute.</source>
          <target state="translated">Если мы заставим наши ответы API занять 5 секунд, &lt;a href=&quot;https://codesandbox.io/s/relaxed-greider-suewh&quot;&gt;мы можем подтвердить,&lt;/a&gt; что теперь React &amp;laquo;сдается&amp;raquo; и все равно переходит к следующему экрану через 3 секунды. Это потому, что мы передали &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; в &lt;code&gt;useTransition()&lt;/code&gt; . Например, если мы &lt;code&gt;{timeoutMs: 60000}&lt;/code&gt; вместо этого {timeoutMs: 60000} , он будет ждать целую минуту.</target>
        </trans-unit>
        <trans-unit id="0d759d3e1bb1bdd18c1893117d44336d9737a917" translate="yes" xml:space="preserve">
          <source>If we try this code, it might seem like it works at first. However, if we randomize the delay time in our &amp;ldquo;fake API&amp;rdquo; implementation and press the &amp;ldquo;Next&amp;rdquo; button fast enough, we&amp;rsquo;ll see from the console logs that something is going very wrong. &lt;strong&gt;Requests from the previous profiles may sometimes &amp;ldquo;come back&amp;rdquo; after we&amp;rsquo;ve already switched the profile to another ID &amp;mdash; and in that case they can overwrite the new state with a stale response for a different ID.&lt;/strong&gt;</source>
          <target state="translated">Если мы попробуем этот код, сначала может показаться, что он работает. Однако, если мы рандомизируем время задержки в нашей реализации &amp;laquo;поддельного API&amp;raquo; и нажмем кнопку &amp;laquo;Далее&amp;raquo; достаточно быстро, мы увидим из журналов консоли, что что-то идет не так. &lt;strong&gt;Запросы из предыдущих профилей могут иногда &amp;laquo;возвращаться&amp;raquo; после того, как мы уже переключили профиль на другой ID - и в этом случае они могут перезаписать новое состояние устаревшим ответом для другого ID.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be3a9278266bf705f6dd179c22a52cc57d1c6f99" translate="yes" xml:space="preserve">
          <source>If we used this in React, displaying 1000 elements would require in the order of one billion comparisons. This is far too expensive. Instead, React implements a heuristic O(n) algorithm based on two assumptions:</source>
          <target state="translated">Если бы мы использовали это в React,то отображение 1000 элементов потребовало бы порядка миллиарда сравнений.Это слишком дорого.Вместо этого в React реализован эвристический алгоритм O(n),основанный на двух предположениях:</target>
        </trans-unit>
        <trans-unit id="0bd6f78d0df5d6a5d29d430057c8831c6b2afedc" translate="yes" xml:space="preserve">
          <source>If we wanted to wrap the &lt;code&gt;CustomTextInput&lt;/code&gt; above to simulate it being clicked immediately after mounting, we could use a ref to get access to the custom input and call its &lt;code&gt;focusTextInput&lt;/code&gt; method manually:</source>
          <target state="translated">Если бы мы хотели обернуть &lt;code&gt;CustomTextInput&lt;/code&gt; выше, чтобы имитировать щелчок по нему сразу после монтирования, мы могли бы использовать ссылку, чтобы получить доступ к пользовательскому вводу и вызвать его метод &lt;code&gt;focusTextInput&lt;/code&gt; вручную:</target>
        </trans-unit>
        <trans-unit id="406ca61e719e6f4e1e3008d4b342561469a8b770" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re willing to sacrifice consistency, we could &lt;strong&gt;pass potentially stale data to the components that delay our transition&lt;/strong&gt;. That&amp;rsquo;s what &lt;code&gt;useDeferredValue()&lt;/code&gt; lets us do:</source>
          <target state="translated">Если мы готовы пожертвовать согласованностью, мы можем &lt;strong&gt;передать потенциально устаревшие данные компонентам, которые задерживают наш переход&lt;/strong&gt; . Вот что позволяет нам использовать &lt;code&gt;useDeferredValue()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6c9413bd0fc5834a029e8af7dddbd9382c56068a" translate="yes" xml:space="preserve">
          <source>If you already have &lt;code&gt;props&lt;/code&gt; as an object, and you want to pass it in JSX, you can use &lt;code&gt;...&lt;/code&gt; as a &amp;ldquo;spread&amp;rdquo; operator to pass the whole props object. These two components are equivalent:</source>
          <target state="translated">Если у вас уже есть &lt;code&gt;props&lt;/code&gt; в качестве объекта и вы хотите передать его в JSX, вы можете использовать &lt;code&gt;...&lt;/code&gt; как оператор &amp;laquo;распространения&amp;raquo; для передачи всего объекта props. Эти два компонента эквивалентны:</target>
        </trans-unit>
        <trans-unit id="8735706de7bdc6d287d2a819b6a76fae1e775b79" translate="yes" xml:space="preserve">
          <source>If you already minify the application scripts, &lt;strong&gt;your site will be production-ready&lt;/strong&gt; if you ensure that the deployed HTML loads the versions of React ending in &lt;code&gt;production.min.js&lt;/code&gt;:</source>
          <target state="translated">Если вы уже минимизировали скрипты приложения, &lt;strong&gt;ваш сайт будет готов к работе,&lt;/strong&gt; если вы убедитесь, что развернутый HTML загружает версии React, заканчивающиеся на &lt;code&gt;production.min.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1cd058484ca6af46bd0f0bdc60864ddb7e7bdf9f" translate="yes" xml:space="preserve">
          <source>If you are confident you want to write it by hand, you may compare &lt;code&gt;this.props&lt;/code&gt; with &lt;code&gt;nextProps&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; with &lt;code&gt;nextState&lt;/code&gt; and return &lt;code&gt;false&lt;/code&gt; to tell React the update can be skipped. Note that returning &lt;code&gt;false&lt;/code&gt; does not prevent child components from re-rendering when &lt;em&gt;their&lt;/em&gt; state changes.</source>
          <target state="translated">Если вы уверены, что хотите написать его вручную, вы можете сравнить &lt;code&gt;this.props&lt;/code&gt; с &lt;code&gt;nextProps&lt;/code&gt; и &lt;code&gt;this.state&lt;/code&gt; с &lt;code&gt;nextState&lt;/code&gt; и вернуть &lt;code&gt;false&lt;/code&gt; , чтобы сообщить React, что обновление можно пропустить. Обратите внимание, что возврат &lt;code&gt;false&lt;/code&gt; не препятствует повторному рендерингу дочерних компонентов при изменении &lt;em&gt;их&lt;/em&gt; состояния.</target>
        </trans-unit>
        <trans-unit id="15c76b0412bce989363700bf2ef3011d9639d358" translate="yes" xml:space="preserve">
          <source>If you are using a Babel transform like &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;transform-class-properties&lt;/a&gt; , you can also declare &lt;code&gt;defaultProps&lt;/code&gt; as static property within a React component class. This syntax has not yet been finalized though and will require a compilation step to work within a browser. For more information, see the &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;class fields proposal&lt;/a&gt;.</source>
          <target state="translated">Если вы используете преобразование Babel, например, &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;transform-class-properties&lt;/a&gt; , вы также можете объявить &lt;code&gt;defaultProps&lt;/code&gt; как статическое свойство в классе компонента React. Этот синтаксис еще не доработан, и для работы в браузере потребуется этап компиляции. Для получения дополнительной информации см. &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;Предложение полей класса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75b66416e2290abd98cf21dbd99025df7c4ba6a0" translate="yes" xml:space="preserve">
          <source>If you are using the experimental &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;public class fields syntax&lt;/a&gt;, you can use a &lt;strong&gt;static&lt;/strong&gt; class field to initialize your &lt;code&gt;contextType&lt;/code&gt;.</source>
          <target state="translated">Если вы используете экспериментальный &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;синтаксис полей открытого класса&lt;/a&gt; , вы можете использовать поле &lt;strong&gt;статического&lt;/strong&gt; класса для инициализации вашего &lt;code&gt;contextType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bcd73af03cb4d3e4e3b7c1bd1f74a1bd7b665d0" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t sure whether your build process is set up correctly, you can check it by installing &lt;a href=&quot;https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi&quot;&gt;React Developer Tools for Chrome&lt;/a&gt;. If you visit a site with React in production mode, the icon will have a dark background:</source>
          <target state="translated">Если вы не уверены, правильно ли настроен ваш процесс сборки, вы можете проверить его, установив &lt;a href=&quot;https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi&quot;&gt;React Developer Tools для Chrome&lt;/a&gt; . Если вы посетите сайт с React в рабочем режиме, значок будет иметь темный фон:</target>
        </trans-unit>
        <trans-unit id="eb0c664da034e861544cfcdf5f02c8fd40d847b9" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t using class fields syntax, you can use an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt; in the callback:</source>
          <target state="translated">Если вы не используете синтаксис полей класса, вы можете использовать &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;стрелочную функцию&lt;/a&gt; в обратном вызове:</target>
        </trans-unit>
        <trans-unit id="38bf06802507eba86661f75bc21760f1686e68d8" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t, you&amp;rsquo;ll need to setup bundling yourself. For example, see the &lt;a href=&quot;https://webpack.js.org/guides/installation/&quot;&gt;Installation&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/guides/getting-started/&quot;&gt;Getting Started&lt;/a&gt; guides on the Webpack docs.</source>
          <target state="translated">Если это не так, вам нужно будет установить пакет самостоятельно. Например, см. Руководства по &lt;a href=&quot;https://webpack.js.org/guides/installation/&quot;&gt;установке&lt;/a&gt; и &lt;a href=&quot;https://webpack.js.org/guides/getting-started/&quot;&gt;началу работы&lt;/a&gt; в документации Webpack.</target>
        </trans-unit>
        <trans-unit id="7e3292dd08de71388ad7c0b1a0bf8e95045ff37d" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.</source>
          <target state="translated">Если вы &lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt; на узле, на котором уже есть эта разметка, отрисованная сервером, React сохранит ее и подключит только обработчики событий, что позволит вам получить очень эффективную работу при первой загрузке.</target>
        </trans-unit>
        <trans-unit id="c12886015a122be4810ebe17201bb8cce342272e" translate="yes" xml:space="preserve">
          <source>If you call it on a &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; DOM node, it reads the attributes off of the original DOM node, hides it with an inline style, and then appends a separate DOM node with its own visual representation right after the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;. Then it fires jQuery events to notify us about the changes.</source>
          <target state="translated">Если вы вызываете его на узле DOM &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; , он считывает атрибуты исходного узла DOM, скрывает его встроенным стилем, а затем добавляет отдельный узел DOM со своим собственным визуальным представлением сразу после &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; . Затем он запускает события jQuery, чтобы уведомить нас об изменениях.</target>
        </trans-unit>
        <trans-unit id="a4f9877110efff3327fdffedf68d4026372380df" translate="yes" xml:space="preserve">
          <source>If you can&amp;rsquo;t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common owner component.</source>
          <target state="translated">Если вы не можете найти компонент, для которого имеет смысл владеть состоянием, создайте новый компонент исключительно для хранения состояния и добавьте его где-нибудь в иерархии над компонентом общего владельца.</target>
        </trans-unit>
        <trans-unit id="e80d72886f63f44e90c32f25b0726ec9919167cc" translate="yes" xml:space="preserve">
          <source>If you do have performance issues, by all means, optimize!</source>
          <target state="translated">Если у вас действительно есть проблемы с производительностью,обязательно оптимизируйте!</target>
        </trans-unit>
        <trans-unit id="842af6389784f4195a6f44b18d1ae6472e5779f0" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t experience the problems described above or don&amp;rsquo;t feel comfortable using JavaScript tools yet, consider &lt;a href=&quot;add-react-to-a-website&quot;&gt;adding React as a plain &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag on an HTML page&lt;/a&gt;, optionally &lt;a href=&quot;add-react-to-a-website#optional-try-react-with-jsx&quot;&gt;with JSX&lt;/a&gt;.</source>
          <target state="translated">Если вы не испытываете описанных выше проблем или пока не чувствуете себя комфортно при использовании инструментов JavaScript, рассмотрите возможность &lt;a href=&quot;add-react-to-a-website&quot;&gt;добавления React в виде простого &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; на HTML-страницу&lt;/a&gt; , при желании &lt;a href=&quot;add-react-to-a-website#optional-try-react-with-jsx&quot;&gt;с JSX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3a3d724ce9d7d08105873a53c6f8dacf835179a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a minification step for your scripts, &lt;a href=&quot;https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3&quot;&gt;here&amp;rsquo;s one way to set it up&lt;/a&gt;.</source>
          <target state="translated">Если у вас нет шага минификации для ваших скриптов, &lt;a href=&quot;https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3&quot;&gt;вот один из способов его настройки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a180293faf5f67e8b6a45fe2b65f049a132062b3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Create React App, you can add &lt;a href=&quot;https://www.npmjs.com/package/@babel/plugin-transform-react-jsx-source&quot;&gt;this plugin&lt;/a&gt; manually to your Babel configuration. Note that it&amp;rsquo;s intended only for development and &lt;strong&gt;must be disabled in production&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169a21de60ad2e2c1ea7fcef1a94d52e1be56808" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Create React App, you can add &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source&quot;&gt;this plugin&lt;/a&gt; manually to your Babel configuration. Note that it&amp;rsquo;s intended only for development and &lt;strong&gt;must be disabled in production&lt;/strong&gt;.</source>
          <target state="translated">Если вы не используете приложение Create React, вы можете вручную добавить &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source&quot;&gt;этот плагин&lt;/a&gt; в конфигурацию Babel. Обратите внимание, что он предназначен только для разработки и &lt;strong&gt;должен быть отключен в производственной среде&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="59cb0765a73ef01c64e7a89fed250a66bd20f39c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use ES6 classes, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module instead. See &lt;a href=&quot;react-without-es6&quot;&gt;Using React without ES6&lt;/a&gt; for more information.</source>
          <target state="translated">Если вы не используете классы ES6, вы можете вместо этого использовать модуль create-response &lt;code&gt;create-react-class&lt;/code&gt; . См. Раздел &lt;a href=&quot;react-without-es6&quot;&gt;Использование React без ES6&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f856dc1fed776914cf062b3e550d19f3eb8f9429" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use ES6 yet, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module instead:</source>
          <target state="translated">Если вы еще не используете ES6, вы можете использовать вместо него модуль &lt;code&gt;create-react-class&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4b0b9b7af2dae0cbfcf4257fa36894387d46af3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Relay today, you might have to wait before you can really try Suspense in your app. So far, it&amp;rsquo;s the only implementation that we tested in production and are confident in.</source>
          <target state="translated">Если вы не используете Relay сегодня, вам, возможно, придется подождать, прежде чем вы действительно сможете попробовать Suspense в своем приложении. Пока это единственная реализация, которую мы протестировали в производственной среде и в которой уверены.</target>
        </trans-unit>
        <trans-unit id="332383307eebba5d31fd9d269485dc3ba0b151a2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use a JavaScript bundler and loaded React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, it is already in scope as the &lt;code&gt;React&lt;/code&gt; global.</source>
          <target state="translated">Если вы не используете сборщик JavaScript и загружаете React из &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; , он уже находится в области видимости как глобальный &lt;code&gt;React&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fce0593a2dfad3e9857ade52faf663322205bd6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use either Create React App or Babel, you can use &lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;flow-remove-types&lt;/a&gt; to strip the type annotations.</source>
          <target state="translated">Если вы не используете ни Create React App, ни Babel, вы можете использовать &lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;flow-remove-types,&lt;/a&gt; чтобы удалить аннотации типов.</target>
        </trans-unit>
        <trans-unit id="fb891743d28825149d46e0a3067c093baedd036f" translate="yes" xml:space="preserve">
          <source>If you feel completely stuck, start by keeping all files in a single folder. Eventually it will grow large enough that you will want to separate some files from the rest. By that time you&amp;rsquo;ll have enough knowledge to tell which files you edit together most often. In general, it is a good idea to keep files that often change together close to each other. This principle is called &amp;ldquo;colocation&amp;rdquo;.</source>
          <target state="translated">Если вы чувствуете себя полностью застрявшим, начните с хранения всех файлов в одной папке. Со временем он станет достаточно большим, и вам захочется отделить некоторые файлы от остальных. К тому времени у вас будет достаточно знаний, чтобы определить, какие файлы вы редактируете вместе чаще всего. В общем, рекомендуется хранить файлы, которые часто меняются вместе, близко друг к другу. Этот принцип называется &amp;laquo;колокация&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="df68e6e9e49708727aa3d9b52f358771b20204ab" translate="yes" xml:space="preserve">
          <source>If you feel that the React documentation goes at a faster pace than you&amp;rsquo;re comfortable with, check out &lt;a href=&quot;https://www.taniarascia.com/getting-started-with-react/&quot;&gt;this overview of React by Tania Rascia&lt;/a&gt;. It introduces the most important React concepts in a detailed, beginner-friendly way. Once you&amp;rsquo;re done, give the documentation another try!</source>
          <target state="translated">Если вы чувствуете, что документация React идет быстрее, чем вам удобно, ознакомьтесь с &lt;a href=&quot;https://www.taniarascia.com/getting-started-with-react/&quot;&gt;этим обзором React от Тани Расция&lt;/a&gt; . Он подробно знакомит с наиболее важными концепциями React и удобен для новичков. Как только вы закончите, попробуйте документацию еще раз!</target>
        </trans-unit>
        <trans-unit id="4d81fbc72ec17b2e89d0c20f4ef89b52ec88b669" translate="yes" xml:space="preserve">
          <source>If you find that you need the underlying browser event for some reason, simply use the &lt;code&gt;nativeEvent&lt;/code&gt; attribute to get it. Every &lt;code&gt;SyntheticEvent&lt;/code&gt; object has the following attributes:</source>
          <target state="translated">Если вы обнаружите, что по какой-то причине вам нужно базовое событие браузера, просто используйте атрибут &lt;code&gt;nativeEvent&lt;/code&gt; , чтобы получить его. Каждый объект &lt;code&gt;SyntheticEvent&lt;/code&gt; имеет следующие атрибуты:</target>
        </trans-unit>
        <trans-unit id="96e08083c70a07076b5dab4e563d39dc680a49a8" translate="yes" xml:space="preserve">
          <source>If you find that you need the underlying browser event for some reason, simply use the &lt;code&gt;nativeEvent&lt;/code&gt; attribute to get it. The synthetic events are different from, and do not map directly to, the browser&amp;rsquo;s native events. For example in &lt;code&gt;onMouseLeave&lt;/code&gt;&lt;code&gt;event.nativeEvent&lt;/code&gt; will point to a &lt;code&gt;mouseout&lt;/code&gt; event. The specific mapping is not part of the public API and may change at any time. Every &lt;code&gt;SyntheticEvent&lt;/code&gt; object has the following attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76310cae2aa02095c07fe271a1cb7cd76b5e2f80" translate="yes" xml:space="preserve">
          <source>If you first click &amp;ldquo;Show alert&amp;rdquo; and then increment the counter, the alert will show the &lt;code&gt;count&lt;/code&gt; variable &lt;strong&gt;at the time you clicked the &amp;ldquo;Show alert&amp;rdquo; button&lt;/strong&gt;. This prevents bugs caused by the code assuming props and state don&amp;rsquo;t change.</source>
          <target state="translated">Если вы сначала нажмете &amp;laquo;Показать предупреждение&amp;raquo;, а затем увеличите счетчик, в предупреждении будет отображаться переменная &lt;code&gt;count&lt;/code&gt; &lt;strong&gt;в то время, когда вы нажали кнопку &amp;laquo;Показать предупреждение&amp;raquo;&lt;/strong&gt; . Это предотвращает ошибки, вызванные кодом, предполагающим, что реквизиты и состояние не меняются.</target>
        </trans-unit>
        <trans-unit id="88c29ce29fd299ea922160b41c611cec1eecbc8a" translate="yes" xml:space="preserve">
          <source>If you followed the instructions above, you should be able to run Flow for the first time.</source>
          <target state="translated">Если вы будете следовать инструкциям,приведенным выше,вы сможете запустить Flow в первый раз.</target>
        </trans-unit>
        <trans-unit id="c5309b9cba3e5ecb4cc81e27f68ffbda4d5dab96" translate="yes" xml:space="preserve">
          <source>If you followed the instructions above, you should be able to run TypeScript for the first time.</source>
          <target state="translated">Если вы будете следовать инструкциям,приведенным выше,вы сможете запустить TypeScript в первый раз.</target>
        </trans-unit>
        <trans-unit id="35f39f38f2b3af85590f8b59543c367401e440f4" translate="yes" xml:space="preserve">
          <source>If you get tired of typing &lt;code&gt;React.createElement&lt;/code&gt; so much, one common pattern is to assign a shorthand:</source>
          <target state="translated">Если вы так устали набирать &lt;code&gt;React.createElement&lt;/code&gt; , один из распространенных способов - назначить сокращение:</target>
        </trans-unit>
        <trans-unit id="7325f76c86bc8debb6d4b74351284f0958afc1d0" translate="yes" xml:space="preserve">
          <source>If you have a large existing app, or if your app depends on a lot of third-party packages, please don&amp;rsquo;t expect that you can use the Concurrent Mode immediately. &lt;strong&gt;For example, at Facebook we are using Concurrent Mode for the new website, but we&amp;rsquo;re not planning to enable it on the old website.&lt;/strong&gt; This is because our old website still uses unsafe lifecycle methods in the product code, incompatible third-party libraries, and patterns that don&amp;rsquo;t work well with the Concurrent Mode.</source>
          <target state="translated">Если у вас есть большое приложение или ваше приложение зависит от множества сторонних пакетов, не ожидайте, что вы сразу сможете использовать параллельный режим. &lt;strong&gt;Например, в Facebook мы используем одновременный режим для нового веб-сайта, но мы не планируем включать его на старом веб-сайте. &lt;/strong&gt;Это связано с тем, что наш старый веб-сайт по-прежнему использует небезопасные методы жизненного цикла в коде продукта, несовместимые сторонние библиотеки и шаблоны, которые не работают с параллельным режимом.</target>
        </trans-unit>
        <trans-unit id="049b884296cbaec372f91838646c82b517badc89" translate="yes" xml:space="preserve">
          <source>If you have an event handler such as &lt;code&gt;onClick&lt;/code&gt; or &lt;code&gt;onScroll&lt;/code&gt; and want to prevent the callback from being fired too quickly, then you can limit the rate at which callback is executed. This can be done by using:</source>
          <target state="translated">Если у вас есть обработчик события , такие как &lt;code&gt;onClick&lt;/code&gt; или &lt;code&gt;onScroll&lt;/code&gt; и хотите , чтобы предотвратить обратный вызов от увольнения слишком быстро, то вы можете ограничить скорость , при которой обратный вызов выполняется. Это можно сделать с помощью:</target>
        </trans-unit>
        <trans-unit id="4c213f4472d12ecabe35b829a19649d2ed0d0411" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed the React DevTools, you can find them here:</source>
          <target state="translated">Если вы еще не установили React DevTools, вы можете найти их здесь:</target>
        </trans-unit>
        <trans-unit id="6f4eeb14778b01a7164c9500da7ff7d43818dfb4" translate="yes" xml:space="preserve">
          <source>If you imagine a component tree as a waterfall of props, each component&amp;rsquo;s state is like an additional water source that joins it at an arbitrary point but also flows down.</source>
          <target state="translated">Если представить дерево компонентов как водопад реквизита, состояние каждого компонента будет похоже на дополнительный источник воды, который присоединяется к нему в произвольной точке, но также течет вниз.</target>
        </trans-unit>
        <trans-unit id="827469f1283cc9cfff29c0d19a28165070940429" translate="yes" xml:space="preserve">
          <source>If you implement it naively, inserting an element at the beginning has worse performance. For example, converting between these two trees works poorly:</source>
          <target state="translated">Если вы реализуете его наивно,то вставка элемента в начале имеет худшую производительность.Например,преобразование между этими двумя деревьями работает плохо:</target>
        </trans-unit>
        <trans-unit id="d15834c075532b4876fc67d3752aa2da60bdf369" translate="yes" xml:space="preserve">
          <source>If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like &lt;code&gt;this.state.isClient&lt;/code&gt;, which you can set to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;componentDidMount()&lt;/code&gt;. This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration. Note that this approach will make your components slower because they have to render twice, so use it with caution.</source>
          <target state="translated">Если вам намеренно нужно отрендерить что-то другое на сервере и клиенте, вы можете выполнить двухпроходный рендеринг. Компоненты, которые отображают что-то другое на клиенте, могут читать переменную состояния, например &lt;code&gt;this.state.isClient&lt;/code&gt; , для которой вы можете установить значение &lt;code&gt;true&lt;/code&gt; в &lt;code&gt;componentDidMount()&lt;/code&gt; . Таким образом, начальный проход рендеринга будет отображать тот же контент, что и сервер, избегая несоответствий, но дополнительный проход будет выполняться синхронно сразу после гидратации. Обратите внимание, что этот подход сделает ваши компоненты медленнее, потому что они должны отображаться дважды, поэтому используйте его с осторожностью.</target>
        </trans-unit>
        <trans-unit id="286d3422088a5f59b246609f9ba1c043e52041ac" translate="yes" xml:space="preserve">
          <source>If you intentionally want to read the &lt;em&gt;latest&lt;/em&gt; state from some asynchronous callback, you could keep it in &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;a ref&lt;/a&gt;, mutate it, and read from it.</source>
          <target state="translated">Если вы намеренно хотите прочитать &lt;em&gt;последнее&lt;/em&gt; состояние из некоторого асинхронного обратного вызова, вы можете сохранить его в &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;ссылке&lt;/a&gt; , изменить его и прочитать из него.</target>
        </trans-unit>
        <trans-unit id="e225027ec18fdfd87c9b8442cffb1951bc054fb1" translate="yes" xml:space="preserve">
          <source>If you know that in some situations your component doesn&amp;rsquo;t need to update, you can return &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;shouldComponentUpdate&lt;/code&gt; instead, to skip the whole rendering process, including calling &lt;code&gt;render()&lt;/code&gt; on this component and below.</source>
          <target state="translated">Если вы знаете, что в некоторых ситуациях ваш компонент не нуждается в обновлении, вы можете вместо этого вернуть &lt;code&gt;false&lt;/code&gt; из &lt;code&gt;shouldComponentUpdate&lt;/code&gt; , чтобы пропустить весь процесс рендеринга, включая вызов &lt;code&gt;render()&lt;/code&gt; для этого компонента и ниже.</target>
        </trans-unit>
        <trans-unit id="f91d2eeadcd117626f038d440e0070b4483671a4" translate="yes" xml:space="preserve">
          <source>If you load React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, these top-level APIs are available on the &lt;code&gt;ReactDOM&lt;/code&gt; global. If you use ES6 with npm, you can write &lt;code&gt;import ReactDOM from 'react-dom'&lt;/code&gt;. If you use ES5 with npm, you can write &lt;code&gt;var ReactDOM = require('react-dom')&lt;/code&gt;.</source>
          <target state="translated">Если вы загружаете React из &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; , эти API верхнего уровня доступны в глобальном &lt;code&gt;ReactDOM&lt;/code&gt; . Если вы используете ES6 с npm, вы можете написать &lt;code&gt;import ReactDOM from 'react-dom'&lt;/code&gt; . Если вы используете ES5 с npm, вы можете написать &lt;code&gt;var ReactDOM = require('react-dom')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b93e9d0b0522ffa63fd03295a5cdd6cf8a5e08ca" translate="yes" xml:space="preserve">
          <source>If you look at &lt;code&gt;ProductTable&lt;/code&gt;, you&amp;rsquo;ll see that the table header (containing the &amp;ldquo;Name&amp;rdquo; and &amp;ldquo;Price&amp;rdquo; labels) isn&amp;rsquo;t its own component. This is a matter of preference, and there&amp;rsquo;s an argument to be made either way. For this example, we left it as part of &lt;code&gt;ProductTable&lt;/code&gt; because it is part of rendering the &lt;em&gt;data collection&lt;/em&gt; which is &lt;code&gt;ProductTable&lt;/code&gt;&amp;rsquo;s responsibility. However, if this header grows to be complex (e.g., if we were to add affordances for sorting), it would certainly make sense to make this its own &lt;code&gt;ProductTableHeader&lt;/code&gt; component.</source>
          <target state="translated">Если вы посмотрите на &lt;code&gt;ProductTable&lt;/code&gt; , вы увидите, что заголовок таблицы (содержащий метки &amp;laquo;Имя&amp;raquo; и &amp;laquo;Цена&amp;raquo;) не является отдельным компонентом. Это вопрос предпочтений, и в любом случае есть аргументы. В этом примере мы оставили его как часть &lt;code&gt;ProductTable&lt;/code&gt; , потому что это часть &lt;em&gt;обработки сбора данных, за&lt;/em&gt; которую &lt;code&gt;ProductTable&lt;/code&gt; . Однако, если этот заголовок станет сложным (например, если мы добавим возможности для сортировки), определенно имеет смысл сделать его собственным компонентом &lt;code&gt;ProductTableHeader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d1d424e7e902eeef27e0e70b07d9c861ccdada" translate="yes" xml:space="preserve">
          <source>If you manually configured Babel for your project, you will need to install a special preset for Flow.</source>
          <target state="translated">Если вы вручную настроили Babel для вашего проекта,вам нужно будет установить специальную предустановку для Flow.</target>
        </trans-unit>
        <trans-unit id="2852832854adc219ab4e001ad21ce5c774975fe9" translate="yes" xml:space="preserve">
          <source>If you miss automatic merging, you can write a custom &lt;code&gt;useLegacyState&lt;/code&gt; Hook that merges object state updates. However, instead &lt;strong&gt;we recommend to split state into multiple state variables based on which values tend to change together.&lt;/strong&gt;</source>
          <target state="translated">Если вы пропустите автоматическое слияние, вы можете написать собственный &lt;code&gt;useLegacyState&lt;/code&gt; который объединяет обновления состояния объекта. Однако вместо этого &lt;strong&gt;мы рекомендуем разделить состояние на несколько переменных состояния в зависимости от того, какие значения имеют тенденцию изменяться вместе.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4b8240e4f9b63ece74e9ad3522c2bee38662743" translate="yes" xml:space="preserve">
          <source>If you miss automatic merging, you could write a custom &lt;code&gt;useLegacyState&lt;/code&gt; Hook that merges object state updates. However, &lt;strong&gt;we recommend to split state into multiple state variables based on which values tend to change together.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79521cbe23ba5b60b28726474c0765c13be1ba0" translate="yes" xml:space="preserve">
          <source>If you name the render function, DevTools will also include its name (e.g. &amp;rdquo;&lt;em&gt;ForwardRef(myFunction)&lt;/em&gt;&amp;rdquo;):</source>
          <target state="translated">Если вы назовете функцию рендеринга, DevTools также включит ее имя (например, &amp;laquo; &lt;em&gt;ForwardRef (myFunction)&lt;/em&gt; &amp;raquo;):</target>
        </trans-unit>
        <trans-unit id="86f30ff0b95e1da79af197894b22f7fa988c3f02" translate="yes" xml:space="preserve">
          <source>If you need to &lt;strong&gt;perform a side effect&lt;/strong&gt; (for example, data fetching or an animation) in response to a change in props, use &lt;a href=&quot;#componentdidupdate&quot;&gt;&lt;code&gt;componentDidUpdate&lt;/code&gt;&lt;/a&gt; lifecycle instead.</source>
          <target state="translated">Если вам нужно &lt;strong&gt;выполнить побочный эффект&lt;/strong&gt; (например, выборку данных или анимацию) в ответ на изменение свойств, используйте вместо этого жизненный цикл &lt;a href=&quot;#componentdidupdate&quot;&gt; &lt;code&gt;componentDidUpdate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c925262a759cc54d5372cde4e465f2bacbb07601" translate="yes" xml:space="preserve">
          <source>If you need to access event object&amp;rsquo;s properties after the event handler has run, you need to call &lt;code&gt;e.persist()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205f3177c868e6b279f403e9745e8dcaeb2d6fd7" translate="yes" xml:space="preserve">
          <source>If you need to catch an error inside event handler, use the regular JavaScript &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; statement:</source>
          <target state="translated">Если вам нужно поймать ошибку внутри обработчика событий, используйте обычный оператор JavaScript &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="70a74f7dd4fe0268f156490184fdd512266a1aa6" translate="yes" xml:space="preserve">
          <source>If you need to have access to the parent component in the handler, you also need to bind the function to the component instance (see below).</source>
          <target state="translated">Если вам нужен доступ к родительскому компоненту в обработчике,вам также нужно связать функцию с экземпляром компонента (см.ниже).</target>
        </trans-unit>
        <trans-unit id="ca64c98be7ac6b3d7e337c9127443df11a919dbf" translate="yes" xml:space="preserve">
          <source>If you need to interact with the browser, perform your work in &lt;code&gt;componentDidMount()&lt;/code&gt; or the other lifecycle methods instead. Keeping &lt;code&gt;render()&lt;/code&gt; pure makes components easier to think about.</source>
          <target state="translated">Если вам нужно взаимодействовать с браузером, выполняйте свою работу в &lt;code&gt;componentDidMount()&lt;/code&gt; или других методах жизненного цикла. Сохранение чистоты &lt;code&gt;render()&lt;/code&gt; упрощает рассмотрение компонентов.</target>
        </trans-unit>
        <trans-unit id="999ea53a2b5707c7945911f1e76d3cadb698fd97" translate="yes" xml:space="preserve">
          <source>If you need to modify some value in response to user input or a network response, use &lt;code&gt;state&lt;/code&gt; instead.</source>
          <target state="translated">Если вам нужно изменить какое-либо значение в ответ на ввод пользователя или ответ сети, используйте вместо этого &lt;code&gt;state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8943142e15f89aafbe2213a7c4d356ded10b9fca" translate="yes" xml:space="preserve">
          <source>If you need to test a custom Hook, you can do so by creating a component in your test, and using your Hook from it. Then you can test the component you wrote.</source>
          <target state="translated">Если вам нужно протестировать пользовательский Hook,вы можете сделать это,создав компонент в вашем тесте,и используя Hook из него.Затем вы можете протестировать написанный вами компонент.</target>
        </trans-unit>
        <trans-unit id="8f1a99a66b2ca1ad147dc87037be4bed83199b9c" translate="yes" xml:space="preserve">
          <source>If you notice that you&amp;rsquo;re getting comfortable with build tools and want them to do more for you, &lt;a href=&quot;create-a-new-react-app&quot;&gt;the next section&lt;/a&gt; describes some of the most popular and approachable toolchains. If not &amp;mdash; those script tags will do just fine!</source>
          <target state="translated">Если вы заметили, что привыкаете к инструментам сборки и хотите, чтобы они делали для вас больше, &lt;a href=&quot;create-a-new-react-app&quot;&gt;в следующем разделе&lt;/a&gt; описаны некоторые из наиболее популярных и доступных инструментальных цепочек. Если нет - эти теги скрипта подойдут!</target>
        </trans-unit>
        <trans-unit id="130609e0ef86c8bb326cdb736a8d5fa6030de201" translate="yes" xml:space="preserve">
          <source>If you now create a file called &lt;code&gt;src/like_button.js&lt;/code&gt; with this &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/c8e112dc74ac44aac4f673f2c39d19d1/raw/09b951c86c1bf1116af741fa4664511f2f179f0a/like_button.js&quot;&gt;JSX starter code&lt;/a&gt;&lt;/strong&gt;, the watcher will create a preprocessed &lt;code&gt;like_button.js&lt;/code&gt; with the plain JavaScript code suitable for the browser. When you edit the source file with JSX, the transform will re-run automatically.</source>
          <target state="translated">Если вы теперь создаете файл с именем &lt;code&gt;src/like_button.js&lt;/code&gt; с этим &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/c8e112dc74ac44aac4f673f2c39d19d1/raw/09b951c86c1bf1116af741fa4664511f2f179f0a/like_button.js&quot;&gt;стартовым кодом JSX&lt;/a&gt;&lt;/strong&gt; , наблюдатель создаст предварительно обработанный &lt;code&gt;like_button.js&lt;/code&gt; с простым кодом JavaScript, подходящим для браузера. Когда вы редактируете исходный файл с помощью JSX, преобразование автоматически запускается повторно.</target>
        </trans-unit>
        <trans-unit id="eeff73e27684ff93921c75989a38770068d66406" translate="yes" xml:space="preserve">
          <source>If you often find yourself writing code like this, &lt;a href=&quot;https://www.npmjs.com/package/classnames#usage-with-reactjs&quot;&gt;classnames&lt;/a&gt; package can simplify it.</source>
          <target state="translated">Если вы часто пишете такой код, пакет &lt;a href=&quot;https://www.npmjs.com/package/classnames#usage-with-reactjs&quot;&gt;classnames&lt;/a&gt; может его упростить.</target>
        </trans-unit>
        <trans-unit id="523f123efc70d115d1e9f594fc23ba7ce9678a9f" translate="yes" xml:space="preserve">
          <source>If you pass an empty array (&lt;code&gt;[]&lt;/code&gt;), the props and state inside the effect will always have their initial values. While passing &lt;code&gt;[]&lt;/code&gt; as the second argument is closer to the familiar &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt; mental model, there are usually &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;better&lt;/a&gt;&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;solutions&lt;/a&gt; to avoid re-running effects too often. Also, don&amp;rsquo;t forget that React defers running &lt;code&gt;useEffect&lt;/code&gt; until after the browser has painted, so doing extra work is less of a problem.</source>
          <target state="translated">Если вы передадите пустой массив ( &lt;code&gt;[]&lt;/code&gt; ), свойства и состояние внутри эффекта всегда будут иметь свои начальные значения. Хотя передача &lt;code&gt;[]&lt;/code&gt; в качестве второго аргумента ближе к знакомым ментальным моделям &lt;code&gt;componentDidMount&lt;/code&gt; и &lt;code&gt;componentWillUnmount&lt;/code&gt; , обычно есть &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;лучшие &lt;/a&gt;&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;решения,&lt;/a&gt; позволяющие избежать слишком частого повторного запуска эффектов. Кроме того, не забывайте, что React откладывает запуск &lt;code&gt;useEffect&lt;/code&gt; до тех пор, пока браузер не отрисовывает , поэтому дополнительная работа не представляет проблемы.</target>
        </trans-unit>
        <trans-unit id="ec6b23abafdc2b9551fe13b784fbb8c555b202cd" translate="yes" xml:space="preserve">
          <source>If you pass no value for a prop, it defaults to &lt;code&gt;true&lt;/code&gt;. These two JSX expressions are equivalent:</source>
          <target state="translated">Если вы не передаете значение для свойства, по умолчанию используется значение &lt;code&gt;true&lt;/code&gt; . Эти два выражения JSX эквивалентны:</target>
        </trans-unit>
        <trans-unit id="c20bd7989c1f9f633f138de90c77630a2841cd72" translate="yes" xml:space="preserve">
          <source>If you plan to use React on the client to make the markup interactive, do not use this method. Instead, use &lt;a href=&quot;#rendertonodestream&quot;&gt;&lt;code&gt;renderToNodeStream&lt;/code&gt;&lt;/a&gt; on the server and &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on the client.</source>
          <target state="translated">Если вы планируете использовать React на клиенте, чтобы сделать разметку интерактивной, не используйте этот метод. Вместо этого используйте &lt;a href=&quot;#rendertonodestream&quot;&gt; &lt;code&gt;renderToNodeStream&lt;/code&gt; &lt;/a&gt; на сервере и &lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt; на клиенте.</target>
        </trans-unit>
        <trans-unit id="4310f49d1554474b642c8b917463ce1122a21130" translate="yes" xml:space="preserve">
          <source>If you plan to use React on the client to make the markup interactive, do not use this method. Instead, use &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;renderToString&lt;/code&gt;&lt;/a&gt; on the server and &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on the client.</source>
          <target state="translated">Если вы планируете использовать React на клиенте, чтобы сделать разметку интерактивной, не используйте этот метод. Вместо этого используйте &lt;a href=&quot;#rendertostring&quot;&gt; &lt;code&gt;renderToString&lt;/code&gt; &lt;/a&gt; на сервере и &lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt; на клиенте.</target>
        </trans-unit>
        <trans-unit id="47e07a9bb649f4c37cacef3f1b08b496d76e7c98" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing,&lt;/strong&gt; check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. In this tutorial, we build a tic-tac-toe game in React. You might be tempted to skip it because you&amp;rsquo;re not building games &amp;mdash; but give it a chance. The techniques you&amp;rsquo;ll learn in the tutorial are fundamental to building &lt;em&gt;any&lt;/em&gt; React apps, and mastering it will give you a much deeper understanding.</source>
          <target state="translated">Если вы предпочитаете &lt;strong&gt;учиться на практике,&lt;/strong&gt; ознакомьтесь с нашим &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;практическим руководством&lt;/a&gt; . В этом уроке мы создаем игру в крестики-нолики в React. У вас может возникнуть соблазн пропустить его, потому что вы не создаете игры, но дайте ему шанс. Методы, которые вы изучите в этом руководстве, являются фундаментальными для создания &lt;em&gt;любых&lt;/em&gt; приложений React, и их освоение даст вам гораздо более глубокое понимание.</target>
        </trans-unit>
        <trans-unit id="c1b9fd1209940d1b60d72917c0ebfc7e5668281f" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing,&lt;/strong&gt; check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. In this tutorial, we build a tic-tac-toe game in React. You might be tempted to skip it because you&amp;rsquo;re not into building games &amp;mdash; but give it a chance. The techniques you&amp;rsquo;ll learn in the tutorial are fundamental to building &lt;em&gt;any&lt;/em&gt; React apps, and mastering it will give you a much deeper understanding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ae91e52cf25cb83ca4d281086a571771ef39b0" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing&lt;/strong&gt;, start with our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;.</source>
          <target state="translated">Если вы предпочитаете &lt;strong&gt;учиться на практике&lt;/strong&gt; , начните с нашего &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;практического руководства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c18121d1ed0c7e2f4c183167ee82f078e32e932e" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn concepts step by step,&lt;/strong&gt; our &lt;a href=&quot;index&quot;&gt;guide to main concepts&lt;/a&gt; is the best place to start. Every next chapter in it builds on the knowledge introduced in the previous chapters so you won&amp;rsquo;t miss anything as you go along.</source>
          <target state="translated">Если вы предпочитаете &lt;strong&gt;изучать концепции шаг за шагом,&lt;/strong&gt; лучше всего начать с нашего &lt;a href=&quot;index&quot;&gt;руководства по основным концепциям&lt;/a&gt; . Каждая следующая глава в нем основывается на знаниях, введенных в предыдущих главах, поэтому вы ничего не пропустите в процессе.</target>
        </trans-unit>
        <trans-unit id="51a1d7a5fd157767ed19cef5074e83cab2e2cd1f" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn concepts step by step&lt;/strong&gt;, start with our &lt;a href=&quot;index&quot;&gt;guide to main concepts&lt;/a&gt;.</source>
          <target state="translated">Если вы предпочитаете &lt;strong&gt;изучать концепции шаг за шагом&lt;/strong&gt; , начните с нашего &lt;a href=&quot;index&quot;&gt;руководства по основным концепциям&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a70d45458110999e3ed23edf11293a04e3c413b" translate="yes" xml:space="preserve">
          <source>If you prefer to set up your own JavaScript toolchain from scratch, &lt;a href=&quot;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&quot;&gt;check out this guide&lt;/a&gt; that re-creates some of the Create React App functionality.</source>
          <target state="translated">Если вы предпочитаете создавать собственную цепочку инструментов JavaScript с нуля, &lt;a href=&quot;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&quot;&gt;ознакомьтесь с этим руководством,&lt;/a&gt; которое воссоздает некоторые функции приложения Create React.</target>
        </trans-unit>
        <trans-unit id="ce6bf88e40be3156ec3b84e97a7685d5e9ea541e" translate="yes" xml:space="preserve">
          <source>If you prefer to use your own text editor, you can also &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;download this HTML file&lt;/a&gt;, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so we&amp;rsquo;d only recommend using this for simple demos.</source>
          <target state="translated">Если вы предпочитаете использовать собственный текстовый редактор, вы также можете &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;загрузить этот HTML-файл&lt;/a&gt; , отредактировать его и открыть из локальной файловой системы в браузере. Он выполняет медленное преобразование кода во время выполнения, поэтому мы рекомендуем использовать его только для простых демонстраций.</target>
        </trans-unit>
        <trans-unit id="f757443e0590f766abe60dffa51082eecb2b0c12" translate="yes" xml:space="preserve">
          <source>If you press &amp;ldquo;Open Profile&amp;rdquo; now, you can tell something is wrong. It takes a whole seven seconds to make the transition now! This is because our trivia API is too slow. Let&amp;rsquo;s say we can&amp;rsquo;t make the API faster. How can we improve the user experience with this constraint?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d251364ce59ed1632b03eee6d1772a843639a2d0" translate="yes" xml:space="preserve">
          <source>If you press &amp;ldquo;Open Profile&amp;rdquo; now, you can tell something is wrong. It takes whole seven seconds to make the transition now! This is because our trivia API is too slow. Let&amp;rsquo;s say we can&amp;rsquo;t make the API faster. How can we improve the user experience with this constraint?</source>
          <target state="translated">Если вы сейчас нажмете &amp;laquo;Открыть профиль&amp;raquo;, вы поймете, что что-то не так. Теперь переход занимает целых семь секунд! Это потому, что наш API викторин работает слишком медленно. Допустим, мы не можем сделать API быстрее. Как мы можем улучшить взаимодействие с пользователем с этим ограничением?</target>
        </trans-unit>
        <trans-unit id="ab0fcad6ece9f5a091fd940a4e69d81e420608bb" translate="yes" xml:space="preserve">
          <source>If you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt; comparison algorithm&lt;/a&gt;.)</source>
          <target state="translated">Если вы вернете то же значение из Reducer Hook, что и текущее состояние, React выйдет из строя без рендеринга дочерних элементов или эффектов срабатывания. (React использует &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;алгоритм сравнения &lt;/a&gt; &lt;code&gt;Object.is&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="759d8e9c5a7a89f86b0192bac647a89f30115a0f" translate="yes" xml:space="preserve">
          <source>If you run this code and watch the console logs, you&amp;rsquo;ll notice the sequence is:</source>
          <target state="translated">Если вы запустите этот код и посмотрите журналы консоли, вы заметите, что последовательность такова:</target>
        </trans-unit>
        <trans-unit id="5efa147e22d5f8a48f15dbde439cdd94297df3a9" translate="yes" xml:space="preserve">
          <source>If you see an error message saying &amp;ldquo;You have mistakenly installed the &lt;code&gt;babel&lt;/code&gt; package&amp;rdquo;, you might have missed &lt;a href=&quot;#add-jsx-to-a-project&quot;&gt;the previous step&lt;/a&gt;. Perform it in the same folder, and then try again.</source>
          <target state="translated">Если вы видите сообщение об ошибке &amp;laquo;Вы по ошибке установили пакет &lt;code&gt;babel&lt;/code&gt; &amp;raquo;, возможно, вы пропустили &lt;a href=&quot;#add-jsx-to-a-project&quot;&gt;предыдущий шаг&lt;/a&gt; . Выполните это в той же папке, а затем попробуйте еще раз.</target>
        </trans-unit>
        <trans-unit id="b075833725a23cb77b5ba4dda4642dd74ec1c98a" translate="yes" xml:space="preserve">
          <source>If you see no output, it means that it completed successfully.</source>
          <target state="translated">Если вы не видите вывода,это означает,что он завершился успешно.</target>
        </trans-unit>
        <trans-unit id="0c6e92cbb0194609294df3744170608e6c63909c" translate="yes" xml:space="preserve">
          <source>If you serve React from a CDN, we recommend to keep the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes&quot;&gt;&lt;code&gt;crossorigin&lt;/code&gt;&lt;/a&gt; attribute set:</source>
          <target state="translated">Если вы обслуживаете React из CDN, мы рекомендуем оставить атрибут &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes&quot;&gt; &lt;code&gt;crossorigin&lt;/code&gt; &lt;/a&gt; установленным:</target>
        </trans-unit>
        <trans-unit id="6188f195de25803ee9e3dfbd8d8e12ea147b1a34" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;suppressHydrationWarning&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don&amp;rsquo;t overuse it. You can read more about hydration in the &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="translated">Если вы установите для &lt;code&gt;suppressHydrationWarning&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; , React не будет предупреждать вас о несовпадении атрибутов и содержимого этого элемента. Он работает только на один уровень и предназначен для использования в качестве аварийного люка. Не злоупотребляйте этим. Вы можете узнать больше о гидратации в &lt;a href=&quot;react-dom#hydrate&quot;&gt;документации &lt;/a&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4b1b979c8e20d02ec5a081ede351ede1e9e64ce" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;list of dependencies&lt;/a&gt; as the last argument to &lt;code&gt;useEffect&lt;/code&gt;, &lt;code&gt;useLayoutEffect&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, &lt;code&gt;useCallback&lt;/code&gt;, or &lt;code&gt;useImperativeHandle&lt;/code&gt;, it must include all values that are used inside the callback and participate in the React data flow. That includes props, state, and anything derived from them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83336394d37cf4d7a5b1da0ff1854997645bf222" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;list of dependencies&lt;/a&gt; as the last argument to &lt;code&gt;useEffect&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, &lt;code&gt;useCallback&lt;/code&gt;, or &lt;code&gt;useImperativeHandle&lt;/code&gt;, it must include all values used inside that participate in the React data flow. That includes props, state, and anything derived from them.</source>
          <target state="translated">Если вы указываете &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;список зависимостей&lt;/a&gt; в качестве последнего аргумента для &lt;code&gt;useEffect&lt;/code&gt; , &lt;code&gt;useMemo&lt;/code&gt; , &lt;code&gt;useCallback&lt;/code&gt; или &lt;code&gt;useImperativeHandle&lt;/code&gt; , он должен включать все используемые внутри значения, которые участвуют в потоке данных React. Это включает в себя свойства, состояние и все, что на их основе.</target>
        </trans-unit>
        <trans-unit id="faccdb965000ef6d3d72692abf68f01516804384" translate="yes" xml:space="preserve">
          <source>If you try to type or check the box in the current version of the example, you&amp;rsquo;ll see that React ignores your input. This is intentional, as we&amp;rsquo;ve set the &lt;code&gt;value&lt;/code&gt; prop of the &lt;code&gt;input&lt;/code&gt; to always be equal to the &lt;code&gt;state&lt;/code&gt; passed in from &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="translated">Если вы попытаетесь ввести или установить флажок в текущей версии примера, вы увидите, что React игнорирует ваш ввод. Это сделано намеренно, поскольку мы установили свойство &lt;code&gt;value&lt;/code&gt; &lt;code&gt;input&lt;/code&gt; всегда равным &lt;code&gt;state&lt;/code&gt; переданному из &lt;code&gt;FilterableProductTable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6678ae603feef4934590c9fa76461843ca5d6683" translate="yes" xml:space="preserve">
          <source>If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt; comparison algorithm&lt;/a&gt;.)</source>
          <target state="translated">Если вы обновите State Hook до того же значения, что и текущее состояние, React выйдет из строя без рендеринга дочерних элементов или эффектов запуска. (React использует &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;алгоритм сравнения &lt;/a&gt; &lt;code&gt;Object.is&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="56066137d55bf0e7ea681f5b1c777065f8ae4ce8" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;, run:</source>
          <target state="translated">Если вы используете &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; , запустите:</target>
        </trans-unit>
        <trans-unit id="ade7aaf73be5436c90eadc8335fc3dd6aae134ed" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;, run:</source>
          <target state="translated">Если вы используете &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; , запустите:</target>
        </trans-unit>
        <trans-unit id="2699510a2c0fb7e097d079f03709fb5c277aac2f" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;react-test-renderer&lt;/code&gt;, it also provides an &lt;code&gt;act&lt;/code&gt; export that behaves the same way.</source>
          <target state="translated">Если вы используете &lt;code&gt;react-test-renderer&lt;/code&gt; , он также предоставляет экспорт &lt;code&gt;act&lt;/code&gt; который ведет себя таким же образом.</target>
        </trans-unit>
        <trans-unit id="2f17ca24abe37d1b86e8f96b92da181d93f0022e" translate="yes" xml:space="preserve">
          <source>If you use Create React App, you can &lt;strong&gt;skip the rest of this page&lt;/strong&gt;. It describes the manual setup which doesn&amp;rsquo;t apply to Create React App users.</source>
          <target state="translated">Если вы используете приложение Create React, вы можете &lt;strong&gt;пропустить оставшуюся часть этой страницы&lt;/strong&gt; . Он описывает ручную настройку, которая не применяется к пользователям Create React App.</target>
        </trans-unit>
        <trans-unit id="4a8c97699e7a184def74f6d4614cb42d1ba5dcbe" translate="yes" xml:space="preserve">
          <source>If you use React 16.2 or lower, or if you need more flexibility than provided by ref forwarding, you can use &lt;a href=&quot;https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509&quot;&gt;this alternative approach&lt;/a&gt; and explicitly pass a ref as a differently named prop.</source>
          <target state="translated">Если вы используете React 16.2 или ниже, или если вам нужна большая гибкость, чем обеспечивается пересылкой ссылок, вы можете использовать &lt;a href=&quot;https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509&quot;&gt;этот альтернативный подход&lt;/a&gt; и явно передать ссылку как свойство с другим именем.</target>
        </trans-unit>
        <trans-unit id="5a26f616e6ce178a355bc6c9ea84fd7cd247eb1f" translate="yes" xml:space="preserve">
          <source>If you use React 16.3 or higher, we recommend to use &lt;a href=&quot;forwarding-refs&quot;&gt;ref forwarding&lt;/a&gt; for these cases. &lt;strong&gt;Ref forwarding lets components opt into exposing any child component&amp;rsquo;s ref as their own&lt;/strong&gt;. You can find a detailed example of how to expose a child&amp;rsquo;s DOM node to a parent component &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;in the ref forwarding documentation&lt;/a&gt;.</source>
          <target state="translated">Если вы используете React 16.3 или выше, мы рекомендуем использовать для этих случаев &lt;a href=&quot;forwarding-refs&quot;&gt;переадресацию ссылок&lt;/a&gt; . &lt;strong&gt;Переадресация ссылок позволяет компонентам выбрать отображение ссылки любого дочернего компонента как своей собственной&lt;/strong&gt; . Вы можете найти подробный пример того, как предоставить дочерний узел DOM родительскому компоненту, &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;в документации по пересылке ссылок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c9cdf2ae438a9227b0fb23473474b484ea3d6ee" translate="yes" xml:space="preserve">
          <source>If you use React with Web Components (which is uncommon), use the &lt;code&gt;class&lt;/code&gt; attribute instead.</source>
          <target state="translated">Если вы используете React с веб-компонентами (что редко), используйте вместо этого атрибут &lt;code&gt;class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab5e9d5516774b9d626ce5a38d7e13d370bfc3f7" translate="yes" xml:space="preserve">
          <source>If you use Yarn, run:</source>
          <target state="translated">Если ты используешь Пряжу,беги:</target>
        </trans-unit>
        <trans-unit id="102d3b3dd48c9c09e36ebc5686501b3bb694fec8" translate="yes" xml:space="preserve">
          <source>If you use npm, run:</source>
          <target state="translated">Если ты используешь npm,беги:</target>
        </trans-unit>
        <trans-unit id="b8118d016218e4b145cd1549aa3d71605952205a" translate="yes" xml:space="preserve">
          <source>If you use server rendering, keep in mind that &lt;em&gt;neither&lt;/em&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt; nor &lt;code&gt;useEffect&lt;/code&gt; can run until the JavaScript is downloaded. This is why React warns when a server-rendered component contains &lt;code&gt;useLayoutEffect&lt;/code&gt;. To fix this, either move that logic to &lt;code&gt;useEffect&lt;/code&gt; (if it isn&amp;rsquo;t necessary for the first render), or delay showing that component until after the client renders (if the HTML looks broken until &lt;code&gt;useLayoutEffect&lt;/code&gt; runs).</source>
          <target state="translated">Если вы используете серверный рендеринг, имейте в виду, что &lt;em&gt;ни &lt;/em&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; , ни &lt;code&gt;useEffect&lt;/code&gt; не могут работать, пока не будет загружен JavaScript. Вот почему React предупреждает, когда компонент, отображаемый на сервере, содержит &lt;code&gt;useLayoutEffect&lt;/code&gt; . Чтобы исправить это, либо переместите эту логику в &lt;code&gt;useEffect&lt;/code&gt; (если это не требуется для первого рендеринга), либо отложите отображение этого компонента до тех пор, пока клиент не &lt;code&gt;useLayoutEffect&lt;/code&gt; рендеринг (если HTML выглядит неработающим, до запуска useLayoutEffect ).</target>
        </trans-unit>
        <trans-unit id="70f4f49dc8d98ed757f120ffbd84c5052c4128e4" translate="yes" xml:space="preserve">
          <source>If you use server-side React rendering, normally there is a warning when the server and the client render different content. However, in some rare cases, it is very hard or impossible to guarantee an exact match. For example, timestamps are expected to differ on the server and on the client.</source>
          <target state="translated">Если вы используете React рендеринг на стороне сервера,обычно есть предупреждение,когда сервер и клиент рендерируют разное содержимое.Однако в некоторых редких случаях очень сложно или невозможно гарантировать точное совпадение.Например,ожидается,что временные метки будут различаться на сервере и на клиенте.</target>
        </trans-unit>
        <trans-unit id="4b4178e978ea6a519b02f6012454f8eaa90a9377" translate="yes" xml:space="preserve">
          <source>If you use this optimization, make sure the array includes &lt;strong&gt;all values from the component scope (such as props and state) that change over time and that are used by the effect&lt;/strong&gt;. Otherwise, your code will reference stale values from previous renders. Learn more about &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how to deal with functions&lt;/a&gt; and &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;what to do when the array changes too often&lt;/a&gt;.</source>
          <target state="translated">Если вы используете эту оптимизацию, убедитесь, что в массив входят &lt;strong&gt;все значения из области действия компонента (например, свойства и состояние), которые меняются со временем и используются эффектом&lt;/strong&gt; . В противном случае ваш код будет ссылаться на устаревшие значения из предыдущих отрисовок. Узнайте больше о &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;том, как работать с функциями&lt;/a&gt; и &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;что делать, если массив меняется слишком часто&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b64e4be8855b0be8c046942224485641c321ede" translate="yes" xml:space="preserve">
          <source>If you use this optimization, make sure the array includes &lt;strong&gt;all values from the component scope (such as props and state) that change over time and that are used by the effect&lt;/strong&gt;. Otherwise, your code will reference stale values from previous renders. Learn more about &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how to deal with functions&lt;/a&gt; and what to do when the &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;array values change too often&lt;/a&gt;.</source>
          <target state="translated">Если вы используете эту оптимизацию, убедитесь, что в массив входят &lt;strong&gt;все значения из области действия компонента (например, свойства и состояние), которые меняются со временем и используются эффектом&lt;/strong&gt; . В противном случае ваш код будет ссылаться на устаревшие значения из предыдущих отрисовок. Узнайте больше о &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;том, как работать с функциями&lt;/a&gt; и что делать, если &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;значения массива меняются слишком часто&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4105f95647054b8ce2ef44647d3afb57bb52d64" translate="yes" xml:space="preserve">
          <source>If you use this shorthand form for &lt;code&gt;React.createElement&lt;/code&gt;, it can be almost as convenient to use React without JSX.</source>
          <target state="translated">Если вы используете эту сокращенную форму для &lt;code&gt;React.createElement&lt;/code&gt; , можно почти так же удобно использовать React без JSX.</target>
        </trans-unit>
        <trans-unit id="cd2291bcdecaf7bcb60d1e8e04c1651f5828fbb6" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;componentWillReceiveProps&lt;/code&gt; for &lt;strong&gt;re-computing some data only when a prop changes&lt;/strong&gt;, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;use a memoization helper instead&lt;/a&gt;.</source>
          <target state="translated">Если вы использовали &lt;code&gt;componentWillReceiveProps&lt;/code&gt; для &lt;strong&gt;повторного вычисления некоторых данных только тогда , когда опора изменение&lt;/strong&gt; , &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;использовать помощник запоминания вместо&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa1798685fecc6fe21b1daed99365b31b3e0abf4" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;componentWillReceiveProps&lt;/code&gt; to &lt;strong&gt;&amp;ldquo;reset&amp;rdquo; some state when a prop changes&lt;/strong&gt;, consider either making a component &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;fully controlled&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;fully uncontrolled with a &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы использовали &lt;code&gt;componentWillReceiveProps&lt;/code&gt; для &lt;strong&gt;&amp;laquo;сброса&amp;raquo; некоторого состояния при изменении свойства&lt;/strong&gt; , подумайте о том, чтобы сделать компонент &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;полностью управляемым&lt;/a&gt; или &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;полностью неконтролируемым с помощью &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a26502e1fe8a2d37c09afc69271006277d32cf" translate="yes" xml:space="preserve">
          <source>If you used classes in React before, this code should look familiar:</source>
          <target state="translated">Если вы раньше использовали классы в React,то этот код должен выглядеть знакомо:</target>
        </trans-unit>
        <trans-unit id="f80346a09a47643908c6e3e6ed53648965736c75" translate="yes" xml:space="preserve">
          <source>If you visit a site with React in development mode, the icon will have a red background:</source>
          <target state="translated">Если вы посещаете сайт с Реакцией в режиме разработки,то иконка будет иметь красный фон:</target>
        </trans-unit>
        <trans-unit id="8d195f74ff5d044f82074fc4c274d0cab852a524" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;&amp;ldquo;reset&amp;rdquo; some state when a prop changes&lt;/strong&gt;, consider either making a component &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;fully controlled&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;fully uncontrolled with a &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Если вы хотите &lt;strong&gt;&amp;laquo;сбросить&amp;raquo; какое-то состояние при изменении свойства&lt;/strong&gt; , подумайте о том, чтобы сделать компонент &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;полностью управляемым&lt;/a&gt; или &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;полностью неконтролируемым с помощью &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="029c59f29056b8c40cf61f9a51a8fb598e52ee51" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;re-compute some data only when a prop changes&lt;/strong&gt;, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;use a memoization helper instead&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите &lt;strong&gt;повторно вычислить некоторые данные только при изменении свойства&lt;/strong&gt; , &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;используйте помощник мемоизации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec176e2b65d2b16278f626d01b65a2ecdb160310" translate="yes" xml:space="preserve">
          <source>If you want to access the event properties in an asynchronous way, you should call &lt;code&gt;event.persist()&lt;/code&gt; on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.</source>
          <target state="translated">Если вы хотите получить доступ к свойствам события асинхронным способом, вам следует вызвать &lt;code&gt;event.persist()&lt;/code&gt; для события, которое удалит синтетическое событие из пула и позволит ссылкам на событие сохраняться в коде пользователя.</target>
        </trans-unit>
        <trans-unit id="7b47497fde239e197e47109c7ac26f42ec5315b4" translate="yes" xml:space="preserve">
          <source>If you want to allow people to take a &lt;code&gt;ref&lt;/code&gt; to your function component, you can use &lt;a href=&quot;forwarding-refs&quot;&gt;&lt;code&gt;forwardRef&lt;/code&gt;&lt;/a&gt; (possibly in conjunction with &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt;&lt;code&gt;useImperativeHandle&lt;/code&gt;&lt;/a&gt;), or you can convert the component to a class.</source>
          <target state="translated">Если вы хотите , чтобы люди могли взять &lt;code&gt;ref&lt;/code&gt; в компоненте функции, вы можете использовать &lt;a href=&quot;forwarding-refs&quot;&gt; &lt;code&gt;forwardRef&lt;/code&gt; &lt;/a&gt; (возможно , в сочетании с &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt; &lt;code&gt;useImperativeHandle&lt;/code&gt; &lt;/a&gt; ), или вы можете конвертировать компонент в классе.</target>
        </trans-unit>
        <trans-unit id="9774977c9a0cf92ae57d02963964597fc3851501" translate="yes" xml:space="preserve">
          <source>If you want to extend your contrast testing abilities you can use these tools:</source>
          <target state="translated">Если вы хотите расширить свои возможности тестирования контрастности,вы можете использовать эти инструменты:</target>
        </trans-unit>
        <trans-unit id="86422551613e303c9360cc61b58e27131dcc97ca" translate="yes" xml:space="preserve">
          <source>If you want to mark an &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; as selected, reference the value of that option in the &lt;code&gt;value&lt;/code&gt; of its &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; instead. Check out &lt;a href=&quot;forms#the-select-tag&quot;&gt;&amp;ldquo;The select Tag&amp;rdquo;&lt;/a&gt; for detailed instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c61cdf741239e1629cb1394fd5b25ad2e23b07e" translate="yes" xml:space="preserve">
          <source>If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it.</source>
          <target state="translated">Если вы хотите повторно использовать не пользовательский функционал между компонентами,мы предлагаем извлечь его в отдельный модуль JavaScript.Компоненты могут импортировать его и использовать эту функцию,объект или класс,не расширяя его.</target>
        </trans-unit>
        <trans-unit id="0c62cdf54a3c4b69e723af171e44872b6cf5229d" translate="yes" xml:space="preserve">
          <source>If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array (&lt;code&gt;[]&lt;/code&gt;) as a second argument. This tells React that your effect doesn&amp;rsquo;t depend on &lt;em&gt;any&lt;/em&gt; values from props or state, so it never needs to re-run. This isn&amp;rsquo;t handled as a special case &amp;mdash; it follows directly from how the dependencies array always works.</source>
          <target state="translated">Если вы хотите запустить эффект и очистить его только один раз (при монтировании и размонтировании), вы можете передать пустой массив ( &lt;code&gt;[]&lt;/code&gt; ) в качестве второго аргумента. Это сообщает React, что ваш эффект не зависит от &lt;em&gt;каких-либо&lt;/em&gt; значений из свойств или состояния, поэтому его никогда не нужно запускать повторно. Это не рассматривается как особый случай - это напрямую следует из того, как всегда работает массив зависимостей.</target>
        </trans-unit>
        <trans-unit id="ff9f5e51b60174574056d9954f4502bc83ff6681" translate="yes" xml:space="preserve">
          <source>If you want to test out how some specific JSX is converted into JavaScript, you can try out &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;the online Babel compiler&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите проверить, как какой-то конкретный JSX конвертируется в JavaScript, вы можете попробовать &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;онлайн-компилятор Babel&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5c25e81b4c83c34080d583406db75e5fbd89cb" translate="yes" xml:space="preserve">
          <source>If you want, you can &lt;a href=&quot;https://codesandbox.io/s/m5o42082xy&quot;&gt;extract this logic&lt;/a&gt; into a reusable Hook:</source>
          <target state="translated">Если хотите, вы можете &lt;a href=&quot;https://codesandbox.io/s/m5o42082xy&quot;&gt;извлечь эту логику&lt;/a&gt; в многоразовый Hook:</target>
        </trans-unit>
        <trans-unit id="399df8ef1381d54faa0cf11b65366b05a0ec37b9" translate="yes" xml:space="preserve">
          <source>If you worked with React before, you might be familiar with an older API where the &lt;code&gt;ref&lt;/code&gt; attribute is a string, like &lt;code&gt;&quot;textInput&quot;&lt;/code&gt;, and the DOM node is accessed as &lt;code&gt;this.refs.textInput&lt;/code&gt;. We advise against it because string refs have &lt;a href=&quot;https://github.com/facebook/react/pull/8333#issuecomment-271648615&quot;&gt;some issues&lt;/a&gt;, are considered legacy, and &lt;strong&gt;are likely to be removed in one of the future releases&lt;/strong&gt;.</source>
          <target state="translated">Если вы раньше работали с React, возможно, вы знакомы со старым API, в котором атрибут &lt;code&gt;ref&lt;/code&gt; представляет собой строку, например &lt;code&gt;&quot;textInput&quot;&lt;/code&gt; , а доступ к узлу DOM осуществляется как &lt;code&gt;this.refs.textInput&lt;/code&gt; . Мы не советуем это делать, потому что ссылки на строки имеют &lt;a href=&quot;https://github.com/facebook/react/pull/8333#issuecomment-271648615&quot;&gt;некоторые проблемы&lt;/a&gt; , считаются устаревшими и &lt;strong&gt;, вероятно, будут удалены в одном из будущих выпусков&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="aefdc0d20887310bdbbac46cc25deb537667e418" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d rather play it safe, you have a few options:</source>
          <target state="translated">Если вы предпочитаете перестраховаться, у вас есть несколько вариантов:</target>
        </trans-unit>
        <trans-unit id="c7e8f0a6c71e57b282d77890abf3bb605b7ee301" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re &lt;strong&gt;learning React&lt;/strong&gt; or &lt;strong&gt;creating a new &lt;a href=&quot;glossary#single-page-application&quot;&gt;single-page&lt;/a&gt; app,&lt;/strong&gt; use &lt;a href=&quot;#create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="translated">Если вы &lt;strong&gt;изучаете React&lt;/strong&gt; или &lt;strong&gt;создаете новое &lt;a href=&quot;glossary#single-page-application&quot;&gt;одностраничное&lt;/a&gt; приложение,&lt;/strong&gt; используйте &lt;a href=&quot;#create-react-app&quot;&gt;Create React App&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35c007d618e08aa59cd6a4806d7e82c16701dda7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re benchmarking or experiencing performance problems in your React apps, make sure you&amp;rsquo;re testing with the minified production build.</source>
          <target state="translated">Если вы проводите сравнительный анализ или испытываете проблемы с производительностью в своих приложениях React, убедитесь, что вы тестируете минифицированную производственную сборку.</target>
        </trans-unit>
        <trans-unit id="7fc0f59462da1ba03fb1bccaf4af7f83c2421ae8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;component library&lt;/strong&gt; or &lt;strong&gt;integrating with an existing codebase&lt;/strong&gt;, try &lt;a href=&quot;#more-flexible-toolchains&quot;&gt;More Flexible Toolchains&lt;/a&gt;.</source>
          <target state="translated">Если вы создаете &lt;strong&gt;библиотеку компонентов&lt;/strong&gt; или &lt;strong&gt;интегрируетесь с существующей базой кода&lt;/strong&gt; , попробуйте &lt;a href=&quot;#more-flexible-toolchains&quot;&gt;более гибкие цепочки инструментов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3161c887f0931683850b4ab0d55e09441cde098" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;server-rendered website with Node.js,&lt;/strong&gt; try &lt;a href=&quot;#nextjs&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="translated">Если вы создаете &lt;strong&gt;веб - сайт сервера рендеренных с Node.js,&lt;/strong&gt; попробуйте &lt;a href=&quot;#nextjs&quot;&gt;Next.js&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fbb68fe4e24629438d31ddaa72b597eeb2cb3e7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;static content-oriented website,&lt;/strong&gt; try &lt;a href=&quot;#gatsby&quot;&gt;Gatsby&lt;/a&gt;.</source>
          <target state="translated">Если вы создаете &lt;strong&gt;сайт, ориентированный&lt;/strong&gt; на &lt;strong&gt;статический контент,&lt;/strong&gt; попробуйте &lt;a href=&quot;#gatsby&quot;&gt;Gatsby&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb0145636525588474f0e8276c35e496d1aac96" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from a design background, &lt;a href=&quot;https://reactfordesigners.com/&quot;&gt;these resources&lt;/a&gt; are a great place to get started.</source>
          <target state="translated">Если вы начинаете заниматься дизайном, &lt;a href=&quot;https://reactfordesigners.com/&quot;&gt;эти ресурсы&lt;/a&gt; - отличное место для начала.</target>
        </trans-unit>
        <trans-unit id="1b21a8327f2d695d247dab9ba4c44926f184c95d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from classes, you might be tempted to always call &lt;code&gt;useState()&lt;/code&gt; once and put all state into a single object. You can do it if you&amp;rsquo;d like. Here is an example of a component that follows the mouse movement. We keep its position and size in the local state:</source>
          <target state="translated">Если вы пришли из классов, у вас может возникнуть соблазн всегда вызывать &lt;code&gt;useState()&lt;/code&gt; один раз и помещать все состояние в один объект. Вы можете это сделать, если хотите. Вот пример компонента, который следует за движением мыши. Сохраняем его положение и размер в локальном состоянии:</target>
        </trans-unit>
        <trans-unit id="bbe478a8949bbc21442ebfd2295d514e9b9da8e6" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re curious to see more examples of how JSX is converted to JavaScript, you can try out &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;the online Babel compiler&lt;/a&gt;.</source>
          <target state="translated">Если вам интересно увидеть больше примеров того, как JSX конвертируется в JavaScript, вы можете попробовать &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;онлайн-компилятор Babel&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cdbf14a41aa9dba4bb37c7ce0040976c3385bce3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re currently using &lt;code&gt;this.refs.textInput&lt;/code&gt; to access refs, we recommend using either the &lt;a href=&quot;#callback-refs&quot;&gt;callback pattern&lt;/a&gt; or the &lt;a href=&quot;#creating-refs&quot;&gt;&lt;code&gt;createRef&lt;/code&gt; API&lt;/a&gt; instead.</source>
          <target state="translated">Если вы в настоящее время используете &lt;code&gt;this.refs.textInput&lt;/code&gt; для доступа к ссылкам , мы рекомендуем вместо этого использовать либо &lt;a href=&quot;#callback-refs&quot;&gt;шаблон обратного вызова,&lt;/a&gt; либо &lt;a href=&quot;#creating-refs&quot;&gt; &lt;code&gt;createRef&lt;/code&gt; API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c02314892cb9a48617e7c2fdd059a92d98fef42" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with React class lifecycle methods, you can think of &lt;code&gt;useEffect&lt;/code&gt; Hook as &lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, and &lt;code&gt;componentWillUnmount&lt;/code&gt; combined.</source>
          <target state="translated">Если вы знакомы с методами жизненного цикла класса React, вы можете думать об &lt;code&gt;useEffect&lt;/code&gt; Hook как об объединенных &lt;code&gt;componentDidMount&lt;/code&gt; , &lt;code&gt;componentDidUpdate&lt;/code&gt; и &lt;code&gt;componentWillUnmount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bdbd195fffc505b9d49fae18463ec74871e0648" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with the context API before Hooks, &lt;code&gt;useContext(MyContext)&lt;/code&gt; is equivalent to &lt;code&gt;static contextType = MyContext&lt;/code&gt; in a class, or to &lt;code&gt;&amp;lt;MyContext.Consumer&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если вы знакомы с контекстным API до хуков, &lt;code&gt;useContext(MyContext)&lt;/code&gt; эквивалентен &lt;code&gt;static contextType = MyContext&lt;/code&gt; в классе или &lt;code&gt;&amp;lt;MyContext.Consumer&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71cc84d56c28a1262eb498557fb996376cead69c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in playing around with React, you can use an online code playground. Try a Hello World template on &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;, or &lt;a href=&quot;https://glitch.com/edit/#!/remix/starter-react-template&quot;&gt;Glitch&lt;/a&gt;.</source>
          <target state="translated">Если вам интересно поиграть с React, вы можете использовать онлайн-площадку для кода. Попробуйте шаблон Hello World на &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt; , &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt; или &lt;a href=&quot;https://glitch.com/edit/#!/remix/starter-react-template&quot;&gt;Glitch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="111900da49ce06d00c9d5ebb52775be7c724af2c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in playing around with React, you can use an online code playground. Try a Hello World template on &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;, or &lt;a href=&quot;https://stackblitz.com/fork/react&quot;&gt;Stackblitz&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b478957a5f6430e0e6de7b367d98ab11dc6863ad" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re just starting a project, &lt;a href=&quot;https://en.wikipedia.org/wiki/Analysis_paralysis&quot;&gt;don&amp;rsquo;t spend more than five minutes&lt;/a&gt; on choosing a file structure. Pick any of the above approaches (or come up with your own) and start writing code! You&amp;rsquo;ll likely want to rethink it anyway after you&amp;rsquo;ve written some real code.</source>
          <target state="translated">Если вы только начинаете проект, &lt;a href=&quot;https://en.wikipedia.org/wiki/Analysis_paralysis&quot;&gt;не тратьте больше пяти минут&lt;/a&gt; на выбор файловой структуры. Выберите любой из вышеперечисленных подходов (или придумайте свой) и начинайте писать код! Скорее всего, вы все равно захотите переосмыслить это после того, как напишете реальный код.</target>
        </trans-unit>
        <trans-unit id="02065c0e863b23eb9f215dd9e810ad0fbc822f45" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for a complete solution including validation, keeping track of the visited fields, and handling form submission, &lt;a href=&quot;https://jaredpalmer.com/formik&quot;&gt;Formik&lt;/a&gt; is one of the popular choices. However, it is built on the same principles of controlled components and managing state &amp;mdash; so don&amp;rsquo;t neglect to learn them.</source>
          <target state="translated">Если вы ищете комплексное решение, включающее проверку, отслеживание посещенных полей и обработку &lt;a href=&quot;https://jaredpalmer.com/formik&quot;&gt;отправки&lt;/a&gt; формы, Formik - один из популярных вариантов. Однако он построен на тех же принципах контролируемых компонентов и управления состоянием, поэтому не забывайте их изучать.</target>
        </trans-unit>
        <trans-unit id="ff4bea4c5b521a6375a592447c292171386ec893" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re migrating code from a class component, note &lt;code&gt;useLayoutEffect&lt;/code&gt; fires in the same phase as &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. However, &lt;strong&gt;we recommend starting with &lt;code&gt;useEffect&lt;/code&gt; first&lt;/strong&gt; and only trying &lt;code&gt;useLayoutEffect&lt;/code&gt; if that causes a problem.</source>
          <target state="translated">Если вы &lt;code&gt;useLayoutEffect&lt;/code&gt; код из компонента класса, обратите внимание, что useLayoutEffect срабатывает на той же фазе, что и &lt;code&gt;componentDidMount&lt;/code&gt; и &lt;code&gt;componentDidUpdate&lt;/code&gt; . Однако &lt;strong&gt;мы рекомендуем сначала начать с &lt;code&gt;useEffect&lt;/code&gt; &lt;/strong&gt; и пробовать &lt;code&gt;useLayoutEffect&lt;/code&gt; только в том случае, если это вызывает проблему.</target>
        </trans-unit>
        <trans-unit id="1c5503753c4ba3a8933fe75a74d026956b4dbf0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re new to Hooks, you might want to check out &lt;a href=&quot;hooks-overview&quot;&gt;the overview&lt;/a&gt; first. You may also find useful information in the &lt;a href=&quot;hooks-faq&quot;&gt;frequently asked questions&lt;/a&gt; section.</source>
          <target state="translated">Если вы новичок в хуках, возможно, вы захотите сначала ознакомиться &lt;a href=&quot;hooks-overview&quot;&gt;с обзором&lt;/a&gt; . Вы также можете найти полезную информацию в разделе &lt;a href=&quot;hooks-faq&quot;&gt;часто задаваемых вопросов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83c7ebc6b49f6dd3625d44bdc17f0c9841de397f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not familiar with this syntax, check out the &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;explanation&lt;/a&gt; in the State Hook documentation.</source>
          <target state="translated">Если вы не знакомы с этим синтаксисом, ознакомьтесь с &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;объяснением&lt;/a&gt; в документации State Hook.</target>
        </trans-unit>
        <trans-unit id="5174b478727365c84b01ba51be97ccc6bde6c829" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up Webpack yourself, you&amp;rsquo;ll probably want to read Webpack&amp;rsquo;s &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;guide on code splitting&lt;/a&gt;. Your Webpack config should look vaguely &lt;a href=&quot;https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269&quot;&gt;like this&lt;/a&gt;.</source>
          <target state="translated">Если вы настраиваете Webpack самостоятельно, вы, вероятно, захотите прочитать &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;руководство&lt;/a&gt; Webpack по разделению кода . Конфигурация вашего Webpack должна выглядеть &lt;a href=&quot;https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269&quot;&gt;примерно так&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a795cf4399197efaee67030befff9eb14a55d67d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re the author of a third party React framework, library, developer tool, or similar infrastructure-type project, you can help us keep React stable for your users and the entire React community by periodically running your test suite against the most recent changes. If you&amp;rsquo;re interested, follow these steps:</source>
          <target state="translated">Если вы являетесь автором стороннего фреймворка, библиотеки, инструмента разработчика или аналогичного инфраструктурного проекта, вы можете помочь нам сохранить стабильность React для ваших пользователей и всего сообщества React, периодически выполняя свой набор тестов для самых последних изменения. Если вам интересно, выполните следующие действия:</target>
        </trans-unit>
        <trans-unit id="88d974a28ce0731e8c5b22ec90e221bfa58d8cf7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let&amp;rsquo;s look at a practical example to see why this design helps us create components with fewer bugs.</source>
          <target state="translated">Если вы привыкли к классам, вам может быть интересно, почему фаза очистки эффекта происходит после каждого повторного рендеринга, а не только один раз во время размонтирования. Давайте посмотрим на практический пример, чтобы понять, почему этот дизайн помогает нам создавать компоненты с меньшим количеством ошибок.</target>
        </trans-unit>
        <trans-unit id="1a62f31b074af071c75f6aa5fa6fe227724f9d8d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://create-react-app.dev/&quot;&gt;Create React App&lt;/a&gt;, &lt;a href=&quot;https://nextjs.org/&quot;&gt;Next.js&lt;/a&gt;, &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;, or a similar tool, you will have a Webpack setup out of the box to bundle your app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e2e192cd0c1fbe3f4992433f068147160c96ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, &lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;Next.js&lt;/a&gt;, &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;, or a similar tool, you will have a Webpack setup out of the box to bundle your app.</source>
          <target state="translated">Если вы используете &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; , &lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;Next.js&lt;/a&gt; , &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt; или аналогичный инструмент, у вас будет готовая настройка Webpack для объединения вашего приложения.</target>
        </trans-unit>
        <trans-unit id="3d127abe7b8ab646fe461064799810c4bc682187" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Create React App, both &lt;code&gt;Object.assign&lt;/code&gt; and the object spread syntax are available by default.</source>
          <target state="translated">Если вы используете приложение Create React, по умолчанию доступны как &lt;code&gt;Object.assign&lt;/code&gt; ,так и синтаксис распространения объекта.</target>
        </trans-unit>
        <trans-unit id="0e78c645e20c8ca2c19f0d386c2f5955c20c8fe1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Create React App, please follow &lt;a href=&quot;#create-react-app&quot;&gt;the instructions above&lt;/a&gt;.</source>
          <target state="translated">Если вы используете приложение Create React, следуйте &lt;a href=&quot;#create-react-app&quot;&gt;приведенным выше инструкциям&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b82de6f7cc131deac549e5bef7f9e8de5d34f8d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re working on a data fetching library, there&amp;rsquo;s a crucial aspect of Render-as-You-Fetch you don&amp;rsquo;t want to miss. &lt;strong&gt;We kick off fetching &lt;em&gt;before&lt;/em&gt; rendering.&lt;/strong&gt; Look at this code example closer:</source>
          <target state="translated">Если вы работаете над библиотекой выборки данных, вы не хотите пропустить важный аспект Render-as-You-Fetch. &lt;strong&gt;Мы начинаем загрузку &lt;em&gt;перед&lt;/em&gt; рендерингом. &lt;/strong&gt;Взгляните на этот пример кода поближе:</target>
        </trans-unit>
        <trans-unit id="52cc1d74837d5c0361acef0611ccd09597783f72" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a library that tests mostly browser-specific behavior, and requires native browser behavior like layout or real inputs, you could use a framework like &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha.&lt;/a&gt;</source>
          <target state="translated">Если вы пишете библиотеку, которая тестирует в основном поведение конкретного браузера и требует собственного поведения браузера, такого как макет или реальные входные данные, вы можете использовать фреймворк, такой как &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1b3ede746a1b41e135139260bd938036c1b5653" translate="yes" xml:space="preserve">
          <source>If your React component&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; function renders the same result given the same props and state, you can use &lt;code&gt;React.PureComponent&lt;/code&gt; for a performance boost in some cases.</source>
          <target state="translated">Если функция &lt;code&gt;render()&lt;/code&gt; вашего компонента React отображает тот же результат при тех же свойствах и состоянии, вы можете использовать &lt;code&gt;React.PureComponent&lt;/code&gt; для повышения производительности в некоторых случаях.</target>
        </trans-unit>
        <trans-unit id="2ae535fa4a52d95be43cd119d3dce94ee825d2ad" translate="yes" xml:space="preserve">
          <source>If your application renders long lists of data (hundreds or thousands of rows), we recommended using a technique known as &amp;ldquo;windowing&amp;rdquo;. This technique only renders a small subset of your rows at any given time, and can dramatically reduce the time it takes to re-render the components as well as the number of DOM nodes created.</source>
          <target state="translated">Если ваше приложение отображает длинные списки данных (сотни или тысячи строк), мы рекомендуем использовать технику, известную как &amp;laquo;оконная обработка&amp;raquo;. Этот метод визуализирует только небольшое подмножество ваших строк в любой момент времени и может значительно сократить время, необходимое для повторного отрисовки компонентов, а также количество созданных узлов DOM.</target>
        </trans-unit>
        <trans-unit id="6b0415d8714549e60a664370c6ba10482c3fc92d" translate="yes" xml:space="preserve">
          <source>If your application requires pointer events, we recommend adding a third party pointer event polyfill.</source>
          <target state="translated">Если вашему приложению требуются события по указателям,мы рекомендуем добавить сторонний полифиль по событиям по указателям.</target>
        </trans-unit>
        <trans-unit id="2395816cffe7512d0939e7686c6115bba399430f" translate="yes" xml:space="preserve">
          <source>If your component implements the &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; lifecycle (which is rare), the value it returns will be passed as a third &amp;ldquo;snapshot&amp;rdquo; parameter to &lt;code&gt;componentDidUpdate()&lt;/code&gt;. Otherwise this parameter will be undefined.</source>
          <target state="translated">Если ваш компонент реализует жизненный цикл &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; (что бывает редко), возвращаемое им значение будет передано как третий параметр &amp;laquo;моментального снимка&amp;raquo; в &lt;code&gt;componentDidUpdate()&lt;/code&gt; . В противном случае этот параметр будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="5a60b45baec63445920ea948b6b750469a15d8d0" translate="yes" xml:space="preserve">
          <source>If your component renders the same result given the same props, you can wrap it in a call to &lt;code&gt;React.memo&lt;/code&gt; for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d599f1233ec4f9623c8e348df9de9e2c174bee" translate="yes" xml:space="preserve">
          <source>If your function component renders the same result given the same props, you can wrap it in a call to &lt;code&gt;React.memo&lt;/code&gt; for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.</source>
          <target state="translated">Если ваш функциональный компонент отображает тот же результат при тех же реквизитах, вы можете &lt;code&gt;React.memo&lt;/code&gt; его в вызов React.memo для повышения производительности в некоторых случаях, запомнив результат. Это означает, что React пропустит рендеринг компонента и повторно использует последний результат рендеринга.</target>
        </trans-unit>
        <trans-unit id="7b153be87230d19e0959754d7e8fdb722e18406e" translate="yes" xml:space="preserve">
          <source>If your project is built with &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, run:</source>
          <target state="translated">Если ваш проект построен с помощью &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;приложения Create React&lt;/a&gt; , запустите:</target>
        </trans-unit>
        <trans-unit id="4f76989cbe467f747eafaee915ffd618ee7e8e9e" translate="yes" xml:space="preserve">
          <source>If your project was set up using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, congratulations! The Flow annotations are already being stripped by default so you don&amp;rsquo;t need to do anything else in this step.</source>
          <target state="translated">Если ваш проект был настроен с помощью &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;приложения Create React&lt;/a&gt; , поздравляем! Аннотации потока уже удаляются по умолчанию, поэтому вам не нужно больше ничего делать на этом шаге.</target>
        </trans-unit>
        <trans-unit id="0fc4f1f17431418025447890fea827dfa0079ea0" translate="yes" xml:space="preserve">
          <source>If your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e8d7dcd1b990fee40afd460f8d53442f4e8b92" translate="yes" xml:space="preserve">
          <source>If your update function returns the exact same value, the subsequent rerender will be skipped completely.</source>
          <target state="translated">Если функция обновления вернет точно такое же значение,последующая перемотка будет полностью пропущена.</target>
        </trans-unit>
        <trans-unit id="e2e9082f9e460ca12ce12808ea1db2401ca59946" translate="yes" xml:space="preserve">
          <source>Image Events</source>
          <target state="translated">События изображения</target>
        </trans-unit>
        <trans-unit id="38bbbb29751f3fd92cc08381c3226ccef034d3b1" translate="yes" xml:space="preserve">
          <source>Imagine that we already have a JSON API and a mock from our designer. The mock looks like this:</source>
          <target state="translated">Представьте себе,что у нас уже есть JSON API и насмешка от нашего дизайнера.Инсценировка выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="515dd2117b7986f40a9ea292c49529e087a55c0a" translate="yes" xml:space="preserve">
          <source>Imagine we&amp;rsquo;re navigating between two screens in an app. Sometimes, we might not have enough code and data loaded to show a &amp;ldquo;good enough&amp;rdquo; loading state to the user on the new screen. Transitioning to an empty screen or a large spinner can be a jarring experience. However, it&amp;rsquo;s also common that the necessary code and data doesn&amp;rsquo;t take too long to fetch. &lt;strong&gt;Wouldn&amp;rsquo;t it be nicer if React could stay on the old screen for a little longer, and &amp;ldquo;skip&amp;rdquo; the &amp;ldquo;bad loading state&amp;rdquo; before showing the new screen?&lt;/strong&gt;</source>
          <target state="translated">Представьте, что мы перемещаемся между двумя экранами в приложении. Иногда нам может не хватить кода и загруженных данных, чтобы показать пользователю &amp;laquo;достаточно хорошее&amp;raquo; состояние загрузки на новом экране. Переход к пустому экрану или большому счетчику может быть неприятным. Однако часто бывает так, что получение необходимого кода и данных не занимает много времени. &lt;strong&gt;Разве не было бы лучше, если бы React мог оставаться на старом экране еще немного и &amp;laquo;пропускать&amp;raquo; &amp;laquo;плохое состояние загрузки&amp;raquo; перед отображением нового экрана?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a33a303f56a6bbd06206e5ce4d8446405d3fa4f3" translate="yes" xml:space="preserve">
          <source>Importantly, custom Hooks give you the power to constrain React API if you&amp;rsquo;d like to type them more strictly in some way. React gives you the primitives, but you can combine them in different ways than what we provide out of the box.</source>
          <target state="translated">Важно отметить, что пользовательские хуки дают вам возможность ограничивать React API, если вы хотите каким-то образом вводить их более строго. React предоставляет вам примитивы, но вы можете комбинировать их разными способами, нежели те, которые мы предоставляем из коробки.</target>
        </trans-unit>
        <trans-unit id="389fbb58f34b12bedefc8ca743f17e0f3583836d" translate="yes" xml:space="preserve">
          <source>Importantly, the way you &lt;em&gt;use&lt;/em&gt; React is the same. Concepts like components, props, and state fundamentally work the same way. When you want to update the screen, you set the state.</source>
          <target state="translated">Важно отметить, что способ &lt;em&gt;использования&lt;/em&gt; React такой же. Такие концепции, как компоненты, свойства и состояние, в основном работают одинаково. Когда вы хотите обновить экран, вы устанавливаете состояние.</target>
        </trans-unit>
        <trans-unit id="1368d43d01a36b5581bb3e9a2be050b9de12c101" translate="yes" xml:space="preserve">
          <source>In CSS, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents&quot;&gt;&lt;code&gt;display: contents&lt;/code&gt;&lt;/a&gt; attribute can be used if you don&amp;rsquo;t want the node to be part of the layout.</source>
          <target state="translated">В CSS атрибут &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents&quot;&gt; &lt;code&gt;display: contents&lt;/code&gt; &lt;/a&gt; можно использовать, если вы не хотите, чтобы узел был частью макета.</target>
        </trans-unit>
        <trans-unit id="4b55e065dea1bfb41665c75fc1cc794c8f70a095" translate="yes" xml:space="preserve">
          <source>In Concurrent Mode, rendering is not blocking. It is interruptible. This improves the user experience. It also unlocks new features that weren&amp;rsquo;t possible before. Before we look at concrete examples in the &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;next&lt;/a&gt;&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;chapters&lt;/a&gt;, we&amp;rsquo;ll do a high-level overview of new features.</source>
          <target state="translated">В параллельном режиме рендеринг не блокируется. Это прерывается. Это улучшает пользовательский опыт. Он также открывает новые возможности, которые раньше были невозможны. Прежде чем мы рассмотрим конкретные примеры в &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;следующих &lt;/a&gt;&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;главах&lt;/a&gt; , мы сделаем общий обзор новых функций.</target>
        </trans-unit>
        <trans-unit id="7ecc95e249a2849c1eb4333865f60656c17be67b" translate="yes" xml:space="preserve">
          <source>In Concurrent Mode, the lifecycle methods &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;previously marked&lt;/a&gt; as &amp;ldquo;unsafe&amp;rdquo; actually &lt;em&gt;are&lt;/em&gt; unsafe, and lead to bugs even more than in today&amp;rsquo;s React. We don&amp;rsquo;t recommend trying Concurrent Mode until your app is &lt;a href=&quot;strict-mode&quot;&gt;Strict Mode&lt;/a&gt;-compatible.</source>
          <target state="translated">В режиме параллельного, методы жизненного цикла , &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;ранее отмеченные&lt;/a&gt; как &amp;laquo;небезопасные&amp;raquo; на самом деле &lt;em&gt;являются&lt;/em&gt; небезопасными, и привести к ошибкам даже больше , чем в сегодняшних React. Мы не рекомендуем пробовать одновременный режим, пока ваше приложение не станет совместимым со &lt;a href=&quot;strict-mode&quot;&gt;строгим режимом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21ea6a0b5b929f6e4d971d6001063e6cdcc606f8" translate="yes" xml:space="preserve">
          <source>In ES6 classes, you can define the initial state by assigning &lt;code&gt;this.state&lt;/code&gt; in the constructor:</source>
          <target state="translated">В классах ES6 вы можете определить начальное состояние, присвоив &lt;code&gt;this.state&lt;/code&gt; в конструкторе:</target>
        </trans-unit>
        <trans-unit id="74b9508d775e315d9d48d1ac6d2be46507d95cbb" translate="yes" xml:space="preserve">
          <source>In HTML, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; creates a drop-down list. For example, this HTML creates a drop-down list of flavors:</source>
          <target state="translated">В HTML &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; создает раскрывающийся список. Например, этот HTML-код создает раскрывающийся список разновидностей:</target>
        </trans-unit>
        <trans-unit id="6260ccb22bfbbde7ec537c88316f474366bfa99b" translate="yes" xml:space="preserve">
          <source>In HTML, a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; element defines its text by its children:</source>
          <target state="translated">В HTML элемент &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; определяет свой текст своими дочерними элементами:</target>
        </trans-unit>
        <trans-unit id="cee26a6db634e40e4019da1e44bc2fa5e8708d30" translate="yes" xml:space="preserve">
          <source>In HTML, an &lt;code&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/code&gt; lets the user choose one or more files from their device storage to be uploaded to a server or manipulated by JavaScript via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications&quot;&gt;File API&lt;/a&gt;.</source>
          <target state="translated">В HTML &lt;code&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/code&gt; позволяет пользователю выбрать один или несколько файлов из хранилища своего устройства, которые будут загружены на сервер или обработаны с помощью JavaScript через &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications&quot;&gt;File API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd8882487752794b9ff3cba07ccbd1e6347dd57" translate="yes" xml:space="preserve">
          <source>In HTML, form elements such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with &lt;a href=&quot;react-component#setstate&quot;&gt;&lt;code&gt;setState()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В HTML элементы формы, такие как &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; , обычно поддерживают свое собственное состояние и обновляют его на основе ввода данных пользователем. В React изменяемое состояние обычно сохраняется в свойстве состояния компонентов и обновляется только с помощью &lt;a href=&quot;react-component#setstate&quot;&gt; &lt;code&gt;setState()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="451fb8c93e5b83ed15cecd30a84768222971358c" translate="yes" xml:space="preserve">
          <source>In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: &lt;code&gt;props.children&lt;/code&gt;. There are several different ways to pass children:</source>
          <target state="translated">В выражениях JSX, которые содержат как открывающий, так и закрывающий теги, содержимое между этими тегами передается как специальное &lt;code&gt;props.children&lt;/code&gt; : props.children . Есть несколько разных способов передать детей:</target>
        </trans-unit>
        <trans-unit id="2b47b7c0e900bd9fddd8dd976d3fa0c74ee40520" translate="yes" xml:space="preserve">
          <source>In JavaScript, these two code snippets are &lt;strong&gt;not&lt;/strong&gt; equivalent:</source>
          <target state="translated">В JavaScript эти два фрагмента кода &lt;strong&gt;не&lt;/strong&gt; эквивалентны:</target>
        </trans-unit>
        <trans-unit id="896c4ff0b7dad9168327f4c2b1e69fd7b821d242" translate="yes" xml:space="preserve">
          <source>In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.</source>
          <target state="translated">В приложениях &quot;React apps&quot; вопрос о том,является ли тот или иной компонент государственным или апатридным,рассматривается как имплементационная деталь компонента,которая со временем может меняться.Вы можете использовать компоненты без состояния внутри компонентов с контролем состояния и наоборот.</target>
        </trans-unit>
        <trans-unit id="b509261276a2c24087d4a53dfcbb229d41ff110f" translate="yes" xml:space="preserve">
          <source>In React class components, the &lt;code&gt;render&lt;/code&gt; method itself shouldn&amp;rsquo;t cause side effects. It would be too early &amp;mdash; we typically want to perform our effects &lt;em&gt;after&lt;/em&gt; React has updated the DOM.</source>
          <target state="translated">В компонентах класса React сам метод &lt;code&gt;render&lt;/code&gt; не должен вызывать побочных эффектов. Было бы слишком рано - обычно мы хотим выполнить наши эффекты &lt;em&gt;после того, как&lt;/em&gt; React обновит DOM.</target>
        </trans-unit>
        <trans-unit id="cea30c1cddacc5c2fb8659ad8a3ea7724439494a" translate="yes" xml:space="preserve">
          <source>In React components declared as ES6 classes, methods follow the same semantics as regular ES6 classes. This means that they don&amp;rsquo;t automatically bind &lt;code&gt;this&lt;/code&gt; to the instance. You&amp;rsquo;ll have to explicitly use &lt;code&gt;.bind(this)&lt;/code&gt; in the constructor:</source>
          <target state="translated">В компонентах React, объявленных как классы ES6, методы следуют той же семантике, что и обычные классы ES6. Это означает, что они не связывают &lt;code&gt;this&lt;/code&gt; автоматически с экземпляром. Вам нужно будет явно использовать &lt;code&gt;.bind(this)&lt;/code&gt; в конструкторе:</target>
        </trans-unit>
        <trans-unit id="538221c0cbcf54504c0c303253382099a46a923b" translate="yes" xml:space="preserve">
          <source>In React, a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; uses a &lt;code&gt;value&lt;/code&gt; attribute instead. This way, a form using a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; can be written very similarly to a form that uses a single-line input:</source>
          <target state="translated">В React &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; вместо этого использует атрибут &lt;code&gt;value&lt;/code&gt; . Таким образом, форма, использующая &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; , может быть написана очень похоже на форму, которая использует однострочный ввод:</target>
        </trans-unit>
        <trans-unit id="9c9a3a5e0ceac65aab6602bc1dbe2fe9e493d0fe" translate="yes" xml:space="preserve">
          <source>In React, all DOM properties and attributes (including event handlers) should be camelCased. For example, the HTML attribute &lt;code&gt;tabindex&lt;/code&gt; corresponds to the attribute &lt;code&gt;tabIndex&lt;/code&gt; in React. The exception is &lt;code&gt;aria-*&lt;/code&gt; and &lt;code&gt;data-*&lt;/code&gt; attributes, which should be lowercased. For example, you can keep &lt;code&gt;aria-label&lt;/code&gt; as &lt;code&gt;aria-label&lt;/code&gt;.</source>
          <target state="translated">В React все свойства и атрибуты DOM (включая обработчики событий) должны быть в верблюжьем. Например, HTML-атрибут &lt;code&gt;tabindex&lt;/code&gt; соответствует атрибуту &lt;code&gt;tabIndex&lt;/code&gt; в React. Исключение составляет &lt;code&gt;aria-*&lt;/code&gt; и &lt;code&gt;data-*&lt;/code&gt; атрибуты, которые должны быть строчными. Например, вы можете сохранить &lt;code&gt;aria-label&lt;/code&gt; как &lt;code&gt;aria-label&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c511871e368bc7af53ec2e81d4fb957978f940e" translate="yes" xml:space="preserve">
          <source>In React, an &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; is always an uncontrolled component because its value can only be set by a user, and not programmatically.</source>
          <target state="translated">В React &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; всегда является неконтролируемым компонентом, потому что его значение может быть установлено только пользователем, а не программно.</target>
        </trans-unit>
        <trans-unit id="3c7fa02f2469625e763a13cd5609a01cda7c6c08" translate="yes" xml:space="preserve">
          <source>In React, both &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; represent the &lt;em&gt;rendered&lt;/em&gt; values, i.e. what&amp;rsquo;s currently on the screen.</source>
          <target state="translated">В React и &lt;code&gt;this.props&lt;/code&gt; , и &lt;code&gt;this.state&lt;/code&gt; представляют &lt;em&gt;отображаемые&lt;/em&gt; значения, то есть то, что в данный момент отображается на экране.</target>
        </trans-unit>
        <trans-unit id="f14047f4f0476e66fe99901264ae249589cef260" translate="yes" xml:space="preserve">
          <source>In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called &amp;ldquo;lifting state up&amp;rdquo;. We will remove the local state from the &lt;code&gt;TemperatureInput&lt;/code&gt; and move it into the &lt;code&gt;Calculator&lt;/code&gt; instead.</source>
          <target state="translated">В React совместное использование состояния достигается перемещением его к ближайшему общему предку компонентов, которые в нем нуждаются. Это называется &amp;laquo;состояние подъема&amp;raquo;. Мы удалим локальное состояние из &lt;code&gt;TemperatureInput&lt;/code&gt; и вместо этого переместим его в &lt;code&gt;Calculator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a53b8bc22280c0c555667af9e91fb2d02153f1e" translate="yes" xml:space="preserve">
          <source>In React, this could instead be:</source>
          <target state="translated">В действительности,это может быть вместо этого:</target>
        </trans-unit>
        <trans-unit id="410126e91330d77043a8e4cf7862f0a183679992" translate="yes" xml:space="preserve">
          <source>In React, this is also achieved by composition, where a more &amp;ldquo;specific&amp;rdquo; component renders a more &amp;ldquo;generic&amp;rdquo; one and configures it with props:</source>
          <target state="translated">В React это также достигается с помощью композиции, когда более &amp;laquo;специфический&amp;raquo; компонент отображает более &amp;laquo;общий&amp;raquo; и настраивает его с помощью свойств:</target>
        </trans-unit>
        <trans-unit id="5f50da8ee138f52d6b59eebfb1b47338f96dd4b5" translate="yes" xml:space="preserve">
          <source>In React, this is usually solved by making a component &amp;ldquo;controlled&amp;rdquo;. Just like the DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; accepts both a &lt;code&gt;value&lt;/code&gt; and an &lt;code&gt;onChange&lt;/code&gt; prop, so can the custom &lt;code&gt;TemperatureInput&lt;/code&gt; accept both &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;onTemperatureChange&lt;/code&gt; props from its parent &lt;code&gt;Calculator&lt;/code&gt;.</source>
          <target state="translated">В React это обычно решается путем создания компонента &amp;laquo;управляемым&amp;raquo;. Точно так же, как DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; принимает как &lt;code&gt;value&lt;/code&gt; и &lt;code&gt;onChange&lt;/code&gt; , пользовательский &lt;code&gt;TemperatureInput&lt;/code&gt; может принимать &lt;code&gt;onTemperatureChange&lt;/code&gt; &lt;code&gt;temperature&lt;/code&gt; и onTemperatureChange от своего родительского &lt;code&gt;Calculator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87275e536b566529b077b0ff131cc019d2d910ed" translate="yes" xml:space="preserve">
          <source>In React, transforming arrays into lists of &lt;a href=&quot;rendering-elements&quot;&gt;elements&lt;/a&gt; is nearly identical.</source>
          <target state="translated">В React преобразование массивов в списки &lt;a href=&quot;rendering-elements&quot;&gt;элементов&lt;/a&gt; практически идентично.</target>
        </trans-unit>
        <trans-unit id="28e0e1f0e9359d0e312a435e081792d0bfb666a7" translate="yes" xml:space="preserve">
          <source>In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.</source>
          <target state="translated">В React вы можете создавать различные компоненты,которые инкапсулируют нужное вам поведение.Затем,вы можете отрисовать только некоторые из них,в зависимости от состояния вашего приложения.</target>
        </trans-unit>
        <trans-unit id="f18d05ee6185a8ba49d29302bd632b76aa474a54" translate="yes" xml:space="preserve">
          <source>In React, you most likely write your components in a &lt;code&gt;.js&lt;/code&gt; file. In TypeScript we have 2 file extensions:</source>
          <target state="translated">В React вы, скорее всего, пишете свои компоненты в файле &lt;code&gt;.js&lt;/code&gt; . В TypeScript у нас есть 2 расширения файлов:</target>
        </trans-unit>
        <trans-unit id="9f15ab1b0e75d6b53c4958487bbf30fca20cdcdd" translate="yes" xml:space="preserve">
          <source>In a React class, you would typically set up a subscription in &lt;code&gt;componentDidMount&lt;/code&gt;, and clean it up in &lt;code&gt;componentWillUnmount&lt;/code&gt;. For example, let&amp;rsquo;s say we have a &lt;code&gt;ChatAPI&lt;/code&gt; module that lets us subscribe to a friend&amp;rsquo;s online status. Here&amp;rsquo;s how we might subscribe and display that status using a class:</source>
          <target state="translated">В классе React вы обычно настраиваете подписку в &lt;code&gt;componentDidMount&lt;/code&gt; и очищаете ее в &lt;code&gt;componentWillUnmount&lt;/code&gt; . Например, предположим, что у нас есть модуль &lt;code&gt;ChatAPI&lt;/code&gt; , который позволяет нам подписываться на статус друга в сети. Вот как мы можем подписаться и отобразить этот статус с помощью класса:</target>
        </trans-unit>
        <trans-unit id="ae59876c3b29c0877309b94f02f1bd1dffc61a49" translate="yes" xml:space="preserve">
          <source>In a class component, we would need to add &lt;code&gt;componentDidUpdate&lt;/code&gt; to handle this case:</source>
          <target state="translated">В компоненте класса нам нужно будет добавить &lt;code&gt;componentDidUpdate&lt;/code&gt; для обработки этого случая:</target>
        </trans-unit>
        <trans-unit id="92c2ff44f620f5f28854f62d80affff3a499ba93" translate="yes" xml:space="preserve">
          <source>In a class, we initialize the &lt;code&gt;count&lt;/code&gt; state to &lt;code&gt;0&lt;/code&gt; by setting &lt;code&gt;this.state&lt;/code&gt; to &lt;code&gt;{ count: 0 }&lt;/code&gt; in the constructor:</source>
          <target state="translated">В классе мы инициализация &lt;code&gt;count&lt;/code&gt; состояния до &lt;code&gt;0&lt;/code&gt; , установив &lt;code&gt;this.state&lt;/code&gt; на &lt;code&gt;{ count: 0 }&lt;/code&gt; в конструкторе:</target>
        </trans-unit>
        <trans-unit id="0f976be121765c87a20b8cbb91d05fe0f6e68773" translate="yes" xml:space="preserve">
          <source>In a class, we need to call &lt;code&gt;this.setState()&lt;/code&gt; to update the &lt;code&gt;count&lt;/code&gt; state:</source>
          <target state="translated">В классе нам нужно вызвать &lt;code&gt;this.setState()&lt;/code&gt; чтобы обновить состояние &lt;code&gt;count&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42f4e9921f51af97e4b657670a6fd71ed33571b6" translate="yes" xml:space="preserve">
          <source>In a function component, we have no &lt;code&gt;this&lt;/code&gt;, so we can&amp;rsquo;t assign or read &lt;code&gt;this.state&lt;/code&gt;. Instead, we call the &lt;code&gt;useState&lt;/code&gt; Hook directly inside our component:</source>
          <target state="translated">В функциональном компоненте у нас нет &lt;code&gt;this&lt;/code&gt; , поэтому мы не можем присвоить или прочитать &lt;code&gt;this.state&lt;/code&gt; . Вместо этого мы вызываем &lt;code&gt;useState&lt;/code&gt; Hook непосредственно внутри нашего компонента:</target>
        </trans-unit>
        <trans-unit id="f02a6361f2d8d56c63358f0ea5c054c54d590ac2" translate="yes" xml:space="preserve">
          <source>In a function, we already have &lt;code&gt;setCount&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; as variables so we don&amp;rsquo;t need &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">В функции, у нас уже есть &lt;code&gt;setCount&lt;/code&gt; и &lt;code&gt;count&lt;/code&gt; как переменные , так нам не нужно &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8baa32bfe1b6970407832863578c772af74c5714" translate="yes" xml:space="preserve">
          <source>In a function, we can use &lt;code&gt;count&lt;/code&gt; directly:</source>
          <target state="translated">В функции мы можем напрямую использовать &lt;code&gt;count&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e453bfad87294cd830086d87833eed893f7ed85e" translate="yes" xml:space="preserve">
          <source>In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.</source>
          <target state="translated">В типичном React приложении данные передаются сверху вниз (от родителя к ребенку)через реквизит,но это может быть громоздко для определенных типов реквизита (например,предпочтение локали,тема пользовательского интерфейса),которые требуются многим компонентам внутри приложения.Контекст предоставляет способ разделить такие значения между компонентами без необходимости явно передавать реквизит через каждый уровень дерева.</target>
        </trans-unit>
        <trans-unit id="b9e54856b0d6dda52097e2ff1d03dbed8218a984" translate="yes" xml:space="preserve">
          <source>In addition to making code reuse and code organization more difficult, we&amp;rsquo;ve found that classes can be a large barrier to learning React. You have to understand how &lt;code&gt;this&lt;/code&gt; works in JavaScript, which is very different from how it works in most languages. You have to remember to bind the event handlers. Without unstable &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-class-properties/&quot;&gt;syntax proposals&lt;/a&gt;, the code is very verbose. People can understand props, state, and top-down data flow perfectly well but still struggle with classes. The distinction between function and class components in React and when to use each one leads to disagreements even between experienced React developers.</source>
          <target state="translated">Мы обнаружили, что классы не только усложняют повторное использование кода и его организацию, но и являются большим препятствием для изучения React. Вы должны понимать, как &lt;code&gt;this&lt;/code&gt; работает в JavaScript, который сильно отличается от того, как это работает в большинстве языков. Вы должны не забыть привязать обработчики событий. Без &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-class-properties/&quot;&gt;предложений&lt;/a&gt; нестабильного синтаксиса код будет очень многословным. Люди прекрасно понимают свойства свойств, состояний и нисходящего потока данных, но при этом испытывают трудности с классами. Различие между функциональными и классовыми компонентами в React и тем, когда использовать каждый из них, приводит к разногласиям даже между опытными разработчиками React.</target>
        </trans-unit>
        <trans-unit id="289e0d186dd0eceb3a53aed219c7fedfcae512fa" translate="yes" xml:space="preserve">
          <source>In addition, consider that the design of Hooks is more efficient in a couple ways:</source>
          <target state="translated">Кроме того,учтите,что конструкция крючков более эффективна в паре способов:</target>
        </trans-unit>
        <trans-unit id="cf07c2cb1d9764411791f25d366167bf2c6a4a7d" translate="yes" xml:space="preserve">
          <source>In an environment where you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; simulate a DOM (e.g. testing React Native components on Node.js), you could use &lt;a href=&quot;test-utils#simulate&quot;&gt;event simulation helpers&lt;/a&gt; to simulate interactions with elements. Alternately, you could use the &lt;code&gt;fireEvent&lt;/code&gt; helper from &lt;a href=&quot;https://testing-library.com/docs/native-testing-library&quot;&gt;&lt;code&gt;@testing-library/react-native&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В среде, где вы &lt;em&gt;не можете&lt;/em&gt; имитировать DOM (например, тестирование компонентов React Native на Node.js), вы можете использовать &lt;a href=&quot;test-utils#simulate&quot;&gt;помощники моделирования событий&lt;/a&gt; для имитации взаимодействия с элементами. В качестве альтернативы вы можете использовать помощник &lt;code&gt;fireEvent&lt;/code&gt; из &lt;a href=&quot;https://testing-library.com/docs/native-testing-library&quot;&gt; &lt;code&gt;@testing-library/react-native&lt;/code&gt; &lt;/a&gt; react -native .</target>
        </trans-unit>
        <trans-unit id="7f063e3769c1f0ad77a1abd50a358ab7846c95c3" translate="yes" xml:space="preserve">
          <source>In an environment where you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; simulate a DOM (e.g. testing React Native components on Node.js), you could use &lt;a href=&quot;test-utils#simulate&quot;&gt;event simulation helpers&lt;/a&gt; to simulate interactions with elements. Alternately, you could use the &lt;code&gt;fireEvent&lt;/code&gt; helper from &lt;a href=&quot;https://testing-library.com/docs/react-native-testing-library/intro&quot;&gt;&lt;code&gt;@testing-library/react-native&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd08e59d935cb13b1f6c01dc28056496f6a9bc4e" translate="yes" xml:space="preserve">
          <source>In applications with many components, it&amp;rsquo;s very important to free up resources taken by the components when they are destroyed.</source>
          <target state="translated">В приложениях с большим количеством компонентов очень важно освободить ресурсы, занятые компонентами при их уничтожении.</target>
        </trans-unit>
        <trans-unit id="6b767eadf5b4139629873d3d67b44c49dd15f7ed" translate="yes" xml:space="preserve">
          <source>In both cases, the &lt;code&gt;e&lt;/code&gt; argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with &lt;code&gt;bind&lt;/code&gt; any further arguments are automatically forwarded.</source>
          <target state="translated">В обоих случаях аргумент &lt;code&gt;e&lt;/code&gt; , представляющий событие React, будет передан как второй аргумент после идентификатора. С помощью стрелочной функции мы должны передать ее явно, но с помощью &lt;code&gt;bind&lt;/code&gt; любые дальнейшие аргументы перенаправляются автоматически.</target>
        </trans-unit>
        <trans-unit id="d1802f47fc0c94f1304e39a33f567229bc6a0fe9" translate="yes" xml:space="preserve">
          <source>In cases where you cannot define the prop statically (e.g. because you need to close over the component&amp;rsquo;s props and/or state) &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; should extend &lt;code&gt;React.Component&lt;/code&gt; instead.</source>
          <target state="translated">В случаях, когда вы не можете определить опору статически (например, потому что вам нужно закрыть &lt;code&gt;React.Component&lt;/code&gt; и / или состояние компонента), &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; следует вместо этого расширять React.Component .</target>
        </trans-unit>
        <trans-unit id="d09f5ea2f719cb84240d22955b912b59e89f6fc3" translate="yes" xml:space="preserve">
          <source>In contrast, this function is impure because it changes its own input:</source>
          <target state="translated">Напротив,эта функция загрязнена,так как изменяет свой собственный вход:</target>
        </trans-unit>
        <trans-unit id="ba9a0d3186492384944825ac9b7292279498c6fb" translate="yes" xml:space="preserve">
          <source>In depth: When and why are &lt;code&gt;setState()&lt;/code&gt; calls batched?</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; : когда и почему вызовы setState () группируются ?</target>
        </trans-unit>
        <trans-unit id="e28fdfcba350e9460a5b11538d17a9495f7864ad" translate="yes" xml:space="preserve">
          <source>In depth: Why isn&amp;rsquo;t &lt;code&gt;this.state&lt;/code&gt; updated immediately?</source>
          <target state="translated">&lt;code&gt;this.state&lt;/code&gt; : почему this.state не обновляется немедленно?</target>
        </trans-unit>
        <trans-unit id="c1b95b07888beb397c1c34cba846e81f89eafcbe" translate="yes" xml:space="preserve">
          <source>In either case, we &lt;strong&gt;don&amp;rsquo;t recommend this pattern&lt;/strong&gt; and only show it here for completeness. Instead, it is preferable to &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;avoid passing callbacks deep down&lt;/a&gt;.</source>
          <target state="translated">В любом случае мы &lt;strong&gt;не рекомендуем этот шаблон&lt;/strong&gt; и показываем его здесь только для полноты &lt;strong&gt;картины&lt;/strong&gt; . Вместо этого предпочтительно &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;избегать передачи обратных вызовов глубоко внутри&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9d91c5022448dc96b7db04173ff7b2483babe71" translate="yes" xml:space="preserve">
          <source>In fact, if we open the console, we&amp;rsquo;ll see a warning:</source>
          <target state="translated">Фактически, если мы откроем консоль, мы увидим предупреждение:</target>
        </trans-unit>
        <trans-unit id="f345dbdd77bde7a2de6d314ebebbeb5d11132d71" translate="yes" xml:space="preserve">
          <source>In fact, this is exactly how React is used at Facebook. This lets us write applications in React piece by piece, and combine them with our existing server-generated templates and other client-side code.</source>
          <target state="translated">На самом деле,именно так используется React на Facebook.Это позволяет нам писать приложения в React по частям,и объединять их с нашими существующими серверными шаблонами и другим клиентским кодом.</target>
        </trans-unit>
        <trans-unit id="ffdfd80e389f7e74a49541704e05ae80cc6fc69b" translate="yes" xml:space="preserve">
          <source>In general, we &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; bump the major version number for changes to:</source>
          <target state="translated">Как правило, мы &lt;em&gt;не&lt;/em&gt; увеличиваем основной номер версии для изменений:</target>
        </trans-unit>
        <trans-unit id="7e0726e767128fb2eb99272298da3fc6afa9f477" translate="yes" xml:space="preserve">
          <source>In general, we don&amp;rsquo;t recommend &lt;em&gt;not&lt;/em&gt; passing a value for a prop, because it can be confused with the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6 object shorthand&lt;/a&gt;&lt;code&gt;{foo}&lt;/code&gt; which is short for &lt;code&gt;{foo: foo}&lt;/code&gt; rather than &lt;code&gt;{foo: true}&lt;/code&gt;. This behavior is just there so that it matches the behavior of HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee266aeffd83dee46d08b5a2d9e5dd0db59bd0ba" translate="yes" xml:space="preserve">
          <source>In general, we don&amp;rsquo;t recommend using this because it can be confused with the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6 object shorthand&lt;/a&gt;&lt;code&gt;{foo}&lt;/code&gt; which is short for &lt;code&gt;{foo: foo}&lt;/code&gt; rather than &lt;code&gt;{foo: true}&lt;/code&gt;. This behavior is just there so that it matches the behavior of HTML.</source>
          <target state="translated">В общем, мы не рекомендуем использовать это, потому что его можно спутать с &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;сокращением объекта ES6 &lt;/a&gt; &lt;code&gt;{foo}&lt;/code&gt; , которое является сокращением от &lt;code&gt;{foo: foo}&lt;/code&gt; а не &lt;code&gt;{foo: true}&lt;/code&gt; . Это поведение просто для того, чтобы оно соответствовало поведению HTML.</target>
        </trans-unit>
        <trans-unit id="fb1a71609500b2f5f9daba332366828dbac63210" translate="yes" xml:space="preserve">
          <source>In large component trees, an alternative we recommend is to pass down a &lt;code&gt;dispatch&lt;/code&gt; function from &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; via context:</source>
          <target state="translated">В больших деревьях компонентов альтернативой, которую мы рекомендуем, является передача функции &lt;code&gt;dispatch&lt;/code&gt; от &lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; &lt;/a&gt; через контекст:</target>
        </trans-unit>
        <trans-unit id="ba93ca3416f3cbfccc68a69a219fb2048e2dc7a7" translate="yes" xml:space="preserve">
          <source>In many cases it&amp;rsquo;s not possible to break these components into smaller ones because the stateful logic is all over the place. It&amp;rsquo;s also difficult to test them. This is one of the reasons many people prefer to combine React with a separate state management library. However, that often introduces too much abstraction, requires you to jump between different files, and makes reusing components more difficult.</source>
          <target state="translated">Во многих случаях невозможно разбить эти компоненты на более мелкие, потому что логика с отслеживанием состояния присутствует повсюду. Их тоже сложно проверить. Это одна из причин, по которой многие люди предпочитают комбинировать React с отдельной библиотекой управления состоянием. Однако это часто приводит к слишком большой абстракции, требует переключения между разными файлами и затрудняет повторное использование компонентов.</target>
        </trans-unit>
        <trans-unit id="c3440d610e4a5c2ec2cdeed99640aaa90c65f21a" translate="yes" xml:space="preserve">
          <source>In more complex cases (such as if one state depends on another state), try moving the state update logic outside the effect with the &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt; Hook&lt;/a&gt;. &lt;a href=&quot;https://adamrackis.dev/state-and-use-reducer/&quot;&gt;This article&lt;/a&gt; offers an example of how you can do this. &lt;strong&gt;The identity of the &lt;code&gt;dispatch&lt;/code&gt; function from &lt;code&gt;useReducer&lt;/code&gt; is always stable&lt;/strong&gt; &amp;mdash; even if the reducer function is declared inside the component and reads its props.</source>
          <target state="translated">В более сложных случаях (например, если один состояние зависит от другого государства), попытайтесь переместить логику обновления состояния вне эффекта с &lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; Hook&lt;/a&gt; . &lt;a href=&quot;https://adamrackis.dev/state-and-use-reducer/&quot;&gt;В этой статье&lt;/a&gt; предлагается пример того, как это можно сделать. &lt;strong&gt;Идентификатор функции &lt;code&gt;dispatch&lt;/code&gt; из &lt;code&gt;useReducer&lt;/code&gt; всегда стабилен,&lt;/strong&gt; даже если функция-редуктор объявлена ​​внутри компонента и считывает его свойства.</target>
        </trans-unit>
        <trans-unit id="ea3661ac2ed158cad82144227101fb280362b435" translate="yes" xml:space="preserve">
          <source>In most cases you should use controlled components.</source>
          <target state="translated">В большинстве случаев следует использовать контролируемые компоненты.</target>
        </trans-unit>
        <trans-unit id="4a7abdefe6c187e6dc04e0d7f5c214840047bcdd" translate="yes" xml:space="preserve">
          <source>In most cases, instead of writing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; by hand, you can inherit from &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt;. It is equivalent to implementing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; with a shallow comparison of current and previous props and state.</source>
          <target state="translated">В большинстве случаев вместо того, чтобы писать &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; вручную, вы можете наследовать от &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt; &lt;code&gt;React.PureComponent&lt;/code&gt; &lt;/a&gt; . Это эквивалентно реализации &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; с поверхностным сравнением текущих и предыдущих свойств и состояния.</target>
        </trans-unit>
        <trans-unit id="cbad587d21c37cda62d8252410ab69d53dfcaebf" translate="yes" xml:space="preserve">
          <source>In most cases, jsdom behaves like a regular browser would, but doesn&amp;rsquo;t have features like &lt;a href=&quot;https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform&quot;&gt;layout and navigation&lt;/a&gt;. This is still useful for most web-based component tests, since it runs quicker than having to start up a browser for each test. It also runs in the same process as your tests, so you can write code to examine and assert on the rendered DOM.</source>
          <target state="translated">В большинстве случаев jsdom ведет себя как обычный браузер, но не имеет таких функций, как &lt;a href=&quot;https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform&quot;&gt;макет и навигация&lt;/a&gt; . Это по-прежнему полезно для большинства тестов веб-компонентов, поскольку оно выполняется быстрее, чем необходимость запускать браузер для каждого теста. Он также выполняется в том же процессе, что и ваши тесты, поэтому вы можете написать код для проверки и утверждения на визуализированной DOM.</target>
        </trans-unit>
        <trans-unit id="1911017bb2356e24f2e7725ec8dd38cb5980645a" translate="yes" xml:space="preserve">
          <source>In most cases, we recommend using &lt;a href=&quot;forms#controlled-components&quot;&gt;controlled components&lt;/a&gt; to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself.</source>
          <target state="translated">В большинстве случаев мы рекомендуем использовать &lt;a href=&quot;forms#controlled-components&quot;&gt;контролируемые компоненты&lt;/a&gt; для реализации форм. В управляемом компоненте данные формы обрабатываются компонентом React. Альтернативой являются неконтролируемые компоненты, в которых данные формы обрабатываются самой DOM.</target>
        </trans-unit>
        <trans-unit id="6d3c1b36b4f10f7bf6d14d76f2b5886538fe9af9" translate="yes" xml:space="preserve">
          <source>In order to solve this issue, React supports a &lt;code&gt;key&lt;/code&gt; attribute. When children have keys, React uses the key to match children in the original tree with children in the subsequent tree. For example, adding a &lt;code&gt;key&lt;/code&gt; to our inefficient example above can make the tree conversion efficient:</source>
          <target state="translated">Чтобы решить эту проблему, React поддерживает &lt;code&gt;key&lt;/code&gt; атрибут. Когда у потомков есть ключи, React использует ключ для сопоставления потомков в исходном дереве с потомками в последующем дереве. Например, добавление &lt;code&gt;key&lt;/code&gt; в наш неэффективный пример выше может сделать преобразование дерева эффективным:</target>
        </trans-unit>
        <trans-unit id="9b6804b7a0eea45b9845222ba70ab59b4cf0b8e7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;connect&lt;/code&gt; is a higher-order function that returns a higher-order component!</source>
          <target state="translated">Другими словами, &lt;code&gt;connect&lt;/code&gt; - это функция высшего порядка, которая возвращает компонент более высокого порядка!</target>
        </trans-unit>
        <trans-unit id="80f812104a6e940fb1554b3b0a149eca257b5c85" translate="yes" xml:space="preserve">
          <source>In our example, we already have two state variables. The input text is in &lt;code&gt;query&lt;/code&gt;, and we read the translation from &lt;code&gt;resource&lt;/code&gt;. We want changes to the &lt;code&gt;query&lt;/code&gt; state to happen immediately, but changes to the &lt;code&gt;resource&lt;/code&gt; (i.e. fetching a new translation) should trigger a transition.</source>
          <target state="translated">В нашем примере у нас уже есть две переменные состояния. Введенный текст находится в &lt;code&gt;query&lt;/code&gt; , и мы читаем перевод с &lt;code&gt;resource&lt;/code&gt; . Мы хотим, чтобы изменения в состоянии &lt;code&gt;query&lt;/code&gt; происходили немедленно, но изменения &lt;code&gt;resource&lt;/code&gt; (то есть получение нового перевода) должны запускать переход.</target>
        </trans-unit>
        <trans-unit id="2e399b2e569c6a0bcf071e62ad256ed5a3d201d7" translate="yes" xml:space="preserve">
          <source>In our experience, code that uses idiomatic React patterns and doesn&amp;rsquo;t rely on external state management solutions is the easiest to get running in the Concurrent Mode. We will describe common problems we&amp;rsquo;ve seen and the solutions to them separately in the coming weeks.</source>
          <target state="translated">По нашему опыту, код, который использует идиоматические шаблоны React и не полагается на решения для управления внешним состоянием, проще всего запустить в параллельном режиме. В ближайшие недели мы отдельно опишем типичные проблемы, которые мы видели, и их решения.</target>
        </trans-unit>
        <trans-unit id="3a945c86c779350192d3215abb4afd0b7e2b4ebf" translate="yes" xml:space="preserve">
          <source>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</source>
          <target state="translated">По нашему опыту,размышления о том,как должен выглядеть пользовательский интерфейс в любой момент,а не о том,как его менять с течением времени,устраняют целый класс ошибок.</target>
        </trans-unit>
        <trans-unit id="2c952c1cb63d7f6dce2e3deb06b435fa75cedd7a" translate="yes" xml:space="preserve">
          <source>In our experience, thinking about how the UI should look at any given moment, rather than how to change it over time, eliminates a whole class of bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d3facfdb5b3a33c51c1e47e735a86dc335c375" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;this.props.children&lt;/code&gt; is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.</source>
          <target state="translated">В частности, &lt;code&gt;this.props.children&lt;/code&gt; - это специальная опора, обычно определяемая дочерними тегами в выражении JSX, а не в самом теге.</target>
        </trans-unit>
        <trans-unit id="ff52786b96cb28b8516c4c77d035f3f94ffa6e3e" translate="yes" xml:space="preserve">
          <source>In particular, the rule enforces that:</source>
          <target state="translated">В частности,правило обеспечивает это:</target>
        </trans-unit>
        <trans-unit id="0d696f2b7ef6c0b071645ffc121cc67457984603" translate="yes" xml:space="preserve">
          <source>In practice, finding a key is usually not hard. The element you are going to display may already have a unique ID, so the key can just come from your data:</source>
          <target state="translated">На практике найти ключ обычно не сложно.Элемент,который вы собираетесь вывести на экран,может уже иметь уникальный идентификатор,поэтому ключ может просто прийти из ваших данных:</target>
        </trans-unit>
        <trans-unit id="c43f54f78b227de9a41edca0fcd34399cba7c611" translate="yes" xml:space="preserve">
          <source>In practice, most React apps only call &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; once. In the next sections we will learn how such code gets encapsulated into &lt;a href=&quot;state-and-lifecycle&quot;&gt;stateful components&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade1231470ce955a57c66a5a4a65595e2c307122" translate="yes" xml:space="preserve">
          <source>In practice, most React apps only call &lt;code&gt;ReactDOM.render()&lt;/code&gt; once. In the next sections we will learn how such code gets encapsulated into &lt;a href=&quot;state-and-lifecycle&quot;&gt;stateful components&lt;/a&gt;.</source>
          <target state="translated">На практике большинство приложений React вызывают &lt;code&gt;ReactDOM.render()&lt;/code&gt; только один раз. В следующих разделах мы узнаем, как такой код инкапсулируется в &lt;a href=&quot;state-and-lifecycle&quot;&gt;компоненты с отслеживанием состояния&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="909459ee6d5f8fcf3afdeb0255be50e086b6e528" translate="yes" xml:space="preserve">
          <source>In practice, these assumptions are valid for almost all practical use cases.</source>
          <target state="translated">На практике эти допущения справедливы почти для всех случаев практического использования.</target>
        </trans-unit>
        <trans-unit id="3d0b8aeba59f064eef6dc0b26b57e2face696137" translate="yes" xml:space="preserve">
          <source>In practice, we expect that most apps using Legacy Mode today should be able to migrate at least to the Blocking Mode (if not Concurrent Mode). This fragmentation can be annoying for libraries that aim to support all Modes in the short term. However, gradually moving the ecosystem away from the Legacy Mode will also &lt;em&gt;solve&lt;/em&gt; problems that affect major libraries in the React ecosystem, such as &lt;a href=&quot;https://github.com/facebook/react/issues/14536&quot;&gt;confusing Suspense behavior when reading layout&lt;/a&gt; and &lt;a href=&quot;https://github.com/facebook/react/issues/15080&quot;&gt;lack of consistent batching guarantees&lt;/a&gt;. There&amp;rsquo;s a number of bugs that can&amp;rsquo;t be fixed in Legacy Mode without changing semantics, but don&amp;rsquo;t exist in Blocking and Concurrent Modes.</source>
          <target state="translated">На практике мы ожидаем, что большинство приложений, использующих устаревший режим сегодня, смогут перейти по крайней мере в режим блокировки (если не в параллельный режим). Эта фрагментация может раздражать библиотеки, которые стремятся поддерживать все режимы в краткосрочной перспективе. Однако постепенный переход экосистемы от устаревшего режима также &lt;em&gt;решит&lt;/em&gt; проблемы, которые влияют на основные библиотеки в экосистеме React, такие как &lt;a href=&quot;https://github.com/facebook/react/issues/14536&quot;&gt;запутанное поведение Suspense при чтении макета&lt;/a&gt; и &lt;a href=&quot;https://github.com/facebook/react/issues/15080&quot;&gt;отсутствие согласованных гарантий пакетной обработки&lt;/a&gt; . Есть ряд ошибок, которые нельзя исправить в устаревшем режиме без изменения семантики, но которых нет в блокирующем и параллельном режимах.</target>
        </trans-unit>
        <trans-unit id="6b279656dca3be237f10a8565147d5f390d7e94e" translate="yes" xml:space="preserve">
          <source>In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return &lt;code&gt;null&lt;/code&gt; instead of its render output.</source>
          <target state="translated">В редких случаях может потребоваться, чтобы компонент скрывался, даже если он был визуализирован другим компонентом. Для этого верните &lt;code&gt;null&lt;/code&gt; вместо вывода рендеринга.</target>
        </trans-unit>
        <trans-unit id="0a098d464d31796bcdd791f834a68bda2df286c2" translate="yes" xml:space="preserve">
          <source>In rare cases, you may be running a test on a component that uses multiple renderers. For example, you may be running snapshot tests on a component with &lt;code&gt;react-test-renderer&lt;/code&gt;, that internally uses &lt;code&gt;ReactDOM.render&lt;/code&gt; inside a child component to render some content. In this scenario, you can wrap updates with &lt;code&gt;act()&lt;/code&gt;s corresponding to their renderers.</source>
          <target state="translated">В редких случаях вы можете запускать тест на компоненте, который использует несколько средств визуализации. Например, вы можете запускать тесты моментальных снимков для компонента с помощью &lt;code&gt;ReactDOM.render&lt;/code&gt; &lt;code&gt;react-test-renderer&lt;/code&gt; , который внутренне использует ReactDOM.render внутри дочернего компонента для визуализации некоторого содержимого. В этом сценарии вы можете заключить обновления в &lt;code&gt;act()&lt;/code&gt; соответствующие их средствам визуализации.</target>
        </trans-unit>
        <trans-unit id="04d050c85bc701c68bd6d50bf673ea61647fdec4" translate="yes" xml:space="preserve">
          <source>In rare cases, you might want to have access to a child&amp;rsquo;s DOM node from a parent component. This is generally not recommended because it breaks component encapsulation, but it can occasionally be useful for triggering focus or measuring the size or position of a child DOM node.</source>
          <target state="translated">В редких случаях вам может потребоваться доступ к дочернему узлу DOM из родительского компонента. Обычно это не рекомендуется, потому что это нарушает инкапсуляцию компонентов, но иногда может быть полезно для запуска фокуса или измерения размера или положения дочернего узла DOM.</target>
        </trans-unit>
        <trans-unit id="c6863ffdd3d1c41a019b99c0ce9ef587c06e42de" translate="yes" xml:space="preserve">
          <source>In some browsers we can easily view the accessibility information for each element in the accessibility tree:</source>
          <target state="translated">В некоторых браузерах мы можем легко просматривать информацию о доступности для каждого элемента дерева доступности:</target>
        </trans-unit>
        <trans-unit id="ef7f108e140b39155a7e18cc38167a7857627734" translate="yes" xml:space="preserve">
          <source>In some cases formatting a value for display might be an expensive operation. It&amp;rsquo;s also unnecessary unless a Hook is actually inspected.</source>
          <target state="translated">В некоторых случаях форматирование значения для отображения может оказаться дорогостоящей операцией. Это также не нужно, если только крючок не проверен.</target>
        </trans-unit>
        <trans-unit id="abfe23fc439cd1390e394329a6ecb1eeec14f4b5" translate="yes" xml:space="preserve">
          <source>In some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with &lt;code&gt;prevProps&lt;/code&gt; or &lt;code&gt;prevState&lt;/code&gt; inside &lt;code&gt;componentDidUpdate&lt;/code&gt;:</source>
          <target state="translated">В некоторых случаях очистка или применение эффекта после каждого рендеринга может вызвать проблемы с производительностью. В компонентах класса мы можем решить эту проблему, написав дополнительное сравнение с &lt;code&gt;prevProps&lt;/code&gt; или &lt;code&gt;prevState&lt;/code&gt; внутри &lt;code&gt;componentDidUpdate&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="110ae94bd79008897c0972ade096014f8e0302a9" translate="yes" xml:space="preserve">
          <source>In some rare cases you might need to memoize a callback with &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; but the memoization doesn&amp;rsquo;t work very well because the inner function has to be re-created too often. If the function you&amp;rsquo;re memoizing is an event handler and isn&amp;rsquo;t used during rendering, you can use &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;ref as an instance variable&lt;/a&gt;, and save the last committed value into it manually:</source>
          <target state="translated">В некоторых редких случаях вам может потребоваться &lt;a href=&quot;hooks-reference#usecallback&quot;&gt; &lt;code&gt;useCallback&lt;/code&gt; &lt;/a&gt; обратный вызов с помощью useCallback, но мемоизация работает не очень хорошо, потому что внутренняя функция должна создаваться повторно. Если функция, которую вы запоминаете, является обработчиком событий и не используется во время рендеринга, вы можете использовать &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;ref в качестве переменной экземпляра&lt;/a&gt; и сохранить в ней последнее зафиксированное значение вручную:</target>
        </trans-unit>
        <trans-unit id="0c1cdbd6853a083ca4623e0db98a09dc4da4738b" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;development&lt;/strong&gt; mode, you can visualize how components mount, update, and unmount, using the performance tools in supported browsers. For example:</source>
          <target state="translated">В режиме &lt;strong&gt;разработки&lt;/strong&gt; вы можете визуализировать, как компоненты монтируются, обновляются и отключаются, используя инструменты производительности в поддерживаемых браузерах. Например:</target>
        </trans-unit>
        <trans-unit id="f0b550316b6eedb96eacfc072502ecdd2917564a" translate="yes" xml:space="preserve">
          <source>In the React rendering lifecycle, the &lt;code&gt;value&lt;/code&gt; attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a &lt;code&gt;defaultValue&lt;/code&gt; attribute instead of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">В жизненном цикле отрисовки React атрибут &lt;code&gt;value&lt;/code&gt; в элементах формы переопределит значение в DOM. С неконтролируемым компонентом вы часто хотите, чтобы React указывал начальное значение, но оставлял последующие обновления неконтролируемыми. Чтобы справиться с этим случаем, вы можете указать атрибут &lt;code&gt;defaultValue&lt;/code&gt; вместо &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d3c7fd4b516fb9bcad29f73328ec8f65a7430fc" translate="yes" xml:space="preserve">
          <source>In the React rendering lifecycle, the &lt;code&gt;value&lt;/code&gt; attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a &lt;code&gt;defaultValue&lt;/code&gt; attribute instead of &lt;code&gt;value&lt;/code&gt;. Changing the value of &lt;code&gt;defaultValue&lt;/code&gt; attribute after a component has mounted will not cause any update of the value in the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903bb48f1156a6b0ac31b18a1cbe3d5dc1be1cc3" translate="yes" xml:space="preserve">
          <source>In the above component, we have &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;fruit&lt;/code&gt;, and &lt;code&gt;todos&lt;/code&gt; as local variables, and we can update them individually:</source>
          <target state="translated">В приведенном выше компоненте у нас есть &lt;code&gt;age&lt;/code&gt; , &lt;code&gt;fruit&lt;/code&gt; и &lt;code&gt;todos&lt;/code&gt; в качестве локальных переменных, и мы можем обновлять их индивидуально:</target>
        </trans-unit>
        <trans-unit id="4d1e3bc1269742bd242168387646a23702e59a34" translate="yes" xml:space="preserve">
          <source>In the above example, React passes a &lt;code&gt;ref&lt;/code&gt; given to &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; element as a second argument to the rendering function inside the &lt;code&gt;React.forwardRef&lt;/code&gt; call. This rendering function passes the &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">В приведенном выше примере, React проходит &lt;code&gt;ref&lt;/code&gt; данное &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; элемента в качестве второго аргумента функции рендеринга внутри &lt;code&gt;React.forwardRef&lt;/code&gt; вызова. Эта функция рендеринга передает &lt;code&gt;ref&lt;/code&gt; на &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; элемента.</target>
        </trans-unit>
        <trans-unit id="ccb9604592cfa6b12895f257ac0c24ea334d72d8" translate="yes" xml:space="preserve">
          <source>In the above example, strict mode checks will &lt;em&gt;not&lt;/em&gt; be run against the &lt;code&gt;Header&lt;/code&gt; and &lt;code&gt;Footer&lt;/code&gt; components. However, &lt;code&gt;ComponentOne&lt;/code&gt; and &lt;code&gt;ComponentTwo&lt;/code&gt;, as well as all of their descendants, will have the checks.</source>
          <target state="translated">В приведенном выше примере проверки в строгом режиме &lt;em&gt;не&lt;/em&gt; будут выполняться для компонентов &lt;code&gt;Header&lt;/code&gt; и &lt;code&gt;Footer&lt;/code&gt; . Однако &lt;code&gt;ComponentOne&lt;/code&gt; и &lt;code&gt;ComponentTwo&lt;/code&gt; , а также все их потомки будут иметь проверки.</target>
        </trans-unit>
        <trans-unit id="161b69b6d458031682de9bd001c8a47eb9f053a9" translate="yes" xml:space="preserve">
          <source>In the above examples, it is important to read the &lt;code&gt;scrollHeight&lt;/code&gt; property in &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; because there may be delays between &amp;ldquo;render&amp;rdquo; phase lifecycles (like &lt;code&gt;render&lt;/code&gt;) and &amp;ldquo;commit&amp;rdquo; phase lifecycles (like &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;).</source>
          <target state="translated">В приведенных выше примерах важно прочитать свойство &lt;code&gt;scrollHeight&lt;/code&gt; в &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; , потому что могут быть задержки между жизненными &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; фазы &amp;laquo;рендеринга&amp;raquo; (например, &lt;code&gt;render&lt;/code&gt; ) и жизненными циклами фазы &amp;laquo;фиксация&amp;raquo; (например, getSnapshotBeforeUpdate и &lt;code&gt;componentDidUpdate&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1492c41f81989404e70e8f6aae15b755c6639ac" translate="yes" xml:space="preserve">
          <source>In the beginning, our stated goal was to remove the duplicated logic from the &lt;code&gt;FriendStatus&lt;/code&gt; and &lt;code&gt;FriendListItem&lt;/code&gt; components. Both of them want to know whether a friend is online.</source>
          <target state="translated">Вначале нашей заявленной целью было удалить повторяющуюся логику из компонентов &lt;code&gt;FriendStatus&lt;/code&gt; и &lt;code&gt;FriendListItem&lt;/code&gt; . Они оба хотят знать, в сети ли их друг.</target>
        </trans-unit>
        <trans-unit id="c894c3353cd13202ba9261426d4b8ea1935aef6a" translate="yes" xml:space="preserve">
          <source>In the cron job, update your React packages to the most recent React release in the Next channel, using &lt;code&gt;next&lt;/code&gt; tag on npm. Using the npm cli:</source>
          <target state="translated">В задании cron обновите свои пакеты React до самой последней версии React в канале Next, используя тег &lt;code&gt;next&lt;/code&gt; в npm. Используя npm cli:</target>
        </trans-unit>
        <trans-unit id="2fe2f07417c38339db698cf1646bb4c866463cd8" translate="yes" xml:space="preserve">
          <source>In the event of an error, you can render a fallback UI with &lt;code&gt;componentDidCatch()&lt;/code&gt; by calling &lt;code&gt;setState&lt;/code&gt;, but this will be deprecated in a future release. Use &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; to handle fallback rendering instead.</source>
          <target state="translated">В случае ошибки вы можете отобразить резервный пользовательский интерфейс с помощью &lt;code&gt;componentDidCatch()&lt;/code&gt; , вызвав &lt;code&gt;setState&lt;/code&gt; , но в будущих версиях это будет устаревшим. &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; используйте статический getDerivedStateFromError () для обработки резервной отрисовки.</target>
        </trans-unit>
        <trans-unit id="81bc674a950124866a089232847d2007a365dc48" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;Parent&lt;/code&gt; passes its ref callback as an &lt;code&gt;inputRef&lt;/code&gt; prop to the &lt;code&gt;CustomTextInput&lt;/code&gt;, and the &lt;code&gt;CustomTextInput&lt;/code&gt; passes the same function as a special &lt;code&gt;ref&lt;/code&gt; attribute to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. As a result, &lt;code&gt;this.inputElement&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt; will be set to the DOM node corresponding to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element in the &lt;code&gt;CustomTextInput&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;Parent&lt;/code&gt; передает свой обратный вызов ref как &lt;code&gt;inputRef&lt;/code&gt; в &lt;code&gt;CustomTextInput&lt;/code&gt; , а &lt;code&gt;CustomTextInput&lt;/code&gt; передает ту же функцию, что и специальный атрибут &lt;code&gt;ref&lt;/code&gt; , в &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; . В результате &lt;code&gt;this.inputElement&lt;/code&gt; в &lt;code&gt;Parent&lt;/code&gt; будет установлен на узел DOM, соответствующий элементу &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; в &lt;code&gt;CustomTextInput&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78bb563116bb5963983d968cb91e61df5f00f963" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;kind&lt;/code&gt; prop is safely consumed and &lt;em&gt;is not&lt;/em&gt; passed on to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element in the DOM. All other props are passed via the &lt;code&gt;...other&lt;/code&gt; object making this component really flexible. You can see that it passes an &lt;code&gt;onClick&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; props.</source>
          <target state="translated">В приведенном выше примере свойство &lt;code&gt;kind&lt;/code&gt; безопасно потребляется и &lt;em&gt;не&lt;/em&gt; передается в элемент &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; в DOM. Все остальные свойства передаются через объект &lt;code&gt;...other&lt;/code&gt; , что делает этот компонент действительно гибким. Вы можете видеть, что он передает реквизиты &lt;code&gt;onClick&lt;/code&gt; и &lt;code&gt;children&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50c03112f0e316b498156bed257c2771954012e9" translate="yes" xml:space="preserve">
          <source>In the example above, we pass &lt;code&gt;[count]&lt;/code&gt; as the second argument. What does this mean? If the &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;5&lt;/code&gt;, and then our component re-renders with &lt;code&gt;count&lt;/code&gt; still equal to &lt;code&gt;5&lt;/code&gt;, React will compare &lt;code&gt;[5]&lt;/code&gt; from the previous render and &lt;code&gt;[5]&lt;/code&gt; from the next render. Because all items in the array are the same (&lt;code&gt;5 === 5&lt;/code&gt;), React would skip the effect. That&amp;rsquo;s our optimization.</source>
          <target state="translated">В приведенном выше примере мы передаем &lt;code&gt;[count]&lt;/code&gt; в качестве второго аргумента. Что это значит? Если &lt;code&gt;count&lt;/code&gt; равен &lt;code&gt;5&lt;/code&gt; , а затем наш компонент выполняет повторный рендеринг со &lt;code&gt;count&lt;/code&gt; прежнему равным &lt;code&gt;5&lt;/code&gt; , React сравнит &lt;code&gt;[5]&lt;/code&gt; из предыдущего рендеринга и &lt;code&gt;[5]&lt;/code&gt; из следующего рендеринга. Поскольку все элементы в массиве одинаковы ( &lt;code&gt;5 === 5&lt;/code&gt; ), React пропустит эффект. Это наша оптимизация.</target>
        </trans-unit>
        <trans-unit id="b7c3d10a47d45d9cf31357af92cb4eff75e31bc3" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;FancyButton&lt;/code&gt; uses &lt;code&gt;React.forwardRef&lt;/code&gt; to obtain the &lt;code&gt;ref&lt;/code&gt; passed to it, and then forward it to the DOM &lt;code&gt;button&lt;/code&gt; that it renders:</source>
          <target state="translated">В приведенном ниже примере &lt;code&gt;FancyButton&lt;/code&gt; использует &lt;code&gt;React.forwardRef&lt;/code&gt; для получения переданной ему &lt;code&gt;ref&lt;/code&gt; , а затем перенаправляет ее на &lt;code&gt;button&lt;/code&gt; DOM , которую он отображает:</target>
        </trans-unit>
        <trans-unit id="da172bb676090bc853f066f60868863ede80ccc2" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;&amp;lt;WarningBanner /&amp;gt;&lt;/code&gt; is rendered depending on the value of the prop called &lt;code&gt;warn&lt;/code&gt;. If the value of the prop is &lt;code&gt;false&lt;/code&gt;, then the component does not render:</source>
          <target state="translated">В приведенном ниже примере &lt;code&gt;&amp;lt;WarningBanner /&amp;gt;&lt;/code&gt; отображается в зависимости от значения свойства с именем &lt;code&gt;warn&lt;/code&gt; . Если значение свойства равно &lt;code&gt;false&lt;/code&gt; , компонент не отображает:</target>
        </trans-unit>
        <trans-unit id="4c9b0d091cbcaeb26aef58746ea16d7326d16599" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;List&lt;/code&gt; component renders a Backbone collection, using the &lt;code&gt;Item&lt;/code&gt; component to render individual items.</source>
          <target state="translated">В приведенном ниже примере компонент &lt;code&gt;List&lt;/code&gt; отображает коллекцию Backbone, используя компонент &lt;code&gt;Item&lt;/code&gt; для визуализации отдельных элементов.</target>
        </trans-unit>
        <trans-unit id="132775b1447feeefec74e2f18536a9d528215b18" translate="yes" xml:space="preserve">
          <source>In the example below, we declare a variable called &lt;code&gt;name&lt;/code&gt; and then use it inside JSX by wrapping it in curly braces:</source>
          <target state="translated">В приведенном ниже примере мы объявляем переменную с именем &lt;code&gt;name&lt;/code&gt; , а затем используем ее внутри JSX, заключая ее в фигурные скобки:</target>
        </trans-unit>
        <trans-unit id="d7dd67cb57a4dc9f027ea3f3b201e027d6f0cf20" translate="yes" xml:space="preserve">
          <source>In the example below, we embed the result of calling a JavaScript function, &lt;code&gt;formatName(user)&lt;/code&gt;, into an &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">В приведенном ниже примере мы встраиваем результат вызова функции JavaScript, &lt;code&gt;formatName(user)&lt;/code&gt; , в элемент &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e50a991765ef6cc4009766a397d70d227449d563" translate="yes" xml:space="preserve">
          <source>In the example below, we use it to conditionally render a small block of text.</source>
          <target state="translated">В приведенном ниже примере мы используем его для условного отображения небольшого блока текста.</target>
        </trans-unit>
        <trans-unit id="d3bfcd8d3b96478cd697022392b9e4b2c38089ff" translate="yes" xml:space="preserve">
          <source>In the example below, we will create a &lt;a href=&quot;state-and-lifecycle#adding-local-state-to-a-class&quot;&gt;stateful component&lt;/a&gt; called &lt;code&gt;LoginControl&lt;/code&gt;.</source>
          <target state="translated">В приведенном ниже примере мы создадим &lt;a href=&quot;state-and-lifecycle#adding-local-state-to-a-class&quot;&gt;компонент с &lt;/a&gt; &lt;code&gt;LoginControl&lt;/code&gt; состояния под названием LoginControl .</target>
        </trans-unit>
        <trans-unit id="6b92032c1bbddab0648c95b3163a2986b7e77271" translate="yes" xml:space="preserve">
          <source>In the example below, we will make a copy of the model&amp;rsquo;s attributes to form the initial state. We subscribe to the &lt;code&gt;change&lt;/code&gt; event (and unsubscribe on unmounting), and when it happens, we update the state with the model&amp;rsquo;s current attributes. Finally, we make sure that if the &lt;code&gt;model&lt;/code&gt; prop itself changes, we don&amp;rsquo;t forget to unsubscribe from the old model, and subscribe to the new one.</source>
          <target state="translated">В приведенном ниже примере мы сделаем копию атрибутов модели, чтобы сформировать начальное состояние. Мы подписываемся на событие &lt;code&gt;change&lt;/code&gt; (и отказываемся от подписки при отключении), и когда это происходит, мы обновляем состояние текущими атрибутами модели. Наконец, мы следим за тем, чтобы при изменении самого свойства &lt;code&gt;model&lt;/code&gt; мы не забывали отказаться от подписки на старую модель и подписаться на новую.</target>
        </trans-unit>
        <trans-unit id="63df20cb3c0206857b6eb72aa649ffbe4eec47b7" translate="yes" xml:space="preserve">
          <source>In the examples above we declared a separate &lt;code&gt;listItems&lt;/code&gt; variable and included it in JSX:</source>
          <target state="translated">В приведенных выше примерах мы объявили отдельную переменную &lt;code&gt;listItems&lt;/code&gt; и включили ее в JSX:</target>
        </trans-unit>
        <trans-unit id="ee218035757e1dcb006cf4b284261900739df97e" translate="yes" xml:space="preserve">
          <source>In the examples above, we only relied on features that are natively supported by the browsers. This is why we used a JavaScript function call to tell React what to display:</source>
          <target state="translated">В приведенных выше примерах мы полагались только на те возможности,которые нативно поддерживаются браузерами.Поэтому мы использовали вызов JavaScript-функции,чтобы сказать React,что отображать:</target>
        </trans-unit>
        <trans-unit id="d4709b211731b0d98acf24cd2d4b4c0e25f437be" translate="yes" xml:space="preserve">
          <source>In the future, the second argument might get added automatically by a build-time transformation.</source>
          <target state="translated">В будущем второй аргумент может быть добавлен автоматически путем преобразования во времени сборки.</target>
        </trans-unit>
        <trans-unit id="8be1cdda076b922dcae71dadf71ff42ad65b19bd" translate="yes" xml:space="preserve">
          <source>In the long term, we intend Suspense to become the primary way to read asynchronous data from components &amp;mdash; no matter where that data is coming from.</source>
          <target state="translated">В долгосрочной перспективе мы стремимся к тому, чтобы приостановка стала основным способом чтения асинхронных данных из компонентов - независимо от того, откуда эти данные поступают.</target>
        </trans-unit>
        <trans-unit id="067bfddcfac5a573b68db915d05c5417e983d5ef" translate="yes" xml:space="preserve">
          <source>In the past, JavaScript errors inside components used to corrupt React&amp;rsquo;s internal state and cause it to &lt;a href=&quot;https://github.com/facebook/react/issues/4026&quot;&gt;emit&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/6895&quot;&gt;cryptic&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/8579&quot;&gt;errors&lt;/a&gt; on next renders. These errors were always caused by an earlier error in the application code, but React did not provide a way to handle them gracefully in components, and could not recover from them.</source>
          <target state="translated">В прошлом ошибка JavaScript внутри компонентов , используемых для коррумпированного РЕАКТА внутреннего состояния и привести к ее &lt;a href=&quot;https://github.com/facebook/react/issues/4026&quot;&gt;испускают &lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/6895&quot;&gt;загадочные &lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/8579&quot;&gt;ошибки&lt;/a&gt; на следующем делает. Эти ошибки всегда были вызваны более ранней ошибкой в ​​коде приложения, но React не предоставлял способ корректно обрабатывать их в компонентах и ​​не мог исправить их.</target>
        </trans-unit>
        <trans-unit id="1d1757c6b2b83b26c148e1fe2455fe52c634722f" translate="yes" xml:space="preserve">
          <source>In the previous Suspense example, we only had one &lt;code&gt;resource&lt;/code&gt;, so we held it in a top-level variable. Now that we have multiple resources, we moved it to the &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt;&amp;rsquo;s component state:</source>
          <target state="translated">В предыдущем примере Suspense у нас был только один &lt;code&gt;resource&lt;/code&gt; , поэтому мы сохранили его в переменной верхнего уровня. Теперь, когда у нас есть несколько ресурсов, мы переместили их в состояние компонента &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fbb97b6fdd583b9cf2c6eeadfbb049b439293e48" translate="yes" xml:space="preserve">
          <source>In the previous approach, we fetched data before we called &lt;code&gt;setState&lt;/code&gt;:</source>
          <target state="translated">В предыдущем подходе мы &lt;code&gt;setState&lt;/code&gt; данные перед вызовом setState :</target>
        </trans-unit>
        <trans-unit id="c0baea048f9023ac78378921b5cbb9d00932c292" translate="yes" xml:space="preserve">
          <source>In the typical React dataflow, &lt;a href=&quot;components-and-props&quot;&gt;props&lt;/a&gt; are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.</source>
          <target state="translated">В типичных Реагировать поток данных, &lt;a href=&quot;components-and-props&quot;&gt;реквизит&lt;/a&gt; является единственным способом , что родительские компоненты взаимодействуют со своими детьми. Чтобы изменить дочерний элемент, вы повторно визуализируете его с новыми реквизитами. Однако есть несколько случаев, когда вам нужно обязательно изменить дочерний элемент за пределами обычного потока данных. Изменяемый дочерний элемент может быть экземпляром компонента React или элементом DOM. Для обоих этих случаев React предоставляет аварийный выход.</target>
        </trans-unit>
        <trans-unit id="a86357d07cf0dbd879f2bd26a66e1afff5014629" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;shouldComponentUpdate&lt;/code&gt; is just checking if there is any change in &lt;code&gt;props.color&lt;/code&gt; or &lt;code&gt;state.count&lt;/code&gt;. If those values don&amp;rsquo;t change, the component doesn&amp;rsquo;t update. If your component got more complex, you could use a similar pattern of doing a &amp;ldquo;shallow comparison&amp;rdquo; between all the fields of &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; to determine if the component should update. This pattern is common enough that React provides a helper to use this logic - just inherit from &lt;code&gt;React.PureComponent&lt;/code&gt;. So this code is a simpler way to achieve the same thing:</source>
          <target state="translated">В этом коде &lt;code&gt;shouldComponentUpdate&lt;/code&gt; просто проверяет, есть ли какие-либо изменения в &lt;code&gt;props.color&lt;/code&gt; или &lt;code&gt;state.count&lt;/code&gt; . Если эти значения не меняются, компонент не обновляется. Если ваш компонент стал более сложным, вы могли бы использовать аналогичный шаблон выполнения &amp;laquo;неглубокого сравнения&amp;raquo; между всеми полями &lt;code&gt;props&lt;/code&gt; и &lt;code&gt;state&lt;/code&gt; чтобы определить, следует ли обновлять компонент. Этот шаблон достаточно распространен, поэтому React предоставляет помощника для использования этой логики - просто наследуйте от &lt;code&gt;React.PureComponent&lt;/code&gt; . Итак, этот код - более простой способ добиться того же:</target>
        </trans-unit>
        <trans-unit id="9baf7530f7f1f0cc2de7e8a95550b370cd39a79c" translate="yes" xml:space="preserve">
          <source>In this code, we&amp;rsquo;ve wrapped our data fetching with &lt;code&gt;startTransition&lt;/code&gt;. This allows us to start fetching the profile data right away, while deferring the render of the next profile page and its associated &lt;code&gt;Spinner&lt;/code&gt; for 2 seconds (the time shown in &lt;code&gt;timeoutMs&lt;/code&gt;).</source>
          <target state="translated">В этом коде мы завершили получение данных с помощью &lt;code&gt;startTransition&lt;/code&gt; . Это позволяет нам сразу начать выборку данных профиля, одновременно откладывая рендеринг следующей страницы профиля и связанного с ней &lt;code&gt;Spinner&lt;/code&gt; на 2 секунды (время, указанное в &lt;code&gt;timeoutMs&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a37905846a8f4c106d186eeaf752c69ecc60a20e" translate="yes" xml:space="preserve">
          <source>In this document, we&amp;rsquo;ll discuss why higher-order components are useful, and how to write your own.</source>
          <target state="translated">В этом документе мы обсудим, почему компоненты более высокого порядка полезны и как написать свои собственные.</target>
        </trans-unit>
        <trans-unit id="cbf9764d5b2c9095bb5b4589f2f63cafc22cfd01" translate="yes" xml:space="preserve">
          <source>In this document, we&amp;rsquo;ll discuss why render props are useful, and how to write your own.</source>
          <target state="translated">В этом документе мы обсудим, почему свойства рендеринга полезны и как написать свои собственные.</target>
        </trans-unit>
        <trans-unit id="600a8bed687912f2e4672cb1492ee6559ff93168" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; waits for both requests but starts them in parallel:</source>
          <target state="translated">В этом примере &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; ожидает обоих запросов, но запускает их параллельно:</target>
        </trans-unit>
        <trans-unit id="d9098805d0375365763e9b4152ec3e31f62f1c1a" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;ProfileDetails&lt;/code&gt; is waiting for an asynchronous API call to fetch some data. While we wait for &lt;code&gt;ProfileDetails&lt;/code&gt; and &lt;code&gt;ProfilePhoto&lt;/code&gt;, we will show the &lt;code&gt;Loading...&lt;/code&gt; fallback instead. It is important to note that until all children inside &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; has loaded, we will continue to show the fallback.</source>
          <target state="translated">В этом примере &lt;code&gt;ProfileDetails&lt;/code&gt; ожидает вызова асинхронного API для получения некоторых данных. Пока мы ждем &lt;code&gt;ProfileDetails&lt;/code&gt; и &lt;code&gt;ProfilePhoto&lt;/code&gt; , вместо этого мы покажем запасной вариант &lt;code&gt;Loading...&lt;/code&gt; Важно отметить, что пока все дочерние &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; внутри &amp;lt;Suspense&amp;gt; не будут загружены, мы продолжим показывать откат.</target>
        </trans-unit>
        <trans-unit id="782491ad80c95f67dcb2debb7f87f060c15672be" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;every item in &lt;code&gt;&amp;lt;MySlowList&amp;gt;&lt;/code&gt; has an artificial slowdown &amp;mdash; each of them blocks the thread for a few milliseconds&lt;/strong&gt;. We&amp;rsquo;d never do this in a real app, but this helps us simulate what can happen in a deep component tree with no single obvious place to optimize.</source>
          <target state="translated">В этом примере &lt;strong&gt;каждый элемент в &lt;code&gt;&amp;lt;MySlowList&amp;gt;&lt;/code&gt; имеет искусственное замедление - каждый из них блокирует поток на несколько миллисекунд&lt;/strong&gt; . Мы бы никогда не сделали этого в реальном приложении, но это помогает нам смоделировать то, что может произойти в глубоком дереве компонентов без единого очевидного места для оптимизации.</target>
        </trans-unit>
        <trans-unit id="1e713cd57d3c728babeb0c18ce780cd3201c1805" translate="yes" xml:space="preserve">
          <source>In this example, React would unsubscribe from our &lt;code&gt;ChatAPI&lt;/code&gt; when the component unmounts, as well as before re-running the effect due to a subsequent render. (If you want, there&amp;rsquo;s a way to &lt;a href=&quot;hooks-effect#tip-optimizing-performance-by-skipping-effects&quot;&gt;tell React to skip re-subscribing&lt;/a&gt; if the &lt;code&gt;props.friend.id&lt;/code&gt; we passed to &lt;code&gt;ChatAPI&lt;/code&gt; didn&amp;rsquo;t change.)</source>
          <target state="translated">В этом примере React &lt;code&gt;ChatAPI&lt;/code&gt; подписку на наш ChatAPI, когда компонент отключится, а также перед повторным запуском эффекта из-за последующей визуализации. (Если хотите, есть способ &lt;a href=&quot;hooks-effect#tip-optimizing-performance-by-skipping-effects&quot;&gt;сказать React пропустить повторную подписку,&lt;/a&gt; если &lt;code&gt;props.friend.id&lt;/code&gt; ,который мы передали в &lt;code&gt;ChatAPI&lt;/code&gt; , не изменился.)</target>
        </trans-unit>
        <trans-unit id="be0484ff678e7e7fe151098cbd0937ebbd00eb82" translate="yes" xml:space="preserve">
          <source>In this example, a parent component that renders &lt;code&gt;&amp;lt;FancyInput ref={inputRef} /&amp;gt;&lt;/code&gt; would be able to call &lt;code&gt;inputRef.current.focus()&lt;/code&gt;.</source>
          <target state="translated">В этом примере родительский компонент, отображающий &lt;code&gt;&amp;lt;FancyInput ref={inputRef} /&amp;gt;&lt;/code&gt; , сможет вызвать &lt;code&gt;inputRef.current.focus()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4bb4e68cbd0c4ac7dd0c4d7a725bdc64841434" translate="yes" xml:space="preserve">
          <source>In this example, each time &lt;code&gt;&amp;lt;MouseTracker&amp;gt;&lt;/code&gt; renders, it generates a new function as the value of the &lt;code&gt;&amp;lt;Mouse render&amp;gt;&lt;/code&gt; prop, thus negating the effect of &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; extending &lt;code&gt;React.PureComponent&lt;/code&gt; in the first place!</source>
          <target state="translated">В этом примере каждый раз, когда &lt;code&gt;&amp;lt;MouseTracker&amp;gt;&lt;/code&gt; выполняет рендеринг, он генерирует новую функцию в качестве значения свойства &lt;code&gt;&amp;lt;Mouse render&amp;gt;&lt;/code&gt; , тем самым сводя на нет эффект расширения &lt;code&gt;React.PureComponent&lt;/code&gt; &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; в первую очередь!</target>
        </trans-unit>
        <trans-unit id="1a67a59e557a8bb22da36c7b17ee44b1abf8d495" translate="yes" xml:space="preserve">
          <source>In this example, the callback ref will be called only when the component mounts and unmounts, since the rendered &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; component stays present throughout any rerenders. If you want to be notified any time a component resizes, you may want to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver&quot;&gt;&lt;code&gt;ResizeObserver&lt;/code&gt;&lt;/a&gt; or a third-party Hook built on it.</source>
          <target state="translated">В этом примере ссылка обратного вызова будет вызываться только тогда, когда компонент монтируется и размонтируется, поскольку визуализированный компонент &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; остается присутствующим во время любых повторных рендеров. Если вы хотите получать уведомления каждый раз при изменении размера компонента, вы можете использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver&quot;&gt; &lt;code&gt;ResizeObserver&lt;/code&gt; &lt;/a&gt; или сторонний Hook, построенный на нем.</target>
        </trans-unit>
        <trans-unit id="e22a8550914f5fd593b0e5202ccbe094289cbe2b" translate="yes" xml:space="preserve">
          <source>In this example, we are using a class component, but the same functionality could also be applied to function components, or components created by &lt;a href=&quot;react-api#reactmemo&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;react-api#reactforwardref&quot;&gt;&lt;code&gt;React.forwardRef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55f1824db5d408d73e18ba03a5505618f145cbb" translate="yes" xml:space="preserve">
          <source>In this example, we manually thread through a &lt;code&gt;color&lt;/code&gt; prop in order to style the &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;Message&lt;/code&gt; components appropriately. Using context, we can pass this through the tree automatically:</source>
          <target state="translated">В этом примере мы вручную прописываем &lt;code&gt;color&lt;/code&gt; опору, чтобы соответствующим образом &lt;code&gt;Button&lt;/code&gt; компоненты Button и &lt;code&gt;Message&lt;/code&gt; . Используя контекст, мы можем автоматически передать это по дереву:</target>
        </trans-unit>
        <trans-unit id="f0d3462a96fdf5b6668c86137312037ef5107ef1" translate="yes" xml:space="preserve">
          <source>In this example, we render a component and format the rendered HTML with the &lt;a href=&quot;https://www.npmjs.com/package/pretty&quot;&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/a&gt; package, before saving it as an inline snapshot:</source>
          <target state="translated">В этом примере мы визуализируем компонент и форматируем визуализированный HTML-код с помощью пакета &lt;a href=&quot;https://www.npmjs.com/package/pretty&quot;&gt; &lt;code&gt;pretty&lt;/code&gt; &lt;/a&gt; , прежде чем сохранить его как встроенный снимок:</target>
        </trans-unit>
        <trans-unit id="a2a678be6ef80893f4443dae3189e07dc9af8576" translate="yes" xml:space="preserve">
          <source>In this example, we start data fetching at the load &lt;em&gt;and&lt;/em&gt; every time you press &amp;ldquo;Refresh&amp;rdquo;. We put the result of calling &lt;code&gt;fetchUserAndPosts()&lt;/code&gt; into state so that components below can start reading the new data from the request we just kicked off.</source>
          <target state="translated">В этом примере мы начинаем выборку данных при загрузке &lt;em&gt;и&lt;/em&gt; каждый раз, когда вы нажимаете &amp;laquo;Обновить&amp;raquo;. Мы &lt;code&gt;fetchUserAndPosts()&lt;/code&gt; результат вызова fetchUserAndPosts () в состояние, чтобы компоненты ниже могли начать чтение новых данных из запроса, который мы только что начали.</target>
        </trans-unit>
        <trans-unit id="40e5ce9d2c277949ff6850c2e07a7ce4249ad65e" translate="yes" xml:space="preserve">
          <source>In this example, we started our journey on the &lt;code&gt;&amp;lt;HomePage&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">В этом примере мы начали наше путешествие с &lt;code&gt;&amp;lt;HomePage&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="be16ebf22fd30a0569861e07662b2e8b026b4f83" translate="yes" xml:space="preserve">
          <source>In this guide, we will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.</source>
          <target state="translated">В этом руководстве мы рассмотрим составные элементы React apps:элементы и компоненты.Освоив их,вы сможете создавать сложные приложения из небольших многоразовых частей.</target>
        </trans-unit>
        <trans-unit id="04d2198505214dcf8ceed2b4c9ee7adaedd5197b" translate="yes" xml:space="preserve">
          <source>In this scenario, you would use a framework like &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt; or a library like &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; so you can navigate between multiple routes and assert on side effects not just in the browser, but potentially on the backend as well.</source>
          <target state="translated">В этом сценарии вы должны использовать фреймворк, такой как &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress,&lt;/a&gt; или библиотеку, такую ​​как &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer,&lt;/a&gt; чтобы вы могли перемещаться между несколькими маршрутами и утверждать о побочных эффектах не только в браузере, но, возможно, и на бэкэнде.</target>
        </trans-unit>
        <trans-unit id="012fec99829ecc46c7a061a559b55cea20db4530" translate="yes" xml:space="preserve">
          <source>In this section, we will consider a few problems where developers new to React often reach for inheritance, and show how we can solve them with composition.</source>
          <target state="translated">В этом разделе мы рассмотрим несколько проблем,с которыми часто сталкиваются разработчики,только что вступившие в React,и покажем,как их можно решить с помощью композиции.</target>
        </trans-unit>
        <trans-unit id="2354bfe7189104f2d54a127296a8b8ac4cb54d00" translate="yes" xml:space="preserve">
          <source>In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.</source>
          <target state="translated">В этом разделе мы создадим калькулятор температуры,который будет вычислять,будет ли вода кипеть при заданной температуре.</target>
        </trans-unit>
        <trans-unit id="83d7bcb20d79f9f405dc2a045c7b8717d8f1c228" translate="yes" xml:space="preserve">
          <source>In this section, we will learn how to make the &lt;code&gt;Clock&lt;/code&gt; component truly reusable and encapsulated. It will set up its own timer and update itself every second.</source>
          <target state="translated">В этом разделе мы узнаем, как сделать компонент &lt;code&gt;Clock&lt;/code&gt; действительно многоразовым и инкапсулированным. Он установит свой собственный таймер и будет обновлять себя каждую секунду.</target>
        </trans-unit>
        <trans-unit id="ce38739a991553b55a16fa00b7561acd9e3c69cd" translate="yes" xml:space="preserve">
          <source>In this section, we will show how to add a React component to an existing HTML page. You can follow along with your own website, or create an empty HTML file to practice.</source>
          <target state="translated">В этом разделе мы покажем,как добавить компонент React к существующей HTML-странице.Вы можете проследить за этим вместе со своим собственным веб-сайтом или создать пустой HTML-файл,чтобы попрактиковаться.</target>
        </trans-unit>
        <trans-unit id="c457ca26e31df4ff72bf75e4781f7e68170aaedf" translate="yes" xml:space="preserve">
          <source>In those rare cases where you need to apply a HOC dynamically, you can also do it inside a component&amp;rsquo;s lifecycle methods or its constructor.</source>
          <target state="translated">В тех редких случаях, когда вам нужно применить HOC динамически, вы также можете сделать это внутри методов жизненного цикла компонента или его конструктора.</target>
        </trans-unit>
        <trans-unit id="98e74adf3229ab63477c62be5d7146a7e849046e" translate="yes" xml:space="preserve">
          <source>Inclusive Components</source>
          <target state="translated">Инклюзивные компоненты</target>
        </trans-unit>
        <trans-unit id="1042f8600a94d974b83e4d369aaa4b17edb453b8" translate="yes" xml:space="preserve">
          <source>Indicate the human language of page texts as screen reader software uses this to select the correct voice settings:</source>
          <target state="translated">Укажите человеческий язык текста страницы,так как скринридер использует это для выбора правильных голосовых настроек:</target>
        </trans-unit>
        <trans-unit id="49a578fd2622c2582fc0bfccfa222e7fbdccd773" translate="yes" xml:space="preserve">
          <source>Initializing &lt;a href=&quot;state-and-lifecycle&quot;&gt;local state&lt;/a&gt; by assigning an object to &lt;code&gt;this.state&lt;/code&gt;.</source>
          <target state="translated">Инициализация &lt;a href=&quot;state-and-lifecycle&quot;&gt;локального состояния&lt;/a&gt; путем присвоения объекта &lt;code&gt;this.state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="308f934b533308c752b10e77267068798d66f567" translate="yes" xml:space="preserve">
          <source>Inline If with Logical &amp;amp;&amp;amp; Operator</source>
          <target state="translated">Встроенный оператор If с логическим оператором &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="bb9001f5844d8678a32c2945ed8a6fb7c63e0e2f" translate="yes" xml:space="preserve">
          <source>Inline If-Else with Conditional Operator</source>
          <target state="translated">Онлайн If-Else с условным оператором</target>
        </trans-unit>
        <trans-unit id="66528a87a38e1e59da8d23434a47ffa479d5a4ba" translate="yes" xml:space="preserve">
          <source>Inside a loop, it is common to want to pass an extra parameter to an event handler. For example, if &lt;code&gt;id&lt;/code&gt; is the row ID, either of the following would work:</source>
          <target state="translated">Внутри цикла обычно требуется передать дополнительный параметр в обработчик событий. Например, если &lt;code&gt;id&lt;/code&gt; - это идентификатор строки, подойдет одно из следующих действий:</target>
        </trans-unit>
        <trans-unit id="4304c63954bdc246b29ab78b7a7b6fb0356bca4f" translate="yes" xml:space="preserve">
          <source>Inside the listener, call &lt;code&gt;setState&lt;/code&gt; whenever the data source changes.</source>
          <target state="translated">Внутри слушателя вызывайте &lt;code&gt;setState&lt;/code&gt; всякий раз, когда изменяется источник данных.</target>
        </trans-unit>
        <trans-unit id="1da0532bc1d42056af8f38805b51309a604715c0" translate="yes" xml:space="preserve">
          <source>Inside these methods, the &lt;code&gt;Calculator&lt;/code&gt; component asks React to re-render itself by calling &lt;code&gt;this.setState()&lt;/code&gt; with the new input value and the current scale of the input we just edited.</source>
          <target state="translated">Внутри этих методов компонент &lt;code&gt;Calculator&lt;/code&gt; просит React повторно &lt;code&gt;this.setState()&lt;/code&gt; себя, вызывая this.setState () с новым значением ввода и текущим масштабом только что отредактированного ввода.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">Свойства вещества</target>
        </trans-unit>
        <trans-unit id="68b9166fcdb7337cee3b47f14be3169cc82acd61" translate="yes" xml:space="preserve">
          <source>Instead of artificially separating &lt;em&gt;technologies&lt;/em&gt; by putting markup and logic in separate files, React &lt;a href=&quot;https://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separates &lt;em&gt;concerns&lt;/em&gt;&lt;/a&gt; with loosely coupled units called &amp;ldquo;components&amp;rdquo; that contain both. We will come back to components in a &lt;a href=&quot;components-and-props&quot;&gt;further section&lt;/a&gt;, but if you&amp;rsquo;re not yet comfortable putting markup in JS, &lt;a href=&quot;https://www.youtube.com/watch?v=x7cQ3mrcKaY&quot;&gt;this talk&lt;/a&gt; might convince you otherwise.</source>
          <target state="translated">Вместо того, чтобы искусственно разделять &lt;em&gt;технологии&lt;/em&gt; , помещая разметку и логику в отдельные файлы, React &lt;a href=&quot;https://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;разделяет &lt;em&gt;проблемы&lt;/em&gt;&lt;/a&gt; слабосвязанными единицами, называемыми &amp;laquo;компонентами&amp;raquo;, которые содержат и то, и другое. Мы вернемся к компонентам в &lt;a href=&quot;components-and-props&quot;&gt;следующем разделе&lt;/a&gt; , но если вам еще не комфортно размещать разметку в JS, &lt;a href=&quot;https://www.youtube.com/watch?v=x7cQ3mrcKaY&quot;&gt;этот доклад&lt;/a&gt; может убедить вас в обратном.</target>
        </trans-unit>
        <trans-unit id="d025bac2dca752df204440cbc1297998e47df835" translate="yes" xml:space="preserve">
          <source>Instead of calling real APIs in all your tests, you can mock requests with dummy data. Mocking data fetching with &amp;ldquo;fake&amp;rdquo; data prevents flaky tests due to an unavailable backend, and makes them run faster. Note: you may still want to run a subset of tests using an &lt;a href=&quot;testing-environments#end-to-end-tests-aka-e2e-tests&quot;&gt;&amp;ldquo;end-to-end&amp;rdquo;&lt;/a&gt; framework that tells whether the whole app is working together.</source>
          <target state="translated">Вместо того, чтобы вызывать настоящие API во всех ваших тестах, вы можете имитировать запросы с фиктивными данными. Мокинг выборки данных с помощью &amp;laquo;фальшивых&amp;raquo; данных предотвращает нестабильные тесты из-за недоступности серверной части и заставляет их работать быстрее. Примечание: вы все равно можете захотеть запустить подмножество тестов, используя &lt;a href=&quot;testing-environments#end-to-end-tests-aka-e2e-tests&quot;&gt;&amp;laquo;сквозную&amp;raquo;&lt;/a&gt; структуру, которая сообщает, работает ли все приложение вместе.</target>
        </trans-unit>
        <trans-unit id="df48b0f4d5bf5819b9914fd6531ebe1dc8a79973" translate="yes" xml:space="preserve">
          <source>Instead of doing &lt;code&gt;useTransition&lt;/code&gt; in every other component, we can build it into our design system.</source>
          <target state="translated">Вместо того, чтобы использовать &lt;code&gt;useTransition&lt;/code&gt; в каждом другом компоненте, мы можем встроить его в нашу дизайн-систему.</target>
        </trans-unit>
        <trans-unit id="8aded08fa023761e3f1e6e5311a0cc3ddf79baf0" translate="yes" xml:space="preserve">
          <source>Instead of mutation, HOCs should use composition, by wrapping the input component in a container component:</source>
          <target state="translated">Вместо мутации,HOCs должны использовать композицию,обернув входной компонент в компонент контейнера:</target>
        </trans-unit>
        <trans-unit id="5cf9d7c83880386192ebfbb360c2c6812d8bcf20" translate="yes" xml:space="preserve">
          <source>Instead of passing a &lt;code&gt;ref&lt;/code&gt; attribute created by &lt;code&gt;createRef()&lt;/code&gt;, you pass a function. The function receives the React component instance or HTML DOM element as its argument, which can be stored and accessed elsewhere.</source>
          <target state="translated">Вместо передачи атрибута &lt;code&gt;ref&lt;/code&gt; , созданного &lt;code&gt;createRef()&lt;/code&gt; , вы передаете функцию. Функция получает экземпляр компонента React или элемент HTML DOM в качестве аргумента, который может быть сохранен и доступен в другом месте.</target>
        </trans-unit>
        <trans-unit id="8c04ebdd8624a1412a2c00e3ee3be737187bc902" translate="yes" xml:space="preserve">
          <source>Instead of showing a spinner, can we add a visual effect like &amp;ldquo;greying out&amp;rdquo; the current screen?</source>
          <target state="translated">Можем ли мы вместо отображения счетчика добавить визуальный эффект, например &amp;laquo;затемнение&amp;raquo; текущего экрана?</target>
        </trans-unit>
        <trans-unit id="54c51eb3d5154be37011a4c79e90fdae3d688bfd" translate="yes" xml:space="preserve">
          <source>Instead, &lt;em&gt;pass the function itself&lt;/em&gt; (without parens):</source>
          <target state="translated">Вместо этого &lt;em&gt;передайте саму функцию&lt;/em&gt; (без скобок):</target>
        </trans-unit>
        <trans-unit id="6cf33354387d8bc0b95b73e1b637b872d08038c4" translate="yes" xml:space="preserve">
          <source>Instead, apply HOCs outside the component definition so that the resulting component is created only once. Then, its identity will be consistent across renders. This is usually what you want, anyway.</source>
          <target state="translated">Вместо этого применяйте HOC вне определения компонента,чтобы результирующий компонент был создан только один раз.Тогда его идентичность будет одинаковой во всех случаях.В любом случае,это обычно то,что вы хотите.</target>
        </trans-unit>
        <trans-unit id="14487f72778797d41aa4fbaf38ed77b989f65799" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;setState()&lt;/code&gt;:</source>
          <target state="translated">Вместо этого используйте &lt;code&gt;setState()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="441f654229a4276797437835009f1f108efbc02d" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;useEffect&lt;/code&gt;. The function passed to &lt;code&gt;useEffect&lt;/code&gt; will run after the render is committed to the screen. Think of effects as an escape hatch from React&amp;rsquo;s purely functional world into the imperative world.</source>
          <target state="translated">Вместо этого используйте &lt;code&gt;useEffect&lt;/code&gt; . Функция, переданная в &lt;code&gt;useEffect&lt;/code&gt; , будет запущена после того, как рендеринг будет зафиксирован на экране. Думайте об эффектах как о побеге из чисто функционального мира React в императивный мир.</target>
        </trans-unit>
        <trans-unit id="6e5c222edd3cc915db386166adcd08d3c4524ced" translate="yes" xml:space="preserve">
          <source>Instead, we release new features in minor versions. That means that minor releases are often more interesting and compelling than majors, despite their unassuming name.</source>
          <target state="translated">Вместо этого мы выпускаем новые функции в небольших версиях.Это означает,что минорные релизы часто более интересны и убедительны,чем мейджоры,несмотря на их непритязательное название.</target>
        </trans-unit>
        <trans-unit id="9cad89ab27a31a43bc8bcabb4f1530a63711b236" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;d like to share this logic between &lt;code&gt;FriendStatus&lt;/code&gt; and &lt;code&gt;FriendListItem&lt;/code&gt;.</source>
          <target state="translated">Вместо этого мы хотели бы поделиться этой логикой между &lt;code&gt;FriendStatus&lt;/code&gt; и &lt;code&gt;FriendListItem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bc56bd7b51ec191a2b44a72405da8bdc2c8e271" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;ll look at Suspense as a logical next step in a sequence of approaches:</source>
          <target state="translated">Вместо этого мы рассмотрим задержку как следующий логический шаг в последовательности подходов:</target>
        </trans-unit>
        <trans-unit id="56e78cabfede8d071dad68a99417a1db55165ae4" translate="yes" xml:space="preserve">
          <source>Integrating with DOM Manipulation Plugins</source>
          <target state="translated">Интеграция с манипуляционными плагинами DOM</target>
        </trans-unit>
        <trans-unit id="fabcdcb5781cef22218fde185dcc3275b3caf232" translate="yes" xml:space="preserve">
          <source>Integrating with Model Layers</source>
          <target state="translated">Интеграция со слоями модели</target>
        </trans-unit>
        <trans-unit id="2abfc3b773acf5210e59c6612eeb838ec30c6daf" translate="yes" xml:space="preserve">
          <source>Integrating with Other Libraries</source>
          <target state="translated">Интеграция с другими библиотеками</target>
        </trans-unit>
        <trans-unit id="323ce191323fe812d9b2285405712a7540e602ee" translate="yes" xml:space="preserve">
          <source>Integrating with Other View Libraries</source>
          <target state="translated">Интеграция с библиотеками других видов</target>
        </trans-unit>
        <trans-unit id="a7ead22e923dd75533f31fb755b0096e8335cf4b" translate="yes" xml:space="preserve">
          <source>Integrating with jQuery Chosen Plugin</source>
          <target state="translated">Интеграция с выбранной вилкой jQuery</target>
        </trans-unit>
        <trans-unit id="31f07fcd6fa5d6cf3bce211abaa7f9938b9f8b59" translate="yes" xml:space="preserve">
          <source>Integrating with third-party DOM libraries.</source>
          <target state="translated">Интеграция со сторонними DOM-библиотеками.</target>
        </trans-unit>
        <trans-unit id="d188e3da39485e86c68a2e47954789d012f3e98a" translate="yes" xml:space="preserve">
          <source>Intentional Loading Sequences</source>
          <target state="translated">Умышленная загрузка последовательностей</target>
        </trans-unit>
        <trans-unit id="458622e11438e28a4579aeaa119e2f6a90af7730" translate="yes" xml:space="preserve">
          <source>Interactions can be used to identify the cause of an update, although the API for tracing them is still experimental.</source>
          <target state="translated">Взаимодействие может быть использовано для определения причины обновления,хотя API для их отслеживания все еще является экспериментальным.</target>
        </trans-unit>
        <trans-unit id="6896564dcbd1c525b78f98182de42c4bb2b09515" translate="yes" xml:space="preserve">
          <source>Internally, React uses several clever techniques to minimize the number of costly DOM operations required to update the UI. For many applications, using React will lead to a fast user interface without doing much work to specifically optimize for performance. Nevertheless, there are several ways you can speed up your React application.</source>
          <target state="translated">Внутри компании React используется несколько умных методов для минимизации количества дорогостоящих операций DOM,необходимых для обновления пользовательского интерфейса.Для многих приложений использование React приведет к быстрому пользовательскому интерфейсу,не выполняя большой работы по оптимизации производительности.Тем не менее,существует несколько способов ускорить работу React приложения.</target>
        </trans-unit>
        <trans-unit id="78abc071449ad0da13e4d5e5a3f22e08fc793563" translate="yes" xml:space="preserve">
          <source>Interruptible Prerendering</source>
          <target state="translated">Прерывистая предварительная блокировка</target>
        </trans-unit>
        <trans-unit id="5bdb65efee969d707c5e1bc2b4a881568f89c4af" translate="yes" xml:space="preserve">
          <source>Interruptible Rendering</source>
          <target state="translated">Прерывистая оферта</target>
        </trans-unit>
        <trans-unit id="fe91e5b2febdee26a910e78fb467ec00cef2cc7f" translate="yes" xml:space="preserve">
          <source>Introducing Concurrent Mode</source>
          <target state="translated">Вводящий параллельный режим</target>
        </trans-unit>
        <trans-unit id="8d1fa1c8913451a1f429075bf69c1c706857274d" translate="yes" xml:space="preserve">
          <source>Introducing Concurrent Mode (Experimental)</source>
          <target state="translated">Введение параллельного режима (экспериментальный)</target>
        </trans-unit>
        <trans-unit id="2c358e3ea80007355c4cebac6d98e29b8a15fd58" translate="yes" xml:space="preserve">
          <source>Introducing Error Boundaries</source>
          <target state="translated">Представляющие границы ошибок</target>
        </trans-unit>
        <trans-unit id="6752670ac4fd3d43c072341f57aeec0c7e6fa7d6" translate="yes" xml:space="preserve">
          <source>Introducing Hooks</source>
          <target state="translated">Представляющие крючки</target>
        </trans-unit>
        <trans-unit id="99fc0e820b4798682e759dbf88cc8628f74605fc" translate="yes" xml:space="preserve">
          <source>Introducing JSX</source>
          <target state="translated">Представляем JSX</target>
        </trans-unit>
        <trans-unit id="f9c770701ef9646b1634d74252668c51159f3855" translate="yes" xml:space="preserve">
          <source>Invokes a function on every immediate child contained within &lt;code&gt;children&lt;/code&gt; with &lt;code&gt;this&lt;/code&gt; set to &lt;code&gt;thisArg&lt;/code&gt;. If &lt;code&gt;children&lt;/code&gt; is an array it will be traversed and the function will be called for each child in the array. If children is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, this method will return &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; rather than an array.</source>
          <target state="translated">Вызывает функцию для каждого непосредственного дочернего &lt;code&gt;thisArg&lt;/code&gt; содержащегося в &lt;code&gt;children&lt;/code&gt; элементах с &lt;code&gt;this&lt;/code&gt; значением thisArg . Если &lt;code&gt;children&lt;/code&gt; элементы являются массивом, он будет пройден, и функция будет вызываться для каждого дочернего элемента в массиве. Если дочерние &lt;code&gt;null&lt;/code&gt; имеют значение null или &lt;code&gt;undefined&lt;/code&gt; , этот метод вернет значение &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; , а не массив.</target>
        </trans-unit>
        <trans-unit id="19019a267c68ec0d9a87bbfe53368307773f4e69" translate="yes" xml:space="preserve">
          <source>Is it OK to use arrow functions in render methods?</source>
          <target state="translated">Можно ли использовать функции стрелок в методах рендеринга?</target>
        </trans-unit>
        <trans-unit id="b94bd0fbbd4ff5757505741937dacab45d2007bf" translate="yes" xml:space="preserve">
          <source>Is it passed in from a parent via props? If so, it probably isn&amp;rsquo;t state.</source>
          <target state="translated">Он передается от родителя через реквизит? Если так, вероятно, это не состояние.</target>
        </trans-unit>
        <trans-unit id="b12fb0c98d31f06f2e894073d26a29b446b6105a" translate="yes" xml:space="preserve">
          <source>Is it safe to omit functions from the list of dependencies?</source>
          <target state="translated">Безопасно ли опускать функции из списка зависимостей?</target>
        </trans-unit>
        <trans-unit id="36e2fa776e8e49d37a8c66174c7a287fbd5c8891" translate="yes" xml:space="preserve">
          <source>Is the Shadow DOM the same as the Virtual DOM?</source>
          <target state="translated">Является ли Shadow DOM тем же самым,что и Virtual DOM?</target>
        </trans-unit>
        <trans-unit id="118a7d245e14f3d46907f813b32d6d32103aa8e9" translate="yes" xml:space="preserve">
          <source>Is there a recommended way to structure React projects?</source>
          <target state="translated">Есть ли рекомендуемый способ структурирования проектов React?</target>
        </trans-unit>
        <trans-unit id="431584afff8cf3078b613772134b8cf66a20ffd7" translate="yes" xml:space="preserve">
          <source>Is there something like forceUpdate?</source>
          <target state="translated">Есть что-то вроде ForceUpdate?</target>
        </trans-unit>
        <trans-unit id="c240e644bcf66edddc303b13a6145795d52277ac" translate="yes" xml:space="preserve">
          <source>Is there something like instance variables?</source>
          <target state="translated">Есть ли что-то вроде переменных экземпляров?</target>
        </trans-unit>
        <trans-unit id="85ab7deeb83142d16bed5604f08f86936f301d70" translate="yes" xml:space="preserve">
          <source>Is this page useful?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615079284bccc262002fb9d64da4565ad0ff149a" translate="yes" xml:space="preserve">
          <source>It accepts &lt;code&gt;author&lt;/code&gt; (an object), &lt;code&gt;text&lt;/code&gt; (a string), and &lt;code&gt;date&lt;/code&gt; (a date) as props, and describes a comment on a social media website.</source>
          <target state="translated">Он принимает &lt;code&gt;author&lt;/code&gt; (объект), &lt;code&gt;text&lt;/code&gt; (строку) и &lt;code&gt;date&lt;/code&gt; (дату) в качестве реквизита и описывает комментарий на веб-сайте социальной сети.</target>
        </trans-unit>
        <trans-unit id="fe1bc6eb63b54ec080a5b630f4c12685f9a1f7ff" translate="yes" xml:space="preserve">
          <source>It all begins with running one command in your terminal.</source>
          <target state="translated">Все начинается с выполнения одной команды в вашем терминале.</target>
        </trans-unit>
        <trans-unit id="188127c3aef7bdf7fd35fe7c856bcfd34c54e44a" translate="yes" xml:space="preserve">
          <source>It calls &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; every second from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;&lt;code&gt;setInterval()&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cb8127bb9bd6695f9f71a7f9270c5ec20060df" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;ReactDOM.render()&lt;/code&gt; every second from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;&lt;code&gt;setInterval()&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">Он вызывает &lt;code&gt;ReactDOM.render()&lt;/code&gt; каждую секунду из обратного вызова &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt; &lt;code&gt;setInterval()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cef424d8853229927def0460dc79c6c0ba401d9" translate="yes" xml:space="preserve">
          <source>It can also be used for larger expressions although it is less obvious what&amp;rsquo;s going on:</source>
          <target state="translated">Его также можно использовать для более крупных выражений, хотя это менее очевидно, что происходит:</target>
        </trans-unit>
        <trans-unit id="0cbe1ab611653ca85961be292443488b8a02544f" translate="yes" xml:space="preserve">
          <source>It can be tedious to manually calculate the proper color combinations for all cases in your website so instead, you can &lt;a href=&quot;https://jxnblk.com/colorable/&quot;&gt;calculate an entire accessible color palette with Colorable&lt;/a&gt;.</source>
          <target state="translated">Может быть утомительно вручную рассчитывать правильные цветовые комбинации для всех случаев на вашем веб-сайте, поэтому вместо этого вы можете &lt;a href=&quot;https://jxnblk.com/colorable/&quot;&gt;рассчитать всю доступную цветовую палитру с помощью Colorable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d62fd02389ef9525bb5984bc2a6e5af4ca327920" translate="yes" xml:space="preserve">
          <source>It can sometimes be tedious to use controlled components, because you need to write an event handler for every way your data can change and pipe all of the input state through a React component. This can become particularly annoying when you are converting a preexisting codebase to React, or integrating a React application with a non-React library. In these situations, you might want to check out &lt;a href=&quot;uncontrolled-components&quot;&gt;uncontrolled components&lt;/a&gt;, an alternative technique for implementing input forms.</source>
          <target state="translated">Иногда использование контролируемых компонентов может быть утомительным, потому что вам нужно написать обработчик событий для каждого способа изменения ваших данных и передать все входное состояние через компонент React. Это может стать особенно раздражающим, когда вы конвертируете уже существующую кодовую базу в React или интегрируете приложение React с библиотекой, отличной от React. В этих ситуациях вы можете захотеть проверить &lt;a href=&quot;uncontrolled-components&quot;&gt;неконтролируемые компоненты&lt;/a&gt; , альтернативный метод реализации форм ввода.</target>
        </trans-unit>
        <trans-unit id="2005e7f27cdc72de843371aaff7b32477d8c91bf" translate="yes" xml:space="preserve">
          <source>It conceptually makes sense for the filter text and checked value to live in &lt;code&gt;FilterableProductTable&lt;/code&gt;</source>
          <target state="translated">Концептуально имеет смысл, чтобы текст фильтра и проверяемое значение жили в &lt;code&gt;FilterableProductTable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="688f0ab18438d6d367169c900008f7481be7690d" translate="yes" xml:space="preserve">
          <source>It displays &amp;ldquo;Hello, world&amp;rdquo; on the page.</source>
          <target state="translated">На странице отображается &amp;laquo;Hello, world&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="52ab860d9c544904ffaab788e02b64e8286beee6" translate="yes" xml:space="preserve">
          <source>It displays a heading saying &amp;ldquo;Hello, world!&amp;rdquo; on the page.</source>
          <target state="translated">В нем отображается заголовок &amp;laquo;Привет, мир!&amp;raquo; на странице.</target>
        </trans-unit>
        <trans-unit id="e82647fae753dc8b035e66a8857ffb17ac2da33f" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t suffer from this bug. (But we also didn&amp;rsquo;t make any changes to it.)</source>
          <target state="translated">Он не страдает этой ошибкой. (Но мы также не внесли в него никаких изменений.)</target>
        </trans-unit>
        <trans-unit id="602a6efa84948afcddd9d1b66dd5be71479d7a38" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;only&lt;/strong&gt; safe to omit a function from the dependency list if nothing in it (or the functions called by it) references props, state, or values derived from them. This example has a bug:</source>
          <target state="translated">Это &lt;strong&gt;только&lt;/strong&gt; безопасно опустить функцию из списка зависимостей , если ничего в нем (или функции , вызываемой ею) ссылка реквизит, государственные или значения не происходят от них. В этом примере есть ошибка:</target>
        </trans-unit>
        <trans-unit id="6ead55f0f98915b5c6f13c05726f2286aab42a96" translate="yes" xml:space="preserve">
          <source>It is an early time for Hooks, and some third-party libraries might not be compatible with Hooks at the moment.</source>
          <target state="translated">Для Hooks еще рано,и некоторые сторонние библиотеки могут быть несовместимы с Hooks на данный момент.</target>
        </trans-unit>
        <trans-unit id="50466c950e08c88b69e598ab61d92c2dc031d70e" translate="yes" xml:space="preserve">
          <source>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</source>
          <target state="translated">Он называется JSX и является синтаксическим расширением JavaScript.Мы рекомендуем использовать его с React для описания того,как должен выглядеть пользовательский интерфейс.JSX может напоминать язык шаблонов,но в его состав входит вся мощь JavaScript.</target>
        </trans-unit>
        <trans-unit id="92466150db2416a73798d13e0245efd07871c27a" translate="yes" xml:space="preserve">
          <source>It is common for CSS classes to depend on the component props or state:</source>
          <target state="translated">Обычно классы CSS зависят от реквизита компонента или состояния:</target>
        </trans-unit>
        <trans-unit id="7e283c36c21325ef64876afd9194c0a0cb70a383" translate="yes" xml:space="preserve">
          <source>It is documented in our &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;code splitting guide&lt;/a&gt;. Note that &lt;code&gt;lazy&lt;/code&gt; components can be deep inside the &lt;code&gt;Suspense&lt;/code&gt; tree &amp;mdash; it doesn&amp;rsquo;t have to wrap every one of them. The best practice is to place &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; where you want to see a loading indicator, but to use &lt;code&gt;lazy()&lt;/code&gt; wherever you want to do code splitting.</source>
          <target state="translated">Это задокументировано в нашем &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;руководстве по разделению кода&lt;/a&gt; . Обратите внимание, что &lt;code&gt;lazy&lt;/code&gt; компоненты могут находиться глубоко внутри дерева &lt;code&gt;Suspense&lt;/code&gt; - не обязательно обертывать каждый из них. Лучше всего разместить &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; там, где вы хотите видеть индикатор загрузки, но использовать &lt;code&gt;lazy()&lt;/code&gt; везде, где вы хотите выполнить разделение кода.</target>
        </trans-unit>
        <trans-unit id="f9b84f156dc2b1e8053f6383bcb338d839775393" translate="yes" xml:space="preserve">
          <source>It is equivalent to this ES5 code:</source>
          <target state="translated">Он эквивалентен этому коду ES5:</target>
        </trans-unit>
        <trans-unit id="e8b287ce575a54f80be869742a5c4a51c76fe13e" translate="yes" xml:space="preserve">
          <source>It is expected that you use the development mode when working on your app, and the production mode when deploying your app to the users.</source>
          <target state="translated">Предполагается,что вы используете режим разработки при работе с приложением,а режим производства-при развертывании приложения для пользователей.</target>
        </trans-unit>
        <trans-unit id="c952a73f20c5f13e3de4b9d7ef50fbb5a61fc052" translate="yes" xml:space="preserve">
          <source>It is important that we also call &lt;code&gt;ReactDOM.unmountComponentAtNode()&lt;/code&gt; in the &lt;code&gt;remove&lt;/code&gt; method so that React unregisters event handlers and other resources associated with the component tree when it is detached.</source>
          <target state="translated">Важно, чтобы мы также вызывали &lt;code&gt;ReactDOM.unmountComponentAtNode()&lt;/code&gt; в методе &lt;code&gt;remove&lt;/code&gt; чтобы React отменил регистрацию обработчиков событий и других ресурсов, связанных с деревом компонентов при его отсоединении.</target>
        </trans-unit>
        <trans-unit id="32d368243a184c2b8d827bcbfe71e38225d8ed76" translate="yes" xml:space="preserve">
          <source>It is important to remember that the reconciliation algorithm is an implementation detail. React could rerender the whole app on every action; the end result would be the same. Just to be clear, rerender in this context means calling &lt;code&gt;render&lt;/code&gt; for all components, it doesn&amp;rsquo;t mean React will unmount and remount them. It will only apply the differences following the rules stated in the previous sections.</source>
          <target state="translated">Важно помнить, что алгоритм согласования - это деталь реализации. React мог повторно отображать все приложение при каждом действии; конечный результат будет таким же. Чтобы быть ясным, повторный рендеринг в этом контексте означает вызов &lt;code&gt;render&lt;/code&gt; для всех компонентов, это не означает, что React будет отключать и повторно монтировать их. Он будет применять различия только в соответствии с правилами, изложенными в предыдущих разделах.</target>
        </trans-unit>
        <trans-unit id="061882208caaee20f8d6caf81dd052b896705df2" translate="yes" xml:space="preserve">
          <source>It is often necessary to update the context from a component that is nested somewhere deeply in the component tree. In this case you can pass a function down through the context to allow consumers to update the context:</source>
          <target state="translated">Часто бывает необходимо обновлять контекст из компонента,который вложен где-то глубоко в дерево компонентов.В этом случае можно передать функцию вниз по контексту,чтобы потребители могли обновить контекст:</target>
        </trans-unit>
        <trans-unit id="68f2025036d719ebb13936746e156dcb2e46aebc" translate="yes" xml:space="preserve">
          <source>It is safe to embed user input in JSX:</source>
          <target state="translated">В JSX безопасно встраивать пользовательский ввод:</target>
        </trans-unit>
        <trans-unit id="aa4e4c8c699f839e3d4430e49f56a9d08895180e" translate="yes" xml:space="preserve">
          <source>It lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:</source>
          <target state="translated">Он позволяет извлечь логику вычисления начального состояния за пределами редуктора.Это также удобно для последующего сброса состояния в ответ на действие:</target>
        </trans-unit>
        <trans-unit id="534a38fabcd6aaf35f04bf09e44ca89301bf0ea1" translate="yes" xml:space="preserve">
          <source>It might feel redundant to pass down the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt; props through many levels if in the end only the &lt;code&gt;Avatar&lt;/code&gt; component really needs it. It&amp;rsquo;s also annoying that whenever the &lt;code&gt;Avatar&lt;/code&gt; component needs more props from the top, you have to add them at all the intermediate levels too.</source>
          <target state="translated">Может показаться излишним передавать реквизиты &lt;code&gt;user&lt;/code&gt; и &lt;code&gt;avatarSize&lt;/code&gt; на многих уровнях, если в конечном итоге это действительно нужно только компоненту &lt;code&gt;Avatar&lt;/code&gt; . Также раздражает то, что всякий раз, когда компоненту &lt;code&gt;Avatar&lt;/code&gt; требуется больше реквизита сверху, вам также нужно добавлять их на всех промежуточных уровнях.</target>
        </trans-unit>
        <trans-unit id="50fb2495198065234962cb4b4d0c32c48a17f7f2" translate="yes" xml:space="preserve">
          <source>It returns an empty string on an invalid &lt;code&gt;temperature&lt;/code&gt;, and it keeps the output rounded to the third decimal place:</source>
          <target state="translated">Он возвращает пустую строку с недопустимой &lt;code&gt;temperature&lt;/code&gt; и сохраняет вывод округленным до третьего десятичного знака:</target>
        </trans-unit>
        <trans-unit id="72f61e484682b21e93d363b30d4566ea24fa8ee5" translate="yes" xml:space="preserve">
          <source>It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You&amp;rsquo;ll need to have &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node &amp;gt;= 8.10 and npm &amp;gt;= 5.6&lt;/a&gt; on your machine. To create a project, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9057e6a7d66d1d7c47dc528ed3b3b130a69063f" translate="yes" xml:space="preserve">
          <source>It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You&amp;rsquo;ll need to have Node &amp;gt;= 8.10 and npm &amp;gt;= 5.6 on your machine. To create a project, run:</source>
          <target state="translated">Он настраивает вашу среду разработки, чтобы вы могли использовать новейшие функции JavaScript, обеспечивая удобство разработки и оптимизацию вашего приложения для производства. На вашем компьютере должны быть Node&amp;gt; = 8.10 и npm&amp;gt; = 5.6. Чтобы создать проект, запустите:</target>
        </trans-unit>
        <trans-unit id="706a32880b71586a8d7aa0ac7d5f1463de4cb7ba" translate="yes" xml:space="preserve">
          <source>It takes &lt;code&gt;friendID&lt;/code&gt; as an argument, and returns whether our friend is online.</source>
          <target state="translated">Он принимает &lt;code&gt;friendID&lt;/code&gt; в качестве аргумента и возвращает, находится ли наш друг в сети.</target>
        </trans-unit>
        <trans-unit id="3161055d73426680e8d35bc1e7cbbe8e4104358e" translate="yes" xml:space="preserve">
          <source>It took us only seven lines of code to add this transition:</source>
          <target state="translated">Нам понадобилось всего семь строк кода,чтобы добавить этот переход:</target>
        </trans-unit>
        <trans-unit id="45e77ef569a1f7d7c48e0e05eba962af9f6767c1" translate="yes" xml:space="preserve">
          <source>It will render either &lt;code&gt;&amp;lt;LoginButton /&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;LogoutButton /&amp;gt;&lt;/code&gt; depending on its current state. It will also render a &lt;code&gt;&amp;lt;Greeting /&amp;gt;&lt;/code&gt; from the previous example:</source>
          <target state="translated">Он будет отображать либо &lt;code&gt;&amp;lt;LoginButton /&amp;gt;&lt;/code&gt; , либо &lt;code&gt;&amp;lt;LogoutButton /&amp;gt;&lt;/code&gt; в зависимости от его текущего состояния. Он также отобразит &lt;code&gt;&amp;lt;Greeting /&amp;gt;&lt;/code&gt; из предыдущего примера:</target>
        </trans-unit>
        <trans-unit id="2155bb73f8bf6451916989b5cbacb97df229da2a" translate="yes" xml:space="preserve">
          <source>It will use &lt;code&gt;this.setState()&lt;/code&gt; to schedule updates to the component local state:</source>
          <target state="translated">Он будет использовать &lt;code&gt;this.setState()&lt;/code&gt; для планирования обновлений локального состояния компонента:</target>
        </trans-unit>
        <trans-unit id="d02413defbcafdd99d3c520fd9d4aa148536aaf1" translate="yes" xml:space="preserve">
          <source>It works because in JavaScript, &lt;code&gt;true &amp;amp;&amp;amp; expression&lt;/code&gt; always evaluates to &lt;code&gt;expression&lt;/code&gt;, and &lt;code&gt;false &amp;amp;&amp;amp; expression&lt;/code&gt; always evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Это работает, потому что в JavaScript &lt;code&gt;true &amp;amp;&amp;amp; expression&lt;/code&gt; всегда оценивается как &lt;code&gt;expression&lt;/code&gt; , а &lt;code&gt;false &amp;amp;&amp;amp; expression&lt;/code&gt; всегда оценивается как &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df1035dc615a18406c02f413ad0f4e40e484e2b1" translate="yes" xml:space="preserve">
          <source>It would catch both rendering errors &lt;em&gt;and&lt;/em&gt; errors from Suspense data fetching. We can have as many error boundaries as we like but it&amp;rsquo;s best to &lt;a href=&quot;https://aweary.dev/fault-tolerance-react/&quot;&gt;be intentional&lt;/a&gt; about their placement.</source>
          <target state="translated">Он будет обнаруживать как ошибки рендеринга, так &lt;em&gt;и&lt;/em&gt; ошибки при отложенной выборке данных. Мы можем иметь как много границ ошибок , как нам нравится , но это лучше , чтобы &lt;a href=&quot;https://aweary.dev/fault-tolerance-react/&quot;&gt;быть преднамеренным&lt;/a&gt; об их размещении.</target>
        </trans-unit>
        <trans-unit id="d53bef197f2d6ecda97fc0ca21c3fffc1a9ab88e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a good idea to get to know React first, before adding in additional libraries. You can build quite complex applications using only React.</source>
          <target state="translated">Перед добавлением дополнительных библиотек рекомендуется сначала познакомиться с React. Вы можете создавать довольно сложные приложения, используя только React.</target>
        </trans-unit>
        <trans-unit id="1069cd6014468c5f2a1a444828d18bfcd86ae157" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a result of several years of research and development, but it&amp;rsquo;s not finished. In the section on &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;adopting Concurrent Mode&lt;/a&gt;, we&amp;rsquo;ll describe how you can try it and what you can expect.</source>
          <target state="translated">Это результат нескольких лет исследований и разработок, но они еще не закончены. В разделе, посвященном &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;использованию конкурентного режима&lt;/a&gt; , мы расскажем, как вы можете его попробовать и чего ожидать.</target>
        </trans-unit>
        <trans-unit id="5b97c1e1db1289e7c4f51d01cbfaea288680830c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s difficult to remember which props or state are used by functions outside of the effect. This is why &lt;strong&gt;usually you&amp;rsquo;ll want to declare functions needed by an effect &lt;em&gt;inside&lt;/em&gt; of it.&lt;/strong&gt; Then it&amp;rsquo;s easy to see what values from the component scope that effect depends on:</source>
          <target state="translated">Трудно вспомнить, какие свойства или состояние используются функциями вне эффекта. Вот почему &lt;strong&gt;обычно вы хотите объявлять функции, необходимые для эффекта &lt;em&gt;внутри&lt;/em&gt; него. &lt;/strong&gt;Тогда легко увидеть, от каких значений из области компонента зависит этот эффект:</target>
        </trans-unit>
        <trans-unit id="12d523ee0a8b2e43fbd774373dabc117b68d15fc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s hard to reuse stateful logic between components</source>
          <target state="translated">Трудно повторно использовать логику с отслеживанием состояния между компонентами</target>
        </trans-unit>
        <trans-unit id="e11305e8e0d8ed22ffeb90393f322ef30d355dd4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to remember that just because the pattern is called &amp;ldquo;render props&amp;rdquo; you don&amp;rsquo;t &lt;em&gt;have to use a prop named &lt;code&gt;render&lt;/code&gt; to use this pattern&lt;/em&gt;. In fact, &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&lt;em&gt;any&lt;/em&gt; prop that is a function that a component uses to know what to render is technically a &amp;ldquo;render prop&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">Важно помнить, что только потому, что шаблон называется &amp;laquo;render props&amp;raquo;, вам не &lt;em&gt;нужно использовать свойство с именем &lt;code&gt;render&lt;/code&gt; для использования этого шаблона&lt;/em&gt; . Фактически, &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&lt;em&gt;любая&lt;/em&gt; опора, которая является функцией, которую компонент использует, чтобы знать, что визуализировать, технически является &amp;laquo;опорой визуализации&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abbcf3e467e64993c40145b58380cca00dde2358" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not a Hook because it doesn&amp;rsquo;t compose like Hooks do. &lt;code&gt;React.memo&lt;/code&gt; is equivalent to &lt;code&gt;PureComponent&lt;/code&gt;, but it only compares props. (You can also add a second argument to specify a custom comparison function that takes the old and new props. If it returns true, the update is skipped.)</source>
          <target state="translated">Это не Hook, потому что он не сочиняет, как Hooks. &lt;code&gt;React.memo&lt;/code&gt; эквивалентен &lt;code&gt;PureComponent&lt;/code&gt; , но сравнивает только реквизиты. (Вы также можете добавить второй аргумент, чтобы указать настраиваемую функцию сравнения, которая принимает старые и новые свойства. Если он возвращает true, обновление пропускается.)</target>
        </trans-unit>
        <trans-unit id="218c8c3fba795922b2f79061baba6ea0eea01f6d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible that a minor release will not include new features. &lt;a href=&quot;https://semver.org/#spec-item-7&quot;&gt;This is allowed by semver&lt;/a&gt;, which states &lt;strong&gt;&amp;rdquo;[a minor version] MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes.&amp;rdquo;&lt;/strong&gt;</source>
          <target state="translated">Возможно, что второстепенный выпуск не будет включать новые функции. &lt;a href=&quot;https://semver.org/#spec-item-7&quot;&gt;Это разрешено semver&lt;/a&gt; , в котором говорится: &lt;strong&gt;&amp;laquo;[младшая версия] МОЖЕТ быть увеличена, если в частный код вводятся существенные новые функции или улучшения. Он МОЖЕТ включать изменения уровня патча &amp;raquo;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ed922784aa3b9ce3ee3dfd000c51ce8f2ddc5c7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible that in the future React will provide a &lt;code&gt;usePrevious&lt;/code&gt; Hook out of the box since it&amp;rsquo;s a relatively common use case.</source>
          <target state="translated">Возможно, что в будущем React предоставит &lt;code&gt;usePrevious&lt;/code&gt; Hook из коробки, поскольку это относительно распространенный вариант использования.</target>
        </trans-unit>
        <trans-unit id="4411f615cb9a34eac0782d89d41554e9d48dcddd" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s typically better to make more specific assertions than to use snapshots. These kinds of tests include implementation details so they break easily, and teams can get desensitized to snapshot breakages. Selectively &lt;a href=&quot;#mocking-modules&quot;&gt;mocking some child components&lt;/a&gt; can help reduce the size of snapshots and keep them readable for the code review.</source>
          <target state="translated">Обычно лучше делать более конкретные утверждения, чем использовать снимки. Эти виды тестов включают детали реализации, поэтому они легко ломаются, и команды могут не реагировать на поломки моментальных снимков. Выборочная &lt;a href=&quot;#mocking-modules&quot;&gt;имитация некоторых дочерних компонентов&lt;/a&gt; может помочь уменьшить размер снимков и сделать их доступными для чтения для проверки кода.</target>
        </trans-unit>
        <trans-unit id="1abbf23e01de1391e6e121af6cd34d1a85aa0356" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;useDeferredValue&lt;/code&gt; is not &lt;em&gt;only&lt;/em&gt; useful for data fetching. It also helps when an expensive component tree causes an interaction (e.g. typing in an input) to be sluggish. Just like we can &amp;ldquo;defer&amp;rdquo; a value that takes too long to fetch (and show its old value despite other components updating), we can do this with trees that take too long to render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483a41989a3f28face460eaf57d7dae044787b9f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;useDeferredValue&lt;/code&gt; is not &lt;em&gt;only&lt;/em&gt; useful for data fetching. It also helps when an expensive component tree causes an interaction (e.g. typing in an input) to be sluggish. Just like we can &amp;ldquo;defer&amp;rdquo; a value that takes too long to fetch (and show its old value despite others components updating), we can do this with trees that take too long to render.</source>
          <target state="translated">Стоит отметить, что &lt;code&gt;useDeferredValue&lt;/code&gt; полезен не &lt;em&gt;только&lt;/em&gt; для выборки данных. Это также помогает, когда дорогостоящее дерево компонентов вызывает вялое взаимодействие (например, ввод ввода). Точно так же, как мы можем &amp;laquo;отложить&amp;raquo; значение, получение которого занимает слишком много времени (и показать его старое значение, несмотря на обновление других компонентов), мы можем сделать это с деревьями, отображение которых занимает слишком много времени.</target>
        </trans-unit>
        <trans-unit id="55b65216aa0540eaf6506a4435bb83e1e7f8f013" translate="yes" xml:space="preserve">
          <source>JAWS in Internet Explorer</source>
          <target state="translated">JAWS в Internet Explorer</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="1390ed0a23d1a0f6a989a72f7740422bce623820" translate="yes" xml:space="preserve">
          <source>JSX Children</source>
          <target state="translated">JSX Дети</target>
        </trans-unit>
        <trans-unit id="5a08e455cb80c9325d21ca392ead0811d7f7928f" translate="yes" xml:space="preserve">
          <source>JSX In Depth</source>
          <target state="translated">JSX в глубину</target>
        </trans-unit>
        <trans-unit id="d79f80b3f74dfa812404ff28047b6abd93ce00a8" translate="yes" xml:space="preserve">
          <source>JSX Prevents Injection Attacks</source>
          <target state="translated">JSX предотвращает инъекционные атаки</target>
        </trans-unit>
        <trans-unit id="201092e5747855ff7f46489df7db6fec3735acac" translate="yes" xml:space="preserve">
          <source>JSX Represents Objects</source>
          <target state="translated">JSX представляет объекты</target>
        </trans-unit>
        <trans-unit id="f821c0797aa66329cd5b6a52d7b985154fb5e626" translate="yes" xml:space="preserve">
          <source>JSX allows &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embedding any expression&lt;/a&gt; in curly braces so we could inline the &lt;code&gt;map()&lt;/code&gt; result:</source>
          <target state="translated">JSX позволяет &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;заключить любое выражение&lt;/a&gt; в фигурные скобки, чтобы мы могли встроить результат &lt;code&gt;map()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f572ba8add6be836659fce1a76a91186f8683f81" translate="yes" xml:space="preserve">
          <source>JSX is a syntax extension to JavaScript. It is similar to a template language, but it has full power of JavaScript. JSX gets compiled to &lt;code&gt;React.createElement()&lt;/code&gt; calls which return plain JavaScript objects called &amp;ldquo;React elements&amp;rdquo;. To get a basic introduction to JSX &lt;a href=&quot;introducing-jsx&quot;&gt;see the docs here&lt;/a&gt; and find a more in-depth tutorial on JSX &lt;a href=&quot;jsx-in-depth&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">JSX - это синтаксическое расширение JavaScript. Он похож на язык шаблонов, но имеет все возможности JavaScript. JSX компилируется в &lt;code&gt;React.createElement()&lt;/code&gt; которые возвращают простые объекты JavaScript, называемые &amp;laquo;элементами React&amp;raquo;. Чтобы получить базовое представление о JSX, &lt;a href=&quot;introducing-jsx&quot;&gt;просмотрите документацию здесь&lt;/a&gt; и найдите более подробное руководство по JSX &lt;a href=&quot;jsx-in-depth&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a6badf2480a79666ab2a50ef49c41eec53e3e92" translate="yes" xml:space="preserve">
          <source>JSX is an Expression Too</source>
          <target state="translated">JSX-это слишком экспрессия</target>
        </trans-unit>
        <trans-unit id="a7d41082c94e0ade95a8097ecf33e2cb44acdb09" translate="yes" xml:space="preserve">
          <source>JSX is not a requirement for using React. Using React without JSX is especially convenient when you don&amp;rsquo;t want to set up compilation in your build environment.</source>
          <target state="translated">JSX не является обязательным требованием для использования React. Использование React без JSX особенно удобно, если вы не хотите настраивать компиляцию в среде сборки.</target>
        </trans-unit>
        <trans-unit id="dd38b28ee1a9a309326f94891c1df14009e831fa" translate="yes" xml:space="preserve">
          <source>JSX produces React &amp;ldquo;elements&amp;rdquo;. We will explore rendering them to the DOM in the &lt;a href=&quot;rendering-elements&quot;&gt;next section&lt;/a&gt;. Below, you can find the basics of JSX necessary to get you started.</source>
          <target state="translated">JSX производит &amp;laquo;элементы&amp;raquo; React. Мы рассмотрим их рендеринг в DOM в &lt;a href=&quot;rendering-elements&quot;&gt;следующем разделе&lt;/a&gt; . Ниже вы можете найти основы JSX, необходимые для начала работы.</target>
        </trans-unit>
        <trans-unit id="e5c0788f2156485e43ec1aec3f13813b6ce0ec76" translate="yes" xml:space="preserve">
          <source>JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing:</source>
          <target state="translated">JSX удаляет пробелы в начале и в конце строки.Он также удаляет пустые строки.Удаляются новые строки,примыкающие к тегам;новые строки,встречающиеся в середине строковых литералов,конденсируются в один пробел.Таким образом,все они рендерингуют в одно и то же место:</target>
        </trans-unit>
        <trans-unit id="e557a0ad7b8dd428002b075a12a339460bf81183" translate="yes" xml:space="preserve">
          <source>JSX tags may contain children:</source>
          <target state="translated">JSX-теги могут содержать детей:</target>
        </trans-unit>
        <trans-unit id="c88547a44d266cdafe70fec17001f13058415c5b" translate="yes" xml:space="preserve">
          <source>JavaScript Environment Requirements</source>
          <target state="translated">Требования к среде JavaScript</target>
        </trans-unit>
        <trans-unit id="191332a52bb73fc079e6c2be8fbab52a7b9b0c79" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions as Children</source>
          <target state="translated">Выражения на JavaScript в детстве</target>
        </trans-unit>
        <trans-unit id="f86b0b485fe227f9926cd86119e4d67d9db9cb41" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions as Props</source>
          <target state="translated">Выражения JavaScript в качестве реквизита</target>
        </trans-unit>
        <trans-unit id="8262e0b313f4b908f2bfa1fa8c04c78e05342554" translate="yes" xml:space="preserve">
          <source>JavaScript Resources</source>
          <target state="translated">JavaScript-ресурсы</target>
        </trans-unit>
        <trans-unit id="3ab669d11c2053c3096b0ce975c409719b9ab1f3" translate="yes" xml:space="preserve">
          <source>JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates:</source>
          <target state="translated">Выражения JavaScript можно смешивать с другими типами детей.Это часто полезно вместо строковых шаблонов:</target>
        </trans-unit>
        <trans-unit id="fdc6b5ae1ed04a526c0403c39f6d892a4884f28f" translate="yes" xml:space="preserve">
          <source>Jest is widely compatible with React projects, supporting features like mocked &lt;a href=&quot;#mocking-modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;#mocking-timers&quot;&gt;timers&lt;/a&gt;, and &lt;a href=&quot;#mocking-a-rendering-surface&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt; support. &lt;strong&gt;If you use Create React App, &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests&quot;&gt;Jest is already included out of the box&lt;/a&gt; with useful defaults.&lt;/strong&gt;</source>
          <target state="translated">Jest широко совместим с проектами React, поддерживая такие функции, как &lt;a href=&quot;#mocking-a-rendering-surface&quot;&gt; &lt;code&gt;jsdom&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#mocking-modules&quot;&gt; модулей&lt;/a&gt; и &lt;a href=&quot;#mocking-timers&quot;&gt;таймеры&lt;/a&gt; , а также поддержку jsdom . &lt;strong&gt;Если вы используете приложение Create React, &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests&quot;&gt;Jest уже включен из коробки&lt;/a&gt; с полезными значениями по умолчанию.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains разрабатывает и поддерживает несколько инструментов специально для сообщества &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React&lt;/a&gt; : привязки React, а также приложение &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin&lt;/a&gt; . Последний поможет вам начать создавать приложения React с Kotlin без конфигурации сборки.</target>
        </trans-unit>
        <trans-unit id="26f4f29dc54a0429c9c6356ba883190a57985b95" translate="yes" xml:space="preserve">
          <source>Just because it&amp;rsquo;s possible, doesn&amp;rsquo;t mean that it&amp;rsquo;s the best approach for React apps. We encourage you to use React components when you can. React components are easier to reuse in React applications, and often provide more control over their behavior and appearance.</source>
          <target state="translated">Просто потому, что это возможно, не означает, что это лучший подход для приложений React. Мы рекомендуем вам по возможности использовать компоненты React. Компоненты React легче повторно использовать в приложениях React, и они часто обеспечивают больший контроль над их поведением и внешним видом.</target>
        </trans-unit>
        <trans-unit id="59c6c9a90cc15a2b6bbb52187ffa7d5c291abb80" translate="yes" xml:space="preserve">
          <source>Just like in JavaScript, it is up to you to choose an appropriate style based on what you and your team consider more readable. Also remember that whenever conditions become too complex, it might be a good time to &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract a component&lt;/a&gt;.</source>
          <target state="translated">Как и в случае с JavaScript, вы должны выбрать подходящий стиль, исходя из того, что вы и ваша команда считаете более читабельным. Также помните, что когда условия становятся слишком сложными, это может быть хорошее время для &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;извлечения компонента&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e19fb11d1b21bc4e9e11220a38333f6f51bc6998" translate="yes" xml:space="preserve">
          <source>Just like in a real browser, jsdom lets us model user interactions; tests can dispatch events on DOM nodes, and then observe and assert on the side effects of these actions &lt;a href=&quot;testing-recipes#events&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;.</source>
          <target state="translated">Как и в реальном браузере, jsdom позволяет нам моделировать взаимодействие с пользователем; тесты могут отправлять события на узлы DOM, а затем наблюдать и утверждать побочные эффекты этих действий &lt;a href=&quot;testing-recipes#events&quot;&gt;&lt;small&gt;(пример)&lt;/small&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04a953b2cc6af815cf1d538af4ea7e0cdd73a8c9" translate="yes" xml:space="preserve">
          <source>Just like with &lt;code&gt;useState&lt;/code&gt;, you can use more than a single effect in a component:</source>
          <target state="translated">Как и в случае с &lt;code&gt;useState&lt;/code&gt; , в компоненте можно использовать более одного эффекта:</target>
        </trans-unit>
        <trans-unit id="0417f986bcfb4e8e2b6c2b20736543a236a42518" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; is composable, like anything in React. For example, you can create a grid by putting several &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; rows inside a &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; table.</source>
          <target state="translated">Имейте в виду, что &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; можно компоновать, как и все в React. Например, вы можете создать сетку, поставив несколько &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; строк внутри &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; таблицы.</target>
        </trans-unit>
        <trans-unit id="07019d7742ef51cadec0c4168d9dbc4ff41a327c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;useRef&lt;/code&gt;&lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; notify you when its content changes. Mutating the &lt;code&gt;.current&lt;/code&gt; property doesn&amp;rsquo;t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a &lt;a href=&quot;hooks-faq#how-can-i-measure-a-dom-node&quot;&gt;callback ref&lt;/a&gt; instead.</source>
          <target state="translated">Имейте в виду, что &lt;code&gt;useRef&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; уведомляет вас об изменении своего содержимого. Изменение свойства &lt;code&gt;.current&lt;/code&gt; не вызывает повторного рендеринга. Если вы хотите запустить какой-либо код, когда React присоединяет или отключает ссылку на узел DOM, вы можете вместо этого использовать &lt;a href=&quot;hooks-faq#how-can-i-measure-a-dom-node&quot;&gt;ссылку обратного вызова&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2fa659e6371af8e34371298a054c6fa0b8e3f4e6" translate="yes" xml:space="preserve">
          <source>Keep scrolling down, and you&amp;rsquo;ll find the link to the &lt;a href=&quot;introducing-jsx&quot;&gt;next chapter of this guide&lt;/a&gt; right before the website footer.</source>
          <target state="translated">Продолжайте прокручивать страницу вниз, и вы найдете ссылку на &lt;a href=&quot;introducing-jsx&quot;&gt;следующую главу этого руководства&lt;/a&gt; прямо перед нижним колонтитулом веб-сайта.</target>
        </trans-unit>
        <trans-unit id="4a277208935542103e33cce1ec94231bfcbe2812" translate="yes" xml:space="preserve">
          <source>Keep using &lt;code&gt;createReactClass&lt;/code&gt;.</source>
          <target state="translated">Продолжайте использовать &lt;code&gt;createReactClass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3961da9502b1e99387aff089f5c83ca94c5c588d" translate="yes" xml:space="preserve">
          <source>Keyboard Events</source>
          <target state="translated">События на клавиатуре</target>
        </trans-unit>
        <trans-unit id="a63562f9dc59d3d173ce1da297fea061eda935fe" translate="yes" xml:space="preserve">
          <source>Keyboard focus and focus outline</source>
          <target state="translated">Фокус клавиатуры и контур фокуса</target>
        </trans-unit>
        <trans-unit id="71a38cea4a8ef2893215c7068a770d00cbeee9f2" translate="yes" xml:space="preserve">
          <source>Keyboard focus refers to the current element in the DOM that is selected to accept input from the keyboard. We see it everywhere as a focus outline similar to that shown in the following image:</source>
          <target state="translated">Под фокусом клавиатуры понимается текущий элемент на флэш-накопителе,выбранный для приема ввода с клавиатуры.Мы видим его повсюду в виде контура фокуса,похожего на тот,который показан на следующем изображении:</target>
        </trans-unit>
        <trans-unit id="7ea41b7bfa6e4c0a74c593ca76797a28b26b665e" translate="yes" xml:space="preserve">
          <source>Keyed Fragments</source>
          <target state="translated">Ключевые фрагменты</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="033fe9e03aa157b184cec9c5c36765ae681fc7ed" translate="yes" xml:space="preserve">
          <source>Keys Must Only Be Unique Among Siblings</source>
          <target state="translated">Ключи должны быть только уникальными среди братьев и сестер.</target>
        </trans-unit>
        <trans-unit id="58d08b1dcb85c35147a1b3441c0c392efd3a8241" translate="yes" xml:space="preserve">
          <source>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:</source>
          <target state="translated">Клавиши помощи Реагировать определить,какие элементы изменились,добавлены или удалены.Ключи должны быть отданы элементам внутри массива,чтобы придать элементам стабильную идентичность:</target>
        </trans-unit>
        <trans-unit id="c207367e515ac72a16c2932ecfa02b3376650bf0" translate="yes" xml:space="preserve">
          <source>Keys only make sense in the context of the surrounding array.</source>
          <target state="translated">Ключи имеют смысл только в контексте окружающего массива.</target>
        </trans-unit>
        <trans-unit id="21b4e388c860748250255ac3aec6577a53bb08ca" translate="yes" xml:space="preserve">
          <source>Keys only need to be unique among sibling elements in the same array. They don&amp;rsquo;t need to be unique across the whole application or even a single component.</source>
          <target state="translated">Ключи должны быть уникальными только среди элементов-братьев в одном массиве. Они не обязательно должны быть уникальными для всего приложения или даже для одного компонента.</target>
        </trans-unit>
        <trans-unit id="f269f84d4b420a7eccc734c9f3e4bbe7ec1e654b" translate="yes" xml:space="preserve">
          <source>Keys serve as a hint to React but they don&amp;rsquo;t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name:</source>
          <target state="translated">Ключи служат подсказкой для React, но они не передаются вашим компонентам. Если вам нужно такое же значение в вашем компоненте, передайте его явно как опору с другим именем:</target>
        </trans-unit>
        <trans-unit id="4eb803361f1db02c12313aa22ea43364fef308c9" translate="yes" xml:space="preserve">
          <source>Keys should be stable, predictable, and unique. Unstable keys (like those produced by &lt;code&gt;Math.random()&lt;/code&gt;) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.</source>
          <target state="translated">Ключи должны быть стабильными, предсказуемыми и уникальными. Нестабильные ключи (например, созданные &lt;code&gt;Math.random()&lt;/code&gt; ) приведут к ненужному воссозданию многих экземпляров компонентов и узлов DOM, что может вызвать снижение производительности и потерю состояния дочерних компонентов.</target>
        </trans-unit>
        <trans-unit id="46d2b02a27e73ea54e2ad8018f1f566c76419e35" translate="yes" xml:space="preserve">
          <source>Keys used within arrays should be unique among their siblings. However they don&amp;rsquo;t need to be globally unique. We can use the same keys when we produce two different arrays:</source>
          <target state="translated">Ключи, используемые в массивах, должны быть уникальными среди своих братьев и сестер. Однако они не обязательно должны быть уникальными в глобальном масштабе. Мы можем использовать одни и те же ключи при создании двух разных массивов:</target>
        </trans-unit>
        <trans-unit id="b950ddccc3180b1568a4677560f1be2e72ae0d05" translate="yes" xml:space="preserve">
          <source>Knowledge Level Assumptions</source>
          <target state="translated">Допущения уровня знаний</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="087f43dec679500a381105d8177480d92e5bc6f7" translate="yes" xml:space="preserve">
          <source>Labeling</source>
          <target state="translated">Labeling</target>
        </trans-unit>
        <trans-unit id="86ade0000eab7713840cb80442178dbad165e1c7" translate="yes" xml:space="preserve">
          <source>Later, you write a component for subscribing to a single blog post, which follows a similar pattern:</source>
          <target state="translated">Позже вы пишете компонент для подписки на один пост в блоге,который следует аналогичному шаблону:</target>
        </trans-unit>
        <trans-unit id="4e81f878f11e9186c40f41b370cbeff1223f6553" translate="yes" xml:space="preserve">
          <source>Latest Channel</source>
          <target state="translated">Последний канал</target>
        </trans-unit>
        <trans-unit id="801295034f8f587a8731684b0829ce3fafe33d56" translate="yes" xml:space="preserve">
          <source>Latest is the channel used for stable React releases. It corresponds to the &lt;code&gt;latest&lt;/code&gt; tag on npm. It is the recommended channel for all React apps that are shipped to real users.</source>
          <target state="translated">Последний - это канал, используемый для стабильных выпусков React. Он соответствует &lt;code&gt;latest&lt;/code&gt; тегу в npm. Это рекомендуемый канал для всех приложений React, которые отправляются реальным пользователям.</target>
        </trans-unit>
        <trans-unit id="09dea8b1934495cf50be92926eded5430df29f58" translate="yes" xml:space="preserve">
          <source>Lazy initial state</source>
          <target state="translated">ленивое исходное состояние</target>
        </trans-unit>
        <trans-unit id="0aa93a4477a941d54e9e6489ff5a7fb43a5339e0" translate="yes" xml:space="preserve">
          <source>Lazy initialization</source>
          <target state="translated">ленивая инициализация</target>
        </trans-unit>
        <trans-unit id="e1c5a8ff2c0a4cee2266af52e69d8ea217bc6355" translate="yes" xml:space="preserve">
          <source>Learn Gatsby from &lt;a href=&quot;https://www.gatsbyjs.org/docs/&quot;&gt;its official guide&lt;/a&gt; and a &lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-starters/&quot;&gt;gallery of starter kits&lt;/a&gt;.</source>
          <target state="translated">Изучите Гэтсби из &lt;a href=&quot;https://www.gatsbyjs.org/docs/&quot;&gt;его официального руководства&lt;/a&gt; и &lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-starters/&quot;&gt;галереи стартовых наборов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="378cbbf54cbb2e3f3bd201f02c1b946ec3601eba" translate="yes" xml:space="preserve">
          <source>Learn More</source>
          <target state="translated">Узнать больше</target>
        </trans-unit>
        <trans-unit id="47738a476129c3a8cb6d980e52a9a75eb86f2183" translate="yes" xml:space="preserve">
          <source>Learn Next.js from &lt;a href=&quot;https://nextjs.org/learn/&quot;&gt;its official guide&lt;/a&gt;.</source>
          <target state="translated">Изучите Next.js из &lt;a href=&quot;https://nextjs.org/learn/&quot;&gt;его официального руководства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="802c853c766c4a1fb751dfe0a5007088efb8fff9" translate="yes" xml:space="preserve">
          <source>Learn React</source>
          <target state="translated">Учиться реагировать</target>
        </trans-unit>
        <trans-unit id="6c1aff18b114655a3728004f5ddf84acf496ed61" translate="yes" xml:space="preserve">
          <source>Learn more about it at &lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;fb.me/react-interaction-tracing&lt;/a&gt;</source>
          <target state="translated">Узнайте больше об этом на &lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;fb.me/react-interaction-tracing.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74783fcd98611ef8c679d0b35c17456b50fdbdab" translate="yes" xml:space="preserve">
          <source>Learn more about setState</source>
          <target state="translated">Узнать больше о setState</target>
        </trans-unit>
        <trans-unit id="3d9e1ea32612926012e0f27c2e2d3bc9d3504c65" translate="yes" xml:space="preserve">
          <source>Learn more about the new &lt;code&gt;createRef&lt;/code&gt; API here.</source>
          <target state="translated">Узнайте больше о новом API &lt;code&gt;createRef&lt;/code&gt; здесь.</target>
        </trans-unit>
        <trans-unit id="d12363dec3cec522658520bb14b574d2c38d4a9b" translate="yes" xml:space="preserve">
          <source>Legacy API</source>
          <target state="translated">API наследия</target>
        </trans-unit>
        <trans-unit id="dde4f866b5827a3ecdb1b59f566920d28fc762d3" translate="yes" xml:space="preserve">
          <source>Legacy API: String Refs</source>
          <target state="translated">API наследия:Ссылки на струны</target>
        </trans-unit>
        <trans-unit id="e5b92b7804190333f8d5aa0581703f3b2664d74b" translate="yes" xml:space="preserve">
          <source>Legacy Context</source>
          <target state="translated">Наследственный контекст</target>
        </trans-unit>
        <trans-unit id="673ce3a3969d34565237049f3b8553b6bff614da" translate="yes" xml:space="preserve">
          <source>Legacy Lifecycle Methods</source>
          <target state="translated">Методы жизненного цикла наследия</target>
        </trans-unit>
        <trans-unit id="0ebe4f64c19e892054a7737b95e642e4103d4505" translate="yes" xml:space="preserve">
          <source>Legacy Mode</source>
          <target state="translated">Режим наследия</target>
        </trans-unit>
        <trans-unit id="e41df52dcff2d5fb3f135df9c40c44c902c43f73" translate="yes" xml:space="preserve">
          <source>Lessons Learned</source>
          <target state="translated">Извлеченные уроки</target>
        </trans-unit>
        <trans-unit id="59538c378635dc8630feb1d884595472a4a714c5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s Get Started!</source>
          <target state="translated">Давайте начнем!</target>
        </trans-unit>
        <trans-unit id="83ad68c13a4560eb3e6da14fe3991a29f25a12c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assign a &lt;code&gt;key&lt;/code&gt; to our list items inside &lt;code&gt;numbers.map()&lt;/code&gt; and fix the missing key issue.</source>
          <target state="translated">Давайте назначим &lt;code&gt;key&lt;/code&gt; элементам нашего списка внутри &lt;code&gt;numbers.map()&lt;/code&gt; и исправим проблему с отсутствующим ключом.</target>
        </trans-unit>
        <trans-unit id="62e35c44c6745b986cc311a397ff72118a2f50c3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s compare how different data fetching strategies deal with this requirement.</source>
          <target state="translated">Давайте сравним, как разные стратегии выборки данных справляются с этим требованием.</target>
        </trans-unit>
        <trans-unit id="45e9d17f03076a3ad9477b82b07a51d4ce77f838" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get back to our &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;first Suspense demo&lt;/a&gt; where there was just one profile. Currently, it fetches the data only once. We&amp;rsquo;ll add a &amp;ldquo;Refresh&amp;rdquo; button to check for server updates.</source>
          <target state="translated">Вернемся к нашему &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;первому демо Suspense,&lt;/a&gt; где был только один профиль. В настоящее время он получает данные только один раз. Мы добавим кнопку &amp;laquo;Обновить&amp;raquo; для проверки обновлений сервера.</target>
        </trans-unit>
        <trans-unit id="f2172c9119c229d11c473d5df9aa8d5d8d41b93a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go over these in detail.</source>
          <target state="translated">Давайте рассмотрим их подробнее.</target>
        </trans-unit>
        <trans-unit id="c35b4f5f51eb24f390b73104414deef66768949e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go through each one and figure out which one is state. Ask three questions about each piece of data:</source>
          <target state="translated">Давайте рассмотрим каждый из них и выясним, какой из них является государством. Задайте три вопроса по каждому фрагменту данных:</target>
        </trans-unit>
        <trans-unit id="efb2b5e509c3f39d850f9c0bc68afe5b00ce8cbb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now &lt;strong&gt;recap what we learned line by line&lt;/strong&gt; and check our understanding.</source>
          <target state="translated">Давайте теперь &lt;strong&gt;повторим то, что мы узнали, строка за строкой&lt;/strong&gt; и проверим наше понимание.</target>
        </trans-unit>
        <trans-unit id="2db586e06ea830a0bf5bd7eba403ec7c7c1d5191" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s quickly recap what&amp;rsquo;s going on and the order in which the methods are called:</source>
          <target state="translated">Давайте быстро вспомним, что происходит, и порядок, в котором вызываются методы:</target>
        </trans-unit>
        <trans-unit id="b731235df3a08f9cefe099e4a2b6bfde68c1ff0c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap the two examples above and see how Concurrent Mode unifies them. &lt;strong&gt;In Concurrent Mode, React can work on several state updates &lt;em&gt;concurrently&lt;/em&gt;&lt;/strong&gt; &amp;mdash; just like branches let different team members work independently:</source>
          <target state="translated">Давайте вспомним два приведенных выше примера и посмотрим, как Concurrent Mode объединяет их. &lt;strong&gt;В параллельном режиме React может работать с несколькими обновлениями состояния &lt;em&gt;одновременно&lt;/em&gt;&lt;/strong&gt; - точно так же, как ветки позволяют различным членам команды работать независимо:</target>
        </trans-unit>
        <trans-unit id="27b3965c34758d4b1e54e8fcc6e8e8d971b07cb2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what happens in this example:</source>
          <target state="translated">Напомним, что происходит в этом примере:</target>
        </trans-unit>
        <trans-unit id="87dc62cffe0ac1c4c5391c6f0828660b4dd4a79a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what happens when you edit an input:</source>
          <target state="translated">Давайте вспомним, что происходит, когда вы редактируете ввод:</target>
        </trans-unit>
        <trans-unit id="3eca8e8ef68c829498c7d9e68354b1472e530462" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s revisit &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;this demo&lt;/a&gt; from the previous page about &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching&lt;/a&gt;.</source>
          <target state="translated">Давайте вернемся к &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;этой демонстрации&lt;/a&gt; с предыдущей страницы о &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;приостановке для выборки данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31e57dda434c35263f11856e0672be5db88ed7e8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite this example again, but using Suspense only:</source>
          <target state="translated">Давайте перепишем этот пример еще раз, но только с использованием Suspense:</target>
        </trans-unit>
        <trans-unit id="e68a7b21d6c5f27413fdb9eda1dd97e5fd7b5762" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run through this strategy for our application:</source>
          <target state="translated">Давайте рассмотрим эту стратегию для нашего приложения:</target>
        </trans-unit>
        <trans-unit id="85ef0e00ecbe33d94c5d49e91e16ab5645be9c88" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that fetching the user details is very fast and only takes 300 milliseconds. Currently, we&amp;rsquo;re waiting a whole second because we need both user details and posts to display a consistent profile page. But what if we want to show the details faster?</source>
          <target state="translated">Допустим, получение данных о пользователе происходит очень быстро и занимает всего 300 миллисекунд. В настоящее время мы ждем целую секунду, потому что нам нужны как данные пользователя, так и сообщения для отображения согласованной страницы профиля. Но что, если мы хотим показать детали быстрее?</target>
        </trans-unit>
        <trans-unit id="4991d5eafd8e8e062c0f087c85c40c1ea2d4cc4e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that this is the API we&amp;rsquo;re striving for with our &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; wrapper React component:</source>
          <target state="translated">Допустим, это API, к которому мы стремимся с помощью нашего компонента React оболочки &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2036fedebbcaf2b79f375bedb67a4420e6a7e60a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say there is a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; somewhere in your HTML file:</source>
          <target state="translated">Допустим, где-то в вашем HTML-файле есть &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e0dc0ebd0f6824d83a50f1aeaa18d1eaaf7cabfa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this works step by step.</source>
          <target state="translated">Давайте посмотрим, как это работает, шаг за шагом.</target>
        </trans-unit>
        <trans-unit id="65e8fb3a23f53b18cf26df347e321256ab7c212c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how we could write this component with Hooks.</source>
          <target state="translated">Давайте посмотрим, как мы могли бы написать этот компонент с помощью хуков.</target>
        </trans-unit>
        <trans-unit id="af6fa6b57cf391318ac0bf024b8e3823314cbcfa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see why this matters.</source>
          <target state="translated">Посмотрим, почему это важно.</target>
        </trans-unit>
        <trans-unit id="b577a0e161bcf81a4e96e3f3a99c76d5a54c4977" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at each of the props:</source>
          <target state="translated">Рассмотрим подробнее каждый реквизит:</target>
        </trans-unit>
        <trans-unit id="a23b9ea82a3fd528716ce8cd73af2430db7a55e4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take another look at all the changes we&amp;rsquo;ve made since the &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;original example&lt;/a&gt;:</source>
          <target state="translated">Давайте еще раз посмотрим на все изменения, которые мы внесли по сравнению с &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;исходным примером&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5910b527fe0e81b1ac837051111d1cfb45c48766" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, &lt;code&gt;FilterableProductTable&lt;/code&gt; will pass callbacks to &lt;code&gt;SearchBar&lt;/code&gt; that will fire whenever the state should be updated. We can use the &lt;code&gt;onChange&lt;/code&gt; event on the inputs to be notified of it. The callbacks passed by &lt;code&gt;FilterableProductTable&lt;/code&gt; will call &lt;code&gt;setState()&lt;/code&gt;, and the app will be updated.</source>
          <target state="translated">Давайте подумаем о том, чего мы хотим. Мы хотим быть уверены, что всякий раз, когда пользователь меняет форму, мы обновляем состояние, чтобы отражать ввод пользователя. Поскольку компоненты должны обновлять только свое собственное состояние, &lt;code&gt;FilterableProductTable&lt;/code&gt; будет передавать обратные вызовы в &lt;code&gt;SearchBar&lt;/code&gt; , которые будут срабатывать всякий раз, когда состояние должно быть обновлено. Мы можем использовать событие &lt;code&gt;onChange&lt;/code&gt; на входах, чтобы получать уведомления об этом. Обратные вызовы , принятые &lt;code&gt;FilterableProductTable&lt;/code&gt; будут называть &lt;code&gt;setState()&lt;/code&gt; , и приложение будет обновляться.</target>
        </trans-unit>
        <trans-unit id="1e893f82b5ddbd897be82bf493ce9e81174e5eb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try that:</source>
          <target state="translated">Попробуем это:</target>
        </trans-unit>
        <trans-unit id="b5f77d8b5f6dfc038e27b746c7a414fe97a3630d" translate="yes" xml:space="preserve">
          <source>Libraries can prevent waterfalls by offering a more centralized way to do data fetching. For example, Relay solves this problem by moving the information about the data a component needs to statically analyzable &lt;em&gt;fragments&lt;/em&gt;, which later get composed into a single query.</source>
          <target state="translated">Библиотеки могут предотвращать водопады, предлагая более централизованный способ получения данных. Например, Relay решает эту проблему, перемещая информацию о данных, необходимых компоненту, в статически анализируемые &lt;em&gt;фрагменты&lt;/em&gt; , которые позже объединяются в единый запрос.</target>
        </trans-unit>
        <trans-unit id="46000d17b247964f6470d045921aa1d6334b0a4b" translate="yes" xml:space="preserve">
          <source>Libraries like &lt;a href=&quot;https://mochajs.org/#running-mocha-in-the-browser&quot;&gt;mocha&lt;/a&gt; work well in real browser environments, and could help for tests that explicitly need it.</source>
          <target state="translated">Такие библиотеки, как &lt;a href=&quot;https://mochajs.org/#running-mocha-in-the-browser&quot;&gt;mocha,&lt;/a&gt; хорошо работают в реальных браузерных средах и могут помочь в тестах, где это явно необходимо.</target>
        </trans-unit>
        <trans-unit id="041313632fc218e701e7df8b55493ecd8a5123e5" translate="yes" xml:space="preserve">
          <source>Libraries that use render props include &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Route/render-func&quot;&gt;React Router&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/downshift&quot;&gt;Downshift&lt;/a&gt; and &lt;a href=&quot;https://github.com/jaredpalmer/formik&quot;&gt;Formik&lt;/a&gt;.</source>
          <target state="translated">Библиотеки, которые используют реквизиты рендеринга, включают &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Route/render-func&quot;&gt;React Router&lt;/a&gt; , &lt;a href=&quot;https://github.com/paypal/downshift&quot;&gt;Downshift&lt;/a&gt; и &lt;a href=&quot;https://github.com/jaredpalmer/formik&quot;&gt;Formik&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40721cc170a6bfccd149edbfe1dc276de96ccd33" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution 4.0 International Public License.</source>
          <target state="translated">Лицензия выдана в соответствии с международной общественной лицензией Creative Commons Attribution 4.0.</target>
        </trans-unit>
        <trans-unit id="17ff789df886ac8c1ebe62bba2f20adc6571666a" translate="yes" xml:space="preserve">
          <source>Lifecycle Methods</source>
          <target state="translated">Методы жизненного цикла</target>
        </trans-unit>
        <trans-unit id="17ec3a03bfeda0f665ab03b38f3ed1016d195b0e" translate="yes" xml:space="preserve">
          <source>Lifecycle methods are custom functionality that gets executed during the different phases of a component. There are methods available when the component gets created and inserted into the DOM (&lt;a href=&quot;react-component#mounting&quot;&gt;mounting&lt;/a&gt;), when the component updates, and when the component gets unmounted or removed from the DOM.</source>
          <target state="translated">Методы жизненного цикла - это настраиваемые функции, которые выполняются на разных этапах работы компонента. Существуют методы, доступные, когда компонент создается и вставляется в DOM ( &lt;a href=&quot;react-component#mounting&quot;&gt;монтирование&lt;/a&gt; ), когда компонент обновляется, и когда компонент размонтируется или удаляется из DOM.</target>
        </trans-unit>
        <trans-unit id="fe2783625398c73ad59607a3ac0e2c10a16bd848" translate="yes" xml:space="preserve">
          <source>Lifting State Up</source>
          <target state="translated">Подъемное состояние вверх</target>
        </trans-unit>
        <trans-unit id="60f96af2feedeafd8240d4e2179b169296b1ab38" translate="yes" xml:space="preserve">
          <source>Lifting state involves writing more &amp;ldquo;boilerplate&amp;rdquo; code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state &amp;ldquo;lives&amp;rdquo; in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input.</source>
          <target state="translated">Снятие состояния предполагает написание большего количества &amp;laquo;шаблонного&amp;raquo; кода, чем подходы с двусторонним связыванием, но, как преимущество, требуется меньше усилий для поиска и изоляции ошибок. Поскольку любое состояние &amp;laquo;живет&amp;raquo; в каком-то компоненте, и только этот компонент может его изменить, площадь поверхности для ошибок значительно сокращается. Кроме того, вы можете реализовать любую настраиваемую логику для отклонения или преобразования пользовательского ввода.</target>
        </trans-unit>
        <trans-unit id="6205c7daf26478bf62962f9d33d7bc15dfc34968" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#reactchildrenmap&quot;&gt;&lt;code&gt;React.Children.map()&lt;/code&gt;&lt;/a&gt; but does not return an array.</source>
          <target state="translated">Как &lt;a href=&quot;#reactchildrenmap&quot;&gt; &lt;code&gt;React.Children.map()&lt;/code&gt; &lt;/a&gt; , но не возвращает массив.</target>
        </trans-unit>
        <trans-unit id="1a7b45e8f4e6108d3cd632f0d9032c3748a2b4eb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#scryrendereddomcomponentswithclass&quot;&gt;&lt;code&gt;scryRenderedDOMComponentsWithClass()&lt;/code&gt;&lt;/a&gt; but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">Подобно &lt;a href=&quot;#scryrendereddomcomponentswithclass&quot;&gt; &lt;code&gt;scryRenderedDOMComponentsWithClass()&lt;/code&gt; &lt;/a&gt; но ожидает, что будет один результат, и возвращает этот единственный результат или выдает исключение, если есть любое другое количество совпадений, кроме одного.</target>
        </trans-unit>
        <trans-unit id="fbfeab98f1492d3cbd4fe154e243495eb88fd5bc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#scryrendereddomcomponentswithtag&quot;&gt;&lt;code&gt;scryRenderedDOMComponentsWithTag()&lt;/code&gt;&lt;/a&gt; but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">Подобно &lt;a href=&quot;#scryrendereddomcomponentswithtag&quot;&gt; &lt;code&gt;scryRenderedDOMComponentsWithTag()&lt;/code&gt; &lt;/a&gt; но ожидает, что будет один результат, и возвращает этот единственный результат, или выдает исключение, если есть любое другое количество совпадений, кроме одного.</target>
        </trans-unit>
        <trans-unit id="f9229dd48cd84c65e22bacddf9669feed15d9307" translate="yes" xml:space="preserve">
          <source>Like Next, the Experimental channel is a prerelease channel that tracks the master branch of the React repository. Unlike Next, Experimental releases include additional features and APIs that are not ready for wider release.</source>
          <target state="translated">Как и Next,экспериментальный канал-это канал предварительного выпуска,который отслеживает главную ветку репозитория React.В отличие от Next,экспериментальные релизы включают дополнительные функции и API,которые не готовы к более широкому выпуску.</target>
        </trans-unit>
        <trans-unit id="b243b275e73df60e527af74a2a1e22222d9d870a" translate="yes" xml:space="preserve">
          <source>Like any unfamiliar technology, React does have a learning curve. With practice and some patience, you &lt;em&gt;will&lt;/em&gt; get the hang of it.</source>
          <target state="translated">Как и любой незнакомой технологии, React требует обучения. С практикой и немного терпения, вы &lt;em&gt;будете&lt;/em&gt; получите повесить его.</target>
        </trans-unit>
        <trans-unit id="3b06e3b678326306ca6aedaf4c7b742dbd8cc493" translate="yes" xml:space="preserve">
          <source>Like components, the contract between &lt;code&gt;withSubscription&lt;/code&gt; and the wrapped component is entirely props-based. This makes it easy to swap one HOC for a different one, as long as they provide the same props to the wrapped component. This may be useful if you change data-fetching libraries, for example.</source>
          <target state="translated">Как и компоненты, контракт между &lt;code&gt;withSubscription&lt;/code&gt; и обернутым компонентом полностью основан на свойствах . Это упрощает замену одного HOC на другой при условии, что они предоставляют одинаковые свойства для обернутого компонента. Это может быть полезно, например, при изменении библиотек выборки данных.</target>
        </trans-unit>
        <trans-unit id="8756ee6b18f3a0b99d47c3487ab6bf4153dc005f" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;&amp;lt;input type=&quot;checkbox&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;input type=&quot;radio&quot;&amp;gt;&lt;/code&gt; support &lt;code&gt;defaultChecked&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; supports &lt;code&gt;defaultValue&lt;/code&gt;.</source>
          <target state="translated">Точно так же &lt;code&gt;&amp;lt;input type=&quot;checkbox&quot;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;input type=&quot;radio&quot;&amp;gt;&lt;/code&gt; поддерживают &lt;code&gt;defaultChecked&lt;/code&gt; , а &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; поддерживают &lt;code&gt;defaultValue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64b1d121df3542e14f97acaa2800f9f76542cac7" translate="yes" xml:space="preserve">
          <source>Linting in Flow</source>
          <target state="translated">Внутренняя вязь в потоке</target>
        </trans-unit>
        <trans-unit id="f3b64dc10b36fcc65c0d847eaaa62fd7fe512239" translate="yes" xml:space="preserve">
          <source>Lists and Keys</source>
          <target state="translated">Списки и ключи</target>
        </trans-unit>
        <trans-unit id="110bfe58a1735dfc3135bc1d5e016924d60c0744" translate="yes" xml:space="preserve">
          <source>Live Demo</source>
          <target state="translated">Живая демонстрация</target>
        </trans-unit>
        <trans-unit id="5f00bd7dc65bd809a53f2303fb70b92320c36fa6" translate="yes" xml:space="preserve">
          <source>Live-editing CSS and JS in development.</source>
          <target state="translated">Живое редактирование CSS и JS в разработке.</target>
        </trans-unit>
        <trans-unit id="dc841064cbfd066e159686f41aef96834b0e8bf6" translate="yes" xml:space="preserve">
          <source>Looking at the now generated &lt;code&gt;tsconfig.json&lt;/code&gt;, you can see that there are many options you can use to configure the compiler. For a detailed description of all the options, check &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Глядя на сгенерированный &lt;code&gt;tsconfig.json&lt;/code&gt; , можно увидеть, что существует множество параметров, которые можно использовать для настройки компилятора. Подробное описание всех опций смотрите &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f500ff46d146daea76d615ff5daed4f1aeaa0d00" translate="yes" xml:space="preserve">
          <source>MDN HTML elements reference</source>
          <target state="translated">ссылка на элементы MDN HTML</target>
        </trans-unit>
        <trans-unit id="d5beafe9207c5520f3ac09a7866f79c87d68f07b" translate="yes" xml:space="preserve">
          <source>MDN Web Docs takes a look at this and describes how we can build &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets&quot;&gt;keyboard-navigable JavaScript widgets&lt;/a&gt;.</source>
          <target state="translated">MDN Web Docs рассматривает это и описывает, как мы можем создавать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets&quot;&gt;виджеты JavaScript с возможностью навигации с клавиатуры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48b1316849f970c5b3e2af20718278c5b7793286" translate="yes" xml:space="preserve">
          <source>Main Concepts</source>
          <target state="translated">Основные концепции</target>
        </trans-unit>
        <trans-unit id="02ff3711bd667ed46bace9ec4c6ec8190ecebfcc" translate="yes" xml:space="preserve">
          <source>Major releases can also contain new features, and any release can include bug fixes.</source>
          <target state="translated">Мажорные выпуски также могут содержать новые возможности,и любой выпуск может включать исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="f18f93964d446c1e6ba3cd266eb85e86312f1773" translate="yes" xml:space="preserve">
          <source>Make sure you aren&amp;rsquo;t &lt;em&gt;calling the function&lt;/em&gt; when you pass it to the component:</source>
          <target state="translated">Убедитесь, что вы не &lt;em&gt;вызываете функцию&lt;/em&gt; при передаче ее компоненту:</target>
        </trans-unit>
        <trans-unit id="1908a834f7fac54b702b7157c4e6dc90e16f736a" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re familiar with simpler alternatives:</source>
          <target state="translated">Убедитесь, что вы знакомы с более простыми альтернативами:</target>
        </trans-unit>
        <trans-unit id="90e7115a4c3ac435e928084df77c98aa6a10ab0d" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re running the application in the development mode.</source>
          <target state="translated">Убедитесь, что вы запускаете приложение в режиме разработки.</target>
        </trans-unit>
        <trans-unit id="16f51d22d8fb5f4e18c7b9a43a14aa00fb1d1d71" translate="yes" xml:space="preserve">
          <source>Managing focus, text selection, or media playback.</source>
          <target state="translated">Управление фокусом,выбором текста или воспроизведением мультимедиа.</target>
        </trans-unit>
        <trans-unit id="63ee04fb3d96bb1368dfb5a70eed53b537b4cf07" translate="yes" xml:space="preserve">
          <source>Many React users credit reading &lt;a href=&quot;thinking-in-react&quot;&gt;Thinking in React&lt;/a&gt; as the moment React finally &amp;ldquo;clicked&amp;rdquo; for them. It&amp;rsquo;s probably the oldest React walkthrough but it&amp;rsquo;s still just as relevant.</source>
          <target state="translated">Многие пользователи React считают, что чтение &amp;laquo; &lt;a href=&quot;thinking-in-react&quot;&gt;Thinking in React&amp;raquo;&lt;/a&gt; - это момент, когда React наконец &amp;laquo;щелкнул&amp;raquo; для них. Это, вероятно, самое старое пошаговое руководство по React, но оно не менее актуально.</target>
        </trans-unit>
        <trans-unit id="25207d84725584b98b20c010ae4e867354803e86" translate="yes" xml:space="preserve">
          <source>Maybe.</source>
          <target state="translated">Maybe.</target>
        </trans-unit>
        <trans-unit id="5279878671cef1bbee173e636b630698108458c0" translate="yes" xml:space="preserve">
          <source>Mechanisms to skip to desired content</source>
          <target state="translated">Механизмы перехода к желаемому содержанию</target>
        </trans-unit>
        <trans-unit id="80ebd3a5b45a9f5adf87a363ab82624e164a1745" translate="yes" xml:space="preserve">
          <source>Media Events</source>
          <target state="translated">Медиа События</target>
        </trans-unit>
        <trans-unit id="2fce9fc1bba59eae6ae511090a30e9f9acda79af" translate="yes" xml:space="preserve">
          <source>Migration Step: Blocking Mode</source>
          <target state="translated">Шаг миграции:Режим блокировки</target>
        </trans-unit>
        <trans-unit id="c51e9091bf1aa90a7dc06f8b80d1cf4f79106e04" translate="yes" xml:space="preserve">
          <source>Minor releases are the most common type of release.</source>
          <target state="translated">Мелкие выпуски-наиболее распространенный тип выпуска.</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="e609b515d8887ae3c0a2bcd948b76d5eb888dcae" translate="yes" xml:space="preserve">
          <source>Mocking Modules</source>
          <target state="translated">Издевательские модули</target>
        </trans-unit>
        <trans-unit id="5fd5e79fcfd93473fe47f93cc81171186377bc01" translate="yes" xml:space="preserve">
          <source>Mocking a rendering surface</source>
          <target state="translated">Издевательство над поверхностью рендеринга</target>
        </trans-unit>
        <trans-unit id="9f9db431c0932c551ce8ea2f4c40d441d4aa97a6" translate="yes" xml:space="preserve">
          <source>Mocking functions</source>
          <target state="translated">Издевательские функции</target>
        </trans-unit>
        <trans-unit id="7e3ebffe5140fcd669b91ded83765eee7cd79ed7" translate="yes" xml:space="preserve">
          <source>Mocking modules</source>
          <target state="translated">Издевательские модули</target>
        </trans-unit>
        <trans-unit id="dfc6f7ed11adb29245ad928339ee3fe94bf8f96c" translate="yes" xml:space="preserve">
          <source>Mocking timers</source>
          <target state="translated">Издевательские таймеры</target>
        </trans-unit>
        <trans-unit id="c5ab7c68a15742b6ace6a0b59f0802cd56989f9d" translate="yes" xml:space="preserve">
          <source>More Complex Widgets</source>
          <target state="translated">Более сложные виджеты</target>
        </trans-unit>
        <trans-unit id="ae1e9c89527fbc96f2921cbe93fbfc11e6a52a9a" translate="yes" xml:space="preserve">
          <source>More Flexible Toolchains</source>
          <target state="translated">Более гибкие цепи инструментов</target>
        </trans-unit>
        <trans-unit id="c42df7c665642f754f240ed7f247eeed80d1ceb3" translate="yes" xml:space="preserve">
          <source>More concretely, &lt;strong&gt;a render prop is a function prop that a component uses to know what to render.&lt;/strong&gt;</source>
          <target state="translated">Точнее говоря, &lt;strong&gt;свойство рендеринга - это свойство функции, которое компонент использует, чтобы знать, что рендерить.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4184dc3093adbdaf5a60e796e014a24e3eb74b2" translate="yes" xml:space="preserve">
          <source>Most React apps will have their files &amp;ldquo;bundled&amp;rdquo; using tools like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Bundling is the process of following imported files and merging them into a single file: a &amp;ldquo;bundle&amp;rdquo;. This bundle can then be included on a webpage to load an entire app at once.</source>
          <target state="translated">Файлы большинства приложений React будут &amp;laquo;объединены&amp;raquo; с помощью таких инструментов, как &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; , &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; или &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; . Объединение - это процесс отслеживания импортированных файлов и их объединения в один файл: &amp;laquo;пакет&amp;raquo;. Затем этот пакет можно включить на веб-страницу для одновременной загрузки всего приложения.</target>
        </trans-unit>
        <trans-unit id="7f5a32a23f908873850adbc01e3bfc083647f135" translate="yes" xml:space="preserve">
          <source>Most of the time, you can use &lt;code&gt;React.PureComponent&lt;/code&gt; instead of writing your own &lt;code&gt;shouldComponentUpdate&lt;/code&gt;. It only does a shallow comparison, so you can&amp;rsquo;t use it if the props or state may have been mutated in a way that a shallow comparison would miss.</source>
          <target state="translated">В большинстве случаев вы можете использовать &lt;code&gt;React.PureComponent&lt;/code&gt; вместо написания собственного &lt;code&gt;shouldComponentUpdate&lt;/code&gt; . Он выполняет только поверхностное сравнение, поэтому вы не можете использовать его, если свойства или состояние могли быть изменены таким образом, что поверхностное сравнение будет пропущено.</target>
        </trans-unit>
        <trans-unit id="0d6ec3d67d6c3f4388c5225ce97b912bc6998b9b" translate="yes" xml:space="preserve">
          <source>Most people who use React don&amp;rsquo;t use Web Components, but you may want to, especially if you are using third-party UI components that are written using Web Components.</source>
          <target state="translated">Большинство людей, которые используют React, не используют веб-компоненты, но вы можете захотеть, особенно если вы используете сторонние компоненты пользовательского интерфейса, написанные с использованием веб-компонентов.</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="26ae06ab481b93e012f7ab95465638d5fb60ed34" translate="yes" xml:space="preserve">
          <source>Mounting</source>
          <target state="translated">Mounting</target>
        </trans-unit>
        <trans-unit id="b239ecd4f1b125963a812db57dc3cec60573502b" translate="yes" xml:space="preserve">
          <source>Mouse Events</source>
          <target state="translated">Мышей События</target>
        </trans-unit>
        <trans-unit id="7b20c10dce51324fb107e751c01666324956e394" translate="yes" xml:space="preserve">
          <source>Mouse and pointer events</source>
          <target state="translated">События с мышью и указателями</target>
        </trans-unit>
        <trans-unit id="4d1e7bad76871046ddf523d9fe663dd3a621512b" translate="yes" xml:space="preserve">
          <source>Move the body of the function into the &lt;code&gt;render()&lt;/code&gt; method.</source>
          <target state="translated">Переместите тело функции в метод &lt;code&gt;render()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b29de6bcd589e86e040638485090ea2a9bf182d" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;Profiler&lt;/code&gt; components can be used to measure different parts of an application:</source>
          <target state="translated">Для измерения различных частей приложения можно использовать несколько компонентов &lt;code&gt;Profiler&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8e23b3461f95ee737c2d746ec92f09e64df8c67e" translate="yes" xml:space="preserve">
          <source>Multiple Renderers</source>
          <target state="translated">Многократные арендаторы</target>
        </trans-unit>
        <trans-unit id="b0479fd15fec4ef8ee834648226853be71fdeda8" translate="yes" xml:space="preserve">
          <source>Mutating HOCs are a leaky abstraction&amp;mdash;the consumer must know how they are implemented in order to avoid conflicts with other HOCs.</source>
          <target state="translated">Мутирующие HOC - это ненадежная абстракция - потребитель должен знать, как они реализованы, чтобы избежать конфликтов с другими HOC.</target>
        </trans-unit>
        <trans-unit id="6b4fb500f3d1079177a94f12b723a038f9d11e9c" translate="yes" xml:space="preserve">
          <source>Mutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React&amp;rsquo;s &lt;em&gt;render phase&lt;/em&gt;). Doing so will lead to confusing bugs and inconsistencies in the UI.</source>
          <target state="translated">Мутации, подписки, таймеры, ведение журнала и другие побочные эффекты не допускаются внутри основного тела функционального компонента (называемого &lt;em&gt;фазой рендеринга&lt;/em&gt; React ). Это приведет к сбивающим с толку ошибкам и несоответствиям в пользовательском интерфейсе.</target>
        </trans-unit>
        <trans-unit id="298fe7648153e9ef9747060691f787af56551508" translate="yes" xml:space="preserve">
          <source>NVDA in Firefox</source>
          <target state="translated">NVDA в Firefox</target>
        </trans-unit>
        <trans-unit id="88f2f30ba49708ae97f8d92b8a8a72e7ddff53df" translate="yes" xml:space="preserve">
          <source>Named Exports</source>
          <target state="translated">Наименованный экспорт</target>
        </trans-unit>
        <trans-unit id="8223c4ee1ebba2ecb6739e2c07dbe5aef3df91b4" translate="yes" xml:space="preserve">
          <source>Naming Changes from React 15</source>
          <target state="translated">Название Изменения по сравнению с реакцией 15</target>
        </trans-unit>
        <trans-unit id="e41e56840d69bd1bdd31e27707dc3a8b970413df" translate="yes" xml:space="preserve">
          <source>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn&amp;rsquo;t care whether it is defined as a function or a class.</source>
          <target state="translated">Ни родительский, ни дочерний компоненты не могут знать, является ли определенный компонент с состоянием или без него, и им не должно быть дела до того, определен ли он как функция или как класс.</target>
        </trans-unit>
        <trans-unit id="c44dcd3a4ac0c4c177b3fafe8b75ff34a66cc079" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.state&lt;/code&gt; directly, as calling &lt;code&gt;setState()&lt;/code&gt; afterwards may replace the mutation you made. Treat &lt;code&gt;this.state&lt;/code&gt; as if it were immutable.</source>
          <target state="translated">Никогда не &lt;code&gt;this.state&lt;/code&gt; напрямую, так как &lt;code&gt;setState()&lt;/code&gt; вызов setState () может заменить сделанную вами мутацию. Относитесь к &lt;code&gt;this.state&lt;/code&gt; как к неизменяемому.</target>
        </trans-unit>
        <trans-unit id="2cb61bead103f4e57375ed4a4afb6cfadf7e8a73" translate="yes" xml:space="preserve">
          <source>New Behavior for Uncaught Errors</source>
          <target state="translated">Новое Поведение для Недостигнутых Ошибок</target>
        </trans-unit>
        <trans-unit id="9840d3214efbf61f44cf5554641966293bd9f3a1" translate="yes" xml:space="preserve">
          <source>Next Channel</source>
          <target state="translated">Следующий канал</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">Следующие шаги</target>
        </trans-unit>
        <trans-unit id="0ed8ca892cbf39b577e860e50cdb6e102751578f" translate="yes" xml:space="preserve">
          <source>Next, add three &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags to the HTML page right before the closing &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">Затем добавьте три &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; на HTML-страницу прямо перед закрывающим &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="87cb58c13d37c6cc1855c1dd32d1fed18cfeb93f" translate="yes" xml:space="preserve">
          <source>Next, the &lt;code&gt;render()&lt;/code&gt; method is called and the diff algorithm recurses on the previous result and the new result.</source>
          <target state="translated">Затем вызывается метод &lt;code&gt;render()&lt;/code&gt; и алгоритм сравнения повторяет предыдущий результат и новый результат.</target>
        </trans-unit>
        <trans-unit id="3e81212e5ac19cfc9b59fe21a631d3753e83f2b5" translate="yes" xml:space="preserve">
          <source>Next, we will create a component called &lt;code&gt;Calculator&lt;/code&gt;. It renders an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; that lets you enter the temperature, and keeps its value in &lt;code&gt;this.state.temperature&lt;/code&gt;.</source>
          <target state="translated">Далее мы создадим компонент под названием &lt;code&gt;Calculator&lt;/code&gt; . Он отображает &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , который позволяет вам ввести температуру, и сохраняет ее значение в &lt;code&gt;this.state.temperature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="773f24daf1da57217e2f8e8567bf1bc9016af437" translate="yes" xml:space="preserve">
          <source>Next, we will extract a &lt;code&gt;UserInfo&lt;/code&gt; component that renders an &lt;code&gt;Avatar&lt;/code&gt; next to the user&amp;rsquo;s name:</source>
          <target state="translated">Затем мы &lt;code&gt;UserInfo&lt;/code&gt; компонент UserInfo, который отображает &lt;code&gt;Avatar&lt;/code&gt; рядом с именем пользователя:</target>
        </trans-unit>
        <trans-unit id="72d6961628775828349729a4be218018b6d3a3ac" translate="yes" xml:space="preserve">
          <source>Next, we will implement the lifecycle methods. We need to initialize Chosen with the ref to the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; node in &lt;code&gt;componentDidMount&lt;/code&gt;, and tear it down in &lt;code&gt;componentWillUnmount&lt;/code&gt;:</source>
          <target state="translated">Далее мы реализуем методы жизненного цикла. Нам нужно инициализировать Chosen ссылкой на узел &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; в &lt;code&gt;componentDidMount&lt;/code&gt; и удалить его в &lt;code&gt;componentWillUnmount&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ce34474eda0627488f7dc85176d87bf118e6e53d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add an import for the &lt;code&gt;useTransition&lt;/code&gt; Hook from React:</source>
          <target state="translated">Далее мы добавим импорт для &lt;code&gt;useTransition&lt;/code&gt; из React:</target>
        </trans-unit>
        <trans-unit id="00d7070daf25a2f645c41cd51b24e95c602ef3cd" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll make the &lt;code&gt;Clock&lt;/code&gt; set up its own timer and update itself every second.</source>
          <target state="translated">Затем мы заставим &lt;code&gt;Clock&lt;/code&gt; устанавливать собственный таймер и обновлять себя каждую секунду.</target>
        </trans-unit>
        <trans-unit id="83e778abae94d2dfc988da43bf316d54e5851ca7" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll tell the compiler where our source code is and where the output should go.</source>
          <target state="translated">Затем мы сообщим компилятору, где находится наш исходный код и куда должен идти вывод.</target>
        </trans-unit>
        <trans-unit id="694fd7bdca2fabcac6a912607368e98378b0b39b" translate="yes" xml:space="preserve">
          <source>Next.js</source>
          <target state="translated">Next.js</target>
        </trans-unit>
        <trans-unit id="aa4786474b1f9c2b27bbf660fd976c2e3f9e0c0b" translate="yes" xml:space="preserve">
          <source>No Breaking Changes</source>
          <target state="translated">Без изменений</target>
        </trans-unit>
        <trans-unit id="ea583f6afe9b6e25e50f115711dd0b56142fcb36" translate="yes" xml:space="preserve">
          <source>No! Check out &lt;a href=&quot;react-without-es6&quot;&gt;&amp;ldquo;React Without ES6&amp;rdquo;&lt;/a&gt; to learn more.</source>
          <target state="translated">Нет! Ознакомьтесь с &lt;a href=&quot;react-without-es6&quot;&gt;&amp;laquo;React Without ES6&amp;raquo;,&lt;/a&gt; чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="65b196a9e021f5013ed7f97aab941425359e880d" translate="yes" xml:space="preserve">
          <source>No! Check out &lt;a href=&quot;react-without-jsx&quot;&gt;&amp;ldquo;React Without JSX&amp;rdquo;&lt;/a&gt; to learn more.</source>
          <target state="translated">Нет! Ознакомьтесь с &lt;a href=&quot;react-without-jsx&quot;&gt;&amp;laquo;React Without JSX&amp;raquo;,&lt;/a&gt; чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="9848de506504aee3698fb2303cc082341679f4dc" translate="yes" xml:space="preserve">
          <source>No, they are different. The Shadow DOM is a browser technology designed primarily for scoping variables and CSS in web components. The virtual DOM is a concept implemented by libraries in JavaScript on top of browser APIs.</source>
          <target state="translated">Нет,они разные.Shadow DOM-это технология браузера,предназначенная в первую очередь для просмотра переменных и CSS в веб-компонентах.Виртуальный DOM-это концепция,реализованная библиотеками на JavaScript поверх API браузера.</target>
        </trans-unit>
        <trans-unit id="e4ec72f282ae4d51f6663dfafe02a89ddbd53865" translate="yes" xml:space="preserve">
          <source>No. In modern browsers, the raw performance of closures compared to classes doesn&amp;rsquo;t differ significantly except in extreme scenarios.</source>
          <target state="translated">Нет. В современных браузерах чистая производительность замыканий по сравнению с классами существенно не отличается, за исключением крайних сценариев.</target>
        </trans-unit>
        <trans-unit id="0e489b277ff2e842c4240cf5198329ad064dfd60" translate="yes" xml:space="preserve">
          <source>No. There are &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;no plans&lt;/a&gt; to remove classes from React &amp;mdash; we all need to keep shipping products and can&amp;rsquo;t afford rewrites. We recommend trying Hooks in new code.</source>
          <target state="translated">Нет. &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;Планов&lt;/a&gt; по удалению классов из React нет - нам всем нужно сохранить готовые продукты, и мы не можем позволить себе переписывать. Мы рекомендуем попробовать хуки в новом коде.</target>
        </trans-unit>
        <trans-unit id="a407ef4de7c3c16900e064cfde1c40d6f88459c3" translate="yes" xml:space="preserve">
          <source>Normally you should try to avoid all uses of &lt;code&gt;forceUpdate()&lt;/code&gt; and only read from &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; in &lt;code&gt;render()&lt;/code&gt;.</source>
          <target state="translated">Обычно вам следует избегать любого использования &lt;code&gt;forceUpdate()&lt;/code&gt; и читать только из &lt;code&gt;this.props&lt;/code&gt; и &lt;code&gt;this.state&lt;/code&gt; в &lt;code&gt;render()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99653f5245ac5639a7989484c01146c83245683b" translate="yes" xml:space="preserve">
          <source>Normally you would define a React component as a plain JavaScript class:</source>
          <target state="translated">Обычно компонент React определяется как простой класс JavaScript:</target>
        </trans-unit>
        <trans-unit id="183009a95c48cc3c8552b8d193bc55733a9da03e" translate="yes" xml:space="preserve">
          <source>Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, &lt;code&gt;props.children&lt;/code&gt; works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as &lt;code&gt;props.children&lt;/code&gt;:</source>
          <target state="translated">Обычно выражения JavaScript, вставленные в JSX, будут оценивать строку, элемент React или список этих вещей. Однако &lt;code&gt;props.children&lt;/code&gt; работает так же, как и любой другой объект , в том смысле, что он может передавать любые данные, а не только те, которые React умеет отображать. Например, если у вас есть настраиваемый компонент, вы можете сделать так, чтобы он &lt;code&gt;props.children&lt;/code&gt; обратный вызов как props.children :</target>
        </trans-unit>
        <trans-unit id="190f214c6271f32c16616efc1edf4a598d1724d4" translate="yes" xml:space="preserve">
          <source>Normally, there is a warning when an element with children is also marked as &lt;code&gt;contentEditable&lt;/code&gt;, because it won&amp;rsquo;t work. This attribute suppresses that warning. Don&amp;rsquo;t use this unless you are building a library like &lt;a href=&quot;https://facebook.github.io/draft-js/&quot;&gt;Draft.js&lt;/a&gt; that manages &lt;code&gt;contentEditable&lt;/code&gt; manually.</source>
          <target state="translated">Обычно появляется предупреждение, когда элемент с &lt;code&gt;contentEditable&lt;/code&gt; элементами также помечается как contentEditable , потому что это не сработает. Этот атрибут подавляет это предупреждение. Не используйте это, если вы не создаете библиотеку, такую ​​как &lt;a href=&quot;https://facebook.github.io/draft-js/&quot;&gt;Draft.js,&lt;/a&gt; которая управляет &lt;code&gt;contentEditable&lt;/code&gt; вручную.</target>
        </trans-unit>
        <trans-unit id="0cd4b09c96906d68937c9412b6fd82a68a4314a7" translate="yes" xml:space="preserve">
          <source>Normally, when we add features to React, you can start using them immediately. Fragments, Context, and even Hooks are examples of such features. You can use in new code without making any changes to the existing code.</source>
          <target state="translated">Обычно,когда мы добавляем функции в React,вы можете начать использовать их сразу же.Примерами таких возможностей являются фрагменты,контекст и даже Hooks.Вы можете использовать их в новом коде,не внося никаких изменений в существующий.</target>
        </trans-unit>
        <trans-unit id="6c6b777eeab761f59c9850ff240a2c5f5aa55549" translate="yes" xml:space="preserve">
          <source>Normally, when we add features to React, you can start using them immediately. Fragments, Context, and even Hooks are examples of such features. You can use them in new code without making any changes to the existing code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2dec545b1bcbcdd30f45e8128cc1dc979967845" translate="yes" xml:space="preserve">
          <source>Normally, when you return an element from a component&amp;rsquo;s render method, it&amp;rsquo;s mounted into the DOM as a child of the nearest parent node:</source>
          <target state="translated">Обычно, когда вы возвращаете элемент из метода рендеринга компонента, он монтируется в DOM как дочерний элемент ближайшего родительского узла:</target>
        </trans-unit>
        <trans-unit id="b36f36a60ec7e988ebd6b0da0589f77cbff203cc" translate="yes" xml:space="preserve">
          <source>Normally, you shouldn&amp;rsquo;t mutate local state in React. However, as an escape hatch, you can use an incrementing counter to force a re-render even if the state has not changed:</source>
          <target state="translated">Обычно вы не должны изменять локальное состояние в React. Однако в качестве аварийного люка вы можете использовать увеличивающийся счетчик для принудительного повторного рендеринга, даже если состояние не изменилось:</target>
        </trans-unit>
        <trans-unit id="65436a84c77556cccffc3de4f952f08eb5996b2a" translate="yes" xml:space="preserve">
          <source>Normally, you shouldn&amp;rsquo;t need to think about this. But it matters for HOCs because it means you can&amp;rsquo;t apply a HOC to a component within the render method of a component:</source>
          <target state="translated">Обычно вам не нужно об этом думать. Но это важно для HOC, потому что это означает, что вы не можете применить HOC к компоненту в методе рендеринга компонента:</target>
        </trans-unit>
        <trans-unit id="b634d41d383d2c2c85fe24302f5a62774271b079" translate="yes" xml:space="preserve">
          <source>Not all HOCs look the same. Sometimes they accept only a single argument, the wrapped component:</source>
          <target state="translated">Не все HOC выглядят одинаково.Иногда они принимают только один аргумент,завернутый компонент:</target>
        </trans-unit>
        <trans-unit id="81b40478626081aff6b6152a5ac2bc60a347ba9e" translate="yes" xml:space="preserve">
          <source>Not all style properties are converted to pixel strings though. Certain ones remain unitless (eg &lt;code&gt;zoom&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;, &lt;code&gt;flex&lt;/code&gt;). A complete list of unitless properties can be seen &lt;a href=&quot;https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSProperty.js#L15-L59&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Однако не все свойства стиля преобразуются в строки пикселей. Некоторые из них остаются без единиц (например, &lt;code&gt;zoom&lt;/code&gt; , &lt;code&gt;order&lt;/code&gt; , &lt;code&gt;flex&lt;/code&gt; ). Полный список безразмерных свойств можно увидеть &lt;a href=&quot;https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSProperty.js#L15-L59&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3dce74d24f02b63c13638f91d2e8c790ee44211" translate="yes" xml:space="preserve">
          <source>Not every React release deserves its own blog post, but you can find a detailed changelog for every release in the &lt;a href=&quot;https://github.com/facebook/react/blob/master/CHANGELOG.md&quot;&gt;&lt;code&gt;CHANGELOG.md&lt;/code&gt; file in the React repository&lt;/a&gt;, as well as on the &lt;a href=&quot;https://github.com/facebook/react/releases&quot;&gt;Releases&lt;/a&gt; page.</source>
          <target state="translated">Не каждый выпуск React заслуживает отдельного сообщения в блоге, но вы можете найти подробный &lt;a href=&quot;https://github.com/facebook/react/blob/master/CHANGELOG.md&quot;&gt; &lt;code&gt;CHANGELOG.md&lt;/code&gt; &lt;/a&gt; изменений для каждого выпуска в файле CHANGELOG.md в репозитории React , а также на странице &lt;a href=&quot;https://github.com/facebook/react/releases&quot;&gt;Releases&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="b703ebbf1b1cf4f4af246b8831b3304e1ea7b732" translate="yes" xml:space="preserve">
          <source>Note for component library maintainers</source>
          <target state="translated">Примечание для сопровождающих библиотек компонентов</target>
        </trans-unit>
        <trans-unit id="61f07fc00eca63f479177f8f24ebc20765f4ab58" translate="yes" xml:space="preserve">
          <source>Note how &lt;strong&gt;we have to duplicate the code between these two lifecycle methods in class.&lt;/strong&gt;</source>
          <target state="translated">Обратите внимание, как &lt;strong&gt;мы должны дублировать код между этими двумя методами жизненного цикла в классе.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="136a652f0357162f7faa10211f6de25fc285e258" translate="yes" xml:space="preserve">
          <source>Note how the logic that sets &lt;code&gt;document.title&lt;/code&gt; is split between &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. The subscription logic is also spread between &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;. And &lt;code&gt;componentDidMount&lt;/code&gt; contains code for both tasks.</source>
          <target state="translated">Обратите внимание, как логика, устанавливающая &lt;code&gt;document.title&lt;/code&gt; , разделена между &lt;code&gt;componentDidMount&lt;/code&gt; и &lt;code&gt;componentDidUpdate&lt;/code&gt; . Логика подписки также распределена между &lt;code&gt;componentDidMount&lt;/code&gt; и &lt;code&gt;componentWillUnmount&lt;/code&gt; . А &lt;code&gt;componentDidMount&lt;/code&gt; содержит код для обеих задач.</target>
        </trans-unit>
        <trans-unit id="af859993c451cb0b08b7e66c1d591884e0bd7b2b" translate="yes" xml:space="preserve">
          <source>Note how this would work for props, state, or any other calculated value.</source>
          <target state="translated">Обратите внимание,как это будет работать для реквизита,состояния или любого другого рассчитанного значения.</target>
        </trans-unit>
        <trans-unit id="81f0076b98d34a6e29be0cedd7cf07479dcc0f97" translate="yes" xml:space="preserve">
          <source>Note how we also changed the effect dependencies from &lt;code&gt;[]&lt;/code&gt; to &lt;code&gt;[id]&lt;/code&gt; &amp;mdash; because we want the effect to re-run when the &lt;code&gt;id&lt;/code&gt; changes. Otherwise, we wouldn&amp;rsquo;t refetch new data.</source>
          <target state="translated">Обратите внимание, как мы также изменили зависимости эффекта с &lt;code&gt;[]&lt;/code&gt; на &lt;code&gt;[id]&lt;/code&gt; - потому что мы хотим, чтобы эффект запускался повторно при изменении &lt;code&gt;id&lt;/code&gt; . В противном случае мы бы не запрашивали новые данные.</target>
        </trans-unit>
        <trans-unit id="66e67313f6ff24b0ac9427a27eaa56f7a14b86fb" translate="yes" xml:space="preserve">
          <source>Note how we eliminated the &lt;code&gt;if (...)&lt;/code&gt; &amp;ldquo;is loading&amp;rdquo; checks from our components. This doesn&amp;rsquo;t only remove boilerplate code, but it also simplifies making quick design changes. For example, if we wanted profile details and posts to always &amp;ldquo;pop in&amp;rdquo; together, we could delete the &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary between them. Or we could make them independent from each other by giving each &lt;em&gt;its own&lt;/em&gt;&lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary. Suspense lets us change the granularity of our loading states and orchestrate their sequencing without invasive changes to our code.</source>
          <target state="translated">Обратите внимание, как мы устранили проверки &lt;code&gt;if (...)&lt;/code&gt; &amp;laquo;загружается&amp;raquo; из наших компонентов. Это не только удаляет шаблонный код, но также упрощает внесение быстрых изменений в дизайн. Например, если мы хотим, чтобы детали профиля и сообщения всегда &amp;laquo;появлялись&amp;raquo; вместе, мы могли бы удалить границу &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; между ними. Или мы могли бы сделать их независимыми друг от друга, задав каждому &lt;em&gt;свою&lt;/em&gt; границу &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; . Приостановка позволяет нам изменять степень детализации наших состояний загрузки и организовывать их последовательность, не внося серьезных изменений в наш код.</target>
        </trans-unit>
        <trans-unit id="a102e3bac932a4b73c9dad4c0a7268f562de444e" translate="yes" xml:space="preserve">
          <source>Note how we pass &lt;code&gt;props&lt;/code&gt; to the base constructor:</source>
          <target state="translated">Обратите внимание, как мы передаем &lt;code&gt;props&lt;/code&gt; в базовый конструктор:</target>
        </trans-unit>
        <trans-unit id="2582d2e45f28b6c6e7c9a5f4534087c1aa30ef02" translate="yes" xml:space="preserve">
          <source>Note how we save the timer ID right on &lt;code&gt;this&lt;/code&gt; (&lt;code&gt;this.timerID&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, как мы сохраняем ID таймера прямо на &lt;code&gt;this&lt;/code&gt; ( &lt;code&gt;this.timerID&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7abe7d49c5110b0b495bee7ab2bbbd92a50f878a" translate="yes" xml:space="preserve">
          <source>Note how we used the ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;computed property name&lt;/a&gt; syntax to update the state key corresponding to the given input name:</source>
          <target state="translated">Обратите внимание, как мы использовали синтаксис &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;имени вычисляемого свойства&lt;/a&gt; ES6 для обновления ключа состояния, соответствующего заданному имени входа:</target>
        </trans-unit>
        <trans-unit id="b008f8350f4cfc8fc1ac8218af3644148e094014" translate="yes" xml:space="preserve">
          <source>Note how we were able to move the &lt;code&gt;useState&lt;/code&gt; call for the &lt;code&gt;position&lt;/code&gt; state variable and the related effect into a custom Hook without changing their code. If all state was in a single object, extracting it would be more difficult.</source>
          <target state="translated">Обратите внимание, как мы смогли переместить вызов &lt;code&gt;useState&lt;/code&gt; для переменной состояния &lt;code&gt;position&lt;/code&gt; и связанный эффект в настраиваемый Hook без изменения их кода. Если бы все состояние было в одном объекте, извлечь его было бы сложнее.</target>
        </trans-unit>
        <trans-unit id="4b1a921c73e886405b533b71309555191e0dd804" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;SuspenseList&lt;/code&gt; only operates on the closest &lt;code&gt;Suspense&lt;/code&gt; and &lt;code&gt;SuspenseList&lt;/code&gt; components below it. It does not search for boundaries deeper than one level. However, it is possible to nest multiple &lt;code&gt;SuspenseList&lt;/code&gt; components in each other to build grids.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;SuspenseList&lt;/code&gt; работает только с ближайшими к нему компонентами &lt;code&gt;Suspense&lt;/code&gt; и &lt;code&gt;SuspenseList&lt;/code&gt; . Он не ищет границ глубже одного уровня. Однако можно вкладывать несколько компонентов &lt;code&gt;SuspenseList&lt;/code&gt; друг в друга для построения сеток.</target>
        </trans-unit>
        <trans-unit id="5369d72764239c963258ac4860d4222756071b86" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;error boundaries only catch errors in the components below them in the tree&lt;/strong&gt;. An error boundary can&amp;rsquo;t catch an error within itself. If an error boundary fails trying to render the error message, the error will propagate to the closest error boundary above it. This, too, is similar to how catch {} block works in JavaScript.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;границы ошибок улавливают ошибки только в компонентах под ними в дереве&lt;/strong&gt; . Граница ошибки не может уловить ошибку внутри себя. Если граница ошибки не удалась при попытке отобразить сообщение об ошибке, ошибка будет распространяться на ближайшую границу ошибки над ней. Это тоже похоже на то, как блок catch {} работает в JavaScript.</target>
        </trans-unit>
        <trans-unit id="056385a2ed6637b481ae142bf0a46d9f70a318a3" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;the numbers are relative so components will render faster in production&lt;/strong&gt;. Still, this should help you realize when unrelated UI gets updated by mistake, and how deep and how often your UI updates occur.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;числа являются относительными, поэтому компоненты будут отображаться быстрее в производстве&lt;/strong&gt; . Тем не менее, это должно помочь вам понять, когда несвязанный пользовательский интерфейс обновляется по ошибке, а также насколько глубоко и как часто происходят обновления вашего пользовательского интерфейса.</target>
        </trans-unit>
        <trans-unit id="89ff4a5e91c66b9d6944b9d99f0d60617bdf219c" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;to enable Hooks, all React packages need to be 16.8.0 or higher&lt;/strong&gt;. Hooks won&amp;rsquo;t work if you forget to update, for example, React DOM.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;для включения хуков все пакеты React должны быть 16.8.0 или выше&lt;/strong&gt; . Хуки не будут работать, если вы забудете обновить, например, React DOM.</target>
        </trans-unit>
        <trans-unit id="a58c552c3d3190dd2fb91ca8e1639154f214426b" translate="yes" xml:space="preserve">
          <source>Note that React assigns no special meaning to the &lt;code&gt;this.el&lt;/code&gt; field. It only works because we have previously assigned this field from a &lt;code&gt;ref&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method:</source>
          <target state="translated">Обратите внимание, что React не придает особого значения полю &lt;code&gt;this.el&lt;/code&gt; .Это работает только потому, что мы ранее назначили это поле из &lt;code&gt;ref&lt;/code&gt; в методе &lt;code&gt;render()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="47b82595a068571374ab58a7ca07015bf588a435" translate="yes" xml:space="preserve">
          <source>Note that React may still need to render that specific component again before bailing out. That shouldn&amp;rsquo;t be a concern because React won&amp;rsquo;t unnecessarily go &amp;ldquo;deeper&amp;rdquo; into the tree. If you&amp;rsquo;re doing expensive calculations while rendering, you can optimize them with &lt;code&gt;useMemo&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что React может потребоваться снова отрендерить этот конкретный компонент перед выходом из строя. Это не должно вызывать беспокойства, потому что React не будет без надобности &amp;laquo;углубляться&amp;raquo; в дерево. Если вы выполняете дорогостоящие вычисления во время рендеринга, вы можете оптимизировать их с помощью &lt;code&gt;useMemo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20548fe21065f678631f41f93e7e5b0293cf3638" translate="yes" xml:space="preserve">
          <source>Note that React only had to do DOM mutations for C6, which was inevitable. For C8, it bailed out by comparing the rendered React elements, and for C2&amp;rsquo;s subtree and C7, it didn&amp;rsquo;t even have to compare the elements as we bailed out on &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, and &lt;code&gt;render&lt;/code&gt; was not called.</source>
          <target state="translated">Обратите внимание, что React должен был произвести мутации DOM только для C6, что было неизбежно. Для C8 он помог, сравнив визуализированные элементы React, а для поддерева C2 и C7 даже не пришлось сравнивать элементы, поскольку мы &lt;code&gt;shouldComponentUpdate&lt;/code&gt; от shouldComponentUpdate , а &lt;code&gt;render&lt;/code&gt; не был вызван.</target>
        </trans-unit>
        <trans-unit id="cd5e25e3c06e2e0a9f837231ef8545ceec20aa21" translate="yes" xml:space="preserve">
          <source>Note that a HOC doesn&amp;rsquo;t modify the input component, nor does it use inheritance to copy its behavior. Rather, a HOC &lt;em&gt;composes&lt;/em&gt; the original component by &lt;em&gt;wrapping&lt;/em&gt; it in a container component. A HOC is a pure function with zero side-effects.</source>
          <target state="translated">Обратите внимание, что HOC не изменяет входной компонент и не использует наследование для копирования своего поведения. Скорее HOC &lt;em&gt;составляет&lt;/em&gt; исходный компонент, &lt;em&gt;оборачивая&lt;/em&gt; его в компонент-контейнер. HOC - это чистая функция с нулевыми побочными эффектами.</target>
        </trans-unit>
        <trans-unit id="b0e7b7a2953e10e5ee351f37db62af70ce535d29" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;aria-*&lt;/code&gt; HTML attributes are fully supported in JSX. Whereas most DOM properties and attributes in React are camelCased, these attributes should be hyphen-cased (also known as kebab-case, lisp-case, etc) as they are in plain HTML:</source>
          <target state="translated">Обратите внимание, что все &lt;code&gt;aria-*&lt;/code&gt; HTML aria- * полностью поддерживаются в JSX. В то время как большинство свойств и атрибутов DOM в React имеют camelCased, эти атрибуты должны быть разделены дефисом (также известные как kebab-case, lisp-case и т. Д.), Как и в обычном HTML:</target>
        </trans-unit>
        <trans-unit id="7624acea1a9c060576a9f15d678ecc769a9b76e6" translate="yes" xml:space="preserve">
          <source>Note that if a parent component causes your component to re-render, this method will be called even if props have not changed. Make sure to compare the current and next values if you only want to handle changes.</source>
          <target state="translated">Обратите внимание,что если родительский компонент вызывает переотправку вашего компонента,этот метод будет вызван,даже если реквизит не изменился.Убедитесь,что вы сравниваете текущее и следующее значения,если хотите обрабатывать только изменения.</target>
        </trans-unit>
        <trans-unit id="c974944cb18d8a4b4d98d26cf2d4b75e73525b1b" translate="yes" xml:space="preserve">
          <source>Note that in the above example we &lt;strong&gt;need&lt;/strong&gt; to keep the function in the dependencies list. This ensures that a change in the &lt;code&gt;productId&lt;/code&gt; prop of &lt;code&gt;ProductPage&lt;/code&gt; automatically triggers a refetch in the &lt;code&gt;ProductDetails&lt;/code&gt; component.</source>
          <target state="translated">Обратите внимание, что в приведенном выше примере нам &lt;strong&gt;нужно&lt;/strong&gt; сохранить функцию в списке зависимостей. Это гарантирует, что изменение &lt;code&gt;productId&lt;/code&gt; для &lt;code&gt;ProductPage&lt;/code&gt; автоматически инициирует повторную выборку в компоненте &lt;code&gt;ProductDetails&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15064b1b66df67d34d5a232d98bfeba9ea33bea0" translate="yes" xml:space="preserve">
          <source>Note that rendering &lt;code&gt;lazy&lt;/code&gt; components requires that there&amp;rsquo;s a &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; component higher in the rendering tree. This is how you specify a loading indicator.</source>
          <target state="translated">Обратите внимание, что рендеринг &lt;code&gt;lazy&lt;/code&gt; компонентов требует наличия компонента &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; выше в дереве рендеринга. Вот как вы указываете индикатор загрузки.</target>
        </trans-unit>
        <trans-unit id="aa4c033446ec6662e8a38df6618cdc398a3612d3" translate="yes" xml:space="preserve">
          <source>Note that returning a falsy expression will still cause the element after &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to be skipped but will return the falsy expression. In the example below, &lt;code&gt;&amp;lt;div&amp;gt;0&amp;lt;/div&amp;gt;&lt;/code&gt; will be returned by the render method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca9869270c610c84eca37a4188271b709cfb625" translate="yes" xml:space="preserve">
          <source>Note that styles are not autoprefixed. To support older browsers, you need to supply corresponding style properties:</source>
          <target state="translated">Обратите внимание,что стили не исправляются автоматически.Для поддержки старых браузеров необходимо предоставить соответствующие свойства стилей:</target>
        </trans-unit>
        <trans-unit id="067b30a981f559502026a96e0fc3941571707473" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;read()&lt;/code&gt; call in this example doesn&amp;rsquo;t &lt;em&gt;start&lt;/em&gt; fetching. It only tries to read the data that is &lt;strong&gt;already being fetched&lt;/strong&gt;. This difference is crucial to creating fast applications with Suspense. We don&amp;rsquo;t want to delay loading data until a component starts rendering. As a data fetching library author, you can enforce this by making it impossible to get a &lt;code&gt;resource&lt;/code&gt; object without also starting a fetch. Every demo on this page using our &amp;ldquo;fake API&amp;rdquo; enforces this.</source>
          <target state="translated">Обратите внимание, что вызов &lt;code&gt;read()&lt;/code&gt; в этом примере не &lt;em&gt;начинает&lt;/em&gt; выборку. Он только пытается прочитать данные, которые &lt;strong&gt;уже извлекаются&lt;/strong&gt; . Это различие имеет решающее значение для создания быстрых приложений с задержкой. Мы не хотим откладывать загрузку данных до тех пор, пока компонент не начнет рендеринг. Как автор библиотеки выборки данных, вы можете добиться этого, сделав невозможным получение объекта &lt;code&gt;resource&lt;/code&gt; без запуска выборки. Каждая демонстрация на этой странице, использующая наш &amp;laquo;поддельный API&amp;raquo;, обеспечивает это.</target>
        </trans-unit>
        <trans-unit id="dd2a771e4fad07ffb446c282efadcd2888cbe8e6" translate="yes" xml:space="preserve">
          <source>Note that the Coconut option is initially selected, because of the &lt;code&gt;selected&lt;/code&gt; attribute. React, instead of using this &lt;code&gt;selected&lt;/code&gt; attribute, uses a &lt;code&gt;value&lt;/code&gt; attribute on the root &lt;code&gt;select&lt;/code&gt; tag. This is more convenient in a controlled component because you only need to update it in one place. For example:</source>
          <target state="translated">Обратите внимание, что изначально выбран параметр &amp;laquo;Кокос&amp;raquo; из-за атрибута &lt;code&gt;selected&lt;/code&gt; . React вместо этого &lt;code&gt;selected&lt;/code&gt; атрибута использует атрибут &lt;code&gt;value&lt;/code&gt; в корневом теге &lt;code&gt;select&lt;/code&gt; . Это более удобно в управляемом компоненте, потому что вам нужно обновить его только в одном месте. Например:</target>
        </trans-unit>
        <trans-unit id="d5999130fbdfde82a85986a35fe0795798389c68" translate="yes" xml:space="preserve">
          <source>Note that the above example is demonstrating regular JavaScript behavior and doesn&amp;rsquo;t use error boundaries.</source>
          <target state="translated">Обратите внимание, что приведенный выше пример демонстрирует обычное поведение JavaScript и не использует границы ошибок.</target>
        </trans-unit>
        <trans-unit id="61cff9e21e25a4670560f3ba3575f47b51bc9f0f" translate="yes" xml:space="preserve">
          <source>Note that the button doesn&amp;rsquo;t care &lt;em&gt;what&lt;/em&gt; state we&amp;rsquo;re updating. It&amp;rsquo;s wrapping &lt;em&gt;any&lt;/em&gt; state updates that happen during its &lt;code&gt;onClick&lt;/code&gt; handler into a transition. Now that our &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; takes care of setting up the transition, the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component doesn&amp;rsquo;t need to set up its own:</source>
          <target state="translated">Обратите внимание, что кнопке не важно, &lt;em&gt;какое&lt;/em&gt; состояние мы обновляем. Он оборачивает &lt;em&gt;любые&lt;/em&gt; обновления состояния, которые происходят во время его обработчика &lt;code&gt;onClick&lt;/code&gt; , в переход. Теперь, когда наш &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; позаботится о настройке перехода, компоненту &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; не нужно настраивать свой собственный:</target>
        </trans-unit>
        <trans-unit id="23b6882327e1c317b3769b724af427c65f26d7de" translate="yes" xml:space="preserve">
          <source>Note that this approach won&amp;rsquo;t work in a loop because Hook calls &lt;a href=&quot;hooks-rules&quot;&gt;can&amp;rsquo;t&lt;/a&gt; be placed inside loops. But you can extract a separate component for the list item, and call &lt;code&gt;useMemo&lt;/code&gt; there.</source>
          <target state="translated">Обратите внимание, что этот подход не будет работать в цикле, потому что вызовы Hook &lt;a href=&quot;hooks-rules&quot;&gt;не могут&lt;/a&gt; быть размещены внутри циклов. Но вы можете извлечь отдельный компонент для элемента списка и вызвать там &lt;code&gt;useMemo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bb49079ffd95590ce09e3d67d7befe22d9e2ab" translate="yes" xml:space="preserve">
          <source>Note that this example is not meant to be exhaustive with regards to working with Backbone, but it should give you an idea for how to approach this in a generic way:</source>
          <target state="translated">Обратите внимание,что этот пример не является исчерпывающим в отношении работы с Backbone,но он должен дать вам представление о том,как подойти к этому в общем плане:</target>
        </trans-unit>
        <trans-unit id="c41ae3592459d184c8cfe8a8c9a865858f7f5834" translate="yes" xml:space="preserve">
          <source>Note that this method is fired on &lt;em&gt;every&lt;/em&gt; render, regardless of the cause. This is in contrast to &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt;, which only fires when the parent causes a re-render and not as a result of a local &lt;code&gt;setState&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что этот метод запускается при &lt;em&gt;каждом&lt;/em&gt; рендеринге, независимо от причины. Это отличается от &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt; , который срабатывает только тогда, когда родительский элемент вызывает повторный рендеринг, а не в результате локального &lt;code&gt;setState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="293936fb383c744f2f9630271a7efb4989979625" translate="yes" xml:space="preserve">
          <source>Note that this only works if &lt;code&gt;CustomTextInput&lt;/code&gt; is declared as a class:</source>
          <target state="translated">Обратите внимание, что это работает, только если &lt;code&gt;CustomTextInput&lt;/code&gt; объявлен как класс:</target>
        </trans-unit>
        <trans-unit id="d6de8667681c14632896b78b9f59b00902732f9a" translate="yes" xml:space="preserve">
          <source>Note that we defined both &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt;. Many jQuery plugins attach event listeners to the DOM so it&amp;rsquo;s important to detach them in &lt;code&gt;componentWillUnmount&lt;/code&gt;. If the plugin does not provide a method for cleanup, you will probably have to provide your own, remembering to remove any event listeners the plugin registered to prevent memory leaks.</source>
          <target state="translated">Обратите внимание, что мы определили &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;методы жизненного цикла &lt;/a&gt; &lt;code&gt;componentDidMount&lt;/code&gt; и &lt;code&gt;componentWillUnmount&lt;/code&gt; . Многие плагины jQuery прикрепляют прослушиватели событий к DOM, поэтому важно отсоединить их в &lt;code&gt;componentWillUnmount&lt;/code&gt; . Если плагин не предоставляет метод очистки, вам, вероятно, придется предоставить свой собственный, не забывая удалять любые прослушиватели событий, зарегистрированные плагином, чтобы предотвратить утечку памяти.</target>
        </trans-unit>
        <trans-unit id="0e7bd878200c78bd50ee3d98b684ecb341171678" translate="yes" xml:space="preserve">
          <source>Note that we pass &lt;code&gt;[]&lt;/code&gt; as a dependency array to &lt;code&gt;useCallback&lt;/code&gt;. This ensures that our ref callback doesn&amp;rsquo;t change between the re-renders, and so React won&amp;rsquo;t call it unnecessarily.</source>
          <target state="translated">Обратите внимание, что мы передаем &lt;code&gt;[]&lt;/code&gt; как массив зависимостей в &lt;code&gt;useCallback&lt;/code&gt; . Это гарантирует, что обратный вызов ref не изменится между повторными отрисовками, и React не будет вызывать его без необходимости.</target>
        </trans-unit>
        <trans-unit id="f3da62d793b8e6e725893da6d74020b9b0c1d282" translate="yes" xml:space="preserve">
          <source>Note that you can still choose whether to pass the application &lt;em&gt;state&lt;/em&gt; down as props (more explicit) or as context (more convenient for very deep updates). If you use context to pass down the state too, use two different context types &amp;mdash; the &lt;code&gt;dispatch&lt;/code&gt; context never changes, so components that read it don&amp;rsquo;t need to rerender unless they also need the application state.</source>
          <target state="translated">Обратите внимание, что вы по-прежнему можете выбрать, передавать ли &lt;em&gt;состояние&lt;/em&gt; приложения в качестве реквизита (более явный) или в качестве контекста (более удобно для очень глубоких обновлений). Если вы также используете контекст для передачи состояния, используйте два разных типа контекста - контекст &lt;code&gt;dispatch&lt;/code&gt; никогда не изменяется, поэтому компоненты, которые его читают, не нуждаются в повторной визуализации, если им также не требуется состояние приложения.</target>
        </trans-unit>
        <trans-unit id="5438c62ee57f24fd4d0711d668e74ee64c6002c5" translate="yes" xml:space="preserve">
          <source>Note that you cannot call &lt;code&gt;this.setState()&lt;/code&gt; here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; returns.</source>
          <target state="translated">Обратите внимание, что здесь нельзя вызвать &lt;code&gt;this.setState()&lt;/code&gt; ; вам также не следует делать ничего другого (например, отправлять действие Redux), которое &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; бы обновление компонента React до возврата UNSAFE_componentWillUpdate () .</target>
        </trans-unit>
        <trans-unit id="9bcdc977b06fb5be1faf45e2966b7781759aee94" translate="yes" xml:space="preserve">
          <source>Note there are other statically typed languages that compile to JavaScript and are thus React compatible. For example, &lt;a href=&quot;https://fable.io/&quot;&gt;F#/Fable&lt;/a&gt; with &lt;a href=&quot;https://elmish.github.io/react&quot;&gt;elmish-react&lt;/a&gt;. Check out their respective sites for more information, and feel free to add more statically typed languages that work with React to this page!</source>
          <target state="translated">Обратите внимание, что есть другие языки со статической типизацией, которые компилируются в JavaScript и поэтому совместимы с React. Например, &lt;a href=&quot;https://fable.io/&quot;&gt;F # / Fable&lt;/a&gt; с &lt;a href=&quot;https://elmish.github.io/react&quot;&gt;elmish-react&lt;/a&gt; . Посетите соответствующие сайты для получения дополнительной информации и не стесняйтесь добавлять на эту страницу больше языков со статической типизацией, которые работают с React!</target>
        </trans-unit>
        <trans-unit id="04e9b4dc0a682c919374be737463c7b46bbd33ef" translate="yes" xml:space="preserve">
          <source>Note we passed a configuration object to &lt;code&gt;useTransition&lt;/code&gt;. Its &lt;code&gt;timeoutMs&lt;/code&gt; property specifies &lt;strong&gt;how long we&amp;rsquo;re willing to wait for the transition to finish&lt;/strong&gt;. By passing &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt;, we say &amp;ldquo;If the next profile takes more than 3 seconds to load, show the big spinner &amp;mdash; but before that timeout it&amp;rsquo;s okay to keep showing the previous screen&amp;rdquo;.</source>
          <target state="translated">Обратите внимание, что мы передали объект конфигурации в &lt;code&gt;useTransition&lt;/code&gt; . Его свойство &lt;code&gt;timeoutMs&lt;/code&gt; указывает, &lt;strong&gt;как долго мы готовы ждать завершения перехода&lt;/strong&gt; . При пропускании &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; , мы говорим : &amp;laquo;Если следующий профиль занимает более 3 -х секунд , чтобы нагрузка, показать большую блесну - но до этого тайм - аута это нормально держать показывая предыдущий экран&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="3d0510089477e2c3202ca52ed149fc2903a72e31" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt; need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.</source>
          <target state="translated">Обратите внимание, как &lt;code&gt;componentDidMount&lt;/code&gt; и &lt;code&gt;componentWillUnmount&lt;/code&gt; должны отражать друг друга. Методы жизненного цикла вынуждают нас разделять эту логику, хотя концептуально код в обоих из них связан с одним и тем же эффектом.</target>
        </trans-unit>
        <trans-unit id="87bf57ef650f61bb6153e8d1ccb5545722813ea9" translate="yes" xml:space="preserve">
          <source>Notice how we wrapped &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; in an extra &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. This is necessary because Chosen will append another DOM element right after the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; node we passed to it. However, as far as React is concerned, &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; always only has a single child. This is how we ensure that React updates won&amp;rsquo;t conflict with the extra DOM node appended by Chosen. It is important that if you modify the DOM outside of React flow, you must ensure React doesn&amp;rsquo;t have a reason to touch those DOM nodes.</source>
          <target state="translated">Обратите внимание, как мы заключили &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; в дополнительный &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; . Это необходимо, потому что Chosen добавит еще один элемент DOM сразу после узла &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; ,который мы ему передали. Однако, что касается React, &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; всегда имеет только один дочерний элемент. Таким образом мы гарантируем, что обновления React не будут конфликтовать с дополнительным узлом DOM, добавленным Chosen. Важно, что если вы изменяете DOM вне потока React, вы должны убедиться, что у React нет причин касаться этих узлов DOM.</target>
        </trans-unit>
        <trans-unit id="f4059c045862b5d2fc7b27115084fa8f80b3c32e" translate="yes" xml:space="preserve">
          <source>Notice how when you type into the input, the &lt;code&gt;&amp;lt;Translation&amp;gt;&lt;/code&gt; component suspends, and we see the &lt;code&gt;&amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;&lt;/code&gt; fallback until we get fresh results. This is not ideal. It would be better if we could see the &lt;em&gt;previous&lt;/em&gt; translation for a bit while we&amp;rsquo;re fetching the next one.</source>
          <target state="translated">Обратите внимание, как когда вы вводите ввод, компонент &lt;code&gt;&amp;lt;Translation&amp;gt;&lt;/code&gt; приостанавливается, и мы видим &lt;code&gt;&amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;&lt;/code&gt; пока не получим свежие результаты. Это не идеально. Было бы лучше, если бы мы могли немного увидеть &lt;em&gt;предыдущий&lt;/em&gt; перевод, пока мы получаем следующий.</target>
        </trans-unit>
        <trans-unit id="e41a0eb10d6b00e47a2107e31a6fe602367acaa9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;this.state.value&lt;/code&gt; is initialized in the constructor, so that the text area starts off with some text in it.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;this.state.value&lt;/code&gt; инициализируется в конструкторе, поэтому текстовая область начинается с некоторого текста в ней.</target>
        </trans-unit>
        <trans-unit id="c48101c52bcbacc9cc53778eb2bf3edb99dccc8c" translate="yes" xml:space="preserve">
          <source>Notifying the user of errors</source>
          <target state="translated">Уведомление пользователя об ошибках</target>
        </trans-unit>
        <trans-unit id="c404d41fa7846adb181731741a44bd59410207d8" translate="yes" xml:space="preserve">
          <source>Now React knows that the element with key &lt;code&gt;'2014'&lt;/code&gt; is the new one, and the elements with the keys &lt;code&gt;'2015'&lt;/code&gt; and &lt;code&gt;'2016'&lt;/code&gt; have just moved.</source>
          <target state="translated">Теперь React знает, что элемент с ключом &lt;code&gt;'2014'&lt;/code&gt; является новым, а элементы с ключами &lt;code&gt;'2015'&lt;/code&gt; и &lt;code&gt;'2016'&lt;/code&gt; только что перемещены.</target>
        </trans-unit>
        <trans-unit id="a823d334901d2890efe56f8ef0b2a72eeceac120" translate="yes" xml:space="preserve">
          <source>Now consider the version of this component that uses Hooks:</source>
          <target state="translated">Теперь рассмотрим версию этого компонента,использующую Hooks:</target>
        </trans-unit>
        <trans-unit id="8183f56b4559e51b16e97bdcb7a1243573a8bd1d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s say that our chat application also has a contact list, and we want to render names of online users with a green color. We could copy and paste similar logic above into our &lt;code&gt;FriendListItem&lt;/code&gt; component but it wouldn&amp;rsquo;t be ideal:</source>
          <target state="translated">Теперь предположим, что в нашем приложении чата также есть список контактов, и мы хотим отображать имена онлайн-пользователей зеленым цветом. Мы могли бы скопировать и вставить аналогичную логику, приведенную выше, в наш компонент &lt;code&gt;FriendListItem&lt;/code&gt; , но это было бы не идеально:</target>
        </trans-unit>
        <trans-unit id="925974ac4f4434d5e39f807c69d3762bcfdfc9e3" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s say we want to write some logic that changes &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; when the user moves their mouse. Note how we have to merge these fields into the previous state object manually:</source>
          <target state="translated">Теперь предположим, что мы хотим написать некоторую логику, которая изменяется &lt;code&gt;left&lt;/code&gt; и &lt;code&gt;top&lt;/code&gt; когда пользователь перемещает мышь. Обратите внимание, как мы должны вручную объединить эти поля в предыдущий объект состояния:</target>
        </trans-unit>
        <trans-unit id="6e4daa5c187fd27dc1d98689209a36560e567ee5" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see how we can do the same with the &lt;code&gt;useEffect&lt;/code&gt; Hook.</source>
          <target state="translated">Теперь посмотрим, как мы можем сделать то же самое с &lt;code&gt;useEffect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f0c36b18073d97246d1ae6fdd941d78bd84aa02" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see how we can use our custom Hook.</source>
          <target state="translated">Теперь давайте посмотрим, как мы можем использовать наш собственный крючок.</target>
        </trans-unit>
        <trans-unit id="4ff24b1ed7e4290e5868df543207689b4f4b743a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s turn to the &lt;code&gt;Calculator&lt;/code&gt; component.</source>
          <target state="translated">Теперь перейдем к компоненту &amp;laquo; &lt;code&gt;Calculator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="844b2d5f9df9b2eb6e433eb964cbaab4370de078" translate="yes" xml:space="preserve">
          <source>Now that we know more about effects, these lines should make sense:</source>
          <target state="translated">Теперь,когда мы знаем больше об эффектах,эти линии должны иметь смысл:</target>
        </trans-unit>
        <trans-unit id="9b0970d0ace9e4ccf49f5bb229273af5230ad8a4" translate="yes" xml:space="preserve">
          <source>Now that we know what the &lt;code&gt;useState&lt;/code&gt; Hook does, our example should make more sense:</source>
          <target state="translated">Теперь, когда мы знаем, что &lt;code&gt;useState&lt;/code&gt; Hook, наш пример должен иметь больше смысла:</target>
        </trans-unit>
        <trans-unit id="8a8788b2f194e8402d2a42fc02e179198bb60d53" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted this logic to a &lt;code&gt;useFriendStatus&lt;/code&gt; hook, we can &lt;em&gt;just use it:&lt;/em&gt;</source>
          <target state="translated">Теперь, когда мы извлекли эту логику из &lt;code&gt;useFriendStatus&lt;/code&gt; , мы можем &lt;em&gt;просто использовать ее:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ad30db96883edc2b1c98cb238c68962796e03d5" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve identified the components in our mock, let&amp;rsquo;s arrange them into a hierarchy. Components that appear within another component in the mock should appear as a child in the hierarchy:</source>
          <target state="translated">Теперь, когда мы определили компоненты в нашем макете, давайте устроим их в иерархию. Компоненты, которые появляются внутри другого компонента в макете, должны отображаться как дочерние в иерархии:</target>
        </trans-unit>
        <trans-unit id="5fb8a97af0340e1169bfb8c33de464ee1f6338c0" translate="yes" xml:space="preserve">
          <source>Now that you have your component hierarchy, it&amp;rsquo;s time to implement your app. The easiest way is to build a version that takes your data model and renders the UI but has no interactivity. It&amp;rsquo;s best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing. We&amp;rsquo;ll see why.</source>
          <target state="translated">Теперь, когда у вас есть иерархия компонентов, пришло время реализовать ваше приложение. Самый простой способ - создать версию, которая берет вашу модель данных и отображает пользовательский интерфейс, но не имеет интерактивности. Лучше всего разделить эти процессы, потому что для создания статической версии требуется много печатать и не думать, а добавление интерактивности требует много размышлений, а не набора текста. Посмотрим почему.</target>
        </trans-unit>
        <trans-unit id="48ab459928ce6ebd5489677a0e93ec9929ee70a3" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component encapsulates all behavior associated with listening for &lt;code&gt;mousemove&lt;/code&gt; events and storing the (x, y) position of the cursor, but it&amp;rsquo;s not yet truly reusable.</source>
          <target state="translated">Теперь компонент &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; инкапсулирует все поведение, связанное с прослушиванием событий &lt;code&gt;mousemove&lt;/code&gt; и сохранением позиции курсора (x, y), но его еще нельзя использовать повторно.</target>
        </trans-unit>
        <trans-unit id="8290d2b0cd763be0c1cff68b5b8f6a2022e9e2e1" translate="yes" xml:space="preserve">
          <source>Now the clock ticks every second.</source>
          <target state="translated">Теперь часы тикают каждую секунду.</target>
        </trans-unit>
        <trans-unit id="445b4c42d80c61abe526efe3707111a846581295" translate="yes" xml:space="preserve">
          <source>Now the question is: How can we reuse this behavior in another component? In other words, if another component needs to know about the cursor position, can we encapsulate that behavior so that we can easily share it with that component?</source>
          <target state="translated">Теперь вопрос в том,как мы можем повторно использовать это поведение в другом компоненте? Другими словами,если другому компоненту необходимо знать о позиции курсора,можем ли мы инкапсулировать это поведение так,чтобы мы могли легко разделить его с этим компонентом?</target>
        </trans-unit>
        <trans-unit id="1024ae8f19583bac76078bc0bd6540db20a2ec73" translate="yes" xml:space="preserve">
          <source>Now the subscription will only be recreated when &lt;code&gt;props.source&lt;/code&gt; changes.</source>
          <target state="translated">Теперь подписка будет воссоздана только при изменении &lt;code&gt;props.source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54d03c366729e2d81c1e64f36f6b07756f996b09" translate="yes" xml:space="preserve">
          <source>Now typing has a lot less stutter &amp;mdash; although we pay for this by showing the results with a lag.</source>
          <target state="translated">Теперь при наборе текста заикание стало намного меньше - хотя мы платим за это, показывая результаты с задержкой.</target>
        </trans-unit>
        <trans-unit id="dcc5b4606d16f6fd9f79e37463ac776146ee84f2" translate="yes" xml:space="preserve">
          <source>Now we can use it from both components:</source>
          <target state="translated">Теперь мы можем использовать его из обоих компонентов:</target>
        </trans-unit>
        <trans-unit id="1eb51804f6cb1c7460d60f186cd080f9b9a70bf5" translate="yes" xml:space="preserve">
          <source>Now we could use it in our component, and let the reducer drive its state management:</source>
          <target state="translated">Теперь мы можем использовать его в нашем компоненте и позволить редуктору управлять своим состоянием:</target>
        </trans-unit>
        <trans-unit id="4fe952474b56ef3cb4e5c17adcf45971d3250970" translate="yes" xml:space="preserve">
          <source>Now you can use JSX in any &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag by adding &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; attribute to it. Here is &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;an example HTML file with JSX&lt;/a&gt; that you can download and play with.</source>
          <target state="translated">Теперь вы можете использовать JSX в любом &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; , добавив к нему атрибут &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; . Вот &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;пример HTML-файла с JSX,&lt;/a&gt; который вы можете скачать и поиграть.</target>
        </trans-unit>
        <trans-unit id="8ad6204428141993d5d0c80a5aa20caa71f41e56" translate="yes" xml:space="preserve">
          <source>Now you know what Concurrent Mode is all about!</source>
          <target state="translated">Теперь вы знаете,что такое Concurrent Mode!</target>
        </trans-unit>
        <trans-unit id="a0921c0c4a9937c51a84cd82cfb41ca7387c23e1" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;re all set! We recommend to check out the following resources to learn more about Flow:</source>
          <target state="translated">Теперь все готово! Мы рекомендуем ознакомиться со следующими ресурсами, чтобы узнать больше о Flow:</target>
        </trans-unit>
        <trans-unit id="8a49e11731f8fb793b2ecb4306067e3e3083ea67" translate="yes" xml:space="preserve">
          <source>Now, add &lt;code&gt;flow&lt;/code&gt; to the &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; section of your &lt;code&gt;package.json&lt;/code&gt; to be able to use this from the terminal:</source>
          <target state="translated">Теперь добавьте &lt;code&gt;flow&lt;/code&gt; в раздел &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; вашего &lt;code&gt;package.json&lt;/code&gt; , чтобы иметь возможность использовать его из терминала:</target>
        </trans-unit>
        <trans-unit id="c8086f34489af74ae217e4df5aa3be615d57812e" translate="yes" xml:space="preserve">
          <source>Now, instead of effectively cloning the &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component and hard-coding something else in its &lt;code&gt;render&lt;/code&gt; method to solve for a specific use case, we provide a &lt;code&gt;render&lt;/code&gt; prop that &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; can use to dynamically determine what it renders.</source>
          <target state="translated">Теперь, вместо того, чтобы эффективно клонировать компонент &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; и жестко кодировать что-то еще в его методе &lt;code&gt;render&lt;/code&gt; для решения конкретного случая использования, мы предоставляем опору &lt;code&gt;render&lt;/code&gt; которую &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; может использовать для динамического определения того, что она рендерит.</target>
        </trans-unit>
        <trans-unit id="2f73936a74018552ceacc64aa326e02fb6cf0a5b" translate="yes" xml:space="preserve">
          <source>Now, no matter which input you edit, &lt;code&gt;this.state.temperature&lt;/code&gt; and &lt;code&gt;this.state.scale&lt;/code&gt; in the &lt;code&gt;Calculator&lt;/code&gt; get updated. One of the inputs gets the value as is, so any user input is preserved, and the other input value is always recalculated based on it.</source>
          <target state="translated">Теперь, независимо от того, какой ввод вы редактируете, &lt;code&gt;this.state.temperature&lt;/code&gt; и &lt;code&gt;this.state.scale&lt;/code&gt; в &lt;code&gt;Calculator&lt;/code&gt; обновляются. Один из входов получает значение как есть, поэтому любой пользовательский ввод сохраняется, а другое входное значение всегда пересчитывается на его основе.</target>
        </trans-unit>
        <trans-unit id="301eea1e7c8206fb45c541acd3e524bf4a699d97" translate="yes" xml:space="preserve">
          <source>Now, the &lt;code&gt;setInterval&lt;/code&gt; callback executes once a second, but each time the inner call to &lt;code&gt;setCount&lt;/code&gt; can use an up-to-date value for &lt;code&gt;count&lt;/code&gt; (called &lt;code&gt;c&lt;/code&gt; in the callback here.)</source>
          <target state="translated">Теперь обратный вызов &lt;code&gt;setInterval&lt;/code&gt; выполняется раз в секунду, но каждый раз, когда внутренний вызов &lt;code&gt;setCount&lt;/code&gt; может использовать актуальное значение для &lt;code&gt;count&lt;/code&gt; (здесь называется &lt;code&gt;c&lt;/code&gt; в обратном вызове ).</target>
        </trans-unit>
        <trans-unit id="9e8130cbd3e360ebc980c05ecf896eace815977b" translate="yes" xml:space="preserve">
          <source>Now, this feels a lot better! When we click Next, it gets disabled because clicking it multiple times doesn&amp;rsquo;t make sense. And the new &amp;ldquo;Loading&amp;hellip;&amp;rdquo; tells the user that the app didn&amp;rsquo;t freeze.</source>
          <target state="translated">Теперь это намного лучше! Когда мы нажимаем &amp;laquo;Далее&amp;raquo;, он отключается, потому что щелкать его несколько раз не имеет смысла. А новая &amp;laquo;Загрузка&amp;hellip;&amp;raquo; сообщает пользователю, что приложение не зависло.</target>
        </trans-unit>
        <trans-unit id="b0f788b2b09588e404d0447b39bd5c7c761184f0" translate="yes" xml:space="preserve">
          <source>Now, when the &lt;code&gt;TemperatureInput&lt;/code&gt; wants to update its temperature, it calls &lt;code&gt;this.props.onTemperatureChange&lt;/code&gt;:</source>
          <target state="translated">Теперь, когда &lt;code&gt;TemperatureInput&lt;/code&gt; хочет обновить свою температуру, он вызывает &lt;code&gt;this.props.onTemperatureChange&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e7446f170a663a7c78e802aab1ac1a7cb9040dd" translate="yes" xml:space="preserve">
          <source>OK, so we&amp;rsquo;ve identified what the minimal set of app state is. Next, we need to identify which component mutates, or &lt;em&gt;owns&lt;/em&gt;, this state.</source>
          <target state="translated">Итак, мы определили минимальный набор состояний приложения. Затем нам нужно определить, какой компонент мутирует или &lt;em&gt;владеет&lt;/em&gt; этим состоянием.</target>
        </trans-unit>
        <trans-unit id="585a7418eed63f477ec8bd53089988cc7e4a12c6" translate="yes" xml:space="preserve">
          <source>Of course, application UIs are dynamic and change over time. In the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next section&lt;/a&gt;, we will introduce a new concept of &amp;ldquo;state&amp;rdquo;. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</source>
          <target state="translated">Конечно, пользовательские интерфейсы приложений динамичны и со временем меняются. В &lt;a href=&quot;state-and-lifecycle&quot;&gt;следующем разделе&lt;/a&gt; мы представим новое понятие &amp;laquo;состояние&amp;raquo;. Состояние позволяет компонентам React изменять свой вывод с течением времени в ответ на действия пользователя, сетевые ответы и что-либо еще, не нарушая этого правила.</target>
        </trans-unit>
        <trans-unit id="3132cb0b79eb69074dc3e62af86660efd5589630" translate="yes" xml:space="preserve">
          <source>Of course, this is possible to fix in this particular example. We could remove the &lt;code&gt;Promise.all()&lt;/code&gt; call, and wait for both Promises separately. However, this approach gets progressively more difficult as the complexity of our data and component tree grows. It&amp;rsquo;s hard to write reliable components when arbitrary parts of the data tree may be missing or stale. So fetching all data for the new screen and &lt;em&gt;then&lt;/em&gt; rendering is often a more practical option.</source>
          <target state="translated">Конечно, в этом конкретном примере это можно исправить. Мы могли бы удалить &lt;code&gt;Promise.all()&lt;/code&gt; и дождаться обоих обещаний по отдельности. Однако этот подход становится все более сложным по мере роста сложности наших данных и дерева компонентов. Трудно писать надежные компоненты, когда произвольные части дерева данных могут отсутствовать или устареть. Так что выборка всех данных для нового экрана и &lt;em&gt;последующий&lt;/em&gt; рендеринг зачастую более практичный вариант.</target>
        </trans-unit>
        <trans-unit id="a4a2711c46e947081b52625c85320ddf4541e19b" translate="yes" xml:space="preserve">
          <source>Of course, two versions of the tree rendering &lt;em&gt;at the same time&lt;/em&gt; is an illusion, just like the idea that all programs run on your computer at the same time is an illusion. An operating system switches between different applications very fast. Similarly, React can switch between the version of the tree you see on the screen and the version that it&amp;rsquo;s &amp;ldquo;preparing&amp;rdquo; to show next.</source>
          <target state="translated">Конечно, две версии визуализации дерева &lt;em&gt;одновременно&lt;/em&gt; - это иллюзия, точно так же, как идея, что все программы запускаются на вашем компьютере одновременно, является иллюзией. Операционная система очень быстро переключается между различными приложениями. Точно так же React может переключаться между версией дерева, которую вы видите на экране, и версией, которую он &amp;laquo;готовит&amp;raquo; к следующей.</target>
        </trans-unit>
        <trans-unit id="4d6825e0a32d926930eddf56f84b2970fa58fb08" translate="yes" xml:space="preserve">
          <source>Of the many options, we&amp;rsquo;ll look at &lt;code&gt;rootDir&lt;/code&gt; and &lt;code&gt;outDir&lt;/code&gt;. In its true fashion, the compiler will take in typescript files and generate javascript files. However we don&amp;rsquo;t want to get confused with our source files and the generated output.</source>
          <target state="translated">Из множества вариантов мы рассмотрим &lt;code&gt;rootDir&lt;/code&gt; и &lt;code&gt;outDir&lt;/code&gt; . Настоящим компилятор принимает файлы машинописного текста и генерирует файлы javascript. Однако мы не хотим путаться с нашими исходными файлами и сгенерированным выводом.</target>
        </trans-unit>
        <trans-unit id="dd20357e3644302dde97b2ad62dcb95ce1daedfd" translate="yes" xml:space="preserve">
          <source>Often, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to &lt;code&gt;useEffect&lt;/code&gt; may return a clean-up function. For example, to create a subscription:</source>
          <target state="translated">Часто эффекты создают ресурсы, которые необходимо очистить до того, как компонент покинет экран, например подписку или идентификатор таймера. Для этого функция, переданная в &lt;code&gt;useEffect&lt;/code&gt; , может возвращать функцию очистки. Например, чтобы создать подписку:</target>
        </trans-unit>
        <trans-unit id="2eb2d11868ae24a92e334900c6ad022490e23cc8" translate="yes" xml:space="preserve">
          <source>Often, render props and higher-order components render only a single child. We think Hooks are a simpler way to serve this use case. There is still a place for both patterns (for example, a virtual scroller component might have a &lt;code&gt;renderItem&lt;/code&gt; prop, or a visual container component might have its own DOM structure). But in most cases, Hooks will be sufficient and can help reduce nesting in your tree.</source>
          <target state="translated">Часто объекты рендеринга и компоненты более высокого порядка рендерит только одного дочернего элемента. Мы думаем, что хуки - это более простой способ выполнить этот вариант использования. По-прежнему есть место для обоих шаблонов (например, компонент виртуального скроллера может иметь &lt;code&gt;renderItem&lt;/code&gt; , или компонент визуального контейнера может иметь свою собственную структуру DOM). Но в большинстве случаев крючков будет достаточно, и они помогут уменьшить количество вложений в дерево.</target>
        </trans-unit>
        <trans-unit id="e238d62aafad5d06561c0c307e341349b7b49d0a" translate="yes" xml:space="preserve">
          <source>Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let&amp;rsquo;s see how this works in action.</source>
          <target state="translated">Часто несколько компонентов должны отражать одни и те же изменяющиеся данные. Мы рекомендуем поднять общее состояние до их ближайшего общего предка. Посмотрим, как это работает в действии.</target>
        </trans-unit>
        <trans-unit id="2a50db4683ea185c93852b3e2a65a8212128837a" translate="yes" xml:space="preserve">
          <source>On Node.js, runners like Jest &lt;a href=&quot;https://jestjs.io/docs/en/manual-mocks&quot;&gt;support mocking modules&lt;/a&gt;. You could also use libraries like &lt;a href=&quot;https://www.npmjs.com/package/mock-require&quot;&gt;&lt;code&gt;mock-require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">На Node.js такие раннеры, как Jest, &lt;a href=&quot;https://jestjs.io/docs/en/manual-mocks&quot;&gt;поддерживают фиктивные модули&lt;/a&gt; . Вы также можете использовать библиотеки, такие как &lt;a href=&quot;https://www.npmjs.com/package/mock-require&quot;&gt; &lt;code&gt;mock-require&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0710c7b04d45a11f0492b116459fb4abc9eedba3" translate="yes" xml:space="preserve">
          <source>On mount, add a change listener to &lt;code&gt;DataSource&lt;/code&gt;.</source>
          <target state="translated">При монтировании добавьте слушателя изменений в &lt;code&gt;DataSource&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82c91bbc6306c5630c222b9dcf2187c2dc2ae099" translate="yes" xml:space="preserve">
          <source>On the next pages, you&amp;rsquo;ll learn more details about specific topics:</source>
          <target state="translated">На следующих страницах вы узнаете более подробную информацию по конкретным темам:</target>
        </trans-unit>
        <trans-unit id="9d62e4f730620eef1f3de85e2d6c3131a9b4dfea" translate="yes" xml:space="preserve">
          <source>On this page we&amp;rsquo;ve learned about one of the Hooks provided by React, called &lt;code&gt;useState&lt;/code&gt;. We&amp;rsquo;re also sometimes going to refer to it as the &amp;ldquo;State Hook&amp;rdquo;. It lets us add local state to React function components &amp;mdash; which we did for the first time ever!</source>
          <target state="translated">На этой странице мы узнали об одном из хуков, предоставляемых React, под названием &lt;code&gt;useState&lt;/code&gt; . Мы также иногда будем называть это &amp;laquo;крючком состояния&amp;raquo;. Это позволяет нам добавлять локальное состояние к компонентам функции React - что мы сделали впервые!</target>
        </trans-unit>
        <trans-unit id="0c2cd7a4d0e65ff37df2b337e658e2df9075d64a" translate="yes" xml:space="preserve">
          <source>On this page, we don&amp;rsquo;t assume knowledge of Relay, so we won&amp;rsquo;t be using it for this example. Instead, we&amp;rsquo;ll write something similar manually by combining our data fetching methods:</source>
          <target state="translated">На этой странице мы не предполагаем, что знаем Relay, поэтому мы не будем использовать его в этом примере. Вместо этого мы напишем нечто подобное вручную, объединив наши методы получения данных:</target>
        </trans-unit>
        <trans-unit id="fb59abe30c04acfe966b6c95ce457faf73c79f0f" translate="yes" xml:space="preserve">
          <source>On this page, we will primarily use function components. However, these testing strategies don&amp;rsquo;t depend on implementation details, and work just as well for class components too.</source>
          <target state="translated">На этой странице мы в основном будем использовать функциональные компоненты. Однако эти стратегии тестирования не зависят от деталей реализации и работают также и для компонентов класса.</target>
        </trans-unit>
        <trans-unit id="4d9354d5334212c4fa7c510917e4a36aa72a9176" translate="yes" xml:space="preserve">
          <source>On unmount, remove the change listener.</source>
          <target state="translated">При размонтировании удалите слушателя изменений.</target>
        </trans-unit>
        <trans-unit id="06dfbc05cf68b1af9ef7e3eb0c666319a41ff504" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re comfortable with the &lt;a href=&quot;index&quot;&gt;main concepts&lt;/a&gt; and played with React a little bit, you might be interested in more advanced topics. This section will introduce you to the powerful, but less commonly used React features like &lt;a href=&quot;context&quot;&gt;context&lt;/a&gt; and &lt;a href=&quot;refs-and-the-dom&quot;&gt;refs&lt;/a&gt;.</source>
          <target state="translated">Когда вы освоитесь с &lt;a href=&quot;index&quot;&gt;основными концепциями&lt;/a&gt; и немного поиграете с React, вас могут заинтересовать более сложные темы. В этом разделе вы познакомитесь с мощными, но менее часто используемыми функциями React, такими как &lt;a href=&quot;context&quot;&gt;context&lt;/a&gt; и &lt;a href=&quot;refs-and-the-dom&quot;&gt;refs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26db98adea48b68a169ca2de0e843e2459313e88" translate="yes" xml:space="preserve">
          <source>One caveat is that some &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;&amp;ldquo;falsy&amp;rdquo; values&lt;/a&gt;, such as the &lt;code&gt;0&lt;/code&gt; number, are still rendered by React. For example, this code will not behave as you might expect because &lt;code&gt;0&lt;/code&gt; will be printed when &lt;code&gt;props.messages&lt;/code&gt; is an empty array:</source>
          <target state="translated">Одно предостережение заключается в том, что некоторые &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;&amp;laquo;ложные&amp;raquo; значения&lt;/a&gt; , такие как число &lt;code&gt;0&lt;/code&gt; , все еще обрабатываются React. Например, этот код не будет вести себя так, как вы могли ожидать, потому что &lt;code&gt;0&lt;/code&gt; будет напечатан, когда &lt;code&gt;props.messages&lt;/code&gt; является пустым массивом:</target>
        </trans-unit>
        <trans-unit id="92d29f167487a4fbbd927e887cecef3d212e829f" translate="yes" xml:space="preserve">
          <source>One common confusion is that Web Components use &amp;ldquo;class&amp;rdquo; instead of &amp;ldquo;className&amp;rdquo;.</source>
          <target state="translated">Одна из распространенных ошибок заключается в том, что веб-компоненты используют &amp;laquo;класс&amp;raquo; вместо &amp;laquo;имя класса&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d84c92ddc298e496ea4adc3bf91cf1363cd458a5" translate="yes" xml:space="preserve">
          <source>One common use case is a component wanting to update itself on a time interval. It&amp;rsquo;s easy to use &lt;code&gt;setInterval()&lt;/code&gt;, but it&amp;rsquo;s important to cancel your interval when you don&amp;rsquo;t need it anymore to save memory. React provides &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; that let you know when a component is about to be created or destroyed. Let&amp;rsquo;s create a simple mixin that uses these methods to provide an easy &lt;code&gt;setInterval()&lt;/code&gt; function that will automatically get cleaned up when your component is destroyed.</source>
          <target state="translated">Один из распространенных вариантов использования - компонент, желающий обновлять себя через определенный промежуток времени. Использовать &lt;code&gt;setInterval()&lt;/code&gt; , но важно отменить интервал, когда он больше не нужен для экономии памяти. React предоставляет &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;методы жизненного цикла,&lt;/a&gt; которые сообщают вам, когда компонент будет создан или уничтожен. Давайте создадим простой миксин, который использует эти методы для обеспечения простой функции &lt;code&gt;setInterval()&lt;/code&gt; которая будет автоматически очищаться при уничтожении вашего компонента.</target>
        </trans-unit>
        <trans-unit id="91fca79071097d684ed292ccb8f4ce6e063eb595" translate="yes" xml:space="preserve">
          <source>One common way to structure projects is locate CSS, JS, and tests together inside folders grouped by feature or route.</source>
          <target state="translated">Одним из распространенных способов структурирования проектов является поиск CSS,JS и совместное тестирование внутри папок,сгруппированных по функциям или маршруту.</target>
        </trans-unit>
        <trans-unit id="eecfa7e254d87da6b100134e8a7e164ed183eec7" translate="yes" xml:space="preserve">
          <source>One common way to structure projects is to locate CSS, JS, and tests together inside folders grouped by feature or route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3294950b9d1114486b86edac639fe247ba41031e" translate="yes" xml:space="preserve">
          <source>One interesting thing to note about render props is that you can implement most &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; (HOC) using a regular component with a render prop. For example, if you would prefer to have a &lt;code&gt;withMouse&lt;/code&gt; HOC instead of a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component, you could easily create one using a regular &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a render prop:</source>
          <target state="translated">В отношении свойств рендеринга следует отметить одну интересную вещь: вы можете реализовать большинство &lt;a href=&quot;higher-order-components&quot;&gt;компонентов более высокого порядка&lt;/a&gt; (HOC), используя обычный компонент с опорой рендеринга. Например, если вы предпочитаете иметь &lt;code&gt;withMouse&lt;/code&gt; HOC вместо компонента &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; , вы можете легко создать его, используя обычную &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; с опорой рендеринга:</target>
        </trans-unit>
        <trans-unit id="89bb7b23e1cfb796ff7ccb3c5631654a6d5d4429" translate="yes" xml:space="preserve">
          <source>One might confuse elements with a more widely known concept of &amp;ldquo;components&amp;rdquo;. We will introduce components in the &lt;a href=&quot;components-and-props&quot;&gt;next section&lt;/a&gt;. Elements are what components are &amp;ldquo;made of&amp;rdquo;, and we encourage you to read this section before jumping ahead.</source>
          <target state="translated">Можно спутать элементы с более широко известным понятием &amp;laquo;компоненты&amp;raquo;. Мы представим компоненты в &lt;a href=&quot;components-and-props&quot;&gt;следующем разделе&lt;/a&gt; . Элементы - это то, из чего &amp;laquo;сделаны&amp;raquo; компоненты, и мы рекомендуем вам прочитать этот раздел, прежде чем двигаться дальше.</target>
        </trans-unit>
        <trans-unit id="7588b233fbe6695c0a65bfe0ca7544cc4e57a4ac" translate="yes" xml:space="preserve">
          <source>One might think that this is a problem specific to &lt;code&gt;useEffect&lt;/code&gt; or Hooks. Maybe if we port this code to classes or use convenient syntax like &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;, it will solve the problem?</source>
          <target state="translated">Можно подумать, что это проблема, специфичная для &lt;code&gt;useEffect&lt;/code&gt; или Hooks. Может быть, если мы перенесем этот код в классы или воспользуемся удобным синтаксисом вроде &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; , это решит проблему?</target>
        </trans-unit>
        <trans-unit id="c0f348c5b745ab1da4b86972cf956fe2d397217e" translate="yes" xml:space="preserve">
          <source>One of the many great parts of React is how it makes you think about apps as you build them. In this document, we&amp;rsquo;ll walk you through the thought process of building a searchable product data table using React.</source>
          <target state="translated">Одна из многих замечательных частей React - это то, как он заставляет вас думать о приложениях в процессе их создания. В этом документе мы проведем вас через мыслительный процесс создания таблицы данных о товарах с возможностью поиска с помощью React.</target>
        </trans-unit>
        <trans-unit id="7ac2374e3473c6ff21b1231d986c7761ceb4980d" translate="yes" xml:space="preserve">
          <source>One of the problems we outlined in the &lt;a href=&quot;hooks-intro#complex-components-become-hard-to-understand&quot;&gt;Motivation&lt;/a&gt; for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:</source>
          <target state="translated">Одна из проблем, которую мы обозначили в разделе &amp;laquo; &lt;a href=&quot;hooks-intro#complex-components-become-hard-to-understand&quot;&gt;Мотивация&lt;/a&gt; для хуков&amp;raquo;, заключается в том, что методы жизненного цикла класса часто содержат несвязанную логику, но связанную логику разбивают на несколько методов. Вот компонент, который объединяет логику счетчика и индикатора статуса друга из предыдущих примеров:</target>
        </trans-unit>
        <trans-unit id="a418baabb2a2970b5f712a2f3fec059c69ada5c1" translate="yes" xml:space="preserve">
          <source>One possible solution to this is to &lt;em&gt;delay the spinner itself&lt;/em&gt; from displaying:</source>
          <target state="translated">Одно из возможных решений - &lt;em&gt;отложить&lt;/em&gt; отображение &lt;em&gt;самого счетчика&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b271b0f7d1b61e9056e53697bfa59e66ec53dabf" translate="yes" xml:space="preserve">
          <source>One rudimentary way to measure the position or size of a DOM node is to use a &lt;a href=&quot;refs-and-the-dom#callback-refs&quot;&gt;callback ref&lt;/a&gt;. React will call that callback whenever the ref gets attached to a different node. Here is a &lt;a href=&quot;https://codesandbox.io/s/l7m0v5x4v9&quot;&gt;small demo&lt;/a&gt;:</source>
          <target state="translated">Один элементарный способ измерить положение или размер узла DOM - использовать &lt;a href=&quot;refs-and-the-dom#callback-refs&quot;&gt;обратный вызов ref&lt;/a&gt; . React будет вызывать этот обратный вызов всякий раз, когда ссылка прикрепляется к другому узлу. Вот &lt;a href=&quot;https://codesandbox.io/s/l7m0v5x4v9&quot;&gt;небольшая демонстрация&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6fa8706f6009f63753c15a5df17eaaa0d7f204a0" translate="yes" xml:space="preserve">
          <source>One solution to this is to extract the model&amp;rsquo;s attributes as plain data whenever it changes, and keep this logic in a single place. The following is &lt;a href=&quot;higher-order-components&quot;&gt;a higher-order component&lt;/a&gt; that extracts all attributes of a Backbone model into state, passing the data to the wrapped component.</source>
          <target state="translated">Одно из решений этого - извлекать атрибуты модели в виде простых данных всякий раз, когда они меняются, и хранить эту логику в одном месте. Ниже представлен &lt;a href=&quot;higher-order-components&quot;&gt;компонент более высокого порядка,&lt;/a&gt; который извлекает все атрибуты модели Backbone в состояние, передавая данные обернутому компоненту.</target>
        </trans-unit>
        <trans-unit id="58b79eb7fa7ae8bb13eed6fa689b5ce8ed867366" translate="yes" xml:space="preserve">
          <source>One way to solve this issue &lt;strong&gt;without context&lt;/strong&gt; is to &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;pass down the &lt;code&gt;Avatar&lt;/code&gt; component itself&lt;/a&gt; so that the intermediate components don&amp;rsquo;t need to know about the &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;avatarSize&lt;/code&gt; props:</source>
          <target state="translated">Один из способов решить эту проблему &lt;strong&gt;без контекста&lt;/strong&gt; - &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;передать сам компонент &lt;code&gt;Avatar&lt;/code&gt; ,&lt;/a&gt; чтобы промежуточным компонентам не нужно было знать о &lt;code&gt;user&lt;/code&gt; или реквизитах &lt;code&gt;avatarSize&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6299e6ee53c4fc7bdfb602433272b7a519918fc" translate="yes" xml:space="preserve">
          <source>One way we could fix it is by putting them both in a single boundary:</source>
          <target state="translated">Один из способов исправить это-поместить их обоих в одну границу:</target>
        </trans-unit>
        <trans-unit id="c05b9709100b2a39470a0603a95728131ccfa2e0" translate="yes" xml:space="preserve">
          <source>Online Playgrounds</source>
          <target state="translated">Игровые площадки онлайн</target>
        </trans-unit>
        <trans-unit id="68c313b91ba43cdce9e6230021dd3cc44332356e" translate="yes" xml:space="preserve">
          <source>Only Call Hooks at the Top Level</source>
          <target state="translated">Только перехваты звонков на высшем уровне</target>
        </trans-unit>
        <trans-unit id="980e73ef860f23909c36445661b606d8b3e93697" translate="yes" xml:space="preserve">
          <source>Only Call Hooks from React Functions</source>
          <target state="translated">Только &quot;Крючки вызова&quot; от реактивных функций.</target>
        </trans-unit>
        <trans-unit id="5acf9b36b7f149f65b12a00c58b688239df37660" translate="yes" xml:space="preserve">
          <source>Only call Hooks &lt;strong&gt;at the top level&lt;/strong&gt;. Don&amp;rsquo;t call Hooks inside loops, conditions, or nested functions.</source>
          <target state="translated">Вызывайте хуки только &lt;strong&gt;на верхнем уровне&lt;/strong&gt; . Не вызывайте ловушки внутри циклов, условий или вложенных функций.</target>
        </trans-unit>
        <trans-unit id="c8bacc2bc0cd7f69fa0df071e2e600234a8896fe" translate="yes" xml:space="preserve">
          <source>Only call Hooks &lt;strong&gt;from React function components&lt;/strong&gt;. Don&amp;rsquo;t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks &amp;mdash; your own custom Hooks. We&amp;rsquo;ll learn about them in a moment.)</source>
          <target state="translated">Вызывайте &lt;strong&gt;хуки&lt;/strong&gt; только &lt;strong&gt;из компонентов функции React&lt;/strong&gt; . Не вызывайте хуки из обычных функций JavaScript. (Есть еще одно допустимое место для вызова хуков - ваши собственные хуки. Мы узнаем о них чуть позже.)</target>
        </trans-unit>
        <trans-unit id="78f87a20c05bef10c0fc20bc0609245bc0128bed" translate="yes" xml:space="preserve">
          <source>Only do this if you couldn&amp;rsquo;t find a better alternative, as relying on mutation makes components less predictable. If there&amp;rsquo;s a specific pattern that doesn&amp;rsquo;t translate well, &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;file an issue&lt;/a&gt; with a runnable example code and we can try to help.</source>
          <target state="translated">Делайте это только в том случае, если вы не смогли найти лучшей альтернативы, поскольку мутация делает компоненты менее предсказуемыми. Если есть конкретный шаблон, который плохо переводится, сообщите &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;о проблеме&lt;/a&gt; с помощью работоспособного примера кода, и мы постараемся помочь.</target>
        </trans-unit>
        <trans-unit id="c28575a6029fc70e57860e000b695cc6f0b3e57e" translate="yes" xml:space="preserve">
          <source>Only ever use CSS that removes this outline, for example by setting &lt;code&gt;outline: 0&lt;/code&gt;, if you are replacing it with another focus outline implementation.</source>
          <target state="translated">Используйте только CSS, который удаляет этот контур, например, устанавливая &lt;code&gt;outline: 0&lt;/code&gt; , если вы заменяете его другой реализацией контура фокуса.</target>
        </trans-unit>
        <trans-unit id="7322dbc7cc37c39174edd21f985b523446462851" translate="yes" xml:space="preserve">
          <source>Only use error boundaries for recovering from unexpected exceptions; &lt;strong&gt;don&amp;rsquo;t try to use them for control flow.&lt;/strong&gt;</source>
          <target state="translated">Используйте границы ошибок только для восстановления после неожиданных исключений; &lt;strong&gt;не пытайтесь использовать их для потока управления.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b1b25a5af502c4955acf005be6d083dc1a30602" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;https://codesandbox.io/s/nameless-butterfly-fkw5q&quot;&gt;this example&lt;/a&gt;. When you press a button, you&amp;rsquo;ll see the Pending state for a second before moving on. This transition feels nice and fluid.</source>
          <target state="translated">Откройте &lt;a href=&quot;https://codesandbox.io/s/nameless-butterfly-fkw5q&quot;&gt;этот пример&lt;/a&gt; . Когда вы нажимаете кнопку, вы на секунду увидите состояние ожидания, прежде чем двигаться дальше. Этот переход кажется приятным и плавным.</target>
        </trans-unit>
        <trans-unit id="82faec880ab06096a12df754c31b316dbff6580b" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;this example&lt;/a&gt; and click &amp;ldquo;Open Profile&amp;rdquo;. You will see several visual states one by one:</source>
          <target state="translated">Откройте &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;этот пример&lt;/a&gt; и нажмите &amp;laquo;Открыть профиль&amp;raquo;. Вы увидите несколько визуальных состояний одно за другим:</target>
        </trans-unit>
        <trans-unit id="f911658ce7d859922d5257b0b036abe5292fca9b" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;this starter code&lt;/a&gt;&lt;/strong&gt; and paste it into the file you created.</source>
          <target state="translated">Откройте &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;этот стартовый код&lt;/a&gt;&lt;/strong&gt; и вставьте его в созданный файл.</target>
        </trans-unit>
        <trans-unit id="55d9ece27ec32d8829711be1a1d3afea9c2dafd2" translate="yes" xml:space="preserve">
          <source>Open the Chrome DevTools &lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;Performance&lt;/a&gt;&lt;/strong&gt; tab and press &lt;strong&gt;Record&lt;/strong&gt;.</source>
          <target state="translated">Откройте вкладку &amp;laquo; &lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;Производительность&lt;/a&gt;&lt;/strong&gt; Chrome DevTools &amp;raquo; и нажмите &amp;laquo; &lt;strong&gt;Запись&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a45e17e011c01ffe2a91ced4f7a209475dd8d2a0" translate="yes" xml:space="preserve">
          <source>Optimizing Performance</source>
          <target state="translated">Оптимизация производительности</target>
        </trans-unit>
        <trans-unit id="db92a3f80d780ad79d58ccf80d95c08e0583866f" translate="yes" xml:space="preserve">
          <source>Optimizing the output for production.</source>
          <target state="translated">Оптимизация производства.</target>
        </trans-unit>
        <trans-unit id="ebed446427427efeada77fb1de8555c343d3531f" translate="yes" xml:space="preserve">
          <source>Opting into Concurrent Mode introduces semantic changes to how React works. This means that you can&amp;rsquo;t use Concurrent Mode in just a few components. Because of this, some apps may not be able to migrate directly to Concurrent Mode.</source>
          <target state="translated">Включение параллельного режима вносит семантические изменения в работу React. Это означает, что вы не можете использовать Concurrent Mode всего в нескольких компонентах. Из-за этого некоторые приложения могут быть недоступны для прямого перехода в параллельный режим.</target>
        </trans-unit>
        <trans-unit id="eb6793ee41543d3424f0cf56f0cf4f4c5c5d0813" translate="yes" xml:space="preserve">
          <source>Optional: &lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;Download the full example (2KB zipped)&lt;/a&gt;</source>
          <target state="translated">Необязательно: &lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;загрузите полный пример (2 КБ в архиве)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee3267798d0259e5dd98aa26c31e33223e26cac3" translate="yes" xml:space="preserve">
          <source>Optional: Try React with JSX</source>
          <target state="translated">Необязательно:Попробуйте реагировать с JSX</target>
        </trans-unit>
        <trans-unit id="3a09e35972dfc007bcd7aa10e05cf800743e8354" translate="yes" xml:space="preserve">
          <source>Or yarn:</source>
          <target state="translated">Или пряжа:</target>
        </trans-unit>
        <trans-unit id="160496746ed70b43025c17e2f2433373eef18b6a" translate="yes" xml:space="preserve">
          <source>Other APIs</source>
          <target state="translated">Другие API</target>
        </trans-unit>
        <trans-unit id="1b361bfb2d40f2fa584dfe16d7abd56931268577" translate="yes" xml:space="preserve">
          <source>Other Build Setups</source>
          <target state="translated">Другие настройки здания</target>
        </trans-unit>
        <trans-unit id="718591843f9ba65a328acf7e21cfb68fa2042427" translate="yes" xml:space="preserve">
          <source>Other Events</source>
          <target state="translated">Другие события</target>
        </trans-unit>
        <trans-unit id="456d2677e518e26ef0d24a4e5e0c50a00c1e8bbd" translate="yes" xml:space="preserve">
          <source>Other Languages</source>
          <target state="translated">Другие языки</target>
        </trans-unit>
        <trans-unit id="b1866d3283a2c6b4f31b7bd94d302109ad919e6f" translate="yes" xml:space="preserve">
          <source>Other Patterns</source>
          <target state="translated">Другие модели</target>
        </trans-unit>
        <trans-unit id="670876f3113d937960727ed05a2f82e686590502" translate="yes" xml:space="preserve">
          <source>Other Points for Consideration</source>
          <target state="translated">Другие вопросы для рассмотрения</target>
        </trans-unit>
        <trans-unit id="c8298a228f42e1a844433af47c0c496b7ae9065b" translate="yes" xml:space="preserve">
          <source>Other Screen Readers</source>
          <target state="translated">Другие считыватели экрана</target>
        </trans-unit>
        <trans-unit id="a6a3346524b28d21d18a28316c1731fc127a349f" translate="yes" xml:space="preserve">
          <source>Other Utilities</source>
          <target state="translated">Другие коммунальные услуги</target>
        </trans-unit>
        <trans-unit id="4715125742dd4e459dcb1cbb3b644f3692b0c443" translate="yes" xml:space="preserve">
          <source>Other approaches to this, such as composing Promises in a special way, are increasingly difficult to pull off when the loading states are located in different components down the tree.</source>
          <target state="translated">Другие подходы к этому,такие как составление обещаний особым образом,становятся все более сложными,когда состояния нагрузки расположены в различных компонентах вниз по дереву.</target>
        </trans-unit>
        <trans-unit id="b17f43760c19635a2cfeb450e22843e0fca3cca3" translate="yes" xml:space="preserve">
          <source>Other effects might not have a cleanup phase, and don&amp;rsquo;t return anything.</source>
          <target state="translated">Другие эффекты могут не иметь фазы очистки и ничего не возвращать.</target>
        </trans-unit>
        <trans-unit id="efe0a2f2b6a088b22020eedfca1f8171b23b1b2a" translate="yes" xml:space="preserve">
          <source>Other libraries might support hooks in the future too.</source>
          <target state="translated">Другие библиотеки также могут поддерживать крючки в будущем.</target>
        </trans-unit>
        <trans-unit id="fbb1c9f1eb4ca77b950c7272aaa7baca69202c49" translate="yes" xml:space="preserve">
          <source>Our &amp;ldquo;Next&amp;rdquo; button click handler sets the state that switches the current profile in the state:</source>
          <target state="translated">Наш обработчик нажатия кнопки &amp;laquo;Далее&amp;raquo; устанавливает состояние, которое переключает текущий профиль в состояние:</target>
        </trans-unit>
        <trans-unit id="d8d512d8960f76b07e5be884686cf1a1860c585e" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Button&lt;/code&gt; component will immediately show the Pending state indicator on click:</source>
          <target state="translated">Наш компонент &lt;code&gt;Button&lt;/code&gt; сразу покажет индикатор Pending state при нажатии:</target>
        </trans-unit>
        <trans-unit id="5564b57b9c8ed5194280102aa6b272b6ace8690e" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Welcome&lt;/code&gt; component returns a &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; element as the result.</source>
          <target state="translated">Наш компонент &lt;code&gt;Welcome&lt;/code&gt; возвращает в качестве результата элемент &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e602677bd730cb72e7da761f1b1f89e01b70c7" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;useTransition()&lt;/code&gt; call returns two values: &lt;code&gt;startTransition&lt;/code&gt; and &lt;code&gt;isPending&lt;/code&gt;.</source>
          <target state="translated">Наш &lt;code&gt;useTransition()&lt;/code&gt; возвращает два значения: &lt;code&gt;startTransition&lt;/code&gt; и &lt;code&gt;isPending&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b96521a8515cede856d54400c09ad380c0daf2e3" translate="yes" xml:space="preserve">
          <source>Our JSON API returns some data that looks like this:</source>
          <target state="translated">Наш JSON API возвращает некоторые данные,которые выглядят так:</target>
        </trans-unit>
        <trans-unit id="bef855825370735f30744e8e204330946ef7b36c" translate="yes" xml:space="preserve">
          <source>Our React applications continuously modify the HTML DOM during runtime, sometimes leading to keyboard focus being lost or set to an unexpected element. In order to repair this, we need to programmatically nudge the keyboard focus in the right direction. For example, by resetting keyboard focus to a button that opened a modal window after that modal window is closed.</source>
          <target state="translated">Наши React приложения непрерывно изменяют HTML DOM во время выполнения,что иногда приводит к потере фокуса клавиатуры или установке неожиданного элемента.Чтобы это исправить,нам необходимо программно подтолкнуть фокус клавиатуры в нужном направлении.Например,путем сброса фокуса клавиатуры на кнопку,которая открывала модальное окно после закрытия этого модального окна.</target>
        </trans-unit>
        <trans-unit id="74299bea00c013faee08bac03735a9e8eb9da361" translate="yes" xml:space="preserve">
          <source>Our first attempt might look like this:</source>
          <target state="translated">Наша первая попытка может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="cfdb46afa859b90b54e6db2005a9424a33bafd62" translate="yes" xml:space="preserve">
          <source>Our goal is for Hooks to cover all use cases for classes as soon as possible. There are no Hook equivalents to the uncommon &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; and &lt;code&gt;componentDidCatch&lt;/code&gt; lifecycles yet, but we plan to add them soon.</source>
          <target state="translated">Наша цель состоит в том, чтобы хуки как можно скорее охватили все варианты использования классов. Пока нет эквивалентов &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; для необычных жизненных циклов getSnapshotBeforeUpdate и &lt;code&gt;componentDidCatch&lt;/code&gt; , но мы планируем добавить их в ближайшее время.</target>
        </trans-unit>
        <trans-unit id="4fbbff78891e0fe3161c5f1fa839d8f83c89e351" translate="yes" xml:space="preserve">
          <source>Our goal is for Hooks to cover all use cases for classes as soon as possible. There are no Hook equivalents to the uncommon &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt;, &lt;code&gt;getDerivedStateFromError&lt;/code&gt; and &lt;code&gt;componentDidCatch&lt;/code&gt; lifecycles yet, but we plan to add them soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7bdd68f3093bdd85231792c356d3a08261c101" translate="yes" xml:space="preserve">
          <source>Our new example starts by importing the &lt;code&gt;useState&lt;/code&gt; Hook from React:</source>
          <target state="translated">Наш новый пример начинается с импорта &lt;code&gt;useState&lt;/code&gt; из React:</target>
        </trans-unit>
        <trans-unit id="1fc98859f39fc7662d2321203db3a057fbfc1f78" translate="yes" xml:space="preserve">
          <source>Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync.</source>
          <target state="translated">Наше новое требование заключается в том,что в дополнение к входу по Цельсию мы предоставляем вход по Фаренгейту,и они синхронизируются.</target>
        </trans-unit>
        <trans-unit id="bdbaf73bc5cb4adf782290fa0e9328bf03a93107" translate="yes" xml:space="preserve">
          <source>Our old experiments with functional APIs in the &lt;a href=&quot;https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State&quot;&gt;react-future&lt;/a&gt; repository.</source>
          <target state="translated">Наши старые эксперименты с функциональными API в репозитории &lt;a href=&quot;https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State&quot;&gt;react-future&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecead6fae262a6840fa100e15a353465a381857e" translate="yes" xml:space="preserve">
          <source>Over a million developers use React, collectively maintaining millions of components. The Facebook codebase alone has over 50,000 React components. That means we need to make it as easy as possible to upgrade to new versions of React; if we make large changes without a migration path, people will be stuck on old versions. We test these upgrade paths on Facebook itself &amp;ndash; if our team of less than 10 people can update 50,000+ components alone, we hope the upgrade will be manageable for anyone using React. In many cases, we write &lt;a href=&quot;https://github.com/reactjs/react-codemod&quot;&gt;automated scripts&lt;/a&gt; to upgrade component syntax, which we then include in the open-source release for everyone to use.</source>
          <target state="translated">Более миллиона разработчиков используют React, коллективно обслуживая миллионы компонентов. Только кодовая база Facebook насчитывает более 50 000 компонентов React. Это означает, что нам нужно максимально упростить обновление до новых версий React; если мы внесем большие изменения без пути миграции, люди застрянут на старых версиях. Мы тестируем эти способы обновления на самом Facebook - если наша команда из менее чем 10 человек сможет обновить только 50 000+ компонентов, мы надеемся, что обновление будет управляемым для всех, кто использует React. Во многих случаях мы пишем &lt;a href=&quot;https://github.com/reactjs/react-codemod&quot;&gt;автоматизированные сценарии&lt;/a&gt; для обновления синтаксиса компонентов, которые затем включаем в выпуск с открытым исходным кодом, чтобы каждый мог их использовать.</target>
        </trans-unit>
        <trans-unit id="67ee80037726319e2173c25a2b8a820cdf39330c" translate="yes" xml:space="preserve">
          <source>Over the next several months, many libraries will appear with different takes on Suspense APIs. &lt;strong&gt;If you prefer to learn when things are more stable, you might prefer to ignore this work for now, and come back when the Suspense ecosystem is more mature.&lt;/strong&gt;</source>
          <target state="translated">В течение следующих нескольких месяцев появится множество библиотек с разными взглядами на Suspense API. &lt;strong&gt;Если вы предпочитаете учиться, когда дела обстоят более стабильно, вы можете пока проигнорировать эту работу и вернуться, когда экосистема Suspense станет более зрелой.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33b00a214a218165c819825f50d811fd28c59d9c" translate="yes" xml:space="preserve">
          <source>Overall, this makes it so that &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; all work very similarly - they all accept a &lt;code&gt;value&lt;/code&gt; attribute that you can use to implement a controlled component.</source>
          <target state="translated">В целом это делает так, что &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; работают очень похоже - все они принимают атрибут &lt;code&gt;value&lt;/code&gt; который вы можете использовать для реализации управляемого компонента.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="ac6ae6a452c9a133b258c63f82756651e2997eaf" translate="yes" xml:space="preserve">
          <source>Package Managers</source>
          <target state="translated">Менеджеры пакетов</target>
        </trans-unit>
        <trans-unit id="20ec6193c88aaa60a810f707fb624f400dab682a" translate="yes" xml:space="preserve">
          <source>Package managers are tools that allow you to manage dependencies in your project. &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; are two package managers commonly used in React applications. Both of them are clients for the same npm package registry.</source>
          <target state="translated">Менеджеры пакетов - это инструменты, которые позволяют управлять зависимостями в вашем проекте. &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; и &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; - два менеджера пакетов, обычно используемые в приложениях React. Оба они являются клиентами одного и того же реестра пакетов npm.</target>
        </trans-unit>
        <trans-unit id="7dca5f8363324ed0f27645a7b9839654bdd31f45" translate="yes" xml:space="preserve">
          <source>Parent-Child Coupling</source>
          <target state="translated">Сочетание родителей и детей</target>
        </trans-unit>
        <trans-unit id="60bd5e09f1e5e3ba47a58c7db16fad72304e43c8" translate="yes" xml:space="preserve">
          <source>Pass a &amp;ldquo;create&amp;rdquo; function and an array of dependencies. &lt;code&gt;useMemo&lt;/code&gt; will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.</source>
          <target state="translated">Передайте функцию &amp;laquo;создать&amp;raquo; и массив зависимостей. &lt;code&gt;useMemo&lt;/code&gt; будет пересчитывать мемоизированное значение только при изменении одной из зависимостей. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.</target>
        </trans-unit>
        <trans-unit id="dd926194677835b376654a809999d830104e7b63" translate="yes" xml:space="preserve">
          <source>Pass a function instead of an object to &lt;code&gt;setState&lt;/code&gt; to ensure the call always uses the most updated version of state (see below).</source>
          <target state="translated">Передайте функцию вместо объекта в &lt;code&gt;setState&lt;/code&gt; , чтобы при вызове всегда использовалась самая обновленная версия состояния (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="2780570791c9ee7131760cf13185af6586f6a67f" translate="yes" xml:space="preserve">
          <source>Pass a mocked component module to this method to augment it with useful methods that allow it to be used as a dummy React component. Instead of rendering as usual, the component will become a simple &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; (or other tag if &lt;code&gt;mockTagName&lt;/code&gt; is provided) containing any provided children.</source>
          <target state="translated">Передайте фиктивный компонентный модуль этому методу, чтобы дополнить его полезными методами, которые позволяют использовать его в качестве фиктивного компонента React. Вместо обычного рендеринга компонент станет простым &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; (или другим тегом, если &lt;code&gt;mockTagName&lt;/code&gt; ), содержащим любых предоставленных дочерних элементов .</target>
        </trans-unit>
        <trans-unit id="fdde832b0e4e25e7efa528b27f908118f6bfa769" translate="yes" xml:space="preserve">
          <source>Pass a string as the &lt;code&gt;className&lt;/code&gt; prop:</source>
          <target state="translated">Передайте строку как &lt;code&gt;className&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="534c9e580a2811b44edf2a15e3bc0f460c0a7212" translate="yes" xml:space="preserve">
          <source>Pass an inline callback and an array of dependencies. &lt;code&gt;useCallback&lt;/code&gt; will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. &lt;code&gt;shouldComponentUpdate&lt;/code&gt;).</source>
          <target state="translated">Передайте встроенный обратный вызов и массив зависимостей. &lt;code&gt;useCallback&lt;/code&gt; вернет мемоизированную версию обратного вызова, которая изменяется только в случае изменения одной из зависимостей. Это полезно при передаче обратных вызовов оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных &lt;code&gt;shouldComponentUpdate&lt;/code&gt; (например, shouldComponentUpdate ).</target>
        </trans-unit>
        <trans-unit id="6b1ecfde360ca670c99a034b3467938615912d18" translate="yes" xml:space="preserve">
          <source>Pass event handlers and other functions as props to child components:</source>
          <target state="translated">Передавайте обработчики событий и другие функции в качестве реквизита к детским компонентам:</target>
        </trans-unit>
        <trans-unit id="7977cb8dad2d6673088b4722d378da8582b6ab23" translate="yes" xml:space="preserve">
          <source>Passing Arguments to Event Handlers</source>
          <target state="translated">Передача аргументов организаторам соревнований</target>
        </trans-unit>
        <trans-unit id="7731b6038ead3e4f42010f183a92cc0e8e663535" translate="yes" xml:space="preserve">
          <source>Passing Functions to Components</source>
          <target state="translated">Передача функций компонентам</target>
        </trans-unit>
        <trans-unit id="47c211ae4a2b3b47216fe468fbd82f27983e4011" translate="yes" xml:space="preserve">
          <source>Passing an update function allows you to access the current state value inside the updater. Since &lt;code&gt;setState&lt;/code&gt; calls are batched, this lets you chain updates and ensure they build on top of each other instead of conflicting:</source>
          <target state="translated">Передача функции обновления позволяет получить доступ к текущему значению состояния внутри средства обновления. Поскольку вызовы &lt;code&gt;setState&lt;/code&gt; являются пакетными , это позволяет вам связывать обновления и гарантировать, что они строятся поверх друг друга, а не конфликтуют:</target>
        </trans-unit>
        <trans-unit id="9a6194136e1fc05bb75b0051025e3237f9608a70" translate="yes" xml:space="preserve">
          <source>People come to React from different backgrounds and with different learning styles. Whether you prefer a more theoretical or a practical approach, we hope you&amp;rsquo;ll find this section helpful.</source>
          <target state="translated">Люди приходят в React с разным опытом и разными стилями обучения. Если вы предпочитаете более теоретический или практический подход, мы надеемся, что этот раздел окажется для вас полезным.</target>
        </trans-unit>
        <trans-unit id="a454c4946afe6de8abb7a71c3c543078037ceb08" translate="yes" xml:space="preserve">
          <source>Perform the actions you want to profile. Don&amp;rsquo;t record more than 20 seconds or Chrome might hang.</source>
          <target state="translated">Выполните действия, которые хотите профилировать. Не записывайте дольше 20 секунд, иначе Chrome может зависнуть.</target>
        </trans-unit>
        <trans-unit id="1456888f4e0889c6c1362473e30e3fb8f16a2193" translate="yes" xml:space="preserve">
          <source>Performance Optimizations</source>
          <target state="translated">Оптимизация производительности</target>
        </trans-unit>
        <trans-unit id="afe33e97d445c1aa01afdea12de2c8a6bf6ef536" translate="yes" xml:space="preserve">
          <source>Phew, that was fast! If some things didn&amp;rsquo;t quite make sense or you&amp;rsquo;d like to learn more in detail, you can read the next pages, starting with the &lt;a href=&quot;hooks-state&quot;&gt;State Hook&lt;/a&gt; documentation.</source>
          <target state="translated">Уф, это было быстро! Если некоторые вещи не совсем понятны или вы хотите узнать больше, вы можете прочитать следующие страницы, начиная с документации &lt;a href=&quot;hooks-state&quot;&gt;State Hook&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="649b0aad2e87bf224c37505fbd45954d6ae44866" translate="yes" xml:space="preserve">
          <source>Play a bit more with the &lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;demo&lt;/a&gt;, and try to imagine it happening.</source>
          <target state="translated">Поиграйте еще немного с &lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;демо&lt;/a&gt; и попробуйте представить, как это происходит.</target>
        </trans-unit>
        <trans-unit id="e22243b7987a499744ba5d18f9114f54c25fe1f4" translate="yes" xml:space="preserve">
          <source>Please note that browser / screen reader combinations matter. It is recommended that you test your application in the browser best suited to your screen reader of choice.</source>
          <target state="translated">Пожалуйста,обратите внимание,что важны комбинации браузер/программа для чтения с экрана.Рекомендуется протестировать ваше приложение в браузере,наиболее подходящем для выбранного вами скринридера.</target>
        </trans-unit>
        <trans-unit id="e61307201646dc8a1687dacab76a450772d3c680" translate="yes" xml:space="preserve">
          <source>Please note that the syntax above is &lt;strong&gt;experimental&lt;/strong&gt; and the syntax may change, or the proposal might not make it into the language.</source>
          <target state="translated">Обратите внимание, что приведенный выше синтаксис является &lt;strong&gt;экспериментальным,&lt;/strong&gt; и синтаксис может измениться, или предложение может не включиться в язык.</target>
        </trans-unit>
        <trans-unit id="a84c3942bb67e056a4c3f6552e902c1c6de812f7" translate="yes" xml:space="preserve">
          <source>Pointer Events</source>
          <target state="translated">Указательные события</target>
        </trans-unit>
        <trans-unit id="51c36c348e5c25ede527a987ca5d7e15ef86c339" translate="yes" xml:space="preserve">
          <source>Pointer events are not yet supported in every browser (at the time of writing this article, supported browsers include: Chrome, Firefox, Edge, and Internet Explorer). React deliberately does not polyfill support for other browsers because a standard-conform polyfill would significantly increase the bundle size of &lt;code&gt;react-dom&lt;/code&gt;.</source>
          <target state="translated">События указателя пока поддерживаются не во всех браузерах (на момент написания этой статьи поддерживаемые браузеры включают: Chrome, Firefox, Edge и Internet Explorer). React намеренно не поддерживает полифилы для других браузеров, потому что полифил, соответствующий стандарту, значительно увеличит размер пакета react &lt;code&gt;react-dom&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0c88242e813893ab8ad50b7e16808768f9baafb" translate="yes" xml:space="preserve">
          <source>Portals</source>
          <target state="translated">Portals</target>
        </trans-unit>
        <trans-unit id="4b918b44974a1664555fe8092f41a8a9c3c7132e" translate="yes" xml:space="preserve">
          <source>Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.</source>
          <target state="translated">Порталы предоставляют первоклассный способ визуализации дочерних компонентов в DOM-узел,который существует вне иерархии DOM родительского компонента.</target>
        </trans-unit>
        <trans-unit id="029998f5e0e501dc2ec70d705846fadf01f5078f" translate="yes" xml:space="preserve">
          <source>Practical Tutorial</source>
          <target state="translated">Практическое руководство</target>
        </trans-unit>
        <trans-unit id="0da325394f7b2561f269c38b5353a62787615dc5" translate="yes" xml:space="preserve">
          <source>Prefer the standard &lt;code&gt;useEffect&lt;/code&gt; when possible to avoid blocking visual updates.</source>
          <target state="translated">По возможности предпочитайте стандартный &lt;code&gt;useEffect&lt;/code&gt; , чтобы не блокировать визуальные обновления.</target>
        </trans-unit>
        <trans-unit id="87cfce24dccded60294e74f312a7bb64c4e35de4" translate="yes" xml:space="preserve">
          <source>Preferred: Pending &amp;rarr; Skeleton &amp;rarr; Complete</source>
          <target state="translated">Предпочтительно: Ожидается &amp;rarr; Скелет &amp;rarr; Завершено</target>
        </trans-unit>
        <trans-unit id="fb1323678aee55ea7816c8e30aa6f1bdb912fb64" translate="yes" xml:space="preserve">
          <source>Press &amp;ldquo;Next&amp;rdquo; a few times. Notice it already feels very different. &lt;strong&gt;Instead of immediately seeing an empty screen on click, we now keep seeing the previous page for a while.&lt;/strong&gt; When the data has loaded, React transitions us to the new screen.</source>
          <target state="translated">Несколько раз нажмите &amp;laquo;Далее&amp;raquo;. Заметьте, это уже совсем другое ощущение. &lt;strong&gt;Вместо того, чтобы сразу видеть пустой экран при щелчке, теперь мы некоторое время продолжаем видеть предыдущую страницу. &lt;/strong&gt;Когда данные загружены, React переводит нас на новый экран.</target>
        </trans-unit>
        <trans-unit id="ef2165e905ee1367c14a6f33243da7d43b8b7584" translate="yes" xml:space="preserve">
          <source>Preventing Component from Rendering</source>
          <target state="translated">Предотвращение попадания компонентов в рейд</target>
        </trans-unit>
        <trans-unit id="3efe0b4e061393bdaf49e8a579601b4bd4ce78de" translate="yes" xml:space="preserve">
          <source>Previously, React provided two ways for managing refs: the legacy string ref API and the callback API. Although the string ref API was the more convenient of the two, it had &lt;a href=&quot;https://github.com/facebook/react/issues/1373&quot;&gt;several downsides&lt;/a&gt; and so our official recommendation was to &lt;a href=&quot;refs-and-the-dom#legacy-api-string-refs&quot;&gt;use the callback form instead&lt;/a&gt;.</source>
          <target state="translated">Ранее React предоставлял два способа управления ссылками: устаревший API-интерфейс для ссылки на строку и API-интерфейс обратного вызова. Хотя API строковых ссылок был более удобным из двух, у него было &lt;a href=&quot;https://github.com/facebook/react/issues/1373&quot;&gt;несколько недостатков,&lt;/a&gt; поэтому наша официальная рекомендация заключалась в &lt;a href=&quot;refs-and-the-dom#legacy-api-string-refs&quot;&gt;том, чтобы вместо этого использовать форму обратного вызова&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f508d98b08c23e21ae8ba502e34faaa9bf61dd9" translate="yes" xml:space="preserve">
          <source>Previously, we only encountered React elements that represent DOM tags:</source>
          <target state="translated">Раньше мы встречались только с React-элементами,которые представляют DOM-теги:</target>
        </trans-unit>
        <trans-unit id="886739715565d2665d39c8366ec2d10dc344405d" translate="yes" xml:space="preserve">
          <source>Priority-based Rendering</source>
          <target state="translated">Приоритетная кредитная деятельность</target>
        </trans-unit>
        <trans-unit id="bb2e2459a0759f7d2b3b0d9811210079874a39cc" translate="yes" xml:space="preserve">
          <source>Profiler API</source>
          <target state="translated">API профайлера</target>
        </trans-unit>
        <trans-unit id="5f47591c38d90876e84e5a679c6dc16b4b65918a" translate="yes" xml:space="preserve">
          <source>Profiling Components with the Chrome Performance Tab</source>
          <target state="translated">Профилирование компонентов с помощью вкладки &quot;Хромирование&quot;.</target>
        </trans-unit>
        <trans-unit id="e9edfd9d87db8eb1b7c2fee04f3c7d3c4f51081d" translate="yes" xml:space="preserve">
          <source>Profiling Components with the DevTools Profiler</source>
          <target state="translated">Компоненты профилирования с помощью Профилировщика DevTools</target>
        </trans-unit>
        <trans-unit id="38e01723f7448dcb8aa35875d9f81ee04d125e7e" translate="yes" xml:space="preserve">
          <source>Profiling adds some additional overhead, so &lt;strong&gt;it is disabled in &lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;the production build&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">Профилирование добавляет некоторые дополнительные накладные расходы, поэтому &lt;strong&gt;в &lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;производственной сборке&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; оно отключено&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a865967da74c8436b8d176a76b2002d968e98151" translate="yes" xml:space="preserve">
          <source>Programmatically managing focus</source>
          <target state="translated">Программное управление фокусом</target>
        </trans-unit>
        <trans-unit id="86cd3058a8d5775df18dce4ea57b680ca5e164b6" translate="yes" xml:space="preserve">
          <source>Progressive Hydration</source>
          <target state="translated">Прогрессивная гидратация</target>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="351f56a6fefd5127c90506d3e91990f1d7631787" translate="yes" xml:space="preserve">
          <source>Properties:</source>
          <target state="translated">Properties:</target>
        </trans-unit>
        <trans-unit id="2187830d82c3a1f4829ffcf9703990399389ecd1" translate="yes" xml:space="preserve">
          <source>Props Default to &amp;ldquo;True&amp;rdquo;</source>
          <target state="translated">По умолчанию для реквизита установлено значение &amp;laquo;True&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="9c2d9ce6b30a5f9172862e1e2a2103f1545aae76" translate="yes" xml:space="preserve">
          <source>Props and composition give you all the flexibility you need to customize a component&amp;rsquo;s look and behavior in an explicit and safe way. Remember that components may accept arbitrary props, including primitive values, React elements, or functions.</source>
          <target state="translated">Реквизит и композиция дают вам всю гибкость, необходимую для явной и безопасной настройки внешнего вида и поведения компонента. Помните, что компоненты могут принимать произвольные свойства, включая примитивные значения, элементы React или функции.</target>
        </trans-unit>
        <trans-unit id="78feac20bb5fc62e7459d810b7135fef805d6854" translate="yes" xml:space="preserve">
          <source>Props are Read-Only</source>
          <target state="translated">Реквизит только для чтения</target>
        </trans-unit>
        <trans-unit id="b33f3c7f743fb12f6a11e786a2fcb6e13d6efcfa" translate="yes" xml:space="preserve">
          <source>Props in JSX</source>
          <target state="translated">Реквизит в JSX</target>
        </trans-unit>
        <trans-unit id="5e8dad475166c2eac08c646b3ebdf3559b8f22bb" translate="yes" xml:space="preserve">
          <source>Props vs State</source>
          <target state="translated">Реквизит против государства</target>
        </trans-unit>
        <trans-unit id="ef11665379e87b4432e89567d3144207597dde64" translate="yes" xml:space="preserve">
          <source>Provide a mechanism to allow users to skip past navigation sections in your application as this assists and speeds up keyboard navigation.</source>
          <target state="translated">Предоставьте механизм,позволяющий пользователям пропускать разделы навигации в вашем приложении,так как это облегчает и ускоряет навигацию по клавиатуре.</target>
        </trans-unit>
        <trans-unit id="65135d5ec4d5950c26be85cdc6405b0542ba4616" translate="yes" xml:space="preserve">
          <source>Putting Research into Production</source>
          <target state="translated">Внедрение исследований в производство</target>
        </trans-unit>
        <trans-unit id="4ee9c42d60235c923278d5e44bad794e0fe45c13" translate="yes" xml:space="preserve">
          <source>Quickly Try JSX</source>
          <target state="translated">Быстро попробуйте JSX</target>
        </trans-unit>
        <trans-unit id="723a59bfbd4916773b778eea25c500ba0e2055e2" translate="yes" xml:space="preserve">
          <source>Race Conditions with &lt;code&gt;componentDidUpdate&lt;/code&gt;</source>
          <target state="translated">Условия гонки с &lt;code&gt;componentDidUpdate&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
