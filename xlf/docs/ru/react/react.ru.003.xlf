<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="8ace34e863de930657650d2da4b04c7f1f377acc" translate="yes" xml:space="preserve">
          <source>Race Conditions with &lt;code&gt;useEffect&lt;/code&gt;</source>
          <target state="translated">Условия гонки с &lt;code&gt;useEffect&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c456dc6554aed5954e8c75d3fa6572cdb27a30f" translate="yes" xml:space="preserve">
          <source>Race Conditions with componentDidUpdate</source>
          <target state="translated">Условия гонки с помощью componentDidUpdate</target>
        </trans-unit>
        <trans-unit id="42274756b2dc2c17eaeb7f294f21deef9e594667" translate="yes" xml:space="preserve">
          <source>Race Conditions with useEffect</source>
          <target state="translated">Условия гонки с использованиемЭффект</target>
        </trans-unit>
        <trans-unit id="7a22b192ac2fa53d431f80c3ed1ab58049c5282b" translate="yes" xml:space="preserve">
          <source>Race conditions are bugs that happen due to incorrect assumptions about the order in which our code may run. Fetching data in the &lt;code&gt;useEffect&lt;/code&gt; Hook or in class lifecycle methods like &lt;code&gt;componentDidUpdate&lt;/code&gt; often leads to them. Suspense can help here, too &amp;mdash; let&amp;rsquo;s see how.</source>
          <target state="translated">Условия гонки - это ошибки, возникающие из-за неверных предположений о порядке, в котором может выполняться наш код. Получение данных в &lt;code&gt;useEffect&lt;/code&gt; или в методах жизненного цикла класса, таких как &lt;code&gt;componentDidUpdate&lt;/code&gt; , часто приводит к ним. Здесь тоже может помочь саспенс - посмотрим, как это сделать.</target>
        </trans-unit>
        <trans-unit id="14755c296af9379808222382bdd6b5de345159dc" translate="yes" xml:space="preserve">
          <source>Rarely Used Lifecycle Methods</source>
          <target state="translated">Редко используемые методы жизненного цикла</target>
        </trans-unit>
        <trans-unit id="26dd7fe02a64876676c6cbd9aa8708f0a20b47f9" translate="yes" xml:space="preserve">
          <source>Re-render the in-memory tree with a new root element. This simulates a React update at the root. If the new element has the same type and key as the previous element, the tree will be updated; otherwise, it will re-mount a new tree.</source>
          <target state="translated">Повторная отрисовка дерева внутренней памяти с новым корневым элементом.Это симулирует обновление React в корне.Если новый элемент имеет тот же тип и ключ,что и предыдущий,то дерево будет обновлено;в противном случае,дерево будет заново смонтировано.</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="cec80c2bc8202e23af151e7f74a7ef7ace217cd9" translate="yes" xml:space="preserve">
          <source>React 15 included a very limited support for error boundaries under a different method name: &lt;code&gt;unstable_handleError&lt;/code&gt;. This method no longer works, and you will need to change it to &lt;code&gt;componentDidCatch&lt;/code&gt; in your code starting from the first 16 beta release.</source>
          <target state="translated">React 15 включал очень ограниченную поддержку границ ошибок под другим именем метода: &lt;code&gt;unstable_handleError&lt;/code&gt; . Этот метод больше не работает, и вам нужно будет изменить его на &lt;code&gt;componentDidCatch&lt;/code&gt; в своем коде, начиная с первой бета-версии 16.</target>
        </trans-unit>
        <trans-unit id="5d738f325e7c19b6858708f27583b05cb0428fc2" translate="yes" xml:space="preserve">
          <source>React 16 depends on the collection types &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;. If you support older browsers and devices which may not yet provide these natively (e.g. IE &amp;lt; 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">React 16 зависит от типов коллекции &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt; . Если вы поддерживаете старые браузеры и устройства, которые могут еще не предоставлять их изначально (например, IE &amp;lt;11) или которые имеют несовместимые реализации (например, IE 11), рассмотрите возможность включения глобального полифилла в ваше связанное приложение, например &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; или &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel -полифил&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74986fa4e985ed82adb453f97ce762c40df9fea1" translate="yes" xml:space="preserve">
          <source>React 16 depends on the collection types &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;. If you support older browsers and devices which may not yet provide these natively (e.g. IE &amp;lt; 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1051bec19cd5874a397897a7f06cc6437c451c36" translate="yes" xml:space="preserve">
          <source>React 16 prints all errors that occurred during rendering to the console in development, even if the application accidentally swallows them. In addition to the error message and the JavaScript stack, it also provides component stack traces. Now you can see where exactly in the component tree the failure has happened:</source>
          <target state="translated">Реакция 16 выводит на печать все ошибки,которые возникли во время рендеринга в консоль при разработке,даже если приложение случайно их проглотило.Кроме сообщения об ошибке и стека JavaScript,он также предоставляет трассировку стека компонентов.Теперь можно увидеть,где именно в дереве компонентов произошел сбой:</target>
        </trans-unit>
        <trans-unit id="30e0407bcbcc67abd7c79d5c3bd2fcd47ad42dd9" translate="yes" xml:space="preserve">
          <source>React 16.3 added a third option that offers the convenience of a string ref without any of the downsides:</source>
          <target state="translated">В п.16.3 добавлена третья опция,обеспечивающая удобство работы со ссылкой на строку без каких-либо недостатков:</target>
        </trans-unit>
        <trans-unit id="3c32dfc45304c45a68c84f0c0ee4c4f05460c24f" translate="yes" xml:space="preserve">
          <source>React 16.6 added a &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; component that lets you &amp;ldquo;wait&amp;rdquo; for some code to load and declaratively specify a loading state (like a spinner) while we&amp;rsquo;re waiting:</source>
          <target state="translated">В React 16.6 добавлен компонент &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; , который позволяет вам &amp;laquo;ждать&amp;raquo; загрузки некоторого кода и декларативно указывать состояние загрузки (например, счетчик), пока мы ждем:</target>
        </trans-unit>
        <trans-unit id="b645cea94d9f5a02a027aeb84445527c67977cf7" translate="yes" xml:space="preserve">
          <source>React 16.8.0 is the first release to support Hooks. When upgrading, don&amp;rsquo;t forget to update all packages, including React DOM. React Native supports Hooks since &lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;the 0.59 release of React Native&lt;/a&gt;.</source>
          <target state="translated">React 16.8.0 - первый выпуск, поддерживающий хуки. При обновлении не забудьте обновить все пакеты, включая React DOM. React Native поддерживает хуки с &lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;момента выхода React Native 0.59&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e30a4592694f3d8efb2c8c6a713f826f50e4e4ee" translate="yes" xml:space="preserve">
          <source>React 16.8.0 is the first release to support Hooks. When upgrading, don&amp;rsquo;t forget to update all packages, including React DOM. React Native supports Hooks since &lt;a href=&quot;https://reactnative.dev/blog/2019/03/12/releasing-react-native-059&quot;&gt;the 0.59 release of React Native&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb6d1eb7c6bbf9522f3b769efa0699d62f423a0" translate="yes" xml:space="preserve">
          <source>React 17 on the web &lt;strong&gt;does not&lt;/strong&gt; use event pooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2fa57c98aa2ff66a34e3804ba4afdbf43f949c" translate="yes" xml:space="preserve">
          <source>React &lt;a href=&quot;react-without-jsx&quot;&gt;doesn&amp;rsquo;t require&lt;/a&gt; using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</source>
          <target state="translated">React &lt;a href=&quot;react-without-jsx&quot;&gt;не требует&lt;/a&gt; использования JSX, но большинство людей считают его полезным в качестве наглядного пособия при работе с пользовательским интерфейсом внутри кода JavaScript. Это также позволяет React отображать более полезные сообщения об ошибках и предупреждения.</target>
        </trans-unit>
        <trans-unit id="e56b4ec7d4044adf40d8ea846a837d5e5d0e2ec1" translate="yes" xml:space="preserve">
          <source>React DOM</source>
          <target state="translated">Реакция МЗУ</target>
        </trans-unit>
        <trans-unit id="0e17312bf427154aa9521cc18565e992f954d046" translate="yes" xml:space="preserve">
          <source>React DOM Server</source>
          <target state="translated">Реактивный сервер DOM</target>
        </trans-unit>
        <trans-unit id="6783695eda495767c874d2c12b708f12b9eb5c68" translate="yes" xml:space="preserve">
          <source>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</source>
          <target state="translated">React DOM сравнивает элемент и его детей с предыдущим и применяет только обновления,необходимые для приведения флэш-накопителя в желаемое состояние.</target>
        </trans-unit>
        <trans-unit id="c0f543b7e06f16286089bf4be437499e1b43b727" translate="yes" xml:space="preserve">
          <source>React DOM efficiently updates the DOM to match &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">React DOM эффективно обновляет DOM в соответствии с &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fdeb7ff15e5768ee7e11ab66cd7913eac488847" translate="yes" xml:space="preserve">
          <source>React DOM updates the DOM with the boiling verdict and to match the desired input values. The input we just edited receives its current value, and the other input is updated to the temperature after conversion.</source>
          <target state="translated">Реакция DOM обновляет DOM с вердиктом кипения и для соответствия желаемым входным значениям.Только что отредактированный вход получает свое текущее значение,а другой вход после преобразования обновляется до температуры.</target>
        </trans-unit>
        <trans-unit id="1b3e9e3b704e86ac0ae2261ed5ae0110bb475463" translate="yes" xml:space="preserve">
          <source>React DOM uses camelCase property naming convention instead of HTML attribute names. For example, &lt;code&gt;tabindex&lt;/code&gt; becomes &lt;code&gt;tabIndex&lt;/code&gt; in JSX. The attribute &lt;code&gt;class&lt;/code&gt; is also written as &lt;code&gt;className&lt;/code&gt; since &lt;code&gt;class&lt;/code&gt; is a reserved word in JavaScript:</source>
          <target state="translated">React DOM использует соглашение об именах свойств camelCase вместо имен атрибутов HTML. Например, &lt;code&gt;tabindex&lt;/code&gt; становится &lt;code&gt;tabIndex&lt;/code&gt; в JSX. Атрибут &lt;code&gt;class&lt;/code&gt; также записывается как &lt;code&gt;className&lt;/code&gt; , поскольку &lt;code&gt;class&lt;/code&gt; - зарезервированное слово в JavaScript:</target>
        </trans-unit>
        <trans-unit id="64f7152b69ea8b7e6f11fc24d5c27c7549c6acd1" translate="yes" xml:space="preserve">
          <source>React Documentation</source>
          <target state="translated">Реакционная документация</target>
        </trans-unit>
        <trans-unit id="3a01dc41ed1fa68614175afe8e165764d9609ab0" translate="yes" xml:space="preserve">
          <source>React Must Be in Scope</source>
          <target state="translated">Реакция должна быть в сфере действия</target>
        </trans-unit>
        <trans-unit id="ee67e7a559cad7f7f0016ea4240d3102eab0e39c" translate="yes" xml:space="preserve">
          <source>React Native</source>
          <target state="translated">Реакция Коренной</target>
        </trans-unit>
        <trans-unit id="a2c6dfc0e1dfdf3f794b802a1ba06278b93a1b13" translate="yes" xml:space="preserve">
          <source>React Only Updates What&amp;rsquo;s Necessary</source>
          <target state="translated">React Only Updates Что необходимо</target>
        </trans-unit>
        <trans-unit id="3633a811906ebb40f86bdd77c315e1e2bde36321" translate="yes" xml:space="preserve">
          <source>React Redux since v7.1.0 &lt;a href=&quot;https://react-redux.js.org/api/hooks&quot;&gt;supports Hooks API&lt;/a&gt; and exposes hooks like &lt;code&gt;useDispatch&lt;/code&gt; or &lt;code&gt;useSelector&lt;/code&gt;.</source>
          <target state="translated">React Redux, начиная с версии 7.1.0, &lt;a href=&quot;https://react-redux.js.org/api/hooks&quot;&gt;поддерживает Hooks API&lt;/a&gt; и предоставляет такие хуки, как &lt;code&gt;useDispatch&lt;/code&gt; или &lt;code&gt;useSelector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bb3fe34bf0fbac0db48c2c52246f7bf4643b58d" translate="yes" xml:space="preserve">
          <source>React Router &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Hooks&quot;&gt;supports hooks&lt;/a&gt; since v5.1.</source>
          <target state="translated">React Router &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Hooks&quot;&gt;поддерживает хуки&lt;/a&gt; начиная с версии 5.1.</target>
        </trans-unit>
        <trans-unit id="db30dab9afce5ee17ad60f6815d45c7d2775403c" translate="yes" xml:space="preserve">
          <source>React Shallow Renderer</source>
          <target state="translated">Реакция неглубокий рендерер</target>
        </trans-unit>
        <trans-unit id="59f752bd2488cbb706a191bae6c25ec360c9ae78" translate="yes" xml:space="preserve">
          <source>React Test Renderer</source>
          <target state="translated">Ремонтник реакционных испытаний</target>
        </trans-unit>
        <trans-unit id="493a1a450ae702c6d46a164382378d365c88d431" translate="yes" xml:space="preserve">
          <source>React Testing Library offers a &lt;a href=&quot;https://testing-library.com/docs/dom-testing-library/api-events&quot;&gt;more concise helper&lt;/a&gt; for firing events.</source>
          <target state="translated">Библиотека тестирования React предлагает &lt;a href=&quot;https://testing-library.com/docs/dom-testing-library/api-events&quot;&gt;более лаконичный помощник&lt;/a&gt; для запуска событий.</target>
        </trans-unit>
        <trans-unit id="a3a37522e503e9a2cee5bb38180398e2a23e1f1f" translate="yes" xml:space="preserve">
          <source>React Top-Level API</source>
          <target state="translated">Реакционный API верхнего уровня</target>
        </trans-unit>
        <trans-unit id="8e60d7618dece37120d3987205a0d2168962460f" translate="yes" xml:space="preserve">
          <source>React Without ES6</source>
          <target state="translated">Реагировать без ES6</target>
        </trans-unit>
        <trans-unit id="cd5884fb1f8e40d0ef6cbe86d6584a46690762e1" translate="yes" xml:space="preserve">
          <source>React Without JSX</source>
          <target state="translated">Реагировать без JSX</target>
        </trans-unit>
        <trans-unit id="9fe2f9ba8b44464b4bfefd199f9bc13307ee3332" translate="yes" xml:space="preserve">
          <source>React also depends on &lt;code&gt;requestAnimationFrame&lt;/code&gt; (even in test environments).</source>
          <target state="translated">React также зависит от &lt;code&gt;requestAnimationFrame&lt;/code&gt; (даже в тестовых средах).</target>
        </trans-unit>
        <trans-unit id="7d8f2b9666834dcad7e288b25fd8480664eaad61" translate="yes" xml:space="preserve">
          <source>React also supports another way to set refs called &amp;ldquo;callback refs&amp;rdquo;, which gives more fine-grain control over when refs are set and unset.</source>
          <target state="translated">React также поддерживает другой способ установки ссылок, называемый &amp;laquo;callback refs&amp;raquo;, который дает более точный контроль над тем, когда ссылки устанавливаются и не устанавливаются.</target>
        </trans-unit>
        <trans-unit id="10225c998465dfe979466a99502e0be87e759457" translate="yes" xml:space="preserve">
          <source>React and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components&quot;&gt;Web Components&lt;/a&gt; are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data. The two goals are complementary. As a developer, you are free to use React in your Web Components, or to use Web Components in React, or both.</source>
          <target state="translated">React и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components&quot;&gt;веб-компоненты&lt;/a&gt; созданы для решения разных задач. Веб-компоненты обеспечивают надежную инкапсуляцию для многократно используемых компонентов, а React предоставляет декларативную библиотеку, которая поддерживает синхронизацию DOM с вашими данными. Эти две цели дополняют друг друга. Как разработчик, вы можете свободно использовать React в своих веб-компонентах или использовать веб-компоненты в React, или и то, и другое.</target>
        </trans-unit>
        <trans-unit id="27082daf4244e21a91a723f26657721dc905d29e" translate="yes" xml:space="preserve">
          <source>React builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components. This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects. Sometimes it is referred to as a &amp;ldquo;virtual DOM&amp;rdquo;, but it works the same way on React Native.</source>
          <target state="translated">React создает и поддерживает внутреннее представление визуализированного пользовательского интерфейса. Он включает элементы React, которые вы возвращаете из своих компонентов. Такое представление позволяет React избегать создания узлов DOM и доступа к существующим без необходимости, поскольку это может быть медленнее, чем операции с объектами JavaScript. Иногда его называют &amp;laquo;виртуальным DOM&amp;raquo;, но в React Native он работает точно так же.</target>
        </trans-unit>
        <trans-unit id="610b64665a6a2f5e728c19e6eca03a8b39cdcf07" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;Calculator&lt;/code&gt; component&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method to learn what the UI should look like. The values of both inputs are recomputed based on the current temperature and the active scale. The temperature conversion is performed here.</source>
          <target state="translated">React вызывает метод &lt;code&gt;render&lt;/code&gt; компонента &lt;code&gt;Calculator&lt;/code&gt; , чтобы узнать, как должен выглядеть пользовательский интерфейс. Значения обоих входов пересчитываются на основе текущей температуры и активной шкалы. Здесь выполняется преобразование температуры.</target>
        </trans-unit>
        <trans-unit id="ba853d2a17e24f0bd22d89450b9557d4a2c11971" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;Welcome&lt;/code&gt; component with &lt;code&gt;{name: 'Sara'}&lt;/code&gt; as the props.</source>
          <target state="translated">React вызывает компонент &lt;code&gt;Welcome&lt;/code&gt; с &lt;code&gt;{name: 'Sara'}&lt;/code&gt; в качестве реквизита.</target>
        </trans-unit>
        <trans-unit id="d6f2ebfc937521d2470061f7e3d9cde73833393e" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;render&lt;/code&gt; method of the &lt;code&gt;BoilingVerdict&lt;/code&gt; component, passing the temperature in Celsius as its props.</source>
          <target state="translated">React вызовов &lt;code&gt;render&lt;/code&gt; метод &lt;code&gt;BoilingVerdict&lt;/code&gt; компоненты, проходя температуру в градусах Цельсия , как его реквизит.</target>
        </trans-unit>
        <trans-unit id="f3922365ae8f20c0cd2b94600d6dd96e8199f37c" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;render&lt;/code&gt; methods of the individual &lt;code&gt;TemperatureInput&lt;/code&gt; components with their new props specified by the &lt;code&gt;Calculator&lt;/code&gt;. It learns what their UI should look like.</source>
          <target state="translated">React вызывает методы &lt;code&gt;render&lt;/code&gt; отдельных компонентов &lt;code&gt;TemperatureInput&lt;/code&gt; с их новыми свойствами, указанными &lt;code&gt;Calculator&lt;/code&gt; . Он узнает, как должен выглядеть их пользовательский интерфейс.</target>
        </trans-unit>
        <trans-unit id="36fdfacce7eedd6661f907c10f0f4ea9af876fce" translate="yes" xml:space="preserve">
          <source>React calls the function specified as &lt;code&gt;onChange&lt;/code&gt; on the DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. In our case, this is the &lt;code&gt;handleChange&lt;/code&gt; method in the &lt;code&gt;TemperatureInput&lt;/code&gt; component.</source>
          <target state="translated">React вызывает функцию, указанную как &lt;code&gt;onChange&lt;/code&gt; в DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; . В нашем случае это метод &lt;code&gt;handleChange&lt;/code&gt; в компоненте &lt;code&gt;TemperatureInput&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd8b2d2111896cb2314cfe1f0bde6a55efe40119" translate="yes" xml:space="preserve">
          <source>React can be embedded into other applications thanks to the flexibility of &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">React может быть встроен в другие приложения благодаря гибкости &lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1330ed30fca80f90b213d9b6f69f3e0df6ecab7" translate="yes" xml:space="preserve">
          <source>React can be used in any web application. It can be embedded in other applications and, with a little care, other applications can be embedded in React. This guide will examine some of the more common use cases, focusing on integration with &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; and &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt;, but the same ideas can be applied to integrating components with any existing code.</source>
          <target state="translated">React можно использовать в любом веб-приложении. Он может быть встроен в другие приложения, и, при некоторой осторожности, другие приложения можно встроить в React. В этом руководстве будут рассмотрены некоторые из наиболее распространенных вариантов использования с упором на интеграцию с &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; и &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt; , но те же идеи могут быть применены к интеграции компонентов с любым существующим кодом.</target>
        </trans-unit>
        <trans-unit id="d37e463c6f9b2a55b2880cfa9eafdf5e114306ed" translate="yes" xml:space="preserve">
          <source>React can be used to power animations. See &lt;a href=&quot;https://reactcommunity.org/react-transition-group/&quot;&gt;React Transition Group&lt;/a&gt; and &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;React Motion&lt;/a&gt; or &lt;a href=&quot;https://github.com/react-spring/react-spring&quot;&gt;React Spring&lt;/a&gt;, for example.</source>
          <target state="translated">React можно использовать для создания анимации. См., Например, &lt;a href=&quot;https://reactcommunity.org/react-transition-group/&quot;&gt;React Transition Group&lt;/a&gt; и &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;React Motion&lt;/a&gt; или &lt;a href=&quot;https://github.com/react-spring/react-spring&quot;&gt;React Spring&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c793e68bb1fac249aba0ce5f3bec7e5d7023c434" translate="yes" xml:space="preserve">
          <source>React community&amp;rsquo;s experiments with render prop APIs, including &lt;a href=&quot;https://github.com/ryanflorence&quot;&gt;Ryan Florence&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/reactions/component&quot;&gt;Reactions Component&lt;/a&gt;.</source>
          <target state="translated">Реагировать эксперименты сообщества с опорой делают API, в том числе &lt;a href=&quot;https://github.com/ryanflorence&quot;&gt;Райан Флоренс&lt;/a&gt; &amp;laquo;s &lt;a href=&quot;https://github.com/reactions/component&quot;&gt;реакций компонентов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27be082454b7d8bc7b1e13ab663caeb1f2c60981" translate="yes" xml:space="preserve">
          <source>React components are small, reusable pieces of code that return a React element to be rendered to the page. The simplest version of React component is a plain JavaScript function that returns a React element:</source>
          <target state="translated">Реактивные компоненты-это маленькие,многократно используемые фрагменты кода,которые возвращают элемент React,который будет отображен на странице.Самая простая версия React-компонента-простая JavaScript-функция,которая возвращает React-элемент:</target>
        </trans-unit>
        <trans-unit id="48861e38df56656ab830494ad258a4d6191d07f5" translate="yes" xml:space="preserve">
          <source>React components can also be defined as functions which can be wrapped:</source>
          <target state="translated">Реактивные компоненты также могут быть определены как функции,которые могут быть завернуты:</target>
        </trans-unit>
        <trans-unit id="e4cc5817b2558aba649764feaed76c372dd8b626" translate="yes" xml:space="preserve">
          <source>React components have their own &amp;ldquo;lifecycle&amp;rdquo;. They may receive props or update state at any point in time. However, each asynchronous request &lt;em&gt;also&lt;/em&gt; has its own &amp;ldquo;lifecycle&amp;rdquo;. It starts when we kick it off, and finishes when we get a response. The difficulty we&amp;rsquo;re experiencing is &amp;ldquo;synchronizing&amp;rdquo; several processes in time that affect each other. This is hard to think about.</source>
          <target state="translated">Компоненты React имеют собственный &amp;laquo;жизненный цикл&amp;raquo;. Они могут получать реквизиты или обновлять состояние в любой момент. Однако у каждого асинхронного запроса &lt;em&gt;также&lt;/em&gt; есть свой &amp;laquo;жизненный цикл&amp;raquo;. Он начинается, когда мы начинаем, и заканчивается, когда мы получаем ответ. Сложность, с которой мы сталкиваемся, заключается в &amp;laquo;синхронизации&amp;raquo; во времени нескольких процессов, влияющих друг на друга. Об этом сложно думать.</target>
        </trans-unit>
        <trans-unit id="4222b5a8657725e4a00728011e55a70511e28796" translate="yes" xml:space="preserve">
          <source>React components hide their implementation details, including their rendered output. Other components using &lt;code&gt;FancyButton&lt;/code&gt;&lt;strong&gt;usually will not need to&lt;/strong&gt;&lt;a href=&quot;refs-and-the-dom&quot;&gt;obtain a ref&lt;/a&gt; to the inner &lt;code&gt;button&lt;/code&gt; DOM element. This is good because it prevents components from relying on each other&amp;rsquo;s DOM structure too much.</source>
          <target state="translated">Компоненты React скрывают детали своей реализации, включая визуализированный результат. Другим компонентам, использующим &lt;code&gt;FancyButton&lt;/code&gt; ,&lt;strong&gt;обычно не требуется &lt;/strong&gt;&lt;a href=&quot;refs-and-the-dom&quot;&gt;получать &lt;/a&gt;ссылку на DOM-элемент внутренней &lt;code&gt;button&lt;/code&gt; . Это хорошо, потому что не позволяет компонентам слишком сильно полагаться на структуру DOM друг друга.</target>
        </trans-unit>
        <trans-unit id="5817ef7548b0234e3521fa7650bb8ea6c27ada2e" translate="yes" xml:space="preserve">
          <source>React components let you split the UI into independent, reusable pieces, and think about each piece in isolation. React components can be defined by subclassing &lt;code&gt;React.Component&lt;/code&gt; or &lt;code&gt;React.PureComponent&lt;/code&gt;.</source>
          <target state="translated">Компоненты React позволяют разделить пользовательский интерфейс на независимые, повторно используемые части и рассматривать каждую часть отдельно. Компоненты React могут быть определены путем &lt;code&gt;React.Component&lt;/code&gt; подклассов React.Component или &lt;code&gt;React.PureComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca8d82c06b82b483efb7cfed08df669ddf86929f" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t call &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; with initial props during &lt;a href=&quot;#mounting&quot;&gt;mounting&lt;/a&gt;. It only calls this method if some of component&amp;rsquo;s props may update. Calling &lt;code&gt;this.setState()&lt;/code&gt; generally doesn&amp;rsquo;t trigger &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt;.</source>
          <target state="translated">React не вызывает &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; с начальными реквизитами во время &lt;a href=&quot;#mounting&quot;&gt;монтирования&lt;/a&gt; . Он вызывает этот метод только в том случае, если некоторые свойства компонента могут обновляться. Вызов &lt;code&gt;this.setState()&lt;/code&gt; обычно не вызывает &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca31c5026bd08138666663526caeedbe15b5ea02" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t force you to use the ES6 class syntax. If you prefer to avoid it, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module or a similar custom abstraction instead. Take a look at &lt;a href=&quot;react-without-es6&quot;&gt;Using React without ES6&lt;/a&gt; to learn more.</source>
          <target state="translated">React не заставляет вас использовать синтаксис класса ES6. Если вы предпочитаете избегать этого, вы можете использовать вместо него модуль &lt;code&gt;create-react-class&lt;/code&gt; или аналогичную настраиваемую абстракцию. Взгляните на &lt;a href=&quot;react-without-es6&quot;&gt;Использование React без ES6,&lt;/a&gt; чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="74b56919404ce18c573bf25676a77e3c0c3ec215" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t have opinions on how you put files into folders. That said there are a few common approaches popular in the ecosystem you may want to consider.</source>
          <target state="translated">React не имеет мнения о том, как размещать файлы в папках. Тем не менее, есть несколько распространенных подходов, популярных в экосистеме, которые вы, возможно, захотите рассмотреть.</target>
        </trans-unit>
        <trans-unit id="65aea3f2a5c31b29c9426cd1a03d900e3079061c" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle methods, the event handlers don&amp;rsquo;t happen during rendering. So if they throw, React still knows what to display on the screen.</source>
          <target state="translated">React не требует границ ошибок для восстановления после ошибок в обработчиках событий. В отличие от метода рендеринга и методов жизненного цикла, обработчики событий не выполняются во время рендеринга. Так что, если они бросят, React все равно знает, что отображать на экране.</target>
        </trans-unit>
        <trans-unit id="8fd4db2f190bce0d1cd19887d508e28c6fb7d62f" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t offer a way to &amp;ldquo;attach&amp;rdquo; reusable behavior to a component (for example, connecting it to a store). If you&amp;rsquo;ve worked with React for a while, you may be familiar with patterns like &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; and &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; that try to solve this. But these patterns require you to restructure your components when you use them, which can be cumbersome and make code harder to follow. If you look at a typical React application in React DevTools, you will likely find a &amp;ldquo;wrapper hell&amp;rdquo; of components surrounded by layers of providers, consumers, higher-order components, render props, and other abstractions. While we could &lt;a href=&quot;https://github.com/facebook/react-devtools/pull/503&quot;&gt;filter them out in DevTools&lt;/a&gt;, this points to a deeper underlying problem: React needs a better primitive for sharing stateful logic.</source>
          <target state="translated">React не предлагает способ &amp;laquo;прикрепить&amp;raquo; повторно используемое поведение к компоненту (например, подключить его к магазину). Если вы какое-то время работали с React, возможно, вы знакомы с такими шаблонами, как &lt;a href=&quot;render-props&quot;&gt;рендеринг реквизита&lt;/a&gt; и &lt;a href=&quot;higher-order-components&quot;&gt;компоненты более высокого порядка,&lt;/a&gt; которые пытаются решить эту проблему. Но эти шаблоны требуют от вас реструктуризации компонентов при их использовании, что может быть громоздким и усложнять выполнение кода. Если вы посмотрите на типичное приложение React в React DevTools, вы, вероятно, найдете &amp;laquo;ад-оболочку&amp;raquo; из компонентов, окруженных уровнями поставщиков, потребителей, компонентов более высокого порядка, реквизитов рендеринга и других абстракций. Хотя мы могли бы &lt;a href=&quot;https://github.com/facebook/react-devtools/pull/503&quot;&gt;отфильтровать их в DevTools&lt;/a&gt; , это указывает на более глубокую проблему: React нужен лучший примитив для обмена логикой с отслеживанием состояния.</target>
        </trans-unit>
        <trans-unit id="f78ca1328cbe2529b63f5cb261c75fa5b40138a1" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t use the &lt;code&gt;state = initialState&lt;/code&gt; argument convention popularized by Redux. The initial value sometimes needs to depend on props and so is specified from the Hook call instead. If you feel strongly about this, you can call &lt;code&gt;useReducer(reducer, undefined, reducer)&lt;/code&gt; to emulate the Redux behavior, but it&amp;rsquo;s not encouraged.</source>
          <target state="translated">React не использует &lt;code&gt;state = initialState&lt;/code&gt; аргументах state = initialState, популяризированное Redux. Начальное значение иногда должно зависеть от props и поэтому вместо этого указывается в вызове Hook. Если вас это сильно &lt;code&gt;useReducer(reducer, undefined, reducer)&lt;/code&gt; , вы можете вызвать useReducer (reducer, undefined, reducer) для эмуляции поведения Redux, но это не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="d83294fcb3556b3e4c12f42b28d13fbaa61565e3" translate="yes" xml:space="preserve">
          <source>React elements are &lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;immutable&lt;/a&gt;. Once you create an element, you can&amp;rsquo;t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</source>
          <target state="translated">Элементы React &lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;неизменны&lt;/a&gt; . После создания элемента вы не можете изменить его дочерние элементы или атрибуты. Элемент похож на один кадр в фильме: он представляет пользовательский интерфейс в определенный момент времени.</target>
        </trans-unit>
        <trans-unit id="72d7e53a8e0f9d5ea79b7f65c786e10e05c2fc30" translate="yes" xml:space="preserve">
          <source>React elements are the building blocks of React applications. One might confuse elements with a more widely known concept of &amp;ldquo;components&amp;rdquo;. An element describes what you want to see on the screen. React elements are immutable.</source>
          <target state="translated">Элементы React - это строительные блоки приложений React. Можно спутать элементы с более широко известным понятием &amp;laquo;компоненты&amp;raquo;. Элемент описывает то, что вы хотите видеть на экране. Элементы React неизменны.</target>
        </trans-unit>
        <trans-unit id="6524f58f9d8f8ab1fca2ad781736505d87a9d6ca" translate="yes" xml:space="preserve">
          <source>React elements like &lt;code&gt;&amp;lt;Contacts /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Chat /&amp;gt;&lt;/code&gt; are just objects, so you can pass them as props like any other data. This approach may remind you of &amp;ldquo;slots&amp;rdquo; in other libraries but there are no limitations on what you can pass as props in React.</source>
          <target state="translated">Элементы React, такие как &lt;code&gt;&amp;lt;Contacts /&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;Chat /&amp;gt;&lt;/code&gt; , являются просто объектами, поэтому вы можете передавать их как реквизиты, как и любые другие данные. Этот подход может напоминать вам &amp;laquo;слоты&amp;raquo; в других библиотеках, но нет никаких ограничений на то, что вы можете передать в качестве реквизита в React.</target>
        </trans-unit>
        <trans-unit id="d783a77ced1d87ae35cd28616b7b8dde4c0feec8" translate="yes" xml:space="preserve">
          <source>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.</source>
          <target state="translated">Реакция включает в себя тот факт,что логика рендеринга неразрывно связана с другой логикой пользовательского интерфейса:как обрабатываются события,как меняется состояние с течением времени и как данные подготавливаются к отображению.</target>
        </trans-unit>
        <trans-unit id="71aa7bf3c2141f944fb5d607ee0a640c055cd5e3" translate="yes" xml:space="preserve">
          <source>React event handlers are named using camelCase, rather than lowercase.</source>
          <target state="translated">Обработчики реактивных событий именуются с помощью верблюжьего кейса,а не с помощью нижнего регистра.</target>
        </trans-unit>
        <trans-unit id="aaaede23e33f54df8554d19c52716021dc6d0ad7" translate="yes" xml:space="preserve">
          <source>React events are named using camelCase, rather than lowercase.</source>
          <target state="translated">Реакционные события называются с помощью верблюжьего кейса,а не в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="d81cbd9c023137339681f3ecb86a4870cf58d1f3" translate="yes" xml:space="preserve">
          <source>React events will be grouped under the &lt;strong&gt;User Timing&lt;/strong&gt; label.</source>
          <target state="translated">События React будут сгруппированы под меткой &lt;strong&gt;User Timing&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9a9f448560435e23fa1b8b20e5ca27d1ae3d080b" translate="yes" xml:space="preserve">
          <source>React expects that the rendered content is identical between the server and the client. It can patch up differences in text content, but you should treat mismatches as bugs and fix them. In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.</source>
          <target state="translated">Реагируйте,ожидая,что отображенный контент будет идентичен между сервером и клиентом.Он может исправить различия в текстовом содержимом,но вы должны трактовать несовпадения как ошибки и исправлять их.В режиме разработки React предупреждает о несовпадениях при гидратации.Нет никаких гарантий,что различия в атрибутах будут исправлены в случае несовпадения.Это важно для производительности,так как в большинстве приложений несоответствия встречаются редко,и поэтому проверка всей разметки была бы непомерно дорогой.</target>
        </trans-unit>
        <trans-unit id="688c4519446fdd44f425e4ac67a8e7c31b228818" translate="yes" xml:space="preserve">
          <source>React follows &lt;a href=&quot;https://semver.org/&quot;&gt;semantic versioning (semver)&lt;/a&gt; principles.</source>
          <target state="translated">React следует принципам &lt;a href=&quot;https://semver.org/&quot;&gt;семантического управления версиями (semver)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ace8a8f59843973f666f085ceaf962fea60d36e" translate="yes" xml:space="preserve">
          <source>React for Beginners</source>
          <target state="translated">Реакция для начинающих</target>
        </trans-unit>
        <trans-unit id="0c447ed07bb40a48e19866c8e49bff0aaf61e27b" translate="yes" xml:space="preserve">
          <source>React for Designers</source>
          <target state="translated">Реакция для дизайнеров</target>
        </trans-unit>
        <trans-unit id="a3064a3146d7f8947ad21494bc1745e87bfe69d8" translate="yes" xml:space="preserve">
          <source>React fully supports building accessible websites, often by using standard HTML techniques.</source>
          <target state="translated">React полностью поддерживает создание доступных веб-сайтов,часто с использованием стандартных методов HTML.</target>
        </trans-unit>
        <trans-unit id="0931dcf2a1d7800c25ee9a956b9c2839a169eadd" translate="yes" xml:space="preserve">
          <source>React guarantees that &lt;code&gt;dispatch&lt;/code&gt; function identity is stable and won&amp;rsquo;t change on re-renders. This is why it&amp;rsquo;s safe to omit from the &lt;code&gt;useEffect&lt;/code&gt; or &lt;code&gt;useCallback&lt;/code&gt; dependency list.</source>
          <target state="translated">React гарантирует, что идентификатор функции &lt;code&gt;dispatch&lt;/code&gt; стабилен и не изменится при повторном рендеринге. Вот почему безопасно исключить из &lt;code&gt;useEffect&lt;/code&gt; зависимостей useEffect или &lt;code&gt;useCallback&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="760079d64e4b1bb1d3f5af076b4f911126e07d29" translate="yes" xml:space="preserve">
          <source>React guarantees that &lt;code&gt;setState&lt;/code&gt; function identity is stable and won&amp;rsquo;t change on re-renders. This is why it&amp;rsquo;s safe to omit from the &lt;code&gt;useEffect&lt;/code&gt; or &lt;code&gt;useCallback&lt;/code&gt; dependency list.</source>
          <target state="translated">React гарантирует, что &lt;code&gt;setState&lt;/code&gt; функции setState стабилен и не изменится при повторном рендеринге. Вот почему безопасно исключить из &lt;code&gt;useEffect&lt;/code&gt; зависимостей useEffect или &lt;code&gt;useCallback&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c2ef58675954a462a2178998aa8077eb12b98d" translate="yes" xml:space="preserve">
          <source>React guarantees that whenever we look at these components on the screen, they will reflect data from the same &lt;code&gt;user&lt;/code&gt;. If a different &lt;code&gt;user&lt;/code&gt; is passed down because of a state update, you would see them changing together. You can&amp;rsquo;t ever record a screen and find a frame where they would show values from different &lt;code&gt;user&lt;/code&gt;s. (If you ever run into a case like this, file a bug!)</source>
          <target state="translated">React гарантирует, что всякий раз, когда мы смотрим на эти компоненты на экране, они будут отражать данные одного и того же &lt;code&gt;user&lt;/code&gt; . Если из-за обновления состояния будет передан другой &lt;code&gt;user&lt;/code&gt; , вы увидите, что они меняются вместе. Вы никогда не сможете записать экран и найти кадр, в котором бы отображались значения от разных &lt;code&gt;user&lt;/code&gt; . (Если вы когда-нибудь столкнетесь с подобным случаем, сообщите об ошибке!)</target>
        </trans-unit>
        <trans-unit id="cdc83e6519b0f0d8e4abbcdc04e6a6bc27050c9d" translate="yes" xml:space="preserve">
          <source>React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.</source>
          <target state="translated">Реакция имеет мощную модель состава,и мы рекомендуем использовать состав вместо наследования для повторного использования кода между компонентами.</target>
        </trans-unit>
        <trans-unit id="df3b73a4c521d8e8577e5382082dcb38c98839b5" translate="yes" xml:space="preserve">
          <source>React has always provided a JavaScript-centric API to the DOM. Since React components often take both custom and DOM-related props, React uses the &lt;code&gt;camelCase&lt;/code&gt; convention just like the DOM APIs:</source>
          <target state="translated">React всегда предоставлял API для DOM, ориентированный на JavaScript. Поскольку компоненты React часто используют как пользовательские, так и связанные с DOM &lt;code&gt;camelCase&lt;/code&gt; , React использует соглашение camelCase точно так же, как DOM API:</target>
        </trans-unit>
        <trans-unit id="6034f047f205ffc8dc240f7e19af8c137e1310ea" translate="yes" xml:space="preserve">
          <source>React has an API to update context, but it is fundamentally broken and you should not use it.</source>
          <target state="translated">React имеет API для обновления контекста,но он в корне сломан,и вы не должны его использовать.</target>
        </trans-unit>
        <trans-unit id="01b02eb95334a25e55e537194d6a183abb3dc8f6" translate="yes" xml:space="preserve">
          <source>React has been designed from the start for gradual adoption, and &lt;strong&gt;you can use as little or as much React as you need.&lt;/strong&gt; Whether you want to get a taste of React, add some interactivity to a simple HTML page, or start a complex React-powered app, the links in this section will help you get started.</source>
          <target state="translated">React был разработан с самого начала для постепенного внедрения, и &lt;strong&gt;вы можете использовать столько или меньше React, сколько вам нужно. &lt;/strong&gt;Если вы хотите попробовать React, добавить интерактивности к простой HTML-странице или запустить сложное приложение на основе React, ссылки в этом разделе помогут вам начать работу.</target>
        </trans-unit>
        <trans-unit id="c050def493e7cae09b97f99b2e48a3bc9ad5f3d3" translate="yes" xml:space="preserve">
          <source>React has been designed from the start for gradual adoption, and &lt;strong&gt;you can use as little or as much React as you need&lt;/strong&gt;. Perhaps you only want to add some &amp;ldquo;sprinkles of interactivity&amp;rdquo; to an existing page. React components are a great way to do that.</source>
          <target state="translated">React был разработан с самого начала для постепенного внедрения, и &lt;strong&gt;вы можете использовать столько или меньше React, сколько вам нужно&lt;/strong&gt; . Возможно, вы хотите лишь добавить к существующей странице &amp;laquo;немного интерактивности&amp;raquo;. Компоненты React - отличный способ сделать это.</target>
        </trans-unit>
        <trans-unit id="7e2cc4782b2fb108291fcfae89e4501e3f4d58b8" translate="yes" xml:space="preserve">
          <source>React has two different approaches to dealing with form inputs.</source>
          <target state="translated">Реакция имеет два различных подхода к работе с форм-входами.</target>
        </trans-unit>
        <trans-unit id="6556acb734c30d6b0e81652863896aeac19e12df" translate="yes" xml:space="preserve">
          <source>React implements a browser-independent DOM system for performance and cross-browser compatibility. We took the opportunity to clean up a few rough edges in browser DOM implementations.</source>
          <target state="translated">React реализует независимую от браузера DOM-систему для производительности и межбраузерной совместимости.Мы воспользовались возможностью очистить несколько грубых граней в браузерных DOM реализациях.</target>
        </trans-unit>
        <trans-unit id="6e11539e493eeb1713363587c427ffbbd6d68e65" translate="yes" xml:space="preserve">
          <source>React is a JavaScript library, and so we&amp;rsquo;ll assume you have a basic understanding of the JavaScript language. &lt;strong&gt;If you don&amp;rsquo;t feel very confident, we recommend &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;going through a JavaScript tutorial&lt;/a&gt; to check your knowledge level&lt;/strong&gt; and enable you to follow along this guide without getting lost. It might take you between 30 minutes and an hour, but as a result you won&amp;rsquo;t have to feel like you&amp;rsquo;re learning both React and JavaScript at the same time.</source>
          <target state="translated">React - это библиотека JavaScript, поэтому мы предполагаем, что у вас есть базовые представления о языке JavaScript. &lt;strong&gt;Если вы не очень уверены в себе, мы рекомендуем &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;пройти обучение по JavaScript,&lt;/a&gt; чтобы проверить свой уровень знаний&lt;/strong&gt; и позволить вам следовать этому руководству, не заблудившись. Это может занять от 30 минут до часа, но в результате вам не придется думать, что вы изучаете React и JavaScript одновременно.</target>
        </trans-unit>
        <trans-unit id="61c3cb0936f8fb199aa04b34b04ecfe3125551c1" translate="yes" xml:space="preserve">
          <source>React is pretty flexible but it has a single strict rule:</source>
          <target state="translated">Реакция довольно гибкая,но у нее есть одно строгое правило:</target>
        </trans-unit>
        <trans-unit id="dd576a79e84680cddef9aa2ab5587fa94134d1fe" translate="yes" xml:space="preserve">
          <source>React is unaware of changes made to the DOM outside of React. It determines updates based on its own internal representation, and if the same DOM nodes are manipulated by another library, React gets confused and has no way to recover.</source>
          <target state="translated">Реакция неизвестна об изменениях,внесенных в флэш-накопитель за пределами Реакции.Он определяет обновления,основываясь на своем собственном внутреннем представлении,и если одни и те же DOM-узлы манипулируются другой библиотекой,React путается и не имеет возможности восстановить.</target>
        </trans-unit>
        <trans-unit id="6cb3494e2a27c4434fdf174bb108a83ae2a686d9" translate="yes" xml:space="preserve">
          <source>React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.</source>
          <target state="translated">Реакция,на наш взгляд,является основным способом построения больших,быстрых веб-приложений с помощью JavaScript.Он очень хорошо масштабируется для нас на Facebook и Instagram.</target>
        </trans-unit>
        <trans-unit id="56d6afe7c746ff7047ca63f1d78e3dc5b9dcfae0" translate="yes" xml:space="preserve">
          <source>React keeps track of the currently rendering component. Thanks to the &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;, we know that Hooks are only called from React components (or custom Hooks &amp;mdash; which are also only called from React components).</source>
          <target state="translated">React отслеживает текущий компонент рендеринга. Благодаря &lt;a href=&quot;hooks-rules&quot;&gt;правилам хуков&lt;/a&gt; мы знаем, что хуки вызываются только из компонентов React (или пользовательских хуков, которые также вызываются только из компонентов React).</target>
        </trans-unit>
        <trans-unit id="4e89f6b54b1e83e2f41d243abe76734deb9a4d0b" translate="yes" xml:space="preserve">
          <source>React lets you define components as classes or functions. Components defined as classes currently provide more features which are described in detail on this page. To define a React component class, you need to extend &lt;code&gt;React.Component&lt;/code&gt;:</source>
          <target state="translated">React позволяет определять компоненты как классы или функции. Компоненты, определенные как классы, в настоящее время предоставляют больше возможностей, которые подробно описаны на этой странице. Чтобы определить класс компонента React, вам необходимо расширить &lt;code&gt;React.Component&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="97a984b046ffb2272bbcd3ebf68f1025fff620f2" translate="yes" xml:space="preserve">
          <source>React makes this data flow explicit to help you understand how your program works, but it does require a little more typing than traditional two-way data binding.</source>
          <target state="translated">Реакция делает этот поток данных явным,чтобы помочь вам понять,как работает ваша программа,но он требует немного больше набора текста,чем традиционная двусторонняя привязка данных.</target>
        </trans-unit>
        <trans-unit id="51fd1862df14bb5b3bd3097a75315aaec37c0d5c" translate="yes" xml:space="preserve">
          <source>React may batch multiple &lt;code&gt;setState()&lt;/code&gt; calls into a single update for performance.</source>
          <target state="translated">React может &lt;code&gt;setState()&lt;/code&gt; несколько вызовов setState () в одно обновление для повышения производительности.</target>
        </trans-unit>
        <trans-unit id="e7723873e421d86b75d6e18af64ca7963f769b3b" translate="yes" xml:space="preserve">
          <source>React normalizes events so that they have consistent properties across different browsers.</source>
          <target state="translated">Реакция нормализует события таким образом,что они имеют последовательные свойства в разных браузерах.</target>
        </trans-unit>
        <trans-unit id="2d906a56aa31f7c4795766f5e6511a32ef9c51c2" translate="yes" xml:space="preserve">
          <source>React offers a new built-in &lt;code&gt;useTransition()&lt;/code&gt; Hook to help with this.</source>
          <target state="translated">React предлагает новый встроенный &lt;code&gt;useTransition()&lt;/code&gt; чтобы помочь в этом.</target>
        </trans-unit>
        <trans-unit id="8a6c999a7613998525cad958f1f5a4415aeb6c88" translate="yes" xml:space="preserve">
          <source>React passes the &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;(props, ref) =&amp;gt; ...&lt;/code&gt; function inside &lt;code&gt;forwardRef&lt;/code&gt; as a second argument.</source>
          <target state="translated">React проходит &lt;code&gt;ref&lt;/code&gt; к &lt;code&gt;(props, ref) =&amp;gt; ...&lt;/code&gt; функция внутри &lt;code&gt;forwardRef&lt;/code&gt; в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="6b8a0c49fcebb56ee095e5a48d9f54395dede3d8" translate="yes" xml:space="preserve">
          <source>React previously shipped with an experimental context API. The old API will be supported in all 16.x releases, but applications using it should migrate to the new version. The legacy API will be removed in a future major React version. Read the &lt;a href=&quot;legacy-context&quot;&gt;legacy context docs here&lt;/a&gt;.</source>
          <target state="translated">React ранее поставлялся с экспериментальным контекстным API. Старый API будет поддерживаться во всех выпусках 16.x, но приложения, использующие его, должны перейти на новую версию. Устаревший API будет удален в будущей основной версии React. Прочтите &lt;a href=&quot;legacy-context&quot;&gt;устаревшую документацию по контексту здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2765ccc9886a57c1e31be3cce27fa7d9e6c6390f" translate="yes" xml:space="preserve">
          <source>React provides a declarative API so that you don&amp;rsquo;t have to worry about exactly what changes on every update. This makes writing applications a lot easier, but it might not be obvious how this is implemented within React. This article explains the choices we made in React&amp;rsquo;s &amp;ldquo;diffing&amp;rdquo; algorithm so that component updates are predictable while being fast enough for high-performance apps.</source>
          <target state="translated">React предоставляет декларативный API, поэтому вам не нужно беспокоиться о том, что именно меняется при каждом обновлении. Это значительно упрощает написание приложений, но может быть неочевидно, как это реализовано в React. В этой статье объясняется, какой выбор мы сделали в алгоритме &amp;laquo;различий&amp;raquo; React, чтобы обновления компонентов были предсказуемыми, но при этом были достаточно быстрыми для высокопроизводительных приложений.</target>
        </trans-unit>
        <trans-unit id="d6cb4b93a472ab33ec73a24af7d41c47515e59e1" translate="yes" xml:space="preserve">
          <source>React provides a few built-in Hooks like &lt;code&gt;useState&lt;/code&gt;. You can also create your own Hooks to reuse stateful behavior between different components. We&amp;rsquo;ll look at the built-in Hooks first.</source>
          <target state="translated">React предоставляет несколько встроенных хуков, например &lt;code&gt;useState&lt;/code&gt; . Вы также можете создавать свои собственные хуки для повторного использования поведения с отслеживанием состояния между различными компонентами. Сначала мы рассмотрим встроенные хуки.</target>
        </trans-unit>
        <trans-unit id="01011cf1aceb6ea9b5b96f5c62df1bcc3dd1a485" translate="yes" xml:space="preserve">
          <source>React relies on a thriving open source community to file bug reports, open pull requests, and &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;submit RFCs&lt;/a&gt;. To encourage feedback we sometimes share special builds of React that include unreleased features.</source>
          <target state="translated">React полагается на процветающее сообщество с открытым исходным кодом для &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;отправки&lt;/a&gt; отчетов об ошибках, открытия запросов на вытягивание и отправки RFC . Чтобы поощрять обратную связь, мы иногда публикуем специальные сборки React, которые включают невыпущенные функции.</target>
        </trans-unit>
        <trans-unit id="f40d6ae813b74cf5f01219aa31530ea03f76cff9" translate="yes" xml:space="preserve">
          <source>React supports a special attribute that you can attach to any component. The &lt;code&gt;ref&lt;/code&gt; attribute can be an object created by &lt;a href=&quot;react-api#reactcreateref&quot;&gt;&lt;code&gt;React.createRef()&lt;/code&gt; function&lt;/a&gt; or a callback function, or a string (in legacy API). When the &lt;code&gt;ref&lt;/code&gt; attribute is a callback function, the function receives the underlying DOM element or class instance (depending on the type of element) as its argument. This allows you to have direct access to the DOM element or component instance.</source>
          <target state="translated">React поддерживает специальный атрибут, который можно прикрепить к любому компоненту. &lt;code&gt;ref&lt;/code&gt; атрибут может быть объектом , созданным с помощью &lt;a href=&quot;react-api#reactcreateref&quot;&gt; &lt;code&gt;React.createRef()&lt;/code&gt; функции&lt;/a&gt; или функции обратного вызова, или строка (в старой версии API). Когда атрибут &lt;code&gt;ref&lt;/code&gt; является функцией обратного вызова, функция получает базовый элемент DOM или экземпляр класса (в зависимости от типа элемента) в качестве аргумента. Это позволяет вам иметь прямой доступ к элементу DOM или экземпляру компонента.</target>
        </trans-unit>
        <trans-unit id="238af60aedac40fa19ce64bb9c937963b487a350" translate="yes" xml:space="preserve">
          <source>React supports all popular browsers, including Internet Explorer 9 and above, although &lt;a href=&quot;javascript-environment-requirements&quot;&gt;some polyfills are required&lt;/a&gt; for older browsers such as IE 9 and IE 10.</source>
          <target state="translated">React поддерживает все популярные браузеры, включая Internet Explorer 9 и выше, хотя &lt;a href=&quot;javascript-environment-requirements&quot;&gt;некоторые полифиллы необходимы&lt;/a&gt; для старых браузеров, таких как IE 9 и IE 10.</target>
        </trans-unit>
        <trans-unit id="f1108fbc718d743d28b30340d206d3e26c0f8796" translate="yes" xml:space="preserve">
          <source>React then calls the &lt;code&gt;Clock&lt;/code&gt; component&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s render output.</source>
          <target state="translated">Затем React вызывает метод &lt;code&gt;render()&lt;/code&gt; компонента &lt;code&gt;Clock&lt;/code&gt; . Так React узнает, что должно отображаться на экране. Затем React обновляет DOM в соответствии с выводом рендеринга &lt;code&gt;Clock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ec1afc5c4c338193066f6b054d7fabc1ccd93cf" translate="yes" xml:space="preserve">
          <source>React treats components starting with lowercase letters as DOM tags. For example, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; represents an HTML div tag, but &lt;code&gt;&amp;lt;Welcome /&amp;gt;&lt;/code&gt; represents a component and requires &lt;code&gt;Welcome&lt;/code&gt; to be in scope.</source>
          <target state="translated">React рассматривает компоненты, начинающиеся со строчных букв, как теги DOM. Например, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; представляет тег HTML div, но &lt;code&gt;&amp;lt;Welcome /&amp;gt;&lt;/code&gt; представляет компонент и требует, чтобы &lt;code&gt;Welcome&lt;/code&gt; было в области действия.</target>
        </trans-unit>
        <trans-unit id="960c9be08d5e97c9a662b93134873e0dbeec6765" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt;. It calls &lt;code&gt;resource.user.read()&lt;/code&gt;. None of the data is fetched yet, so this component &amp;ldquo;suspends&amp;rdquo;. React skips over it, and tries rendering other components in the tree.</source>
          <target state="translated">React пытается отобразить &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; . Он вызывает &lt;code&gt;resource.user.read()&lt;/code&gt; . Никакие данные еще не получены, поэтому этот компонент &amp;laquo;приостанавливается&amp;raquo;. React пропускает его и пытается отобразить другие компоненты в дереве.</target>
        </trans-unit>
        <trans-unit id="058b3578eec02c6fb7e50af3a2a4e4de20aaa646" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt;. It returns &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; as children.</source>
          <target state="translated">React пытается отобразить &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; . Он возвращает &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; как дочерние элементы .</target>
        </trans-unit>
        <trans-unit id="e8754ec34540679dad16654502b2c038a71a9b14" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt;. It calls &lt;code&gt;resource.posts.read()&lt;/code&gt;. Again, there&amp;rsquo;s no data yet, so this component also &amp;ldquo;suspends&amp;rdquo;. React skips over it too, and tries rendering other components in the tree.</source>
          <target state="translated">React пытается отобразить &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; . Он вызывает &lt;code&gt;resource.posts.read()&lt;/code&gt; . Опять же, данных пока нет, поэтому этот компонент также &amp;laquo;приостанавливается&amp;raquo;. React тоже пропускает его и пытается отобразить другие компоненты в дереве.</target>
        </trans-unit>
        <trans-unit id="2bdef9269be61bc9f880c393261771ba76dbc66f" translate="yes" xml:space="preserve">
          <source>React used to support &lt;code&gt;findDOMNode&lt;/code&gt; to search the tree for a DOM node given a class instance. Normally you don&amp;rsquo;t need this because you can &lt;a href=&quot;refs-and-the-dom#creating-refs&quot;&gt;attach a ref directly to a DOM node&lt;/a&gt;.</source>
          <target state="translated">React используется для поддержки &lt;code&gt;findDOMNode&lt;/code&gt; для поиска в дереве узла DOM с учетом экземпляра класса. Обычно вам это не нужно, потому что вы можете &lt;a href=&quot;refs-and-the-dom#creating-refs&quot;&gt;прикрепить ссылку непосредственно к узлу DOM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c79ec4f41b9bc945a753ba6040b79d5949594109" translate="yes" xml:space="preserve">
          <source>React uses a heuristic to decide how &amp;ldquo;urgent&amp;rdquo; an update is, and lets you adjust it with a few lines of code so that you can achieve the desired user experience for every interaction.</source>
          <target state="translated">React использует эвристику, чтобы решить, насколько &amp;laquo;срочно&amp;raquo; обновление, и позволяет вам настроить его с помощью нескольких строк кода, чтобы вы могли добиться желаемого взаимодействия с пользователем при каждом взаимодействии.</target>
        </trans-unit>
        <trans-unit id="22e5b4566adcb56a590eb14809c46d916e2a5e62" translate="yes" xml:space="preserve">
          <source>React will always try to use a shorter lag when network and device allows it.</source>
          <target state="translated">Реакция всегда будет пытаться использовать более короткую задержку,когда сеть и устройство позволяют это.</target>
        </trans-unit>
        <trans-unit id="8dd1f1c89423b4d41ec8e1d8fe3ab9451ec3bb8a" translate="yes" xml:space="preserve">
          <source>React will assign the &lt;code&gt;current&lt;/code&gt; property with the DOM element when the component mounts, and assign it back to &lt;code&gt;null&lt;/code&gt; when it unmounts. &lt;code&gt;ref&lt;/code&gt; updates happen before &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt; lifecycle methods.</source>
          <target state="translated">React назначит &lt;code&gt;current&lt;/code&gt; свойство элементу DOM при монтировании компонента и вернет ему значение &lt;code&gt;null&lt;/code&gt; при размонтировании. Обновления &lt;code&gt;ref&lt;/code&gt; происходят до методов жизненного цикла &lt;code&gt;componentDidMount&lt;/code&gt; или &lt;code&gt;componentDidUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1522b7fcb611ab5619ba5c29f57c6f91086ebb4a" translate="yes" xml:space="preserve">
          <source>React will automatically append a &amp;ldquo;px&amp;rdquo; suffix to certain numeric inline style properties. If you want to use units other than &amp;ldquo;px&amp;rdquo;, specify the value as a string with the desired unit. For example:</source>
          <target state="translated">React автоматически добавит суффикс &amp;laquo;px&amp;raquo; к определенным числовым свойствам встроенного стиля. Если вы хотите использовать единицы измерения, отличные от &amp;laquo;px&amp;raquo;, укажите значение в виде строки с желаемой единицей измерения. Например:</target>
        </trans-unit>
        <trans-unit id="e48c661adaa0691f91d81c42dd5ad79faa9d5b40" translate="yes" xml:space="preserve">
          <source>React will call the &lt;code&gt;ref&lt;/code&gt; callback with the DOM element when the component mounts, and call it with &lt;code&gt;null&lt;/code&gt; when it unmounts. Refs are guaranteed to be up-to-date before &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt; fires.</source>
          <target state="translated">React вызовет обратный вызов &lt;code&gt;ref&lt;/code&gt; с элементом DOM при монтировании компонента и вызовет его с &lt;code&gt;null&lt;/code&gt; при размонтировании. Ссылки гарантированно будут актуальными до срабатывания &lt;code&gt;componentDidMount&lt;/code&gt; или &lt;code&gt;componentDidUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bec961fa87460a8199bc91207f5602b57da775e4" translate="yes" xml:space="preserve">
          <source>React will match the two &lt;code&gt;&amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;&lt;/code&gt; trees, match the two &lt;code&gt;&amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;&lt;/code&gt; trees, and then insert the &lt;code&gt;&amp;lt;li&amp;gt;third&amp;lt;/li&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">React сопоставит два &lt;code&gt;&amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;&lt;/code&gt; дерева, совпадет с двумя &lt;code&gt;&amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;&lt;/code&gt; деревьями, а затем вставит &lt;code&gt;&amp;lt;li&amp;gt;third&amp;lt;/li&amp;gt;&lt;/code&gt; дерево.</target>
        </trans-unit>
        <trans-unit id="84c8d3d2c6b4ee18e7f6c58c4d0878cfba840ef7" translate="yes" xml:space="preserve">
          <source>React will mutate every child instead of realizing it can keep the &lt;code&gt;&amp;lt;li&amp;gt;Duke&amp;lt;/li&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;li&amp;gt;Villanova&amp;lt;/li&amp;gt;&lt;/code&gt; subtrees intact. This inefficiency can be a problem.</source>
          <target state="translated">React будет видоизменять каждого дочернего элемента вместо того, чтобы понимать, что может сохранить поддеревья &lt;code&gt;&amp;lt;li&amp;gt;Duke&amp;lt;/li&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;li&amp;gt;Villanova&amp;lt;/li&amp;gt;&lt;/code&gt; нетронутыми. Эта неэффективность может стать проблемой.</target>
        </trans-unit>
        <trans-unit id="037827f04da7e99d82ca6ffa924d84f2be8f32ef" translate="yes" xml:space="preserve">
          <source>React will only call this function during the first render. See the &lt;a href=&quot;hooks-reference#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt; API reference&lt;/a&gt;.</source>
          <target state="translated">React вызовет эту функцию только во время первого рендеринга. См. &lt;a href=&quot;hooks-reference#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; API useState&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d35f599dec735a7f7b9332bdccd38457cff29aae" translate="yes" xml:space="preserve">
          <source>React wouldn&amp;rsquo;t know what to return for the second &lt;code&gt;useState&lt;/code&gt; Hook call. React expected that the second Hook call in this component corresponds to the &lt;code&gt;persistForm&lt;/code&gt; effect, just like during the previous render, but it doesn&amp;rsquo;t anymore. From that point, every next Hook call after the one we skipped would also shift by one, leading to bugs.</source>
          <target state="translated">React не знал бы, что вернуть при втором &lt;code&gt;useState&lt;/code&gt; Hook. React ожидал, что второй вызов Hook в этом компоненте соответствует эффекту &lt;code&gt;persistForm&lt;/code&gt; , как и во время предыдущего рендеринга, но теперь это не так. С этого момента каждый следующий вызов Hook после пропущенного также будет сдвигаться на единицу, что приведет к ошибкам.</target>
        </trans-unit>
        <trans-unit id="42280d34287efbc44d3bf22242efdd37d8595402" translate="yes" xml:space="preserve">
          <source>React&amp;rsquo;s diffing algorithm (called &lt;a href=&quot;reconciliation&quot;&gt;Reconciliation&lt;/a&gt;) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one. If the component returned from &lt;code&gt;render&lt;/code&gt; is identical (&lt;code&gt;===&lt;/code&gt;) to the component from the previous render, React recursively updates the subtree by diffing it with the new one. If they&amp;rsquo;re not equal, the previous subtree is unmounted completely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1eb9dd2c424ef3fafa626c2c77948281802077e" translate="yes" xml:space="preserve">
          <source>React&amp;rsquo;s diffing algorithm (called reconciliation) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one. If the component returned from &lt;code&gt;render&lt;/code&gt; is identical (&lt;code&gt;===&lt;/code&gt;) to the component from the previous render, React recursively updates the subtree by diffing it with the new one. If they&amp;rsquo;re not equal, the previous subtree is unmounted completely.</source>
          <target state="translated">Алгоритм сравнения React (называемый согласованием) использует идентификатор компонента, чтобы определить, следует ли обновлять существующее поддерево или отбрасывать его и монтировать новое. Если компонент, возвращенный из &lt;code&gt;render&lt;/code&gt; , идентичен ( &lt;code&gt;===&lt;/code&gt; ) компоненту из предыдущего рендеринга, React рекурсивно обновляет поддерево, сравнивая его с новым. Если они не равны, предыдущее поддерево полностью размонтируется.</target>
        </trans-unit>
        <trans-unit id="4b48776bb22bae427abe8b46cd79f8f736c2050d" translate="yes" xml:space="preserve">
          <source>React.Children</source>
          <target state="translated">React.Children</target>
        </trans-unit>
        <trans-unit id="cc1be87ed14efcaf593075d9ede44a45138aadc0" translate="yes" xml:space="preserve">
          <source>React.Children.count</source>
          <target state="translated">React.Children.count</target>
        </trans-unit>
        <trans-unit id="5af3ed601dd15ebbdaac8d067d95b65af5198725" translate="yes" xml:space="preserve">
          <source>React.Children.forEach</source>
          <target state="translated">React.Children.forEach</target>
        </trans-unit>
        <trans-unit id="b0b9f26dfc87ce7a1fabe603e845da6e1df1ce2e" translate="yes" xml:space="preserve">
          <source>React.Children.map</source>
          <target state="translated">React.Children.map</target>
        </trans-unit>
        <trans-unit id="4a803a2f5a435fe023facedc929712933c00bafa" translate="yes" xml:space="preserve">
          <source>React.Children.only</source>
          <target state="translated">React.Children.only</target>
        </trans-unit>
        <trans-unit id="b1c41bf42fafc87b8d58972c97a42005a457379c" translate="yes" xml:space="preserve">
          <source>React.Children.toArray</source>
          <target state="translated">React.Children.toArray</target>
        </trans-unit>
        <trans-unit id="5cfad44c38cc0f45d4217d64395ad2d18bc09eac" translate="yes" xml:space="preserve">
          <source>React.Component</source>
          <target state="translated">React.Component</target>
        </trans-unit>
        <trans-unit id="8767054cca9f51c04adc1d990df49bae21bd19e8" translate="yes" xml:space="preserve">
          <source>React.Fragment</source>
          <target state="translated">React.Fragment</target>
        </trans-unit>
        <trans-unit id="ec2b194c043c081abd8e1fa7d7077fc02478f79a" translate="yes" xml:space="preserve">
          <source>React.PureComponent</source>
          <target state="translated">React.PureComponent</target>
        </trans-unit>
        <trans-unit id="6f447c27948b73409db445d85ed438ff52b2fed4" translate="yes" xml:space="preserve">
          <source>React.Suspense</source>
          <target state="translated">React.Suspense</target>
        </trans-unit>
        <trans-unit id="da177d61b90dfb2b87eaf6b6fa8fe737abb149c1" translate="yes" xml:space="preserve">
          <source>React.createContext</source>
          <target state="translated">React.createContext</target>
        </trans-unit>
        <trans-unit id="9a1b7db7ce8d37e9b8f0ff95428c282a544b51fe" translate="yes" xml:space="preserve">
          <source>React.createRef</source>
          <target state="translated">React.createRef</target>
        </trans-unit>
        <trans-unit id="470198c910691938bdf95d3f55a8eea2de68e228" translate="yes" xml:space="preserve">
          <source>React.forwardRef</source>
          <target state="translated">React.forwardRef</target>
        </trans-unit>
        <trans-unit id="4d68edc4675fcac6e43f56a62dd19ef2ec4f971c" translate="yes" xml:space="preserve">
          <source>React.lazy</source>
          <target state="translated">React.lazy</target>
        </trans-unit>
        <trans-unit id="b168874df4ce448e7d39cbd474dab62d2a63a48c" translate="yes" xml:space="preserve">
          <source>React.memo</source>
          <target state="translated">React.memo</target>
        </trans-unit>
        <trans-unit id="d1dd4b799fd5b42020755757fd1ad8e4de9166c0" translate="yes" xml:space="preserve">
          <source>ReactDOM</source>
          <target state="translated">ReactDOM</target>
        </trans-unit>
        <trans-unit id="575e6ab87dc7232bd5aee91c11fb19e0ec0429d1" translate="yes" xml:space="preserve">
          <source>ReactDOMServer</source>
          <target state="translated">ReactDOMServer</target>
        </trans-unit>
        <trans-unit id="1c6e2478a4ec4479a4090a890821692248b05319" translate="yes" xml:space="preserve">
          <source>ReactJS: Props vs. State</source>
          <target state="translated">Реквизит против штата.</target>
        </trans-unit>
        <trans-unit id="6bba779745f1dc5e89a8dc6f34f971f62a0cbbcf" translate="yes" xml:space="preserve">
          <source>Read more about the use of these elements to enhance accessibility here:</source>
          <target state="translated">Подробнее об использовании этих элементов для повышения доступности можно прочитать здесь:</target>
        </trans-unit>
        <trans-unit id="074b86f971ede72779f80c5984d463c0b08f7ddd" translate="yes" xml:space="preserve">
          <source>Read our &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;blog post on avoiding derived state&lt;/a&gt; to learn about what to do if you think you need some state to depend on the props.</source>
          <target state="translated">Прочтите нашу &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;запись в блоге об избежании производного состояния,&lt;/a&gt; чтобы узнать, что делать, если вы считаете, что вам нужно какое-то состояние, которое зависело бы от свойств.</target>
        </trans-unit>
        <trans-unit id="81948a47f0cece8eebf3d00111f8c4906a80131d" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;context&quot;&gt;new context API documentation&lt;/a&gt; to help migrate to the new version.</source>
          <target state="translated">Прочтите документацию по &lt;a href=&quot;context&quot;&gt;новому контекстному API,&lt;/a&gt; чтобы помочь перейти на новую версию.</target>
        </trans-unit>
        <trans-unit id="9d13f2fc7ceb07a1e30213b5dad32a3a5179b292" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;hooks-intro#motivation&quot;&gt;Motivation&lt;/a&gt; to learn why we&amp;rsquo;re introducing Hooks to React.</source>
          <target state="translated">Прочтите &lt;a href=&quot;hooks-intro#motivation&quot;&gt;Мотивацию,&lt;/a&gt; чтобы узнать, почему мы вводим Hooks to React.</target>
        </trans-unit>
        <trans-unit id="3bbadf53c7263d165aad6e988afe2df6a73f4a1f" translate="yes" xml:space="preserve">
          <source>Reading State</source>
          <target state="translated">Читающее государство</target>
        </trans-unit>
        <trans-unit id="f219cc0614ae6860f43a3cd84b5cf31fc312cd9d" translate="yes" xml:space="preserve">
          <source>Reason</source>
          <target state="translated">Reason</target>
        </trans-unit>
        <trans-unit id="bbff96495da2dd73f63babc3c8bf1ad05fa7f5d9" translate="yes" xml:space="preserve">
          <source>Reason is developed at Facebook, and is used in some of its products like Messenger. It is still somewhat experimental but it has &lt;a href=&quot;https://reasonml.github.io/reason-react/&quot;&gt;dedicated React bindings&lt;/a&gt; maintained by Facebook and a &lt;a href=&quot;https://reasonml.github.io/docs/en/community.html&quot;&gt;vibrant community&lt;/a&gt;.</source>
          <target state="translated">Reason разрабатывается в Facebook и используется в некоторых из ее продуктов, таких как Messenger. Он все еще в некоторой степени экспериментален, но у него есть &lt;a href=&quot;https://reasonml.github.io/reason-react/&quot;&gt;специальные привязки React,&lt;/a&gt; поддерживаемые Facebook и &lt;a href=&quot;https://reasonml.github.io/docs/en/community.html&quot;&gt;динамичным сообществом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a49698c20a1d19a475a3edf8be8f8f8b30ec65ca" translate="yes" xml:space="preserve">
          <source>Recap</source>
          <target state="translated">Recap</target>
        </trans-unit>
        <trans-unit id="9fb1092f32d4fcbf9e061ffd718d4ec689c6c95e" translate="yes" xml:space="preserve">
          <source>Recipes</source>
          <target state="translated">Recipes</target>
        </trans-unit>
        <trans-unit id="3a2b9fcfa6cb6b47fdf570bba482c7f6bd5778c1" translate="yes" xml:space="preserve">
          <source>Recommended Courses</source>
          <target state="translated">Рекомендуемые курсы</target>
        </trans-unit>
        <trans-unit id="10837ad0c0a51856150f656df265fcd25ac01ed3" translate="yes" xml:space="preserve">
          <source>Recommended Toolchains</source>
          <target state="translated">Рекомендуемые цепочки инструментов</target>
        </trans-unit>
        <trans-unit id="244546a122b5c31cc9d410496feb2d652e2bbdc1" translate="yes" xml:space="preserve">
          <source>Recommended Tools</source>
          <target state="translated">Рекомендуемые инструменты</target>
        </trans-unit>
        <trans-unit id="b29da9dd20f256ca2ca1f8f9694721825196ea4d" translate="yes" xml:space="preserve">
          <source>Reconciliation</source>
          <target state="translated">Reconciliation</target>
        </trans-unit>
        <trans-unit id="332ed81ec8ca439bef285d75f52c06cbc08b32a4" translate="yes" xml:space="preserve">
          <source>Recursing On Children</source>
          <target state="translated">Присмотр за детьми</target>
        </trans-unit>
        <trans-unit id="ccfd566b538210ffef62a3cbbf17af444ab5c269" translate="yes" xml:space="preserve">
          <source>Reducers are very convenient to test in isolation, and scale to express complex update logic. You can further break them apart into smaller reducers if necessary. However, you might also enjoy the benefits of using React local state, or might not want to install another library.</source>
          <target state="translated">Редукторы очень удобны для тестирования по отдельности и масштабирования для выражения сложной логики обновления.При необходимости их можно разбить на более мелкие редукторы.Однако,вы также можете воспользоваться преимуществами использования React local state,или,возможно,не захотеть устанавливать другую библиотеку.</target>
        </trans-unit>
        <trans-unit id="0997f5332014e1341252581fa75655f6f29042ff" translate="yes" xml:space="preserve">
          <source>Ref forwarding is a technique for automatically passing a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; through a component to one of its children. This is typically not necessary for most components in the application. However, it can be useful for some kinds of components, especially in reusable component libraries. The most common scenarios are described below.</source>
          <target state="translated">Пересылка &lt;a href=&quot;refs-and-the-dom&quot;&gt;ссылок&lt;/a&gt; - это метод автоматической передачи ссылки через компонент одному из его дочерних элементов. Обычно это не требуется для большинства компонентов приложения. Однако это может быть полезно для некоторых видов компонентов, особенно в библиотеках компонентов многократного использования. Ниже описаны наиболее распространенные сценарии.</target>
        </trans-unit>
        <trans-unit id="88e9c6ab30810deb881b406399ad25815aa00430" translate="yes" xml:space="preserve">
          <source>Ref forwarding is not limited to DOM components. You can forward refs to class component instances, too.</source>
          <target state="translated">Переадресация не ограничивается компонентами DOM.Вы также можете пересылать ссылки на экземпляры компонентов класса.</target>
        </trans-unit>
        <trans-unit id="f94f7a816faa7ffd5cf23158233fea5b06cec8af" translate="yes" xml:space="preserve">
          <source>Refer to the &lt;a href=&quot;https://reactjs.org/docs/&quot;&gt;React docs&lt;/a&gt; if you need help executing this step.</source>
          <target state="translated">Обратитесь к &lt;a href=&quot;https://reactjs.org/docs/&quot;&gt;документации React,&lt;/a&gt; если вам нужна помощь в выполнении этого шага.</target>
        </trans-unit>
        <trans-unit id="c29e646865b903a7f9176acc308f47b762dfedc4" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how best to use ChromeVox:</source>
          <target state="translated">Обратитесь к следующим руководствам о том,как лучше всего использовать ChromeVox:</target>
        </trans-unit>
        <trans-unit id="d97130a2c24d6da30b1f2bcc6a91ee349588c307" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to activate and use VoiceOver:</source>
          <target state="translated">Обратитесь к следующим руководствам по активации и использованию VoiceOver:</target>
        </trans-unit>
        <trans-unit id="387cf309f2faa4474cac2537147bc4a9fb447c54" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to best use JAWS:</source>
          <target state="translated">Обратитесь к следующим руководствам о том,как лучше всего использовать JAWS:</target>
        </trans-unit>
        <trans-unit id="c1af4dc4226ba5d7f48cd9164c32b42e6e3bf5ff" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to best use NVDA:</source>
          <target state="translated">Обратитесь к следующим руководствам о том,как лучше всего использовать NVDA:</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="e01e6c1194053e77088bcfb2d27b92af6a763645" translate="yes" xml:space="preserve">
          <source>Reference: Component</source>
          <target state="translated">Ссылка:Компонент</target>
        </trans-unit>
        <trans-unit id="07e5e98584609eccb9f77b23943878ea7e66663b" translate="yes" xml:space="preserve">
          <source>Reference: React</source>
          <target state="translated">Ссылка:Реакция</target>
        </trans-unit>
        <trans-unit id="6c5d1b546101e34b2fef5dfa40c4a0c35d04ef65" translate="yes" xml:space="preserve">
          <source>Reference: Test Utilities</source>
          <target state="translated">Ссылка:Тестовые утилиты</target>
        </trans-unit>
        <trans-unit id="9b4ff94e05defc26bbc7cd77d4ca3c6ebd0b6024" translate="yes" xml:space="preserve">
          <source>Referencing Context in Function Components</source>
          <target state="translated">Контекст ссылки в функциональных компонентах</target>
        </trans-unit>
        <trans-unit id="9b14990da33d9df39d9d550b2e7f8b6fcd2b42ba" translate="yes" xml:space="preserve">
          <source>Referencing Context in Lifecycle Methods</source>
          <target state="translated">Контекст ссылки в методах жизненного цикла</target>
        </trans-unit>
        <trans-unit id="701486a68f3896a8a5368aead277807a6847151f" translate="yes" xml:space="preserve">
          <source>Refs</source>
          <target state="translated">Refs</target>
        </trans-unit>
        <trans-unit id="a3d901aa78a934ff41addcb0fd717d3f919ed007" translate="yes" xml:space="preserve">
          <source>Refs Aren&amp;rsquo;t Passed Through</source>
          <target state="translated">Ссылки не проходят</target>
        </trans-unit>
        <trans-unit id="f52edcfa76c4c361d68ab116986e39ab247fed52" translate="yes" xml:space="preserve">
          <source>Refs and Function Components</source>
          <target state="translated">Рефлексы и функциональные компоненты</target>
        </trans-unit>
        <trans-unit id="fb466d16b8687b6a8370254e6e32e29e3d0859c3" translate="yes" xml:space="preserve">
          <source>Refs and the DOM</source>
          <target state="translated">Refs и DOM</target>
        </trans-unit>
        <trans-unit id="d02e5e18486fdb7d98bc4b06d983eb76fb1c3d9f" translate="yes" xml:space="preserve">
          <source>Refs are created using &lt;code&gt;React.createRef()&lt;/code&gt; and attached to React elements via the &lt;code&gt;ref&lt;/code&gt; attribute. Refs are commonly assigned to an instance property when a component is constructed so they can be referenced throughout the component.</source>
          <target state="translated">&lt;code&gt;React.createRef()&lt;/code&gt; создаются с помощью React.createRef () и прикрепляются к элементам React через атрибут &lt;code&gt;ref&lt;/code&gt; . Ссылки обычно присваиваются свойству экземпляра при создании компонента, чтобы на них можно было ссылаться по всему компоненту.</target>
        </trans-unit>
        <trans-unit id="7d161866c6b9501cf0d2efb1f50f2016be3d6821" translate="yes" xml:space="preserve">
          <source>Refs provide a way to access DOM nodes or React elements created in the render method.</source>
          <target state="translated">Refs предоставляют способ доступа к DOM-узлам или React-элементам,созданным в методе рендеринга.</target>
        </trans-unit>
        <trans-unit id="899dfdc1d167e0237757bc336e63500e23158098" translate="yes" xml:space="preserve">
          <source>Relay has its own answers to some of these questions. There is certainly more than a single way to do it, and we&amp;rsquo;re excited to see what new ideas the React community comes up with.</source>
          <target state="translated">У Relay есть свои ответы на некоторые из этих вопросов. Конечно, существует более чем один способ сделать это, и мы очень рады видеть, какие новые идеи предлагает сообщество React.</target>
        </trans-unit>
        <trans-unit id="f9896fabfbfb541e50cf8fbc89e1dedd902b28da" translate="yes" xml:space="preserve">
          <source>Release Channels</source>
          <target state="translated">Каналы сброса</target>
        </trans-unit>
        <trans-unit id="37042d2abc9098ffc1431b21485e7d0a1a7e4bba" translate="yes" xml:space="preserve">
          <source>Releases in Experimental are published with the &lt;code&gt;experimental&lt;/code&gt; tag on npm. Versions are generated from a hash of the build&amp;rsquo;s contents, e.g. &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt;.</source>
          <target state="translated">Выбросы в Экспериментальной публикуются с &lt;code&gt;experimental&lt;/code&gt; наклеивают НПМ. Версии генерируются из хэша содержимого сборки, например &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1437218113e95e798836c2813420f7b58e53793d" translate="yes" xml:space="preserve">
          <source>Releases in Next are published with the &lt;code&gt;next&lt;/code&gt; tag on npm. Versions are generated from a hash of the build&amp;rsquo;s contents, e.g. &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt;.</source>
          <target state="translated">Релизы в Next публикуются со &lt;code&gt;next&lt;/code&gt; тегом в npm. Версии генерируются из хэша содержимого сборки, например &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="506ceb7ad9bf42c314daf190028b0b49649a9a76" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;props&lt;/code&gt; are readonly. They should not be modified in any way:</source>
          <target state="translated">Помните, что &lt;code&gt;props&lt;/code&gt; доступны только для чтения. Их ни в коем случае нельзя изменять:</target>
        </trans-unit>
        <trans-unit id="00ec254bb146176823654d1ba7e18ca2d439ac55" translate="yes" xml:space="preserve">
          <source>Remember that only React files ending with &lt;code&gt;.production.min.js&lt;/code&gt; are suitable for production.</source>
          <target state="translated">Помните, что для производства подходят только файлы React, заканчивающиеся на &lt;code&gt;.production.min.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55c0498b17e0f7958c5f1cfe9a4af9cc2fac5b70" translate="yes" xml:space="preserve">
          <source>Remember that the function passed to &lt;code&gt;useMemo&lt;/code&gt; runs during rendering. Don&amp;rsquo;t do anything there that you wouldn&amp;rsquo;t normally do while rendering. For example, side effects belong in &lt;code&gt;useEffect&lt;/code&gt;, not &lt;code&gt;useMemo&lt;/code&gt;.</source>
          <target state="translated">Помните, что функция, переданная в &lt;code&gt;useMemo&lt;/code&gt; , запускается во время рендеринга. Не делайте там ничего, чего вы обычно не делаете при рендеринге. Например, побочные эффекты относятся к &lt;code&gt;useEffect&lt;/code&gt; , а не &lt;code&gt;useMemo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a6275d186fd90e50c31acd8ea5dda666aacddf8" translate="yes" xml:space="preserve">
          <source>Remember that this is only necessary before deploying to production. For normal development, use &lt;code&gt;npm start&lt;/code&gt;.</source>
          <target state="translated">Помните, что это необходимо только перед развертыванием в производственной среде. Для нормальной разработки используйте &lt;code&gt;npm start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a9b6c75a01a157a01b48b838460f641ef9518a1" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply &lt;code&gt;TerserPlugin&lt;/code&gt; in development because it will hide useful React warnings, and make the builds much slower.</source>
          <target state="translated">Помните, что вам нужно делать это только для производственных сборок. Вы не должны применять &lt;code&gt;TerserPlugin&lt;/code&gt; в разработке, потому что он скроет полезные предупреждения React и сделает сборку намного медленнее.</target>
        </trans-unit>
        <trans-unit id="1aa3b578bcc142e681e33d9082e9b12920727051" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply the &lt;code&gt;terser&lt;/code&gt; plugin or the &lt;code&gt;replace&lt;/code&gt; plugin with &lt;code&gt;'production'&lt;/code&gt; value in development because they will hide useful React warnings, and make the builds much slower.</source>
          <target state="translated">Помните, что вам нужно делать это только для производственных сборок. Вы не должны применять плагин &lt;code&gt;terser&lt;/code&gt; или &lt;code&gt;replace&lt;/code&gt; плагин со значением &lt;code&gt;'production'&lt;/code&gt; в процессе разработки, потому что они скроют полезные предупреждения React и сделают сборку намного медленнее.</target>
        </trans-unit>
        <trans-unit id="0564aab96aa66b680690a02b7eaf83e614ce4779" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply these plugins in development because they will hide useful React warnings, and make the builds much slower.</source>
          <target state="translated">Помните, что вам нужно делать это только для производственных сборок. Вы не должны применять эти плагины в разработке, потому что они скроют полезные предупреждения React и сделают сборку намного медленнее.</target>
        </trans-unit>
        <trans-unit id="cee5bbc977133f79e172d6c135cbc3a08da22a4c" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t pass the &lt;code&gt;-p&lt;/code&gt; flag or apply this plugin in development, because it will hide useful React warnings and make the builds much slower.</source>
          <target state="translated">Помните, что вам нужно делать это только для производственных сборок. Вы не должны передавать флаг &lt;code&gt;-p&lt;/code&gt; или применять этот плагин в разработке, потому что он скроет полезные предупреждения React и сделает сборку намного медленнее.</target>
        </trans-unit>
        <trans-unit id="02638cc549bbccd3a59e4d9f2b3447b3799a9799" translate="yes" xml:space="preserve">
          <source>Remember to be mindful of user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so if you render something different in the client-only pass, the transition can be jarring. However, if executed well, it may be beneficial to render a &amp;ldquo;shell&amp;rdquo; of the application on the server, and only show some of the extra widgets on the client. To learn how to do this without getting the markup mismatch issues, refer to the explanation in the previous paragraph.</source>
          <target state="translated">Не забывайте о работе пользователей при медленном подключении. Код JavaScript может загружаться значительно позже, чем исходный HTML-рендеринг, поэтому, если вы визуализируете что-то другое в проходе только для клиента, переход может быть неприятным. Однако при правильном выполнении может быть полезно визуализировать &amp;laquo;оболочку&amp;raquo; приложения на сервере и показывать только некоторые из дополнительных виджетов на клиенте. Чтобы узнать, как это сделать, не получив проблем с несоответствием разметки, см. Объяснение в предыдущем абзаце.</target>
        </trans-unit>
        <trans-unit id="0cf6b3967ff86476349c6cba924e1f4df9063ba0" translate="yes" xml:space="preserve">
          <source>Remember: React is all about one-way data flow down the component hierarchy. It may not be immediately clear which component should own what state. &lt;strong&gt;This is often the most challenging part for newcomers to understand,&lt;/strong&gt; so follow these steps to figure it out:</source>
          <target state="translated">Помните: React - это односторонний поток данных вниз по иерархии компонентов. Может быть не сразу понятно, какой компонент в каком состоянии должен владеть. &lt;strong&gt;Часто это самая сложная часть для понимания новичками,&lt;/strong&gt; поэтому выполните следующие действия, чтобы понять это:</target>
        </trans-unit>
        <trans-unit id="4bddbe70e7cebef78898e35292cc2468b12a94b5" translate="yes" xml:space="preserve">
          <source>Remove a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns &lt;code&gt;true&lt;/code&gt; if a component was unmounted and &lt;code&gt;false&lt;/code&gt; if there was no component to unmount.</source>
          <target state="translated">Удалите смонтированный компонент React из DOM и очистите его обработчики событий и состояние. Если в контейнер не был смонтирован ни один компонент, вызов этой функции ничего не делает. Возвращает &lt;code&gt;true&lt;/code&gt; , если компонент был размонтирован, и &lt;code&gt;false&lt;/code&gt; , если не было компонента, который нужно размонтировать.</target>
        </trans-unit>
        <trans-unit id="86694784f4769bf45b391e840ebd17a5027533ee" translate="yes" xml:space="preserve">
          <source>Remove the &lt;code&gt;date&lt;/code&gt; prop from the &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">Удалите опору &lt;code&gt;date&lt;/code&gt; из элемента &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f97a2511af3b23436102ab6d44ee45e78c76ee6" translate="yes" xml:space="preserve">
          <source>Render Props</source>
          <target state="translated">реквизит</target>
        </trans-unit>
        <trans-unit id="e1ac8a2e8fd4c4d9b2e888fc8ab5aa1c5641c010" translate="yes" xml:space="preserve">
          <source>Render a React element into a detached DOM node in the document. &lt;strong&gt;This function requires a DOM.&lt;/strong&gt; It is effectively equivalent to:</source>
          <target state="translated">Визуализируйте элемент React в отдельный узел DOM в документе. &lt;strong&gt;Эта функция требует DOM. &lt;/strong&gt;Фактически это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="6f4c267baa0ea37da44d3295841c41f7517ef016" translate="yes" xml:space="preserve">
          <source>Render a React element into the DOM in the supplied &lt;code&gt;container&lt;/code&gt; and return a &lt;a href=&quot;refs-and-the-dom&quot;&gt;reference&lt;/a&gt; to the component (or returns &lt;code&gt;null&lt;/code&gt; for &lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;stateless components&lt;/a&gt;).</source>
          <target state="translated">Визуализируйте элемент React в DOM в предоставленном &lt;code&gt;container&lt;/code&gt; и верните &lt;a href=&quot;refs-and-the-dom&quot;&gt;ссылку&lt;/a&gt; на компонент (или возвращает &lt;code&gt;null&lt;/code&gt; для &lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;компонентов без состояния&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc5294dc207a073f91e4e23440d40dc7c1fe8ec8" translate="yes" xml:space="preserve">
          <source>Render a React element to its initial HTML. React will return an HTML string. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</source>
          <target state="translated">Отображение элемента React в исходном HTML.React вернет строку HTML.Вы можете использовать этот метод для генерации HTML на сервере и отправки разметки вниз по первоначальному запросу для более быстрой загрузки страниц и для того,чтобы позволить поисковым системам сканировать ваши страницы для целей SEO.</target>
        </trans-unit>
        <trans-unit id="c0113dc822fbf0c0333e792a37212eab08364f58" translate="yes" xml:space="preserve">
          <source>Render a React element to its initial HTML. Returns a &lt;a href=&quot;https://nodejs.org/api/stream.html#stream_readable_streams&quot;&gt;Readable stream&lt;/a&gt; that outputs an HTML string. The HTML output by this stream is exactly equal to what &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;ReactDOMServer.renderToString&lt;/code&gt;&lt;/a&gt; would return. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</source>
          <target state="translated">Визуализируйте элемент React в его исходный HTML. Возвращает &lt;a href=&quot;https://nodejs.org/api/stream.html#stream_readable_streams&quot;&gt;читаемый поток,&lt;/a&gt; который выводит строку HTML. Вывод HTML этим потоком в точности равен тому, что &lt;a href=&quot;#rendertostring&quot;&gt; &lt;code&gt;ReactDOMServer.renderToString&lt;/code&gt; &lt;/a&gt; . Вы можете использовать этот метод для генерации HTML на сервере и отправки разметки при первоначальном запросе для более быстрой загрузки страницы и для разрешения поисковым системам сканировать ваши страницы в целях SEO.</target>
        </trans-unit>
        <trans-unit id="cfd90297d318440c1f2f1e20386ac52433816dbc" translate="yes" xml:space="preserve">
          <source>Render phase lifecycles include the following class component methods:</source>
          <target state="translated">Фазовые жизненные циклы розыгрыша включают в себя следующие методы компонент класса:</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="1c25bcd6bd276eac5fcaea0f95ff3ce958900765" translate="yes" xml:space="preserve">
          <source>Rendering Elements</source>
          <target state="translated">Рендеринговые элементы</target>
        </trans-unit>
        <trans-unit id="6e673765026d08ba19736d6743a5af8bbfbf2280" translate="yes" xml:space="preserve">
          <source>Rendering Multiple Components</source>
          <target state="translated">Рендеринг многокомпонентных</target>
        </trans-unit>
        <trans-unit id="5de451ee11969db712ecfa41261cd69923ac3c5e" translate="yes" xml:space="preserve">
          <source>Rendering a Component</source>
          <target state="translated">Оформление компонента</target>
        </trans-unit>
        <trans-unit id="5a1b1f26449aa10c5465e1866d5b17350d60dba1" translate="yes" xml:space="preserve">
          <source>Rendering an Element into the DOM</source>
          <target state="translated">Отправка элемента в МРЗ.</target>
        </trans-unit>
        <trans-unit id="2deeb1304f9fe594167184d5df3f289bd150a128" translate="yes" xml:space="preserve">
          <source>Reorders can also cause issues with component state when indexes are used as keys. Component instances are updated and reused based on their key. If the key is an index, moving an item changes it. As a result, component state for things like uncontrolled inputs can get mixed up and updated in unexpected ways.</source>
          <target state="translated">Переупорядочивание может также вызывать проблемы с состоянием компонентов,когда индексы используются в качестве ключей.Экземпляры компонентов обновляются и повторно используются на основе их ключа.Если ключ является индексом,перемещение элемента изменяет его.В результате,состояние компонентов для таких вещей,как неконтролируемые входы,может быть перепутано и обновлено неожиданными способами.</target>
        </trans-unit>
        <trans-unit id="fbe7d9e0840a5d5cc2233edcc4df112b60c50775" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;props&lt;/code&gt; with &lt;code&gt;this.props&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; body.</source>
          <target state="translated">Замените &lt;code&gt;props&lt;/code&gt; на &lt;code&gt;this.props&lt;/code&gt; в теле &lt;code&gt;render()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb57ef5effd1f60e8626d7c988da95a24b5ec275" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;this.props.date&lt;/code&gt; with &lt;code&gt;this.state.date&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method:</source>
          <target state="translated">Замените &lt;code&gt;this.props.date&lt;/code&gt; на &lt;code&gt;this.state.date&lt;/code&gt; в методе &lt;code&gt;render()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f9ea2adea65e9fb0a33960f20df2ec187396b408" translate="yes" xml:space="preserve">
          <source>Replaces &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; and enables &lt;a href=&quot;concurrent-mode-adoption#migration-step-blocking-mode&quot;&gt;Blocking Mode&lt;/a&gt;.</source>
          <target state="translated">Заменяет &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; и включает &lt;a href=&quot;concurrent-mode-adoption#migration-step-blocking-mode&quot;&gt;режим блокировки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="317adb3c3ea2c25ffb027f680071c7621ebb38a5" translate="yes" xml:space="preserve">
          <source>Replaces &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; and enables Concurrent Mode.</source>
          <target state="translated">Заменяет &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; и включает параллельный режим.</target>
        </trans-unit>
        <trans-unit id="28a19901d94163b49c0b9a0ab562c759e0d3c83b" translate="yes" xml:space="preserve">
          <source>Replacing String-Based Rendering with React</source>
          <target state="translated">Замена струнного риндеринга на реактивный</target>
        </trans-unit>
        <trans-unit id="326977983d9f5ffff2fba0920254350c35e6b262" translate="yes" xml:space="preserve">
          <source>Requires a &lt;a href=&quot;render-props#using-props-other-than-render&quot;&gt;function as a child&lt;/a&gt;. The function receives the current context value and returns a React node. The &lt;code&gt;value&lt;/code&gt; argument passed to the function will be equal to the &lt;code&gt;value&lt;/code&gt; prop of the closest Provider for this context above in the tree. If there is no Provider for this context above, the &lt;code&gt;value&lt;/code&gt; argument will be equal to the &lt;code&gt;defaultValue&lt;/code&gt; that was passed to &lt;code&gt;createContext()&lt;/code&gt;.</source>
          <target state="translated">Требуется &lt;a href=&quot;render-props#using-props-other-than-render&quot;&gt;функция как ребенок&lt;/a&gt; . Функция получает текущее значение контекста и возвращает узел React. &lt;code&gt;value&lt;/code&gt; аргумент передается функция будет равен &lt;code&gt;value&lt;/code&gt; подпорки ближайшего поставщика для данного контекста выше в дереве. Если для этого контекста выше нет Provider, аргумент &lt;code&gt;value&lt;/code&gt; будет равен &lt;code&gt;defaultValue&lt;/code&gt; , переданному в &lt;code&gt;createContext()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8319d57e9244f07c04fc5e8602151a6c0fa2d6f" translate="yes" xml:space="preserve">
          <source>Requiring Single Child</source>
          <target state="translated">Требующий единственного ребенка</target>
        </trans-unit>
        <trans-unit id="7111cdd0dc257beff8eea7a806b1ab1fd962ca5c" translate="yes" xml:space="preserve">
          <source>Resist the temptation to modify a component&amp;rsquo;s prototype (or otherwise mutate it) inside a HOC.</source>
          <target state="translated">Не поддавайтесь искушению изменить прототип компонента (или иначе видоизменить его) внутри HOC.</target>
        </trans-unit>
        <trans-unit id="d9204284eada33e6b4a89c93c4c4d56bd1b58bad" translate="yes" xml:space="preserve">
          <source>Return a function that produces React elements of a given type. Like &lt;a href=&quot;#createelement&quot;&gt;&lt;code&gt;React.createElement()&lt;/code&gt;&lt;/a&gt;, the type argument can be either a tag name string (such as &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt;), a &lt;a href=&quot;components-and-props&quot;&gt;React component&lt;/a&gt; type (a class or a function), or a &lt;a href=&quot;#reactfragment&quot;&gt;React fragment&lt;/a&gt; type.</source>
          <target state="translated">Вернуть функцию, которая производит элементы React заданного типа. Как и &lt;a href=&quot;#createelement&quot;&gt; &lt;code&gt;React.createElement()&lt;/code&gt; &lt;/a&gt; , аргумент типа может быть либо строкой имени тега (например, &lt;code&gt;'div'&lt;/code&gt; или &lt;code&gt;'span'&lt;/code&gt; ), типом &lt;a href=&quot;components-and-props&quot;&gt;компонента React&lt;/a&gt; (класс или функция) или типом &lt;a href=&quot;#reactfragment&quot;&gt;фрагмента React&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d9490a5975f4c1aeeb1fba945378a6267587086" translate="yes" xml:space="preserve">
          <source>Return an object representing the rendered tree. The representation is more detailed than the one provided by &lt;code&gt;toJSON()&lt;/code&gt;, and includes the user-written components. You probably don&amp;rsquo;t need this method unless you&amp;rsquo;re writing your own assertion library on top of the test renderer.</source>
          <target state="translated">Вернуть объект, представляющий визуализированное дерево. Представление более детально, чем то, которое предоставляет &lt;code&gt;toJSON()&lt;/code&gt; , и включает в себя компоненты, написанные пользователем. Вам, вероятно, не понадобится этот метод, если вы не пишете свою собственную библиотеку утверждений поверх тестового средства визуализации.</target>
        </trans-unit>
        <trans-unit id="f7c1bb71db1342d91c5ef36e51eb4eaefb116d31" translate="yes" xml:space="preserve">
          <source>Return an object representing the rendered tree. This tree only contains the platform-specific nodes like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; and their props, but doesn&amp;rsquo;t contain any user-written components. This is handy for &lt;a href=&quot;https://facebook.github.io/jest/docs/en/snapshot-testing.html#snapshot-testing-with-jest&quot;&gt;snapshot testing&lt;/a&gt;.</source>
          <target state="translated">Вернуть объект, представляющий визуализированное дерево. Это дерево содержит только узлы, зависящие от платформы, такие как &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; , и их свойства, но не содержит никаких пользовательских компонентов. Это удобно для &lt;a href=&quot;https://facebook.github.io/jest/docs/en/snapshot-testing.html#snapshot-testing-with-jest&quot;&gt;тестирования снимков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74fc039e9565bf16b53a3b89e5b81f2b44db53f3" translate="yes" xml:space="preserve">
          <source>Return the instance corresponding to the root element, if available. This will not work if the root element is a function component because they don&amp;rsquo;t have instances.</source>
          <target state="translated">Верните экземпляр, соответствующий корневому элементу, если он доступен. Это не сработает, если корневой элемент является функциональным компонентом, потому что у них нет экземпляров.</target>
        </trans-unit>
        <trans-unit id="1bf63f8c82c0848fec82740dea18e1228a6949a1" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;null&lt;/code&gt; from a component&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method does not affect the firing of the component&amp;rsquo;s lifecycle methods. For instance &lt;code&gt;componentDidUpdate&lt;/code&gt; will still be called.</source>
          <target state="translated">Возврат &lt;code&gt;null&lt;/code&gt; из метода &lt;code&gt;render&lt;/code&gt; компонента не влияет на запуск методов жизненного цикла компонента. Например, &lt;code&gt;componentDidUpdate&lt;/code&gt; по- прежнему будет вызываться.</target>
        </trans-unit>
        <trans-unit id="7bc6aecb5d9aba689da1df93e2754ec3bbba006b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;element&lt;/code&gt; is a React element whose type is of a React &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="translated">Возвращает &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;element&lt;/code&gt; является элементом React, тип которого имеет React &lt;code&gt;componentClass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a190fbdb0884ae9441f701da292b119b62675501" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;element&lt;/code&gt; is any React element.</source>
          <target state="translated">Возвращает &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;element&lt;/code&gt; является любым элементом React.</target>
        </trans-unit>
        <trans-unit id="4c122a79f21fb165125e2d7f4bf95f4c5c45a74e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a DOM component (such as a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Возвращает значение &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;instance&lt;/code&gt; является компонентом DOM (например, &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e33afd14605447b5271912282d921b04b0bd5370" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a component whose type is of a React &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="translated">Возвращает &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;instance&lt;/code&gt; является компонентом, имеющим тип React &lt;code&gt;componentClass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="499d37d763d22c84b2d39e5c1954470c821ac070" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a user-defined component, such as a class or a function.</source>
          <target state="translated">Возвращает &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;instance&lt;/code&gt; является определяемым пользователем компонентом, например классом или функцией.</target>
        </trans-unit>
        <trans-unit id="ebac6d7da5644ee246df2cbcbead0e219e53e73f" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoized&lt;/a&gt; callback.</source>
          <target state="translated">Возвращает &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;мемоизированный&lt;/a&gt; обратный вызов.</target>
        </trans-unit>
        <trans-unit id="d3db2224691dc0b90f31765016663484bb5df51c" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoized&lt;/a&gt; value.</source>
          <target state="translated">Возвращает &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;мемоизированное&lt;/a&gt; значение.</target>
        </trans-unit>
        <trans-unit id="ebd4eccf8c2df94f154d585fd787ad0e2ae4f7f8" translate="yes" xml:space="preserve">
          <source>Returns a deferred version of the value that may &amp;ldquo;lag behind&amp;rdquo; it for at most &lt;code&gt;timeoutMs&lt;/code&gt;.</source>
          <target state="translated">Возвращает отложенную версию значения, которая может &amp;laquo;отставать&amp;raquo; от нее максимум на &lt;code&gt;timeoutMs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3aaff9eb4ac50df91dd22852b4c13a60bac4270" translate="yes" xml:space="preserve">
          <source>Returns a stateful value, and a function to update it.</source>
          <target state="translated">Возвращает статусное значение и функцию для его обновления.</target>
        </trans-unit>
        <trans-unit id="62e25a4ff0b51f4bd36d6a71ad97da75dd2e0c57" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;children&lt;/code&gt; opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice &lt;code&gt;this.props.children&lt;/code&gt; before passing it down.</source>
          <target state="translated">Возвращает непрозрачную структуру данных &lt;code&gt;children&lt;/code&gt; элементов в виде плоского массива с ключами, назначенными каждому дочернему элементу. Полезно, если вы хотите управлять коллекциями дочерних элементов в методах рендеринга, особенно если вы хотите изменить порядок или нарезать &lt;code&gt;this.props.children&lt;/code&gt; перед его передачей.</target>
        </trans-unit>
        <trans-unit id="4fdadee436b13fdfda743f94c2cfe940b695fe60" translate="yes" xml:space="preserve">
          <source>Returns the root &amp;ldquo;test instance&amp;rdquo; object that is useful for making assertions about specific nodes in the tree. You can use it to find other &amp;ldquo;test instances&amp;rdquo; deeper below.</source>
          <target state="translated">Возвращает корневой объект &amp;laquo;тестового экземпляра&amp;raquo;, который полезен для утверждений о конкретных узлах в дереве. Вы можете использовать его, чтобы глубже найти другие &amp;laquo;тестовые примеры&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5a38b55153cd2060423a41d78bde79f2b8e20191" translate="yes" xml:space="preserve">
          <source>Returns the total number of components in &lt;code&gt;children&lt;/code&gt;, equal to the number of times that a callback passed to &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;forEach&lt;/code&gt; would be invoked.</source>
          <target state="translated">Возвращает общее количество компонентов в &lt;code&gt;children&lt;/code&gt; элементах , равное количеству вызовов обратного вызова, переданных в &lt;code&gt;map&lt;/code&gt; или &lt;code&gt;forEach&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4aeaf8edb1adb3ef0d49248b4bb93fa627e27381" translate="yes" xml:space="preserve">
          <source>Reviewing the Changes</source>
          <target state="translated">Обзор изменений</target>
        </trans-unit>
        <trans-unit id="cee656e4e4fb4012f85e12695536c23a5e0e62c3" translate="yes" xml:space="preserve">
          <source>Rollup</source>
          <target state="translated">Rollup</target>
        </trans-unit>
        <trans-unit id="74d0a40665676a538ac8d7c46b8e150fe7235473" translate="yes" xml:space="preserve">
          <source>Route-based code splitting</source>
          <target state="translated">Разделение кода маршрута</target>
        </trans-unit>
        <trans-unit id="60d643b40f21ca2b9a8a2512b3ba9f597aab6291" translate="yes" xml:space="preserve">
          <source>Rules of Hooks</source>
          <target state="translated">Правила крючков</target>
        </trans-unit>
        <trans-unit id="9020d3797b111846dfc58e088bf239a503f003ec" translate="yes" xml:space="preserve">
          <source>Run JSX Preprocessor</source>
          <target state="translated">Запустить JSX препроцессор</target>
        </trans-unit>
        <trans-unit id="e0f8daf0577d98a996bfa8ec0c41df7d50af891c" translate="yes" xml:space="preserve">
          <source>Run your test suite against the updated packages.</source>
          <target state="translated">Запустите ваш набор тестов против обновленных пакетов.</target>
        </trans-unit>
        <trans-unit id="0827761783f753ff9b40994c31529959784a8de2" translate="yes" xml:space="preserve">
          <source>Running Flow</source>
          <target state="translated">Бегущий поток</target>
        </trans-unit>
        <trans-unit id="fc77263186fd8066db7ad56b10769297381f425f" translate="yes" xml:space="preserve">
          <source>Running TypeScript</source>
          <target state="translated">Выполняемый TypeScript</target>
        </trans-unit>
        <trans-unit id="98df08dc14cf2fe8409704906e8ba7f061915ee5" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;, but is used to hydrate a container whose HTML contents were rendered by &lt;a href=&quot;react-dom-server&quot;&gt;&lt;code&gt;ReactDOMServer&lt;/code&gt;&lt;/a&gt;. React will attempt to attach event listeners to the existing markup.</source>
          <target state="translated">То же, что и &lt;a href=&quot;#render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt; , но используется для гидратации контейнера, HTML-содержимое которого было отрисовано &lt;a href=&quot;react-dom-server&quot;&gt; &lt;code&gt;ReactDOMServer&lt;/code&gt; &lt;/a&gt; . React попытается прикрепить прослушиватели событий к существующей разметке.</target>
        </trans-unit>
        <trans-unit id="f129cfc1e70fca4be604a579a5f801302cd6ac8e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#scryrenderedcomponentswithtype&quot;&gt;&lt;code&gt;scryRenderedComponentsWithType()&lt;/code&gt;&lt;/a&gt; but expects there to be one result and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">То же, что и &lt;a href=&quot;#scryrenderedcomponentswithtype&quot;&gt; &lt;code&gt;scryRenderedComponentsWithType()&lt;/code&gt; &lt;/a&gt; но ожидает, что будет один результат, и возвращает этот один результат, или выдает исключение, если есть любое другое количество совпадений, кроме одного.</target>
        </trans-unit>
        <trans-unit id="a4ebff257960955bf717b48cfa34669ee1fa3976" translate="yes" xml:space="preserve">
          <source>Scaling to many files and components.</source>
          <target state="translated">Масштабирование до многих файлов и компонентов.</target>
        </trans-unit>
        <trans-unit id="9a78372a71733c0c9188bac3d792afa287fb2eda" translate="yes" xml:space="preserve">
          <source>Screen readers</source>
          <target state="translated">Экранные считыватели</target>
        </trans-unit>
        <trans-unit id="b61bfcb18d2395a6da3e919d474b496e6bf967ac" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot;&gt;this visualization&lt;/a&gt; for a comparison of &lt;code&gt;throttle&lt;/code&gt; and &lt;code&gt;debounce&lt;/code&gt; functions.</source>
          <target state="translated">См. &lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot;&gt;Эту визуализацию&lt;/a&gt; для сравнения функций &lt;code&gt;throttle&lt;/code&gt; и &lt;code&gt;debounce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7cb44d447dbdc4f2ebff6dfd7717cd653ac4777" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;react-without-jsx&quot;&gt;Using React without JSX&lt;/a&gt; for more information.</source>
          <target state="translated">См. &lt;a href=&quot;react-without-jsx&quot;&gt;Использование React без JSX&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d32e26b0425e2167e0dcb6fdf91a985d64bf28a6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;state-and-lifecycle&quot;&gt;State and Lifecycle&lt;/a&gt; for more information about the state.</source>
          <target state="translated">См. &lt;a href=&quot;state-and-lifecycle&quot;&gt;Состояние и Жизненный цикл&lt;/a&gt; для получения дополнительной информации о состоянии.</target>
        </trans-unit>
        <trans-unit id="85a5ceb78c2280eeda3b846f0acb9cd42d788db2" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;the recommended pattern for derived state&lt;/a&gt;.</source>
          <target state="translated">См. Также &lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;рекомендуемый шаблон для производного состояния&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a01530646c79b2f55199eeb7b47f0556cdd706ac" translate="yes" xml:space="preserve">
          <source>See below for how to fix this problem.</source>
          <target state="translated">Смотрите ниже,как решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="1693e8fef7af337e4a3ee1564391e1db17535c9f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;react-component&quot;&gt;React.Component API Reference&lt;/a&gt; for a list of methods and properties related to the base &lt;code&gt;React.Component&lt;/code&gt; class.</source>
          <target state="translated">См. &lt;a href=&quot;react-component&quot;&gt;Справочник&lt;/a&gt; по API React.Component для получения списка методов и свойств, связанных с базовым классом &lt;code&gt;React.Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b57f0fefc1bf09d35ad975ad4ca5e7a0022756a" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/BwWzwm&quot;&gt;Thinking In React: Step 2&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">См. Статью &amp;laquo;Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/BwWzwm&quot;&gt;Thinking In React: Step 2&amp;raquo;&lt;/a&gt; на &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="889e869dc48285461d9781e138af203334338e0d" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/LzWZvb&quot;&gt;Thinking In React: Step 5&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">См. Статью &amp;laquo;Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/LzWZvb&quot;&gt;Thinking In React: Step 5&amp;raquo;&lt;/a&gt; на &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b9f4e6141331c9cdb4f88c27dd7d6b936edcd8e" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/qPrNQZ&quot;&gt;Thinking In React: Step 4&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">См. Статью &amp;laquo;Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/qPrNQZ&quot;&gt;Thinking In React: Step 4&amp;raquo;&lt;/a&gt; на &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e91150ff591242b615b363e43cadf66bc003b974" translate="yes" xml:space="preserve">
          <source>Selection Events</source>
          <target state="translated">Отборочные мероприятия</target>
        </trans-unit>
        <trans-unit id="337b6de00774331dfea10bf7602f57a929bd0481" translate="yes" xml:space="preserve">
          <source>Selective Hydration</source>
          <target state="translated">Селективная гидратация</target>
        </trans-unit>
        <trans-unit id="7c55bcc8e6eca62fa53850720b0e3bfdb3df096a" translate="yes" xml:space="preserve">
          <source>Semantic HTML</source>
          <target state="translated">семантический HTML</target>
        </trans-unit>
        <trans-unit id="b2058039eabd80a65369d8f9cda9fc120b4c0fed" translate="yes" xml:space="preserve">
          <source>Semantic HTML is the foundation of accessibility in a web application. Using the various HTML elements to reinforce the meaning of information in our websites will often give us accessibility for free.</source>
          <target state="translated">Семантический HTML является основой доступности в веб-приложении.Использование различных элементов HTML для усиления смысла информации на наших веб-сайтах часто дает нам доступ к ней бесплатно.</target>
        </trans-unit>
        <trans-unit id="551eb6c2699adf574c58f34b218b75ea8a444ba2" translate="yes" xml:space="preserve">
          <source>Separating independent state variables also has another benefit. It makes it easy to later extract some related logic into a custom Hook, for example:</source>
          <target state="translated">Разделение независимых переменных состояния также имеет еще одно преимущество.Это облегчает последующее извлечение некоторой связанной логики,например,в пользовательский крюк:</target>
        </trans-unit>
        <trans-unit id="ab5ab1acf5db0758245097e8fa3ad6f910f353a0" translate="yes" xml:space="preserve">
          <source>Server side rendering</source>
          <target state="translated">Рендеринг серверной стороны</target>
        </trans-unit>
        <trans-unit id="aa8d26b865d79b0e63b8bfd0b9391b4237522018" translate="yes" xml:space="preserve">
          <source>Server-only. This API is not available in the browser.</source>
          <target state="translated">Только для сервера.Этот API недоступен в браузере.</target>
        </trans-unit>
        <trans-unit id="21878b65dc5eb634bcd11071915a81b9ce37484e" translate="yes" xml:space="preserve">
          <source>Set the document &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; to correctly describe the current page content as this ensures that the user remains aware of the current page context:</source>
          <target state="translated">Задайте для документа &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; правильное описание содержимого текущей страницы, так как это гарантирует, что пользователь будет знать текущий контекст страницы:</target>
        </trans-unit>
        <trans-unit id="32b0183325e39fb8a7bae93ef8b271742e8892b1" translate="yes" xml:space="preserve">
          <source>Set up a cron job using your preferred continuous integration platform. Cron jobs are supported by both &lt;a href=&quot;https://circleci.com/docs/2.0/triggers/#scheduled-builds&quot;&gt;CircleCI&lt;/a&gt; and &lt;a href=&quot;https://docs.travis-ci.com/user/cron-jobs/&quot;&gt;Travis CI&lt;/a&gt;.</source>
          <target state="translated">Настройте задание cron, используя предпочитаемую платформу непрерывной интеграции. Задания Cron поддерживаются как &lt;a href=&quot;https://circleci.com/docs/2.0/triggers/#scheduled-builds&quot;&gt;CircleCI, так&lt;/a&gt; и &lt;a href=&quot;https://docs.travis-ci.com/user/cron-jobs/&quot;&gt;Travis CI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca49bc3bc95dc20864ef73e70622bcc8d41e81bb" translate="yes" xml:space="preserve">
          <source>Setting the Initial State</source>
          <target state="translated">Установка начального состояния</target>
        </trans-unit>
        <trans-unit id="418beebb985e8d40774763fdd4f9e8a6047b5b90" translate="yes" xml:space="preserve">
          <source>Setting the document title</source>
          <target state="translated">Установка названия документа</target>
        </trans-unit>
        <trans-unit id="fac5905f3c39f20c6f85ca274a70117415678188" translate="yes" xml:space="preserve">
          <source>Setting the language</source>
          <target state="translated">Настройка языка</target>
        </trans-unit>
        <trans-unit id="c08c4a1087611b4f8dc1ce3b9d6eab6afb735be4" translate="yes" xml:space="preserve">
          <source>Setup/Teardown</source>
          <target state="translated">Setup/Teardown</target>
        </trans-unit>
        <trans-unit id="1a12bbc273b9d327eac0e2f46ee90996baa545d4" translate="yes" xml:space="preserve">
          <source>Shallow Renderer</source>
          <target state="translated">мелкий рендер</target>
        </trans-unit>
        <trans-unit id="157334ad7585fe71fa4ab72dc1138a4016d37634" translate="yes" xml:space="preserve">
          <source>Shallow testing currently has some limitations, namely not supporting refs.</source>
          <target state="translated">Неглубокое тестирование в настоящее время имеет некоторые ограничения,а именно,не поддерживает ссылки.</target>
        </trans-unit>
        <trans-unit id="61717f0f4104f3c6b59d2620027283eb267d0f6f" translate="yes" xml:space="preserve">
          <source>Short Syntax</source>
          <target state="translated">Короткий синтаксис</target>
        </trans-unit>
        <trans-unit id="d78971d67c66eff9e3aca079ae91a776c3dbebcf" translate="yes" xml:space="preserve">
          <source>Should I use Hooks, classes, or a mix of both?</source>
          <target state="translated">Мне использовать крючки,классы или сочетание и того,и другого?</target>
        </trans-unit>
        <trans-unit id="65ba853a7020f20726c91f50244f39620f835b31" translate="yes" xml:space="preserve">
          <source>Should I use a state management library like Redux or MobX?</source>
          <target state="translated">Должен ли я использовать государственную библиотеку управления,такую как Redux или MobX?</target>
        </trans-unit>
        <trans-unit id="2eea49ef9ef41333d4d180d43ca9ea2c23559f87" translate="yes" xml:space="preserve">
          <source>Should I use one or many state variables?</source>
          <target state="translated">Должен ли я использовать одну или несколько переменных состояния?</target>
        </trans-unit>
        <trans-unit id="9e6a9215ce35f846b17b522ab097d2abb82a7869" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#rendertonodestream&quot;&gt;&lt;code&gt;renderToNodeStream&lt;/code&gt;&lt;/a&gt;, except this doesn&amp;rsquo;t create extra DOM attributes that React uses internally, such as &lt;code&gt;data-reactroot&lt;/code&gt;. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save some bytes.</source>
          <target state="translated">Подобно &lt;a href=&quot;#rendertonodestream&quot;&gt; &lt;code&gt;renderToNodeStream&lt;/code&gt; &lt;/a&gt; , за исключением того, что он не создает дополнительных атрибутов DOM, которые React использует для внутренних целей, таких как &lt;code&gt;data-reactroot&lt;/code&gt; . Это полезно, если вы хотите использовать React в качестве простого генератора статических страниц, так как удаление дополнительных атрибутов может сэкономить несколько байтов.</target>
        </trans-unit>
        <trans-unit id="3608f05da13ebf98cb83134331188e8ec9e99c3e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;renderToString&lt;/code&gt;&lt;/a&gt;, except this doesn&amp;rsquo;t create extra DOM attributes that React uses internally, such as &lt;code&gt;data-reactroot&lt;/code&gt;. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save some bytes.</source>
          <target state="translated">Подобно &lt;a href=&quot;#rendertostring&quot;&gt; &lt;code&gt;renderToString&lt;/code&gt; &lt;/a&gt; , за исключением того, что он не создает дополнительных атрибутов DOM, которые React использует для внутренних целей, таких как &lt;code&gt;data-reactroot&lt;/code&gt; . Это полезно, если вы хотите использовать React в качестве простого генератора статических страниц, так как удаление дополнительных атрибутов может сэкономить несколько байтов.</target>
        </trans-unit>
        <trans-unit id="90d668391f22451830d3dcf0d685e789289cf850" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;act()&lt;/code&gt; helper from &lt;code&gt;react-dom/test-utils&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;TestRenderer.act&lt;/code&gt; prepares a component for assertions. Use this version of &lt;code&gt;act()&lt;/code&gt; to wrap calls to &lt;code&gt;TestRenderer.create&lt;/code&gt; and &lt;code&gt;testRenderer.update&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;a href=&quot;test-utils#act&quot;&gt;помощнику &lt;/a&gt; &lt;code&gt;act()&lt;/code&gt; из &lt;code&gt;react-dom/test-utils&lt;/code&gt; &lt;code&gt;TestRenderer.act&lt;/code&gt; -dom / test-utils , TestRenderer.act подготавливает компонент для утверждений. Используйте эту версию &lt;code&gt;act()&lt;/code&gt; чтобы обернуть вызовы &lt;code&gt;TestRenderer.create&lt;/code&gt; и &lt;code&gt;testRenderer.update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f95b4050bee5ae0b356d207e738904d2352b8c01" translate="yes" xml:space="preserve">
          <source>Similarly, all SVG attributes are fully supported:</source>
          <target state="translated">Аналогично,все атрибуты SVG полностью поддерживаются:</target>
        </trans-unit>
        <trans-unit id="ac994655a077627f0a00237edd40be91d12515d2" translate="yes" xml:space="preserve">
          <source>Similarly, we know from research that interactions like hover and text input need to be handled within a very short period of time, while clicks and page transitions can wait a little longer without feeling laggy. The different &amp;ldquo;priorities&amp;rdquo; that Concurrent Mode uses internally roughly correspond to the interaction categories in the human perception research.</source>
          <target state="translated">Точно так же мы знаем из исследований, что такие взаимодействия, как наведение курсора и ввод текста, необходимо обрабатывать в течение очень короткого периода времени, в то время как клики и переходы между страницами могут подождать немного дольше, не чувствуя задержки. Различные &amp;laquo;приоритеты&amp;raquo;, которые используются в Concurrent Mode внутри, примерно соответствуют категориям взаимодействия в исследовании человеческого восприятия.</target>
        </trans-unit>
        <trans-unit id="95c6045668485e434001bbb400904f65d6473b52" translate="yes" xml:space="preserve">
          <source>Simulate</source>
          <target state="translated">Simulate</target>
        </trans-unit>
        <trans-unit id="cdbbf7631367f8cecedfefc8e66eb086c7762a50" translate="yes" xml:space="preserve">
          <source>Simulate an event dispatch on a DOM node with optional &lt;code&gt;eventData&lt;/code&gt; event data.</source>
          <target state="translated">Имитируйте отправку события на узле DOM с дополнительными &lt;code&gt;eventData&lt;/code&gt; события eventData .</target>
        </trans-unit>
        <trans-unit id="7a90574fe221159516cab518b7b70d81b6f6d291" translate="yes" xml:space="preserve">
          <source>Since &amp;ldquo;virtual DOM&amp;rdquo; is more of a pattern than a specific technology, people sometimes say it to mean different things. In React world, the term &amp;ldquo;virtual DOM&amp;rdquo; is usually associated with &lt;a href=&quot;rendering-elements&quot;&gt;React elements&lt;/a&gt; since they are the objects representing the user interface. React, however, also uses internal objects called &amp;ldquo;fibers&amp;rdquo; to hold additional information about the component tree. They may also be considered a part of &amp;ldquo;virtual DOM&amp;rdquo; implementation in React.</source>
          <target state="translated">Поскольку &amp;laquo;виртуальный DOM&amp;raquo; - это скорее шаблон, чем конкретная технология, люди иногда говорят, что это означает разные вещи. В мире React термин &amp;laquo;виртуальная модель DOM&amp;raquo; обычно ассоциируется с &lt;a href=&quot;rendering-elements&quot;&gt;элементами React,&lt;/a&gt; поскольку они представляют собой объекты, представляющие пользовательский интерфейс. Однако React также использует внутренние объекты, называемые &amp;laquo;волокнами&amp;raquo;, для хранения дополнительной информации о дереве компонентов. Их также можно рассматривать как часть реализации &amp;laquo;виртуальной DOM&amp;raquo; в React.</target>
        </trans-unit>
        <trans-unit id="4830b2d00e988292620868e08773981b63e3a3f0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;for&lt;/code&gt; is a reserved word in JavaScript, React elements use &lt;code&gt;htmlFor&lt;/code&gt; instead.</source>
          <target state="translated">Поскольку &lt;code&gt;for&lt;/code&gt; - зарезервированное слово в JavaScript, элементы &lt;code&gt;htmlFor&lt;/code&gt; вместо этого используют htmlFor .</target>
        </trans-unit>
        <trans-unit id="c096576bbc5548a29f7624ed231f5f3700e9858e" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;false&lt;/code&gt; for the subtree rooted at C2, React did not attempt to render C2, and thus didn&amp;rsquo;t even have to invoke &lt;code&gt;shouldComponentUpdate&lt;/code&gt; on C4 and C5.</source>
          <target state="translated">Поскольку &lt;code&gt;shouldComponentUpdate&lt;/code&gt; вернул &lt;code&gt;false&lt;/code&gt; для поддерева с корнем C2, React не пытался визуализировать C2, и поэтому даже не нужно было вызывать &lt;code&gt;shouldComponentUpdate&lt;/code&gt; на C4 и C5.</target>
        </trans-unit>
        <trans-unit id="fa0676e6e4f1be773446c673e249d40dd484a093" translate="yes" xml:space="preserve">
          <source>Since Hooks are functions, we can pass information between them.</source>
          <target state="translated">Поскольку Hooks-это функции,мы можем передавать информацию между ними.</target>
        </trans-unit>
        <trans-unit id="ce78c3b89392f8fd00349533b1a860c5b146a75c" translate="yes" xml:space="preserve">
          <source>Since JSX compiles into calls to &lt;code&gt;React.createElement&lt;/code&gt;, the &lt;code&gt;React&lt;/code&gt; library must also always be in scope from your JSX code.</source>
          <target state="translated">Поскольку JSX компилируется в вызовы &lt;code&gt;React.createElement&lt;/code&gt; , библиотека &lt;code&gt;React&lt;/code&gt; также всегда должна находиться в области видимости вашего JSX-кода.</target>
        </trans-unit>
        <trans-unit id="582c0c532f56fb3bc564df7ce904fded5bbd449f" translate="yes" xml:space="preserve">
          <source>Since JSX is closer to JavaScript than to HTML, React DOM uses &lt;code&gt;camelCase&lt;/code&gt; property naming convention instead of HTML attribute names.</source>
          <target state="translated">Поскольку JSX ближе к JavaScript, чем к HTML, React DOM использует &lt;code&gt;camelCase&lt;/code&gt; об именах свойств camelCase вместо имен атрибутов HTML.</target>
        </trans-unit>
        <trans-unit id="a5465180db9678022404188e56a14dedb56e8c77" translate="yes" xml:space="preserve">
          <source>Since an uncontrolled component keeps the source of truth in the DOM, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can also be slightly less code if you want to be quick and dirty. Otherwise, you should usually use controlled components.</source>
          <target state="translated">Так как неконтролируемый компонент хранит источник истины в DOM,иногда при использовании неконтролируемых компонентов проще интегрировать реактивный и не реактивный код.Также может быть немного меньше кода,если вы хотите быть быстрым и грязным.В противном случае,обычно следует использовать контролируемые компоненты.</target>
        </trans-unit>
        <trans-unit id="12802519d13596acb64db3728385146466f1c0c6" translate="yes" xml:space="preserve">
          <source>Since components are the basic unit of code reuse in React, let&amp;rsquo;s try refactoring the code a bit to use a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component that encapsulates the behavior we need to reuse elsewhere.</source>
          <target state="translated">Поскольку компоненты являются основной единицей повторного использования кода в React, давайте попробуем немного реорганизовать код, чтобы использовать компонент &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; , который инкапсулирует поведение, которое нам нужно повторно использовать в другом месте.</target>
        </trans-unit>
        <trans-unit id="7d149476874665e632f5d09368dfec9b329e5fb0" translate="yes" xml:space="preserve">
          <source>Since object refs were largely added as a replacement for string refs, strict mode now warns about usage of string refs.</source>
          <target state="translated">Так как ссылки на объекты в основном добавлялись как замена ссылок на строки,строгий режим теперь предупреждает об использовании ссылок на строки.</target>
        </trans-unit>
        <trans-unit id="945a3eb7a113afe7fb345d5867e2f0417b7c4d31" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;value&lt;/code&gt; attribute is set on our form element, the displayed value will always be &lt;code&gt;this.state.value&lt;/code&gt;, making the React state the source of truth. Since &lt;code&gt;handleChange&lt;/code&gt; runs on every keystroke to update the React state, the displayed value will update as the user types.</source>
          <target state="translated">Поскольку атрибут &lt;code&gt;value&lt;/code&gt; установлен в нашем элементе формы, отображаемое значение всегда будет &lt;code&gt;this.state.value&lt;/code&gt; , что делает состояние React источником истины. Поскольку &lt;code&gt;handleChange&lt;/code&gt; запускается при каждом нажатии клавиши для обновления состояния React, отображаемое значение будет обновляться по мере ввода пользователем.</target>
        </trans-unit>
        <trans-unit id="65dca83b0699ba95c122c68674390a7799fe42a9" translate="yes" xml:space="preserve">
          <source>Since this technique is a little unusual, you&amp;rsquo;ll probably want to explicitly state that &lt;code&gt;children&lt;/code&gt; should be a function in your &lt;code&gt;propTypes&lt;/code&gt; when designing an API like this.</source>
          <target state="translated">Поскольку этот метод немного необычен, вы, вероятно, захотите явно указать, что &lt;code&gt;children&lt;/code&gt; &lt;code&gt;propTypes&lt;/code&gt; должны быть функцией в ваших propTypes при разработке такого API.</target>
        </trans-unit>
        <trans-unit id="b258100f25369e4ae0ce97a3b2cb85cb2dfc0fe6" translate="yes" xml:space="preserve">
          <source>Since you&amp;rsquo;re often displaying a JSON data model to a user, you&amp;rsquo;ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely. That&amp;rsquo;s because UI and data models tend to adhere to the same &lt;em&gt;information architecture&lt;/em&gt;. Separate your UI into components, where each component matches one piece of your data model.</source>
          <target state="translated">Поскольку вы часто показываете пользователю модель данных JSON, вы обнаружите, что если ваша модель была построена правильно, ваш пользовательский интерфейс (и, следовательно, ваша структура компонентов) будет хорошо отображаться. Это потому, что UI и модели данных, как правило, придерживаются одной и той же &lt;em&gt;информационной архитектуры&lt;/em&gt; . Разделите свой пользовательский интерфейс на компоненты, каждый из которых соответствует одной части вашей модели данных.</target>
        </trans-unit>
        <trans-unit id="625d8d80af7bbcdfa81222888dc91ae1c67047a5" translate="yes" xml:space="preserve">
          <source>Single-File Builds</source>
          <target state="translated">Однофайловые сборки</target>
        </trans-unit>
        <trans-unit id="b79ccec4e08c14b21b7dbe1bf30a724c5d594935" translate="yes" xml:space="preserve">
          <source>Single-page Application</source>
          <target state="translated">Одностраничное применение</target>
        </trans-unit>
        <trans-unit id="5e268b8fb13c4275436f6fec47445b6c6a370b4f" translate="yes" xml:space="preserve">
          <source>Skiplinks or Skip Navigation Links are hidden navigation links that only become visible when keyboard users interact with the page. They are very easy to implement with internal page anchors and some styling:</source>
          <target state="translated">Пропускные ссылки или Пропустить навигационные ссылки-это скрытые навигационные ссылки,которые становятся видимыми только при взаимодействии пользователей клавиатуры со страницей.Их очень легко реализовать с помощью внутренних якорей страницы и некоторого стиля:</target>
        </trans-unit>
        <trans-unit id="cdf5126870db570bc7f1db0845f8a4e0d4d3ae76" translate="yes" xml:space="preserve">
          <source>Snapshot Testing</source>
          <target state="translated">Тестирование снимков</target>
        </trans-unit>
        <trans-unit id="540d1ef8fe38fe16e9bd6ac54276ab966b7a4f51" translate="yes" xml:space="preserve">
          <source>So What About Inheritance?</source>
          <target state="translated">Так что насчет наследства?</target>
        </trans-unit>
        <trans-unit id="be184e3655c9a842843034adac922d2b6b3bcf62" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve built an app that renders correctly as a function of props and state flowing down the hierarchy. Now it&amp;rsquo;s time to support data flowing the other way: the form components deep in the hierarchy need to update the state in &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="translated">До сих пор мы создали приложение, которое правильно отображается в зависимости от свойств и состояния, перемещающихся по иерархии. Теперь пришло время поддержать поток данных другим путем: компоненты формы глубоко в иерархии должны обновить состояние в &lt;code&gt;FilterableProductTable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d36706ca32133596b9127ed5d816900d1e29cf2" translate="yes" xml:space="preserve">
          <source>So finally, our state is:</source>
          <target state="translated">Так что,наконец-то,наше государство:</target>
        </trans-unit>
        <trans-unit id="41a2c2d31192f2035b56a37240597cc8d1ce2f0e" translate="yes" xml:space="preserve">
          <source>So how does React know which state corresponds to which &lt;code&gt;useState&lt;/code&gt; call? The answer is that &lt;strong&gt;React relies on the order in which Hooks are called&lt;/strong&gt;. Our example works because the order of the Hook calls is the same on every render:</source>
          <target state="translated">Итак, как React узнает, какое состояние соответствует &lt;code&gt;useState&lt;/code&gt; вызову useState ? Ответ заключается в том, что &lt;strong&gt;React зависит от порядка, в котором вызываются хуки&lt;/strong&gt; . Наш пример работает, потому что порядок вызовов Hook одинаков для каждого рендера:</target>
        </trans-unit>
        <trans-unit id="91956b86d2b226dc60b40a10c6064c0879b25281" translate="yes" xml:space="preserve">
          <source>So the correct fix is to put &lt;code&gt;setQuery&lt;/code&gt; (which doesn&amp;rsquo;t suspend) &lt;em&gt;outside&lt;/em&gt; the transition, but &lt;code&gt;setResource&lt;/code&gt; (which will suspend) &lt;em&gt;inside&lt;/em&gt; of it.</source>
          <target state="translated">Итак, правильное исправление - поместить &lt;code&gt;setQuery&lt;/code&gt; (который не приостанавливается) &lt;em&gt;вне&lt;/em&gt; перехода, но &lt;code&gt;setResource&lt;/code&gt; (который будет приостановлен) &lt;em&gt;внутри&lt;/em&gt; него.</target>
        </trans-unit>
        <trans-unit id="11bcfd3ea24e7b454ce05dfb87c9d0158ac74b60" translate="yes" xml:space="preserve">
          <source>So the following jQuery implementation&amp;hellip;</source>
          <target state="translated">Итак, следующая реализация jQuery&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="bf1cb757dd15a9b82f28af071a783eda7ce755d2" translate="yes" xml:space="preserve">
          <source>So using a render prop makes it possible to use either pattern.</source>
          <target state="translated">Таким образом,использование рендерингового реквизита позволяет использовать любой из шаблонов.</target>
        </trans-unit>
        <trans-unit id="b8bee9b25a62fc9052ff4b48a5eeea612a72ba58" translate="yes" xml:space="preserve">
          <source>So what if we could write a &lt;code&gt;useReducer&lt;/code&gt; Hook that lets us manage the &lt;em&gt;local&lt;/em&gt; state of our component with a reducer? A simplified version of it might look like this:</source>
          <target state="translated">Что, если бы мы могли написать &lt;code&gt;useReducer&lt;/code&gt; который позволяет нам управлять &lt;em&gt;локальным&lt;/em&gt; состоянием нашего компонента с помощью редуктора? Упрощенная версия может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="4363bcb8572f01d639e93f80d7731d5945c5a5b1" translate="yes" xml:space="preserve">
          <source>So what&amp;rsquo;s the point of Suspense? There are a few ways we can answer this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06b3c258f542a990c77a5fae1fe50270e36d2d1" translate="yes" xml:space="preserve">
          <source>So what&amp;rsquo;s the point of Suspense? There&amp;rsquo;s a few ways we can answer this:</source>
          <target state="translated">Так в чем же смысл саспенса? На это можно ответить несколькими способами:</target>
        </trans-unit>
        <trans-unit id="c7658e82394e9389e52b89bd4d2384e335440e9a" translate="yes" xml:space="preserve">
          <source>So, how can Hooks solve this problem? Just like &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;you can use the &lt;em&gt;State&lt;/em&gt; Hook more than once&lt;/a&gt;, you can also use several effects. This lets us separate unrelated logic into different effects:</source>
          <target state="translated">Итак, как хуки могут решить эту проблему? Так же, как &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;вы можете использовать &lt;em&gt;State&lt;/em&gt; Hook более одного раза&lt;/a&gt; , вы также можете использовать несколько эффектов. Это позволяет нам разделить несвязанную логику на разные эффекты:</target>
        </trans-unit>
        <trans-unit id="8d02b7e415d9e8d63052f83b346ef42769efa71e" translate="yes" xml:space="preserve">
          <source>Solving Race Conditions with Suspense</source>
          <target state="translated">Урегулирование условий гонки с подвесом</target>
        </trans-unit>
        <trans-unit id="5dcc864f338464da25786ad58214ee40c24cb4fd" translate="yes" xml:space="preserve">
          <source>Some components don&amp;rsquo;t know their children ahead of time. This is especially common for components like &lt;code&gt;Sidebar&lt;/code&gt; or &lt;code&gt;Dialog&lt;/code&gt; that represent generic &amp;ldquo;boxes&amp;rdquo;.</source>
          <target state="translated">Некоторые компоненты не знают своих детей заранее. Это особенно характерно для таких компонентов, как &lt;code&gt;Sidebar&lt;/code&gt; или &lt;code&gt;Dialog&lt;/code&gt; которые представляют собой общие &amp;laquo;блоки&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="96871b8dd7b23918e375f655cee67524e2b12086" translate="yes" xml:space="preserve">
          <source>Some components have dependencies for modules that may not work well in test environments, or aren&amp;rsquo;t essential to our tests. It can be useful to selectively mock these modules out with suitable replacements &lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;.</source>
          <target state="translated">Некоторые компоненты имеют зависимости для модулей, которые могут плохо работать в тестовых средах или не являются необходимыми для наших тестов. Может быть полезно выборочно имитировать эти модули с подходящими заменами &lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;&lt;small&gt;(пример)&lt;/small&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="614c13a8b04ce94e3f4ed5ff071c3bd90dde1618" translate="yes" xml:space="preserve">
          <source>Some examples in the documentation use &lt;code&gt;style&lt;/code&gt; for convenience, but &lt;strong&gt;using the &lt;code&gt;style&lt;/code&gt; attribute as the primary means of styling elements is generally not recommended.&lt;/strong&gt; In most cases, &lt;a href=&quot;#classname&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt; should be used to reference classes defined in an external CSS stylesheet. &lt;code&gt;style&lt;/code&gt; is most often used in React applications to add dynamically-computed styles at render time. See also &lt;a href=&quot;faq-styling&quot;&gt;FAQ: Styling and CSS&lt;/a&gt;.</source>
          <target state="translated">В некоторых примерах документации &lt;code&gt;style&lt;/code&gt; используется для удобства, но &lt;strong&gt;использование атрибута &lt;code&gt;style&lt;/code&gt; в качестве основного средства стилизации элементов обычно не рекомендуется.&lt;/strong&gt; В большинстве случаев &lt;a href=&quot;#classname&quot;&gt; &lt;code&gt;className&lt;/code&gt; &lt;/a&gt; следует использовать для ссылки на классы, определенные во внешней таблице стилей CSS. &lt;code&gt;style&lt;/code&gt; чаще всего используется в приложениях React для добавления динамически вычисляемых стилей во время рендеринга. См. Также &lt;a href=&quot;faq-styling&quot;&gt;FAQ: стили и CSS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef4f7933de9dfc7491281fed4ffdc03bbfcf3853" translate="yes" xml:space="preserve">
          <source>Some modules might not work well inside a testing environment, or may not be as essential to the test itself. Mocking out these modules with dummy replacements can make it easier to write tests for your own code.</source>
          <target state="translated">Некоторые модули могут плохо работать в тестовой среде,или могут быть не так важны для самого теста.Насмешка над этими модулями с помощью фиктивных замен может облегчить написание тестов для собственного кода.</target>
        </trans-unit>
        <trans-unit id="c4cfa33208dbe4639a0d378dff52c7435fff87fc" translate="yes" xml:space="preserve">
          <source>Some of the DOM attributes supported by React include:</source>
          <target state="translated">Некоторые из атрибутов DOM,поддерживаемых React,включают в себя:</target>
        </trans-unit>
        <trans-unit id="96e5cbe3009d23e8b32e7d37fe1acce8dabd1560" translate="yes" xml:space="preserve">
          <source>Some people also prefer to go further, and separate components into different folders depending on their role in the application. For example, &lt;a href=&quot;http://bradfrost.com/blog/post/atomic-web-design/&quot;&gt;Atomic Design&lt;/a&gt; is a design methodology built on this principle. Remember that it&amp;rsquo;s often more productive to treat such methodologies as helpful examples rather than strict rules to follow.</source>
          <target state="translated">Некоторые люди также предпочитают идти дальше и разделять компоненты по разным папкам в зависимости от их роли в приложении. Например, &lt;a href=&quot;http://bradfrost.com/blog/post/atomic-web-design/&quot;&gt;Atomic Design&lt;/a&gt; - это методология проектирования, построенная на этом принципе. Помните, что зачастую более продуктивно рассматривать такие методологии как полезные примеры, а не как строгие правила, которым нужно следовать.</target>
        </trans-unit>
        <trans-unit id="d096867d249bc9020052a71ba018f7a10b3ca19c" translate="yes" xml:space="preserve">
          <source>Something Missing?</source>
          <target state="translated">Что-то пропало?</target>
        </trans-unit>
        <trans-unit id="80413ba692b4736af61c7baf6819b5bb8236d925" translate="yes" xml:space="preserve">
          <source>Sometimes a parent component needs to set focus to an element in a child component. We can do this by &lt;a href=&quot;refs-and-the-dom#exposing-dom-refs-to-parent-components&quot;&gt;exposing DOM refs to parent components&lt;/a&gt; through a special prop on the child component that forwards the parent&amp;rsquo;s ref to the child&amp;rsquo;s DOM node.</source>
          <target state="translated">Иногда родительскому компоненту необходимо установить фокус на элемент дочернего компонента. Мы можем сделать это, &lt;a href=&quot;refs-and-the-dom#exposing-dom-refs-to-parent-components&quot;&gt;предоставив родительским компонентам ссылки на DOM&lt;/a&gt; через специальную опору дочернего компонента, которая перенаправляет ссылку родительского элемента на дочерний узел DOM.</target>
        </trans-unit>
        <trans-unit id="b43c302a7eeb97d1c3b75a79a6531baafe26b30a" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to define a static method on a React component. For example, Relay containers expose a static method &lt;code&gt;getFragment&lt;/code&gt; to facilitate the composition of GraphQL fragments.</source>
          <target state="translated">Иногда полезно определить статический метод в компоненте React. Например, контейнеры Relay предоставляют статический метод &lt;code&gt;getFragment&lt;/code&gt; для облегчения композиции фрагментов GraphQL.</target>
        </trans-unit>
        <trans-unit id="5d35c9c3f98eb464527bcc5a72fa4944c7139e41" translate="yes" xml:space="preserve">
          <source>Sometimes people find third-party books and video courses more helpful than the official documentation. We maintain &lt;a href=&quot;https://reactjs.org/community/courses.html&quot;&gt;a list of commonly recommended resources&lt;/a&gt;, some of which are free.</source>
          <target state="translated">Иногда люди находят сторонние книги и видеокурсы более полезными, чем официальная документация. Мы ведем &lt;a href=&quot;https://reactjs.org/community/courses.html&quot;&gt;список часто рекомендуемых ресурсов&lt;/a&gt; , некоторые из которых бесплатны.</target>
        </trans-unit>
        <trans-unit id="892625bcde39b047433f6f0e4c2a6c85238cae55" translate="yes" xml:space="preserve">
          <source>Sometimes this results in clearer code, but this style can also be abused. Like in JavaScript, it is up to you to decide whether it is worth extracting a variable for readability. Keep in mind that if the &lt;code&gt;map()&lt;/code&gt; body is too nested, it might be a good time to &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract a component&lt;/a&gt;.</source>
          <target state="translated">Иногда это приводит к более ясному коду, но этим стилем также можно злоупотреблять. Как и в JavaScript, вам решать, стоит ли извлекать переменную для удобства чтения. Имейте в виду, что если тело &lt;code&gt;map()&lt;/code&gt; слишком вложено, возможно, самое время &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;извлечь компонент&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0183ce117e89d5333990aad33e9f21dbd3c8ad5" translate="yes" xml:space="preserve">
          <source>Sometimes very different components may share some common functionality. These are sometimes called &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-cutting_concern&quot;&gt;cross-cutting concerns&lt;/a&gt;. &lt;code&gt;createReactClass&lt;/code&gt; lets you use a legacy &lt;code&gt;mixins&lt;/code&gt; system for that.</source>
          <target state="translated">Иногда очень разные компоненты могут иметь общие функции. Иногда это называют &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-cutting_concern&quot;&gt;сквозными проблемами&lt;/a&gt; . &lt;code&gt;createReactClass&lt;/code&gt; позволяет использовать для этого устаревшую систему &lt;code&gt;mixins&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0df05a3843bbcf9ee66e7ee68ac3c0653e4fec68" translate="yes" xml:space="preserve">
          <source>Sometimes we break HTML semantics when we add &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; elements to our JSX to make our React code work, especially when working with lists (&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;dl&amp;gt;&lt;/code&gt;) and the HTML &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;. In these cases we should rather use &lt;a href=&quot;fragments&quot;&gt;React Fragments&lt;/a&gt; to group together multiple elements.</source>
          <target state="translated">Иногда мы нарушаем семантику HTML, когда добавляем элементы &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; в наш JSX, чтобы наш код React работал, особенно при работе со списками ( &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;dl&amp;gt;&lt;/code&gt; ) и HTML &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; . В этих случаях мы должны использовать &lt;a href=&quot;fragments&quot;&gt;React Fragments&lt;/a&gt; для группировки нескольких элементов.</target>
        </trans-unit>
        <trans-unit id="6e2e5311eb15d9d862c73dbfbe53759a23f39f84" translate="yes" xml:space="preserve">
          <source>Sometimes we think about components as being &amp;ldquo;special cases&amp;rdquo; of other components. For example, we might say that a &lt;code&gt;WelcomeDialog&lt;/code&gt; is a special case of &lt;code&gt;Dialog&lt;/code&gt;.</source>
          <target state="translated">Иногда мы думаем о компонентах как о &amp;laquo;особых случаях&amp;raquo; других компонентов. Например, мы можем сказать, что &lt;code&gt;WelcomeDialog&lt;/code&gt; - это частный случай &lt;code&gt;Dialog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2113ccfe3cef67ecda3109bea67055bdcc179fac" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to &lt;strong&gt;run some additional code after React has updated the DOM.&lt;/strong&gt; Network requests, manual DOM mutations, and logging are common examples of effects that don&amp;rsquo;t require a cleanup. We say that because we can run them and immediately forget about them. Let&amp;rsquo;s compare how classes and Hooks let us express such side effects.</source>
          <target state="translated">Иногда мы хотим &lt;strong&gt;запустить дополнительный код после того, как React обновит DOM. &lt;/strong&gt;Сетевые запросы, ручные мутации DOM и ведение журнала - распространенные примеры эффектов, которые не требуют очистки. Мы говорим так, потому что можем запустить их и сразу же забыть о них. Давайте сравним, как классы и хуки позволяют нам выражать такие побочные эффекты.</target>
        </trans-unit>
        <trans-unit id="657bcb464d6a199b5a3987ac0c1ea4a5d73c44d1" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to reuse some stateful logic between components. Traditionally, there were two popular solutions to this problem: &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; and &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt;. Custom Hooks let you do this, but without adding more components to your tree.</source>
          <target state="translated">Иногда мы хотим повторно использовать логику с отслеживанием состояния между компонентами. Традиционно существовало два популярных решения этой проблемы: &lt;a href=&quot;higher-order-components&quot;&gt;компоненты высшего порядка&lt;/a&gt; и &lt;a href=&quot;render-props&quot;&gt;свойства рендеринга&lt;/a&gt; . Пользовательские хуки позволяют вам делать это, но без добавления дополнительных компонентов в ваше дерево.</target>
        </trans-unit>
        <trans-unit id="351447063fd3690ce16863aa7ac3c07a6ab525f3" translate="yes" xml:space="preserve">
          <source>Sometimes, you may not want to mock timers. For example, maybe you&amp;rsquo;re testing an animation, or interacting with an endpoint that&amp;rsquo;s sensitive to timing (like an API rate limiter). Libraries with timer mocks let you enable and disable them on a per test/suite basis, so you can explicitly choose how these tests would run.</source>
          <target state="translated">Иногда вы можете не захотеть высмеивать таймеры. Например, возможно, вы тестируете анимацию или взаимодействуете с конечной точкой, чувствительной к времени (например, ограничителем скорости API). Библиотеки с имитаторами таймеров позволяют включать и отключать их для каждого теста / набора, поэтому вы можете явно выбирать, как эти тесты будут запускаться.</target>
        </trans-unit>
        <trans-unit id="091ab55337927adfcab6d0cbf58d4ada7ebe5d05" translate="yes" xml:space="preserve">
          <source>Sometimes, your effect may be using state that changes too often. You might be tempted to omit that state from a list of dependencies, but that usually leads to bugs:</source>
          <target state="translated">Иногда вашим эффектом может быть использование состояния,которое меняется слишком часто.У вас может возникнуть соблазн пропустить это состояние из списка зависимостей,но это обычно приводит к ошибкам:</target>
        </trans-unit>
        <trans-unit id="b0f090c0f44aceac36d2c9eb988dd8280d3ee8e3" translate="yes" xml:space="preserve">
          <source>Specialization</source>
          <target state="translated">Specialization</target>
        </trans-unit>
        <trans-unit id="1fa161cc62a9e4ea6aa020d607d68a8963cee67c" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;[count]&lt;/code&gt; as a list of dependencies would fix the bug, but would cause the interval to be reset on every change. Effectively, each &lt;code&gt;setInterval&lt;/code&gt; would get one chance to execute before being cleared (similar to a &lt;code&gt;setTimeout&lt;/code&gt;.) That may not be desirable. To fix this, we can use the &lt;a href=&quot;hooks-reference#functional-updates&quot;&gt;functional update form of &lt;code&gt;setState&lt;/code&gt;&lt;/a&gt;. It lets us specify &lt;em&gt;how&lt;/em&gt; the state needs to change without referencing the &lt;em&gt;current&lt;/em&gt; state:</source>
          <target state="translated">Указание &lt;code&gt;[count]&lt;/code&gt; в качестве списка зависимостей исправит ошибку, но приведет к сбросу интервала при каждом изменении. Фактически, каждый &lt;code&gt;setInterval&lt;/code&gt; получит один шанс выполнить перед очисткой (аналогично &lt;code&gt;setTimeout&lt;/code&gt; ). Это может быть нежелательно. Чтобы исправить это, мы можем использовать &lt;a href=&quot;hooks-reference#functional-updates&quot;&gt;функциональную форму обновления &lt;code&gt;setState&lt;/code&gt; &lt;/a&gt; . Это позволяет нам указать, &lt;em&gt;как&lt;/em&gt; состояние должно измениться, не ссылаясь на &lt;em&gt;текущее&lt;/em&gt; состояние:</target>
        </trans-unit>
        <trans-unit id="9f9a50e2fbfe07712e5925cf722f8b4a41d2e0df" translate="yes" xml:space="preserve">
          <source>Specifying Attributes with JSX</source>
          <target state="translated">Указание атрибутов с помощью JSX</target>
        </trans-unit>
        <trans-unit id="5a158241151d38add28063d1a39efc6a532ed860" translate="yes" xml:space="preserve">
          <source>Specifying Children with JSX</source>
          <target state="translated">Указание детей с JSX</target>
        </trans-unit>
        <trans-unit id="e4fa66e9ea342e16491d74d178d20dc425ce360e" translate="yes" xml:space="preserve">
          <source>Specifying The React Element Type</source>
          <target state="translated">Указание типа элемента реакции</target>
        </trans-unit>
        <trans-unit id="248e5212cad1782449c4a8e8fdc79f7d18ea7441" translate="yes" xml:space="preserve">
          <source>Specifying the initial state</source>
          <target state="translated">Определение исходного состояния</target>
        </trans-unit>
        <trans-unit id="484b72292d9dd5e8ed98a1228281ec72fe6aaebe" translate="yes" xml:space="preserve">
          <source>Specifying the value prop on a &lt;a href=&quot;forms#controlled-components&quot;&gt;controlled component&lt;/a&gt; prevents the user from changing the input unless you desire so. If you&amp;rsquo;ve specified a &lt;code&gt;value&lt;/code&gt; but the input is still editable, you may have accidentally set &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Указание свойства value для &lt;a href=&quot;forms#controlled-components&quot;&gt;управляемого компонента не&lt;/a&gt; позволяет пользователю изменять ввод, если вы этого не пожелаете. Если вы указали &lt;code&gt;value&lt;/code&gt; , но вход по - прежнему доступен для редактирования, вы можете иметь случайно установленное &lt;code&gt;value&lt;/code&gt; для &lt;code&gt;undefined&lt;/code&gt; или &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04a3524370f46bd76ff0ae35ee1a6d4dc7ad661e" translate="yes" xml:space="preserve">
          <source>Splitting High and Low Priority State</source>
          <target state="translated">Разделение Высокого и Низкого Приоритета Государства</target>
        </trans-unit>
        <trans-unit id="7250062690f9f9d303c56e302576ed47dd44bdaf" translate="yes" xml:space="preserve">
          <source>Spread Attributes</source>
          <target state="translated">Распределение атрибутов</target>
        </trans-unit>
        <trans-unit id="efd4ca2d204c1e4616c4e8cf039d050140fdb3ee" translate="yes" xml:space="preserve">
          <source>Spread attributes can be useful but they also make it easy to pass unnecessary props to components that don&amp;rsquo;t care about them or to pass invalid HTML attributes to the DOM. We recommend using this syntax sparingly.</source>
          <target state="translated">Атрибуты распространения могут быть полезны, но они также упрощают передачу ненужных свойств компонентам, которые не заботятся о них, или передачу недопустимых атрибутов HTML в DOM. Мы рекомендуем использовать этот синтаксис с осторожностью.</target>
        </trans-unit>
        <trans-unit id="064bfcfabe6af4f3be4dbea953ea4d27d586523d" translate="yes" xml:space="preserve">
          <source>Standalone Node Package</source>
          <target state="translated">Автономный пакет узлов</target>
        </trans-unit>
        <trans-unit id="5def4534ce22a871405cdf372bebde72db101bdc" translate="yes" xml:space="preserve">
          <source>Standards and Guidelines</source>
          <target state="translated">Стандарты и руководства</target>
        </trans-unit>
        <trans-unit id="cd1bd3ab3b9ae3d1a43994956517d5ee88941549" translate="yes" xml:space="preserve">
          <source>Start Fetching Early</source>
          <target state="translated">Начать забирать рано</target>
        </trans-unit>
        <trans-unit id="711a21abde2479b997c6cb2cae4595727f2a64c8" translate="yes" xml:space="preserve">
          <source>Start With A Mock</source>
          <target state="translated">Начните с насмешки</target>
        </trans-unit>
        <trans-unit id="91177ccaba80c331e7a4c30fc35a6c5a3d541e03" translate="yes" xml:space="preserve">
          <source>Start fetching</source>
          <target state="translated">Начните забирать</target>
        </trans-unit>
        <trans-unit id="8f669e598b328d921b668756a5d615493ee0168c" translate="yes" xml:space="preserve">
          <source>Start rendering</source>
          <target state="translated">Начать рендеринг</target>
        </trans-unit>
        <trans-unit id="a86d8f44e22238201b173b962f6886510a0da088" translate="yes" xml:space="preserve">
          <source>Starting with 16.8.0, React includes a stable implementation of React Hooks for:</source>
          <target state="translated">Начиная с 16.8.0,React включает в себя стабильную реализацию React Hooks for:</target>
        </trans-unit>
        <trans-unit id="92f810f23bdc85140b73e30ea49450509c5bd85c" translate="yes" xml:space="preserve">
          <source>Starting with React 17, the &lt;code&gt;onScroll&lt;/code&gt; event &lt;strong&gt;does not bubble&lt;/strong&gt; in React. This matches the browser behavior and prevents the confusion when a nested scrollable element fires events on a distant parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c688a4bc8cbf6a9e644ceeea91e61be20a88de" translate="yes" xml:space="preserve">
          <source>State Updates May Be Asynchronous</source>
          <target state="translated">Обновления состояния могут быть асинхронными.</target>
        </trans-unit>
        <trans-unit id="88237580e68309e5a5a6557ed798f9117f825c21" translate="yes" xml:space="preserve">
          <source>State Updates are Merged</source>
          <target state="translated">Обновления состояния объединены</target>
        </trans-unit>
        <trans-unit id="a8d6e1e76b0e2efabcf40d1b7270dae7fadac365" translate="yes" xml:space="preserve">
          <source>State and Lifecycle</source>
          <target state="translated">Состояние и жизненный цикл</target>
        </trans-unit>
        <trans-unit id="67d1df931840b49786d4500f55b14d3015fe3f48" translate="yes" xml:space="preserve">
          <source>State and Lifecycle guide</source>
          <target state="translated">Руководство по штату и жизненному циклу</target>
        </trans-unit>
        <trans-unit id="4df972d16c5d19e8d5ddb903b62a89007862e156" translate="yes" xml:space="preserve">
          <source>State is similar to props, but it is private and fully controlled by the component.</source>
          <target state="translated">Государство похоже на реквизит,но оно является частным и полностью контролируется компонентом.</target>
        </trans-unit>
        <trans-unit id="1d1c74f2d06c5f4368c9bc7a2cf5d263cebf3d96" translate="yes" xml:space="preserve">
          <source>State updater functions (the first argument to &lt;code&gt;setState&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d421eaa763efe61aa522fbfca14b10e27b8dcc0" translate="yes" xml:space="preserve">
          <source>State variables and state cells in &lt;a href=&quot;http://displayscript.org/introduction.html&quot;&gt;DisplayScript&lt;/a&gt;.</source>
          <target state="translated">Переменные состояния и ячейки состояния в &lt;a href=&quot;http://displayscript.org/introduction.html&quot;&gt;DisplayScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3878c33013f598bc32c82cf1ead566633a3f208e" translate="yes" xml:space="preserve">
          <source>Static Methods Must Be Copied Over</source>
          <target state="translated">Статические методы должны быть скопированы поверх</target>
        </trans-unit>
        <trans-unit id="bd88cfef69c4e37c1ba575ea9f53e708a1a1232c" translate="yes" xml:space="preserve">
          <source>Static Type Checking</source>
          <target state="translated">Статическая проверка типа</target>
        </trans-unit>
        <trans-unit id="924e72d946f8bfadb7a3147de738b256272c4bf4" translate="yes" xml:space="preserve">
          <source>Static type checkers like &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; identify certain types of problems before you even run your code. They can also improve developer workflow by adding features like auto-completion. For this reason, we recommend using Flow or TypeScript instead of &lt;code&gt;PropTypes&lt;/code&gt; for larger code bases.</source>
          <target state="translated">Средства проверки статических типов, такие как &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; и &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript,&lt;/a&gt; выявляют определенные типы проблем еще до того, как вы запустите свой код. Они также могут улучшить рабочий процесс разработчика, добавив такие функции, как автозаполнение. По этой причине мы рекомендуем использовать Flow или TypeScript вместо &lt;code&gt;PropTypes&lt;/code&gt; для больших баз кода.</target>
        </trans-unit>
        <trans-unit id="a0bd05cb8a239da7ed3487a46c276e0484a9dd10" translate="yes" xml:space="preserve">
          <source>Staying Informed</source>
          <target state="translated">Оставаясь информированным</target>
        </trans-unit>
        <trans-unit id="9feb5d73b7d630e1fa9f796479ee1477109b8dba" translate="yes" xml:space="preserve">
          <source>Step 1: Add a DOM Container to the HTML</source>
          <target state="translated">Шаг 1:Добавление контейнера DOM в HTML</target>
        </trans-unit>
        <trans-unit id="14221e6881613f0cccb7ed29f77307bf69df44a9" translate="yes" xml:space="preserve">
          <source>Step 1: Break The UI Into A Component Hierarchy</source>
          <target state="translated">Шаг 1:Разорвите иерархию компонентов пользовательского интерфейса</target>
        </trans-unit>
        <trans-unit id="f86ff7cc0b24afa445be129e259c884fd0af8b9b" translate="yes" xml:space="preserve">
          <source>Step 2: Add the Script Tags</source>
          <target state="translated">Шаг 2:Добавление тегов сценария</target>
        </trans-unit>
        <trans-unit id="123ca7868e30446f688a7f747df83b53290cef75" translate="yes" xml:space="preserve">
          <source>Step 2: Build A Static Version in React</source>
          <target state="translated">Шаг 2:Построение статической версии в реакции</target>
        </trans-unit>
        <trans-unit id="39ec5061574d18b5de0be9ab6b2b1a042b9c2339" translate="yes" xml:space="preserve">
          <source>Step 3: Create a React Component</source>
          <target state="translated">Шаг 3:Создание реактивного компонента</target>
        </trans-unit>
        <trans-unit id="33a5f37d369f03644215598531ec2c023674c11b" translate="yes" xml:space="preserve">
          <source>Step 3: Identify The Minimal (but complete) Representation Of UI State</source>
          <target state="translated">Шаг 3:Определите минимальное (но полное)представление государства пользовательского интерфейса.</target>
        </trans-unit>
        <trans-unit id="62f65581c960b7670694036d15605d1e79ee3f22" translate="yes" xml:space="preserve">
          <source>Step 4: Identify Where Your State Should Live</source>
          <target state="translated">Шаг 4:Определите,где должно жить ваше государство.</target>
        </trans-unit>
        <trans-unit id="d63ae2a1550f68c81fc498e7a755f439ca787317" translate="yes" xml:space="preserve">
          <source>Step 5: Add Inverse Data Flow</source>
          <target state="translated">Шаг 5:Добавление обратного потока данных</target>
        </trans-unit>
        <trans-unit id="0395deb615c42389e7f7f63e97f88c21bad5e8cb" translate="yes" xml:space="preserve">
          <source>Step-by-Step Guide</source>
          <target state="translated">Пошаговое руководство</target>
        </trans-unit>
        <trans-unit id="ded55f9c4ea8f5cf7b52f527f0d476e47f977212" translate="yes" xml:space="preserve">
          <source>Stop recording.</source>
          <target state="translated">Прекратите запись.</target>
        </trans-unit>
        <trans-unit id="7c183131363f4251f89993f5090afc10d8f0caad" translate="yes" xml:space="preserve">
          <source>Strict Mode</source>
          <target state="translated">Строгий режим</target>
        </trans-unit>
        <trans-unit id="ffd57d06c3bfecbc437452b09e192830e0690661" translate="yes" xml:space="preserve">
          <source>Strict mode can&amp;rsquo;t automatically detect side effects for you, but it can help you spot them by making them a little more deterministic. This is done by intentionally double-invoking the following functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1433029b40a7c8096820012bb4fd0012e00acc4b" translate="yes" xml:space="preserve">
          <source>Strict mode can&amp;rsquo;t automatically detect side effects for you, but it can help you spot them by making them a little more deterministic. This is done by intentionally double-invoking the following methods:</source>
          <target state="translated">Строгий режим не может автоматически обнаруживать побочные эффекты, но он может помочь вам обнаружить их, сделав их более детерминированными. Это делается путем намеренного двойного вызова следующих методов:</target>
        </trans-unit>
        <trans-unit id="0f8563c9f25fde889f1c031be9d1996fb84fdad0" translate="yes" xml:space="preserve">
          <source>Strict mode checks are run in development mode only; &lt;em&gt;they do not impact the production build&lt;/em&gt;.</source>
          <target state="translated">Проверки в строгом режиме выполняются только в режиме разработки; &lt;em&gt;они не влияют на производственную сборку&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="18c909570fe3d2f04f7e3e21101c4ef09a029b7b" translate="yes" xml:space="preserve">
          <source>String Literals</source>
          <target state="translated">Строковые буквы</target>
        </trans-unit>
        <trans-unit id="504651e88e0554e0480e5760d113aa05357364b8" translate="yes" xml:space="preserve">
          <source>String Refs</source>
          <target state="translated">Ссылки на струны</target>
        </trans-unit>
        <trans-unit id="9491d60784f7659ed917ac4823f4059dd50ab9e6" translate="yes" xml:space="preserve">
          <source>Stripping Flow Syntax from the Compiled Code</source>
          <target state="translated">Синтаксис удаления потока из компилированного кода</target>
        </trans-unit>
        <trans-unit id="89d196a4aa8b803a1ebf5056e05caebbbc2bd828" translate="yes" xml:space="preserve">
          <source>Style keys are camelCased in order to be consistent with accessing the properties on DOM nodes from JS (e.g. &lt;code&gt;node.style.backgroundImage&lt;/code&gt;). Vendor prefixes &lt;a href=&quot;https://www.andismith.com/blogs/2012/02/modernizr-prefixed/&quot;&gt;other than &lt;code&gt;ms&lt;/code&gt;&lt;/a&gt; should begin with a capital letter. This is why &lt;code&gt;WebkitTransition&lt;/code&gt; has an uppercase &amp;ldquo;W&amp;rdquo;.</source>
          <target state="translated">Ключи стиля имеют camelCased, чтобы обеспечить согласованный доступ к свойствам узлов DOM из JS (например, &lt;code&gt;node.style.backgroundImage&lt;/code&gt; ). Префиксы поставщика, &lt;a href=&quot;https://www.andismith.com/blogs/2012/02/modernizr-prefixed/&quot;&gt;отличные от &lt;code&gt;ms&lt;/code&gt; ,&lt;/a&gt; должны начинаться с заглавной буквы. Вот почему в &lt;code&gt;WebkitTransition&lt;/code&gt; есть заглавная буква &amp;laquo;W&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="dd76e22706bae25144071aa88dd7860b26352adb" translate="yes" xml:space="preserve">
          <source>Styling and CSS</source>
          <target state="translated">Стилинг и CSS</target>
        </trans-unit>
        <trans-unit id="414b5ca82eb42c71f0f2d39c844f482fd42ea9da" translate="yes" xml:space="preserve">
          <source>Subsequent calls will override values from previous calls in the same cycle, so the quantity will only be incremented once. If the next state depends on the current state, we recommend using the updater function form, instead:</source>
          <target state="translated">Последующие вызовы будут переопределять значения предыдущих вызовов в том же цикле,поэтому их количество будет увеличено только один раз.Если следующее состояние зависит от текущего,мы рекомендуем вместо этого использовать форму функции обновления:</target>
        </trans-unit>
        <trans-unit id="333ad9c79db454c75a821468e0cf82cb446eefbc" translate="yes" xml:space="preserve">
          <source>Such functions are called &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;&amp;ldquo;pure&amp;rdquo;&lt;/a&gt; because they do not attempt to change their inputs, and always return the same result for the same inputs.</source>
          <target state="translated">Такие функции называются &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;&amp;laquo;чистыми&amp;raquo;,&lt;/a&gt; потому что они не пытаются изменить свои входные данные и всегда возвращают один и тот же результат для тех же входных данных.</target>
        </trans-unit>
        <trans-unit id="2358d63b1ed4396759930456a478ea2a3ecb09ca" translate="yes" xml:space="preserve">
          <source>Supported Events</source>
          <target state="translated">Поддерживаемые события</target>
        </trans-unit>
        <trans-unit id="e9d85411dc54581517da69d2b9ea66c39e1aebb2" translate="yes" xml:space="preserve">
          <source>Suppose you have a structure like:</source>
          <target state="translated">Предположим,у тебя есть такая структура:</target>
        </trans-unit>
        <trans-unit id="abd40b2a3a10e13029651065e57e2382da64bf8f" translate="yes" xml:space="preserve">
          <source>Suspense</source>
          <target state="translated">Suspense</target>
        </trans-unit>
        <trans-unit id="a18d9f771ec11baec15e54073d783f488add33bd" translate="yes" xml:space="preserve">
          <source>Suspense API</source>
          <target state="translated">API приостановки</target>
        </trans-unit>
        <trans-unit id="ac2887f41b70a20e517e2b034cd704e52c8fb68b" translate="yes" xml:space="preserve">
          <source>Suspense Reveal &amp;ldquo;Train&amp;rdquo;</source>
          <target state="translated">Саспенс-шоу &amp;laquo;Поезд&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="321f28f3a1ac7332ad69a67dae8b9247d8a85a04" translate="yes" xml:space="preserve">
          <source>Suspense SSR + Hydration</source>
          <target state="translated">Суспензия SSR+гидратация</target>
        </trans-unit>
        <trans-unit id="81114a1c8b3333230f42d8c8600b93746352c08a" translate="yes" xml:space="preserve">
          <source>Suspense and Race Conditions</source>
          <target state="translated">Условия притяжения и гонки</target>
        </trans-unit>
        <trans-unit id="b82aa4510b7ffae21c24013d7b39f194e5aaa84e" translate="yes" xml:space="preserve">
          <source>Suspense answers some questions, but it also poses new questions of its own:</source>
          <target state="translated">Suspense отвечает на некоторые вопросы,но в то же время ставит новые вопросы:</target>
        </trans-unit>
        <trans-unit id="0668777af59a2bb3b94fb7bd2790a6a69182a367" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching</source>
          <target state="translated">Приостановка для сбора данных</target>
        </trans-unit>
        <trans-unit id="17e3380602b04a7d645ea7631524d14d2b831868" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching (Experimental)</source>
          <target state="translated">Приостановка для сбора данных (экспериментальная)</target>
        </trans-unit>
        <trans-unit id="693b7a99ad484ef032cfb982205ce455d09996b7" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching is a new feature that lets you also use &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; to &lt;strong&gt;declaratively &amp;ldquo;wait&amp;rdquo; for anything else, including data.&lt;/strong&gt; This page focuses on the data fetching use case, but it can also wait for images, scripts, or other asynchronous work.</source>
          <target state="translated">Suspense for Data Fetching - это новая функция, которая позволяет вам также использовать &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; для &lt;strong&gt;декларативного &amp;laquo;ожидания&amp;raquo; чего-либо еще, включая данные. &lt;/strong&gt;Эта страница посвящена варианту использования получения данных, но также может ожидать изображений, сценариев или другой асинхронной работы.</target>
        </trans-unit>
        <trans-unit id="9b0d4cdaa1a76384c088f402a4f96d85a28531e2" translate="yes" xml:space="preserve">
          <source>Suspense is not a data fetching library. It&amp;rsquo;s a &lt;strong&gt;mechanism for data fetching libraries&lt;/strong&gt; to communicate to React that &lt;em&gt;the data a component is reading is not ready yet&lt;/em&gt;. React can then wait for it to be ready and update the UI. At Facebook, we use Relay and its &lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;new Suspense integration&lt;/a&gt;. We expect that other libraries like Apollo can provide similar integrations.</source>
          <target state="translated">Suspense - это не библиотека для выборки данных. Это &lt;strong&gt;механизм для библиотек выборки данных,&lt;/strong&gt; который сообщает React, что &lt;em&gt;данные, которые компонент читает, еще не готовы&lt;/em&gt; . Затем React может дождаться его готовности и обновить пользовательский интерфейс. В Facebook мы используем Relay и его &lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;новую интеграцию Suspense&lt;/a&gt; . Мы ожидаем, что другие библиотеки, такие как Apollo, могут обеспечить аналогичную интеграцию.</target>
        </trans-unit>
        <trans-unit id="ae0fdcad1737c52adbeb2031aa8e91aa234309f3" translate="yes" xml:space="preserve">
          <source>Suspense is significantly different from existing approaches to these problems, so reading about it for the first time often leads to misconceptions. Let&amp;rsquo;s clarify the most common ones:</source>
          <target state="translated">Suspense значительно отличается от существующих подходов к этим проблемам, поэтому первое чтение о нем часто приводит к неправильным представлениям. Разберем самые распространенные из них:</target>
        </trans-unit>
        <trans-unit id="2300fe3099f2f4c3d641d1d53b84cabdafe3a65d" translate="yes" xml:space="preserve">
          <source>Suspense itself as a mechanism is flexible and doesn&amp;rsquo;t have many constraints. Product code needs to be more constrained to ensure no waterfalls, but there are different ways to provide these guarantees. Some questions that we&amp;rsquo;re currently exploring include:</source>
          <target state="translated">Сама по себе приостановка как механизм является гибким и не имеет многих ограничений. Код продукта должен быть более ограниченным, чтобы гарантировать отсутствие водопадов, но есть разные способы предоставить эти гарантии. Вот некоторые вопросы, которые мы сейчас изучаем:</target>
        </trans-unit>
        <trans-unit id="e0d14a0b49b6d0f702b2ffbbecd59f387529f76b" translate="yes" xml:space="preserve">
          <source>Suspense lets components &amp;ldquo;wait&amp;rdquo; for something before rendering. Today, Suspense only supports one use case: &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;loading components dynamically with &lt;code&gt;React.lazy&lt;/code&gt;&lt;/a&gt;. In the future, it will support other use cases like data fetching.</source>
          <target state="translated">Suspense позволяет компонентам &amp;laquo;ждать&amp;raquo; чего-то перед рендерингом. Сегодня Suspense поддерживает только один вариант использования: &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;динамическую загрузку компонентов с помощью &lt;code&gt;React.lazy&lt;/code&gt; &lt;/a&gt; . В будущем он будет поддерживать другие варианты использования, такие как получение данных.</target>
        </trans-unit>
        <trans-unit id="5cc08b841d3b9a32f5104a0898d01491b08aa477" translate="yes" xml:space="preserve">
          <source>Suspense lets your components &amp;ldquo;wait&amp;rdquo; for something before they can render. In &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;this example&lt;/a&gt;, two components wait for an asynchronous API call to fetch some data:</source>
          <target state="translated">Suspense позволяет вашим компонентам &amp;laquo;ждать&amp;raquo; чего-то, прежде чем они смогут выполнить рендеринг. В &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;этом примере&lt;/a&gt; два компонента ожидают вызова асинхронного API для получения некоторых данных:</target>
        </trans-unit>
        <trans-unit id="597e77ccf0147ff1e0e95dbbfc0c166549395d98" translate="yes" xml:space="preserve">
          <source>SuspenseList</source>
          <target state="translated">SuspenseList</target>
        </trans-unit>
        <trans-unit id="f0933b54a50ee57a6c427ef3484a69b2e12b94de" translate="yes" xml:space="preserve">
          <source>SyntheticEvent</source>
          <target state="translated">SyntheticEvent</target>
        </trans-unit>
        <trans-unit id="eb94a49137dc3e1d46de143e47c86b9942e468c2" translate="yes" xml:space="preserve">
          <source>Teams with a strong focus on user experience sometimes solve similar problems with one-off solutions. However, those solutions rarely survive for a long time, as they&amp;rsquo;re hard to maintain. With Concurrent Mode, our goal is to bake the UI research findings into the abstraction itself, and provide idiomatic ways to use them. As a UI library, React is well-positioned to do that.</source>
          <target state="translated">Команды, уделяющие особое внимание пользовательскому опыту, иногда решают аналогичные проблемы с помощью одноразовых решений. Однако эти решения редко сохраняются в течение длительного времени, поскольку их сложно поддерживать. В Concurrent Mode наша цель - встроить результаты исследования пользовательского интерфейса в саму абстракцию и предоставить идиоматические способы их использования. Как UI-библиотека, React хорошо подходит для этого.</target>
        </trans-unit>
        <trans-unit id="63c65f0a5afe770a42c1f536806bc2ba23c61729" translate="yes" xml:space="preserve">
          <source>Temporarily &lt;strong&gt;disable all Chrome extensions, especially React DevTools&lt;/strong&gt;. They can significantly skew the results!</source>
          <target state="translated">Временно &lt;strong&gt;отключите все расширения Chrome, особенно React DevTools&lt;/strong&gt; . Они могут существенно исказить результаты!</target>
        </trans-unit>
        <trans-unit id="2d9f45c513924550decb83eed63be6f6d9fd3fb5" translate="yes" xml:space="preserve">
          <source>Test Renderer</source>
          <target state="translated">Прокатчик тестов</target>
        </trans-unit>
        <trans-unit id="f9f882a7cfbac9fa3cff0ad94e26ffd24816fce8" translate="yes" xml:space="preserve">
          <source>Test Utilities</source>
          <target state="translated">Тестовые утилиты</target>
        </trans-unit>
        <trans-unit id="ba890ac7eaae740a1397d738f471733e2031742f" translate="yes" xml:space="preserve">
          <source>Test runners</source>
          <target state="translated">Тестовые бегуны</target>
        </trans-unit>
        <trans-unit id="124162fb455da17f3c10873c994eb7025be9ae73" translate="yes" xml:space="preserve">
          <source>Test runners like &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt;, &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha&lt;/a&gt;, &lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;ava&lt;/a&gt; let you write test suites as regular JavaScript, and run them as part of your development process. Additionally, test suites are run as part of continuous integration.</source>
          <target state="translated">&lt;a href=&quot;https://jestjs.io/&quot;&gt;Средства&lt;/a&gt; запуска тестов, такие как Jest , &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha&lt;/a&gt; , &lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;ava,&lt;/a&gt; позволяют писать наборы тестов как обычный JavaScript и запускать их как часть процесса разработки. Кроме того, наборы тестов запускаются как часть непрерывной интеграции.</target>
        </trans-unit>
        <trans-unit id="df1ad36dfe1da6bac30d4a2122b6bbb6bcdc9305" translate="yes" xml:space="preserve">
          <source>TestInstance</source>
          <target state="translated">TestInstance</target>
        </trans-unit>
        <trans-unit id="0e69f126cac48a7e0d8d39281bf25ed113ce94ed" translate="yes" xml:space="preserve">
          <source>TestRenderer</source>
          <target state="translated">TestRenderer</target>
        </trans-unit>
        <trans-unit id="6cfd3bb51c904996890bb1730778d2a7efc233b6" translate="yes" xml:space="preserve">
          <source>TestRenderer instance</source>
          <target state="translated">инстанция TestRenderer</target>
        </trans-unit>
        <trans-unit id="b4da10691865addeea2f1c653b85a8f1e0286f02" translate="yes" xml:space="preserve">
          <source>TestRenderer.act()</source>
          <target state="translated">TestRenderer.act()</target>
        </trans-unit>
        <trans-unit id="2e71b6a628eaf51262cd4d225cbcddbb76bb40a1" translate="yes" xml:space="preserve">
          <source>TestRenderer.create()</source>
          <target state="translated">TestRenderer.create()</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="12812e81c11031211b6dbe3caf13286f4d099fbc" translate="yes" xml:space="preserve">
          <source>Testing Environments</source>
          <target state="translated">Условия тестирования</target>
        </trans-unit>
        <trans-unit id="89b062a062bb5077e146efeebbb24fba0a676163" translate="yes" xml:space="preserve">
          <source>Testing Overview</source>
          <target state="translated">Обзор тестирования</target>
        </trans-unit>
        <trans-unit id="d4f180c77cb6606396db8f6554504a4d8a6d0019" translate="yes" xml:space="preserve">
          <source>Testing Recipes</source>
          <target state="translated">Рецепты для тестирования</target>
        </trans-unit>
        <trans-unit id="6cd6d80805fdc664e169392908689e2225952cde" translate="yes" xml:space="preserve">
          <source>Testing accessibility in the browser</source>
          <target state="translated">Тестирование доступности в браузере</target>
        </trans-unit>
        <trans-unit id="e77bc776e14ce1b3f92953a1505b14b5e8807a09" translate="yes" xml:space="preserve">
          <source>Testing with a screen reader should form part of your accessibility tests.</source>
          <target state="translated">Тестирование с помощью скринридера должно быть частью тестов на доступность.</target>
        </trans-unit>
        <trans-unit id="a38b0e5bfa5bb2618320d9e5309a34ceaea5d8a2" translate="yes" xml:space="preserve">
          <source>Testing your rate limiting</source>
          <target state="translated">Тестирование вашего ограничения скорости</target>
        </trans-unit>
        <trans-unit id="0ee7b58ebfe6f538de913f611a981507c709cfc5" translate="yes" xml:space="preserve">
          <source>Tests often run in an environment without access to a real rendering surface like a browser. For these environments, we recommend simulating a browser with &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt;, a lightweight browser implementation that runs inside Node.js.</source>
          <target state="translated">Тесты часто выполняются в среде без доступа к реальной поверхности рендеринга, такой как браузер. Для этих сред мы рекомендуем имитировать браузер с помощью &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt; &lt;code&gt;jsdom&lt;/code&gt; &lt;/a&gt; , облегченной реализации браузера, работающей внутри Node.js.</target>
        </trans-unit>
        <trans-unit id="5360faacc2fd3e662f0f2d953eff4fe5f229a4dc" translate="yes" xml:space="preserve">
          <source>That means that with a version number &lt;strong&gt;x.y.z&lt;/strong&gt;:</source>
          <target state="translated">Это означает, что с номером версии &lt;strong&gt;xyz&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="2572cbe643325f3e4047c805feaf04cce5e624d2" translate="yes" xml:space="preserve">
          <source>That said, if we expect that a change on this list will cause broad problems in the community, we will still do our best to provide a gradual migration path.</source>
          <target state="translated">Тем не менее,если мы ожидаем,что изменения в этом списке вызовут широкие проблемы в обществе,мы все равно сделаем все возможное,чтобы обеспечить постепенный путь миграции.</target>
        </trans-unit>
        <trans-unit id="133f42dd430ef5bbc99318df87da28082b76ff20" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s It!</source>
          <target state="translated">Это оно!</target>
        </trans-unit>
        <trans-unit id="47cf34ef6f2d037d4305bba6dc055a53cc17f54f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;logProps&amp;rdquo; HOC passes all &lt;code&gt;props&lt;/code&gt; through to the component it wraps, so the rendered output will be the same. For example, we can use this HOC to log all props that get passed to our &amp;ldquo;fancy button&amp;rdquo; component:</source>
          <target state="translated">HOC &amp;laquo;logProps&amp;raquo; передает все &lt;code&gt;props&lt;/code&gt; компоненту, который он оборачивает, поэтому визуализированный результат будет таким же. Например, мы можем использовать этот HOC для регистрации всех свойств, которые передаются нашему компоненту &amp;laquo;причудливой кнопки&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="e338a1de1df09480e7fd8879427799044a4cefcc" translate="yes" xml:space="preserve">
          <source>The &amp;rdquo;+&amp;rdquo; and &amp;rdquo;-&amp;rdquo; buttons use the functional form, because the updated value is based on the previous value. But the &amp;ldquo;Reset&amp;rdquo; button uses the normal form, because it always sets the count back to the initial value.</source>
          <target state="translated">Кнопки &amp;laquo;+&amp;raquo; и &amp;laquo;-&amp;raquo; используют функциональную форму, потому что обновленное значение основано на предыдущем значении. Но кнопка &amp;laquo;Сброс&amp;raquo; использует обычную форму, потому что она всегда возвращает счетчику исходное значение.</target>
        </trans-unit>
        <trans-unit id="01b742ba6eb43b216e145ce39e12bd4bdf765b31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;events&quot;&gt;&lt;code&gt;SyntheticEvent&lt;/code&gt;&lt;/a&gt; objects are pooled. This means that the &lt;code&gt;SyntheticEvent&lt;/code&gt; object will be reused and all properties will be nullified after the event event handler has been called. For example, this won&amp;rsquo;t work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2384cbfbef2aaecf2b1b1cef6cc143a819625453" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary&quot;&gt;glossary&lt;/a&gt; contains an overview of the most common terms you&amp;rsquo;ll see in the React documentation. There is also a FAQ section dedicated to short questions and answers about common topics, including &lt;a href=&quot;faq-ajax&quot;&gt;making AJAX requests&lt;/a&gt;, &lt;a href=&quot;faq-state&quot;&gt;component state&lt;/a&gt;, and &lt;a href=&quot;faq-structure&quot;&gt;file structure&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary&quot;&gt;Глоссарий&lt;/a&gt; содержит обзор наиболее распространенных терминов , вы увидите в React документации. Также есть раздел часто задаваемых вопросов, посвященный коротким вопросам и ответам на общие темы, включая &lt;a href=&quot;faq-ajax&quot;&gt;выполнение запросов AJAX&lt;/a&gt; , &lt;a href=&quot;faq-state&quot;&gt;состояние компонентов&lt;/a&gt; и &lt;a href=&quot;faq-structure&quot;&gt;структуру файлов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="748db1aa2803f2dfcb93b31b6cbd612e4302e368" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt; Hook makes it easier to control when individual children update, reducing the need for pure components.</source>
          <target state="translated">&lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt; &lt;code&gt;useMemo&lt;/code&gt; &lt;/a&gt; крюк делает его легче контролировать , когда отдельные дети обновление, уменьшая потребность в чистых компонентов.</target>
        </trans-unit>
        <trans-unit id="d194b55aa0e5c4407ec3ef22a2a2374e9ad14f78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-intro&quot;&gt;introduction page&lt;/a&gt; used this example to get familiar with Hooks:</source>
          <target state="translated">На &lt;a href=&quot;hooks-intro&quot;&gt;вводной странице&lt;/a&gt; этот пример использовался для знакомства с хуками:</target>
        </trans-unit>
        <trans-unit id="2346342023beadde66b62f9c79644b07c2e16dd8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; Hook lets you keep the same callback reference between re-renders so that &lt;code&gt;shouldComponentUpdate&lt;/code&gt; continues to work:</source>
          <target state="translated">&lt;a href=&quot;hooks-reference#usecallback&quot;&gt; &lt;code&gt;useCallback&lt;/code&gt; &lt;/a&gt; крючок позволяет сохранить ту же ссылку обратного вызова между повторными делает так , что &lt;code&gt;shouldComponentUpdate&lt;/code&gt; продолжает работу:</target>
        </trans-unit>
        <trans-unit id="120d49be1a12891d545be48cefeee776b16e23c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-reference#usememo&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt; Hook lets you cache calculations between multiple renders by &amp;ldquo;remembering&amp;rdquo; the previous computation:</source>
          <target state="translated">&lt;a href=&quot;hooks-reference#usememo&quot;&gt; &lt;code&gt;useMemo&lt;/code&gt; &lt;/a&gt; Hook позволяет кэшировать расчеты между множественным оказывает на &amp;laquo;запоминание&amp;raquo; предыдущего вычисления:</target>
        </trans-unit>
        <trans-unit id="098a2975ef1c374c6d16cb1384320a5fa0b0dcb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;array destructuring&lt;/a&gt; syntax lets us give different names to the state variables we declared by calling &lt;code&gt;useState&lt;/code&gt;. These names aren&amp;rsquo;t a part of the &lt;code&gt;useState&lt;/code&gt; API. Instead, React assumes that if you call &lt;code&gt;useState&lt;/code&gt; many times, you do it in the same order during every render. We&amp;rsquo;ll come back to why this works and when this is useful later.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;Массив деструктурирующий&lt;/a&gt; синтаксис позволяет нам давать разные имена переменных состояния мы объявленным по телефону &lt;code&gt;useState&lt;/code&gt; . Эти имена не являются частью &lt;code&gt;useState&lt;/code&gt; API. Вместо этого React предполагает, что если вы вызываете &lt;code&gt;useState&lt;/code&gt; много раз, вы делаете это в том же порядке во время каждого рендеринга. Мы вернемся к тому, почему это работает и когда это будет полезно позже.</target>
        </trans-unit>
        <trans-unit id="c1157f3e19fdd019adc6c8af16bcb7d469610ebc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/TrySound/rollup-plugin-terser&quot;&gt;&lt;code&gt;terser&lt;/code&gt;&lt;/a&gt; plugin compresses and mangles the final bundle.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/TrySound/rollup-plugin-terser&quot;&gt; &lt;code&gt;terser&lt;/code&gt; &lt;/a&gt; плагин компрессов и Mangles конечного пучка.</target>
        </trans-unit>
        <trans-unit id="edcb883b6855822aeaaaf923c3ccb9c7db6aacae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/evcohen/eslint-plugin-jsx-a11y&quot;&gt;eslint-plugin-jsx-a11y&lt;/a&gt; plugin for ESLint provides AST linting feedback regarding accessibility issues in your JSX. Many IDE&amp;rsquo;s allow you to integrate these findings directly into code analysis and source code windows.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/evcohen/eslint-plugin-jsx-a11y&quot;&gt;Eslint-плагин-JSX-a11y&lt;/a&gt; плагин для ESLint обеспечивает AST пылеобразования обратную связь относительно вопросов доступности в вашем JSX. Многие IDE позволяют интегрировать эти результаты непосредственно в окна анализа кода и исходного кода.</target>
        </trans-unit>
        <trans-unit id="466c527e21770fbc02c5b0d781265c63d3f2df55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;&lt;code&gt;envify&lt;/code&gt;&lt;/a&gt; transform ensures the right build environment is set. Make it global (&lt;code&gt;-g&lt;/code&gt;).</source>
          <target state="translated">Преобразование &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt; &lt;code&gt;envify&lt;/code&gt; &lt;/a&gt; обеспечивает установку правильной среды сборки. Сделайте его глобальным ( &lt;code&gt;-g&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="682e1228ae05401a65c58b0a5a7c5947327f9fa8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/hughsk/uglifyify&quot;&gt;&lt;code&gt;uglifyify&lt;/code&gt;&lt;/a&gt; transform removes development imports. Make it global too (&lt;code&gt;-g&lt;/code&gt;).</source>
          <target state="translated">Преобразование &lt;a href=&quot;https://github.com/hughsk/uglifyify&quot;&gt; &lt;code&gt;uglifyify&lt;/code&gt; &lt;/a&gt; удаляет импорт разработки. Сделайте его тоже глобальным ( &lt;code&gt;-g&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d8ad55d9dccafa63caad67ca7c1eeabc211f835" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rollup/rollup-plugin-commonjs&quot;&gt;&lt;code&gt;commonjs&lt;/code&gt;&lt;/a&gt; plugin provides support for CommonJS in Rollup.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rollup/rollup-plugin-commonjs&quot;&gt; &lt;code&gt;commonjs&lt;/code&gt; &lt;/a&gt; плагин обеспечивает поддержку CommonJS в накопительном пакете.</target>
        </trans-unit>
        <trans-unit id="fec342ad3128435e51009a9f76d45133f8620021" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt; plugin ensures the right build environment is set.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; плагин обеспечивает правильное окружение сборки установлены.</target>
        </trans-unit>
        <trans-unit id="de89beb93569715dce635201036fc64e63c3ab03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://reactjs.org/&quot;&gt;React homepage&lt;/a&gt; contains a few small React examples with a live editor. Even if you don&amp;rsquo;t know anything about React yet, try changing their code and see how it affects the result.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/&quot;&gt;Реагировать домашнюю страница&lt;/a&gt; содержит несколько небольших Реагировать примеры с живым редактором. Даже если вы еще ничего не знаете о React, попробуйте изменить их код и посмотрите, как это повлияет на результат.</target>
        </trans-unit>
        <trans-unit id="974ac1c4a0c9da760228a943bce37428cd6a0e23" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://reactjs.org/blog/&quot;&gt;React blog&lt;/a&gt; is the official source for the updates from the React team. Anything important, including release notes or deprecation notices, will be posted there first.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/blog/&quot;&gt;Реагировать блог&lt;/a&gt; является официальным источником обновлений от React команды. Все важное, включая примечания к выпуску или уведомления об отказе от поддержки, будет сначала опубликовано там.</target>
        </trans-unit>
        <trans-unit id="2ad57eeeea994127067368039363f4ff4d6702fb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://wave.webaim.org/extension/&quot;&gt;Web Accessibility Evaluation Tool&lt;/a&gt; is another accessibility browser extension.</source>
          <target state="translated">&lt;a href=&quot;https://wave.webaim.org/extension/&quot;&gt;Доступность Инструмент оценки Web&lt;/a&gt; является другим расширением доступности браузера.</target>
        </trans-unit>
        <trans-unit id="f83d6081d60ff040de57036c3c2ca925f0d22729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.w3.org/WAI/intro/aria&quot;&gt;Web Accessibility Initiative - Accessible Rich Internet Applications&lt;/a&gt; document contains techniques for building fully accessible JavaScript widgets.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/WAI/intro/aria&quot;&gt;Инициатива Web Accessibility - Доступ Rich Internet Applications&lt;/a&gt; документ содержит методы для создания полностью доступных виджетов JavaScript.</target>
        </trans-unit>
        <trans-unit id="54c94cd5415c60ee0381a2c958378a40eaeaf801" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.w3.org/WAI/intro/wcag&quot;&gt;Web Content Accessibility Guidelines&lt;/a&gt; provides guidelines for creating accessible web sites.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/WAI/intro/wcag&quot;&gt;Web Content Accessibility Guidelines&lt;/a&gt; дает рекомендации по созданию доступных веб - сайтов.</target>
        </trans-unit>
        <trans-unit id="71e5eefc03760deefaf5de6d0e50a96ab32f93bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing-recipes&quot;&gt;&lt;code&gt;recipes&lt;/code&gt;&lt;/a&gt; document contains more details on how &lt;code&gt;act()&lt;/code&gt; behaves, with examples and usage.</source>
          <target state="translated">В документе с &lt;a href=&quot;testing-recipes&quot;&gt; &lt;code&gt;recipes&lt;/code&gt; &lt;/a&gt; содержится более подробная информация о том, как работает &lt;code&gt;act()&lt;/code&gt; , с примерами и использованием.</target>
        </trans-unit>
        <trans-unit id="93cd169de202dab7b3a7bc88a7d0ccacf3c3279a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Avatar&lt;/code&gt; doesn&amp;rsquo;t need to know that it is being rendered inside a &lt;code&gt;Comment&lt;/code&gt;. This is why we have given its prop a more generic name: &lt;code&gt;user&lt;/code&gt; rather than &lt;code&gt;author&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Avatar&lt;/code&gt; не нужно знать , что он визуализируется внутри &lt;code&gt;Comment&lt;/code&gt; . Вот почему мы дали его опоре более общее имя: &lt;code&gt;user&lt;/code&gt; а не &lt;code&gt;author&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a76f53d7593b26bd487b5056b04b9938d981554" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FormattedDate&lt;/code&gt; component would receive the &lt;code&gt;date&lt;/code&gt; in its props and wouldn&amp;rsquo;t know whether it came from the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s state, from the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s props, or was typed by hand:</source>
          <target state="translated">Компонент &lt;code&gt;FormattedDate&lt;/code&gt; получит &lt;code&gt;date&lt;/code&gt; в своих свойствах и не будет знать, было ли оно получено из состояния &lt;code&gt;Clock&lt;/code&gt; , из &lt;code&gt;Clock&lt;/code&gt; или набрано вручную:</target>
        </trans-unit>
        <trans-unit id="ef0d77ae8586dfacccde29ab8965e058f9cd57a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profiler&lt;/code&gt; measures how often a React application renders and what the &amp;ldquo;cost&amp;rdquo; of rendering is. Its purpose is to help identify parts of an application that are slow and may benefit from &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;optimizations such as memoization&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;Profiler&lt;/code&gt; меры , как часто Реагировать приложение делает и то , что &amp;laquo;стоимость&amp;raquo; рендеринга. Его цель - помочь определить части приложения, которые работают медленно и могут выиграть от &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;оптимизации, такой как мемоизация&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ada4ac9d87ac916586daecc13fbb29890339bfea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profiler&lt;/code&gt; requires an &lt;code&gt;onRender&lt;/code&gt; function as a prop. React calls this function any time a component within the profiled tree &amp;ldquo;commits&amp;rdquo; an update. It receives parameters describing what was rendered and how long it took.</source>
          <target state="translated">&lt;code&gt;Profiler&lt;/code&gt; требует &lt;code&gt;onRender&lt;/code&gt; функции в качестве опоры. React вызывает эту функцию каждый раз, когда компонент в профилированном дереве &amp;laquo;фиксирует&amp;raquo; обновление. Он получает параметры, описывающие, что было отрисовано и сколько времени это заняло.</target>
        </trans-unit>
        <trans-unit id="135fecf5352f306a8ec799e1818c365ff3112c82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;React.Fragment&lt;/code&gt; component lets you return multiple elements in a &lt;code&gt;render()&lt;/code&gt; method without creating an additional DOM element:</source>
          <target state="translated">Компонент &lt;code&gt;React.Fragment&lt;/code&gt; позволяет возвращать несколько элементов в методе &lt;code&gt;render()&lt;/code&gt; без создания дополнительного элемента DOM:</target>
        </trans-unit>
        <trans-unit id="bb92ce250ac6de4e11572565bd150102f2d8a162" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;React.lazy&lt;/code&gt; function lets you render a dynamic import as a regular component.</source>
          <target state="translated">Функция &lt;code&gt;React.lazy&lt;/code&gt; позволяет отображать динамический импорт как обычный компонент.</target>
        </trans-unit>
        <trans-unit id="edb6a31b8dfd687a65274464ad8c41bf13e449eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReactDOMServer&lt;/code&gt; object enables you to render components to static markup. Typically, it&amp;rsquo;s used on a Node server:</source>
          <target state="translated">Объект &lt;code&gt;ReactDOMServer&lt;/code&gt; позволяет отображать компоненты в статической разметке. Обычно он используется на сервере Node:</target>
        </trans-unit>
        <trans-unit id="9450751b918d37e1e6d5d17ecb9ef92dc4e90c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SyntheticEvent&lt;/code&gt; is pooled. This means that the &lt;code&gt;SyntheticEvent&lt;/code&gt; object will be reused and all properties will be nullified after the event callback has been invoked. This is for performance reasons. As such, you cannot access the event in an asynchronous way.</source>
          <target state="translated">&lt;code&gt;SyntheticEvent&lt;/code&gt; будет объедин ли. Это означает, что объект &lt;code&gt;SyntheticEvent&lt;/code&gt; будет повторно использован, и все свойства будут обнулены после вызова обратного вызова события. Это из соображений производительности. Таким образом, вы не можете получить доступ к событию асинхронным способом.</target>
        </trans-unit>
        <trans-unit id="199347fbd83520bd3e789e3686528fa06113abd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checked&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; components of type &lt;code&gt;checkbox&lt;/code&gt; or &lt;code&gt;radio&lt;/code&gt;. You can use it to set whether the component is checked. This is useful for building controlled components. &lt;code&gt;defaultChecked&lt;/code&gt; is the uncontrolled equivalent, which sets whether the component is checked when it is first mounted.</source>
          <target state="translated">&lt;code&gt;checked&lt;/code&gt; атрибут поддерживается &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; компонент типа &lt;code&gt;checkbox&lt;/code&gt; или &lt;code&gt;radio&lt;/code&gt; . Вы можете использовать его, чтобы установить, отмечен ли компонент. Это полезно для создания управляемых компонентов. &lt;code&gt;defaultChecked&lt;/code&gt; - это неуправляемый эквивалент, который устанавливает, проверяется ли компонент при первом монтировании.</target>
        </trans-unit>
        <trans-unit id="b6728729851a5746fae29188678d79fa67af247b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;componentDidMount()&lt;/code&gt; method runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</source>
          <target state="translated">Метод &lt;code&gt;componentDidMount()&lt;/code&gt; запускается после того, как вывод компонента был визуализирован в DOM. Это хорошее место для установки таймера:</target>
        </trans-unit>
        <trans-unit id="ed96963c77fb1890112f95b4829564475778ec4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compose&lt;/code&gt; utility function is provided by many third-party libraries including lodash (as &lt;a href=&quot;https://lodash.com/docs/#flowRight&quot;&gt;&lt;code&gt;lodash.flowRight&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;https://redux.js.org/api/compose&quot;&gt;Redux&lt;/a&gt;, and &lt;a href=&quot;https://ramdajs.com/docs/#compose&quot;&gt;Ramda&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; функция полезности обеспечивается многими библиотеками сторонних включая lodash (как &lt;a href=&quot;https://lodash.com/docs/#flowRight&quot;&gt; &lt;code&gt;lodash.flowRight&lt;/code&gt; &lt;/a&gt; ), &lt;a href=&quot;https://redux.js.org/api/compose&quot;&gt;Перевождь&lt;/a&gt; и &lt;a href=&quot;https://ramdajs.com/docs/#compose&quot;&gt;Ramda&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e04791f8bce0f48514a481f8e96c984420b6e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contextType&lt;/code&gt; property on a class can be assigned a Context object created by &lt;a href=&quot;#reactcreatecontext&quot;&gt;&lt;code&gt;React.createContext()&lt;/code&gt;&lt;/a&gt;. This lets you consume the nearest current value of that Context type using &lt;code&gt;this.context&lt;/code&gt;. You can reference this in any of the lifecycle methods including the render function.</source>
          <target state="translated">&lt;code&gt;contextType&lt;/code&gt; свойство по классу может быть присвоен объект контекста , созданного &lt;a href=&quot;#reactcreatecontext&quot;&gt; &lt;code&gt;React.createContext()&lt;/code&gt; &lt;/a&gt; . Это позволяет использовать ближайшее текущее значение этого типа Context с помощью &lt;code&gt;this.context&lt;/code&gt; . Вы можете ссылаться на это в любом из методов жизненного цикла, включая функцию рендеринга.</target>
        </trans-unit>
        <trans-unit id="cccbfd6e53da65ebc9b175cdb8162582789149dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultProps&lt;/code&gt; will be used to ensure that &lt;code&gt;this.props.name&lt;/code&gt; will have a value if it was not specified by the parent component. The &lt;code&gt;propTypes&lt;/code&gt; typechecking happens after &lt;code&gt;defaultProps&lt;/code&gt; are resolved, so typechecking will also apply to the &lt;code&gt;defaultProps&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;defaultProps&lt;/code&gt; будет использоваться для того , чтобы &lt;code&gt;this.props.name&lt;/code&gt; будет иметь значение , если он не был указан в качестве родительского компонента. &lt;code&gt;propTypes&lt;/code&gt; проверка типов происходит после того, как &lt;code&gt;defaultProps&lt;/code&gt; будут решены, поэтому проверка типов будут также применяться к &lt;code&gt;defaultProps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ee13fb806f9e8f23f14548fbcf1c0937a20a5c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultValue&lt;/code&gt; argument is &lt;strong&gt;only&lt;/strong&gt; used when a component does not have a matching Provider above it in the tree. This can be helpful for testing components in isolation without wrapping them. Note: passing &lt;code&gt;undefined&lt;/code&gt; as a Provider value does not cause consuming components to use &lt;code&gt;defaultValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;defaultValue&lt;/code&gt; аргумент &lt;strong&gt;только&lt;/strong&gt; используется , когда компонент не имеет соответствия поставщика над ним в дереве. Это может быть полезно для изолированного тестирования компонентов без упаковки. Примечание: передача &lt;code&gt;undefined&lt;/code&gt; в качестве значения Provider не приводит к тому, что потребляющие компоненты используют &lt;code&gt;defaultValue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a777fc98bbd33659d037fd7c927c40043be8933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;displayName&lt;/code&gt; string is used in debugging messages. Usually, you don&amp;rsquo;t need to set it explicitly because it&amp;rsquo;s inferred from the name of the function or class that defines the component. You might want to set it explicitly if you want to display a different name for debugging purposes or when you create a higher-order component, see &lt;a href=&quot;higher-order-components#convention-wrap-the-display-name-for-easy-debugging&quot;&gt;Wrap the Display Name for Easy Debugging&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;displayName&lt;/code&gt; строка используется в отладочных сообщений. Обычно вам не нужно устанавливать его явно, потому что он выводится из имени функции или класса, определяющего компонент. Возможно, вы захотите установить его явно, если вы хотите отображать другое имя для целей отладки или при создании компонента более высокого порядка, подробности см. В разделе &amp;laquo; &lt;a href=&quot;higher-order-components#convention-wrap-the-display-name-for-easy-debugging&quot;&gt;Перенос отображаемого имени для простой отладки&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f3264d4c6693710d81212483cd77491f03734f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fallback&lt;/code&gt; prop accepts any React elements that you want to render while waiting for the component to load. You can place the &lt;code&gt;Suspense&lt;/code&gt; component anywhere above the lazy component. You can even wrap multiple lazy components with a single &lt;code&gt;Suspense&lt;/code&gt; component.</source>
          <target state="translated">&lt;code&gt;fallback&lt;/code&gt; проп принимает любой Реагировать элементы , которые вы хотите , чтобы сделать во время ожидания компоненты к нагрузке. Вы можете разместить компонент &lt;code&gt;Suspense&lt;/code&gt; в любом месте над ленивым компонентом. Вы даже можете обернуть несколько ленивых компонентов одним компонентом &lt;code&gt;Suspense&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a87cab9efee0ca186ad1f9234f7af7e9b2e6f23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getChildContext&lt;/code&gt; function will be called when the state or props changes. In order to update data in the context, trigger a local state update with &lt;code&gt;this.setState&lt;/code&gt;. This will trigger a new context and changes will be received by the children.</source>
          <target state="translated">Функция &lt;code&gt;getChildContext&lt;/code&gt; будет вызываться при изменении состояния или свойств. Чтобы обновить данные в контексте, запустите обновление локального состояния с помощью &lt;code&gt;this.setState&lt;/code&gt; . Это вызовет новый контекст, и изменения будут приняты детьми.</target>
        </trans-unit>
        <trans-unit id="aec1e744f364f63f5ad699d9c279366bd3b643fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handleChange&lt;/code&gt; method in the &lt;code&gt;TemperatureInput&lt;/code&gt; component calls &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt; with the new desired value. Its props, including &lt;code&gt;onTemperatureChange&lt;/code&gt;, were provided by its parent component, the &lt;code&gt;Calculator&lt;/code&gt;.</source>
          <target state="translated">Метод &lt;code&gt;handleChange&lt;/code&gt; в компоненте &lt;code&gt;TemperatureInput&lt;/code&gt; вызывает &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt; с новым желаемым значением. Его &lt;code&gt;onTemperatureChange&lt;/code&gt; , включая onTemperaChange , были предоставлены его родительским компонентом &lt;code&gt;Calculator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="210f25cbff1c57d320cf40f4827a05dd0f21c6f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initialState&lt;/code&gt; argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:</source>
          <target state="translated">&lt;code&gt;initialState&lt;/code&gt; аргумент состояние используется во время начальной визуализации. В последующих рендерах это не принимается во внимание. Если начальное состояние является результатом дорогостоящих вычислений, вы можете вместо этого предоставить функцию, которая будет выполняться только при начальной визуализации:</target>
        </trans-unit>
        <trans-unit id="a4b380ee4d5e3b1bd645f3f0bfab036ddd24f72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isPending&lt;/code&gt; boolean lets React know that our component is transitioning, so we are able to let the user know this by showing some loading text on the previous profile page.</source>
          <target state="translated">&lt;code&gt;isPending&lt;/code&gt; булево позволяет Реагировать знать , что наш компонент переходит, поэтому мы можем позволить пользователю знать это, показывая некоторые загрузки текста на предыдущей странице профиля.</target>
        </trans-unit>
        <trans-unit id="cd1395ba5aab1721b29879ffafc1520cf2ef8732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; property can take any of the values documented in the &lt;a href=&quot;https://www.w3.org/TR/uievents-key/#named-key-attribute-values&quot;&gt;DOM Level 3 Events spec&lt;/a&gt;.</source>
          <target state="translated">Свойство &lt;code&gt;key&lt;/code&gt; может принимать любое из значений, задокументированных в &lt;a href=&quot;https://www.w3.org/TR/uievents-key/#named-key-attribute-values&quot;&gt;спецификации событий DOM уровня 3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50b803bb4c9f45c5004b2f4b0708f76ae97a29fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name !== ''&lt;/code&gt; condition is &lt;code&gt;true&lt;/code&gt; on the first render, so we run this Hook. However, on the next render the user might clear the form, making the condition &lt;code&gt;false&lt;/code&gt;. Now that we skip this Hook during rendering, the order of the Hook calls becomes different:</source>
          <target state="translated">&lt;code&gt;name !== ''&lt;/code&gt; условие &lt;code&gt;true&lt;/code&gt; на первый рендер, поэтому мы запускаем этот крюк. Однако при следующем рендеринге пользователь может очистить форму, сделав условие &lt;code&gt;false&lt;/code&gt; . Теперь, когда мы пропускаем этот Hook во время рендеринга, порядок вызовов Hook становится другим:</target>
        </trans-unit>
        <trans-unit id="f85476d3988e9bdfdd3e540a4ed2f05b110634e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onBlur&lt;/code&gt; event handler is called when focus has left the element (or left some element inside of it). For example, it&amp;rsquo;s called when the user clicks outside of a focused text input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f669e76a5881578195b4cedc603f344983fd17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onChange&lt;/code&gt; event behaves as you would expect it to: whenever a form field is changed, this event is fired. We intentionally do not use the existing browser behavior because &lt;code&gt;onChange&lt;/code&gt; is a misnomer for its behavior and React relies on this event to handle user input in real time.</source>
          <target state="translated">В &lt;code&gt;onChange&lt;/code&gt; ведет себя событие , как можно было бы ожидать его: всякий раз , когда поле формы изменяется, то это событие. Мы намеренно не используем существующее поведение браузера, потому что &lt;code&gt;onChange&lt;/code&gt; - неправильное название для его поведения, и React полагается на это событие для обработки пользовательского ввода в реальном времени.</target>
        </trans-unit>
        <trans-unit id="d9df1c231344463418878f550484397733c07805" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onFocus&lt;/code&gt; event is called when the element (or some element inside of it) receives focus. For example, it&amp;rsquo;s called when the user clicks on a text input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e4f5de13553781365d91a92540227537125ed7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onMouseEnter&lt;/code&gt; and &lt;code&gt;onMouseLeave&lt;/code&gt; events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</source>
          <target state="translated">События &lt;code&gt;onMouseEnter&lt;/code&gt; и &lt;code&gt;onMouseLeave&lt;/code&gt; распространяются от оставленного элемента к элементу, который вводится, вместо обычного всплывания и не имеют фазы захвата.</target>
        </trans-unit>
        <trans-unit id="cf02d54b18eb7e4b7f6b5f2f59bf6af62f2393be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onPointerEnter&lt;/code&gt; and &lt;code&gt;onPointerLeave&lt;/code&gt; events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</source>
          <target state="translated">События &lt;code&gt;onPointerEnter&lt;/code&gt; и &lt;code&gt;onPointerLeave&lt;/code&gt; распространяются от оставленного элемента к элементу, который вводится, вместо обычного всплывания и не имеют фазы захвата.</target>
        </trans-unit>
        <trans-unit id="674e5d12b6df14f94e34397b4ed6ffef33e647e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onTemperatureChange&lt;/code&gt; prop will be provided together with the &lt;code&gt;temperature&lt;/code&gt; prop by the parent &lt;code&gt;Calculator&lt;/code&gt; component. It will handle the change by modifying its own local state, thus re-rendering both inputs with the new values. We will look at the new &lt;code&gt;Calculator&lt;/code&gt; implementation very soon.</source>
          <target state="translated">Свойство &lt;code&gt;onTemperatureChange&lt;/code&gt; будет предоставлено вместе с параметром &lt;code&gt;temperature&lt;/code&gt; родительским компонентом &lt;code&gt;Calculator&lt;/code&gt; . Он обработает изменение, изменив свое собственное локальное состояние, таким образом повторно визуализируя оба ввода с новыми значениями. Мы очень скоро рассмотрим новую реализацию &lt;code&gt;Calculator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d719b7a2d158d7590b77512a3cf13bd01ac52e85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-dom&lt;/code&gt; package provides DOM-specific methods that can be used at the top level of your app and as an escape hatch to get outside of the React model if you need to. Most of your components should not need to use this module.</source>
          <target state="translated">Пакет &lt;code&gt;react-dom&lt;/code&gt; предоставляет методы, специфичные для DOM, которые можно использовать на верхнем уровне вашего приложения и в качестве аварийного выхода, чтобы при необходимости выйти за пределы модели React. Большинство ваших компонентов не должны использовать этот модуль.</target>
        </trans-unit>
        <trans-unit id="bed13105d59f319bf16f5451f3a730147d671056" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render()&lt;/code&gt; function should be pure, meaning that it does not modify component state, it returns the same result each time it&amp;rsquo;s invoked, and it does not directly interact with the browser.</source>
          <target state="translated">Функция &lt;code&gt;render()&lt;/code&gt; должна быть чистой, что означает, что она не изменяет состояние компонента, она возвращает тот же результат каждый раз при вызове и не взаимодействует напрямую с браузером.</target>
        </trans-unit>
        <trans-unit id="0a3390f73827da0e30d1b704469d47775415fc2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render()&lt;/code&gt; method is the only required method in a class component.</source>
          <target state="translated">Метод &lt;code&gt;render()&lt;/code&gt; - единственный обязательный метод в компоненте класса.</target>
        </trans-unit>
        <trans-unit id="481c653efaf41fafb96ad006f60184c54f2b1c80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; методом</target>
        </trans-unit>
        <trans-unit id="54fcb9f91c38f310283c2df0f37ef88cd13c8c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; method will be called each time an update happens, but as long as we render &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; into the same DOM node, only a single instance of the &lt;code&gt;Clock&lt;/code&gt; class will be used. This lets us use additional features such as local state and lifecycle methods.</source>
          <target state="translated">Метод &lt;code&gt;render&lt;/code&gt; будет вызываться каждый раз, когда происходит обновление, но пока мы рендерим &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; в один и тот же узел DOM, будет использоваться только один экземпляр класса &lt;code&gt;Clock&lt;/code&gt; . Это позволяет нам использовать дополнительные функции, такие как методы локального состояния и жизненного цикла.</target>
        </trans-unit>
        <trans-unit id="71aa8e04c24836138e98c85afaa8c4097328724c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;revealOrder=&quot;forwards&quot;&lt;/code&gt; option means that the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; nodes inside this list &lt;strong&gt;will only &amp;ldquo;reveal&amp;rdquo; their content in the order they appear in the tree &amp;mdash; even if the data for them arrives in a different order&lt;/strong&gt;. &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; has other interesting modes: try changing &lt;code&gt;&quot;forwards&quot;&lt;/code&gt; to &lt;code&gt;&quot;backwards&quot;&lt;/code&gt; or &lt;code&gt;&quot;together&quot;&lt;/code&gt; and see what happens.</source>
          <target state="translated">Параметр &lt;code&gt;revealOrder=&quot;forwards&quot;&lt;/code&gt; означает, что ближайшие узлы &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; внутри этого списка &lt;strong&gt;будут &amp;laquo;открывать&amp;raquo; свое содержимое только в том порядке, в котором они появляются в дереве, даже если данные для них поступают в другом порядке&lt;/strong&gt; . &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; есть и другие интересные режимы: попробуйте изменить &lt;code&gt;&quot;forwards&quot;&lt;/code&gt; на &lt;code&gt;&quot;backwards&quot;&lt;/code&gt; или &lt;code&gt;&quot;together&quot;&lt;/code&gt; и посмотрите, что произойдет.</target>
        </trans-unit>
        <trans-unit id="107dbf68568c2380480dc053ea5bfc5ee8072aa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selected&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; components. You can use it to set whether the component is selected. This is useful for building controlled components.</source>
          <target state="translated">&lt;code&gt;selected&lt;/code&gt; атрибут поддерживается &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; компоненты. Вы можете использовать его, чтобы указать, выбран ли компонент. Это полезно для создания управляемых компонентов.</target>
        </trans-unit>
        <trans-unit id="203b22e021419cba17f499d4cb5572448638f462" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setState&lt;/code&gt; function is used to update the state. It accepts a new state value and enqueues a re-render of the component.</source>
          <target state="translated">Функция &lt;code&gt;setState&lt;/code&gt; используется для обновления состояния. Он принимает новое значение состояния и ставит в очередь повторную визуализацию компонента.</target>
        </trans-unit>
        <trans-unit id="357dff3065dc86ea9f744a876b9ab8c50c2ae184" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;style&lt;/code&gt; attribute accepts a JavaScript object with camelCased properties rather than a CSS string. This is consistent with the DOM &lt;code&gt;style&lt;/code&gt; JavaScript property, is more efficient, and prevents XSS security holes. For example:</source>
          <target state="translated">&lt;code&gt;style&lt;/code&gt; атрибут принимает объект JavaScript с camelCased свойств , а не строками CSS. Это соответствует свойству JavaScript &lt;code&gt;style&lt;/code&gt; DOM , более эффективно и предотвращает бреши в безопасности XSS. Например:</target>
        </trans-unit>
        <trans-unit id="8bc5e56642dd04f2aba447e6f924682226c0df90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useTransition&lt;/code&gt; hook returns two values in an array.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; крюк возвращает два значения в массиве.</target>
        </trans-unit>
        <trans-unit id="7e1f703ed3eb58b4b8f113ebc5568614f8d4fd8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; components. You can use it to set the value of the component. This is useful for building controlled components. &lt;code&gt;defaultValue&lt;/code&gt; is the uncontrolled equivalent, which sets the value of the component when it is first mounted.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; атрибута поддерживается &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; области компонентов. Вы можете использовать его для установки значения компонента. Это полезно для создания управляемых компонентов. &lt;code&gt;defaultValue&lt;/code&gt; - это неуправляемый эквивалент, который устанавливает значение компонента при его первом монтировании.</target>
        </trans-unit>
        <trans-unit id="3b3a8f7885d22f578c1eb0f567738d06ed793b6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; components. You can use it to set the value of the component. This is useful for building controlled components. &lt;code&gt;defaultValue&lt;/code&gt; is the uncontrolled equivalent, which sets the value of the component when it is first mounted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3679e38fe474c4819ac2803806e3be80472bfc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Effect Hook&lt;/em&gt; lets you perform side effects in function components:</source>
          <target state="translated">&lt;em&gt;Hook Effect&lt;/em&gt; позволяет выполнять побочные эффекты в компонентах функции:</target>
        </trans-unit>
        <trans-unit id="a9385e3f6becba3f891272f25765e8d4da17eddd" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;commit&lt;/strong&gt; phase is when React applies any changes. (In the case of React DOM, this is when React inserts, updates, and removes DOM nodes.) React also calls lifecycles like &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt; during this phase.</source>
          <target state="translated">&lt;strong&gt;Фиксации&lt;/strong&gt; фазы , когда React применяет каких - либо изменений. (В случае React DOM это когда React вставляет, обновляет и удаляет узлы DOM.) React также вызывает на этом этапе жизненные циклы, такие как &lt;code&gt;componentDidMount&lt;/code&gt; и &lt;code&gt;componentDidUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c328cac95d0c017f1f700cb3a749d7591b80a4e4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;render&lt;/strong&gt; phase determines what changes need to be made to e.g. the DOM. During this phase, React calls &lt;code&gt;render&lt;/code&gt; and then compares the result to the previous render.</source>
          <target state="translated">&lt;strong&gt;Визуализации&lt;/strong&gt; фазы определяет , какие изменения должны быть сделаны , например , в DOM. На этом этапе React вызывает &lt;code&gt;render&lt;/code&gt; а затем сравнивает результат с предыдущим рендером.</target>
        </trans-unit>
        <trans-unit id="874a87db1393bc286872f5465f37d25df7ac77ad" translate="yes" xml:space="preserve">
          <source>The API call duration in this example is randomized. If you keep refreshing it, you will notice that sometimes the posts arrive first, and sometimes the &amp;ldquo;fun facts&amp;rdquo; arrive first.</source>
          <target state="translated">Продолжительность вызова API в этом примере случайна. Если вы продолжите обновлять его, то заметите, что иногда сначала приходят сообщения, а иногда - &amp;laquo;забавные факты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1f489e901fd1aa4d117bab0e4b0d39576560ff5b" translate="yes" xml:space="preserve">
          <source>The API of ES6 classes is similar to &lt;code&gt;createReactClass()&lt;/code&gt; with a few exceptions.</source>
          <target state="translated">API классов ES6 похож на &lt;code&gt;createReactClass()&lt;/code&gt; за некоторыми исключениями.</target>
        </trans-unit>
        <trans-unit id="3560d1810ba6a290f018a30acb7a6abe17dc478d" translate="yes" xml:space="preserve">
          <source>The Component Lifecycle</source>
          <target state="translated">Жизненный цикл компонентов</target>
        </trans-unit>
        <trans-unit id="21bf04493983dc2ff15309868ae4a25193bad67d" translate="yes" xml:space="preserve">
          <source>The Data Flows Down</source>
          <target state="translated">Потоки данных вниз</target>
        </trans-unit>
        <trans-unit id="616776b2c6e2444aea1e5faa27917853b1c7f97e" translate="yes" xml:space="preserve">
          <source>The Diffing Algorithm</source>
          <target state="translated">Алгоритм отклонения</target>
        </trans-unit>
        <trans-unit id="c5491cfca6b82c27502e045c3ec98fc3838da8d2" translate="yes" xml:space="preserve">
          <source>The Effect Hook unifies both use cases with a single API.</source>
          <target state="translated">Effect Hook объединяет оба варианта использования с одним API.</target>
        </trans-unit>
        <trans-unit id="1612e741e93d1c692496ad71dfcff5baab42464f" translate="yes" xml:space="preserve">
          <source>The Effect Hook, &lt;code&gt;useEffect&lt;/code&gt;, adds the ability to perform side effects from a function component. It serves the same purpose as &lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, and &lt;code&gt;componentWillUnmount&lt;/code&gt; in React classes, but unified into a single API. (We&amp;rsquo;ll show examples comparing &lt;code&gt;useEffect&lt;/code&gt; to these methods in &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; эффектов, useEffect , добавляет возможность выполнять побочные эффекты из функционального компонента. Он служит той же цели, что и &lt;code&gt;componentDidMount&lt;/code&gt; , &lt;code&gt;componentDidUpdate&lt;/code&gt; и &lt;code&gt;componentWillUnmount&lt;/code&gt; в классах React, но объединен в единый API. (Мы покажем примеры сравнения &lt;code&gt;useEffect&lt;/code&gt; с этими методами в &lt;a href=&quot;hooks-effect&quot;&gt;разделе Использование &lt;/a&gt;обработчика эффектов .)</target>
        </trans-unit>
        <trans-unit id="124aae01ad58b7e1a4ee8c92047de4631d765919" translate="yes" xml:space="preserve">
          <source>The HTML output by this stream is exactly equal to what &lt;a href=&quot;#rendertostaticmarkup&quot;&gt;&lt;code&gt;ReactDOMServer.renderToStaticMarkup&lt;/code&gt;&lt;/a&gt; would return.</source>
          <target state="translated">Вывод HTML этим потоком в точности равен тому, что &lt;a href=&quot;#rendertostaticmarkup&quot;&gt; &lt;code&gt;ReactDOMServer.renderToStaticMarkup&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b58a9fba5b1ef8c2e9715e61380a0bbdc5a87e1" translate="yes" xml:space="preserve">
          <source>The Next channel is a prerelease channel that tracks the master branch of the React repository. We use prereleases in the Next channel as release candidates for the Latest channel. You can think of Next as a superset of Latest that is updated more frequently.</source>
          <target state="translated">Следующий канал-это канал предварительного выпуска,который отслеживает главную ветку репозитория React.Мы используем пререлизы в Next канале в качестве релиз-кандидатов для Последнего канала.Вы можете думать о Next как о суперсети Latest,которая обновляется чаще.</target>
        </trans-unit>
        <trans-unit id="737fdcd14ec762266f15547050e6808527354f7e" translate="yes" xml:space="preserve">
          <source>The Next channel is designed to support integration testing between React and other projects.</source>
          <target state="translated">Следующий канал предназначен для поддержки интеграционного тестирования между React и другими проектами.</target>
        </trans-unit>
        <trans-unit id="b3ed94c8d360c8d9c494a2ca722d37e49ce3e6ed" translate="yes" xml:space="preserve">
          <source>The Paciello Group - Color Contrast Analyzer</source>
          <target state="translated">Пациэльская группа-анализатор цветового контраста</target>
        </trans-unit>
        <trans-unit id="089acaacdb35dc83d6617b2cd65a862a39e1490f" translate="yes" xml:space="preserve">
          <source>The Paciello Group explains accessible names</source>
          <target state="translated">Группа Пасьяльо объясняет доступные имена</target>
        </trans-unit>
        <trans-unit id="b6ecb4067f5d6149e2462ed2c6f4975edca53137" translate="yes" xml:space="preserve">
          <source>The Power Of Not Mutating Data</source>
          <target state="translated">Сила не мутирующих данных</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">Проблема</target>
        </trans-unit>
        <trans-unit id="892213a47fde12815f3b55308a07c21a28514331" translate="yes" xml:space="preserve">
          <source>The Provider component accepts a &lt;code&gt;value&lt;/code&gt; prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e24b6b93e7419bc0e50a40347349c779318865" translate="yes" xml:space="preserve">
          <source>The React documentation assumes some familiarity with programming in the JavaScript language. You don&amp;rsquo;t have to be an expert, but it&amp;rsquo;s harder to learn both React and JavaScript at the same time.</source>
          <target state="translated">Документация React предполагает некоторое знакомство с программированием на языке JavaScript. Вам не обязательно быть экспертом, но одновременно выучить React и JavaScript сложнее.</target>
        </trans-unit>
        <trans-unit id="0fd3ac585dc50ef7294c9de3e83e35480b26454b" translate="yes" xml:space="preserve">
          <source>The React team primarily recommends these solutions:</source>
          <target state="translated">Реакционная группа в первую очередь рекомендует эти решения:</target>
        </trans-unit>
        <trans-unit id="ba2f4b1bedd474c3014f164a2122303c060ccb81" translate="yes" xml:space="preserve">
          <source>The Receded state doesn&amp;rsquo;t feel very nice because it hides existing content.</source>
          <target state="translated">Состояние &amp;laquo;Удалено&amp;raquo; не очень приятное, поскольку оно скрывает существующий контент.</target>
        </trans-unit>
        <trans-unit id="1f929f091bc2ce827e8bf4c5ed48e578b25c2e1c" translate="yes" xml:space="preserve">
          <source>The Three Steps</source>
          <target state="translated">Три шага</target>
        </trans-unit>
        <trans-unit id="e6a086f204eb46311763e005551391b5b863e8b8" translate="yes" xml:space="preserve">
          <source>The W3C demonstrates user notifications</source>
          <target state="translated">W3C демонстрирует уведомления пользователей</target>
        </trans-unit>
        <trans-unit id="a94514ea6fcc374a0e4ec5a9365c3dabf4e39fbb" translate="yes" xml:space="preserve">
          <source>The W3C shows us how to label elements</source>
          <target state="translated">W3C показывает нам,как маркировать элементы.</target>
        </trans-unit>
        <trans-unit id="94dcda409aa812a420ab1cfa14badcf0b13d6d3b" translate="yes" xml:space="preserve">
          <source>The above two components are equivalent from React&amp;rsquo;s point of view.</source>
          <target state="translated">Два вышеуказанных компонента эквивалентны с точки зрения React.</target>
        </trans-unit>
        <trans-unit id="37cd269b859b44611e84ee5db5c7b9f522b36e09" translate="yes" xml:space="preserve">
          <source>The above two lines are equivalent, and use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;&lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">Две приведенные выше строки эквивалентны и используют &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;стрелочные функции&lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt; &lt;code&gt;Function.prototype.bind&lt;/code&gt; &lt;/a&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="215acedeed5a2bd97d915656e07e386e37862aa8" translate="yes" xml:space="preserve">
          <source>The algorithm will not try to match subtrees of different component types. If you see yourself alternating between two component types with very similar output, you may want to make it the same type. In practice, we haven&amp;rsquo;t found this to be an issue.</source>
          <target state="translated">Алгоритм не будет пытаться сопоставить поддеревья разных типов компонентов. Если вы видите, что чередуете два типа компонентов с очень похожими выходными данными, вы можете сделать их одного и того же типа. На практике мы не обнаружили в этом проблемы.</target>
        </trans-unit>
        <trans-unit id="d4d34ce90ceca5ceb82456075b266e3c7316fc14" translate="yes" xml:space="preserve">
          <source>The answer is that any change to React (or other software) carries some risk of breaking in unexpected ways. Imagine a scenario where a patch release that fixes one bug accidentally introduces a different bug. This would not only be disruptive to developers, but also harm their confidence in future patch releases. It&amp;rsquo;s especially regrettable if the original fix is for a bug that is rarely encountered in practice.</source>
          <target state="translated">Ответ заключается в том, что любое изменение в React (или другом программном обеспечении) несет определенный риск неожиданного выхода из строя. Представьте себе сценарий, в котором выпуск патча, исправляющий одну ошибку, случайно вводит другую ошибку. Это не только подорвет разработчиков, но и подорвет их уверенность в будущих выпусках исправлений. Особенно жаль, если исходное исправление касается ошибки, которая редко встречается на практике.</target>
        </trans-unit>
        <trans-unit id="e635eec21597077475b644c681e965353535e3c4" translate="yes" xml:space="preserve">
          <source>The answer to this problem &lt;strong&gt;is to split the state in two parts:&lt;/strong&gt; a &amp;ldquo;high priority&amp;rdquo; part that updates immediately, and a &amp;ldquo;low priority&amp;rdquo; part that may wait for a transition.</source>
          <target state="translated">Решением этой проблемы &lt;strong&gt;является разделение состояния на две части: часть&lt;/strong&gt; с &amp;laquo;высоким приоритетом&amp;raquo;, которая обновляется немедленно, и часть с &amp;laquo;низким приоритетом&amp;raquo;, которая может ждать перехода.</target>
        </trans-unit>
        <trans-unit id="a7a38c075e6a3910c420e7a01266e74d7df6ccf8" translate="yes" xml:space="preserve">
          <source>The approach above requires your React components to be aware of the Backbone models and collections. If you later plan to migrate to another data management solution, you might want to concentrate the knowledge about Backbone in as few parts of the code as possible.</source>
          <target state="translated">Вышеуказанный подход требует,чтобы ваши компоненты React были осведомлены о моделях и коллекциях Backbone.Если в дальнейшем вы планируете перейти на другое решение по управлению данными,то,возможно,вы захотите сконцентрировать знания о компании Backbone на как можно меньшем количестве частей кода.</target>
        </trans-unit>
        <trans-unit id="c20f69e03e2db102e3ca9bf7104bb1da944732c2" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the callback. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the callback should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="translated">Массив зависимостей не передается в качестве аргументов обратному вызову. Однако концептуально это то, что они представляют: каждое значение, указанное в обратном вызове, также должно появиться в массиве dependencies. В будущем достаточно продвинутый компилятор сможет создавать этот массив автоматически.</target>
        </trans-unit>
        <trans-unit id="e2478d3374b94309b968843a77f28e2fb9c9b3b9" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the effect function. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="translated">Массив зависимостей не передается в качестве аргументов функции эффекта. Однако концептуально они представляют то, что они представляют: каждое значение, указанное внутри функции эффекта, также должно появиться в массиве зависимостей. В будущем достаточно продвинутый компилятор сможет создавать этот массив автоматически.</target>
        </trans-unit>
        <trans-unit id="029b5464ab1167d56107b8168f06ebc2ea8d2817" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the function. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="translated">Массив зависимостей не передается в качестве аргументов функции. Однако концептуально это то, что они представляют: каждое значение, указанное внутри функции, также должно появиться в массиве зависимостей. В будущем достаточно продвинутый компилятор сможет создавать этот массив автоматически.</target>
        </trans-unit>
        <trans-unit id="7f143982715c022eb1b0b1e351548f58f45f5da7" translate="yes" xml:space="preserve">
          <source>The best way to introduce code-splitting into your app is through the dynamic &lt;code&gt;import()&lt;/code&gt; syntax.</source>
          <target state="translated">Лучший способ внедрить разделение кода в ваше приложение - использовать синтаксис динамического &lt;code&gt;import()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71f1b3c82a840e802e29fee64e41fc0cc4d94466" translate="yes" xml:space="preserve">
          <source>The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys:</source>
          <target state="translated">Лучший способ выбрать ключ-это использовать строку,которая уникальным образом идентифицирует элемент списка среди своих братьев и сестер.Чаще всего в качестве ключа вы используете идентификаторы из ваших данных:</target>
        </trans-unit>
        <trans-unit id="ef94bfdedef023164021f6b1e4be76fc19c50903" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;act()&lt;/code&gt; will also flush the effects inside of them.</source>
          <target state="translated">Вызов &lt;code&gt;act()&lt;/code&gt; также сбрасывает эффекты внутри них.</target>
        </trans-unit>
        <trans-unit id="556c1bcef07eebbaa4e004179e9cfd3eeb9f0fd9" translate="yes" xml:space="preserve">
          <source>The children test instances of this test instance.</source>
          <target state="translated">Дети проверяют экземпляры этого теста.</target>
        </trans-unit>
        <trans-unit id="c6ef3d6c1361f3d575ce5bfd7aa23746e033615f" translate="yes" xml:space="preserve">
          <source>The clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the &lt;strong&gt;previous effect is cleaned up before executing the next effect&lt;/strong&gt;. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.</source>
          <target state="translated">Функция очистки запускается перед удалением компонента из пользовательского интерфейса, чтобы предотвратить утечку памяти. Кроме того, если компонент визуализируется несколько раз (как обычно), &lt;strong&gt;предыдущий эффект очищается перед выполнением следующего эффекта&lt;/strong&gt; . В нашем примере это означает, что новая подписка создается при каждом обновлении. Чтобы избежать срабатывания эффекта при каждом обновлении, обратитесь к следующему разделу.</target>
        </trans-unit>
        <trans-unit id="a0d7a14266fbc4abca5b3a288ac51756a81b9c9a" translate="yes" xml:space="preserve">
          <source>The commit phase is usually very fast, but rendering can be slow. For this reason, the upcoming async mode (which is not enabled by default yet) breaks the rendering work into pieces, pausing and resuming the work to avoid blocking the browser. This means that React may invoke render phase lifecycles more than once before committing, or it may invoke them without committing at all (because of an error or a higher priority interruption).</source>
          <target state="translated">Фаза коммита обычно очень быстрая,но рендеринг может быть медленным.По этой причине,предстоящий режим асинхронизации (который по умолчанию пока не включен)разбивает работу по рендерингу на части,останавливая и возобновляя ее,чтобы избежать блокировки браузера.Это означает,что React может вызывать жизненные циклы фазы рендеринга более одного раза перед фиксацией,или же он может вызывать их вообще без фиксации (из-за ошибки или прерывания с более высоким приоритетом).</target>
        </trans-unit>
        <trans-unit id="4da89e96ab9a876de60be2bee912c245e63ac6d3" translate="yes" xml:space="preserve">
          <source>The commit phase is usually very fast, but rendering can be slow. For this reason, the upcoming concurrent mode (which is not enabled by default yet) breaks the rendering work into pieces, pausing and resuming the work to avoid blocking the browser. This means that React may invoke render phase lifecycles more than once before committing, or it may invoke them without committing at all (because of an error or a higher priority interruption).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d925f6ec4f8cdb5a9258d473e99341d40e0c29" translate="yes" xml:space="preserve">
          <source>The common owner component is &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="translated">Компонент общего владельца - &lt;code&gt;FilterableProductTable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a63c154dead70a08be6cc8e31aeac4618b4d14ed" translate="yes" xml:space="preserve">
          <source>The compiler is of no help to us until we tell it what to do. In TypeScript, these rules are defined in a special file called &lt;code&gt;tsconfig.json&lt;/code&gt;. To generate this file:</source>
          <target state="translated">Компилятор нам не поможет, пока мы не скажем ему, что делать. В TypeScript эти правила определены в специальном файле &lt;code&gt;tsconfig.json&lt;/code&gt; . Чтобы сгенерировать этот файл:</target>
        </trans-unit>
        <trans-unit id="121cd37d21dcf9844e0b109d86b1a674e3ab8297" translate="yes" xml:space="preserve">
          <source>The complete implementation of the &lt;code&gt;Chosen&lt;/code&gt; component looks like this:</source>
          <target state="translated">Полная реализация компонента &lt;code&gt;Chosen&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="b7fdbd63cb007ae3a70e4c0ab3cbfed9aceb771a" translate="yes" xml:space="preserve">
          <source>The component below demonstrates how to make an AJAX call in &lt;code&gt;componentDidMount&lt;/code&gt; to populate local component state.</source>
          <target state="translated">Компонент ниже демонстрирует, как выполнить вызов AJAX в &lt;code&gt;componentDidMount&lt;/code&gt; для заполнения состояния локального компонента.</target>
        </trans-unit>
        <trans-unit id="1198438307a24068ab1bba755a37a1b96d2a22fd" translate="yes" xml:space="preserve">
          <source>The component can either be provided as a string, as a subclass of &lt;code&gt;React.Component&lt;/code&gt;, or a plain function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6ce7faf44f37b3dd8abfc2e0722acdb78a9da3" translate="yes" xml:space="preserve">
          <source>The component can either be provided as a string, or as a subclass of &lt;code&gt;React.Component&lt;/code&gt;, or a plain function for stateless components.</source>
          <target state="translated">Компонент может быть либо строкой, либо подклассом &lt;code&gt;React.Component&lt;/code&gt; , либо простой функцией для компонентов без состояния.</target>
        </trans-unit>
        <trans-unit id="7be5cec66fa7af4738a87fd4dc3bac4a3b9e7f65" translate="yes" xml:space="preserve">
          <source>The component instance corresponding to this test instance. It is only available for class components, as function components don&amp;rsquo;t have instances. It matches the &lt;code&gt;this&lt;/code&gt; value inside the given component.</source>
          <target state="translated">Экземпляр компонента, соответствующий этому экземпляру теста. Он доступен только для компонентов класса, поскольку у функциональных компонентов нет экземпляров. Он соответствует значению &lt;code&gt;this&lt;/code&gt; внутри данного компонента.</target>
        </trans-unit>
        <trans-unit id="1c518ce84f1f2ec0768b9431ff8843a33c87e2e0" translate="yes" xml:space="preserve">
          <source>The component type corresponding to this test instance. For example, a &lt;code&gt;&amp;lt;Button /&amp;gt;&lt;/code&gt; component has a type of &lt;code&gt;Button&lt;/code&gt;.</source>
          <target state="translated">Тип компонента, соответствующий этому экземпляру теста. Например, компонент &lt;code&gt;&amp;lt;Button /&amp;gt;&lt;/code&gt; имеет тип &lt;code&gt;Button&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a0029f3f238b96fbe9f5f708c5daccae03c6952" translate="yes" xml:space="preserve">
          <source>The constructor for a React component is called before it is mounted. When implementing the constructor for a &lt;code&gt;React.Component&lt;/code&gt; subclass, you should call &lt;code&gt;super(props)&lt;/code&gt; before any other statement. Otherwise, &lt;code&gt;this.props&lt;/code&gt; will be undefined in the constructor, which can lead to bugs.</source>
          <target state="translated">Конструктор компонента React вызывается перед его монтированием. При реализации конструктора для подкласса &lt;code&gt;React.Component&lt;/code&gt; вы должны вызывать &lt;code&gt;super(props)&lt;/code&gt; перед любым другим оператором. В противном случае &lt;code&gt;this.props&lt;/code&gt; будет неопределенным в конструкторе, что может привести к ошибкам.</target>
        </trans-unit>
        <trans-unit id="16c0031304d2df9c111be15322f423f7290b0447" translate="yes" xml:space="preserve">
          <source>The container components created by HOCs show up in the &lt;a href=&quot;https://github.com/facebook/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; like any other component. To ease debugging, choose a display name that communicates that it&amp;rsquo;s the result of a HOC.</source>
          <target state="translated">Компоненты контейнера, созданные HOC, отображаются в &lt;a href=&quot;https://github.com/facebook/react-devtools&quot;&gt;инструментах разработчика React,&lt;/a&gt; как и любой другой компонент. Чтобы упростить отладку, выберите отображаемое имя, которое сообщает, что это результат HOC.</target>
        </trans-unit>
        <trans-unit id="f005497689e0366001c3fb7c5e6cf6a2f89e046f" translate="yes" xml:space="preserve">
          <source>The default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.</source>
          <target state="translated">Поведение по умолчанию для эффектов-это запуск эффекта после каждого завершенного рендера.Таким образом,эффект всегда воссоздается,если изменяется одна из его зависимостей.</target>
        </trans-unit>
        <trans-unit id="a9abe7524edac0d7bf58996697456382aebf41d4" translate="yes" xml:space="preserve">
          <source>The definition of a &amp;ldquo;feature&amp;rdquo; is not universal, and it is up to you to choose the granularity. If you can&amp;rsquo;t come up with a list of top-level folders, you can ask the users of your product what major parts it consists of, and use their mental model as a blueprint.</source>
          <target state="translated">Определение &amp;laquo;особенности&amp;raquo; не универсально, и степень детализации зависит от вас. Если вы не можете составить список папок верхнего уровня, вы можете спросить пользователей вашего продукта, из каких основных частей он состоит, и использовать их ментальную модель в качестве образца.</target>
        </trans-unit>
        <trans-unit id="727f035106e7c393c4cb029a45dec8da874d352f" translate="yes" xml:space="preserve">
          <source>The degree of change between the most recent Next release and the most recent Latest release is approximately the same as you would find between two minor semver releases. However, &lt;strong&gt;the Next channel does not conform to semantic versioning.&lt;/strong&gt; You should expect occasional breaking changes between successive releases in the Next channel.</source>
          <target state="translated">Степень различий между самым последним выпуском Next и самым последним выпуском Latest примерно такая же, как между двумя второстепенными выпусками semver. Однако &lt;strong&gt;канал Next не соответствует семантическому управлению версиями. &lt;/strong&gt;Вы должны ожидать случайных критических изменений между последовательными выпусками в канале Next.</target>
        </trans-unit>
        <trans-unit id="11c828ed161f8e904365be750c1b6b190b0b36c6" translate="yes" xml:space="preserve">
          <source>The developer can hint at which child elements may be stable across different renders with a &lt;code&gt;key&lt;/code&gt; prop.</source>
          <target state="translated">Разработчик может намекнуть, какие дочерние элементы могут быть стабильными при разных рендерингах с помощью &lt;code&gt;key&lt;/code&gt; свойства.</target>
        </trans-unit>
        <trans-unit id="90fce0d3e59b886792d5aea4491610c01d3638de" translate="yes" xml:space="preserve">
          <source>The easiest way to avoid conflicts is to prevent the React component from updating. You can do this by rendering elements that React has no reason to update, like an empty &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Самый простой способ избежать конфликтов - предотвратить обновление компонента React. Вы можете сделать это, отрисовав элементы, которые React не нужно обновлять, например пустой &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="039378bb9c3350b891bbb97f95519708b2e90b22" translate="yes" xml:space="preserve">
          <source>The empty set of dependencies, &lt;code&gt;[]&lt;/code&gt;, means that the effect will only run once when the component mounts, and not on every re-render. The problem is that inside the &lt;code&gt;setInterval&lt;/code&gt; callback, the value of &lt;code&gt;count&lt;/code&gt; does not change, because we&amp;rsquo;ve created a closure with the value of &lt;code&gt;count&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt; as it was when the effect callback ran. Every second, this callback then calls &lt;code&gt;setCount(0 + 1)&lt;/code&gt;, so the count never goes above 1.</source>
          <target state="translated">Пустой набор зависимостей &lt;code&gt;[]&lt;/code&gt; означает, что эффект будет выполняться только один раз при монтировании компонента, а не при каждом повторном рендеринге. Проблема в том, что внутри обратного вызова &lt;code&gt;setInterval&lt;/code&gt; значение &lt;code&gt;count&lt;/code&gt; не изменяется, потому что мы создали закрытие со значением &lt;code&gt;count&lt;/code&gt; , установленным на &lt;code&gt;0&lt;/code&gt; , как это было при выполнении обратного вызова эффекта. Затем каждую секунду этот обратный вызов вызывает &lt;code&gt;setCount(0 + 1)&lt;/code&gt; , поэтому счетчик никогда не превышает 1.</target>
        </trans-unit>
        <trans-unit id="e7d18e24fe1c347ef1b3c94e07922d8cc04f6942" translate="yes" xml:space="preserve">
          <source>The event handlers below are triggered by an event in the bubbling phase. To register an event handler for the capture phase, append &lt;code&gt;Capture&lt;/code&gt; to the event name; for example, instead of using &lt;code&gt;onClick&lt;/code&gt;, you would use &lt;code&gt;onClickCapture&lt;/code&gt; to handle the click event in the capture phase.</source>
          <target state="translated">Обработчики событий ниже запускаются событием в фазе восходящей цепочки. Чтобы зарегистрировать обработчик событий для фазы захвата, добавьте &lt;code&gt;Capture&lt;/code&gt; к имени события; например, вместо того , чтобы использовать &lt;code&gt;onClick&lt;/code&gt; , вы должны использовать &lt;code&gt;onClickCapture&lt;/code&gt; обрабатывать событие щелчка в фазе захвата.</target>
        </trans-unit>
        <trans-unit id="35470d31aa9c663f5b39b9e3bf6a8825cba5c87e" translate="yes" xml:space="preserve">
          <source>The event sequence now becomes like this:</source>
          <target state="translated">Теперь последовательность событий становится такой:</target>
        </trans-unit>
        <trans-unit id="2feb552bc0b04f016976d27749dad0528ebe0952" translate="yes" xml:space="preserve">
          <source>The exact way to do this depends on the tools you use to compile JavaScript.</source>
          <target state="translated">Точный способ сделать это зависит от инструментов,которые вы используете для компиляции JavaScript.</target>
        </trans-unit>
        <trans-unit id="778ba0676987a60a9e2c8429a7aa41f2c83bff58" translate="yes" xml:space="preserve">
          <source>The example API returns a JSON object like this:</source>
          <target state="translated">Пример API возвращает JSON объект,как этот:</target>
        </trans-unit>
        <trans-unit id="2d6f789ab2260e267676497b52bf0d82f9dfacb6" translate="yes" xml:space="preserve">
          <source>The example below implements a common pattern: using the &lt;code&gt;ref&lt;/code&gt; callback to store a reference to a DOM node in an instance property.</source>
          <target state="translated">В приведенном ниже примере реализуется общий шаблон: использование обратного вызова &lt;code&gt;ref&lt;/code&gt; для хранения ссылки на узел DOM в свойстве экземпляра.</target>
        </trans-unit>
        <trans-unit id="5f9470c3b84dc932fd588852cc8390acf73521e5" translate="yes" xml:space="preserve">
          <source>The examples below demonstrate the differences.</source>
          <target state="translated">Приведенные ниже примеры демонстрируют различия.</target>
        </trans-unit>
        <trans-unit id="8caf0302f63f1367b6cfadfc61944e1907afd828" translate="yes" xml:space="preserve">
          <source>The examples below have been updated to use the &lt;code&gt;React.createRef()&lt;/code&gt; API introduced in React 16.3. If you are using an earlier release of React, we recommend using &lt;a href=&quot;#callback-refs&quot;&gt;callback refs&lt;/a&gt; instead.</source>
          <target state="translated">Приведенные ниже примеры были обновлены для использования API &lt;code&gt;React.createRef()&lt;/code&gt; представленного в React 16.3. Если вы используете более раннюю версию React, мы рекомендуем вместо этого использовать &lt;a href=&quot;#callback-refs&quot;&gt;ссылки обратного вызова&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="455e064548d40d5ab668249f72a1cd4f0163750c" translate="yes" xml:space="preserve">
          <source>The file input Tag</source>
          <target state="translated">Входной файл Тег</target>
        </trans-unit>
        <trans-unit id="eb4803464d7b9f0c8c680d9449f96660c199ce10" translate="yes" xml:space="preserve">
          <source>The filtered list of products</source>
          <target state="translated">Отфильтрованный список продукции</target>
        </trans-unit>
        <trans-unit id="782d3e0cd7b112da27839308868fb0a14dcc498e" translate="yes" xml:space="preserve">
          <source>The first argument (&lt;code&gt;child&lt;/code&gt;) is any &lt;a href=&quot;react-component#render&quot;&gt;renderable React child&lt;/a&gt;, such as an element, string, or fragment. The second argument (&lt;code&gt;container&lt;/code&gt;) is a DOM element.</source>
          <target state="translated">Первый аргумент ( &lt;code&gt;child&lt;/code&gt; элемент ) - это любой &lt;a href=&quot;react-component#render&quot;&gt;отображаемый дочерний&lt;/a&gt; элемент React , например элемент, строка или фрагмент. Второй аргумент ( &lt;code&gt;container&lt;/code&gt; ) - это элемент DOM.</target>
        </trans-unit>
        <trans-unit id="b8c5930c6860f5766726b86234129269ec281ca2" translate="yes" xml:space="preserve">
          <source>The first argument is an &lt;code&gt;updater&lt;/code&gt; function with the signature:</source>
          <target state="translated">Первый аргумент - это функция &lt;code&gt;updater&lt;/code&gt; с подписью:</target>
        </trans-unit>
        <trans-unit id="bb81ac8fd7276dc657a1d763df0cbcb0143cbe4c" translate="yes" xml:space="preserve">
          <source>The first parameter is the wrapped component. The second parameter retrieves the data we&amp;rsquo;re interested in, given a &lt;code&gt;DataSource&lt;/code&gt; and the current props.</source>
          <target state="translated">Первый параметр - это обернутый компонент. Второй параметр извлекает интересующие нас данные, учитывая &lt;code&gt;DataSource&lt;/code&gt; и текущие свойства.</target>
        </trans-unit>
        <trans-unit id="003f348ba9fdbe52c6f6090cd3f9396dc2b157db" translate="yes" xml:space="preserve">
          <source>The first part of a JSX tag determines the type of the React element.</source>
          <target state="translated">Первая часть JSX-тега определяет тип элемента React.</target>
        </trans-unit>
        <trans-unit id="917597890dc6b95bb360440dd8da1fd3c7810b0f" translate="yes" xml:space="preserve">
          <source>The first thing you&amp;rsquo;ll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. If you&amp;rsquo;re working with a designer, they may have already done this, so go talk to them! Their Photoshop layer names may end up being the names of your React components!</source>
          <target state="translated">Первое, что вам нужно сделать, это нарисовать рамки вокруг каждого компонента (и подкомпонента) в макете и дать им все имена. Если вы работаете с дизайнером, возможно, он уже это сделал, так что поговорите с ним! Их имена слоев Photoshop могут оказаться именами ваших компонентов React!</target>
        </trans-unit>
        <trans-unit id="58af51c7a5ea330490a54c507bc24a5957ec1db5" translate="yes" xml:space="preserve">
          <source>The first two tags load React. The third one will load your component code.</source>
          <target state="translated">Первые две метки загружаются Реакция.Третий загрузит код вашего компонента.</target>
        </trans-unit>
        <trans-unit id="63d7151a3f248b4aaf387f1b0df617c10a48c0cc" translate="yes" xml:space="preserve">
          <source>The following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don&amp;rsquo;t stress about learning them up front.</source>
          <target state="translated">Следующие хуки являются либо вариантами основных из предыдущего раздела, либо необходимы только для определенных крайних случаев. Не беспокойтесь о том, чтобы изучить их заранее.</target>
        </trans-unit>
        <trans-unit id="e308e9b3043ec57ac18e0b3c611264d1750d56e5" translate="yes" xml:space="preserve">
          <source>The following WCAG checklists provide an overview:</source>
          <target state="translated">Следующие контрольные списки WCAG предоставляют обзор:</target>
        </trans-unit>
        <trans-unit id="694131f03d1bab80a6c7d4c80f4b1b3a3241dee3" translate="yes" xml:space="preserve">
          <source>The following code demonstrates this. (The input is locked at first but becomes editable after a short delay.)</source>
          <target state="translated">Следующий код демонстрирует это.(Вход сначала блокируется,но после короткой задержки становится доступным для редактирования).</target>
        </trans-unit>
        <trans-unit id="6211b0539ce28a1c45c57e19f644594cc9415732" translate="yes" xml:space="preserve">
          <source>The following methods can be used in both the server and browser environments:</source>
          <target state="translated">Следующие методы могут использоваться как в серверной,так и в браузерной среде:</target>
        </trans-unit>
        <trans-unit id="9e58ff833910cac432aba7935a817cbc0b058b56" translate="yes" xml:space="preserve">
          <source>The following resources show us how to do this:</source>
          <target state="translated">Следующие ресурсы показывают нам,как это сделать:</target>
        </trans-unit>
        <trans-unit id="98a6e91ed5c938365a3d023a4ee79e40777157be" translate="yes" xml:space="preserve">
          <source>The following toolchains offer more flexibility and choice. We recommend them to more experienced users:</source>
          <target state="translated">Следующие инструментальные цепочки обеспечивают большую гибкость и выбор.Мы рекомендуем их более опытным пользователям:</target>
        </trans-unit>
        <trans-unit id="e92b55a478f169e90eff18e9f5c9f441b0eac9b2" translate="yes" xml:space="preserve">
          <source>The granularity of error boundaries is up to you. You may wrap top-level route components to display a &amp;ldquo;Something went wrong&amp;rdquo; message to the user, just like server-side frameworks often handle crashes. You may also wrap individual widgets in an error boundary to protect them from crashing the rest of the application.</source>
          <target state="translated">Степень детализации границ ошибок зависит от вас. Вы можете обернуть компоненты маршрута верхнего уровня, чтобы отобразить сообщение &amp;laquo;Что-то пошло не так&amp;raquo; для пользователя, точно так же, как серверные фреймворки часто обрабатывают сбои. Вы также можете заключить отдельные виджеты в границу ошибки, чтобы защитить их от сбоя остальной части приложения.</target>
        </trans-unit>
        <trans-unit id="2a6247bb2d42aa3e3342c1d43e5c94a83c8139f8" translate="yes" xml:space="preserve">
          <source>The inputs stay in sync because their values are computed from the same state:</source>
          <target state="translated">Входы остаются синхронизированными,так как их значения вычисляются из одного и того же состояния:</target>
        </trans-unit>
        <trans-unit id="7f76c6b2c5bda1e950d51d378999359849f255f5" translate="yes" xml:space="preserve">
          <source>The keyboard</source>
          <target state="translated">Клавиатура</target>
        </trans-unit>
        <trans-unit id="0054077e1ddf463832b68523a2ad7ad7cfc55cae" translate="yes" xml:space="preserve">
          <source>The last interesting case is C8. React had to render this component, but since the React elements it returned were equal to the previously rendered ones, it didn&amp;rsquo;t have to update the DOM.</source>
          <target state="translated">Последний интересный случай - C8. React должен был отрендерить этот компонент, но поскольку возвращаемые им элементы React были равны ранее отрисованным, обновлять DOM не пришлось.</target>
        </trans-unit>
        <trans-unit id="650917a3548229098547ab66dc585a177cef3daa" translate="yes" xml:space="preserve">
          <source>The lazy component should then be rendered inside a &lt;code&gt;Suspense&lt;/code&gt; component, which allows us to show some fallback content (such as a loading indicator) while we&amp;rsquo;re waiting for the lazy component to load.</source>
          <target state="translated">Затем ленивый компонент должен быть отрисован внутри компонента &lt;code&gt;Suspense&lt;/code&gt; , который позволяет нам отображать некоторый запасной контент (например, индикатор загрузки), пока мы ждем загрузки ленивого компонента.</target>
        </trans-unit>
        <trans-unit id="a20ca449aab3a55095a75facca274bd40f837461" translate="yes" xml:space="preserve">
          <source>The legacy context API is error-prone, and will be removed in a future major version. It still works for all 16.x releases but will show this warning message in strict mode:</source>
          <target state="translated">Унаследованное контекстное API подвержено ошибкам и будет удалено в будущей основной версии.Он все еще работает для всех версий 16.x,но будет показывать это предупреждение в строгом режиме:</target>
        </trans-unit>
        <trans-unit id="da3bba855b5bdb90a044ae1549472e5dd22f334f" translate="yes" xml:space="preserve">
          <source>The legacy context API will be removed in a future major version. Use the &lt;a href=&quot;context&quot;&gt;new context API&lt;/a&gt; introduced with version 16.3. The legacy API will continue working for all 16.x releases.</source>
          <target state="translated">Устаревший контекстный API будет удален в будущей основной версии. Используйте &lt;a href=&quot;context&quot;&gt;новый контекстный API,&lt;/a&gt; представленный в версии 16.3. Устаревший API будет продолжать работать для всех выпусков 16.x.</target>
        </trans-unit>
        <trans-unit id="81ccef2b9339e6d81469f85f907bf4389c10515e" translate="yes" xml:space="preserve">
          <source>The lifecycle methods below are marked as &amp;ldquo;legacy&amp;rdquo;. They still work, but we don&amp;rsquo;t recommend using them in the new code. You can learn more about migrating away from legacy lifecycle methods in &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">Приведенные ниже методы жизненного цикла помечены как &amp;laquo;устаревшие&amp;raquo;. Они по-прежнему работают, но мы не рекомендуем использовать их в новом коде. Вы можете узнать больше о миграции с устаревших методов жизненного цикла в &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;этом сообщении блога&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15cd4ff64ab80f5a2212f2df0011a9c029b32518" translate="yes" xml:space="preserve">
          <source>The majority of websites aren&amp;rsquo;t, and don&amp;rsquo;t need to be, single-page apps. With &lt;strong&gt;a few lines of code and no build tooling&lt;/strong&gt;, try React in a small part of your website. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.</source>
          <target state="translated">Большинство веб-сайтов не являются и не должны быть одностраничными приложениями. Имея &lt;strong&gt;несколько строк кода и не имея инструментов для сборки&lt;/strong&gt; , попробуйте React в небольшой части своего веб-сайта. Затем вы можете постепенно расширять его присутствие или оставить его в нескольких динамических виджетах.</target>
        </trans-unit>
        <trans-unit id="16f4513e10a025e9de18b63415157d7cf17b1b0f" translate="yes" xml:space="preserve">
          <source>The merging is shallow, so &lt;code&gt;this.setState({comments})&lt;/code&gt; leaves &lt;code&gt;this.state.posts&lt;/code&gt; intact, but completely replaces &lt;code&gt;this.state.comments&lt;/code&gt;.</source>
          <target state="translated">Слияние неглубокое, поэтому &lt;code&gt;this.setState({comments})&lt;/code&gt; оставляет неизменным &lt;code&gt;this.state.posts&lt;/code&gt; , но полностью заменяет &lt;code&gt;this.state.comments&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dcbdabac908b8f2fc6e0ffecf4fbddf1e58850e" translate="yes" xml:space="preserve">
          <source>The methods in this section correspond to uncommon use cases. They&amp;rsquo;re handy once in a while, but most of your components probably don&amp;rsquo;t need any of them. &lt;strong&gt;You can see most of the methods below on &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; if you click the &amp;ldquo;Show less common lifecycles&amp;rdquo; checkbox at the top of it.&lt;/strong&gt;</source>
          <target state="translated">Методы в этом разделе соответствуют необычным вариантам использования. Время от времени они бывают удобными, но большинству ваших компонентов они, вероятно, не нужны. &lt;strong&gt;Вы можете увидеть большинство из приведенных ниже методов на &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;этой диаграмме жизненного цикла,&lt;/a&gt; если установите флажок &amp;laquo;Показать менее распространенные жизненные циклы&amp;raquo; вверху.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a5a58960afc3a46f1622f9179fa142d4ab56648" translate="yes" xml:space="preserve">
          <source>The methods in this section correspond to uncommon use cases. They&amp;rsquo;re handy once in a while, but most of your components probably don&amp;rsquo;t need any of them. &lt;strong&gt;You can see most of the methods below on &lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; if you click the &amp;ldquo;Show less common lifecycles&amp;rdquo; checkbox at the top of it.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8fed08012b5625fe563e0b37a0ff08e44a38cb3" translate="yes" xml:space="preserve">
          <source>The methods in this section cover the vast majority of use cases you&amp;rsquo;ll encounter creating React components. &lt;strong&gt;For a visual reference, check out &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">Методы в этом разделе охватывают подавляющее большинство случаев использования, с которыми вы столкнетесь при создании компонентов React. &lt;strong&gt;Для наглядности ознакомьтесь с &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;этой схемой жизненного цикла&lt;/a&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4ced5c859243ea7f8a1e5d64710e4914cd027be" translate="yes" xml:space="preserve">
          <source>The methods in this section cover the vast majority of use cases you&amp;rsquo;ll encounter creating React components. &lt;strong&gt;For a visual reference, check out &lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e0c3ff6eb1184d53d22e7e647c950849c06e4c" translate="yes" xml:space="preserve">
          <source>The most common signature for HOCs looks like this:</source>
          <target state="translated">Самая распространенная подпись для HOCs выглядит так:</target>
        </trans-unit>
        <trans-unit id="01e425821d940bee1f75b9701bf9cae45803a7fb" translate="yes" xml:space="preserve">
          <source>The most common technique is to wrap the display name of the wrapped component. So if your higher-order component is named &lt;code&gt;withSubscription&lt;/code&gt;, and the wrapped component&amp;rsquo;s display name is &lt;code&gt;CommentList&lt;/code&gt;, use the display name &lt;code&gt;WithSubscription(CommentList)&lt;/code&gt;:</source>
          <target state="translated">Самый распространенный метод - обернуть отображаемое имя обернутого компонента. Поэтому, если ваш компонент более высокого уровня назван &lt;code&gt;withSubscription&lt;/code&gt; , а отображаемое имя обернутого компонента - &lt;code&gt;CommentList&lt;/code&gt; , используйте отображаемое имя &lt;code&gt;WithSubscription(CommentList)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d772efa9541ff8cc5757d21265f1b50c9976f1e3" translate="yes" xml:space="preserve">
          <source>The most important difference between &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt; is that &lt;code&gt;props&lt;/code&gt; are passed from a parent component, but &lt;code&gt;state&lt;/code&gt; is managed by the component itself. A component cannot change its &lt;code&gt;props&lt;/code&gt;, but it can change its &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">Наиболее важное различие между &lt;code&gt;state&lt;/code&gt; и &lt;code&gt;props&lt;/code&gt; состоит в том, что &lt;code&gt;props&lt;/code&gt; передаются от родительского компонента, но &lt;code&gt;state&lt;/code&gt; управляется самим компонентом. Компонент не может изменить свои &lt;code&gt;props&lt;/code&gt; , но может изменить свое &lt;code&gt;state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5da4bb3efd80371c6e943cdabe174c4c7232ece8" translate="yes" xml:space="preserve">
          <source>The most important things we learned so far are:</source>
          <target state="translated">Самые важные вещи,которые мы узнали до сих пор:</target>
        </trans-unit>
        <trans-unit id="0f3841fcee35f1e3e8f100fa6282724ddf54ce64" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;act&lt;/code&gt; comes from the &lt;a href=&quot;http://wiki.c2.com/?ArrangeActAssert&quot;&gt;Arrange-Act-Assert&lt;/a&gt; pattern.</source>
          <target state="translated">Название &lt;code&gt;act&lt;/code&gt; происходит от паттерна &lt;a href=&quot;http://wiki.c2.com/?ArrangeActAssert&quot;&gt;Arrange-Act-Assert&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5264af61d93942a8eba8291eaa575dd302096081" translate="yes" xml:space="preserve">
          <source>The names on the left aren&amp;rsquo;t a part of the React API. You can name your own state variables:</source>
          <target state="translated">Имена слева не являются частью React API. Вы можете назвать свои собственные переменные состояния:</target>
        </trans-unit>
        <trans-unit id="4a5345a128b80e8d405e799312115fb3b799e29d" translate="yes" xml:space="preserve">
          <source>The need to manage local state with a reducer in a complex component is common enough that we&amp;rsquo;ve built the &lt;code&gt;useReducer&lt;/code&gt; Hook right into React. You&amp;rsquo;ll find it together with other built-in Hooks in the &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API reference&lt;/a&gt;.</source>
          <target state="translated">Необходимость управлять локальным состоянием с помощью редуктора в сложном компоненте достаточно распространена, &lt;code&gt;useReducer&lt;/code&gt; мы встроили хук useReducer прямо в React. Вы найдете его вместе с другими встроенными хуками в &lt;a href=&quot;hooks-reference&quot;&gt;справочнике&lt;/a&gt; по Hooks API .</target>
        </trans-unit>
        <trans-unit id="9f051d87ee25566d70564d3a58864ab99806f58c" translate="yes" xml:space="preserve">
          <source>The only argument to &lt;code&gt;useState&lt;/code&gt; is the initial state. In the example above, it is &lt;code&gt;0&lt;/code&gt; because our counter starts from zero. Note that unlike &lt;code&gt;this.state&lt;/code&gt;, the state here doesn&amp;rsquo;t have to be an object &amp;mdash; although it can be if you want. The initial state argument is only used during the first render.</source>
          <target state="translated">Единственный аргумент &lt;code&gt;useState&lt;/code&gt; - это начальное состояние. В приведенном выше примере это &lt;code&gt;0&lt;/code&gt; , потому что наш счетчик начинается с нуля. Обратите внимание, что, в отличие от &lt;code&gt;this.state&lt;/code&gt; , состояние здесь не обязательно должно быть объектом - хотя может быть, если хотите. Аргумент начального состояния используется только во время первого рендеринга.</target>
        </trans-unit>
        <trans-unit id="b534a04aeb4f463839ecea6daf302d82f8c6468e" translate="yes" xml:space="preserve">
          <source>The only difference between these two examples is that the first uses regular &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;s, but the second one uses our custom &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; component with &lt;code&gt;useTransition&lt;/code&gt;.</source>
          <target state="translated">Единственная разница между этими двумя примерами заключается в том, что в первом используются обычные &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; , а во втором - наш пользовательский компонент &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; с &lt;code&gt;useTransition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="489679e8916d61c0a6ff61f577314e68b03922ae" translate="yes" xml:space="preserve">
          <source>The only method you &lt;em&gt;must&lt;/em&gt; define in a &lt;code&gt;React.Component&lt;/code&gt; subclass is called &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;. All the other methods described on this page are optional.</source>
          <target state="translated">Единственный метод, который вы &lt;em&gt;должны&lt;/em&gt; определить в подклассе &lt;code&gt;React.Component&lt;/code&gt; , называется &lt;a href=&quot;#render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt; . Все остальные методы, описанные на этой странице, не являются обязательными.</target>
        </trans-unit>
        <trans-unit id="06b09efecaccac65bc2017106119837f0fe67989" translate="yes" xml:space="preserve">
          <source>The only place where you can assign &lt;code&gt;this.state&lt;/code&gt; is the constructor.</source>
          <target state="translated">Единственное место, где вы можете назначить &lt;code&gt;this.state&lt;/code&gt; , - это конструктор.</target>
        </trans-unit>
        <trans-unit id="c3c884b2822ecc82667f90bc15a105ccc9d50096" translate="yes" xml:space="preserve">
          <source>The original list of products</source>
          <target state="translated">Оригинальный список продуктов</target>
        </trans-unit>
        <trans-unit id="4ea78638cae1dd6caebc10f10aa13e863c90b117" translate="yes" xml:space="preserve">
          <source>The original list of products is passed in as props, so that&amp;rsquo;s not state. The search text and the checkbox seem to be state since they change over time and can&amp;rsquo;t be computed from anything. And finally, the filtered list of products isn&amp;rsquo;t state because it can be computed by combining the original list of products with the search text and value of the checkbox.</source>
          <target state="translated">Исходный список продуктов передается как реквизит, так что это не состояние. Кажется, что текст поиска и флажок находятся в состоянии, поскольку они меняются со временем и не могут быть вычислены ни на чем. И, наконец, отфильтрованный список продуктов не является государственным, поскольку его можно вычислить, объединив исходный список продуктов с поисковым текстом и значением флажка.</target>
        </trans-unit>
        <trans-unit id="6f1bbb5016bd5b7f1cbbbc8bff248976ede2bdbd" translate="yes" xml:space="preserve">
          <source>The parent test instance of this test instance.</source>
          <target state="translated">Родительский тестовый экземпляр этого тестового экземпляра.</target>
        </trans-unit>
        <trans-unit id="75a37bc623c00c3288da02b16fb11939ee777c48" translate="yes" xml:space="preserve">
          <source>The problem here isn&amp;rsquo;t just about performance &amp;mdash; remounting a component causes the state of that component and all of its children to be lost.</source>
          <target state="translated">Проблема здесь не только в производительности - перемонтирование компонента приводит к потере состояния этого компонента и всех его дочерних элементов.</target>
        </trans-unit>
        <trans-unit id="15386a7181b277d545f04b8eedc8056cc4a44d6c" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;PureComponent&lt;/code&gt; will do a simple comparison between the old and new values of &lt;code&gt;this.props.words&lt;/code&gt;. Since this code mutates the &lt;code&gt;words&lt;/code&gt; array in the &lt;code&gt;handleClick&lt;/code&gt; method of &lt;code&gt;WordAdder&lt;/code&gt;, the old and new values of &lt;code&gt;this.props.words&lt;/code&gt; will compare as equal, even though the actual words in the array have changed. The &lt;code&gt;ListOfWords&lt;/code&gt; will thus not update even though it has new words that should be rendered.</source>
          <target state="translated">Проблема в том, что &lt;code&gt;PureComponent&lt;/code&gt; будет выполнять простое сравнение между старым и новым значениями &lt;code&gt;this.props.words&lt;/code&gt; . Поскольку этот код &lt;code&gt;handleClick&lt;/code&gt; массив &lt;code&gt;words&lt;/code&gt; в методе &lt;code&gt;WordAdder&lt;/code&gt; , старое и новое значения &lt;code&gt;this.props.words&lt;/code&gt; будут сравниваться как равные, даже если фактические слова в массиве изменились. Таким образом, &lt;code&gt;ListOfWords&lt;/code&gt; не будет обновляться, даже если в нем есть новые слова, которые необходимо отобразить.</target>
        </trans-unit>
        <trans-unit id="1f0ea7c5399c0c473f0cc17a73922eb556fef997" translate="yes" xml:space="preserve">
          <source>The problem is that it&amp;rsquo;s both unnecessary (you can use &lt;code&gt;this.props.color&lt;/code&gt; directly instead), and creates bugs (updates to the &lt;code&gt;color&lt;/code&gt; prop won&amp;rsquo;t be reflected in the state).</source>
          <target state="translated">Проблема в том, что в нем нет необходимости ( вместо этого вы можете использовать &lt;code&gt;this.props.color&lt;/code&gt; ) и создавать ошибки (обновления свойства &lt;code&gt;color&lt;/code&gt; не отражаются в состоянии).</target>
        </trans-unit>
        <trans-unit id="f8e70f0f5024e3a8775d44c1ce4056df7f4d3a4d" translate="yes" xml:space="preserve">
          <source>The problem is, if a context value provided by component changes, descendants that use that value won&amp;rsquo;t update if an intermediate parent returns &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;shouldComponentUpdate&lt;/code&gt;. This is totally out of control of the components using context, so there&amp;rsquo;s basically no way to reliably update the context. &lt;a href=&quot;https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076&quot;&gt;This blog post&lt;/a&gt; has a good explanation of why this is a problem and how you might get around it.</source>
          <target state="translated">Проблема в том, что если значение контекста, предоставленное компонентом, изменяется, потомки, которые используют это значение, не будут обновляться, если промежуточный родительский &lt;code&gt;shouldComponentUpdate&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; из shouldComponentUpdate . Это полностью выходит из-под контроля компонентов, использующих контекст, поэтому в принципе нет способа надежно обновить контекст. &lt;a href=&quot;https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076&quot;&gt;В этом сообщении блога&lt;/a&gt; есть хорошее объяснение того, почему это проблема и как вы можете ее решить.</target>
        </trans-unit>
        <trans-unit id="985aef5fd109f4727b2c3e05bea5a14a684f7867" translate="yes" xml:space="preserve">
          <source>The problem with this is that now we &lt;em&gt;always&lt;/em&gt; wait for both of them to be fetched. However, if it&amp;rsquo;s the &lt;em&gt;posts&lt;/em&gt; that came back first, there&amp;rsquo;s no reason to delay showing them. When fun facts load later, they won&amp;rsquo;t shift the layout because they&amp;rsquo;re already below the posts.</source>
          <target state="translated">Проблема в том, что теперь мы &lt;em&gt;всегда&lt;/em&gt; ждем, пока они оба будут извлечены. Однако, если первыми вернулись &lt;em&gt;сообщения&lt;/em&gt; , нет причин откладывать их показ. Когда забавные факты загрузятся позже, они не будут менять макет, потому что они уже находятся под сообщениями.</target>
        </trans-unit>
        <trans-unit id="03950f8935a0284b924067f2374cf9480513156a" translate="yes" xml:space="preserve">
          <source>The problem with this syntax is that a different callback is created each time the &lt;code&gt;LoggingButton&lt;/code&gt; renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.</source>
          <target state="translated">Проблема с этим синтаксисом заключается в том, что каждый раз при &lt;code&gt;LoggingButton&lt;/code&gt; создается другой обратный вызов . В большинстве случаев это нормально. Однако, если этот обратный вызов передается в качестве опоры для более низких компонентов, эти компоненты могут выполнить дополнительный повторный рендеринг. Обычно мы рекомендуем использовать привязку в конструкторе или использовать синтаксис полей класса, чтобы избежать проблем с производительностью такого рода.</target>
        </trans-unit>
        <trans-unit id="d9fe552e7244a26ea298807902943abd3f5ea401" translate="yes" xml:space="preserve">
          <source>The props corresponding to this test instance. For example, a &lt;code&gt;&amp;lt;Button size=&quot;small&quot; /&amp;gt;&lt;/code&gt; component has &lt;code&gt;{size: 'small'}&lt;/code&gt; as props.</source>
          <target state="translated">Свойства, соответствующие этому тесту. Например, компонент &lt;code&gt;&amp;lt;Button size=&quot;small&quot; /&amp;gt;&lt;/code&gt; имеет &lt;code&gt;{size: 'small'}&lt;/code&gt; качестве свойств.</target>
        </trans-unit>
        <trans-unit id="9fce336ce1bf6f03834b6fbd791d6f0d85f22369" translate="yes" xml:space="preserve">
          <source>The purpose of our &lt;code&gt;useFriendStatus&lt;/code&gt; Hook is to subscribe us to a friend&amp;rsquo;s status. This is why it takes &lt;code&gt;friendID&lt;/code&gt; as an argument, and returns whether this friend is online:</source>
          <target state="translated">Цель нашего &lt;code&gt;useFriendStatus&lt;/code&gt; - подписать нас на статус друга. Вот почему он принимает &lt;code&gt;friendID&lt;/code&gt; в качестве аргумента и возвращает, находится ли этот друг в сети:</target>
        </trans-unit>
        <trans-unit id="b6c0cdaae16617f0fa21ba142bf2809ac5269c18" translate="yes" xml:space="preserve">
          <source>The quickest way to try JSX in your project is to add this &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to your page:</source>
          <target state="translated">Самый быстрый способ попробовать JSX в своем проекте - добавить на свою страницу тег &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3a47571ee342cc7e146815342e103ee52412ecda" translate="yes" xml:space="preserve">
          <source>The reason for the stutter is simple: once rendering begins, it can&amp;rsquo;t be interrupted. So the browser can&amp;rsquo;t update the text input right after the key press. No matter how good a UI library (such as React) might look on a benchmark, if it uses blocking rendering, a certain amount of work in your components will always cause stutter. And, often, there is no easy fix.</source>
          <target state="translated">Причина заикания проста: как только рендеринг начинается, его нельзя прерывать. Таким образом, браузер не может обновить ввод текста сразу после нажатия клавиши. Независимо от того, насколько хорошо UI-библиотека (такая как React) может выглядеть на тесте, если она использует блокирующий рендеринг, определенный объем работы в ваших компонентах всегда будет вызывать заикание. И часто нет простого решения.</target>
        </trans-unit>
        <trans-unit id="6faacd46ba2798dfe6d96de925d3e8fb01c4350a" translate="yes" xml:space="preserve">
          <source>The result looks like this:</source>
          <target state="translated">Результат выглядит так:</target>
        </trans-unit>
        <trans-unit id="61eea536517b5e0755810228e63123231a9fbc54" translate="yes" xml:space="preserve">
          <source>The same functionality can be achieved by using appropriate event handlers instead, such as &lt;code&gt;onBlur&lt;/code&gt; and &lt;code&gt;onFocus&lt;/code&gt;:</source>
          <target state="translated">Такой же функциональности можно достичь, используя вместо этого соответствующие обработчики событий, такие как &lt;code&gt;onBlur&lt;/code&gt; и &lt;code&gt;onFocus&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d7784002558cdfc24a42cb236b2e3ce3aa1c6451" translate="yes" xml:space="preserve">
          <source>The search text the user has entered</source>
          <target state="translated">Текст поиска,введенный пользователем</target>
        </trans-unit>
        <trans-unit id="271217a1e95a4db6a472aae868aac48af77b167f" translate="yes" xml:space="preserve">
          <source>The second &lt;code&gt;ref&lt;/code&gt; argument only exists when you define a component with &lt;code&gt;React.forwardRef&lt;/code&gt; call. Regular function or class components don&amp;rsquo;t receive the &lt;code&gt;ref&lt;/code&gt; argument, and ref is not available in props either.</source>
          <target state="translated">Второй аргумент &lt;code&gt;ref&lt;/code&gt; существует только тогда, когда вы определяете компонент с &lt;code&gt;React.forwardRef&lt;/code&gt; вызова React.forwardRef . Обычные компоненты функции или класса не получают аргумент &lt;code&gt;ref&lt;/code&gt; , а ref также недоступен в props.</target>
        </trans-unit>
        <trans-unit id="55fe0f7cb0bc62f87df6f7b88593c40ba2275b33" translate="yes" xml:space="preserve">
          <source>The second parameter to &lt;code&gt;setState()&lt;/code&gt; is an optional callback function that will be executed once &lt;code&gt;setState&lt;/code&gt; is completed and the component is re-rendered. Generally we recommend using &lt;code&gt;componentDidUpdate()&lt;/code&gt; for such logic instead.</source>
          <target state="translated">Второй параметр для &lt;code&gt;setState()&lt;/code&gt; - это необязательная функция обратного вызова, которая будет выполнена после завершения &lt;code&gt;setState&lt;/code&gt; и повторной визуализации компонента. Обычно для такой логики мы рекомендуем использовать &lt;code&gt;componentDidUpdate()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f35ac8c2adbf99f7b5bef181874b520f98344d20" translate="yes" xml:space="preserve">
          <source>The select Tag</source>
          <target state="translated">Выберите Tag</target>
        </trans-unit>
        <trans-unit id="07e95df1e5b40e195c7db30f2c1280116b62015e" translate="yes" xml:space="preserve">
          <source>The signature is identical to &lt;code&gt;useEffect&lt;/code&gt;, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside &lt;code&gt;useLayoutEffect&lt;/code&gt; will be flushed synchronously, before the browser has a chance to paint.</source>
          <target state="translated">Подпись идентична &lt;code&gt;useEffect&lt;/code&gt; , но срабатывает синхронно после всех мутаций DOM. Используйте это для чтения макета из DOM и синхронного повторного рендеринга. Обновления, запланированные внутри &lt;code&gt;useLayoutEffect&lt;/code&gt; , будут сброшены синхронно, прежде чем у браузера появится возможность рисовать.</target>
        </trans-unit>
        <trans-unit id="5c639e86090bfaf74758cb091cb2ea67a1fddcf3" translate="yes" xml:space="preserve">
          <source>The simplest way to avoid this problem is to avoid mutating values that you are using as props or state. For example, the &lt;code&gt;handleClick&lt;/code&gt; method above could be rewritten using &lt;code&gt;concat&lt;/code&gt; as:</source>
          <target state="translated">Самый простой способ избежать этой проблемы - избегать изменения значений, которые вы используете как свойства или состояние. Например, &lt;code&gt;handleClick&lt;/code&gt; выше метод handleClick можно переписать с помощью &lt;code&gt;concat&lt;/code&gt; как:</target>
        </trans-unit>
        <trans-unit id="71460fd47e61e6f8130d4e6e217a7bd0d4fb7bfc" translate="yes" xml:space="preserve">
          <source>The simplest way to consume &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt; models and collections from a React component is to listen to the various change events and manually force an update.</source>
          <target state="translated">Самый простой способ использовать модели и коллекции &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt; из компонента React - это прослушать различные события изменений и вручную принудительно выполнить обновление.</target>
        </trans-unit>
        <trans-unit id="c75dd6397b4e899517f186ce7dd6fec1fc4143c7" translate="yes" xml:space="preserve">
          <source>The simplest way to define a component is to write a JavaScript function:</source>
          <target state="translated">Самый простой способ определить компонент-это написать функцию JavaScript:</target>
        </trans-unit>
        <trans-unit id="ea592b9f9c12cb222debb92695fe41e5990f382a" translate="yes" xml:space="preserve">
          <source>The smallest React example looks like this:</source>
          <target state="translated">Самый маленький пример реакции выглядит так:</target>
        </trans-unit>
        <trans-unit id="40b2a1c643d292094f43059dfae62b82207b4ff4" translate="yes" xml:space="preserve">
          <source>The solution for this problem is to use the &lt;code&gt;React.forwardRef&lt;/code&gt; API (introduced with React 16.3). &lt;a href=&quot;forwarding-refs&quot;&gt;Learn more about it in the forwarding refs section&lt;/a&gt;.</source>
          <target state="translated">Решением этой проблемы является использование API &lt;code&gt;React.forwardRef&lt;/code&gt; (представленного в React 16.3). &lt;a href=&quot;forwarding-refs&quot;&gt;Узнайте больше об этом в разделе переадресации ссылок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e03e04eaae4ac606ca548d267f13b377ac94de6" translate="yes" xml:space="preserve">
          <source>The state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.</source>
          <target state="translated">Состояние содержит специфические для данного компонента данные,которые могут меняться со временем.Состояние определяется пользователем и должно быть простым JavaScript-объектом.</target>
        </trans-unit>
        <trans-unit id="d178c16b57f339917ec9004067811e1e0f7f4019" translate="yes" xml:space="preserve">
          <source>The state of each component is completely independent. Hooks are a way to reuse &lt;em&gt;stateful logic&lt;/em&gt;, not state itself. In fact, each &lt;em&gt;call&lt;/em&gt; to a Hook has a completely isolated state &amp;mdash; so you can even use the same custom Hook twice in one component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22478714b7fd0f489e81d753e9c3c235e69d54ef" translate="yes" xml:space="preserve">
          <source>The state of these components is completely independent. Hooks are a way to reuse &lt;em&gt;stateful logic&lt;/em&gt;, not state itself. In fact, each &lt;em&gt;call&lt;/em&gt; to a Hook has a completely isolated state &amp;mdash; so you can even use the same custom Hook twice in one component.</source>
          <target state="translated">Состояние этих компонентов полностью независимое. Хуки - это способ повторно использовать &lt;em&gt;логику&lt;/em&gt; с отслеживанием &lt;em&gt;состояния&lt;/em&gt; , а не само состояние. Фактически, каждый &lt;em&gt;вызов&lt;/em&gt; Hook имеет полностью изолированное состояние, поэтому вы даже можете использовать один и тот же пользовательский Hook дважды в одном компоненте.</target>
        </trans-unit>
        <trans-unit id="2641b617455464f7d6496f2f2334b192cde2dbee" translate="yes" xml:space="preserve">
          <source>The state starts as &lt;code&gt;{ count: 0 }&lt;/code&gt;, and we increment &lt;code&gt;state.count&lt;/code&gt; when the user clicks a button by calling &lt;code&gt;this.setState()&lt;/code&gt;. We&amp;rsquo;ll use snippets from this class throughout the page.</source>
          <target state="translated">Состояние начинается как &lt;code&gt;{ count: 0 }&lt;/code&gt; , и мы увеличиваем &lt;code&gt;state.count&lt;/code&gt; , когда пользователь нажимает кнопку, вызывая &lt;code&gt;this.setState()&lt;/code&gt; . Мы будем использовать фрагменты из этого класса на всей странице.</target>
        </trans-unit>
        <trans-unit id="2573196fe586fe5ec0e5e5bd258214571daa5288" translate="yes" xml:space="preserve">
          <source>The static &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; lifecycle</source>
          <target state="translated">Статический жизненный цикл &lt;code&gt;getDerivedStateFromProps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18095f89e6ec05009ccfd909d0cb8cefbc086b0a" translate="yes" xml:space="preserve">
          <source>The stream returned from this method will return a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like &lt;a href=&quot;https://www.npmjs.com/package/iconv-lite&quot;&gt;iconv-lite&lt;/a&gt;, which provides transform streams for transcoding text.</source>
          <target state="translated">Поток, возвращаемый этим методом, вернет поток байтов, закодированный в utf-8. Если вам нужен поток в другой кодировке, обратите внимание на такой проект, как &lt;a href=&quot;https://www.npmjs.com/package/iconv-lite&quot;&gt;iconv-lite&lt;/a&gt; , который предоставляет потоки преобразования для перекодирования текста.</target>
        </trans-unit>
        <trans-unit id="c23c69a9c20200b9704aea13ea549c14e1ec4040" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;Hello world!&lt;/code&gt; is available in &lt;code&gt;props.children&lt;/code&gt; in the &lt;code&gt;Welcome&lt;/code&gt; component:</source>
          <target state="translated">Строка &lt;code&gt;Hello world!&lt;/code&gt; доступен в &lt;code&gt;props.children&lt;/code&gt; в компоненте &lt;code&gt;Welcome&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89ccb3f5a789f0345b99477baf67e4ea269b0c4b" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&amp;ldquo;render prop&amp;rdquo;&lt;/a&gt; refers to a technique for sharing code between React components using a prop whose value is a function.</source>
          <target state="translated">Термин &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&amp;laquo;свойство рендеринга&amp;raquo;&lt;/a&gt; относится к методике совместного использования кода между компонентами React с использованием свойства, значение которого является функцией.</target>
        </trans-unit>
        <trans-unit id="945ad83d6f6df882982c2eea500580f8486a2610" translate="yes" xml:space="preserve">
          <source>The textarea Tag</source>
          <target state="translated">Текстильная метка</target>
        </trans-unit>
        <trans-unit id="0b75157dc01568e5ebeb7fddf73f5af3b9ebb9b6" translate="yes" xml:space="preserve">
          <source>The toolchains recommended on this page &lt;strong&gt;don&amp;rsquo;t require configuration to get started&lt;/strong&gt;.</source>
          <target state="translated">Наборы инструментов, рекомендованные на этой странице &lt;strong&gt;, не требуют настройки для начала работы&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="46c2a81a73e1db62c5ec0751bf9c3489bd2fa0f4" translate="yes" xml:space="preserve">
          <source>The tradeoff we&amp;rsquo;re making here is that &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; will be inconsistent with other components and potentially show an older item. Click &amp;ldquo;Next&amp;rdquo; a few times, and you&amp;rsquo;ll notice it. But thanks to that, we were able to cut down the transition time from 1000ms to 300ms.</source>
          <target state="translated">Компромисс, который мы здесь делаем, заключается в том, что &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; будет несовместим с другими компонентами и, возможно, покажет более старый элемент. Нажмите &amp;laquo;Далее&amp;raquo; несколько раз, и вы это заметите. Но благодаря этому мы смогли сократить время перехода с 1000 мс до 300 мс.</target>
        </trans-unit>
        <trans-unit id="12aef5cfe0207aa12a859449db31e95cefb54821" translate="yes" xml:space="preserve">
          <source>The value of the checkbox</source>
          <target state="translated">Значение флажка</target>
        </trans-unit>
        <trans-unit id="47da38aacbdc104c0e2be9e42b4998d633ad332b" translate="yes" xml:space="preserve">
          <source>The value of the ref differs depending on the type of the node:</source>
          <target state="translated">Значение ссылки отличается в зависимости от типа узла:</target>
        </trans-unit>
        <trans-unit id="8d6f43e31ac36677cfe23fbc628d0bbec73cb47d" translate="yes" xml:space="preserve">
          <source>The versions above are only meant for development, and are not suitable for production. Minified and optimized production versions of React are available at:</source>
          <target state="translated">Вышеуказанные версии предназначены только для разработки и не подходят для производства.Минимизированные и оптимизированные производственные версии React доступны по адресу:</target>
        </trans-unit>
        <trans-unit id="74ef4a162b977ab31ffac13bf23f9dcbf0227789" translate="yes" xml:space="preserve">
          <source>The virtual DOM (VDOM) is a programming concept where an ideal, or &amp;ldquo;virtual&amp;rdquo;, representation of a UI is kept in memory and synced with the &amp;ldquo;real&amp;rdquo; DOM by a library such as ReactDOM. This process is called &lt;a href=&quot;reconciliation&quot;&gt;reconciliation&lt;/a&gt;.</source>
          <target state="translated">Виртуальный DOM (VDOM) - это концепция программирования, в которой идеальное или &amp;laquo;виртуальное&amp;raquo; представление пользовательского интерфейса хранится в памяти и синхронизируется с &amp;laquo;реальной&amp;raquo; DOM библиотекой, такой как ReactDOM. Этот процесс называется &lt;a href=&quot;reconciliation&quot;&gt;примирением&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="574a3a781870e163cce88ef2b0762f4b08191e2e" translate="yes" xml:space="preserve">
          <source>The way changes are determined can cause some issues when passing objects as &lt;code&gt;value&lt;/code&gt;: see &lt;a href=&quot;#caveats&quot;&gt;Caveats&lt;/a&gt;.</source>
          <target state="translated">Способ определения изменений может вызвать некоторые проблемы при передаче объектов в качестве &lt;code&gt;value&lt;/code&gt; : см. &lt;a href=&quot;#caveats&quot;&gt;Предостережения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b1b6af3227db905819bedeb8a6cf6a56db68adc" translate="yes" xml:space="preserve">
          <source>Then add the &lt;code&gt;flow&lt;/code&gt; preset to your &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;Babel configuration&lt;/a&gt;. For example, if you configure Babel through &lt;code&gt;.babelrc&lt;/code&gt; file, it could look like this:</source>
          <target state="translated">Затем добавьте предустановку &lt;code&gt;flow&lt;/code&gt; в &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;конфигурацию Babel&lt;/a&gt; . Например, если вы настроите Babel через файл &lt;code&gt;.babelrc&lt;/code&gt; , это может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="49b398d1b5e04088832e8b4a9d6f3fd68e540ca4" translate="yes" xml:space="preserve">
          <source>Then we can focus it elsewhere in our component when needed:</source>
          <target state="translated">Тогда,при необходимости,мы сможем сфокусировать его в другом месте нашего компонента:</target>
        </trans-unit>
        <trans-unit id="9618d02f199ba8a6ff1e620695267d9b59eba053" translate="yes" xml:space="preserve">
          <source>Then you can assert:</source>
          <target state="translated">Тогда ты можешь утверждать:</target>
        </trans-unit>
        <trans-unit id="d964dac0f67b92e21c4a4e8448328868b35a75e8" translate="yes" xml:space="preserve">
          <source>Then you can update them independently with separate &lt;code&gt;setState()&lt;/code&gt; calls:</source>
          <target state="translated">Затем вы можете обновлять их независимо с помощью отдельных &lt;code&gt;setState()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4acfee1bfbaf53b3d5fb903139781650425ac98e" translate="yes" xml:space="preserve">
          <source>Then you can use it as a regular component:</source>
          <target state="translated">Тогда вы можете использовать его как обычный компонент:</target>
        </trans-unit>
        <trans-unit id="352af5a158542075e87c87aa4822f1cc90f9c371" translate="yes" xml:space="preserve">
          <source>Then, to create a production build, add the &lt;code&gt;-p&lt;/code&gt; flag to the &lt;code&gt;build&lt;/code&gt; command:</source>
          <target state="translated">Затем, чтобы создать производственную сборку, добавьте флаг &lt;code&gt;-p&lt;/code&gt; к команде &lt;code&gt;build&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b1892a438ed36b827ab226ef3f0d930f33d28ce" translate="yes" xml:space="preserve">
          <source>There are a few good use cases for refs:</source>
          <target state="translated">Есть несколько хороших примеров использования для судей:</target>
        </trans-unit>
        <trans-unit id="6693c58ee9b46421c76137aee80156eafed70d79" translate="yes" xml:space="preserve">
          <source>There are a few less commonly used built-in Hooks that you might find useful. For example, &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt; lets you subscribe to React context without introducing nesting:</source>
          <target state="translated">Есть несколько менее часто используемых встроенных хуков, которые могут вам пригодиться. Например, &lt;a href=&quot;hooks-reference#usecontext&quot;&gt; &lt;code&gt;useContext&lt;/code&gt; &lt;/a&gt; позволяет подписаться на контекст React без использования вложенности:</target>
        </trans-unit>
        <trans-unit id="67ccf0a06731ef0941dac9931fd0d028970a49b3" translate="yes" xml:space="preserve">
          <source>There are a few more heuristics, and they might change over time as we fine-tune the rule to balance finding bugs with avoiding false positives.</source>
          <target state="translated">Есть еще несколько эвристик,и со временем они могут измениться,так как мы дорабатываем правило,чтобы сбалансировать поиск ошибок с избежанием ложных срабатываний.</target>
        </trans-unit>
        <trans-unit id="fb277ba2cfa0f874f335d88ec76a246c5b350e75" translate="yes" xml:space="preserve">
          <source>There are a few problems with this. One is that the input component cannot be reused separately from the enhanced component. More crucially, if you apply another HOC to &lt;code&gt;EnhancedComponent&lt;/code&gt; that &lt;em&gt;also&lt;/em&gt; mutates &lt;code&gt;componentDidUpdate&lt;/code&gt;, the first HOC&amp;rsquo;s functionality will be overridden! This HOC also won&amp;rsquo;t work with function components, which do not have lifecycle methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f27bf7450b1f7493e5f3835cc19efaeea4250b6" translate="yes" xml:space="preserve">
          <source>There are a few problems with this. One is that the input component cannot be reused separately from the enhanced component. More crucially, if you apply another HOC to &lt;code&gt;EnhancedComponent&lt;/code&gt; that &lt;em&gt;also&lt;/em&gt; mutates &lt;code&gt;componentWillReceiveProps&lt;/code&gt;, the first HOC&amp;rsquo;s functionality will be overridden! This HOC also won&amp;rsquo;t work with function components, which do not have lifecycle methods.</source>
          <target state="translated">С этим есть несколько проблем. Во-первых, компонент ввода нельзя повторно использовать отдельно от расширенного компонента. Что еще более важно, если вы примените другой HOC к &lt;code&gt;EnhancedComponent&lt;/code&gt; , который &lt;em&gt;также&lt;/em&gt; мутирует &lt;code&gt;componentWillReceiveProps&lt;/code&gt; , функциональность первого HOC будет отменена! Этот HOC также не будет работать с функциональными компонентами, у которых нет методов жизненного цикла.</target>
        </trans-unit>
        <trans-unit id="bfc361ac490a02de7694989e5f2a21519a4e9158" translate="yes" xml:space="preserve">
          <source>There are a few ways to test React components. Broadly, they divide into two categories:</source>
          <target state="translated">Есть несколько способов проверить реактивные компоненты.В широком смысле,они делятся на две категории:</target>
        </trans-unit>
        <trans-unit id="34efc5850f64e7842db51c2c07fdbcdd7ce86bfb" translate="yes" xml:space="preserve">
          <source>There are a number of attributes that work differently between React and HTML:</source>
          <target state="translated">Существует ряд атрибутов,которые работают по-разному в React и HTML:</target>
        </trans-unit>
        <trans-unit id="094824494a1508942600fda7b6cb25cca5aedab2" translate="yes" xml:space="preserve">
          <source>There are a number of tools we can use to assist in the creation of accessible web applications.</source>
          <target state="translated">Существует ряд инструментов,которые мы можем использовать для помощи в создании доступных веб-приложений.</target>
        </trans-unit>
        <trans-unit id="63f2e85d0d652f9d1bc05d28f3438dd676ea31cf" translate="yes" xml:space="preserve">
          <source>There are just two of them: &lt;code&gt;setState()&lt;/code&gt; and &lt;code&gt;forceUpdate()&lt;/code&gt;.</source>
          <target state="translated">Их всего два: &lt;code&gt;setState()&lt;/code&gt; и &lt;code&gt;forceUpdate()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f815a5aa15ca4b033e70b18a3f7155b455cca3b" translate="yes" xml:space="preserve">
          <source>There are many pain points associated with deep directory nesting in JavaScript projects. It becomes harder to write relative imports between them, or to update those imports when the files are moved. Unless you have a very compelling reason to use a deep folder structure, consider limiting yourself to a maximum of three or four nested folders within a single project. Of course, this is only a recommendation, and it may not be relevant to your project.</source>
          <target state="translated">Существует много болевых точек,связанных с глубоким вложением каталогов в JavaScript-проектах.Становится труднее записывать относительные импорты между ними или обновлять эти импорты при перемещении файлов.Если у вас нет очень веских причин использовать глубокую структуру папок,подумайте об ограничении себя максимум тремя-четырьмя вложенными папками в рамках одного проекта.Конечно,это только рекомендация,и она может не иметь отношения к вашему проекту.</target>
        </trans-unit>
        <trans-unit id="bb52a486a0defd5e5a737df39df0a9e362d83228" translate="yes" xml:space="preserve">
          <source>There are several different ways to specify props in JSX.</source>
          <target state="translated">Есть несколько различных способов указать реквизит в JSX.</target>
        </trans-unit>
        <trans-unit id="ba31773d4580276a2fa01ba27c7c6e4050da9978" translate="yes" xml:space="preserve">
          <source>There are several ways to make sure functions have access to component attributes like &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt;, depending on which syntax and build steps you are using.</source>
          <target state="translated">Есть несколько способов убедиться, что функции имеют доступ к таким атрибутам компонентов, как &lt;code&gt;this.props&lt;/code&gt; и &lt;code&gt;this.state&lt;/code&gt; , в зависимости от того, какой синтаксис и шаги сборки вы используете.</target>
        </trans-unit>
        <trans-unit id="035c67657dec8a559bd085096871d672c1441169" translate="yes" xml:space="preserve">
          <source>There are some generic solutions to this algorithmic problem of generating the minimum number of operations to transform one tree into another. However, the &lt;a href=&quot;https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf&quot;&gt;state of the art algorithms&lt;/a&gt; have a complexity in the order of O(n&lt;sup&gt;3&lt;/sup&gt;) where n is the number of elements in the tree.</source>
          <target state="translated">Есть несколько общих решений этой алгоритмической проблемы генерации минимального числа операций для преобразования одного дерева в другое. Однако &lt;a href=&quot;https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf&quot;&gt;современные алгоритмы&lt;/a&gt; имеют сложность порядка O (n &lt;sup&gt;3&lt;/sup&gt; ), где n - количество элементов в дереве.</target>
        </trans-unit>
        <trans-unit id="bd7701becfe3cd2853a0554a2a6f2a828400586b" translate="yes" xml:space="preserve">
          <source>There are some special rules about where you can and can&amp;rsquo;t use Hooks within a component. We&amp;rsquo;ll learn them in &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="translated">Существуют некоторые особые правила относительно того, где можно и где нельзя использовать хуки в компоненте. Мы узнаем их в &lt;a href=&quot;hooks-rules&quot;&gt;Правилах хуков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5ab23a7947a8c9190ca88a94b27fa5bfa00f119" translate="yes" xml:space="preserve">
          <source>There are three things you should know about &lt;code&gt;setState()&lt;/code&gt;.</source>
          <target state="translated">Вы должны знать три вещи о &lt;code&gt;setState()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="495dcf3a5be823b2ed9fbe753129b50e1e7a9952" translate="yes" xml:space="preserve">
          <source>There are two common kinds of side effects in React components: those that don&amp;rsquo;t require cleanup, and those that do. Let&amp;rsquo;s look at this distinction in more detail.</source>
          <target state="translated">В компонентах React есть два распространенных вида побочных эффектов: те, которые не требуют очистки, и те, которые требуют очистки. Давайте рассмотрим это различие более подробно.</target>
        </trans-unit>
        <trans-unit id="7bbc4d57f5374db57bc481f127695ec68040f840" translate="yes" xml:space="preserve">
          <source>There are two different ways to initialize &lt;code&gt;useReducer&lt;/code&gt; state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:</source>
          <target state="translated">Есть два разных способа инициализировать состояние &lt;code&gt;useReducer&lt;/code&gt; . Вы можете выбрать любой из них в зависимости от сценария использования. Самый простой способ - передать начальное состояние в качестве второго аргумента:</target>
        </trans-unit>
        <trans-unit id="b5bced4d36eb8976c4c687005ab8da42f62d1581" translate="yes" xml:space="preserve">
          <source>There are two main reasons:</source>
          <target state="translated">Есть две основные причины:</target>
        </trans-unit>
        <trans-unit id="b56772a4b4c1e06b0df2a414953a659ffda40d7b" translate="yes" xml:space="preserve">
          <source>There are two main ways to get declarations for a library:</source>
          <target state="translated">Существует два основных способа получения деклараций для библиотеки:</target>
        </trans-unit>
        <trans-unit id="a32a8b81054e306fc51c8a8d5d4a6e5c26811de5" translate="yes" xml:space="preserve">
          <source>There are two types of &amp;ldquo;model&amp;rdquo; data in React: props and state. It&amp;rsquo;s important to understand the distinction between the two; skim &lt;a href=&quot;state-and-lifecycle&quot;&gt;the official React docs&lt;/a&gt; if you aren&amp;rsquo;t sure what the difference is. See also &lt;a href=&quot;faq-state#what-is-the-difference-between-state-and-props&quot;&gt;FAQ: What is the difference between state and props?&lt;/a&gt;</source>
          <target state="translated">В React есть два типа &amp;laquo;модельных&amp;raquo; данных: свойства и состояние. Важно понимать разницу между ними; просмотрите &lt;a href=&quot;state-and-lifecycle&quot;&gt;официальную документацию React,&lt;/a&gt; если вы не уверены, в чем разница. См. Также &lt;a href=&quot;faq-state#what-is-the-difference-between-state-and-props&quot;&gt;FAQ: В чем разница между состоянием и реквизитом?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="972f3aee5b48db67c62cfafa5894934c6d7a06bc" translate="yes" xml:space="preserve">
          <source>There is a JavaScript proposal to add &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread properties&lt;/a&gt; to make it easier to update objects without mutation as well:</source>
          <target state="translated">Существует предложение JavaScript добавить &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;свойства распространения объекта,&lt;/a&gt; чтобы упростить обновление объектов без изменения:</target>
        </trans-unit>
        <trans-unit id="3b6781e91bd723c7b2a32f9c7b9c767072958836" translate="yes" xml:space="preserve">
          <source>There is a common theme around Concurrent Mode features. &lt;strong&gt;Its mission is to help integrate the findings from the Human-Computer Interaction research into real UIs.&lt;/strong&gt;</source>
          <target state="translated">Есть общая тема, связанная с функциями параллельного режима. &lt;strong&gt;Его миссия - помочь интегрировать результаты исследования взаимодействия человека и компьютера в реальные пользовательские интерфейсы.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c02f2726f7bf82129cb0890af06297b7f6ef5f8" translate="yes" xml:space="preserve">
          <source>There is a new, shorter syntax you can use for declaring fragments. It looks like empty tags:</source>
          <target state="translated">Существует новый,более короткий синтаксис,который можно использовать для декларирования фрагментов.Он выглядит как пустые теги:</target>
        </trans-unit>
        <trans-unit id="268f6fed8cb60468299ecf4640f5b215834edb2a" translate="yes" xml:space="preserve">
          <source>There is a simpler way to solve this. &lt;strong&gt;Instead of making the transition shorter, we can &amp;ldquo;disconnect&amp;rdquo; the slow component from the transition&lt;/strong&gt; by wrapping it into &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Есть более простой способ решить эту проблему. &lt;strong&gt;Вместо того, чтобы делать переход короче, мы можем &amp;laquo;отсоединить&amp;raquo; медленный компонент от перехода&lt;/strong&gt; , заключив его в &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2255fef7c8ea4db88004b8c5dca9f64337cd0c4f" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://flow.org/en/docs/config/options/#toc-all-boolean&quot;&gt;an option&lt;/a&gt; to force Flow to check &lt;em&gt;all&lt;/em&gt; files regardless of the annotation. This can be too noisy for existing projects, but is reasonable for a new project if you want to fully type it with Flow.</source>
          <target state="translated">Также есть &lt;a href=&quot;https://flow.org/en/docs/config/options/#toc-all-boolean&quot;&gt;возможность&lt;/a&gt; заставить Flow проверять &lt;em&gt;все&lt;/em&gt; файлы независимо от аннотации. Это может быть слишком шумно для существующих проектов, но разумно для нового проекта, если вы хотите полностью ввести его с помощью Flow.</target>
        </trans-unit>
        <trans-unit id="7a6f37ffca9a0422d14d4f49211218871c0bda6b" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;#short-syntax&quot;&gt;short syntax&lt;/a&gt; for declaring them.</source>
          <target state="translated">Существует также новый &lt;a href=&quot;#short-syntax&quot;&gt;короткий синтаксис&lt;/a&gt; для их объявления.</target>
        </trans-unit>
        <trans-unit id="f70442d13f0b33081b997d454535c8bb3c00192d" translate="yes" xml:space="preserve">
          <source>There is an internal list of &amp;ldquo;memory cells&amp;rdquo; associated with each component. They&amp;rsquo;re just JavaScript objects where we can put some data. When you call a Hook like &lt;code&gt;useState()&lt;/code&gt;, it reads the current cell (or initializes it during the first render), and then moves the pointer to the next one. This is how multiple &lt;code&gt;useState()&lt;/code&gt; calls each get independent local state.</source>
          <target state="translated">С каждым компонентом связан внутренний список &amp;laquo;ячеек памяти&amp;raquo;. Это просто объекты JavaScript, куда мы можем поместить некоторые данные. Когда вы вызываете Hook, например &lt;code&gt;useState()&lt;/code&gt; , он считывает текущую ячейку (или инициализирует ее во время первого рендеринга), а затем перемещает указатель на следующую. Вот так каждый из нескольких &lt;code&gt;useState()&lt;/code&gt; получает независимое локальное состояние.</target>
        </trans-unit>
        <trans-unit id="d22c59ace56ae0e2f33663b9156aad827b310eee" translate="yes" xml:space="preserve">
          <source>There is no special code for handling updates because &lt;code&gt;useEffect&lt;/code&gt; handles them &lt;em&gt;by default&lt;/em&gt;. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:</source>
          <target state="translated">Специального кода для обработки обновлений нет, потому что &lt;code&gt;useEffect&lt;/code&gt; обрабатывает их &lt;em&gt;по умолчанию&lt;/em&gt; . Он очищает предыдущие эффекты перед применением следующих эффектов. Чтобы проиллюстрировать это, вот последовательность вызовов подписки и отказа от подписки, которые этот компонент может производить с течением времени:</target>
        </trans-unit>
        <trans-unit id="642dbc420d30f0e2507cbd973e44025c3ff1e85c" translate="yes" xml:space="preserve">
          <source>There is no special meaning to either &lt;code&gt;temperature&lt;/code&gt; or &lt;code&gt;onTemperatureChange&lt;/code&gt; prop names in custom components. We could have called them anything else, like name them &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;onChange&lt;/code&gt; which is a common convention.</source>
          <target state="translated">В пользовательских компонентах нет специального значения ни для &lt;code&gt;temperature&lt;/code&gt; ни для имен &lt;code&gt;onTemperatureChange&lt;/code&gt; . Мы могли бы назвать их как угодно, например, называть их &lt;code&gt;value&lt;/code&gt; и &lt;code&gt;onChange&lt;/code&gt; , что является общепринятым соглашением.</target>
        </trans-unit>
        <trans-unit id="67cb15262522dd0a8cac5f7e753834e720749476" translate="yes" xml:space="preserve">
          <source>There is no step four. &lt;strong&gt;You have just added the first React component to your website.&lt;/strong&gt;</source>
          <target state="translated">Четвертого шага нет. &lt;strong&gt;Вы только что добавили на свой сайт первый компонент React.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bdbe940e85f9c9f408b6f7b07e4942bd67b971b2" translate="yes" xml:space="preserve">
          <source>There is one caveat to the above example: refs will not get passed through. That&amp;rsquo;s because &lt;code&gt;ref&lt;/code&gt; is not a prop. Like &lt;code&gt;key&lt;/code&gt;, it&amp;rsquo;s handled differently by React. If you add a ref to a HOC, the ref will refer to the outermost container component, not the wrapped component.</source>
          <target state="translated">В приведенном выше примере есть одно предостережение: ссылки не будут переданы. Это потому, что &lt;code&gt;ref&lt;/code&gt; не является опорой. Как и &lt;code&gt;key&lt;/code&gt; , React обрабатывает его по-другому. Если вы добавите ссылку в HOC, ссылка будет ссылаться на внешний компонент контейнера, а не на завернутый компонент.</target>
        </trans-unit>
        <trans-unit id="edb71d2b04e7a94b003ba55463bb2af6d539a2e7" translate="yes" xml:space="preserve">
          <source>There should be a single &amp;ldquo;source of truth&amp;rdquo; for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the &lt;a href=&quot;state-and-lifecycle#the-data-flows-down&quot;&gt;top-down data flow&lt;/a&gt;.</source>
          <target state="translated">Должен быть единый &amp;laquo;источник истины&amp;raquo; для любых данных, которые изменяются в приложении React. Обычно состояние сначала добавляется к компоненту, которому оно нужно для рендеринга. Затем, если он нужен другим компонентам, вы можете поднять его до их ближайшего общего предка. Вместо того, чтобы пытаться синхронизировать состояние между различными компонентами, вы должны полагаться на &lt;a href=&quot;state-and-lifecycle#the-data-flows-down&quot;&gt;нисходящий поток данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50e2bee19b1efd62498d4e7cf956c72bd6a2c65c" translate="yes" xml:space="preserve">
          <source>There will be no complicated tools or install requirements &amp;mdash; &lt;strong&gt;to complete this section, you only need an internet connection, and a minute of your time.&lt;/strong&gt;</source>
          <target state="translated">Не будет никаких сложных инструментов или требований &lt;strong&gt;к&lt;/strong&gt; установке - &lt;strong&gt;для заполнения этого раздела вам понадобится только подключение к Интернету и минута вашего времени.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a00d2e6fc2d4c1af40a867da6248d449045f1b6d" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s nothing left to try rendering. Because &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; suspended, React shows the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; fallback above it in the tree: &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt;. We&amp;rsquo;re done for now.</source>
          <target state="translated">Больше нечего попробовать рендеринг. Поскольку &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; приостановлен, React показывает ближайший резервный вариант &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; над ним в дереве: &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt; . На данный момент мы закончили.</target>
        </trans-unit>
        <trans-unit id="a8630452d7c496e5f59324dba0cad19af10a411b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s nothing new inside of it &amp;mdash; the logic is copied from the components above. Just like in a component, make sure to only call other Hooks unconditionally at the top level of your custom Hook.</source>
          <target state="translated">Внутри нет ничего нового - логика скопирована с компонентов выше. Как и в случае с компонентом, убедитесь, что вы вызываете другие хуки безоговорочно только на верхнем уровне вашего пользовательского хука.</target>
        </trans-unit>
        <trans-unit id="f7952e7362764435c9ea989c8c2fb10bb29a9cee" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s still something that feels broken about &lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;our last example&lt;/a&gt;. Sure, it&amp;rsquo;s nice not to see a &amp;ldquo;bad&amp;rdquo; loading state. &lt;strong&gt;But having no indication of progress at all feels even worse!&lt;/strong&gt; When we click &amp;ldquo;Next&amp;rdquo;, nothing happens and it feels like the app is broken.</source>
          <target state="translated">В &lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;нашем последнем примере&lt;/a&gt; все еще есть что-то, что кажется сломанным . Конечно, приятно не видеть &amp;laquo;плохого&amp;raquo; состояния загрузки. &lt;strong&gt;Но без каких-либо признаков прогресса - еще хуже! &lt;/strong&gt;Когда мы нажимаем &amp;laquo;Далее&amp;raquo;, ничего не происходит, и кажется, что приложение сломано.</target>
        </trans-unit>
        <trans-unit id="a6bddc517086dd36d013186f2bec7354c8db9a7c" translate="yes" xml:space="preserve">
          <source>Therefore, if the condition is &lt;code&gt;true&lt;/code&gt;, the element right after &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will appear in the output. If it is &lt;code&gt;false&lt;/code&gt;, React will ignore and skip it.</source>
          <target state="translated">Следовательно, если условие &lt;code&gt;true&lt;/code&gt; , в выводе появится элемент сразу после &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; . Если оно &lt;code&gt;false&lt;/code&gt; , React проигнорирует и пропустит его.</target>
        </trans-unit>
        <trans-unit id="acf42ba40fc8ff04bd47c18be64214611d7241a1" translate="yes" xml:space="preserve">
          <source>These acronyms all refer to the most recent versions of the ECMAScript Language Specification standard, which the JavaScript language is an implementation of. The ES6 version (also known as ES2015) includes many additions to the previous versions such as: arrow functions, classes, template literals, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; statements. You can learn more about specific versions &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#Versions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Все эти сокращения относятся к самым последним версиям стандарта ECMAScript Language Specification, реализацией которого является язык JavaScript. Версия ES6 (также известная как ES2015) включает множество дополнений к предыдущим версиям, например: стрелочные функции, классы, литералы шаблонов, операторы &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; . Вы можете узнать больше о конкретных версиях &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#Versions&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9c8f570a03b769a433d84e1f653f21208428d0f" translate="yes" xml:space="preserve">
          <source>These additional methods depend on a package (&lt;code&gt;stream&lt;/code&gt;) that is &lt;strong&gt;only available on the server&lt;/strong&gt;, and won&amp;rsquo;t work in the browser.</source>
          <target state="translated">Эти дополнительные методы зависят от пакета ( &lt;code&gt;stream&lt;/code&gt; ), который &lt;strong&gt;доступен только на сервере&lt;/strong&gt; , и не будут работать в браузере.</target>
        </trans-unit>
        <trans-unit id="25f2c87c8d7c38128e886a538842ed24717179ac" translate="yes" xml:space="preserve">
          <source>These features are still experimental and are subject to change. They are not yet a part of a stable React release, but you can try them in an experimental build.</source>
          <target state="translated">Эти функции все еще являются экспериментальными и могут быть изменены.Они еще не являются частью стабильного React-релиза,но вы можете попробовать их в экспериментальной сборке.</target>
        </trans-unit>
        <trans-unit id="cfd15dde0728fd1294866669352da44f07f52a05" translate="yes" xml:space="preserve">
          <source>These focus events work on all elements in the React DOM, not just form elements.</source>
          <target state="translated">Эти фокус-мероприятия работают со всеми элементами в React DOM,а не только с элементами формы.</target>
        </trans-unit>
        <trans-unit id="6edf527844fb9062eb5f03c19c4ca3c36036d6d5" translate="yes" xml:space="preserve">
          <source>These instructions are &lt;em&gt;not&lt;/em&gt; for Create React App users. Even though Create React App uses Babel under the hood, it is already configured to understand Flow. Only follow this step if you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; use Create React App.</source>
          <target state="translated">Эти инструкции &lt;em&gt;не предназначены&lt;/em&gt; для пользователей приложения Create React. Несмотря на то, что приложение Create React использует Babel под капотом, оно уже настроено для работы с Flow. Выполняйте этот шаг, только если вы &lt;em&gt;не&lt;/em&gt; используете приложение Create React.</target>
        </trans-unit>
        <trans-unit id="27cd91a26272aaf22f4c969e79b8478aeac76543" translate="yes" xml:space="preserve">
          <source>These methods are called &amp;ldquo;lifecycle methods&amp;rdquo;.</source>
          <target state="translated">Эти методы называются &amp;laquo;методами жизненного цикла&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2cf266ce8120d83117da0747bc989507336f90cb" translate="yes" xml:space="preserve">
          <source>These methods are called in the following order when an instance of a component is being created and inserted into the DOM:</source>
          <target state="translated">Эти методы вызываются в следующем порядке,когда создается экземпляр компонента и вставляется в флэш-накопитель:</target>
        </trans-unit>
        <trans-unit id="b08807c117d4211e82a119e990441e3210202eac" translate="yes" xml:space="preserve">
          <source>These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.</source>
          <target state="translated">Эти методы вызываются при ошибке во время рендеринга,в методе жизненного цикла или в конструкторе любого дочернего компонента.</target>
        </trans-unit>
        <trans-unit id="bf826c1be1dddf71c330af16e0387bbeaf491590" translate="yes" xml:space="preserve">
          <source>These methods are considered legacy and you should &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;avoid them&lt;/a&gt; in new code:</source>
          <target state="translated">Эти методы считаются устаревшими, и вам следует &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;избегать их&lt;/a&gt; в новом коде:</target>
        </trans-unit>
        <trans-unit id="5397ce3496bad1b4a47faf92ec8d097aa003eb30" translate="yes" xml:space="preserve">
          <source>These objects are called &amp;ldquo;React elements&amp;rdquo;. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</source>
          <target state="translated">Эти объекты называются &amp;laquo;элементами React&amp;raquo;. Вы можете думать о них как о описании того, что вы хотите видеть на экране. React читает эти объекты и использует их для построения модели DOM и поддержания ее в актуальном состоянии.</target>
        </trans-unit>
        <trans-unit id="7b6700f21ab8958202550e8eb63814cd2f217a46" translate="yes" xml:space="preserve">
          <source>These props work similarly to the corresponding HTML attributes, with the exception of the special cases documented above.</source>
          <target state="translated">Эти реквизиты работают аналогично соответствующим атрибутам HTML,за исключением особых случаев,описанных выше.</target>
        </trans-unit>
        <trans-unit id="57b15873af6800f6b7b4f80c07910a05fdb08912" translate="yes" xml:space="preserve">
          <source>These two code snippets are equivalent. While &lt;strong&gt;JSX is &lt;a href=&quot;react-without-jsx&quot;&gt;completely optional&lt;/a&gt;&lt;/strong&gt;, many people find it helpful for writing UI code &amp;mdash; both with React and with other libraries.</source>
          <target state="translated">Эти два фрагмента кода эквивалентны. Хотя &lt;strong&gt;JSX &lt;a href=&quot;react-without-jsx&quot;&gt;совершенно необязателен&lt;/a&gt;&lt;/strong&gt; , многие люди считают его полезным для написания кода пользовательского интерфейса - как с React, так и с другими библиотеками.</target>
        </trans-unit>
        <trans-unit id="ed106eaeea3ec56157f40637b694602b4cae386d" translate="yes" xml:space="preserve">
          <source>These two examples are identical:</source>
          <target state="translated">Эти два примера идентичны:</target>
        </trans-unit>
        <trans-unit id="56d15e879fdb4c26d55c62a23500106fee00015c" translate="yes" xml:space="preserve">
          <source>These two functions convert numbers. We will write another function that takes a string &lt;code&gt;temperature&lt;/code&gt; and a converter function as arguments and returns a string. We will use it to calculate the value of one input based on the other input.</source>
          <target state="translated">Эти две функции преобразуют числа. Мы напишем другую функцию, которая принимает в качестве аргументов &lt;code&gt;temperature&lt;/code&gt; строки и функцию преобразователя и возвращает строку. Мы будем использовать его для вычисления значения одного ввода на основе другого ввода.</target>
        </trans-unit>
        <trans-unit id="3699d971496c4c45664da21c1ceb710a806217eb" translate="yes" xml:space="preserve">
          <source>These two lines of code find the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; we added to our HTML in the first step, and then display our &amp;ldquo;Like&amp;rdquo; button React component inside of it.</source>
          <target state="translated">Эти две строки кода находят &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; ,который мы добавили в наш HTML на первом шаге, а затем отображают внутри него нашу кнопку &amp;laquo;Нравится&amp;raquo;, компонент React.</target>
        </trans-unit>
        <trans-unit id="4a0587ca694e69794c117c641540939e9bf9ef81" translate="yes" xml:space="preserve">
          <source>Think of &lt;code&gt;setState()&lt;/code&gt; as a &lt;em&gt;request&lt;/em&gt; rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. React does not guarantee that the state changes are applied immediately.</source>
          <target state="translated">Думайте о &lt;code&gt;setState()&lt;/code&gt; как о &lt;em&gt;запросе,&lt;/em&gt; а не о немедленной команде для обновления компонента. Для лучшего восприятия производительности React может отложить ее, а затем обновить несколько компонентов за один проход. React не гарантирует немедленного применения изменений состояния.</target>
        </trans-unit>
        <trans-unit id="82175a17958f607718d88007b35ef471a4c8a4fc" translate="yes" xml:space="preserve">
          <source>Think of all of the pieces of data in our example application. We have:</source>
          <target state="translated">Подумайте обо всех кусочках данных в нашем примерном приложении.У нас есть:</target>
        </trans-unit>
        <trans-unit id="a9605b9c41376c59380ce0d49a74b0c4e4dec5fc" translate="yes" xml:space="preserve">
          <source>Thinking in React</source>
          <target state="translated">Мыслить в ответ</target>
        </trans-unit>
        <trans-unit id="1ac9e8ec0e64fdd160c9350d87ed590c03f195a8" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://github.com/facebook/react/issues/11527#issuecomment-360199710&quot;&gt;GitHub comment&lt;/a&gt; dives deep into the specific examples.</source>
          <target state="translated">Этот &lt;a href=&quot;https://github.com/facebook/react/issues/11527#issuecomment-360199710&quot;&gt;комментарий GitHub&lt;/a&gt; подробно описывает конкретные примеры.</target>
        </trans-unit>
        <trans-unit id="80ff15eb59c42a69211ff51d176242fbe4d315e0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;resource&lt;/code&gt; object represents the data that isn&amp;rsquo;t there yet, but might eventually get loaded. When we call &lt;code&gt;read()&lt;/code&gt;, we either get the data, or the component &amp;ldquo;suspends&amp;rdquo;.</source>
          <target state="translated">Этот объект &lt;code&gt;resource&lt;/code&gt; представляет данные, которых еще нет, но которые в конечном итоге могут быть загружены. Когда мы вызываем &lt;code&gt;read()&lt;/code&gt; , мы либо получаем данные, либо компонент &amp;laquo;приостанавливается&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="476f561e8a18c3f9a07a3bccf37bcc7bf21f3874" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;inversion of control&lt;/em&gt; can make your code cleaner in many cases by reducing the amount of props you need to pass through your application and giving more control to the root components. However, this isn&amp;rsquo;t the right choice in every case: moving more complexity higher in the tree makes those higher-level components more complicated and forces the lower-level components to be more flexible than you may want.</source>
          <target state="translated">Эта &lt;em&gt;инверсия управления&lt;/em&gt; может сделать ваш код более чистым во многих случаях за счет уменьшения количества пропсов, которые вам нужно передать через ваше приложение, и предоставления большего контроля корневым компонентам. Однако это не правильный выбор в каждом случае: перемещение большей сложности выше в дереве делает эти компоненты более высокого уровня более сложными и заставляет компоненты более низкого уровня быть более гибкими, чем вы можете захотеть.</target>
        </trans-unit>
        <trans-unit id="c2d8fcc8f1d3d88cd2e77fadce662c854a2e0c6b" translate="yes" xml:space="preserve">
          <source>This API was introduced as a replacement of the deprecated &lt;code&gt;React.addons.cloneWithProps()&lt;/code&gt;.</source>
          <target state="translated">Этот API был представлен как замена устаревшего &lt;code&gt;React.addons.cloneWithProps()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65ff46d55592f673e6ce548bfba9bb56b9ccffbe" translate="yes" xml:space="preserve">
          <source>This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and function components. And because it&amp;rsquo;s a pure function, it&amp;rsquo;s composable with other HOCs, or even with itself.</source>
          <target state="translated">Этот HOC имеет ту же функциональность, что и изменяющаяся версия, при этом избегая возможности конфликтов. Он одинаково хорошо работает с классовыми и функциональными компонентами. И поскольку это чистая функция, ее можно комбинировать с другими HOC или даже с самим собой.</target>
        </trans-unit>
        <trans-unit id="d22c37d9cec94e4690e2dd97d9efbf3bb2f8b371" translate="yes" xml:space="preserve">
          <source>This JavaScript syntax is called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;&amp;ldquo;array destructuring&amp;rdquo;&lt;/a&gt;. It means that we&amp;rsquo;re making two new variables &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;setFruit&lt;/code&gt;, where &lt;code&gt;fruit&lt;/code&gt; is set to the first value returned by &lt;code&gt;useState&lt;/code&gt;, and &lt;code&gt;setFruit&lt;/code&gt; is the second. It is equivalent to this code:</source>
          <target state="translated">Этот синтаксис JavaScript называется &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;&amp;laquo;деструктуризация массива&amp;raquo;&lt;/a&gt; . Это означает, что мы создаем две новые переменные &lt;code&gt;fruit&lt;/code&gt; и &lt;code&gt;setFruit&lt;/code&gt; , где для &lt;code&gt;fruit&lt;/code&gt; установлено первое значение, возвращаемое &lt;code&gt;useState&lt;/code&gt; , а для &lt;code&gt;setFruit&lt;/code&gt; - второе. Это эквивалентно этому коду:</target>
        </trans-unit>
        <trans-unit id="f39d319ca5796008fa8e12b9089eeb33281858c9" translate="yes" xml:space="preserve">
          <source>This allows us to start showing the new text for the &lt;code&gt;input&lt;/code&gt; immediately, which allows the webpage to feel responsive. Meanwhile, &lt;code&gt;MySlowList&lt;/code&gt; &amp;ldquo;lag behind&amp;rdquo; for up to 2 seconds according to the &lt;code&gt;timeoutMs&lt;/code&gt; before updating, allowing it to render with the current text in the background.</source>
          <target state="translated">Это позволяет нам немедленно начать показывать новый текст для &lt;code&gt;input&lt;/code&gt; , что позволяет веб-странице чувствовать себя отзывчивой. Между тем, &lt;code&gt;MySlowList&lt;/code&gt; &amp;laquo;отстает&amp;raquo; на срок до 2 секунд согласно &lt;code&gt;timeoutMs&lt;/code&gt; перед обновлением, что позволяет отображать его с текущим текстом в фоновом режиме.</target>
        </trans-unit>
        <trans-unit id="2faedabcd971bfb80a56e6a80e4761e335043c56" translate="yes" xml:space="preserve">
          <source>This allows us to start showing the new text for the &lt;code&gt;input&lt;/code&gt; immediately, which allows the webpage to feel responsive. Meanwhile, &lt;code&gt;MySlowList&lt;/code&gt; &amp;ldquo;lags behind&amp;rdquo; for up to 2 seconds according to the &lt;code&gt;timeoutMs&lt;/code&gt; before updating, allowing it to render with the current text in the background.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aada4a90bf5f5f9b0e68049574b4b5eb9269c5b" translate="yes" xml:space="preserve">
          <source>This also allows you to handle out-of-order responses with a local variable inside the effect:</source>
          <target state="translated">Это также позволяет обрабатывать нестандартные ответы с локальной переменной внутри эффекта:</target>
        </trans-unit>
        <trans-unit id="d31f740bc3cca1056bef47f761e3120ae5f4ad05" translate="yes" xml:space="preserve">
          <source>This also works for effects that have a cleanup phase:</source>
          <target state="translated">Это также работает для эффектов,которые имеют фазу очистки:</target>
        </trans-unit>
        <trans-unit id="c00c421c14ae8acb27703b9f15f007c9b9f49302" translate="yes" xml:space="preserve">
          <source>This also works for user-defined components:</source>
          <target state="translated">Это также работает для определенных пользователем компонентов:</target>
        </trans-unit>
        <trans-unit id="9dd47e6d4547b62faa16a4d7bcc454ad3c75bf3e" translate="yes" xml:space="preserve">
          <source>This approach enables the declarative API of React: You tell React what state you want the UI to be in, and it makes sure the DOM matches that state. This abstracts out the attribute manipulation, event handling, and manual DOM updating that you would otherwise have to use to build your app.</source>
          <target state="translated">Этот подход позволяет использовать декларативный API React:вы говорите React,в каком состоянии должен находиться пользовательский интерфейс,и он гарантирует,что DOM соответствует этому состоянию.Это абстрагирует манипуляцию атрибутами,обработку событий и ручное обновление DOM,которое в противном случае вам пришлось бы использовать для создания вашего приложения.</target>
        </trans-unit>
        <trans-unit id="52a664b8479bda397f841c5ef66ce5073db36b03" translate="yes" xml:space="preserve">
          <source>This approach is fine for learning and creating simple demos. However, it makes your website slow and &lt;strong&gt;isn&amp;rsquo;t suitable for production&lt;/strong&gt;. When you&amp;rsquo;re ready to move forward, remove this new &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag and the &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; attributes you&amp;rsquo;ve added. Instead, in the next section you will set up a JSX preprocessor to convert all your &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags automatically.</source>
          <target state="translated">Такой подход подходит для изучения и создания простых демонстраций. Однако это замедляет работу вашего сайта и &lt;strong&gt;не подходит для производства&lt;/strong&gt; . Когда вы будете готовы двигаться вперед, удалите этот новый &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; и добавленные вами атрибуты &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; . Вместо этого в следующем разделе вы настроите препроцессор JSX для автоматического преобразования всех ваших тегов &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc7a58c1bb894f6665e299a7d4744f572f039148" translate="yes" xml:space="preserve">
          <source>This approach will work for our specific use case, but we haven&amp;rsquo;t achieved the objective of truly encapsulating the behavior in a reusable way. Now, every time we want the mouse position for a different use case, we have to create a new component (i.e. essentially another &lt;code&gt;&amp;lt;MouseWithCat&amp;gt;&lt;/code&gt;) that renders something specifically for that use case.</source>
          <target state="translated">Этот подход будет работать для нашего конкретного варианта использования, но мы не достигли цели по-настоящему инкапсулировать поведение с возможностью повторного использования. Теперь, каждый раз, когда нам нужна позиция мыши для другого варианта использования, мы должны создавать новый компонент (то есть, по сути, другой &lt;code&gt;&amp;lt;MouseWithCat&amp;gt;&lt;/code&gt; ), который отображает что-то специально для этого варианта использования.</target>
        </trans-unit>
        <trans-unit id="2e57d12892a38e7dcd020760497cd1e93da0684e" translate="yes" xml:space="preserve">
          <source>This avoids creating an expensive object until it&amp;rsquo;s truly needed for the first time. If you use Flow or TypeScript, you can also give &lt;code&gt;getObserver()&lt;/code&gt; a non-nullable type for convenience.</source>
          <target state="translated">Это позволяет избежать создания дорогостоящего объекта до тех пор, пока он действительно не понадобится в первый раз. Если вы используете Flow или TypeScript, вы также можете предоставить &lt;code&gt;getObserver()&lt;/code&gt; для удобства тип, не допускающий значения NULL.</target>
        </trans-unit>
        <trans-unit id="f4bfd1fe7162ecd3d60fc0279dd88e809b50adee" translate="yes" xml:space="preserve">
          <source>This behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.</source>
          <target state="translated">Такое поведение обеспечивает согласованность по умолчанию и предотвращает ошибки,которые часто встречаются в компонентах класса из-за отсутствия логики обновления.</target>
        </trans-unit>
        <trans-unit id="57cd10a74bd70a6ee7ad4242517da20969dce195" translate="yes" xml:space="preserve">
          <source>This behavior is usually not relevant. It&amp;rsquo;s only mentioned here for completeness.</source>
          <target state="translated">Такое поведение обычно не актуально. Это упомянуто здесь только для полноты.</target>
        </trans-unit>
        <trans-unit id="36d268dd874440a54786b6aa3e4fd35dffcea642" translate="yes" xml:space="preserve">
          <source>This can be a problem with more complex data structures. For example, let&amp;rsquo;s say you want a &lt;code&gt;ListOfWords&lt;/code&gt; component to render a comma-separated list of words, with a parent &lt;code&gt;WordAdder&lt;/code&gt; component that lets you click a button to add a word to the list. This code does &lt;em&gt;not&lt;/em&gt; work correctly:</source>
          <target state="translated">Это может быть проблемой с более сложными структурами данных. Например, предположим, что вы хотите, &lt;code&gt;ListOfWords&lt;/code&gt; компонент ListOfWords отображал список слов, разделенных запятыми, с родительским компонентом &lt;code&gt;WordAdder&lt;/code&gt; , который позволяет вам нажать кнопку, чтобы добавить слово в список. Этот код обычно &lt;em&gt;не&lt;/em&gt; работает правильно:</target>
        </trans-unit>
        <trans-unit id="e3fd91e7d534e8d25e2851069fc549d8b17681ec" translate="yes" xml:space="preserve">
          <source>This can be useful to conditionally render React elements. This JSX renders the &lt;code&gt;&amp;lt;Header /&amp;gt;&lt;/code&gt; component only if &lt;code&gt;showHeader&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">Это может быть полезно для условного рендеринга элементов React. Это JSX делает &lt;code&gt;&amp;lt;Header /&amp;gt;&lt;/code&gt; компонент только если &lt;code&gt;showHeader&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4cda35b9ac3d3dc1a2fb8d778758e7d5c8c67eb1" translate="yes" xml:space="preserve">
          <source>This can lead to a lot of repetitive code across components. This is why &lt;strong&gt;we generally recommend to bake &lt;code&gt;useTransition&lt;/code&gt; into the &lt;em&gt;design system&lt;/em&gt; components of your app&lt;/strong&gt;. For example, we can extract the transition logic into our own &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Это может привести к появлению большого количества повторяющегося кода в компонентах. Вот почему &lt;strong&gt;мы обычно рекомендуем &lt;code&gt;useTransition&lt;/code&gt; в компоненты &lt;em&gt;дизайн-системы&lt;/em&gt; вашего приложения&lt;/strong&gt; . Например, мы можем извлечь логику перехода в наш собственный компонент &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0acb8e50c6ec942725a3ba4829c748d2a76cb440" translate="yes" xml:space="preserve">
          <source>This change has an important implication. &lt;strong&gt;As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.&lt;/strong&gt;</source>
          <target state="translated">Это изменение имеет важное значение. &lt;strong&gt;Начиная с React 16, ошибки, которые не были обнаружены ни одной границей ошибок, приводят к отключению всего дерева компонентов React.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45bd4df84d8256fb24d5cb41b9549c58035a0dac" translate="yes" xml:space="preserve">
          <source>This change means that as you migrate to React 16, you will likely uncover existing crashes in your application that have been unnoticed before. Adding error boundaries lets you provide better user experience when something goes wrong.</source>
          <target state="translated">Это изменение означает,что при переходе на React 16 вы,скорее всего,обнаружите существующие сбои в вашем приложении,которые ранее были незамечены.Добавление границ ошибок позволяет вам обеспечить лучший пользовательский опыт,когда что-то идет не так.</target>
        </trans-unit>
        <trans-unit id="6ef0e2d23198ee6495349b5b1d8a65e07c969027" translate="yes" xml:space="preserve">
          <source>This code &lt;strong&gt;will not&lt;/strong&gt; work if you transform classes with Babel. See &lt;a href=&quot;https://github.com/w3c/webcomponents/issues/587&quot;&gt;this issue&lt;/a&gt; for the discussion. Include the &lt;a href=&quot;https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs#custom-elements-es5-adapterjs&quot;&gt;custom-elements-es5-adapter&lt;/a&gt; before you load your web components to fix this issue.</source>
          <target state="translated">Этот код &lt;strong&gt;не будет&lt;/strong&gt; работать, если вы преобразовываете классы с помощью Babel. Смотрите &lt;a href=&quot;https://github.com/w3c/webcomponents/issues/587&quot;&gt;этот вопрос&lt;/a&gt; для обсуждения. Включите &lt;a href=&quot;https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs#custom-elements-es5-adapterjs&quot;&gt;custom-elements-es5-adapter&lt;/a&gt; перед загрузкой веб-компонентов, чтобы решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="75a9a87d91df5d83f693447e427e9a52b32eb756" translate="yes" xml:space="preserve">
          <source>This code calls &lt;code&gt;computeExpensiveValue(a, b)&lt;/code&gt;. But if the dependencies &lt;code&gt;[a, b]&lt;/code&gt; haven&amp;rsquo;t changed since the last value, &lt;code&gt;useMemo&lt;/code&gt; skips calling it a second time and simply reuses the last value it returned.</source>
          <target state="translated">Этот код вызывает &lt;code&gt;computeExpensiveValue(a, b)&lt;/code&gt; . Но если зависимости &lt;code&gt;[a, b]&lt;/code&gt; не изменились с момента последнего значения, &lt;code&gt;useMemo&lt;/code&gt; пропускает вызов во второй раз и просто повторно использует последнее возвращенное значение.</target>
        </trans-unit>
        <trans-unit id="81c06c00fb945143b7361b0df45a46e15659b746" translate="yes" xml:space="preserve">
          <source>This code defines a React component called &lt;code&gt;LikeButton&lt;/code&gt;. Don&amp;rsquo;t worry if you don&amp;rsquo;t understand it yet &amp;mdash; we&amp;rsquo;ll cover the building blocks of React later in our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;hands-on tutorial&lt;/a&gt; and &lt;a href=&quot;index&quot;&gt;main concepts guide&lt;/a&gt;. For now, let&amp;rsquo;s just get it showing on the screen!</source>
          <target state="translated">Этот код определяет компонент React под названием &lt;code&gt;LikeButton&lt;/code&gt; . Не волнуйтесь, если вы этого еще не понимаете - мы рассмотрим строительные блоки React позже в нашем &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;практическом руководстве&lt;/a&gt; и руководстве по &lt;a href=&quot;index&quot;&gt;основным концепциям&lt;/a&gt; . А пока давайте просто покажем это на экране!</target>
        </trans-unit>
        <trans-unit id="ec10d5aea9322aa37f3498ec1bf3e0477eec9989" translate="yes" xml:space="preserve">
          <source>This code displays a bullet list of numbers between 1 and 5.</source>
          <target state="translated">Этот код отображает пулевой список номеров от 1 до 5.</target>
        </trans-unit>
        <trans-unit id="0909f97a53314c9c73d25a10366a5436355b5bcb" translate="yes" xml:space="preserve">
          <source>This code exposes the functionality to both pointer device and keyboard users. Also note the added &lt;code&gt;aria-*&lt;/code&gt; props to support screen-reader users. For simplicity&amp;rsquo;s sake the keyboard events to enable &lt;code&gt;arrow key&lt;/code&gt; interaction of the popover options have not been implemented.</source>
          <target state="translated">Этот код предоставляет функциональные возможности как стрелочному устройству, так и пользователям клавиатуры. Также обратите внимание на добавленные реквизиты &lt;code&gt;aria-*&lt;/code&gt; для поддержки пользователей программ чтения с экрана. Для простоты не были реализованы события клавиатуры для включения взаимодействия &lt;code&gt;arrow key&lt;/code&gt; со стрелками с опциями всплывающего окна.</target>
        </trans-unit>
        <trans-unit id="d03bff01f1b2c1f0ab0a8b09ec93a5ca0ae8ec22" translate="yes" xml:space="preserve">
          <source>This code is deceptively easy to read.</source>
          <target state="translated">Этот код обманчиво легко читается.</target>
        </trans-unit>
        <trans-unit id="9c3f4795fe6fc80bbb24c51583253bdab9f12c27" translate="yes" xml:space="preserve">
          <source>This code is very readable, but unlike the examples earlier, the Suspense version doesn&amp;rsquo;t suffer from race conditions. You might be wondering why. The answer is that in the Suspense version, we don&amp;rsquo;t have to think about &lt;em&gt;time&lt;/em&gt; as much in our code. Our original code with race conditions needed to set the state &lt;em&gt;at the right moment later&lt;/em&gt;, or otherwise it would be wrong. But with Suspense, we set the state &lt;em&gt;immediately&lt;/em&gt; &amp;mdash; so it&amp;rsquo;s harder to mess it up.</source>
          <target state="translated">Этот код легко читается, но, в отличие от примеров, приведенных ранее, версия Suspense не страдает от состояния гонки. Вам может быть интересно, почему. Ответ заключается в том, что в версии Suspense нам не нужно так много думать о &lt;em&gt;времени&lt;/em&gt; в нашем коде. Наш исходный код с условиями гонки должен был установить состояние &lt;em&gt;в нужный момент позже&lt;/em&gt; , иначе это было бы неправильно. Но с Suspense мы устанавливаем состояние &lt;em&gt;сразу,&lt;/em&gt; так что испортить его сложнее.</target>
        </trans-unit>
        <trans-unit id="aa231c70c510f0fa3b63aa156a3b29b91e637dfa" translate="yes" xml:space="preserve">
          <source>This code logs &lt;code&gt;[2, 4, 6, 8, 10]&lt;/code&gt; to the console.</source>
          <target state="translated">Этот код записывает &lt;code&gt;[2, 4, 6, 8, 10]&lt;/code&gt; в консоль.</target>
        </trans-unit>
        <trans-unit id="6a6f4f287ca192e5cbaa9fe54b7458432ec57111" translate="yes" xml:space="preserve">
          <source>This code uses a &lt;code&gt;ref&lt;/code&gt; to store a reference to a DOM node:</source>
          <target state="translated">Этот код использует &lt;code&gt;ref&lt;/code&gt; сохранить ссылку на узел DOM:</target>
        </trans-unit>
        <trans-unit id="6a8d7c8fd298f61f6a8bbce768774e83c0634e4e" translate="yes" xml:space="preserve">
          <source>This command installs the latest version of Flow into your project.</source>
          <target state="translated">Эта команда устанавливает последнюю версию Flow в ваш проект.</target>
        </trans-unit>
        <trans-unit id="e2822f37a50da57c71f17598917890486aef2cbb" translate="yes" xml:space="preserve">
          <source>This command will create a Flow configuration file that you will need to commit.</source>
          <target state="translated">Эта команда создаст файл конфигурации Flow,который вам нужно будет зафиксировать.</target>
        </trans-unit>
        <trans-unit id="7e628fdea4b27c53ebdbd7cfcab1d2dfb0cb46e5" translate="yes" xml:space="preserve">
          <source>This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let&amp;rsquo;s extract a few components from it.</source>
          <target state="translated">Этот компонент может быть сложно изменить из-за всей вложенности, а также трудно повторно использовать отдельные его части. Выделим из него несколько компонентов.</target>
        </trans-unit>
        <trans-unit id="9a4e11fd53e38859e2f4e904e8bc53c30f989275" translate="yes" xml:space="preserve">
          <source>This convention helps ensure that HOCs are as flexible and reusable as possible.</source>
          <target state="translated">Эта конвенция помогает обеспечить максимальную гибкость и возможность многократного использования HOC.</target>
        </trans-unit>
        <trans-unit id="b994c283ac2682b4140498a38b7c06a032ede4f8" translate="yes" xml:space="preserve">
          <source>This demo is a teaser. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t quite make sense yet. We&amp;rsquo;ll talk more about how it works below. Keep in mind that Suspense is more of a &lt;em&gt;mechanism&lt;/em&gt;, and particular APIs like &lt;code&gt;fetchProfileData()&lt;/code&gt; or &lt;code&gt;resource.posts.read()&lt;/code&gt; in the above example are not very important. If you&amp;rsquo;re curious, you can find their definitions right in the &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;demo sandbox&lt;/a&gt;.</source>
          <target state="translated">Эта демонстрация представляет собой тизер. Не волнуйтесь, если это еще не совсем понятно. Подробнее о том, как это работает, мы поговорим ниже. Имейте в виду, что Suspense - это скорее &lt;em&gt;механизм&lt;/em&gt; , и определенные API, такие как &lt;code&gt;fetchProfileData()&lt;/code&gt; или &lt;code&gt;resource.posts.read()&lt;/code&gt; в приведенном выше примере, не очень важны. Если вам интересно, вы можете найти их определения прямо в &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;демонстрационной песочнице&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c154659e1f7cd40edb5f4f1f5bd3d6e54fcb386b" translate="yes" xml:space="preserve">
          <source>This document goes through the factors that can affect your environment and recommendations for some scenarios.</source>
          <target state="translated">В этом документе рассматриваются факторы,которые могут повлиять на вашу окружающую среду,и даются рекомендации по некоторым сценариям.</target>
        </trans-unit>
        <trans-unit id="35b8fd0fdad43cdb6f7a55761174dc27e6567773" translate="yes" xml:space="preserve">
          <source>This document will be most relevant to developers who work on frameworks, libraries, or developer tooling. Developers who use React primarily to build user-facing applications should not need to worry about our prerelease channels.</source>
          <target state="translated">Этот документ будет наиболее актуален для разработчиков,которые работают над фреймворками,библиотеками или инструментами для разработчиков.Разработчикам,использующим React в первую очередь для сборки пользовательских приложений,не следует беспокоиться о наших каналах предварительного выпуска.</target>
        </trans-unit>
        <trans-unit id="435796402e94e0bfce47d4b1891156df1a181824" translate="yes" xml:space="preserve">
          <source>This documentation always reflects the latest stable version of React. Since React 16, you can find older versions of the documentation on a &lt;a href=&quot;https://reactjs.org/versions&quot;&gt;separate page&lt;/a&gt;. Note that documentation for past versions is snapshotted at the time of the release, and isn&amp;rsquo;t being continuously updated.</source>
          <target state="translated">Эта документация всегда отражает последнюю стабильную версию React. Начиная с React 16, вы можете найти более старые версии документации на &lt;a href=&quot;https://reactjs.org/versions&quot;&gt;отдельной странице&lt;/a&gt; . Обратите внимание, что документация для прошлых версий создается во время выпуска и не обновляется постоянно.</target>
        </trans-unit>
        <trans-unit id="4f71278bd00ce0cd4a740cd181d9c507c3a29e6b" translate="yes" xml:space="preserve">
          <source>This documentation is aimed at early adopters and people who are curious. &lt;strong&gt;If you&amp;rsquo;re new to React, don&amp;rsquo;t worry about these features&lt;/strong&gt; &amp;mdash; you don&amp;rsquo;t need to learn them right now.</source>
          <target state="translated">Эта документация предназначена для первых пользователей и людей, которым интересно. &lt;strong&gt;Если вы новичок в React, не беспокойтесь об этих функциях&lt;/strong&gt; - вам не нужно изучать их прямо сейчас.</target>
        </trans-unit>
        <trans-unit id="437152ef0fb92cb09cfcc08f167fa7c209605af6" translate="yes" xml:space="preserve">
          <source>This documentation is aimed at early adopters and people who are curious. &lt;strong&gt;If you&amp;rsquo;re new to React, don&amp;rsquo;t worry about these features&lt;/strong&gt; &amp;mdash; you don&amp;rsquo;t need to learn them right now. For example, if you&amp;rsquo;re looking for a data fetching tutorial that works today, read &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; instead.</source>
          <target state="translated">Эта документация предназначена для первых пользователей и людей, которым интересно. &lt;strong&gt;Если вы новичок в React, не беспокойтесь об этих функциях&lt;/strong&gt; - вам не нужно изучать их прямо сейчас. Например, если вы ищете учебное пособие по извлечению данных, которое работает сегодня, лучше прочтите &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;эту статью&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3b7a9dc3eaa0b9d881ea28d247bfcc301b885f9" translate="yes" xml:space="preserve">
          <source>This documentation section focuses on testing strategies for the first case. While full end-to-end tests can be very useful to prevent regressions to important workflows, such tests are not concerned with React components in particular, and are out of scope of this section.</source>
          <target state="translated">Этот раздел документации посвящен тестированию стратегий для первого случая.Хотя полные сквозные тесты могут быть очень полезны для предотвращения регрессий к важным рабочим процессам,такие тесты не касаются,в частности,React-компонентов,и выходят за рамки этого раздела.</target>
        </trans-unit>
        <trans-unit id="3240812f318bd40bfe50a481d020711afec7ad2b" translate="yes" xml:space="preserve">
          <source>This documentation section focuses on testing strategies for the first case. While full end-to-end tests can be very useful to prevent regressions to important workflows, such tests are not concerned with React components in particular, and are out of the scope of this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922990d6659447b8f59207b30b32f18ac5da5266" translate="yes" xml:space="preserve">
          <source>This documentation section is useful when you want to learn more details about a particular React API. For example, &lt;a href=&quot;react-component&quot;&gt;&lt;code&gt;React.Component&lt;/code&gt; API reference&lt;/a&gt; can provide you with details on how &lt;code&gt;setState()&lt;/code&gt; works, and what different lifecycle methods are useful for.</source>
          <target state="translated">Этот раздел документации полезен, когда вы хотите узнать больше о конкретном React API. Например, &lt;a href=&quot;react-component&quot;&gt; &lt;code&gt;React.Component&lt;/code&gt; API React.Component&lt;/a&gt; может предоставить вам подробную информацию о том, как работает &lt;code&gt;setState()&lt;/code&gt; , и для чего полезны различные методы жизненного цикла.</target>
        </trans-unit>
        <trans-unit id="6e0fc508cf47e625d8de371f53892327cc9e9bdd" translate="yes" xml:space="preserve">
          <source>This does not mean it is impossible or even necessarily difficult to combine React with other ways of affecting the DOM, you just have to be mindful of what each is doing.</source>
          <target state="translated">Это не означает,что невозможно или даже обязательно трудно совместить Реакцию с другими способами воздействия на флэш-накопитель,вы просто должны помнить о том,что каждый из них делает.</target>
        </trans-unit>
        <trans-unit id="b8276e9f3cf97b98c079c64319a9395bb85c298e" translate="yes" xml:space="preserve">
          <source>This enables a better &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;error handling experience&lt;/a&gt; in React 16 and later.</source>
          <target state="translated">Это позволяет лучше &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;обрабатывать ошибки&lt;/a&gt; в React 16 и новее.</target>
        </trans-unit>
        <trans-unit id="6271e95bb91f56ffa298799cf7094cffbc64f6c4" translate="yes" xml:space="preserve">
          <source>This ensures, for example, that if both &lt;code&gt;Parent&lt;/code&gt; and &lt;code&gt;Child&lt;/code&gt; call &lt;code&gt;setState&lt;/code&gt; during a click event, &lt;code&gt;Child&lt;/code&gt; isn&amp;rsquo;t re-rendered twice. Instead, React &amp;ldquo;flushes&amp;rdquo; the state updates at the end of the browser event. This results in significant performance improvements in larger apps.</source>
          <target state="translated">Это гарантирует, что , например, если оба &lt;code&gt;Parent&lt;/code&gt; и &lt;code&gt;Child&lt;/code&gt; вызов &lt;code&gt;setState&lt;/code&gt; во время события щелчка, &lt;code&gt;Child&lt;/code&gt; не перерисовываются дважды. Вместо этого React &amp;laquo;сбрасывает&amp;raquo; обновления состояния в конце события браузера. Это приводит к значительному повышению производительности в более крупных приложениях.</target>
        </trans-unit>
        <trans-unit id="eee2a3b437fecc5c5822dcc3a1aa7661967a85bb" translate="yes" xml:space="preserve">
          <source>This example is modified for hooks from a previous example in the &lt;a href=&quot;context&quot;&gt;Context Advanced Guide&lt;/a&gt;, where you can find more information about when and how to use Context.</source>
          <target state="translated">Этот пример изменен для хуков из предыдущего примера в &lt;a href=&quot;context&quot;&gt;Расширенном руководстве&lt;/a&gt; по контексту , где вы можете найти дополнительную информацию о том, когда и как использовать контекст.</target>
        </trans-unit>
        <trans-unit id="46bc9849fafc7153a5665495ec0e17727641f27f" translate="yes" xml:space="preserve">
          <source>This example renders a counter. When you click the button, it increments the value:</source>
          <target state="translated">Этот пример показывает счетчик.При нажатии на кнопку он увеличивает значение:</target>
        </trans-unit>
        <trans-unit id="25d9404a127c52ed8d6407f955450a6c3892e5d8" translate="yes" xml:space="preserve">
          <source>This example renders a different greeting depending on the value of &lt;code&gt;isLoggedIn&lt;/code&gt; prop.</source>
          <target state="translated">В этом примере отображается другое приветствие в зависимости от значения &lt;code&gt;isLoggedIn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b723244ac7769f9d42bc741d1cc7c26e97275391" translate="yes" xml:space="preserve">
          <source>This feature was added to JavaScript in ES2018.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa578e3db7433d9dce5a039b28793d6ebc08f28" translate="yes" xml:space="preserve">
          <source>This feels a lot better! Clicking &amp;ldquo;Refresh&amp;rdquo; doesn&amp;rsquo;t pull us away from the page we&amp;rsquo;re browsing anymore. We see something is loading &amp;ldquo;inline&amp;rdquo;, and when the data is ready, it&amp;rsquo;s displayed.</source>
          <target state="translated">Это намного лучше! Нажатие &amp;laquo;Обновить&amp;raquo; больше не уводит нас от просматриваемой страницы. Мы видим, что что-то загружается &amp;laquo;встроенно&amp;raquo;, и когда данные готовы, они отображаются.</target>
        </trans-unit>
        <trans-unit id="53a0f3e6dfc92e9db69114ebee6eb233f6ffcd07" translate="yes" xml:space="preserve">
          <source>This form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases, it&amp;rsquo;s convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called &amp;ldquo;controlled components&amp;rdquo;.</source>
          <target state="translated">Эта форма имеет поведение HTML-формы по умолчанию: переход на новую страницу, когда пользователь отправляет форму. Если вам нужно такое поведение в React, оно просто работает. Но в большинстве случаев удобно иметь функцию JavaScript, которая обрабатывает отправку формы и имеет доступ к данным, которые пользователь ввел в форму. Стандартный способ добиться этого - использовать метод, называемый &amp;laquo;контролируемые компоненты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ab7820f59467fdd32ce070f1b80bfd31db68d1ae" translate="yes" xml:space="preserve">
          <source>This form may seem confusing or unnecessary, but it has a useful property. Single-argument HOCs like the one returned by the &lt;code&gt;connect&lt;/code&gt; function have the signature &lt;code&gt;Component =&amp;gt; Component&lt;/code&gt;. Functions whose output type is the same as its input type are really easy to compose together.</source>
          <target state="translated">Эта форма может показаться запутанной или ненужной, но у нее есть полезное свойство. HOC с одним аргументом, подобный тому, который возвращается функцией &lt;code&gt;connect&lt;/code&gt; имеет подпись &lt;code&gt;Component =&amp;gt; Component&lt;/code&gt; . Функции, тип вывода которых совпадает с типом ввода, действительно легко скомпоновать вместе.</target>
        </trans-unit>
        <trans-unit id="cb9e95f2893a4866bae321fd4e53d2d167c573c0" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;setState()&lt;/code&gt; is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of:</source>
          <target state="translated">Эта форма &lt;code&gt;setState()&lt;/code&gt; также является асинхронной, и несколько вызовов в течение одного цикла могут быть объединены в пакет. Например, если вы попытаетесь увеличить количество товара более одного раза в одном и том же цикле, это приведет к эквиваленту:</target>
        </trans-unit>
        <trans-unit id="42fc90231014ca33898b042e3cf5d5166ecf1c1c" translate="yes" xml:space="preserve">
          <source>This function is a valid React component because it accepts a single &amp;ldquo;props&amp;rdquo; (which stands for properties) object argument with data and returns a React element. We call such components &amp;ldquo;function components&amp;rdquo; because they are literally JavaScript functions.</source>
          <target state="translated">Эта функция является допустимым компонентом React, потому что она принимает единственный аргумент объекта &amp;laquo;props&amp;raquo; (который обозначает свойства) с данными и возвращает элемент React. Мы называем такие компоненты &amp;laquo;функциональными компонентами&amp;raquo;, потому что они буквально являются функциями JavaScript.</target>
        </trans-unit>
        <trans-unit id="ebc1a8ba6d4628a8a3c7196192f99a87a1bd99af" translate="yes" xml:space="preserve">
          <source>This funny tag syntax is neither a string nor HTML.</source>
          <target state="translated">Этот забавный синтаксис тегов не является ни строкой,ни HTML.</target>
        </trans-unit>
        <trans-unit id="4443039824b2698985c389ddf03cc24cafe1255b" translate="yes" xml:space="preserve">
          <source>This gets at the root of what Concurrent Mode is. We&amp;rsquo;ve &lt;a href=&quot;concurrent-mode-intro#intentional-loading-sequences&quot;&gt;previously said&lt;/a&gt; it&amp;rsquo;s a bit like React working on state update on a &amp;ldquo;branch&amp;rdquo;. Another way we can conceptualize is that wrapping a state update in &lt;code&gt;startTransition&lt;/code&gt; begins rendering it &lt;em&gt;&amp;ldquo;in a different universe&amp;rdquo;&lt;/em&gt;, much like in science fiction movies. We don&amp;rsquo;t &amp;ldquo;see&amp;rdquo; that universe directly &amp;mdash; but we can get a signal from it that tells us something is happening (&lt;code&gt;isPending&lt;/code&gt;). When the update is ready, our &amp;ldquo;universes&amp;rdquo; merge back together, and we see the result on the screen!</source>
          <target state="translated">Это лежит в основе того, что такое Concurrent Mode. Мы &lt;a href=&quot;concurrent-mode-intro#intentional-loading-sequences&quot;&gt;ранее говорили&lt;/a&gt; , что это немного похоже React работает на обновлении состояния на &amp;laquo;ветви&amp;raquo;. Другой способ, которым мы можем концептуализировать, заключается в том, что упаковка обновления состояния в &lt;code&gt;startTransition&lt;/code&gt; начинает отображать его &lt;em&gt;&amp;laquo;в другой вселенной&amp;raquo;&lt;/em&gt; , как в научно-фантастических фильмах. Мы не &amp;laquo;видим&amp;raquo; эту вселенную напрямую, но можем получить от нее сигнал, который сообщает нам, что что-то происходит ( &lt;code&gt;isPending&lt;/code&gt; ). Когда обновление будет готово, наши &amp;laquo;вселенные&amp;raquo; снова объединятся, и мы увидим результат на экране!</target>
        </trans-unit>
        <trans-unit id="998f34489f4bb64d39d8842ae0c316430832dd96" translate="yes" xml:space="preserve">
          <source>This guide is designed for people who prefer &lt;strong&gt;learning concepts step by step&lt;/strong&gt;. If you prefer to learn by doing, check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. You might find this guide and the tutorial complementary to each other.</source>
          <target state="translated">Это руководство предназначено для людей, которые предпочитают &lt;strong&gt;изучать концепции шаг за шагом&lt;/strong&gt; . Если вы предпочитаете учиться на практике, ознакомьтесь с нашим &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;практическим руководством&lt;/a&gt; . Вы можете найти это руководство и учебник, дополняющие друг друга.</target>
        </trans-unit>
        <trans-unit id="a85cf72b8fe4c4bfdcedf2d7561fb56fd2aca5d8" translate="yes" xml:space="preserve">
          <source>This guide occasionally uses some of the newer JavaScript syntax in the examples. If you haven&amp;rsquo;t worked with JavaScript in the last few years, &lt;a href=&quot;https://gist.github.com/gaearon/683e676101005de0add59e8bb345340c&quot;&gt;these three points&lt;/a&gt; should get you most of the way.</source>
          <target state="translated">В этом руководстве в примерах иногда используется новый синтаксис JavaScript. Если вы не работали с JavaScript в последние несколько лет, &lt;a href=&quot;https://gist.github.com/gaearon/683e676101005de0add59e8bb345340c&quot;&gt;эти три пункта&lt;/a&gt; должны помочь вам в этом.</target>
        </trans-unit>
        <trans-unit id="81e4ce45e3f3a7f95f58bb8c19a35f09c68f268f" translate="yes" xml:space="preserve">
          <source>This has an interesting implication. Even if we use a GraphQL client that collects all data requirements in a single request, &lt;em&gt;streaming the response lets us show more content sooner&lt;/em&gt;. Because we render-&lt;em&gt;as-we-fetch&lt;/em&gt; (as opposed to &lt;em&gt;after&lt;/em&gt; fetching), if &lt;code&gt;user&lt;/code&gt; appears in the response earlier than &lt;code&gt;posts&lt;/code&gt;, we&amp;rsquo;ll be able to &amp;ldquo;unlock&amp;rdquo; the outer &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary before the response even finishes. We might have missed this earlier, but even the fetch-then-render solution contained a waterfall: between fetching and rendering. Suspense doesn&amp;rsquo;t inherently suffer from this waterfall, and libraries like Relay take advantage of this.</source>
          <target state="translated">Это имеет интересный смысл. Даже если мы используем клиент GraphQL, который собирает все требования к данным в одном запросе, &lt;em&gt;потоковая передача ответа позволяет нам быстрее показывать больше контента&lt;/em&gt; . Поскольку мы визуализируем &lt;em&gt;как мы получаем выборку&lt;/em&gt; (а не &lt;em&gt;после&lt;/em&gt; выборки), если &lt;code&gt;user&lt;/code&gt; появляется в ответе раньше, чем &lt;code&gt;posts&lt;/code&gt; , мы сможем &amp;laquo;разблокировать&amp;raquo; внешнюю границу &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; еще до того, как ответ закончится. Возможно, мы пропустили это раньше, но даже решение &amp;laquo;выборка-затем-рендеринг&amp;raquo; содержало водопад: между выборкой и рендерингом. Саспенс не страдает от этого водопада, и библиотеки, такие как Relay, пользуются этим.</target>
        </trans-unit>
        <trans-unit id="ff59847832eda94cc856a80d664ae3e8945e2a20" translate="yes" xml:space="preserve">
          <source>This helper is considered legacy, and we encourage you to either use JSX or use &lt;code&gt;React.createElement()&lt;/code&gt; directly instead.</source>
          <target state="translated">Этот помощник считается устаревшим, и мы рекомендуем вам либо использовать JSX, либо &lt;code&gt;React.createElement()&lt;/code&gt; использовать React.createElement () .</target>
        </trans-unit>
        <trans-unit id="45b88d2165ef4f3c9c1467a053131dbd114d3bd3" translate="yes" xml:space="preserve">
          <source>This helps make your tests run closer to what real users would experience when using your application. The rest of these examples use &lt;code&gt;act()&lt;/code&gt; to make these guarantees.</source>
          <target state="translated">Это помогает сделать ваши тесты более близкими к тому, что будут испытывать реальные пользователи при использовании вашего приложения. В остальных примерах для обеспечения этих гарантий используется &lt;code&gt;act()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="812baa4dde898829de6f1ec51ca212cbe1c227c1" translate="yes" xml:space="preserve">
          <source>This illustrates how UI libraries, including React, typically work today. Once they start rendering an update, including creating new DOM nodes and running the code inside components, they can&amp;rsquo;t interrupt this work. We&amp;rsquo;ll call this approach &amp;ldquo;blocking rendering&amp;rdquo;.</source>
          <target state="translated">Это показывает, как библиотеки пользовательского интерфейса, включая React, обычно работают сегодня. Как только они начинают рендеринг обновления, включая создание новых узлов DOM и выполнение кода внутри компонентов, они не могут прервать эту работу. Назовем этот подход &amp;laquo;блокирующим рендерингом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fa7d8e8505d96d032001acde26d204de1f9b82ac" translate="yes" xml:space="preserve">
          <source>This includes event bubbling. An event fired from inside a portal will propagate to ancestors in the containing &lt;em&gt;React tree&lt;/em&gt;, even if those elements are not ancestors in the &lt;em&gt;DOM tree&lt;/em&gt;. Assuming the following HTML structure:</source>
          <target state="translated">Это включает всплытие событий. Событие, запущенное изнутри портала, будет распространяться на предков в содержащем его &lt;em&gt;дереве React&lt;/em&gt; , даже если эти элементы не являются предками в &lt;em&gt;дереве DOM&lt;/em&gt; . Предполагая следующую структуру HTML:</target>
        </trans-unit>
        <trans-unit id="99dc48109b6cce011425c20dc166b6aaf5634758" translate="yes" xml:space="preserve">
          <source>This is a bit simplified, and in practice solutions tend to use a mix of different approaches. Still, we will look at them in isolation to better contrast their tradeoffs.</source>
          <target state="translated">Это немного упрощено,и на практике решения,как правило,используют сочетание различных подходов.Тем не менее,мы будем рассматривать их по отдельности,чтобы лучше противопоставлять их компромиссы.</target>
        </trans-unit>
        <trans-unit id="f354ebc1c8de6bed11d9fe920271b4b204cffba6" translate="yes" xml:space="preserve">
          <source>This is a rare use case. If you need it, you can &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;use a mutable ref&lt;/a&gt; to manually store a boolean value corresponding to whether you are on the first or a subsequent render, then check that flag in your effect. (If you find yourself doing this often, you could create a custom Hook for it.)</source>
          <target state="translated">Это редкий случай использования. Если вам это нужно, вы можете &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;использовать изменяемую ссылку,&lt;/a&gt; чтобы вручную сохранить логическое значение, соответствующее тому, находитесь ли вы на первом или последующем рендере, а затем проверьте этот флаг в своем эффекте. (Если вы часто делаете это, вы можете создать для этого собственный хук.)</target>
        </trans-unit>
        <trans-unit id="75075312cba14b3581378e03695ec96938d319ac" translate="yes" xml:space="preserve">
          <source>This is a rather convoluted pattern but it shows that you can do this escape hatch optimization if you need it. It&amp;rsquo;s more bearable if you extract it to a custom Hook:</source>
          <target state="translated">Это довольно запутанный шаблон, но он показывает, что вы можете выполнить оптимизацию аварийного вывода, если вам это нужно. Это будет более терпимо, если вы извлечете его на собственный Hook:</target>
        </trans-unit>
        <trans-unit id="5227f8717f5136bb9804d5f23e2236aefaabea00" translate="yes" xml:space="preserve">
          <source>This is also &lt;strong&gt;the easiest way to integrate React into an existing website.&lt;/strong&gt; You can always add a larger toolchain if you find it helpful!</source>
          <target state="translated">Это также &lt;strong&gt;самый простой способ интегрировать React в существующий веб-сайт. &lt;/strong&gt;Вы всегда можете добавить более крупный набор инструментов, если сочтете это полезным!</target>
        </trans-unit>
        <trans-unit id="23555155fd49eb625fe9b6ee74d6f52738cd077a" translate="yes" xml:space="preserve">
          <source>This is an implementation detail so avoid relying on it directly. In the future versions, React will batch updates by default in more cases.</source>
          <target state="translated">Это деталь реализации,так что не полагайтесь на нее напрямую.В будущих версиях,React будет пакетно обновляться по умолчанию в большем количестве случаев.</target>
        </trans-unit>
        <trans-unit id="3a3631bbcc581acd6fff6b114d111cf6ae38309c" translate="yes" xml:space="preserve">
          <source>This is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render &amp;mdash; but React class components don&amp;rsquo;t have a method like this. We could extract a separate method but we would still have to call it in two places.</source>
          <target state="translated">Это потому, что во многих случаях мы хотим выполнить один и тот же побочный эффект независимо от того, был ли компонент только что смонтирован или был ли он обновлен. Концептуально мы хотим, чтобы это происходило после каждого рендеринга, но у компонентов класса React нет такого метода. Мы могли бы извлечь отдельный метод, но нам все равно пришлось бы вызывать его в двух местах.</target>
        </trans-unit>
        <trans-unit id="94660750769ee2d6cb7338105b6ef20240dc1dbe" translate="yes" xml:space="preserve">
          <source>This is because when we update a state variable, we &lt;em&gt;replace&lt;/em&gt; its value. This is different from &lt;code&gt;this.setState&lt;/code&gt; in a class, which &lt;em&gt;merges&lt;/em&gt; the updated fields into the object.</source>
          <target state="translated">Это потому, что когда мы обновляем переменную состояния, мы &lt;em&gt;заменяем&lt;/em&gt; ее значение. Это отличается от &lt;code&gt;this.setState&lt;/code&gt; в классе, который &lt;em&gt;объединяет&lt;/em&gt; обновленные поля в объект.</target>
        </trans-unit>
        <trans-unit id="2a47325c97eec71b52ae248148cefc0b2a8e23dc" translate="yes" xml:space="preserve">
          <source>This is both more convenient from the maintenance perspective (no need to keep forwarding callbacks), and avoids the callback problem altogether. Passing &lt;code&gt;dispatch&lt;/code&gt; down like this is the recommended pattern for deep updates.</source>
          <target state="translated">Это более удобно с точки зрения обслуживания (нет необходимости постоянно пересылать обратные вызовы) и в целом позволяет избежать проблемы обратного вызова. Такая передача &lt;code&gt;dispatch&lt;/code&gt; - рекомендуемый шаблон для глубоких обновлений.</target>
        </trans-unit>
        <trans-unit id="78dce35fd65045b02f21fbe73c4f3d79910e2283" translate="yes" xml:space="preserve">
          <source>This is commonly called a &amp;ldquo;top-down&amp;rdquo; or &amp;ldquo;unidirectional&amp;rdquo; data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components &amp;ldquo;below&amp;rdquo; them in the tree.</source>
          <target state="translated">Это обычно называется &amp;laquo;нисходящим&amp;raquo; или &amp;laquo;однонаправленным&amp;raquo; потоком данных. Любое состояние всегда принадлежит определенному компоненту, и любые данные или пользовательский интерфейс, производные от этого состояния, могут влиять только на компоненты &amp;laquo;ниже&amp;raquo; их в дереве.</target>
        </trans-unit>
        <trans-unit id="f263fdbfe4befbdbe35c83008d89219aa3bc1f80" translate="yes" xml:space="preserve">
          <source>This is commonly used to keep the interface responsive when you have something that renders immediately based on user input and something that needs to wait for a data fetch.</source>
          <target state="translated">Обычно это используется для того,чтобы интерфейс реагировал на изменения,когда у вас есть что-то,что сразу же выводится на основе пользовательского ввода,и что-то,что должно ждать получения данных.</target>
        </trans-unit>
        <trans-unit id="f35b27d1c72a73a47404576ed9069707f86b93da" translate="yes" xml:space="preserve">
          <source>This is enough to get our component to render, but we also want to be notified about the value changes. To do this, we will subscribe to the jQuery &lt;code&gt;change&lt;/code&gt; event on the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; managed by Chosen.</source>
          <target state="translated">Этого достаточно, чтобы наш компонент отобразился, но мы также хотим получать уведомления об изменении значения. Для этого мы подпишемся на событие &lt;code&gt;change&lt;/code&gt; jQuery в &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; , управляемом Chosen.</target>
        </trans-unit>
        <trans-unit id="76b2cd066ec6800da2e6fca46c1c5bc66a392c5d" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;.bind&lt;/code&gt;:</source>
          <target state="translated">Это эквивалентно вызову &lt;code&gt;.bind&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d3c5bf674b9409038c85e451ead5b4000258b898" translate="yes" xml:space="preserve">
          <source>This is especially useful for data fetching. It is usually preferable to use &amp;ldquo;fake&amp;rdquo; data for tests to avoid the slowness and flakiness due to fetching from real API endpoints &lt;a href=&quot;testing-recipes#data-fetching&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;. This helps make the tests predictable. Libraries like &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; and &lt;a href=&quot;https://sinonjs.org/&quot;&gt;sinon&lt;/a&gt;, among others, support mocked functions. For end-to-end tests, mocking network can be more difficult, but you might also want to test the real API endpoints in them anyway.</source>
          <target state="translated">Это особенно полезно для выборки данных. Обычно предпочтительнее использовать &amp;laquo;поддельные&amp;raquo; данные для тестов, чтобы избежать медлительности и нестабильности из-за выборки из реальных конечных точек API &lt;a href=&quot;testing-recipes#data-fetching&quot;&gt;&lt;small&gt;(пример)&lt;/small&gt;&lt;/a&gt; . Это помогает сделать тесты предсказуемыми. Такие библиотеки, как &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; и &lt;a href=&quot;https://sinonjs.org/&quot;&gt;sinon&lt;/a&gt; , среди прочих, поддерживают фиктивные функции. Для сквозных тестов имитировать сеть может быть сложнее, но вы все равно можете протестировать в них реальные конечные точки API.</target>
        </trans-unit>
        <trans-unit id="91a0acb35ae332ccbc63c94a04c970a5a6662d52" translate="yes" xml:space="preserve">
          <source>This is not React-specific behavior; it is a part of &lt;a href=&quot;https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/&quot;&gt;how functions work in JavaScript&lt;/a&gt;. Generally, if you refer to a method without &lt;code&gt;()&lt;/code&gt; after it, such as &lt;code&gt;onClick={this.handleClick}&lt;/code&gt;, you should bind that method.</source>
          <target state="translated">Это не специфичное для React поведение; это часть того, &lt;a href=&quot;https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/&quot;&gt;как функции работают в JavaScript&lt;/a&gt; . Как правило, если вы ссылаетесь на метод без &lt;code&gt;()&lt;/code&gt; после него, например &lt;code&gt;onClick={this.handleClick}&lt;/code&gt; , вы должны привязать этот метод.</target>
        </trans-unit>
        <trans-unit id="acd30756daf69694d4f232dd03c1bf787fd40f16" translate="yes" xml:space="preserve">
          <source>This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list:</source>
          <target state="translated">Это часто полезно при отрисовке списка JSX выражений произвольной длины.Например,это позволяет отрисовывать список HTML:</target>
        </trans-unit>
        <trans-unit id="5a99ff5d36d8c6c9227545d3f9b811542fdf7a14" translate="yes" xml:space="preserve">
          <source>This is one example of many cases where depending on only pointer and mouse events will break functionality for keyboard users. Always testing with the keyboard will immediately highlight the problem areas which can then be fixed by using keyboard aware event handlers.</source>
          <target state="translated">Это один из примеров многих случаев,когда в зависимости только от событий с указателем и мышью нарушается функциональность для пользователей клавиатуры.Всегда тестирование с клавиатурой сразу же выделит проблемные области,которые затем можно будет исправить с помощью обработчиков событий,знающих о событиях на клавиатуре.</target>
        </trans-unit>
        <trans-unit id="c45d9be4282e8391a17aca9ac958259838791726" translate="yes" xml:space="preserve">
          <source>This is the first chapter in a step-by-step guide about main React concepts. You can find a list of all its chapters in the navigation sidebar. If you&amp;rsquo;re reading this from a mobile device, you can access the navigation by pressing the button in the bottom right corner of your screen.</source>
          <target state="translated">Это первая глава в пошаговом руководстве по основным концепциям React. Вы можете найти список всех его глав на боковой панели навигации. Если вы читаете это с мобильного устройства, вы можете получить доступ к навигации, нажав кнопку в правом нижнем углу экрана.</target>
        </trans-unit>
        <trans-unit id="c25acae8adf4005a2b896567a72c2c799a087f8c" translate="yes" xml:space="preserve">
          <source>This is the only lifecycle method called on server rendering.</source>
          <target state="translated">Это единственный метод жизненного цикла,вызываемый при рендеринге сервера.</target>
        </trans-unit>
        <trans-unit id="81793ae769b5dc5c19104ac5a737a90042932a4e" translate="yes" xml:space="preserve">
          <source>This is typically implemented by attaching a &lt;code&gt;click&lt;/code&gt; event to the &lt;code&gt;window&lt;/code&gt; object that closes the popover:</source>
          <target state="translated">Обычно это реализуется путем присоединения события &lt;code&gt;click&lt;/code&gt; к объекту &lt;code&gt;window&lt;/code&gt; , закрывающему всплывающее окно:</target>
        </trans-unit>
        <trans-unit id="8a759a421b0f990ff09a818938bdffadcc8719ff" translate="yes" xml:space="preserve">
          <source>This is valid JSX, and &lt;code&gt;props.children&lt;/code&gt; in &lt;code&gt;MyComponent&lt;/code&gt; will simply be the string &lt;code&gt;&quot;Hello world!&quot;&lt;/code&gt;. HTML is unescaped, so you can generally write JSX just like you would write HTML in this way:</source>
          <target state="translated">Это действительный JSX, и &lt;code&gt;props.children&lt;/code&gt; в &lt;code&gt;MyComponent&lt;/code&gt; будет просто строкой &lt;code&gt;&quot;Hello world!&quot;&lt;/code&gt; . HTML не экранирован, поэтому вы можете писать JSX так же, как вы пишете HTML следующим образом:</target>
        </trans-unit>
        <trans-unit id="c613ddcfbe3b097acdf335938f040949d7b413dc" translate="yes" xml:space="preserve">
          <source>This is why in React classes, we put side effects into &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:</source>
          <target state="translated">Вот почему в классах React мы добавляем побочные эффекты в &lt;code&gt;componentDidMount&lt;/code&gt; и &lt;code&gt;componentDidUpdate&lt;/code&gt; . Возвращаясь к нашему примеру, вот компонент класса счетчика React, который обновляет заголовок документа сразу после того, как React вносит изменения в DOM:</target>
        </trans-unit>
        <trans-unit id="c62ddb716217cd9d943db6e89f3da163d5211696" translate="yes" xml:space="preserve">
          <source>This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.</source>
          <target state="translated">Вот почему государство часто называют местным или инкапсулированным.Оно не доступно ни одному компоненту,кроме того,который владеет и устанавливает его.</target>
        </trans-unit>
        <trans-unit id="18a571f38f03339764897ec37c93ff611f9faab0" translate="yes" xml:space="preserve">
          <source>This is why when we click the button, it feels like we&amp;rsquo;ve &amp;ldquo;taken a step back&amp;rdquo;. The &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary which was previously showing useful content (&lt;code&gt;&amp;lt;HomePage /&amp;gt;&lt;/code&gt;) had to &amp;ldquo;recede&amp;rdquo; to showing the fallback (&lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt;). We call that a &lt;strong&gt;Receded&lt;/strong&gt; state.</source>
          <target state="translated">Вот почему, когда мы нажимаем кнопку, создается ощущение, что мы &amp;laquo;сделали шаг назад&amp;raquo;. &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; границы , которая была ранее показывающее полезным содержание ( &lt;code&gt;&amp;lt;HomePage /&amp;gt;&lt;/code&gt; ) должно было &amp;laquo;отступают&amp;raquo; к показу запасного варианта ( &lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt; ). Мы называем это состоянием &lt;strong&gt;отступления&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="718eb18e387e45c3190a58540cc9769ac7b3487c" translate="yes" xml:space="preserve">
          <source>This lets other components pass arbitrary children to them by nesting the JSX:</source>
          <target state="translated">Это позволяет другим компонентам передавать им произвольных детей путем вложенности JSX:</target>
        </trans-unit>
        <trans-unit id="b8cee0a900fd1abfbf74aa34a43408d67133f7b3" translate="yes" xml:space="preserve">
          <source>This lets us know whether the &lt;em&gt;currently selected&lt;/em&gt; friend is online. If we pick a different friend and update the &lt;code&gt;recipientID&lt;/code&gt; state variable, our &lt;code&gt;useFriendStatus&lt;/code&gt; Hook will unsubscribe from the previously selected friend, and subscribe to the status of the newly selected one.</source>
          <target state="translated">Это позволяет нам узнать, находится ли &lt;em&gt;текущий выбранный&lt;/em&gt; друг в сети. Если мы выберем другого друга и обновим переменную состояния &lt;code&gt;recipientID&lt;/code&gt; , наш &lt;code&gt;useFriendStatus&lt;/code&gt; от ранее выбранного друга и подпишется на статус нового выбранного друга.</target>
        </trans-unit>
        <trans-unit id="17465f6f30cbbd158822bfd9a93d4e55ec625a26" translate="yes" xml:space="preserve">
          <source>This lets us simplify &lt;code&gt;Comment&lt;/code&gt; even further:</source>
          <target state="translated">Это позволяет нам еще больше упростить &lt;code&gt;Comment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2145d5b7dc2e2f3be97d96fbee1e1d4c248b4f29" translate="yes" xml:space="preserve">
          <source>This lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state.</source>
          <target state="translated">Этот жизненный цикл вызывается после того,как ошибка была брошена потомком.Он получает ошибку,которая была брошена в качестве параметра и должна вернуть значение в состояние обновления.</target>
        </trans-unit>
        <trans-unit id="968ffe95e9be91c36d5595d98ef8add12caa0d69" translate="yes" xml:space="preserve">
          <source>This lifecycle is invoked after an error has been thrown by a descendant component. It receives two parameters:</source>
          <target state="translated">Этот жизненный цикл вызывается после того,как ошибка была брошена потомком.Он получает два параметра:</target>
        </trans-unit>
        <trans-unit id="594ba927ec8ab8edb9aadc0d0584d8c6c365a647" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillMount&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="translated">Этот жизненный цикл ранее назывался &lt;code&gt;componentWillMount&lt;/code&gt; . Это имя будет работать до версии 17. Используйте &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;код &lt;/a&gt; &lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; мод rename-unsafe-lifecycles для автоматического обновления ваших компонентов.</target>
        </trans-unit>
        <trans-unit id="6588d01fe985f33b6111c5dd3aa724cc493cfaf0" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillReceiveProps&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="translated">Этот жизненный цикл ранее назывался &lt;code&gt;componentWillReceiveProps&lt;/code&gt; . Это имя будет работать до версии 17. Используйте &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;код &lt;/a&gt; &lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; мод rename-unsafe-lifecycles для автоматического обновления ваших компонентов.</target>
        </trans-unit>
        <trans-unit id="94637589013bd1046cc3548741fa19cadd64d909" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillUpdate&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="translated">Этот жизненный цикл ранее назывался &lt;code&gt;componentWillUpdate&lt;/code&gt; . Это имя будет работать до версии 17. Используйте &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;код &lt;/a&gt; &lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; мод rename-unsafe-lifecycles для автоматического обновления ваших компонентов.</target>
        </trans-unit>
        <trans-unit id="f1c80a55eed22ae85461d3cfcaba922c6522694d" translate="yes" xml:space="preserve">
          <source>This makes sense in the vast majority of situations. Inconsistent UI is confusing and can mislead users. (For example, it would be terrible if a messenger&amp;rsquo;s Send button and the conversation picker pane &amp;ldquo;disagreed&amp;rdquo; about which thread is currently selected.)</source>
          <target state="translated">Это имеет смысл в подавляющем большинстве ситуаций. Несогласованный интерфейс сбивает с толку и может ввести пользователей в заблуждение. (Например, было бы ужасно, если бы кнопка &amp;laquo;Отправить&amp;raquo; в мессенджере и панель выбора беседы &amp;laquo;не соглашались&amp;raquo; относительно того, какая ветка выбрана в данный момент.)</target>
        </trans-unit>
        <trans-unit id="ef24e13773cbfa21de17ac04cc277350c44f1c93" translate="yes" xml:space="preserve">
          <source>This may work fine for users with pointer devices, such as a mouse, but operating this with the keyboard alone leads to broken functionality when tabbing to the next element as the &lt;code&gt;window&lt;/code&gt; object never receives a &lt;code&gt;click&lt;/code&gt; event. This can lead to obscured functionality which blocks users from using your application.</source>
          <target state="translated">Это может нормально работать для пользователей с указательными устройствами, такими как мышь, но работа с этой только клавиатурой приводит к нарушению функциональности при переходе к следующему элементу, поскольку объект &lt;code&gt;window&lt;/code&gt; никогда не получает событие &lt;code&gt;click&lt;/code&gt; . Это может привести к скрытой функциональности, которая не позволяет пользователям использовать ваше приложение.</target>
        </trans-unit>
        <trans-unit id="85ab2af6f9d4c72cf5bf3ee19ce9e396909f22dc" translate="yes" xml:space="preserve">
          <source>This means that refs intended for our &lt;code&gt;FancyButton&lt;/code&gt; component will actually be attached to the &lt;code&gt;LogProps&lt;/code&gt; component:</source>
          <target state="translated">Это означает, что ссылки, предназначенные для нашего компонента &lt;code&gt;FancyButton&lt;/code&gt; , будут фактически прикреплены к компоненту &lt;code&gt;LogProps&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="20cdec50ca2bbe2c60a25c71a851df8e68f79fdd" translate="yes" xml:space="preserve">
          <source>This means that you can use JSX inside of &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;for&lt;/code&gt; loops, assign it to variables, accept it as arguments, and return it from functions:</source>
          <target state="translated">Это означает, что вы можете использовать JSX внутри операторов &lt;code&gt;if&lt;/code&gt; и циклов &lt;code&gt;for&lt;/code&gt; , назначать его переменным, принимать в качестве аргументов и возвращать из функций:</target>
        </trans-unit>
        <trans-unit id="3bf58efcf63a028a41c47c43c10732e6a1a269f5" translate="yes" xml:space="preserve">
          <source>This means writing ES6 classes comes with a little more boilerplate code for event handlers, but the upside is slightly better performance in large applications.</source>
          <target state="translated">Это означает,что написание классов ES6 поставляется с немного большим количеством кода шаблона для обработчиков событий,но плюсом является несколько лучшая производительность в больших приложениях.</target>
        </trans-unit>
        <trans-unit id="c6ccb7790fbe3b5adbb51adc314fe96e90f8b9bd" translate="yes" xml:space="preserve">
          <source>This method doesn&amp;rsquo;t have access to the component instance. If you&amp;rsquo;d like, you can reuse some code between &lt;code&gt;getDerivedStateFromProps()&lt;/code&gt; and the other class methods by extracting pure functions of the component props and state outside the class definition.</source>
          <target state="translated">У этого метода нет доступа к экземпляру компонента. При желании вы можете повторно использовать некоторый код между &lt;code&gt;getDerivedStateFromProps()&lt;/code&gt; и другими методами класса, извлекая чистые функции из свойств компонента и состояния вне определения класса.</target>
        </trans-unit>
        <trans-unit id="deaaaea3817236bf17270b39c61839a1ba533f0b" translate="yes" xml:space="preserve">
          <source>This method exists for &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state&quot;&gt;rare use cases&lt;/a&gt; where the state depends on changes in props over time. For example, it might be handy for implementing a &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; component that compares its previous and next children to decide which of them to animate in and out.</source>
          <target state="translated">Этот метод существует для &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state&quot;&gt;редких случаев использования,&lt;/a&gt; когда состояние зависит от изменений свойств с течением времени. Например, это может быть удобно для реализации компонента &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; , который сравнивает свои предыдущие и следующие дочерние элементы, чтобы решить, какой из них нужно анимировать, а какой - нет.</target>
        </trans-unit>
        <trans-unit id="831ab868298258b184dc29308d4e3381f3bfdc48" translate="yes" xml:space="preserve">
          <source>This method is a good place to set up any subscriptions. If you do that, don&amp;rsquo;t forget to unsubscribe in &lt;code&gt;componentWillUnmount()&lt;/code&gt;.</source>
          <target state="translated">Этот метод - хорошее место для настройки любых подписок. Если вы это сделаете, не забудьте отказаться от подписки в &lt;code&gt;componentWillUnmount()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ab528114f0749b536a7ef2d3ed5cc959586f962" translate="yes" xml:space="preserve">
          <source>This method is called when a component is being removed from the DOM:</source>
          <target state="translated">Этот метод вызывается,когда компонент удаляется из флэш-накопителя:</target>
        </trans-unit>
        <trans-unit id="8d1ff3351a12658bbf9b29cefa88394ca0bb9811" translate="yes" xml:space="preserve">
          <source>This method only exists as a &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;performance optimization&lt;/a&gt;.&lt;/strong&gt; Do not rely on it to &amp;ldquo;prevent&amp;rdquo; a render, as this can lead to bugs.</source>
          <target state="translated">Этот метод существует только для &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;оптимизации производительности&lt;/a&gt; . &lt;/strong&gt;Не полагайтесь на него, чтобы &amp;laquo;предотвратить&amp;raquo; рендеринг, так как это может привести к ошибкам.</target>
        </trans-unit>
        <trans-unit id="ebb829156f7c61ef4acced6f34d456127053816e" translate="yes" xml:space="preserve">
          <source>This method only exists as a &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;performance optimization&lt;/a&gt;.&lt;/strong&gt; Do not rely on it to &amp;ldquo;prevent&amp;rdquo; a rendering, as this can lead to bugs. &lt;strong&gt;Consider using the built-in &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;PureComponent&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; instead of writing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; by hand. &lt;code&gt;PureComponent&lt;/code&gt; performs a shallow comparison of props and state, and reduces the chance that you&amp;rsquo;ll skip a necessary update.</source>
          <target state="translated">Этот метод существует только для &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;оптимизации производительности&lt;/a&gt; . &lt;/strong&gt;Не полагайтесь на него, чтобы &amp;laquo;предотвратить&amp;raquo; рендеринг, так как это может привести к ошибкам. &lt;strong&gt;Рассмотрите возможность использования встроенного &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt; &lt;code&gt;PureComponent&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; вместо того, чтобы писать &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; вручную. &lt;code&gt;PureComponent&lt;/code&gt; выполняет поверхностное сравнение свойств и состояния и снижает вероятность того, что вы пропустите необходимое обновление.</target>
        </trans-unit>
        <trans-unit id="ee800d90e38eaef10a7bc57aaa91d6a6506aa2cf" translate="yes" xml:space="preserve">
          <source>This might be a bit convoluted but you can extract it into a custom Hook:</source>
          <target state="translated">Это может быть немного запутанным,но вы можете извлечь его в пользовательский Крюк:</target>
        </trans-unit>
        <trans-unit id="e32186cfd473e2a105089ea30d4f98232d190b91" translate="yes" xml:space="preserve">
          <source>This might look strange at first, but an update during rendering is exactly what &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; has always been like conceptually.</source>
          <target state="translated">Сначала это может показаться странным, но обновление во время рендеринга - это именно то, &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; всегда концептуально был getDerivedStateFromProps .</target>
        </trans-unit>
        <trans-unit id="ef2cab890f08c2a76dbdff387f6da7cc1005dff6" translate="yes" xml:space="preserve">
          <source>This might seem like a lot to take in at first. Don&amp;rsquo;t rush it! If you&amp;rsquo;re lost in the explanation, look at the code above again and try to read it from top to bottom. We promise that once you try to &amp;ldquo;forget&amp;rdquo; how state works in classes, and look at this code with fresh eyes, it will make sense.</source>
          <target state="translated">Поначалу это может показаться сложным. Не торопитесь! Если вы запутались в объяснении, посмотрите на приведенный выше код еще раз и попробуйте прочитать его сверху вниз. Мы обещаем, что если вы попытаетесь &amp;laquo;забыть&amp;raquo;, как работает состояние в классах, и взглянете на этот код свежим взглядом, это обретет смысл.</target>
        </trans-unit>
        <trans-unit id="d07825aa1cec991e99499e19669c9ccceb78fe54" translate="yes" xml:space="preserve">
          <source>This new function &lt;code&gt;useState&lt;/code&gt; is the first &amp;ldquo;Hook&amp;rdquo; we&amp;rsquo;ll learn about, but this example is just a teaser. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t make sense yet!</source>
          <target state="translated">Эта новая функция &lt;code&gt;useState&lt;/code&gt; - первая &amp;laquo; ловушка &amp;raquo;, о которой мы узнаем, но этот пример - всего лишь тизер. Не волнуйтесь, если это еще не имеет смысла!</target>
        </trans-unit>
        <trans-unit id="e3a722c80ed9c76ca1113dc4457219ac30784908" translate="yes" xml:space="preserve">
          <source>This only applies to development mode. &lt;em&gt;Lifecycles will not be double-invoked in production mode.&lt;/em&gt;</source>
          <target state="translated">Это относится только к режиму разработки. &lt;em&gt;Жизненные циклы не будут запускаться дважды в производственном режиме.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4350c5287a7a2684318bbc298f11388e35c98227" translate="yes" xml:space="preserve">
          <source>This package provides a React renderer that can be used to render React components to pure JavaScript objects, without depending on the DOM or a native mobile environment.</source>
          <target state="translated">Этот пакет предоставляет React рендер,который может быть использован для рендеринга React компонентов на чистые JavaScript объекты,без зависимости от DOM или родного мобильного окружения.</target>
        </trans-unit>
        <trans-unit id="8402b5bdda223e1895c6750dabf232de29a825ec" translate="yes" xml:space="preserve">
          <source>This page answers some of the frequently asked questions about &lt;a href=&quot;hooks-overview&quot;&gt;Hooks&lt;/a&gt;.</source>
          <target state="translated">Эта страница отвечает на некоторые часто задаваемые вопросы о &lt;a href=&quot;hooks-overview&quot;&gt;хуках&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34334d5085c7858cfe5a0f8a0877627d68a2b7b4" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;re using &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; as a test runner. If you use a different test runner, you may need to adjust the API, but the overall shape of the solution will likely be the same. Read more details on setting up a testing environment on the &lt;a href=&quot;testing-environments&quot;&gt;Testing Environments&lt;/a&gt; page.</source>
          <target state="translated">На этой странице предполагается, что вы используете &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; как средство запуска тестов. Если вы используете другое средство запуска тестов, вам может потребоваться настроить API, но общая форма решения, скорее всего, будет такой же. Дополнительные сведения о настройке среды &lt;a href=&quot;testing-environments&quot;&gt;тестирования&lt;/a&gt; см. На странице Среды тестирования .</target>
        </trans-unit>
        <trans-unit id="3a166d200254a5d8e02bad9a5106cd778d917587" translate="yes" xml:space="preserve">
          <source>This page contains a detailed API reference for the React component class definition. It assumes you&amp;rsquo;re familiar with fundamental React concepts, such as &lt;a href=&quot;components-and-props&quot;&gt;Components and Props&lt;/a&gt;, as well as &lt;a href=&quot;state-and-lifecycle&quot;&gt;State and Lifecycle&lt;/a&gt;. If you&amp;rsquo;re not, read them first.</source>
          <target state="translated">Эта страница содержит подробный справочник по API для определения класса компонента React. Предполагается, что вы знакомы с фундаментальными концепциями React, такими как &lt;a href=&quot;components-and-props&quot;&gt;компоненты и свойства&lt;/a&gt; , а также состояние &lt;a href=&quot;state-and-lifecycle&quot;&gt;и жизненный цикл&lt;/a&gt; . Если нет, сначала прочтите их.</target>
        </trans-unit>
        <trans-unit id="5b013d41bce54d9463c50238174c350420a86fd1" translate="yes" xml:space="preserve">
          <source>This page describes &lt;strong&gt;experimental features that are &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;not yet available&lt;/a&gt; in a stable release&lt;/strong&gt;. Don&amp;rsquo;t rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.</source>
          <target state="translated">На этой странице описаны &lt;strong&gt;экспериментальные функции, которые &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;еще не доступны&lt;/a&gt; в стабильной версии&lt;/strong&gt; . Не полагайтесь на экспериментальные сборки React в производственных приложениях. Эти функции могут существенно измениться без предупреждения до того, как станут частью React.</target>
        </trans-unit>
        <trans-unit id="122960595a4931302583328a511b76c9b89150ab" translate="yes" xml:space="preserve">
          <source>This page describes &lt;strong&gt;experimental features that are not yet available in a stable release&lt;/strong&gt;. Don&amp;rsquo;t rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.</source>
          <target state="translated">На этой странице описаны &lt;strong&gt;экспериментальные функции, которые еще не доступны в стабильной версии&lt;/strong&gt; . Не полагайтесь на экспериментальные сборки React в производственных приложениях. Эти функции могут существенно измениться без предупреждения до того, как станут частью React.</target>
        </trans-unit>
        <trans-unit id="4047aad22e87564322a6b203dc72bdb4dac3a75c" translate="yes" xml:space="preserve">
          <source>This page describes a few popular React toolchains which help with tasks like:</source>
          <target state="translated">На этой странице описаны несколько популярных цепочек инструментов React,которые помогают при выполнении таких задач:</target>
        </trans-unit>
        <trans-unit id="e37bdca683407609c8ea8e0d16eadc7cfa276546" translate="yes" xml:space="preserve">
          <source>This page describes the APIs for the built-in Hooks in React.</source>
          <target state="translated">На этой странице описаны API для встроенных Hooks in React.</target>
        </trans-unit>
        <trans-unit id="1e718f59fd28ee7f281f2c32ed198268003156f5" translate="yes" xml:space="preserve">
          <source>This page introduces the concept of state and lifecycle in a React component. You can find a &lt;a href=&quot;react-component&quot;&gt;detailed component API reference here&lt;/a&gt;.</source>
          <target state="translated">На этой странице представлена ​​концепция состояния и жизненного цикла компонента React. Вы можете найти &lt;a href=&quot;react-component&quot;&gt;подробный справочник по API компонентов здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a3489831af2b614861bf122f1b342924d1410d7" translate="yes" xml:space="preserve">
          <source>This page is an API reference for the React &lt;a href=&quot;concurrent-mode-intro&quot;&gt;Concurrent Mode&lt;/a&gt;. If you&amp;rsquo;re looking for a guided introduction instead, check out &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.</source>
          <target state="translated">Эта страница представляет собой справочник по API для &lt;a href=&quot;concurrent-mode-intro&quot;&gt;параллельного режима&lt;/a&gt; React . Если вместо этого вы ищете управляемое введение, ознакомьтесь с &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Параллельными шаблонами пользовательского интерфейса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c533e178a623d6b733cedd5bdbf8ab43278f207d" translate="yes" xml:space="preserve">
          <source>This page is an overview of the React documentation and related resources.</source>
          <target state="translated">Эта страница представляет собой обзор документации React и соответствующих ресурсов.</target>
        </trans-unit>
        <trans-unit id="435071639c16cd82d53215bba45c4f7afefd14fc" translate="yes" xml:space="preserve">
          <source>This page is only relevant for React 16 and earlier, and for React Native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8155926f2a677459aa518b97627e56b8d5d2b3b9" translate="yes" xml:space="preserve">
          <source>This page provides a theoretical overview of Concurrent Mode. &lt;strong&gt;For a more practical introduction, you might want to check out the next sections:&lt;/strong&gt;</source>
          <target state="translated">На этой странице представлен теоретический обзор Concurrent Mode. &lt;strong&gt;Для более практического введения вы можете изучить следующие разделы:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a471db84150e912bcf081d5315a354a60b2801c7" translate="yes" xml:space="preserve">
          <source>This pattern is sufficient for many cases when you need to decouple a child from its immediate parents. You can take it even further with &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; if the child needs to communicate with the parent before rendering.</source>
          <target state="translated">Этого шаблона достаточно для многих случаев, когда нужно отделить ребенка от его непосредственных родителей. Вы можете пойти еще дальше с помощью &lt;a href=&quot;render-props&quot;&gt;рендеринга реквизитов,&lt;/a&gt; если ребенку нужно общаться с родителем перед рендерингом.</target>
        </trans-unit>
        <trans-unit id="d9fd07e4c840f003b08c9bdf6f21a1ec4e1acc30" translate="yes" xml:space="preserve">
          <source>This performs a shallow merge of &lt;code&gt;stateChange&lt;/code&gt; into the new state, e.g., to adjust a shopping cart item quantity:</source>
          <target state="translated">Это выполняет неглубокое слияние &lt;code&gt;stateChange&lt;/code&gt; с новым состоянием, например, для настройки количества товаров в корзине:</target>
        </trans-unit>
        <trans-unit id="846fc8c98cf14dc25d66ba13bf4262e8d78da49b" translate="yes" xml:space="preserve">
          <source>This plugin is included by default in &lt;a href=&quot;create-a-new-react-app#create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="translated">Этот плагин по умолчанию включен в &lt;a href=&quot;create-a-new-react-app#create-react-app&quot;&gt;приложение Create React&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82c77f485b089c71f74af9f0894a753a93bcba93" translate="yes" xml:space="preserve">
          <source>This policy is designed to be pragmatic: certainly, we don&amp;rsquo;t want to cause headaches for you. If we bumped the major version for all of these changes, we would end up releasing more major versions and ultimately causing more versioning pain for the community. It would also mean that we can&amp;rsquo;t make progress in improving React as fast as we&amp;rsquo;d like.</source>
          <target state="translated">Эта политика носит прагматичный характер: мы, конечно же, не хотим причинять вам головную боль. Если бы мы увеличили основную версию для всех этих изменений, мы бы выпустим больше основных версий и, в конечном итоге, усугубили бы проблемы с версией для сообщества. Это также будет означать, что мы не сможем добиться прогресса в улучшении React так быстро, как нам хотелось бы.</target>
        </trans-unit>
        <trans-unit id="1ea9e452d1eff58bbc103278e7e1bc082218f9a3" translate="yes" xml:space="preserve">
          <source>This poses a question of how do we know &lt;em&gt;what&lt;/em&gt; to fetch before rendering the next screen. There are several ways to solve this (for example, by integrating data fetching closer with your routing solution). If you work on a data fetching library, &lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;Building Great User Experiences with Concurrent Mode and Suspense&lt;/a&gt; presents a deep dive on how to accomplish this and why it&amp;rsquo;s important.</source>
          <target state="translated">Это ставит вопрос о том, как мы узнаем, &lt;em&gt;что&lt;/em&gt; нужно получить перед рендерингом следующего экрана. Есть несколько способов решить эту проблему (например, путем более тесной интеграции извлечения данных с вашим решением маршрутизации). Если вы работаете над библиотекой выборки данных, &amp;laquo; &lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;Создание отличного пользовательского опыта с одновременным режимом и приостановкой&amp;raquo;&lt;/a&gt; представляет собой подробное описание того, как этого добиться и почему это важно.</target>
        </trans-unit>
        <trans-unit id="f84a144236df428813d59f9cce1db593da13efb1" translate="yes" xml:space="preserve">
          <source>This presents a problem. If the response for fun facts arrives first, we&amp;rsquo;ll see the fun facts below the &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; fallback for posts. We might start reading them, but then the &lt;em&gt;posts&lt;/em&gt; response will come back, and shift all the facts down. This is jarring.</source>
          <target state="translated">Это представляет проблему. Если сначала поступит ответ с интересными фактами, мы увидим забавные факты под резервным вариантом &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; для сообщений. Мы могли бы начать их читать, но потом ответ на &lt;em&gt;сообщения&lt;/em&gt; вернется и сдвинет все факты вниз. Это неприятно.</target>
        </trans-unit>
        <trans-unit id="8635080f7265c9f1c5179ee0c18eafa6af31514f" translate="yes" xml:space="preserve">
          <source>This problem is possible to fix (you could use the effect cleanup function to either ignore or cancel stale requests), but it&amp;rsquo;s unintuitive and difficult to debug.</source>
          <target state="translated">Эту проблему можно исправить (вы можете использовать функцию очистки эффекта, чтобы игнорировать или отменять устаревшие запросы), но это неинтуитивно и сложно отлаживать.</target>
        </trans-unit>
        <trans-unit id="8d1f82deaae287572c7914a6acb4b6162faaf183" translate="yes" xml:space="preserve">
          <source>This reference guide documents the &lt;code&gt;SyntheticEvent&lt;/code&gt; wrapper that forms part of React&amp;rsquo;s Event System. See the &lt;a href=&quot;handling-events&quot;&gt;Handling Events&lt;/a&gt; guide to learn more.</source>
          <target state="translated">В этом справочном руководстве &lt;code&gt;SyntheticEvent&lt;/code&gt; оболочка SyntheticEvent, которая является частью системы событий React. См. Руководство по &lt;a href=&quot;handling-events&quot;&gt;обработке событий,&lt;/a&gt; чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="7d398accdf2e13d5c40a6a46660190acf5d11f2a" translate="yes" xml:space="preserve">
          <source>This release is primarily aimed at early adopters, library authors, and curious people.</source>
          <target state="translated">Этот выпуск в первую очередь ориентирован на ранних усыновителей,библиотечных авторов и любопытных людей.</target>
        </trans-unit>
        <trans-unit id="219eb5ca004ef24ebdbe9552a6315cfaaddd9726" translate="yes" xml:space="preserve">
          <source>This requirement is common enough that it is built into the &lt;code&gt;useEffect&lt;/code&gt; Hook API. You can tell React to &lt;em&gt;skip&lt;/em&gt; applying an effect if certain values haven&amp;rsquo;t changed between re-renders. To do so, pass an array as an optional second argument to &lt;code&gt;useEffect&lt;/code&gt;:</source>
          <target state="translated">Это требование достаточно распространено, поэтому оно встроено в API-интерфейс &lt;code&gt;useEffect&lt;/code&gt; Hook. Вы можете указать React &lt;em&gt;пропустить&lt;/em&gt; применение эффекта, если определенные значения не изменились между повторными рендерингами. Для этого передайте массив как необязательный второй аргумент для &lt;code&gt;useEffect&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="72e02f13475aaf546ed6868e8e94f97eaca88513" translate="yes" xml:space="preserve">
          <source>This reveals an important insight. React always prefers to go to the Skeleton state as soon as possible. Even if we use transitions with long timeouts everywhere, React will not stay in the Pending state for longer than necessary to avoid the Receded state.</source>
          <target state="translated">Это раскрывает важное понимание.Реакция всегда предпочитает как можно скорее отправиться в штат Скелет.Даже если мы повсюду используем переходы с длительными таймаутами,Реакция не будет оставаться в Отложенном состоянии дольше,чем это необходимо для того,чтобы избежать состояния Рецепта.</target>
        </trans-unit>
        <trans-unit id="4974405692544c270ead0116083e7b2246305e51" translate="yes" xml:space="preserve">
          <source>This scenario (Receded &amp;rarr; Skeleton &amp;rarr; Complete) is the default one. However, the Receded state is not very pleasant because it &amp;ldquo;hides&amp;rdquo; existing information. This is why React lets us opt into a different sequence (&lt;strong&gt;Pending&lt;/strong&gt; &amp;rarr; Skeleton &amp;rarr; Complete) with &lt;code&gt;useTransition&lt;/code&gt;.</source>
          <target state="translated">Этот сценарий (Отступление &amp;rarr; Скелет &amp;rarr; Завершено) является сценарием по умолчанию. Однако состояние &amp;laquo;Удалено&amp;raquo; не очень приятное, поскольку оно &amp;laquo;скрывает&amp;raquo; существующую информацию. Вот почему React позволяет нам выбрать другую последовательность ( &lt;strong&gt;Pending&lt;/strong&gt; &amp;rarr; Skeleton &amp;rarr; Complete) с &lt;code&gt;useTransition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8932805285fb5fb9fa75db833708a1c02394b849" translate="yes" xml:space="preserve">
          <source>This section documents a legacy API. See the &lt;a href=&quot;context&quot;&gt;new API&lt;/a&gt;.</source>
          <target state="translated">В этом разделе описывается устаревший API. См. &lt;a href=&quot;context&quot;&gt;Новый API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="deb7679ee67f771ffc1fa43a1b5ac4df3c5b01eb" translate="yes" xml:space="preserve">
          <source>This section exists only for the reference.</source>
          <target state="translated">Этот раздел существует только для справки.</target>
        </trans-unit>
        <trans-unit id="ed85cf7679f0f0f6b3d4ece5fc84efdd9e4a1ae9" translate="yes" xml:space="preserve">
          <source>This section is divided in two pages:</source>
          <target state="translated">Этот раздел разделен на две страницы:</target>
        </trans-unit>
        <trans-unit id="11ef194a779a4e464739e9fe4bc7b3d85cd3c158" translate="yes" xml:space="preserve">
          <source>This section is only relevant if you configure webpack directly.</source>
          <target state="translated">Этот раздел применим только в том случае,если вы напрямую настраиваете веб-пакет.</target>
        </trans-unit>
        <trans-unit id="431d6b70a9186c1768894b47222b952f79b7c64c" translate="yes" xml:space="preserve">
          <source>This signals to the user that some work is happening. However, if the transition is relatively short (less than 500ms), it might be too distracting and make the transition itself feel &lt;em&gt;slower&lt;/em&gt;.</source>
          <target state="translated">Это сигнализирует пользователю о том, что выполняется некоторая работа. Однако, если переход относительно короткий (менее 500 мс), он может слишком отвлекать и сделать сам переход &lt;em&gt;более медленным&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="42c7316ea14507d8a3106cad0c901fad61aced90" translate="yes" xml:space="preserve">
          <source>This snippet is based on the &lt;a href=&quot;hooks-state&quot;&gt;counter example from the previous page&lt;/a&gt;, but we added a new feature to it: we set the document title to a custom message including the number of clicks.</source>
          <target state="translated">Этот фрагмент основан на &lt;a href=&quot;hooks-state&quot;&gt;примере счетчика с предыдущей страницы&lt;/a&gt; , но мы добавили в него новую функцию: мы устанавливаем заголовок документа для настраиваемого сообщения, включая количество кликов.</target>
        </trans-unit>
        <trans-unit id="1a2b973923810065ae120310178374258ed4b621" translate="yes" xml:space="preserve">
          <source>This strategy is mostly useful while React-powered parts of the page are isolated from each other. Inside React code, it&amp;rsquo;s easier to use &lt;a href=&quot;components-and-props#composing-components&quot;&gt;component composition&lt;/a&gt; instead.</source>
          <target state="translated">Эта стратегия наиболее полезна, когда части страницы на основе React изолированы друг от друга. Внутри кода React вместо этого проще использовать &lt;a href=&quot;components-and-props#composing-components&quot;&gt;компонентную композицию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af97e3139dc5dabdecc79fb897156e2581c55f4a" translate="yes" xml:space="preserve">
          <source>This syntax is enabled by default in &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="translated">Этот синтаксис включен по умолчанию в &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;приложении Create React&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6a74e9393c537e68f37f167c1398d5d5cb7b7e5" translate="yes" xml:space="preserve">
          <source>This technique can also be particularly useful with &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; (also known as HOCs). Let&amp;rsquo;s start with an example HOC that logs component props to the console:</source>
          <target state="translated">Этот метод также может быть особенно полезен с &lt;a href=&quot;higher-order-components&quot;&gt;компонентами более высокого порядка&lt;/a&gt; (также известными как HOC). Начнем с примера HOC, который записывает свойства компонентов в консоль:</target>
        </trans-unit>
        <trans-unit id="f2aa2891249ff7426f74024d6c648d613960876e" translate="yes" xml:space="preserve">
          <source>This technique is not limited to Backbone. You can use React with any model library by subscribing to its changes in the lifecycle methods and, optionally, copying the data into the local React state.</source>
          <target state="translated">Эта техника не ограничивается позвоночником.Вы можете использовать React с любой библиотекой моделей,подписавшись на ее изменения в методах жизненного цикла и,опционально,скопировав данные в локальное React State.</target>
        </trans-unit>
        <trans-unit id="5452f415731db14c0cf1bafa5cfea7a02476b736" translate="yes" xml:space="preserve">
          <source>This technique makes the behavior that we need to share extremely portable. To get that behavior, render a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a &lt;code&gt;render&lt;/code&gt; prop that tells it what to render with the current (x, y) of the cursor.</source>
          <target state="translated">Этот метод делает поведение, которым мы должны поделиться, чрезвычайно переносимым. Чтобы получить такое поведение, визуализируйте &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; с опорой &lt;code&gt;render&lt;/code&gt; которая сообщает ему, что визуализировать с текущим (x, y) курсора.</target>
        </trans-unit>
        <trans-unit id="cd27a6856541e6f1acbb51200bd11813ffca7cb1" translate="yes" xml:space="preserve">
          <source>This use case is not common, but it may occur in UIs like a chat thread that need to handle scroll position in a special way.</source>
          <target state="translated">Этот случай использования не является распространенным,но он может встречаться в UI,как поток чата,который должен обрабатывать положение прокрутки особым образом.</target>
        </trans-unit>
        <trans-unit id="03fa86c4209790d37407690c0571a1707fae797b" translate="yes" xml:space="preserve">
          <source>This versioning policy does not apply to prerelease builds in the Next or Experimental channels. &lt;a href=&quot;release-channels&quot;&gt;Learn more about prereleases.&lt;/a&gt;</source>
          <target state="translated">Эта политика управления версиями не применяется к предварительным сборкам в каналах Next и Experimental. &lt;a href=&quot;release-channels&quot;&gt;Узнайте больше о предварительных версиях.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="538b744fcb20bb669203461ab8ea0f4f166bb679" translate="yes" xml:space="preserve">
          <source>This wasn&amp;rsquo;t very difficult to implement. However, if you start thinking about how this could possibly work, it might become a little mindbending. If we set the state, how come we don&amp;rsquo;t see the result right away? &lt;em&gt;Where&lt;/em&gt; is the next &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; rendering?</source>
          <target state="translated">Это было несложно реализовать. Однако, если вы начнете думать о том, как это могло бы работать, это может стать немного головокружительным. Если мы устанавливаем состояние, почему мы не видим результат сразу? &lt;em&gt;Где&lt;/em&gt; следующий рендеринг &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="eeb258d5f9ce72d55863431781bc340ff334eba5" translate="yes" xml:space="preserve">
          <source>This way, Chosen will know to update its DOM element when the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; children managed by React change.</source>
          <target state="translated">Таким образом, Chosen будет знать, что нужно обновлять свой элемент DOM при изменении дочерних элементов &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; , управляемых React.</target>
        </trans-unit>
        <trans-unit id="4ec28439ceebf9c4cb58d176fb968b8783b61655" translate="yes" xml:space="preserve">
          <source>This way, components using &lt;code&gt;FancyButton&lt;/code&gt; can get a ref to the underlying &lt;code&gt;button&lt;/code&gt; DOM node and access it if necessary&amp;mdash;just like if they used a DOM &lt;code&gt;button&lt;/code&gt; directly.</source>
          <target state="translated">Таким образом, компоненты, использующие &lt;code&gt;FancyButton&lt;/code&gt; , могут получить ссылку на базовый узел DOM &lt;code&gt;button&lt;/code&gt; и получить к нему доступ при необходимости - точно так же, как если бы они использовали &lt;code&gt;button&lt;/code&gt; DOM напрямую.</target>
        </trans-unit>
        <trans-unit id="f587d14d7da8b297c6acc91bd9525b1f055544f8" translate="yes" xml:space="preserve">
          <source>This way, only the higher-order component needs to know about Backbone model internals, and most components in the app can stay agnostic of Backbone.</source>
          <target state="translated">Таким образом,только компоненты более высокого порядка должны знать о внутренних деталях модели Backbone,и большинство компонентов в приложении могут оставаться агностическими от Backbone.</target>
        </trans-unit>
        <trans-unit id="a68f6ee634325f5570e4ef9513f5baf023e798ec" translate="yes" xml:space="preserve">
          <source>This will automatically load the bundle containing the &lt;code&gt;OtherComponent&lt;/code&gt; when this component is first rendered.</source>
          <target state="translated">Это автоматически загрузит пакет, содержащий &lt;code&gt;OtherComponent&lt;/code&gt; , при первой визуализации этого компонента.</target>
        </trans-unit>
        <trans-unit id="4daa2bc6eb40a0cae06d556ea78d107730c1a949" translate="yes" xml:space="preserve">
          <source>This will create a production build of your app in the &lt;code&gt;build/&lt;/code&gt; folder of your project.</source>
          <target state="translated">Это создаст производственную сборку вашего приложения в папке &lt;code&gt;build/&lt;/code&gt; вашего проекта.</target>
        </trans-unit>
        <trans-unit id="21d07f344e93b8d1d52a83aa0e0b2781c4b8f11b" translate="yes" xml:space="preserve">
          <source>This will destroy the old &lt;code&gt;Counter&lt;/code&gt; and remount a new one.</source>
          <target state="translated">Это уничтожит старый &lt;code&gt;Counter&lt;/code&gt; и перемонтирует новый.</target>
        </trans-unit>
        <trans-unit id="f0e763956fc3a258729b7ba8f4a255aa7e25a67d" translate="yes" xml:space="preserve">
          <source>This will let you use the Flow syntax in your code.</source>
          <target state="translated">Это позволит вам использовать синтаксис Flow в вашем коде.</target>
        </trans-unit>
        <trans-unit id="0d22477424f4173933134c5395efeb476e21ff5a" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;useRef()&lt;/code&gt; creates a plain JavaScript object. The only difference between &lt;code&gt;useRef()&lt;/code&gt; and creating a &lt;code&gt;{current: ...}&lt;/code&gt; object yourself is that &lt;code&gt;useRef&lt;/code&gt; will give you the same ref object on every render.</source>
          <target state="translated">Это работает, потому что &lt;code&gt;useRef()&lt;/code&gt; создает простой объект JavaScript. Единственная разница между &lt;code&gt;useRef()&lt;/code&gt; и созданием объекта &lt;code&gt;{current: ...}&lt;/code&gt; самостоятельно состоит в том, что &lt;code&gt;useRef&lt;/code&gt; будет давать вам один и тот же объект ref при каждой визуализации.</target>
        </trans-unit>
        <trans-unit id="b90fb512dd2dc602c018f93fa57436e6ed3df13a" translate="yes" xml:space="preserve">
          <source>This would break the consistency between &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt;, causing issues that are very hard to debug.</source>
          <target state="translated">Это нарушит согласованность между &lt;code&gt;props&lt;/code&gt; и &lt;code&gt;state&lt;/code&gt; , вызывая проблемы, которые очень трудно отлаживать.</target>
        </trans-unit>
        <trans-unit id="95c22763d2077a1ee86e0ec4084c276829b632d6" translate="yes" xml:space="preserve">
          <source>This would make some of the new features we&amp;rsquo;re working on impossible to implement.</source>
          <target state="translated">Это сделало бы невозможным реализацию некоторых новых функций, над которыми мы работаем.</target>
        </trans-unit>
        <trans-unit id="c63210a01f156ac5b080f30f90aa5a8002dd873b" translate="yes" xml:space="preserve">
          <source>Though you may build a single-page application in React, it is not a requirement. React can also be used for enhancing small parts of existing websites with additional interactivity. Code written in React can coexist peacefully with markup rendered on the server by something like PHP, or with other client-side libraries. In fact, this is exactly how React is being used at Facebook.</source>
          <target state="translated">Хотя вы можете построить одностраничное приложение в React,это не является обязательным требованием.React также может быть использовано для улучшения небольших частей существующих веб-сайтов с дополнительной интерактивностью.Код,написанный в React,может мирно сосуществовать с разметкой,сделанной на сервере чем-то вроде PHP,или с другими клиентскими библиотеками.На самом деле,именно так React используется на Facebook.</target>
        </trans-unit>
        <trans-unit id="8ecbfeb2bc4103c08c0932a78431577e530cc4f3" translate="yes" xml:space="preserve">
          <source>Throttle</source>
          <target state="translated">Throttle</target>
        </trans-unit>
        <trans-unit id="105be49bda488aaca7ed254ac9ecc09a5112187b" translate="yes" xml:space="preserve">
          <source>Throttling prevents a function from being called more than once in a given window of time. The example below throttles a &amp;ldquo;click&amp;rdquo; handler to prevent calling it more than once per second.</source>
          <target state="translated">Регулировка предотвращает вызов функции более одного раза в заданный промежуток времени. В приведенном ниже примере дросселируется обработчик &amp;laquo;щелчка&amp;raquo;, чтобы предотвратить его вызов чаще одного раза в секунду.</target>
        </trans-unit>
        <trans-unit id="841cd03a97cd854590864d79ae48ee749c5e902e" translate="yes" xml:space="preserve">
          <source>Timers</source>
          <target state="translated">Timers</target>
        </trans-unit>
        <trans-unit id="3dac8fa9afddf95742a5b60661cff381617249d8" translate="yes" xml:space="preserve">
          <source>Timing of effects</source>
          <target state="translated">Сроки действия эффектов</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="02a6b3cc0676cb3a0bc75f54672fa33daf4c1c54" translate="yes" xml:space="preserve">
          <source>Tip: Minify JavaScript for Production</source>
          <target state="translated">Совет:минимизируйте использование JavaScript для производства</target>
        </trans-unit>
        <trans-unit id="47616b21251215181f15d43775daece337895ac6" translate="yes" xml:space="preserve">
          <source>Tip: Optimizing Performance by Skipping Effects</source>
          <target state="translated">Совет:Оптимизация производительности за счет эффектов пропуска</target>
        </trans-unit>
        <trans-unit id="7fa62c774597708b7f9dc61b6315405aedb3c2e8" translate="yes" xml:space="preserve">
          <source>Tip: Pass Information Between Hooks</source>
          <target state="translated">Совет:Передача информации между крюками</target>
        </trans-unit>
        <trans-unit id="6646f32e08b3abdc68e954b73a34054ed4a2fe87" translate="yes" xml:space="preserve">
          <source>Tip: Reuse a Component</source>
          <target state="translated">Совет:Повторное использование компонента</target>
        </trans-unit>
        <trans-unit id="3cb18070e3d87dfd34832eb7efde20c790409673" translate="yes" xml:space="preserve">
          <source>Tip: Use Multiple Effects to Separate Concerns</source>
          <target state="translated">Совет:используйте несколько эффектов для разделения опасений</target>
        </trans-unit>
        <trans-unit id="057cb52d94797cd2b615c07e7a0fe7d5d1551b78" translate="yes" xml:space="preserve">
          <source>Tip: Using Multiple State Variables</source>
          <target state="translated">Совет:Использование множественных переменных состояния</target>
        </trans-unit>
        <trans-unit id="cac26bb6c0e4c5715088485c08a32cef54843337" translate="yes" xml:space="preserve">
          <source>Tip: What Do Square Brackets Mean?</source>
          <target state="translated">Совет:Что означают квадратные кронштейны?</target>
        </trans-unit>
        <trans-unit id="0fcbdd8749f567ca5ba943cad166f28f7c8d3609" translate="yes" xml:space="preserve">
          <source>Tips for Using Effects</source>
          <target state="translated">Советы по использованию эффектов</target>
        </trans-unit>
        <trans-unit id="8c18a9fca169c11391ce64e4496ce6b8c1d20039" translate="yes" xml:space="preserve">
          <source>To answer these questions, we will refer to the next section on &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.</source>
          <target state="translated">Чтобы ответить на эти вопросы, мы обратимся к следующему разделу, посвященному &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;параллельным шаблонам пользовательского интерфейса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cec2f6f831ea050e128a8fa50a07760d119b6ac9" translate="yes" xml:space="preserve">
          <source>To avoid re-creating the ignored initial state, we can pass a &lt;strong&gt;function&lt;/strong&gt; to &lt;code&gt;useState&lt;/code&gt;:</source>
          <target state="translated">Чтобы избежать повторного создания игнорируемого начального состояния, мы можем передать &lt;strong&gt;функцию&lt;/strong&gt; в &lt;code&gt;useState&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="67a0eb6712ca908d62558fdb45a11cb5f440325c" translate="yes" xml:space="preserve">
          <source>To avoid winding up with a large bundle, it&amp;rsquo;s good to get ahead of the problem and start &amp;ldquo;splitting&amp;rdquo; your bundle. Code-Splitting is a feature supported by bundlers like &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://rollupjs.org/guide/en/#code-splitting&quot;&gt;Rollup&lt;/a&gt; and Browserify (via &lt;a href=&quot;https://github.com/browserify/factor-bundle&quot;&gt;factor-bundle&lt;/a&gt;) which can create multiple bundles that can be dynamically loaded at runtime.</source>
          <target state="translated">Чтобы не получить большой пакет, хорошо бы опередить проблему и начать &amp;laquo;разбивать&amp;raquo; свой пакет. Разделение кода - это функция, поддерживаемая такими сборщиками, как &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;Webpack&lt;/a&gt; , &lt;a href=&quot;https://rollupjs.org/guide/en/#code-splitting&quot;&gt;Rollup&lt;/a&gt; и Browserify (через &lt;a href=&quot;https://github.com/browserify/factor-bundle&quot;&gt;factor-bundle&lt;/a&gt; ), которые могут создавать несколько пакетов, которые могут динамически загружаться во время выполнения.</target>
        </trans-unit>
        <trans-unit id="3828d4a44288ab3a5602117afc478907c184247c" translate="yes" xml:space="preserve">
          <source>To be able to show errors and hints from other packages, the compiler relies on declaration files. A declaration file provides all the type information about a library. This enables us to use javascript libraries like those on npm in our project.</source>
          <target state="translated">Чтобы иметь возможность показывать ошибки и подсказки из других пакетов,компилятор полагается на файлы объявлений.Файл объявлений предоставляет всю информацию о типе библиотеки.Это позволяет нам использовать в нашем проекте библиотеки javascript,подобные тем,что есть в npm.</target>
        </trans-unit>
        <trans-unit id="ee8e92cc09f5d0c415337688bf30629119745650" translate="yes" xml:space="preserve">
          <source>To build a static version of your app that renders your data model, you&amp;rsquo;ll want to build components that reuse other components and pass data using &lt;em&gt;props&lt;/em&gt;. &lt;em&gt;props&lt;/em&gt; are a way of passing data from parent to child. If you&amp;rsquo;re familiar with the concept of &lt;em&gt;state&lt;/em&gt;, &lt;strong&gt;don&amp;rsquo;t use state at all&lt;/strong&gt; to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don&amp;rsquo;t need it.</source>
          <target state="translated">Чтобы создать статическую версию вашего приложения, которая отображает вашу модель данных, вы захотите создать компоненты, которые повторно используют другие компоненты и передают данные с помощью &lt;em&gt;свойств&lt;/em&gt; . &lt;em&gt;props&lt;/em&gt; - это способ передачи данных от родителя к потомку. Если вы знакомы с концепцией &lt;em&gt;состояния&lt;/em&gt; , &lt;strong&gt;вообще не используйте состояние&lt;/strong&gt; для создания этой статической версии. Состояние зарезервировано только для интерактивности, то есть данных, которые меняются со временем. Поскольку это статическая версия приложения, она вам не нужна.</target>
        </trans-unit>
        <trans-unit id="44e1640b1de0ce4a7e355efb726594659452c610" translate="yes" xml:space="preserve">
          <source>To build your app correctly, you first need to think of the minimal set of mutable state that your app needs. The key here is &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY: &lt;em&gt;Don&amp;rsquo;t Repeat Yourself&lt;/em&gt;&lt;/a&gt;. Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. For example, if you&amp;rsquo;re building a TODO list, keep an array of the TODO items around; don&amp;rsquo;t keep a separate state variable for the count. Instead, when you want to render the TODO count, take the length of the TODO items array.</source>
          <target state="translated">Чтобы правильно построить свое приложение, вам сначала нужно подумать о минимальном наборе изменяемого состояния, которое требуется вашему приложению. Ключевым моментом здесь является &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;СУХОЙ: &lt;em&gt;не&lt;/em&gt;&lt;/a&gt; повторяйся . Выясните абсолютное минимальное представление состояния, в котором нуждается ваше приложение, и вычислите все остальное, что вам нужно, по запросу. Например, если вы создаете список TODO, храните массив элементов TODO; не храните отдельную переменную состояния для подсчета. Вместо этого, когда вы хотите отобразить счетчик TODO, возьмите длину массива элементов TODO.</target>
        </trans-unit>
        <trans-unit id="c67fad59392ccaf9eabdb04c2a983cfc8ae6159e" translate="yes" xml:space="preserve">
          <source>To compare these approaches, we&amp;rsquo;ll implement a profile page with each of them.</source>
          <target state="translated">Чтобы сравнить эти подходы, мы реализуем страницу профиля для каждого из них.</target>
        </trans-unit>
        <trans-unit id="96c475cd68a1fc17197255130dcc89b3e9015930" translate="yes" xml:space="preserve">
          <source>To create a &lt;strong&gt;new project&lt;/strong&gt; with TypeScript support, run:</source>
          <target state="translated">Чтобы создать &lt;strong&gt;новый проект&lt;/strong&gt; с поддержкой TypeScript, запустите:</target>
        </trans-unit>
        <trans-unit id="58471b12b491c92d9fe1ca36cea662b1ac465f46" translate="yes" xml:space="preserve">
          <source>To create a production build, make sure that you add these plugins &lt;strong&gt;(the order matters)&lt;/strong&gt;:</source>
          <target state="translated">Чтобы создать производственную сборку, убедитесь, что вы добавили эти плагины &lt;strong&gt;(порядок имеет значение)&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="2b971cbe6f62da89ac8ee7a0afbbd588d46b42f7" translate="yes" xml:space="preserve">
          <source>To create a production build, make sure that you add these transforms &lt;strong&gt;(the order matters)&lt;/strong&gt;:</source>
          <target state="translated">Чтобы создать производственную сборку, убедитесь, что вы добавили эти преобразования &lt;strong&gt;(порядок имеет значение)&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="09c773716596ab713897dcc4bd3d4c47765e2c72" translate="yes" xml:space="preserve">
          <source>To demonstrate how to use it, we will connect a &lt;code&gt;NameInput&lt;/code&gt; React component to a Backbone model, and update its &lt;code&gt;firstName&lt;/code&gt; attribute every time the input changes:</source>
          <target state="translated">Чтобы продемонстрировать, как его использовать, мы подключим компонент &lt;code&gt;NameInput&lt;/code&gt; React к модели Backbone и будем обновлять его атрибут &lt;code&gt;firstName&lt;/code&gt; каждый раз, когда изменяется ввод:</target>
        </trans-unit>
        <trans-unit id="0ab6586b71fbb2871880374f66e0a1257dbeeb31" translate="yes" xml:space="preserve">
          <source>To demonstrate the issue, we will add a top-level &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; component that renders our &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; with a button that lets us &lt;strong&gt;switch between different profiles&lt;/strong&gt;:</source>
          <target state="translated">Чтобы продемонстрировать проблему, мы добавим компонент верхнего уровня &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; , который отображает наш &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; с помощью кнопки, которая позволяет нам &lt;strong&gt;переключаться между различными профилями&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="9560e6c157be1cfbb8dadbde0a7036fe5b15715f" translate="yes" xml:space="preserve">
          <source>To demonstrate this feature, we&amp;rsquo;ll use &lt;a href=&quot;https://codesandbox.io/s/musing-ramanujan-bgw2o&quot;&gt;the profile switcher example&lt;/a&gt;. Click the &amp;ldquo;Next&amp;rdquo; button and notice how it takes 1 second to do a transition.</source>
          <target state="translated">Чтобы продемонстрировать эту функцию, мы будем использовать &lt;a href=&quot;https://codesandbox.io/s/musing-ramanujan-bgw2o&quot;&gt;пример переключателя профилей&lt;/a&gt; . Нажмите кнопку &amp;laquo;Далее&amp;raquo; и обратите внимание, что переход занимает 1 секунду.</target>
        </trans-unit>
        <trans-unit id="1c67e18ada396a70dc3856809cab6d64b8650311" translate="yes" xml:space="preserve">
          <source>To demonstrate this, let&amp;rsquo;s sketch out a wrapper for a generic jQuery plugin.</source>
          <target state="translated">Чтобы продемонстрировать это, давайте нарисуем оболочку для универсального плагина jQuery.</target>
        </trans-unit>
        <trans-unit id="e825e335e101a3280e4a617d4f080f38681e18c0" translate="yes" xml:space="preserve">
          <source>To do this in Chrome:</source>
          <target state="translated">Сделать это в Хроме:</target>
        </trans-unit>
        <trans-unit id="61a324463a8291f2d8b2c3c948a378a1dc9f02f3" translate="yes" xml:space="preserve">
          <source>To exclude a component that needs layout effects from the server-rendered HTML, render it conditionally with &lt;code&gt;showChild &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; and defer showing it with &lt;code&gt;useEffect(() =&amp;gt; { setShowChild(true); }, [])&lt;/code&gt;. This way, the UI doesn&amp;rsquo;t appear broken before hydration.</source>
          <target state="translated">Чтобы исключить компонент, которому требуются эффекты макета, из обработанного сервером HTML, визуализируйте его условно с помощью &lt;code&gt;showChild &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; и &lt;code&gt;useEffect(() =&amp;gt; { setShowChild(true); }, [])&lt;/code&gt; его отображение с помощью useEffect (() =&amp;gt; {setShowChild (true);}, []) . Таким образом, пользовательский интерфейс не выглядит сломанным до гидратации.</target>
        </trans-unit>
        <trans-unit id="eb8f9dde0c24efe373765229e6c43a7c2f9337d4" translate="yes" xml:space="preserve">
          <source>To fix it, use a second form of &lt;code&gt;setState()&lt;/code&gt; that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:</source>
          <target state="translated">Чтобы исправить это, используйте вторую форму &lt;code&gt;setState()&lt;/code&gt; которая принимает функцию, а не объект. Эта функция получит предыдущее состояние в качестве первого аргумента, а реквизиты в момент применения обновления в качестве второго аргумента:</target>
        </trans-unit>
        <trans-unit id="3d6dd3cdedde657acf900d4a89c0336446299310" translate="yes" xml:space="preserve">
          <source>To fix this, make sure that the expression before &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; is always boolean:</source>
          <target state="translated">Чтобы исправить это, убедитесь, что выражение перед &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; всегда является логическим:</target>
        </trans-unit>
        <trans-unit id="26f99cfd42eb715ac4995805986b83748003e11d" translate="yes" xml:space="preserve">
          <source>To fix this, we will assign the type to a capitalized variable first:</source>
          <target state="translated">Для исправления этого сначала мы присваиваем тип заглавной переменной:</target>
        </trans-unit>
        <trans-unit id="4180ca125a608d7a0e25df64e609f9ecb9c30f6e" translate="yes" xml:space="preserve">
          <source>To fix this, we will rename &lt;code&gt;hello&lt;/code&gt; to &lt;code&gt;Hello&lt;/code&gt; and use &lt;code&gt;&amp;lt;Hello /&amp;gt;&lt;/code&gt; when referring to it:</source>
          <target state="translated">Чтобы исправить это, мы переименуем &lt;code&gt;hello&lt;/code&gt; в &lt;code&gt;Hello&lt;/code&gt; и будем использовать &lt;code&gt;&amp;lt;Hello /&amp;gt;&lt;/code&gt; при обращении к нему:</target>
        </trans-unit>
        <trans-unit id="4dbe0f13cbbf4d21a676b7a8718fc4a5f8142b73" translate="yes" xml:space="preserve">
          <source>To get around this problem, you can sometimes define the prop as an instance method, like so:</source>
          <target state="translated">Чтобы обойти эту проблему,иногда можно определить реквизит как метод экземпляра:</target>
        </trans-unit>
        <trans-unit id="40ba2f6b08deb2dd30866e5b1b9d4a3ddab93d66" translate="yes" xml:space="preserve">
          <source>To get around this, lift the value into the parent&amp;rsquo;s state:</source>
          <target state="translated">Чтобы обойти это, переведите значение в родительское состояние:</target>
        </trans-unit>
        <trans-unit id="2f2493e07779dd5286222aecb67fb87e67cc0be1" translate="yes" xml:space="preserve">
          <source>To illustrate this, let&amp;rsquo;s look at a prolific example of broken accessibility caused by click events. This is the outside click pattern, where a user can disable an opened popover by clicking outside the element.</source>
          <target state="translated">Чтобы проиллюстрировать это, давайте рассмотрим обширный пример нарушения доступности, вызванного событиями щелчка. Это шаблон внешнего щелчка, при котором пользователь может отключить открываемое всплывающее окно, щелкнув за пределами элемента.</target>
        </trans-unit>
        <trans-unit id="13f9c02dda0f950eb210d479587b65f95f4cc303" translate="yes" xml:space="preserve">
          <source>To illustrate this, we&amp;rsquo;ll use another component from our hypothetical chat example. This is a chat message recipient picker that displays whether the currently selected friend is online:</source>
          <target state="translated">Чтобы проиллюстрировать это, мы будем использовать другой компонент из нашего гипотетического примера чата. Это средство выбора получателя сообщения чата, которое показывает, находится ли текущий выбранный друг в сети:</target>
        </trans-unit>
        <trans-unit id="961d23cd4294477c013c8951229dab570e818eda" translate="yes" xml:space="preserve">
          <source>To implement this, pass a second argument to &lt;code&gt;useEffect&lt;/code&gt; that is the array of values that the effect depends on. Our updated example now looks like this:</source>
          <target state="translated">Чтобы реализовать это, передайте в &lt;code&gt;useEffect&lt;/code&gt; второй аргумент, который представляет собой массив значений, от которых зависит эффект. Наш обновленный пример теперь выглядит так:</target>
        </trans-unit>
        <trans-unit id="0cbe7212eb0bb22a0ce6673108171b6c2eba3a81" translate="yes" xml:space="preserve">
          <source>To implement this, we need to add &amp;ldquo;state&amp;rdquo; to the &lt;code&gt;Clock&lt;/code&gt; component.</source>
          <target state="translated">Чтобы реализовать это, нам нужно добавить &amp;laquo;состояние&amp;raquo; к компоненту &lt;code&gt;Clock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e877ead3847a981597e9e8f4b95b055907cf7831" translate="yes" xml:space="preserve">
          <source>To keep context re-rendering fast, React needs to make each context consumer a separate node in the tree.</source>
          <target state="translated">Для быстрого восстановления контекста React необходимо сделать каждого потребителя контекста отдельным узлом в дереве.</target>
        </trans-unit>
        <trans-unit id="ef8ae5d271af6e506124cf18131498a70ca2be75" translate="yes" xml:space="preserve">
          <source>To learn more about the reasoning behind this convention, please read &lt;a href=&quot;jsx-in-depth#user-defined-components-must-be-capitalized&quot;&gt;JSX In Depth&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать больше о причинах этого соглашения, прочтите &lt;a href=&quot;jsx-in-depth#user-defined-components-must-be-capitalized&quot;&gt;JSX In Depth&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0cf9ecedef1338a4eac3e138d708e2dc3ae6e04d" translate="yes" xml:space="preserve">
          <source>To load a specific version of &lt;code&gt;react&lt;/code&gt; and &lt;code&gt;react-dom&lt;/code&gt;, replace &lt;code&gt;16&lt;/code&gt; with the version number.</source>
          <target state="translated">Чтобы загрузить определенную версию &lt;code&gt;react&lt;/code&gt; и &lt;code&gt;react-dom&lt;/code&gt; , замените &lt;code&gt;16&lt;/code&gt; номером версии.</target>
        </trans-unit>
        <trans-unit id="a5eda8e7fdbff1721f24fafdb7853cef70444134" translate="yes" xml:space="preserve">
          <source>To load a specific version of &lt;code&gt;react&lt;/code&gt; and &lt;code&gt;react-dom&lt;/code&gt;, replace &lt;code&gt;17&lt;/code&gt; with the version number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9170ed3b74ebf37599d0d132e15a2a18d2b9e376" translate="yes" xml:space="preserve">
          <source>To make your UI interactive, you need to be able to trigger changes to your underlying data model. React achieves this with &lt;strong&gt;state&lt;/strong&gt;.</source>
          <target state="translated">Чтобы сделать ваш пользовательский интерфейс интерактивным, вы должны иметь возможность инициировать изменения в вашей базовой модели данных. React достигает этого с помощью &lt;strong&gt;состояния&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5db9a96f52fb596a5edee35fcf3c37dc6093b9ec" translate="yes" xml:space="preserve">
          <source>To opt into production profiling, React provides a special production build with profiling enabled. Read more about how to use this build at &lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiling&lt;/a&gt;</source>
          <target state="translated">Чтобы выбрать производственное профилирование, React предоставляет специальную производственную сборку с включенным профилированием. Узнайте больше о том, как использовать эту сборку, на &lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiling.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75c17fcf1c7e00497ec03d423858cf51a3dcb835" translate="yes" xml:space="preserve">
          <source>To prepare a component for assertions, wrap the code rendering it and performing updates inside an &lt;code&gt;act()&lt;/code&gt; call. This makes your test run closer to how React works in the browser.</source>
          <target state="translated">Чтобы подготовить компонент к утверждениям, оберните код, отображающий его и выполняющий обновления, внутри вызова &lt;code&gt;act()&lt;/code&gt; . Это приближает ваш тест к тому, как React работает в браузере.</target>
        </trans-unit>
        <trans-unit id="b39042bd85f101d91f59c4ce1fe317b35d4e24bd" translate="yes" xml:space="preserve">
          <source>To prevent React from touching the DOM after mounting, we will return an empty &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; from the &lt;code&gt;render()&lt;/code&gt; method. The &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; element has no properties or children, so React has no reason to update it, leaving the jQuery plugin free to manage that part of the DOM:</source>
          <target state="translated">Чтобы React не касался DOM после монтирования, мы вернем пустой &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; из метода &lt;code&gt;render()&lt;/code&gt; . Элемент &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; не имеет свойств или дочерних элементов, поэтому у React нет причин обновлять его, оставляя плагин jQuery свободным для управления этой частью DOM:</target>
        </trans-unit>
        <trans-unit id="aa5fc70f2e6ed1981d083882d48e4da2f10514fd" translate="yes" xml:space="preserve">
          <source>To recap:</source>
          <target state="translated">Подводя итог:</target>
        </trans-unit>
        <trans-unit id="040be61ccf0b0b4ecaddbde299a3d8ac64c9d4c6" translate="yes" xml:space="preserve">
          <source>To reduce the boilerplate, we recommend using &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; which is designed to encourage writing tests that use your components as the end users do.</source>
          <target state="translated">Чтобы уменьшить шаблонность, мы рекомендуем использовать &lt;a href=&quot;https://testing-library.com/react&quot;&gt;библиотеку тестирования React,&lt;/a&gt; которая предназначена для поощрения написания тестов, использующих ваши компоненты, как это делают конечные пользователи.</target>
        </trans-unit>
        <trans-unit id="42bbd6b79127d268b3e68ed35e45d252d94d666f" translate="yes" xml:space="preserve">
          <source>To render a React element into a root DOM node, pass both to &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf123112fa334cc8cc9830f8fa36f2c5c572a5c3" translate="yes" xml:space="preserve">
          <source>To render a React element into a root DOM node, pass both to &lt;code&gt;ReactDOM.render()&lt;/code&gt;:</source>
          <target state="translated">Чтобы отобразить элемент React в корневом узле DOM, передайте оба в &lt;code&gt;ReactDOM.render()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6cd0441cfa854cfc8274a8b07aebcc808a1c6f06" translate="yes" xml:space="preserve">
          <source>To set focus in React, we can use &lt;a href=&quot;refs-and-the-dom&quot;&gt;Refs to DOM elements&lt;/a&gt;.</source>
          <target state="translated">Чтобы установить фокус в React, мы можем использовать &lt;a href=&quot;refs-and-the-dom&quot;&gt;ссылки на элементы DOM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc462152955304c3080ea64e57ba27af39acf454" translate="yes" xml:space="preserve">
          <source>To show that all components are truly isolated, we can create an &lt;code&gt;App&lt;/code&gt; component that renders three &lt;code&gt;&amp;lt;Clock&amp;gt;&lt;/code&gt;s:</source>
          <target state="translated">Чтобы показать, что все компоненты действительно изолированы, мы можем создать компонент &lt;code&gt;App&lt;/code&gt; , который отображает три &lt;code&gt;&amp;lt;Clock&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="802b4b9df13b5c75142658af8ad751b38ada5317" translate="yes" xml:space="preserve">
          <source>To solve these problems, &lt;strong&gt;Hooks let you use more of React&amp;rsquo;s features without classes.&lt;/strong&gt; Conceptually, React components have always been closer to functions. Hooks embrace functions, but without sacrificing the practical spirit of React. Hooks provide access to imperative escape hatches and don&amp;rsquo;t require you to learn complex functional or reactive programming techniques.</source>
          <target state="translated">Чтобы решить эти проблемы, &lt;strong&gt;хуки позволяют использовать больше возможностей React без классов. &lt;/strong&gt;Концептуально компоненты React всегда были ближе к функциям. Хуки включают функции, но без ущерба для практического духа React. Хуки обеспечивают доступ к обязательным аварийным выходам и не требуют от вас изучения сложных функциональных или реактивных методов программирования.</target>
        </trans-unit>
        <trans-unit id="711f5e98a5aa9e9c0eca8855c68da41e1af743dd" translate="yes" xml:space="preserve">
          <source>To solve this, &lt;strong&gt;Hooks let you split one component into smaller functions based on what pieces are related (such as setting up a subscription or fetching data)&lt;/strong&gt;, rather than forcing a split based on lifecycle methods. You may also opt into managing the component&amp;rsquo;s local state with a reducer to make it more predictable.</source>
          <target state="translated">Чтобы решить эту проблему, &lt;strong&gt;хуки позволяют разделить один компонент на более мелкие функции в зависимости от того, какие части связаны между собой (например, настройка подписки или выборка данных)&lt;/strong&gt; , а не принудительное разделение на основе методов жизненного цикла. Вы также можете выбрать управление локальным состоянием компонента с помощью редуктора, чтобы сделать его более предсказуемым.</target>
        </trans-unit>
        <trans-unit id="456430f26783e12f01dfb3ab0df061bfad8fd1e5" translate="yes" xml:space="preserve">
          <source>To solve this, we will import &lt;code&gt;SuspenseList&lt;/code&gt;:</source>
          <target state="translated">Чтобы решить эту проблему, мы импортируем &lt;code&gt;SuspenseList&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="df1f73a03ded94e95f1acc62d67c8fde1d9192e4" translate="yes" xml:space="preserve">
          <source>To solve this, you could copy the methods onto the container before returning it:</source>
          <target state="translated">Чтобы решить эту проблему,вы можете скопировать методы на контейнер,прежде чем возвращать его:</target>
        </trans-unit>
        <trans-unit id="41cee84baf17b8b37b5a62207732214045e846c5" translate="yes" xml:space="preserve">
          <source>To specify a CSS class, use the &lt;code&gt;className&lt;/code&gt; attribute. This applies to all regular DOM and SVG elements like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;, and others.</source>
          <target state="translated">Чтобы указать класс CSS, используйте атрибут &lt;code&gt;className&lt;/code&gt; . Это относится ко всем обычным элементам DOM и SVG, таким как &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; и другим.</target>
        </trans-unit>
        <trans-unit id="ff92cd51808e0c139d5c320624daac6f819d6683" translate="yes" xml:space="preserve">
          <source>To use Flow, you need to:</source>
          <target state="translated">Чтобы использовать Flow,тебе нужно:</target>
        </trans-unit>
        <trans-unit id="7728e4d8199feb9c930de3dba23c508446c8b19f" translate="yes" xml:space="preserve">
          <source>To use TypeScript, you need to:</source>
          <target state="translated">Чтобы использовать TypeScript,необходимо:</target>
        </trans-unit>
        <trans-unit id="161f5895c0ace53ed0bdbe5b22982a6a7e932910" translate="yes" xml:space="preserve">
          <source>To write an uncontrolled component, instead of writing an event handler for every state update, you can &lt;a href=&quot;refs-and-the-dom&quot;&gt;use a ref&lt;/a&gt; to get form values from the DOM.</source>
          <target state="translated">Чтобы написать неконтролируемый компонент, вместо написания обработчика событий для каждого обновления состояния, вы можете &lt;a href=&quot;refs-and-the-dom&quot;&gt;использовать ref&lt;/a&gt; для получения значений формы из DOM.</target>
        </trans-unit>
        <trans-unit id="10ccc5d107f7904bbc61b7a412891849240b695c" translate="yes" xml:space="preserve">
          <source>To write this without mutating the original object, we can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; method:</source>
          <target state="translated">Чтобы написать это без изменения исходного объекта, мы можем использовать метод &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7d7f0884f833f751d0ef4b5804217e883199fbd5" translate="yes" xml:space="preserve">
          <source>Touch Events</source>
          <target state="translated">Сенсорные события</target>
        </trans-unit>
        <trans-unit id="f698e5b2645ac0bbc246d48b10271b68e9474767" translate="yes" xml:space="preserve">
          <source>Tradeoffs</source>
          <target state="translated">Tradeoffs</target>
        </trans-unit>
        <trans-unit id="e09ef19ed713b6bf4b952611e8fb8bed5595d988" translate="yes" xml:space="preserve">
          <source>Traditional Approaches vs Suspense</source>
          <target state="translated">Традиционные подходы против Суспензии</target>
        </trans-unit>
        <trans-unit id="9c6bcbcbb843659ef482025bbc0496703fc2c9f1" translate="yes" xml:space="preserve">
          <source>Traditionally in React, we&amp;rsquo;ve had two popular ways to share stateful logic between components: &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; and &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt;. We will now look at how Hooks solve many of the same problems without forcing you to add more components to the tree.</source>
          <target state="translated">Традиционно в React у нас было два популярных способа обмена логикой с отслеживанием состояния между компонентами: &lt;a href=&quot;render-props&quot;&gt;рендеринг свойств&lt;/a&gt; и &lt;a href=&quot;higher-order-components&quot;&gt;компонентов более высокого порядка&lt;/a&gt; . Теперь мы посмотрим, как хуки решают многие из тех же проблем, не заставляя вас добавлять дополнительные компоненты в дерево.</target>
        </trans-unit>
        <trans-unit id="867ed4b8bc75b5b5326132e2b60c8c0b99335d9c" translate="yes" xml:space="preserve">
          <source>Traditionally, performance concerns around inline functions in React have been related to how passing new callbacks on each render breaks &lt;code&gt;shouldComponentUpdate&lt;/code&gt; optimizations in child components. Hooks approach this problem from three sides.</source>
          <target state="translated">Традиционно проблемы с производительностью встроенных функций в React были связаны с тем, как передача новых обратных вызовов при каждом &lt;code&gt;shouldComponentUpdate&lt;/code&gt; рендеринга должна оптимизировать ComponentUpdate в дочерних компонентах. Крючки подходят к этой проблеме с трех сторон.</target>
        </trans-unit>
        <trans-unit id="79b58c889bdd40be6a9258235ddadc622908c97f" translate="yes" xml:space="preserve">
          <source>Transforming Elements</source>
          <target state="translated">Преобразующие элементы</target>
        </trans-unit>
        <trans-unit id="861553513522659f696c3c2acb5a9f21bd9c2977" translate="yes" xml:space="preserve">
          <source>Transition Events</source>
          <target state="translated">Переходные события</target>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="dab3f667a0d8b5abd4238e47610e2d5abaeedb69" translate="yes" xml:space="preserve">
          <source>Transitions Are Everywhere</source>
          <target state="translated">Переходы повсюду</target>
        </trans-unit>
        <trans-unit id="7b44f1918af555e5d533829bafdc652efe0e1809" translate="yes" xml:space="preserve">
          <source>Transitions are probably the most common Concurrent Mode pattern you&amp;rsquo;ll encounter, but there are a few more patterns you might find useful.</source>
          <target state="translated">Переходы, вероятно, являются наиболее распространенным шаблоном параллельного режима, с которым вы столкнетесь, но есть еще несколько шаблонов, которые могут оказаться полезными.</target>
        </trans-unit>
        <trans-unit id="7a496151406c7c9004e4058dfa652f7eb082f09c" translate="yes" xml:space="preserve">
          <source>Traverse all components in &lt;code&gt;tree&lt;/code&gt; and accumulate all components where &lt;code&gt;test(component)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. This is not that useful on its own, but it&amp;rsquo;s used as a primitive for other test utils.</source>
          <target state="translated">Обход всех компонентов в &lt;code&gt;tree&lt;/code&gt; и накапливаются все компоненты , где &lt;code&gt;test(component)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; . Сам по себе это не так полезно, но используется как примитив для других тестовых утилит.</target>
        </trans-unit>
        <trans-unit id="43ac9a4202ce55afef326fe04f9278e801c3bbcd" translate="yes" xml:space="preserve">
          <source>Triggering imperative animations.</source>
          <target state="translated">Запуск анимации императива.</target>
        </trans-unit>
        <trans-unit id="eccdf562ab40da83be6c16a48f5e930ce51f7c3d" translate="yes" xml:space="preserve">
          <source>Try React</source>
          <target state="translated">Попробуйте реагировать</target>
        </trans-unit>
        <trans-unit id="cfb591755dd76c1452b5a348fbeebe6806df4186" translate="yes" xml:space="preserve">
          <source>Try to avoid this pattern if possible.</source>
          <target state="translated">Постарайтесь по возможности избегать этой закономерности.</target>
        </trans-unit>
        <trans-unit id="f6062735b940c7bf271c9b6f8c2b28e0bf5e59c6" translate="yes" xml:space="preserve">
          <source>Try to resist adding abstraction too early. Now that function components can do more, it&amp;rsquo;s likely that the average function component in your codebase will become longer. This is normal &amp;mdash; don&amp;rsquo;t feel like you &lt;em&gt;have to&lt;/em&gt; immediately split it into Hooks. But we also encourage you to start spotting cases where a custom Hook could hide complex logic behind a simple interface, or help untangle a messy component.</source>
          <target state="translated">Постарайтесь не добавлять абстракции слишком рано. Теперь, когда функциональные компоненты могут делать больше, вероятно, что средний функциональный компонент в вашей кодовой базе станет длиннее. Это нормально - не думайте, что вам &lt;em&gt;нужно&lt;/em&gt; сразу же разбивать его на хуки. Но мы также рекомендуем вам начать замечать случаи, когда пользовательский крючок может скрыть сложную логику за простым интерфейсом или помочь распутать беспорядочный компонент.</target>
        </trans-unit>
        <trans-unit id="334611c431de5751798ac787ddca7df7e73e72f9" translate="yes" xml:space="preserve">
          <source>Try typing into the input now. Something&amp;rsquo;s wrong! The input is updating very slowly.</source>
          <target state="translated">Попробуйте ввести текст прямо сейчас. Что-то не так! Вход обновляется очень медленно.</target>
        </trans-unit>
        <trans-unit id="1b99d50739153c959d7213579c4a965e5873684c" translate="yes" xml:space="preserve">
          <source>Two elements of different types will produce different trees.</source>
          <target state="translated">Два элемента разных типов будут производить разные деревья.</target>
        </trans-unit>
        <trans-unit id="3ba69662a63352acd45295d8a4cf929df3f97fd7" translate="yes" xml:space="preserve">
          <source>Type Definitions</source>
          <target state="translated">Определения типа</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="d3523ff7754d38fca6faee8a30f9b66412b28d78" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: Basic Types</source>
          <target state="translated">Документация по TypeScript:Основные типы</target>
        </trans-unit>
        <trans-unit id="f9ce122df460bfd7e1f36f7b4329fefda2a5f261" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: Migrating from Javascript</source>
          <target state="translated">Документация по TypeScript:Миграция с Javascript</target>
        </trans-unit>
        <trans-unit id="35a5e4b988fb1f5f965bda27ff40e707d14e3010" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: React and Webpack</source>
          <target state="translated">Документация по TypeScript:Реакция и Webpack</target>
        </trans-unit>
        <trans-unit id="c3d225e3af7ff48de43e2bd459c9b1c338c2417b" translate="yes" xml:space="preserve">
          <source>Typechecking With PropTypes</source>
          <target state="translated">Типичная проверка с помощью PropTypes</target>
        </trans-unit>
        <trans-unit id="d215bb61686448cb9ae653f89b0f5e7dd3dad265" translate="yes" xml:space="preserve">
          <source>Typically it is placed at the top of a file. Try adding it to some files in your project and run &lt;code&gt;yarn flow&lt;/code&gt; or &lt;code&gt;npm run flow&lt;/code&gt; to see if Flow already found any issues.</source>
          <target state="translated">Обычно он размещается в верхней части файла. Попробуйте добавить его в некоторые файлы своего проекта и запустите &lt;code&gt;yarn flow&lt;/code&gt; или &lt;code&gt;npm run flow&lt;/code&gt; , чтобы узнать, обнаружил ли Flow какие-либо проблемы.</target>
        </trans-unit>
        <trans-unit id="73e9a38fd5dec87870b44081fc23f86a7fa9e9ef" translate="yes" xml:space="preserve">
          <source>Typically, elements are not used directly, but get returned from components.</source>
          <target state="translated">Обычно элементы не используются напрямую,а возвращаются из компонентов.</target>
        </trans-unit>
        <trans-unit id="fa0ea11a83e136215d62bce59ca2e4bf0e74fd2d" translate="yes" xml:space="preserve">
          <source>Typically, in React constructors are only used for two purposes:</source>
          <target state="translated">Как правило,в реакторных конструкторах используются только для двух целей:</target>
        </trans-unit>
        <trans-unit id="1daac2fa2690d23fe34be5b54bc70593b395a6de" translate="yes" xml:space="preserve">
          <source>Typically, new React apps have a single &lt;code&gt;App&lt;/code&gt; component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like &lt;code&gt;Button&lt;/code&gt; and gradually work your way to the top of the view hierarchy.</source>
          <target state="translated">Как правило, новые приложения React имеют один компонент &lt;code&gt;App&lt;/code&gt; на самом верху. Однако, если вы интегрируете React в существующее приложение, вы можете начать снизу вверх с небольшого компонента, такого как &lt;code&gt;Button&lt;/code&gt; , и постепенно продвигаться к вершине иерархии представлений.</target>
        </trans-unit>
        <trans-unit id="68a6a755ada6660b29b2c9a473f41d1442935fd7" translate="yes" xml:space="preserve">
          <source>Typically, this method can be replaced by &lt;code&gt;componentDidUpdate()&lt;/code&gt;. If you were reading from the DOM in this method (e.g. to save a scroll position), you can move that logic to &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt;.</source>
          <target state="translated">Обычно этот метод можно заменить на &lt;code&gt;componentDidUpdate()&lt;/code&gt; . Если в этом методе вы читали из DOM (например, чтобы сохранить позицию прокрутки), вы можете переместить эту логику в &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f8fe4b91a258395d82ce705eae35d1dba13e5d0" translate="yes" xml:space="preserve">
          <source>UI Events</source>
          <target state="translated">События пользовательского интерфейса</target>
        </trans-unit>
        <trans-unit id="4fb0447cd4cc8d21fe08d8d8d1d385e065b4d751" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillMount()</source>
          <target state="translated">UNSAFE_componentWillMount()</target>
        </trans-unit>
        <trans-unit id="043736bc28e0c4444c9b35f7a1596b1baa86712f" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillReceiveProps()</source>
          <target state="translated">UNSAFE_componentWillReceiveProps()</target>
        </trans-unit>
        <trans-unit id="602b351d9bb4a7f81d1bd7cf0654468b51cd30dd" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillUpdate()</source>
          <target state="translated">UNSAFE_componentWillUpdate()</target>
        </trans-unit>
        <trans-unit id="44a89ad0f567037d498dd94937dc567d3df46056" translate="yes" xml:space="preserve">
          <source>Uncontrolled Components</source>
          <target state="translated">Неконтролируемые компоненты</target>
        </trans-unit>
        <trans-unit id="91ba162b681d6b6ee5e37c09ea2e8e36df8b03a6" translate="yes" xml:space="preserve">
          <source>Under the Hood</source>
          <target state="translated">Под капотом</target>
        </trans-unit>
        <trans-unit id="91622521af8534f6e0a8cc517ee55a45aa6f3a6c" translate="yes" xml:space="preserve">
          <source>Unfortunately, neither using a class nor the &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; syntax helped us solve this problem. This version suffers from exactly the same race conditions, for the same reasons.</source>
          <target state="translated">К сожалению, ни использование класса, ни синтаксис &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; не помогли нам решить эту проблему. Эта версия страдает точно такими же условиями гонки по тем же причинам.</target>
        </trans-unit>
        <trans-unit id="9f80ce906590fe652cad0aa027fb0b4de4ce5b39" translate="yes" xml:space="preserve">
          <source>Unless you have a solution that helps prevent waterfalls, we suggest to prefer APIs that favor or enforce fetching before render. For a concrete example, you can look at how &lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference#usepreloadedquery&quot;&gt;Relay Suspense API&lt;/a&gt; enforces preloading. Our messaging about this hasn&amp;rsquo;t been very consistent in the past. Suspense for Data Fetching is still experimental, so you can expect our recommendations to change over time as we learn more from production usage and understand the problem space better.</source>
          <target state="translated">Если у вас нет решения, которое помогает предотвратить &amp;laquo;водопады&amp;raquo;, мы рекомендуем отдавать предпочтение API, которые поддерживают или обеспечивают принудительную выборку перед рендерингом. В качестве конкретного примера вы можете посмотреть, как &lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference#usepreloadedquery&quot;&gt;Relay Suspense API&lt;/a&gt; обеспечивает предварительную загрузку. В прошлом наши сообщения об этом не были очень последовательными. Приостановка получения данных по-прежнему является экспериментальной, поэтому вы можете ожидать, что наши рекомендации будут меняться со временем, поскольку мы узнаем больше из производственного использования и лучше поймем проблемную область.</target>
        </trans-unit>
        <trans-unit id="961dfa537f5c77804b72ca4ff3d24ad3146c886c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;, the function passed to &lt;code&gt;useEffect&lt;/code&gt; fires &lt;strong&gt;after&lt;/strong&gt; layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn&amp;rsquo;t block the browser from updating the screen.</source>
          <target state="translated">В отличие от &lt;code&gt;componentDidMount&lt;/code&gt; и &lt;code&gt;componentDidUpdate&lt;/code&gt; , функция, переданная в &lt;code&gt;useEffect&lt;/code&gt; , срабатывает &lt;strong&gt;после&lt;/strong&gt; макета и рисования во время отложенного события. Это делает его подходящим для многих распространенных побочных эффектов, таких как настройка подписок и обработчиков событий, потому что большинство типов работы не должны блокировать браузер от обновления экрана.</target>
        </trans-unit>
        <trans-unit id="60a61e13204634a47f56d56022d06304cef51b86" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt;, effects scheduled with &lt;code&gt;useEffect&lt;/code&gt; don&amp;rsquo;t block the browser from updating the screen. This makes your app feel more responsive. The majority of effects don&amp;rsquo;t need to happen synchronously. In the uncommon cases where they do (such as measuring the layout), there is a separate &lt;a href=&quot;hooks-reference#uselayouteffect&quot;&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt;&lt;/a&gt; Hook with an API identical to &lt;code&gt;useEffect&lt;/code&gt;.</source>
          <target state="translated">В отличие от &lt;code&gt;componentDidMount&lt;/code&gt; или &lt;code&gt;componentDidUpdate&lt;/code&gt; , эффекты, запланированные с помощью &lt;code&gt;useEffect&lt;/code&gt; , не блокируют обновление экрана браузером. Это делает ваше приложение более отзывчивым. Большинство эффектов не обязательно должно происходить синхронно. В редких случаях, когда они это делают (например, при измерении макета), существует отдельный &lt;a href=&quot;hooks-reference#uselayouteffect&quot;&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; &lt;/a&gt; с API, идентичным &lt;code&gt;useEffect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b85ad9f5bd023a746d09d4ff6f648319da333072" translate="yes" xml:space="preserve">
          <source>Unlike a React component, a custom Hook doesn&amp;rsquo;t need to have a specific signature. We can decide what it takes as arguments, and what, if anything, it should return. In other words, it&amp;rsquo;s just like a normal function. Its name should always start with &lt;code&gt;use&lt;/code&gt; so that you can tell at a glance that the &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; apply to it.</source>
          <target state="translated">В отличие от компонента React, настраиваемый Hook не требует определенной подписи. Мы можем решить, что он принимает в качестве аргументов и что должен возвращать. Другими словами, это обычная функция. Его имя всегда должно начинаться с &lt;code&gt;use&lt;/code&gt; , чтобы вы могли сразу понять, что к нему применяются &lt;a href=&quot;hooks-rules&quot;&gt;правила хуков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b66fd7542b07767f815ec47cf6d8029807d9066" translate="yes" xml:space="preserve">
          <source>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</source>
          <target state="translated">В отличие от DOM-элементов браузера,React-элементы являются обычными объектами и дешевы в создании.React DOM заботится об обновлении флэш-накопителя,чтобы он соответствовал React элементам.</target>
        </trans-unit>
        <trans-unit id="409cf1b9538e64c6ea6640e27a0a2cb930cbc916" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; method on class components, the &lt;code&gt;areEqual&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt; if the props are equal and &lt;code&gt;false&lt;/code&gt; if the props are not equal. This is the inverse from &lt;code&gt;shouldComponentUpdate&lt;/code&gt;.</source>
          <target state="translated">В отличие от &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt; для компонентов класса, функция &lt;code&gt;areEqual&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , если свойства равны, и &lt;code&gt;false&lt;/code&gt; , если свойства не равны. Это обратное от &lt;code&gt;shouldComponentUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d59b8380230e83e5040bef8fbd9f3658ca115f6" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;setState&lt;/code&gt; method found in class components, &lt;code&gt;useState&lt;/code&gt; does not automatically merge update objects. You can replicate this behavior by combining the function updater form with object spread syntax:</source>
          <target state="translated">В отличие от метода &lt;code&gt;setState&lt;/code&gt; , находящегося в компонентах класса, &lt;code&gt;useState&lt;/code&gt; не объединяет объекты обновления автоматически. Вы можете воспроизвести это поведение, объединив форму средства обновления функции с синтаксисом распространения объекта:</target>
        </trans-unit>
        <trans-unit id="1d4c6b47d1d280d4c980af5669c79f72a2220526" translate="yes" xml:space="preserve">
          <source>Unlike the lifecycle methods above (which React calls for you), the methods below are the methods &lt;em&gt;you&lt;/em&gt; can call from your components.</source>
          <target state="translated">В отличие от приведенных выше методов жизненного цикла (которые React вызывает для вас), приведенные ниже методы - это методы, которые &lt;em&gt;вы&lt;/em&gt; можете вызывать из своих компонентов.</target>
        </trans-unit>
        <trans-unit id="afee7066378e96dff04ac25d626ac161d6174ffc" translate="yes" xml:space="preserve">
          <source>Unmount the in-memory tree, triggering the appropriate lifecycle events.</source>
          <target state="translated">Размонтируйте дерево внутренней памяти,запустив соответствующие события жизненного цикла.</target>
        </trans-unit>
        <trans-unit id="dc1890384805c160e15933042986e8c1270701db" translate="yes" xml:space="preserve">
          <source>Unmounting</source>
          <target state="translated">Unmounting</target>
        </trans-unit>
        <trans-unit id="ec6952e09b9cc6aee90f3110c55ff105e4facbf9" translate="yes" xml:space="preserve">
          <source>Updating</source>
          <target state="translated">Updating</target>
        </trans-unit>
        <trans-unit id="7140c62e34aa56f0454814b03078ba09696680fc" translate="yes" xml:space="preserve">
          <source>Updating Context</source>
          <target state="translated">Обновляющий контекст</target>
        </trans-unit>
        <trans-unit id="e8f9d5ed2b68142879f0064acd39d5dddc19e0e8" translate="yes" xml:space="preserve">
          <source>Updating Context from a Nested Component</source>
          <target state="translated">Обновление контекста из вложенного компонента</target>
        </trans-unit>
        <trans-unit id="636abf0ade1a63bc188164ee602e69ee61c11abf" translate="yes" xml:space="preserve">
          <source>Updating State</source>
          <target state="translated">Обновляющееся состояние</target>
        </trans-unit>
        <trans-unit id="6eb521bc92ea8deef0873674e85f6a2b677e0160" translate="yes" xml:space="preserve">
          <source>Updating the Rendered Element</source>
          <target state="translated">Обновление реорганизованного элемента</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="cb779c71f17fb4651dcbb26ce93ad9f3b869a15e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; to let React know if a component&amp;rsquo;s output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.</source>
          <target state="translated">Используйте &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; чтобы сообщить React, не влияет ли на вывод компонента текущее изменение состояния или свойств. По умолчанию выполняется повторная визуализация при каждом изменении состояния, и в подавляющем большинстве случаев следует полагаться на поведение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b1f252513f7226882a0b24dbdb6d8dcbaf0e88fb" translate="yes" xml:space="preserve">
          <source>Use HOCs For Cross-Cutting Concerns</source>
          <target state="translated">Использовать HOCs для решения сквозных задач</target>
        </trans-unit>
        <trans-unit id="efcd67afa619eafb57d29f164d865f7967e67a72" translate="yes" xml:space="preserve">
          <source>Use Render Props for Cross-Cutting Concerns</source>
          <target state="translated">Использовать реквизит для поперечной резки</target>
        </trans-unit>
        <trans-unit id="945e7893698701d1a0783de1c07354e2873bcd51" translate="yes" xml:space="preserve">
          <source>Use an integrated toolchain for the best user and developer experience.</source>
          <target state="translated">Используйте интегрированную цепочку инструментов для наилучшего взаимодействия с пользователями и разработчиками.</target>
        </trans-unit>
        <trans-unit id="9e6c96a7f53534a11f3be968f06caa0a7bdbcfbe" translate="yes" xml:space="preserve">
          <source>Use arrow functions, e.g. &lt;code&gt;onClick={(e) =&amp;gt; this.handleClick(e)}&lt;/code&gt;.</source>
          <target state="translated">Используйте стрелочные функции, например &lt;code&gt;onClick={(e) =&amp;gt; this.handleClick(e)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7add3fa600f24de210341c304ca34869584489ae" translate="yes" xml:space="preserve">
          <source>Use as little or as much React as you need.</source>
          <target state="translated">Используйте так мало или так много Реакция,как вам нужно.</target>
        </trans-unit>
        <trans-unit id="a25e73bb61bda8c3da0ca1b1bab2f08d9fd2b4b1" translate="yes" xml:space="preserve">
          <source>Use refs sparingly. If you find yourself often using refs to &amp;ldquo;make things happen&amp;rdquo; in your app, consider getting more familiar with &lt;a href=&quot;lifting-state-up&quot;&gt;top-down data flow&lt;/a&gt;.</source>
          <target state="translated">Умеренно используйте ссылки. Если вы часто используете ссылки, чтобы &amp;laquo;заставить что-то происходить&amp;raquo; в своем приложении, подумайте о том, чтобы поближе познакомиться с &lt;a href=&quot;lifting-state-up&quot;&gt;потоком данных сверху вниз&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a45798aa0c2077edf1d4bdb602e7360df7b30fa1" translate="yes" xml:space="preserve">
          <source>Use the Production Build</source>
          <target state="translated">Использовать производственное здание</target>
        </trans-unit>
        <trans-unit id="501943d285edf21697f4469e8359a5357bcaaa0a" translate="yes" xml:space="preserve">
          <source>Use the right file extensions</source>
          <target state="translated">Используйте правильные расширения файлов</target>
        </trans-unit>
        <trans-unit id="d60684d4bf976b6606e32f95fd03e20ad2cdaa9b" translate="yes" xml:space="preserve">
          <source>Use this as an opportunity to operate on the DOM when the component has been updated. This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).</source>
          <target state="translated">Используйте это как возможность работать на флэш-накопителе после обновления компонента.Это также хорошее место для выполнения сетевых запросов,если вы сравниваете текущий реквизит с предыдущим (например,сетевой запрос может не понадобиться,если реквизит не изменился).</target>
        </trans-unit>
        <trans-unit id="09bb24d7602932e8e5252fa3559cae849ed40e36" translate="yes" xml:space="preserve">
          <source>User-Defined Components Must Be Capitalized</source>
          <target state="translated">Определенные пользователем компоненты должны быть капитализированы</target>
        </trans-unit>
        <trans-unit id="7bf9efc7891aa3dc73c45128d1b30d30f360d6b7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Enter&lt;/code&gt; to activate elements.</source>
          <target state="translated">Использование &lt;code&gt;Enter&lt;/code&gt; для активации элементов.</target>
        </trans-unit>
        <trans-unit id="ce90babb0b7d4740ec6dff8069a1a70de2528e0a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Function.prototype.bind&lt;/code&gt; in render creates a new function each time the component renders, which may have performance implications (see below).</source>
          <target state="translated">Использование &lt;code&gt;Function.prototype.bind&lt;/code&gt; в рендере создает новую функцию каждый раз при рендеринге компонента, что может повлиять на производительность (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="0268b704052253efcc133928357695716f43f5ba" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;React.lazy&lt;/code&gt;with dynamic import requires Promises to be available in the JS environment. This requires a polyfill on IE11 and below.</source>
          <target state="translated">Для использования &lt;code&gt;React.lazy&lt;/code&gt; с динамическим импортом требуется, чтобы Promises были доступны в среде JS. Для этого требуется полифилл в IE11 и ниже.</target>
        </trans-unit>
        <trans-unit id="a83225bb31031d74727c744b6f62dbc383870f8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ReactDOM.render()&lt;/code&gt; to hydrate a server-rendered container is deprecated and will be removed in React 17. Use &lt;a href=&quot;#hydrate&quot;&gt;&lt;code&gt;hydrate()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Использование &lt;code&gt;ReactDOM.render()&lt;/code&gt; для гидратации контейнера, отображаемого на сервере, устарело и будет удалено в React 17. Вместо этого используйте &lt;a href=&quot;#hydrate&quot;&gt; &lt;code&gt;hydrate()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48a22ac3c2727930ac2f50162b02ed7090f9a062" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Tab&lt;/code&gt; and &lt;code&gt;Shift+Tab&lt;/code&gt; to browse.</source>
          <target state="translated">Использование &lt;code&gt;Tab&lt;/code&gt; и &lt;code&gt;Shift+Tab&lt;/code&gt; для просмотра.</target>
        </trans-unit>
        <trans-unit id="5e1ba50e8dbe44c933cf9cf96a6e9c30d740bb4f" translate="yes" xml:space="preserve">
          <source>Using Backbone Models in React Components</source>
          <target state="translated">Использование магистральных моделей в реактивных компонентах</target>
        </trans-unit>
        <trans-unit id="c5fda53e2ec39e55fd191ee394197d4e5b88f71c" translate="yes" xml:space="preserve">
          <source>Using Dot Notation for JSX Type</source>
          <target state="translated">Использование точечной нотации для типа JSX</target>
        </trans-unit>
        <trans-unit id="338906b8dfe048bf958f52de3a30e3c835027dc9" translate="yes" xml:space="preserve">
          <source>Using Props Other Than &lt;code&gt;render&lt;/code&gt;</source>
          <target state="translated">Использование реквизита, отличного от &lt;code&gt;render&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88a483ee4ba49991c90e9465efe4ff7c34213894" translate="yes" xml:space="preserve">
          <source>Using React in your Web Components</source>
          <target state="translated">Использование Реакции в Ваших Веб-компонентах</target>
        </trans-unit>
        <trans-unit id="5fc69751a627e9e7608b6451c760b3088a1776d1" translate="yes" xml:space="preserve">
          <source>Using State Correctly</source>
          <target state="translated">Использование государства Правильно</target>
        </trans-unit>
        <trans-unit id="603e93ed4db9941f0130803851a41f15bbe0f4a6" translate="yes" xml:space="preserve">
          <source>Using Suspense in Practice</source>
          <target state="translated">Использование приостановки на практике</target>
        </trans-unit>
        <trans-unit id="64afa8340add2c118e1444b499855f90bdb7bdc0" translate="yes" xml:space="preserve">
          <source>Using TypeScript with Create React App</source>
          <target state="translated">Использование скрипта TypeScript с созданием приложения React App</target>
        </trans-unit>
        <trans-unit id="3181824009d3d8ab8f244eb65008a1d2883dcad7" translate="yes" xml:space="preserve">
          <source>Using Web Components in React</source>
          <target state="translated">Использование веб-компонентов в реакции</target>
        </trans-unit>
        <trans-unit id="2b2c69cb3df5e00c387989ba3ee2f2cdc8414be3" translate="yes" xml:space="preserve">
          <source>Using a Custom Hook</source>
          <target state="translated">Использование пользовательского крюка</target>
        </trans-unit>
        <trans-unit id="6f7d4170c0a916b341350d421df2093f43390598" translate="yes" xml:space="preserve">
          <source>Using a render prop can negate the advantage that comes from using &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt; if you create the function inside a &lt;code&gt;render&lt;/code&gt; method. This is because the shallow prop comparison will always return &lt;code&gt;false&lt;/code&gt; for new props, and each &lt;code&gt;render&lt;/code&gt; in this case will generate a new value for the render prop.</source>
          <target state="translated">Использование &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt; &lt;code&gt;React.PureComponent&lt;/code&gt; &lt;/a&gt; рендеринга может свести на нет преимущество, которое дает использование React.PureComponent, если вы создаете функцию внутри метода &lt;code&gt;render&lt;/code&gt; . Это связано с тем, что сравнение мелких свойств всегда будет возвращать &lt;code&gt;false&lt;/code&gt; для новых свойств, и каждый &lt;code&gt;render&lt;/code&gt; в этом случае будет генерировать новое значение для свойства рендеринга.</target>
        </trans-unit>
        <trans-unit id="49915cecc2ab68b6142d2a20882e769c815b1066" translate="yes" xml:space="preserve">
          <source>Using an arrow function in render creates a new function each time the component renders, which may break optimizations based on strict identity comparison.</source>
          <target state="translated">Использование функции стрелки в рендере создает новую функцию каждый раз,когда компонент визуализирует,что может нарушить оптимизацию,основанную на строгом сравнении идентичности.</target>
        </trans-unit>
        <trans-unit id="fda59156c5563425ee7b0abda49555ce452777ef" translate="yes" xml:space="preserve">
          <source>Using context, we can avoid passing props through intermediate elements:</source>
          <target state="translated">Используя контекст,мы можем избежать прохождения реквизита через промежуточные элементы:</target>
        </trans-unit>
        <trans-unit id="645200f75c6ba99bc214dfeec259746827cb20cb" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in Chrome</source>
          <target state="translated">Использование инспектора доступа в хроме</target>
        </trans-unit>
        <trans-unit id="1c8312836922d5bcc9a8621ff5c07034606e0932" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in Firefox</source>
          <target state="translated">Использование Инспектора Доступности в Firefox</target>
        </trans-unit>
        <trans-unit id="d5154d969b060a162f316e9c1d66f061f10670c9" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in OS X Safari</source>
          <target state="translated">Использование Инспектора Доступности в OS X Safari</target>
        </trans-unit>
        <trans-unit id="34c7c3a33655d5d85c739523b21799c0f20d8a60" translate="yes" xml:space="preserve">
          <source>Using the Effect Hook</source>
          <target state="translated">Использование эффектного крючка</target>
        </trans-unit>
        <trans-unit id="5e7e608bd7f9e83ae5e7e66cf348bd9227a4b385" translate="yes" xml:space="preserve">
          <source>Using the Next Channel for Integration Testing</source>
          <target state="translated">Использование следующего канала для тестирования интеграции</target>
        </trans-unit>
        <trans-unit id="2cfba3a33414eaa5fb929de86b11b61915da61b8" translate="yes" xml:space="preserve">
          <source>Using the State Hook</source>
          <target state="translated">Использование государственного крюка</target>
        </trans-unit>
        <trans-unit id="ed1021f647e8e233565d10846cc30295f9907000" translate="yes" xml:space="preserve">
          <source>Using third-party libraries from npm.</source>
          <target state="translated">Использование сторонних библиотек с npm.</target>
        </trans-unit>
        <trans-unit id="30d2d9559518afc440cfbf857d66b14037aea32a" translate="yes" xml:space="preserve">
          <source>Using this lifecycle method often leads to bugs and inconsistencies</source>
          <target state="translated">Использование этого метода жизненного цикла часто приводит к ошибкам и несоответствиям.</target>
        </trans-unit>
        <trans-unit id="b8d2760e3203f83799237c703f9e064427a4c014" translate="yes" xml:space="preserve">
          <source>Using this technique will only capture the last published value in a frame. You can see an example of how this optimization works on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/scroll&quot;&gt;&lt;code&gt;MDN&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">При использовании этого метода в кадр будет записано только последнее опубликованное значение. Вы можете увидеть пример того, как эта оптимизация работает на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/scroll&quot;&gt; &lt;code&gt;MDN&lt;/code&gt; .&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f13ada68bafae110ed822c96f8ad142bdd952a1f" translate="yes" xml:space="preserve">
          <source>Using this, we first create a ref to an element in the JSX of a component class:</source>
          <target state="translated">Используя это,мы сначала создаем ссылку на элемент в JSX класса компонента:</target>
        </trans-unit>
        <trans-unit id="06db89939f2e73f5bd1f0be19ed53194716ba43e" translate="yes" xml:space="preserve">
          <source>Usually you would render lists inside a &lt;a href=&quot;components-and-props&quot;&gt;component&lt;/a&gt;.</source>
          <target state="translated">Обычно списки визуализируются внутри &lt;a href=&quot;components-and-props&quot;&gt;компонента&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e48c24f8824265a1d358e010460e0be08e5de8e2" translate="yes" xml:space="preserve">
          <source>Usually, HOCs accept additional arguments. In this example from Relay, a config object is used to specify a component&amp;rsquo;s data dependencies:</source>
          <target state="translated">Обычно HOC принимают дополнительные аргументы. В этом примере от Relay объект конфигурации используется для указания зависимостей данных компонента:</target>
        </trans-unit>
        <trans-unit id="b203f86fed1a8723475dce775230e059b8ed90f3" translate="yes" xml:space="preserve">
          <source>Usually, an update to Next is accompanied by a corresponding update to Experimental. They are based on the same source revision, but are built using a different set of feature flags.</source>
          <target state="translated">Обычно обновление до Next сопровождается соответствующим обновлением до Experimental.Они основаны на одной и той же ревизии исходного кода,но собираются с использованием другого набора флагов возможностей.</target>
        </trans-unit>
        <trans-unit id="f1866b2703384cc1bc55c57199a504d049c9aa7b" translate="yes" xml:space="preserve">
          <source>Usually, when we update the state, we expect to see changes on the screen immediately. This makes sense because we want to keep our app responsive to user input. However, there are cases where we might prefer to &lt;strong&gt;defer an update from appearing on the screen&lt;/strong&gt;.</source>
          <target state="translated">Обычно, когда мы обновляем состояние, мы ожидаем немедленного появления изменений на экране. Это имеет смысл, потому что мы хотим, чтобы наше приложение реагировало на ввод пользователя. Однако есть случаи, когда мы могли бы предпочесть &lt;strong&gt;отложить появление обновления на экране&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a7169fb86be8f9fb1f6dc74f3d60393bc42e3fa2" translate="yes" xml:space="preserve">
          <source>Verifies that &lt;code&gt;children&lt;/code&gt; has only one child (a React element) and returns it. Otherwise this method throws an error.</source>
          <target state="translated">Проверяет, что у &lt;code&gt;children&lt;/code&gt; есть только один дочерний элемент (элемент React), и возвращает его. В противном случае этот метод выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="b84f1567e8f5f03f192913a113aca22668c5a0d0" translate="yes" xml:space="preserve">
          <source>Verifies the object is a React element. Returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Проверяет, является ли объект элементом React. Возвращает &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d6aa7034ec4c5be2d4ab35f28b89ccab502b9e" translate="yes" xml:space="preserve">
          <source>Versioned Documentation</source>
          <target state="translated">Версионная документация</target>
        </trans-unit>
        <trans-unit id="cd797cf0fe303d32f5502e0cd652eb3709acf2f2" translate="yes" xml:space="preserve">
          <source>Versioning Policy</source>
          <target state="translated">Политика версионирования</target>
        </trans-unit>
        <trans-unit id="0e87ae23796278c9462fd444edf70fe1a009d923" translate="yes" xml:space="preserve">
          <source>Video Introduction</source>
          <target state="translated">Введение в видео</target>
        </trans-unit>
        <trans-unit id="c2a2aea3dead057a6a1ec3e587afea025320c2dd" translate="yes" xml:space="preserve">
          <source>View the full example source code</source>
          <target state="translated">Просмотреть полный пример исходного кода</target>
        </trans-unit>
        <trans-unit id="64cfe6fcb223ea8768b2640f2636977ba0d164fb" translate="yes" xml:space="preserve">
          <source>Virtual DOM and Internals</source>
          <target state="translated">Виртуальный DOM и Интернэшнл</target>
        </trans-unit>
        <trans-unit id="f85fbf92e499fc71591a2e669124a9722afaf021" translate="yes" xml:space="preserve">
          <source>Virtualize Long Lists</source>
          <target state="translated">Виртуализировать длинные списки</target>
        </trans-unit>
        <trans-unit id="2ef3ffb278db3f335c5ff68b2879712b4c381076" translate="yes" xml:space="preserve">
          <source>VoiceOver in Safari</source>
          <target state="translated">VoiceOver в Сафари</target>
        </trans-unit>
        <trans-unit id="d9957a9af3a69ef84d5b820d611a3f62b1ccf86a" translate="yes" xml:space="preserve">
          <source>VoiceOver is an integrated screen reader on Apple devices.</source>
          <target state="translated">VoiceOver-это встроенное устройство чтения экрана на устройствах Apple.</target>
        </trans-unit>
        <trans-unit id="665b0a94753596ab58c7b0bfabd4f05a281f3d86" translate="yes" xml:space="preserve">
          <source>WAI-ARIA</source>
          <target state="translated">WAI-ARIA</target>
        </trans-unit>
        <trans-unit id="55894c1196e8f880851ae38d59786f7cb22f88d8" translate="yes" xml:space="preserve">
          <source>WAI-ARIA Authoring Practices - Design Patterns and Widgets</source>
          <target state="translated">WAI-ARIA Авторинговые практики-Шаблоны и виджеты для проектирования</target>
        </trans-unit>
        <trans-unit id="3354373068a65230be0efcf6468f02a4db93217b" translate="yes" xml:space="preserve">
          <source>WCAG</source>
          <target state="translated">WCAG</target>
        </trans-unit>
        <trans-unit id="0f298949c575de92097cb4a1eb81d16e079aff0f" translate="yes" xml:space="preserve">
          <source>WCAG - Understanding the Color Contrast Requirement</source>
          <target state="translated">WCAG-Понимание требований к цветовому контрасту</target>
        </trans-unit>
        <trans-unit id="565ff00b6dae2e3752c6332ca334f9853f076fdb" translate="yes" xml:space="preserve">
          <source>WCAG - Understanding the Document Title Requirement</source>
          <target state="translated">WCAG-Понимание требований к заголовку документа</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
