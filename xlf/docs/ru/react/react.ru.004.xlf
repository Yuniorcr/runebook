<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="0bfe11fb0bd23f69ef55dfbf3a328a415deca1e1" translate="yes" xml:space="preserve">
          <source>We also can&amp;rsquo;t display the &lt;code&gt;BoilingVerdict&lt;/code&gt; from &lt;code&gt;Calculator&lt;/code&gt;. The &lt;code&gt;Calculator&lt;/code&gt; doesn&amp;rsquo;t know the current temperature because it is hidden inside the &lt;code&gt;TemperatureInput&lt;/code&gt;.</source>
          <target state="translated">Мы также не можем отображать &lt;code&gt;BoilingVerdict&lt;/code&gt; из &lt;code&gt;Calculator&lt;/code&gt; . &lt;code&gt;Calculator&lt;/code&gt; не знает текущую температуру , поскольку она скрыта внутри &lt;code&gt;TemperatureInput&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e2280d133c53709865c8f43e30cdfb593c6f1a9" translate="yes" xml:space="preserve">
          <source>We also encourage you to use JS error reporting services (or build your own) so that you can learn about unhandled exceptions as they happen in production, and fix them.</source>
          <target state="translated">Мы также рекомендуем вам использовать JS-сервисы отчетности об ошибках (или создать свои собственные),чтобы вы могли узнать о необработанных исключениях,как они происходят в производстве,и исправить их.</target>
        </trans-unit>
        <trans-unit id="81cce18154015640ed2a3912f965c20c89cc804d" translate="yes" xml:space="preserve">
          <source>We also learned a little bit more about what Hooks are. Hooks are functions that let you &amp;ldquo;hook into&amp;rdquo; React features from function components. Their names always start with &lt;code&gt;use&lt;/code&gt;, and there are more Hooks we haven&amp;rsquo;t seen yet.</source>
          <target state="translated">Мы также узнали немного больше о том, что такое хуки. Хуки - это функции, которые позволяют вам &amp;laquo;подключаться&amp;raquo; к функциям React из функциональных компонентов. Их имена всегда начинаются с &lt;code&gt;use&lt;/code&gt; , и есть еще хуки, которых мы еще не видели.</target>
        </trans-unit>
        <trans-unit id="1a06b4800bed82086df99569fc99b049a8f536a2" translate="yes" xml:space="preserve">
          <source>We also recommend checking out Enzyme&amp;rsquo;s &lt;a href=&quot;https://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow Rendering API&lt;/a&gt;. It provides a nicer higher-level API over the same functionality.</source>
          <target state="translated">Мы также рекомендуем попробовать Enzyme &lt;a href=&quot;https://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow Rendering API&lt;/a&gt; . Он предоставляет более приятный API более высокого уровня по той же функциональности.</target>
        </trans-unit>
        <trans-unit id="d2acd14c5f1177e3efc803ef0c6bfa85043eff0c" translate="yes" xml:space="preserve">
          <source>We also recommend to verify that the CDN you are using sets the &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; HTTP header:</source>
          <target state="translated">Мы также рекомендуем убедиться, что используемый вами CDN устанавливает HTTP-заголовок &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9f90673956b6b1153d069bebc4fcb338546634e9" translate="yes" xml:space="preserve">
          <source>We also understand that the bar for adding a new primitive to React is extremely high. For curious readers, we have prepared a &lt;a href=&quot;https://github.com/reactjs/rfcs/pull/68&quot;&gt;detailed RFC&lt;/a&gt; that dives into motivation with more details, and provides extra perspective on the specific design decisions and related prior art.</source>
          <target state="translated">Мы также понимаем, что планка для добавления нового примитива в React чрезвычайно высока. Для любопытных читателей мы подготовили &lt;a href=&quot;https://github.com/reactjs/rfcs/pull/68&quot;&gt;подробный RFC&lt;/a&gt; , в котором более подробно рассказывается о мотивации и дается дополнительная информация о конкретных проектных решениях и соответствующем уровне техники.</target>
        </trans-unit>
        <trans-unit id="e88e0a56f6ad5a5eb9d99b0270eccb4e024c1a34" translate="yes" xml:space="preserve">
          <source>We also want to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval&quot;&gt;clear that timer&lt;/a&gt; whenever the DOM produced by the &lt;code&gt;Clock&lt;/code&gt; is removed. This is called &amp;ldquo;unmounting&amp;rdquo; in React.</source>
          <target state="translated">Мы также хотим &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval&quot;&gt;очищать этот таймер&lt;/a&gt; всякий раз, когда DOM, созданный &lt;code&gt;Clock&lt;/code&gt; , удаляется. В React это называется &amp;laquo;размонтирование&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5365ad1fb8e8f2e33ecc7188b78c50f5f0e7479f" translate="yes" xml:space="preserve">
          <source>We are regularly refining the heuristics in order to make common use cases faster. In the current implementation, you can express the fact that a subtree has been moved amongst its siblings, but you cannot tell that it has moved somewhere else. The algorithm will rerender that full subtree.</source>
          <target state="translated">Мы регулярно совершенствуем эвристику для того,чтобы быстрее сделать обычные случаи использования.В текущей реализации можно выразить тот факт,что поддерево было перемещено среди своих братьев и сестер,но нельзя сказать,что оно переместилось куда-то еще.Алгоритм вернет это полное поддерево.</target>
        </trans-unit>
        <trans-unit id="d116c83b89af6cbda01c9512b005b983349cadd5" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;ReactDOM.render()&lt;/code&gt; with the &lt;code&gt;&amp;lt;Welcome name=&quot;Sara&quot; /&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">Мы вызываем &lt;code&gt;ReactDOM.render()&lt;/code&gt; с элементом &lt;code&gt;&amp;lt;Welcome name=&quot;Sara&quot; /&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0687fbf49286c2ec12b4f4678698a178afc11fdd" translate="yes" xml:space="preserve">
          <source>We call this a &amp;ldquo;root&amp;rdquo; DOM node because everything inside it will be managed by React DOM.</source>
          <target state="translated">Мы называем это &amp;laquo;корневым&amp;raquo; узлом DOM, потому что все внутри него будет управляться React DOM.</target>
        </trans-unit>
        <trans-unit id="dea916ead1ececf4e26bb88719ffd02a287439fb" translate="yes" xml:space="preserve">
          <source>We call this approach &amp;ldquo;fetch-on-render&amp;rdquo; because it doesn&amp;rsquo;t start fetching until &lt;em&gt;after&lt;/em&gt; the component has rendered on the screen. This leads to a problem known as a &amp;ldquo;waterfall&amp;rdquo;.</source>
          <target state="translated">Мы называем этот подход &amp;laquo;выборки-на-визуализации&amp;raquo; , потому что он не начинает выборку , пока &lt;em&gt;после&lt;/em&gt; того, как компонент оказал на экране. Это приводит к проблеме, известной как &amp;laquo;водопад&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="801ca9e396c70ea52ff8cfbd3f95c4e9d3304075" translate="yes" xml:space="preserve">
          <source>We can check some accessibility features directly in our JSX code. Often intellisense checks are already provided in JSX aware IDE&amp;rsquo;s for the ARIA roles, states and properties. We also have access to the following tool:</source>
          <target state="translated">Мы можем проверить некоторые функции доступности прямо в нашем JSX-коде. Часто проверки intellisense уже предусмотрены в IDE с поддержкой JSX для ролей, состояний и свойств ARIA. У нас также есть доступ к следующему инструменту:</target>
        </trans-unit>
        <trans-unit id="0315740899889aaecb6fca0ac9d4299c0036235a" translate="yes" xml:space="preserve">
          <source>We can combine the two by making the React state be the &amp;ldquo;single source of truth&amp;rdquo;. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a &amp;ldquo;controlled component&amp;rdquo;.</source>
          <target state="translated">Мы можем объединить их, сделав состояние React &amp;laquo;единственным источником истины&amp;raquo;. Затем компонент React, который отображает форму, также контролирует, что происходит в этой форме при последующем вводе пользователем. Элемент формы ввода, значение которого таким образом контролируется React, называется &amp;laquo;управляемый компонент&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d318ed6f5f31fef5a0927c77ba11af495ad3b8e8" translate="yes" xml:space="preserve">
          <source>We can declare special methods on the component class to run some code when a component mounts and unmounts:</source>
          <target state="translated">Мы можем объявить специальные методы на классе компонентов для выполнения некоторого кода,когда компонент монтируется и размонтируется:</target>
        </trans-unit>
        <trans-unit id="38da4b536bf1075811107d57f35f3c7ec26e707d" translate="yes" xml:space="preserve">
          <source>We can now change the &lt;code&gt;Calculator&lt;/code&gt; to render two separate temperature inputs:</source>
          <target state="translated">Теперь мы можем изменить &lt;code&gt;Calculator&lt;/code&gt; для отображения двух отдельных входных значений температуры:</target>
        </trans-unit>
        <trans-unit id="73fada2c6ee0dde707d8d724cd500dba20459065" translate="yes" xml:space="preserve">
          <source>We can now see that the need for &lt;code&gt;useTransition&lt;/code&gt; is &lt;em&gt;very&lt;/em&gt; common. Pretty much any button click or interaction that can lead to a component suspending needs to be wrapped in &lt;code&gt;useTransition&lt;/code&gt; to avoid accidentally hiding something the user is interacting with.</source>
          <target state="translated">Теперь мы можем видеть , что потребность в &lt;code&gt;useTransition&lt;/code&gt; является &lt;em&gt;очень&lt;/em&gt; распространенным явлением. Практически любое нажатие кнопки или взаимодействие, которое может привести к приостановке работы компонента, необходимо заключить в &lt;code&gt;useTransition&lt;/code&gt; , чтобы случайно не скрыть то, с чем взаимодействует пользователь.</target>
        </trans-unit>
        <trans-unit id="240673c357597499949284e0383f4fe5f428ec57" translate="yes" xml:space="preserve">
          <source>We can now simplify &lt;code&gt;Comment&lt;/code&gt; a tiny bit:</source>
          <target state="translated">Теперь мы можем немного упростить &lt;code&gt;Comment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a1651e3cc930105fbd7c7f2a069537f4573a560c" translate="yes" xml:space="preserve">
          <source>We can refactor the previous example into a component that accepts an array of &lt;code&gt;numbers&lt;/code&gt; and outputs a list of elements.</source>
          <target state="translated">Мы можем преобразовать предыдущий пример в компонент, который принимает массив &lt;code&gt;numbers&lt;/code&gt; и выводит список элементов.</target>
        </trans-unit>
        <trans-unit id="0b8395d3ccd48364a5e95de668d92822952ff915" translate="yes" xml:space="preserve">
          <source>We can see how typing in the input causes stutter. Now let&amp;rsquo;s add &lt;code&gt;useDeferredValue&lt;/code&gt;:</source>
          <target state="translated">Мы видим, как ввод текста вызывает заикание. Теперь добавим &lt;code&gt;useDeferredValue&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ac714531d13810a1f186c53455166ed3abd9b760" translate="yes" xml:space="preserve">
          <source>We can see in &lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;this example&lt;/a&gt; that pressing &amp;ldquo;Refresh&amp;rdquo; works. The &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; components receive a new &lt;code&gt;resource&lt;/code&gt; prop that represents the fresh data, they &amp;ldquo;suspend&amp;rdquo; because we don&amp;rsquo;t have a response yet, and we see the fallbacks. When the response loads, we can see the updated posts (our fake API adds them every 3 seconds).</source>
          <target state="translated">В &lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;этом примере&lt;/a&gt; мы видим, что нажатие &amp;laquo;Обновить&amp;raquo; работает. В &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; компоненты получить новый &lt;code&gt;resource&lt;/code&gt; пропеллер , который представляет свежие данные, они &amp;laquo;приостановить&amp;raquo; , потому что у нас нет ответа еще, и мы видим резервные объявления. Когда ответ загружается, мы видим обновленные сообщения (наш поддельный API добавляет их каждые 3 секунды).</target>
        </trans-unit>
        <trans-unit id="1ea1ede495fd5963c31b6ef743c03c777ac3dc91" translate="yes" xml:space="preserve">
          <source>We can see now how Concurrent Mode helps us achieve a good user experience without sacrificing isolation and modularity of components. React coordinates the transition.</source>
          <target state="translated">Теперь мы видим,как Concurrent Mode помогает нам достичь хорошего пользовательского опыта без ущерба для изоляции и модульности компонентов.Реакция координирует переход.</target>
        </trans-unit>
        <trans-unit id="4f967ab5065b900688a0c0d89c66176628622a03" translate="yes" xml:space="preserve">
          <source>We can set this in React using the &lt;a href=&quot;https://github.com/gaearon/react-document-title&quot;&gt;React Document Title Component&lt;/a&gt;.</source>
          <target state="translated">Мы можем установить это в React с помощью &lt;a href=&quot;https://github.com/gaearon/react-document-title&quot;&gt;компонента React Document Title&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2bd80e65c62c614b84617e1716cdcc13cdf9204" translate="yes" xml:space="preserve">
          <source>We can start by encapsulating how the clock looks:</source>
          <target state="translated">Мы можем начать с инкапсуляции того,как выглядят часы:</target>
        </trans-unit>
        <trans-unit id="062efaa9ef4ef374ba95e07a8f7fbb0094129c10" translate="yes" xml:space="preserve">
          <source>We can start by extracting a &lt;code&gt;TemperatureInput&lt;/code&gt; component from &lt;code&gt;Calculator&lt;/code&gt;. We will add a new &lt;code&gt;scale&lt;/code&gt; prop to it that can either be &lt;code&gt;&quot;c&quot;&lt;/code&gt; or &lt;code&gt;&quot;f&quot;&lt;/code&gt;:</source>
          <target state="translated">Мы можем начать с извлечения компонента &lt;code&gt;TemperatureInput&lt;/code&gt; из &lt;code&gt;Calculator&lt;/code&gt; . Мы добавим к нему новую опору &lt;code&gt;scale&lt;/code&gt; которая может быть либо &lt;code&gt;&quot;c&quot;&lt;/code&gt; либо &lt;code&gt;&quot;f&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2c05e2cbfb5369191e544f39acda01e6250d465" translate="yes" xml:space="preserve">
          <source>We can use it in three steps.</source>
          <target state="translated">Мы можем использовать его в три этапа.</target>
        </trans-unit>
        <trans-unit id="2e2446e404b6ead27ad20b61ec7f4e53599aafb6" translate="yes" xml:space="preserve">
          <source>We can write a function that creates components, like &lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt;, that subscribe to &lt;code&gt;DataSource&lt;/code&gt;. The function will accept as one of its arguments a child component that receives the subscribed data as a prop. Let&amp;rsquo;s call the function &lt;code&gt;withSubscription&lt;/code&gt;:</source>
          <target state="translated">Мы можем написать функцию, которая создает компоненты, такие как &lt;code&gt;CommentList&lt;/code&gt; и &lt;code&gt;BlogPost&lt;/code&gt; , которые подписываются на &lt;code&gt;DataSource&lt;/code&gt; . Функция примет в качестве одного из своих аргументов дочерний компонент, который получает подписанные данные в качестве опоры. &lt;code&gt;withSubscription&lt;/code&gt; функцию с подпиской :</target>
        </trans-unit>
        <trans-unit id="89ba067a3566a17960dd50516dca67227912a77a" translate="yes" xml:space="preserve">
          <source>We can write a test for this component:</source>
          <target state="translated">Мы можем написать тест для этого компонента:</target>
        </trans-unit>
        <trans-unit id="d8e41c4d141e5855cbde52500c24c257c93ac43e" translate="yes" xml:space="preserve">
          <source>We can write tests for it:</source>
          <target state="translated">Мы можем написать тесты для этого:</target>
        </trans-unit>
        <trans-unit id="fd9941e6ca2b2bcc146e2e3bddb7ece3c0bfd372" translate="yes" xml:space="preserve">
          <source>We can write tests for this component by leveraging &lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest&amp;rsquo;s timer mocks&lt;/a&gt;, and testing the different states it can be in.</source>
          <target state="translated">Мы можем писать тесты для этого компонента, используя &lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;фиктивные таймеры Jest&lt;/a&gt; и тестируя различные состояния, в которых он может находиться.</target>
        </trans-unit>
        <trans-unit id="1c7a8c823c57fed4ff580d4dbf33ecaf747d353f" translate="yes" xml:space="preserve">
          <source>We could have stored the value of both inputs but it turns out to be unnecessary. It is enough to store the value of the most recently changed input, and the scale that it represents. We can then infer the value of the other input based on the current &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; alone.</source>
          <target state="translated">Мы могли бы сохранить значение обоих входов, но в этом нет необходимости. Достаточно сохранить значение последнего измененного ввода и масштаб, который он представляет. Затем мы можем вывести значение другого входа только на основе текущей &lt;code&gt;temperature&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acfdbd4f44790b2811125b8ac3c5fb8fee686a44" translate="yes" xml:space="preserve">
          <source>We could introduce Suspense without mentioning the popular data fetching approaches. However, this makes it more difficult to see which problems Suspense solves, why these problems are worth solving, and how Suspense is different from the existing solutions.</source>
          <target state="translated">Мы могли бы ввести Suspense без упоминания популярных подходов к сбору данных.Однако это затрудняет понимание того,какие проблемы решает Suspense,почему эти проблемы стоят того,и чем Suspense отличается от существующих решений.</target>
        </trans-unit>
        <trans-unit id="585fc27656bad76f723c37445c9bb4da260c11b5" translate="yes" xml:space="preserve">
          <source>We could write tests for it:</source>
          <target state="translated">Мы могли бы написать тесты для этого:</target>
        </trans-unit>
        <trans-unit id="3e58e1cd19c11a614603dedfb8a316a8e141d81a" translate="yes" xml:space="preserve">
          <source>We create a &lt;a href=&quot;refs-and-the-dom&quot;&gt;React ref&lt;/a&gt; by calling &lt;code&gt;React.createRef&lt;/code&gt; and assign it to a &lt;code&gt;ref&lt;/code&gt; variable.</source>
          <target state="translated">Мы создаем &lt;a href=&quot;refs-and-the-dom&quot;&gt;React ref&lt;/a&gt; , вызывая &lt;code&gt;React.createRef&lt;/code&gt; и присваивая его переменной &lt;code&gt;ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="480f6cdda7556b73ac82824cc7b0bb1d95bbd4f0" translate="yes" xml:space="preserve">
          <source>We debated this decision, but in our experience it is worse to leave corrupted UI in place than to completely remove it. For example, in a product like Messenger leaving the broken UI visible could lead to somebody sending a message to the wrong person. Similarly, it is worse for a payments app to display a wrong amount than to render nothing.</source>
          <target state="translated">Мы обсуждали это решение,но,по нашему опыту,хуже оставить поврежденный пользовательский интерфейс на месте,чем полностью его удалить.Например,в таком продукте,как Messenger,оставление поврежденного пользовательского интерфейса видимым может привести к тому,что кто-то отправит сообщение не тому человеку.Аналогичным образом,для платежного приложения хуже отображать неправильную сумму,чем ничего не отображать.</target>
        </trans-unit>
        <trans-unit id="1781a89c81643968a25cd7b4d162af832e4f691e" translate="yes" xml:space="preserve">
          <source>We declare a state variable called &lt;code&gt;count&lt;/code&gt;, and set it to &lt;code&gt;0&lt;/code&gt;. React will remember its current value between re-renders, and provide the most recent one to our function. If we want to update the current &lt;code&gt;count&lt;/code&gt;, we can call &lt;code&gt;setCount&lt;/code&gt;.</source>
          <target state="translated">Мы объявляем переменную состояния с именем &lt;code&gt;count&lt;/code&gt; и устанавливаем ее в &lt;code&gt;0&lt;/code&gt; . React запомнит свое текущее значение между повторными отрисовками и предоставит нашей функции самое последнее значение. Если мы хотим обновить текущий &lt;code&gt;count&lt;/code&gt; , мы можем вызвать &lt;code&gt;setCount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1157d2f6d524a9bab78d01f0f931451f950ee13e" translate="yes" xml:space="preserve">
          <source>We declare the &lt;code&gt;count&lt;/code&gt; state variable, and then we tell React we need to use an effect. We pass a function to the &lt;code&gt;useEffect&lt;/code&gt; Hook. This function we pass &lt;em&gt;is&lt;/em&gt; our effect. Inside our effect, we set the document title using the &lt;code&gt;document.title&lt;/code&gt; browser API. We can read the latest &lt;code&gt;count&lt;/code&gt; inside the effect because it&amp;rsquo;s in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.</source>
          <target state="translated">Мы объявляем переменную состояния &lt;code&gt;count&lt;/code&gt; , а затем сообщаем React, что нам нужно использовать эффект. Мы передаем функцию &lt;code&gt;useEffect&lt;/code&gt; . Эта функция, которую мы передаем, и &lt;em&gt;есть&lt;/em&gt; наш эффект. Внутри нашего эффекта мы устанавливаем заголовок документа с помощью API браузера &lt;code&gt;document.title&lt;/code&gt; . Мы можем прочитать последний &lt;code&gt;count&lt;/code&gt; внутри эффекта, потому что он находится в области действия нашей функции. Когда React визуализирует наш компонент, он запоминает эффект, который мы использовали, а затем запускает наш эффект после обновления DOM. Это происходит для каждого рендера, включая первый.</target>
        </trans-unit>
        <trans-unit id="054642f59673a4f5210fd696dfb50dd0fc393abd" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t choose &lt;code&gt;useRef&lt;/code&gt; in this example because an object ref doesn&amp;rsquo;t notify us about &lt;em&gt;changes&lt;/em&gt; to the current ref value. Using a callback ref ensures that &lt;a href=&quot;https://codesandbox.io/s/818zzk8m78&quot;&gt;even if a child component displays the measured node later&lt;/a&gt; (e.g. in response to a click), we still get notified about it in the parent component and can update the measurements.</source>
          <target state="translated">Мы не выбрали &lt;code&gt;useRef&lt;/code&gt; в этом примере, потому что ссылка на объект не уведомляет нас об &lt;em&gt;изменениях&lt;/em&gt; текущего значения ссылки. Использование обратного вызова ref гарантирует, что &lt;a href=&quot;https://codesandbox.io/s/818zzk8m78&quot;&gt;даже если дочерний компонент отобразит измеренный узел позже&lt;/a&gt; (например, в ответ на щелчок), мы все равно получим уведомление об этом в родительском компоненте и сможем обновить измерения.</target>
        </trans-unit>
        <trans-unit id="0b9a31c8e7a657381cb91a3a3efbc87ae1284206" translate="yes" xml:space="preserve">
          <source>We do not recommend doing deep equality checks or using &lt;code&gt;JSON.stringify()&lt;/code&gt; in &lt;code&gt;shouldComponentUpdate()&lt;/code&gt;. It is very inefficient and will harm performance.</source>
          <target state="translated">Мы не рекомендуем выполнять глубокую проверку равенства или использовать &lt;code&gt;JSON.stringify()&lt;/code&gt; в &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; . Это очень неэффективно и ухудшит производительность.</target>
        </trans-unit>
        <trans-unit id="f8a90d5ff1e8d82817c939402d5e44da6170a7a2" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t have to return a named function from the effect. We called it &lt;code&gt;cleanup&lt;/code&gt; here to clarify its purpose, but you could return an arrow function or call it something different.</source>
          <target state="translated">Нам не нужно возвращать именованную функцию из эффекта. Мы назвали его здесь &lt;code&gt;cleanup&lt;/code&gt; чтобы прояснить его цель, но вы можете вернуть стрелочную функцию или назвать ее по-другому.</target>
        </trans-unit>
        <trans-unit id="d21059cf406cb5e8fbc1297f3553a843f44e80d3" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend adding debug values to every custom Hook. It&amp;rsquo;s most valuable for custom Hooks that are part of shared libraries.</source>
          <target state="translated">Мы не рекомендуем добавлять значения отладки к каждому пользовательскому хуку. Это наиболее ценно для пользовательских хуков, которые являются частью общих библиотек.</target>
        </trans-unit>
        <trans-unit id="c256b313bdb7417edd7396978a005028a790c640" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend using indexes for keys if the order of items may change. This can negatively impact performance and may cause issues with component state. Check out Robin Pokorny&amp;rsquo;s article for an &lt;a href=&quot;https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318&quot;&gt;in-depth explanation on the negative impacts of using an index as a key&lt;/a&gt;. If you choose not to assign an explicit key to list items then React will default to using indexes as keys.</source>
          <target state="translated">Мы не рекомендуем использовать индексы для ключей, если порядок элементов может измениться. Это может отрицательно сказаться на производительности и вызвать проблемы с состоянием компонентов. Ознакомьтесь со статьей Робина Покорного, чтобы получить &lt;a href=&quot;https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318&quot;&gt;подробное объяснение негативных последствий использования индекса в качестве ключа&lt;/a&gt; . Если вы решите не назначать явный ключ элементам списка, React по умолчанию будет использовать индексы в качестве ключей.</target>
        </trans-unit>
        <trans-unit id="f7a2c32757c53f98e7f15fd8320c8286a85f7b74" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t support older browsers that don&amp;rsquo;t support ES5 methods, but you may find that your apps do work in older browsers if polyfills such as &lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;es5-shim and es5-sham&lt;/a&gt; are included in the page. You&amp;rsquo;re on your own if you choose to take this path.</source>
          <target state="translated">Мы не поддерживаем старые браузеры, которые не поддерживают методы ES5, но вы можете обнаружить, что ваши приложения действительно работают в старых браузерах, если на странице включены полифиллы, такие как es5-shim &lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;и es5-sham&lt;/a&gt; . Если вы выберете этот путь, вы предоставлены сами себе.</target>
        </trans-unit>
        <trans-unit id="d7054c5c327eab83e8a538c07a37096fc9ba86ae" translate="yes" xml:space="preserve">
          <source>We expect to see a lot of experimentation in the community with other libraries. There is one important thing to note for data fetching library authors.</source>
          <target state="translated">Мы ожидаем увидеть много экспериментов в сообществе с другими библиотеками.Есть одна важная вещь,которую следует отметить авторам библиотек,собирающих данные.</target>
        </trans-unit>
        <trans-unit id="1811475d8d5e4bfca6bcc31a35dddff5ea826ba4" translate="yes" xml:space="preserve">
          <source>We finish fetching posts</source>
          <target state="translated">Мы заканчиваем забирать посты</target>
        </trans-unit>
        <trans-unit id="bd1d02bb8014d90531045031402948fe7570892b" translate="yes" xml:space="preserve">
          <source>We finish fetching user details</source>
          <target state="translated">Мы заканчиваем собирать информацию о пользователе</target>
        </trans-unit>
        <trans-unit id="abe12286a3512c8899854e56ae85e9c6930b655f" translate="yes" xml:space="preserve">
          <source>We forward this &lt;code&gt;ref&lt;/code&gt; argument down to &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; by specifying it as a JSX attribute.</source>
          <target state="translated">Мы перенаправляем этот аргумент &lt;code&gt;ref&lt;/code&gt; в &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; , определяя его как атрибут JSX.</target>
        </trans-unit>
        <trans-unit id="1c1b58e7b12eec27541e758845c7fe3cd4ed8a68" translate="yes" xml:space="preserve">
          <source>We gave this &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; a unique &lt;code&gt;id&lt;/code&gt; HTML attribute. This will allow us to find it from the JavaScript code later and display a React component inside of it.</source>
          <target state="translated">Мы присвоили этому &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; уникальный HTML-атрибут &lt;code&gt;id&lt;/code&gt; . Это позволит нам найти его в коде JavaScript позже и отобразить внутри него компонент React.</target>
        </trans-unit>
        <trans-unit id="c245c7bd223dde0a276aa2c9b895f7664846e5a6" translate="yes" xml:space="preserve">
          <source>We have a pretty good track record for keeping React releases free of bugs, but patch releases have an even higher bar for reliability because most developers assume they can be adopted without adverse consequences.</source>
          <target state="translated">У нас неплохой послужной список для того,чтобы держать React-релизы свободными от ошибок,но патч-релизы имеют еще более высокую планку надежности,потому что большинство разработчиков полагают,что их можно принять без негативных последствий.</target>
        </trans-unit>
        <trans-unit id="33f48ef96719930c7b83f5ac73cec67a078fa4ec" translate="yes" xml:space="preserve">
          <source>We have two inputs now, but when you enter the temperature in one of them, the other doesn&amp;rsquo;t update. This contradicts our requirement: we want to keep them in sync.</source>
          <target state="translated">Сейчас у нас есть два входа, но когда вы вводите температуру в один из них, другой не обновляется. Это противоречит нашему требованию: мы хотим синхронизировать их.</target>
        </trans-unit>
        <trans-unit id="24b615fc96a058b3af22def911e880fa3fa06a51" translate="yes" xml:space="preserve">
          <source>We include the entire &lt;code&gt;listItems&lt;/code&gt; array inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; element, and &lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;render it to the DOM&lt;/a&gt;:</source>
          <target state="translated">Мы включаем весь массив &lt;code&gt;listItems&lt;/code&gt; в элемент &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; и &lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;визуализируем его в DOM&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f264ce8ea8b9422cb05320c59c32289e8a41d8fa" translate="yes" xml:space="preserve">
          <source>We intend for Hooks to cover all existing use cases for classes, but &lt;strong&gt;we will keep supporting class components for the foreseeable future.&lt;/strong&gt; At Facebook, we have tens of thousands of components written as classes, and we have absolutely no plans to rewrite them. Instead, we are starting to use Hooks in the new code side by side with classes.</source>
          <target state="translated">Мы предполагаем, что хуки охватят все существующие варианты использования классов, но &lt;strong&gt;в обозримом будущем мы продолжим поддерживать компоненты класса. &lt;/strong&gt;В Facebook у нас есть десятки тысяч компонентов, написанных как классы, и у нас нет абсолютно никаких планов их переписывать. Вместо этого мы начинаем использовать хуки в новом коде бок о бок с классами.</target>
        </trans-unit>
        <trans-unit id="c713f1e114aac40ce80667421a2a28046e3cfa12" translate="yes" xml:space="preserve">
          <source>We keep the currently chosen friend ID in the &lt;code&gt;recipientID&lt;/code&gt; state variable, and update it if the user chooses a different friend in the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; picker.</source>
          <target state="translated">Мы сохраняем текущий выбранный идентификатор друга в переменной состояния &lt;code&gt;recipientID&lt;/code&gt; и обновляем его, если пользователь выбирает другого друга в &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bebd065febb63c4c26c6d9264a1ea50385c149ba" translate="yes" xml:space="preserve">
          <source>We know that &lt;a href=&quot;components-and-props#props-are-read-only&quot;&gt;props are read-only&lt;/a&gt;. When the &lt;code&gt;temperature&lt;/code&gt; was in the local state, the &lt;code&gt;TemperatureInput&lt;/code&gt; could just call &lt;code&gt;this.setState()&lt;/code&gt; to change it. However, now that the &lt;code&gt;temperature&lt;/code&gt; is coming from the parent as a prop, the &lt;code&gt;TemperatureInput&lt;/code&gt; has no control over it.</source>
          <target state="translated">Мы знаем, что &lt;a href=&quot;components-and-props#props-are-read-only&quot;&gt;реквизиты доступны только для чтения&lt;/a&gt; . Когда &lt;code&gt;temperature&lt;/code&gt; была в локальном состоянии, &lt;code&gt;TemperatureInput&lt;/code&gt; мог просто вызвать &lt;code&gt;this.setState()&lt;/code&gt; чтобы изменить ее. Однако теперь, когда &lt;code&gt;temperature&lt;/code&gt; исходит от родительского элемента в качестве свойства, &lt;code&gt;TemperatureInput&lt;/code&gt; не может ее контролировать.</target>
        </trans-unit>
        <trans-unit id="876790cf7c1befea3d21048ec699314173e464db" translate="yes" xml:space="preserve">
          <source>We know that React developers are focused on shipping products and don&amp;rsquo;t have time to look into every new API that&amp;rsquo;s being released. Hooks are very new, and it might be better to wait for more examples and tutorials before considering learning or adopting them.</source>
          <target state="translated">Мы знаем, что разработчики React сосредоточены на поставках продуктов и у них нет времени изучать каждый выпускаемый новый API. Хуки очень новы, и, возможно, лучше подождать больше примеров и руководств, прежде чем рассматривать или применять их.</target>
        </trans-unit>
        <trans-unit id="a3eff7a79862d5e529eb12353784eb51ca7e1aff" translate="yes" xml:space="preserve">
          <source>We moved the function inside the effect so it doesn&amp;rsquo;t need to be in its dependency list.</source>
          <target state="translated">Мы переместили функцию внутрь эффекта, поэтому она не должна быть в списке зависимостей.</target>
        </trans-unit>
        <trans-unit id="6d56e8fa2275dad4f8e035a0280660359a418e87" translate="yes" xml:space="preserve">
          <source>We offer production-ready versions of React and React DOM as single files:</source>
          <target state="translated">Мы предлагаем готовые к производству версии React и React DOM в виде отдельных файлов:</target>
        </trans-unit>
        <trans-unit id="173d3966a33df8916b07b6198d8a3107fe3fdd80" translate="yes" xml:space="preserve">
          <source>We pass our &lt;code&gt;ref&lt;/code&gt; down to &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; by specifying it as a JSX attribute.</source>
          <target state="translated">Мы проходим наш &lt;code&gt;ref&lt;/code&gt; до &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; , указав его в качестве атрибута JSX.</target>
        </trans-unit>
        <trans-unit id="0fd48e29a186685285cacd537ec278624c56cfec" translate="yes" xml:space="preserve">
          <source>We previously recommended mixins as a way to handle cross-cutting concerns. We&amp;rsquo;ve since realized that mixins create more trouble than they are worth. &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;Read more&lt;/a&gt; about why we&amp;rsquo;ve moved away from mixins and how you can transition your existing components.</source>
          <target state="translated">Ранее мы рекомендовали миксины как способ решения сквозных проблем. С тех пор мы поняли, что миксины создают больше проблем, чем они того стоят. &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;Узнайте больше&lt;/a&gt; о том, почему мы отошли от миксинов и как вы можете перенести существующие компоненты.</target>
        </trans-unit>
        <trans-unit id="b732ce77a4e21236193d4ed1a3cfdc1759dbca1e" translate="yes" xml:space="preserve">
          <source>We provide &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-react.proptypes&quot;&gt;a codemod script&lt;/a&gt; to automate the conversion.</source>
          <target state="translated">Мы предоставляем &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-react.proptypes&quot;&gt;скрипт codemod&lt;/a&gt; для автоматизации преобразования.</target>
        </trans-unit>
        <trans-unit id="7f537600ac475b0e28fd9838f0994971eb587cef" translate="yes" xml:space="preserve">
          <source>We provide &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes&quot;&gt;a codemod script&lt;/a&gt; to automate the conversion.</source>
          <target state="translated">Мы предоставляем &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes&quot;&gt;скрипт codemod&lt;/a&gt; для автоматизации преобразования.</target>
        </trans-unit>
        <trans-unit id="2369cb3e294a76670599da056d0a5f3e1999ae3a" translate="yes" xml:space="preserve">
          <source>We provide a &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter plugin&lt;/a&gt; to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.</source>
          <target state="translated">Мы предоставляем &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;подключаемый модуль линтера&lt;/a&gt; для автоматического применения этих правил. Мы понимаем, что эти правила могут сначала показаться ограничивающими или запутанными, но они необходимы для правильной работы хуков.</target>
        </trans-unit>
        <trans-unit id="0938ce335cf46095dc66994cff21751a2cbd8d1a" translate="yes" xml:space="preserve">
          <source>We provide an &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; ESLint rule as a part of the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It warns when dependencies are specified incorrectly and suggests a fix.</source>
          <target state="translated">Мы предоставляем &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt; &lt;code&gt;exhaustive-deps&lt;/code&gt; &lt;/a&gt; правило ESLint как часть пакета &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt; . Он предупреждает, когда зависимости указаны неправильно, и предлагает исправление.</target>
        </trans-unit>
        <trans-unit id="ab72bfddf6528413d326567c0887f4498b85d602" translate="yes" xml:space="preserve">
          <source>We provide an &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;ESLint plugin&lt;/a&gt; that enforces &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; to avoid bugs. It assumes that any function starting with &amp;rdquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo; and a capital letter right after it is a Hook. We recognize this heuristic isn&amp;rsquo;t perfect and there may be some false positives, but without an ecosystem-wide convention there is just no way to make Hooks work well &amp;mdash; and longer names will discourage people from either adopting Hooks or following the convention.</source>
          <target state="translated">Мы предоставляем &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;плагин ESLint,&lt;/a&gt; который применяет &lt;a href=&quot;hooks-rules&quot;&gt;правила хуков,&lt;/a&gt; чтобы избежать ошибок. Предполагается, что любая функция, начинающаяся с &amp;laquo; &lt;code&gt;use&lt;/code&gt; &amp;raquo; и заглавной буквы сразу после нее, является хуком. Мы признаем, что эта эвристика несовершенна и могут быть некоторые ложные срабатывания, но без соглашения в масштабах всей экосистемы просто невозможно заставить хуки работать хорошо - а более длинные имена будут отбивать у людей желание либо принять хуки, либо следовать соглашению.</target>
        </trans-unit>
        <trans-unit id="e678ec6a3cf91996c6dfc88cfd13ce2bedcc8a3b" translate="yes" xml:space="preserve">
          <source>We provide more recommendations on splitting independent state variables &lt;a href=&quot;hooks-faq#should-i-use-one-or-many-state-variables&quot;&gt;in the FAQ&lt;/a&gt;.</source>
          <target state="translated">Мы предоставляем больше рекомендаций по разделению независимых переменных состояния &lt;a href=&quot;hooks-faq#should-i-use-one-or-many-state-variables&quot;&gt;в FAQ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54061fe31bd1eb76ce19d28df0f5e134c8d482c7" translate="yes" xml:space="preserve">
          <source>We provide the &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; ESLint rule as a part of the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It helps you find components that don&amp;rsquo;t handle updates consistently.</source>
          <target state="translated">Мы предоставляем правило Exustive &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt; &lt;code&gt;exhaustive-deps&lt;/code&gt; &lt;/a&gt; ESLint как часть пакета &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt; . Это поможет вам найти компоненты, которые не обрабатывают обновления постоянно.</target>
        </trans-unit>
        <trans-unit id="89b928f0f765e5ca5c0cf26a707c679396e87061" translate="yes" xml:space="preserve">
          <source>We recommend &lt;a href=&quot;introducing-jsx&quot;&gt;using JSX&lt;/a&gt; to describe what your UI should look like. Each JSX element is just syntactic sugar for calling &lt;a href=&quot;#createelement&quot;&gt;&lt;code&gt;React.createElement()&lt;/code&gt;&lt;/a&gt;. You will not typically invoke the following methods directly if you are using JSX.</source>
          <target state="translated">Мы рекомендуем &lt;a href=&quot;introducing-jsx&quot;&gt;использовать JSX,&lt;/a&gt; чтобы описать, как должен выглядеть ваш пользовательский интерфейс. Каждый элемент JSX - это просто синтаксический сахар для вызова &lt;a href=&quot;#createelement&quot;&gt; &lt;code&gt;React.createElement()&lt;/code&gt; &lt;/a&gt; . Обычно вы не будете напрямую вызывать следующие методы, если используете JSX.</target>
        </trans-unit>
        <trans-unit id="0cc25672e0f55ea9b98f9dd9e96289f1e47e413c" translate="yes" xml:space="preserve">
          <source>We recommend dispatching real DOM events on DOM elements, and then asserting on the result. Consider a &lt;code&gt;Toggle&lt;/code&gt; component:</source>
          <target state="translated">Мы рекомендуем отправлять реальные события DOM на элементы DOM, а затем утверждать результат. Рассмотрим компонент &lt;code&gt;Toggle&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36b1daa5d9b179778ea122685bd4a019f602d46b" translate="yes" xml:space="preserve">
          <source>We recommend going through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;this JavaScript overview&lt;/a&gt; to check your knowledge level. It will take you between 30 minutes and an hour but you will feel more confident learning React.</source>
          <target state="translated">Мы рекомендуем просмотреть &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;этот обзор JavaScript,&lt;/a&gt; чтобы проверить свой уровень знаний. Это займет у вас от 30 минут до часа, но вы будете чувствовать себя более уверенно, изучая React.</target>
        </trans-unit>
        <trans-unit id="1c51aa488fbf01c0bfe43f52e75c750fe6169a43" translate="yes" xml:space="preserve">
          <source>We recommend naming components with a capital letter. If you do have a component that starts with a lowercase letter, assign it to a capitalized variable before using it in JSX.</source>
          <target state="translated">Мы рекомендуем называть компоненты заглавной буквой.Если у вас есть компонент,начинающийся с строчной буквы,присвойте его заглавной переменной перед использованием в JSX.</target>
        </trans-unit>
        <trans-unit id="7db5b6288d689438ea763cca5989dd7db15ed6d2" translate="yes" xml:space="preserve">
          <source>We recommend naming props from the component&amp;rsquo;s own point of view rather than the context in which it is being used.</source>
          <target state="translated">Мы рекомендуем называть реквизиты с точки зрения самого компонента, а не с учетом контекста, в котором он используется.</target>
        </trans-unit>
        <trans-unit id="4e15764df958d424fa327a0c196872978d94f795" translate="yes" xml:space="preserve">
          <source>We recommend that such components use the special &lt;code&gt;children&lt;/code&gt; prop to pass children elements directly into their output:</source>
          <target state="translated">Мы рекомендуем , чтобы такие компоненты используют специальные &lt;code&gt;children&lt;/code&gt; проп передать дочерние элементы непосредственно в их продукции:</target>
        </trans-unit>
        <trans-unit id="c066bd0b31ba19b1ea60f7d180f0c929fb5bfc2b" translate="yes" xml:space="preserve">
          <source>We recommend that you don&amp;rsquo;t skip topics because they build on each other.</source>
          <target state="translated">Мы рекомендуем вам не пропускать темы, потому что они дополняют друг друга.</target>
        </trans-unit>
        <trans-unit id="7378b8164ba09b0803d591f679c436a1534386de" translate="yes" xml:space="preserve">
          <source>We recommend to &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;pass &lt;code&gt;dispatch&lt;/code&gt; down in context&lt;/a&gt; rather than individual callbacks in props. The approach below is only mentioned here for completeness and as an escape hatch.</source>
          <target state="translated">Мы рекомендуем &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;передавать &lt;code&gt;dispatch&lt;/code&gt; в контексте,&lt;/a&gt; а не отдельные обратные вызовы в props. Приведенный ниже подход упоминается здесь только для полноты картины и как аварийный выход.</target>
        </trans-unit>
        <trans-unit id="38df0f4397ee97f12fb96f12d239661a17367c93" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; which is designed to enable and encourage writing tests that use your components as the end users do.</source>
          <target state="translated">Мы рекомендуем использовать &lt;a href=&quot;https://testing-library.com/react&quot;&gt;библиотеку тестирования React,&lt;/a&gt; которая предназначена для включения и поощрения написания тестов, использующих ваши компоненты, как это делают конечные пользователи.</target>
        </trans-unit>
        <trans-unit id="4c6b613a8456e9f6cb8c62aa576baeb43c5ccbbd" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://babeljs.io/docs/editors&quot;&gt;&amp;ldquo;Babel&amp;rdquo; language definition&lt;/a&gt; for your editor of choice so that both ES6 and JSX code is properly highlighted.</source>
          <target state="translated">Мы рекомендуем использовать &lt;a href=&quot;https://babeljs.io/docs/editors&quot;&gt;определение языка &amp;laquo;Babel&amp;raquo;&lt;/a&gt; для выбранного вами редактора, чтобы код ES6 и JSX был правильно выделен.</target>
        </trans-unit>
        <trans-unit id="87a9dda197e65da63033ba548fda02343c3b83df" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://babeljs.io/docs/en/next/editors&quot;&gt;&amp;ldquo;Babel&amp;rdquo; language definition&lt;/a&gt; for your editor of choice so that both ES6 and JSX code is properly highlighted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f79aded3b19e2f5ffe654e038c348525259095" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; rule as part of our &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It warns when dependencies are specified incorrectly and suggests a fix.</source>
          <target state="translated">Мы рекомендуем использовать правило &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt; &lt;code&gt;exhaustive-deps&lt;/code&gt; &lt;/a&gt; как часть нашего &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt; . Он предупреждает, когда зависимости указаны неправильно, и предлагает исправление.</target>
        </trans-unit>
        <trans-unit id="ea209ebd83cc25229df26adf48f3d2ced0664327" translate="yes" xml:space="preserve">
          <source>We released an ESLint plugin called &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; that enforces these two rules. You can add this plugin to your project if you&amp;rsquo;d like to try it:</source>
          <target state="translated">Мы выпустили плагин ESLint под названием &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; ,&lt;/a&gt; который обеспечивает соблюдение этих двух правил. Вы можете добавить этот плагин в свой проект, если хотите его попробовать:</target>
        </trans-unit>
        <trans-unit id="5b062bd2fdca7e9e1ab4dd5cb060c69707aef4fe" translate="yes" xml:space="preserve">
          <source>We split JSX over multiple lines for readability. While it isn&amp;rsquo;t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of &lt;a href=&quot;https://stackoverflow.com/q/2846283&quot;&gt;automatic semicolon insertion&lt;/a&gt;.</source>
          <target state="translated">Мы разбиваем JSX на несколько строк для удобства чтения. Хотя это не обязательно, при этом мы также рекомендуем заключить его в круглые скобки, чтобы избежать ошибок &lt;a href=&quot;https://stackoverflow.com/q/2846283&quot;&gt;автоматической вставки точки с запятой&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2979eccc260e51754eafcade66e564e9baada836" translate="yes" xml:space="preserve">
          <source>We start fetching posts</source>
          <target state="translated">Мы начинаем забирать посты</target>
        </trans-unit>
        <trans-unit id="ca6bb754623f873e0a4dcdef4ad2532d3958b1fc" translate="yes" xml:space="preserve">
          <source>We start fetching user details</source>
          <target state="translated">Мы начинаем получать информацию о пользователях</target>
        </trans-unit>
        <trans-unit id="04adad35ca195632fb236b9657e9704ced9d2d7c" translate="yes" xml:space="preserve">
          <source>We think it is better to offer a &lt;a href=&quot;faq-versioning#commitment-to-stability&quot;&gt;gradual migration strategy&lt;/a&gt; than to make huge breaking changes &amp;mdash; or to let React stagnate into irrelevance.</source>
          <target state="translated">Мы считаем, что лучше предложить &lt;a href=&quot;faq-versioning#commitment-to-stability&quot;&gt;стратегию постепенной миграции,&lt;/a&gt; чем вносить огромные критические изменения - или позволить React потерять актуальность.</target>
        </trans-unit>
        <trans-unit id="9950cb366a5eeff7d38fd73f4a0d3de60ab1d902" translate="yes" xml:space="preserve">
          <source>We used an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt; above, but it also works with regular functions:</source>
          <target state="translated">Мы использовали &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;стрелочную функцию&lt;/a&gt; выше, но она также работает с обычными функциями:</target>
        </trans-unit>
        <trans-unit id="7d06765809acf74687f0fa91ffe1041b5eaa0934" translate="yes" xml:space="preserve">
          <source>We wait&amp;hellip;</source>
          <target state="translated">Ждем&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="883db07b441bd1cc42aaa22c4d8c5fa1d14f3d84" translate="yes" xml:space="preserve">
          <source>We want to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;set up a timer&lt;/a&gt; whenever the &lt;code&gt;Clock&lt;/code&gt; is rendered to the DOM for the first time. This is called &amp;ldquo;mounting&amp;rdquo; in React.</source>
          <target state="translated">Мы хотим &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;установить таймер&lt;/a&gt; всякий раз, когда &lt;code&gt;Clock&lt;/code&gt; впервые отображается в DOM. В React это называется &amp;laquo;монтированием&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e60a58cd26da36dc6344202c0599d60697f33fbb" translate="yes" xml:space="preserve">
          <source>We will attach a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; to the root DOM element. Inside &lt;code&gt;componentDidMount&lt;/code&gt;, we will get a reference to it so we can pass it to the jQuery plugin.</source>
          <target state="translated">Мы прикрепим &lt;a href=&quot;refs-and-the-dom&quot;&gt;ссылку&lt;/a&gt; к корневому элементу DOM. Внутри &lt;code&gt;componentDidMount&lt;/code&gt; мы получим ссылку на него, чтобы передать ее в плагин jQuery.</target>
        </trans-unit>
        <trans-unit id="e74b07ae6f3f43fb223a13322a5557fa91ee2240" translate="yes" xml:space="preserve">
          <source>We will explain these steps below in detail.</source>
          <target state="translated">Мы подробно объясним эти шаги ниже.</target>
        </trans-unit>
        <trans-unit id="44e2af1182c660aac62472f00fe7cd374c0bec16" translate="yes" xml:space="preserve">
          <source>We will explore rendering React elements to the DOM in the &lt;a href=&quot;rendering-elements&quot;&gt;next section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727da5b71551ddb95c401e73e8e543adf070a83e" translate="yes" xml:space="preserve">
          <source>We will explore rendering React elements to the DOM in the next section.</source>
          <target state="translated">Мы рассмотрим рендеринг React элементов на DOM в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="971788bde50fd928ed6ba8e3bf2b7bb52780ffe5" translate="yes" xml:space="preserve">
          <source>We will implement it as an &lt;a href=&quot;uncontrolled-components&quot;&gt;uncontrolled component&lt;/a&gt; for simplicity.</source>
          <target state="translated">Мы будем реализовывать его как &lt;a href=&quot;uncontrolled-components&quot;&gt;неуправляемый компонент&lt;/a&gt; для простоты.</target>
        </trans-unit>
        <trans-unit id="1a236deb13b0671afe90e0152c0f4b89aa0714eb" translate="yes" xml:space="preserve">
          <source>We will later add the timer code back to the component itself.</source>
          <target state="translated">Позже мы добавим код таймера обратно в сам компонент.</target>
        </trans-unit>
        <trans-unit id="b0a6b047e5052fd0d39b2c6745d932b87cc1c444" translate="yes" xml:space="preserve">
          <source>We will move the &lt;code&gt;date&lt;/code&gt; from props to state in three steps:</source>
          <target state="translated">Мы переместим &lt;code&gt;date&lt;/code&gt; из реквизита в состояние в три этапа:</target>
        </trans-unit>
        <trans-unit id="c76792b9c2d19f72980bcb3b0acff6bb2647f253" translate="yes" xml:space="preserve">
          <source>We will now add a brand new feature to the profile page &amp;mdash; a list of fun facts about a person:</source>
          <target state="translated">Теперь мы добавим новую функцию на страницу профиля - список забавных фактов о человеке:</target>
        </trans-unit>
        <trans-unit id="0dbb37dfdc07e84f9e43a35660e37fc112399531" translate="yes" xml:space="preserve">
          <source>We will post to the &lt;a href=&quot;https://reactjs.org/blog&quot;&gt;React blog&lt;/a&gt; when we&amp;rsquo;re ready to announce new experiments, but that doesn&amp;rsquo;t mean we will publicize every experiment.</source>
          <target state="translated">Мы опубликуем сообщение в &lt;a href=&quot;https://reactjs.org/blog&quot;&gt;блоге React,&lt;/a&gt; когда будем готовы объявить о новых экспериментах, но это не значит, что мы будем публиковать каждый эксперимент.</target>
        </trans-unit>
        <trans-unit id="2a8482ef7156081f1581eefc773bc336f6981bd6" translate="yes" xml:space="preserve">
          <source>We will start with a component called &lt;code&gt;BoilingVerdict&lt;/code&gt;. It accepts the &lt;code&gt;celsius&lt;/code&gt; temperature as a prop, and prints whether it is enough to boil the water:</source>
          <target state="translated">Мы начнем с компонента под названием &lt;code&gt;BoilingVerdict&lt;/code&gt; . Он принимает температуру по &lt;code&gt;celsius&lt;/code&gt; как опору и печатает, достаточно ли ее вскипятить:</target>
        </trans-unit>
        <trans-unit id="dadee525eff6a00a825d77ee71e7e982946df9ab" translate="yes" xml:space="preserve">
          <source>We will store the current input&amp;rsquo;s &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; in its local state. This is the state we &amp;ldquo;lifted up&amp;rdquo; from the inputs, and it will serve as the &amp;ldquo;source of truth&amp;rdquo; for both of them. It is the minimal representation of all the data we need to know in order to render both inputs.</source>
          <target state="translated">Мы сохраним текущую &lt;code&gt;temperature&lt;/code&gt; входа и &lt;code&gt;scale&lt;/code&gt; в его локальном состоянии. Это состояние, которое мы &amp;laquo;подняли&amp;raquo; из входов, и оно будет служить &amp;laquo;источником истины&amp;raquo; для них обоих. Это минимальное представление всех данных, которые нам нужно знать, чтобы отобразить оба ввода.</target>
        </trans-unit>
        <trans-unit id="d01910e116749e98643c489148eb7de5ffdd9fe0" translate="yes" xml:space="preserve">
          <source>We will tear down the timer in the &lt;code&gt;componentWillUnmount()&lt;/code&gt; lifecycle method:</source>
          <target state="translated">Мы снесем таймер в методе жизненного цикла &lt;code&gt;componentWillUnmount()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e654907385791ce9020004666c8f0606387ea52d" translate="yes" xml:space="preserve">
          <source>We will use them right below.</source>
          <target state="translated">Мы используем их прямо внизу.</target>
        </trans-unit>
        <trans-unit id="8554f0c6b7512278a4491bcbd1d0b8d3364d7dec" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t pass &lt;code&gt;this.props.onChange&lt;/code&gt; directly to Chosen because component&amp;rsquo;s props might change over time, and that includes event handlers. Instead, we will declare a &lt;code&gt;handleChange()&lt;/code&gt; method that calls &lt;code&gt;this.props.onChange&lt;/code&gt;, and subscribe it to the jQuery &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="translated">Мы не будем передавать &lt;code&gt;this.props.onChange&lt;/code&gt; напрямую в Chosen, потому что свойства компонента могут изменяться со временем, в том числе обработчики событий. Вместо этого мы объявим метод &lt;code&gt;handleChange()&lt;/code&gt; который вызывает &lt;code&gt;this.props.onChange&lt;/code&gt; , и подпишем его на событие &lt;code&gt;change&lt;/code&gt; jQuery :</target>
        </trans-unit>
        <trans-unit id="1dca911b430b3370f62cdffc47de7a06fdd5c7b6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll address this in two steps:</source>
          <target state="translated">Мы рассмотрим это в два этапа:</target>
        </trans-unit>
        <trans-unit id="e57f940373fd0c5266442a10be93fdb7e4add9cd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue this page with an in-depth look at some aspects of &lt;code&gt;useEffect&lt;/code&gt; that experienced React users will likely be curious about. Don&amp;rsquo;t feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.</source>
          <target state="translated">Мы продолжим эту страницу, подробно рассмотрев некоторые аспекты &lt;code&gt;useEffect&lt;/code&gt; , которые, вероятно, заинтересуют опытных пользователей React. Не считайте себя обязанным копаться в них сейчас. Вы всегда можете вернуться на эту страницу, чтобы узнать больше о ловушке эффектов.</target>
        </trans-unit>
        <trans-unit id="06cbd6e1d166c852966f9e06d4a20311c24f2202" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a &lt;code&gt;Greeting&lt;/code&gt; component that displays either of these components depending on whether a user is logged in:</source>
          <target state="translated">Мы создадим компонент &lt;code&gt;Greeting&lt;/code&gt; который отображает любой из этих компонентов в зависимости от того, вошел ли пользователь в систему:</target>
        </trans-unit>
        <trans-unit id="949801e315854c5c1f32189a838ce3882724d1cc" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss this more in &lt;a href=&quot;hooks-custom&quot;&gt;Building Your Own Hooks&lt;/a&gt;.</source>
          <target state="translated">Мы обсудим это подробнее в &lt;a href=&quot;hooks-custom&quot;&gt;разделе Создание собственных крючков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="480d6951f304afe90e50d8db2ae84d223b006104" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss this more in &lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;Using the Effect Hook&lt;/a&gt;.</source>
          <target state="translated">Мы обсудим это подробнее в &lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;разделе &amp;laquo;Использование обработчика эффектов&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="127966720e15953e98cccc3796d46bce910c94fb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start learning about Hooks by comparing this code to an equivalent class example.</source>
          <target state="translated">Мы начнем изучать хуки, сравнив этот код с примером эквивалентного класса.</target>
        </trans-unit>
        <trans-unit id="2e722f3732f23870f1c4ff8fe747d22265714de2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test it using React DOM. To make sure that the behavior matches what happens in the browser, we&amp;rsquo;ll wrap the code rendering and updating it into &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;ReactTestUtils.act()&lt;/code&gt;&lt;/a&gt; calls:</source>
          <target state="translated">Мы протестируем это с помощью React DOM. Чтобы убедиться, что поведение соответствует тому, что происходит в браузере, мы &lt;a href=&quot;test-utils#act&quot;&gt; &lt;code&gt;ReactTestUtils.act()&lt;/code&gt; &lt;/a&gt; рендеринг кода и обновим его вызовами ReactTestUtils.act () :</target>
        </trans-unit>
        <trans-unit id="a76fcdcb61157f6e0610c1005c5c3f29ebd7936e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll wrap that state update into &lt;code&gt;startTransition&lt;/code&gt;. That&amp;rsquo;s how we tell React &lt;strong&gt;we don&amp;rsquo;t mind React delaying that state update&lt;/strong&gt; if it leads to an undesirable loading state:</source>
          <target state="translated">Мы &lt;code&gt;startTransition&lt;/code&gt; это обновление состояния в startTransition . Вот как мы сообщаем React, &lt;strong&gt;что не против того, чтобы React отложил обновление этого состояния,&lt;/strong&gt; если оно приводит к нежелательному состоянию загрузки:</target>
        </trans-unit>
        <trans-unit id="cb815fabe0b5ab52d41ee9b7ea186de1f4f0109c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re &lt;strong&gt;using npm here only to install the JSX preprocessor;&lt;/strong&gt; you won&amp;rsquo;t need it for anything else. Both React and the application code can stay as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags with no changes.</source>
          <target state="translated">Здесь мы &lt;strong&gt;используем npm только для установки препроцессора JSX; &lt;/strong&gt;больше ни для чего он вам не понадобится. И React, и код приложения могут оставаться тегами &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; без изменений.</target>
        </trans-unit>
        <trans-unit id="5b0310a310cf06f594a40e03c38a430ad9503681" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re Still Figuring This Out</source>
          <target state="translated">Мы все еще выясняем это</target>
        </trans-unit>
        <trans-unit id="ed67ce78b0f3e99b0d082bb50f326185eb0b81b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also starting to see how Hooks solve problems outlined in &lt;a href=&quot;hooks-intro#motivation&quot;&gt;Motivation&lt;/a&gt;. We&amp;rsquo;ve seen how effect cleanup avoids duplication in &lt;code&gt;componentDidUpdate&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;, brings related code closer together, and helps us avoid bugs. We&amp;rsquo;ve also seen how we can separate effects by their purpose, which is something we couldn&amp;rsquo;t do in classes at all.</source>
          <target state="translated">Мы также начинаем видеть, как хуки решают проблемы, описанные в разделе &amp;laquo; &lt;a href=&quot;hooks-intro#motivation&quot;&gt;Мотивация&amp;raquo;&lt;/a&gt; . Мы видели, как очистка эффекта позволяет избежать дублирования в &lt;code&gt;componentDidUpdate&lt;/code&gt; и &lt;code&gt;componentWillUnmount&lt;/code&gt; , сближает связанный код и помогает избежать ошибок. Мы также увидели, как можно разделить эффекты по их назначению, чего мы вообще не могли делать в классах.</target>
        </trans-unit>
        <trans-unit id="6da9903b5d3ba7eb4397ce158c0f6108377a0f35" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using &lt;code&gt;isPending&lt;/code&gt; to communicate the state transition progress to the user and to disable the button.</source>
          <target state="translated">Мы используем &lt;code&gt;isPending&lt;/code&gt; , чтобы сообщить пользователю о ходе перехода между состояниями и отключить кнопку.</target>
        </trans-unit>
        <trans-unit id="6735373f84ab2dadb0420bcc149f487be0787431" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using this code in production (and it works for us) but there are still some bugs, missing features, and gaps in the documentation. We&amp;rsquo;d like to hear more about what breaks in Concurrent Mode so we can better prepare it for an official stable release in the future.</source>
          <target state="translated">Мы используем этот код в производстве (и он работает для нас), но в документации все еще есть некоторые ошибки, отсутствующие функции и пробелы. Мы хотели бы узнать больше о том, что ломается в параллельном режиме, чтобы мы могли лучше подготовить его к официальному стабильному выпуску в будущем.</target>
        </trans-unit>
        <trans-unit id="1092279dfe88e8ae37dd255b457e80f4fcd016f8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already kicked off the requests in &lt;code&gt;fetchProfileData()&lt;/code&gt;. It gave us a special &amp;ldquo;resource&amp;rdquo; instead of a Promise. In a realistic example, it would be provided by our data library&amp;rsquo;s Suspense integration, like Relay.</source>
          <target state="translated">Мы уже начали запросы в &lt;code&gt;fetchProfileData()&lt;/code&gt; . Это дало нам особый &amp;laquo;ресурс&amp;raquo; вместо обещания. В реалистичном примере это может обеспечить интеграция Suspense нашей библиотеки данных, например Relay.</target>
        </trans-unit>
        <trans-unit id="d3fc6ac18f17043ca4acd94bf8d17f2db51154a1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen this example at the top of this page, but let&amp;rsquo;s take a closer look at it:</source>
          <target state="translated">Мы уже видели этот пример вверху этой страницы, но давайте посмотрим на него поближе:</target>
        </trans-unit>
        <trans-unit id="e057c5796230f4d10c4ca87533025e33e8d57483" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already used &lt;code&gt;startTransition&lt;/code&gt; to wrap the state update. Now we&amp;rsquo;re going to use &lt;code&gt;isPending&lt;/code&gt; too. React gives this boolean to us so we can tell whether &lt;strong&gt;we&amp;rsquo;re currently waiting for this transition to finish&lt;/strong&gt;. We&amp;rsquo;ll use it to indicate that something is happening:</source>
          <target state="translated">Мы уже использовали &lt;code&gt;startTransition&lt;/code&gt; для обертывания обновления состояния. Теперь мы тоже будем использовать &lt;code&gt;isPending&lt;/code&gt; . React дает нам это логическое значение, чтобы мы могли сказать, &lt;strong&gt;ожидаем&lt;/strong&gt; ли &lt;strong&gt;мы в данный момент завершения этого перехода&lt;/strong&gt; . Мы будем использовать его, чтобы указать, что что-то происходит:</target>
        </trans-unit>
        <trans-unit id="9aced3aa1f133d3833efd40f37731bb88c66df03" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve fixed the first problem (suspending outside of a transition). But now because of the transition, our state doesn&amp;rsquo;t update immediately, and it can&amp;rsquo;t &amp;ldquo;drive&amp;rdquo; a controlled input!</source>
          <target state="translated">Мы устранили первую проблему (приостановка вне перехода). Но теперь из-за перехода наше состояние не обновляется сразу и не может &amp;laquo;управлять&amp;raquo; управляемым вводом!</target>
        </trans-unit>
        <trans-unit id="82123073614b7e2a1707ace493cbc03906ee8fa4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve found that most people don&amp;rsquo;t enjoy manually passing callbacks through every level of a component tree. Even though it is more explicit, it can feel like a lot of &amp;ldquo;plumbing&amp;rdquo;.</source>
          <target state="translated">Мы обнаружили, что большинству людей не нравится вручную передавать обратные вызовы на всех уровнях дерева компонентов. Несмотря на то, что он более явный, это может показаться большим количеством &amp;laquo;сантехники&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="51b337075185a61e05c782a8165f31c63d15e390" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve imported the &lt;code&gt;useTransition&lt;/code&gt; Hook and used it in the component that updates the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a8f1d5554de07fa29800d8a4ff750db37e3153" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve imported the &lt;code&gt;useTransition&lt;/code&gt; Hook and used it the component that updates the state.</source>
          <target state="translated">Мы импортировали &lt;code&gt;useTransition&lt;/code&gt; и использовали его как компонент, обновляющий состояние.</target>
        </trans-unit>
        <trans-unit id="f001cf0b3f4cc8ba635fdca602bd1a42ea0135b3" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve learned that &lt;code&gt;useEffect&lt;/code&gt; lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:</source>
          <target state="translated">Мы узнали, что &lt;code&gt;useEffect&lt;/code&gt; позволяет нам выражать различные побочные эффекты после рендеринга компонента. Некоторые эффекты могут потребовать очистки, чтобы они возвращали функцию:</target>
        </trans-unit>
        <trans-unit id="78fbd837f605a563c276531668570643feff866d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered the basics of Suspense for Data Fetching! Importantly, we now better understand &lt;em&gt;why&lt;/em&gt; Suspense works this way, and how it fits into the data fetching space.</source>
          <target state="translated">Мы рассмотрели основы задержки при получении данных! Важно отметить, что теперь мы лучше понимаем, &lt;em&gt;почему&lt;/em&gt; задержка работает таким образом и как она вписывается в пространство выборки данных.</target>
        </trans-unit>
        <trans-unit id="b9d77fbf8650ce9fdf27f7587fe7efc208425285" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve often had to maintain components that started out simple but grew into an unmanageable mess of stateful logic and side effects. Each lifecycle method often contains a mix of unrelated logic. For example, components might perform some data fetching in &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. However, the same &lt;code&gt;componentDidMount&lt;/code&gt; method might also contain some unrelated logic that sets up event listeners, with cleanup performed in &lt;code&gt;componentWillUnmount&lt;/code&gt;. Mutually related code that changes together gets split apart, but completely unrelated code ends up combined in a single method. This makes it too easy to introduce bugs and inconsistencies.</source>
          <target state="translated">Нам часто приходилось поддерживать компоненты, которые изначально были простыми, но превратились в неуправляемый беспорядок логики с отслеживанием состояния и побочных эффектов. Каждый метод жизненного цикла часто содержит сочетание несвязанной логики. Например, компоненты могут выполнять выборку данных в &lt;code&gt;componentDidMount&lt;/code&gt; и &lt;code&gt;componentDidUpdate&lt;/code&gt; . Однако тот же метод &lt;code&gt;componentDidMount&lt;/code&gt; может также содержать некоторую несвязанную логику, которая устанавливает прослушиватели событий с очисткой, выполняемой в &lt;code&gt;componentWillUnmount&lt;/code&gt; . Взаимосвязанный код, который изменяется вместе, разделяется на части, но совершенно несвязанный код в конечном итоге объединяется в один метод. Это слишком упрощает внесение ошибок и несоответствий.</target>
        </trans-unit>
        <trans-unit id="37efc1571cdaa97dd3e90e2682390ebf13fff680" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve passed &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; to stay on the previous screen for at most 3 seconds.</source>
          <target state="translated">Мы прошли &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; чтобы оставаться на предыдущем экране не более 3 секунд.</target>
        </trans-unit>
        <trans-unit id="f3cab8c9ea1114a4c30f14c35d44b604fb9099d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve prepared a &lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ page&lt;/a&gt; that answers the most common questions about Hooks.</source>
          <target state="translated">Мы подготовили &lt;a href=&quot;hooks-faq&quot;&gt;страницу&lt;/a&gt; часто задаваемых вопросов по хукам, которая отвечает на самые распространенные вопросы о хуках.</target>
        </trans-unit>
        <trans-unit id="602a0253fdc011ba6ec4f21c8ecf132af5c3bcd0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve said before that Concurrent Mode is like React working &amp;ldquo;on a branch&amp;rdquo;. Branches are useful not only for short-term fixes, but also for long-running features. Sometimes you might work on a feature, but it could take weeks before it&amp;rsquo;s in a &amp;ldquo;good enough state&amp;rdquo; to merge into master. This side of our version control metaphor applies to rendering too.</source>
          <target state="translated">Мы уже говорили, что Concurrent Mode похож на React, работающий &amp;laquo;в ветке&amp;raquo;. Ветви полезны не только для краткосрочных исправлений, но и для долгосрочных функций. Иногда вы можете работать над функцией, но могут пройти недели, прежде чем она окажется в &amp;laquo;достаточно хорошем состоянии&amp;raquo; для слияния с основной. Эта сторона нашей метафоры контроля версий применима и к рендерингу.</target>
        </trans-unit>
        <trans-unit id="8bc522ebd2ef515724e353941f7b4486ad297dcb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve solved the previous network &amp;ldquo;waterfall&amp;rdquo;, but accidentally introduced a different one. We wait for &lt;em&gt;all&lt;/em&gt; data to come back with &lt;code&gt;Promise.all()&lt;/code&gt; inside &lt;code&gt;fetchProfileData&lt;/code&gt;, so now we can&amp;rsquo;t render profile details until the posts have been fetched too. We have to wait for both.</source>
          <target state="translated">Мы решили предыдущий сетевой &amp;laquo;водопад&amp;raquo;, но случайно ввели другой. Мы ждем, пока &lt;em&gt;все&lt;/em&gt; данные вернутся, с помощью &lt;code&gt;Promise.all()&lt;/code&gt; внутри &lt;code&gt;fetchProfileData&lt;/code&gt; , поэтому теперь мы не можем отображать детали профиля, пока не будут получены сообщения. Мы должны дождаться обоих.</target>
        </trans-unit>
        <trans-unit id="fc4e74fbf1eee3d969dbfb73e0089d683c0dcc2e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve wrapped our state update into &lt;code&gt;startTransition&lt;/code&gt; to tell React it&amp;rsquo;s okay to delay it.</source>
          <target state="translated">Мы обернули наше обновление состояния в &lt;code&gt;startTransition&lt;/code&gt; , чтобы сообщить React, что его можно отложить.</target>
        </trans-unit>
        <trans-unit id="7d934364c9313824f6e77d311ab14f3ddd86f222" translate="yes" xml:space="preserve">
          <source>Web Components</source>
          <target state="translated">Веб-компоненты</target>
        </trans-unit>
        <trans-unit id="89462d36c40b3b8c651a2fecd29c6a47d67d8652" translate="yes" xml:space="preserve">
          <source>Web Components often expose an imperative API. For instance, a &lt;code&gt;video&lt;/code&gt; Web Component might expose &lt;code&gt;play()&lt;/code&gt; and &lt;code&gt;pause()&lt;/code&gt; functions. To access the imperative APIs of a Web Component, you will need to use a ref to interact with the DOM node directly. If you are using third-party Web Components, the best solution is to write a React component that behaves as a wrapper for your Web Component.</source>
          <target state="translated">Веб-компоненты часто предоставляют императивный API. Например, веб-компонент &lt;code&gt;video&lt;/code&gt; может предоставлять функции &lt;code&gt;play()&lt;/code&gt; и &lt;code&gt;pause()&lt;/code&gt; . Чтобы получить доступ к обязательным API-интерфейсам веб-компонента, вам нужно будет использовать ссылку для непосредственного взаимодействия с узлом DOM. Если вы используете сторонние веб-компоненты, лучшим решением будет написать компонент React, который ведет себя как оболочка для вашего веб-компонента.</target>
        </trans-unit>
        <trans-unit id="e00b9f789bd874e0ed643701b463e09b446cea8c" translate="yes" xml:space="preserve">
          <source>Web accessibility (also referred to as &lt;a href=&quot;https://en.wiktionary.org/wiki/a11y&quot;&gt;&lt;strong&gt;a11y&lt;/strong&gt;&lt;/a&gt;) is the design and creation of websites that can be used by everyone. Accessibility support is necessary to allow assistive technology to interpret web pages.</source>
          <target state="translated">Веб-доступность (также называемая &lt;a href=&quot;https://en.wiktionary.org/wiki/a11y&quot;&gt;&lt;strong&gt;a11y&lt;/strong&gt;&lt;/a&gt; ) - это дизайн и создание веб-сайтов, которыми может пользоваться каждый. Поддержка специальных возможностей необходима для того, чтобы вспомогательные технологии могли интерпретировать веб-страницы.</target>
        </trans-unit>
        <trans-unit id="92d4811d4665c317fc3c6c88f65cc53f18cc4519" translate="yes" xml:space="preserve">
          <source>WebAIM - Color Contrast Checker</source>
          <target state="translated">WebAIM-Проверка цветового контраста</target>
        </trans-unit>
        <trans-unit id="f16c2ab8bf1a5aa2f65c3997b33b403520906211" translate="yes" xml:space="preserve">
          <source>WebAIM - Document Language</source>
          <target state="translated">WebAIM-Язык документов</target>
        </trans-unit>
        <trans-unit id="433235ab1e74117e5fc4f15627618af7d9236d56" translate="yes" xml:space="preserve">
          <source>WebAIM - Skip Navigation Links</source>
          <target state="translated">WebAIM-Пропустить навигационные ссылки</target>
        </trans-unit>
        <trans-unit id="3352c721cf8b15e3c5ba7494a77646493b7d5d12" translate="yes" xml:space="preserve">
          <source>WebAIM - Using JAWS to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-использование JAWS для оценки веб-доступности.</target>
        </trans-unit>
        <trans-unit id="0fc47857541ad45199770ccef6d4b96d6599031d" translate="yes" xml:space="preserve">
          <source>WebAIM - Using NVDA to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-Использование NVDA для оценки веб-доступности</target>
        </trans-unit>
        <trans-unit id="813fcd4a26c1f886c1d65397d9ec24b2e1c6f3ee" translate="yes" xml:space="preserve">
          <source>WebAIM - Using VoiceOver to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-использование VoiceOver для оценки веб-доступности.</target>
        </trans-unit>
        <trans-unit id="30fc76fba519e636eb93a339a1826e6626a74fa8" translate="yes" xml:space="preserve">
          <source>WebAIM WAVE</source>
          <target state="translated">WAVE WebAIM</target>
        </trans-unit>
        <trans-unit id="c6dd3413876261d9d5dfa5f7c1dc00a9a234d113" translate="yes" xml:space="preserve">
          <source>WebAIM looks at form validation</source>
          <target state="translated">WebAIM рассматривает валидацию форм</target>
        </trans-unit>
        <trans-unit id="9a2d1a6a5c28bcf72a8eb9de74d12f7b9c20191c" translate="yes" xml:space="preserve">
          <source>WebAIM shows us how to label elements</source>
          <target state="translated">WebAIM показывает нам,как маркировать элементы</target>
        </trans-unit>
        <trans-unit id="fc2e6cbaeaac02696deef92a72e32fd4e674290a" translate="yes" xml:space="preserve">
          <source>WebAIM talks about keyboard accessibility</source>
          <target state="translated">WebAIM рассказывает о доступности клавиатуры</target>
        </trans-unit>
        <trans-unit id="122c8865b61493b6f789d0524edf7ac87efe4d03" translate="yes" xml:space="preserve">
          <source>Webpack v4+ will minify your code by default in production mode.</source>
          <target state="translated">Webpack v4+по умолчанию минимизирует ваш код в производственном режиме.</target>
        </trans-unit>
        <trans-unit id="91b3f9b7f9ed1db7fbbff897990621a1f329c6b8" translate="yes" xml:space="preserve">
          <source>What Counts as a Breaking Change?</source>
          <target state="translated">Что значит &quot;перемены в лучшую сторону&quot;?</target>
        </trans-unit>
        <trans-unit id="306cd9673550a7548afb1d28d13a9e4ab675260a" translate="yes" xml:space="preserve">
          <source>What Goes Into an Experimental Release?</source>
          <target state="translated">Что входит в экспериментальный релиз?</target>
        </trans-unit>
        <trans-unit id="c1c5f3b99c4945dd281accfdc44da90d90092580" translate="yes" xml:space="preserve">
          <source>What If I Don&amp;rsquo;t Use Relay?</source>
          <target state="translated">Что делать, если я не использую реле?</target>
        </trans-unit>
        <trans-unit id="8f3ce40e7f755e7f9bd29a4ca2ef4eb8d9b5ec5b" translate="yes" xml:space="preserve">
          <source>What Is Concurrent Mode?</source>
          <target state="translated">Что такое параллельный режим?</target>
        </trans-unit>
        <trans-unit id="3a27620fdbb167ecbd14c72dcff5ace0f1c64383" translate="yes" xml:space="preserve">
          <source>What Is Suspense, Exactly?</source>
          <target state="translated">Что такое &quot;Подвеска&quot;,точно?</target>
        </trans-unit>
        <trans-unit id="e8a22cac534b1f2cd30ed5f98b635c16f790eab2" translate="yes" xml:space="preserve">
          <source>What Suspense Is Not</source>
          <target state="translated">В чем суспензия?</target>
        </trans-unit>
        <trans-unit id="c783af8d30d3e4364690860bb0374ea57809d4d3" translate="yes" xml:space="preserve">
          <source>What Suspense Lets You Do</source>
          <target state="translated">Что Подвеска позволяет тебе делать</target>
        </trans-unit>
        <trans-unit id="07167e206dc36076e1208fc57a82343e684c51c1" translate="yes" xml:space="preserve">
          <source>What can I do if my effect dependencies change too often?</source>
          <target state="translated">Что я могу сделать,если мои зависимости от эффекта меняются слишком часто?</target>
        </trans-unit>
        <trans-unit id="1cc6659d6c04ea72141e5d4aadbf96b176eef644" translate="yes" xml:space="preserve">
          <source>What can I do with Hooks that I couldn&amp;rsquo;t with classes?</source>
          <target state="translated">Что я могу делать с хуками, чего не мог делать с классами?</target>
        </trans-unit>
        <trans-unit id="cd3446a7312aac2facf235718a5ffd50e69c7d4a" translate="yes" xml:space="preserve">
          <source>What do Hooks mean for popular APIs like Redux &lt;code&gt;connect()&lt;/code&gt; and React Router?</source>
          <target state="translated">Что означают хуки для популярных API, таких как Redux &lt;code&gt;connect()&lt;/code&gt; и React Router?</target>
        </trans-unit>
        <trans-unit id="f691d89eec058d6953da17f694984d9b247497b5" translate="yes" xml:space="preserve">
          <source>What do Hooks mean for popular APIs like Redux connect() and React Router?</source>
          <target state="translated">Что Hooks означает для популярных API,таких как Redux connect()и React Router?</target>
        </trans-unit>
        <trans-unit id="319d6cb4f612b1898af74f1d58e55bb9a00c7f16" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;const [thing, setThing] = useState()&lt;/code&gt; mean?</source>
          <target state="translated">Что означает &lt;code&gt;const [thing, setThing] = useState()&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="64945305af0a0fa7d3c6dbaa11aaf7b00d606169" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;setState&lt;/code&gt; do?</source>
          <target state="translated">Что делает &lt;code&gt;setState&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="f8684f51532e8049d48a76354c4c251f1768106b" translate="yes" xml:space="preserve">
          <source>What does const [thing, setThing] = useState() mean?</source>
          <target state="translated">Что означает const [вещь,setThing]=useState()?</target>
        </trans-unit>
        <trans-unit id="b4f867b8bb7e53e8c3b6611c9f1d46df6d3e89f0" translate="yes" xml:space="preserve">
          <source>What exactly do the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;lint rules&lt;/a&gt; enforce?</source>
          <target state="translated">Что именно обеспечивают соблюдение &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;правил линта&lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="07ef000a203cb6f931243d3fceed10fdf912e2fc" translate="yes" xml:space="preserve">
          <source>What exactly do the lint rules enforce?</source>
          <target state="translated">Что именно обеспечивают ворсовые правила?</target>
        </trans-unit>
        <trans-unit id="e3b196d959a7d912e75414dca815d74e2142c718" translate="yes" xml:space="preserve">
          <source>What if we want to show a spinner in a different place than &amp;ldquo;above&amp;rdquo; the component in a tree?</source>
          <target state="translated">Что, если мы хотим показать счетчик в другом месте, а не &amp;laquo;над&amp;raquo; компонентом в дереве?</target>
        </trans-unit>
        <trans-unit id="d37eb6cbe5fc394050b5ba4dd59e15bb9146d921" translate="yes" xml:space="preserve">
          <source>What is &amp;ldquo;React Fiber&amp;rdquo;?</source>
          <target state="translated">Что такое &amp;laquo;React Fiber&amp;raquo;?</target>
        </trans-unit>
        <trans-unit id="126626903bfa28709f9dc97154ed4c6b318643af" translate="yes" xml:space="preserve">
          <source>What is CSS-in-JS?</source>
          <target state="translated">Что такое CSS-in-JS?</target>
        </trans-unit>
        <trans-unit id="b9b10ee223edff6297e6ec9600bac8dd2ffc48ff" translate="yes" xml:space="preserve">
          <source>What is the Virtual DOM?</source>
          <target state="translated">Что такое Виртуальный ДОМ?</target>
        </trans-unit>
        <trans-unit id="44ad1d597a94eb0351fcc2bab4f5bc2476770773" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt;?</source>
          <target state="translated">В чем разница между &lt;code&gt;state&lt;/code&gt; и &lt;code&gt;props&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="2153ca8a7eb6c240a2df099c7e84b57dedd442bd" translate="yes" xml:space="preserve">
          <source>What is the difference between passing an object or a function in &lt;code&gt;setState&lt;/code&gt;?</source>
          <target state="translated">В чем разница между передачей объекта или функции в &lt;code&gt;setState&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="ad6b021f6d6be586c97a85a04cd00cea15ecc6a0" translate="yes" xml:space="preserve">
          <source>What is the lifetime of a response? Should caching be global or local? Who manages the cache?</source>
          <target state="translated">Какова продолжительность жизни ответа? Кэширование должно быть глобальным или локальным? Кто управляет кэшем?</target>
        </trans-unit>
        <trans-unit id="a7846b7c3a9328a7abfc787060ce35a9d897ee0d" translate="yes" xml:space="preserve">
          <source>What is the prior art for Hooks?</source>
          <target state="translated">Каков предшествующий уровень техники для Крюка?</target>
        </trans-unit>
        <trans-unit id="84fa9a10d5b5938a5cfd5dcd3fbd211cd8ea85e2" translate="yes" xml:space="preserve">
          <source>What to Expect</source>
          <target state="translated">Чего ожидать</target>
        </trans-unit>
        <trans-unit id="e9a68218a8babe539cd10930840d839404a2a222" translate="yes" xml:space="preserve">
          <source>What would the equivalent of composing GraphQL queries look like for arbitrary Suspense data?</source>
          <target state="translated">Как бы выглядел эквивалент составления GraphQL-запросов для произвольных данных Suspense?</target>
        </trans-unit>
        <trans-unit id="2482c806af9f88ec9421505cdbfb9c23ef1bde71" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a Hook?</source>
          <target state="translated">Что за крючок?</target>
        </trans-unit>
        <trans-unit id="c0a7cdef0637bc5ca89d70c3638524e01a053b8e" translate="yes" xml:space="preserve">
          <source>Wheel Events</source>
          <target state="translated">Колесные события</target>
        </trans-unit>
        <trans-unit id="83b5d183aae32b6135d8bdcde578d304743623d8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; is passed to &lt;code&gt;ReactDOM.render()&lt;/code&gt;, React calls the constructor of the &lt;code&gt;Clock&lt;/code&gt; component. Since &lt;code&gt;Clock&lt;/code&gt; needs to display the current time, it initializes &lt;code&gt;this.state&lt;/code&gt; with an object including the current time. We will later update this state.</source>
          <target state="translated">Когда &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; передается в &lt;code&gt;ReactDOM.render()&lt;/code&gt; , React вызывает конструктор компонента &lt;code&gt;Clock&lt;/code&gt; . Поскольку &lt;code&gt;Clock&lt;/code&gt; необходимо отображать текущее время, они инициализируют &lt;code&gt;this.state&lt;/code&gt; объектом, включающим текущее время. Позже мы обновим это состояние.</target>
        </trans-unit>
        <trans-unit id="adb220ab22b57e8d612d3d8256e10868b648ed39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CommentListWithSubscription&lt;/code&gt; and &lt;code&gt;BlogPostWithSubscription&lt;/code&gt; are rendered, &lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt; will be passed a &lt;code&gt;data&lt;/code&gt; prop with the most current data retrieved from &lt;code&gt;DataSource&lt;/code&gt;:</source>
          <target state="translated">Когда &lt;code&gt;CommentListWithSubscription&lt;/code&gt; и &lt;code&gt;BlogPostWithSubscription&lt;/code&gt; визуализируются, &lt;code&gt;CommentList&lt;/code&gt; и &lt;code&gt;BlogPost&lt;/code&gt; будут принят &lt;code&gt;data&lt;/code&gt; пропеллера с наиболее актуальными данными , извлеченных из &lt;code&gt;DataSource&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0ccf62e1b79fa9fa20a9abbc82844e2c6ed7de3" translate="yes" xml:space="preserve">
          <source>When React sees an element representing a user-defined component, it passes JSX attributes and children to this component as a single object. We call this object &amp;ldquo;props&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63f5b998c37b2aac7d34a276c80403e6fbede6f" translate="yes" xml:space="preserve">
          <source>When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object &amp;ldquo;props&amp;rdquo;.</source>
          <target state="translated">Когда React видит элемент, представляющий определенный пользователем компонент, он передает атрибуты JSX этому компоненту как единый объект. Мы называем этот объект &amp;laquo;реквизитом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b5267c08cb1e8413e3450f6204da4ef3df0d7972" translate="yes" xml:space="preserve">
          <source>When Webpack comes across this syntax, it automatically starts code-splitting your app. If you&amp;rsquo;re using Create React App, this is already configured for you and you can &lt;a href=&quot;https://create-react-app.dev/docs/code-splitting/&quot;&gt;start using it&lt;/a&gt; immediately. It&amp;rsquo;s also supported out of the box in &lt;a href=&quot;https://nextjs.org/docs/advanced-features/dynamic-import&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd960a41239540628263b007251ff1ce228a4975" translate="yes" xml:space="preserve">
          <source>When Webpack comes across this syntax, it automatically starts code-splitting your app. If you&amp;rsquo;re using Create React App, this is already configured for you and you can &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/code-splitting&quot;&gt;start using it&lt;/a&gt; immediately. It&amp;rsquo;s also supported out of the box in &lt;a href=&quot;https://github.com/zeit/next.js/#dynamic-import&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="translated">Когда Webpack встречает этот синтаксис, он автоматически запускает разделение кода вашего приложения. Если вы используете приложение Create React, оно уже настроено для вас, и вы можете немедленно &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/code-splitting&quot;&gt;начать его использовать&lt;/a&gt; . Он также поддерживает из коробки в &lt;a href=&quot;https://github.com/zeit/next.js/#dynamic-import&quot;&gt;Next.js&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24308061c4ea79dc3398cfc8567de4c5dd49d65a" translate="yes" xml:space="preserve">
          <source>When a button gets clicked, it starts a transition and calls &lt;code&gt;props.onClick()&lt;/code&gt; inside of it &amp;mdash; which triggers &lt;code&gt;handleRefreshClick&lt;/code&gt; in the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component. We start fetching the fresh data, but it doesn&amp;rsquo;t trigger a fallback because we&amp;rsquo;re inside a transition, and the 10 second timeout specified in the &lt;code&gt;useTransition&lt;/code&gt; call hasn&amp;rsquo;t passed yet. While a transition is pending, the button displays an inline loading indicator.</source>
          <target state="translated">Когда кнопка нажата, она запускает переход и вызывает внутри него &lt;code&gt;props.onClick()&lt;/code&gt; что вызывает &lt;code&gt;handleRefreshClick&lt;/code&gt; в компоненте &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; . Мы начинаем выборку свежих данных, но это не вызывает отката, потому что мы находимся внутри перехода, а 10-секундный тайм-аут, указанный в вызове &lt;code&gt;useTransition&lt;/code&gt; , еще не прошел. Пока переход ожидается, на кнопке отображается встроенный индикатор загрузки.</target>
        </trans-unit>
        <trans-unit id="88c0e0d8605eedba926805cc491ffa3edad3fcca" translate="yes" xml:space="preserve">
          <source>When a component is removed &lt;em&gt;from within&lt;/em&gt; a React tree, the cleanup is performed automatically, but because we are removing the entire tree by hand, we must call this method.</source>
          <target state="translated">Когда компонент удаляется &lt;em&gt;из&lt;/em&gt; дерева React, очистка выполняется автоматически, но поскольку мы удаляем все дерево вручную, мы должны вызвать этот метод.</target>
        </trans-unit>
        <trans-unit id="fa03685bfee385115f05a87525bb34183aa7d3b6" translate="yes" xml:space="preserve">
          <source>When a component renders to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;findDOMNode&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;. When a component renders to a string, &lt;code&gt;findDOMNode&lt;/code&gt; returns a text DOM node containing that value. As of React 16, a component may return a fragment with multiple children, in which case &lt;code&gt;findDOMNode&lt;/code&gt; will return the DOM node corresponding to the first non-empty child.</source>
          <target state="translated">Когда компонент отображает значение &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;findDOMNode&lt;/code&gt; возвращает значение &lt;code&gt;null&lt;/code&gt; . Когда компонент отображает строку, &lt;code&gt;findDOMNode&lt;/code&gt; возвращает текстовый узел DOM, содержащий это значение. Начиная с React 16, компонент может возвращать фрагмент с несколькими &lt;code&gt;findDOMNode&lt;/code&gt; , и в этом случае findDOMNode вернет узел DOM, соответствующий первому непустому дочернему элементу .</target>
        </trans-unit>
        <trans-unit id="ebba8cb76e6c7b141346c24f24674447a518526e" translate="yes" xml:space="preserve">
          <source>When a component suspends, React needs to show the closest fallback. But the closest fallback to &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; is at the top level:</source>
          <target state="translated">Когда компонент приостанавливается, React должен показать ближайший откат. Но ближайший &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; к &amp;lt;ProfileDetails&amp;gt; находится на верхнем уровне:</target>
        </trans-unit>
        <trans-unit id="43f8277f42239eae9424a66a512a2fcabb104e3b" translate="yes" xml:space="preserve">
          <source>When a component updates, the instance stays the same, so that state is maintained across renders. React updates the props of the underlying component instance to match the new element, and calls &lt;code&gt;componentWillReceiveProps()&lt;/code&gt; and &lt;code&gt;componentWillUpdate()&lt;/code&gt; on the underlying instance.</source>
          <target state="translated">Когда компонент обновляется, экземпляр остается неизменным, так что это состояние сохраняется во время визуализации. React обновляет свойства экземпляра базового компонента, чтобы они соответствовали новому элементу, и вызывает &lt;code&gt;componentWillReceiveProps()&lt;/code&gt; и &lt;code&gt;componentWillUpdate()&lt;/code&gt; для базового экземпляра.</target>
        </trans-unit>
        <trans-unit id="29700bd1b2576f98f84deff1ab59eda1ac5d916a" translate="yes" xml:space="preserve">
          <source>When a component&amp;rsquo;s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM.</source>
          <target state="translated">Когда свойства или состояние компонента меняются, React решает, необходимо ли фактическое обновление DOM, сравнивая вновь возвращенный элемент с ранее визуализированным. Когда они не равны, React обновит DOM.</target>
        </trans-unit>
        <trans-unit id="71688bf085f5be3641ad0e7683c86eab151bc2ac" translate="yes" xml:space="preserve">
          <source>When a component&amp;rsquo;s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM. This process is called &amp;ldquo;reconciliation&amp;rdquo;.</source>
          <target state="translated">Когда свойства или состояние компонента меняются, React решает, необходимо ли фактическое обновление DOM, сравнивая вновь возвращенный элемент с ранее визуализированным. Когда они не равны, React обновит DOM. Этот процесс называется &amp;laquo;примирением&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4a658d61a32f67b5097f57314a0f3ffb42c9b802" translate="yes" xml:space="preserve">
          <source>When a ref is passed to an element in &lt;code&gt;render&lt;/code&gt;, a reference to the node becomes accessible at the &lt;code&gt;current&lt;/code&gt; attribute of the ref.</source>
          <target state="translated">Когда ссылка передается элементу в &lt;code&gt;render&lt;/code&gt; , ссылка на узел становится доступной в &lt;code&gt;current&lt;/code&gt; атрибуте ссылки.</target>
        </trans-unit>
        <trans-unit id="092bbc82c0f9752a97e3de82e29d782cdf9f9183" translate="yes" xml:space="preserve">
          <source>When an element type starts with a lowercase letter, it refers to a built-in component like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; and results in a string &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt; passed to &lt;code&gt;React.createElement&lt;/code&gt;. Types that start with a capital letter like &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; compile to &lt;code&gt;React.createElement(Foo)&lt;/code&gt; and correspond to a component defined or imported in your JavaScript file.</source>
          <target state="translated">Когда тип элемента начинается со строчной буквы, он ссылается на встроенный компонент, такой как &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; , и в результате в &lt;code&gt;React.createElement&lt;/code&gt; передается строка &lt;code&gt;'div'&lt;/code&gt; или &lt;code&gt;'span'&lt;/code&gt; . Типы, начинающиеся с заглавной буквы, например &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; , компилируются в &lt;code&gt;React.createElement(Foo)&lt;/code&gt; и соответствуют компоненту, определенному или импортированному в вашем файле JavaScript.</target>
        </trans-unit>
        <trans-unit id="f3b3db069005ff6eb433c8c7e16d92582e642386" translate="yes" xml:space="preserve">
          <source>When called, it should examine &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; and return one of the following types:</source>
          <target state="translated">При вызове он должен проверить &lt;code&gt;this.props&lt;/code&gt; и &lt;code&gt;this.state&lt;/code&gt; и вернуть один из следующих типов:</target>
        </trans-unit>
        <trans-unit id="3e932a8184d9d49299869706c6d5892582b63c0e" translate="yes" xml:space="preserve">
          <source>When choosing testing tools, it is worth considering a few tradeoffs:</source>
          <target state="translated">При выборе инструментов тестирования стоит учитывать несколько компромиссов:</target>
        </trans-unit>
        <trans-unit id="7dffbe923ddf378219923364d4231ca60a1015b6" translate="yes" xml:space="preserve">
          <source>When comparing two React DOM elements of the same type, React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes. For example:</source>
          <target state="translated">При сравнении двух элементов React DOM одного типа,React смотрит на атрибуты обоих,держит один и тот же базовый узел DOM и обновляет только измененные атрибуты.Например:</target>
        </trans-unit>
        <trans-unit id="0950dde1c2700e4c81c02a18f0ea0517525ca827" translate="yes" xml:space="preserve">
          <source>When converting between these two elements, React knows to only modify the &lt;code&gt;color&lt;/code&gt; style, not the &lt;code&gt;fontWeight&lt;/code&gt;.</source>
          <target state="translated">При преобразовании между этими двумя элементами React знает, что нужно изменять только &lt;code&gt;color&lt;/code&gt; стиль, а не &lt;code&gt;fontWeight&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="684d074ff1bc6db8a43e7868a40828d155492a57" translate="yes" xml:space="preserve">
          <source>When diffing two trees, React first compares the two root elements. The behavior is different depending on the types of the root elements.</source>
          <target state="translated">При различии двух деревьев,Реакция сначала сравнивает два корневых элемента.Поведение отличается в зависимости от типов корневых элементов.</target>
        </trans-unit>
        <trans-unit id="b3f4316f1f0610218ae53493262f1b06012ea13b" translate="yes" xml:space="preserve">
          <source>When is &lt;code&gt;setState&lt;/code&gt; asynchronous?</source>
          <target state="translated">Когда &lt;code&gt;setState&lt;/code&gt; является асинхронным?</target>
        </trans-unit>
        <trans-unit id="eb68f1b04a107d4cc5de744e2d26501dbb590d6c" translate="yes" xml:space="preserve">
          <source>When it previously rendered, the &lt;code&gt;Calculator&lt;/code&gt; had specified that &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Celsius &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleCelsiusChange&lt;/code&gt; method, and &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Fahrenheit &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleFahrenheitChange&lt;/code&gt; method. So either of these two &lt;code&gt;Calculator&lt;/code&gt; methods gets called depending on which input we edited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9986343101ee6da7851b9828f0c4a4eaf4dce38b" translate="yes" xml:space="preserve">
          <source>When it previously rendered, the &lt;code&gt;Calculator&lt;/code&gt; has specified that &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Celsius &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleCelsiusChange&lt;/code&gt; method, and &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Fahrenheit &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleFahrenheitChange&lt;/code&gt; method. So either of these two &lt;code&gt;Calculator&lt;/code&gt; methods gets called depending on which input we edited.</source>
          <target state="translated">Когда он ранее вынесенный &lt;code&gt;Calculator&lt;/code&gt; указал , что &lt;code&gt;onTemperatureChange&lt;/code&gt; из Цельсия &lt;code&gt;TemperatureInput&lt;/code&gt; является &lt;code&gt;Calculator&lt;/code&gt; &amp;laquo;ы &lt;code&gt;handleCelsiusChange&lt;/code&gt; метода и &lt;code&gt;onTemperatureChange&lt;/code&gt; из Фаренгейта &lt;code&gt;TemperatureInput&lt;/code&gt; является &lt;code&gt;Calculator&lt;/code&gt; &amp;laquo;ы &lt;code&gt;handleFahrenheitChange&lt;/code&gt; метода. Таким образом, любой из этих двух методов &lt;code&gt;Calculator&lt;/code&gt; вызывается в зависимости от того, какой ввод мы редактировали.</target>
        </trans-unit>
        <trans-unit id="e9b2aac6423622e177393a29a45bdfea31a200f8" translate="yes" xml:space="preserve">
          <source>When multiple components need to fetch data, this data may arrive in an unpredictable order. However, if you wrap these items in a &lt;code&gt;SuspenseList&lt;/code&gt;, React will not show an item in the list until previous items have been displayed (this behavior is adjustable).</source>
          <target state="translated">Когда нескольким компонентам требуется получить данные, эти данные могут поступать в непредсказуемом порядке. Однако, если вы заключите эти элементы в &lt;code&gt;SuspenseList&lt;/code&gt; , React не будет отображать элемент в списке, пока не будут отображены предыдущие элементы (это поведение можно изменить).</target>
        </trans-unit>
        <trans-unit id="42a683f16be3b2ba0e15fb0b13b5fd965aa7a2f8" translate="yes" xml:space="preserve">
          <source>When possible, we advise against exposing DOM nodes, but it can be a useful escape hatch. Note that this approach requires you to add some code to the child component. If you have absolutely no control over the child component implementation, your last option is to use &lt;a href=&quot;react-dom#finddomnode&quot;&gt;&lt;code&gt;findDOMNode()&lt;/code&gt;&lt;/a&gt;, but it is discouraged and deprecated in &lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt;&lt;code&gt;StrictMode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">По возможности мы не советуем открывать узлы DOM, но это может быть полезный выход из ситуации. Обратите внимание, что этот подход требует добавления кода в дочерний компонент. Если у вас нет абсолютно никакого контроля над реализацией дочернего компонента, последний вариант - использовать &lt;a href=&quot;react-dom#finddomnode&quot;&gt; &lt;code&gt;findDOMNode()&lt;/code&gt; &lt;/a&gt; , но это не рекомендуется и не рекомендуется в &lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt; &lt;code&gt;StrictMode&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60dc9558f9f54b804963bf45bd2054c08d64c066" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;breaking changes&lt;/strong&gt;, we make a &lt;strong&gt;major release&lt;/strong&gt; by changing the &lt;strong&gt;x&lt;/strong&gt; number (ex: 15.6.2 to 16.0.0).</source>
          <target state="translated">При выпуске &lt;strong&gt;критических изменений&lt;/strong&gt; мы делаем &lt;strong&gt;основной выпуск&lt;/strong&gt; , изменяя число &lt;strong&gt;x&lt;/strong&gt; (например, с 15.6.2 на 16.0.0).</target>
        </trans-unit>
        <trans-unit id="c51bee886f54f565c856364002a6f5a65ec91ed6" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;critical bug fixes&lt;/strong&gt;, we make a &lt;strong&gt;patch release&lt;/strong&gt; by changing the &lt;strong&gt;z&lt;/strong&gt; number (ex: 15.6.2 to 15.6.3).</source>
          <target state="translated">Выпуская &lt;strong&gt;критические исправления ошибок&lt;/strong&gt; , мы делаем &lt;strong&gt;выпуск патча&lt;/strong&gt; , изменяя номер &lt;strong&gt;z&lt;/strong&gt; (например, с 15.6.2 на 15.6.3).</target>
        </trans-unit>
        <trans-unit id="da463cb8c8960a42b7c6c641c9cd92e1a9c910f5" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;new features&lt;/strong&gt; or &lt;strong&gt;non-critical fixes&lt;/strong&gt;, we make a &lt;strong&gt;minor release&lt;/strong&gt; by changing the &lt;strong&gt;y&lt;/strong&gt; number (ex: 15.6.2 to 15.7.0).</source>
          <target state="translated">При выпуске &lt;strong&gt;новых функций&lt;/strong&gt; или &lt;strong&gt;некритических исправлений&lt;/strong&gt; мы делаем &lt;strong&gt;второстепенный выпуск&lt;/strong&gt; , изменяя число &lt;strong&gt;y&lt;/strong&gt; (например, с 15.6.2 на 15.7.0).</target>
        </trans-unit>
        <trans-unit id="4c4ce5e89fb709cdcfcdafac99ab55a42fcb22c8" translate="yes" xml:space="preserve">
          <source>When starting a React project, a &lt;a href=&quot;add-react-to-a-website&quot;&gt;simple HTML page with script tags&lt;/a&gt; might still be the best option. It only takes a minute to set up!</source>
          <target state="translated">При запуске проекта React &lt;a href=&quot;add-react-to-a-website&quot;&gt;простая HTML-страница с тегами сценария&lt;/a&gt; может быть лучшим вариантом. Настройка займет всего минуту!</target>
        </trans-unit>
        <trans-unit id="b761467ad522f1cc9758e17d70a4c8a9a2a07e67" translate="yes" xml:space="preserve">
          <source>When strict mode is enabled, React compiles a list of all class components using the unsafe lifecycles, and logs a warning message with information about these components, like so:</source>
          <target state="translated">Когда включен строгий режим,React компилирует список всех компонентов класса,используя небезопасные жизненные циклы,и записывает в журнал предупреждающее сообщение с информацией об этих компонентах:</target>
        </trans-unit>
        <trans-unit id="347743a185cce0b0e36269b13516e6388d551e77" translate="yes" xml:space="preserve">
          <source>When tearing down a tree, old DOM nodes are destroyed. Component instances receive &lt;code&gt;componentWillUnmount()&lt;/code&gt;. When building up a new tree, new DOM nodes are inserted into the DOM. Component instances receive &lt;code&gt;componentWillMount()&lt;/code&gt; and then &lt;code&gt;componentDidMount()&lt;/code&gt;. Any state associated with the old tree is lost.</source>
          <target state="translated">При сносе дерева старые узлы DOM уничтожаются. Экземпляры &lt;code&gt;componentWillUnmount()&lt;/code&gt; получают componentWillUnmount () . При построении нового дерева новые узлы DOM вставляются в DOM. Экземпляры &lt;code&gt;componentWillMount()&lt;/code&gt; получают componentWillMount (), а затем &lt;code&gt;componentDidMount()&lt;/code&gt; . Любое состояние, связанное со старым деревом, теряется.</target>
        </trans-unit>
        <trans-unit id="30d8a42b09cbe7fd1ec6f1e31e28559adfac664f" translate="yes" xml:space="preserve">
          <source>When testing your rate limiting code works correctly it is helpful to have the ability to fast forward time. If you are using &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;&lt;code&gt;jest&lt;/code&gt;&lt;/a&gt; then you can use &lt;a href=&quot;https://facebook.github.io/jest/docs/en/timer-mocks.html&quot;&gt;&lt;code&gt;mock timers&lt;/code&gt;&lt;/a&gt; to fast forward time. If you are using &lt;code&gt;requestAnimationFrame&lt;/code&gt; throttling then you may find &lt;a href=&quot;https://github.com/alexreardon/raf-stub&quot;&gt;&lt;code&gt;raf-stub&lt;/code&gt;&lt;/a&gt; to be a useful tool to control the ticking of animation frames.</source>
          <target state="translated">При тестировании кода, ограничивающего скорость, работает правильно, полезно иметь возможность ускорять время вперед. Если вы используете &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt; &lt;code&gt;jest&lt;/code&gt; &lt;/a&gt; вы можете использовать &lt;a href=&quot;https://facebook.github.io/jest/docs/en/timer-mocks.html&quot;&gt; &lt;code&gt;mock timers&lt;/code&gt; &lt;/a&gt; для ускорения времени вперед. Если вы используете регулирование &lt;code&gt;requestAnimationFrame&lt;/code&gt; , вы можете найти &lt;a href=&quot;https://github.com/alexreardon/raf-stub&quot;&gt; &lt;code&gt;raf-stub&lt;/code&gt; &lt;/a&gt; как полезный инструмент для управления отметкой кадров анимации.</target>
        </trans-unit>
        <trans-unit id="778feebbad29d6b5513a63ee18a925568f6d6163" translate="yes" xml:space="preserve">
          <source>When that&amp;rsquo;s not the case, you can add a new ID property to your model or hash some parts of the content to generate a key. The key only has to be unique among its siblings, not globally unique.</source>
          <target state="translated">Если это не так, вы можете добавить новое свойство ID в свою модель или хешировать некоторые части контента для генерации ключа. Ключ должен быть уникальным только среди своих братьев и сестер, а не глобально.</target>
        </trans-unit>
        <trans-unit id="a0c23aa39d66eaa9a54e2e5df7c6fc165ebfd607" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Clock&lt;/code&gt; output is inserted in the DOM, React calls the &lt;code&gt;componentDidMount()&lt;/code&gt; lifecycle method. Inside it, the &lt;code&gt;Clock&lt;/code&gt; component asks the browser to set up a timer to call the component&amp;rsquo;s &lt;code&gt;tick()&lt;/code&gt; method once a second.</source>
          <target state="translated">Когда вывод &lt;code&gt;Clock&lt;/code&gt; вставлен в DOM, React вызывает метод жизненного цикла &lt;code&gt;componentDidMount()&lt;/code&gt; . Внутри него компонент &lt;code&gt;Clock&lt;/code&gt; просит браузер установить таймер для вызова метода &lt;code&gt;tick()&lt;/code&gt; компонента один раз в секунду.</target>
        </trans-unit>
        <trans-unit id="cf10aa37dfd027d0b674dd7f80a8d15edd1555cb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ref&lt;/code&gt; attribute is used on a custom class component, the &lt;code&gt;ref&lt;/code&gt; object receives the mounted instance of the component as its &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">Когда атрибут &lt;code&gt;ref&lt;/code&gt; используется в компоненте настраиваемого класса, объект &lt;code&gt;ref&lt;/code&gt; получает смонтированный экземпляр компонента в качестве своего &lt;code&gt;current&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1196abe0d02468ca061784efb41273736ae2775d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ref&lt;/code&gt; attribute is used on an HTML element, the &lt;code&gt;ref&lt;/code&gt; created in the constructor with &lt;code&gt;React.createRef()&lt;/code&gt; receives the underlying DOM element as its &lt;code&gt;current&lt;/code&gt; property.</source>
          <target state="translated">Когда атрибут &lt;code&gt;ref&lt;/code&gt; используется в элементе HTML, &lt;code&gt;ref&lt;/code&gt; созданная в конструкторе с помощью &lt;code&gt;React.createRef()&lt;/code&gt; получает базовый элемент DOM в качестве своего &lt;code&gt;current&lt;/code&gt; свойства.</target>
        </trans-unit>
        <trans-unit id="4842e3714ef564d446a08145facb86d1faac4e3f" translate="yes" xml:space="preserve">
          <source>When the nearest &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; above the component updates, this Hook will trigger a rerender with the latest context &lt;code&gt;value&lt;/code&gt; passed to that &lt;code&gt;MyContext&lt;/code&gt; provider. Even if an ancestor uses &lt;a href=&quot;react-api#reactmemo&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate&lt;/code&gt;&lt;/a&gt;, a rerender will still happen starting at the component itself using &lt;code&gt;useContext&lt;/code&gt;.</source>
          <target state="translated">Когда ближайший &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; над компонентом обновляется, этот Hook инициирует повторную визуализацию с последним &lt;code&gt;value&lt;/code&gt; контекста, переданным &lt;code&gt;MyContext&lt;/code&gt; провайдеру MyContext . Даже если предок использует &lt;a href=&quot;react-api#reactmemo&quot;&gt; &lt;code&gt;React.memo&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate&lt;/code&gt; &lt;/a&gt; , повторная визуализация все равно будет происходить, начиная с самого компонента с использованием &lt;code&gt;useContext&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f136dce5bc69460397f4de5f24b415b64d0e59e" translate="yes" xml:space="preserve">
          <source>When the ref is attached, &lt;code&gt;ref.current&lt;/code&gt; will point to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM node.</source>
          <target state="translated">Когда ссылка прикреплена, &lt;code&gt;ref.current&lt;/code&gt; будет указывать на узел DOM &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5004319c4160942e0f6547bee0d83e11339e4331" translate="yes" xml:space="preserve">
          <source>When to Use Context</source>
          <target state="translated">Когда использовать контекст</target>
        </trans-unit>
        <trans-unit id="8d9501cf2be99ddf15d3221bfb5919dd4b8ef921" translate="yes" xml:space="preserve">
          <source>When to Use Refs</source>
          <target state="translated">Когда использовать Ссылки</target>
        </trans-unit>
        <trans-unit id="ce86eaeb59a0d973185f25e1918297ceadd0737d" translate="yes" xml:space="preserve">
          <source>When updating &lt;code&gt;style&lt;/code&gt;, React also knows to update only the properties that changed. For example:</source>
          <target state="translated">При обновлении &lt;code&gt;style&lt;/code&gt; React также знает, что нужно обновлять только те свойства, которые изменились. Например:</target>
        </trans-unit>
        <trans-unit id="3910d9d7e05c337c7e8ee06cb5f7ecbfe75a93ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, you&amp;rsquo;ll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need &lt;a href=&quot;https://classic.yarnpkg.com/en/package/@babel/plugin-syntax-dynamic-import&quot;&gt;@babel/plugin-syntax-dynamic-import&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f686dfc377beeaa047e439ce00efd438744a39e1" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, you&amp;rsquo;ll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need &lt;a href=&quot;https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import&quot;&gt;babel-plugin-syntax-dynamic-import&lt;/a&gt;.</source>
          <target state="translated">При использовании &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; необходимо убедиться, что Babel может анализировать синтаксис динамического импорта, но не преобразовывает его. Для этого вам понадобится &lt;a href=&quot;https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import&quot;&gt;babel-plugin-syntax-dynamic-import&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eba57241352930e4939e8b3898ace71b33c7ff40" translate="yes" xml:space="preserve">
          <source>When using React, you generally don&amp;rsquo;t need to call &lt;code&gt;addEventListener&lt;/code&gt; to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.</source>
          <target state="translated">При использовании React обычно не нужно вызывать &lt;code&gt;addEventListener&lt;/code&gt; для добавления слушателей к элементу DOM после его создания. Вместо этого просто предоставьте слушателя при первоначальной визуализации элемента.</target>
        </trans-unit>
        <trans-unit id="093f2c7f6c3ba701ba5ea625a4f27b321d9a5fb9" translate="yes" xml:space="preserve">
          <source>When using a HOC to extend components, it is recommended to &lt;a href=&quot;forwarding-refs&quot;&gt;forward the ref&lt;/a&gt; to the wrapped component using the &lt;code&gt;forwardRef&lt;/code&gt; function of React. If a third party HOC does not implement ref forwarding, the above pattern can still be used as a fallback.</source>
          <target state="translated">При использовании HOC для расширения компонентов рекомендуется &lt;a href=&quot;forwarding-refs&quot;&gt;перенаправить &lt;/a&gt; &lt;code&gt;forwardRef&lt;/code&gt; на обернутый компонент с помощью функции forwardRef в React. Если сторонний HOC не реализует переадресацию ссылок, вышеуказанный шаблон все равно можно использовать в качестве запасного варианта.</target>
        </trans-unit>
        <trans-unit id="4e906275be6eecf52c0afbd564f7672d05ee4159" translate="yes" xml:space="preserve">
          <source>When we &lt;code&gt;useTransition&lt;/code&gt;, React will let us &amp;ldquo;stay&amp;rdquo; on the previous screen &amp;mdash; and show a progress indicator there. We call that a &lt;strong&gt;Pending&lt;/strong&gt; state. It feels much better than the Receded state because none of our existing content disappears, and the page stays interactive.</source>
          <target state="translated">Когда мы &lt;code&gt;useTransition&lt;/code&gt; , React позволяет нам &amp;laquo;оставаться&amp;raquo; на предыдущем экране - и показывать там индикатор прогресса. Мы называем это состоянием &lt;strong&gt;ожидания&lt;/strong&gt; . Это намного лучше, чем состояние &amp;laquo;Отложено&amp;raquo;, потому что ни один из существующих материалов не исчезает, а страница остается интерактивной.</target>
        </trans-unit>
        <trans-unit id="4854d06865881970adc4acde9ae2a92249e7a3ea" translate="yes" xml:space="preserve">
          <source>When we click &amp;ldquo;Next&amp;rdquo;, the &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; component kicks off a request for the next profile, and passes &lt;em&gt;that&lt;/em&gt; object down to the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Когда мы нажимаем &amp;laquo;Далее&amp;raquo;, компонент &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; запускает запрос следующего профиля и передает &lt;em&gt;этот&lt;/em&gt; объект компоненту &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fca1cc82f8e24916153432702dbf9b64cc55319c" translate="yes" xml:space="preserve">
          <source>When we click the &amp;ldquo;Next&amp;rdquo; button to switch the active profile, the existing page data immediately disappears, and we see the loading indicator for the whole page again. We can call this an &amp;ldquo;undesirable&amp;rdquo; loading state. &lt;strong&gt;It would be nice if we could &amp;ldquo;skip&amp;rdquo; it and wait for some content to load before transitioning to the new screen.&lt;/strong&gt;</source>
          <target state="translated">Когда мы нажимаем кнопку &amp;laquo;Далее&amp;raquo;, чтобы переключить активный профиль, существующие данные страницы немедленно исчезают, и мы снова видим индикатор загрузки для всей страницы. Мы можем назвать это &amp;laquo;нежелательным&amp;raquo; состоянием загрузки. &lt;strong&gt;Было бы неплохо, если бы мы могли &amp;laquo;пропустить&amp;raquo; его и дождаться загрузки некоторого содержимого перед переходом на новый экран.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a9b7e3341f89a25468d35a1902a98055ebd40a4" translate="yes" xml:space="preserve">
          <source>When we declare a state variable with &lt;code&gt;useState&lt;/code&gt;, it returns a pair &amp;mdash; an array with two items. The first item is the current value, and the second is a function that lets us update it. Using &lt;code&gt;[0]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt; to access them is a bit confusing because they have a specific meaning. This is why we use array destructuring instead.</source>
          <target state="translated">Когда мы объявляем переменную состояния с помощью &lt;code&gt;useState&lt;/code&gt; , она возвращает пару - массив с двумя элементами. Первый элемент - это текущее значение, а второй - функция, которая позволяет нам его обновлять. Использование &lt;code&gt;[0]&lt;/code&gt; и &lt;code&gt;[1]&lt;/code&gt; для доступа к ним немного сбивает с толку, потому что они имеют определенное значение. Вот почему вместо этого мы используем деструктуризацию массива.</target>
        </trans-unit>
        <trans-unit id="48f1197e89ad2a45509e77a5dc2018726e3c6911" translate="yes" xml:space="preserve">
          <source>When we fetch data for a page, can the API encourage including data for instant transitions &lt;em&gt;from&lt;/em&gt; it?</source>
          <target state="translated">Когда мы получаем данные для страницы, может ли API поощрять включение данных для мгновенных переходов &lt;em&gt;с&lt;/em&gt; нее?</target>
        </trans-unit>
        <trans-unit id="ed6581c215df6a3091c26a4c2bdef00a960a4785" translate="yes" xml:space="preserve">
          <source>When we render with &lt;code&gt;count&lt;/code&gt; updated to &lt;code&gt;6&lt;/code&gt;, React will compare the items in the &lt;code&gt;[5]&lt;/code&gt; array from the previous render to items in the &lt;code&gt;[6]&lt;/code&gt; array from the next render. This time, React will re-apply the effect because &lt;code&gt;5 !== 6&lt;/code&gt;. If there are multiple items in the array, React will re-run the effect even if just one of them is different.</source>
          <target state="translated">Когда мы выполняем рендеринг с обновленным &lt;code&gt;count&lt;/code&gt; до &lt;code&gt;6&lt;/code&gt; , React сравнивает элементы в массиве &lt;code&gt;[5]&lt;/code&gt; из предыдущего рендеринга с элементами в массиве &lt;code&gt;[6]&lt;/code&gt; из следующего рендеринга. На этот раз React повторно применит эффект, потому что &lt;code&gt;5 !== 6&lt;/code&gt; . Если в массиве несколько элементов, React повторно запустит эффект, даже если только один из них отличается.</target>
        </trans-unit>
        <trans-unit id="15dd239dd01373f359404e41d5b7a62dacbb76d9" translate="yes" xml:space="preserve">
          <source>When we want to display the current count in a class, we read &lt;code&gt;this.state.count&lt;/code&gt;:</source>
          <target state="translated">Когда мы хотим отобразить текущий счетчик в классе, мы читаем &lt;code&gt;this.state.count&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e772ea53410ed97f311017baf25729ac436eb7e" translate="yes" xml:space="preserve">
          <source>When we want to share logic between two JavaScript functions, we extract it to a third function. Both components and Hooks are functions, so this works for them too!</source>
          <target state="translated">Когда мы хотим разделить логику между двумя JavaScript-функциями,мы извлекаем ее в третью функцию.Оба компонента и Hooks являются функциями,так что это тоже работает для них!</target>
        </trans-unit>
        <trans-unit id="b6891052b12cc29726c0f0b0279ac50a1c1387f8" translate="yes" xml:space="preserve">
          <source>When we were learning about &lt;a href=&quot;hooks-effect#example-using-hooks-1&quot;&gt;using the Effect Hook&lt;/a&gt;, we saw this component from a chat application that displays a message indicating whether a friend is online or offline:</source>
          <target state="translated">Когда мы узнали об &lt;a href=&quot;hooks-effect#example-using-hooks-1&quot;&gt;использовании Effect Hook&lt;/a&gt; , мы увидели этот компонент из приложения чата, которое отображает сообщение, указывающее, находится ли друг в сети или офлайн:</target>
        </trans-unit>
        <trans-unit id="5b9387f6a30d7fe6f52f7bcb771030991372ac72" translate="yes" xml:space="preserve">
          <source>When we write code with Promises, we might use &lt;code&gt;catch()&lt;/code&gt; to handle errors. How does this work with Suspense, given that we don&amp;rsquo;t &lt;em&gt;wait&lt;/em&gt; for Promises to start rendering?</source>
          <target state="translated">Когда мы пишем код с помощью Promises, мы можем использовать &lt;code&gt;catch()&lt;/code&gt; для обработки ошибок. Как это работает с задержкой, учитывая, что мы не &lt;em&gt;ждем&lt;/em&gt; начала рендеринга обещаний?</target>
        </trans-unit>
        <trans-unit id="dbbba4fb5bc3bc71466275b51ebcb399bc61b8c2" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re already on the next screen, sometimes the data needed to &amp;ldquo;unlock&amp;rdquo; different &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries arrives in quick succession. For example, two different responses might arrive after 1000ms and 1050ms, respectively. If you&amp;rsquo;ve already waited for a second, waiting another 50ms is not going to be perceptible. This is why React reveals &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries on a schedule, like a &amp;ldquo;train&amp;rdquo; that arrives periodically. This trades a small delay for reducing the layout thrashing and the number of visual changes presented to the user.</source>
          <target state="translated">Когда мы уже находимся на следующем экране, иногда данные, необходимые для &amp;laquo;разблокировки&amp;raquo; различных границ &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; , поступают в быстрой последовательности. Например, два разных ответа могут поступить через 1000 мс и 1050 мс соответственно. Если вы уже подождали секунду, ожидание еще 50 мс будет незаметным. Вот почему React выявляет границы &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; в расписании, как &amp;laquo;поезд&amp;raquo;, который периодически прибывает. Это приносит небольшую задержку на сокращение разметки макета и количества визуальных изменений, представляемых пользователю.</target>
        </trans-unit>
        <trans-unit id="1b060390d4cb54331e0099d906d42df3b0d12cba" translate="yes" xml:space="preserve">
          <source>When working with portals, remember that &lt;a href=&quot;accessibility#programmatically-managing-focus&quot;&gt;managing keyboard focus&lt;/a&gt; becomes very important.</source>
          <target state="translated">При работе с порталами помните, что &lt;a href=&quot;accessibility#programmatically-managing-focus&quot;&gt;управление фокусом клавиатуры&lt;/a&gt; становится очень важным.</target>
        </trans-unit>
        <trans-unit id="8db3a4bc3fdaeca77d8e51c126c8d263c7425a94" translate="yes" xml:space="preserve">
          <source>When writing UI tests, tasks like rendering, user events, or data fetching can be considered as &amp;ldquo;units&amp;rdquo; of interaction with a user interface. &lt;code&gt;react-dom/test-utils&lt;/code&gt; provides a helper called &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;act()&lt;/code&gt;&lt;/a&gt; that makes sure all updates related to these &amp;ldquo;units&amp;rdquo; have been processed and applied to the DOM before you make any assertions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b92b098726d1ea5fd34d3c3b1ae6f350cac787b" translate="yes" xml:space="preserve">
          <source>When writing UI tests, tasks like rendering, user events, or data fetching can be considered as &amp;ldquo;units&amp;rdquo; of interaction with a user interface. React provides a helper called &lt;code&gt;act()&lt;/code&gt; that makes sure all updates related to these &amp;ldquo;units&amp;rdquo; have been processed and applied to the DOM before you make any assertions:</source>
          <target state="translated">При написании тестов пользовательского интерфейса такие задачи, как отрисовка, пользовательские события или выборка данных, можно рассматривать как &amp;laquo;единицы&amp;raquo; взаимодействия с пользовательским интерфейсом. React предоставляет помощник под названием &lt;code&gt;act()&lt;/code&gt; который гарантирует, что все обновления, связанные с этими &amp;laquo;модулями&amp;raquo;, были обработаны и применены к DOM, прежде чем вы сделаете какие-либо утверждения:</target>
        </trans-unit>
        <trans-unit id="815dd6740e6e9c5d08dcb3ad258c5e94e50158fe" translate="yes" xml:space="preserve">
          <source>When writing tests, we&amp;rsquo;d like to mock out the parts of our code that don&amp;rsquo;t have equivalents inside our testing environment (e.g. checking &lt;code&gt;navigator.onLine&lt;/code&gt; status inside Node.js). Tests could also spy on some functions, and observe how other parts of the test interact with them. It is then useful to be able to selectively mock these functions with test-friendly versions.</source>
          <target state="translated">При написании тестов мы хотели бы смоделировать части нашего кода, которые не имеют аналогов в нашей тестовой среде (например, проверка статуса &lt;code&gt;navigator.onLine&lt;/code&gt; внутри Node.js). Тесты также могут следить за некоторыми функциями и наблюдать, как другие части теста взаимодействуют с ними. Затем полезно иметь возможность выборочно имитировать эти функции с помощью версий, удобных для тестирования.</target>
        </trans-unit>
        <trans-unit id="54186af6fe93abf508be013c58f7c15e821c2212" translate="yes" xml:space="preserve">
          <source>When writing unit tests for React, shallow rendering can be helpful. Shallow rendering lets you render a component &amp;ldquo;one level deep&amp;rdquo; and assert facts about what its render method returns, without worrying about the behavior of child components, which are not instantiated or rendered. This does not require a DOM.</source>
          <target state="translated">При написании модульных тестов для React может оказаться полезным неглубокий рендеринг. Неглубокий рендеринг позволяет вам рендерить компонент &amp;laquo;на один уровень в глубину&amp;raquo; и утверждать факты о том, что возвращает его метод рендеринга, не беспокоясь о поведении дочерних компонентов, которые не создаются и не рендерируются. Это не требует DOM.</target>
        </trans-unit>
        <trans-unit id="82a14329dae74e66f4aea2bb76056b1aafd3fd03" translate="yes" xml:space="preserve">
          <source>When you apply a HOC to a component, though, the original component is wrapped with a container component. That means the new component does not have any of the static methods of the original component.</source>
          <target state="translated">Однако при применении HOC к компоненту,исходный компонент обертывается контейнером.Это означает,что новый компонент не имеет ни одного из статических методов оригинального компонента.</target>
        </trans-unit>
        <trans-unit id="d789f6dd4fbb7df7db5b972518ccd2f457118883" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;setState()&lt;/code&gt;, React merges the object you provide into the current state.</source>
          <target state="translated">Когда вы вызываете &lt;code&gt;setState()&lt;/code&gt; , React объединяет предоставленный вами объект с текущим состоянием.</target>
        </trans-unit>
        <trans-unit id="93a56c926d74b4e963b27be254ec9ba6d291fd30" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;useEffect&lt;/code&gt;, you&amp;rsquo;re telling React to run your &amp;ldquo;effect&amp;rdquo; function after flushing changes to the DOM. Effects are declared inside the component so they have access to its props and state. By default, React runs the effects after every render &amp;mdash; &lt;em&gt;including&lt;/em&gt; the first render. (We&amp;rsquo;ll talk more about how this compares to class lifecycles in &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.)</source>
          <target state="translated">Когда вы вызываете &lt;code&gt;useEffect&lt;/code&gt; , вы указываете React запускать вашу функцию &amp;laquo;эффекта&amp;raquo; после сброса изменений в DOM. Эффекты объявляются внутри компонента, поэтому они имеют доступ к его свойствам и состоянию. По умолчанию React запускает эффекты после каждой визуализации, &lt;em&gt;включая&lt;/em&gt; первую. (Мы поговорим подробнее о том, как это соотносится с жизненными циклами классов, в &lt;a href=&quot;hooks-effect&quot;&gt;разделе Использование обработчика эффектов&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="5dc1f9c6d9a1899bf29a171b9ce6e79ac82836a8" translate="yes" xml:space="preserve">
          <source>When you deal with deeply nested objects, updating them in an immutable way can feel convoluted. If you run into this problem, check out &lt;a href=&quot;https://github.com/mweststrate/immer&quot;&gt;Immer&lt;/a&gt; or &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;. These libraries let you write highly readable code without losing the benefits of immutability.</source>
          <target state="translated">Когда вы имеете дело с глубоко вложенными объектами, обновление их неизменным способом может показаться запутанным. Если вы столкнулись с этой проблемой, попробуйте &lt;a href=&quot;https://github.com/mweststrate/immer&quot;&gt;Immer&lt;/a&gt; или &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt; . Эти библиотеки позволяют писать легко читаемый код, не теряя при этом неизменяемости.</target>
        </trans-unit>
        <trans-unit id="a24b1ec6fc11433896d187e1f658c70a7099a2ad" translate="yes" xml:space="preserve">
          <source>When you define a component using an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt;, a common pattern is for an event handler to be a method on the class. For example, this &lt;code&gt;Toggle&lt;/code&gt; component renders a button that lets the user toggle between &amp;ldquo;ON&amp;rdquo; and &amp;ldquo;OFF&amp;rdquo; states:</source>
          <target state="translated">Когда вы определяете компонент с помощью &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;класса ES6&lt;/a&gt; , обычно обработчик событий является методом класса. Например, этот компонент &lt;code&gt;Toggle&lt;/code&gt; отображает кнопку, которая позволяет пользователю переключаться между состояниями &amp;laquo;ON&amp;raquo; и &amp;laquo;OFF&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="01abc8d4d76c5d3b29a56fbabd9fa795ee92ceb3" translate="yes" xml:space="preserve">
          <source>When you design React components, it is usually best to find the &amp;ldquo;minimal representation&amp;rdquo; of state. For example, instead of keeping &lt;code&gt;firstName&lt;/code&gt;, &lt;code&gt;lastName&lt;/code&gt;, and &lt;code&gt;fullName&lt;/code&gt; in state, it&amp;rsquo;s usually better keep only &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt;, and then calculate &lt;code&gt;fullName&lt;/code&gt; during rendering. This lets us avoid mistakes where we update one state but forget the other state.</source>
          <target state="translated">При разработке компонентов React обычно лучше всего найти &amp;laquo;минимальное представление&amp;raquo; состояния. Например, вместо того, чтобы сохранять &lt;code&gt;firstName&lt;/code&gt; , &lt;code&gt;lastName&lt;/code&gt; и &lt;code&gt;fullName&lt;/code&gt; в состоянии, обычно лучше оставить только &lt;code&gt;firstName&lt;/code&gt; и &lt;code&gt;lastName&lt;/code&gt; , а затем вычислить &lt;code&gt;fullName&lt;/code&gt; во время рендеринга. Это позволяет нам избежать ошибок, когда мы обновляем одно состояние, но забываем другое состояние.</target>
        </trans-unit>
        <trans-unit id="0b0e176fb66cf11f7e27af0bcb2e55372392f43e" translate="yes" xml:space="preserve">
          <source>When you don&amp;rsquo;t have stable IDs for rendered items, you may use the item index as a key as a last resort:</source>
          <target state="translated">Если у вас нет стабильных идентификаторов для отображаемых элементов, вы можете использовать индекс элемента в качестве ключа в крайнем случае:</target>
        </trans-unit>
        <trans-unit id="f82a0d500de82ea773a24f53e694f0f8c714eaf2" translate="yes" xml:space="preserve">
          <source>When you don&amp;rsquo;t need any props on the Fragment tag you can use the &lt;a href=&quot;fragments#short-syntax&quot;&gt;short syntax&lt;/a&gt;, if your tooling supports it:</source>
          <target state="translated">Если вам не нужны никакие реквизиты для тега Fragment, вы можете использовать &lt;a href=&quot;fragments#short-syntax&quot;&gt;короткий синтаксис&lt;/a&gt; , если ваш инструментарий его поддерживает:</target>
        </trans-unit>
        <trans-unit id="1f5d758f7a13f26df949720818e29795ba408fea" translate="yes" xml:space="preserve">
          <source>When you need to handle multiple controlled &lt;code&gt;input&lt;/code&gt; elements, you can add a &lt;code&gt;name&lt;/code&gt; attribute to each element and let the handler function choose what to do based on the value of &lt;code&gt;event.target.name&lt;/code&gt;.</source>
          <target state="translated">Когда вам нужно обрабатывать несколько контролируемых элементов &lt;code&gt;input&lt;/code&gt; , вы можете добавить атрибут &lt;code&gt;name&lt;/code&gt; к каждому элементу и позволить функции-обработчику выбирать, что делать, на основе значения &lt;code&gt;event.target.name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c75b2134369a0a04fe58dd9360ac61d55ca554e4" translate="yes" xml:space="preserve">
          <source>When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent:</source>
          <target state="translated">Когда вы передаете строковый литерал,его значение является HTML-уничтоженным.Таким образом,эти два JSX выражения эквивалентны:</target>
        </trans-unit>
        <trans-unit id="231c33cc0825db7915ff2676aa0c0c45eb40c0bc" translate="yes" xml:space="preserve">
          <source>When you run this code, you&amp;rsquo;ll be given a warning that a key should be provided for list items. A &amp;ldquo;key&amp;rdquo; is a special string attribute you need to include when creating lists of elements. We&amp;rsquo;ll discuss why it&amp;rsquo;s important in the next section.</source>
          <target state="translated">Когда вы запустите этот код, вы получите предупреждение о том, что для элементов списка должен быть предоставлен ключ. &amp;laquo;Ключ&amp;raquo; - это специальный строковый атрибут, который необходимо включать при создании списков элементов. В следующем разделе мы обсудим, почему это важно.</target>
        </trans-unit>
        <trans-unit id="392e1c61d6fc0a80b224eb56286bbae56068d9da" translate="yes" xml:space="preserve">
          <source>When you see something wrong in the UI, you can use &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; to inspect the props and move up the tree until you find the component responsible for updating the state. This lets you trace the bugs to their source:</source>
          <target state="translated">Когда вы видите, что в пользовательском интерфейсе что-то не так, вы можете использовать &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; для проверки свойств и перемещения вверх по дереву, пока не найдете компонент, ответственный за обновление состояния. Это позволяет отслеживать ошибки до их источника:</target>
        </trans-unit>
        <trans-unit id="e6c278736c7925bc9c4014f782054c15bd13051c" translate="yes" xml:space="preserve">
          <source>When you use React, at a single point in time you can think of the &lt;code&gt;render()&lt;/code&gt; function as creating a tree of React elements. On the next state or props update, that &lt;code&gt;render()&lt;/code&gt; function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree.</source>
          <target state="translated">Когда вы используете React, в какой-то момент вы можете думать о функции &lt;code&gt;render()&lt;/code&gt; как о создании дерева элементов React. При следующем обновлении состояния или свойств эта функция &lt;code&gt;render()&lt;/code&gt; вернет другое дерево элементов React. Затем React необходимо выяснить, как эффективно обновить пользовательский интерфейс, чтобы он соответствовал самому последнему дереву.</target>
        </trans-unit>
        <trans-unit id="3918d1668774c6039a7d4c11830322620a548fcf" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to deploy to production, running &lt;code&gt;npm run build&lt;/code&gt; will create an optimized build of your app in the &lt;code&gt;build&lt;/code&gt; folder. You can learn more about Create React App &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#create-react-app--&quot;&gt;from its README&lt;/a&gt; and the &lt;a href=&quot;https://facebook.github.io/create-react-app/&quot;&gt;User Guide&lt;/a&gt;.</source>
          <target state="translated">Когда вы будете готовы к развертыванию в производственной среде , запуск &lt;code&gt;npm run build&lt;/code&gt; создаст оптимизированную сборку вашего приложения в папке &lt;code&gt;build&lt;/code&gt; . Вы можете узнать больше о Create React App &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#create-react-app--&quot;&gt;из README&lt;/a&gt; и &lt;a href=&quot;https://facebook.github.io/create-react-app/&quot;&gt;Руководства пользователя&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bebff40c8b08402b37ab557fa24c08cc19a40f98" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, we&amp;rsquo;d encourage you to start trying Hooks in new components you write. Make sure everyone on your team is on board with using them and familiar with this documentation. We don&amp;rsquo;t recommend rewriting your existing classes to Hooks unless you planned to rewrite them anyway (e.g. to fix bugs).</source>
          <target state="translated">Когда вы будете готовы, мы рекомендуем вам начать пробовать хуки в новых компонентах, которые вы пишете. Убедитесь, что все в вашей команде готовы их использовать и знакомы с этой документацией. Мы не рекомендуем переписывать существующие классы в хуки, если вы все равно не планируете их переписывать (например, для исправления ошибок).</target>
        </trans-unit>
        <trans-unit id="60ca1c6e2220d3dcd5eb8ee37e9e869e14d685d1" translate="yes" xml:space="preserve">
          <source>Whenever the root elements have different types, React will tear down the old tree and build the new tree from scratch. Going from &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;, or from &lt;code&gt;&amp;lt;Article&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;Comment&amp;gt;&lt;/code&gt;, or from &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; - any of those will lead to a full rebuild.</source>
          <target state="translated">Всякий раз, когда корневые элементы имеют разные типы, React срывает старое дерево и строит новое дерево с нуля. Переход от &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; к &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; , или от &lt;code&gt;&amp;lt;Article&amp;gt;&lt;/code&gt; к &lt;code&gt;&amp;lt;Comment&amp;gt;&lt;/code&gt; , или от &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; к &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; - любой из них приведет к полной перестройке.</target>
        </trans-unit>
        <trans-unit id="6dd9bbf6973367e79eeae18b9bbda9418cafb732" translate="yes" xml:space="preserve">
          <source>Whenever you get confused by something in JavaScript, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;MDN&lt;/a&gt; and &lt;a href=&quot;https://javascript.info/&quot;&gt;javascript.info&lt;/a&gt; are great websites to check. There are also &lt;a href=&quot;https://reactjs.org/community/support.html&quot;&gt;community support forums&lt;/a&gt; where you can ask for help.</source>
          <target state="translated">Если вас что-то смущает в JavaScript, лучше всего проверить &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;MDN&lt;/a&gt; и &lt;a href=&quot;https://javascript.info/&quot;&gt;javascript.info&lt;/a&gt; . Есть также &lt;a href=&quot;https://reactjs.org/community/support.html&quot;&gt;форумы поддержки сообщества,&lt;/a&gt; где вы можете попросить о помощи.</target>
        </trans-unit>
        <trans-unit id="c8f9e5d66d270d8259063ea04783c1ae12b8c1c6" translate="yes" xml:space="preserve">
          <source>Where Does the Update Happen?</source>
          <target state="translated">Где происходит обновление?</target>
        </trans-unit>
        <trans-unit id="ef742a7bbdd48469bd1b3855fd8bf22859df98d5" translate="yes" xml:space="preserve">
          <source>Where in the component lifecycle should I make an AJAX call?</source>
          <target state="translated">Где в течение жизненного цикла компонентов я должен сделать AJAX звонок?</target>
        </trans-unit>
        <trans-unit id="ae2b962ed56663e8ecdd89ac3430db8cddb1f349" translate="yes" xml:space="preserve">
          <source>Where required, using your keyboard arrow keys to interact with some elements, such as menus and dropdowns.</source>
          <target state="translated">При необходимости используйте клавиши со стрелками клавиатуры для взаимодействия с некоторыми элементами,такими как меню и раскрывающиеся списки.</target>
        </trans-unit>
        <trans-unit id="88a90f10ab7ebe7a5678e36f1ceddd076dd13ba2" translate="yes" xml:space="preserve">
          <source>Where to Place Error Boundaries</source>
          <target state="translated">Где разместить границы ошибок?</target>
        </trans-unit>
        <trans-unit id="5efb59c3c22d68fc4a99b342c9b256a6b2820f68" translate="yes" xml:space="preserve">
          <source>Whereas a component transforms props into UI, a higher-order component transforms a component into another component.</source>
          <target state="translated">В то время как компонент преобразует стойку в пользовательский интерфейс,компонент более высокого порядка преобразует компонент в другой компонент.</target>
        </trans-unit>
        <trans-unit id="6e766e695d0adc0641fe24c8e239dc1edab04b55" translate="yes" xml:space="preserve">
          <source>Whether or not it&amp;rsquo;s an appropriate tradeoff depends on the situation. But it&amp;rsquo;s a handy tool, especially when the content doesn&amp;rsquo;t change noticeably between items, and the user might not even realize they were looking at a stale version for a second.</source>
          <target state="translated">Будет ли это уместным компромиссом, зависит от ситуации. Но это удобный инструмент, особенно когда содержимое не меняется заметно между элементами, и пользователь может даже не осознавать, что смотрит на устаревшую версию на секунду.</target>
        </trans-unit>
        <trans-unit id="5313bb949a427d6a34ce0619291d083860ef68d3" translate="yes" xml:space="preserve">
          <source>Whether you declare a component &lt;a href=&quot;#function-and-class-components&quot;&gt;as a function or a class&lt;/a&gt;, it must never modify its own props. Consider this &lt;code&gt;sum&lt;/code&gt; function:</source>
          <target state="translated">Независимо от того, объявляете ли вы компонент &lt;a href=&quot;#function-and-class-components&quot;&gt;как функцию или класс&lt;/a&gt; , он никогда не должен изменять свои собственные свойства. Рассмотрим эту функцию &lt;code&gt;sum&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9cfad9062c1b8c8d17794fcb8f3a2452cc2e5ab6" translate="yes" xml:space="preserve">
          <source>Which versions of React include Hooks?</source>
          <target state="translated">Какие версии React включают Hooks?</target>
        </trans-unit>
        <trans-unit id="911be78ca9d90df9dbf3aeb3c82775a99547aee6" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;this.props&lt;/code&gt; is set up by React itself and &lt;code&gt;this.state&lt;/code&gt; has a special meaning, you are free to add additional fields to the class manually if you need to store something that doesn&amp;rsquo;t participate in the data flow (like a timer ID).</source>
          <target state="translated">Хотя &lt;code&gt;this.props&lt;/code&gt; настраивается самим React, а &lt;code&gt;this.state&lt;/code&gt; имеет особое значение, вы можете добавить дополнительные поля в класс вручную, если вам нужно сохранить что-то, что не участвует в потоке данных (например, идентификатор таймера ).</target>
        </trans-unit>
        <trans-unit id="1aba78d4a4d0f9fe12fa522d168cd8b574a0e353" translate="yes" xml:space="preserve">
          <source>While declaring a variable and using an &lt;code&gt;if&lt;/code&gt; statement is a fine way to conditionally render a component, sometimes you might want to use a shorter syntax. There are a few ways to inline conditions in JSX, explained below.</source>
          <target state="translated">Хотя объявление переменной и использование оператора &lt;code&gt;if&lt;/code&gt; - прекрасный способ условного рендеринга компонента, иногда может потребоваться более короткий синтаксис. Ниже описано несколько способов встроить условия в JSX.</target>
        </trans-unit>
        <trans-unit id="11e78dcc3d744f87f73cd2a47f9767fd1932daf4" translate="yes" xml:space="preserve">
          <source>While it is generally recommended to use unidirectional data flow such as &lt;a href=&quot;lifting-state-up&quot;&gt;React state&lt;/a&gt;, &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, or &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt;, React components can use a model layer from other frameworks and libraries.</source>
          <target state="translated">Хотя обычно рекомендуется использовать однонаправленный поток данных, такой как &lt;a href=&quot;lifting-state-up&quot;&gt;состояние React&lt;/a&gt; , &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; или &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; , компоненты React могут использовать уровень модели из других фреймворков и библиотек.</target>
        </trans-unit>
        <trans-unit id="9cb5eb9a797258730eedaeda45aa9df92fecc85e" translate="yes" xml:space="preserve">
          <source>While the convention for higher-order components is to pass through all props to the wrapped component, this does not work for refs. That&amp;rsquo;s because &lt;code&gt;ref&lt;/code&gt; is not really a prop &amp;mdash; like &lt;code&gt;key&lt;/code&gt;, it&amp;rsquo;s handled specially by React. If you add a ref to an element whose component is the result of a HOC, the ref refers to an instance of the outermost container component, not the wrapped component.</source>
          <target state="translated">Хотя соглашение для компонентов более высокого порядка заключается в том, чтобы передавать все свойства обернутому компоненту, это не работает для ссылок. Это потому, что &lt;code&gt;ref&lt;/code&gt; на самом деле не является опорой - как &lt;code&gt;key&lt;/code&gt; , он специально обрабатывается React. Если вы добавляете ссылку на элемент, компонент которого является результатом HOC, ссылка ссылается на экземпляр самого внешнего компонента контейнера, а не на завернутый компонент.</target>
        </trans-unit>
        <trans-unit id="80619f6a762505ca83687945b18212f2b9eaa056" translate="yes" xml:space="preserve">
          <source>While this is a very important accessibility feature, it is also a technique that should be used judiciously. Use it to repair the keyboard focus flow when it is disturbed, not to try and anticipate how users want to use applications.</source>
          <target state="translated">Несмотря на то,что это очень важная функция доступности,это также и техника,которую следует использовать разумно.Используйте ее для восстановления фокусировки клавиатуры,когда она нарушена,а не для того,чтобы пытаться предугадать,как пользователи хотят использовать приложения.</target>
        </trans-unit>
        <trans-unit id="fd59be0b1a677335857ab70d19708469811c4d18" translate="yes" xml:space="preserve">
          <source>While this is less common, sometimes you might need multiple &amp;ldquo;holes&amp;rdquo; in a component. In such cases you may come up with your own convention instead of using &lt;code&gt;children&lt;/code&gt;:</source>
          <target state="translated">Хотя это встречается реже, иногда вам может потребоваться несколько &amp;laquo;дыр&amp;raquo; в компоненте. В таких случаях вы можете придумать собственное соглашение вместо использования &lt;code&gt;children&lt;/code&gt; элементов :</target>
        </trans-unit>
        <trans-unit id="ceea2b7f2101d3dab298a7e0940196ece8e3cb89" translate="yes" xml:space="preserve">
          <source>While this is not supported today, in the future we plan to let &lt;code&gt;Suspense&lt;/code&gt; handle more scenarios such as data fetching. You can read about this in &lt;a href=&quot;https://reactjs.org/blog/2018/11/27/react-16-roadmap.html&quot;&gt;our roadmap&lt;/a&gt;.</source>
          <target state="translated">Хотя сегодня это не поддерживается, в будущем мы планируем разрешить &lt;code&gt;Suspense&lt;/code&gt; обрабатывать больше сценариев, таких как выборка данных. Вы можете прочитать об этом в &lt;a href=&quot;https://reactjs.org/blog/2018/11/27/react-16-roadmap.html&quot;&gt;нашей дорожной карте&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2a90b6d038e43771f66fdf8ac4ad272e8778019" translate="yes" xml:space="preserve">
          <source>While this is possible today, it can be difficult to orchestrate. In Concurrent Mode, this feature is built-in. React starts preparing the new screen in memory first &amp;mdash; or, as our metaphor goes, &amp;ldquo;on a different branch&amp;rdquo;. So React can wait before updating the DOM so that more content can load. In Concurrent Mode, we can tell React to keep showing the old screen, fully interactive, with an inline loading indicator. And when the new screen is ready, React can take us to it.</source>
          <target state="translated">Хотя сегодня это возможно, это может быть сложно организовать. В параллельном режиме эта функция встроена. React сначала начинает подготовку нового экрана в памяти - или, как говорится в нашей метафоре, &amp;laquo;на другой ветке&amp;raquo;. Поэтому React может подождать перед обновлением DOM, чтобы можно было загрузить больше контента. В параллельном режиме мы можем указать React, чтобы он продолжал показывать старый экран, полностью интерактивный, со встроенным индикатором загрузки. И когда новый экран будет готов, React может нас к нему перенести.</target>
        </trans-unit>
        <trans-unit id="46d7e7d15375515d6dc839c8d2bfd40fc2b4dadb" translate="yes" xml:space="preserve">
          <source>While you could &lt;a href=&quot;#adding-a-ref-to-a-class-component&quot;&gt;add a ref to the child component&lt;/a&gt;, this is not an ideal solution, as you would only get a component instance rather than a DOM node. Additionally, this wouldn&amp;rsquo;t work with function components.</source>
          <target state="translated">Хотя вы можете &lt;a href=&quot;#adding-a-ref-to-a-class-component&quot;&gt;добавить ссылку на дочерний компонент&lt;/a&gt; , это не идеальное решение, поскольку вы получите только экземпляр компонента, а не узел DOM. Кроме того, это не будет работать с функциональными компонентами.</target>
        </trans-unit>
        <trans-unit id="495b742205ad82447d68cc34f99288cca84b04a8" translate="yes" xml:space="preserve">
          <source>While you probably &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;don&amp;rsquo;t need it&lt;/a&gt;, in rare cases that you do (such as implementing a &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; component), you can update the state right during rendering. React will re-run the component with updated state immediately after exiting the first render so it wouldn&amp;rsquo;t be expensive.</source>
          <target state="translated">Хотя вам, вероятно, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;это не нужно&lt;/a&gt; , в редких случаях, когда вы это делаете (например, при реализации компонента &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; ), вы можете обновить состояние прямо во время рендеринга. React повторно запустит компонент с обновленным состоянием сразу после выхода из первого рендеринга, поэтому это не будет дорого.</target>
        </trans-unit>
        <trans-unit id="5ad1fd6b46143604bd95b453287adc7e23e0fcff" translate="yes" xml:space="preserve">
          <source>While you shouldn&amp;rsquo;t need this often, you may expose some imperative methods to a parent component with the &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt;&lt;code&gt;useImperativeHandle&lt;/code&gt;&lt;/a&gt; Hook.</source>
          <target state="translated">Хотя вам это не нужно часто, вы можете предоставить некоторые императивные методы родительскому компоненту с помощью &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt; &lt;code&gt;useImperativeHandle&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fb67a6e3ebb0c4884c03542ed4d02cc6e3b26d7" translate="yes" xml:space="preserve">
          <source>Who Is This Experimental Release For?</source>
          <target state="translated">Для кого этот экспериментальный релиз?</target>
        </trans-unit>
        <trans-unit id="49c3abb6796bdac1acab2ff039684dce6186a9f6" translate="yes" xml:space="preserve">
          <source>Why Accessibility?</source>
          <target state="translated">Почему Доступность?</target>
        </trans-unit>
        <trans-unit id="f8b6dc9d0e248f1aca599f0014bcad47284d99a8" translate="yes" xml:space="preserve">
          <source>Why JSX?</source>
          <target state="translated">Почему JSX?</target>
        </trans-unit>
        <trans-unit id="3fec80c558c9db1e52790dd2506e452dfd97b669" translate="yes" xml:space="preserve">
          <source>Why So Many Modes?</source>
          <target state="translated">Почему так много мод?</target>
        </trans-unit>
        <trans-unit id="ce0a06b1d50f03b0c1677ffc7fc4f387ed59572e" translate="yes" xml:space="preserve">
          <source>Why am I seeing stale props or state inside my function?</source>
          <target state="translated">Почему я вижу черствый реквизит или состояние внутри моей функции?</target>
        </trans-unit>
        <trans-unit id="0492b756ff8e4f6df5b3fc7ff6de3541b68d8908" translate="yes" xml:space="preserve">
          <source>Why does our &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;last Suspense example&lt;/a&gt; log a warning when clicking the &amp;ldquo;Next&amp;rdquo; button?</source>
          <target state="translated">Почему в нашем &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;последнем примере Suspense&lt;/a&gt; выдается предупреждение при нажатии кнопки &amp;laquo;Далее&amp;raquo;?</target>
        </trans-unit>
        <trans-unit id="65762af3a54e62fab1249620c4413deaa6a70304" translate="yes" xml:space="preserve">
          <source>Why doesn&amp;rsquo;t React update &lt;code&gt;this.state&lt;/code&gt; synchronously?</source>
          <target state="translated">Почему React не обновляет &lt;code&gt;this.state&lt;/code&gt; синхронно?</target>
        </trans-unit>
        <trans-unit id="edf9c3c0fe5bd6b0114a879913f827631f515543" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;setState&lt;/code&gt; giving me the wrong value?</source>
          <target state="translated">Почему &lt;code&gt;setState&lt;/code&gt; дает неправильное значение?</target>
        </trans-unit>
        <trans-unit id="148cbb2bff9a010f21a0ad216df38f1c5d2cd471" translate="yes" xml:space="preserve">
          <source>Why is binding necessary at all?</source>
          <target state="translated">Зачем вообще нужна привязка?</target>
        </trans-unit>
        <trans-unit id="f119dd9eafd6f8c4ac0cc157b3a167f93ba90cf5" translate="yes" xml:space="preserve">
          <source>Why is my function being called every time the component renders?</source>
          <target state="translated">Почему моя функция вызывается каждый раз,когда компонент передает?</target>
        </trans-unit>
        <trans-unit id="c2085905cfd406c9e6d8d4068c20801835544c3f" translate="yes" xml:space="preserve">
          <source>Why the &lt;code&gt;crossorigin&lt;/code&gt; Attribute?</source>
          <target state="translated">Почему атрибут &lt;code&gt;crossorigin&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="aab036cb04b8ab29e50f15ba17971446021a2255" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;PropTypes.element&lt;/code&gt; you can specify that only a single child can be passed to a component as children.</source>
          <target state="translated">С помощью &lt;code&gt;PropTypes.element&lt;/code&gt; вы можете указать, что только один дочерний элемент может быть передан компоненту в качестве дочерних.</target>
        </trans-unit>
        <trans-unit id="0b569b9d21bf8d1be58d672f5980773d97d54e66" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, this is not necessary because it binds all methods:</source>
          <target state="translated">С &lt;code&gt;createReactClass()&lt;/code&gt; этом нет необходимости, потому что он связывает все методы:</target>
        </trans-unit>
        <trans-unit id="d4883092ff15971d97a8aa837d13ef100a68d5eb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, you have to provide a separate &lt;code&gt;getInitialState&lt;/code&gt; method that returns the initial state:</source>
          <target state="translated">С &lt;code&gt;createReactClass()&lt;/code&gt; вы должны предоставить отдельный метод &lt;code&gt;getInitialState&lt;/code&gt; , который возвращает начальное состояние:</target>
        </trans-unit>
        <trans-unit id="50f377ba092fa5d0a0d282bc37a4c8ec440e268f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, you need to define &lt;code&gt;getDefaultProps()&lt;/code&gt; as a function on the passed object:</source>
          <target state="translated">С помощью &lt;code&gt;createReactClass()&lt;/code&gt; вам необходимо определить &lt;code&gt;getDefaultProps()&lt;/code&gt; как функцию для переданного объекта:</target>
        </trans-unit>
        <trans-unit id="df984bf31d472187d2e254fc8283606d23024bfe" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;useTransition&lt;/code&gt;, we can opt into showing a Pending state first instead. This will keep us on the previous screen while the next screen is being prepared.</source>
          <target state="translated">С &lt;code&gt;useTransition&lt;/code&gt; мы можем вместо этого сначала показывать состояние Pending. Это будет держать нас на предыдущем экране, пока готовится следующий экран.</target>
        </trans-unit>
        <trans-unit id="0ece6ef7273f365ef2fee3cd6066494eec178a85" translate="yes" xml:space="preserve">
          <source>With Hooks, you can extract stateful logic from a component so it can be tested independently and reused. &lt;strong&gt;Hooks allow you to reuse stateful logic without changing your component hierarchy.&lt;/strong&gt; This makes it easy to share Hooks among many components or with the community.</source>
          <target state="translated">С помощью хуков вы можете извлечь логику с отслеживанием состояния из компонента, чтобы ее можно было тестировать независимо и повторно использовать. &lt;strong&gt;Хуки позволяют повторно использовать логику с отслеживанием состояния без изменения иерархии компонентов. &lt;/strong&gt;Это позволяет легко обмениваться хуками между многими компонентами или сообществом.</target>
        </trans-unit>
        <trans-unit id="3d1aed9937b8f4a875f46194f502d03b524dc6dd" translate="yes" xml:space="preserve">
          <source>With JSX you pass a function as the event handler, rather than a string.</source>
          <target state="translated">С помощью JSX вы передаете функцию в качестве обработчика события,а не строку.</target>
        </trans-unit>
        <trans-unit id="ed4bd933c03f851c13ccd2147932475182887d8e" translate="yes" xml:space="preserve">
          <source>With React, typically you only need to bind the methods you &lt;em&gt;pass&lt;/em&gt; to other components. For example, &lt;code&gt;&amp;lt;button onClick={this.handleClick}&amp;gt;&lt;/code&gt; passes &lt;code&gt;this.handleClick&lt;/code&gt; so you want to bind it. However, it is unnecessary to bind the &lt;code&gt;render&lt;/code&gt; method or the lifecycle methods: we don&amp;rsquo;t pass them to other components.</source>
          <target state="translated">С React обычно вам нужно только привязать методы, которые вы &lt;em&gt;передаете&lt;/em&gt; другим компонентам. Например, &lt;code&gt;&amp;lt;button onClick={this.handleClick}&amp;gt;&lt;/code&gt; передает &lt;code&gt;this.handleClick&lt;/code&gt; , поэтому вы хотите его привязать. Однако связывать метод &lt;code&gt;render&lt;/code&gt; или методы жизненного цикла необязательно : мы не передаем их другим компонентам.</target>
        </trans-unit>
        <trans-unit id="e7344e4dadc3909a3335b74575ebf433ba99c5ed" translate="yes" xml:space="preserve">
          <source>With Suspense, handling fetching errors works the same way as handling rendering errors &amp;mdash; you can render an &lt;a href=&quot;error-boundaries&quot;&gt;error boundary&lt;/a&gt; anywhere to &amp;ldquo;catch&amp;rdquo; errors in components below.</source>
          <target state="translated">С Suspense обработка ошибок выборки работает так же, как обработка ошибок рендеринга - вы можете визуализировать &lt;a href=&quot;error-boundaries&quot;&gt;границу ошибки в&lt;/a&gt; любом месте, чтобы &amp;laquo;поймать&amp;raquo; ошибки в компонентах ниже.</target>
        </trans-unit>
        <trans-unit id="9efd00870544783d51928530a161bc172e3d880f" translate="yes" xml:space="preserve">
          <source>With Suspense, we still start fetching first, but we flip the last two steps around:</source>
          <target state="translated">С Suspense,мы все еще начинаем забирать первым,но мы переворачиваем последние два шага:</target>
        </trans-unit>
        <trans-unit id="71a13a4bc9a257a4e9bafbaa0cf86edb5925dd2a" translate="yes" xml:space="preserve">
          <source>With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. For example, if we wanted to enforce that names are written with all uppercase letters, we could write &lt;code&gt;handleChange&lt;/code&gt; as:</source>
          <target state="translated">С управляемым компонентом каждая мутация состояния будет иметь связанную функцию-обработчик. Это упрощает изменение или проверку введенных пользователем данных. Например, если мы хотим, чтобы имена писались заглавными буквами, мы могли бы написать &lt;code&gt;handleChange&lt;/code&gt; как:</target>
        </trans-unit>
        <trans-unit id="33f666c5c50a02b68cc5f1089d8d956529654dee" translate="yes" xml:space="preserve">
          <source>With a controlled component, the input&amp;rsquo;s value is always driven by the React state. While this means you have to type a bit more code, you can now pass the value to other UI elements too, or reset it from other event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67500667906c2a530542da2c6f7b33bdea261d21" translate="yes" xml:space="preserve">
          <source>With functions and ES6 classes &lt;code&gt;defaultProps&lt;/code&gt; is defined as a property on the component itself:</source>
          <target state="translated">В функциях и классах ES6 &lt;code&gt;defaultProps&lt;/code&gt; определяется как свойство самого компонента:</target>
        </trans-unit>
        <trans-unit id="88886f54534112497ad51083107a11f86e743c51" translate="yes" xml:space="preserve">
          <source>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4872f49b4f73a2d9aa1f1ea9382a37bb1b4523" translate="yes" xml:space="preserve">
          <source>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to &lt;code&gt;ReactDOM.render()&lt;/code&gt;.</source>
          <target state="translated">Насколько нам известно, единственный способ обновить пользовательский интерфейс - создать новый элемент и передать его в &lt;code&gt;ReactDOM.render()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="061b1b684b37fa6e01cf5d46650b25478b6d35f1" translate="yes" xml:space="preserve">
          <source>With that out of the way, let&amp;rsquo;s get started!</source>
          <target state="translated">Разобравшись с этим, приступим!</target>
        </trans-unit>
        <trans-unit id="e970431e1cb945a83be8e8c9ff751a9c325a5c21" translate="yes" xml:space="preserve">
          <source>With the example above, the &lt;code&gt;Post&lt;/code&gt; component can read &lt;code&gt;props.id&lt;/code&gt;, but not &lt;code&gt;props.key&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере компонент &lt;code&gt;Post&lt;/code&gt; может читать &lt;code&gt;props.id&lt;/code&gt; , но не &lt;code&gt;props.key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7a845306b0978a35ad4c18a5ccd1c03f8079bcf" translate="yes" xml:space="preserve">
          <source>With this approach, we can &lt;strong&gt;fetch code and data in parallel&lt;/strong&gt;. When we navigate between pages, we don&amp;rsquo;t need to wait for a page&amp;rsquo;s code to load to start loading its data. We can start fetching both code and data at the same time (during the link click), delivering a much better user experience.</source>
          <target state="translated">При таком подходе мы можем &lt;strong&gt;получать код и данные параллельно&lt;/strong&gt; . Когда мы перемещаемся между страницами, нам не нужно ждать загрузки кода страницы, чтобы начать загрузку данных. Мы можем начать получение кода и данных одновременно (во время щелчка по ссылке), что значительно повысит удобство работы пользователей.</target>
        </trans-unit>
        <trans-unit id="ca794ea7a32fb93f5c86146905ba234d1fd33e3a" translate="yes" xml:space="preserve">
          <source>With this change, even though we&amp;rsquo;re in the Pending state, we don&amp;rsquo;t display any indication to the user until 500ms has passed. This may not seem like much of an improvement when the API responses are slow. But compare how it feels &lt;a href=&quot;https://codesandbox.io/s/thirsty-liskov-1ygph&quot;&gt;before&lt;/a&gt; and &lt;a href=&quot;https://codesandbox.io/s/hardcore-http-s18xr&quot;&gt;after&lt;/a&gt; when the API call is fast. Even though the rest of the code hasn&amp;rsquo;t changed, suppressing a &amp;ldquo;too fast&amp;rdquo; loading state improves the perceived performance by not calling attention to the delay.</source>
          <target state="translated">Благодаря этому изменению, даже несмотря на то, что мы находимся в состоянии ожидания, мы не показываем пользователю никаких указаний, пока не пройдет 500 мс. Это может показаться незначительным улучшением, когда ответы API медленные. Но сравните, каково это &lt;a href=&quot;https://codesandbox.io/s/thirsty-liskov-1ygph&quot;&gt;до&lt;/a&gt; и &lt;a href=&quot;https://codesandbox.io/s/hardcore-http-s18xr&quot;&gt;после&lt;/a&gt; быстрого вызова API. Несмотря на то, что остальная часть кода не изменилась, подавление &amp;laquo;слишком быстрого&amp;raquo; состояния загрузки улучшает воспринимаемую производительность, не обращая внимания на задержку.</target>
        </trans-unit>
        <trans-unit id="5635b27b3f3a955ac587a6317f7e72991a8317f4" translate="yes" xml:space="preserve">
          <source>With this change, it works as expected. We can type into the input immediately, and the translation later &amp;ldquo;catches up&amp;rdquo; to what we have typed.</source>
          <target state="translated">С этим изменением все работает должным образом. Мы можем вводить текст сразу же, и перевод позже &amp;laquo;догонит&amp;raquo; то, что мы набрали.</target>
        </trans-unit>
        <trans-unit id="ce08b851d8dd00fc80cae81cb3eb7b40fcfc82a3" translate="yes" xml:space="preserve">
          <source>With this change, only the top-most Page component needs to know about the &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Avatar&lt;/code&gt; components&amp;rsquo; use of &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt;.</source>
          <target state="translated">С этим изменением только самый верхний компонент Page должен знать об использовании компонентами &lt;code&gt;Link&lt;/code&gt; и &lt;code&gt;Avatar&lt;/code&gt; &lt;code&gt;user&lt;/code&gt; и &lt;code&gt;avatarSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eccd6c7aebe3ee7b1033ca2e41432db51ce2ee2" translate="yes" xml:space="preserve">
          <source>Wrap Lazy Features in &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Оберните ленивые функции в &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a87b9174801725911157c6c5b05263b9d0b4efa5" translate="yes" xml:space="preserve">
          <source>Wrapping setState in a Transition</source>
          <target state="translated">Обертывание сетСтат в переходе</target>
        </trans-unit>
        <trans-unit id="560b6056cd03b4bbd6db601b466123014a92c0b9" translate="yes" xml:space="preserve">
          <source>Writing Conversion Functions</source>
          <target state="translated">Функции преобразования для записи</target>
        </trans-unit>
        <trans-unit id="62d53daf650bb95bca68a82e9c932fea369dd88e" translate="yes" xml:space="preserve">
          <source>Yes! The &lt;a href=&quot;hooks-reference#useref&quot;&gt;&lt;code&gt;useRef()&lt;/code&gt;&lt;/a&gt; Hook isn&amp;rsquo;t just for DOM refs. The &amp;ldquo;ref&amp;rdquo; object is a generic container whose &lt;code&gt;current&lt;/code&gt; property is mutable and can hold any value, similar to an instance property on a class.</source>
          <target state="translated">Да! &lt;a href=&quot;hooks-reference#useref&quot;&gt; &lt;code&gt;useRef()&lt;/code&gt; &lt;/a&gt; Крюк не только для DOM рефов. Объект &amp;laquo;ref&amp;raquo; - ​​это универсальный контейнер, &lt;code&gt;current&lt;/code&gt; свойство которого изменяемо и может содержать любое значение, подобно свойству экземпляра в классе.</target>
        </trans-unit>
        <trans-unit id="d3e5b9e5308a5e4ac25712b025d561cb9020c6ad" translate="yes" xml:space="preserve">
          <source>Yes, see the docs on styling &lt;a href=&quot;dom-elements#style&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Да, см. Документацию по стилю &lt;a href=&quot;dom-elements#style&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c94219b317ac261806da31fa074e0f23cb0d9f1" translate="yes" xml:space="preserve">
          <source>Yes. See &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;conditionally firing an effect&lt;/a&gt;. Note that forgetting to handle updates often &lt;a href=&quot;hooks-effect#explanation-why-effects-run-on-each-update&quot;&gt;introduces bugs&lt;/a&gt;, which is why this isn&amp;rsquo;t the default behavior.</source>
          <target state="translated">Да. См. &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;Условное срабатывание эффекта&lt;/a&gt; . Обратите внимание, что забывание обрабатывать обновления часто &lt;a href=&quot;hooks-effect#explanation-why-effects-run-on-each-update&quot;&gt;приводит к ошибкам&lt;/a&gt; , поэтому это не поведение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4dcce6c1701948f7d9bfd3db4ed94bd67e027e5c" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;don&amp;rsquo;t have to&lt;/strong&gt; use many state variables. State variables can hold objects and arrays just fine, so you can still group related data together. However, unlike &lt;code&gt;this.setState&lt;/code&gt; in a class, updating a state variable always &lt;em&gt;replaces&lt;/em&gt; it instead of merging it.</source>
          <target state="translated">Вам &lt;strong&gt;не нужно&lt;/strong&gt; использовать много переменных состояния. Переменные состояния могут прекрасно удерживать объекты и массивы, поэтому вы все равно можете группировать связанные данные вместе. Однако, в отличие от &lt;code&gt;this.setState&lt;/code&gt; в классе, обновление переменной состояния всегда &lt;em&gt;заменяет&lt;/em&gt; ее, а не объединяет.</target>
        </trans-unit>
        <trans-unit id="9a4b1f324495e2f088e3d6f0cdc9f89fb5cd9262" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;may call &lt;code&gt;setState()&lt;/code&gt; immediately&lt;/strong&gt; in &lt;code&gt;componentDidMount()&lt;/code&gt;. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the &lt;code&gt;render()&lt;/code&gt; will be called twice in this case, the user won&amp;rsquo;t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the &lt;code&gt;constructor()&lt;/code&gt; instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.</source>
          <target state="translated">Вы &lt;strong&gt;можете позвонить &lt;code&gt;setState()&lt;/code&gt; непосредственно&lt;/strong&gt; в &lt;code&gt;componentDidMount()&lt;/code&gt; . Это вызовет дополнительный рендеринг, но это произойдет до того, как браузер обновит экран. Это гарантирует, что даже если &lt;code&gt;render()&lt;/code&gt; будет вызываться дважды в этом случае, пользователь не увидит промежуточное состояние. Используйте этот шаблон с осторожностью, поскольку он часто вызывает проблемы с производительностью. В большинстве случаев вместо этого вы можете назначить начальное состояние в &lt;code&gt;constructor()&lt;/code&gt; . Однако это может быть необходимо для таких случаев, как модальные окна и всплывающие подсказки, когда вам нужно измерить узел DOM перед рендерингом чего-то, что зависит от его размера или положения.</target>
        </trans-unit>
        <trans-unit id="0fffd92980fb270dfc644a9073a729e972320668" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;may call &lt;code&gt;setState()&lt;/code&gt; immediately&lt;/strong&gt; in &lt;code&gt;componentDidUpdate()&lt;/code&gt; but note that &lt;strong&gt;it must be wrapped in a condition&lt;/strong&gt; like in the example above, or you&amp;rsquo;ll cause an infinite loop. It would also cause an extra re-rendering which, while not visible to the user, can affect the component performance. If you&amp;rsquo;re trying to &amp;ldquo;mirror&amp;rdquo; some state to a prop coming from above, consider using the prop directly instead. Read more about &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;why copying props into state causes bugs&lt;/a&gt;.</source>
          <target state="translated">Вы &lt;strong&gt;можете вызвать &lt;code&gt;setState()&lt;/code&gt; сразу&lt;/strong&gt; в &lt;code&gt;componentDidUpdate()&lt;/code&gt; но обратите внимание, что &lt;strong&gt;он должен быть заключен в условие,&lt;/strong&gt; подобное приведенному выше примеру, иначе вы вызовете бесконечный цикл. Это также приведет к дополнительному повторному рендерингу, который, хотя и не будет виден пользователю, может повлиять на производительность компонента. Если вы пытаетесь &amp;laquo;отразить&amp;raquo; какое-то состояние опоры, исходящей сверху, рассмотрите возможность использования опоры напрямую. Узнайте больше о том, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;почему копирование свойств в состояние вызывает ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="603dad85523484256e65c5bb07930c069dda7af2" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;should not call &lt;code&gt;setState()&lt;/code&gt;&lt;/strong&gt; in &lt;code&gt;componentWillUnmount()&lt;/code&gt; because the component will never be re-rendered. Once a component instance is unmounted, it will never be mounted again.</source>
          <target state="translated">Вы &lt;strong&gt;не должны вызывать &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt; в &lt;code&gt;componentWillUnmount()&lt;/code&gt; потому что компонент никогда не будет повторно отрисован. После размонтирования экземпляра компонента он больше не будет монтироваться.</target>
        </trans-unit>
        <trans-unit id="303da79a4d02468a439c95546cb936fc2ff452ef" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;should not call &lt;code&gt;setState()&lt;/code&gt;&lt;/strong&gt; in the &lt;code&gt;constructor()&lt;/code&gt;. Instead, if your component needs to use local state, &lt;strong&gt;assign the initial state to &lt;code&gt;this.state&lt;/code&gt;&lt;/strong&gt; directly in the constructor:</source>
          <target state="translated">Вы &lt;strong&gt;не должны вызывать &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt; в &lt;code&gt;constructor()&lt;/code&gt; . Вместо этого, если вашему компоненту необходимо использовать локальное состояние, &lt;strong&gt;присвойте начальное состояние &lt;code&gt;this.state&lt;/code&gt; &lt;/strong&gt; непосредственно в конструкторе:</target>
        </trans-unit>
        <trans-unit id="b1f32119d9afed969fb6dda4b28934eeedec90f3" translate="yes" xml:space="preserve">
          <source>You Might Not Need a Toolchain</source>
          <target state="translated">Тебе не нужна цепь для инструментов.</target>
        </trans-unit>
        <trans-unit id="67b66c50d30ba90262826fe97b9b36429e378815" translate="yes" xml:space="preserve">
          <source>You are now ready to code! We recommend to check out the following resources to learn more about TypeScript:</source>
          <target state="translated">Теперь вы готовы к кодированию! Мы рекомендуем ознакомиться со следующими ресурсами,чтобы узнать больше о TypeScript:</target>
        </trans-unit>
        <trans-unit id="973e5c03c0fd9a741a0042c982cebb565ec5f9df" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;add-react-to-a-website&quot;&gt;add React to an HTML page in one minute&lt;/a&gt;. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.</source>
          <target state="translated">Вы можете &lt;a href=&quot;add-react-to-a-website&quot;&gt;добавить React на HTML-страницу за одну минуту&lt;/a&gt; . Затем вы можете постепенно расширять его присутствие или оставить его в нескольких динамических виджетах.</target>
        </trans-unit>
        <trans-unit id="daa0979344c5bce99fe8cd2033a94efe89e8fc6a" translate="yes" xml:space="preserve">
          <source>You can also add a wrapper DOM node in your component and attach a ref directly to it.</source>
          <target state="translated">Вы также можете добавить оберточный DOM-узел в ваш компонент и прикрепить ссылку непосредственно к нему.</target>
        </trans-unit>
        <trans-unit id="349b87f9aabf27468c7550f23c44ba9943c43e8f" translate="yes" xml:space="preserve">
          <source>You can also add it to an &lt;strong&gt;existing Create React App project&lt;/strong&gt;, &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/adding-typescript&quot;&gt;as documented here&lt;/a&gt;.</source>
          <target state="translated">Вы также можете добавить его в &lt;strong&gt;существующий проект Create React App&lt;/strong&gt; , &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/adding-typescript&quot;&gt;как описано здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc81e5ea9298f4348d258492ffdc2b7046f666c1" translate="yes" xml:space="preserve">
          <source>You can also check out the &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API reference&lt;/a&gt; and the &lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ&lt;/a&gt;.</source>
          <target state="translated">Вы также можете ознакомиться со &lt;a href=&quot;hooks-reference&quot;&gt;справочником&lt;/a&gt; по Hooks API и &lt;a href=&quot;hooks-faq&quot;&gt;FAQ&lt;/a&gt; по хукам .</target>
        </trans-unit>
        <trans-unit id="9d10268304c0a25dd7504dbf0c423bd8a4ff9a0c" translate="yes" xml:space="preserve">
          <source>You can also create the initial state lazily. To do this, you can pass an &lt;code&gt;init&lt;/code&gt; function as the third argument. The initial state will be set to &lt;code&gt;init(initialArg)&lt;/code&gt;.</source>
          <target state="translated">Вы также можете лениво создать начальное состояние. Для этого вы можете передать функцию &lt;code&gt;init&lt;/code&gt; в качестве третьего аргумента. Начальное состояние будет установлено на &lt;code&gt;init(initialArg)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ce8997748b7b364b2a5b8fa6eb06cb5298fac78" translate="yes" xml:space="preserve">
          <source>You can also follow the &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs account&lt;/a&gt; on Twitter, but you won&amp;rsquo;t miss anything essential if you only read the blog.</source>
          <target state="translated">Вы также можете подписаться на &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;аккаунт @reactjs&lt;/a&gt; в Twitter, но вы не пропустите ничего существенного, если будете читать только блог.</target>
        </trans-unit>
        <trans-unit id="c56670d911da74ad4acea3f7f57edb7a5fe3c872" translate="yes" xml:space="preserve">
          <source>You can also pick specific props that your component will consume while passing all other props using the spread operator.</source>
          <target state="translated">Вы также можете выбрать конкретные реквизиты,которые ваш компонент будет потреблять при прохождении всех остальных реквизитов с помощью оператора разбрасывания.</target>
        </trans-unit>
        <trans-unit id="e229f290934869795a385808e0402ed8f11b8ceb" translate="yes" xml:space="preserve">
          <source>You can also refer to a React component using dot-notation from within JSX. This is convenient if you have a single module that exports many React components. For example, if &lt;code&gt;MyComponents.DatePicker&lt;/code&gt; is a component, you can use it directly from JSX with:</source>
          <target state="translated">Вы также можете ссылаться на компонент React, используя точечную нотацию из JSX. Это удобно, если у вас есть один модуль, который экспортирует множество компонентов React. Например, если &lt;code&gt;MyComponents.DatePicker&lt;/code&gt; является компонентом, вы можете использовать его непосредственно из JSX с помощью:</target>
        </trans-unit>
        <trans-unit id="8623b3d7d4d43f6c6f405c02d8001ad9f14ba623" translate="yes" xml:space="preserve">
          <source>You can also rewrite code that mutates objects to avoid mutation, in a similar way. For example, let&amp;rsquo;s say we have an object named &lt;code&gt;colormap&lt;/code&gt; and we want to write a function that changes &lt;code&gt;colormap.right&lt;/code&gt; to be &lt;code&gt;'blue'&lt;/code&gt;. We could write:</source>
          <target state="translated">Вы также можете переписать код, который изменяет объекты, чтобы избежать мутации, аналогичным образом. Например, предположим, что у нас есть объект с именем &lt;code&gt;colormap&lt;/code&gt; , и мы хотим написать функцию, которая изменяет &lt;code&gt;colormap.right&lt;/code&gt; на &lt;code&gt;'blue'&lt;/code&gt; . Мы могли бы написать:</target>
        </trans-unit>
        <trans-unit id="6e352e946162df801daa33ab297c25026fd93b28" translate="yes" xml:space="preserve">
          <source>You can also see the filenames and line numbers in the component stack trace. This works by default in &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; projects:</source>
          <target state="translated">Вы также можете увидеть имена файлов и номера строк в трассировке стека компонентов. Это работает по умолчанию в проектах &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="44310bf2359ee79a622ac37b32c6721ba10337eb" translate="yes" xml:space="preserve">
          <source>You can also traverse the output to find specific nodes and make assertions about them.</source>
          <target state="translated">Вы также можете проследить выходные данные,чтобы найти определенные узлы и сделать утверждения о них.</target>
        </trans-unit>
        <trans-unit id="7d16f115884d19dbbe73652d9e5c447e2ecf104b" translate="yes" xml:space="preserve">
          <source>You can also use an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt; to define a component:</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;класс ES6&lt;/a&gt; для определения компонента:</target>
        </trans-unit>
        <trans-unit id="6fd4f33bcd9d3c0110be7b31954290c1a836db0c" translate="yes" xml:space="preserve">
          <source>You can also use it with the shorthand &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; syntax. For more information, see &lt;a href=&quot;https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html&quot;&gt;React v16.2.0: Improved Support for Fragments&lt;/a&gt;.</source>
          <target state="translated">Вы также можете использовать его с сокращенным синтаксисом &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; . Для получения дополнительной информации см. &lt;a href=&quot;https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html&quot;&gt;React v16.2.0: улучшенная поддержка фрагментов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3aeee99f3a099cb1560c2cd739565a340f73dde" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://github.com/dylanb/react-axe&quot;&gt;react-axe&lt;/a&gt; module to report these accessibility findings directly to the console while developing and debugging.</source>
          <target state="translated">Вы также можете использовать модуль &lt;a href=&quot;https://github.com/dylanb/react-axe&quot;&gt;react-ax,&lt;/a&gt; чтобы сообщать об этих результатах доступности непосредственно в консоль во время разработки и отладки.</target>
        </trans-unit>
        <trans-unit id="0eed65ed081006404dbb7accb393e90c7e592705" translate="yes" xml:space="preserve">
          <source>You can also use the self-closing form of the tag if there are no children. So:</source>
          <target state="translated">Вы также можете использовать самозакрывающуюся форму метки,если нет детей.Так что..:</target>
        </trans-unit>
        <trans-unit id="9295f68bc1efa13ff8ed4a3e2fdaca0db413bd6c" translate="yes" xml:space="preserve">
          <source>You can also write your own integration for a data fetching library, if you&amp;rsquo;d like.</source>
          <target state="translated">Вы также можете написать свою собственную интеграцию для библиотеки выборки данных, если хотите.</target>
        </trans-unit>
        <trans-unit id="d0e2eed831e6bee471a1b051322603084a6ff5dd" translate="yes" xml:space="preserve">
          <source>You can always refer to our public GitHub repository&amp;rsquo;s &lt;a href=&quot;https://github.com/facebook/react/commits/master&quot;&gt;history&lt;/a&gt; for a comprehensive list of changes.</source>
          <target state="translated">Вы всегда можете обратиться к &lt;a href=&quot;https://github.com/facebook/react/commits/master&quot;&gt;истории&lt;/a&gt; нашего общедоступного репозитория GitHub за исчерпывающим списком изменений.</target>
        </trans-unit>
        <trans-unit id="b009a9003a97078d2cc35e3df5d168b43b897374" translate="yes" xml:space="preserve">
          <source>You can build collections of elements and &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;include them in JSX&lt;/a&gt; using curly braces &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">Вы можете создавать коллекции элементов и &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;включать их в JSX,&lt;/a&gt; используя фигурные скобки &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aef58e0c6c697aada939945a0796364fbd8020a1" translate="yes" xml:space="preserve">
          <source>You can build top-down or bottom-up. That is, you can either start with building the components higher up in the hierarchy (i.e. starting with &lt;code&gt;FilterableProductTable&lt;/code&gt;) or with the ones lower in it (&lt;code&gt;ProductRow&lt;/code&gt;). In simpler examples, it&amp;rsquo;s usually easier to go top-down, and on larger projects, it&amp;rsquo;s easier to go bottom-up and write tests as you build.</source>
          <target state="translated">Вы можете строить сверху вниз или снизу вверх. То есть вы можете начать с построения компонентов выше в иерархии (т. &lt;code&gt;ProductRow&lt;/code&gt; Начиная с &lt;code&gt;FilterableProductTable&lt;/code&gt; ) или с компонентов ниже ( ProductRow ). В более простых примерах обычно проще идти сверху вниз, а в более крупных проектах легче идти снизу вверх и писать тесты по мере сборки.</target>
        </trans-unit>
        <trans-unit id="ced09d20e0733b6dd23b81aeb615198bfbc46731" translate="yes" xml:space="preserve">
          <source>You can compare these two examples to feel the difference:</source>
          <target state="translated">Вы можете сравнить эти два примера,чтобы почувствовать разницу:</target>
        </trans-unit>
        <trans-unit id="96723e62d1953ac566e2ea02b39f6c1b0247dd57" translate="yes" xml:space="preserve">
          <source>You can continue to use the exact same APIs as you always have; they&amp;rsquo;ll continue to work.</source>
          <target state="translated">Вы можете продолжать использовать те же самые API, что и раньше; они будут продолжать работать.</target>
        </trans-unit>
        <trans-unit id="65b678af9f2bf41e57cf3a9425ebf0baf1058ffd" translate="yes" xml:space="preserve">
          <source>You can control how many loading states are visible at once with the &lt;code&gt;tail&lt;/code&gt; prop. If we specify &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt;, we&amp;rsquo;ll see &lt;em&gt;at most one&lt;/em&gt; fallback at a time. You can play with it &lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568c5b42327ce78962e0349e0bc941c13aa391bb" translate="yes" xml:space="preserve">
          <source>You can control how many loading states are visible at once with the &lt;code&gt;tail&lt;/code&gt; prop. If we specify &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt;, we&amp;rsquo;ll see &lt;em&gt;at most one&lt;/em&gt; fallback at the time. You can play with it &lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Вы можете контролировать количество видимых состояний загрузки одновременно с помощью &lt;code&gt;tail&lt;/code&gt; опоры. Если мы укажем &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt; , мы увидим &lt;em&gt;не более одного&lt;/em&gt; отката за раз. Вы можете поиграть с ним &lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="259f2bd3a3238bf87405bdcfaaa102614b981ebf" translate="yes" xml:space="preserve">
          <source>You can convert a function component like &lt;code&gt;Clock&lt;/code&gt; to a class in five steps:</source>
          <target state="translated">Вы можете преобразовать функциональный компонент, такой как &lt;code&gt;Clock&lt;/code&gt; , в класс за пять шагов:</target>
        </trans-unit>
        <trans-unit id="99aa21f209e1d4380b74a754381c1adecc7d6d46" translate="yes" xml:space="preserve">
          <source>You can define default values for your &lt;code&gt;props&lt;/code&gt; by assigning to the special &lt;code&gt;defaultProps&lt;/code&gt; property:</source>
          <target state="translated">Вы можете определить значения по умолчанию для ваших &lt;code&gt;props&lt;/code&gt; , назначив специальному свойству &lt;code&gt;defaultProps&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="060ad8196b66eae31d457e14f600fdc295c2b991" translate="yes" xml:space="preserve">
          <source>You can enable strict mode for any part of your application. For example:</source>
          <target state="translated">Вы можете включить строгий режим для любой части вашего приложения.Например:</target>
        </trans-unit>
        <trans-unit id="31a484513ad8dd340d05d4eedab4cba055bb08f5" translate="yes" xml:space="preserve">
          <source>You can even set the function&amp;rsquo;s &lt;code&gt;displayName&lt;/code&gt; property to include the component you&amp;rsquo;re wrapping:</source>
          <target state="translated">Вы даже можете установить свойство &lt;code&gt;displayName&lt;/code&gt; функции, чтобы включить компонент, который вы обертываете:</target>
        </trans-unit>
        <trans-unit id="4d4cf37b373742281f14985d8f8a9c6a764f4af0" translate="yes" xml:space="preserve">
          <source>You can expect updates to Latest to be extremely stable. Versions follow the semantic versioning scheme. Learn more about our commitment to stability and incremental migration in our &lt;a href=&quot;faq-versioning&quot;&gt;versioning policy&lt;/a&gt;.</source>
          <target state="translated">Вы можете ожидать, что обновления последней версии будут чрезвычайно стабильными. Версии следуют семантической схеме управления версиями. Узнайте больше о нашей приверженности стабильности и постепенной миграции в нашей &lt;a href=&quot;faq-versioning&quot;&gt;политике управления версиями&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43486125276c666e322a5707b38de7e0642f9408" translate="yes" xml:space="preserve">
          <source>You can find instructions for building your app for production below.</source>
          <target state="translated">Ниже Вы найдете инструкции по созданию Вашего приложения для производства.</target>
        </trans-unit>
        <trans-unit id="b669ecfca0f474a332753750307b5170f4d3d5ab" translate="yes" xml:space="preserve">
          <source>You can have as many such isolated components as you like, and use &lt;code&gt;ReactDOM.render()&lt;/code&gt; to render them to different DOM containers. Gradually, as you convert more of your app to React, you will be able to combine them into larger components, and move some of the &lt;code&gt;ReactDOM.render()&lt;/code&gt; calls up the hierarchy.</source>
          <target state="translated">Вы можете иметь столько изолированных компонентов, сколько захотите, и использовать &lt;code&gt;ReactDOM.render()&lt;/code&gt; для их рендеринга в разные контейнеры DOM. Постепенно, по мере преобразования большей части своего приложения в React, вы сможете объединять их в более крупные компоненты и перемещать некоторые из &lt;code&gt;ReactDOM.render()&lt;/code&gt; вызывает иерархию.</target>
        </trans-unit>
        <trans-unit id="59a095baf122e4a8f541350370263b19ef77da11" translate="yes" xml:space="preserve">
          <source>You can imagine that in a large app, this same pattern of subscribing to &lt;code&gt;DataSource&lt;/code&gt; and calling &lt;code&gt;setState&lt;/code&gt; will occur over and over again. We want an abstraction that allows us to define this logic in a single place and share it across many components. This is where higher-order components excel.</source>
          <target state="translated">Вы можете себе представить, что в большом приложении этот же шаблон подписки на &lt;code&gt;DataSource&lt;/code&gt; и вызова &lt;code&gt;setState&lt;/code&gt; будет повторяться снова и снова. Нам нужна абстракция, которая позволяет нам определять эту логику в одном месте и совместно использовать ее во многих компонентах. Вот где превосходят компоненты высшего порядка.</target>
        </trans-unit>
        <trans-unit id="c2607b19c795cb6467d715b76b65c4f83582007c" translate="yes" xml:space="preserve">
          <source>You can instead make this explicit by passing a ref to your custom component and pass that along to the DOM using &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;ref forwarding&lt;/a&gt;.</source>
          <target state="translated">Вместо этого вы можете сделать это явным, передав ссылку своему пользовательскому компоненту и передав ее в DOM с помощью &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;пересылки ссылок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e58d88ea64ac854e8b852850131003a5b38dfe8b" translate="yes" xml:space="preserve">
          <source>You can learn how to use it from our &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;code splitting documentation&lt;/a&gt;. You might also want to check out &lt;a href=&quot;https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d&quot;&gt;this article&lt;/a&gt; explaining how to use it in more detail.</source>
          <target state="translated">Вы можете узнать, как его использовать, из нашей &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;документации по разделению кода&lt;/a&gt; . Вы также можете ознакомиться с &lt;a href=&quot;https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d&quot;&gt;этой статьей,&lt;/a&gt; в которой подробно объясняется, как ее использовать.</target>
        </trans-unit>
        <trans-unit id="0405db67bd6f9d08d2f8547c2ca89d3bc11fef3e" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;a href=&quot;conditional-rendering&quot;&gt;conditional rendering&lt;/a&gt; and &lt;a href=&quot;lists-and-keys&quot;&gt;loops&lt;/a&gt; in the corresponding sections.</source>
          <target state="translated">Вы можете узнать больше об &lt;a href=&quot;conditional-rendering&quot;&gt;условном рендеринге&lt;/a&gt; и &lt;a href=&quot;lists-and-keys&quot;&gt;циклах&lt;/a&gt; в соответствующих разделах.</target>
        </trans-unit>
        <trans-unit id="ebdc3d81678cb41b857c269d907b419fc833fc42" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;useEffect&lt;/code&gt; on a dedicated page: &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше об &lt;code&gt;useEffect&lt;/code&gt; на специальной странице: &lt;a href=&quot;hooks-effect&quot;&gt;Использование Effect Hook&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2190fea105b1a5c2c5132e45309d084e938f0fab" translate="yes" xml:space="preserve">
          <source>You can learn more about all the built-in Hooks on a dedicated page: &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API Reference&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше обо всех встроенных хуках на специальной странице: &lt;a href=&quot;hooks-reference&quot;&gt;Справочник по API хуков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd76f44fa000769bfbb88ab6451d678fd499b34e" translate="yes" xml:space="preserve">
          <source>You can learn more about custom Hooks on a dedicated page: &lt;a href=&quot;hooks-custom&quot;&gt;Building Your Own Hooks&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о пользовательских хуках на специальной странице: &lt;a href=&quot;hooks-custom&quot;&gt;Создание собственных хуков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44e6a6a3a05e18341e61e8b581459673e8664c2b" translate="yes" xml:space="preserve">
          <source>You can learn more about the State Hook on a dedicated page: &lt;a href=&quot;hooks-state&quot;&gt;Using the State Hook&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о State Hook на специальной странице: &lt;a href=&quot;hooks-state&quot;&gt;Использование State Hook&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ded04d381f1d8a8f1862e047aac6e2b430518c7" translate="yes" xml:space="preserve">
          <source>You can learn more about these rules on a dedicated page: &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше об этих правилах на специальной странице: &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4a8afdfc0befb4880f75b37590103ef140b8332" translate="yes" xml:space="preserve">
          <source>You can learn more about this in &lt;a href=&quot;https://webpack.js.org/guides/production/&quot;&gt;webpack documentation&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше об этом в &lt;a href=&quot;https://webpack.js.org/guides/production/&quot;&gt;документации&lt;/a&gt; по веб-пакету .</target>
        </trans-unit>
        <trans-unit id="6defc311d97882551acc89862aaa8211b5ccb8bf" translate="yes" xml:space="preserve">
          <source>You can map a collection of items to an array of fragments as you would any other type of element as well:</source>
          <target state="translated">Вы можете сопоставить коллекцию элементов с массивом фрагментов,как и любой другой тип элементов:</target>
        </trans-unit>
        <trans-unit id="c39e023484eeec5fc7042f79a35e6d4e7bc21cde" translate="yes" xml:space="preserve">
          <source>You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML:</source>
          <target state="translated">Вы можете смешивать различные типы детей,поэтому Вы можете использовать строковые литералы вместе с детьми JSX.Это еще один способ,при котором JSX похож на HTML,так что это и действительный JSX,и действительный HTML:</target>
        </trans-unit>
        <trans-unit id="68923457893fc208ce455a8d754f8df854066e43" translate="yes" xml:space="preserve">
          <source>You can only subscribe to a single context using this API. If you need to read more than one see &lt;a href=&quot;#consuming-multiple-contexts&quot;&gt;Consuming Multiple Contexts&lt;/a&gt;.</source>
          <target state="translated">Вы можете подписаться только на один контекст с помощью этого API. Если вам нужно прочитать более одного, см. &lt;a href=&quot;#consuming-multiple-contexts&quot;&gt;Использование нескольких контекстов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c0539a6d8aab194914bf2c1b637a40462054bec" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;createNodeMock&lt;/code&gt; function to &lt;code&gt;TestRenderer.create&lt;/code&gt; as the option, which allows for custom mock refs. &lt;code&gt;createNodeMock&lt;/code&gt; accepts the current element and should return a mock ref object. This is useful when you test a component that relies on refs.</source>
          <target state="translated">Вы можете передать &lt;code&gt;createNodeMock&lt;/code&gt; функцию &lt;code&gt;TestRenderer.create&lt;/code&gt; , как вариант, который позволяет для пользовательских макетов рефов. &lt;code&gt;createNodeMock&lt;/code&gt; принимает текущий элемент и должен возвращать фиктивный объект ссылки. Это полезно, когда вы тестируете компонент, который полагается на ссылки.</target>
        </trans-unit>
        <trans-unit id="60a31b4af9209c82ad0c032eb8bd56c3135e3e31" translate="yes" xml:space="preserve">
          <source>You can pass a string literal as a prop. These two JSX expressions are equivalent:</source>
          <target state="translated">Ты можешь передать строку буквально как реквизит.Эти два JSX выражения эквивалентны:</target>
        </trans-unit>
        <trans-unit id="98e2514deb58f721583921f9f4558ca15319f866" translate="yes" xml:space="preserve">
          <source>You can pass an array into the &lt;code&gt;value&lt;/code&gt; attribute, allowing you to select multiple options in a &lt;code&gt;select&lt;/code&gt; tag:</source>
          <target state="translated">Вы можете передать массив в атрибут &lt;code&gt;value&lt;/code&gt; , что позволит вам выбрать несколько параметров в теге &lt;code&gt;select&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6c0dca775a62dc92cd4d4ca42033a80bb40b933d" translate="yes" xml:space="preserve">
          <source>You can pass any JavaScript expression as a prop, by surrounding it with &lt;code&gt;{}&lt;/code&gt;. For example, in this JSX:</source>
          <target state="translated">Вы можете передать любое выражение JavaScript в качестве опоры, заключив его в &lt;code&gt;{}&lt;/code&gt; . Например, в этом JSX:</target>
        </trans-unit>
        <trans-unit id="820386db58d5b70925ee607029782118c88bd411" translate="yes" xml:space="preserve">
          <source>You can pass any JavaScript expression as children, by enclosing it within &lt;code&gt;{}&lt;/code&gt;. For example, these expressions are equivalent:</source>
          <target state="translated">Вы можете передать любое выражение JavaScript в качестве дочерних элементов, заключив его в &lt;code&gt;{}&lt;/code&gt; . Например, эти выражения эквивалентны:</target>
        </trans-unit>
        <trans-unit id="2ca332aa888156d7e208d864ef99671f87200fd7" translate="yes" xml:space="preserve">
          <source>You can pass callback refs between components like you can with object refs that were created with &lt;code&gt;React.createRef()&lt;/code&gt;.</source>
          <target state="translated">Вы можете передавать ссылки обратного вызова между компонентами, как вы можете с &lt;code&gt;React.createRef()&lt;/code&gt; объекты, которые были созданы с помощью React.createRef () .</target>
        </trans-unit>
        <trans-unit id="184b23ee4cb82f84aaf58aa94da5ac57b911db50" translate="yes" xml:space="preserve">
          <source>You can place a &amp;ldquo;container&amp;rdquo; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; like this &lt;strong&gt;anywhere&lt;/strong&gt; inside the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag. You may have as many independent DOM containers on one page as you need. They are usually empty &amp;mdash; React will replace any existing content inside DOM containers.</source>
          <target state="translated">Вы можете поместить &amp;laquo;контейнер&amp;raquo; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; как этот &lt;strong&gt;нигде&lt;/strong&gt; внутри &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; тег. У вас может быть столько независимых контейнеров DOM на одной странице, сколько вам нужно. Обычно они пустые - React заменит любой существующий контент внутри контейнеров DOM.</target>
        </trans-unit>
        <trans-unit id="93edf3c48f793906a4695cc4a4c1f501ab4bdbd0" translate="yes" xml:space="preserve">
          <source>You can play with JSX using &lt;a href=&quot;https://babeljs.io/en/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=DwIwrgLhD2B2AEcDCAbAlgYwNYF4DeAFAJTw4B88EAFmgM4B0tAphAMoQCGETBe86WJgBMAXJQBOYJvAC-RGWQBQ8FfAAyaQYuAB6cFDhkgA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=true&amp;amp;presets=es2015%2Creact%2Cstage-2&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.3&quot;&gt;this online converter&lt;/a&gt;.</source>
          <target state="translated">Вы можете играть с JSX, используя &lt;a href=&quot;https://babeljs.io/en/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=DwIwrgLhD2B2AEcDCAbAlgYwNYF4DeAFAJTw4B88EAFmgM4B0tAphAMoQCGETBe86WJgBMAXJQBOYJvAC-RGWQBQ8FfAAyaQYuAB6cFDhkgA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=true&amp;amp;presets=es2015%2Creact%2Cstage-2&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.3&quot;&gt;этот онлайн-конвертер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d1545332973b55902e4255143d257c96974bde4" translate="yes" xml:space="preserve">
          <source>You can provide more JSX elements as the children. This is useful for displaying nested components:</source>
          <target state="translated">Вы можете предоставить больше JSX-элементов,как дети.Это полезно для отображения вложенных компонентов:</target>
        </trans-unit>
        <trans-unit id="65f15691188f600d9d12d5f168ed2e31e352f23e" translate="yes" xml:space="preserve">
          <source>You can put a string between the opening and closing tags and &lt;code&gt;props.children&lt;/code&gt; will just be that string. This is useful for many of the built-in HTML elements. For example:</source>
          <target state="translated">Вы можете поместить строку между открывающим и закрывающим тегами, и &lt;code&gt;props.children&lt;/code&gt; будет именно этой строкой. Это полезно для многих встроенных элементов HTML. Например:</target>
        </trans-unit>
        <trans-unit id="f565c43f4e7f61294704c4616bb4fff2035deea9" translate="yes" xml:space="preserve">
          <source>You can put any valid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions&quot;&gt;JavaScript expression&lt;/a&gt; inside the curly braces in JSX. For example, &lt;code&gt;2 + 2&lt;/code&gt;, &lt;code&gt;user.firstName&lt;/code&gt;, or &lt;code&gt;formatName(user)&lt;/code&gt; are all valid JavaScript expressions.</source>
          <target state="translated">Вы можете поместить любое допустимое &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions&quot;&gt;выражение JavaScript&lt;/a&gt; в фигурные скобки в JSX. Например, &lt;code&gt;2 + 2&lt;/code&gt; , &lt;code&gt;user.firstName&lt;/code&gt; или &lt;code&gt;formatName(user)&lt;/code&gt; - все допустимые выражения JavaScript.</target>
        </trans-unit>
        <trans-unit id="dea19bc48d1099e474ed6fa06e3adca5d08b7bb8" translate="yes" xml:space="preserve">
          <source>You can see a demo of this &lt;a href=&quot;https://codesandbox.io/s/admiring-mendeleev-y54mk&quot;&gt;here&lt;/a&gt;. The &amp;ldquo;posts&amp;rdquo; and &amp;ldquo;fun facts&amp;rdquo; responses come within 100ms of each other. But React coalesces them and &amp;ldquo;reveals&amp;rdquo; their Suspense boundaries together.</source>
          <target state="translated">Вы можете увидеть демонстрацию этого &lt;a href=&quot;https://codesandbox.io/s/admiring-mendeleev-y54mk&quot;&gt;здесь&lt;/a&gt; . Ответы &amp;laquo;сообщения&amp;raquo; и &amp;laquo;забавные факты&amp;raquo; находятся в пределах 100 мс друг от друга. Но React объединяет их и вместе &amp;laquo;раскрывает&amp;raquo; их границы Suspense.</target>
        </trans-unit>
        <trans-unit id="ecfa9132bdc5d45f7bea98f2b20a650f4c2adcdf" translate="yes" xml:space="preserve">
          <source>You can start seeing how your application will behave: set &lt;code&gt;filterText&lt;/code&gt; to &lt;code&gt;&quot;ball&quot;&lt;/code&gt; and refresh your app. You&amp;rsquo;ll see that the data table is updated correctly.</source>
          <target state="translated">Вы можете начать наблюдать за поведением вашего приложения: установите для &lt;code&gt;filterText&lt;/code&gt; значение &lt;code&gt;&quot;ball&quot;&lt;/code&gt; и обновите приложение. Вы увидите, что таблица данных обновлена ​​правильно.</target>
        </trans-unit>
        <trans-unit id="96719fed07645c37bccf1baf5ade2085d5b7d9e4" translate="yes" xml:space="preserve">
          <source>You can test React components similar to testing other JavaScript code.</source>
          <target state="translated">Вы можете тестировать React компоненты аналогично тестированию других JavaScript-кодов.</target>
        </trans-unit>
        <trans-unit id="319b7a4aae21ffc530a5c776ce1c452ea524854a" translate="yes" xml:space="preserve">
          <source>You can then begin to assert facts about the output.</source>
          <target state="translated">Затем вы можете начать утверждать факты о выходе.</target>
        </trans-unit>
        <trans-unit id="d172c0255df0dcbddf210708de9b34e44a7b2d31" translate="yes" xml:space="preserve">
          <source>You can think of the Blocking Mode as a &amp;ldquo;gracefully degraded&amp;rdquo; version of the Concurrent Mode. &lt;strong&gt;As a result, in longer term we should be able to converge and stop thinking about different Modes altogether.&lt;/strong&gt; But for now, Modes are an important migration strategy. They let everyone decide when a migration is worth it, and upgrade at their own pace.</source>
          <target state="translated">Вы можете думать о режиме блокировки как о &amp;laquo;изящно ухудшенной&amp;raquo; версии параллельного режима. &lt;strong&gt;В результате в более долгосрочной перспективе мы сможем сойтись и перестать думать о разных Режимах вообще. &lt;/strong&gt;Но на данный момент режимы - важная стратегия миграции. Они позволяют каждому решить, стоит ли миграция, и обновлять ее в своем собственном темпе.</target>
        </trans-unit>
        <trans-unit id="6c64d3564a9301555ca04b03520026aa7c6bddae" translate="yes" xml:space="preserve">
          <source>You can think of the shallowRenderer as a &amp;ldquo;place&amp;rdquo; to render the component you&amp;rsquo;re testing, and from which you can extract the component&amp;rsquo;s output.</source>
          <target state="translated">Вы можете думать о shallowRenderer как о &amp;laquo;месте&amp;raquo; для рендеринга тестируемого компонента, из которого вы можете извлечь выходные данные компонента.</target>
        </trans-unit>
        <trans-unit id="0590e174a395555a3c9bb1cf3a4ffa86c9488267" translate="yes" xml:space="preserve">
          <source>You can try out the new JSX fragment syntax with this &lt;a href=&quot;https://codepen.io/reactjs/pen/VrEbjE?editors=1000&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">Вы можете опробовать новый синтаксис фрагмента JSX с помощью этого &lt;a href=&quot;https://codepen.io/reactjs/pen/VrEbjE?editors=1000&quot;&gt;CodePen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="206b1d043bff35e73dffc40254662fddd860491d" translate="yes" xml:space="preserve">
          <source>You can try these builds on personal projects or in a branch, but we don&amp;rsquo;t recommend running them in production. At Facebook, we &lt;em&gt;do&lt;/em&gt; run them in production, but that&amp;rsquo;s because we&amp;rsquo;re also there to fix bugs when something breaks. You&amp;rsquo;ve been warned!</source>
          <target state="translated">Вы можете попробовать эти сборки в личных проектах или в ветке, но мы не рекомендуем запускать их в производственной среде. На Facebook, мы &lt;em&gt;делаем&lt;/em&gt; запустить их в производство, но это потому , что мы и есть , чтобы исправить ошибки , когда что - то ломается. Вас предупредили!</target>
        </trans-unit>
        <trans-unit id="1bf129fcc87d9c8703b3fc987efff35eebff0bb7" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; the same way you&amp;rsquo;d use any other element except that it doesn&amp;rsquo;t support keys or attributes.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; так же, как и любой другой элемент, за исключением того, что он не поддерживает ключи или атрибуты.</target>
        </trans-unit>
        <trans-unit id="7fc4bfbc3568b2331ad90a50be1e5e88a5ee3938" translate="yes" xml:space="preserve">
          <source>You can use Jest&amp;rsquo;s snapshot testing feature to automatically save a copy of the JSON tree to a file and check in your tests that it hasn&amp;rsquo;t changed: &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;Learn more about it&lt;/a&gt;.</source>
          <target state="translated">Вы можете использовать функцию тестирования моментальных снимков Jest, чтобы автоматически сохранять копию дерева JSON в файл и проверять в своих тестах, что оно не изменилось: &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;узнайте больше об этом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4056132b8d01c6d2d7bac67f0daa9dca693db05e" translate="yes" xml:space="preserve">
          <source>You can use an arrow function to wrap around an event handler and pass parameters:</source>
          <target state="translated">Вы можете использовать функцию стрелки,чтобы обернуть обработчик события и передать параметры:</target>
        </trans-unit>
        <trans-unit id="576e418bcc1c573f894bd565b26325d02a2c7944" translate="yes" xml:space="preserve">
          <source>You can use any AJAX library you like with React. Some popular ones are &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;Axios&lt;/a&gt;, &lt;a href=&quot;https://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery AJAX&lt;/a&gt;, and the browser built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;window.fetch&lt;/a&gt;.</source>
          <target state="translated">Вы можете использовать любую понравившуюся библиотеку AJAX с React. Среди популярных - &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;Axios&lt;/a&gt; , &lt;a href=&quot;https://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery AJAX&lt;/a&gt; и встроенный в браузер &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;window.fetch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="071ccad1f37e1a2aa152780b53244d333e2c6010" translate="yes" xml:space="preserve">
          <source>You can use fake timers only in some tests. Above, we enabled them by calling &lt;code&gt;jest.useFakeTimers()&lt;/code&gt;. The main advantage they provide is that your test doesn&amp;rsquo;t actually have to wait five seconds to execute, and you also didn&amp;rsquo;t need to make the component code more convoluted just for testing.</source>
          <target state="translated">Поддельные таймеры можно использовать только в некоторых тестах. Выше мы включили их, вызвав &lt;code&gt;jest.useFakeTimers()&lt;/code&gt; . Основное преимущество, которое они предоставляют, заключается в том, что вашему тесту на самом деле не нужно ждать пять секунд для выполнения, и вам также не нужно делать код компонента более запутанным только для тестирования.</target>
        </trans-unit>
        <trans-unit id="313bb057a2f63bdbdabbce1010d70a283298f2c0" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://www.npmjs.com/package/raf&quot;&gt;raf&lt;/a&gt; package to shim &lt;code&gt;requestAnimationFrame&lt;/code&gt;:</source>
          <target state="translated">Вы можете использовать пакет &lt;a href=&quot;https://www.npmjs.com/package/raf&quot;&gt;raf&lt;/a&gt; для установки совместимости с &lt;code&gt;requestAnimationFrame&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="14fd80619cfa4c8a757789fd180eb2c35fdf8b6f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;currentTarget&lt;/code&gt; and &lt;code&gt;relatedTarget&lt;/code&gt; to differentiate if the focusing or blurring events originated from &lt;em&gt;outside&lt;/em&gt; of the parent element. Here is a demo you can copy and paste that shows how to detect focusing a child, focusing the element itself, and focus entering or leaving the whole subtree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18f7d2685e7d062c1678298785cd06becb18092" translate="yes" xml:space="preserve">
          <source>You can use the State Hook more than once in a single component:</source>
          <target state="translated">Вы можете использовать State Hook не один раз в одном компоненте:</target>
        </trans-unit>
        <trans-unit id="b13cc97b72a37b2c0f156c7b3969fddf1f026f25" translate="yes" xml:space="preserve">
          <source>You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn&amp;rsquo;t change.</source>
          <target state="translated">Вы можете использовать переменные для хранения элементов. Это может помочь вам условно визуализировать часть компонента, в то время как остальная часть вывода не изменится.</target>
        </trans-unit>
        <trans-unit id="1ad2ebdcc22b0a305902796e8d6c0c5dc695b0fc" translate="yes" xml:space="preserve">
          <source>You can verify by inspecting the &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element&quot;&gt;last example&lt;/a&gt; with the browser tools:</source>
          <target state="translated">Вы можете проверить, проверив &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element&quot;&gt;последний пример&lt;/a&gt; с помощью инструментов браузера:</target>
        </trans-unit>
        <trans-unit id="fed7cbf84ae5ac541a4e8a4231d62ef5696a99e1" translate="yes" xml:space="preserve">
          <source>You can wrap a function component with &lt;code&gt;React.memo&lt;/code&gt; to shallowly compare its props:</source>
          <target state="translated">Вы можете обернуть функциональный компонент &lt;code&gt;React.memo&lt;/code&gt; , чтобы неглубоко сравнить его свойства :</target>
        </trans-unit>
        <trans-unit id="76f54fde37523874b455579c8df068962295d11b" translate="yes" xml:space="preserve">
          <source>You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven&amp;rsquo;t considered. We are excited to see what custom Hooks the React community will come up with.</source>
          <target state="translated">Вы можете написать собственные хуки, которые охватывают широкий спектр вариантов использования, таких как обработка форм, анимация, декларативные подписки, таймеры и, возможно, многие другие, которые мы не рассматривали. Мы очень рады видеть, какие пользовательские хуки предложит сообщество React.</target>
        </trans-unit>
        <trans-unit id="43bcb3dd583d6b2dd0d35900294f9bc74472de69" translate="yes" xml:space="preserve">
          <source>You can write to it from inside &lt;code&gt;useEffect&lt;/code&gt;:</source>
          <target state="translated">Вы можете написать в него изнутри &lt;code&gt;useEffect&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="47255993d7f3732c79a6c98cd3fe5fc53875788f" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t opt into Concurrent Mode on a per-subtree basis. Instead, to opt in, you have to do it in the place where today you call &lt;code&gt;ReactDOM.render()&lt;/code&gt;.</source>
          <target state="translated">Вы не можете выбрать одновременный режим для каждого поддерева. Вместо этого, чтобы зарегистрироваться, вы должны сделать это в том месте, где сегодня вы вызываете &lt;code&gt;ReactDOM.render()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa9c95956bb20366a3bf7354777516586cb672a" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use Hooks &lt;em&gt;inside&lt;/em&gt; a class component, but you can definitely mix classes and function components with Hooks in a single tree. Whether a component is a class or a function that uses Hooks is an implementation detail of that component. In the longer term, we expect Hooks to be the primary way people write React components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32390cb7781d4c45dceb903ef23ef22e363cf1d" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use Hooks &lt;em&gt;inside&lt;/em&gt; of a class component, but you can definitely mix classes and function components with Hooks in a single tree. Whether a component is a class or a function that uses Hooks is an implementation detail of that component. In the longer term, we expect Hooks to be the primary way people write React components.</source>
          <target state="translated">Вы не можете использовать хуки &lt;em&gt;внутри&lt;/em&gt; компонента класса, но вы определенно можете смешивать классы и функциональные компоненты с хуками в одном дереве. Является ли компонент классом или функцией, использующей хуки, является деталью реализации этого компонента. В долгосрочной перспективе мы ожидаем, что хуки станут основным способом написания компонентов React.</target>
        </trans-unit>
        <trans-unit id="0dd0330331639f73df7bfd7107d5bd9297f8602e" translate="yes" xml:space="preserve">
          <source>You can, however, &lt;strong&gt;use the &lt;code&gt;ref&lt;/code&gt; attribute inside a function component&lt;/strong&gt; as long as you refer to a DOM element or a class component:</source>
          <target state="translated">Однако вы можете &lt;strong&gt;использовать атрибут &lt;code&gt;ref&lt;/code&gt; внутри функционального компонента,&lt;/strong&gt; если вы ссылаетесь на элемент DOM или компонент класса:</target>
        </trans-unit>
        <trans-unit id="7f38342d82347d389f86bdf83fa1f0ab8b63d28a" translate="yes" xml:space="preserve">
          <source>You cannot use a general expression as the React element type. If you do want to use a general expression to indicate the type of the element, just assign it to a capitalized variable first. This often comes up when you want to render a different component based on a prop:</source>
          <target state="translated">Нельзя использовать общее выражение в качестве типа элемента React.Если вы хотите использовать общее выражение для обозначения типа элемента,просто присвойте его сначала заглавной переменной.Это часто происходит,когда вы хотите отрисовать другой компонент на основе реквизита:</target>
        </trans-unit>
        <trans-unit id="33243c0a4126f37be4f3131649cc1eacea5c2f2f" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to replace callback refs in your components. They are slightly more flexible, so they will remain as an advanced feature.</source>
          <target state="translated">Вам не нужно заменять ссылки обратного вызова в ваших компонентах. Они немного более гибкие, поэтому останутся расширенными функциями.</target>
        </trans-unit>
        <trans-unit id="5ea32ee627ff275bafe9ffb6dfbbc18214bc629f" translate="yes" xml:space="preserve">
          <source>You have to be careful about the meaning of &lt;code&gt;this&lt;/code&gt; in JSX callbacks. In JavaScript, class methods are not &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;bound&lt;/a&gt; by default. If you forget to bind &lt;code&gt;this.handleClick&lt;/code&gt; and pass it to &lt;code&gt;onClick&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; when the function is actually called.</source>
          <target state="translated">Вы должны быть осторожны со значением &lt;code&gt;this&lt;/code&gt; в обратных вызовах JSX. В JavaScript методы класса по умолчанию не &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;привязаны&lt;/a&gt; . Если вы забудете связать &lt;code&gt;this.handleClick&lt;/code&gt; и передать его &lt;code&gt;onClick&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; будет &lt;code&gt;undefined&lt;/code&gt; при фактическом вызове функции.</target>
        </trans-unit>
        <trans-unit id="127ac3f6dd7ddcb0012f37436e79376815c0bff1" translate="yes" xml:space="preserve">
          <source>You may &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embed any expressions in JSX&lt;/a&gt; by wrapping them in curly braces. This includes the JavaScript logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator. It can be handy for conditionally including an element:</source>
          <target state="translated">Вы можете &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;вставлять любые выражения в JSX&lt;/a&gt; , заключив их в фигурные скобки. Сюда входит логический оператор JavaScript &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; . Это может быть удобно для условного включения элемента:</target>
        </trans-unit>
        <trans-unit id="329bb2ebce4c30c002ff2d23c58926794b4e569e" translate="yes" xml:space="preserve">
          <source>You may &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embed expressions in JSX&lt;/a&gt; by wrapping them in curly braces. This includes the JavaScript logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator. It can be handy for conditionally including an element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a0cc95c37e0601bd484fc3858b0de8b575529a" translate="yes" xml:space="preserve">
          <source>You may also use curly braces to embed a JavaScript expression in an attribute:</source>
          <target state="translated">Вы также можете использовать фигурные скобки для встраивания JavaScript выражения в атрибут:</target>
        </trans-unit>
        <trans-unit id="f6d89345f3ccb99c4b8cb79403d5d95c6c80c7c2" translate="yes" xml:space="preserve">
          <source>You may also use custom attributes as long as they&amp;rsquo;re fully lowercase.</source>
          <target state="translated">Вы также можете использовать настраиваемые атрибуты, если они полностью строчные.</target>
        </trans-unit>
        <trans-unit id="75904665efa8694a25758036e4a724ac6e5801a8" translate="yes" xml:space="preserve">
          <source>You may find it valuable to run integration tests against Experimental. This is up to you. However, be advised that Experimental is even less stable than Next. &lt;strong&gt;We do not guarantee any stability between Experimental releases.&lt;/strong&gt;</source>
          <target state="translated">Возможно, вам будет полезно запустить интеграционные тесты с Experimental. Все зависит от вас. Однако имейте в виду, что Experimental еще менее стабилен, чем Next. &lt;strong&gt;Мы не гарантируем стабильности между экспериментальными версиями.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d32c9e3fbc0fdfb2d416e23ef95ad43e35517849" translate="yes" xml:space="preserve">
          <source>You may have noticed similarities between HOCs and a pattern called &lt;strong&gt;container components&lt;/strong&gt;. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.</source>
          <target state="translated">Возможно, вы заметили сходство между HOC и шаблоном, называемым &lt;strong&gt;компонентами контейнера&lt;/strong&gt; . Компоненты контейнера являются частью стратегии разделения ответственности между проблемами высокого и низкого уровня. Контейнеры управляют такими вещами, как подписки и состояние, и передают свойства компонентам, которые обрабатывают такие вещи, как рендеринг пользовательского интерфейса. HOC используют контейнеры как часть своей реализации. Вы можете думать о HOC как о параметризованных определениях компонентов контейнера.</target>
        </trans-unit>
        <trans-unit id="86fc1bfd2853f4054b7a51c82c1449e76256a431" translate="yes" xml:space="preserve">
          <source>You may optionally pass an object as the first argument to &lt;code&gt;setState()&lt;/code&gt; instead of a function:</source>
          <target state="translated">При желании вы можете передать объект в качестве первого аргумента функции &lt;code&gt;setState()&lt;/code&gt; вместо функции:</target>
        </trans-unit>
        <trans-unit id="ee6c85272ea4b9d75ad324a8fc559394991e1935" translate="yes" xml:space="preserve">
          <source>You may use a different pattern, but keep in mind that we want to execute the cleanup &lt;em&gt;even if a test fails&lt;/em&gt;. Otherwise, tests can become &amp;ldquo;leaky&amp;rdquo;, and one test can change the behavior of another test. That makes them difficult to debug.</source>
          <target state="translated">Вы можете использовать другой шаблон, но имейте в виду, что мы хотим выполнить очистку, &lt;em&gt;даже если тест не прошел&lt;/em&gt; . В противном случае тесты могут стать &amp;laquo;негерметичными&amp;raquo;, и один тест может изменить поведение другого теста. Это затрудняет их отладку.</target>
        </trans-unit>
        <trans-unit id="6c68df6de15e5de9ad7a0e61d3aae233a125ac08" translate="yes" xml:space="preserve">
          <source>You may use quotes to specify string literals as attributes:</source>
          <target state="translated">Вы можете использовать кавычки для указания строковых литералов в качестве атрибутов:</target>
        </trans-unit>
        <trans-unit id="6c4ab2bcc9cce4e4f2f236a0689d5a30836ea67d" translate="yes" xml:space="preserve">
          <source>You might be curious how React knows which component &lt;code&gt;useState&lt;/code&gt; corresponds to since we&amp;rsquo;re not passing anything like &lt;code&gt;this&lt;/code&gt; back to React. We&amp;rsquo;ll answer &lt;a href=&quot;hooks-faq#how-does-react-associate-hook-calls-with-components&quot;&gt;this question&lt;/a&gt; and many others in the FAQ section.</source>
          <target state="translated">Вы могли бы быть интересно , как Реагировать знает , какой компонент &lt;code&gt;useState&lt;/code&gt; , соответствует , так как мы не пропуская ничего подобного &lt;code&gt;this&lt;/code&gt; спиной к React. Мы ответим на &lt;a href=&quot;hooks-faq#how-does-react-associate-hook-calls-with-components&quot;&gt;этот&lt;/a&gt; и многие другие вопросы в разделе часто задаваемых вопросов.</target>
        </trans-unit>
        <trans-unit id="39c09441c3e7a9a767a8d286f34ad0922dfcdde2" translate="yes" xml:space="preserve">
          <source>You might be familiar with refs primarily as a way to &lt;a href=&quot;refs-and-the-dom&quot;&gt;access the DOM&lt;/a&gt;. If you pass a ref object to React with &lt;code&gt;&amp;lt;div ref={myRef} /&amp;gt;&lt;/code&gt;, React will set its &lt;code&gt;.current&lt;/code&gt; property to the corresponding DOM node whenever that node changes.</source>
          <target state="translated">Возможно, вы знакомы с refs в первую очередь как с способом &lt;a href=&quot;refs-and-the-dom&quot;&gt;доступа к DOM&lt;/a&gt; . Если вы передадите объект ref в React с помощью &lt;code&gt;&amp;lt;div ref={myRef} /&amp;gt;&lt;/code&gt; , React установит для своего свойства &lt;code&gt;.current&lt;/code&gt; соответствующий узел DOM при каждом изменении этого узла.</target>
        </trans-unit>
        <trans-unit id="843432bbccf637d5c3a245ab223ad53e54801d6b" translate="yes" xml:space="preserve">
          <source>You might be thinking that we&amp;rsquo;d need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that &lt;code&gt;useEffect&lt;/code&gt; is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:</source>
          <target state="translated">Вы могли подумать, что для очистки нам понадобится отдельный эффект. Но код для добавления и удаления подписки настолько тесно связан, что &lt;code&gt;useEffect&lt;/code&gt; предназначен для его сохранения. Если ваш эффект возвращает функцию, React запустит ее, когда придет время очистить:</target>
        </trans-unit>
        <trans-unit id="af3f101aa60ab2f4218f9c28b6ee51cac9e89fff" translate="yes" xml:space="preserve">
          <source>You might be wondering why we&amp;rsquo;re using a counter here instead of a more realistic example. This is to help us focus on the API while we&amp;rsquo;re still making our first steps with Hooks.</source>
          <target state="translated">Вам может быть интересно, почему мы используем здесь счетчик вместо более реалистичного примера. Это поможет нам сосредоточиться на API, пока мы делаем первые шаги с хуками.</target>
        </trans-unit>
        <trans-unit id="83ba6a9a4f28b7236b5b6943244a0b8d6c86dde5" translate="yes" xml:space="preserve">
          <source>You might be wondering: why is &lt;code&gt;useState&lt;/code&gt; not named &lt;code&gt;createState&lt;/code&gt; instead?</source>
          <target state="translated">Вам может быть интересно: почему вместо этого &lt;code&gt;useState&lt;/code&gt; не называется &lt;code&gt;createState&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="3be6e25b6d0f7c01938be3f1f55926afa3c29409" translate="yes" xml:space="preserve">
          <source>You might find using &lt;code&gt;act()&lt;/code&gt; directly a bit too verbose. To avoid some of the boilerplate, you could use a library like &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;, whose helpers are wrapped with &lt;code&gt;act()&lt;/code&gt;.</source>
          <target state="translated">Вы можете найти использование &lt;code&gt;act()&lt;/code&gt; напрямую слишком многословным. Чтобы избежать некоторых шаблонов, вы можете использовать такую ​​библиотеку, как &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; , помощники которой заключены в &lt;code&gt;act()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0db33983cd7798b4c863f844b1e5e18fe94fdbe6" translate="yes" xml:space="preserve">
          <source>You might have noticed the square brackets when we declare a state variable:</source>
          <target state="translated">Вы могли заметить квадратные скобки,когда мы объявляем переменную состояния:</target>
        </trans-unit>
        <trans-unit id="329e92de263dd0e71122a46b673d8f3a5c8c8351" translate="yes" xml:space="preserve">
          <source>You might have previously known these as &amp;ldquo;stateless components&amp;rdquo;. We&amp;rsquo;re now introducing the ability to use React state from these, so we prefer the name &amp;ldquo;function components&amp;rdquo;.</source>
          <target state="translated">Возможно, вы раньше знали их как &amp;laquo;компоненты без состояния&amp;raquo;. Сейчас мы представляем возможность использовать из них состояние React, поэтому мы предпочитаем название &amp;laquo;функциональные компоненты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4ef4a753921a678c61c3979f95fe4cdf4be39d17" translate="yes" xml:space="preserve">
          <source>You might object that fetching &amp;ldquo;at the top level&amp;rdquo; like in this example is impractical. What are we going to do if we navigate to another profile&amp;rsquo;s page? We might want to fetch based on props. The answer to this is &lt;strong&gt;we want to start fetching in the event handlers instead&lt;/strong&gt;. Here is a simplified example of navigating between user&amp;rsquo;s pages:</source>
          <target state="translated">Вы можете возразить, что выборка &amp;laquo;на верхнем уровне&amp;raquo;, как в этом примере, нецелесообразна. Что мы будем делать, если перейдем на страницу другого профиля? Мы можем захотеть получить на основе props. Ответ на этот вопрос - &lt;strong&gt;вместо&lt;/strong&gt; этого &lt;strong&gt;мы хотим начать выборку в обработчиках событий&lt;/strong&gt; . Вот упрощенный пример перехода между страницами пользователя:</target>
        </trans-unit>
        <trans-unit id="e076b28b9370ba50b790e58f9f840b591db7ff32" translate="yes" xml:space="preserve">
          <source>You should populate data with AJAX calls in the &lt;a href=&quot;react-component#mounting&quot;&gt;&lt;code&gt;componentDidMount&lt;/code&gt;&lt;/a&gt; lifecycle method. This is so you can use &lt;code&gt;setState&lt;/code&gt; to update your component when the data is retrieved.</source>
          <target state="translated">Вы должны заполнить данные вызовами AJAX в методе жизненного цикла &lt;a href=&quot;react-component#mounting&quot;&gt; &lt;code&gt;componentDidMount&lt;/code&gt; &lt;/a&gt; . Это значит, что вы можете использовать &lt;code&gt;setState&lt;/code&gt; для обновления вашего компонента при получении данных.</target>
        </trans-unit>
        <trans-unit id="0100f35a274466dbd299b52916e0b9bb563005fd" translate="yes" xml:space="preserve">
          <source>You should see a message like:</source>
          <target state="translated">Ты должен увидеть такое сообщение:</target>
        </trans-unit>
        <trans-unit id="13d510fce1888c91efd69e647dbd0b1304d066fb" translate="yes" xml:space="preserve">
          <source>You should use the File API to interact with the files. The following example shows how to create a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref to the DOM node&lt;/a&gt; to access file(s) in a submit handler:</source>
          <target state="translated">Вы должны использовать File API для взаимодействия с файлами. В следующем примере показано, как создать &lt;a href=&quot;refs-and-the-dom&quot;&gt;ссылку на узел DOM&lt;/a&gt; для доступа к файлу (файлам) в обработчике отправки:</target>
        </trans-unit>
        <trans-unit id="d1ca77292c866d9beccf3afb5cd22e409404eefd" translate="yes" xml:space="preserve">
          <source>You will have to provide any event property that you&amp;rsquo;re using in your component (e.g. keyCode, which, etc&amp;hellip;) as React is not creating any of these for you.</source>
          <target state="translated">Вам нужно будет предоставить любое свойство события, которое вы используете в своем компоненте (например, keyCode, который и т. Д.), Поскольку React не создает ничего из этого для вас.</target>
        </trans-unit>
        <trans-unit id="38e40adba52fc6a8328c5cb7d32f1ed6f48158d5" translate="yes" xml:space="preserve">
          <source>You will need to have &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;window.document&lt;/code&gt; and &lt;code&gt;window.document.createElement&lt;/code&gt; globally available &lt;strong&gt;before&lt;/strong&gt; you import &lt;code&gt;React&lt;/code&gt;. Otherwise React will think it can&amp;rsquo;t access the DOM and methods like &lt;code&gt;setState&lt;/code&gt; won&amp;rsquo;t work.</source>
          <target state="translated">&lt;strong&gt;Перед&lt;/strong&gt; импортом &lt;code&gt;React&lt;/code&gt; вам необходимо иметь глобально доступные &lt;code&gt;window&lt;/code&gt; , &lt;code&gt;window.document&lt;/code&gt; и &lt;code&gt;window.document.createElement&lt;/code&gt; . В противном случае React будет думать, что не может получить доступ к DOM, и такие методы, как &lt;code&gt;setState&lt;/code&gt; , не будут работать.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="178e11c227368aa687fcf840c5bb6cce64f8f141" translate="yes" xml:space="preserve">
          <source>You will not typically invoke &lt;code&gt;React.createFactory()&lt;/code&gt; directly if you are using JSX. See &lt;a href=&quot;react-without-jsx&quot;&gt;React Without JSX&lt;/a&gt; to learn more.</source>
          <target state="translated">Обычно вы не вызываете &lt;code&gt;React.createFactory()&lt;/code&gt; напрямую, если используете JSX. См. &lt;a href=&quot;react-without-jsx&quot;&gt;React Without JSX,&lt;/a&gt; чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="d6c37686a4d152354398670fa644ad54c4e1c2e0" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see here that we have five components in our app. We&amp;rsquo;ve italicized the data each component represents.</source>
          <target state="translated">Здесь вы увидите, что в нашем приложении есть пять компонентов. Мы выделили курсивом данные, которые представляет каждый компонент.</target>
        </trans-unit>
        <trans-unit id="ca95950510b4946724893118d47847f0a2b910dc" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see this technique used in the &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;react-motion&lt;/a&gt; API.</source>
          <target state="translated">Вы увидите, как этот метод используется в API &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;-&lt;/a&gt; интерфейсе реагирования на движение .</target>
        </trans-unit>
        <trans-unit id="1251760a9d7461170b9cdba14cf50e2f7d2632a4" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to a single child for a component. You may pass multiple children, or even have multiple separate &amp;ldquo;slots&amp;rdquo; for children, &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;as documented here&lt;/a&gt;:</source>
          <target state="translated">Вы не ограничены одним дочерним элементом для компонента. Вы можете передать несколько дочерних элементов или даже иметь несколько отдельных &amp;laquo;слотов&amp;raquo; для детей, &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;как описано здесь&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b2b5019f33196f854492a20c611041c35f250ae6" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations &amp;ldquo;side effects&amp;rdquo; (or &amp;ldquo;effects&amp;rdquo; for short) because they can affect other components and can&amp;rsquo;t be done during rendering.</source>
          <target state="translated">Скорее всего, вы раньше выполняли выборку данных, подписки или ручное изменение DOM из компонентов React. Мы называем эти операции &amp;laquo;побочными эффектами&amp;raquo; (или для краткости &amp;laquo;эффектами&amp;raquo;), потому что они могут влиять на другие компоненты и не могут выполняться во время рендеринга.</target>
        </trans-unit>
        <trans-unit id="9a73bce14cb5ed5814b4d3c8caccbf0a4c71d18f" translate="yes" xml:space="preserve">
          <source>Your bundles will end up looking a lot different than this.</source>
          <target state="translated">Твои связки в итоге будут выглядеть совсем по-другому.</target>
        </trans-unit>
        <trans-unit id="ce6353440854dcd821602f8c565c81d1de3f299a" translate="yes" xml:space="preserve">
          <source>Your code might use timer-based functions like &lt;code&gt;setTimeout&lt;/code&gt; to schedule more work in the future. In this example, a multiple choice panel waits for a selection and advances, timing out if a selection isn&amp;rsquo;t made in 5 seconds:</source>
          <target state="translated">В вашем коде могут использоваться функции на основе таймера, такие как &lt;code&gt;setTimeout&lt;/code&gt; , для планирования дополнительных работ в будущем. В этом примере панель с множественным выбором ожидает выбора и продвигается вперед по тайм-ауту, если выбор не сделан в течение 5 секунд:</target>
        </trans-unit>
        <trans-unit id="9b44d57e851b7cfb9edddaba0f27c8b365611372" translate="yes" xml:space="preserve">
          <source>Your event handlers will be passed instances of &lt;code&gt;SyntheticEvent&lt;/code&gt;, a cross-browser wrapper around the browser&amp;rsquo;s native event. It has the same interface as the browser&amp;rsquo;s native event, including &lt;code&gt;stopPropagation()&lt;/code&gt; and &lt;code&gt;preventDefault()&lt;/code&gt;, except the events work identically across all browsers.</source>
          <target state="translated">Вашим обработчикам событий будут переданы экземпляры &lt;code&gt;SyntheticEvent&lt;/code&gt; , кроссбраузерной оболочки вокруг собственного события браузера. Он имеет тот же интерфейс, что и собственное событие браузера, включая &lt;code&gt;stopPropagation()&lt;/code&gt; и &lt;code&gt;preventDefault()&lt;/code&gt; , за исключением того, что события работают одинаково во всех браузерах.</target>
        </trans-unit>
        <trans-unit id="417ad6992902ba487e093b897d3f6d549a9842ce" translate="yes" xml:space="preserve">
          <source>Your first inclination may be to use refs to &amp;ldquo;make things happen&amp;rdquo; in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to &amp;ldquo;own&amp;rdquo; that state is at a higher level in the hierarchy. See the &lt;a href=&quot;lifting-state-up&quot;&gt;Lifting State Up&lt;/a&gt; guide for examples of this.</source>
          <target state="translated">Возможно, вы в первую очередь захотите использовать ссылки, чтобы &amp;laquo;что-то произошло&amp;raquo; в вашем приложении. Если это так, найдите момент и подумайте более критически о том, где должно принадлежать состояние в иерархии компонентов. Часто становится ясно, что подходящее место для &amp;laquo;владения&amp;raquo; этим состоянием находится на более высоком уровне иерархии. Примеры этого см. В руководстве &amp;laquo; &lt;a href=&quot;lifting-state-up&quot;&gt;Повышение состояния подъема&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e168dcadd81316b93e30e3fb63c119e3eacea3d" translate="yes" xml:space="preserve">
          <source>aXe, aXe-core and react-axe</source>
          <target state="translated">aXe,aXe-ядро и реактивная ось</target>
        </trans-unit>
        <trans-unit id="30044d924582132945f46916ec2d07125a58cf2d" translate="yes" xml:space="preserve">
          <source>act()</source>
          <target state="translated">act()</target>
        </trans-unit>
        <trans-unit id="ff492a83ee72d534e12a356ac58617fc5344b70b" translate="yes" xml:space="preserve">
          <source>at a Glance</source>
          <target state="translated">сразу же</target>
        </trans-unit>
        <trans-unit id="27d975804229db5d33e99922cefc38d130415317" translate="yes" xml:space="preserve">
          <source>can be compiled to this code that does not use JSX:</source>
          <target state="translated">может быть скомпилирован с этим кодом,который не использует JSX:</target>
        </trans-unit>
        <trans-unit id="75e4aedce48faf384f3535ffeb842e9a0718a25c" translate="yes" xml:space="preserve">
          <source>checked</source>
          <target state="translated">checked</target>
        </trans-unit>
        <trans-unit id="d80a05355eb77272dccf26e73f9d554a520a954d" translate="yes" xml:space="preserve">
          <source>className</source>
          <target state="translated">className</target>
        </trans-unit>
        <trans-unit id="f1808e1fcdfb51765245f7ae10e6d0f7d45dfdb0" translate="yes" xml:space="preserve">
          <source>cloneElement()</source>
          <target state="translated">cloneElement()</target>
        </trans-unit>
        <trans-unit id="d2ac721e1714aa0c2ba51ae76a737a394508c705" translate="yes" xml:space="preserve">
          <source>compiles into:</source>
          <target state="translated">вливается в..:</target>
        </trans-unit>
        <trans-unit id="e04a959dd07839da3d76b649c2746a372ae67d26" translate="yes" xml:space="preserve">
          <source>componentDidCatch()</source>
          <target state="translated">componentDidCatch()</target>
        </trans-unit>
        <trans-unit id="4cbc3930cb5ae51bf4c7c376a47c4a0303cc508f" translate="yes" xml:space="preserve">
          <source>componentDidMount()</source>
          <target state="translated">componentDidMount()</target>
        </trans-unit>
        <trans-unit id="81560e4b9f7ed9f695cb560e570f84260f6da228" translate="yes" xml:space="preserve">
          <source>componentDidUpdate()</source>
          <target state="translated">componentDidUpdate()</target>
        </trans-unit>
        <trans-unit id="040d2c710c56b213bb8d9a190f9d819d99838912" translate="yes" xml:space="preserve">
          <source>componentWillUnmount()</source>
          <target state="translated">componentWillUnmount()</target>
        </trans-unit>
        <trans-unit id="a5cb5262d854a45e4891ceed1de0d0dce3abd1e6" translate="yes" xml:space="preserve">
          <source>constructor()</source>
          <target state="translated">constructor()</target>
        </trans-unit>
        <trans-unit id="6b181ca2ce1831814647e1033acd0415b7894d36" translate="yes" xml:space="preserve">
          <source>createBlockingRoot</source>
          <target state="translated">createBlockingRoot</target>
        </trans-unit>
        <trans-unit id="f4b3ab4f5c383ec52f890d704e0e8f5effedd508" translate="yes" xml:space="preserve">
          <source>createElement()</source>
          <target state="translated">createElement()</target>
        </trans-unit>
        <trans-unit id="6d39c1e12808130963fbdf6fe78aff2f7954e5cd" translate="yes" xml:space="preserve">
          <source>createFactory()</source>
          <target state="translated">createFactory()</target>
        </trans-unit>
        <trans-unit id="225f66482bb6fa2162c71f4678803312729ce679" translate="yes" xml:space="preserve">
          <source>createPortal()</source>
          <target state="translated">createPortal()</target>
        </trans-unit>
        <trans-unit id="3fa4909ead21a618529dabdaf33aa6c9589a71cb" translate="yes" xml:space="preserve">
          <source>createRoot</source>
          <target state="translated">createRoot</target>
        </trans-unit>
        <trans-unit id="b96f7c4dfd5ac22f73a862391a14b9ad9d087ae5" translate="yes" xml:space="preserve">
          <source>dangerouslySetInnerHTML</source>
          <target state="translated">dangerouslySetInnerHTML</target>
        </trans-unit>
        <trans-unit id="4ffa4d174c4a4c8d2e8354a953a93d148fccc03f" translate="yes" xml:space="preserve">
          <source>defaultProps</source>
          <target state="translated">defaultProps</target>
        </trans-unit>
        <trans-unit id="226e8ab97c399ef7e520a8c77ae9ce3fd60b449f" translate="yes" xml:space="preserve">
          <source>displayName</source>
          <target state="translated">displayName</target>
        </trans-unit>
        <trans-unit id="5c7cef6a6a6ef7a482a82974ea4726169eae6264" translate="yes" xml:space="preserve">
          <source>eslint-plugin-jsx-a11y</source>
          <target state="translated">eslint-plugin-jsx-a11y</target>
        </trans-unit>
        <trans-unit id="c230c9b793507553af38b22847c967a1651daabd" translate="yes" xml:space="preserve">
          <source>findAllInRenderedTree()</source>
          <target state="translated">findAllInRenderedTree()</target>
        </trans-unit>
        <trans-unit id="7ebff84a87431408d85d2c3f89d84055a39bd086" translate="yes" xml:space="preserve">
          <source>findDOMNode</source>
          <target state="translated">findDOMNode</target>
        </trans-unit>
        <trans-unit id="d274d46accd6cdefe4324778fc78f215f1e4c91a" translate="yes" xml:space="preserve">
          <source>findDOMNode()</source>
          <target state="translated">findDOMNode()</target>
        </trans-unit>
        <trans-unit id="e9174cad96a72c7e0c1ad1cd53a888fb02ea7804" translate="yes" xml:space="preserve">
          <source>findRenderedComponentWithType()</source>
          <target state="translated">findRenderedComponentWithType()</target>
        </trans-unit>
        <trans-unit id="c9c73f42f55648fc38ef00e038ae1321d85fbc5d" translate="yes" xml:space="preserve">
          <source>findRenderedDOMComponentWithClass()</source>
          <target state="translated">findRenderedDOMComponentWithClass()</target>
        </trans-unit>
        <trans-unit id="325c7573aec2c9a01bf497f8e01ea68e75fcfe2e" translate="yes" xml:space="preserve">
          <source>findRenderedDOMComponentWithTag()</source>
          <target state="translated">findRenderedDOMComponentWithTag()</target>
        </trans-unit>
        <trans-unit id="f634efed29f9466600dce13d06f22a65c4394c9c" translate="yes" xml:space="preserve">
          <source>forceUpdate()</source>
          <target state="translated">forceUpdate()</target>
        </trans-unit>
        <trans-unit id="48c0d6c8247cdebbadbfb27472c725be283719d3" translate="yes" xml:space="preserve">
          <source>getSnapshotBeforeUpdate()</source>
          <target state="translated">getSnapshotBeforeUpdate()</target>
        </trans-unit>
        <trans-unit id="9f9bed174e7ceb8dd32127ea809e17154176a0fe" translate="yes" xml:space="preserve">
          <source>htmlFor</source>
          <target state="translated">htmlFor</target>
        </trans-unit>
        <trans-unit id="2b70ee25b5685a847d42fd561cddbb0347240ffb" translate="yes" xml:space="preserve">
          <source>hydrate()</source>
          <target state="translated">hydrate()</target>
        </trans-unit>
        <trans-unit id="e607f2c2f3a88ee9efc521cc3eb5a8db451bdb56" translate="yes" xml:space="preserve">
          <source>is slightly different in React:</source>
          <target state="translated">немного отличается в Реакции:</target>
        </trans-unit>
        <trans-unit id="38913b96ec33406bdc107dc1a67355715c31b42c" translate="yes" xml:space="preserve">
          <source>isCompositeComponent()</source>
          <target state="translated">isCompositeComponent()</target>
        </trans-unit>
        <trans-unit id="2d0f44b4556319617244d8e3c0101188b4e9d334" translate="yes" xml:space="preserve">
          <source>isCompositeComponentWithType()</source>
          <target state="translated">isCompositeComponentWithType()</target>
        </trans-unit>
        <trans-unit id="e5db90c47987aedfcd4e6b88a002a4d096541964" translate="yes" xml:space="preserve">
          <source>isDOMComponent()</source>
          <target state="translated">isDOMComponent()</target>
        </trans-unit>
        <trans-unit id="1ff3f8d3e07c1aa64975ff6c37b27b245fec7a06" translate="yes" xml:space="preserve">
          <source>isElement()</source>
          <target state="translated">isElement()</target>
        </trans-unit>
        <trans-unit id="cda9aaf24e1c261b047f9583d068a59d6146a5c1" translate="yes" xml:space="preserve">
          <source>isElementOfType()</source>
          <target state="translated">isElementOfType()</target>
        </trans-unit>
        <trans-unit id="8d189028ca88af62009de3301ce91b75ee91f71d" translate="yes" xml:space="preserve">
          <source>isValidElement()</source>
          <target state="translated">isValidElement()</target>
        </trans-unit>
        <trans-unit id="031703ceb37d4e467e3b4873c48829fe96e8be85" translate="yes" xml:space="preserve">
          <source>mockComponent()</source>
          <target state="translated">mockComponent()</target>
        </trans-unit>
        <trans-unit id="6346291a5b44a7e5edb37e6ad83b5d6d14b97973" translate="yes" xml:space="preserve">
          <source>of React Terms</source>
          <target state="translated">реакционные условия</target>
        </trans-unit>
        <trans-unit id="7fe3c585b87fdfd619db73b230eb60673928e282" translate="yes" xml:space="preserve">
          <source>onBlur</source>
          <target state="translated">onBlur</target>
        </trans-unit>
        <trans-unit id="59897a9118de38c1f4300bf9b771b3280b32c69d" translate="yes" xml:space="preserve">
          <source>onChange</source>
          <target state="translated">onChange</target>
        </trans-unit>
        <trans-unit id="33070cf900f7cbaea369fd3262ef1707dbf7b576" translate="yes" xml:space="preserve">
          <source>onFocus</source>
          <target state="translated">onFocus</target>
        </trans-unit>
        <trans-unit id="53cf26e91fa509e97555428c86572d99948c5513" translate="yes" xml:space="preserve">
          <source>or this:</source>
          <target state="translated">или это:</target>
        </trans-unit>
        <trans-unit id="aa60968734f4f4d402439b0e033649c02834cb03" translate="yes" xml:space="preserve">
          <source>props</source>
          <target state="translated">props</target>
        </trans-unit>
        <trans-unit id="a51a890001a811c94e4fda62e34296855ddfb140" translate="yes" xml:space="preserve">
          <source>props.children</source>
          <target state="translated">props.children</target>
        </trans-unit>
        <trans-unit id="4a8d7ba2ca12dcaf16af003dba0a21a54145f550" translate="yes" xml:space="preserve">
          <source>render()</source>
          <target state="translated">render()</target>
        </trans-unit>
        <trans-unit id="e30b6dae1ced5ea662137753850941aae38407fb" translate="yes" xml:space="preserve">
          <source>renderIntoDocument()</source>
          <target state="translated">renderIntoDocument()</target>
        </trans-unit>
        <trans-unit id="3eeeddfe744d288f2a7cc0b1b5d27869afa633bd" translate="yes" xml:space="preserve">
          <source>renderToNodeStream()</source>
          <target state="translated">renderToNodeStream()</target>
        </trans-unit>
        <trans-unit id="5fb112b72758bd2b1c27c4056814291d3fc57875" translate="yes" xml:space="preserve">
          <source>renderToStaticMarkup()</source>
          <target state="translated">renderToStaticMarkup()</target>
        </trans-unit>
        <trans-unit id="5371d3d06de40c111adfa63626996723a8574fd0" translate="yes" xml:space="preserve">
          <source>renderToStaticNodeStream()</source>
          <target state="translated">renderToStaticNodeStream()</target>
        </trans-unit>
        <trans-unit id="a1e2c92c6bbcd7c635f3fc1dec2fadb6e5d28ee3" translate="yes" xml:space="preserve">
          <source>renderToString()</source>
          <target state="translated">renderToString()</target>
        </trans-unit>
        <trans-unit id="d73fd7553e41429de67252dc32008ee31e7dc96a" translate="yes" xml:space="preserve">
          <source>requestAnimationFrame</source>
          <target state="translated">requestAnimationFrame</target>
        </trans-unit>
        <trans-unit id="5fef477110a77ece862b497872e19102ce62d1d3" translate="yes" xml:space="preserve">
          <source>results in a &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; output of:</source>
          <target state="translated">приводит к выводу &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b93c8e43f94949f681de9d694b201cebad28cd67" translate="yes" xml:space="preserve">
          <source>scryRenderedComponentsWithType()</source>
          <target state="translated">scryRenderedComponentsWithType()</target>
        </trans-unit>
        <trans-unit id="aebb7ccb3b46e0525adf0006807bf12321942ae4" translate="yes" xml:space="preserve">
          <source>scryRenderedDOMComponentsWithClass()</source>
          <target state="translated">scryRenderedDOMComponentsWithClass()</target>
        </trans-unit>
        <trans-unit id="611b9475f3c4c5708aa2d088c24cb54bdd8d5eac" translate="yes" xml:space="preserve">
          <source>scryRenderedDOMComponentsWithTag()</source>
          <target state="translated">scryRenderedDOMComponentsWithTag()</target>
        </trans-unit>
        <trans-unit id="835f3b50e33719422d6faca2d01d99417afea46b" translate="yes" xml:space="preserve">
          <source>selected</source>
          <target state="translated">selected</target>
        </trans-unit>
        <trans-unit id="612b427e6504ad2778fa6e4e5081fa2cfdfe48b0" translate="yes" xml:space="preserve">
          <source>setState()</source>
          <target state="translated">setState()</target>
        </trans-unit>
        <trans-unit id="ce05a867c6397422a23f2df9528118a63884828f" translate="yes" xml:space="preserve">
          <source>shallowRenderer.getRenderOutput()</source>
          <target state="translated">shallowRenderer.getRenderOutput()</target>
        </trans-unit>
        <trans-unit id="d9683e6218d9950582c31235c789381795b9a6a7" translate="yes" xml:space="preserve">
          <source>shallowRenderer.render()</source>
          <target state="translated">shallowRenderer.render()</target>
        </trans-unit>
        <trans-unit id="470481efa1f485463319f0673bb633affe7ebd19" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate In Action</source>
          <target state="translated">ДолжныКомпонентОбновить в действии</target>
        </trans-unit>
        <trans-unit id="912f2ad5b0b4be590e85fc8aaad17da9d9b8bae5" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate()</source>
          <target state="translated">shouldComponentUpdate()</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="6f21255dfbf5dc0666959c7a4d5ec0f7cb311c84" translate="yes" xml:space="preserve">
          <source>static getDerivedStateFromError()</source>
          <target state="translated">статическая getDerivedStateFromError()</target>
        </trans-unit>
        <trans-unit id="a8a1daf7425520001825ba5ee0f62272e1942058" translate="yes" xml:space="preserve">
          <source>static getDerivedStateFromProps()</source>
          <target state="translated">статическая getDerivedStateFromProps()</target>
        </trans-unit>
        <trans-unit id="26ec8d00fb6b55466b3a115f1d559422a7fa7aac" translate="yes" xml:space="preserve">
          <source>style</source>
          <target state="translated">style</target>
        </trans-unit>
        <trans-unit id="ec9c9f0131a2a03ef9592dbbf5b6f941e6f067f8" translate="yes" xml:space="preserve">
          <source>suppressContentEditableWarning</source>
          <target state="translated">suppressContentEditableWarning</target>
        </trans-unit>
        <trans-unit id="8c4c14e070b03ee334f69ae4652b54634b91962e" translate="yes" xml:space="preserve">
          <source>suppressHydrationWarning</source>
          <target state="translated">suppressHydrationWarning</target>
        </trans-unit>
        <trans-unit id="c01f3c9d4dbfd20df94186b9bedc6b8ba8cdbabf" translate="yes" xml:space="preserve">
          <source>testInstance.children</source>
          <target state="translated">testInstance.children</target>
        </trans-unit>
        <trans-unit id="4c915ddcb2a485beede7f30f0a39993ca3eaccfb" translate="yes" xml:space="preserve">
          <source>testInstance.find()</source>
          <target state="translated">testInstance.find()</target>
        </trans-unit>
        <trans-unit id="ef7541e9aa2a73eedf7685db30d9d4b2a52e1346" translate="yes" xml:space="preserve">
          <source>testInstance.findAll()</source>
          <target state="translated">testInstance.findAll()</target>
        </trans-unit>
        <trans-unit id="a18a2aa20f4ff41cfbe29515880a5420b8cb7caf" translate="yes" xml:space="preserve">
          <source>testInstance.findAllByProps()</source>
          <target state="translated">testInstance.findAllByProps()</target>
        </trans-unit>
        <trans-unit id="0563b370095c727ef03938afce647600d255d300" translate="yes" xml:space="preserve">
          <source>testInstance.findAllByType()</source>
          <target state="translated">testInstance.findAllByType()</target>
        </trans-unit>
        <trans-unit id="a80d58798674cc0d4d16f85d332446b150cf2508" translate="yes" xml:space="preserve">
          <source>testInstance.findByProps()</source>
          <target state="translated">testInstance.findByProps()</target>
        </trans-unit>
        <trans-unit id="e6726e57ddc7239270aed690310887f17c4ed5a0" translate="yes" xml:space="preserve">
          <source>testInstance.findByType()</source>
          <target state="translated">testInstance.findByType()</target>
        </trans-unit>
        <trans-unit id="24e32ceafa0199c0e634d8a09f601bf4c75dc6ea" translate="yes" xml:space="preserve">
          <source>testInstance.instance</source>
          <target state="translated">testInstance.instance</target>
        </trans-unit>
        <trans-unit id="6fc49889f4c4cf74fb4892e3812cb5238efc37af" translate="yes" xml:space="preserve">
          <source>testInstance.parent</source>
          <target state="translated">testInstance.parent</target>
        </trans-unit>
        <trans-unit id="991a6b588a17504199fd15ee9a6f4d447180a3a0" translate="yes" xml:space="preserve">
          <source>testInstance.props</source>
          <target state="translated">testInstance.props</target>
        </trans-unit>
        <trans-unit id="59239c90818698c1ff479fb8f72464b55fc9ae0e" translate="yes" xml:space="preserve">
          <source>testInstance.type</source>
          <target state="translated">testInstance.type</target>
        </trans-unit>
        <trans-unit id="9ba87352e263ec108b8cb84015e69b21ec153df3" translate="yes" xml:space="preserve">
          <source>testRenderer.getInstance()</source>
          <target state="translated">testRenderer.getInstance()</target>
        </trans-unit>
        <trans-unit id="321ae1cad7565cf2c094665daccc3a626e875bf6" translate="yes" xml:space="preserve">
          <source>testRenderer.root</source>
          <target state="translated">testRenderer.root</target>
        </trans-unit>
        <trans-unit id="cacb1190f356919021ffa862e4827f65254f8342" translate="yes" xml:space="preserve">
          <source>testRenderer.toJSON()</source>
          <target state="translated">testRenderer.toJSON()</target>
        </trans-unit>
        <trans-unit id="838b9c04859c929c640cb6679ed6e88dee0ad2e2" translate="yes" xml:space="preserve">
          <source>testRenderer.toTree()</source>
          <target state="translated">testRenderer.toTree()</target>
        </trans-unit>
        <trans-unit id="3d1450103c3366cf9be062ef311d80a4b548a39f" translate="yes" xml:space="preserve">
          <source>testRenderer.unmount()</source>
          <target state="translated">testRenderer.unmount()</target>
        </trans-unit>
        <trans-unit id="c93dde1e0b286d37d40077ae8c79ff09c3a8b28d" translate="yes" xml:space="preserve">
          <source>testRenderer.update()</source>
          <target state="translated">testRenderer.update()</target>
        </trans-unit>
        <trans-unit id="2d1c22c80fa325ca4df815d1ebdc1147925b2af3" translate="yes" xml:space="preserve">
          <source>unmountComponentAtNode()</source>
          <target state="translated">unmountComponentAtNode()</target>
        </trans-unit>
        <trans-unit id="0bedb35c3b8a80ac3f44b9bac14dfbc4e37efdb9" translate="yes" xml:space="preserve">
          <source>useCallback</source>
          <target state="translated">useCallback</target>
        </trans-unit>
        <trans-unit id="eae3826cdf2f6c64c219ecbd30dd771505bb87ed" translate="yes" xml:space="preserve">
          <source>useContext</source>
          <target state="translated">useContext</target>
        </trans-unit>
        <trans-unit id="8231dd7a518591bf2d9d957972cf313c1109e75b" translate="yes" xml:space="preserve">
          <source>useDebugValue</source>
          <target state="translated">useDebugValue</target>
        </trans-unit>
        <trans-unit id="3e0fe2934c5acc6440f9c9169e5d9a241b6d23cf" translate="yes" xml:space="preserve">
          <source>useDeferredValue</source>
          <target state="translated">useDeferredValue</target>
        </trans-unit>
        <trans-unit id="b70d205ec49487a219eb853fe1054028bf43991e" translate="yes" xml:space="preserve">
          <source>useDeferredValue Config</source>
          <target state="translated">useDeferredValue Config</target>
        </trans-unit>
        <trans-unit id="26c55908ffcc066654803d696c358e2631cf940d" translate="yes" xml:space="preserve">
          <source>useEffect</source>
          <target state="translated">useEffect</target>
        </trans-unit>
        <trans-unit id="45040bb8abbff5eebf6ea2143e010c489b1650bb" translate="yes" xml:space="preserve">
          <source>useImperativeHandle</source>
          <target state="translated">useImperativeHandle</target>
        </trans-unit>
        <trans-unit id="babcde59d67ee82a21532cbed73f4914eeae6430" translate="yes" xml:space="preserve">
          <source>useLayoutEffect</source>
          <target state="translated">useLayoutEffect</target>
        </trans-unit>
        <trans-unit id="7134ae428d908b7a4b3d2527d83ec7a81d55f99d" translate="yes" xml:space="preserve">
          <source>useMemo</source>
          <target state="translated">useMemo</target>
        </trans-unit>
        <trans-unit id="aba72ff13cf2cb2f8078b149e16a9774c992fe86" translate="yes" xml:space="preserve">
          <source>useReducer</source>
          <target state="translated">useReducer</target>
        </trans-unit>
        <trans-unit id="17ab3e5a1cb289c329720c8fd155c9bc8f22bedc" translate="yes" xml:space="preserve">
          <source>useRef</source>
          <target state="translated">useRef</target>
        </trans-unit>
        <trans-unit id="7aa25205d04ad57a2b7896eb24dd7f3407d332cf" translate="yes" xml:space="preserve">
          <source>useState</source>
          <target state="translated">useState</target>
        </trans-unit>
        <trans-unit id="d7705f0ea90572940d0eb8f6df4eeb064570303d" translate="yes" xml:space="preserve">
          <source>useTransition</source>
          <target state="translated">useTransition</target>
        </trans-unit>
        <trans-unit id="d1eb6757e6abcda4059f5f0fdd80f7ca6d09ab3b" translate="yes" xml:space="preserve">
          <source>useTransition Config</source>
          <target state="translated">useTransition Config</target>
        </trans-unit>
        <trans-unit id="f32b67c7e26342af42efabc674d441dca0a281c5" translate="yes" xml:space="preserve">
          <source>value</source>
          <target state="translated">value</target>
        </trans-unit>
        <trans-unit id="057b6197438cfa301937d3f5cb47577adb242a9e" translate="yes" xml:space="preserve">
          <source>webpack</source>
          <target state="translated">webpack</target>
        </trans-unit>
        <trans-unit id="7ce83ec9cfed7121529d2fe247b4421dd66a5342" translate="yes" xml:space="preserve">
          <source>which results in a correct &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; output of:</source>
          <target state="translated">что приводит к правильному выводу &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aca8ac649e8becdb6a0f2276dad67b03cc039c67" translate="yes" xml:space="preserve">
          <source>⚡️ Effect Hook</source>
          <target state="translated">⚡️ Крючок для эффектов</target>
        </trans-unit>
        <trans-unit id="1cee944946bff8d51e351ab4c7bd42a5de041a84" translate="yes" xml:space="preserve">
          <source>✅</source>
          <target state="translated">✅</target>
        </trans-unit>
        <trans-unit id="f3c3656b9154abf44c13c92e6fda9c4ec21209f2" translate="yes" xml:space="preserve">
          <source>✅ Call Hooks from React function components.</source>
          <target state="translated">✅ Вызов хуков из функциональных компонентов React.</target>
        </trans-unit>
        <trans-unit id="17d726472261fbbf511f74b762b9ac0c2abbd8e9" translate="yes" xml:space="preserve">
          <source>✅ Call Hooks from custom Hooks (we&amp;rsquo;ll learn about them &lt;a href=&quot;hooks-custom&quot;&gt;on the next page&lt;/a&gt;).</source>
          <target state="translated">✅ Вызов хуков из пользовательских хуков (мы узнаем о них &lt;a href=&quot;hooks-custom&quot;&gt;на следующей странице&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="05eb764599eda96ea06ff7639bc59541f5e05465" translate="yes" xml:space="preserve">
          <source>✌️ Rules of Hooks</source>
          <target state="translated">✌️ Правила крючков</target>
        </trans-unit>
        <trans-unit id="45c8b34a57dcfe0d9f8bd262c7212971fccdb70c" translate="yes" xml:space="preserve">
          <source>💡 Building Your Own Hooks</source>
          <target state="translated">💡 Создание собственных крючков</target>
        </trans-unit>
        <trans-unit id="aee90788022779419adf70a0034f4341d4663fc9" translate="yes" xml:space="preserve">
          <source>📌 State Hook</source>
          <target state="translated">📌 Государственный крюк</target>
        </trans-unit>
        <trans-unit id="466bf681aeece7094a8988a08d9ebde47be027ac" translate="yes" xml:space="preserve">
          <source>🔌 Other Hooks</source>
          <target state="translated">🔌 Другие крючки</target>
        </trans-unit>
        <trans-unit id="1fee3b4a52f8bbba1ae107f01184ad871cfe4a4b" translate="yes" xml:space="preserve">
          <source>🚫</source>
          <target state="translated">🚫</target>
        </trans-unit>
        <trans-unit id="982828f9c89097fe661e44f5d2fe2056691fa614" translate="yes" xml:space="preserve">
          <source>🚫*</source>
          <target state="translated">🚫*</target>
        </trans-unit>
        <trans-unit id="9cc8c9733dba90ff1738546ec90ea16e4ef8489f" translate="yes" xml:space="preserve">
          <source>🚫**</source>
          <target state="translated">🚫**</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
