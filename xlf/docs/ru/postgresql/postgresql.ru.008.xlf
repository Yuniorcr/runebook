<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d06f9c00387f2a47db4df9d5fd9d29afd85a64d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.60. General-Purpose Window Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.60. Оконные функции общего назначения&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a7332511d931adb3973faa13e02e9a2f58c70fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.61. Series Generating Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.61. Функции генерации серий&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09c4a37f6c6f303582adee38d96973e59b8f1d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.62. Subscript Generating Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.62. Функции генерации нижнего индекса&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2135932869620b53f88c3e6313d35e2e57eb9554" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.63. Session Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.63. Информационные функции сеанса&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39be6ee87ea95e25c83a72d132334349eca53d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.64. Access Privilege Inquiry Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.64. Функции запроса привилегий доступа&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f88ee46d75d93ee18420ab0ac7544df7b69f3ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.65. &lt;code&gt;aclitem&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.65. Операторы &lt;code&gt;aclitem&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bff51c4fac1999b618aa6e81c66b1e1f53e8a09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.66. &lt;code&gt;aclitem&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.66. &lt;code&gt;aclitem&lt;/code&gt; Функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6ba9eacd371b2f2875e8cef1278fb77ebcd99c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.67. Schema Visibility Inquiry Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.67. Функции запроса видимости схемы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47c6aca319addf46ce6b419f1af927dda7149772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.68. System Catalog Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.68. Системный каталог Информационные функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59944c027b46284746c3c0d85e815a750a8891d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.69. Index Column Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.69. Свойства столбца индекса&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1714aed665ee3ec122913f297f2add6146e8617b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.7. Trigonometric Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.7. Тригонометрические функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1931873243f7b29fd60849cb0265f82b1b3daa21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.70. Index Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.70. Свойства индекса&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="494455ae6249fdb9eaf4bc96c399bcc0b3287c53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.71. Index Access Method Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.71. Свойства метода доступа индекса&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d4a0d7f19cdaf9dd206d8238d622ef290fa34c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.72. Object Information and Addressing Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.72. Информация об объекте и функции адресации&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2397166ddbff9e584fb4c1463d367dec3f650e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.73. Comment Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.73. Комментировать Информационные функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9e98e7f47369de4f674860d137be126fa8ff10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.74. Transaction ID and Snapshot Information Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e1c97f51ff6d0e29990ff06de5f0ff4842e1bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.74. Transaction IDs and Snapshots&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.74. Идентификаторы транзакций и снимки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9297bd2822b43f167f4851fa970b2be7bc55e646" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.75. Snapshot Components&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.75. Компоненты моментальных снимков&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9fe3f4e24a04a45285feb4f7f3c39797576ff14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.76. Committed Transaction Information&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.76. Информация о подтвержденной транзакции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec457094df6650e5b59b2d695b38d59162000858" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.76. Deprecated Transaction ID and Snapshot Information Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037beea666806eb579eb1e15cade8169bb088d22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.77. Committed Transaction Information Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22faf23155a7f6cdba38cb993e993be8e97bdafa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.77. Control Data Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.77. Функции управления данными&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10369b4d2384de89827853c38a3dbb088df94279" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.78. &lt;code&gt;pg_control_checkpoint&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.78. Столбцы &lt;code&gt;pg_control_checkpoint&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4c03e3db71b0f0e87bd2ea049915cd526ae3e4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.78. Control Data Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a853addac70ca1f81119d41bef07e20f8877b599" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.79. &lt;code&gt;pg_control_checkpoint&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be67b2ae4fcc41758e4db5cec6bff447ce947830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.79. &lt;code&gt;pg_control_system&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.79. Столбцы &lt;code&gt;pg_control_system&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc142fb66ffa0a6f7f6394c00a57cfad199c4be9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.8. Hyperbolic Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.8. Гиперболические функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69d99a933c31e93d42b87a8d05638885de6cef43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.80. &lt;code&gt;pg_control_init&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.80. Столбцы &lt;code&gt;pg_control_init&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f8b6c4cc1095d92081bffbb653c34b6d02d3743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.80. &lt;code&gt;pg_control_system&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a173f9966d00cc18bb434a3a4ab064b9459dfff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.81. &lt;code&gt;pg_control_init&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe7424b608f8ebbc9334ad7d348b73c225f8065" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.81. &lt;code&gt;pg_control_recovery&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.81. Столбцы &lt;code&gt;pg_control_recovery&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a159d3ea3ae4f3ccfc518444dfa8484fdb024615" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.82. &lt;code&gt;pg_control_recovery&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258d4eca1eec881df06fbf6eb5c508a7eb4defe6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.82. Configuration Settings Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.82. Функции настроек конфигурации&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e119847bd2faa7c76a5c66565911ba36a9ec0410" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.83. Configuration Settings Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af63c82b09a5fd893d3cbed8d4c9b65a84c8cc49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.83. Server Signaling Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.83. Функции сигнализации сервера&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e11c93734b157fd8c86baa8c5096f64613f03240" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.84. Backup Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.84. Функции управления резервным копированием&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2acca3a24f9bc4df489286e833e69b95dc624f3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.84. Server Signaling Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2eccbc931adbf83e2e35ba4730cc92f21be424" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.85. Backup Control Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cf89f9807ef48af5dc5feac483e531ed89fb76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.85. Recovery Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.85. Функции восстановления информации&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eb7192e9cdc53717cb1d3a3d7a47063c367c5fd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.86. Recovery Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.86. Функции управления восстановлением&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="18d1b2e85a47e7957190d7b5366cb8b95a8619e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.86. Recovery Information Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c22940566328cfb562e298f923b5c5b854ba617" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.87. Recovery Control Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc57c799c7d7ee53ed8b4b0bf37c2b80ea6845e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.87. Snapshot Synchronization Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.87. Функции синхронизации снимков&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56158ae74f61cf23e3e86908ca0820720f4c8518" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.88. Replication SQL Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.88. Функции SQL репликации&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e4a778f3f4aea3b01888a18431c4aec5450cf91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.88. Snapshot Synchronization Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a72ba96b99dede4aa68dbbb8f2f4f443280905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.89. Database Object Size Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.89. Функции размера объекта базы данных&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c7eb24e29872bb8ce841d184195dca28e365a088" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.89. Replication Management Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0821b82f66d9f4a6e0cd038e52ed04c3f7a05a58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.9. SQL String Functions and Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.9. Строковые функции и операторы SQL&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8690793f9807c3f5f8ee02a7cc52f489067f885d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.90. Database Object Location Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.90. Функции размещения объектов базы данных&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57f81cd7ef731234c1aa58e5ac57c4b20d50b59f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.90. Database Object Size Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dac1ecbd39f8f56220a662263d1df23c3bd1d5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.91. Collation Management Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.91. Функции управления сопоставлением&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="648f3f86b8b877c2a7cf1d1174a61e4e892421ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.91. Database Object Location Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75784f3209f818a7b4abe3d1335fa8a55370c481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.92. Collation Management Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d40194ab60a69acde4e12b20bea43def6aedf5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.92. Partitioning Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.92. Разбиение информационных функций&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c370022e15dfd2d0b3991d342e19956b98c04f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.93. Index Maintenance Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.93. Функции обслуживания индекса&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2937ed5c90d57a915d7a2b0a154f93953f850843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.93. Partitioning Information Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8379ad039963b5ac568013d446df9562b67c6abc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.94. Generic File Access Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.94. Общие функции доступа к файлам&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42b95f05574afc667abf5b3192f21fdebd527e31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.94. Index Maintenance Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e2d3bc1f47aa4a1635eb7f3cff3425017bca1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.95. Advisory Lock Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица 9.95. Консультативные функции блокировки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3110ab11d26d5acb24d0ef4008dbf1062e59f19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.95. Generic File Access Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669703497d2e61484f74a9f852b77c7dbe96af61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.96. Advisory Lock Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd947ce6d00206881c9746604187286ad479d127" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table A.1. PostgreSQL Error Codes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица A.1. Коды ошибок PostgreSQL&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a05dac2107a5f9f2ac31f3b94de8292ede9abce7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.1. Month Names&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица B.1. Названия месяцев&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d0ce6d7b1e15e8e01aa65312fb0df9adeaf930d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.2. Day of the Week Names&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица B.2. Имена дней недели&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4035fdc79af664ad037421045dfc08f552eb1aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.3. Date/Time Field Modifiers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица B.3. Модификаторы поля даты / времени&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="559edd83cb5073785f38017209bf4a3b36ac0ed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table C.1. SQL Key Words&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица C.1. Ключевые слова SQL&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d10534ea211538918961793e09cac043e6061f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.1. &lt;code&gt;adminpack&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.1. Функции &lt;code&gt;adminpack&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b519c1bf6f735544d2045d66c60755bcd006027" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.10. &lt;code&gt;intarray&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.10. Операторы &lt;code&gt;intarray&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c07b2821b106599e7e19c067ef0623853754e74b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.11. &lt;code&gt;isn&lt;/code&gt; Data Types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.11. &lt;code&gt;isn&lt;/code&gt; Типы данных&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9de57df1bb6bd0b8cf1c93e4ac13f3f2cd6cec28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.12. &lt;code&gt;isn&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.12. &lt;code&gt;isn&lt;/code&gt; Функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5fc76943f1f53439b794c832fa0195dc25753eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.13. &lt;code&gt;ltree&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.13. Операторы &lt;code&gt;ltree&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f47dedf5cd81c558ae828df89aeceeffbcca4ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.14. &lt;code&gt;ltree&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.14. &lt;code&gt;ltree&lt;/code&gt; Функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db1ea3c10d5f847276d5255278d415ebe4cfbb7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.15. &lt;code&gt;pg_buffercache&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.15. Столбцы &lt;code&gt;pg_buffercache&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bb70b4765f6524df3f91e44d66f42eb9ce59f1f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.16. Supported Algorithms for &lt;code&gt;crypt()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.16. Поддерживаемые алгоритмы для &lt;code&gt;crypt()&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="74efd3a20d0a5ca77d9ec0d65a88482478d0db59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.17. Iteration Counts for &lt;code&gt;crypt()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.17. Количество итераций для &lt;code&gt;crypt()&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e16082250b8218899af06afb261507b192bd2a3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.18. Hash Algorithm Speeds&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.18. Скорость алгоритма хеширования&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="023c35c98f9f91629573b50cb356cd985b32d53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.19. Summary of Functionality with and without OpenSSL&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.19. Краткое описание функциональности с OpenSSL и без него&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97b5d7566b2274950bfb99f59140174951e32afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.2. Cube External Representations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.2. Внешние представления куба&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="31519ff8934e1c9d30bb975be3e1d15050040610" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.20. &lt;code&gt;pgrowlocks&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.20. &lt;code&gt;pgrowlocks&lt;/code&gt; вывода pgrowlocks&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40ee7b256a4076cfeae51995de13c374ee02588a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.21. &lt;code&gt;pg_stat_statements&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.21. Столбцы &lt;code&gt;pg_stat_statements&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2bf9da321dec29d80c37b3aec85adcfd8d4e6ca7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.22. &lt;code&gt;pgstattuple&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.22. &lt;code&gt;pgstattuple&lt;/code&gt; вывода pgstattuple&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36d397f9b671a3e1925bb2eb0936f8f0832e9789" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.23. &lt;code&gt;pgstattuple_approx&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.23. &lt;code&gt;pgstattuple_approx&lt;/code&gt; Выходные столбцы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c437a7af148f8e8389f5c7449218ce3b637fba68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.24. &lt;code&gt;pg_trgm&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.24. Функции &lt;code&gt;pg_trgm&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76d05073c0bf7063af3660fac90eb31ef8a83d22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.25. &lt;code&gt;pg_trgm&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.25. Операторы &lt;code&gt;pg_trgm&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b53fc25e7d7cf3149fa7d701cb97669cc4302291" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.26. &lt;code&gt;seg&lt;/code&gt; External Representations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.26. &lt;code&gt;seg&lt;/code&gt; Внешние представительства&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fce95711636b8b7c0ab0c8c90a10676ec4c5dd99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.27. Examples of Valid &lt;code&gt;seg&lt;/code&gt; Input&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.27. Примеры допустимого ввода &lt;code&gt;seg&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0703329077e17e37589124cf687bfbdb4ff5f02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.28. Seg GiST Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.28. Операторы Seg GiST&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7efb677aa5a54059bffe378ceabe3ff851dc97be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.29. Sepgsql Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.29. Функции Sepgsql&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3a4b5bfe663b6c86554a4fe157eb1e9883705ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.3. Cube Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.3. Операторы куба&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2f068919e3f99a106ec1019bd78e8bde34335d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.30. &lt;code&gt;tablefunc&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.30. &lt;code&gt;tablefunc&lt;/code&gt; Функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c27a41af6ae7cee6f4a14c9d9a0b8aef27e683da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.31. &lt;code&gt;connectby&lt;/code&gt; Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.31. Параметры &lt;code&gt;connectby&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eccc0fa14874dcf09c6ccf36766eb1c65d7a9d87" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.32. Functions for UUID Generation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.32. Функции для генерации UUID&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="285949d92f8186403bfcd2046f6dcc6813339504" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.33. Functions Returning UUID Constants&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.33. Функции, возвращающие константы UUID&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce4775173e0a8d85b3a4c68976acfaac26cdbeba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.34. &lt;code&gt;xml2&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2710d2338031518ccc53baf6792d41b5ad8f677" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.34. Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.34. Функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e4038c34dc95dfcc18297824a175effec134055" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.35. &lt;code&gt;xpath_table&lt;/code&gt; Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.35. Параметры &lt;code&gt;xpath_table&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42b35f9c6abb36ad8fc92db8bdc01beb1c4250a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.4. Cube Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.4. Функции куба&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e92b11d7884dfede47b04bfcbf5a41bf72e63d9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.5. Cube-Based Earthdistance Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.5. Кубические функции расстояния от Земли&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e051b81229455604f98408865a6ac1b4addebbc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.6. Point-Based Earthdistance Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.6. Точечные наземные операторы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="abcf169338c4abfd8292e2d9fff28e5b2b09033c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.7. &lt;code&gt;hstore&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.7. Операторы &lt;code&gt;hstore&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40c6e68eca0fdcd7802454203dbb36dbc3ddb825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.8. &lt;code&gt;hstore&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.8. Функции &lt;code&gt;hstore&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1d86c143b9375e6f997fb5dadf92e3e129f96c3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.9. &lt;code&gt;intarray&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица F.9. Функции &lt;code&gt;intarray&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d890fb1a42200a1b33e3307e2ccd5c9035ab6794" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table K.1. PostgreSQL Limitations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Таблица K.1. Ограничения PostgreSQL&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="696c4ceafbfe949ae4e1ac9f260a8e4f375683bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table of Contents&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Оглавление&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bf69c48186996b82fe7b81247ad9250cfca6c96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table-Level Lock Modes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Режимы блокировки на уровне таблицы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be38ff52aef87b71c69cb929026cdf03c79939a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type Resolution for &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;CASE&lt;/code&gt;, and Related Constructs&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Разрешение типов для &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;CASE&lt;/code&gt; и связанных конструкций&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5460fb3b002cb82e36bdab3a44937749c957abe2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Upgrade streaming replication and log-shipping standby servers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обновите резервные серверы потоковой репликации и доставки журналов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0c5de3159b80d3a3ca8692e2ddf1964928d7107" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;split&lt;/code&gt;. &lt;/strong&gt; The &lt;code&gt;split&lt;/code&gt; command allows you to split the output into smaller files that are acceptable in size to the underlying file system. For example, to make chunks of 1 megabyte:</source>
          <target state="translated">&lt;strong&gt;Используйте &lt;code&gt;split&lt;/code&gt; . &lt;/strong&gt;Команда &lt;code&gt;split&lt;/code&gt; позволяет разделить вывод на файлы меньшего размера, приемлемые по размеру для базовой файловой системы. Например, чтобы сделать куски размером 1 мегабайт:</target>
        </trans-unit>
        <trans-unit id="1a80b9aa68fb3c8b73036c3ce7eec622afb708fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use compressed dumps. &lt;/strong&gt; You can use your favorite compression program, for example gzip:</source>
          <target state="translated">&lt;strong&gt;Используйте сжатые дампы. &lt;/strong&gt;Вы можете использовать свою любимую программу сжатия, например gzip:</target>
        </trans-unit>
        <trans-unit id="1abab695321f295c720b6c84d1b5599f942c1413" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use pg_dump's custom dump format. &lt;/strong&gt; If PostgreSQL was built on a system with the zlib compression library installed, the custom dump format will compress data as it writes it to the output file. This will produce dump file sizes similar to using &lt;code&gt;gzip&lt;/code&gt;, but it has the added advantage that tables can be restored selectively. The following command dumps a database using the custom dump format:</source>
          <target state="translated">&lt;strong&gt;Используйте собственный формат дампа pg_dump. &lt;/strong&gt;Если PostgreSQL был собран в системе с установленной библиотекой сжатия zlib, пользовательский формат дампа будет сжимать данные по мере их записи в выходной файл. Это приведет к созданию файлов дампа, аналогичных использованию &lt;code&gt;gzip&lt;/code&gt; , но у него есть дополнительное преимущество, заключающееся в том, что таблицы можно восстанавливать выборочно. Следующая команда выводит базу данных в настраиваемом формате дампа:</target>
        </trans-unit>
        <trans-unit id="cbfe9fc7a7a29e0a0178f83061d2c90c3e3b191c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use pg_dump's parallel dump feature. &lt;/strong&gt; To speed up the dump of a large database, you can use pg_dump's parallel mode. This will dump multiple tables at the same time. You can control the degree of parallelism with the &lt;code&gt;-j&lt;/code&gt; parameter. Parallel dumps are only supported for the &quot;directory&quot; archive format.</source>
          <target state="translated">&lt;strong&gt;Используйте функцию параллельного дампа pg_dump. &lt;/strong&gt;Чтобы ускорить создание дампа большой базы данных, вы можете использовать параллельный режим pg_dump. Это приведет к сбросу нескольких таблиц одновременно. Вы можете контролировать степень параллелизма с помощью параметра &lt;code&gt;-j&lt;/code&gt; . Параллельные дампы поддерживаются только для формата архива &amp;laquo;каталог&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="edfa928646e2342a7f8cd8c011c0572d9d895659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value Storage Type Conversion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Преобразование типа хранения значений&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf7bb1fedc9115854eb42fd28c3bf8a588f25119" translate="yes" xml:space="preserve">
          <source>@ 1 year 2 mons</source>
          <target state="translated">@ 1 год 2 мес.</target>
        </trans-unit>
        <trans-unit id="03555338c898371183a9886d4e4b1c92f3732990" translate="yes" xml:space="preserve">
          <source>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</source>
          <target state="translated">@ 1 год 2 мес -3 дня 4 часа 5 минут 6 секунд назад</target>
        </trans-unit>
        <trans-unit id="81d943392746fd8a7d1a28c6c2928f65ea407380" translate="yes" xml:space="preserve">
          <source>@ 3 days 4 hours 5 mins 6 secs</source>
          <target state="translated">@ 3 дня 4 часа 5 минут 6 секунд</target>
        </trans-unit>
        <trans-unit id="bf2057e4a34b0143c5ca30f416938d0496f64cf4" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;from SQL&amp;rdquo; function that converts the type from the SQL environment to the language. This function will be invoked on the arguments of a function written in the language.</source>
          <target state="translated">Функция &amp;laquo;из SQL&amp;raquo;, которая преобразует тип из среды SQL в язык. Эта функция будет вызываться для аргументов функции, написанной на этом языке.</target>
        </trans-unit>
        <trans-unit id="5d8d466be36923654e1e5048281d3752210ffa26" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;nil&amp;rdquo; UUID constant, which does not occur as a real UUID.</source>
          <target state="translated">Константа UUID &quot;nil&quot;, которая не встречается как настоящий UUID.</target>
        </trans-unit>
        <trans-unit id="2762eb369c90d7266035a7f6c6fc6bc10aa918a6" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;search&amp;rdquo; operator entry indicates that an index of this operator family can be searched to find all rows satisfying &lt;code&gt;WHERE&lt;/code&gt;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Obviously, such an operator must return &lt;code&gt;boolean&lt;/code&gt;, and its left-hand input type must match the index's column data type.</source>
          <target state="translated">&amp;laquo;Поиск&amp;raquo; запись оператор указывает , что индекс этого семейства операторов можно искать , чтобы найти все строки , удовлетворяющие &lt;code&gt;WHERE&lt;/code&gt; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; . Очевидно, что такой оператор должен возвращать &lt;code&gt;boolean&lt;/code&gt; , а его левый тип ввода должен соответствовать типу данных столбца индекса.</target>
        </trans-unit>
        <trans-unit id="cb8c23a8cc28795360368ac535c18eb45a0b60b7" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;to SQL&amp;rdquo; function that converts the type from the language to the SQL environment. This function will be invoked on the return value of a function written in the language.</source>
          <target state="translated">Функция &amp;laquo;в SQL&amp;raquo;, которая преобразует тип из языка в среду SQL. Эта функция будет вызываться для возвращаемого значения функции, написанной на этом языке.</target>
        </trans-unit>
        <trans-unit id="3ae930caf5146f65e1ff7504137e6bf65415863f" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;user logging out&amp;rdquo; might happen as part of a maintenance job or manually when an administrator logs in as the &lt;code&gt;postgres&lt;/code&gt; user or something similar, so it is hard to prevent in general.</source>
          <target state="translated">&amp;laquo;Выход пользователя из системы&amp;raquo; может происходить как часть работы по обслуживанию или вручную, когда администратор входит в систему как пользователь &lt;code&gt;postgres&lt;/code&gt; или что-то подобное, поэтому в целом его трудно предотвратить.</target>
        </trans-unit>
        <trans-unit id="1ff3ebb0f8189d5c79fdc8dc5893085ae875532b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; that is paired with a &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; database and is maintaining a copy of some or all of the primary database's data. The foremost reasons for doing this are to allow for greater access to that data, and to maintain availability of the data in the event that the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; becomes unavailable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b194a0aad401cf33db00ac53a2bc3183f5f056e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;cluster&lt;/a&gt;'s storage space comprises the data directory plus any additional tablespaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2f7268e91d10d9931079a4060abb1b24912d62" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; that combines (&lt;em&gt;aggregates&lt;/em&gt;) multiple input values, for example by counting, averaging or adding, yielding a single output value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8de6f610e2bf77390b8a376c81b44793683355f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; which can be defined to execute whenever a certain operation (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;) is applied to a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;. A trigger executes within the same &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; as the statement which invoked it, and if the function fails, then the invoking statement also fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2fccb32e2fa61d4f930e061e62abd8488bb50a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that contains data derived from a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized view&lt;/a&gt;. Its internal structure supports fast retrieval of and access to the original data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584813927fa0b70a127a5ac34c88fc5f5c387c54" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is defined by a &lt;code&gt;SELECT&lt;/code&gt; statement (just like a &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;view&lt;/a&gt;), but stores data in the same way that a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; does. It cannot be modified via &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389fa46ef8422aab8a4910b862a288c61f74078c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is defined by a &lt;code&gt;SELECT&lt;/code&gt; statement, but has no storage of its own. Any time a query references a view, the definition of the view is substituted into the query as if the user had typed it as a subquery instead of the name of the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c9b267d1a3c53d206839f21ecc0e74a5743f97" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is in semantic terms the same as a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, but whose storage is distributed across several &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;partitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4beb53d2dd032e24132f47b79c4ab9ee08f60da3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; transmitted from a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend process&lt;/a&gt; to a &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client&lt;/a&gt; upon the completion of an SQL command, usually a &lt;code&gt;SELECT&lt;/code&gt; but it can be an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; command if the &lt;code&gt;RETURNING&lt;/code&gt; clause is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e75dd492c3448df99f37b47329397dc097e33f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which appears to have &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; similar to a regular &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, but will forward requests for data through its &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt;, which will return &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;result sets&lt;/a&gt; structured according to the definition of the &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2896c9fab918dbff2c145f3310c61dcc0ebaadf8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;role&lt;/a&gt; that has the &lt;code&gt;LOGIN&lt;/code&gt; privilege.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0269b93f9965a7efd0bd4de79b884ef8ce24927" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; is considered &lt;a href=&quot;glossary#GLOSSARY-LOGGED&quot;&gt;logged&lt;/a&gt; if changes to it are sent to the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. By default, all regular tables are logged. A table can be specified as &lt;a href=&quot;glossary#GLOSSARY-UNLOGGED&quot;&gt;unlogged&lt;/a&gt; either at creation time or via the &lt;code&gt;ALTER TABLE&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f22694b8568dac5808dc2163d1d852566c139b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command which will provide the columns and rows of the view.</source>
          <target state="translated">Команда &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; или &lt;a href=&quot;sql-values&quot;&gt;VALUES,&lt;/a&gt; которая предоставит столбцы и строки представления.</target>
        </trans-unit>
        <trans-unit id="f5f1049f4109dc5db352ab8d92ece996eabd228c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command which will provide the rows to be returned by the cursor.</source>
          <target state="translated">Команда &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; или &lt;a href=&quot;sql-values&quot;&gt;VALUES,&lt;/a&gt; которая предоставит строки, возвращаемые курсором.</target>
        </trans-unit>
        <trans-unit id="b8b71200935bf14bcaf475eabe324c9a915be563" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;, or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command, or an &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; command that runs a prepared &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;TABLE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; query.</source>
          <target state="translated">Команда &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; , &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt; или &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; или команда &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE,&lt;/a&gt; которая запускает подготовленный запрос &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;TABLE&lt;/code&gt; или &lt;code&gt;VALUES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b516d250c25b6e73cb44ebe944600ea4dcdfab57" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;, or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command. This query will run within a security-restricted operation; in particular, calls to functions that themselves create temporary tables will fail.</source>
          <target state="translated">Команда &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; , &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt; или &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; . Этот запрос будет выполняться в рамках операции с ограничением безопасности; в частности, вызовы функций, которые сами создают временные таблицы, завершатся ошибкой.</target>
        </trans-unit>
        <trans-unit id="4c32cd6f04f46fa40c66ced5598180206388bcb3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;, &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; command whose results are to be copied. Note that parentheses are required around the query.</source>
          <target state="translated">Команда &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; , &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; , &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; или &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; , результаты которой должны быть скопированы. Обратите внимание, что запрос заключен в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="3aac443fc49c397d670128be5de3b30376a87d25" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;&lt;/code&gt; operator must be a strong ordering relation; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; Оператор должен быть сильным упорядоченность отношение; то есть для всех ненулевых значений &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="819a83c6160f87b8fbe9b47f7e8c2fcb8b3441e2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CASE&lt;/code&gt; construct used in this fashion will defeat optimization attempts, so it should only be done when necessary. (In this particular example, it would be better to sidestep the problem by writing &lt;code&gt;y &amp;gt; 1.5*x&lt;/code&gt; instead.)</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; конструкция используется таким образом победите попытки оптимизации, так что это должно быть сделано в случае необходимости только. (В этом конкретном примере было бы лучше обойти проблему, написав вместо этого &lt;code&gt;y &amp;gt; 1.5*x&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="6247b7100ee328df210a70a605d94770307d4618" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CASE&lt;/code&gt; expression does not evaluate any subexpressions that are not needed to determine the result. For example, this is a possible way of avoiding a division-by-zero failure:</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; выражение не оценивает любые подвыражения, которые не нужны для определения результата. Например, это возможный способ избежать отказа при делении на ноль:</target>
        </trans-unit>
        <trans-unit id="99c1d2ec7824e3f9be873b53497fbe438c59e00f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CREATE FUNCTION&lt;/code&gt; command is defined in the SQL standard. The PostgreSQL version is similar but not fully compatible. The attributes are not portable, neither are the different available languages.</source>
          <target state="translated">Команда &lt;code&gt;CREATE FUNCTION&lt;/code&gt; определена в стандарте SQL. Версия PostgreSQL похожа, но не полностью совместима. Атрибуты не переносимы, как и другие доступные языки.</target>
        </trans-unit>
        <trans-unit id="72fba28ad575d8675106f7a64f95b2cad77d64bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; command is defined in the SQL standard. The PostgreSQL version is similar but not fully compatible. For details see also &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;.</source>
          <target state="translated">Команда &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; определена в стандарте SQL. Версия PostgreSQL похожа, но не полностью совместима. Подробнее см. Также &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d8bad9823a1eeb3d425248ce5d647ad68ad9035" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DELETE&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being deleted from the relation, so that there is no new row to check.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; политик не может иметь &lt;code&gt;WITH CHECK&lt;/code&gt; выражения, так как оно применяется только в тех случаях , когда записи удаляются из соотношения, так что нет никакой новой строки , чтобы проверить.</target>
        </trans-unit>
        <trans-unit id="ffed91b9d2e2689c8f9096a3b8e654e3487952c0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;JOIN&lt;/code&gt; clause combines two &lt;code&gt;FROM&lt;/code&gt; items, which for convenience we will refer to as &amp;ldquo;tables&amp;rdquo;, though in reality they can be any type of &lt;code&gt;FROM&lt;/code&gt; item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, &lt;code&gt;JOIN&lt;/code&gt;s nest left-to-right. In any case &lt;code&gt;JOIN&lt;/code&gt; binds more tightly than the commas separating &lt;code&gt;FROM&lt;/code&gt;-list items.</source>
          <target state="translated">Предложение &lt;code&gt;JOIN&lt;/code&gt; объединяет два элемента &lt;code&gt;FROM&lt;/code&gt; , которые для удобства мы будем называть &amp;laquo;таблицами&amp;raquo;, хотя на самом деле они могут быть любым типом элемента &lt;code&gt;FROM&lt;/code&gt; . При необходимости используйте круглые скобки для определения порядка вложения. При отсутствии круглых скобок &lt;code&gt;JOIN&lt;/code&gt; размещаются слева направо. В любом случае &lt;code&gt;JOIN&lt;/code&gt; связывает более жестко, чем запятые, разделяющие элементы &lt;code&gt;FROM&lt;/code&gt; -list.</target>
        </trans-unit>
        <trans-unit id="22a84ad9de4a47f15eabedf603ec63031e192119" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LATERAL&lt;/code&gt; item can appear at top level in the &lt;code&gt;FROM&lt;/code&gt; list, or within a &lt;code&gt;JOIN&lt;/code&gt; tree. In the latter case it can also refer to any items that are on the left-hand side of a &lt;code&gt;JOIN&lt;/code&gt; that it is on the right-hand side of.</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; элемент может появиться на верхнем уровне в &lt;code&gt;FROM&lt;/code&gt; списка, или в пределах &lt;code&gt;JOIN&lt;/code&gt; дерево. В последнем случае он также может относиться к любым элементам, которые находятся слева от &lt;code&gt;JOIN&lt;/code&gt; , от которого он находится справа.</target>
        </trans-unit>
        <trans-unit id="e8ae34e725d60cc08b18c4661033d9a5986eedac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SECURITY DEFINER&lt;/code&gt; procedure cannot execute transaction control statements (for example, &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, depending on the language).</source>
          <target state="translated">&lt;code&gt;SECURITY DEFINER&lt;/code&gt; процедура не может выполнять операторы управления транзакциями (например, &lt;code&gt;COMMIT&lt;/code&gt; и &lt;code&gt;ROLLBACK&lt;/code&gt; , в зависимости от языка).</target>
        </trans-unit>
        <trans-unit id="24640de38cd7e79e6c26b95c139e86bc1984a68f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SELECT&lt;/code&gt; sub-query that produces as many output columns as are listed in the parenthesized column list preceding it. The sub-query must yield no more than one row when executed. If it yields one row, its column values are assigned to the target columns; if it yields no rows, NULL values are assigned to the target columns. The sub-query can refer to old values of the current row of the table being updated.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; , суб-запрос , который производит столько выходных столбцов , как перечислены в списке в скобках колонка предшествующего ему. Подзапрос при выполнении должен давать не более одной строки. Если он дает одну строку, значения ее столбцов назначаются целевым столбцам; если он не дает строк, целевым столбцам присваиваются значения NULL. Подзапрос может ссылаться на старые значения текущей строки обновляемой таблицы.</target>
        </trans-unit>
        <trans-unit id="9f32387ffee5e380629abaa1525601dc9d6facaf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ShareLock&lt;/code&gt; is required on the target index by &lt;code&gt;bt_index_parent_check&lt;/code&gt; (a &lt;code&gt;ShareLock&lt;/code&gt; is also acquired on the heap relation). These locks prevent concurrent data modification from &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; commands. The locks also prevent the underlying relation from being concurrently processed by &lt;code&gt;VACUUM&lt;/code&gt;, as well as all other utility commands. Note that the function holds locks only while running, not for the entire transaction.</source>
          <target state="translated">&lt;code&gt;ShareLock&lt;/code&gt; требуется на целевой показатель по &lt;code&gt;bt_index_parent_check&lt;/code&gt; (а &lt;code&gt;ShareLock&lt;/code&gt; также приобрели на кучного отношении). Эти блокировки предотвращают одновременное изменение данных с помощью команд &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; . Блокировки также не позволяют &lt;code&gt;VACUUM&lt;/code&gt; одновременно обрабатывать базовое отношение и все другие служебные команды. Обратите внимание, что функция удерживает блокировки только во время работы, а не для всей транзакции.</target>
        </trans-unit>
        <trans-unit id="f5a2d75bff2c30ff411c224c9fe1259bed07345e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause after a &lt;code&gt;table_name&lt;/code&gt; indicates that the specified &lt;code&gt;sampling_method&lt;/code&gt; should be used to retrieve a subset of the rows in that table. This sampling precedes the application of any other filters such as &lt;code&gt;WHERE&lt;/code&gt; clauses. The standard PostgreSQL distribution includes two sampling methods, &lt;code&gt;BERNOULLI&lt;/code&gt; and &lt;code&gt;SYSTEM&lt;/code&gt;, and other sampling methods can be installed in the database via extensions.</source>
          <target state="translated">Предложение &lt;code&gt;TABLESAMPLE&lt;/code&gt; после &lt;code&gt;table_name&lt;/code&gt; указывает, что указанный метод &lt;code&gt;sampling_method&lt;/code&gt; должен использоваться для получения подмножества строк в этой таблице. Эта выборка предшествует применению любых других фильтров, таких как &lt;code&gt;WHERE&lt;/code&gt; . Стандартный дистрибутив PostgreSQL включает два метода выборки, &lt;code&gt;BERNOULLI&lt;/code&gt; и &lt;code&gt;SYSTEM&lt;/code&gt; , а другие методы выборки могут быть установлены в базе данных с помощью расширений.</target>
        </trans-unit>
        <trans-unit id="0e67a4c57a74dd900aa610f5f6c701a6078b7404" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TZH&lt;/code&gt; template pattern can match a signed number. Without the &lt;code&gt;FX&lt;/code&gt; option, minus signs may be ambiguous, and could be interpreted as a separator. This ambiguity is resolved as follows: If the number of separators before &lt;code&gt;TZH&lt;/code&gt; in the template string is less than the number of separators before the minus sign in the input string, the minus sign is interpreted as part of &lt;code&gt;TZH&lt;/code&gt;. Otherwise, the minus sign is considered to be a separator between values. For example, &lt;code&gt;to_timestamp('2000 -10', 'YYYY TZH')&lt;/code&gt; matches &lt;code&gt;-10&lt;/code&gt; to &lt;code&gt;TZH&lt;/code&gt;, but &lt;code&gt;to_timestamp('2000 -10', 'YYYY&amp;nbsp;&amp;nbsp;TZH')&lt;/code&gt; matches &lt;code&gt;10&lt;/code&gt; to &lt;code&gt;TZH&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TZH&lt;/code&gt; шаблон шаблон может соответствовать подписанному номеру. Без опции &lt;code&gt;FX&lt;/code&gt; знаки минуса могут быть неоднозначными и интерпретироваться как разделитель. Эта неоднозначность устраняется следующим образом: если количество разделителей перед &lt;code&gt;TZH&lt;/code&gt; в строке шаблона меньше количества разделителей перед знаком минус во входной строке, знак минус интерпретируется как часть &lt;code&gt;TZH&lt;/code&gt; . В противном случае знак минус считается разделителем между значениями. Например, &lt;code&gt;to_timestamp('2000 -10', 'YYYY TZH')&lt;/code&gt; соответствует &lt;code&gt;-10&lt;/code&gt; to &lt;code&gt;TZH&lt;/code&gt; , но &lt;code&gt;to_timestamp('2000 -10', 'YYYY&amp;nbsp;&amp;nbsp;TZH')&lt;/code&gt; соответствует &lt;code&gt;10&lt;/code&gt; to &lt;code&gt;TZH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="975d4d7cc350f909c3d56a227d26009cd1f3f678" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;WITH&lt;/code&gt; query is referenced by writing its name, just as though the query's name were a table name. (In fact, the &lt;code&gt;WITH&lt;/code&gt; query hides any real table of the same name for the purposes of the primary query. If necessary, you can refer to a real table of the same name by schema-qualifying the table's name.) An alias can be provided in the same way as for a table.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; запросом ссылается писать свое имя, так же , как если бы имя в запросе было именем таблицы. (Фактически, запрос &lt;code&gt;WITH&lt;/code&gt; скрывает любую реальную таблицу с тем же именем для целей первичного запроса. При необходимости вы можете обратиться к реальной таблице с тем же именем, указав имя таблицы в схеме.) Псевдонимом может быть предоставляется так же, как и для стола.</target>
        </trans-unit>
        <trans-unit id="ff3f18d6b0d0d8ef8e261f092333e8ac1a83778d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;bloom&lt;/code&gt; index accepts the following parameters in its &lt;code&gt;WITH&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;bloom&lt;/code&gt; индекс принимает следующие параметры в своем &lt;code&gt;WITH&lt;/code&gt; п:</target>
        </trans-unit>
        <trans-unit id="4c2361c26a25ed37192ff6822eb9815e6a1bb350" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;default_expression&lt;/code&gt;, rather than being evaluated immediately when &lt;code&gt;xmltable&lt;/code&gt; is called, is evaluated each time a default is needed for the column. If the expression qualifies as stable or immutable, the repeat evaluation may be skipped. This means that you can usefully use volatile functions like &lt;code&gt;nextval&lt;/code&gt; in &lt;code&gt;default_expression&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;default_expression&lt;/code&gt; оценивается не сразу при &lt;code&gt;xmltable&lt;/code&gt; , а каждый раз, когда для столбца требуется значение по умолчанию. Если выражение квалифицируется как стабильное или неизменяемое, повторную оценку можно пропустить. Это означает, что вы можете с пользой использовать изменчивые функции, такие как &lt;code&gt;nextval&lt;/code&gt; в &lt;code&gt;default_expression&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a8d6c448f4256c5739e1f342a948208b8ac9336" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;dict_xsyn&lt;/code&gt; dictionary accepts the following options:</source>
          <target state="translated">&lt;code&gt;dict_xsyn&lt;/code&gt; словарь принимает следующие параметры:</target>
        </trans-unit>
        <trans-unit id="4731474e93af48b3b039ee433573b761b490ebba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;frame_start&lt;/code&gt; of &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; means that the frame starts with the first row of the partition, and similarly a &lt;code&gt;frame_end&lt;/code&gt; of &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; means that the frame ends with the last row of the partition.</source>
          <target state="translated">Значение &lt;code&gt;frame_start&lt;/code&gt; для &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; означает, что кадр начинается с первой строки раздела, и аналогично &lt;code&gt;frame_end&lt;/code&gt; для &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; означает, что кадр заканчивается последней строкой раздела.</target>
        </trans-unit>
        <trans-unit id="ba67bfc07bc1375b67a77983258edd014dff690f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;money&lt;/code&gt; value can be cast to &lt;code&gt;numeric&lt;/code&gt; without loss of precision. Conversion to other types could potentially lose precision, and must also be done in two stages:</source>
          <target state="translated">&lt;code&gt;money&lt;/code&gt; значение может быть приведено к &lt;code&gt;numeric&lt;/code&gt; без потери точности. Преобразование в другие типы может потенциально потерять точность и также должно выполняться в два этапа:</target>
        </trans-unit>
        <trans-unit id="00e1eada317c8cafe63dee1a39dd2ab5032af82d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;pg_default_acl&lt;/code&gt; entry shows the initial privileges to be assigned to an object belonging to the indicated user. There are currently two types of entry: &amp;ldquo;global&amp;rdquo; entries with &lt;code&gt;defaclnamespace&lt;/code&gt; = 0, and &amp;ldquo;per-schema&amp;rdquo; entries that reference a particular schema. If a global entry is present then it &lt;em&gt;overrides&lt;/em&gt; the normal hard-wired default privileges for the object type. A per-schema entry, if present, represents privileges to be &lt;em&gt;added to&lt;/em&gt; the global or hard-wired default privileges.</source>
          <target state="translated">Запись &lt;code&gt;pg_default_acl&lt;/code&gt; показывает начальные привилегии, которые должны быть назначены объекту, принадлежащему указанному пользователю. В настоящее время существует два типа записей: &amp;laquo;глобальные&amp;raquo; записи с &lt;code&gt;defaclnamespace&lt;/code&gt; = 0 и записи &amp;laquo;для каждой схемы&amp;raquo;, которые ссылаются на конкретную схему. Если присутствует глобальная запись, то она &lt;em&gt;переопределяет&lt;/em&gt; обычные аппаратные привилегии по умолчанию для данного типа объекта. Запись для каждой схемы, если она присутствует, представляет привилегии, которые должны быть &lt;em&gt;добавлены к&lt;/em&gt; глобальным или жестко привязанным привилегиям по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1cb2939b4b6d4ddce66b3a2e4882d5e2fd0717d0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;pg_ident.conf&lt;/code&gt; file that could be used in conjunction with the &lt;code&gt;pg_hba.conf&lt;/code&gt; file in &lt;a href=&quot;auth-pg-hba-conf#EXAMPLE-PG-HBA.CONF&quot;&gt;Example 20.1&lt;/a&gt; is shown in &lt;a href=&quot;auth-username-maps#EXAMPLE-PG-IDENT.CONF&quot;&gt;Example 20.2&lt;/a&gt;. In this example, anyone logged in to a machine on the 192.168 network that does not have the operating system user name &lt;code&gt;bryanh&lt;/code&gt;, &lt;code&gt;ann&lt;/code&gt;, or &lt;code&gt;robert&lt;/code&gt; would not be granted access. Unix user &lt;code&gt;robert&lt;/code&gt; would only be allowed access when he tries to connect as PostgreSQL user &lt;code&gt;bob&lt;/code&gt;, not as &lt;code&gt;robert&lt;/code&gt; or anyone else. &lt;code&gt;ann&lt;/code&gt; would only be allowed to connect as &lt;code&gt;ann&lt;/code&gt;. User &lt;code&gt;bryanh&lt;/code&gt; would be allowed to connect as either &lt;code&gt;bryanh&lt;/code&gt; or as &lt;code&gt;guest1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_ident.conf&lt;/code&gt; файл , который может быть использован в сочетании с &lt;code&gt;pg_hba.conf&lt;/code&gt; файла в &lt;a href=&quot;auth-pg-hba-conf#EXAMPLE-PG-HBA.CONF&quot;&gt;примере 20.1&lt;/a&gt; показано в &lt;a href=&quot;auth-username-maps#EXAMPLE-PG-IDENT.CONF&quot;&gt;примере 20.2&lt;/a&gt; . В этом примере любой, кто вошел в систему в сети 192.168, у которой нет имени пользователя операционной системы &lt;code&gt;bryanh&lt;/code&gt; , &lt;code&gt;ann&lt;/code&gt; или &lt;code&gt;robert&lt;/code&gt; , не получит доступа. Пользователь Unix &lt;code&gt;robert&lt;/code&gt; получит доступ только тогда, когда он попытается подключиться как пользователь PostgreSQL &lt;code&gt;bob&lt;/code&gt; , а не как &lt;code&gt;robert&lt;/code&gt; или кто-либо еще. &lt;code&gt;ann&lt;/code&gt; будет разрешено подключиться только как &lt;code&gt;ann&lt;/code&gt; . Пользователь &lt;code&gt;bryanh&lt;/code&gt; будет разрешено подключиться как &lt;code&gt;bryanh&lt;/code&gt; или как &lt;code&gt;guest1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="421151d14aecca0c09fe097c61a7a69cad0ef7d4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;sort_expression&lt;/code&gt; can also be the column label or number of an output column, as in:</source>
          <target state="translated">&lt;code&gt;sort_expression&lt;/code&gt; также может быть метка столбца или номер выходного столбца, как показано ниже :</target>
        </trans-unit>
        <trans-unit id="2b23f0024d2472dff4bba030a8daa989f120d9ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsquery&lt;/code&gt; value stores lexemes that are to be searched for, and can combine them using the Boolean operators &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), &lt;code&gt;|&lt;/code&gt; (OR), and &lt;code&gt;!&lt;/code&gt; (NOT), as well as the phrase search operator &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY). There is also a variant &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; of the FOLLOWED BY operator, where &lt;code&gt;N&lt;/code&gt; is an integer constant that specifies the distance between the two lexemes being searched for. &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;tsquery&lt;/code&gt; хранит лексемы, которые необходимо найти, и может объединять их с помощью логических операторов &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), &lt;code&gt;|&lt;/code&gt; (ИЛИ), и &lt;code&gt;!&lt;/code&gt; (НЕ), а также оператор поиска фразы &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (СЛЕДУЕТ). Существует также вариант &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; оператора FOLLOWED BY, где &lt;code&gt;N&lt;/code&gt; - целочисленная константа, указывающая расстояние между двумя лексемами, которые ищутся. &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; эквивалентно &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1488cfe9583a001f3966c381b957f6eda3c9c49c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsvector&lt;/code&gt; value is a sorted list of distinct &lt;em&gt;lexemes&lt;/em&gt;, which are words that have been &lt;em&gt;normalized&lt;/em&gt; to merge different variants of the same word (see &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for details). Sorting and duplicate-elimination are done automatically during input, as shown in this example:</source>
          <target state="translated">Значение &lt;code&gt;tsvector&lt;/code&gt; - это отсортированный список различных &lt;em&gt;лексем&lt;/em&gt; , которые представляют собой слова, &lt;em&gt;нормализованные&lt;/em&gt; для объединения различных вариантов одного и того же слова (подробности см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;главе 12&lt;/a&gt; ). Сортировка и устранение дубликатов выполняются автоматически во время ввода, как показано в этом примере:</target>
        </trans-unit>
        <trans-unit id="558bdfda3afcef5f29f3f2e8969b74e0c735aa26" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsvector&lt;/code&gt; value is a sorted list of distinct &lt;em&gt;lexemes&lt;/em&gt;, which are words that have been &lt;em&gt;normalized&lt;/em&gt; to merge different variants of the same word (see &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for details). Sorting and duplicate-elimination are done automatically during input, as shown in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b056d2deaf1866d999d56f9aac903ec6223482" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;zone_abbreviation&lt;/code&gt; is just the abbreviation being defined. An &lt;code&gt;offset&lt;/code&gt; is an integer giving the equivalent offset in seconds from UTC, positive being east from Greenwich and negative being west. For example, -18000 would be five hours west of Greenwich, or North American east coast standard time. &lt;code&gt;D&lt;/code&gt; indicates that the zone name represents local daylight-savings time rather than standard time.</source>
          <target state="translated">&lt;code&gt;zone_abbreviation&lt;/code&gt; просто аббревиатура определяется. &lt;code&gt;offset&lt;/code&gt; является целым числом, эквивалентное смещение в секундах от UTC, положительное существо к востоку от Гринвича и отрицательного бытия запад. Например, -18000 будет на пять часов к западу от Гринвича, или стандартного времени восточного побережья Северной Америки. &lt;code&gt;D&lt;/code&gt; указывает, что название зоны представляет местное летнее время, а не стандартное время.</target>
        </trans-unit>
        <trans-unit id="f4943bcbca867f42994cb13fee08c8f711efae46" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;back reference&lt;/em&gt; (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;) matches the same string matched by the previous parenthesized subexpression specified by the number &lt;code&gt;n&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;Table 9.22&lt;/a&gt;). For example, &lt;code&gt;([bc])\1&lt;/code&gt; matches &lt;code&gt;bb&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; but not &lt;code&gt;bc&lt;/code&gt; or &lt;code&gt;cb&lt;/code&gt;. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</source>
          <target state="translated">&lt;em&gt;Обратная ссылка&lt;/em&gt; ( &lt;code&gt;\&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ) совпадает с тем же строки , совпавшие с предыдущим подвыражению указанного в скобках по числу &lt;code&gt;n&lt;/code&gt; (см &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;таблицу 9.22&lt;/a&gt; ). Например, &lt;code&gt;([bc])\1&lt;/code&gt; соответствует &lt;code&gt;bb&lt;/code&gt; или &lt;code&gt;cc&lt;/code&gt; , но не &lt;code&gt;bc&lt;/code&gt; или &lt;code&gt;cb&lt;/code&gt; . Подвыражение должно полностью предшествовать обратной ссылке в RE. Подвыражения нумеруются в порядке их ведущих круглых скобок. Скобки без записи не определяют подвыражения.</target>
        </trans-unit>
        <trans-unit id="0a817aa5725f2f76fa3ba34527c18e8ded1f121f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;back reference&lt;/em&gt; (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;) matches the same string matched by the previous parenthesized subexpression specified by the number &lt;code&gt;n&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). For example, &lt;code&gt;([bc])\1&lt;/code&gt; matches &lt;code&gt;bb&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; but not &lt;code&gt;bc&lt;/code&gt; or &lt;code&gt;cb&lt;/code&gt;. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6718ca8fb4d919393e897bdec5fb4459615fdc4d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;bracket expression&lt;/em&gt; is a list of characters enclosed in &lt;code&gt;[]&lt;/code&gt;. It normally matches any single character from the list (but see below). If the list begins with &lt;code&gt;^&lt;/code&gt;, it matches any single character &lt;em&gt;not&lt;/em&gt; from the rest of the list. If two characters in the list are separated by &lt;code&gt;-&lt;/code&gt;, this is shorthand for the full range of characters between those two (inclusive) in the collating sequence, e.g., &lt;code&gt;[0-9]&lt;/code&gt; in ASCII matches any decimal digit. It is illegal for two ranges to share an endpoint, e.g., &lt;code&gt;a-c-e&lt;/code&gt;. Ranges are very collating-sequence-dependent, so portable programs should avoid relying on them.</source>
          <target state="translated">&lt;em&gt;Выражение скобки&lt;/em&gt; представляет собой список символов , заключенных в &lt;code&gt;[]&lt;/code&gt; . Обычно он соответствует любому одиночному символу из списка (но см. Ниже). Если список начинается с &lt;code&gt;^&lt;/code&gt; , он соответствует любому одиночному символу &lt;em&gt;не&lt;/em&gt; из остальной части списка. Если два символа в списке разделены знаком &lt;code&gt;-&lt;/code&gt; , это сокращение для полного диапазона символов между этими двумя (включительно) в последовательности сортировки, например, &lt;code&gt;[0-9]&lt;/code&gt; в ASCII соответствует любой десятичной цифре. Недопустимо, чтобы два диапазона имели общую конечную точку, например &lt;code&gt;a-c-e&lt;/code&gt; . Диапазоны очень зависят от последовательности сортировки, поэтому переносимым программам не следует полагаться на них.</target>
        </trans-unit>
        <trans-unit id="e492c903d1ba7fa2a18a8ea616f7ebd7783cffa9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;composite type&lt;/em&gt; represents the structure of a row or record; it is essentially just a list of field names and their data types. PostgreSQL allows composite types to be used in many of the same ways that simple types can be used. For example, a column of a table can be declared to be of a composite type.</source>
          <target state="translated">&lt;em&gt;Составной тип&lt;/em&gt; представляет собой структуру строки или запись; По сути, это просто список имен полей и их типов данных. PostgreSQL позволяет использовать составные типы во многом так же, как простые типы. Например, столбец таблицы может быть объявлен составным типом.</target>
        </trans-unit>
        <trans-unit id="6e860f367bba9069717fd9b941470c654d2b4f8d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint escape&lt;/em&gt; is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="translated">Экранирование &lt;em&gt;ограничения&lt;/em&gt; - это ограничение, соответствующее пустой строке при соблюдении определенных условий, записанное как escape. Они показаны в &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Таблице 9.21&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d0f2ee8729573804e315b4c91c82a2c28f8ca2d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint escape&lt;/em&gt; is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ce7ea4252d54e37a3de7de04c14f271d76b823" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint&lt;/em&gt; matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;Table 9.18&lt;/a&gt;; some more constraints are described later.</source>
          <target state="translated">&lt;em&gt;Ограничение&lt;/em&gt; соответствует пустой строке, но соответствует только при выполнении определенных условий. Ограничение может использоваться там, где может использоваться атом, за исключением того, что за ним не может следовать квантификатор. Простые ограничения показаны в &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;Таблице 9.18&lt;/a&gt; ; некоторые другие ограничения описаны позже.</target>
        </trans-unit>
        <trans-unit id="41327cfa5680423eea0edd7f46f2cf61b64b967b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint&lt;/em&gt; matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;Table 9.19&lt;/a&gt;; some more constraints are described later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82adef88e441ec735dafa62739629a93a7d0b236" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;document&lt;/em&gt; is the unit of searching in a full text search system; for example, a magazine article or email message. The text search engine must be able to parse documents and store associations of lexemes (key words) with their parent document. Later, these associations are used to search for documents that contain query words.</source>
          <target state="translated">&lt;em&gt;Документ&lt;/em&gt; является единицей поиска в полнотекстовом поиске системе; например, статья в журнале или электронное письмо. Система текстового поиска должна иметь возможность анализировать документы и сохранять ассоциации лексем (ключевых слов) с их родительским документом. Позже эти связи используются для поиска документов, содержащих слова запроса.</target>
        </trans-unit>
        <trans-unit id="d539733e585980e704da973d01ffd68041e9bbe5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;domain&lt;/em&gt; is a user-defined data type that is based on another &lt;em&gt;underlying type&lt;/em&gt;. Optionally, it can have constraints that restrict its valid values to a subset of what the underlying type would allow. Otherwise it behaves like the underlying type &amp;mdash; for example, any operator or function that can be applied to the underlying type will work on the domain type. The underlying type can be any built-in or user-defined base type, enum type, array type, composite type, range type, or another domain.</source>
          <target state="translated">&lt;em&gt;Домен&lt;/em&gt; является определенный пользователем тип данных , который основан на другом &lt;em&gt;базового типа&lt;/em&gt; . При желании он может иметь ограничения, которые ограничивают его допустимые значения подмножеством того, что допускает базовый тип. В противном случае он ведет себя как базовый тип - например, любой оператор или функция, которые могут быть применены к базовому типу, будут работать с типом домена. Базовый тип может быть любым встроенным или определяемым пользователем базовым типом, типом перечисления, типом массива, составным типом, типом диапазона или другим доменом.</target>
        </trans-unit>
        <trans-unit id="c13def52e60f456d21c22d940b5598ad3aba92f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label path&lt;/em&gt; is a sequence of zero or more labels separated by dots, for example &lt;code&gt;L1.L2.L3&lt;/code&gt;, representing a path from the root of a hierarchical tree to a particular node. The length of a label path cannot exceed 65535 labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e800c3197134211f2433e1a5e7b9939eb18274d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label path&lt;/em&gt; is a sequence of zero or more labels separated by dots, for example &lt;code&gt;L1.L2.L3&lt;/code&gt;, representing a path from the root of a hierarchical tree to a particular node. The length of a label path must be less than 65kB, but keeping it under 2kB is preferable.</source>
          <target state="translated">&lt;em&gt;Путь этикетка&lt;/em&gt; представляет собой последовательность из нуля или более меток , разделенных точками, например &lt;code&gt;L1.L2.L3&lt;/code&gt; , представляющий собой путь от корня иерархического дерева для конкретного узла. Длина пути метки должна быть менее 65 КБ, но желательно, чтобы она не превышала 2 КБ.</target>
        </trans-unit>
        <trans-unit id="b787370839fd1f05141e9721dfa970b29907a8f6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label&lt;/em&gt; is a sequence of alphanumeric characters and underscores (for example, in C locale the characters &lt;code&gt;A-Za-z0-9_&lt;/code&gt; are allowed). Labels must be less than 256 bytes long.</source>
          <target state="translated">&lt;em&gt;Этикетка&lt;/em&gt; представляет собой последовательность буквенно - цифровых символов и символов подчеркивания (например, в C локали символы &lt;code&gt;A-Za-z0-9_&lt;/code&gt; разрешены). Ярлыки не должны быть длиннее 256 байт.</target>
        </trans-unit>
        <trans-unit id="599ffa36e210ea0adb3274124904be22bf966667" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label&lt;/em&gt; is a sequence of alphanumeric characters and underscores (for example, in C locale the characters &lt;code&gt;A-Za-z0-9_&lt;/code&gt; are allowed). Labels must be less than 256 characters long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ce2d4eb014bcb723a4d1641a42edaac349db30" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;partial index&lt;/em&gt; is an index built over a subset of a table; the subset is defined by a conditional expression (called the &lt;em&gt;predicate&lt;/em&gt; of the partial index). The index contains entries only for those table rows that satisfy the predicate. Partial indexes are a specialized feature, but there are several situations in which they are useful.</source>
          <target state="translated">&lt;em&gt;Частичный индекс&lt;/em&gt; представляет собой индекс построен по подмножеству таблицы; подмножество определяется условным выражением (называемым &lt;em&gt;предикатом&lt;/em&gt; частичного индекса). Индекс содержит записи только для тех строк таблицы, которые удовлетворяют предикату. Частичные индексы - это особая функция, но есть несколько ситуаций, в которых они могут быть полезны.</target>
        </trans-unit>
        <trans-unit id="17789413b2495753606375a6dc95de535511eb7a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;publication&lt;/em&gt; can be defined on any physical replication master. The node where a publication is defined is referred to as &lt;em&gt;publisher&lt;/em&gt;. A publication is a set of changes generated from a table or a group of tables, and might also be described as a change set or replication set. Each publication exists in only one database.</source>
          <target state="translated">&lt;em&gt;Публикация&lt;/em&gt; может быть определена на любом физическом мастер репликации. Узел, на котором определяется публикация, называется &lt;em&gt;издателем&lt;/em&gt; . Публикация - это набор изменений, созданных из таблицы или группы таблиц, который также может быть описан как набор изменений или набор репликации. Каждая публикация существует только в одной базе данных.</target>
        </trans-unit>
        <trans-unit id="bad628aabb95be8473994dba34d6d8a1a5004186" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;subscription&lt;/em&gt; is the downstream side of logical replication. The node where a subscription is defined is referred to as the &lt;em&gt;subscriber&lt;/em&gt;. A subscription defines the connection to another database and set of publications (one or more) to which it wants to subscribe.</source>
          <target state="translated">&lt;em&gt;Подписками&lt;/em&gt; являются ниже по потоку стороны логической репликации. Узел, на котором определена подписка, называется &lt;em&gt;подписчиком&lt;/em&gt; . Подписка определяет соединение с другой базой данных и набор публикаций (одну или несколько), на которые она хочет подписаться.</target>
        </trans-unit>
        <trans-unit id="fa797af3b3f4fb2b2ac87bf17e6b99f0b17a6828" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;table expression&lt;/em&gt; computes a table. The table expression contains a &lt;code&gt;FROM&lt;/code&gt; clause that is optionally followed by &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses. Trivial table expressions simply refer to a table on disk, a so-called base table, but more complex expressions can be used to modify or combine base tables in various ways.</source>
          <target state="translated">&lt;em&gt;Выражение таблицы&lt;/em&gt; вычисляет таблицу. Выражение таблицы содержит предложение &lt;code&gt;FROM&lt;/code&gt; , за которым могут следовать &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; и &lt;code&gt;HAVING&lt;/code&gt; . Тривиальные табличные выражения просто относятся к таблице на диске, так называемой базовой таблице, но более сложные выражения могут использоваться для изменения или комбинирования базовых таблиц различными способами.</target>
        </trans-unit>
        <trans-unit id="2fefdb2ebab2d34cbdb1f2805b62ff07fe84dbed" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window function call&lt;/em&gt; represents the application of an aggregate-like function over some portion of the rows selected by a query. Unlike non-window aggregate calls, this is not tied to grouping of the selected rows into a single output row &amp;mdash; each row remains separate in the query output. However the window function has access to all the rows that would be part of the current row's group according to the grouping specification (&lt;code&gt;PARTITION BY&lt;/code&gt; list) of the window function call. The syntax of a window function call is one of the following:</source>
          <target state="translated">&lt;em&gt;Вызов функции окна&lt;/em&gt; представляет собой применение совокупного типа функции над некоторой частью строк , выбранных в запросе. В отличие от вызовов агрегирования без окон, это не связано с группировкой выбранных строк в одну строку вывода - каждая строка остается отдельной в выводе запроса. Однако оконная функция имеет доступ ко всем строкам, которые были бы частью текущей группы строк в соответствии со спецификацией группировки ( список &lt;code&gt;PARTITION BY&lt;/code&gt; ) вызова оконной функции. Синтаксис вызова оконной функции может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="387625f992bcdbcffbfd0633e6c6c1c4ef1ce98e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window function&lt;/em&gt; performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. However, window functions do not cause rows to become grouped into a single output row like non-window aggregate calls would. Instead, the rows retain their separate identities. Behind the scenes, the window function is able to access more than just the current row of the query result.</source>
          <target state="translated">&lt;em&gt;Функция окна&lt;/em&gt; выполняет вычисление по всей совокупности строк таблицы, которые каким - то образом связанные с текущей строки. Это сравнимо с типом расчета, который можно выполнить с помощью агрегатной функции. Однако оконные функции не заставляют строки группироваться в одну выходную строку, как это сделали бы не оконные агрегатные вызовы. Вместо этого строки сохраняют свои отдельные идентификаторы. За кулисами оконная функция может получить доступ не только к текущей строке результата запроса.</target>
        </trans-unit>
        <trans-unit id="1e933097e94c165163135c375f18dec5b954f260" translate="yes" xml:space="preserve">
          <source>A Bloom filter is a space-efficient data structure that is used to test whether an element is a member of a set. In the case of an index access method, it allows fast exclusion of non-matching tuples via signatures whose size is determined at index creation.</source>
          <target state="translated">Фильтр Bloom-это компактная структура данных,которая используется для проверки того,является ли элемент членом набора.В случае метода доступа к индексам он позволяет быстро исключить несопоставимые кортежи через сигнатуры,размер которых определяется при создании индекса.</target>
        </trans-unit>
        <trans-unit id="7133145b9a1efb20311e9b66542c47e33e3b0d76" translate="yes" xml:space="preserve">
          <source>A Boolean expression that determines whether the trigger function will actually be executed. If &lt;code&gt;WHEN&lt;/code&gt; is specified, the function will only be called if the &lt;code&gt;condition&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. In &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers, the &lt;code&gt;WHEN&lt;/code&gt; condition can refer to columns of the old and/or new row values by writing &lt;code&gt;OLD.column_name&lt;/code&gt; or &lt;code&gt;NEW.column_name&lt;/code&gt; respectively. Of course, &lt;code&gt;INSERT&lt;/code&gt; triggers cannot refer to &lt;code&gt;OLD&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; triggers cannot refer to &lt;code&gt;NEW&lt;/code&gt;.</source>
          <target state="translated">Логическое выражение, определяющее, будет ли действительно выполняться функция триггера. Если указано &lt;code&gt;WHEN&lt;/code&gt; , функция будет вызываться только в том случае, если &lt;code&gt;condition&lt;/code&gt; вернет &lt;code&gt;true&lt;/code&gt; . В триггерах &lt;code&gt;FOR EACH ROW&lt;/code&gt; условие &lt;code&gt;WHEN&lt;/code&gt; может ссылаться на столбцы старых и / или новых значений строк, записывая &lt;code&gt;OLD.column_name&lt;/code&gt; или &lt;code&gt;NEW.column_name&lt;/code&gt; соответственно. Конечно, триггеры &lt;code&gt;INSERT&lt;/code&gt; не могут ссылаться на &lt;code&gt;OLD&lt;/code&gt; , а триггеры &lt;code&gt;DELETE&lt;/code&gt; не могут ссылаться на &lt;code&gt;NEW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f47409118dd85d31d6d901173cd234a285d215a5" translate="yes" xml:space="preserve">
          <source>A GIN index stores a set of (key, posting list) pairs, where a &lt;em&gt;posting list&lt;/em&gt; is a set of row IDs in which the key occurs. The same row ID can appear in multiple posting lists, since an item can contain more than one key. Each key value is stored only once, so a GIN index is very compact for cases where the same key appears many times.</source>
          <target state="translated">Индекс GIN хранит набор пар (ключ, список сообщений), где &lt;em&gt;список сообщений&lt;/em&gt; - это набор идентификаторов строк, в которых встречается ключ. Один и тот же идентификатор строки может отображаться в нескольких списках публикаций, поскольку элемент может содержать более одного ключа. Каждое значение ключа сохраняется только один раз, поэтому индекс GIN очень компактен для случаев, когда один и тот же ключ встречается много раз.</target>
        </trans-unit>
        <trans-unit id="77d714896b96774f11d4e02f2da31afcf21ba9b4" translate="yes" xml:space="preserve">
          <source>A GiST index can be covering, i.e. use the &lt;code&gt;INCLUDE&lt;/code&gt; clause. Included columns can have data types without any GiST operator class. Included attributes will be stored uncompressed.</source>
          <target state="translated">Индекс GiST может быть покрывающим, т.е. использовать предложение &lt;code&gt;INCLUDE&lt;/code&gt; . Включенные столбцы могут иметь типы данных без какого-либо класса операторов GiST. Включенные атрибуты будут храниться без сжатия.</target>
        </trans-unit>
        <trans-unit id="efe49aa51c5c238e7d22d9c414bebd48d8a0f792" translate="yes" xml:space="preserve">
          <source>A GiST index can be covering, i.e., use the &lt;code&gt;INCLUDE&lt;/code&gt; clause. Included columns can have data types without any GiST operator class. Included attributes will be stored uncompressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686f7293e72b8ed4fbfb23d13f584165b259d7cc" translate="yes" xml:space="preserve">
          <source>A GiST index is &lt;em&gt;lossy&lt;/em&gt;, meaning that the index might produce false matches, and it is necessary to check the actual table row to eliminate such false matches. (PostgreSQL does this automatically when needed.) GiST indexes are lossy because each document is represented in the index by a fixed-length signature. The signature is generated by hashing each word into a single bit in an n-bit string, with all these bits OR-ed together to produce an n-bit document signature. When two words hash to the same bit position there will be a false match. If all words in the query have matches (real or false) then the table row must be retrieved to see if the match is correct.</source>
          <target state="translated">Индекс GiST является &lt;em&gt;потерянным&lt;/em&gt; , что означает, что индекс может давать ложные совпадения, и необходимо проверить фактическую строку таблицы, чтобы исключить такие ложные совпадения. (PostgreSQL делает это автоматически, когда это необходимо.) Индексы GiST работают с потерями, потому что каждый документ представлен в индексе подписью фиксированной длины. Подпись генерируется путем хеширования каждого слова в один бит в n-битовой строке, при этом все эти биты объединяются по ИЛИ для создания n-битной подписи документа. Когда два слова попадают в одну и ту же битовую позицию, будет ложное совпадение. Если все слова в запросе имеют совпадения (реальные или ложные), то необходимо получить строку таблицы, чтобы проверить, является ли совпадение правильным.</target>
        </trans-unit>
        <trans-unit id="19939a4fce59080d1c44ab5da5d78d68dd79f01b" translate="yes" xml:space="preserve">
          <source>A GiST index is &lt;em&gt;lossy&lt;/em&gt;, meaning that the index might produce false matches, and it is necessary to check the actual table row to eliminate such false matches. (PostgreSQL does this automatically when needed.) GiST indexes are lossy because each document is represented in the index by a fixed-length signature. The signature length in bytes is determined by the value of the optional integer parameter &lt;code&gt;siglen&lt;/code&gt;. The default signature length (when &lt;code&gt;siglen&lt;/code&gt; is not specified) is 124 bytes, the maximum signature length is 2024 bytes. The signature is generated by hashing each word into a single bit in an n-bit string, with all these bits OR-ed together to produce an n-bit document signature. When two words hash to the same bit position there will be a false match. If all words in the query have matches (real or false) then the table row must be retrieved to see if the match is correct. Longer signatures lead to a more precise search (scanning a smaller fraction of the index and fewer heap pages), at the cost of a larger index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4859377c56a7f4250fc7928febe82211450cf591" translate="yes" xml:space="preserve">
          <source>A GiST or SP-GiST index can accelerate queries involving these range operators: &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;-|-&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; (see &lt;a href=&quot;functions-range#RANGE-OPERATORS-TABLE&quot;&gt;Table 9.53&lt;/a&gt; for more information).</source>
          <target state="translated">Индекс GiST или SP-GiST может ускорить запросы, в которых используются следующие операторы диапазона: &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;lt;@&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;-|-&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; (см. &lt;a href=&quot;functions-range#RANGE-OPERATORS-TABLE&quot;&gt;Таблицу 9.53&lt;/a&gt; для получения дополнительной информации).</target>
        </trans-unit>
        <trans-unit id="5052f6936540d438e9a8f74a835240911affa68e" translate="yes" xml:space="preserve">
          <source>A JIT provider is loaded by dynamically loading the named shared library. The normal library search path is used to locate the library. To provide the required JIT provider callbacks and to indicate that the library is actually a JIT provider, it needs to provide a C function named &lt;code&gt;_PG_jit_provider_init&lt;/code&gt;. This function is passed a struct that needs to be filled with the callback function pointers for individual actions:</source>
          <target state="translated">Поставщик JIT загружается путем динамической загрузки именованной общей библиотеки. Обычный путь поиска библиотеки используется для поиска библиотеки. Чтобы предоставить необходимые обратные вызовы поставщика JIT и указать, что библиотека на самом деле является поставщиком JIT, необходимо предоставить функцию C с именем &lt;code&gt;_PG_jit_provider_init&lt;/code&gt; . Этой функции передается структура, которую необходимо заполнить указателями функций обратного вызова для отдельных действий:</target>
        </trans-unit>
        <trans-unit id="f096d1aabaef04fadfbfc0905d4cc493f3ce419f" translate="yes" xml:space="preserve">
          <source>A JSON null value is converted to a SQL null in all cases.</source>
          <target state="translated">Нулевое значение JSON во всех случаях конвертируется в SQL-ноль.</target>
        </trans-unit>
        <trans-unit id="989ddd2bcb5960954e9e78a9c33e2efbc341a60e" translate="yes" xml:space="preserve">
          <source>A POSIX time zone specification has the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90da68c2f0311ac40f24046e1fc30e1392f07dc8" translate="yes" xml:space="preserve">
          <source>A PostgreSQL database cluster contains one or more named databases. Roles and a few other object types are shared across the entire cluster. A client connection to the server can only access data in a single database, the one specified in the connection request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c15132a79db70b0e2b3cdb81cbd574f378944491" translate="yes" xml:space="preserve">
          <source>A PostgreSQL database cluster contains one or more named databases. Users and groups of users are shared across the entire cluster, but no other data is shared across databases. Any given client connection to the server can access only the data in a single database, the one specified in the connection request.</source>
          <target state="translated">Кластер баз данных PostgreSQL содержит одну или несколько именованных баз данных.Пользователи и группы пользователей совместно используются во всем кластере,но никакие другие данные не совместно используются в базах данных.Любой клиент,подключенный к серверу,может получить доступ только к данным в одной базе данных,указанной в запросе на подключение.</target>
        </trans-unit>
        <trans-unit id="9d33772a25bf4dd8b6ca0ae7bbd6d891d7102d71" translate="yes" xml:space="preserve">
          <source>A Snowball dictionary recognizes everything, whether or not it is able to simplify the word, so it should be placed at the end of the dictionary list. It is useless to have it before any other dictionary because a token will never pass through it to the next dictionary.</source>
          <target state="translated">Словарь Snowball распознает все,способен ли он упростить слово или нет,поэтому его следует поместить в конец списка словарей.Бесполезно иметь его перед любым другим словарем,потому что токен никогда не пройдет через него в следующий словарь.</target>
        </trans-unit>
        <trans-unit id="72bd8340532262887cb9ae14aa89845f88df9078" translate="yes" xml:space="preserve">
          <source>A UUID is written as a sequence of lower-case hexadecimal digits, in several groups separated by hyphens, specifically a group of 8 digits followed by three groups of 4 digits followed by a group of 12 digits, for a total of 32 digits representing the 128 bits. An example of a UUID in this standard form is:</source>
          <target state="translated">UUID записывается как последовательность нижних шестнадцатеричных цифр,в нескольких группах,разделенных дефисами,в частности,группа из 8 цифр,за которой следуют три группы из 4 цифр,за которыми следует группа из 12 цифр,в общей сложности 32 цифры,представляющие 128 бит.Примером UUID в этой стандартной форме является:</target>
        </trans-unit>
        <trans-unit id="99a2ddaed13b4fa5189155f796c23cd0b85b2037" translate="yes" xml:space="preserve">
          <source>A bare &lt;code&gt;VALUES&lt;/code&gt; command:</source>
          <target state="translated">Голые &lt;code&gt;VALUES&lt;/code&gt; команды:</target>
        </trans-unit>
        <trans-unit id="d1c75bcd54e5d624eb16ebfaf6893165bef4c000" translate="yes" xml:space="preserve">
          <source>A better approach is to send the server's stderr output to some type of log rotation program. There is a built-in log rotation facility, which you can use by setting the configuration parameter &lt;code&gt;logging_collector&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The control parameters for this program are described in &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;. You can also use this approach to capture the log data in machine readable CSV (comma-separated values) format.</source>
          <target state="translated">Лучшим подходом является отправка вывода stderr сервера в какую-либо программу ротации журналов. Существует встроенная &lt;code&gt;logging_collector&lt;/code&gt; ротации журналов, которую можно использовать, установив для параметра конфигурации logging_collector значение &lt;code&gt;true&lt;/code&gt; в &lt;code&gt;postgresql.conf&lt;/code&gt; . Параметры управления для этой программы описаны в &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Разделе 19.8.1&lt;/a&gt; . Вы также можете использовать этот подход для сбора данных журнала в машиночитаемом формате CSV (значения, разделенные запятыми).</target>
        </trans-unit>
        <trans-unit id="ebc700417ea8062cbc2133cca40c230572b19efd" translate="yes" xml:space="preserve">
          <source>A better solution is this:</source>
          <target state="translated">Лучшее решение-вот это:</target>
        </trans-unit>
        <trans-unit id="6b5297ccac9bf406cd190777b88e363b006c5135" translate="yes" xml:space="preserve">
          <source>A binary string is a sequence of octets (or bytes). Binary strings are distinguished from character strings in two ways. First, binary strings specifically allow storing octets of value zero and other &amp;ldquo;non-printable&amp;rdquo; octets (usually, octets outside the decimal range 32 to 126). Character strings disallow zero octets, and also disallow any other octet values and sequences of octet values that are invalid according to the database's selected character set encoding. Second, operations on binary strings process the actual bytes, whereas the processing of character strings depends on locale settings. In short, binary strings are appropriate for storing data that the programmer thinks of as &amp;ldquo;raw bytes&amp;rdquo;, whereas character strings are appropriate for storing text.</source>
          <target state="translated">Двоичная строка - это последовательность октетов (или байтов). Двоичные строки отличаются от символьных строк двумя способами. Во-первых, двоичные строки специально позволяют хранить октеты с нулевым значением и другие &amp;laquo;непечатаемые&amp;raquo; октеты (обычно октеты за пределами десятичного диапазона от 32 до 126). Строки символов не допускают нулевых октетов, а также запрещают любые другие значения октетов и последовательности значений октетов, которые недопустимы в соответствии с выбранной кодировкой набора символов базы данных. Во-вторых, операции с двоичными строками обрабатывают фактические байты, тогда как обработка символьных строк зависит от настроек локали. Короче говоря, двоичные строки подходят для хранения данных, которые программист считает &amp;laquo;необработанными байтами&amp;raquo;, тогда как символьные строки подходят для хранения текста.</target>
        </trans-unit>
        <trans-unit id="f9eaea7144ed65ec693bd5b0921667ccf802b3ac" translate="yes" xml:space="preserve">
          <source>A bit string value requires 1 byte for each group of 8 bits, plus 5 or 8 bytes overhead depending on the length of the string (but long values may be compressed or moved out-of-line, as explained in &lt;a href=&quot;datatype-character&quot;&gt;Section 8.3&lt;/a&gt; for character strings).</source>
          <target state="translated">Значение битовой строки требует 1 байт для каждой группы из 8 бит плюс 5 или 8 байтов служебных данных в зависимости от длины строки (но длинные значения могут быть сжаты или перемещены вне строки, как описано в &lt;a href=&quot;datatype-character&quot;&gt;разделе 8.3&lt;/a&gt; для символьных строк. ).</target>
        </trans-unit>
        <trans-unit id="731f4887b94e6b2c73ac23722091bfbfd646df88" translate="yes" xml:space="preserve">
          <source>A bracket expression &lt;code&gt;[...]&lt;/code&gt; specifies a character class, just as in POSIX regular expressions.</source>
          <target state="translated">Выражение в квадратных скобках &lt;code&gt;[...]&lt;/code&gt; определяет класс символов, как и в регулярных выражениях POSIX.</target>
        </trans-unit>
        <trans-unit id="accb592fdd062757612f62053a65bd65ef084e6d" translate="yes" xml:space="preserve">
          <source>A branch &amp;mdash; that is, an RE that has no top-level &lt;code&gt;|&lt;/code&gt; operator &amp;mdash; has the same greediness as the first quantified atom in it that has a greediness attribute.</source>
          <target state="translated">Ветка, то есть RE, не имеющая &lt;code&gt;|&lt;/code&gt; оператор - имеет ту же жадность, что и первый количественно определенный атом в нем, имеющий атрибут жадности.</target>
        </trans-unit>
        <trans-unit id="1e93e1b748baa49f966038b6b801bfe31bf0d6a1" translate="yes" xml:space="preserve">
          <source>A branch is zero or more &lt;em&gt;quantified atoms&lt;/em&gt; or &lt;em&gt;constraints&lt;/em&gt;, concatenated. It matches a match for the first, followed by a match for the second, etc; an empty branch matches the empty string.</source>
          <target state="translated">Ветвь - это ноль или несколько связанных &lt;em&gt;количественно атомов&lt;/em&gt; или &lt;em&gt;ограничений&lt;/em&gt; . Он соответствует совпадению для первого, за ним следует совпадение для второго и т. Д .; пустая ветка соответствует пустой строке.</target>
        </trans-unit>
        <trans-unit id="2afc09a0dce3701a8ab0f81442e2374a5fdfb59a" translate="yes" xml:space="preserve">
          <source>A brief description of the parameter</source>
          <target state="translated">Краткое описание параметра</target>
        </trans-unit>
        <trans-unit id="531e171813e0ccf35b132f56c05f84b2c29d4251" translate="yes" xml:space="preserve">
          <source>A brief example of using the extension follows.</source>
          <target state="translated">Ниже приведен краткий пример использования расширения.</target>
        </trans-unit>
        <trans-unit id="98ac6e951a01b0cf91beea39451931792f189912" translate="yes" xml:space="preserve">
          <source>A call &lt;code&gt;foo(10)&lt;/code&gt; will fail due to the ambiguity about which function should be called.</source>
          <target state="translated">Вызов &lt;code&gt;foo(10)&lt;/code&gt; завершится ошибкой из-за неоднозначности того, какую функцию следует вызывать.</target>
        </trans-unit>
        <trans-unit id="f4fd0d041b9fc5d4d7e64ce01b658bcce1a5ce19" translate="yes" xml:space="preserve">
          <source>A cascading standby sends not only WAL records received from the master but also those restored from the archive. So even if the replication connection in some upstream connection is terminated, streaming replication continues downstream for as long as new WAL records are available.</source>
          <target state="translated">Каскадное резервирование отправляет не только записи WAL,полученные от мастера,но и восстановленные из архива.Таким образом,даже если соединение репликации в каком-то восходящем подключении прервано,потоковая репликация продолжается вниз по течению до тех пор,пока доступны новые записи WAL.</target>
        </trans-unit>
        <trans-unit id="8b122451af392bc569e4090bc6ac8841aa8dd655" translate="yes" xml:space="preserve">
          <source>A case similar to filter conditions occurs with &amp;ldquo;lossy&amp;rdquo; index scans. For example, consider this search for polygons containing a specific point:</source>
          <target state="translated">Случай, подобный условиям фильтрации, происходит при сканировании индекса с потерями. Например, рассмотрим этот поиск многоугольников, содержащих определенную точку:</target>
        </trans-unit>
        <trans-unit id="1483859001ccf841f9287a26876bc89e5ac64726" translate="yes" xml:space="preserve">
          <source>A cast to or from a domain type currently has no effect. Casting to or from a domain uses the casts associated with its underlying type.</source>
          <target state="translated">В настоящее время кастинг к типу домена или из него не имеет никакого эффекта.При литье в или из домена используются слепки,связанные с его базовым типом.</target>
        </trans-unit>
        <trans-unit id="ee03111f55078d640fb1865535e64f9dbf42c86a" translate="yes" xml:space="preserve">
          <source>A catalog row appearing in the initial data can be given a manually-assigned OID by writing an &lt;code&gt;oid =&amp;gt; nnnn&lt;/code&gt; metadata field. Furthermore, if an OID is assigned, a C macro for that OID can be created by writing an &lt;code&gt;oid_symbol =&amp;gt; name&lt;/code&gt; metadata field.</source>
          <target state="translated">Строке каталога, появляющейся в исходных данных, можно присвоить назначенный вручную OID, записав поле метаданных &lt;code&gt;oid =&amp;gt; nnnn&lt;/code&gt; . Кроме того, если OID назначен, макрос C для этого OID может быть создан путем записи поля метаданных &lt;code&gt;oid_symbol =&amp;gt; name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="322518448cbeae5586806e5aaaa6dbbaaee252c8" translate="yes" xml:space="preserve">
          <source>A change in collation definitions can lead to corrupt indexes and other problems because the database system relies on stored objects having a certain sort order. Generally, this should be avoided, but it can happen in legitimate circumstances, such as when using &lt;code&gt;pg_upgrade&lt;/code&gt; to upgrade to server binaries linked with a newer version of ICU. When this happens, all objects depending on the collation should be rebuilt, for example, using &lt;code&gt;REINDEX&lt;/code&gt;. When that is done, the collation version can be refreshed using the command &lt;code&gt;ALTER COLLATION ... REFRESH VERSION&lt;/code&gt;. This will update the system catalog to record the current collator version and will make the warning go away. Note that this does not actually check whether all affected objects have been rebuilt correctly.</source>
          <target state="translated">Изменение определений сопоставления может привести к повреждению индексов и другим проблемам, поскольку система базы данных полагается на сохраненные объекты, имеющие определенный порядок сортировки. Как правило, этого следует избегать, но это может произойти в законных обстоятельствах, например, при использовании &lt;code&gt;pg_upgrade&lt;/code&gt; для обновления до бинарных файлов сервера, связанных с более новой версией ICU. Когда это происходит, все объекты, зависящие от сопоставления, должны быть перестроены, например, с помощью &lt;code&gt;REINDEX&lt;/code&gt; . Когда это будет сделано, версию сопоставления можно обновить с помощью команды &lt;code&gt;ALTER COLLATION ... REFRESH VERSION&lt;/code&gt; . Это обновит системный каталог, чтобы записать текущую версию подборщика, а предупреждение исчезнет. Обратите внимание, что на самом деле это не проверяет, все ли затронутые объекты были правильно перестроены.</target>
        </trans-unit>
        <trans-unit id="1f4a0879a18199d5f077ec0ff2e180faddd77063" translate="yes" xml:space="preserve">
          <source>A check constraint can also refer to several columns. Say you store a regular price and a discounted price, and you want to ensure that the discounted price is lower than the regular price:</source>
          <target state="translated">Ограничение проверки может также относиться к нескольким столбцам.Скажем,вы храните обычную цену и цену со скидкой,и вы хотите убедиться,что цена со скидкой ниже обычной цены:</target>
        </trans-unit>
        <trans-unit id="5fb12afa94e8bc72660d65f619fede9431dd8e90" translate="yes" xml:space="preserve">
          <source>A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For instance, to require positive product prices, you could use:</source>
          <target state="translated">Ограничение проверки является наиболее общим типом ограничения.Оно позволяет указать,что значение в определенной колонке должно удовлетворять выражению Булева (истина-значение).Например,для требования положительной цены продукта можно использовать:</target>
        </trans-unit>
        <trans-unit id="d9805d0aa6ddc05f9bc01627befe8b2b8532cb45" translate="yes" xml:space="preserve">
          <source>A checkpoint is a point in the write-ahead log sequence at which all data files have been updated to reflect the information in the log. All data files will be flushed to disk. Refer to &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt; for more details about what happens during a checkpoint.</source>
          <target state="translated">Контрольная точка - это точка в последовательности журнала упреждающей записи, в которой все файлы данных были обновлены, чтобы отразить информацию в журнале. Все файлы данных будут сброшены на диск. Обратитесь к &lt;a href=&quot;wal-configuration&quot;&gt;Разделу 29.4&lt;/a&gt; для получения более подробной информации о том, что происходит во время контрольной точки.</target>
        </trans-unit>
        <trans-unit id="1a7d37eff183865f5e0589720c997a7480356b5f" translate="yes" xml:space="preserve">
          <source>A checkpoint is also the act of carrying out all the actions that are necessary to reach a checkpoint as defined above. This process is initiated when predefined conditions are met, such as a specified amount of time has passed, or a certain volume of records has been written; or it can be invoked by the user with the command &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10395ea67c519738bcfedd97fec8b7a98e77981" translate="yes" xml:space="preserve">
          <source>A clause of the form</source>
          <target state="translated">Пункт формы</target>
        </trans-unit>
        <trans-unit id="d3d17faa1f9b24f81d090c43c22a75e3dfd2f4a5" translate="yes" xml:space="preserve">
          <source>A clause of the form &lt;code&gt;USING ( a, b, ... )&lt;/code&gt; is shorthand for &lt;code&gt;ON left_table.a = right_table.a AND left_table.b = right_table.b ...&lt;/code&gt;. Also, &lt;code&gt;USING&lt;/code&gt; implies that only one of each pair of equivalent columns will be included in the join output, not both.</source>
          <target state="translated">Положение , в форме с &lt;code&gt;USING ( a, b, ... )&lt;/code&gt; представляет собой сокращенную &lt;code&gt;ON left_table.a = right_table.a AND left_table.b = right_table.b ...&lt;/code&gt; . Кроме того, &lt;code&gt;USING&lt;/code&gt; подразумевает, что только один из каждой пары эквивалентных столбцов будет включен в вывод соединения, а не оба.</target>
        </trans-unit>
        <trans-unit id="2d0bfde758816d57c2adc33132d231587021c551" translate="yes" xml:space="preserve">
          <source>A closely related issue that affects planning time is collapsing of subqueries into their parent query. For example, consider:</source>
          <target state="translated">Тесно связанная с этим проблема,влияющая на время планирования,-это свертывание подзапросов в родительский запрос.Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="ca452f51e79db640e56e4f9925aa0048af9d720d" translate="yes" xml:space="preserve">
          <source>A code defining the specific semantics of this dependency relationship; see text</source>
          <target state="translated">Код,определяющий специфическую семантику этого зависимого отношения;см.текст</target>
        </trans-unit>
        <trans-unit id="2ca8fb5b99b4bb7400bad4589e85235d85b8712a" translate="yes" xml:space="preserve">
          <source>A code defining the type of initial privilege of this object; see text</source>
          <target state="translated">Код,определяющий тип начальной привилегии данного объекта;см.текст</target>
        </trans-unit>
        <trans-unit id="f7f2588e77da5e4feafd01ab8f374851f37bddfd" translate="yes" xml:space="preserve">
          <source>A code number indicating the kind of statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo; of the &lt;code&gt;pg_statistic&lt;/code&gt; row.</source>
          <target state="translated">Номер кода, указывающий тип статистики, хранящейся в &lt;code&gt;N&lt;/code&gt; - м &amp;laquo;слоте&amp;raquo; строки &lt;code&gt;pg_statistic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f423b7df9b88ecbf124e9ccab75b7d879dc4cca0" translate="yes" xml:space="preserve">
          <source>A collation expression</source>
          <target state="translated">Выражение сравнения</target>
        </trans-unit>
        <trans-unit id="9c0dd05ad8edff154a8e6c9ab1b14bf3a7460e7c" translate="yes" xml:space="preserve">
          <source>A collation is an SQL schema object that maps an SQL name to locales provided by libraries installed in the operating system. A collation definition has a &lt;em&gt;provider&lt;/em&gt; that specifies which library supplies the locale data. One standard provider name is &lt;code&gt;libc&lt;/code&gt;, which uses the locales provided by the operating system C library. These are the locales that most tools provided by the operating system use. Another provider is &lt;code&gt;icu&lt;/code&gt;, which uses the external ICU library. ICU locales can only be used if support for ICU was configured when PostgreSQL was built.</source>
          <target state="translated">Параметры сортировки - это объект схемы SQL, который сопоставляет имя SQL с языковыми стандартами, предоставляемыми библиотеками, установленными в операционной системе. Определение сопоставления имеет &lt;em&gt;поставщика,&lt;/em&gt; который указывает, какая библиотека предоставляет данные языкового стандарта. Одно стандартное имя поставщика - &lt;code&gt;libc&lt;/code&gt; , в котором используются локали, предоставленные библиотекой C. Это локали, которые использует большинство инструментов, предоставляемых операционной системой. Другой провайдер - &lt;code&gt;icu&lt;/code&gt; , который использует внешнюю библиотеку ICU. Локали ICU могут использоваться только в том случае, если поддержка ICU была настроена при сборке PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="fd492bf97f6c0e26453468337ad19bf874c44502" translate="yes" xml:space="preserve">
          <source>A collation is either &lt;em&gt;deterministic&lt;/em&gt; or &lt;em&gt;nondeterministic&lt;/em&gt;. A deterministic collation uses deterministic comparisons, which means that it considers strings to be equal only if they consist of the same byte sequence. Nondeterministic comparison may determine strings to be equal even if they consist of different bytes. Typical situations include case-insensitive comparison, accent-insensitive comparison, as well as comparison of strings in different Unicode normal forms. It is up to the collation provider to actually implement such insensitive comparisons; the deterministic flag only determines whether ties are to be broken using bytewise comparison. See also &lt;a href=&quot;https://unicode.org/reports/tr10&quot;&gt;Unicode Technical Standard 10&lt;/a&gt; for more information on the terminology.</source>
          <target state="translated">Параметры сортировки могут быть &lt;em&gt;детерминированными&lt;/em&gt; или &lt;em&gt;недетерминированными&lt;/em&gt; . Детерминированное сопоставление использует детерминированные сравнения, что означает, что оно считает строки равными, только если они состоят из одной и той же последовательности байтов. Недетерминированное сравнение может определять, что строки равны, даже если они состоят из разных байтов. Типичные ситуации включают сравнение без учета регистра, сравнение без учета акцента, а также сравнение строк в различных нормальных формах Unicode. Реализовать такие нечувствительные сравнения должен провайдер сопоставления; детерминированный флаг определяет только, следует ли разрывать связи, используя побайтовое сравнение. См. Также &lt;a href=&quot;https://unicode.org/reports/tr10&quot;&gt;Технический стандарт 10 Unicode&lt;/a&gt; для получения дополнительной информации о терминологии.</target>
        </trans-unit>
        <trans-unit id="585469a73deac416236caf1e82c0a86b85aed8e2" translate="yes" xml:space="preserve">
          <source>A collation is either &lt;em&gt;deterministic&lt;/em&gt; or &lt;em&gt;nondeterministic&lt;/em&gt;. A deterministic collation uses deterministic comparisons, which means that it considers strings to be equal only if they consist of the same byte sequence. Nondeterministic comparison may determine strings to be equal even if they consist of different bytes. Typical situations include case-insensitive comparison, accent-insensitive comparison, as well as comparison of strings in different Unicode normal forms. It is up to the collation provider to actually implement such insensitive comparisons; the deterministic flag only determines whether ties are to be broken using bytewise comparison. See also &lt;a href=&quot;https://www.unicode.org/reports/tr10&quot;&gt;Unicode Technical Standard 10&lt;/a&gt; for more information on the terminology.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ebffe965dbfb2b402733d22f1b65d8768ef66b6" translate="yes" xml:space="preserve">
          <source>A collation object provided by &lt;code&gt;icu&lt;/code&gt; maps to a named collator provided by the ICU library. ICU does not support separate &amp;ldquo;collate&amp;rdquo; and &amp;ldquo;ctype&amp;rdquo; settings, so they are always the same. Also, ICU collations are independent of the encoding, so there is always only one ICU collation of a given name in a database.</source>
          <target state="translated">Объект сопоставления, предоставляемый &lt;code&gt;icu&lt;/code&gt; , сопоставляется с именованным сопоставителем, предоставленным библиотекой ICU. ICU не поддерживает отдельные параметры сопоставления и ctype, поэтому они всегда одинаковы. Кроме того, сопоставления ICU не зависят от кодировки, поэтому в базе данных всегда есть только одно сопоставление ICU с заданным именем.</target>
        </trans-unit>
        <trans-unit id="67e66134fe986b5a1161f010ed997e5c29515718" translate="yes" xml:space="preserve">
          <source>A collation object provided by &lt;code&gt;libc&lt;/code&gt; maps to a combination of &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings, as accepted by the &lt;code&gt;setlocale()&lt;/code&gt; system library call. (As the name would suggest, the main purpose of a collation is to set &lt;code&gt;LC_COLLATE&lt;/code&gt;, which controls the sort order. But it is rarely necessary in practice to have an &lt;code&gt;LC_CTYPE&lt;/code&gt; setting that is different from &lt;code&gt;LC_COLLATE&lt;/code&gt;, so it is more convenient to collect these under one concept than to create another infrastructure for setting &lt;code&gt;LC_CTYPE&lt;/code&gt; per expression.) Also, a &lt;code&gt;libc&lt;/code&gt; collation is tied to a character set encoding (see &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;). The same collation name may exist for different encodings.</source>
          <target state="translated">Объект сопоставления, предоставляемый &lt;code&gt;libc&lt;/code&gt; , сопоставляется с комбинацией &lt;code&gt;LC_COLLATE&lt;/code&gt; и &lt;code&gt;LC_CTYPE&lt;/code&gt; , как это принято вызовом системной библиотеки &lt;code&gt;setlocale()&lt;/code&gt; . (Как следует из названия, основная цель сопоставления - установить &lt;code&gt;LC_COLLATE&lt;/code&gt; , который управляет порядком сортировки. Но на практике редко бывает необходимо иметь параметр &lt;code&gt;LC_CTYPE&lt;/code&gt; , отличный от &lt;code&gt;LC_COLLATE&lt;/code&gt; , поэтому удобнее собирать эти в рамках одной концепции, чем создание другой инфраструктуры для установки &lt;code&gt;LC_CTYPE&lt;/code&gt; для каждого выражения.) Кроме того, сопоставление &lt;code&gt;libc&lt;/code&gt; привязано к кодировке набора символов (см. &lt;a href=&quot;multibyte&quot;&gt;Раздел 23.3.&lt;/a&gt;). Одно и то же имя сопоставления может существовать для разных кодировок.</target>
        </trans-unit>
        <trans-unit id="dbd951bae781e6ca52e1aa0ea05378979fbabbd4" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; in a fixed order. That order may be defined by the &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; (or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;) where the tuple is contained, in which case the tuple is often called a &lt;em&gt;row&lt;/em&gt;. It may also be defined by the structure of a result set, in which case it is sometimes called a &lt;em&gt;record&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d02a0633df2ef26eee92135725af62089ef8cb" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;tables&lt;/a&gt; which describe the structure of all &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt; of the instance. The system catalog resides in the schema &lt;code&gt;pg_catalog&lt;/code&gt;. These tables contain data in internal representation and are not typically considered useful for user examination; a number of user-friendlier &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;views&lt;/a&gt;, also in schema &lt;code&gt;pg_catalog&lt;/code&gt;, offer more convenient access to some of that information, while additional tables and views exist in schema &lt;code&gt;information_schema&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) that expose some of the same and additional information as mandated by the &lt;a href=&quot;glossary#GLOSSARY-SQL-STANDARD&quot;&gt;SQL standard&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b63b111cc045d92308ab6bb0ff812b8d4531fcd" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuples&lt;/a&gt; having a common data structure (the same number of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt;, in the same order, having the same name and type per position). A table is the most common form of &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; in PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e16773e18c89eb8dbf7379d075c0ed8024236a" translate="yes" xml:space="preserve">
          <source>A collection of access privileges to the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;instance&lt;/a&gt;. Roles are themselves a privilege that can be granted to other roles. This is often done for convenience or to ensure completeness when multiple &lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;users&lt;/a&gt; need the same privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b0b809d9ea56c7639bef5d5e043207a72e42ff" translate="yes" xml:space="preserve">
          <source>A collection of databases and global SQL objects, and their common static and dynamic metadata. Sometimes referred to as a &lt;em&gt;cluster&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243ac044c18a03ce7230410123ce180ce925ca61" translate="yes" xml:space="preserve">
          <source>A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt;.)</source>
          <target state="translated">Столбцу можно присвоить значение по умолчанию. Когда создается новая строка и для некоторых столбцов не указаны значения, эти столбцы будут заполнены соответствующими значениями по умолчанию. Команда манипулирования данными также может явно запросить, чтобы столбцу было присвоено значение по умолчанию, без необходимости знать, что это за значение. (Подробности о командах манипулирования данными см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;главе 6.&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="728c6855211584a9477504f501bcae575c68f1dd" translate="yes" xml:space="preserve">
          <source>A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a303981025d3fba2a49b2d8afa067fd02f82810b" translate="yes" xml:space="preserve">
          <source>A column can be referenced in the form:</source>
          <target state="translated">На колонку можно дать ссылку в форме:</target>
        </trans-unit>
        <trans-unit id="5e814702f2c68b1dd74624138092e2f2dac25d61" translate="yes" xml:space="preserve">
          <source>A column marked &lt;code&gt;FOR ORDINALITY&lt;/code&gt; will be populated with row numbers, starting with 1, in the order of nodes retrieved from the &lt;code&gt;row_expression&lt;/code&gt;'s result node-set. At most one column may be marked &lt;code&gt;FOR ORDINALITY&lt;/code&gt;.</source>
          <target state="translated">Столбец, помеченный &lt;code&gt;FOR ORDINALITY&lt;/code&gt; , будет заполнен номерами строк, начиная с 1, в порядке узлов, извлеченных из &lt;code&gt;row_expression&lt;/code&gt; узлов row_expression . &lt;code&gt;FOR ORDINALITY&lt;/code&gt; можно пометить не более одного столбца .</target>
        </trans-unit>
        <trans-unit id="12e0d49f86838408b879ad07c7e5231286011142" translate="yes" xml:space="preserve">
          <source>A column of a foreign table created using this wrapper can have the following options:</source>
          <target state="translated">Столбец чужой таблицы,созданный с помощью этой обертки,может иметь следующие опции:</target>
        </trans-unit>
        <trans-unit id="cc14af77e732b86dd798941f4129e5ffc051f3d7" translate="yes" xml:space="preserve">
          <source>A column reference</source>
          <target state="translated">Ссылка на колонку</target>
        </trans-unit>
        <trans-unit id="43fad0f566cbecaf300364b0a3a7343007869d54" translate="yes" xml:space="preserve">
          <source>A column-specific trigger (one defined using the &lt;code&gt;UPDATE OF column_name&lt;/code&gt; syntax) will fire when any of its columns are listed as targets in the &lt;code&gt;UPDATE&lt;/code&gt; command's &lt;code&gt;SET&lt;/code&gt; list. It is possible for a column's value to change even when the trigger is not fired, because changes made to the row's contents by &lt;code&gt;BEFORE UPDATE&lt;/code&gt; triggers are not considered. Conversely, a command such as &lt;code&gt;UPDATE ... SET x = x ...&lt;/code&gt; will fire a trigger on column &lt;code&gt;x&lt;/code&gt;, even though the column's value did not change.</source>
          <target state="translated">Зависящий от столбца триггер (определенный с использованием синтаксиса &lt;code&gt;UPDATE OF column_name&lt;/code&gt; ) срабатывает, когда какой-либо из его столбцов указан в качестве целей в списке &lt;code&gt;SET&lt;/code&gt; команды &lt;code&gt;UPDATE&lt;/code&gt; . Значение столбца может измениться, даже если триггер не сработал, поскольку изменения, внесенные в содержимое строки триггерами &lt;code&gt;BEFORE UPDATE&lt;/code&gt; , не рассматриваются. И наоборот, такая команда, как &lt;code&gt;UPDATE ... SET x = x ...&lt;/code&gt; запускает триггер для столбца &lt;code&gt;x&lt;/code&gt; , даже если значение столбца не изменилось.</target>
        </trans-unit>
        <trans-unit id="e7ce99ce6bf9fda66b89c10600a10dba3a88bd33" translate="yes" xml:space="preserve">
          <source>A combination of commands that must act as a single &lt;a href=&quot;glossary#GLOSSARY-ATOMIC&quot;&gt;atomic&lt;/a&gt; command: they all succeed or all fail as a single unit, and their effects are not visible to other &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;sessions&lt;/a&gt; until the transaction is complete, and possibly even later, depending on the isolation level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f697bbd81557d764888518e1af36278f9c8d3579" translate="yes" xml:space="preserve">
          <source>A combination of dynamic domain transition and trusted procedure enables an interesting use case that fits the typical process life-cycle of connection pooling software. Even if your connection pooling software is not allowed to run most of SQL commands, you can allow it to switch the security label of the client using the &lt;code&gt;sepgsql_setcon()&lt;/code&gt; function from within a trusted procedure; that should take some credential to authorize the request to switch the client label. After that, this session will have the privileges of the target user, rather than the connection pooler. The connection pooler can later revert the security label change by again using &lt;code&gt;sepgsql_setcon()&lt;/code&gt; with &lt;code&gt;NULL&lt;/code&gt; argument, again invoked from within a trusted procedure with appropriate permissions checks. The point here is that only the trusted procedure actually has permission to change the effective security label, and only does so when given proper credentials. Of course, for secure operation, the credential store (table, procedure definition, or whatever) must be protected from unauthorized access.</source>
          <target state="translated">Комбинация динамического перехода домена и доверенной процедуры позволяет реализовать интересный вариант использования, который соответствует типичному жизненному циклу процесса программного обеспечения пула соединений. Даже если вашему программному обеспечению для пула соединений не разрешено выполнять большинство команд SQL, вы можете разрешить ему переключать метку безопасности клиента с помощью функции &lt;code&gt;sepgsql_setcon()&lt;/code&gt; из доверенной процедуры; который должен принимать некоторые учетные данные для авторизации запроса на переключение метки клиента. После этого этот сеанс будет иметь привилегии целевого пользователя, а не пула подключений. Пул подключений может позже отменить изменение метки безопасности, снова используя &lt;code&gt;sepgsql_setcon()&lt;/code&gt; с &lt;code&gt;NULL&lt;/code&gt; .аргумент, снова вызываемый из доверенной процедуры с соответствующими проверками разрешений. Дело в том, что только доверенная процедура действительно имеет разрешение на изменение действующей метки безопасности, и делает это только при наличии надлежащих учетных данных. Конечно, для безопасной работы хранилище учетных данных (таблица, определение процедуры или что-то еще) должно быть защищено от несанкционированного доступа.</target>
        </trans-unit>
        <trans-unit id="2911cc608e469494b5712a777002f2e21913d79f" translate="yes" xml:space="preserve">
          <source>A command to execute. In &lt;code&gt;COPY FROM&lt;/code&gt;, the input is read from standard output of the command, and in &lt;code&gt;COPY TO&lt;/code&gt;, the output is written to the standard input of the command.</source>
          <target state="translated">Команда для выполнения. В &lt;code&gt;COPY FROM&lt;/code&gt; ввод считывается из стандартного вывода команды, а в &lt;code&gt;COPY TO&lt;/code&gt; вывод записывается на стандартный ввод команды.</target>
        </trans-unit>
        <trans-unit id="b8b60faef517b04517cdc32cdeaec6d45d821a98" translate="yes" xml:space="preserve">
          <source>A command to prevent access to a named set of &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; objects for a named list of &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;roles&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432b06e57f9235552442ece4a5144f1741f08cf9" translate="yes" xml:space="preserve">
          <source>A command to undo all of the operations performed since the beginning of a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfeede7bacbce2d25ad1c8afefcc0d73e7394ef6" translate="yes" xml:space="preserve">
          <source>A comment is a sequence of characters beginning with double dashes and extending to the end of the line, e.g.:</source>
          <target state="translated">Комментарий-это последовательность символов,начинающаяся с двойных тире и простирающаяся до конца строки,например:</target>
        </trans-unit>
        <trans-unit id="3eb6cee486403a5e9f022d4d86b027a6b1d863bd" translate="yes" xml:space="preserve">
          <source>A comment is removed from the input stream before further syntax analysis and is effectively replaced by whitespace.</source>
          <target state="translated">Комментарий удаляется из входного потока перед дальнейшим синтаксическим анализом и эффективно заменяется пробелом.</target>
        </trans-unit>
        <trans-unit id="fd4ff7f9082f219e362f6b80b3a0778be34303a7" translate="yes" xml:space="preserve">
          <source>A completely empty field value (no characters at all between the commas or parentheses) represents a NULL. To write a value that is an empty string rather than NULL, write &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Полностью пустое значение поля (без символов между запятыми или круглыми скобками) представляет собой NULL. Чтобы записать значение, которое является пустой строкой, а не NULL, напишите &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc479538bc2519f6be7743a108e2d4369ba071e0" translate="yes" xml:space="preserve">
          <source>A computer on which PostgreSQL &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instances&lt;/a&gt; run. The term &lt;em&gt;server&lt;/em&gt; denotes real hardware, a container, or a &lt;em&gt;virtual machine&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712b440e19e5b1db615da5ae01b27ee905115fec" translate="yes" xml:space="preserve">
          <source>A computer that communicates with other computers over a network. This is sometimes used as a synonym for &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt;. It is also used to refer to a computer where &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client processes&lt;/a&gt; run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2c2b765e8d46a4effd9275029b3ac9ce35557f" translate="yes" xml:space="preserve">
          <source>A concept of non-existence that is a central tenet of relational database theory. It represents the absence of a definite value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db43da6a754b048f8c15b9fee6431ce49e646a6c" translate="yes" xml:space="preserve">
          <source>A conflict will produce an error and will stop the replication; it must be resolved manually by the user. Details about the conflict can be found in the subscriber's server log.</source>
          <target state="translated">Конфликт приведет к ошибке и остановит репликацию;он должен быть разрешен вручную пользователем.Подробную информацию о конфликте можно найти в лог-файле сервера абонента.</target>
        </trans-unit>
        <trans-unit id="6de61942e5889f7081d4c447f2d861f6661580c6" translate="yes" xml:space="preserve">
          <source>A connection from an application program to the PostgreSQL server has to be established. The application program transmits a query to the server and waits to receive the results sent back by the server.</source>
          <target state="translated">Необходимо установить соединение от прикладной программы к серверу PostgreSQL.Прикладная программа передает запрос на сервер и ожидает получения результатов,отправленных сервером.</target>
        </trans-unit>
        <trans-unit id="ff27f94049d4acbe17b6492b665c173de57c0e06" translate="yes" xml:space="preserve">
          <source>A constant of an &lt;em&gt;arbitrary&lt;/em&gt; type can be entered using any one of the following notations:</source>
          <target state="translated">Константу &lt;em&gt;произвольного&lt;/em&gt; типа можно ввести в любой из следующих нотаций:</target>
        </trans-unit>
        <trans-unit id="def2a00f2b728102b713698dbaec6bf7d1b1ba45" translate="yes" xml:space="preserve">
          <source>A constant or expression to compute and insert at the indicated place in the resulting table (set of rows). In a &lt;code&gt;VALUES&lt;/code&gt; list appearing at the top level of an &lt;code&gt;INSERT&lt;/code&gt;, an &lt;code&gt;expression&lt;/code&gt; can be replaced by &lt;code&gt;DEFAULT&lt;/code&gt; to indicate that the destination column's default value should be inserted. &lt;code&gt;DEFAULT&lt;/code&gt; cannot be used when &lt;code&gt;VALUES&lt;/code&gt; appears in other contexts.</source>
          <target state="translated">Константа или выражение для вычисления и вставки в указанное место в результирующей таблице (набор строк). В списке &lt;code&gt;VALUES&lt;/code&gt; , появляющемся на верхнем уровне &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;expression&lt;/code&gt; может быть заменено на &lt;code&gt;DEFAULT&lt;/code&gt; , чтобы указать, что значение по умолчанию для целевого столбца должно быть вставлено. &lt;code&gt;DEFAULT&lt;/code&gt; нельзя использовать, когда &lt;code&gt;VALUES&lt;/code&gt; появляется в других контекстах.</target>
        </trans-unit>
        <trans-unit id="f51660594b80d9306c037e5807f00beb6e91d699" translate="yes" xml:space="preserve">
          <source>A constant or literal value</source>
          <target state="translated">Постоянное или буквальное значение</target>
        </trans-unit>
        <trans-unit id="cf8fda03118cc7add18d0baf25c70ed12492a1c1" translate="yes" xml:space="preserve">
          <source>A constraint marked with &lt;code&gt;NO INHERIT&lt;/code&gt; will not propagate to child tables.</source>
          <target state="translated">Ограничение, помеченное как &lt;code&gt;NO INHERIT&lt;/code&gt; , не распространяется на дочерние таблицы.</target>
        </trans-unit>
        <trans-unit id="8913bbb8fb57baf6761a820445fb91f212ee581b" translate="yes" xml:space="preserve">
          <source>A convention often used is to write key words in upper case and names in lower case, e.g.:</source>
          <target state="translated">Часто используется конвенция для написания ключевых слов в верхнем регистре и имен в нижнем регистре,например:</target>
        </trans-unit>
        <trans-unit id="270045f32202a02af54823e311103963348c2e0e" translate="yes" xml:space="preserve">
          <source>A conversion of a &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;datum&lt;/a&gt; from its current data type to another data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee55ddb20eb8d0ea230a86a3979ff4c9211fbe9" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typalign&lt;/code&gt; of this column's type</source>
          <target state="translated">Копия &lt;code&gt;pg_type.typalign&lt;/code&gt; типа этого столбца</target>
        </trans-unit>
        <trans-unit id="16520694e80b09447c7974353ea21a94aea9b85b" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typbyval&lt;/code&gt; of this column's type</source>
          <target state="translated">Копия &lt;code&gt;pg_type.typbyval&lt;/code&gt; типа этого столбца</target>
        </trans-unit>
        <trans-unit id="469c374912ca15a938f750a67728c2d10a7ddd2a" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typlen&lt;/code&gt; of this column's type</source>
          <target state="translated">Копия &lt;code&gt;pg_type.typlen&lt;/code&gt; типа этого столбца</target>
        </trans-unit>
        <trans-unit id="64372429a7f7ff378ebe32047bb948215d6fc9f3" translate="yes" xml:space="preserve">
          <source>A cursor has an associated position, which is used by &lt;code&gt;FETCH&lt;/code&gt;. The cursor position can be before the first row of the query result, on any particular row of the result, or after the last row of the result. When created, a cursor is positioned before the first row. After fetching some rows, the cursor is positioned on the row most recently retrieved. If &lt;code&gt;FETCH&lt;/code&gt; runs off the end of the available rows then the cursor is left positioned after the last row, or before the first row if fetching backward. &lt;code&gt;FETCH ALL&lt;/code&gt; or &lt;code&gt;FETCH BACKWARD ALL&lt;/code&gt; will always leave the cursor positioned after the last row or before the first row.</source>
          <target state="translated">У курсора есть связанная позиция, которая используется &lt;code&gt;FETCH&lt;/code&gt; . Положение курсора может быть перед первой строкой результата запроса, в любой конкретной строке результата или после последней строки результата. При создании курсор располагается перед первой строкой. После получения нескольких строк курсор устанавливается на строку, полученную последней. Если &lt;code&gt;FETCH&lt;/code&gt; запускается за конец доступных строк, то курсор остается после последней строки или перед первой строкой, если выполняется выборка назад. &lt;code&gt;FETCH ALL&lt;/code&gt; или &lt;code&gt;FETCH BACKWARD ALL&lt;/code&gt; всегда будет оставлять курсор после последней строки или перед первой строкой.</target>
        </trans-unit>
        <trans-unit id="ca84330d2df84d2fb3203c9d1abd5c728ed51c45" translate="yes" xml:space="preserve">
          <source>A custom-format dump is not a script for psql, but instead must be restored with pg_restore, for example:</source>
          <target state="translated">Пользовательский дамп формата не является скриптом для psql,а должен быть восстановлен,например,с помощью pg_restore:</target>
        </trans-unit>
        <trans-unit id="ac05a9e40c0d434aa68a1851fc9e7d6d26043953" translate="yes" xml:space="preserve">
          <source>A data type &lt;code&gt;tsvector&lt;/code&gt; is provided for storing preprocessed documents, along with a type &lt;code&gt;tsquery&lt;/code&gt; for representing processed queries (&lt;a href=&quot;datatype-textsearch&quot;&gt;Section 8.11&lt;/a&gt;). There are many functions and operators available for these data types (&lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt;), the most important of which is the match operator &lt;code&gt;@@&lt;/code&gt;, which we introduce in &lt;a href=&quot;textsearch-intro#TEXTSEARCH-MATCHING&quot;&gt;Section 12.1.2&lt;/a&gt;. Full text searches can be accelerated using indexes (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;).</source>
          <target state="translated">Тип данных &lt;code&gt;tsvector&lt;/code&gt; предоставляется для хранения предварительно обработанных документов вместе с типом &lt;code&gt;tsquery&lt;/code&gt; для представления обработанных запросов ( &lt;a href=&quot;datatype-textsearch&quot;&gt;раздел 8.11&lt;/a&gt; ). Для этих типов данных доступно множество функций и операторов ( &lt;a href=&quot;functions-textsearch&quot;&gt;раздел 9.13&lt;/a&gt; ), наиболее важным из которых является оператор соответствия &lt;code&gt;@@&lt;/code&gt; , который мы представим в &lt;a href=&quot;textsearch-intro#TEXTSEARCH-MATCHING&quot;&gt;разделе 12.1.2&lt;/a&gt; . Полнотекстовый поиск можно ускорить с помощью индексов ( &lt;a href=&quot;textsearch-indexes&quot;&gt;раздел 12.9&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c829ffd204fab8f2c9ec9a14aa40a4d117b945a" translate="yes" xml:space="preserve">
          <source>A data-only dump will still use &lt;code&gt;COPY&lt;/code&gt;, but it does not drop or recreate indexes, and it does not normally touch foreign keys. &lt;a href=&quot;#ftn.id-1.5.13.7.11.4.2&quot;&gt;&lt;sup id=&quot;id-1.5.13.7.11.4.2&quot;&gt;[13]&lt;/sup&gt;&lt;/a&gt; So when loading a data-only dump, it is up to you to drop and recreate indexes and foreign keys if you wish to use those techniques. It's still useful to increase &lt;code&gt;max_wal_size&lt;/code&gt; while loading the data, but don't bother increasing &lt;code&gt;maintenance_work_mem&lt;/code&gt;; rather, you'd do that while manually recreating indexes and foreign keys afterwards. And don't forget to &lt;code&gt;ANALYZE&lt;/code&gt; when you're done; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">Дамп только данных по-прежнему будет использовать &lt;code&gt;COPY&lt;/code&gt; , но он не удаляет и не воссоздает индексы, и обычно не касается внешних ключей. &lt;a href=&quot;#ftn.id-1.5.13.7.11.4.2&quot;&gt;&lt;sup id=&quot;id-1.5.13.7.11.4.2&quot;&gt;[13]&lt;/sup&gt;&lt;/a&gt; Таким образом, при загрузке дампа только с данными вы должны удалить и воссоздать индексы и внешние ключи, если хотите использовать эти методы. По-прежнему полезно увеличивать &lt;code&gt;max_wal_size&lt;/code&gt; при загрузке данных, но не беспокойтесь об увеличении &lt;code&gt;maintenance_work_mem&lt;/code&gt; ; скорее, вы бы сделали это при последующем создании индексов и внешних ключей вручную. И не забудьте &lt;code&gt;ANALYZE&lt;/code&gt; когда закончите; см. &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Раздел 24.1.3&lt;/a&gt; и &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Раздел 24.1.6&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="a7efff5b8bc220045364eeb6371d5a7d0adfbf4d" translate="yes" xml:space="preserve">
          <source>A database contains one or more named &lt;em&gt;schemas&lt;/em&gt;, which in turn contain tables. Schemas also contain other kinds of named objects, including data types, functions, and operators. The same object name can be used in different schemas without conflict; for example, both &lt;code&gt;schema1&lt;/code&gt; and &lt;code&gt;myschema&lt;/code&gt; can contain tables named &lt;code&gt;mytable&lt;/code&gt;. Unlike databases, schemas are not rigidly separated: a user can access objects in any of the schemas in the database they are connected to, if they have privileges to do so.</source>
          <target state="translated">База данных содержит одну или несколько именованных &lt;em&gt;схем&lt;/em&gt; , которые, в свою очередь, содержат таблицы. Схемы также содержат другие виды именованных объектов, включая типы данных, функции и операторы. Одно и то же имя объекта может использоваться в разных схемах без конфликтов; например, и &lt;code&gt;schema1&lt;/code&gt; , и &lt;code&gt;myschema&lt;/code&gt; могут содержать таблицы с именем &lt;code&gt;mytable&lt;/code&gt; . В отличие от баз данных, схемы не разделены жестко: пользователь может получить доступ к объектам в любой из схем в базе данных, к которой он подключен, если у него есть на это права.</target>
        </trans-unit>
        <trans-unit id="3ebb2f86492fa3a77fa0db26d0c30c86dff05744" translate="yes" xml:space="preserve">
          <source>A database is a named collection of SQL objects (&amp;ldquo;database objects&amp;rdquo;). Generally, every database object (tables, functions, etc.) belongs to one and only one database. (However there are a few system catalogs, for example &lt;code&gt;pg_database&lt;/code&gt;, that belong to a whole cluster and are accessible from each database within the cluster.) More accurately, a database is a collection of schemas and the schemas contain the tables, functions, etc. So the full hierarchy is: server, database, schema, table (or some other kind of object, such as a function).</source>
          <target state="translated">База данных - это именованная коллекция объектов SQL (&amp;laquo;объекты базы данных&amp;raquo;). Как правило, каждый объект базы данных (таблицы, функции и т. Д.) Принадлежит одной и только одной базе данных. (Однако есть несколько системных каталогов, например &lt;code&gt;pg_database&lt;/code&gt; , которые принадлежат целому кластеру и доступны из каждой базы данных в кластере.) Точнее, база данных представляет собой набор схем, а схемы содержат таблицы, функции и т. Д. Итак, полная иерархия такова: сервер, база данных, схема, таблица (или какой-то другой объект, например функция).</target>
        </trans-unit>
        <trans-unit id="c7d2c9abe130147ea353b9080d406b7f3bf3c1ff" translate="yes" xml:space="preserve">
          <source>A database role can have a number of attributes that define its privileges and interact with the client authentication system.</source>
          <target state="translated">Роль базы данных может иметь ряд атрибутов,которые определяют ее привилегии и взаимодействуют с системой аутентификации клиентов.</target>
        </trans-unit>
        <trans-unit id="a3022f04bd927ba344f6e517eda753ede33a9966" translate="yes" xml:space="preserve">
          <source>A database superuser bypasses all permission checks, except the right to log in. This is a dangerous privilege and should not be used carelessly; it is best to do most of your work as a role that is not a superuser. To create a new database superuser, use &lt;code&gt;CREATE ROLE name SUPERUSER&lt;/code&gt;. You must do this as a role that is already a superuser.</source>
          <target state="translated">Суперпользователь базы данных обходит все проверки разрешений, кроме права входа в систему. Это опасная привилегия, и ее не следует использовать небрежно; лучше всего выполнять большую часть своей работы в роли не суперпользователя. Чтобы создать нового суперпользователя базы данных, используйте &lt;code&gt;CREATE ROLE name SUPERUSER&lt;/code&gt; . Вы должны сделать это как роль, которая уже является суперпользователем.</target>
        </trans-unit>
        <trans-unit id="a652bebb73f376f1df0ca8598fee059cf76fc365" translate="yes" xml:space="preserve">
          <source>A default value can be specified, in case a user wants columns of the data type to default to something other than the null value. Specify the default with the &lt;code&gt;DEFAULT&lt;/code&gt; key word. (Such a default can be overridden by an explicit &lt;code&gt;DEFAULT&lt;/code&gt; clause attached to a particular column.)</source>
          <target state="translated">Можно указать значение по умолчанию, если пользователь хочет, чтобы для столбцов этого типа данных по умолчанию было выбрано значение, отличное от нулевого. Укажите значение по умолчанию с помощью ключевого слова &lt;code&gt;DEFAULT&lt;/code&gt; . (Такое значение по умолчанию может быть отменено явным предложением &lt;code&gt;DEFAULT&lt;/code&gt; , прикрепленным к определенному столбцу.)</target>
        </trans-unit>
        <trans-unit id="260245ca0f51394bde912da70513f69a2611aadc" translate="yes" xml:space="preserve">
          <source>A defined set of instructions stored in the database system that can be invoked for execution. A routine can be written in a variety of programming languages. Routines can be &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;functions&lt;/a&gt; (including set-returning functions and &lt;a href=&quot;glossary#GLOSSARY-TRIGGER&quot;&gt;trigger functions&lt;/a&gt;), &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;aggregate functions&lt;/a&gt;, and &lt;a href=&quot;glossary#GLOSSARY-PROCEDURE&quot;&gt;procedures&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1f42cac75263776f033d6ed34f1fbc16bad9be" translate="yes" xml:space="preserve">
          <source>A delay of this many seconds occurs when a new server process is started, after it conducts the authentication procedure. This is intended to give an opportunity to attach to the server process with a debugger.</source>
          <target state="translated">Задержка в несколько секунд возникает при запуске нового процесса на сервере,после того,как он проводит процедуру аутентификации.Это сделано для того,чтобы дать возможность подключиться к серверному процессу с помощью отладчика.</target>
        </trans-unit>
        <trans-unit id="cd25a0e450014180419d77ce403bad9e20cb5564" translate="yes" xml:space="preserve">
          <source>A detailed description of bison or the grammar rules given in &lt;code&gt;gram.y&lt;/code&gt; would be beyond the scope of this paper. There are many books and documents dealing with flex and bison. You should be familiar with bison before you start to study the grammar given in &lt;code&gt;gram.y&lt;/code&gt; otherwise you won't understand what happens there.</source>
          <target state="translated">Подробное описание зубров или грамматических правил в &lt;code&gt;gram.y&lt;/code&gt; выходит за рамки данной статьи. Есть много книг и документов, посвященных гибкости и зубру. Вы должны познакомиться с зубрами, прежде чем приступить к изучению грамматики в &lt;code&gt;gram.y&lt;/code&gt; иначе вы не поймете, что там происходит.</target>
        </trans-unit>
        <trans-unit id="bf3c5419b01f42e467232a91a0454e478bf36293" translate="yes" xml:space="preserve">
          <source>A dictionary is a program that accepts a token as input and returns:</source>
          <target state="translated">Словарь-это программа,которая принимает токен в качестве входного и возвращает его:</target>
        </trans-unit>
        <trans-unit id="28559b5d13d6b8ce91e33b4017f8d681ab5ce5fe" translate="yes" xml:space="preserve">
          <source>A different approach to redirecting inserts into the appropriate child table is to set up rules, instead of a trigger, on the master table. For example:</source>
          <target state="translated">Другой подход к перенаправлению вставок в соответствующую дочернюю таблицу заключается в установке правил,а не триггера,на главной таблице.Например:</target>
        </trans-unit>
        <trans-unit id="92dd343b65d278a179ec5a3ad694901513c02d90" translate="yes" xml:space="preserve">
          <source>A different setting might be appropriate when doing synchronous logical replication. The logical replication workers report the positions of writes and flushes to the publisher, and when using synchronous replication, the publisher will wait for the actual flush. This means that setting &lt;code&gt;synchronous_commit&lt;/code&gt; for the subscriber to &lt;code&gt;off&lt;/code&gt; when the subscription is used for synchronous replication might increase the latency for &lt;code&gt;COMMIT&lt;/code&gt; on the publisher. In this scenario, it can be advantageous to set &lt;code&gt;synchronous_commit&lt;/code&gt; to &lt;code&gt;local&lt;/code&gt; or higher.</source>
          <target state="translated">При синхронной логической репликации может потребоваться другой параметр. Рабочие логической репликации сообщают издателю о позициях записи и сброса, а при использовании синхронной репликации издатель будет ждать фактического сброса. Это означает, что установка параметра &lt;code&gt;synchronous_commit&lt;/code&gt; для подписчика на &lt;code&gt;off&lt;/code&gt; , когда подписка используется для синхронной репликации, может увеличить задержку для &lt;code&gt;COMMIT&lt;/code&gt; на издателе. В этом сценарии может быть выгодно установить для &lt;code&gt;synchronous_commit&lt;/code&gt; значение &lt;code&gt;local&lt;/code&gt; или выше.</target>
        </trans-unit>
        <trans-unit id="77b0f5ef06846b6f2b1bf89e5b5dc745a05b482a" translate="yes" xml:space="preserve">
          <source>A disadvantage of the &lt;code&gt;jsonb_path_ops&lt;/code&gt; approach is that it produces no index entries for JSON structures not containing any values, such as &lt;code&gt;{&quot;a&quot;: {}}&lt;/code&gt;. If a search for documents containing such a structure is requested, it will require a full-index scan, which is quite slow. &lt;code&gt;jsonb_path_ops&lt;/code&gt; is therefore ill-suited for applications that often perform such searches.</source>
          <target state="translated">Недостатком подхода &lt;code&gt;jsonb_path_ops&lt;/code&gt; является то, что он не создает записей индекса для структур JSON, не содержащих никаких значений, таких как &lt;code&gt;{&quot;a&quot;: {}}&lt;/code&gt; . Если запрашивается поиск документов, содержащих такую ​​структуру, потребуется сканирование полного индекса, что довольно медленно. &lt;code&gt;jsonb_path_ops&lt;/code&gt; плохо подходит для приложений, которые часто выполняют такой поиск.</target>
        </trans-unit>
        <trans-unit id="436fb2bab58d12b2362059406a336206c3d00306" translate="yes" xml:space="preserve">
          <source>A discrete range is one whose element type has a well-defined &amp;ldquo;step&amp;rdquo;, such as &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;date&lt;/code&gt;. In these types two elements can be said to be adjacent, when there are no valid values between them. This contrasts with continuous ranges, where it's always (or almost always) possible to identify other element values between two given values. For example, a range over the &lt;code&gt;numeric&lt;/code&gt; type is continuous, as is a range over &lt;code&gt;timestamp&lt;/code&gt;. (Even though &lt;code&gt;timestamp&lt;/code&gt; has limited precision, and so could theoretically be treated as discrete, it's better to consider it continuous since the step size is normally not of interest.)</source>
          <target state="translated">Дискретный диапазон - это диапазон, тип элемента которого имеет четко определенный &amp;laquo;шаг&amp;raquo;, например &lt;code&gt;integer&lt;/code&gt; или &lt;code&gt;date&lt;/code&gt; . В этих типах два элемента можно назвать смежными, если между ними нет допустимых значений. Это контрастирует с непрерывными диапазонами, где всегда (или почти всегда) возможно идентифицировать другие значения элементов между двумя заданными значениями. Например, диапазон &lt;code&gt;numeric&lt;/code&gt; типа является непрерывным, как и диапазон &lt;code&gt;timestamp&lt;/code&gt; . (Несмотря на то, что &lt;code&gt;timestamp&lt;/code&gt; имеет ограниченную точность и теоретически может рассматриваться как дискретная, лучше считать ее непрерывной, поскольку размер шага обычно не представляет интереса.)</target>
        </trans-unit>
        <trans-unit id="a23c5cb9993deaf1311e315f3014f146e372868a" translate="yes" xml:space="preserve">
          <source>A discrete range type should have a &lt;em&gt;canonicalization&lt;/em&gt; function that is aware of the desired step size for the element type. The canonicalization function is charged with converting equivalent values of the range type to have identical representations, in particular consistently inclusive or exclusive bounds. If a canonicalization function is not specified, then ranges with different formatting will always be treated as unequal, even though they might represent the same set of values in reality.</source>
          <target state="translated">Тип дискретного диапазона должен иметь функцию &lt;em&gt;канонизации,&lt;/em&gt; которая знает желаемый размер шага для типа элемента. Функция канонизации отвечает за преобразование эквивалентных значений типа диапазона, чтобы иметь идентичные представления, в частности, последовательно включающие или исключающие границы. Если функция канонизации не указана, тогда диапазоны с различным форматированием всегда будут рассматриваться как неравные, даже если в действительности они могут представлять один и тот же набор значений.</target>
        </trans-unit>
        <trans-unit id="52cd489229e47470dc581e1d13cab54fdd7f5f6e" translate="yes" xml:space="preserve">
          <source>A dollar sign (&lt;code&gt;$&lt;/code&gt;) followed by digits is used to represent a positional parameter in the body of a function definition or a prepared statement. In other contexts the dollar sign can be part of an identifier or a dollar-quoted string constant.</source>
          <target state="translated">Знак доллара ( &lt;code&gt;$&lt;/code&gt; ), за которым следуют цифры, используется для представления позиционного параметра в теле определения функции или подготовленного оператора. В других контекстах знак доллара может быть частью идентификатора или строковой константы в кавычках.</target>
        </trans-unit>
        <trans-unit id="85726c6c75380e885546cdf31fee2dad70737f00" translate="yes" xml:space="preserve">
          <source>A dollar-quoted string that follows a keyword or identifier must be separated from it by whitespace; otherwise the dollar quoting delimiter would be taken as part of the preceding identifier.</source>
          <target state="translated">Строка в долларах,которая следует за ключевым словом или идентификатором,должна быть отделена от него пробелом;в противном случае разделитель в долларах будет принят как часть предыдущего идентификатора.</target>
        </trans-unit>
        <trans-unit id="483ea815eb464b44ff5ffec5d8ce0005d215accd" translate="yes" xml:space="preserve">
          <source>A duplicate is a leaf page tuple (a tuple that points to a table row) where &lt;em&gt;all&lt;/em&gt; indexed key columns have values that match corresponding column values from at least one other leaf page tuple in the same index. Duplicate tuples are quite common in practice. B-Tree indexes can use a special, space-efficient representation for duplicates when an optional technique is enabled: &lt;em&gt;deduplication&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee3f5330478a7b8687aa435c97bcf37602fa11b" translate="yes" xml:space="preserve">
          <source>A failure message indicating inability to bind to a port might indicate that that port is already in use by some non-PostgreSQL process. You might also get this error if you terminate &lt;code&gt;postgres&lt;/code&gt; and immediately restart it using the same port; in this case, you must simply wait a few seconds until the operating system closes the port before trying again. Finally, you might get this error if you specify a port number that your operating system considers to be reserved. For example, many versions of Unix consider port numbers under 1024 to be &amp;ldquo;trusted&amp;rdquo; and only permit the Unix superuser to access them.</source>
          <target state="translated">Сообщение об ошибке, указывающее на невозможность привязки к порту, может указывать на то, что этот порт уже используется каким-либо процессом, не связанным с PostgreSQL. Вы также можете получить эту ошибку, если завершите &lt;code&gt;postgres&lt;/code&gt; и немедленно перезапустите его, используя тот же порт; в этом случае вы должны просто подождать несколько секунд, пока операционная система не закроет порт, прежде чем повторить попытку. Наконец, вы можете получить эту ошибку, если укажете номер порта, который ваша операционная система считает зарезервированным. Например, многие версии Unix считают номера портов ниже 1024 &amp;laquo;доверенными&amp;raquo; и разрешают доступ к ним только суперпользователю Unix.</target>
        </trans-unit>
        <trans-unit id="6c9a12fdfac03387393cfa5d605bafff7741fcf8" translate="yes" xml:space="preserve">
          <source>A failure message mentioning &lt;code&gt;semget&lt;/code&gt; or &lt;code&gt;shmget&lt;/code&gt; probably indicates you need to configure your kernel to provide adequate shared memory and semaphores. For more discussion see &lt;a href=&quot;kernel-resources&quot;&gt;Section 18.4&lt;/a&gt;. You might be able to postpone reconfiguring your kernel by decreasing &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; to reduce the shared memory consumption of PostgreSQL, and/or by reducing &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; to reduce the semaphore consumption.</source>
          <target state="translated">Сообщение об &lt;code&gt;semget&lt;/code&gt; котором упоминаются semget или &lt;code&gt;shmget&lt;/code&gt; , вероятно, указывает на то, что вам необходимо настроить ядро ​​для обеспечения адекватной общей памяти и семафоров. Более подробное обсуждение см. В &lt;a href=&quot;kernel-resources&quot;&gt;Разделе 18.4&lt;/a&gt; . Вы можете отложить перенастройку ядра, уменьшив &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers,&lt;/a&gt; чтобы уменьшить потребление разделяемой памяти PostgreSQL, и / или уменьшив &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections,&lt;/a&gt; чтобы уменьшить потребление семафоров.</target>
        </trans-unit>
        <trans-unit id="6441f31b6574d318eb87a3d59abc87efb6583505" translate="yes" xml:space="preserve">
          <source>A failure message suggesting that another server is already running should be checked carefully, for example by using the command</source>
          <target state="translated">Сообщение о сбое,предполагающее,что другой сервер уже запущен,должно быть тщательно проверено,например,с помощью команды</target>
        </trans-unit>
        <trans-unit id="1d9edc129f87c5a3cfe93256806f12763480e5e4" translate="yes" xml:space="preserve">
          <source>A few of the catalogs are so fundamental that they can't even be created by the BKI &lt;code&gt;create&lt;/code&gt; command that's used for most catalogs, because that command needs to write information into these catalogs to describe the new catalog. These are called &lt;em&gt;bootstrap&lt;/em&gt; catalogs, and defining one takes a lot of extra work: you have to manually prepare appropriate entries for them in the pre-loaded contents of &lt;code&gt;pg_class&lt;/code&gt; and &lt;code&gt;pg_type&lt;/code&gt;, and those entries will need to be updated for subsequent changes to the catalog's structure. (Bootstrap catalogs also need pre-loaded entries in &lt;code&gt;pg_attribute&lt;/code&gt;, but fortunately &lt;code&gt;genbki.pl&lt;/code&gt; handles that chore nowadays.) Avoid making new catalogs be bootstrap catalogs if at all possible.</source>
          <target state="translated">Некоторые каталоги настолько фундаментальны, что их невозможно даже создать с помощью команды BKI &lt;code&gt;create&lt;/code&gt; , которая используется для большинства каталогов, потому что этой команде необходимо записывать информацию в эти каталоги для описания нового каталога. Они называются каталогами &lt;em&gt;начальной загрузки&lt;/em&gt; , и для их определения требуется много дополнительной работы: вам нужно вручную подготовить для них соответствующие записи в предварительно загруженном содержимом &lt;code&gt;pg_class&lt;/code&gt; и &lt;code&gt;pg_type&lt;/code&gt; , и эти записи необходимо будет обновить для последующих изменений в каталоге. структура. (Каталогам начальной загрузки также нужны предварительно загруженные записи в &lt;code&gt;pg_attribute&lt;/code&gt; , но, к счастью, &lt;code&gt;genbki.pl&lt;/code&gt; справляется с этой рутинной работой в настоящее время.) По возможности избегайте превращения новых каталогов в каталоги начальной загрузки.</target>
        </trans-unit>
        <trans-unit id="491372897d998156eaa18d8e18156aea1cce4b05" translate="yes" xml:space="preserve">
          <source>A field selection expression</source>
          <target state="translated">Выражение выбора поля</target>
        </trans-unit>
        <trans-unit id="7c39dad2086ca141110bdca18a2eda32e161292b" translate="yes" xml:space="preserve">
          <source>A file containing the major version number of PostgreSQL</source>
          <target state="translated">Файл,содержащий основной номер версии PostgreSQL</target>
        </trans-unit>
        <trans-unit id="6d87ef4157174eec7539a1a8a3467ba85faf286d" translate="yes" xml:space="preserve">
          <source>A file recording the command-line options the server was last started with</source>
          <target state="translated">Файл,записывающий параметры командной строки,с которой сервер был запущен в последний раз.</target>
        </trans-unit>
        <trans-unit id="329de4f43c6fb34276fdedd0bdd8b0f19adeca12" translate="yes" xml:space="preserve">
          <source>A file used for storing configuration parameters that are set by &lt;code&gt;ALTER SYSTEM&lt;/code&gt;</source>
          <target state="translated">Файл, используемый для хранения параметров конфигурации, установленных &lt;code&gt;ALTER SYSTEM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d60f29dfa94fb158cf5e58302f68dd9e477b3bca" translate="yes" xml:space="preserve">
          <source>A filtering dictionary can be placed anywhere in the list, except at the end where it'd be useless. Filtering dictionaries are useful to partially normalize words to simplify the task of later dictionaries. For example, a filtering dictionary could be used to remove accents from accented letters, as is done by the &lt;a href=&quot;unaccent&quot;&gt;unaccent&lt;/a&gt; module.</source>
          <target state="translated">Фильтрующий словарь можно разместить в любом месте списка, кроме конца, где он будет бесполезен. Словари с фильтрацией полезны для частичной нормализации слов, чтобы упростить задачу последующих словарей. Например, словарь фильтрации может использоваться для удаления акцентов с букв с ударением, как это делает модуль без &lt;a href=&quot;unaccent&quot;&gt;акцента&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61b8bbc2eb9fadf3683e04ebbb9e129815f5ed02" translate="yes" xml:space="preserve">
          <source>A final identifier type used by the system is &lt;code&gt;tid&lt;/code&gt;, or tuple identifier (row identifier). This is the data type of the system column &lt;code&gt;ctid&lt;/code&gt;. A tuple ID is a pair (block number, tuple index within block) that identifies the physical location of the row within its table.</source>
          <target state="translated">Последний тип идентификатора, используемый системой, - это &lt;code&gt;tid&lt;/code&gt; или идентификатор кортежа (идентификатор строки). Это тип данных системного столбца &lt;code&gt;ctid&lt;/code&gt; . Идентификатор кортежа - это пара (номер блока, индекс кортежа в блоке), которая определяет физическое расположение строки в ее таблице.</target>
        </trans-unit>
        <trans-unit id="9534174e684925e17ef91bf3e3714ca6759242b6" translate="yes" xml:space="preserve">
          <source>A fine point of the above example is that the &lt;code&gt;WITH&lt;/code&gt; clause is attached to the &lt;code&gt;INSERT&lt;/code&gt;, not the sub-&lt;code&gt;SELECT&lt;/code&gt; within the &lt;code&gt;INSERT&lt;/code&gt;. This is necessary because data-modifying statements are only allowed in &lt;code&gt;WITH&lt;/code&gt; clauses that are attached to the top-level statement. However, normal &lt;code&gt;WITH&lt;/code&gt; visibility rules apply, so it is possible to refer to the &lt;code&gt;WITH&lt;/code&gt; statement's output from the sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">Прекрасным моментом приведенного выше примера является то, что предложение &lt;code&gt;WITH&lt;/code&gt; присоединяется к &lt;code&gt;INSERT&lt;/code&gt; , а не к вложенному &lt;code&gt;SELECT&lt;/code&gt; внутри &lt;code&gt;INSERT&lt;/code&gt; . Это необходимо, поскольку операторы, изменяющие данные, разрешены только в предложениях &lt;code&gt;WITH&lt;/code&gt; , которые присоединены к оператору верхнего уровня. Однако применяются обычные правила видимости &lt;code&gt;WITH&lt;/code&gt; , поэтому можно ссылаться на вывод оператора &lt;code&gt;WITH&lt;/code&gt; из вложенного &lt;code&gt;SELECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d04dea72f91d057a2ddbc23d00826a2d1a1c915a" translate="yes" xml:space="preserve">
          <source>A first pass to build the index is done for each new index. Once the index is built, its flag &lt;code&gt;pg_index.indisready&lt;/code&gt; is switched to &amp;ldquo;true&amp;rdquo; to make it ready for inserts, making it visible to other sessions once the transaction that performed the build is finished. This step is done in a separate transaction for each index.</source>
          <target state="translated">Первый проход для построения индекса выполняется для каждого нового индекса. Как только индекс построен, его флаг &lt;code&gt;pg_index.indisready&lt;/code&gt; переключается на &amp;laquo;true&amp;raquo;, чтобы он был готов к вставкам, делая его видимым для других сеансов после завершения транзакции, которая выполнила построение. Этот шаг выполняется в отдельной транзакции для каждого индекса.</target>
        </trans-unit>
        <trans-unit id="a130458680bbe29e1418dce659480b6f78389bae" translate="yes" xml:space="preserve">
          <source>A foreign key can also constrain and reference a group of columns. As usual, it then needs to be written in table constraint form. Here is a contrived syntax example:</source>
          <target state="translated">Иностранный ключ также может ограничивать и ссылаться на группу колонок.Как обычно,он должен быть записан в форме ограничения таблицы.Вот нарисованный пример синтаксиса:</target>
        </trans-unit>
        <trans-unit id="7935e3b9aa49c2d43f16cbf75e1d409bba02665a" translate="yes" xml:space="preserve">
          <source>A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains the &lt;em&gt;referential integrity&lt;/em&gt; between two related tables.</source>
          <target state="translated">Ограничение внешнего ключа указывает, что значения в столбце (или группе столбцов) должны соответствовать значениям, появляющимся в некоторой строке другой таблицы. Мы говорим, что это поддерживает &lt;em&gt;ссылочную целостность&lt;/em&gt; между двумя связанными таблицами.</target>
        </trans-unit>
        <trans-unit id="dec7e4504b0a144e3a3d9b45cbf1480f1f8aba04" translate="yes" xml:space="preserve">
          <source>A foreign key must reference columns that either are a primary key or form a unique constraint. This means that the referenced columns always have an index (the one underlying the primary key or unique constraint); so checks on whether a referencing row has a match will be efficient. Since a &lt;code&gt;DELETE&lt;/code&gt; of a row from the referenced table or an &lt;code&gt;UPDATE&lt;/code&gt; of a referenced column will require a scan of the referencing table for rows matching the old value, it is often a good idea to index the referencing columns too. Because this is not always needed, and there are many choices available on how to index, declaration of a foreign key constraint does not automatically create an index on the referencing columns.</source>
          <target state="translated">Внешний ключ должен ссылаться на столбцы, которые либо являются первичным ключом, либо образуют уникальное ограничение. Это означает, что указанные столбцы всегда имеют индекс (тот, который лежит в основе первичного ключа или ограничения уникальности); поэтому проверка того, есть ли совпадение в ссылающейся строке, будет эффективной. Поскольку &lt;code&gt;DELETE&lt;/code&gt; строки из ссылочной таблицы или &lt;code&gt;UPDATE&lt;/code&gt; ссылочного столбца потребует сканирования ссылающейся таблицы на строки, соответствующие старому значению, часто рекомендуется также проиндексировать ссылающиеся столбцы. Поскольку это не всегда необходимо и существует много вариантов индексации, объявление ограничения внешнего ключа не создает автоматически индекс для ссылающихся столбцов.</target>
        </trans-unit>
        <trans-unit id="8ae80fcdea6bfacfb223ea7833eb93180e9021f3" translate="yes" xml:space="preserve">
          <source>A foreign server typically encapsulates connection information that a foreign-data wrapper uses to access an external data resource. Additional user-specific connection information may be specified by means of user mappings.</source>
          <target state="translated">Иностранный сервер обычно инкапсулирует информацию о соединении,которую иностранная обертка данных использует для доступа к внешнему ресурсу данных.Дополнительная информация о соединении,специфичная для пользователя,может быть определена с помощью пользовательских сопоставлений.</target>
        </trans-unit>
        <trans-unit id="9a9b5927e002630605d5343a34d0cf4f9f180fe0" translate="yes" xml:space="preserve">
          <source>A foreign server using the &lt;code&gt;postgres_fdw&lt;/code&gt; foreign data wrapper can have the same options that libpq accepts in connection strings, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;, except that these options are not allowed:</source>
          <target state="translated">Внешний сервер, использующий оболочку &lt;code&gt;postgres_fdw&lt;/code&gt; данных postgres_fdw, может иметь те же параметры, которые принимает libpq в строках подключения, как описано в &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Разделе 33.1.2&lt;/a&gt; , за исключением того, что эти параметры не разрешены:</target>
        </trans-unit>
        <trans-unit id="badba5a356d62e1cd053d7b73d8fe2b817602f47" translate="yes" xml:space="preserve">
          <source>A foreign server using the &lt;code&gt;postgres_fdw&lt;/code&gt; foreign data wrapper can have the same options that libpq accepts in connection strings, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;, except that these options are not allowed or have special handling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be8aee5fcb016100bb8dc793de4e631744baeb3" translate="yes" xml:space="preserve">
          <source>A foreign table created using this wrapper can have the following options:</source>
          <target state="translated">Иностранная таблица,созданная с помощью этой обертки,может иметь следующие опции:</target>
        </trans-unit>
        <trans-unit id="53f8f23c4cbab938356aea7eedc9b0a745c3d640" translate="yes" xml:space="preserve">
          <source>A foreign-data wrapper handler is declared to return &lt;code&gt;fdw_handler&lt;/code&gt;.</source>
          <target state="translated">Объявлен обработчик оболочки &lt;code&gt;fdw_handler&lt;/code&gt; возвращающий fdw_handler .</target>
        </trans-unit>
        <trans-unit id="3d69f8188280c90b11c42fae9d5a6f62a34fa828" translate="yes" xml:space="preserve">
          <source>A full list of &lt;code&gt;tsvector&lt;/code&gt;-related functions is available in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-TABLE&quot;&gt;Table 9.42&lt;/a&gt;.</source>
          <target state="translated">Полный список &lt;code&gt;tsvector&lt;/code&gt; связанных с tsvector , доступен в &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-TABLE&quot;&gt;Таблице 9.42&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65e83897f69ea1032a4c6125df7aec06ca7e6f69" translate="yes" xml:space="preserve">
          <source>A full time zone name, for example &lt;code&gt;America/New_York&lt;/code&gt;. The recognized time zone names are listed in the &lt;code&gt;pg_timezone_names&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-names&quot;&gt;Section 51.92&lt;/a&gt;). PostgreSQL uses the widely-used IANA time zone data for this purpose, so the same time zone names are also recognized by other software.</source>
          <target state="translated">Полное название часового пояса, например &lt;code&gt;America/New_York&lt;/code&gt; . &lt;code&gt;pg_timezone_names&lt;/code&gt; имена часовых поясов перечислены в представлении pg_timezone_names (см. &lt;a href=&quot;view-pg-timezone-names&quot;&gt;Раздел 51.92&lt;/a&gt; ). PostgreSQL использует для этой цели широко используемые данные часовых поясов IANA, поэтому те же имена часовых поясов распознаются и другим программным обеспечением.</target>
        </trans-unit>
        <trans-unit id="ca3257c97b3a14d468e354dcf32c96f8c18bebc4" translate="yes" xml:space="preserve">
          <source>A function call</source>
          <target state="translated">Вызов функции</target>
        </trans-unit>
        <trans-unit id="29b8eafb6b7c2b2b298c30410ef6e0e704d3c56b" translate="yes" xml:space="preserve">
          <source>A function can be represented by its &lt;code&gt;proname&lt;/code&gt;, if that is unique among the &lt;code&gt;pg_proc.dat&lt;/code&gt; entries (this works like regproc input). Otherwise, write it as &lt;code&gt;proname(argtypename,argtypename,...)&lt;/code&gt;, like regprocedure. The argument type names must be spelled exactly as they are in the &lt;code&gt;pg_proc.dat&lt;/code&gt; entry's &lt;code&gt;proargtypes&lt;/code&gt; field. Do not insert any spaces.</source>
          <target state="translated">Функция может быть представлена его &lt;code&gt;proname&lt;/code&gt; , если это является уникальным среди &lt;code&gt;pg_proc.dat&lt;/code&gt; записей (это работает как вход regproc). В противном случае напишите его как &lt;code&gt;proname(argtypename,argtypename,...)&lt;/code&gt; , например regprocedure. Имена типов аргументов должны быть написаны точно так же, как они указаны в поле &lt;code&gt;pg_proc.dat&lt;/code&gt; записи &lt;code&gt;proargtypes&lt;/code&gt; . Не вставляйте пробелы.</target>
        </trans-unit>
        <trans-unit id="665c5d40faa1c27c6639ca8ba23f82787f2ca582" translate="yes" xml:space="preserve">
          <source>A function that takes a single argument of composite type can optionally be called using field-selection syntax, and conversely field selection can be written in functional style. That is, the notations &lt;code&gt;col(table)&lt;/code&gt; and &lt;code&gt;table.col&lt;/code&gt; are interchangeable. This behavior is not SQL-standard but is provided in PostgreSQL because it allows use of functions to emulate &amp;ldquo;computed fields&amp;rdquo;. For more information see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;.</source>
          <target state="translated">Функция, которая принимает единственный аргумент составного типа, может быть дополнительно вызвана с использованием синтаксиса выбора поля, и, наоборот, выбор поля может быть написан в функциональном стиле. То есть обозначения &lt;code&gt;col(table)&lt;/code&gt; и &lt;code&gt;table.col&lt;/code&gt; взаимозаменяемы. Это поведение не является стандартом SQL, но предоставляется в PostgreSQL, поскольку оно позволяет использовать функции для имитации &amp;laquo;вычисляемых полей&amp;raquo;. Для получения дополнительной информации см. &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Раздел 8.16.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f8fec4e5b8f079531cd32a009d627206c65e10" translate="yes" xml:space="preserve">
          <source>A generated column cannot be part of a partition key.</source>
          <target state="translated">Сгенерированный столбец не может быть частью ключа простенка.</target>
        </trans-unit>
        <trans-unit id="e0ac9eba09cfa3c9dbd2d45d33c0ab9b56aec7dc" translate="yes" xml:space="preserve">
          <source>A generated column cannot be written to directly. In &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands, a value cannot be specified for a generated column, but the keyword &lt;code&gt;DEFAULT&lt;/code&gt; may be specified.</source>
          <target state="translated">В сгенерированный столбец нельзя записать напрямую. В командах &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; нельзя указать значение для сгенерированного столбца, но можно указать ключевое слово &lt;code&gt;DEFAULT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a974e7fa8fff8257dce1404630bd9e17704afbe0" translate="yes" xml:space="preserve">
          <source>A generated column cannot have a column default or an identity definition.</source>
          <target state="translated">Генерируемый столбец не может иметь колонку по умолчанию или определение идентичности.</target>
        </trans-unit>
        <trans-unit id="1dbf7e263f1354b2b93387f1bfe3cc26e77a333d" translate="yes" xml:space="preserve">
          <source>A generated column is a special column that is always computed from other columns. Thus, it is for columns what a view is for tables. There are two kinds of generated columns: stored and virtual. A stored generated column is computed when it is written (inserted or updated) and occupies storage as if it were a normal column. A virtual generated column occupies no storage and is computed when it is read. Thus, a virtual generated column is similar to a view and a stored generated column is similar to a materialized view (except that it is always updated automatically). PostgreSQL currently implements only stored generated columns.</source>
          <target state="translated">Генерируемый столбец-это специальный столбец,который всегда вычисляется из других столбцов.Таким образом,именно для столбцов создается представление для таблиц.Существует два вида генерируемых столбцов:хранимый и виртуальный.Хранимый сгенерированный столбец вычисляется,когда он записывается (вставляется или обновляется)и занимает хранение,как если бы это был обычный столбец.Виртуальный сгенерированный столбец не занимает хранения и вычисляется при чтении.Таким образом,виртуальный сгенерированный столбец похож на представление,а сохраненный сгенерированный столбец похож на материализованное представление (за исключением того,что он всегда обновляется автоматически).PostgreSQL в настоящее время реализует только сохраненные сгенерированные столбцы.</target>
        </trans-unit>
        <trans-unit id="be4467cb35124e2c3c1d0bf937b508ea68a8aa1a" translate="yes" xml:space="preserve">
          <source>A generation expression cannot reference a system column, except &lt;code&gt;tableoid&lt;/code&gt;.</source>
          <target state="translated">Выражение генерации не может ссылаться на системный столбец, кроме &lt;code&gt;tableoid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e7a5a9dc2e173ff254950537b52dfc433ffc740" translate="yes" xml:space="preserve">
          <source>A generation expression cannot reference another generated column.</source>
          <target state="translated">Выражение генерации не может ссылаться на другой сгенерированный столбец.</target>
        </trans-unit>
        <trans-unit id="cddf5b488fdbb3769abd336844e34805f857556c" translate="yes" xml:space="preserve">
          <source>A group of backend and auxiliary processes that communicate using a common shared memory area. One &lt;a href=&quot;glossary#GLOSSARY-POSTMASTER&quot;&gt;postmaster process&lt;/a&gt; manages the instance; one instance manages exactly one &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; with all its databases. Many instances can run on the same &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; as long as their TCP ports do not conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5204280cf84852f809b22497f5b5b7223747d56b" translate="yes" xml:space="preserve">
          <source>A heap page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. For example:</source>
          <target state="translated">Изображение страницы кучи, полученное с помощью &lt;code&gt;get_raw_page&lt;/code&gt; , должно быть передано в качестве аргумента. Например:</target>
        </trans-unit>
        <trans-unit id="852fc3cf5ee76f5f80b4e90d90cfd5ea3f69f788" translate="yes" xml:space="preserve">
          <source>A helpful trick for testing queries when you are not certain if they might loop is to place a &lt;code&gt;LIMIT&lt;/code&gt; in the parent query. For example, this query would loop forever without the &lt;code&gt;LIMIT&lt;/code&gt;:</source>
          <target state="translated">Полезный прием для тестирования запросов, когда вы не уверены, могут ли они зацикливаться, - это поместить &lt;code&gt;LIMIT&lt;/code&gt; в родительский запрос. Например, без &lt;code&gt;LIMIT&lt;/code&gt; этот запрос будет повторяться бесконечно :</target>
        </trans-unit>
        <trans-unit id="83afefe0fbb71aaede7acaeb0c43f98d93c15f12" translate="yes" xml:space="preserve">
          <source>A high schedule lag time is an indication that the system cannot process transactions at the specified rate, with the chosen number of clients and threads. When the average transaction execution time is longer than the scheduled interval between each transaction, each successive transaction will fall further behind, and the schedule lag time will keep increasing the longer the test run is. When that happens, you will have to reduce the specified transaction rate.</source>
          <target state="translated">Высокое время запаздывания графика является признаком того,что система не может обрабатывать транзакции с заданной скоростью,с выбранным количеством клиентов и потоков.Когда среднее время выполнения транзакции превышает запланированный интервал между каждой транзакцией,каждая последующая транзакция будет отставать еще больше,а время задержки по расписанию будет продолжать увеличиваться,чем дольше длится выполнение теста.Когда это произойдет,вам придется снизить указанную скорость выполнения транзакций.</target>
        </trans-unit>
        <trans-unit id="61cac6a1eeedd7da0737519022c8bf6afc564b8b" translate="yes" xml:space="preserve">
          <source>A histogram of the counts of distinct non-null element values within the values of the column, followed by the average number of distinct non-null elements. (Null for scalar types.)</source>
          <target state="translated">Гистограмма подсчета значений отдельных ненулевых элементов в пределах значений столбца,за которой следует среднее количество отдельных ненулевых элементов.(Нуль для скалярных типов.)</target>
        </trans-unit>
        <trans-unit id="e17cd8aa619245cf1ec3d376e7b36d9afdaa66d4" translate="yes" xml:space="preserve">
          <source>A host name specification that starts with a dot (&lt;code&gt;.&lt;/code&gt;) matches a suffix of the actual host name. So &lt;code&gt;.example.com&lt;/code&gt; would match &lt;code&gt;foo.example.com&lt;/code&gt; (but not just &lt;code&gt;example.com&lt;/code&gt;).</source>
          <target state="translated">Спецификация имени хоста, начинающаяся с точки ( &lt;code&gt;.&lt;/code&gt; ), Соответствует суффиксу фактического имени хоста. Таким образом, &lt;code&gt;.example.com&lt;/code&gt; будет соответствовать &lt;code&gt;foo.example.com&lt;/code&gt; (но не только &lt;code&gt;example.com&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="16a83f51a8f292b8e135eff3bc4b49e6a7b0c8c1" translate="yes" xml:space="preserve">
          <source>A joined table is a table derived from two other (real or derived) tables according to the rules of the particular join type. Inner, outer, and cross-joins are available. The general syntax of a joined table is</source>
          <target state="translated">Объединяемая таблица-это таблица,производная от двух других (вещественных или производных)таблиц в соответствии с правилами конкретного типа соединения.Имеются внутренние,внешние и поперечные соединения.Общий синтаксис объединённой таблицы -</target>
        </trans-unit>
        <trans-unit id="c38978f6d39cb114e0bbdd4555f08d4137a6d679" translate="yes" xml:space="preserve">
          <source>A key feature of psql variables is that you can substitute (&amp;ldquo;interpolate&amp;rdquo;) them into regular SQL statements, as well as the arguments of meta-commands. Furthermore, psql provides facilities for ensuring that variable values used as SQL literals and identifiers are properly quoted. The syntax for interpolating a value without any quoting is to prepend the variable name with a colon (&lt;code&gt;:&lt;/code&gt;). For example,</source>
          <target state="translated">Ключевой особенностью переменных psql является то, что вы можете заменять (&amp;laquo;интерполировать&amp;raquo;) их в обычные операторы SQL, а также в аргументы метакоманд. Кроме того, psql предоставляет средства для обеспечения правильного цитирования значений переменных, используемых в качестве литералов и идентификаторов SQL. Синтаксис для интерполирования значения без какого - либо со ссылкой на это предварять имя переменного с двоеточием ( &lt;code&gt;:&lt;/code&gt; ). Например,</target>
        </trans-unit>
        <trans-unit id="82961127c30e9d99b0606fff4408183ed9cb0961" translate="yes" xml:space="preserve">
          <source>A key property of &lt;code&gt;WITH&lt;/code&gt; queries is that they are normally evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to be executed once and only once, regardless of whether the primary query reads all or any of their output.</source>
          <target state="translated">Ключевым свойством запросов &lt;code&gt;WITH&lt;/code&gt; является то, что они обычно оцениваются только один раз за выполнение первичного запроса, даже если первичный запрос обращается к ним более одного раза. В частности, операторы, изменяющие данные, гарантированно будут выполнены один и только один раз, независимо от того, читает ли основной запрос все или часть их вывода.</target>
        </trans-unit>
        <trans-unit id="61ba864342105e7de2a1c4f77ad3ea649ab3dd8e" translate="yes" xml:space="preserve">
          <source>A larger setting would be appropriate if other programs on the machine also need huge pages. Don't forget to add this setting to &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; so that it will be reapplied after reboots.</source>
          <target state="translated">Если другим программам на машине также нужны огромные страницы, подойдет установка большего размера. Не забудьте добавить этот параметр в &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; , чтобы он применялся повторно после перезагрузки.</target>
        </trans-unit>
        <trans-unit id="740fc98f7710c6fce519cc7ddb08e68b536ff0d4" translate="yes" xml:space="preserve">
          <source>A less-oversimplified example of a &lt;code&gt;subtype_diff&lt;/code&gt; function is:</source>
          <target state="translated">Менее упрощенный пример функции &lt;code&gt;subtype_diff&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="15b979d3d44d76b40d5152f1d019597a03929970" translate="yes" xml:space="preserve">
          <source>A limitation of pgbench is that it can itself become the bottleneck when trying to test a large number of client sessions. This can be alleviated by running pgbench on a different machine from the database server, although low network latency will be essential. It might even be useful to run several pgbench instances concurrently, on several client machines, against the same database server.</source>
          <target state="translated">Ограничением pgbench является то,что он может сам стать узким местом при попытке тестирования большого количества клиентских сессий.Этого можно избежать,запустив pgbench на другой машине,отличной от сервера баз данных,хотя низкая сетевая задержка будет существенной.Может быть даже полезно запустить несколько экземпляров pgbench одновременно на нескольких клиентских машинах на одном сервере баз данных.</target>
        </trans-unit>
        <trans-unit id="ab2d89a97d20a5efbc73683817ba2ff464b9a103" translate="yes" xml:space="preserve">
          <source>A limitation of these built-in triggers is that they treat all the input columns alike. To process columns differently &amp;mdash; for example, to weight title differently from body &amp;mdash; it is necessary to write a custom trigger. Here is an example using PL/pgSQL as the trigger language:</source>
          <target state="translated">Ограничением этих встроенных триггеров является то, что они одинаково обрабатывают все входные столбцы. Чтобы по-разному обрабатывать столбцы - например, чтобы присвоить вес заголовку и тексту, - необходимо написать собственный триггер. Вот пример использования PL / pgSQL в качестве языка триггеров:</target>
        </trans-unit>
        <trans-unit id="f76857de86cd4afe434d4b21d9313477ab29ebe7" translate="yes" xml:space="preserve">
          <source>A limitation of this feature is that an &lt;code&gt;ORDER BY&lt;/code&gt; clause applying to the result of a &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, or &lt;code&gt;EXCEPT&lt;/code&gt; clause can only specify an output column name or number, not an expression.</source>
          <target state="translated">Ограничением этой функции является то, что предложение &lt;code&gt;ORDER BY&lt;/code&gt; , применяемое к результату предложения &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; или &lt;code&gt;EXCEPT&lt;/code&gt; , может указывать только имя или номер выходного столбца, но не выражение.</target>
        </trans-unit>
        <trans-unit id="6e332e0f99b25d5ac06d1f211aa0eb2e56e7af5e" translate="yes" xml:space="preserve">
          <source>A list of NULL flags for the most common combinations of values. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">Список флагов NULL для наиболее распространенных комбинаций значений. (Нулевое значение, если значение &lt;code&gt;most_common_vals&lt;/code&gt; равно.)</target>
        </trans-unit>
        <trans-unit id="faedcc532ba9e80276afc21b0d135826be8f1422" translate="yes" xml:space="preserve">
          <source>A list of non-null element values most often appearing within values of the column. (Null for scalar types.)</source>
          <target state="translated">Список значений ненулевых элементов,наиболее часто встречающихся внутри значений колонки.(Нуль для скалярных типов.)</target>
        </trans-unit>
        <trans-unit id="9222c144bac210ee75eb7f8e023e5b70c063c9b1" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and the update expressions. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement. Note that the target table must not appear in the &lt;code&gt;from_list&lt;/code&gt;, unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_list&lt;/code&gt;).</source>
          <target state="translated">Список табличных выражений, позволяющий столбцам из других таблиц появляться в условии &lt;code&gt;WHERE&lt;/code&gt; и выражениях обновления. Это похоже на список таблиц , которые могут быть указаны в &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; п&lt;/a&gt; о в &lt;code&gt;SELECT&lt;/code&gt; , заявление. Обратите внимание, что целевая таблица не должна появляться в &lt;code&gt;from_list&lt;/code&gt; , если только вы не планируете самостоятельное соединение (в этом случае она должна отображаться с псевдонимом в &lt;code&gt;from_list&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a5ec616bf7215f2b568c6fa91ae40cb63c46d2ff" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table in the &lt;code&gt;using_list&lt;/code&gt;, unless you wish to set up a self-join.</source>
          <target state="translated">Список табличных выражений, позволяющий столбцам из других таблиц появляться в условии &lt;code&gt;WHERE&lt;/code&gt; . Это похоже на список таблиц , которые могут быть указаны в &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; п&lt;/a&gt; о в &lt;code&gt;SELECT&lt;/code&gt; , заявление; например, можно указать псевдоним для имени таблицы. Не повторяйте целевую таблицу в &lt;code&gt;using_list&lt;/code&gt; , если вы не хотите настроить самостоятельное соединение.</target>
        </trans-unit>
        <trans-unit id="4a9f5b6a7fa98f13d9b0649d9b104ce5e824c915" translate="yes" xml:space="preserve">
          <source>A list of the base frequencies of the most common combinations, i.e., product of per-value frequencies. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">Список базовых частот наиболее распространенных комбинаций, т. Е. Произведение частот на значение. (Нулевое значение, если значение &lt;code&gt;most_common_vals&lt;/code&gt; равно.)</target>
        </trans-unit>
        <trans-unit id="c0a9903e8f4ef251af0eff5fa2455e175a7548a4" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common combinations, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">Список частот наиболее распространенных комбинаций, то есть количество вхождений каждой, деленное на общее количество строк. (Нулевое значение, если значение &lt;code&gt;most_common_vals&lt;/code&gt; равно.)</target>
        </trans-unit>
        <trans-unit id="527238c1ce219277abbb45386e199364181b4e39" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common element values, i.e., the fraction of rows containing at least one instance of the given value. Two or three additional values follow the per-element frequencies; these are the minimum and maximum of the preceding per-element frequencies, and optionally the frequency of null elements. (Null when &lt;code&gt;most_common_elems&lt;/code&gt; is.)</source>
          <target state="translated">Список частот наиболее общих значений элементов, т. Е. Доля строк, содержащих хотя бы один экземпляр данного значения. Два или три дополнительных значения следуют за частотами каждого элемента; это минимум и максимум предшествующих частот для каждого элемента и, необязательно, частота нулевых элементов. (Нулевое значение, если значение &lt;code&gt;most_common_elems&lt;/code&gt; равно.)</target>
        </trans-unit>
        <trans-unit id="6973fe18397e6786beffdd562ca0c447ef38be82" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common values, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">Список частот наиболее распространенных значений, т. Е. Количество вхождений каждого, деленное на общее количество строк. (Нулевое значение, если значение &lt;code&gt;most_common_vals&lt;/code&gt; равно.)</target>
        </trans-unit>
        <trans-unit id="f63bcd58b43a4c5b783b6642ba5709e3ccbcb180" translate="yes" xml:space="preserve">
          <source>A list of the most common combinations of values in the columns. (Null if no combinations seem to be more common than any others.)</source>
          <target state="translated">Список наиболее распространенных комбинаций значений в столбцах.(Нуль,если ни одна из комбинаций не кажется более распространенной,чем любая другая).</target>
        </trans-unit>
        <trans-unit id="7e7a21f80a86cbb3d663d9a6c19c5698cb32c935" translate="yes" xml:space="preserve">
          <source>A list of the most common values in the column. (Null if no values seem to be more common than any others.)</source>
          <target state="translated">Список наиболее распространенных значений в столбце.(Нуль,если ни одно из значений не кажется более распространенным,чем другие).</target>
        </trans-unit>
        <trans-unit id="f5ec309be4a2c82919d5db6bbf83466f9afb0124" translate="yes" xml:space="preserve">
          <source>A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt;, this means a list of command tags (e.g. &lt;code&gt;'DROP FUNCTION'&lt;/code&gt;).</source>
          <target state="translated">Список значений связанной &lt;code&gt;filter_variable&lt;/code&gt; для которой должен срабатывать триггер. Для &lt;code&gt;TAG&lt;/code&gt; это означает список командных тегов (например, &lt;code&gt;'DROP FUNCTION'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ff968df28749e5bcff327cac21b38ab15e60f682" translate="yes" xml:space="preserve">
          <source>A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt;, this means a list of command tags (e.g., &lt;code&gt;'DROP FUNCTION'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4fe90764276ed140f41c638b69ba17b32d691f" translate="yes" xml:space="preserve">
          <source>A list of values that divide the column's values into groups of approximately equal population. The values in &lt;code&gt;most_common_vals&lt;/code&gt;, if present, are omitted from this histogram calculation. (This column is null if the column data type does not have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator or if the &lt;code&gt;most_common_vals&lt;/code&gt; list accounts for the entire population.)</source>
          <target state="translated">Список значений, которые делят значения столбца на группы примерно равной совокупности. Значения в &lt;code&gt;most_common_vals&lt;/code&gt; , если они есть, не учитываются при вычислении гистограммы. (Этот столбец имеет значение NULL, если тип данных столбца не имеет оператора &lt;code&gt;&amp;lt;&lt;/code&gt; или если список &lt;code&gt;most_common_vals&lt;/code&gt; учитывает всю совокупность.)</target>
        </trans-unit>
        <trans-unit id="ed9c3dd9d41fb7cb75cda90adbcd956a0d568298" translate="yes" xml:space="preserve">
          <source>A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (could be empty), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt;, or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40d49086dbccf43760fcf28e8592fb7682d6120" translate="yes" xml:space="preserve">
          <source>A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (empty on Windows), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt;, or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</source>
          <target state="translated">Файл блокировки, в котором записывается текущий идентификатор процесса postmaster (PID), путь к каталогу данных кластера, метка времени начала postmaster, номер порта, путь к каталогу сокета домена Unix (пусто в Windows), первый допустимый listen_address (IP-адрес или &lt;code&gt;*&lt;/code&gt; , или пустой, если нет прослушивание TCP) и идентификатор сегмента общей памяти (этот файл отсутствует после завершения работы сервера)</target>
        </trans-unit>
        <trans-unit id="66a4816dba1f7f218c3433fca4faabe3c13b10b2" translate="yes" xml:space="preserve">
          <source>A logical replication subscription can be a standby for synchronous replication (see &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;). The standby name is by default the subscription name. An alternative name can be specified as &lt;code&gt;application_name&lt;/code&gt; in the connection information of the subscription.</source>
          <target state="translated">Подписка на логическую репликацию может быть резервной для синхронной репликации (см. &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Подраздел 26.2.8&lt;/a&gt; ). Имя режима ожидания по умолчанию является именем подписки. Альтернативное имя может быть указано как &lt;code&gt;application_name&lt;/code&gt; в информации о подключении подписки.</target>
        </trans-unit>
        <trans-unit id="fcc633543c398580321199fbfe8326677176cedc" translate="yes" xml:space="preserve">
          <source>A logical replication worker will be started to replicate data for the new subscription at the commit of the transaction where this command is run.</source>
          <target state="translated">Логический работник репликации начнет реплицировать данные для новой подписки при фиксации транзакции,в которой выполняется эта команда.</target>
        </trans-unit>
        <trans-unit id="0ff838ef761258a1112513121456f0155f8255d4" translate="yes" xml:space="preserve">
          <source>A low-level description of an individual data change. It contains sufficient information for the data change to be re-executed (&lt;em&gt;replayed&lt;/em&gt;) in case a system failure causes the change to be lost. WAL records use a non-printable binary format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60aa88a1c8ef8747220ad187c41c4e1174fc8b76" translate="yes" xml:space="preserve">
          <source>A master-standby replication setup sends all data modification queries to the master server. The master server asynchronously sends data changes to the standby server. The standby can answer read-only queries while the master server is running. The standby server is ideal for data warehouse queries.</source>
          <target state="translated">Настройка репликации в режиме &quot;мастер-резервный&quot; посылает все запросы на модификацию данных на мастер-сервер.Мастер-сервер асинхронно посылает изменения данных на резервный сервер.Резервный сервер может отвечать на запросы только для чтения во время работы ведущего сервера.Резервный сервер идеально подходит для запросов к хранилищу данных.</target>
        </trans-unit>
        <trans-unit id="bb03b0cc86a8c8af01abf7c3fc42f075822f31ef" translate="yes" xml:space="preserve">
          <source>A means of identifying a &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;row&lt;/a&gt; within a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; by values contained within one or more &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; in that relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030845a8e99966136eb3e489c254a79843ff0977" translate="yes" xml:space="preserve">
          <source>A means of representing data that is not contained in the local &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; so that it appears as if were in local &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table(s)&lt;/a&gt;. With a foreign data wrapper it is possible to define a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-SERVER&quot;&gt;foreign server&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5439dc35c023b011f3a3c74704c816d5906e3290" translate="yes" xml:space="preserve">
          <source>A means of restricting data in one &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; by a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-KEY&quot;&gt;foreign key&lt;/a&gt; so that it must have matching data in another &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a6939174ae7d3834abe5ab38f570dcd2acae81" translate="yes" xml:space="preserve">
          <source>A mechanism by which large attributes of table rows are split and stored in a secondary table, called the &lt;em&gt;TOAST table&lt;/em&gt;. Each relation with large attributes has its own TOAST table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0378f878c1722be034fadd027bbbb3d7983fc4d" translate="yes" xml:space="preserve">
          <source>A mechanism designed to allow several &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transactions&lt;/a&gt; to be reading and writing the same rows without one process causing other processes to stall. In PostgreSQL, MVCC is implemented by creating copies (&lt;em&gt;versions&lt;/em&gt;) of &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuples&lt;/a&gt; as they are modified; after transactions that can see the old versions terminate, those old versions need to be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c544cc7b4fa2f30c5d33aa71e0de0990d629df" translate="yes" xml:space="preserve">
          <source>A mechanism that allows a process to limit or prevent simultaneous access to a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6419859ed47f78b720bf1d7b110d267f1953f4" translate="yes" xml:space="preserve">
          <source>A message like:</source>
          <target state="translated">Сообщение вроде:</target>
        </trans-unit>
        <trans-unit id="917ffeb96cdfecb3f8736cd3bea86dd56c48ad27" translate="yes" xml:space="preserve">
          <source>A minimal sequence for creating a new procedural language is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0390b8c07f298b04ffb62c09de627ab67ceed13" translate="yes" xml:space="preserve">
          <source>A modified version of shared hardware functionality is file system replication, where all changes to a file system are mirrored to a file system residing on another computer. The only restriction is that the mirroring must be done in a way that ensures the standby server has a consistent copy of the file system &amp;mdash; specifically, writes to the standby must be done in the same order as those on the master. DRBD is a popular file system replication solution for Linux.</source>
          <target state="translated">Модифицированная версия общих аппаратных функций - это репликация файловой системы, при которой все изменения в файловой системе отражаются в файловой системе, находящейся на другом компьютере. Единственное ограничение состоит в том, что зеркальное отображение должно выполняться таким образом, чтобы резервный сервер имел согласованную копию файловой системы - в частности, запись в резервный сервер должна выполняться в том же порядке, что и на главном. DRBD - популярное решение для репликации файловой системы для Linux.</target>
        </trans-unit>
        <trans-unit id="eaf74e8b7bd2011db8b23c31e08c4d8c5dc7b496" translate="yes" xml:space="preserve">
          <source>A more complete example, which is directly useful for most European languages, can be found in &lt;code&gt;unaccent.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; when the &lt;code&gt;unaccent&lt;/code&gt; module is installed. This rules file translates characters with accents to the same characters without accents, and it also expands ligatures into the equivalent series of simple characters (for example, &amp;AElig; to AE).</source>
          <target state="translated">Более полный пример, который является непосредственно полезным для большинства европейских языков, можно найти в &lt;code&gt;unaccent.rules&lt;/code&gt; , который установлен в &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; когда &lt;code&gt;unaccent&lt;/code&gt; установлен модуль. Этот файл правил переводит символы с диакритическими знаками в те же символы без диакритических знаков, а также расширяет лигатуры до эквивалентной серии простых символов (например, &amp;AElig; в AE).</target>
        </trans-unit>
        <trans-unit id="e62513d51117a7629a102ebbc4e62bd57c604e14" translate="yes" xml:space="preserve">
          <source>A more complex example is to select the ten most recent documents that contain &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;table&lt;/code&gt; in the &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt;:</source>
          <target state="translated">Более сложный пример - выбрать десять самых последних документов, которые содержат &lt;code&gt;create&lt;/code&gt; и &lt;code&gt;table&lt;/code&gt; в &lt;code&gt;title&lt;/code&gt; или &lt;code&gt;body&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a65faa0d2e1360aa9fc34743f49ee685ce803abe" translate="yes" xml:space="preserve">
          <source>A more complex view that does not satisfy all these conditions is read-only by default: the system will not allow an insert, update, or delete on the view. You can get the effect of an updatable view by creating &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers on the view, which must convert attempted inserts, etc. on the view into appropriate actions on other tables. For more information see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;. Another possibility is to create rules (see &lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULE&lt;/a&gt;), but in practice triggers are easier to understand and use correctly.</source>
          <target state="translated">Более сложное представление, которое не удовлетворяет всем этим условиям, по умолчанию доступно только для чтения: система не разрешает вставку, обновление или удаление представления. Вы можете получить эффект обновляемого представления, создав триггеры &lt;code&gt;INSTEAD OF&lt;/code&gt; в представлении, которые должны преобразовывать попытки вставки и т. Д. В представлении в соответствующие действия в других таблицах. Для получения дополнительной информации см. &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; . Другая возможность - создавать правила (см. &lt;a href=&quot;sql-createrule&quot;&gt;СОЗДАТЬ ПРАВИЛО&lt;/a&gt; ), но на практике триггеры легче понять и правильно использовать.</target>
        </trans-unit>
        <trans-unit id="21c69ec8617bd0a23e27b4a22f876578e2ac2724" translate="yes" xml:space="preserve">
          <source>A multicharacter operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">Имя многосимвольного оператора не может заканчиваться на &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; , если имя также не содержит хотя бы один из этих символов:</target>
        </trans-unit>
        <trans-unit id="763ddc64feb8cdfed8680a02b945f082cacaa6b2" translate="yes" xml:space="preserve">
          <source>A multicolumn B-tree index can be used with query conditions that involve any subset of the index's columns, but the index is most efficient when there are constraints on the leading (leftmost) columns. The exact rule is that equality constraints on leading columns, plus any inequality constraints on the first column that does not have an equality constraint, will be used to limit the portion of the index that is scanned. Constraints on columns to the right of these columns are checked in the index, so they save visits to the table proper, but they do not reduce the portion of the index that has to be scanned. For example, given an index on &lt;code&gt;(a, b, c)&lt;/code&gt; and a query condition &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt;, the index would have to be scanned from the first entry with &lt;code&gt;a&lt;/code&gt; = 5 and &lt;code&gt;b&lt;/code&gt; = 42 up through the last entry with &lt;code&gt;a&lt;/code&gt; = 5. Index entries with &lt;code&gt;c&lt;/code&gt; &amp;gt;= 77 would be skipped, but they'd still have to be scanned through. This index could in principle be used for queries that have constraints on &lt;code&gt;b&lt;/code&gt; and/or &lt;code&gt;c&lt;/code&gt; with no constraint on &lt;code&gt;a&lt;/code&gt; &amp;mdash; but the entire index would have to be scanned, so in most cases the planner would prefer a sequential table scan over using the index.</source>
          <target state="translated">Многоколоночный индекс в виде B-дерева можно использовать с условиями запроса, которые включают любое подмножество столбцов индекса, но индекс наиболее эффективен, когда есть ограничения на ведущие (крайние левые) столбцы. Точное правило заключается в том, что ограничения равенства для ведущих столбцов плюс любые ограничения неравенства для первого столбца, не имеющего ограничения равенства, будут использоваться для ограничения части сканируемого индекса. Ограничения для столбцов справа от этих столбцов проверяются в индексе, поэтому они сохраняют посещения самой таблицы, но не уменьшают часть индекса, которую необходимо просканировать. Например, если индекс на &lt;code&gt;(a, b, c)&lt;/code&gt; и условие запроса , &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt; , индекс должен был бы быть отсканированы с первой записи с &lt;code&gt;a&lt;/code&gt; = 5 и &lt;code&gt;b&lt;/code&gt; = 42 до последней записи с &lt;code&gt;a&lt;/code&gt; = 5. Записи индекса с &lt;code&gt;c&lt;/code&gt; &amp;gt; = 77 будут пропущены, но их все равно придется сканировать. Этот индекс в принципе можно использовать для запросов, которые имеют ограничения на &lt;code&gt;b&lt;/code&gt; и / или &lt;code&gt;c&lt;/code&gt; без ограничения на &lt;code&gt;a&lt;/code&gt; , но весь индекс должен быть просканирован, поэтому в большинстве случаев планировщик предпочтет последовательное сканирование таблицы, а не использование индекса .</target>
        </trans-unit>
        <trans-unit id="5fc5434281e629991ee555ca6201f316515a8d25" translate="yes" xml:space="preserve">
          <source>A multicolumn BRIN index can be used with query conditions that involve any subset of the index's columns. Like GIN and unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use. The only reason to have multiple BRIN indexes instead of one multicolumn BRIN index on a single table is to have a different &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter.</source>
          <target state="translated">Многоколоночный индекс BRIN можно использовать с условиями запроса, которые включают любое подмножество столбцов индекса. Подобно GIN и в отличие от B-дерева или GiST, эффективность поиска по индексу одинакова, независимо от того, какие столбцы индекса используются в условиях запроса. Единственная причина иметь несколько индексов BRIN вместо одного многоколоночного индекса BRIN в одной таблице - это иметь другой параметр хранения &lt;code&gt;pages_per_range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04d3a962116670f39174cfb6d475fa11fdc7b880" translate="yes" xml:space="preserve">
          <source>A multicolumn GIN index can be used with query conditions that involve any subset of the index's columns. Unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use.</source>
          <target state="translated">Многоколоночный GIN-индекс может использоваться с условиями запроса,включающими любое подмножество столбцов индекса.В отличие от B-дерева или GiST,эффективность поиска по индексу одинакова независимо от того,в каком столбце(ах)индекса используются условия запроса.</target>
        </trans-unit>
        <trans-unit id="a40f443a6350a7a3a7b742a42955a0061cf6840b" translate="yes" xml:space="preserve">
          <source>A multicolumn GiST index can be used with query conditions that involve any subset of the index's columns. Conditions on additional columns restrict the entries returned by the index, but the condition on the first column is the most important one for determining how much of the index needs to be scanned. A GiST index will be relatively ineffective if its first column has only a few distinct values, even if there are many distinct values in additional columns.</source>
          <target state="translated">Многоколоночный индекс GiST может использоваться с условиями запроса,включающими любое подмножество столбцов индекса.Условия в дополнительных столбцах ограничивают записи,возвращаемые индексом,однако условие в первом столбце является наиболее важным для определения того,какую часть индекса необходимо отсканировать.Индекс GiST будет относительно неэффективным,если его первый столбец имеет только несколько различных значений,даже если в дополнительных столбцах имеется много различных значений.</target>
        </trans-unit>
        <trans-unit id="61e3a968ac084ffcdbf2ee57ee023225a4c61ed4" translate="yes" xml:space="preserve">
          <source>A multiple-character operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">Многосимвольное имя оператора не может заканчиваться на &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; , если имя также не содержит хотя бы один из этих символов:</target>
        </trans-unit>
        <trans-unit id="c34267e8f8081ad131049e90185ef07a4a593a2c" translate="yes" xml:space="preserve">
          <source>A name (without schema qualification) must be specified for each &lt;code&gt;WITH&lt;/code&gt; query. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery.</source>
          <target state="translated">Имя (без уточнения схемы) должно быть указано для каждого запроса &lt;code&gt;WITH&lt;/code&gt; . При желании можно указать список имен столбцов; если он опущен, имена столбцов выводятся из подзапроса.</target>
        </trans-unit>
        <trans-unit id="6bf463ff31beb31d0372f0b1e73503dfa89eeca4" translate="yes" xml:space="preserve">
          <source>A name to use for a returned column.</source>
          <target state="translated">Имя,которое будет использоваться для возвращаемой колонки.</target>
        </trans-unit>
        <trans-unit id="272bf486701f1c7737a7b79a5df1a6cc7e2d076e" translate="yes" xml:space="preserve">
          <source>A named collection of &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt; which all use the same &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt; and have other configuration values in common.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c6fcfc35cb51a17f46343c3f38d154442e2627" translate="yes" xml:space="preserve">
          <source>A named collection of &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;local SQL objects&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14bebfb5283ed66820e63249347863d7698ec1a3" translate="yes" xml:space="preserve">
          <source>A named location on the server file system. All &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt; which require storage beyond their definition in the &lt;a href=&quot;glossary#GLOSSARY-SYSTEM-CATALOG&quot;&gt;system catalog&lt;/a&gt; must belong to a single tablespace. Initially, a database cluster contains a single usable tablespace which is used as the default for all SQL objects, called &lt;code&gt;pg_default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05611b43715c57dcc82e9a73dc2d7f3d8e3a806" translate="yes" xml:space="preserve">
          <source>A named variable. Its value can be set by the parameter &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; of several JSON processing functions. See &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; and its notes for details.</source>
          <target state="translated">Именованная переменная. Его значение может быть установлено с помощью &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; параметров нескольких функций обработки JSON. См. Подробности в &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Таблице 9.47&lt;/a&gt; и примечаниях к ней.</target>
        </trans-unit>
        <trans-unit id="74fdd4598f86747d21b59f0ff46b91f71c06f897" translate="yes" xml:space="preserve">
          <source>A named variable. Its value can be set by the parameter &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; of several JSON processing functions; see &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91a5ad7df4feb45e2e64cef1252fbd5ff25b557" translate="yes" xml:space="preserve">
          <source>A new database object basically inherits the security label of the parent object, except when the security policy has special rules known as type-transition rules, in which case a different label may be applied. For schemas, the parent object is the current database; for tables, sequences, views, and functions, it is the containing schema; for columns, it is the containing table.</source>
          <target state="translated">Новый объект базы данных,по сути,наследует метку безопасности родительского объекта,за исключением тех случаев,когда политика безопасности имеет специальные правила,известные как правила перехода типа,и в этом случае может быть применена другая метка.Для схем родительским объектом является текущая БД;для таблиц,последовательностей,представлений и функций-содержащая схема;для столбцов-содержащая таблица.</target>
        </trans-unit>
        <trans-unit id="a69d7af9d66bab695fb9262e5704599a7bd6821d" translate="yes" xml:space="preserve">
          <source>A new heap entry is made before making its index entries. (Therefore a concurrent index scan is likely to fail to see the heap entry. This is okay because the index reader would be uninterested in an uncommitted row anyway. But see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt;.)</source>
          <target state="translated">Новая запись в куче создается перед внесением ее индексных записей. (Поэтому при одновременном сканировании индекса, скорее всего, не удастся увидеть запись в куче. Это нормально, потому что читатель индекса в любом случае не будет интересоваться незафиксированной строкой. Но см. &lt;a href=&quot;index-unique-checks&quot;&gt;Раздел 61.5&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="e9bfb94dcc9a12b2e365d8f54e18e6c8a60beb96" translate="yes" xml:space="preserve">
          <source>A new random session key is generated.</source>
          <target state="translated">Генерируется новый ключ случайной сессии.</target>
        </trans-unit>
        <trans-unit id="cd5509bd2e57840414a4b31d4dcfe1a53cd60297" translate="yes" xml:space="preserve">
          <source>A new temporary index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt;. This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</source>
          <target state="translated">В каталог &lt;code&gt;pg_index&lt;/code&gt; добавлено новое временное определение индекса . Это определение будет использоваться для замены старого индекса. &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; блокировка на уровне сессии принимается на индексы будучи переиндексирован, а также связанные с ними таблицы , чтобы предотвратить любое изменение схемы во время обработки.</target>
        </trans-unit>
        <trans-unit id="e67b7984583e1c4ea079d2de00a7015a2704c63b" translate="yes" xml:space="preserve">
          <source>A new transient index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt;. This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ddb11c7f41b9fc173a0daee9b22a0046a88a72" translate="yes" xml:space="preserve">
          <source>A non-XML result assigned to an &lt;code&gt;xml&lt;/code&gt; output column produces content, a single text node with the string value of the result. An XML result assigned to a column of any other type may not have more than one node, or an error is raised. If there is exactly one node, the column will be set as if by assigning the node's string value (as defined for the XPath 1.0 &lt;code&gt;string&lt;/code&gt; function) to the PostgreSQL type.</source>
          <target state="translated">Результат не в формате XML, назначенный выходному столбцу &lt;code&gt;xml&lt;/code&gt; , создает контент, единственный текстовый узел со строковым значением результата. Результат XML, присвоенный столбцу любого другого типа, может иметь не более одного узла, в противном случае возникает ошибка. Если имеется ровно один узел, столбец будет установлен так, как если бы строковое значение узла (как определено для &lt;code&gt;string&lt;/code&gt; функции XPath 1.0 ) было присвоено типу PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="473219c281a2d874786237c92b0fcf8169682ead" translate="yes" xml:space="preserve">
          <source>A non-exclusive low level backup is one that allows other concurrent backups to be running (both those started using the same backup API and those started using &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;app-pgbasebackup&quot;&gt;Неисключительное&lt;/a&gt; резервное копирование низкого уровня - это резервное копирование, которое позволяет запускать другие параллельные резервные копии (как те, которые были запущены с использованием одного и того же API резервного копирования, так и те, которые были запущены с использованием pg_basebackup ).</target>
        </trans-unit>
        <trans-unit id="401550561965c2499f16ad6fd4b31c047d5f304a" translate="yes" xml:space="preserve">
          <source>A normal relationship between separately-created objects. The dependent object can be dropped without affecting the referenced object. The referenced object can only be dropped by specifying &lt;code&gt;CASCADE&lt;/code&gt;, in which case the dependent object is dropped, too. Example: a table column has a normal dependency on its data type.</source>
          <target state="translated">Нормальные отношения между отдельно созданными объектами. Зависимый объект можно отбросить, не затрагивая ссылочный объект. Указанный объект можно удалить, только указав &lt;code&gt;CASCADE&lt;/code&gt; , и в этом случае удаляется и зависимый объект. Пример: столбец таблицы обычно зависит от своего типа данных.</target>
        </trans-unit>
        <trans-unit id="f4e6fa0c13024f923c36983ca255cb802f2a15dc" translate="yes" xml:space="preserve">
          <source>A not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraint &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt;, but in PostgreSQL creating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way.</source>
          <target state="translated">Ненулевое ограничение всегда записывается как ограничение столбца. Ненулевое ограничение функционально эквивалентно созданию проверочного ограничения &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt; , но в PostgreSQL создание явного ненулевого ограничения более эффективно. Недостатком является то, что вы не можете давать явные имена ненулевым ограничениям, созданным таким образом.</target>
        </trans-unit>
        <trans-unit id="29e3f0f63dd403df874ec2bd2e2e99cfcbefc40b" translate="yes" xml:space="preserve">
          <source>A not-null constraint simply specifies that a column must not assume the null value. A syntax example:</source>
          <target state="translated">Ничтожное ограничение просто указывает на то,что столбец не должен принимать нулевое значение.Пример синтаксиса:</target>
        </trans-unit>
        <trans-unit id="38f215d8dff9a872adcc025cd248723a7de60a09" translate="yes" xml:space="preserve">
          <source>A number of probes or trace points are already inserted into the source code. These probes are intended to be used by database developers and administrators. By default the probes are not compiled into PostgreSQL; the user needs to explicitly tell the configure script to make the probes available.</source>
          <target state="translated">В исходный код уже вставлено несколько зондов или точек трассировки.Эти зонды предназначены для использования разработчиками и администраторами баз данных.По умолчанию зонды не компилируются в PostgreSQL;пользователю необходимо явно указать сценарий настройки,чтобы сделать зонды доступными.</target>
        </trans-unit>
        <trans-unit id="62bf9b2e29dd2eab9640de99e0e28efaa651fde7" translate="yes" xml:space="preserve">
          <source>A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.28&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.29&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</source>
          <target state="translated">В исходном коде содержится ряд стандартных пробников, как показано в &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Таблице 27.28&lt;/a&gt; ; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;В таблице 27.29&lt;/a&gt; показаны типы, используемые в датчиках. Безусловно, можно добавить больше зондов для улучшения наблюдаемости PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="ae551e6f1a5e0e884b3ccb3cbfaaaffb2764ba8e" translate="yes" xml:space="preserve">
          <source>A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.42&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.43&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f77be94ef3c8feb2e598e753ef0750ef27c239" translate="yes" xml:space="preserve">
          <source>A number of these variables are treated specially by psql. They represent certain option settings that can be changed at run time by altering the value of the variable, or in some cases represent changeable state of psql. By convention, all specially treated variables' names consist of all upper-case ASCII letters (and possibly digits and underscores). To ensure maximum compatibility in the future, avoid using such variable names for your own purposes.</source>
          <target state="translated">Некоторые из этих переменных специально обрабатываются psql.Они представляют собой определенные настройки опций,которые могут быть изменены во время выполнения путем изменения значения переменной,или в некоторых случаях представляют собой изменчивое состояние psql.По соглашению,все специально обработанные имена переменных состоят из всех прописных ASCII-буквенных букв (и,возможно,цифр и символов подчеркивания).Чтобы обеспечить максимальную совместимость в будущем,избегайте использования таких имен переменных в собственных целях.</target>
        </trans-unit>
        <trans-unit id="9671dc450d1031cf1ea5da7434a9e12abf1e8725" translate="yes" xml:space="preserve">
          <source>A numeric constant that contains neither a decimal point nor an exponent is initially presumed to be type &lt;code&gt;integer&lt;/code&gt; if its value fits in type &lt;code&gt;integer&lt;/code&gt; (32 bits); otherwise it is presumed to be type &lt;code&gt;bigint&lt;/code&gt; if its value fits in type &lt;code&gt;bigint&lt;/code&gt; (64 bits); otherwise it is taken to be type &lt;code&gt;numeric&lt;/code&gt;. Constants that contain decimal points and/or exponents are always initially presumed to be type &lt;code&gt;numeric&lt;/code&gt;.</source>
          <target state="translated">Числовая константа, не содержащая ни десятичной точки, ни экспоненты, изначально считается &lt;code&gt;integer&lt;/code&gt; типом, если ее значение соответствует &lt;code&gt;integer&lt;/code&gt; типу (32 бита); в противном случае предполагается, что это тип &lt;code&gt;bigint&lt;/code&gt; , если его значение соответствует типу &lt;code&gt;bigint&lt;/code&gt; (64 бита); в противном случае он считается &lt;code&gt;numeric&lt;/code&gt; . Константы, содержащие десятичные точки и / или показатели степени, всегда изначально считаются &lt;code&gt;numeric&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28053ae7864d70a55d085c051398ee367a8ba696" translate="yes" xml:space="preserve">
          <source>A numeric constant that specifies the length in bytes of the new type's internal representation. The default assumption is that it is variable-length.</source>
          <target state="translated">Числовая константа,задающая длину в байтах внутреннего представления нового типа.По умолчанию предполагается,что это переменная длина.</target>
        </trans-unit>
        <trans-unit id="458377c420bfcead4a575e16d3cb5a525edf744e" translate="yes" xml:space="preserve">
          <source>A one-dimensional interval starting at &lt;code&gt;x&lt;/code&gt; and ending at &lt;code&gt;y&lt;/code&gt; or vice versa; the order does not matter</source>
          <target state="translated">Одномерный интервал, начинающийся с &lt;code&gt;x&lt;/code&gt; и заканчивающийся &lt;code&gt;y&lt;/code&gt; или наоборот; порядок не имеет значения</target>
        </trans-unit>
        <trans-unit id="258b20d113a4ac0002010f6811f02c8de89d74bf" translate="yes" xml:space="preserve">
          <source>A one-dimensional point (or, zero-length one-dimensional interval)</source>
          <target state="translated">Одномерная точка (или нулевой одномерный интервал).</target>
        </trans-unit>
        <trans-unit id="bc1071526f0987dbc584cef038787a5b04285bb1" translate="yes" xml:space="preserve">
          <source>A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. For example:</source>
          <target state="translated">Изображение страницы, полученное с помощью &lt;code&gt;get_raw_page&lt;/code&gt; , должно быть передано в качестве аргумента. Например:</target>
        </trans-unit>
        <trans-unit id="5d8915a6b0933e1f5dc0f9cee0ae40fe953639a8" translate="yes" xml:space="preserve">
          <source>A parent table cannot be dropped while any of its children remain. Neither can columns or check constraints of child tables be dropped or altered if they are inherited from any parent tables. If you wish to remove a table and all of its descendants, one easy way is to drop the parent table with the &lt;code&gt;CASCADE&lt;/code&gt; option (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Родительская таблица не может быть удалена, пока остается любой из ее дочерних элементов. Столбцы или проверочные ограничения дочерних таблиц также не могут быть удалены или изменены, если они унаследованы от каких-либо родительских таблиц. Если вы хотите удалить таблицу и всех ее потомков, один из простых способов - удалить родительскую таблицу с помощью опции &lt;code&gt;CASCADE&lt;/code&gt; (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b87d25eb2f25d2d484b24b9f4a15020854de03d4" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this foreign table.</source>
          <target state="translated">Родительская таблица,чтобы ассоциировать или де-ассоциировать с этой иностранной таблицей.</target>
        </trans-unit>
        <trans-unit id="9038188b4e1e4e207e5656bab49c0b4bbe2840fb" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this table.</source>
          <target state="translated">Родительская таблица для связи или развязки с этой таблицей.</target>
        </trans-unit>
        <trans-unit id="bef9303e674e1152b39759a3ac4a051765f051a5" translate="yes" xml:space="preserve">
          <source>A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition.</source>
          <target state="translated">Раздел должен иметь те же имена и типы столбцов, что и секционированная таблица, к которой он принадлежит. Изменения имен столбцов или типов многораздельной таблицы автоматически распространяются на все разделы. Ограничения &lt;code&gt;CHECK&lt;/code&gt; будут автоматически унаследованы каждым разделом, но отдельный раздел может указывать дополнительные ограничения &lt;code&gt;CHECK&lt;/code&gt; ; дополнительные ограничения с тем же именем и условием, что и в родительском, будут объединены с родительским ограничением. Значения по умолчанию можно указать отдельно для каждого раздела.</target>
        </trans-unit>
        <trans-unit id="2b0fee0af770b0e2b7c1779ad6d02cf3f6e73981" translate="yes" xml:space="preserve">
          <source>A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition. But note that a partition's default value is not applied when inserting a tuple through a partitioned table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753a83c5b7fc1757da85bcf15b0058b4367b5ffe" translate="yes" xml:space="preserve">
          <source>A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached are marked &lt;code&gt;NO INHERIT&lt;/code&gt;, the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2265efb683514f071f0b16aed28cd3bcc5853f6a" translate="yes" xml:space="preserve">
          <source>A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached is marked &lt;code&gt;NO INHERIT&lt;/code&gt;, the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</source>
          <target state="translated">Раздел, использующий &lt;code&gt;FOR VALUES&lt;/code&gt; , использует тот же синтаксис для &lt;code&gt;partition_bound_spec&lt;/code&gt; , что и &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Спецификация границы раздела должна соответствовать стратегии разделения и ключу раздела целевой таблицы. В присоединяемой таблице должны быть все те же столбцы, что и в целевой таблице, и не более; кроме того, типы столбцов также должны совпадать. Кроме того, он должен иметь все ограничения &lt;code&gt;NOT NULL&lt;/code&gt; и &lt;code&gt;CHECK&lt;/code&gt; целевой таблицы. В настоящее время ограничения &lt;code&gt;FOREIGN KEY&lt;/code&gt; не рассматриваются. &lt;code&gt;UNIQUE&lt;/code&gt; разделе будут созданы ограничения UNIQUE и &lt;code&gt;PRIMARY KEY&lt;/code&gt; из родительской таблицы, если они еще не существуют. Если какой-либо из &lt;code&gt;CHECK&lt;/code&gt; ограничения присоединяемой таблицы помечены как &lt;code&gt;NO INHERIT&lt;/code&gt; , команда завершится ошибкой; такие ограничения должны быть воссозданы без предложения &lt;code&gt;NO INHERIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02bfa1f4284b2b7254a60122f0ece5c14ca3baa1" translate="yes" xml:space="preserve">
          <source>A partitioned table is divided into sub-tables (called partitions), which are created using separate &lt;code&gt;CREATE TABLE&lt;/code&gt; commands. The partitioned table is itself empty. A data row inserted into the table is routed to a partition based on the value of columns or expressions in the partition key. If no existing partition matches the values in the new row, an error will be reported.</source>
          <target state="translated">Секционированная таблица делится на подтаблицы (называемые разделами), которые создаются с помощью отдельных команд &lt;code&gt;CREATE TABLE&lt;/code&gt; . Сама секционированная таблица пуста. Строка данных, вставленная в таблицу, направляется в секцию на основе значений столбцов или выражений в ключе секции. Если ни один из существующих разделов не соответствует значениям в новой строке, будет сообщено об ошибке.</target>
        </trans-unit>
        <trans-unit id="47bfb6365d874606167f5297b7825760e1b94998" translate="yes" xml:space="preserve">
          <source>A password is only significant if the client authentication method requires the user to supply a password when connecting to the database. The &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;md5&lt;/code&gt; authentication methods make use of passwords. Database passwords are separate from operating system passwords. Specify a password upon role creation with &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt;.</source>
          <target state="translated">Пароль имеет значение только в том случае, если метод аутентификации клиента требует, чтобы пользователь вводил пароль при подключении к базе данных. В методах аутентификации &lt;code&gt;password&lt;/code&gt; и &lt;code&gt;md5&lt;/code&gt; используются пароли. Пароли базы данных отделены от паролей операционной системы. Укажите пароль при создании роли с помощью &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35958631e7f174f767add77cc9815bb09387d918" translate="yes" xml:space="preserve">
          <source>A password that does not follow either of those formats is assumed to be unencrypted.</source>
          <target state="translated">Пароль,который не следует ни одному из этих форматов,считается нешифрованным.</target>
        </trans-unit>
        <trans-unit id="ab9b8b43d3aed0e06f19d1971e9a5e5fb76320e8" translate="yes" xml:space="preserve">
          <source>A path expression can be a Boolean predicate, although the SQL/JSON standard allows predicates only in filters. This is necessary for implementation of the &lt;code&gt;@@&lt;/code&gt; operator. For example, the following &lt;code&gt;jsonpath&lt;/code&gt; expression is valid in PostgreSQL:</source>
          <target state="translated">Выражение пути может быть логическим предикатом, хотя стандарт SQL / JSON допускает предикаты только в фильтрах. Это необходимо для реализации оператора &lt;code&gt;@@&lt;/code&gt; . Например, в PostgreSQL допустимо следующее выражение &lt;code&gt;jsonpath&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="630b9b00d6c7d46f1803db83394a9ee4f3b0c93b" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of SQL/JSON items (&lt;em&gt;SQL/JSON sequence&lt;/em&gt;) is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</source>
          <target state="translated">Выражение пути состоит из последовательности элементов, разрешенных &lt;code&gt;jsonpath&lt;/code&gt; данных jsonpath . Выражение пути оценивается слева направо, но вы можете использовать круглые скобки для изменения порядка операций. Если оценка успешна, создается последовательность элементов SQL / JSON ( &lt;em&gt;последовательность SQL / JSON&lt;/em&gt; ), а результат оценки возвращается функции запроса JSON, которая завершает указанное вычисление.</target>
        </trans-unit>
        <trans-unit id="87f4c54faa8f7479fd0c8926b062c01e3b7b2498" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is normally evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of JSON items is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419a53a9c84f96a1644ee859a8c3c016a2c745c2" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of path elements, which can be any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b906a3261066476a4e478667be529d451288613" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of path elements, which can be the following:</source>
          <target state="translated">Выражение пути состоит из последовательности элементов пути,которая может быть следующей:</target>
        </trans-unit>
        <trans-unit id="46a75a9a8ee3f1ff5de45744e068475e9be0d81b" translate="yes" xml:space="preserve">
          <source>A pattern that contains a dot (&lt;code&gt;.&lt;/code&gt;) is interpreted as a schema name pattern followed by an object name pattern. For example, &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; displays all tables whose table name includes &lt;code&gt;bar&lt;/code&gt; that are in schemas whose schema name starts with &lt;code&gt;foo&lt;/code&gt;. When no dot appears, then the pattern matches only objects that are visible in the current schema search path. Again, a dot within double quotes loses its special meaning and is matched literally.</source>
          <target state="translated">Шаблон, содержащий точку ( &lt;code&gt;.&lt;/code&gt; ), Интерпретируется как шаблон имени схемы, за которым следует шаблон имени объекта. Например, &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; отображает все таблицы, имя таблицы которых включает &lt;code&gt;bar&lt;/code&gt; , которые находятся в схемах, имя схемы которых начинается с &lt;code&gt;foo&lt;/code&gt; . Если точка не отображается, шаблон соответствует только объектам, которые видны в текущем пути поиска схемы. Опять же, точка в двойных кавычках теряет свое особое значение и соответствует буквально.</target>
        </trans-unit>
        <trans-unit id="e2fdd324df9af943d98a0446644b1732be556666" translate="yes" xml:space="preserve">
          <source>A physical file which stores data for a given &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;. File segments are limited in size by a configuration value (typically 1 gigabyte), so if a relation exceeds that size, it is split into multiple segments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5474357c1efadc094c42e8ca5e1d158c9c8724d2" translate="yes" xml:space="preserve">
          <source>A plain integer denotes a day of the year, counting from zero to 364, or to 365 in leap years.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7897c4bbe5ec9cccaaddf1f6c43de7d3f2aaad08" translate="yes" xml:space="preserve">
          <source>A point in n-dimensional space, represented internally as a zero-volume cube</source>
          <target state="translated">Точка в n-мерном пространстве,представленная внутри в виде куба нулевого объема.</target>
        </trans-unit>
        <trans-unit id="45445178529cbc6647ad679b1b5ca9fd7c3a49b9" translate="yes" xml:space="preserve">
          <source>A point in the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt; sequence at which it is guaranteed that the heap and index data files have been updated with all information from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; modified before that checkpoint; a &lt;em&gt;checkpoint record&lt;/em&gt; is written and flushed to WAL to mark that point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b7209c416eb8b0cd4ad3c6e895e2f5e59edbd1" translate="yes" xml:space="preserve">
          <source>A policy grants the permission to select, insert, update, or delete rows that match the relevant policy expression. Existing table rows are checked against the expression specified in &lt;code&gt;USING&lt;/code&gt;, while new rows that would be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; are checked against the expression specified in &lt;code&gt;WITH CHECK&lt;/code&gt;. When a &lt;code&gt;USING&lt;/code&gt; expression returns true for a given row then that row is visible to the user, while if false or null is returned then the row is not visible. When a &lt;code&gt;WITH CHECK&lt;/code&gt; expression returns true for a row then that row is inserted or updated, while if false or null is returned then an error occurs.</source>
          <target state="translated">Политика предоставляет разрешение на выбор, вставку, обновление или удаление строк, соответствующих соответствующему выражению политики. Существующие строки таблицы проверяются на соответствие выражению, указанному в &lt;code&gt;USING&lt;/code&gt; , а новые строки, которые будут созданы с помощью &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; , проверяются на соответствие выражению, указанному в &lt;code&gt;WITH CHECK&lt;/code&gt; . Когда выражение &lt;code&gt;USING&lt;/code&gt; возвращает истину для данной строки, эта строка видна пользователю, а если возвращается false или null, строка не видна. Когда выражение &lt;code&gt;WITH CHECK&lt;/code&gt; возвращает true для строки, эта строка вставляется или обновляется, а если возвращается false или null, возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="f8e613dc0d26e68918f83658070562d9898412d1" translate="yes" xml:space="preserve">
          <source>A position normally indicates the source word's location in the document. Positional information can be used for &lt;em&gt;proximity ranking&lt;/em&gt;. Position values can range from 1 to 16383; larger numbers are silently set to 16383. Duplicate positions for the same lexeme are discarded.</source>
          <target state="translated">Позиция обычно указывает расположение исходного слова в документе. Позиционная информация может использоваться для &lt;em&gt;ранжирования&lt;/em&gt; по &lt;em&gt;близости&lt;/em&gt; . Значения позиции могут находиться в диапазоне от 1 до 16383; большие числа автоматически устанавливаются на 16383. Дублирующиеся позиции для одной и той же лексемы отбрасываются.</target>
        </trans-unit>
        <trans-unit id="8124e08cb675a3763a841977baebeafd4db084c2" translate="yes" xml:space="preserve">
          <source>A positional parameter reference is used to indicate a value that is supplied externally to an SQL statement. Parameters are used in SQL function definitions and in prepared queries. Some client libraries also support specifying data values separately from the SQL command string, in which case parameters are used to refer to the out-of-line data values. The form of a parameter reference is:</source>
          <target state="translated">Ссылка на позиционный параметр используется для указания значения,которое поступает извне в SQL-оператор.Параметры используются в определениях SQL-функций и в подготовленных запросах.Некоторые клиентские библиотеки также поддерживают указание значений данных отдельно от командной строки SQL,в этом случае параметры используются для ссылки на внестрочные значения данных.Форма ссылки на параметр:</target>
        </trans-unit>
        <trans-unit id="3833bdb7ea9a948094cad484b196a53403718838" translate="yes" xml:space="preserve">
          <source>A positional parameter reference, in the body of a function definition or prepared statement</source>
          <target state="translated">Опорный позиционный параметр,в теле определения функции или подготовленного утверждения</target>
        </trans-unit>
        <trans-unit id="0f115ce95e27f153df6502e75df85ece7a17f10c" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated execution cost for the function, in units of &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;. If the function returns a set, this is the cost per returned row. If the cost is not specified, 1 unit is assumed for C-language and internal functions, and 100 units for functions in all other languages. Larger values cause the planner to try to avoid evaluating the function more often than necessary.</source>
          <target state="translated">Положительное число, дающее приблизительную стоимость выполнения функции в единицах &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt; . Если функция возвращает набор, это стоимость возвращаемой строки. Если стоимость не указана, предполагается, что 1 единица для C-языка и внутренних функций и 100 единиц для функций на всех других языках. Большие значения заставляют планировщика стараться избегать оценки функции чаще, чем это необходимо.</target>
        </trans-unit>
        <trans-unit id="30c1a79cbb9484177e363d4544efe87e3e39ffa7" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated number of rows that the planner should expect the function to return. This is only allowed when the function is declared to return a set. The default assumption is 1000 rows.</source>
          <target state="translated">Положительное число,дающее предполагаемое количество строк,которое планировщик должен ожидать возврата функции.Это допускается только в том случае,если функция объявлена как возвращающая набор.По умолчанию предполагается 1000 строк.</target>
        </trans-unit>
        <trans-unit id="02f79e462db5425b448e96c1072a3f594c31942d" translate="yes" xml:space="preserve">
          <source>A possible query to use this index would be:</source>
          <target state="translated">Возможен запрос на использование этого индекса:</target>
        </trans-unit>
        <trans-unit id="a46068a086ffe6678122c2b4a804a11dab670aaa" translate="yes" xml:space="preserve">
          <source>A prepared statement can be executed with either a &lt;em&gt;generic plan&lt;/em&gt; or a &lt;em&gt;custom plan&lt;/em&gt;. A generic plan is the same across all executions, while a custom plan is generated for a specific execution using the parameter values given in that call. Use of a generic plan avoids planning overhead, but in some situations a custom plan will be much more efficient to execute because the planner can make use of knowledge of the parameter values. (Of course, if the prepared statement has no parameters, then this is moot and a generic plan is always used.)</source>
          <target state="translated">Подготовленный оператор может быть выполнен либо с &lt;em&gt;общим планом,&lt;/em&gt; либо с &lt;em&gt;индивидуальным планом&lt;/em&gt; . Общий план одинаков для всех выполнений, в то время как настраиваемый план создается для конкретного выполнения с использованием значений параметров, указанных в этом вызове. Использование общего плана позволяет избежать накладных расходов на планирование, но в некоторых ситуациях индивидуальный план будет намного более эффективным для выполнения, поскольку планировщик может использовать информацию о значениях параметров. (Конечно, если подготовленный оператор не имеет параметров, это спорный вопрос, и всегда используется общий план.)</target>
        </trans-unit>
        <trans-unit id="13348ea1ec457fbeed4d2620cc50c2e7f85fa0ae" translate="yes" xml:space="preserve">
          <source>A primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table. This requires that the values be both unique and not null. So, the following two table definitions accept the same data:</source>
          <target state="translated">Ограничение первичного ключа указывает на то,что столбец или группа столбцов может быть использован в качестве уникального идентификатора для строк таблицы.Для этого необходимо,чтобы значения были как уникальными,так и не нулевыми.Таким образом,следующие два определения таблицы принимают одни и те же данные:</target>
        </trans-unit>
        <trans-unit id="3f893762c520af1aa49b543485b038d4cb74971c" translate="yes" xml:space="preserve">
          <source>A procedural language call handler is declared to return &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">Объявлен обработчик вызова процедурного языка, возвращающий &lt;code&gt;language_handler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85b471a8bbdcb0184dcaf026b542b9d1c7608b3f" translate="yes" xml:space="preserve">
          <source>A process that saves copies of &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt; for the purpose of creating backups or keeping &lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;replicas&lt;/a&gt; current.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68348e6f47688291dbdf76ea9ce04384d5ed5818" translate="yes" xml:space="preserve">
          <source>A process that writes &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt; from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; to &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df87a47e5d11566e3968df708fe83a96d24cbb48" translate="yes" xml:space="preserve">
          <source>A process that writes dirty &lt;a href=&quot;glossary#GLOSSARY-DATA-PAGE&quot;&gt;data pages&lt;/a&gt; from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; to the file system. It wakes up periodically, but works only for a short period in order to distribute its expensive I/O activity over time to avoid generating larger I/O peaks which could block other processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b598946555659e8de8862e7df2ae169d900a0d4a" translate="yes" xml:space="preserve">
          <source>A publication can only be dropped by its owner or a superuser.</source>
          <target state="translated">Публикация может быть выкинута только ее владельцем или суперпользователем.</target>
        </trans-unit>
        <trans-unit id="ba53206c029e2edfae51f727e267685bcdf05085" translate="yes" xml:space="preserve">
          <source>A publication is created using the &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; command and may later be altered or dropped using corresponding commands.</source>
          <target state="translated">Публикация создается с помощью команды &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; и может быть позже изменена или удалена с помощью соответствующих команд.</target>
        </trans-unit>
        <trans-unit id="c9ab2d1b430251390fd77666a59dc72c11f11cfe" translate="yes" xml:space="preserve">
          <source>A publication is essentially a group of tables whose data changes are intended to be replicated through logical replication. See &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt; for details about how publications fit into the logical replication setup.</source>
          <target state="translated">Публикация - это, по сути, группа таблиц, изменения данных в которых предназначены для репликации посредством логической репликации. См. &lt;a href=&quot;logical-replication-publication&quot;&gt;Раздел 30.1&lt;/a&gt; для подробностей о том, как публикации вписываются в схему логической репликации.</target>
        </trans-unit>
        <trans-unit id="e2338433bd110932bcc29150142a24f592f4dfbb" translate="yes" xml:space="preserve">
          <source>A published table must have a &amp;ldquo;replica identity&amp;rdquo; configured in order to be able to replicate &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; operations, so that appropriate rows to update or delete can be identified on the subscriber side. By default, this is the primary key, if there is one. Another unique index (with certain additional requirements) can also be set to be the replica identity. If the table does not have any suitable key, then it can be set to replica identity &amp;ldquo;full&amp;rdquo;, which means the entire row becomes the key. This, however, is very inefficient and should only be used as a fallback if no other solution is possible. If a replica identity other than &amp;ldquo;full&amp;rdquo; is set on the publisher side, a replica identity comprising the same or fewer columns must also be set on the subscriber side. See &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;&lt;code&gt;REPLICA IDENTITY&lt;/code&gt;&lt;/a&gt; for details on how to set the replica identity. If a table without a replica identity is added to a publication that replicates &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations then subsequent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations will cause an error on the publisher. &lt;code&gt;INSERT&lt;/code&gt; operations can proceed regardless of any replica identity.</source>
          <target state="translated">У опубликованной таблицы должна быть настроена &amp;laquo;идентичность реплики&amp;raquo;, чтобы иметь возможность реплицировать операции &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; , чтобы соответствующие строки для обновления или удаления могли быть идентифицированы на стороне подписчика. По умолчанию это первичный ключ, если он есть. Другой уникальный индекс (с некоторыми дополнительными требованиями) также может быть установлен в качестве идентификатора реплики. Если таблица не имеет подходящего ключа, то для нее можно установить &amp;laquo;полную&amp;raquo; идентичность реплики, что означает, что вся строка становится ключом. Однако это очень неэффективно и должно использоваться только в качестве запасного варианта, если невозможно другое решение. Если на стороне издателя установлен идентификатор реплики, отличный от &amp;laquo;полного&amp;raquo;, на стороне подписчика также должен быть установлен идентификатор реплики, содержащий такие же или меньшее количество столбцов. Видеть&lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt; &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; &lt;/a&gt; для получения подробной информации о том, как установить идентичность реплики. Если таблица без идентичности реплик добавляются к публикациикоторая повторяет &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; операциито последующая &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; операции будет вызывать ошибку на издателе.Операции &lt;code&gt;INSERT&lt;/code&gt; могут выполняться независимо от идентичности реплики.</target>
        </trans-unit>
        <trans-unit id="0fa8cd1ec75091ae1b152072de83438ac13c7ac1" translate="yes" xml:space="preserve">
          <source>A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.16&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;.</source>
          <target state="translated">Количественный атом - это &lt;em&gt;атом,&lt;/em&gt; за которым может следовать один &lt;em&gt;количественный показатель&lt;/em&gt; . Без квантификатора он соответствует совпадению с атомом. С помощью квантификатора он может сопоставить некоторое количество совпадений атома. &lt;em&gt;Атом&lt;/em&gt; может быть любой из возможностей , показанных в &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;таблице 9.16&lt;/a&gt; . Возможные кванторы и их значения показаны в &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;таблице 9.17&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc21709c3a9df27bc9570d7ce18a8b13da68c2a0" translate="yes" xml:space="preserve">
          <source>A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.18&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b90372a7f382e1ebe5fbc1067a98d78caf7059" translate="yes" xml:space="preserve">
          <source>A quantified atom with a fixed-repetition quantifier (&lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; or &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt;) has the same greediness (possibly none) as the atom itself.</source>
          <target state="translated">Количественный атом с квантификатором фиксированного повторения ( &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; или &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; ) Имеет такую ​​же жадность (возможно, нулевую), что и сам атом.</target>
        </trans-unit>
        <trans-unit id="d2086c7d3f841e613b77902ebf9e5b97e2cde610" translate="yes" xml:space="preserve">
          <source>A quantified atom with a non-greedy quantifier (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is non-greedy (prefers shortest match).</source>
          <target state="translated">Количественный атом с нежадным квантификатором (включая &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; С &lt;code&gt;m&lt;/code&gt; равным &lt;code&gt;n&lt;/code&gt; ) не является жадным (предпочитает кратчайшее совпадение).</target>
        </trans-unit>
        <trans-unit id="044befe289d741f6adb775e3119a52c47ef4c4c1" translate="yes" xml:space="preserve">
          <source>A quantified atom with other normal quantifiers (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is greedy (prefers longest match).</source>
          <target state="translated">Количественный атом с другими нормальными квантификаторами (включая &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; с &lt;code&gt;m&lt;/code&gt; , равным &lt;code&gt;n&lt;/code&gt; ) является жадным (предпочитает наиболее длинное совпадение).</target>
        </trans-unit>
        <trans-unit id="b0376c8a695cc9a8414ca39502c5036b915645c0" translate="yes" xml:space="preserve">
          <source>A quantifier cannot immediately follow another quantifier, e.g., &lt;code&gt;**&lt;/code&gt; is invalid. A quantifier cannot begin an expression or subexpression or follow &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">Квантификатор не может сразу следовать за другим квантификатором, например, &lt;code&gt;**&lt;/code&gt; недопустимо. Квантификатор не может начинать выражение или часть выражения или следовать за &lt;code&gt;^&lt;/code&gt; или &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4fb059cdfd53bb422968b17a105f57bd04f411c" translate="yes" xml:space="preserve">
          <source>A query (&lt;code&gt;SELECT&lt;/code&gt; statement) that supplies the rows to be inserted. Refer to the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; statement for a description of the syntax.</source>
          <target state="translated">Запрос ( &lt;code&gt;SELECT&lt;/code&gt; ), который предоставляет строки для вставки. Обратитесь к &lt;a href=&quot;sql-select&quot;&gt;оператору SELECT&lt;/a&gt; за описанием синтаксиса.</target>
        </trans-unit>
        <trans-unit id="f6cba9f4354114ea501407f47fa13c76eb60151c" translate="yes" xml:space="preserve">
          <source>A query can be &amp;ldquo;qualified&amp;rdquo; by adding a &lt;code&gt;WHERE&lt;/code&gt; clause that specifies which rows are wanted. The &lt;code&gt;WHERE&lt;/code&gt; clause contains a Boolean (truth value) expression, and only rows for which the Boolean expression is true are returned. The usual Boolean operators (&lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, and &lt;code&gt;NOT&lt;/code&gt;) are allowed in the qualification. For example, the following retrieves the weather of San Francisco on rainy days:</source>
          <target state="translated">Запрос можно &amp;laquo;квалифицировать&amp;raquo;, добавив предложение &lt;code&gt;WHERE&lt;/code&gt; , указывающее, какие строки нужны. Предложение &lt;code&gt;WHERE&lt;/code&gt; содержит логическое выражение (значение истинности), и возвращаются только строки, для которых логическое выражение истинно. В квалификации разрешены обычные логические операторы ( &lt;code&gt;AND&lt;/code&gt; , &lt;code&gt;OR&lt;/code&gt; и &lt;code&gt;NOT&lt;/code&gt; ). Например, следующее извлекает погоду Сан-Франциско в дождливые дни:</target>
        </trans-unit>
        <trans-unit id="a3f98fa3c0d12a208eadd01d5ce05b0ffde908aa" translate="yes" xml:space="preserve">
          <source>A read-only SQL transaction cannot alter non-temporary tables. This parameter controls the default read-only status of each new transaction. The default is &lt;code&gt;off&lt;/code&gt; (read/write).</source>
          <target state="translated">Транзакция SQL только для чтения не может изменять невременные таблицы. Этот параметр управляет статусом по умолчанию только для чтения каждой новой транзакции. По умолчанию &lt;code&gt;off&lt;/code&gt; (чтение / запись).</target>
        </trans-unit>
        <trans-unit id="4a7841fe30d1103325f6249de23cba34804bfa4e" translate="yes" xml:space="preserve">
          <source>A reader should report an error if a field-count word is neither -1 nor the expected number of columns. This provides an extra check against somehow getting out of sync with the data.</source>
          <target state="translated">Читатель должен сообщить об ошибке,если слово счетчика полей не является ни -1,ни ожидаемым количеством столбцов.Это обеспечивает дополнительную проверку на некоторую не синхронизированность с данными.</target>
        </trans-unit>
        <trans-unit id="fddf89d1b48df3d1a7d816db398c1f9bc279cad0" translate="yes" xml:space="preserve">
          <source>A record can have one of the seven formats</source>
          <target state="translated">Запись может иметь один из семи форматов</target>
        </trans-unit>
        <trans-unit id="755da3745b4f352a5f0983d774febfd9dd4f8a2e" translate="yes" xml:space="preserve">
          <source>A record can have several formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b600abb4523a0f2e29ac983d05c8a91aade45f9" translate="yes" xml:space="preserve">
          <source>A recursive &lt;code&gt;DROP COLUMN&lt;/code&gt; operation will remove a descendant table's column only if the descendant does not inherit that column from any other parents and never had an independent definition of the column. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; (i.e., &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt;) never removes any descendant columns, but instead marks them as independently defined rather than inherited. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; command will fail for a partitioned table, because all partitions of a table must have the same columns as the partitioning root.</source>
          <target state="translated">Рекурсивная операция &lt;code&gt;DROP COLUMN&lt;/code&gt; удаляет столбец таблицы-потомка, только если потомок не наследует этот столбец от других родителей и никогда не имел независимого определения столбца. Нерекурсивная команда &lt;code&gt;DROP COLUMN&lt;/code&gt; (т.е. &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt; ) никогда не удаляет столбцы-потомки, а вместо этого отмечает их как независимо определенные, а не унаследованные. Нерекурсивная команда &lt;code&gt;DROP COLUMN&lt;/code&gt; завершится ошибкой для многораздельной таблицы, потому что все разделы таблицы должны иметь те же столбцы, что и корень разделения.</target>
        </trans-unit>
        <trans-unit id="c8e116c04f64e1769d84da7554d28932fe4d3963" translate="yes" xml:space="preserve">
          <source>A regular expression is a character sequence that is an abbreviated definition of a set of strings (a &lt;em&gt;regular set&lt;/em&gt;). A string is said to match a regular expression if it is a member of the regular set described by the regular expression. As with &lt;code&gt;LIKE&lt;/code&gt;, pattern characters match string characters exactly unless they are special characters in the regular expression language &amp;mdash; but regular expressions use different special characters than &lt;code&gt;LIKE&lt;/code&gt; does. Unlike &lt;code&gt;LIKE&lt;/code&gt; patterns, a regular expression is allowed to match anywhere within a string, unless the regular expression is explicitly anchored to the beginning or end of the string.</source>
          <target state="translated">Регулярное выражение - это последовательность символов, которая представляет собой сокращенное определение набора строк ( &lt;em&gt;регулярный набор&lt;/em&gt; ). Считается, что строка соответствует регулярному выражению, если она является членом регулярного набора, описываемого регулярным выражением. Как и в случае с &lt;code&gt;LIKE&lt;/code&gt; , символы шаблона точно соответствуют строковым символам, если только они не являются специальными символами в языке регулярных выражений, но в регулярных выражениях используются специальные символы, отличные от &lt;code&gt;LIKE&lt;/code&gt; . В отличие от шаблонов &lt;code&gt;LIKE&lt;/code&gt; , регулярному выражению разрешено совпадать в любом месте строки, если только регулярное выражение явно не привязано к началу или концу строки.</target>
        </trans-unit>
        <trans-unit id="8bcf2029d3dfa5827a2882665f99b1d027b1662c" translate="yes" xml:space="preserve">
          <source>A regular expression is defined as one or more &lt;em&gt;branches&lt;/em&gt;, separated by &lt;code&gt;|&lt;/code&gt;. It matches anything that matches one of the branches.</source>
          <target state="translated">Регулярное выражение определяется как одна или несколько &lt;em&gt;ветвей&lt;/em&gt; , разделенных знаком &lt;code&gt;|&lt;/code&gt; . Он соответствует всему, что соответствует одной из ветвей.</target>
        </trans-unit>
        <trans-unit id="3ee887f7d2952dfa9f7859c97d7cc185154f3579" translate="yes" xml:space="preserve">
          <source>A request sent by a client to a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend&lt;/a&gt;, usually to return results or to modify data on the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55280929ef651951f4ea5727fbd13d553ba423e3" translate="yes" xml:space="preserve">
          <source>A restriction on the values of data allowed within a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, or in attributes of a &lt;em&gt;domain&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4f1bec4e67db6d8c109c21ce30fc24feb18e6d" translate="yes" xml:space="preserve">
          <source>A rich set of functions and operators is available to perform various geometric operations such as scaling, translation, rotation, and determining intersections. They are explained in &lt;a href=&quot;functions-geometry&quot;&gt;Section 9.11&lt;/a&gt;.</source>
          <target state="translated">Доступен богатый набор функций и операторов для выполнения различных геометрических операций, таких как масштабирование, перемещение, поворот и определение пересечений. Они объяснены в &lt;a href=&quot;functions-geometry&quot;&gt;Разделе 9.11&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd3e55f45b03c0434f66fdb4c772115d77e89a86" translate="yes" xml:space="preserve">
          <source>A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</source>
          <target state="translated">Роль также может иметь зависящие от роли значения по умолчанию для многих параметров конфигурации времени выполнения, описанных в &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;главе 19&lt;/a&gt; . Например, если по какой-то причине вы хотите отключить сканирование индекса (подсказка: не очень хорошая идея) при каждом подключении, вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="5f70d4edcc88d0b7db0593c0dc96e77fa856833c" translate="yes" xml:space="preserve">
          <source>A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1819e27998d44ae23e1be32dd84afd40392e29ad" translate="yes" xml:space="preserve">
          <source>A role cannot be removed if it is still referenced in any database of the cluster; an error will be raised if so. Before dropping the role, you must drop all the objects it owns (or reassign their ownership) and revoke any privileges the role has been granted on other objects. The &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; and &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; commands can be useful for this purpose; see &lt;a href=&quot;role-removal&quot;&gt;Section 21.4&lt;/a&gt; for more discussion.</source>
          <target state="translated">Роль не может быть удалена, если на нее по-прежнему есть ссылки в любой базе данных кластера; в этом случае возникнет ошибка. Перед тем как отбросить роль, вы должны удалить все объекты, которыми она владеет (или переназначить их право собственности), и отозвать все привилегии, предоставленные этой ролью для других объектов. Для этой цели могут быть полезны команды &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; и &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP &lt;/a&gt;OWNED ; см. &lt;a href=&quot;role-removal&quot;&gt;Раздел 21.4&lt;/a&gt; для более подробного обсуждения.</target>
        </trans-unit>
        <trans-unit id="ca7ed328c6182a99c2ad02ba1bf771cc523959b3" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create databases (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt;.</source>
          <target state="translated">Роли должно быть явно предоставлено разрешение на создание баз данных (кроме суперпользователей, поскольку они обходят все проверки разрешений). Чтобы создать такую ​​роль, используйте &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d62d4d6cefafa0c4a7b229d226042d5cdbe21812" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create more roles (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt;. A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can alter and drop other roles, too, as well as grant or revoke membership in them. However, to create, alter, drop, or change membership of a superuser role, superuser status is required; &lt;code&gt;CREATEROLE&lt;/code&gt; is insufficient for that.</source>
          <target state="translated">Роли должно быть явно дано разрешение на создание дополнительных ролей (кроме суперпользователей, поскольку они обходят все проверки разрешений). Чтобы создать такую ​​роль, используйте &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt; . Роль с привилегией &lt;code&gt;CREATEROLE&lt;/code&gt; может изменять и удалять другие роли, а также предоставлять или отзывать членство в них. Однако для создания, изменения, удаления или изменения членства в роли суперпользователя требуется статус суперпользователя; &lt;code&gt;CREATEROLE&lt;/code&gt; для этого недостаточно.</target>
        </trans-unit>
        <trans-unit id="17ba5cb05b3fc9de95da7091b339d5cf7b10fc50" translate="yes" xml:space="preserve">
          <source>A role must explicitly be given permission to initiate streaming replication (except for superusers, since those bypass all permission checks). A role used for streaming replication must have &lt;code&gt;LOGIN&lt;/code&gt; permission as well. To create such a role, use &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt;.</source>
          <target state="translated">Роли должно быть явно предоставлено разрешение на запуск потоковой репликации (кроме суперпользователей, поскольку они обходят все проверки разрешений). Роль, используемая для потоковой репликации, также должна иметь разрешение &lt;code&gt;LOGIN&lt;/code&gt; . Чтобы создать такую ​​роль, используйте &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94be28bc6eb3b4ca303ced8b07cef3c876649a6d" translate="yes" xml:space="preserve">
          <source>A role's attributes can be modified after creation with &lt;code&gt;ALTER ROLE&lt;/code&gt;. See the reference pages for the &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; commands for details.</source>
          <target state="translated">Атрибуты роли можно изменить после создания с помощью &lt;code&gt;ALTER ROLE&lt;/code&gt; . См. Справочные страницы для команд &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; и &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="081acf24bd36c70b53212a425e34d472f83362f1" translate="yes" xml:space="preserve">
          <source>A row constructor</source>
          <target state="translated">Гребной конструктор</target>
        </trans-unit>
        <trans-unit id="22f30213b82e4ac8580d06b76fb30db617ce4ae6" translate="yes" xml:space="preserve">
          <source>A row constructor can include the syntax &lt;code&gt;rowvalue&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt;, which will be expanded to a list of the elements of the row value, just as occurs when the &lt;code&gt;.*&lt;/code&gt; syntax is used at the top level of a &lt;code&gt;SELECT&lt;/code&gt; list (see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;). For example, if table &lt;code&gt;t&lt;/code&gt; has columns &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, these are the same:</source>
          <target state="translated">Конструктор строки может включать синтаксис &lt;code&gt;rowvalue&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; , Который будет расширен до списка элементов значения строки, как это происходит, когда синтаксис &lt;code&gt;.*&lt;/code&gt; Используется на верхнем уровне списка &lt;code&gt;SELECT&lt;/code&gt; (см. &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Раздел 8.16.5.&lt;/a&gt; ). Например, если в таблице &lt;code&gt;t&lt;/code&gt; есть столбцы &lt;code&gt;f1&lt;/code&gt; и &lt;code&gt;f2&lt;/code&gt; , они будут одинаковыми:</target>
        </trans-unit>
        <trans-unit id="f65566297d0cf76754b5ffd2e69f3d748460cda5" translate="yes" xml:space="preserve">
          <source>A row constructor is an expression that builds a row value (also called a composite value) using values for its member fields. A row constructor consists of the key word &lt;code&gt;ROW&lt;/code&gt;, a left parenthesis, zero or more expressions (separated by commas) for the row field values, and finally a right parenthesis. For example:</source>
          <target state="translated">Конструктор строки - это выражение, которое создает значение строки (также называемое составным значением), используя значения для его полей-членов. Конструктор строки состоит из ключевого слова &lt;code&gt;ROW&lt;/code&gt; , левой круглой скобки, нуля или нескольких выражений (разделенных запятыми) для значений поля строки и, наконец, правой круглой скобки. Например:</target>
        </trans-unit>
        <trans-unit id="e083a9bfabe61aa93820ae695a4040f7ab7fb65b" translate="yes" xml:space="preserve">
          <source>A rule has significantly more overhead than a trigger, but the overhead is paid once per query rather than once per row, so this method might be advantageous for bulk-insert situations. In most cases, however, the trigger method will offer better performance.</source>
          <target state="translated">Правило имеет значительно больше накладных расходов,чем триггер,но накладные расходы оплачиваются один раз за запрос,а не один раз за строку,поэтому данный метод может быть выгоден для ситуаций с объемной вставкой.В большинстве случаев,однако,триггерный метод обеспечивает более высокую производительность.</target>
        </trans-unit>
        <trans-unit id="3a8ed465468f0b09e900dc84f22e1ad03222e742" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/members&lt;/code&gt; under the data directory, adding one, and then multiplying by 52352 (0xCC80). The file names are in hexadecimal. There is no simple recipe such as the ones for other options of appending zeroes.</source>
          <target state="translated">Безопасное значение может быть определено путем поиска имени файла с наибольшим числовым значением в каталоге &lt;code&gt;pg_multixact/members&lt;/code&gt; в каталоге данных, добавления единицы и затем умножения на 52352 (0xCC80). Имена файлов в шестнадцатеричном формате. Нет простого рецепта, подобного тем, которые используются для других вариантов добавления нулей.</target>
        </trans-unit>
        <trans-unit id="427cc987ada87144cf5033e51fd5ca57fac98875" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_xact&lt;/code&gt; under the data directory, adding one, and then multiplying by 1048576 (0x100000). Note that the file names are in hexadecimal. It is usually easiest to specify the option value in hexadecimal too. For example, if &lt;code&gt;0011&lt;/code&gt; is the largest entry in &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;-x 0x1200000&lt;/code&gt; will work (five trailing zeroes provide the proper multiplier).</source>
          <target state="translated">Безопасное значение может быть определено путем поиска имени файла с наибольшим численным значением в каталоге &lt;code&gt;pg_xact&lt;/code&gt; в каталоге данных, добавления единицы и затем умножения на 1048576 (0x100000). Обратите внимание, что имена файлов указаны в шестнадцатеричном формате. Обычно проще всего указать значение параметра в шестнадцатеричном формате. Например, если &lt;code&gt;0011&lt;/code&gt; является самой большой записью в &lt;code&gt;pg_xact&lt;/code&gt; , будет работать &lt;code&gt;-x 0x1200000&lt;/code&gt; (пять завершающих нулей обеспечивают правильный множитель).</target>
        </trans-unit>
        <trans-unit id="cb05b109b960491956518dbc25a95b68a60bb5b7" translate="yes" xml:space="preserve">
          <source>A safe value for the next multitransaction ID (first part) can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/offsets&lt;/code&gt; under the data directory, adding one, and then multiplying by 65536 (0x10000). Conversely, a safe value for the oldest multitransaction ID (second part of &lt;code&gt;-m&lt;/code&gt;) can be determined by looking for the numerically smallest file name in the same directory and multiplying by 65536. The file names are in hexadecimal, so the easiest way to do this is to specify the option value in hexadecimal and append four zeroes.</source>
          <target state="translated">Безопасное значение для следующего идентификатора мультитранзакции (первая часть) может быть определено путем поиска самого большого числового имени файла в каталоге &lt;code&gt;pg_multixact/offsets&lt;/code&gt; в каталоге данных, добавления единицы и затем умножения на 65536 (0x10000). И наоборот, безопасное значение для самого старого идентификатора мультитранзакции (вторая часть &lt;code&gt;-m&lt;/code&gt; ) может быть определено путем поиска числового наименьшего имени файла в том же каталоге и умножения на 65536. Имена файлов указаны в шестнадцатеричном формате, поэтому самый простой способ сделать это указать значение параметра в шестнадцатеричном формате и добавить четыре нуля.</target>
        </trans-unit>
        <trans-unit id="210bab91fc67894e59300e346dd93bb05146f64b" translate="yes" xml:space="preserve">
          <source>A safe value for the oldest transaction ID for which the commit time can be retrieved (first part) can be determined by looking for the numerically smallest file name in the directory &lt;code&gt;pg_commit_ts&lt;/code&gt; under the data directory. Conversely, a safe value for the newest transaction ID for which the commit time can be retrieved (second part) can be determined by looking for the numerically greatest file name in the same directory. The file names are in hexadecimal.</source>
          <target state="translated">Безопасное значение для самого старого идентификатора транзакции, для которого можно получить время фиксации (первая часть), может быть определено путем поиска наименьшего числового имени файла в каталоге &lt;code&gt;pg_commit_ts&lt;/code&gt; в каталоге данных. И наоборот, безопасное значение идентификатора самой новой транзакции, для которого может быть получено время фиксации (вторая часть), может быть определено путем поиска самого большого числового имени файла в том же каталоге. Имена файлов в шестнадцатеричном формате.</target>
        </trans-unit>
        <trans-unit id="8c66ea914339b5b34a8487aab28576ebc5ca45da" translate="yes" xml:space="preserve">
          <source>A savepoint is a special mark inside a transaction that allows all commands that are executed after it was established to be rolled back, restoring the transaction state to what it was at the time of the savepoint.</source>
          <target state="translated">Точка сохранения-это специальная метка внутри транзакции,позволяющая откатиться назад всем командам,которые выполняются после ее установления,восстанавливая состояние транзакции до того,каким оно было в момент точки сохранения.</target>
        </trans-unit>
        <trans-unit id="7568eb3ea7434ae7b0d16a00f453676381b783a8" translate="yes" xml:space="preserve">
          <source>A scalar subquery</source>
          <target state="translated">Скалярный подзапрос</target>
        </trans-unit>
        <trans-unit id="81af8f2f005c91eb2539d9bedb25765441d8772a" translate="yes" xml:space="preserve">
          <source>A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt; for other expressions involving subqueries.</source>
          <target state="translated">Скалярный подзапрос - это обычный запрос &lt;code&gt;SELECT&lt;/code&gt; в круглых скобках, который возвращает ровно одну строку с одним столбцом. ( Информацию о написании запросов см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;главе 7.&lt;/a&gt; ) &lt;code&gt;SELECT&lt;/code&gt; запрос SELECT, и единственное возвращаемое значение используется в выражении окружающего значения. Ошибочно использовать запрос, который возвращает более одной строки или более одного столбца в качестве скалярного подзапроса. (Но если во время определенного выполнения подзапрос не возвращает строк, ошибки нет; скалярный результат принимается равным нулю.) Подзапрос может ссылаться на переменные из окружающего запроса, которые будут действовать как константы во время любой оценки. подзапроса. См. Также &lt;a href=&quot;functions-subquery&quot;&gt;Раздел 9.22&lt;/a&gt; о других выражениях, включающих подзапросы.</target>
        </trans-unit>
        <trans-unit id="e0ba5f6cf2c1fcbf75fbd9fbfb66a812b9004a7f" translate="yes" xml:space="preserve">
          <source>A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt; for other expressions involving subqueries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22189bcf116df43b441c919d8d32eb0f9603b0c4" translate="yes" xml:space="preserve">
          <source>A scan key is the internal representation of a &lt;code&gt;WHERE&lt;/code&gt; clause of the form &lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;, where the index key is one of the columns of the index and the operator is one of the members of the operator family associated with that index column. An index scan has zero or more scan keys, which are implicitly ANDed &amp;mdash; the returned tuples are expected to satisfy all the indicated conditions.</source>
          <target state="translated">Одним из ключевого сканирования является внутренним представлением &lt;code&gt;WHERE&lt;/code&gt; п формы &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; , где ключ индекса является одним из столбцов индекса и оператор является одним из членов семьи оператора , связанная с этим колонками. Сканирование индекса имеет ноль или более ключей сканирования, которые неявно объединены AND - возвращаемые кортежи должны удовлетворять всем указанным условиям.</target>
        </trans-unit>
        <trans-unit id="f42378ba798baf455e1545f6ed59407d2afa77b9" translate="yes" xml:space="preserve">
          <source>A schema can only be dropped by its owner or a superuser. Note that the owner can drop the schema (and thereby all contained objects) even if they do not own some of the objects within the schema.</source>
          <target state="translated">Схему может бросить только ее владелец или суперпользователь.Обратите внимание,что владелец может отбросить схему (и тем самым все содержащиеся в ней объекты),даже если он не владеет некоторыми из объектов в схеме.</target>
        </trans-unit>
        <trans-unit id="254b4940dad1d633556557588b281f41f26bbd38" translate="yes" xml:space="preserve">
          <source>A schema is a namespace for &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt;, which all reside in the same &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;. Each SQL object must reside in exactly one schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6403de1aa8d8ec1e90672c217c0a1e9ee16c135" translate="yes" xml:space="preserve">
          <source>A schema is essentially a namespace: it contains named objects (tables, data types, functions, and operators) whose names can duplicate those of other objects existing in other schemas. Named objects are accessed either by &amp;ldquo;qualifying&amp;rdquo; their names with the schema name as a prefix, or by setting a search path that includes the desired schema(s). A &lt;code&gt;CREATE&lt;/code&gt; command specifying an unqualified object name creates the object in the current schema (the one at the front of the search path, which can be determined with the function &lt;code&gt;current_schema&lt;/code&gt;).</source>
          <target state="translated">Схема - это, по сути, пространство имен: она содержит именованные объекты (таблицы, типы данных, функции и операторы), имена которых могут дублировать имена других объектов, существующих в других схемах. Доступ к именованным объектам осуществляется либо путем &amp;laquo;уточнения&amp;raquo; их имен с помощью имени схемы в качестве префикса, либо путем установки пути поиска, который включает желаемую схему (схемы). Команда &lt;code&gt;CREATE&lt;/code&gt; , указывающая неквалифицированное имя объекта, создает объект в текущей схеме (той, которая находится в &lt;code&gt;current_schema&lt;/code&gt; пути поиска, который можно определить с помощью функции current_schema ).</target>
        </trans-unit>
        <trans-unit id="896efd5a8d00dc02d53497ffb75c3ac39fb5a4a6" translate="yes" xml:space="preserve">
          <source>A script file contains one or more SQL commands terminated by semicolons. Empty lines and lines beginning with &lt;code&gt;--&lt;/code&gt; are ignored. Script files can also contain &amp;ldquo;meta commands&amp;rdquo;, which are interpreted by pgbench itself, as described below.</source>
          <target state="translated">Файл сценария содержит одну или несколько команд SQL, заканчивающихся точкой с запятой. Пустые строки и строки, начинающиеся с &lt;code&gt;--&lt;/code&gt; игнорируются. Файлы сценариев также могут содержать &amp;laquo;мета-команды&amp;raquo;, которые интерпретируются самим pgbench, как описано ниже.</target>
        </trans-unit>
        <trans-unit id="c4717af9b4226f3b00d724aebfdacf0ab19f7c65" translate="yes" xml:space="preserve">
          <source>A second database, &lt;code&gt;template1&lt;/code&gt;, is also created during database cluster initialization. Whenever a new database is created within the cluster, &lt;code&gt;template1&lt;/code&gt; is essentially cloned. This means that any changes you make in &lt;code&gt;template1&lt;/code&gt; are propagated to all subsequently created databases. Because of this, avoid creating objects in &lt;code&gt;template1&lt;/code&gt; unless you want them propagated to every newly created database. More details appear in &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">Вторая база данных, &lt;code&gt;template1&lt;/code&gt; , также создается во время инициализации кластера базы данных. Каждый раз, когда в кластере создается новая база данных, &lt;code&gt;template1&lt;/code&gt; по существу клонируется. Это означает, что любые изменения, внесенные в &lt;code&gt;template1&lt;/code&gt; , распространяются на все впоследствии созданные базы данных. По этой причине избегайте создания объектов в &lt;code&gt;template1&lt;/code&gt; , если вы не хотите, чтобы они распространялись на каждую вновь созданную базу данных. Более подробная информация представлена ​​в &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Разделе 22.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0553fb63d3a8d00dba1af17146ccb321bca9edc" translate="yes" xml:space="preserve">
          <source>A separator (a space or non-letter/non-digit character) in the template string of &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt; matches any single separator in the input string or is skipped, unless the &lt;code&gt;FX&lt;/code&gt; option is used. For example, &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; work, but &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; returns an error because the number of separators in the input string exceeds the number of separators in the template.</source>
          <target state="translated">Разделитель (пробел или &lt;code&gt;to_timestamp&lt;/code&gt; / нецифровой символ) в строке шаблона to_timestamp и &lt;code&gt;to_date&lt;/code&gt; соответствует любому одиночному разделителю во входной строке или пропускается, если не используется опция &lt;code&gt;FX&lt;/code&gt; . Например, &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; и &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; работают, но &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; возвращает ошибка, потому что количество разделителей во входной строке превышает количество разделителей в шаблоне.</target>
        </trans-unit>
        <trans-unit id="11592b154f9e554cd84c7343d4d02f52f502b436" translate="yes" xml:space="preserve">
          <source>A sequential scan over this large table takes a long time:</source>
          <target state="translated">Последовательное сканирование этого большого стола занимает много времени:</target>
        </trans-unit>
        <trans-unit id="79af3c162f9318c384ae01ff487ce072e1768dfe" translate="yes" xml:space="preserve">
          <source>A sequential scan will always necessitate a relation-level predicate lock. This can result in an increased rate of serialization failures. It may be helpful to encourage the use of index scans by reducing &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; and/or increasing &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;. Be sure to weigh any decrease in transaction rollbacks and restarts against any overall change in query execution time.</source>
          <target state="translated">Последовательное сканирование всегда требует блокировки предиката на уровне отношений. Это может привести к увеличению количества сбоев сериализации. Может быть полезно поощрять использование сканирования индекса, уменьшая &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; и / или увеличивая &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt; . Обязательно сопоставьте любое уменьшение количества откатов и перезапусков транзакций с любым общим изменением времени выполнения запроса.</target>
        </trans-unit>
        <trans-unit id="c996ff6e0403a4fb8e72d039c933ec1c36020db2" translate="yes" xml:space="preserve">
          <source>A series of documents that define the SQL language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfa1c21333697528077114ccbfbc09a0f9f978f" translate="yes" xml:space="preserve">
          <source>A serious limitation of the inheritance feature is that indexes (including unique constraints) and foreign key constraints only apply to single tables, not to their inheritance children. This is true on both the referencing and referenced sides of a foreign key constraint. Thus, in the terms of the above example:</source>
          <target state="translated">Серьезным ограничением функции наследования является то,что индексы (включая уникальные ограничения)и ограничения по иностранным ключам применимы только к отдельным таблицам,а не к их детям-наследникам.Это справедливо как для стороны,на которую ссылаются,так и для стороны,на которую ссылаются ограничения постороннего ключа.Таким образом,с точки зрения приведенного выше примера:</target>
        </trans-unit>
        <trans-unit id="b2bd01559e686b7857df249c11b785bd65be39d9" translate="yes" xml:space="preserve">
          <source>A server process, which manages the database files, accepts connections to the database from client applications, and performs database actions on behalf of the clients. The database server program is called &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">Серверный процесс, который управляет файлами базы данных, принимает подключения к базе данных от клиентских приложений и выполняет действия с базой данных от имени клиентов. Программа сервера базы данных называется &lt;code&gt;postgres&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eda9a27048331b66fd1707531a40ce77f3ddd8c9" translate="yes" xml:space="preserve">
          <source>A session can be unregistered for a given notification channel with the &lt;code&gt;UNLISTEN&lt;/code&gt; command. A session's listen registrations are automatically cleared when the session ends.</source>
          <target state="translated">Сессию можно &lt;code&gt;UNLISTEN&lt;/code&gt; регистрацию для данного канала уведомлений с помощью команды UNLISTEN . Регистрация прослушивания сеанса автоматически очищается по окончании сеанса.</target>
        </trans-unit>
        <trans-unit id="2159dca873e4422248b8b886c40fce3f04eaaa4b" translate="yes" xml:space="preserve">
          <source>A session running a &lt;code id=&quot;serializable&quot;&gt;SERIALIZABLE&lt;/code&gt; transaction blocks a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction from acquiring a snapshot until the latter determines that it is safe to avoid taking any predicate locks. See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; for more information about serializable and deferrable transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b584c1806aab227b279342fcda898366eb0bc1" translate="yes" xml:space="preserve">
          <source>A session will allocate temporary buffers as needed up to the limit given by &lt;code&gt;temp_buffers&lt;/code&gt;. The cost of setting a large value in sessions that do not actually need many temporary buffers is only a buffer descriptor, or about 64 bytes, per increment in &lt;code&gt;temp_buffers&lt;/code&gt;. However if a buffer is actually used an additional 8192 bytes will be consumed for it (or in general, &lt;code&gt;BLCKSZ&lt;/code&gt; bytes).</source>
          <target state="translated">Сеанс будет выделять временные буферы по мере необходимости до предела, заданного &lt;code&gt;temp_buffers&lt;/code&gt; . Стоимость установки большого значения в сеансах, которые на самом деле не требуют большого количества временных буферов, - это только дескриптор буфера или около 64 байтов на приращение в &lt;code&gt;temp_buffers&lt;/code&gt; . Однако, если буфер фактически используется, для него будут потреблены дополнительные 8192 байта (или, как &lt;code&gt;BLCKSZ&lt;/code&gt; байты BLCKSZ ).</target>
        </trans-unit>
        <trans-unit id="1986f4a7eb9ec7c322dfb6c9c6e1924b057be9e0" translate="yes" xml:space="preserve">
          <source>A set of background processes that routinely perform &lt;a href=&quot;glossary#GLOSSARY-VACUUM&quot;&gt;vacuum&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-ANALYZE&quot;&gt;analyze&lt;/a&gt; operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d05cbafd4652352f5f70c34a9c2c9722aea37c" translate="yes" xml:space="preserve">
          <source>A set of functions and function-like expressions are available for producing XML content from SQL data. As such, they are particularly suitable for formatting query results into XML documents for processing in client applications.</source>
          <target state="translated">Для получения XML-контента из данных SQL доступен набор функций и функциональноподобных выражений.Как таковые,они особенно подходят для форматирования результатов запросов в XML-документы для обработки в клиентских приложениях.</target>
        </trans-unit>
        <trans-unit id="db5cffdfcc14ae057b50bf32801b87510be72218" translate="yes" xml:space="preserve">
          <source>A set of functions and function-like expressions is available for producing XML content from SQL data. As such, they are particularly suitable for formatting query results into XML documents for processing in client applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675287b9d3c5bb2ab0654e84d04004c09628b2e2" translate="yes" xml:space="preserve">
          <source>A shorthand notation is provided for specifying two common types of grouping set. A clause of the form</source>
          <target state="translated">Для указания двух общих типов набора группировок предусмотрена короткая запись.Пункт формы</target>
        </trans-unit>
        <trans-unit id="4eb84b728058fd55ea25770f3f034fccfd80efda" translate="yes" xml:space="preserve">
          <source>A shorthand version of &lt;code&gt;get_raw_page&lt;/code&gt;, for reading from the main fork. Equivalent to &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</source>
          <target state="translated">Сокращенная версия &lt;code&gt;get_raw_page&lt;/code&gt; для чтения из основной вилки. Эквивалентно &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf3b68bae267e9ec8dc713868f0cc42a385b1b59" translate="yes" xml:space="preserve">
          <source>A sign formatted using &lt;code&gt;SG&lt;/code&gt;, &lt;code&gt;PL&lt;/code&gt;, or &lt;code&gt;MI&lt;/code&gt; is not anchored to the number; for example, &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; produces &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; but &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; produces &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt;. (The Oracle implementation does not allow the use of &lt;code&gt;MI&lt;/code&gt; before &lt;code&gt;9&lt;/code&gt;, but rather requires that &lt;code&gt;9&lt;/code&gt; precede &lt;code&gt;MI&lt;/code&gt;.)</source>
          <target state="translated">Знак, отформатированный с использованием &lt;code&gt;SG&lt;/code&gt; , &lt;code&gt;PL&lt;/code&gt; или &lt;code&gt;MI&lt;/code&gt; , не привязан к номеру; например, &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; дает &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; а &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; дает &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt; . (Реализация Oracle не позволяет использовать &lt;code&gt;MI&lt;/code&gt; до &lt;code&gt;9&lt;/code&gt; , а требует, чтобы &lt;code&gt;9&lt;/code&gt; предшествовало &lt;code&gt;MI&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="28f22335db260bb1a77d3874ff5a159c8ea0367a" translate="yes" xml:space="preserve">
          <source>A signature is a lossy representation of the indexed attribute(s), and as such is prone to reporting false positives; that is, it may be reported that an element is in the set, when it is not. So index search results must always be rechecked using the actual attribute values from the heap entry. Larger signatures reduce the odds of a false positive and thus reduce the number of useless heap visits, but of course also make the index larger and hence slower to scan.</source>
          <target state="translated">Сигнатура-это убыточное представление индексируемого атрибута (атрибутов),и как таковая склонна сообщать о ложных срабатываниях,то есть может быть сообщено о том,что элемент находится в наборе,когда его нет.Поэтому результаты индексированного поиска всегда должны быть перепроверены с использованием действительных значений атрибута из кучи записей.Большие сигнатуры уменьшают шансы ложного срабатывания и,таким образом,уменьшают количество бесполезных посещений кучи,но,конечно же,делают индекс больше и,следовательно,медленнее сканировать.</target>
        </trans-unit>
        <trans-unit id="32035573077f021fbb97ad61e501af43e164ab91" translate="yes" xml:space="preserve">
          <source>A similar approach is used in most non-fiction books: terms and concepts that are frequently looked up by readers are collected in an alphabetic index at the end of the book. The interested reader can scan the index relatively quickly and flip to the appropriate page(s), rather than having to read the entire book to find the material of interest. Just as it is the task of the author to anticipate the items that readers are likely to look up, it is the task of the database programmer to foresee which indexes will be useful.</source>
          <target state="translated">Аналогичный подход используется в большинстве нехудожественных книг:термины и понятия,которые часто просматриваются читателями,собираются в алфавитном указателе в конце книги.Заинтересованный читатель может относительно быстро отсканировать указатель и перевернуть его на соответствующую страницу (страницы),вместо того,чтобы читать всю книгу,чтобы найти интересующий его материал.Точно так же,как задача автора-предвидеть,какие материалы читатель скорее всего будет искать,так и задача программиста базы данных-предугадать,какие индексы будут полезны.</target>
        </trans-unit>
        <trans-unit id="0ce67715832ac88218d019874223da06f72da1b1" translate="yes" xml:space="preserve">
          <source>A similar command will be generated for each new file to be archived.</source>
          <target state="translated">Аналогичная команда будет генерироваться для каждого нового архивируемого файла.</target>
        </trans-unit>
        <trans-unit id="3786a908833219f288eb01ce7bf3707543bec989" translate="yes" xml:space="preserve">
          <source>A similar problem occurs with estimation of the cardinality of sets of multiple columns, such as the number of groups that would be generated by a &lt;code&gt;GROUP BY&lt;/code&gt; clause. When &lt;code&gt;GROUP BY&lt;/code&gt; lists a single column, the n-distinct estimate (which is visible as the estimated number of rows returned by the HashAggregate node) is very accurate:</source>
          <target state="translated">Аналогичная проблема возникает с оценкой количества элементов наборов из нескольких столбцов, например количества групп, которые будут созданы с помощью предложения &lt;code&gt;GROUP BY&lt;/code&gt; . Когда &lt;code&gt;GROUP BY&lt;/code&gt; перечисляет один столбец, оценка, состоящая из n различных (которая отображается как приблизительное количество строк, возвращаемых узлом HashAggregate), очень точна:</target>
        </trans-unit>
        <trans-unit id="5d9a6505729509f95a09312b10bc6d90c22cf17c" translate="yes" xml:space="preserve">
          <source>A similar result could be accomplished with a join:</source>
          <target state="translated">Аналогичный результат может быть достигнут с помощью соединения:</target>
        </trans-unit>
        <trans-unit id="37fd7a4a35913776332656300b6e6e873ef35bb0" translate="yes" xml:space="preserve">
          <source>A simple GIN index on the &lt;code&gt;jdoc&lt;/code&gt; column can support this query. But note that such an index will store copies of every key and value in the &lt;code&gt;jdoc&lt;/code&gt; column, whereas the expression index of the previous example stores only data found under the &lt;code&gt;tags&lt;/code&gt; key. While the simple-index approach is far more flexible (since it supports queries about any key), targeted expression indexes are likely to be smaller and faster to search than a simple index.</source>
          <target state="translated">Простой индекс GIN в столбце &lt;code&gt;jdoc&lt;/code&gt; может поддерживать этот запрос. Но обратите внимание, что такой индекс будет хранить копии каждого ключа и значения в столбце &lt;code&gt;jdoc&lt;/code&gt; , тогда как индекс выражения в предыдущем примере хранит только данные, найденные под ключом &lt;code&gt;tags&lt;/code&gt; . Хотя подход простого индекса является гораздо более гибким (поскольку он поддерживает запросы по любому ключу), целевые индексы выражения, вероятно, будут меньше и быстрее для поиска, чем простой индекс.</target>
        </trans-unit>
        <trans-unit id="1dca6bdccd192c38f7d0a54b1d6c641ecfc4dd07" translate="yes" xml:space="preserve">
          <source>A simple aggregate function is made from one or two ordinary functions: a state transition function &lt;code&gt;sfunc&lt;/code&gt;, and an optional final calculation function &lt;code&gt;ffunc&lt;/code&gt;. These are used as follows:</source>
          <target state="translated">Простая агрегатная функция состоит из одной или двух обычных функций: функции перехода состояний &lt;code&gt;sfunc&lt;/code&gt; и дополнительной функции окончательного вычисления &lt;code&gt;ffunc&lt;/code&gt; . Они используются следующим образом:</target>
        </trans-unit>
        <trans-unit id="92c5b995463bf0dd676bdb47c7d11c8b07e323eb" translate="yes" xml:space="preserve">
          <source>A simple example of configuration is:</source>
          <target state="translated">Простой пример настройки:</target>
        </trans-unit>
        <trans-unit id="0929a1c1d2dae1cb142a133fc2a8d2f50ec36161" translate="yes" xml:space="preserve">
          <source>A simple example of these rules is</source>
          <target state="translated">Простой пример этих правил</target>
        </trans-unit>
        <trans-unit id="a7391df0d455f9692788470d09f0d785e12ddd80" translate="yes" xml:space="preserve">
          <source>A simple kind of query has the form:</source>
          <target state="translated">Простой вид запроса имеет форму:</target>
        </trans-unit>
        <trans-unit id="e9cf93d0e888ede997ab50815543f2f23545f52a" translate="yes" xml:space="preserve">
          <source>A single index scan can only use query clauses that use the index's columns with operators of its operator class and are joined with &lt;code&gt;AND&lt;/code&gt;. For example, given an index on &lt;code&gt;(a, b)&lt;/code&gt; a query condition like &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; could use the index, but a query like &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; could not directly use the index.</source>
          <target state="translated">Одно сканирование индекса может использовать только те предложения запроса, которые используют столбцы индекса с операторами его класса операторов и соединяются с помощью &lt;code&gt;AND&lt;/code&gt; . Например, с учетом индекса на &lt;code&gt;(a, b)&lt;/code&gt; условие запроса, такое как &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; может использовать индекс, но запрос типа &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; не может напрямую использовать индекс.</target>
        </trans-unit>
        <trans-unit id="867794d10e104f13c9e8cf27b9206d3b607f31d5" translate="yes" xml:space="preserve">
          <source>A single operator is provided, shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;Table F.6&lt;/a&gt;.</source>
          <target state="translated">Предусмотрен один оператор, показанный в &lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;таблице F.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ecaee1e3e7fc4cc75092b8ce7abdaa9285ac3ce" translate="yes" xml:space="preserve">
          <source>A small number of objects, like role, database, and tablespace names, are defined at the cluster level and stored in the &lt;code&gt;pg_global&lt;/code&gt; tablespace. Inside the cluster are multiple databases, which are isolated from each other but can access cluster-level objects. Inside each database are multiple schemas, which contain objects like tables and functions. So the full hierarchy is: cluster, database, schema, table (or some other kind of object, such as a function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b58acc01d25d1802019308ca111c48a0d1dd06" translate="yes" xml:space="preserve">
          <source>A software add-on package that can be installed on an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; to get extra features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d707a25df7385c415429f55133f3338c29d9eb5" translate="yes" xml:space="preserve">
          <source>A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">Оператор сортировки. Подробности см. &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; разделе ORDER BY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d3b735b7f3eb84460aea32d14769c9c3214fb68" translate="yes" xml:space="preserve">
          <source>A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf7b59bf27af641775e9434a262775adcfc35c9" translate="yes" xml:space="preserve">
          <source>A special case of a &lt;a href=&quot;glossary#GLOSSARY-UNIQUE-CONSTRAINT&quot;&gt;unique constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that also guarantees that all of the &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; within the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;primary key&lt;/a&gt; do not have &lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null&lt;/a&gt; values. As the name implies, there can be only one primary key per table, though it is possible to have multiple unique constraints that also have no null-capable attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36087e3651816803cdd143451424471a45426ba" translate="yes" xml:space="preserve">
          <source>A special case that's sometimes useful is that &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; can be used to require that two patterns match the same word.</source>
          <target state="translated">Особый случай, который иногда бывает полезен, - это то, что &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; может использоваться для требования, чтобы два шаблона соответствовали одному и тому же слову.</target>
        </trans-unit>
        <trans-unit id="80f2af404248705306ef790e8642f0ac8c9028d1" translate="yes" xml:space="preserve">
          <source>A special heuristic is applied to determine whether a deduplication pass in a unique index should take place. It can often skip straight to splitting a leaf page, avoiding a performance penalty from wasting cycles on unhelpful deduplication passes. If you're concerned about the overhead of deduplication, consider setting &lt;code&gt;deduplicate_items = off&lt;/code&gt; selectively. Leaving deduplication enabled in unique indexes has little downside.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae37c740b6d35e6443717335fb07bf95869ce22" translate="yes" xml:space="preserve">
          <source>A special mark in the sequence of steps in a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt;. Data modifications after this point in time may be reverted to the time of the savepoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e32359cf0b0268eacae302550072c34383af98" translate="yes" xml:space="preserve">
          <source>A specialized process responsible for executing checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a70bf6435ed23a7c676143743be435f017bc889" translate="yes" xml:space="preserve">
          <source>A standby acting as both a receiver and a sender is known as a cascading standby. Standbys that are more directly connected to the master are known as upstream servers, while those standby servers further away are downstream servers. Cascading replication does not place limits on the number or arrangement of downstream servers, though each standby connects to only one upstream server which eventually links to a single master/primary server.</source>
          <target state="translated">Резервный режим,действующий как в качестве приемника,так и в качестве отправителя,известен как каскадный резервный режим.Резервные серверы,которые более непосредственно подключены к главному серверу,известны как восходящие серверы,в то время как те резервные серверы,которые находятся дальше,являются нисходящими серверами.Каскадная репликация не накладывает ограничений на количество или расположение последующих серверов,хотя каждый резервный подключается только к одному восходящему серверу,который в конечном итоге подключается к одному главному/основному серверу.</target>
        </trans-unit>
        <trans-unit id="94007c63f83c2bc9effa88a81f497e0678595186" translate="yes" xml:space="preserve">
          <source>A standby server can be implemented using file-based log shipping (&lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) or streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;), or a combination of both. For information on hot standby, see &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;.</source>
          <target state="translated">Резервный сервер может быть реализован с использованием файловой доставки журналов ( &lt;a href=&quot;warm-standby&quot;&gt;раздел 26.2&lt;/a&gt; ) или потоковой репликации (см. &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Раздел 26.2.5&lt;/a&gt; ) или их комбинации. Для получения информации о горячем резерве см. &lt;a href=&quot;hot-standby&quot;&gt;Раздел 26.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="326a3efd4c9e08bc49a95748f894324f178b3b88" translate="yes" xml:space="preserve">
          <source>A state that allows a client and a backend to interact, communicating over a &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb6647573ef74b2ae4f7352625efc1c166ad8a5" translate="yes" xml:space="preserve">
          <source>A statement can only see rows committed before it began. This is the default.</source>
          <target state="translated">Заявление может видеть только те строки,которые были сделаны до его начала.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="4a7d12fc82f3d9f19299237c20a3b225478fd75c" translate="yes" xml:space="preserve">
          <source>A statistics kind to be computed in this statistics object. Currently supported kinds are &lt;code&gt;ndistinct&lt;/code&gt;, which enables n-distinct statistics, &lt;code&gt;dependencies&lt;/code&gt;, which enables functional dependency statistics, and &lt;code&gt;mcv&lt;/code&gt; which enables most-common values lists. If this clause is omitted, all supported statistics kinds are included in the statistics object. For more information, see &lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;Section 14.2.2&lt;/a&gt; and &lt;a href=&quot;multivariate-statistics-examples&quot;&gt;Section 70.2&lt;/a&gt;.</source>
          <target state="translated">Вид статистики, вычисляемый в этом объекте статистики. В настоящее время поддерживаются следующие типы: &lt;code&gt;ndistinct&lt;/code&gt; , который включает n- разную статистику, &lt;code&gt;dependencies&lt;/code&gt; , который включает статистику функциональных зависимостей, и &lt;code&gt;mcv&lt;/code&gt; , который включает списки наиболее распространенных значений. Если это предложение опущено, в объект статистики включаются все поддерживаемые виды статистики. Для получения дополнительной информации см. &lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;Раздел 14.2.2&lt;/a&gt; и &lt;a href=&quot;multivariate-statistics-examples&quot;&gt;Раздел 70.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7afb9dfc5301530890be994c8fdaea740d424bc6" translate="yes" xml:space="preserve">
          <source>A storage structure that keeps metadata about each data page of a table's main fork. The free space map entry for each page stores the amount of free space that's available for future tuples, and is structured to be efficiently searched for available space for a new tuple of a given size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d5e9e679ad2ea336688f58c0cc38f17ebb2361" translate="yes" xml:space="preserve">
          <source>A storage structure that keeps metadata about each data page of a table's main fork. The visibility map entry for each page stores two bits: the first one (&lt;code&gt;all-visible&lt;/code&gt;) indicates that all tuples in the page are visible to all transactions. The second one (&lt;code&gt;all-frozen&lt;/code&gt;) indicates that all tuples in the page are marked frozen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069a72422c3cc6a607349a4e700ca343dee3bf3a" translate="yes" xml:space="preserve">
          <source>A stored array value can be enlarged by assigning to elements not already present. Any positions between those previously present and the newly assigned elements will be filled with nulls. For example, if array &lt;code&gt;myarray&lt;/code&gt; currently has 4 elements, it will have six elements after an update that assigns to &lt;code&gt;myarray[6]&lt;/code&gt;; &lt;code&gt;myarray[5]&lt;/code&gt; will contain null. Currently, enlargement in this fashion is only allowed for one-dimensional arrays, not multidimensional arrays.</source>
          <target state="translated">Сохраненное значение массива можно увеличить, присвоив его элементам, которых еще нет. Любые позиции между ранее присутствующими и вновь назначенными элементами будут заполнены нулями. Например, если массив &lt;code&gt;myarray&lt;/code&gt; в настоящее время имеет 4 элемента, он будет иметь шесть элементов после обновления, которое присваивается &lt;code&gt;myarray[6]&lt;/code&gt; ; &lt;code&gt;myarray[5]&lt;/code&gt; будет содержать ноль . В настоящее время такое расширение разрешено только для одномерных массивов, но не для многомерных массивов.</target>
        </trans-unit>
        <trans-unit id="dffe36d8e51b4ef2ab1fe0c1b3e201415f713820" translate="yes" xml:space="preserve">
          <source>A string constant defining the function; the meaning depends on the language. It can be an internal function name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">Строковая константа,определяющая функцию;значение зависит от языка.Это может быть имя внутренней функции,путь к объектному файлу,команда SQL или текст на процедурном языке.</target>
        </trans-unit>
        <trans-unit id="dbfdac594b047310ca108ad639b27f52bf3906ca" translate="yes" xml:space="preserve">
          <source>A string constant defining the procedure; the meaning depends on the language. It can be an internal procedure name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">Строковая константа,определяющая процедуру;значение зависит от языка.Это может быть внутреннее имя процедуры,путь к объектному файлу,команда SQL или текст на процедурном языке.</target>
        </trans-unit>
        <trans-unit id="f2a8b822478dd09960c81d58138d7e54120409b2" translate="yes" xml:space="preserve">
          <source>A string constant in SQL is an arbitrary sequence of characters bounded by single quotes (&lt;code&gt;'&lt;/code&gt;), for example &lt;code&gt;'This is a string'&lt;/code&gt;. To include a single-quote character within a string constant, write two adjacent single quotes, e.g., &lt;code&gt;'Dianne''s horse'&lt;/code&gt;. Note that this is &lt;em&gt;not&lt;/em&gt; the same as a double-quote character (&lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">Строковая константа в SQL - это произвольная последовательность символов, заключенная в одинарные кавычки ( &lt;code&gt;'&lt;/code&gt; ), например &lt;code&gt;'This is a string'&lt;/code&gt; . Чтобы включить в строковую константу символ одинарной кавычки, напишите две смежные одинарные кавычки, например, &lt;code&gt;'Dianne''s horse'&lt;/code&gt; . Обратите внимание, что это &lt;em&gt;не&lt;/em&gt; то же самое, что символ двойной кавычки ( &lt;code&gt;&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9740675c09c16dac87aea8ba937f0db10ddc9e95" translate="yes" xml:space="preserve">
          <source>A string literal representing the textual label associated with one value of an enum type.</source>
          <target state="translated">Строковый литерал,представляющий текстовую метку,связанную с одним значением типа перечисления.</target>
        </trans-unit>
        <trans-unit id="349698cab225818ce6aaeac8a591649416d8d5ab" translate="yes" xml:space="preserve">
          <source>A string of the form &lt;code&gt;&lt;em&gt;n&lt;/em&gt;$&lt;/code&gt; where &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; is the index of the argument to print. Index 1 means the first argument after &lt;em&gt;&lt;code&gt;formatstr&lt;/code&gt;&lt;/em&gt;. If the &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; is omitted, the default is to use the next argument in sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5b7ed5b9f283f907a7fca459d4258127f634e3" translate="yes" xml:space="preserve">
          <source>A string of the form &lt;code&gt;n$&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the index of the argument to print. Index 1 means the first argument after &lt;code&gt;formatstr&lt;/code&gt;. If the &lt;code&gt;position&lt;/code&gt; is omitted, the default is to use the next argument in sequence.</source>
          <target state="translated">Строка вида &lt;code&gt;n$&lt;/code&gt; где &lt;code&gt;n&lt;/code&gt; - индекс аргумента для печати. Индекс 1 означает первый аргумент после &lt;code&gt;formatstr&lt;/code&gt; . Если &lt;code&gt;position&lt;/code&gt; не указана, по умолчанию используется следующий аргумент в последовательности.</target>
        </trans-unit>
        <trans-unit id="ddfb60a35b54b4a543c700ebe6924626aa1923e3" translate="yes" xml:space="preserve">
          <source>A string-like syntax is used for working with string types and for working with complex extension types. Strings with unspecified type are matched with likely operator candidates.</source>
          <target state="translated">Синтаксис,подобный строковому,используется для работы со строковыми типами и для работы со сложными типами расширений.Строки с неопределенным типом сопоставляются с вероятными кандидатами операторов.</target>
        </trans-unit>
        <trans-unit id="1cc21b370e49b36cc3877fbc8b204fee390f5ba0" translate="yes" xml:space="preserve">
          <source>A sub-&lt;code&gt;SELECT&lt;/code&gt; can appear in the &lt;code&gt;FROM&lt;/code&gt; clause. This acts as though its output were created as a temporary table for the duration of this single &lt;code&gt;SELECT&lt;/code&gt; command. Note that the sub-&lt;code&gt;SELECT&lt;/code&gt; must be surrounded by parentheses, and an alias &lt;em&gt;must&lt;/em&gt; be provided for it. A &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command can also be used here.</source>
          <target state="translated">Подраздел &lt;code&gt;SELECT&lt;/code&gt; может появиться в предложении &lt;code&gt;FROM&lt;/code&gt; . Это действует так, как если бы его выходные данные были созданы как временная таблица на время выполнения этой единственной команды &lt;code&gt;SELECT&lt;/code&gt; . Обратите внимание , что суб- &lt;code&gt;SELECT&lt;/code&gt; должны быть заключены в круглые скобки, а псевдоним &lt;em&gt;должен&lt;/em&gt; быть предусмотрен для него. Здесь также можно использовать команду &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20d744869b3f288cd0f4b443c304ea51738904ae" translate="yes" xml:space="preserve">
          <source>A subquery can also be a &lt;code&gt;VALUES&lt;/code&gt; list:</source>
          <target state="translated">Подзапрос также может быть списком &lt;code&gt;VALUES&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="467730923a1355f01d0ecc067917a4e744b3c1af" translate="yes" xml:space="preserve">
          <source>A subscriber node may have multiple subscriptions if desired. It is possible to define multiple subscriptions between a single publisher-subscriber pair, in which case care must be taken to ensure that the subscribed publication objects don't overlap.</source>
          <target state="translated">При желании абонентский узел может иметь несколько подписок.Можно определить несколько подписок между одной парой издатель-подписчик,и в этом случае необходимо позаботиться о том,чтобы подписанные объекты публикации не пересекались.</target>
        </trans-unit>
        <trans-unit id="d3b9d35fca34aebbff75a223845b5323b4b90739" translate="yes" xml:space="preserve">
          <source>A subscripted expression</source>
          <target state="translated">Подписанное выражение</target>
        </trans-unit>
        <trans-unit id="e3de42d209ab44c2b82ef6de9aa6e4c065c039e8" translate="yes" xml:space="preserve">
          <source>A subscription can only be dropped by a superuser.</source>
          <target state="translated">От подписки может отказаться только суперпользователь.</target>
        </trans-unit>
        <trans-unit id="6aba51cc9b50b3a680d08e5aa1b132f7c7c53586" translate="yes" xml:space="preserve">
          <source>A substitute name for &lt;code&gt;table_name&lt;/code&gt;. When an alias is provided, it completely hides the actual name of the table. This is particularly useful when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; targets a table named &lt;code&gt;excluded&lt;/code&gt;, since that will otherwise be taken as the name of the special table representing rows proposed for insertion.</source>
          <target state="translated">Замещающее имя для &lt;code&gt;table_name&lt;/code&gt; . Когда предоставляется псевдоним, он полностью скрывает фактическое имя таблицы. Это особенно полезно, когда &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; нацелено на таблицу с именем &lt;code&gt;excluded&lt;/code&gt; , поскольку в противном случае это будет принято как имя специальной таблицы, представляющей строки, предлагаемые для вставки.</target>
        </trans-unit>
        <trans-unit id="1a3b95411aa0d3922856aa0c08c5b45d4d583913" translate="yes" xml:space="preserve">
          <source>A substitute name for the &lt;code&gt;FROM&lt;/code&gt; item containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example given &lt;code&gt;FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;SELECT&lt;/code&gt; must refer to this &lt;code&gt;FROM&lt;/code&gt; item as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table.</source>
          <target state="translated">Замещающее имя для элемента &lt;code&gt;FROM&lt;/code&gt; , содержащего псевдоним. Псевдоним используется для краткости или для устранения неоднозначности для самосоединений (когда одна и та же таблица сканируется несколько раз). Когда предоставляется псевдоним, он полностью скрывает фактическое имя таблицы или функции; например, если дан &lt;code&gt;FROM foo AS f&lt;/code&gt; , оставшаяся часть &lt;code&gt;SELECT&lt;/code&gt; должна ссылаться на этот элемент &lt;code&gt;FROM&lt;/code&gt; как на &lt;code&gt;f&lt;/code&gt; , а не &lt;code&gt;foo&lt;/code&gt; . Если записан псевдоним, список псевдонимов столбцов также может быть записан для предоставления замещающих имен для одного или нескольких столбцов таблицы.</target>
        </trans-unit>
        <trans-unit id="3b6a0087f5676053b92594d5853d2ef232106666" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;DELETE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Замещающее имя целевой таблицы. Когда предоставляется псевдоним, он полностью скрывает фактическое имя таблицы. Например, если &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt; , оставшаяся часть оператора &lt;code&gt;DELETE&lt;/code&gt; должна ссылаться на эту таблицу как на &lt;code&gt;f&lt;/code&gt; , а не &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c430b6c82238597e098d25669857d482151c353" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;UPDATE foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;UPDATE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Замещающее имя целевой таблицы. Когда предоставляется псевдоним, он полностью скрывает фактическое имя таблицы. Например, если &lt;code&gt;UPDATE foo AS f&lt;/code&gt; , оставшаяся часть оператора &lt;code&gt;UPDATE&lt;/code&gt; должна ссылаться на эту таблицу как на &lt;code&gt;f&lt;/code&gt; , а не &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79a0d38239253966494c7a744510fc637f363e29" translate="yes" xml:space="preserve">
          <source>A successful run will exit with status 0. Exit status 1 indicates static problems such as invalid command-line options. Errors during the run such as database errors or problems in the script will result in exit status 2. In the latter case, pgbench will print partial results.</source>
          <target state="translated">Успешный запуск завершится со статусом 0.Статус выхода 1 указывает на статические проблемы,такие как недействительные опции командной строки.Ошибки во время выполнения,такие как ошибки в базе данных или проблемы в скрипте,приведут к выходу со статусом 2.В последнем случае pgbench распечатает частичные результаты.</target>
        </trans-unit>
        <trans-unit id="81738814316428e9e33dbf3e06dfac5985eb834b" translate="yes" xml:space="preserve">
          <source>A superuser may override this check on a per-user-mapping basis by setting the user mapping option &lt;code&gt;password_required 'false'&lt;/code&gt;, e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a652a2bcf1b7844eb4e57bf495f13644006240" translate="yes" xml:space="preserve">
          <source>A synchronous replica receiving changes via logical decoding will work in the scope of a single database. Since, in contrast to that, &lt;em&gt;&lt;code&gt;synchronous_standby_names&lt;/code&gt;&lt;/em&gt; currently is server wide, this means this technique will not work properly if more than one database is actively used.</source>
          <target state="translated">Синхронная реплика, получающая изменения посредством логического декодирования, будет работать в рамках единой базы данных. Поскольку, в отличие от этого, &lt;em&gt; &lt;code&gt;synchronous_standby_names&lt;/code&gt; в&lt;/em&gt; настоящее время распространяется на весь сервер, это означает, что этот метод не будет работать должным образом, если активно используется более одной базы данных.</target>
        </trans-unit>
        <trans-unit id="53732038fc5add15dbcd0175e133d7a901f6ac5b" translate="yes" xml:space="preserve">
          <source>A synchronous standby can be a physical replication standby or a logical replication subscriber. It can also be any other physical or logical WAL replication stream consumer that knows how to send the appropriate feedback messages. Besides the built-in physical and logical replication systems, this includes special programs such as &lt;code&gt;pg_receivewal&lt;/code&gt; and &lt;code&gt;pg_recvlogical&lt;/code&gt; as well as some third-party replication systems and custom programs. Check the respective documentation for details on synchronous replication support.</source>
          <target state="translated">Синхронная резервная система может быть физической резервной репликацией или подписчиком логической репликации. Это также может быть любой другой физический или логический потребитель потока репликации WAL, который знает, как отправлять соответствующие сообщения обратной связи. Помимо встроенных систем физической и логической репликации, сюда входят специальные программы, такие как &lt;code&gt;pg_receivewal&lt;/code&gt; и &lt;code&gt;pg_recvlogical&lt;/code&gt; , а также некоторые сторонние системы репликации и пользовательские программы. Подробную информацию о поддержке синхронной репликации см. В соответствующей документации.</target>
        </trans-unit>
        <trans-unit id="ac835affae95f586b86b74d66f86a082fb9c7b5d" translate="yes" xml:space="preserve">
          <source>A table access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;table_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a pointer to a struct of type &lt;code&gt;TableAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the table access method. The return value needs to be of server lifetime, which is typically achieved by defining it as a &lt;code&gt;static const&lt;/code&gt; variable in global scope. The &lt;code&gt;TableAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, defines the behavior of the access method using callbacks. These callbacks are pointers to plain C functions and are not visible or callable at the SQL level. All the callbacks and their behavior is defined in the &lt;code&gt;TableAmRoutine&lt;/code&gt; structure (with comments inside the struct defining the requirements for callbacks). Most callbacks have wrapper functions, which are documented from the point of view of a user (rather than an implementor) of the table access method. For details, please refer to the &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt;&lt;code&gt;src/include/access/tableam.h&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">Должна быть объявлена ​​функция обработчика метода доступа к таблице, чтобы принимать единственный аргумент типа &lt;code&gt;internal&lt;/code&gt; и возвращать псевдотип &lt;code&gt;table_am_handler&lt;/code&gt; . Аргумент - это фиктивное значение, которое просто служит для предотвращения прямого вызова функций-обработчиков из команд SQL. Результатом функции должен быть указатель на структуру типа &lt;code&gt;TableAmRoutine&lt;/code&gt; , которая содержит все, что необходимо знать основному коду для использования метода доступа к таблице. Возвращаемое значение должно соответствовать времени жизни сервера, что обычно достигается путем определения его как &lt;code&gt;static const&lt;/code&gt; переменной в глобальной области видимости. Структура &lt;code&gt;TableAmRoutine&lt;/code&gt; , также называемая &lt;em&gt;структурой API&lt;/em&gt; метода доступа&lt;em&gt;&lt;/em&gt;, определяет поведение метода доступа с помощью обратных вызовов. Эти обратные вызовы являются указателями на простые функции C и не видны и не вызываются на уровне SQL. Все обратные вызовы и их поведение определены в структуре &lt;code&gt;TableAmRoutine&lt;/code&gt; (с комментариями внутри структуры, определяющими требования для обратных вызовов). Большинство обратных вызовов имеют функции-оболочки, которые документированы с точки зрения пользователя (а не разработчика) метода доступа к таблице. За подробностями обращайтесь к файлу &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt; &lt;code&gt;src/include/access/tableam.h&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="419d15e411a83cc5bd408b7d5b9d3b39c40e3df3" translate="yes" xml:space="preserve">
          <source>A table access method handler is declared to return &lt;code&gt;table_am_handler&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff995032ef85b617d95b6ca1e8cb93045b2fac9" translate="yes" xml:space="preserve">
          <source>A table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced by PostgreSQL, but it is usually best to follow it.</source>
          <target state="translated">Таблица может иметь максимум один первичный ключ.(Может быть любое количество уникальных и не нулевых ограничений,которые функционально почти одно и то же,но только один из них может быть идентифицирован как первичный ключ).Теория реляционной базы данных диктует,что каждая таблица должна иметь первичный ключ.Это правило не применяется PostgreSQL,но обычно лучше следовать ему.</target>
        </trans-unit>
        <trans-unit id="a5dd3a29c662f0d5a9fc9f1c03648ba7178abbb4" translate="yes" xml:space="preserve">
          <source>A table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure:</source>
          <target state="translated">Таблица может иметь более одного иностранного ключевого ограничения.Это используется для реализации много-многочисленных отношений между таблицами.Скажем,у вас есть таблицы о продуктах и заказах,но теперь вы хотите,чтобы в одном заказе было возможно много продуктов (чего не позволяла вышеприведенная структура).Вы можете использовать эту структуру таблиц:</target>
        </trans-unit>
        <trans-unit id="ea2feaef62849b073ab499dff5691a69fec6f5f4" translate="yes" xml:space="preserve">
          <source>A table can inherit from more than one parent table, in which case it has the union of the columns defined by the parent tables. Any columns declared in the child table's definition are added to these. If the same column name appears in multiple parent tables, or in both a parent table and the child's definition, then these columns are &amp;ldquo;merged&amp;rdquo; so that there is only one such column in the child table. To be merged, columns must have the same data types, else an error is raised. Inheritable check constraints and not-null constraints are merged in a similar fashion. Thus, for example, a merged column will be marked not-null if any one of the column definitions it came from is marked not-null. Check constraints are merged if they have the same name, and the merge will fail if their conditions are different.</source>
          <target state="translated">Таблица может наследовать более чем от одной родительской таблицы, и в этом случае она имеет объединение столбцов, определенных родительскими таблицами. К ним добавляются любые столбцы, объявленные в определении дочерней таблицы. Если одно и то же имя столбца появляется в нескольких родительских таблицах или в родительской таблице и в определении дочернего элемента, эти столбцы &amp;laquo;объединяются&amp;raquo;, так что в дочерней таблице есть только один такой столбец. Для объединения столбцы должны иметь одинаковые типы данных, иначе возникает ошибка. Унаследованные проверочные ограничения и ненулевые ограничения объединяются аналогичным образом. Таким образом, например, объединенный столбец будет помечен как ненулевой, если какое-либо из определений столбца, из которого он был получен, помечено как ненулевое. Проверочные ограничения объединяются, если они имеют одно и то же имя, и объединение не удастся, если их условия отличаются.</target>
        </trans-unit>
        <trans-unit id="b60ab6e47e92c777a5fb70888a73042517cd9738" translate="yes" xml:space="preserve">
          <source>A table cannot have more than 1600 columns. (In practice, the effective limit is usually lower because of tuple-length constraints.)</source>
          <target state="translated">Стол не может иметь более 1600 столбцов.(На практике эффективный предел обычно ниже из-за ограничений длины кортежа).</target>
        </trans-unit>
        <trans-unit id="d9a20219501c53fe0d9df9736a36bbb3c0e01830" translate="yes" xml:space="preserve">
          <source>A table expression allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and update expressions. This uses the same syntax as the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/a&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table as a &lt;code&gt;from_item&lt;/code&gt; unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_item&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9427796f4e0c19b3da10d1c29ad2a87a93a84b6f" translate="yes" xml:space="preserve">
          <source>A table expression allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This uses the same syntax as the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/a&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table as a &lt;code&gt;from_item&lt;/code&gt; unless you wish to set up a self-join (in which case it must appear with an alias in the &lt;code&gt;from_item&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d4dec2662223321ee541222a2fb74e1b35e9b6" translate="yes" xml:space="preserve">
          <source>A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</source>
          <target state="translated">Таблица в реляционной базе данных очень похожа на таблицу на бумаге: она состоит из строк и столбцов. Количество и порядок столбцов фиксированы, и каждый столбец имеет имя. Количество строк варьируется - оно отражает, сколько данных хранится в данный момент. SQL не дает никаких гарантий относительно порядка строк в таблице. При чтении таблицы строки будут отображаться в неопределенном порядке, если только сортировка не запрошена явно. Это рассматривается в &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;главе 7&lt;/a&gt; . Более того, SQL не назначает уникальные идентификаторы строкам, поэтому в таблице может быть несколько полностью идентичных строк. Это следствие математической модели, лежащей в основе SQL, но обычно нежелательно. Позже в этой главе мы увидим, как решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="d3a09d1c3ee1c32fce111e8e9a61e27e850dce55" translate="yes" xml:space="preserve">
          <source>A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7ed2eab9cf794fb325a1b40465300bd26db30b" translate="yes" xml:space="preserve">
          <source>A table reference can be a table name (possibly schema-qualified), or a derived table such as a subquery, a &lt;code&gt;JOIN&lt;/code&gt; construct, or complex combinations of these. If more than one table reference is listed in the &lt;code&gt;FROM&lt;/code&gt; clause, the tables are cross-joined (that is, the Cartesian product of their rows is formed; see below). The result of the &lt;code&gt;FROM&lt;/code&gt; list is an intermediate virtual table that can then be subject to transformations by the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses and is finally the result of the overall table expression.</source>
          <target state="translated">Ссылка на таблицу может быть именем таблицы (возможно, дополненной схемой) или производной таблицей, такой как подзапрос, конструкция &lt;code&gt;JOIN&lt;/code&gt; или их сложные комбинации. Если в предложении &lt;code&gt;FROM&lt;/code&gt; указано более одной ссылки на таблицу , таблицы соединяются перекрестно (то есть формируется декартово произведение их строк; см. Ниже). Результатом списка &lt;code&gt;FROM&lt;/code&gt; является промежуточная виртуальная таблица, которая затем может подвергаться преобразованиям с помощью &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; и &lt;code&gt;HAVING&lt;/code&gt; и, наконец, является результатом общего табличного выражения.</target>
        </trans-unit>
        <trans-unit id="8ea15f1133af85b529e072e262c881e0f91d10ea" translate="yes" xml:space="preserve">
          <source>A table that has columns with potentially large entries will have an associated &lt;em&gt;TOAST&lt;/em&gt; table, which is used for out-of-line storage of field values that are too large to keep in the table rows proper. &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; links from a table to its TOAST table, if any. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="translated">Таблица, в которой есть столбцы с потенциально большими записями, будет иметь связанную таблицу &lt;em&gt;TOAST&lt;/em&gt; , которая используется для &lt;em&gt;автономного&lt;/em&gt; хранения значений полей, которые слишком велики для хранения в строках таблицы. &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;reltoastrelid&lt;/code&gt; ссылается на таблицу TOAST, если таковая имеется. См &lt;a href=&quot;storage-toast&quot;&gt;раздел 68.2&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="4c16bcd4cf40264715bc5e3b5d07ef4d9afb5816" translate="yes" xml:space="preserve">
          <source>A tablesample method handler is declared to return &lt;code&gt;tsm_handler&lt;/code&gt;.</source>
          <target state="translated">Объявлен обработчик метода &lt;code&gt;tsm_handler&lt;/code&gt; возвращающий tsm_handler .</target>
        </trans-unit>
        <trans-unit id="816a4cd8c0ed513824b7c88b1bb7cf4571478fb1" translate="yes" xml:space="preserve">
          <source>A tablespace allows superusers to define an alternative location on the file system where the data files containing database objects (such as tables and indexes) can reside.</source>
          <target state="translated">Пространство таблиц позволяет суперпользователям определить альтернативное место в файловой системе,где могут находиться файлы данных,содержащие объекты базы данных (такие как таблицы и индексы).</target>
        </trans-unit>
        <trans-unit id="820b586a949a1d02483ccf3a6e05f26f2fdbeced" translate="yes" xml:space="preserve">
          <source>A tablespace can only be dropped by its owner or a superuser. The tablespace must be empty of all database objects before it can be dropped. It is possible that objects in other databases might still reside in the tablespace even if no objects in the current database are using the tablespace. Also, if the tablespace is listed in the &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; setting of any active session, the &lt;code&gt;DROP&lt;/code&gt; might fail due to temporary files residing in the tablespace.</source>
          <target state="translated">Табличное пространство может быть удалено только его владельцем или суперпользователем. Табличное пространство должно быть пустым от всех объектов базы данных, прежде чем его можно будет отбросить. Возможно, что объекты в других базах данных все еще могут находиться в табличном пространстве, даже если никакие объекты в текущей базе данных не используют это табличное пространство. Кроме того, если табличное пространство указано в настройке &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; любого активного сеанса, &lt;code&gt;DROP&lt;/code&gt; может завершиться ошибкой из-за временных файлов, находящихся в табличном пространстве.</target>
        </trans-unit>
        <trans-unit id="d48bc9df0b7c8031d0790b2f1fc9c85172017b3e" translate="yes" xml:space="preserve">
          <source>A tablespace cannot be used independently of the cluster in which it is defined; see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="translated">Табличное пространство не может использоваться независимо от кластера, в котором оно определено; см. &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Раздел 22.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d579dc88e9cdf352d2f344d0841a4b50c6608379" translate="yes" xml:space="preserve">
          <source>A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt; and &lt;code&gt;effective_io_concurrency&lt;/code&gt;. Setting either value for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</source>
          <target state="translated">Параметр табличного пространства, который необходимо установить или сбросить. В настоящее время доступны только параметры &lt;code&gt;seq_page_cost&lt;/code&gt; , &lt;code&gt;random_page_cost&lt;/code&gt; и &lt;code&gt;effective_io_concurrency&lt;/code&gt; . Установка любого значения для определенного табличного пространства переопределит обычную оценку планировщиком стоимости чтения страниц из таблиц в этом табличном пространстве, как установлено одноименными параметрами конфигурации (см. &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;Seq_page_cost&lt;/a&gt; , &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; , &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt; ). Это может быть полезно, если одно табличное пространство расположено на диске, который работает быстрее или медленнее, чем остальная часть подсистемы ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="4c99f85ae41b2644b7b55fc1d2d2a8d62880eaa2" translate="yes" xml:space="preserve">
          <source>A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt;, &lt;code&gt;effective_io_concurrency&lt;/code&gt; and &lt;code&gt;maintenance_io_concurrency&lt;/code&gt;. Setting these values for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, and the executor's prefetching behavior, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-IO-CONCURRENCY&quot;&gt;maintenance_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ac97e0fad0b28b51a14115817e32577fe4a0b90" translate="yes" xml:space="preserve">
          <source>A temporary name can be given to tables and complex table references to be used for references to the derived table in the rest of the query. This is called a &lt;em&gt;table alias&lt;/em&gt;.</source>
          <target state="translated">Таблицам и сложным ссылкам на таблицы можно дать временное имя, которое будет использоваться для ссылок на производную таблицу в остальной части запроса. Это называется &lt;em&gt;псевдонимом таблицы&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="154e0fcec698de6b2015fa25f68088725ba8e1d2" translate="yes" xml:space="preserve">
          <source>A text search configuration binds a parser together with a set of dictionaries to process the parser's output tokens. For each token type that the parser can return, a separate list of dictionaries is specified by the configuration. When a token of that type is found by the parser, each dictionary in the list is consulted in turn, until some dictionary recognizes it as a known word. If it is identified as a stop word, or if no dictionary recognizes the token, it will be discarded and not indexed or searched for. Normally, the first dictionary that returns a non-&lt;code&gt;NULL&lt;/code&gt; output determines the result, and any remaining dictionaries are not consulted; but a filtering dictionary can replace the given word with a modified word, which is then passed to subsequent dictionaries.</source>
          <target state="translated">Конфигурация текстового поиска связывает синтаксический анализатор с набором словарей для обработки выходных токенов синтаксического анализатора. Для каждого типа токена, который может возвращать парсер, в конфигурации указывается отдельный список словарей. Когда синтаксический анализатор обнаруживает токен этого типа, он обращается к каждому словарю в списке по очереди, пока какой-либо словарь не распознает его как известное слово. Если он идентифицирован как стоп-слово или если никакой словарь не распознает токен, он будет отброшен и не будет проиндексирован или найден. Обычно результат определяет первый словарь, который возвращает результат, отличный от &lt;code&gt;NULL&lt;/code&gt; , и никакие оставшиеся словари не запрашиваются; но фильтрующий словарь может заменить данное слово измененным словом, которое затем передается в последующие словари.</target>
        </trans-unit>
        <trans-unit id="b660e99784a0c9ca392fa9c70b6890953f937efa" translate="yes" xml:space="preserve">
          <source>A text search configuration specifies all options necessary to transform a document into a &lt;code&gt;tsvector&lt;/code&gt;: the parser to use to break text into tokens, and the dictionaries to use to transform each token into a lexeme. Every call of &lt;code&gt;to_tsvector&lt;/code&gt; or &lt;code&gt;to_tsquery&lt;/code&gt; needs a text search configuration to perform its processing. The configuration parameter &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; specifies the name of the default configuration, which is the one used by text search functions if an explicit configuration parameter is omitted. It can be set in &lt;code&gt;postgresql.conf&lt;/code&gt;, or set for an individual session using the &lt;code&gt;SET&lt;/code&gt; command.</source>
          <target state="translated">Конфигурация текстового поиска определяет все параметры, необходимые для преобразования документа в &lt;code&gt;tsvector&lt;/code&gt; : синтаксический анализатор для разбиения текста на токены и словари для преобразования каждого токена в лексему. Каждый вызов &lt;code&gt;to_tsvector&lt;/code&gt; или &lt;code&gt;to_tsquery&lt;/code&gt; требует конфигурации текстового поиска для выполнения своей обработки. Параметр конфигурации &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; указывает имя конфигурации по умолчанию, которая используется функциями текстового поиска, если явный параметр конфигурации не указан. Его можно установить в &lt;code&gt;postgresql.conf&lt;/code&gt; или установить для отдельного сеанса с помощью команды &lt;code&gt;SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbb87e15ef4cfdfbfbbdeb4da5c6a41f2a086081" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary (sometimes abbreviated as TZ) is a collection of words that includes information about the relationships of words and phrases, i.e., broader terms (BT), narrower terms (NT), preferred terms, non-preferred terms, related terms, etc.</source>
          <target state="translated">Тезаурусный словарь (иногда сокращенно TZ)-это набор слов,включающий информацию о соотношениях слов и словосочетаний,т.е.более широкие термины (BT),более узкие термины (NT),предпочтительные термины,непочтительные термины,связанные термины и т.д.</target>
        </trans-unit>
        <trans-unit id="657570ff202cabc5e9df7f56f8f1f48bd50b5f6f" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary uses a &lt;em&gt;subdictionary&lt;/em&gt; (which is specified in the dictionary's configuration) to normalize the input text before checking for phrase matches. It is only possible to select one subdictionary. An error is reported if the subdictionary fails to recognize a word. In that case, you should remove the use of the word or teach the subdictionary about it. You can place an asterisk (&lt;code&gt;*&lt;/code&gt;) at the beginning of an indexed word to skip applying the subdictionary to it, but all sample words &lt;em&gt;must&lt;/em&gt; be known to the subdictionary.</source>
          <target state="translated">Словарь тезауруса использует &lt;em&gt;вложенный&lt;/em&gt; словарь (который указан в конфигурации словаря) для нормализации &lt;em&gt;вводимого&lt;/em&gt; текста перед проверкой совпадений фраз. Можно выбрать только один вложенный словарь. Сообщается об ошибке, если вспомогательный словарь не может распознать слово. В этом случае вам следует отказаться от использования этого слова или рассказать о нем во вспомогательном словаре. Вы можете поместить звездочку ( &lt;code&gt;*&lt;/code&gt; ) в начало проиндексированного слова, чтобы не применять к нему вспомогательный словарь, но все образцы слов &lt;em&gt;должны&lt;/em&gt; быть известны этому вспомогательному словарю.</target>
        </trans-unit>
        <trans-unit id="555f5a4dff77bb6e52e02e4204a9cef467ac2510" translate="yes" xml:space="preserve">
          <source>A third identifier type used by the system is &lt;code&gt;cid&lt;/code&gt;, or command identifier. This is the data type of the system columns &lt;code&gt;cmin&lt;/code&gt; and &lt;code&gt;cmax&lt;/code&gt;. Command identifiers are also 32-bit quantities.</source>
          <target state="translated">Третий тип идентификатора, используемый системой, - это &lt;code&gt;cid&lt;/code&gt; , или идентификатор команды. Это тип данных системных столбцов &lt;code&gt;cmin&lt;/code&gt; и &lt;code&gt;cmax&lt;/code&gt; . Идентификаторы команд также являются 32-битными величинами.</target>
        </trans-unit>
        <trans-unit id="ea6ae6aa8002700db2a8dea433bfc36222024c69" translate="yes" xml:space="preserve">
          <source>A third possible use for partial indexes does not require the index to be used in queries at all. The idea here is to create a unique index over a subset of a table, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;. This enforces uniqueness among the rows that satisfy the index predicate, without constraining those that do not.</source>
          <target state="translated">Третье возможное использование частичных индексов вообще не требует, чтобы индекс использовался в запросах. Идея здесь состоит в том, чтобы создать уникальный индекс для подмножества таблицы, как в &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Примере 11.3&lt;/a&gt; . Это обеспечивает уникальность среди строк, удовлетворяющих предикату индекса, без ограничения тех, которые не удовлетворяют.</target>
        </trans-unit>
        <trans-unit id="47db754740c9f2ded7d303bbef7ae69f38fb4dbf" translate="yes" xml:space="preserve">
          <source>A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt;. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6336e70f63a890b86a6cdbf6ec2c2a9832cb6d" translate="yes" xml:space="preserve">
          <source>A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt;. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition-date rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</source>
          <target state="translated">Аббревиатура часового пояса, например &lt;code&gt;PST&lt;/code&gt; . Такая спецификация просто определяет конкретное смещение от UTC, в отличие от полных имен часовых поясов, которые также могут подразумевать набор правил перехода на летнее время и даты перехода. &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; сокращения перечислены в представлении pg_timezone_abbrevs (см. &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Раздел 51.91&lt;/a&gt; ). Вы не можете установить для параметров конфигурации &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; или &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; сокращение часового пояса, но вы можете использовать сокращения во входных значениях даты / времени и с оператором &lt;code&gt;AT TIME ZONE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c1c7cede62c34481ae2c11f0263c23892006d69" translate="yes" xml:space="preserve">
          <source>A time zone cannot be specified when processing &lt;code&gt;timestamp without time zone&lt;/code&gt; or &lt;code&gt;interval&lt;/code&gt; inputs. These are always taken at face value.</source>
          <target state="translated">Часовой пояс нельзя указать при обработке &lt;code&gt;timestamp without time zone&lt;/code&gt; ввода часового пояса или &lt;code&gt;interval&lt;/code&gt; . Они всегда принимаются за чистую монету.</target>
        </trans-unit>
        <trans-unit id="f8aefcc9f6e4a3be95cca7cfd42df6a2625d531c" translate="yes" xml:space="preserve">
          <source>A timezone abbreviation file can contain blank lines and comments beginning with &lt;code&gt;#&lt;/code&gt;. Non-comment lines must have one of these formats:</source>
          <target state="translated">Файл аббревиатуры часового пояса может содержать пустые строки и комментарии, начинающиеся с &lt;code&gt;#&lt;/code&gt; . Строки без комментариев должны иметь один из следующих форматов:</target>
        </trans-unit>
        <trans-unit id="61f64c13915c0871a3186bb5a87ae1ae25b54733" translate="yes" xml:space="preserve">
          <source>A token can be a &lt;em&gt;key word&lt;/em&gt;, an &lt;em&gt;identifier&lt;/em&gt;, a &lt;em&gt;quoted identifier&lt;/em&gt;, a &lt;em&gt;literal&lt;/em&gt; (or constant), or a special character symbol. Tokens are normally separated by whitespace (space, tab, newline), but need not be if there is no ambiguity (which is generally only the case if a special character is adjacent to some other token type).</source>
          <target state="translated">Токен может быть &lt;em&gt;ключевым словом&lt;/em&gt; , &lt;em&gt;идентификатором&lt;/em&gt; , &lt;em&gt;идентификатором&lt;/em&gt; в &lt;em&gt;кавычках&lt;/em&gt; , &lt;em&gt;литералом&lt;/em&gt; (или константой) или специальным символьным символом. Токены обычно разделяются пробелом (пробел, табуляция, новая строка), но это не обязательно, если нет двусмысленности (что обычно имеет место только в том случае, если специальный символ находится рядом с каким-либо другим типом токена).</target>
        </trans-unit>
        <trans-unit id="8690158fd0b251c00dae6dfc7ede983456ddc45f" translate="yes" xml:space="preserve">
          <source>A token type emitted by the configuration's parser</source>
          <target state="translated">Тип токена,излучаемый синтаксическим анализатором конфигурации.</target>
        </trans-unit>
        <trans-unit id="c55f58174d7a27cababe64df945ac6699fb690f5" translate="yes" xml:space="preserve">
          <source>A transaction can also see its own statistics (as yet untransmitted to the collector) in the views &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt;, and &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt;. These numbers do not act as stated above; instead they update continuously throughout the transaction.</source>
          <target state="translated">Транзакция также может видеть свою собственную статистику (еще не переданную сборщику) в представлениях &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt; , &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt; , &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt; и &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt; . Эти числа не действуют так, как указано выше; вместо этого они постоянно обновляются на протяжении всей транзакции.</target>
        </trans-unit>
        <trans-unit id="014bab7370933e95d60b2fbeb6b4ddd7ac675ebb" translate="yes" xml:space="preserve">
          <source>A transaction can export more than one snapshot, if needed. Note that doing so is only useful in &lt;code&gt;READ COMMITTED&lt;/code&gt; transactions, since in &lt;code&gt;REPEATABLE READ&lt;/code&gt; and higher isolation levels, transactions use the same snapshot throughout their lifetime. Once a transaction has exported any snapshots, it cannot be prepared with &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7c34d636397a5326ca01bffe81c685d0466ea6" translate="yes" xml:space="preserve">
          <source>A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.</source>
          <target state="translated">Транзакция повторно выполняет запрос,возвращающий набор строк,удовлетворяющих условию поиска,и обнаруживает,что набор строк,удовлетворяющих условию,изменился в связи с другой недавно завершенной транзакцией.</target>
        </trans-unit>
        <trans-unit id="f8c2fd7479305ce91383c02d70969dd66b2acddb" translate="yes" xml:space="preserve">
          <source>A transaction re-reads data it has previously read and finds that data has been modified by another transaction (that committed since the initial read).</source>
          <target state="translated">Транзакция повторно считывает данные,которые она прочитала ранее,и обнаруживает,что данные были изменены другой транзакцией (которая была зафиксирована после первоначального прочтения).</target>
        </trans-unit>
        <trans-unit id="c3382e299466bb042feceee6752ca8ef0259c657" translate="yes" xml:space="preserve">
          <source>A transaction reads data written by a concurrent uncommitted transaction.</source>
          <target state="translated">Транзакция считывает данные,записанные параллельной нефиксированной транзакцией.</target>
        </trans-unit>
        <trans-unit id="f339f7f826bbe705459f4d6147b96402061e9382" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;LISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">Транзакция, которая выполнила &lt;code&gt;LISTEN&lt;/code&gt; , не может быть подготовлена ​​к двухфазной фиксации.</target>
        </trans-unit>
        <trans-unit id="3d0230fafa23fc125f62b605c5c7adbafb550941" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;NOTIFY&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">Транзакция, которая выполнила &lt;code&gt;NOTIFY&lt;/code&gt; , не может быть подготовлена ​​к двухфазной фиксации.</target>
        </trans-unit>
        <trans-unit id="6073bbb0958767b4f02cfd2e64c1259376f80a5e" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;UNLISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">Транзакция, которая выполнила &lt;code&gt;UNLISTEN&lt;/code&gt; , не может быть подготовлена ​​к двухфазной фиксации.</target>
        </trans-unit>
        <trans-unit id="fbb0eb006f978734fefdbee822c93e37ab76e793" translate="yes" xml:space="preserve">
          <source>A transform specifies how to adapt a data type to a procedural language. For example, when writing a function in PL/Python using the &lt;code&gt;hstore&lt;/code&gt; type, PL/Python has no prior knowledge how to present &lt;code&gt;hstore&lt;/code&gt; values in the Python environment. Language implementations usually default to using the text representation, but that is inconvenient when, for example, an associative array or a list would be more appropriate.</source>
          <target state="translated">Преобразование указывает, как адаптировать тип данных к процедурному языку. Например, при написании функции на PL / Python с использованием типа &lt;code&gt;hstore&lt;/code&gt; PL / Python не знает заранее, как представлять значения &lt;code&gt;hstore&lt;/code&gt; в среде Python. Реализации языка обычно по умолчанию используют текстовое представление, но это неудобно, когда, например, более подходящим будет ассоциативный массив или список.</target>
        </trans-unit>
        <trans-unit id="8c2b373e9fbb9296093271c1db45ed67d33a82b6" translate="yes" xml:space="preserve">
          <source>A transform specifies two functions:</source>
          <target state="translated">Преобразование определяет две функции:</target>
        </trans-unit>
        <trans-unit id="0c9fe367d63aa8028ded2402f8662551682fdc1d" translate="yes" xml:space="preserve">
          <source>A trigger function is declared to return &lt;code&gt;trigger.&lt;/code&gt;</source>
          <target state="translated">Объявлена ​​функция триггера для возврата &lt;code&gt;trigger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7aece537a33eef527a0311c288ac02d9c4de009" translate="yes" xml:space="preserve">
          <source>A trigger that is marked &lt;code&gt;FOR EACH ROW&lt;/code&gt; is called once for every row that the operation modifies. For example, a &lt;code&gt;DELETE&lt;/code&gt; that affects 10 rows will cause any &lt;code&gt;ON DELETE&lt;/code&gt; triggers on the target relation to be called 10 separate times, once for each deleted row. In contrast, a trigger that is marked &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; only executes once for any given operation, regardless of how many rows it modifies (in particular, an operation that modifies zero rows will still result in the execution of any applicable &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; triggers).</source>
          <target state="translated">Триггер, помеченный &lt;code&gt;FOR EACH ROW&lt;/code&gt; , вызывается один раз для каждой строки, изменяемой операцией. Например, &lt;code&gt;DELETE&lt;/code&gt; , затрагивающий 10 строк, приведет к тому, что любые триггеры &lt;code&gt;ON DELETE&lt;/code&gt; в целевом отношении будут вызываться 10 отдельных раз, по одному разу для каждой удаленной строки. Напротив, триггер, помеченный &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; , выполняется только один раз для любой данной операции, независимо от того, сколько строк он изменяет (в частности, операция, которая изменяет нулевые строки, все равно приведет к выполнению любых применимых триггеров &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="7eef7b97e3bd1ce7b7ee3cef5b1119d2228d0033" translate="yes" xml:space="preserve">
          <source>A trigram is a group of three consecutive characters taken from a string. We can measure the similarity of two strings by counting the number of trigrams they share. This simple idea turns out to be very effective for measuring the similarity of words in many natural languages.</source>
          <target state="translated">Триграмма-это группа из трех последовательных символов,взятых из строки.Мы можем измерить сходство двух строк,посчитав количество триграмм,которые они разделяют.Эта простая идея оказывается очень эффективной для измерения сходства слов во многих естественных языках.</target>
        </trans-unit>
        <trans-unit id="a08b1cdf2b0b095b9d5863bddf7e5d8e3d7c32c3" translate="yes" xml:space="preserve">
          <source>A trivial example of &lt;code&gt;LATERAL&lt;/code&gt; is</source>
          <target state="translated">Тривиальный пример &lt;code&gt;LATERAL&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e8e38ccfb8ee20281247054f727fc62c3822f6eb" translate="yes" xml:space="preserve">
          <source>A type cast</source>
          <target state="translated">Ликвидация типа</target>
        </trans-unit>
        <trans-unit id="3a3537ff39dd61d4d97ae8731a9b41e347a01f70" translate="yes" xml:space="preserve">
          <source>A type cast specifies a conversion from one data type to another. PostgreSQL accepts two equivalent syntaxes for type casts:</source>
          <target state="translated">Приведение типа указывает на преобразование одного типа данных в другой.PostgreSQL принимает два эквивалентных синтаксиса для приведения типов:</target>
        </trans-unit>
        <trans-unit id="191f8bc0dbd057f5d062293ad47b726e2c4bd97b" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which restricts the values allowed in one or a combination of columns so that each value or combination of values can only appear once in the relation &amp;mdash; that is, no other row in the relation contains values that are equal to those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47769c3fbebe762aaf5ca2f230501fed1e2e6077" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which restricts the values allowed in one or more &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt;. The check constraint can make reference to any attribute of the same row in the relation, but cannot reference other rows of the same relation or other relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0d1fa65cb5707a942beda0ba4cefcb538e80bc" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on one or more &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; in a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; which requires the value(s) in those &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; to identify zero or one &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;row&lt;/a&gt; in another (or, infrequently, the same) &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90f0d3baf2cdb5f8ece9a12f549c13ec0fed9a9" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; used in a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt; that applies to a &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;partition&lt;/a&gt; of the query's &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;result set&lt;/a&gt;; the function's result is based on values found in &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; of the same partition or frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5a2e79c8fc1633f97f91eb24cc9a0675c7c13b" translate="yes" xml:space="preserve">
          <source>A type of relation that is used to generate values. Typically the generated values are sequential non-repeating numbers. They are commonly used to generate surrogate &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;primary key&lt;/a&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c0d0a70cc72776a389a8d07d0b7fa59473f06b" translate="yes" xml:space="preserve">
          <source>A type of routine that receives zero or more arguments, returns zero or more output values, and is constrained to run within one transaction. Functions are invoked as part of a query, for example via &lt;code&gt;SELECT&lt;/code&gt;. Certain functions can return &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;sets&lt;/a&gt;; those are called &lt;em&gt;set-returning functions&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103d10d7e532eccef03717f65e1f2bc653ed5156" translate="yes" xml:space="preserve">
          <source>A type of routine. Their distinctive qualities are that they do not return values, and that they are allowed to make transactional statements such as &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;. They are invoked via the &lt;code&gt;CALL&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2685b870f0e5693341cc020b2215b601f4f13b60" translate="yes" xml:space="preserve">
          <source>A typical application of table aliases is to assign short identifiers to long table names to keep the join clauses readable. For example:</source>
          <target state="translated">Типичным применением псевдонимов таблиц является присвоение коротких идентификаторов длинным именам таблиц для сохранения читабельности объединенных пунктов.Например:</target>
        </trans-unit>
        <trans-unit id="53e9ce7093c6b3d709e92599c2e63f01a872a533" translate="yes" xml:space="preserve">
          <source>A typical cost estimator will proceed as follows:</source>
          <target state="translated">Типичный оценщик расходов будет действовать следующим образом:</target>
        </trans-unit>
        <trans-unit id="0dc6b779feedceaca26b9995072395fe22118094" translate="yes" xml:space="preserve">
          <source>A typical observed effect when this setting is on is that shared memory objects used for parallel query execution are removed at apparently random times, leading to errors and warnings while attempting to open and remove them, like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d74e530024da711c01ee4999c6bbacc75f1477" translate="yes" xml:space="preserve">
          <source>A typical observed effect when this setting is on is that the semaphore objects used by a PostgreSQL server are removed at apparently random times, leading to the server crashing with log messages like</source>
          <target state="translated">Типичный наблюдаемый эффект при такой настройке заключается в том,что семафорные объекты,используемые сервером PostgreSQL,удаляются в видимо случайное время,что приводит к аварийному завершению работы сервера с сообщениями в журнале,такими как</target>
        </trans-unit>
        <trans-unit id="3fc9f5b992a80655782589dd8a0df2c7a647d35a" translate="yes" xml:space="preserve">
          <source>A typical query that can use this index would be:</source>
          <target state="translated">Типичный запрос,который может использовать этот индекс:</target>
        </trans-unit>
        <trans-unit id="0521362e3f43575ffcfbc899da16b98a9800ce48" translate="yes" xml:space="preserve">
          <source>A typical use is in reading the current value of the sequence for an identity or serial column, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169a523c2d612c2511933ebb2897995bb069e2f2" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication origin. Should never leave the system.</source>
          <target state="translated">Уникальный,общекластерный идентификатор происхождения репликации.Никогда не должен покидать систему.</target>
        </trans-unit>
        <trans-unit id="47f21621fe9103c27d1085b3377ce1e6907d3fec" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication slot</source>
          <target state="translated">Уникальный,общекластерный идентификатор для слота репликации.</target>
        </trans-unit>
        <trans-unit id="5d4bfd425f4eb16bbefa46dacd068b22bd41528d" translate="yes" xml:space="preserve">
          <source>A useful property of &lt;code&gt;WITH&lt;/code&gt; queries is that they are normally evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling &lt;code&gt;WITH&lt;/code&gt; queries. Thus, expensive calculations that are needed in multiple places can be placed within a &lt;code&gt;WITH&lt;/code&gt; query to avoid redundant work. Another possible application is to prevent unwanted multiple evaluations of functions with side-effects. However, the other side of this coin is that the optimizer is not able to push restrictions from the parent query down into a multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query, since that might affect all uses of the &lt;code&gt;WITH&lt;/code&gt; query's output when it should affect only one. The multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query will be evaluated as written, without suppression of rows that the parent query might discard afterwards. (But, as mentioned above, evaluation might stop early if the reference(s) to the query demand only a limited number of rows.)</source>
          <target state="translated">Полезным свойством запросов &lt;code&gt;WITH&lt;/code&gt; является то, что они обычно оцениваются только один раз при выполнении родительского запроса, даже если на них ссылается более одного раза родительский запрос или запросы- родственники &lt;code&gt;WITH&lt;/code&gt; . Таким образом, в запрос &lt;code&gt;WITH&lt;/code&gt; можно поместить дорогостоящие вычисления, которые необходимы в нескольких местах, чтобы избежать лишней работы. Другое возможное применение - предотвращение нежелательных множественных вычислений функций с побочными эффектами. Однако другая сторона этой медали заключается в том, что оптимизатор не может перенести ограничения из родительского запроса вниз в запрос &lt;code&gt;WITH&lt;/code&gt; с множественными ссылками , поскольку это может повлиять на все виды использования вывода запроса &lt;code&gt;WITH&lt;/code&gt; , тогда как это должно повлиять только на одно. Многочисленные ссылки &lt;code&gt;WITH&lt;/code&gt; Запрос WITH будет оцениваться так, как он написан, без подавления строк, которые родительский запрос может впоследствии отбросить. (Но, как упоминалось выше, оценка может прекратиться раньше, если ссылка (и) на запрос требует только ограниченное количество строк.)</target>
        </trans-unit>
        <trans-unit id="46f8eb17a4dc6792884149cbde1b901dd618e58c" translate="yes" xml:space="preserve">
          <source>A user able to modify the schema of subscriber-side tables can execute arbitrary code as a superuser. Limit ownership and &lt;code&gt;TRIGGER&lt;/code&gt; privilege on such tables to roles that superusers trust. Moreover, if untrusted users can create tables, use only publications that list tables explicitly. That is to say, create a subscription &lt;code&gt;FOR ALL TABLES&lt;/code&gt; only when superusers trust every user permitted to create a non-temp table on the publisher or the subscriber.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624d70f8d00542243273d8f95b839148832783a9" translate="yes" xml:space="preserve">
          <source>A user can also be allowed to create objects in someone else's schema. To allow that, the &lt;code&gt;CREATE&lt;/code&gt; privilege on the schema needs to be granted. Note that by default, everyone has &lt;code&gt;CREATE&lt;/code&gt; and &lt;code&gt;USAGE&lt;/code&gt; privileges on the schema &lt;code&gt;public&lt;/code&gt;. This allows all users that are able to connect to a given database to create objects in its &lt;code&gt;public&lt;/code&gt; schema. Some &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;usage patterns&lt;/a&gt; call for revoking that privilege:</source>
          <target state="translated">Пользователю также может быть разрешено создавать объекты в чужой схеме. Для этого необходимо предоставить привилегию &lt;code&gt;CREATE&lt;/code&gt; для схемы. Обратите внимание, что по умолчанию у всех есть права &lt;code&gt;CREATE&lt;/code&gt; и &lt;code&gt;USAGE&lt;/code&gt; в схеме &lt;code&gt;public&lt;/code&gt; . Это позволяет всем пользователям, которые могут подключиться к данной базе данных, создавать объекты в ее &lt;code&gt;public&lt;/code&gt; схеме. Некоторые &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;шаблоны использования&lt;/a&gt; требуют отмены этой привилегии:</target>
        </trans-unit>
        <trans-unit id="b9aa765822babac771b767a7977f197f0cfd20dc" translate="yes" xml:space="preserve">
          <source>A user can only revoke privileges that were granted directly by that user. If, for example, user A has granted a privilege with grant option to user B, and user B has in turn granted it to user C, then user A cannot revoke the privilege directly from C. Instead, user A could revoke the grant option from user B and use the &lt;code&gt;CASCADE&lt;/code&gt; option so that the privilege is in turn revoked from user C. For another example, if both A and B have granted the same privilege to C, A can revoke their own grant but not B's grant, so C will still effectively have the privilege.</source>
          <target state="translated">Пользователь может отозвать только те привилегии, которые были ему предоставлены напрямую. Если, например, пользователь A предоставил привилегию с опцией предоставления пользователю B, а пользователь B, в свою очередь, предоставил ее пользователю C, то пользователь A не может отозвать привилегию непосредственно у C. Вместо этого пользователь A может отозвать опцию предоставления от пользователя B и используйте опцию &lt;code&gt;CASCADE&lt;/code&gt; , чтобы привилегия, в свою очередь, была отозвана у пользователя C. В другом примере, если и A, и B предоставили одну и ту же привилегию для C, A может отозвать свое собственное разрешение, но не разрешение B, поэтому C по-прежнему будет иметь привилегию.</target>
        </trans-unit>
        <trans-unit id="9eef0500388438dcdd883438e62adfff2b4c59d7" translate="yes" xml:space="preserve">
          <source>A user mapping, defined with &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;, is needed as well to identify the role that will be used on the remote server:</source>
          <target state="translated">Отображение пользователей, определенное с помощью &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt; , также необходимо для определения роли, которая будет использоваться на удаленном сервере:</target>
        </trans-unit>
        <trans-unit id="cd811596f6c21fd6820e0962c95748afb5dd8832" translate="yes" xml:space="preserve">
          <source>A user may perform &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, etc. on a column if they hold that privilege for either the specific column or its whole table. Granting the privilege at the table level and then revoking it for one column will not do what one might wish: the table-level grant is unaffected by a column-level operation.</source>
          <target state="translated">Пользователь может выполнить &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; и т. Д. Для столбца, если он обладает этой привилегией либо для конкретного столбца, либо для всей его таблицы. Предоставление привилегии на уровне таблицы, а затем ее отмена для одного столбца не приведет к желаемому результату: на грант на уровне таблицы не влияет операция на уровне столбца.</target>
        </trans-unit>
        <trans-unit id="8d16a3b790258dd6e7bcb147ac82c63396f9dabe" translate="yes" xml:space="preserve">
          <source>A user with appropriate privileges can pass &lt;code&gt;tablespace_name&lt;/code&gt; to &lt;code&gt;CREATE DATABASE&lt;/code&gt;, &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; to have the data files for these objects stored within the specified tablespace.</source>
          <target state="translated">Пользователь с соответствующими правами может передать &lt;code&gt;tablespace_name&lt;/code&gt; для &lt;code&gt;CREATE DATABASE&lt;/code&gt; , &lt;code&gt;CREATE TABLE&lt;/code&gt; , &lt;code&gt;CREATE INDEX&lt;/code&gt; или &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; иметь файлы данных для этих объектов , хранящихся в указанном табличном пространстве.</target>
        </trans-unit>
        <trans-unit id="cb5146129674511426d710b87f38fac56dd128fd" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no argument and returning type &lt;code&gt;event_trigger&lt;/code&gt;.</source>
          <target state="translated">Предоставляемая пользователем функция, объявленная как не принимающая аргументов и возвращающая тип &lt;code&gt;event_trigger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="944b09ef2e50c44bc480f5f428bf817a45e1996f" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no arguments and returning type &lt;code&gt;trigger&lt;/code&gt;, which is executed when the trigger fires.</source>
          <target state="translated">Предоставляемая пользователем функция, объявленная как не принимающая аргументов и возвращающая &lt;code&gt;trigger&lt;/code&gt; типа , которая выполняется при срабатывании триггера.</target>
        </trans-unit>
        <trans-unit id="3c03a8192bb8c460f615ba363c0076eb7beddfc8" translate="yes" xml:space="preserve">
          <source>A validator function would typically inspect the function body for syntactical correctness, but it can also look at other properties of the function, for example if the language cannot handle certain argument types. To signal an error, the validator function should use the &lt;code&gt;ereport()&lt;/code&gt; function. The return value of the function is ignored.</source>
          <target state="translated">Функция валидатора обычно проверяет тело функции на синтаксическую правильность, но она также может проверять другие свойства функции, например, если язык не может обрабатывать определенные типы аргументов. Чтобы сигнализировать об ошибке, функция валидатора должна использовать функцию &lt;code&gt;ereport()&lt;/code&gt; . Возвращаемое значение функции игнорируется.</target>
        </trans-unit>
        <trans-unit id="7bb559a62e1812965348b9dc25a132908d898b4a" translate="yes" xml:space="preserve">
          <source>A value (but not a key) can be an SQL &lt;code&gt;NULL&lt;/code&gt;. For example:</source>
          <target state="translated">Значение (но не ключ) может быть SQL &lt;code&gt;NULL&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="f11b15a75cd7fa69b386c1868dbf1a5bd1c71215" translate="yes" xml:space="preserve">
          <source>A value expression is one of the following:</source>
          <target state="translated">Выражение значения является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="15f463c504877012fea738b4b0d0b079a3d4f123" translate="yes" xml:space="preserve">
          <source>A value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types: &lt;code&gt;MATCH FULL&lt;/code&gt;, &lt;code&gt;MATCH PARTIAL&lt;/code&gt;, and &lt;code&gt;MATCH SIMPLE&lt;/code&gt; (which is the default). &lt;code&gt;MATCH FULL&lt;/code&gt; will not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null; if they are all null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH SIMPLE&lt;/code&gt; allows any of the foreign key columns to be null; if any of them are null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH PARTIAL&lt;/code&gt; is not yet implemented. (Of course, &lt;code&gt;NOT NULL&lt;/code&gt; constraints can be applied to the referencing column(s) to prevent these cases from arising.)</source>
          <target state="translated">Значение, вставленное в ссылочный столбец (столбцы), сопоставляется со значениями ссылочной таблицы и ссылочных столбцов с использованием данного типа сопоставления. Есть три типа соответствия: &lt;code&gt;MATCH FULL&lt;/code&gt; , &lt;code&gt;MATCH PARTIAL&lt;/code&gt; и &lt;code&gt;MATCH SIMPLE&lt;/code&gt; (который по умолчанию). &lt;code&gt;MATCH FULL&lt;/code&gt; не допускает, чтобы один столбец внешнего ключа из нескольких столбцов имел значение NULL, если только все столбцы внешнего ключа не имеют значения NULL; если все они равны нулю, строка не обязана иметь совпадение в указанной таблице. &lt;code&gt;MATCH SIMPLE&lt;/code&gt; позволяет любому столбцу внешнего ключа быть пустым; если какой-либо из них равен нулю, строка не обязательно должна иметь совпадение в указанной таблице. &lt;code&gt;MATCH PARTIAL&lt;/code&gt; пока не реализован. (Конечно, &lt;code&gt;NOT NULL&lt;/code&gt; к ссылочным столбцам могут быть применены ограничения, чтобы предотвратить возникновение таких случаев.)</target>
        </trans-unit>
        <trans-unit id="d3f19f348507a8389d8d149cdf77d56e254062cd" translate="yes" xml:space="preserve">
          <source>A variable representing the JSON text to be queried (the &lt;em&gt;context item&lt;/em&gt;).</source>
          <target state="translated">Переменная, представляющая запрашиваемый текст JSON ( &lt;em&gt;элемент контекста&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad2426a5221bd13cdbc6ec097f91418bf9cf0787" translate="yes" xml:space="preserve">
          <source>A variable representing the JSON value being queried (the &lt;em&gt;context item&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7ff43247d2073dd8c93ef6f893b8751eb3e7bd" translate="yes" xml:space="preserve">
          <source>A variable representing the result of path evaluation in filter expressions.</source>
          <target state="translated">Переменная,представляющая результат оценки пути в выражениях фильтров.</target>
        </trans-unit>
        <trans-unit id="156f0d479c5cbda4c018211d44db7834d2c5eaed" translate="yes" xml:space="preserve">
          <source>A variant of quoted identifiers allows including escaped Unicode characters identified by their code points. This variant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case U followed by ampersand) immediately before the opening double quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the identifier &lt;code&gt;&quot;data&quot;&lt;/code&gt; could be written as</source>
          <target state="translated">Вариант цитируемых идентификаторов позволяет включать экранированные символы Unicode, идентифицируемые их кодовыми точками. Этот вариант начинается с &lt;code&gt;U&amp;amp;&lt;/code&gt; (верхний или нижний регистр U, за которым следует амперсанд) непосредственно перед открывающей двойной кавычкой, без пробелов между ними, например &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt; . (Обратите внимание, что это создает двусмысленность с оператором &lt;code&gt;&amp;amp;&lt;/code&gt; . Используйте пробелы вокруг оператора, чтобы избежать этой проблемы.) Внутри кавычек символы Юникода могут быть указаны в экранированной форме, записав обратную косую черту, за которой следует четырехзначный шестнадцатеричный номер кодовой точки или в качестве альтернативы обратная косая черта, за которой следует знак плюс, за которым следует шестизначный шестнадцатеричный номер кодовой точки. Например, идентификатор &lt;code&gt;&quot;data&quot;&lt;/code&gt; можно записать как</target>
        </trans-unit>
        <trans-unit id="acdae0bdc3109dd35a6d548731ba6bb6d6a12b1e" translate="yes" xml:space="preserve">
          <source>A variant of the above query is</source>
          <target state="translated">Вариантом вышеприведенного запроса является</target>
        </trans-unit>
        <trans-unit id="86b56417739883cc59cc6c063327a17fce9dbe75" translate="yes" xml:space="preserve">
          <source>A view column name list must be specified for a recursive view.</source>
          <target state="translated">Для рекурсивного вида должен быть указан список имен столбцов вида.</target>
        </trans-unit>
        <trans-unit id="85b3bfd48768285b52ad306ba0d6292137e9c9f1" translate="yes" xml:space="preserve">
          <source>A view that is simple enough to be automatically updatable (see &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt;) does not require a user-created rule in order to be updatable. While you can create an explicit rule anyway, the automatic update transformation will generally outperform an explicit rule.</source>
          <target state="translated">Представление, которое достаточно просто для автоматического обновления (см. &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt; ), не требует созданного пользователем правила для возможности обновления. Хотя вы в любом случае можете создать явное правило, автоматическое преобразование обновления обычно превосходит явное правило.</target>
        </trans-unit>
        <trans-unit id="b5c5c1bad9d2f71be50a1fcf23b697eb7750bb21" translate="yes" xml:space="preserve">
          <source>A window function call</source>
          <target state="translated">Вызов оконной функции</target>
        </trans-unit>
        <trans-unit id="014e860f54b04147bfef99f64476d36d0f965833" translate="yes" xml:space="preserve">
          <source>A window function call always contains an &lt;code&gt;OVER&lt;/code&gt; clause directly following the window function's name and argument(s). This is what syntactically distinguishes it from a normal function or non-window aggregate. The &lt;code&gt;OVER&lt;/code&gt; clause determines exactly how the rows of the query are split up for processing by the window function. The &lt;code&gt;PARTITION BY&lt;/code&gt; clause within &lt;code&gt;OVER&lt;/code&gt; divides the rows into groups, or partitions, that share the same values of the &lt;code&gt;PARTITION BY&lt;/code&gt; expression(s). For each row, the window function is computed across the rows that fall into the same partition as the current row.</source>
          <target state="translated">Вызов оконной функции всегда содержит предложение &lt;code&gt;OVER&lt;/code&gt; , которое следует непосредственно за именем оконной функции и аргументом (ами). Это то, что синтаксически отличает его от обычной функции или агрегата без окон. Предложение &lt;code&gt;OVER&lt;/code&gt; определяет, как именно строки запроса разделяются для обработки оконной функцией. Предложение &lt;code&gt;PARTITION BY&lt;/code&gt; в &lt;code&gt;OVER&lt;/code&gt; делит строки на группы или разделы, которые имеют одинаковые значения выражения (-ий) &lt;code&gt;PARTITION BY&lt;/code&gt; . Для каждой строки оконная функция вычисляется по строкам, которые попадают в тот же раздел, что и текущая строка.</target>
        </trans-unit>
        <trans-unit id="69ff975e62e5e9881d6e40cfa6394518b64c0b59" translate="yes" xml:space="preserve">
          <source>A word is defined as in the specification of &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; above. Constraint escapes are illegal within bracket expressions.</source>
          <target state="translated">Слово определяется, как в спецификации &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; и &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; выше. Экраны ограничений недопустимы в квадратных скобках.</target>
        </trans-unit>
        <trans-unit id="e7b5c134c4da8e8da4908f5aacc24a6aa1409eb3" translate="yes" xml:space="preserve">
          <source>A working example of a waiting &lt;code&gt;restore_command&lt;/code&gt; is provided in the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</source>
          <target state="translated">Рабочий пример ожидающей команды &lt;code&gt;restore_command&lt;/code&gt; представлен в модуле &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; . Его следует использовать как справочник о том, как правильно реализовать логику, описанную выше. Его также можно расширить по мере необходимости для поддержки определенных конфигураций и сред.</target>
        </trans-unit>
        <trans-unit id="94040fbf2d2ff3dac676f0671c8578ae0488b46e" translate="yes" xml:space="preserve">
          <source>A working example of a waiting &lt;code&gt;restore_command&lt;/code&gt; is provided in the &lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d87e11b3c84c752269b580bca5caeedfc37d702" translate="yes" xml:space="preserve">
          <source>A write transaction has more than 64 subtransactions</source>
          <target state="translated">Сделка на запись имеет более 64 субтранзакций.</target>
        </trans-unit>
        <trans-unit id="cbd57cfd9437b3c9c1c3ce7cb0fb7a7b8366940a" translate="yes" xml:space="preserve">
          <source>ABORT</source>
          <target state="translated">ABORT</target>
        </trans-unit>
        <trans-unit id="7a0ffd6011b0a819cbe07ec59ab6319e323b19e8" translate="yes" xml:space="preserve">
          <source>ABORT &amp;mdash; abort the current transaction</source>
          <target state="translated">ABORT - прервать текущую транзакцию</target>
        </trans-unit>
        <trans-unit id="e3a56e2d83c5cd3911209ecd97318531d89949dd" translate="yes" xml:space="preserve">
          <source>ACCESS EXCLUSIVE</source>
          <target state="translated">ЭКСКЛЮЗИВНЫЙ ДОСТУП</target>
        </trans-unit>
        <trans-unit id="236082e0393025e2b67ccb853e349993a3e685de" translate="yes" xml:space="preserve">
          <source>ACCESS SHARE</source>
          <target state="translated">АКЦЕСС ШАР</target>
        </trans-unit>
        <trans-unit id="d4c15b3f603d1252b36800551086669559ae86a4" translate="yes" xml:space="preserve">
          <source>ACID</source>
          <target state="translated">ACID</target>
        </trans-unit>
        <trans-unit id="41f215a6d36c7782875bfb5d6d290ebb1e7961df" translate="yes" xml:space="preserve">
          <source>AES</source>
          <target state="translated">AES</target>
        </trans-unit>
        <trans-unit id="7cd735bc88414abeac25ef102606e6871aeba944" translate="yes" xml:space="preserve">
          <source>AIX</source>
          <target state="translated">AIX</target>
        </trans-unit>
        <trans-unit id="d3f3cb97007280f4a9b1e690872959eda00344a5" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE</source>
          <target state="translated">ПЕРЕМЕННЫЙ АГРЕГАТ</target>
        </trans-unit>
        <trans-unit id="ed3d1c36faecc14690efbf5d3029f3dd4930091a" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE &amp;mdash; change the definition of an aggregate function</source>
          <target state="translated">ALTER AGGREGATE - изменить определение агрегатной функции</target>
        </trans-unit>
        <trans-unit id="a11472b885174cf0a5b8f565bbd9df33d5c63d9f" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION</source>
          <target state="translated">СОПОСТАВЛЕНИЕ ИЗМЕНЕНИЙ</target>
        </trans-unit>
        <trans-unit id="56c3d4607ffe2e71e2c5f2646969f8ca0df737b4" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION &amp;mdash; change the definition of a collation</source>
          <target state="translated">ALTER COLLATION - изменить определение сопоставления</target>
        </trans-unit>
        <trans-unit id="41b42a1cc1e0f91fde1b7c9e18dfe7b36339b901" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION</source>
          <target state="translated">МОДИФИЦИРОВАННОЕ ПРЕОБРАЗОВАНИЕ</target>
        </trans-unit>
        <trans-unit id="ccebf78a2dc7b51b4b857717880c57e697294e8c" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION &amp;mdash; change the definition of a conversion</source>
          <target state="translated">ALTER CONVERSION - изменить определение преобразования</target>
        </trans-unit>
        <trans-unit id="00ca4087b8df03743dae97498c53fb19953638fa" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE</source>
          <target state="translated">АЛЬТЕР ДАТАБАЗА</target>
        </trans-unit>
        <trans-unit id="bea7726d13edb6ca210b4e6c9e61ad1bc910bed8" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE &amp;mdash; change a database</source>
          <target state="translated">ALTER DATABASE - изменить базу данных</target>
        </trans-unit>
        <trans-unit id="2d6bcd612a3e7b99bb9476838637e9b5438e3634" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES</source>
          <target state="translated">ИЗМЕНИТЬ СТАНДАРТНЫЕ ПРАВА</target>
        </trans-unit>
        <trans-unit id="d8ff7f2d5af359b01a54f95e0ec2fd521bd7747c" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES &amp;mdash; define default access privileges</source>
          <target state="translated">ALTER DEFAULT PRIVILEGES - определение прав доступа по умолчанию</target>
        </trans-unit>
        <trans-unit id="3f3cf48aa306a7a17143c18f42b0b45f1ba91588" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN</source>
          <target state="translated">АЛЬТЕР-ДОМЕН</target>
        </trans-unit>
        <trans-unit id="535f7dde2f03c36ca7629e33ff7b1217df1764aa" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN &amp;mdash; change the definition of a domain</source>
          <target state="translated">ALTER DOMAIN - изменить определение домена</target>
        </trans-unit>
        <trans-unit id="20933ed39426b19f4475367266e6e6f9a626ffa6" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER</source>
          <target state="translated">ИНИЦИИРОВАТЬ ИЗМЕНЕНИЕ СОБЫТИЯ</target>
        </trans-unit>
        <trans-unit id="10dfbf336834913b8615fd608fa879b835569269" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER &amp;mdash; change the definition of an event trigger</source>
          <target state="translated">ALTER EVENT TRIGGER - изменить определение триггера события</target>
        </trans-unit>
        <trans-unit id="0800582e9a19732ccd7ede52083d298eb7e533f7" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION</source>
          <target state="translated">ИЗМЕНЕНИЕ РАСШИРЕНИЯ</target>
        </trans-unit>
        <trans-unit id="fceab1548e1fa0086ad916c8c58c48d5f822b214" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION &amp;mdash; change the definition of an extension</source>
          <target state="translated">ALTER EXTENSION - изменить определение расширения</target>
        </trans-unit>
        <trans-unit id="1845d1a7f6884f411e6b6fe79fb5470d0541e6de" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER</source>
          <target state="translated">ОБЁРТОЧНАЯ БУМАГА ДЛЯ ВНЕШНИХ ДАННЫХ</target>
        </trans-unit>
        <trans-unit id="81f39fe099a4b1e8700a250047ab0bd19b916bbd" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER &amp;mdash; change the definition of a foreign-data wrapper</source>
          <target state="translated">ALTER FOREIGN DATA WRAPPER - изменить определение оболочки сторонних данных</target>
        </trans-unit>
        <trans-unit id="a09c3d2b46b06da9b27051fbdd7021dbe016aef6" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE</source>
          <target state="translated">ИНТЕРНАЦИОНАЛЬНЫЙ СТОЛ</target>
        </trans-unit>
        <trans-unit id="8624b9015bf6424468dfa21128e81480cb2172bb" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE &amp;mdash; change the definition of a foreign table</source>
          <target state="translated">ALTER FOREIGN TABLE - изменить определение сторонней таблицы</target>
        </trans-unit>
        <trans-unit id="6f1e4d41d93587f0bfc00e49946d0343d91452a6" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION</source>
          <target state="translated">АЛЬТЕР ФУНКЦИЯ</target>
        </trans-unit>
        <trans-unit id="0d8b2dd3aa8516a6e8465a116eb3a3088efc3943" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION &amp;mdash; change the definition of a function</source>
          <target state="translated">ALTER FUNCTION - изменить определение функции</target>
        </trans-unit>
        <trans-unit id="1d015a780bf1ecbd73d8b159554c5fb6595a8014" translate="yes" xml:space="preserve">
          <source>ALTER GROUP</source>
          <target state="translated">АЛЬТЕР ГРУППА</target>
        </trans-unit>
        <trans-unit id="8b6db204989799abd80f3151dc7f1e0c1b92ec62" translate="yes" xml:space="preserve">
          <source>ALTER GROUP &amp;mdash; change role name or membership</source>
          <target state="translated">ALTER GROUP - изменить имя роли или членство</target>
        </trans-unit>
        <trans-unit id="48c2e5d4cd7c661c29fd2888d9f2286c8fc0c6bf" translate="yes" xml:space="preserve">
          <source>ALTER INDEX</source>
          <target state="translated">АЛЬТЕР ИНДЕКС</target>
        </trans-unit>
        <trans-unit id="7af8592c9de99cba72394d1922b6e193f563c137" translate="yes" xml:space="preserve">
          <source>ALTER INDEX &amp;mdash; change the definition of an index</source>
          <target state="translated">ALTER INDEX - изменить определение индекса</target>
        </trans-unit>
        <trans-unit id="1593f1abf4a97117a0be55f5da7d21f597c8c250" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE</source>
          <target state="translated">АЛЬТЕР-ЛАНГУАГ</target>
        </trans-unit>
        <trans-unit id="2d47f4538397cbf8b0a1e802f6dfa7cb56556115" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE &amp;mdash; change the definition of a procedural language</source>
          <target state="translated">ALTER LANGUAGE - изменить определение процедурного языка</target>
        </trans-unit>
        <trans-unit id="b8e23037908ab469bed89826c20ecdd2b7ec5245" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT</source>
          <target state="translated">ИЗМЕНЯТЬ КРУПНЫЙ ОБЪЕКТ</target>
        </trans-unit>
        <trans-unit id="d01f8e01043a2f37f9bf2b4fbe638ce531bf573c" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT &amp;mdash; change the definition of a large object</source>
          <target state="translated">ALTER LARGE OBJECT - изменить определение большого объекта</target>
        </trans-unit>
        <trans-unit id="acf3facbc79c94e9820cd014a83e0c3bffc8d33e" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW</source>
          <target state="translated">ИЗМЕНЯТЬ МАТЕРИАЛИЗОВАННОЕ ПРЕДСТАВЛЕНИЕ</target>
        </trans-unit>
        <trans-unit id="ff19a08e1cc705b85f737d7d03bbe11848829b1c" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW &amp;mdash; change the definition of a materialized view</source>
          <target state="translated">ALTER MATERIALIZED VIEW - изменить определение материализованного представления</target>
        </trans-unit>
        <trans-unit id="dce6c5285005edbbb84e2318b05691c4b30c9b74" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR</source>
          <target state="translated">АЛЬТЕР-ОПЕРАТОР</target>
        </trans-unit>
        <trans-unit id="7dafb4a30aeb9191e7113acec86c091ff802f404" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR &amp;mdash; change the definition of an operator</source>
          <target state="translated">ALTER OPERATOR - изменить определение оператора</target>
        </trans-unit>
        <trans-unit id="a0e738cb1034a6c7d40880b830a0d0aabd9fe44b" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS</source>
          <target state="translated">КЛАСС ПЕРЕСТРОЙКИ ОПЕРАТОРА</target>
        </trans-unit>
        <trans-unit id="cb0f6723f3b16452ec4b0d07ef7fe014b4a43893" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS &amp;mdash; change the definition of an operator class</source>
          <target state="translated">ALTER OPERATOR CLASS - изменить определение класса оператора</target>
        </trans-unit>
        <trans-unit id="0ba7fb1c4beddce29550f5cb8b66990a01471bb0" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY</source>
          <target state="translated">СЕМЕЙСТВО ОПЕРАТОРОВ ПЕРЕМЕНЫ</target>
        </trans-unit>
        <trans-unit id="b145c0d850ce88d5e3be9bd1acd90a4f15ebe361" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY &amp;mdash; change the definition of an operator family</source>
          <target state="translated">ALTER OPERATOR FAMILY - изменить определение семейства операторов</target>
        </trans-unit>
        <trans-unit id="88b3b91499f373dcdd877e9ff64364e5e7e60e0e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY</source>
          <target state="translated">АЛЬТЕР-ПОЛИЦИЯ</target>
        </trans-unit>
        <trans-unit id="833f3039623c0b1cb3fef4e1e4f83cc843bd962e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY &amp;mdash; change the definition of a row level security policy</source>
          <target state="translated">ALTER POLICY - изменить определение политики безопасности на уровне строк</target>
        </trans-unit>
        <trans-unit id="6a0674112110b72195624944bfa13c57d5d82cb7" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE</source>
          <target state="translated">ПРОЦЕДУРА ИЗМЕНЕНИЯ</target>
        </trans-unit>
        <trans-unit id="43575de59088420331627e718ac08acff025d18b" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE &amp;mdash; change the definition of a procedure</source>
          <target state="translated">ALTER PROCEDURE - изменить определение процедуры</target>
        </trans-unit>
        <trans-unit id="54107fe026e19d4f5a11e4537d44c6b6d22b8b09" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION</source>
          <target state="translated">ПЕРЕИЗДАНИЕ</target>
        </trans-unit>
        <trans-unit id="9597d926bb8a9acc34d0e5930cb8d7cd0d4f568f" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION &amp;mdash; change the definition of a publication</source>
          <target state="translated">ALTER PUBLICATION - изменить определение публикации</target>
        </trans-unit>
        <trans-unit id="8d50cc704f5e61444d52d138269e970c84c316a9" translate="yes" xml:space="preserve">
          <source>ALTER ROLE</source>
          <target state="translated">ALTER ROLE</target>
        </trans-unit>
        <trans-unit id="12cc26ef42f3af7ca4348ac6467248637f685960" translate="yes" xml:space="preserve">
          <source>ALTER ROLE &amp;mdash; change a database role</source>
          <target state="translated">ALTER ROLE - изменить роль базы данных</target>
        </trans-unit>
        <trans-unit id="4dcea8729953c25416c614a8e9dd74665955b163" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE</source>
          <target state="translated">АЛЬТЕР-РУТИНА</target>
        </trans-unit>
        <trans-unit id="41b74c3c2f66a654560a7c52136c27e28aece24f" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE &amp;mdash; change the definition of a routine</source>
          <target state="translated">ALTER ROUTINE - изменить определение процедуры</target>
        </trans-unit>
        <trans-unit id="a0e0dff76fa934f2bd1deef6694b1932d808504f" translate="yes" xml:space="preserve">
          <source>ALTER RULE</source>
          <target state="translated">ПРАВИЛА АЛЬТЕР</target>
        </trans-unit>
        <trans-unit id="2fc7414dfcf68c3ac031a4421e6842e26618ab9c" translate="yes" xml:space="preserve">
          <source>ALTER RULE &amp;mdash; change the definition of a rule</source>
          <target state="translated">ALTER RULE - изменить определение правила</target>
        </trans-unit>
        <trans-unit id="d6fc95f83521d1f149e5c2d72ccf2e6275ceff58" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA</source>
          <target state="translated">АЛЬТЕР-ШЕМА</target>
        </trans-unit>
        <trans-unit id="a9c6d7baa1a1fa5c1ea1e4302e14b9b0b1cbc91f" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA &amp;mdash; change the definition of a schema</source>
          <target state="translated">ALTER SCHEMA - изменить определение схемы</target>
        </trans-unit>
        <trans-unit id="e0ff1dd3b5bc12676f75f802c39fe58d3f568b91" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE</source>
          <target state="translated">АЛЬТЕР-СЕКВЕНС</target>
        </trans-unit>
        <trans-unit id="75ca9fc88afe8b3a138533f529504e99e65095c7" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE &amp;mdash; change the definition of a sequence generator</source>
          <target state="translated">ALTER SEQUENCE - изменить определение генератора последовательности</target>
        </trans-unit>
        <trans-unit id="4e991c23674edbbd034fbea9f95fd5732fde6594" translate="yes" xml:space="preserve">
          <source>ALTER SERVER</source>
          <target state="translated">АЛЬТЕРНЫЙ СЕРВЕР</target>
        </trans-unit>
        <trans-unit id="9097ec6c4fcb5127ed5acb37df744bf114c59cf4" translate="yes" xml:space="preserve">
          <source>ALTER SERVER &amp;mdash; change the definition of a foreign server</source>
          <target state="translated">ALTER SERVER - изменить определение стороннего сервера</target>
        </trans-unit>
        <trans-unit id="339516769622a8fe113a08ac4316402cbf0b0186" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS</source>
          <target state="translated">ИЗМЕНЯТЬ СТАТИСТИКУ</target>
        </trans-unit>
        <trans-unit id="08e64dea134c405908e303c3bf604acf6999c23f" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS &amp;mdash; change the definition of an extended statistics object</source>
          <target state="translated">ALTER STATISTICS - изменить определение объекта расширенной статистики</target>
        </trans-unit>
        <trans-unit id="10579de4cfd80edf9752f883f553b098d07c2351" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION</source>
          <target state="translated">ИЗМЕНЁННАЯ ПОДПИСКА</target>
        </trans-unit>
        <trans-unit id="3088c38bfc4248dd70925edc22aa9e03938a70b2" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION &amp;mdash; change the definition of a subscription</source>
          <target state="translated">ALTER SUBSCRIPTION - изменить определение подписки</target>
        </trans-unit>
        <trans-unit id="b751196563736994d3b141da4e3359399f7784c1" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM</source>
          <target state="translated">АЛЬТЕР-СИСТЕМА</target>
        </trans-unit>
        <trans-unit id="43121748c757e8121439597a27c3d6de3f1df5e0" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM &amp;mdash; change a server configuration parameter</source>
          <target state="translated">ALTER SYSTEM - изменить параметр конфигурации сервера</target>
        </trans-unit>
        <trans-unit id="fcdc3e679260efe34d4720e54eb086a76a15f687" translate="yes" xml:space="preserve">
          <source>ALTER TABLE</source>
          <target state="translated">АЛЬТЕР-ТАБЛИЦА</target>
        </trans-unit>
        <trans-unit id="afe4c7733f05b900cf17777f836ea5b6c85eae68" translate="yes" xml:space="preserve">
          <source>ALTER TABLE &amp;mdash; change the definition of a table</source>
          <target state="translated">ALTER TABLE - изменить определение таблицы</target>
        </trans-unit>
        <trans-unit id="c9732ec2c1c41131709b9ec601102740f5d08528" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE</source>
          <target state="translated">АЛЬТЕР ТАБЛИЧНОЕ ПРОСТРАНСТВО</target>
        </trans-unit>
        <trans-unit id="e3e82c20f13259759fc74c305fcf89694aa71e4c" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE &amp;mdash; change the definition of a tablespace</source>
          <target state="translated">ALTER TABLESPACE - изменить определение табличного пространства</target>
        </trans-unit>
        <trans-unit id="ab1241fdf0558dac3416642b6e5e2afa08edd357" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION</source>
          <target state="translated">ИЗМЕНИТЬ НАСТРОЙКИ ТЕКСТОВОГО ПОИСКА</target>
        </trans-unit>
        <trans-unit id="2a241bc8e97bcb10c517130c630f0f5969d5e473" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION &amp;mdash; change the definition of a text search configuration</source>
          <target state="translated">ALTER TEXT SEARCH CONFIGURATION - изменить определение конфигурации текстового поиска</target>
        </trans-unit>
        <trans-unit id="a62239565ecd2214c8d0dc9fde76b1033be6c2fc" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY</source>
          <target state="translated">ТЕКСТОВЫЙ ПОИСКОВЫЙ СЛОВАРЬ ИЗМЕНЕНИЙ</target>
        </trans-unit>
        <trans-unit id="13998d90641b194774e8f12cf56ab5eaead8a314" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY &amp;mdash; change the definition of a text search dictionary</source>
          <target state="translated">ALTER TEXT SEARCH DICTIONARY - изменить определение словаря текстового поиска</target>
        </trans-unit>
        <trans-unit id="8179411a0a3b868da4b4880988c7d06f086d844e" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER</source>
          <target state="translated">ИЗМЕНИТЬ ТЕКСТОВЫЙ ПАРСЕР</target>
        </trans-unit>
        <trans-unit id="b487f243ff77599a0ebe244a83985f8acf1c14ea" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER &amp;mdash; change the definition of a text search parser</source>
          <target state="translated">ALTER TEXT SEARCH PARSER - изменить определение парсера текстового поиска</target>
        </trans-unit>
        <trans-unit id="03386acc96b981e6c35c90b75e2cec735105ea3c" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE</source>
          <target state="translated">ИЗМЕНИТЬ ТЕКСТОВЫЙ ШАБЛОН ПОИСКА</target>
        </trans-unit>
        <trans-unit id="285dbc8186deb64394ffb30b6e1363ad0dbe6498" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE &amp;mdash; change the definition of a text search template</source>
          <target state="translated">ALTER TEXT SEARCH TEMPLATE - изменить определение шаблона текстового поиска</target>
        </trans-unit>
        <trans-unit id="f6742edfb2c8b1a8d27beb1bba87153804373be5" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER</source>
          <target state="translated">АЛЬТЕР-ТРИГГЕР</target>
        </trans-unit>
        <trans-unit id="485c6a654f45ba69729bdbf15496fe29a444d1e3" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER &amp;mdash; change the definition of a trigger</source>
          <target state="translated">ALTER TRIGGER - изменить определение триггера</target>
        </trans-unit>
        <trans-unit id="b8549a9a7b44242713f7d48704380ebba425b154" translate="yes" xml:space="preserve">
          <source>ALTER TYPE</source>
          <target state="translated">АЛЬТЕРНЫЙ ТИП</target>
        </trans-unit>
        <trans-unit id="2921b9477c2e093e0ed29e1dc88121fdd946417d" translate="yes" xml:space="preserve">
          <source>ALTER TYPE &amp;mdash; change the definition of a type</source>
          <target state="translated">ALTER TYPE - изменить определение типа</target>
        </trans-unit>
        <trans-unit id="0f0117db55477563e4484d9879a151cbea4a27fc" translate="yes" xml:space="preserve">
          <source>ALTER USER</source>
          <target state="translated">АЛЬТЕРНЫЙ ПОЛЬЗОВАТЕЛЬ</target>
        </trans-unit>
        <trans-unit id="dc349b6f52ce0d7d5bb23382932a5eb2f67eac63" translate="yes" xml:space="preserve">
          <source>ALTER USER &amp;mdash; change a database role</source>
          <target state="translated">ALTER USER - изменить роль базы данных</target>
        </trans-unit>
        <trans-unit id="a375773515175c08cd7fc8e357c209c60d07f13e" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING</source>
          <target state="translated">ИЗМЕНИТЬ ПОЛЬЗОВАТЕЛЬСКОЕ ОТОБРАЖЕНИЕ</target>
        </trans-unit>
        <trans-unit id="84dbc6c571c120a8defca7e0a6c086e648f98854" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING &amp;mdash; change the definition of a user mapping</source>
          <target state="translated">ALTER USER MAPPING - изменить определение отображения пользователя</target>
        </trans-unit>
        <trans-unit id="219d78bab64e4f5637643b61ce738d2b84487f00" translate="yes" xml:space="preserve">
          <source>ALTER VIEW</source>
          <target state="translated">АЛЬТЕР-ВИЗА</target>
        </trans-unit>
        <trans-unit id="d3ae485ff52fa79c183c7d3ce9f751addfed0468" translate="yes" xml:space="preserve">
          <source>ALTER VIEW &amp;mdash; change the definition of a view</source>
          <target state="translated">ALTER VIEW - изменить определение представления</target>
        </trans-unit>
        <trans-unit id="caadd138e6e8d1596eda80c0f51c856600e89f65" translate="yes" xml:space="preserve">
          <source>ANALYZE</source>
          <target state="translated">ANALYZE</target>
        </trans-unit>
        <trans-unit id="21b8417695362cfdc412c95c44c48fa648556dd9" translate="yes" xml:space="preserve">
          <source>ANALYZE &amp;mdash; collect statistics about a database</source>
          <target state="translated">АНАЛИЗ - собрать статистику о базе данных</target>
        </trans-unit>
        <trans-unit id="e2f2d6cea163ef0dacf4540366528f7c7edd61f2" translate="yes" xml:space="preserve">
          <source>AND &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">И &lt;code&gt;tsquery&lt;/code&gt; вместе</target>
        </trans-unit>
        <trans-unit id="8824eb37da0438275c17449687050c5930f6be40" translate="yes" xml:space="preserve">
          <source>ANDs two &lt;code&gt;tsquery&lt;/code&gt;s together, producing a query that matches documents that match both input queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b52ce6d8d3ca14c041a1ecfe44ca34c84c93c5" translate="yes" xml:space="preserve">
          <source>ANSI</source>
          <target state="translated">ANSI</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="5fb9ba93128c23898a1b0a61ebd44810a0c6b606" translate="yes" xml:space="preserve">
          <source>ASCII code of the first character of the argument. For UTF8 returns the Unicode code point of the character. For other multibyte encodings, the argument must be an ASCII character.</source>
          <target state="translated">ASCII код первого символа аргумента.Для UTF8 возвращает точку кода Юникода символа.Для других многобайтных кодировок аргумент должен быть ASCII символом.</target>
        </trans-unit>
        <trans-unit id="7647bd700c1c10eb12b5de06bf40a88672e3451d" translate="yes" xml:space="preserve">
          <source>Aaron D. Gifford</source>
          <target state="translated">Аарон Ди Гиффорд</target>
        </trans-unit>
        <trans-unit id="cd437865cbac7655f8b86519aea764f378093804" translate="yes" xml:space="preserve">
          <source>Abbreviation</source>
          <target state="translated">Abbreviation</target>
        </trans-unit>
        <trans-unit id="1bb9eda0dcf4611f958758d0ccd51e13bf341710" translate="yes" xml:space="preserve">
          <source>Abbreviation (for Pacific Standard Time)</source>
          <target state="translated">Сокращение (для тихоокеанского стандартного времени)</target>
        </trans-unit>
        <trans-unit id="a90aba13b6feb8ff1a5141d94cb1fc2fe96e9477" translate="yes" xml:space="preserve">
          <source>Abbreviations</source>
          <target state="translated">Abbreviations</target>
        </trans-unit>
        <trans-unit id="c5fd5b17ae3c41e41caede4fa07a5960ba1a5f2d" translate="yes" xml:space="preserve">
          <source>Abort any statement that takes more than the specified amount of time. If &lt;code&gt;log_min_error_statement&lt;/code&gt; is set to &lt;code&gt;ERROR&lt;/code&gt; or lower, the statement that timed out will also be logged. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">Прервите любой оператор, который занимает больше указанного времени. Если для &lt;code&gt;log_min_error_statement&lt;/code&gt; установлено значение &lt;code&gt;ERROR&lt;/code&gt; или ниже, оператор с истекшим временем ожидания также будет зарегистрирован. Если это значение указано без единиц измерения, оно принимается в миллисекундах. Нулевое значение (по умолчанию) отключает тайм-аут.</target>
        </trans-unit>
        <trans-unit id="6c33aee3e89187438edae43ea18855e5962050c2" translate="yes" xml:space="preserve">
          <source>Abort any statement that waits longer than the specified amount of time while attempting to acquire a lock on a table, index, row, or other database object. The time limit applies separately to each lock acquisition attempt. The limit applies both to explicit locking requests (such as &lt;code&gt;LOCK TABLE&lt;/code&gt;, or &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; without &lt;code&gt;NOWAIT&lt;/code&gt;) and to implicitly-acquired locks. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">Отмените любой оператор, который ждет дольше указанного времени при попытке получить блокировку таблицы, индекса, строки или другого объекта базы данных. Срок применяется отдельно для каждой попытки получения блокировки. Предел применяется как к явным запросам блокировки (таким как &lt;code&gt;LOCK TABLE&lt;/code&gt; или &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; без &lt;code&gt;NOWAIT&lt;/code&gt; ), так и к неявно полученным блокировкам. Если это значение указано без единиц измерения, оно принимается в миллисекундах. Нулевое значение (по умолчанию) отключает тайм-аут.</target>
        </trans-unit>
        <trans-unit id="82c17c3ccfec7ab27999f74c3eae394cb4e66713" translate="yes" xml:space="preserve">
          <source>Above, since there is no &lt;code&gt;ORDER BY&lt;/code&gt; in the &lt;code&gt;OVER&lt;/code&gt; clause, the window frame is the same as the partition, which for lack of &lt;code&gt;PARTITION BY&lt;/code&gt; is the whole table; in other words each sum is taken over the whole table and so we get the same result for each output row. But if we add an &lt;code&gt;ORDER BY&lt;/code&gt; clause, we get very different results:</source>
          <target state="translated">Выше, поскольку в предложении &lt;code&gt;OVER&lt;/code&gt; нет &lt;code&gt;ORDER BY&lt;/code&gt; , рамка окна такая же, как и раздел, который из-за отсутствия &lt;code&gt;PARTITION BY&lt;/code&gt; представляет собой всю таблицу; другими словами, каждая сумма берется по всей таблице, поэтому мы получаем одинаковый результат для каждой выходной строки. Но если мы добавим предложение &lt;code&gt;ORDER BY&lt;/code&gt; , мы получим совсем другие результаты:</target>
        </trans-unit>
        <trans-unit id="35e4a1a9ace5e53c1521b13130f3b1fce0bb312b" translate="yes" xml:space="preserve">
          <source>Absolute value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc48669a5f045e0b1c73515a6a06d3751ca7ca3" translate="yes" xml:space="preserve">
          <source>Absolute value of the SQL/JSON number</source>
          <target state="translated">Абсолютное значение номера SQL/JSON</target>
        </trans-unit>
        <trans-unit id="adaf687cef3a864875d03ee7f1764cbc49564164" translate="yes" xml:space="preserve">
          <source>Absolute value of the given number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ecf27dff51c67220f14d51d8af97b6912bfba7" translate="yes" xml:space="preserve">
          <source>Access Exclusive locks taken on the primary server, including both explicit &lt;code&gt;LOCK&lt;/code&gt; commands and various DDL actions, conflict with table accesses in standby queries.</source>
          <target state="translated">Эксклюзивные блокировки доступа, принятые на основном сервере, включая как явные команды &lt;code&gt;LOCK&lt;/code&gt; ,так и различные действия DDL, конфликтуют с доступом к таблицам в резервных запросах.</target>
        </trans-unit>
        <trans-unit id="446d3f34dfbff4e7c337ef9e7b895902f1dba9ef" translate="yes" xml:space="preserve">
          <source>Access methods that always return entries in the natural ordering of their data (such as btree) should set &lt;code&gt;amcanorder&lt;/code&gt; to true. Currently, such access methods must use btree-compatible strategy numbers for their equality and ordering operators.</source>
          <target state="translated">Методы доступа, которые всегда возвращают записи в естественном порядке их данных (например, btree), должны устанавливать &lt;code&gt;amcanorder&lt;/code&gt; в значение true. В настоящее время такие методы доступа должны использовать числа стратегии, совместимые с btree, для их операторов равенства и упорядочения.</target>
        </trans-unit>
        <trans-unit id="b0e23c5a90203bbd16a6b86de50258944a0ed57a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordered scans must support &amp;ldquo;marking&amp;rdquo; a position in a scan and later returning to the marked position. The same position might be restored multiple times. However, only one position need be remembered per scan; a new &lt;code&gt;ammarkpos&lt;/code&gt; call overrides the previously marked position. An access method that does not support ordered scans need not provide &lt;code&gt;ammarkpos&lt;/code&gt; and &lt;code&gt;amrestrpos&lt;/code&gt; functions in &lt;code&gt;IndexAmRoutine&lt;/code&gt;; set those pointers to NULL instead.</source>
          <target state="translated">Методы доступа, поддерживающие упорядоченное сканирование, должны поддерживать &amp;laquo;маркировку&amp;raquo; позиции в сканировании и последующий возврат в отмеченную позицию. Одно и то же положение можно восстанавливать несколько раз. Однако за одно сканирование нужно запоминать только одну позицию; новый вызов &lt;code&gt;ammarkpos&lt;/code&gt; отменяет ранее отмеченную позицию. Метод доступа, который не поддерживает упорядоченное сканирование, не должен предоставлять функции &lt;code&gt;ammarkpos&lt;/code&gt; и &lt;code&gt;amrestrpos&lt;/code&gt; в &lt;code&gt;IndexAmRoutine&lt;/code&gt; ; вместо этого установите эти указатели в NULL.</target>
        </trans-unit>
        <trans-unit id="0fdc357a629c5f7047a03e768a0792d5cbb44b9a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should implement &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; property testing, as the core code does not know how to do that and will return NULL. It may also be advantageous to implement &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; testing, if that can be done more cheaply than by opening the index and calling &lt;code&gt;amcanreturn&lt;/code&gt;, which is the core code's default behavior. The default behavior should be satisfactory for all other standard properties.</source>
          <target state="translated">Методы доступа, поддерживающие операторы упорядочения, должны реализовывать &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; свойств AMPROP_DISTANCE_ORDERABLE , поскольку основной код не знает, как это сделать, и вернет NULL. Также может быть &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; реализовать тестирование AMPROP_RETURNABLE , если это можно сделать дешевле, чем путем открытия индекса и вызова &lt;code&gt;amcanreturn&lt;/code&gt; , что является поведением по умолчанию основного кода. Поведение по умолчанию должно быть удовлетворительным для всех других стандартных свойств.</target>
        </trans-unit>
        <trans-unit id="ec93e5f340df1c63a8b7900c8c64d2c56b99c607" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should set &lt;code&gt;amcanorderbyop&lt;/code&gt; to true. This indicates that the index is capable of returning entries in an order satisfying &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Scan modifiers of that form can be passed to &lt;code&gt;amrescan&lt;/code&gt; as described previously.</source>
          <target state="translated">Методы доступа, поддерживающие операторы упорядочивания, должны установить для &lt;code&gt;amcanorderbyop&lt;/code&gt; значение true. Это указывает на то, что индекс может возвращать записи в порядке , удовлетворяющих &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; . Модификаторы сканирования этой формы могут быть переданы в &lt;code&gt;amrescan&lt;/code&gt; , как описано ранее.</target>
        </trans-unit>
        <trans-unit id="9d5da75b46e072ddd4591be60d218524fe1f309e" translate="yes" xml:space="preserve">
          <source>Access privileges for template (not actually used)</source>
          <target state="translated">Привилегии доступа к шаблону (фактически не используются)</target>
        </trans-unit>
        <trans-unit id="85f3b04d8d02176eeb1578817040415abfa34698" translate="yes" xml:space="preserve">
          <source>Access privileges that this type of object should have on creation</source>
          <target state="translated">Привилегии доступа,которые этот тип объекта должен иметь при создании</target>
        </trans-unit>
        <trans-unit id="3d73c85183e638c3a5d257c026ae2497dddb1f32" translate="yes" xml:space="preserve">
          <source>Access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">Права доступа; см &lt;a href=&quot;ddl-priv&quot;&gt;раздел 5.7&lt;/a&gt; для получения более подробной</target>
        </trans-unit>
        <trans-unit id="02bbd73371e69fa85fa69f734c586e2358313738" translate="yes" xml:space="preserve">
          <source>Access to tables referenced in the view is determined by permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for details. Functions called in the view are treated the same as if they had been called directly from the query using the view. Therefore the user of a view must have permissions to call all functions used by the view.</source>
          <target state="translated">Доступ к таблицам, на которые есть ссылки в представлении, определяется разрешениями владельца представления. В некоторых случаях это можно использовать для обеспечения безопасного, но ограниченного доступа к базовым таблицам. Однако не все представления защищены от подделки; подробности см. в &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Разделе 40.5&lt;/a&gt; . Функции, вызываемые в представлении, обрабатываются так же, как если бы они были вызваны непосредственно из запроса с использованием представления. Следовательно, у пользователя представления должны быть разрешения для вызова всех функций, используемых представлением.</target>
        </trans-unit>
        <trans-unit id="c4369eb157086a70b7378313eb6ff8fc4fe92c26" translate="yes" xml:space="preserve">
          <source>Access to tables referenced in the view is determined by permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for details. Functions called in the view are treated the same as if they had been called directly from the query using the view. Therefore the user of a view must have permissions to call all functions used by the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea538985d43ba38411a22fc78790edc64739cd94" translate="yes" xml:space="preserve">
          <source>Access to the column &lt;code&gt;subconninfo&lt;/code&gt; is revoked from normal users, because it could contain plain-text passwords.</source>
          <target state="translated">Доступ к столбцу &lt;code&gt;subconninfo&lt;/code&gt; запрещен для обычных пользователей, поскольку он может содержать пароли в виде простого текста.</target>
        </trans-unit>
        <trans-unit id="709b98ad6555808775120e3c01cba15666c7c18d" translate="yes" xml:space="preserve">
          <source>Access to the table &lt;code&gt;pg_statistic&lt;/code&gt; is restricted to superusers, so that ordinary users cannot learn about the contents of the tables of other users from it. Some selectivity estimation functions will use a user-provided operator (either the operator appearing in the query or a related operator) to analyze the stored statistics. For example, in order to determine whether a stored most common value is applicable, the selectivity estimator will have to run the appropriate &lt;code&gt;=&lt;/code&gt; operator to compare the constant in the query to the stored value. Thus the data in &lt;code&gt;pg_statistic&lt;/code&gt; is potentially passed to user-defined operators. An appropriately crafted operator can intentionally leak the passed operands (for example, by logging them or writing them to a different table), or accidentally leak them by showing their values in error messages, in either case possibly exposing data from &lt;code&gt;pg_statistic&lt;/code&gt; to a user who should not be able to see it.</source>
          <target state="translated">Доступ к таблице &lt;code&gt;pg_statistic&lt;/code&gt; ограничен суперпользователями, поэтому обычные пользователи не могут узнать из нее содержимое таблиц других пользователей. Некоторые функции оценки селективности будут использовать предоставленный пользователем оператор (либо оператор, указанный в запросе, либо связанный оператор) для анализа сохраненной статистики. Например, чтобы определить, применимо ли сохраненное наиболее распространенное значение, оценщику селективности необходимо будет запустить соответствующий оператор &lt;code&gt;=&lt;/code&gt; для сравнения константы в запросе с сохраненным значением. Таким образом, данные в &lt;code&gt;pg_statistic&lt;/code&gt; потенциально передается пользовательским операторам. Правильно созданный оператор может намеренно утечка переданных операндов (например, путем их записи в журнал или записи в другую таблицу) или случайной утечки, показывая их значения в сообщениях об ошибках, в любом случае, возможно, раскрывая данные из &lt;code&gt;pg_statistic&lt;/code&gt; пользователю, который не должно быть видно.</target>
        </trans-unit>
        <trans-unit id="a19557158b233d91213a81525eeee59ee4fa2d0a" translate="yes" xml:space="preserve">
          <source>Access-method-specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">Параметры, зависящие от метода доступа, в виде строк &amp;laquo;ключевое слово = значение&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="bdebd3af85014736552b079e90a39e39b6b4b3f6" translate="yes" xml:space="preserve">
          <source>Accessing remote data may require authenticating to the external data source. This information can be provided by a &lt;em&gt;user mapping&lt;/em&gt;, which can provide additional data such as user names and passwords based on the current PostgreSQL role.</source>
          <target state="translated">Для доступа к удаленным данным может потребоваться аутентификация во внешнем источнике данных. Эта информация может быть предоставлена ​​путем &lt;em&gt;сопоставления пользователей&lt;/em&gt; , которое может предоставить дополнительные данные, такие как имена пользователей и пароли, на основе текущей роли PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="52fe1ef73da9bdc5400467df47e965d263b34732" translate="yes" xml:space="preserve">
          <source>Accessor Operator</source>
          <target state="translated">Аксессуарный оператор</target>
        </trans-unit>
        <trans-unit id="af39d0c333f65451fb8a7cecb17f3d648babe73c" translate="yes" xml:space="preserve">
          <source>Accessor operators listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;Table 8.25&lt;/a&gt;.</source>
          <target state="translated">Операторы доступа перечислены в &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;Таблице 8.25&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a90102b6831b1be9c270ce8e277051052e425746" translate="yes" xml:space="preserve">
          <source>According to the SQL standard all fields of an interval value must have the same sign, so a leading negative sign applies to all fields; for example the negative sign in the interval literal &lt;code&gt;'-1 2:03:04'&lt;/code&gt; applies to both the days and hour/minute/second parts. PostgreSQL allows the fields to have different signs, and traditionally treats each field in the textual representation as independently signed, so that the hour/minute/second part is considered positive in this example. If &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt; then a leading sign is considered to apply to all fields (but only if no additional signs appear). Otherwise the traditional PostgreSQL interpretation is used. To avoid ambiguity, it's recommended to attach an explicit sign to each field if any field is negative.</source>
          <target state="translated">Согласно стандарту SQL все поля значения интервала должны иметь один и тот же знак, поэтому начальный отрицательный знак применяется ко всем полям; например, отрицательный знак в &lt;code&gt;'-1 2:03:04'&lt;/code&gt; интервала &amp;laquo;-1 2:03:04&amp;raquo; применяется как к дням, так и к часам / минутам / секундам . PostgreSQL позволяет полям иметь разные знаки и традиционно рассматривает каждое поле в текстовом представлении как независимо подписанное, поэтому в этом примере часть часа / минуты / секунды считается положительной. Если для &lt;code&gt;IntervalStyle&lt;/code&gt; задано значение &lt;code&gt;sql_standard&lt;/code&gt; тогда считается, что ведущий знак применяется ко всем полям (но только если не появляются дополнительные знаки). В противном случае используется традиционная интерпретация PostgreSQL. Чтобы избежать двусмысленности, рекомендуется прикреплять явный знак к каждому полю, если какое-либо поле отрицательное.</target>
        </trans-unit>
        <trans-unit id="3aa4c2f095ab9191962811c65fa85311b6575f00" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, grant options can be granted to &lt;code&gt;PUBLIC&lt;/code&gt;; PostgreSQL only supports granting grant options to roles.</source>
          <target state="translated">Согласно стандарту SQL, возможности предоставления могут быть предоставлены &lt;code&gt;PUBLIC&lt;/code&gt; ; PostgreSQL поддерживает только предоставление опций предоставления ролям.</target>
        </trans-unit>
        <trans-unit id="1ead55767cf3a2e09a221c81670b8f16ce3da10d" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, omitting &lt;code&gt;ESCAPE&lt;/code&gt; means there is no escape character (rather than defaulting to a backslash), and a zero-length &lt;code&gt;ESCAPE&lt;/code&gt; value is disallowed. PostgreSQL's behavior in this regard is therefore slightly nonstandard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56b4e7b5de2231618fd8815a2cda445e53356b4" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, specifying either &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required in a &lt;code&gt;DROP&lt;/code&gt; command. No database system actually enforces that rule, but whether the default behavior is &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; varies across systems.</source>
          <target state="translated">Согласно стандарту SQL в команде &lt;code&gt;DROP&lt;/code&gt; необходимо указать &lt;code&gt;RESTRICT&lt;/code&gt; или &lt;code&gt;CASCADE&lt;/code&gt; . Фактически ни одна система баз данных не применяет это правило, но поведение по умолчанию &lt;code&gt;RESTRICT&lt;/code&gt; или &lt;code&gt;CASCADE&lt;/code&gt; зависит от системы.</target>
        </trans-unit>
        <trans-unit id="2656819b0489db63b95d67c6ca681b0ebbff6d9d" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the &lt;code&gt;PRIVILEGES&lt;/code&gt; key word in &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; is required. The SQL standard does not support setting the privileges on more than one object per command.</source>
          <target state="translated">В соответствии со стандартом SQL, то &lt;code&gt;PRIVILEGES&lt;/code&gt; ключевое слово в &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; требуется. Стандарт SQL не поддерживает установку привилегий более чем для одного объекта на команду.</target>
        </trans-unit>
        <trans-unit id="63bbcd2e4bc83757343815f2d0c5cf6131ae122b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the command to set this option is</source>
          <target state="translated">В соответствии со стандартом SQL,команда для установки этой опции имеет вид</target>
        </trans-unit>
        <trans-unit id="4b8f45ef50c256265d9c97855d8b0d2a0f3dde8f" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the expressions in the output list should be computed before applying &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, or &lt;code&gt;LIMIT&lt;/code&gt;. This is obviously necessary when using &lt;code&gt;DISTINCT&lt;/code&gt;, since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed after &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt;; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output. PostgreSQL will effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced in &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt; or &lt;code&gt;GROUP BY&lt;/code&gt;. (As a counterexample, &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; clearly must evaluate &lt;code&gt;f(x)&lt;/code&gt; before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so that &lt;code&gt;LIMIT&lt;/code&gt; will act to cut off the output from a set-returning function.</source>
          <target state="translated">Согласно стандарту SQL выражения в выходном списке должны быть вычислены перед применением &lt;code&gt;DISTINCT&lt;/code&gt; , &lt;code&gt;ORDER BY&lt;/code&gt; или &lt;code&gt;LIMIT&lt;/code&gt; . Это, очевидно, необходимо при использовании &lt;code&gt;DISTINCT&lt;/code&gt; , поскольку в противном случае неясно, какие значения делаются различными. Однако во многих случаях удобно, если выходные выражения вычисляются после &lt;code&gt;ORDER BY&lt;/code&gt; и &lt;code&gt;LIMIT&lt;/code&gt; .; особенно, если список вывода содержит какие-либо энергозависимые или дорогостоящие функции. При таком поведении порядок оценок функций становится более интуитивным, и не будет оценок, соответствующих строкам, которые никогда не появляются в выходных данных. PostgreSQL будет эффективно оценивать выходные выражения после сортировки и ограничения, если на эти выражения нет ссылок в &lt;code&gt;DISTINCT&lt;/code&gt; , &lt;code&gt;ORDER BY&lt;/code&gt; или &lt;code&gt;GROUP BY&lt;/code&gt; . (В качестве контрпримера, &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; явно должен оценивать &lt;code&gt;f(x)&lt;/code&gt; перед сортировкой). Выражения вывода, содержащие функции, возвращающие набор, эффективно вычисляются после сортировки и до ограничения, так что &lt;code&gt;LIMIT&lt;/code&gt; будет действовать, чтобы отключить вывод функции, возвращающей набор.</target>
        </trans-unit>
        <trans-unit id="6db467e85d8317c698e30a66a7291c8eafa6149b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the owner of a schema always owns all objects within it. PostgreSQL allows schemas to contain objects owned by users other than the schema owner. This can happen only if the schema owner grants the &lt;code&gt;CREATE&lt;/code&gt; privilege on their schema to someone else, or a superuser chooses to create objects in it.</source>
          <target state="translated">Согласно стандарту SQL, владелец схемы всегда владеет всеми объектами в ней. PostgreSQL позволяет схемам содержать объекты, принадлежащие пользователям, отличным от владельца схемы. Это может произойти, только если владелец схемы предоставит право &lt;code&gt;CREATE&lt;/code&gt; для своей схемы кому-то еще или суперпользователь решит создавать в ней объекты.</target>
        </trans-unit>
        <trans-unit id="3b39ba80593aea6c161c39dff62ffc2f0348762e" translate="yes" xml:space="preserve">
          <source>According to the comp.ai.genetic FAQ it cannot be stressed too strongly that a GA is not a pure random search for a solution to a problem. A GA uses stochastic processes, but the result is distinctly non-random (better than random).</source>
          <target state="translated">В соответствии с comp.ai.genetic FAQ нельзя слишком сильно подчеркивать,что GA не является чистым случайным поиском решения проблемы.В ГА используются стохастические процессы,но результат явно неслучайный (лучше,чем случайный).</target>
        </trans-unit>
        <trans-unit id="2666b06563be42700b836e6d4059dfb52c4a608d" translate="yes" xml:space="preserve">
          <source>According to the standard, the first two characters of an error code denote a class of errors, while the last three characters indicate a specific condition within that class. Thus, an application that does not recognize the specific error code might still be able to infer what to do from the error class.</source>
          <target state="translated">Согласно стандарту,первые два символа кода ошибки обозначают класс ошибок,а последние три символа-конкретное условие внутри этого класса.Таким образом,приложение,которое не распознает конкретный код ошибки,может все же иметь возможность узнать,что делать из класса ошибок.</target>
        </trans-unit>
        <trans-unit id="61abcddacf93fafde9cc0a4bb6f9d2b6e919d03c" translate="yes" xml:space="preserve">
          <source>According to the standard, the source value for a parenthesized sub-list of target column names can be any row-valued expression yielding the correct number of columns. PostgreSQL only allows the source value to be a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt; or a sub-&lt;code&gt;SELECT&lt;/code&gt;. An individual column's updated value can be specified as &lt;code&gt;DEFAULT&lt;/code&gt; in the row-constructor case, but not inside a sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">Согласно стандарту, исходным значением для заключенного в скобки подсписка имен целевых столбцов может быть любое строковое выражение, дающее правильное количество столбцов. PostgreSQL позволяет исходному значению быть только &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;конструктором строки&lt;/a&gt; или вложенным &lt;code&gt;SELECT&lt;/code&gt; . Обновленное значение отдельного столбца может быть указано как &lt;code&gt;DEFAULT&lt;/code&gt; в случае конструктора строки, но не внутри вложенного &lt;code&gt;SELECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0980056b7787afbd8fbd30571ba2c45b1dbaa749" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE INDEX&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">Приобретено &lt;code&gt;CREATE INDEX&lt;/code&gt; (без &lt;code&gt;CONCURRENTLY&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e44eba7914f83fb7f73f8f0a727d44ad52ee7677" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">Получено с помощью &lt;code&gt;CREATE TRIGGER&lt;/code&gt; и некоторых форм &lt;code&gt;ALTER TABLE&lt;/code&gt; (см. &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c03704a90b839a00364666b3432c1fe877f7cfa4" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">Приобретено &lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35b293b84736887604a4df3e4f117c1dcc96bdfc" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;), &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;CREATE STATISTICS&lt;/code&gt;, and certain &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; variants (for full details see &lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt; and &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">Получено с помощью &lt;code&gt;VACUUM&lt;/code&gt; (без &lt;code&gt;FULL&lt;/code&gt; ), &lt;code&gt;ANALYZE&lt;/code&gt; , &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; , &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; , &lt;code&gt;CREATE STATISTICS&lt;/code&gt; и некоторых вариантов &lt;code&gt;ALTER INDEX&lt;/code&gt; и &lt;code&gt;ALTER TABLE&lt;/code&gt; (подробные сведения см. В &lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt; и &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a64648cce36216f47287c3873ec5299a8307659" translate="yes" xml:space="preserve">
          <source>Acquired by the &lt;code&gt;DROP TABLE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;VACUUM FULL&lt;/code&gt;, and &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;) commands. Many forms of &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; also acquire a lock at this level. This is also the default lock mode for &lt;code&gt;LOCK TABLE&lt;/code&gt; statements that do not specify a mode explicitly.</source>
          <target state="translated">Получено &lt;code&gt;REINDEX&lt;/code&gt; &lt;code&gt;DROP TABLE&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; , REINDEX , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;VACUUM FULL&lt;/code&gt; и &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; (без &lt;code&gt;CONCURRENTLY&lt;/code&gt; ). Многие формы &lt;code&gt;ALTER INDEX&lt;/code&gt; и &lt;code&gt;ALTER TABLE&lt;/code&gt; также получают блокировку на этом уровне. Это также режим блокировки по умолчанию для операторов &lt;code&gt;LOCK TABLE&lt;/code&gt; , которые не указывают режим явно.</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="a43a7e7ff4a4d6f955aa729ae7ff758305e7b11f" translate="yes" xml:space="preserve">
          <source>Active txids at the time of the snapshot. The list includes only those active txids between &lt;code&gt;xmin&lt;/code&gt; and &lt;code&gt;xmax&lt;/code&gt;; there might be active txids higher than &lt;code&gt;xmax&lt;/code&gt;. A txid that is &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; and not in this list was already completed at the time of the snapshot, and thus either visible or dead according to its commit status. The list does not include txids of subtransactions.</source>
          <target state="translated">Активные txid на момент создания снимка. Список включает только те активные идентификаторы txid между &lt;code&gt;xmin&lt;/code&gt; и &lt;code&gt;xmax&lt;/code&gt; ; могут быть активные txid выше &lt;code&gt;xmax&lt;/code&gt; . Идентификатор txid, имеющий значение &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; и не входящий в этот список, уже был завершен на момент создания снимка и, следовательно, либо видим, либо мертв в зависимости от его статуса фиксации. Список не включает идентификаторы частичных операций.</target>
        </trans-unit>
        <trans-unit id="409557212ade1f78b39e4494cd71d7a5778b675f" translate="yes" xml:space="preserve">
          <source>Activity status of the WAL receiver process</source>
          <target state="translated">Состояние активности процесса приемника WAL</target>
        </trans-unit>
        <trans-unit id="5074d759e3f5dbe3c6aa005b1369aadfa7087d57" translate="yes" xml:space="preserve">
          <source>Actual data stored in the large object. This will never be more than &lt;code&gt;LOBLKSIZE&lt;/code&gt; bytes and might be less.</source>
          <target state="translated">Актуальные данные хранятся в большом объекте. Это никогда не будет больше байтов &lt;code&gt;LOBLKSIZE&lt;/code&gt; , а может быть меньше.</target>
        </trans-unit>
        <trans-unit id="5cef4a325f0a5fb8a611f2f24f0d274a093ec734" translate="yes" xml:space="preserve">
          <source>Actually the preceding paragraph is an oversimplification: there are two cases in which a function-call construct will be treated as a cast request without having matched it to an actual function. If a function call &lt;code&gt;name&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;) does not exactly match any existing function, but &lt;code&gt;name&lt;/code&gt; is the name of a data type and &lt;code&gt;pg_cast&lt;/code&gt; provides a binary-coercible cast to this type from the type of &lt;code&gt;x&lt;/code&gt;, then the call will be construed as a binary-coercible cast. This exception is made so that binary-coercible casts can be invoked using functional syntax, even though they lack any function. Likewise, if there is no &lt;code&gt;pg_cast&lt;/code&gt; entry but the cast would be to or from a string type, the call will be construed as an I/O conversion cast. This exception allows I/O conversion casts to be invoked using functional syntax.</source>
          <target state="translated">На самом деле предыдущий абзац является чрезмерным упрощением: есть два случая, когда конструкция вызова функции будет рассматриваться как запрос приведения без сопоставления с реальной функцией. Если &lt;code&gt;name&lt;/code&gt; вызова функции ( &lt;code&gt;x&lt;/code&gt; ) не совпадает в точности с какой-либо существующей функцией, но &lt;code&gt;name&lt;/code&gt; - это имя типа данных, а &lt;code&gt;pg_cast&lt;/code&gt; обеспечивает приведение к этому типу с двоичным принуждением из типа &lt;code&gt;x&lt;/code&gt; , тогда вызов будет истолкован как бинарно-принудительное приведение. Это исключение сделано для того, чтобы бинарно-приводимые преобразования могли быть вызваны с использованием функционального синтаксиса, даже если в них отсутствует какая-либо функция. Аналогично, если нет &lt;code&gt;pg_cast&lt;/code&gt; запись, но приведение будет к строковому типу или от него, вызов будет истолкован как преобразование ввода-вывода. Это исключение позволяет вызывать преобразования ввода-вывода с использованием функционального синтаксиса.</target>
        </trans-unit>
        <trans-unit id="99bd76b2471dd3de3de3ab7c1c222041031e9e64" translate="yes" xml:space="preserve">
          <source>Actually, each &amp;ldquo;character&amp;rdquo; can be any string not containing whitespace, so &lt;code&gt;unaccent&lt;/code&gt; dictionaries could be used for other sorts of substring substitutions besides diacritic removal.</source>
          <target state="translated">Фактически, каждый &amp;laquo;символ&amp;raquo; может быть любой строкой, не содержащей пробелов, поэтому словари без &lt;code&gt;unaccent&lt;/code&gt; могут использоваться для других видов подстановок, помимо удаления диакритических знаков.</target>
        </trans-unit>
        <trans-unit id="fb4a150119fee7c38df2ebe67adb1f04cd8a1672" translate="yes" xml:space="preserve">
          <source>Actually, in these example queries, &lt;code&gt;coalesce&lt;/code&gt; should be used to prevent a single &lt;code&gt;NULL&lt;/code&gt; attribute from causing a &lt;code&gt;NULL&lt;/code&gt; result for the whole document.</source>
          <target state="translated">На самом деле, в этих примерах запросов, &lt;code&gt;coalesce&lt;/code&gt; должны использоваться , чтобы предотвратить один &lt;code&gt;NULL&lt;/code&gt; атрибут из вызывая &lt;code&gt;NULL&lt;/code&gt; результат для всего документа.</target>
        </trans-unit>
        <trans-unit id="8f0894c46fc9b6047265c297cf124917360edc17" translate="yes" xml:space="preserve">
          <source>Actually, the even more general syntax</source>
          <target state="translated">Вообще-то,еще более общий синтаксис</target>
        </trans-unit>
        <trans-unit id="9d49dccdc43481d06a4ef58b29107551c088b828" translate="yes" xml:space="preserve">
          <source>Adaptive?</source>
          <target state="translated">Adaptive?</target>
        </trans-unit>
        <trans-unit id="4415296784c0ee879898fb9df132309b61a61a7c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt; or &lt;code&gt;--column-inserts&lt;/code&gt; is also specified.</source>
          <target state="translated">Добавьте &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; к командам &lt;code&gt;INSERT&lt;/code&gt; . Эта опция не действует , если &lt;code&gt;--inserts&lt;/code&gt; или &lt;code&gt;--column-inserts&lt;/code&gt; не указана также.</target>
        </trans-unit>
        <trans-unit id="6e9832f60aad6d89585289ea2e0edf7fc9e5b79b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt;, &lt;code&gt;--column-inserts&lt;/code&gt; or &lt;code&gt;--rows-per-insert&lt;/code&gt; is also specified.</source>
          <target state="translated">Добавьте &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; к командам &lt;code&gt;INSERT&lt;/code&gt; . Эта опция не действует , если &lt;code&gt;--inserts&lt;/code&gt; , &lt;code&gt;--column-inserts&lt;/code&gt; или &lt;code&gt;--rows-per-insert&lt;/code&gt; оно не указана.</target>
        </trans-unit>
        <trans-unit id="df59723089709ab5e5075047c1ac7d254b3f6b22" translate="yes" xml:space="preserve">
          <source>Add a key, or update an existing key with a new value:</source>
          <target state="translated">Добавить ключ или обновить существующий ключ с новым значением:</target>
        </trans-unit>
        <trans-unit id="7a5572f228e469f1c2f4cd272c7b0cda74e7acf6" translate="yes" xml:space="preserve">
          <source>Add a number of days to a date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f3c97b278869eab76434c25a08bb2d9b563aa2" translate="yes" xml:space="preserve">
          <source>Add a time-of-day to a date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bacadfab25c06160832a539f1c1f1901edb824fd" translate="yes" xml:space="preserve">
          <source>Add a transaction script read from &lt;code&gt;filename&lt;/code&gt; to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the test. See below for details.</source>
          <target state="translated">Добавьте сценарий транзакции, прочитанный из &lt;code&gt;filename&lt;/code&gt; в список выполненных сценариев. Необязательный целочисленный вес после &lt;code&gt;@&lt;/code&gt; позволяет настроить вероятность отрисовки теста. Подробнее см. Ниже.</target>
        </trans-unit>
        <trans-unit id="e386cb056d908799805563d1ba2a71ca187f495b" translate="yes" xml:space="preserve">
          <source>Add an interval to a date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30629dc5115a69a1747c013e1cc5a69e275df7a1" translate="yes" xml:space="preserve">
          <source>Add an interval to a time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1ce74f84bf95ea154baff4f8c09c2914ce6d50" translate="yes" xml:space="preserve">
          <source>Add an interval to a timestamp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b612d09d7cda7883ad9f9c1e74b2026a76de08a5" translate="yes" xml:space="preserve">
          <source>Add columns</source>
          <target state="translated">Добавить колонки</target>
        </trans-unit>
        <trans-unit id="fdd20704520d17d4473df8ba637e593e3c1e9d32" translate="yes" xml:space="preserve">
          <source>Add constraints</source>
          <target state="translated">Добавить ограничения</target>
        </trans-unit>
        <trans-unit id="7b67cedcfe4d56f7816bcfdf431ad5afd738eb2a" translate="yes" xml:space="preserve">
          <source>Add intervals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee44cc339a6c285bac845e10d98461ab1145004" translate="yes" xml:space="preserve">
          <source>Add non-overlapping table constraints to the child tables to define the allowed key values in each.</source>
          <target state="translated">Добавьте в дочерние таблицы ограничения,не перекрывающие таблицы,чтобы определить допустимые ключевые значения в каждой из них.</target>
        </trans-unit>
        <trans-unit id="48999cb16b06daffee5cbba84a68d9e3c43940fe" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the function is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the function-local setting is removed, so that the function executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all function-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER FUNCTION&lt;/code&gt; is executed as the value to be applied when the function is entered.</source>
          <target state="translated">Добавьте или измените назначение, которое будет выполнено параметру конфигурации при вызове функции. Если &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;DEFAULT&lt;/code&gt; или, что эквивалентно, &lt;code&gt;RESET&lt;/code&gt; , используется функция локальной установки удаляется, так что функция выполняется со значением , присутствующим в окружающей среде. Используйте &lt;code&gt;RESET ALL&lt;/code&gt; чтобы очистить все локальные настройки функции. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; сохраняет значение параметра, которое является текущим при выполнении &lt;code&gt;ALTER FUNCTION&lt;/code&gt; , как значение, которое будет применяться при входе в функцию.</target>
        </trans-unit>
        <trans-unit id="741a6eebd9634b6405712ee7bced8a90249de64a" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the procedure is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the procedure-local setting is removed, so that the procedure executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all procedure-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; is executed as the value to be applied when the procedure is entered.</source>
          <target state="translated">Добавьте или измените назначение параметра конфигурации при вызове процедуры. Если &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;DEFAULT&lt;/code&gt; или, что эквивалентно, &lt;code&gt;RESET&lt;/code&gt; используется, процедура локальной настройки удаляется, так что процедура выполняется со значением , присутствующим в окружающей среде. Используйте &lt;code&gt;RESET ALL&lt;/code&gt; , чтобы очистить все локальные настройки процедуры. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; сохраняет значение параметра, которое является текущим при выполнении &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; , как значение, которое будет применяться при входе в процедуру.</target>
        </trans-unit>
        <trans-unit id="3e939370f13d4d6648fdf6ebce042de2b0c8b35d" translate="yes" xml:space="preserve">
          <source>Add some tables to the publication:</source>
          <target state="translated">Добавьте несколько таблиц к публикации:</target>
        </trans-unit>
        <trans-unit id="0adf6644f343dab5da55bc308f3c6ee3087cbd49" translate="yes" xml:space="preserve">
          <source>Add the new column, with a default, to &lt;code&gt;pg_proc.h&lt;/code&gt;:</source>
          <target state="translated">Добавьте новый столбец со значением по умолчанию в &lt;code&gt;pg_proc.h&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="752268a69e3b24883f304a215dae5d50dea7c0b0" translate="yes" xml:space="preserve">
          <source>Add the probe definition to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;:</source>
          <target state="translated">Добавьте определение зонда в &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ce0fb0fdfabd7e1bdcafb562c60398cbe55ebe0d" translate="yes" xml:space="preserve">
          <source>Add the probe definitions to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;</source>
          <target state="translated">Добавьте определения зондов в &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4acf1110e0d52a03ba3a64c356b491cd2bd51279" translate="yes" xml:space="preserve">
          <source>Add the specified built-in script to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the script. If not specified, it is set to 1. Available built-in scripts are: &lt;code&gt;tpcb-like&lt;/code&gt;, &lt;code&gt;simple-update&lt;/code&gt; and &lt;code&gt;select-only&lt;/code&gt;. Unambiguous prefixes of built-in names are accepted. With special name &lt;code&gt;list&lt;/code&gt;, show the list of built-in scripts and exit immediately.</source>
          <target state="translated">Добавить указанный встроенный скрипт в список выполняемых скриптов. Необязательный целочисленный вес после &lt;code&gt;@&lt;/code&gt; позволяет настроить вероятность отрисовки скрипта. Если не указано, устанавливается значение 1. Доступные встроенные сценарии: &lt;code&gt;tpcb-like&lt;/code&gt; , &lt;code&gt;simple-update&lt;/code&gt; и &lt;code&gt;select-only&lt;/code&gt; . Допускаются однозначные префиксы встроенных имен. Со специальным &lt;code&gt;list&lt;/code&gt; имен покажите список встроенных скриптов и немедленно выйдите.</target>
        </trans-unit>
        <trans-unit id="c0ab5a63742ff89241c46899c37233e1df7c86b0" translate="yes" xml:space="preserve">
          <source>Add users to a group:</source>
          <target state="translated">Добавить пользователей в группу:</target>
        </trans-unit>
        <trans-unit id="8caea2f156f156f661ed21fc3f27f4bbd2fa80f2" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;NOT NULL&lt;/code&gt; constraint requires scanning the table to verify that existing rows meet the constraint, but does not require a table rewrite.</source>
          <target state="translated">Добавление ограничения &lt;code&gt;CHECK&lt;/code&gt; или &lt;code&gt;NOT NULL&lt;/code&gt; требует сканирования таблицы, чтобы убедиться, что существующие строки соответствуют ограничению, но не требует перезаписи таблицы.</target>
        </trans-unit>
        <trans-unit id="cffe5a53117b776e99930ab76048f8855b384b5a" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause allows a list of columns to be specified which will be included in the non-key portion of the index. Although uniqueness is not enforced on the included columns, the constraint still depends on them. Consequently, some operations on the included columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">Добавление ограничения &lt;code&gt;PRIMARY KEY&lt;/code&gt; автоматически создаст уникальный индекс btree для столбца или группы столбцов, используемых в ограничении. Необязательное предложение &lt;code&gt;INCLUDE&lt;/code&gt; позволяет указать список столбцов, которые будут включены в неключевую часть индекса. Хотя уникальность не применяется к включенным столбцам, ограничение по-прежнему зависит от них. Следовательно, некоторые операции с включенными столбцами (например, &lt;code&gt;DROP COLUMN&lt;/code&gt; ) могут вызвать каскадное ограничение и удаление индекса.</target>
        </trans-unit>
        <trans-unit id="9e3b837b83f00305a477861a47c68fa313f35aa1" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause allows a list of columns to be specified which will be included in the non-key portion of the index. Although uniqueness is not enforced on the included columns, the constraint still depends on them. Consequently, some operations on the included columns (e.g., &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c642f86413e7e0c5d8cf9f40dd1b146f4c06e416" translate="yes" xml:space="preserve">
          <source>Adding a column with a volatile &lt;code&gt;DEFAULT&lt;/code&gt; or changing the type of an existing column will require the entire table and its indexes to be rewritten. As an exception, when changing the type of an existing column, if the &lt;code&gt;USING&lt;/code&gt; clause does not change the column contents and the old type is either binary coercible to the new type or an unconstrained domain over the new type, a table rewrite is not needed; but any indexes on the affected columns must still be rebuilt. Table and/or index rebuilds may take a significant amount of time for a large table; and will temporarily require as much as double the disk space.</source>
          <target state="translated">Добавление столбца с изменчивым значением &lt;code&gt;DEFAULT&lt;/code&gt; или изменение типа существующего столбца потребует перезаписи всей таблицы и ее индексов. В качестве исключения, при изменении типа существующего столбца, если предложение &lt;code&gt;USING&lt;/code&gt; не изменяет содержимое столбца, а старый тип является либо двоичным, приводимым к новому типу, либо неограниченным доменом над новым типом, перезапись таблицы не требуется. ; но любые индексы в затронутых столбцах все равно необходимо перестроить. Перестроение таблицы и / или индекса может занять значительное время для большой таблицы; и временно потребует вдвое больше дискового пространства.</target>
        </trans-unit>
        <trans-unit id="c58efc1059381c4bf8b362143436cd8c4af55346" translate="yes" xml:space="preserve">
          <source>Adding a constraint using an existing index can be helpful in situations where a new constraint needs to be added without blocking table updates for a long time. To do that, create the index using &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, and then install it as an official constraint using this syntax. See the example below.</source>
          <target state="translated">Добавление ограничения с использованием существующего индекса может быть полезным в ситуациях, когда необходимо добавить новое ограничение, не блокируя обновления таблицы в течение длительного времени. Для этого создайте индекс, используя &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; , а затем установите его как официальное ограничение, используя этот синтаксис. См. Пример ниже.</target>
        </trans-unit>
        <trans-unit id="c57d929aced463125ab8b2f66f31b21a04522c5d" translate="yes" xml:space="preserve">
          <source>Adding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, and will force the column(s) to be marked &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">Добавление первичного ключа автоматически создаст уникальный индекс B-дерева для столбца или группы столбцов, перечисленных в первичном ключе, и заставит столбец (столбцы) быть помеченным как &lt;code&gt;NOT NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ee5dc2437e432908c48ca918b4296acc2f6a028" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint. A uniqueness restriction covering only some rows cannot be written as a unique constraint, but it is possible to enforce such a restriction by creating a unique &lt;a href=&quot;indexes-partial&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">Добавление уникального ограничения автоматически создает уникальный индекс B-дерева для столбца или группы столбцов, перечисленных в ограничении. Ограничение уникальности, охватывающее только некоторые строки, не может быть записано как ограничение уникальности, но можно применить такое ограничение, создав уникальный &lt;a href=&quot;indexes-partial&quot;&gt;частичный индекс&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e5ef315a51bb0b0043f1a6d7277abada165d078" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional clause &lt;code&gt;INCLUDE&lt;/code&gt; adds to that index one or more columns on which the uniqueness is not enforced. Note that although the constraint is not enforced on the included columns, it still depends on them. Consequently, some operations on these columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">Добавление уникального ограничения автоматически создаст уникальный индекс btree для столбца или группы столбцов, используемых в ограничении. Необязательное предложение &lt;code&gt;INCLUDE&lt;/code&gt; добавляет к этому индексу один или несколько столбцов, уникальность которых не применяется. Обратите внимание, что хотя ограничение не применяется к включенным столбцам, оно по-прежнему зависит от них. Следовательно, некоторые операции с этими столбцами (например, &lt;code&gt;DROP COLUMN&lt;/code&gt; ) могут вызвать каскадное ограничение и удаление индекса.</target>
        </trans-unit>
        <trans-unit id="fa8235a384df080ad3fe537c45554b56b2b4ea42" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional clause &lt;code&gt;INCLUDE&lt;/code&gt; adds to that index one or more columns on which the uniqueness is not enforced. Note that although the constraint is not enforced on the included columns, it still depends on them. Consequently, some operations on these columns (e.g., &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcad53930a4507d157767aa00d4a8d4f833266c" translate="yes" xml:space="preserve">
          <source>Adding an exclusion constraint will automatically create an index of the type specified in the constraint declaration.</source>
          <target state="translated">Добавление ограничения на исключение автоматически создаст индекс типа,указанного в объявлении ограничения.</target>
        </trans-unit>
        <trans-unit id="7173dacda23801ef619f4e60a2645585a6fe0048" translate="yes" xml:space="preserve">
          <source>Adding parentheses around an RE does not change its greediness.</source>
          <target state="translated">Добавление скобок вокруг РЭ не меняет его жадности.</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="65d284b9baecd42d63cb154eecd228122b272bd2" translate="yes" xml:space="preserve">
          <source>Addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table, in addition to the lock on the table receiving the constraint.</source>
          <target state="translated">Добавление ограничения внешнего ключа требует блокировки &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; для указанной таблицы в дополнение к блокировке таблицы, получающей ограничение.</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">Дополнительные особенности</target>
        </trans-unit>
        <trans-unit id="15680ea5248b05a075106e29ed181bc54958d717" translate="yes" xml:space="preserve">
          <source>Additional binary string manipulation functions are available and are listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.12&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.11&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c24238b1c616d3f7452d5dd9217a02ce8ecaf1" translate="yes" xml:space="preserve">
          <source>Additional binary string manipulation functions are available and are listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.13&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.12&lt;/a&gt;.</source>
          <target state="translated">Доступны дополнительные функции манипулирования двоичной строкой, которые перечислены в &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Таблице 9.13&lt;/a&gt; . Некоторые из них используются внутри компании для реализации стандартных строковых функций SQL, перечисленных в &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Таблице 9.12&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e5fd4e93e599bcb1fb3d2db4b33749ab6dcc12b" translate="yes" xml:space="preserve">
          <source>Additional considerations apply to the use of generated columns.</source>
          <target state="translated">Дополнительные соображения относятся к использованию сгенерированных колонок.</target>
        </trans-unit>
        <trans-unit id="aa325cbf6ead34348f2e89548944a03a6c03ebc9" translate="yes" xml:space="preserve">
          <source>Additional discussion and practical examples can be found in &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;.</source>
          <target state="translated">Дополнительное обсуждение и практические примеры можно найти в &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Разделе 5.8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fbe8c837563c2f0daf28f682cb1a5ab1ec6f6fe" translate="yes" xml:space="preserve">
          <source>Additional enhancements by Andrew Gierth &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;, United Kingdom</source>
          <target state="translated">Дополнительные улучшения от Эндрю Гирта &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt; , Великобритания</target>
        </trans-unit>
        <trans-unit id="0ef08f4faa1371707ef2f6feef718bf54953d0e6" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;hstore&lt;/code&gt; type for the languages PL/Perl and PL/Python. The extensions for PL/Perl are called &lt;code&gt;hstore_plperl&lt;/code&gt; and &lt;code&gt;hstore_plperlu&lt;/code&gt;, for trusted and untrusted PL/Perl. If you install these transforms and specify them when creating a function, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Perl hashes. The extensions for PL/Python are called &lt;code&gt;hstore_plpythonu&lt;/code&gt;, &lt;code&gt;hstore_plpython2u&lt;/code&gt;, and &lt;code&gt;hstore_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Python dictionaries.</source>
          <target state="translated">Доступны дополнительные расширения, реализующие преобразования для типа &lt;code&gt;hstore&lt;/code&gt; для языков PL / Perl и PL / Python. Расширения для PL / Perl называются &lt;code&gt;hstore_plperl&lt;/code&gt; и &lt;code&gt;hstore_plperlu&lt;/code&gt; для надежных и ненадежных PL / Perl. Если вы установите эти преобразования и укажете их при создании функции, значения &lt;code&gt;hstore&lt;/code&gt; будут сопоставлены хешам Perl. Расширения для PL / Python называются &lt;code&gt;hstore_plpythonu&lt;/code&gt; , &lt;code&gt;hstore_plpython2u&lt;/code&gt; и &lt;code&gt;hstore_plpython3u&lt;/code&gt; ( соглашение об именах PL / Python см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Разделе 45.1&lt;/a&gt; ). Если вы их используете, значения &lt;code&gt;hstore&lt;/code&gt; отображаются в словарях Python.</target>
        </trans-unit>
        <trans-unit id="17bd8a6e2056a675b0fbad2a48d38ec5e91b9a37" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;hstore&lt;/code&gt; type for the languages PL/Perl and PL/Python. The extensions for PL/Perl are called &lt;code&gt;hstore_plperl&lt;/code&gt; and &lt;code&gt;hstore_plperlu&lt;/code&gt;, for trusted and untrusted PL/Perl. If you install these transforms and specify them when creating a function, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Perl hashes. The extensions for PL/Python are called &lt;code&gt;hstore_plpythonu&lt;/code&gt;, &lt;code&gt;hstore_plpython2u&lt;/code&gt;, and &lt;code&gt;hstore_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Python dictionaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6954bc39f2ef60e2e03ec59460cfa1e30432da9" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;jsonb&lt;/code&gt; type for different procedural languages.</source>
          <target state="translated">Доступны дополнительные расширения, реализующие преобразования для типа &lt;code&gt;jsonb&lt;/code&gt; для различных процедурных языков.</target>
        </trans-unit>
        <trans-unit id="041eecca386b7ca679e006e4c9dbf17a8a23f03a" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;ltree&lt;/code&gt; type for PL/Python. The extensions are called &lt;code&gt;ltree_plpythonu&lt;/code&gt;, &lt;code&gt;ltree_plpython2u&lt;/code&gt;, and &lt;code&gt;ltree_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you install these transforms and specify them when creating a function, &lt;code&gt;ltree&lt;/code&gt; values are mapped to Python lists. (The reverse is currently not supported, however.)</source>
          <target state="translated">Доступны дополнительные расширения, реализующие преобразования для типа &lt;code&gt;ltree&lt;/code&gt; для PL / Python. Расширения называются &lt;code&gt;ltree_plpythonu&lt;/code&gt; , &lt;code&gt;ltree_plpython2u&lt;/code&gt; и &lt;code&gt;ltree_plpython3u&lt;/code&gt; ( соглашение об именах PL / Python см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Разделе 45.1&lt;/a&gt; ). Если вы установите эти преобразования и укажете их при создании функции, значения &lt;code&gt;ltree&lt;/code&gt; отображаются в списки Python. (Однако в настоящее время обратное не поддерживается.)</target>
        </trans-unit>
        <trans-unit id="5a2588f70de7908623c3d75b4d858ce4b4c9f548" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;ltree&lt;/code&gt; type for PL/Python. The extensions are called &lt;code&gt;ltree_plpythonu&lt;/code&gt;, &lt;code&gt;ltree_plpython2u&lt;/code&gt;, and &lt;code&gt;ltree_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you install these transforms and specify them when creating a function, &lt;code&gt;ltree&lt;/code&gt; values are mapped to Python lists. (The reverse is currently not supported, however.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848e3ef5eb869b4a42890d26de458d77b4145059" translate="yes" xml:space="preserve">
          <source>Additional functions related to statistics collection are listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Table 27.20&lt;/a&gt;.</source>
          <target state="translated">Дополнительные функции, связанные со сбором статистики, перечислены в &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Табл. 27.20&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efb9efc34358e145f231e909fca0c910acaa66eb" translate="yes" xml:space="preserve">
          <source>Additional functions related to statistics collection are listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Table 27.30&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a49395f2c7e958118c2da8e1de4c14e6b60602" translate="yes" xml:space="preserve">
          <source>Additional information about how to invoke the function. Again, the interpretation is language-specific.</source>
          <target state="translated">Дополнительная информация о том,как вызвать функцию.Опять же,интерпретация зависит от языка.</target>
        </trans-unit>
        <trans-unit id="284dcb5991a8da2d3edb0ed1251edf3e8b725229" translate="yes" xml:space="preserve">
          <source>Additional information about subscriptions and logical replication as a whole is available at &lt;a href=&quot;logical-replication-subscription&quot;&gt;Section 30.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">Дополнительная информация о подписках и логической репликации в целом доступна в &lt;a href=&quot;logical-replication-subscription&quot;&gt;Разделах 30.2&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;30&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="031701e67cc64e29e0f780df4ac7b24959b2258c" translate="yes" xml:space="preserve">
          <source>Additional information about subscriptions and logical replication as a whole is available at &lt;a href=&quot;logical-replication-subscription&quot;&gt;Section 30.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eacaa0140464ef9b6f84f47defe84ade132e976" translate="yes" xml:space="preserve">
          <source>Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign (&lt;code&gt;-&lt;/code&gt;) which will cause the format specifier's output to be left-justified. This has no effect unless the &lt;code&gt;width&lt;/code&gt; field is also specified.</source>
          <target state="translated">Дополнительные параметры, управляющие форматированием вывода спецификатора формата. В настоящее время единственным поддерживаемым флагом является знак минус ( &lt;code&gt;-&lt;/code&gt; ), который приводит к выравниванию вывода спецификатора формата по левому краю. Это не имеет никакого эффекта, если также не указано поле &lt;code&gt;width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2569d5e654fdba9e13f3a3587c2c0d71e119a8f" translate="yes" xml:space="preserve">
          <source>Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign (&lt;code&gt;-&lt;/code&gt;) which will cause the format specifier's output to be left-justified. This has no effect unless the &lt;em&gt;&lt;code&gt;width&lt;/code&gt;&lt;/em&gt; field is also specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fdddce1ec06b246bce73843e8826c300263ddb0" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique indexes are applied to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">Дополнительные ограничения применяются, когда уникальные индексы применяются к многораздельным таблицам; см. &lt;a href=&quot;sql-createtable&quot;&gt;СОЗДАТЬ ТАБЛИЦУ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9379cab208a52cab9a14d1960740e0e9980c40a5" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique or primary key constraints are added to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. Also, foreign key constraints on partitioned tables may not be declared &lt;code&gt;NOT VALID&lt;/code&gt; at present.</source>
          <target state="translated">Дополнительные ограничения применяются, когда ограничения уникальности или первичного ключа добавляются к многораздельным таблицам; см. &lt;a href=&quot;sql-createtable&quot;&gt;СОЗДАТЬ ТАБЛИЦУ&lt;/a&gt; . Кроме того, ограничения внешнего ключа для секционированных таблиц в настоящее время не могут быть объявлены как &lt;code&gt;NOT VALID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8765f8e8e885763ce10457dabe0ae485bb31d5b" translate="yes" xml:space="preserve">
          <source>Additional string manipulation functions are available and are listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;Table 9.10&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;.</source>
          <target state="translated">Доступны дополнительные функции манипулирования строками, которые перечислены в &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;Таблице 9.10&lt;/a&gt; . Некоторые из них используются внутри компании для реализации стандартных строковых функций SQL, перечисленных в &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Таблице 9.9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="010f13497a3e5b588a77355b773385544bc33904" translate="yes" xml:space="preserve">
          <source>Additional updates were made by Joshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; in July 2006. These include &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; and cleaning up the code to use the V1 call protocol instead of the deprecated V0 protocol.</source>
          <target state="translated">Дополнительные обновления были сделаны Джошуа Райхом &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; в июле 2006 года. Они включают &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; и очистку кода для использования протокола вызовов V1 вместо устаревшего протокола V0.</target>
        </trans-unit>
        <trans-unit id="a5f30130c7eb4575fcc776243da7a4179d9cf6f4" translate="yes" xml:space="preserve">
          <source>Additional, more detailed, description of the parameter</source>
          <target state="translated">Дополнительное,более подробное описание параметра</target>
        </trans-unit>
        <trans-unit id="f10aed98f8a0fbbcdcab810e37d64419e4b89806" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;em&gt;comments&lt;/em&gt; can occur in SQL input. They are not tokens, they are effectively equivalent to whitespace.</source>
          <target state="translated">Кроме того, &lt;em&gt;комментарии&lt;/em&gt; могут возникать при вводе данных SQL. Это не токены, они фактически эквивалентны пробелам.</target>
        </trans-unit>
        <trans-unit id="3ce7d7c047715fd1454a60e6f8ab9c8a858ce3b2" translate="yes" xml:space="preserve">
          <source>Additionally, an alias is required if the table reference is a subquery (see &lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;Section 7.2.1.3&lt;/a&gt;).</source>
          <target state="translated">Кроме того, псевдоним требуется, если ссылка на таблицу является подзапросом (см. &lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;Раздел 7.2.1.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2987436262917a5192b10eeed405ee0544038a4c" translate="yes" xml:space="preserve">
          <source>Additionally, if a query usually requires an implicit conversion for a function, and if then the user defines a new function with the correct argument types, the parser should use this new function and no longer do implicit conversion to use the old function.</source>
          <target state="translated">Кроме того,если запрос обычно требует неявного преобразования для функции,и если тогда пользователь определяет новую функцию с правильными типами аргументов,синтаксический анализатор должен использовать эту новую функцию и больше не делать неявного преобразования для использования старой функции.</target>
        </trans-unit>
        <trans-unit id="0a6ee1654a9731eebc2384fd193841ff3bb1bd0e" translate="yes" xml:space="preserve">
          <source>Additionally, if you are running PostgreSQL inside a zone, you may need to raise the zone resource usage limits as well. See &quot;Chapter2: Projects and Tasks&quot; in the &lt;em&gt;System Administrator's Guide&lt;/em&gt; for more information on &lt;code&gt;projects&lt;/code&gt; and &lt;code&gt;prctl&lt;/code&gt;.</source>
          <target state="translated">Кроме того, если вы используете PostgreSQL внутри зоны, вам также может потребоваться увеличить лимит использования ресурсов зоны. См. &quot;Chapter2: Projects and Tasks&quot; в &lt;em&gt;Руководстве системного администратора&lt;/em&gt; для получения дополнительной информации о &lt;code&gt;projects&lt;/code&gt; и &lt;code&gt;prctl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0aee321f704c4c1848fccdf5704c469a83987cc5" translate="yes" xml:space="preserve">
          <source>Additionally, refresh options as described under &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; may be specified.</source>
          <target state="translated">Кроме того, могут быть указаны параметры обновления, описанные в разделе &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78567ce71a3b54c604529593f06074abcf105927" translate="yes" xml:space="preserve">
          <source>Additionally, the SQL standard collation name &lt;code&gt;ucs_basic&lt;/code&gt; is available for encoding &lt;code&gt;UTF8&lt;/code&gt;. It is equivalent to &lt;code&gt;C&lt;/code&gt; and sorts by Unicode code point.</source>
          <target state="translated">Кроме того, для кодировки &lt;code&gt;UTF8&lt;/code&gt; доступно стандартное имя сортировки SQL &lt;code&gt;ucs_basic&lt;/code&gt; . Он эквивалентен &lt;code&gt;C&lt;/code&gt; и сортируется по кодовой точке Unicode.</target>
        </trans-unit>
        <trans-unit id="53f8119d06cd2559361245d09ce9820bdfc91e36" translate="yes" xml:space="preserve">
          <source>Adds an offset to an address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5aedd449033d6b8107ae365cb24a243a1adca0c" translate="yes" xml:space="preserve">
          <source>Adds collations to the system catalog &lt;code&gt;pg_collation&lt;/code&gt; based on all the locales it finds in the operating system. This is what &lt;code&gt;initdb&lt;/code&gt; uses; see &lt;a href=&quot;collation#COLLATION-MANAGING&quot;&gt;Section 23.2.2&lt;/a&gt; for more details. If additional locales are installed into the operating system later on, this function can be run again to add collations for the new locales. Locales that match existing entries in &lt;code&gt;pg_collation&lt;/code&gt; will be skipped. (But collation objects based on locales that are no longer present in the operating system are not removed by this function.) The &lt;em&gt;&lt;code&gt;schema&lt;/code&gt;&lt;/em&gt; parameter would typically be &lt;code&gt;pg_catalog&lt;/code&gt;, but that is not a requirement; the collations could be installed into some other schema as well. The function returns the number of new collation objects it created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e874368d9d21cc7beffa67760d80cf1b272a6209" translate="yes" xml:space="preserve">
          <source>Adds element to end of array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36522cf2f752a15facac71afeb7f67a4b36db952" translate="yes" xml:space="preserve">
          <source>Adds the coordinates of the second &lt;code&gt;point&lt;/code&gt; to those of each point of the first argument, thus performing translation. Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c767351a24f76f0563dcac6f0be4bd35c8869c" translate="yes" xml:space="preserve">
          <source>Adjust interval so 24-hour time periods are represented as days</source>
          <target state="translated">Отрегулируйте интервал таким образом,чтобы 24-часовые временные промежутки были представлены в виде дней.</target>
        </trans-unit>
        <trans-unit id="7279c011b0d2f4cdb22e6caf6d21633e1e395dfa" translate="yes" xml:space="preserve">
          <source>Adjust interval so 30-day time periods are represented as months</source>
          <target state="translated">Отрегулируйте интервал так,чтобы 30-дневные периоды времени были представлены как месяцы.</target>
        </trans-unit>
        <trans-unit id="0d09f290462815bf94d7d19b5220a29471c8dd87" translate="yes" xml:space="preserve">
          <source>Adjust interval using &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt;, with additional sign adjustments</source>
          <target state="translated">Отрегулируйте интервал с помощью &lt;code&gt;justify_days&lt;/code&gt; и &lt;code&gt;justify_hours&lt;/code&gt; с дополнительными настройками знаков</target>
        </trans-unit>
        <trans-unit id="d5274237f32eaf0cd335b0f45d9e9e406fe2937c" translate="yes" xml:space="preserve">
          <source>Adjust temperature entries and reset precipitation to its default value in one row of the table &lt;code&gt;weather&lt;/code&gt;:</source>
          <target state="translated">Настройте значения температуры и сбросьте количество осадков до значения по умолчанию в одной строке таблицы &lt;code&gt;weather&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="597cf96132dd221de223e71df7ddc2feda8ca0e0" translate="yes" xml:space="preserve">
          <source>Adjustable printing options are:</source>
          <target state="translated">Имеются регулируемые опции печати:</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="25a6044596d068aa8f0b03a3756a046b4662f84e" translate="yes" xml:space="preserve">
          <source>Administration Functions</source>
          <target state="translated">Функции администрирования</target>
        </trans-unit>
        <trans-unit id="9ff417ada04d397f658792af845a2743c3df515c" translate="yes" xml:space="preserve">
          <source>Administrators can grant access to these roles to users using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command, for example:</source>
          <target state="translated">Администраторы могут предоставить доступ к этим ролям пользователям с помощью команды &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; , например:</target>
        </trans-unit>
        <trans-unit id="5748ca9fbce0c666d06fe84d7811e46cfd6b343d" translate="yes" xml:space="preserve">
          <source>Advance sequence and return new value</source>
          <target state="translated">Предварительная последовательность и возврат нового значения</target>
        </trans-unit>
        <trans-unit id="4d638e9190ad6b08f1c75c8684e03ac19dde11c0" translate="yes" xml:space="preserve">
          <source>Advance the sequence object to its next value and return that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value.</source>
          <target state="translated">Переместите объект последовательности к его следующему значению и верните это значение. Это делается атомарно: даже если несколько сеансов выполняются &lt;code&gt;nextval&lt;/code&gt; одновременно, каждый безопасно получит отдельное значение последовательности.</target>
        </trans-unit>
        <trans-unit id="05743e363937b509ed8a8c4f9befec86cf089852" translate="yes" xml:space="preserve">
          <source>Advanced Configuration and Power Interface (ACPI) provides a Power Management (PM) Timer, which Linux refers to as the acpi_pm. The clock derived from acpi_pm will at best provide 300 nanosecond resolution.</source>
          <target state="translated">Расширенный интерфейс конфигурации и питания (ACPI)предоставляет таймер управления питанием (PM),который Linux называет acpi_pm.Часы,полученные от acpi_pm,в лучшем случае обеспечивают разрешение 300 наносекунд.</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">Дополнительные функции</target>
        </trans-unit>
        <trans-unit id="40fdbd870880a4ac68ea44233cfb9a2306bc99de" translate="yes" xml:space="preserve">
          <source>Advanced users can use regular-expression notations such as character classes, for example &lt;code&gt;[0-9]&lt;/code&gt; to match any digit. All regular expression special characters work as specified in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;, except for &lt;code&gt;.&lt;/code&gt; which is taken as a separator as mentioned above, &lt;code&gt;*&lt;/code&gt; which is translated to the regular-expression notation &lt;code&gt;.*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; which is translated to &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;$&lt;/code&gt; which is matched literally. You can emulate these pattern characters at need by writing &lt;code&gt;?&lt;/code&gt; for &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;(R+|)&lt;/code&gt; for &lt;code&gt;R*&lt;/code&gt;, or &lt;code&gt;(R|)&lt;/code&gt; for &lt;code&gt;R?&lt;/code&gt;. &lt;code&gt;$&lt;/code&gt; is not needed as a regular-expression character since the pattern must match the whole name, unlike the usual interpretation of regular expressions (in other words, &lt;code&gt;$&lt;/code&gt; is automatically appended to your pattern). Write &lt;code&gt;*&lt;/code&gt; at the beginning and/or end if you don't wish the pattern to be anchored. Note that within double quotes, all regular expression special characters lose their special meanings and are matched literally. Also, the regular expression special characters are matched literally in operator name patterns (i.e., the argument of &lt;code&gt;\do&lt;/code&gt;).</source>
          <target state="translated">Опытные пользователи могут использовать обозначения регулярных выражений, такие как классы символов, например &lt;code&gt;[0-9]&lt;/code&gt; , чтобы соответствовать любой цифре. Все специальные символы регулярных выражений работают, как указано в &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Разделе 9.7.3&lt;/a&gt; , за исключением &lt;code&gt;.&lt;/code&gt; который взят в качестве разделителя , как указано выше, &lt;code&gt;*&lt;/code&gt; что в переводе на регулярных выражений нотации &lt;code&gt;.*&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; который переведен на &lt;code&gt;.&lt;/code&gt; , и &lt;code&gt;$&lt;/code&gt; , что соответствует буквально. Вы можете при необходимости подражать этим образцам, написав &lt;code&gt;?&lt;/code&gt; для &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;(R+|)&lt;/code&gt; для &lt;code&gt;R*&lt;/code&gt; или &lt;code&gt;(R|)&lt;/code&gt; для &lt;code&gt;R?&lt;/code&gt; . &lt;code&gt;$&lt;/code&gt; не требуется в качестве символа регулярного выражения, поскольку шаблон должен совпадать со всем именем, в отличие от обычной интерпретации регулярных выражений (другими словами, &lt;code&gt;$&lt;/code&gt; автоматически добавляется к вашему шаблону). Напишите &lt;code&gt;*&lt;/code&gt; в начале и / или в конце, если вы не хотите, чтобы шаблон был привязан. Обратите внимание, что в двойных кавычках все специальные символы регулярных выражений теряют свое особое значение и совпадают буквально. Кроме того, специальные символы регулярных выражений буквально сопоставляются в шаблонах имен операторов (т. Е. Аргументе &lt;code&gt;\do&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ae1d5d5862d5067d5253f55fa2d10173937d4fc6" translate="yes" xml:space="preserve">
          <source>Advances the current confirmed position of a replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. The slot will not be moved backwards, and it will not be moved beyond the current insert location. Returns name of the slot and real position to which it was advanced to.</source>
          <target state="translated">Перемещает текущую подтвержденную позицию слота репликации с именем &lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt; . Слот не будет перемещен назад и не будет перемещен за пределы текущего места вставки. Возвращает имя слота и реальную позицию, на которую он был продвинут.</target>
        </trans-unit>
        <trans-unit id="3d5aab029628974dd5c58605edc8a94526445808" translate="yes" xml:space="preserve">
          <source>Advances the current confirmed position of a replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. The slot will not be moved backwards, and it will not be moved beyond the current insert location. Returns the name of the slot and the actual position that it was advanced to. The updated slot position information is written out at the next checkpoint if any advancing is done. So in the event of a crash, the slot may return to an earlier position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c81d024a1ba21f51051976ec1e66bb25143e15" translate="yes" xml:space="preserve">
          <source>Advances the sequence object to its next value and returns that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value. If the sequence object has been created with default parameters, successive &lt;code&gt;nextval&lt;/code&gt; calls will return successive values beginning with 1. Other behaviors can be obtained by using appropriate parameters in the &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d323581d870eb70c61501cdd5933132dd855a86" translate="yes" xml:space="preserve">
          <source>Advisory locks can be acquired on keys consisting of either a single &lt;code&gt;bigint&lt;/code&gt; value or two integer values. A &lt;code&gt;bigint&lt;/code&gt; key is displayed with its high-order half in the &lt;code&gt;classid&lt;/code&gt; column, its low-order half in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 1. The original &lt;code&gt;bigint&lt;/code&gt; value can be reassembled with the expression &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt;. Integer keys are displayed with the first key in the &lt;code&gt;classid&lt;/code&gt; column, the second key in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 2. The actual meaning of the keys is up to the user. Advisory locks are local to each database, so the &lt;code&gt;database&lt;/code&gt; column is meaningful for an advisory lock.</source>
          <target state="translated">Консультативные блокировки могут быть получены для ключей, состоящих либо из одного значения &lt;code&gt;bigint&lt;/code&gt; , либо из двух целых значений. &lt;code&gt;bigint&lt;/code&gt; ключ отображается с его высоким порядком половиной в &lt;code&gt;classid&lt;/code&gt; колонка, ее низкий порядок половина в &lt;code&gt;objid&lt;/code&gt; колонки, и &lt;code&gt;objsubid&lt;/code&gt; равного 1. Оригинальный &lt;code&gt;bigint&lt;/code&gt; значение может быть повторно собрана с выражением &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt; . Клавиши Целые отображаются с первым ключом в &lt;code&gt;classid&lt;/code&gt; колонка, вторым ключом в &lt;code&gt;objid&lt;/code&gt; колонки, и &lt;code&gt;objsubid&lt;/code&gt; равного 2. Фактическое значение клавиша составляет до пользователя. Консультативные блокировки являются локальными для каждой базы данных, поэтому &lt;code&gt;database&lt;/code&gt; Столбец базы данных имеет значение для рекомендательной блокировки.</target>
        </trans-unit>
        <trans-unit id="f6c29c3eec39081073449cf551f29f5ff2063ec1" translate="yes" xml:space="preserve">
          <source>Advisory locks work normally in recovery, including deadlock detection. Note that advisory locks are never WAL logged, so it is impossible for an advisory lock on either the primary or the standby to conflict with WAL replay. Nor is it possible to acquire an advisory lock on the primary and have it initiate a similar advisory lock on the standby. Advisory locks relate only to the server on which they are acquired.</source>
          <target state="translated">Консультативные замки нормально работают при восстановлении,включая обнаружение тупика.Обратите внимание,что консультативные замки никогда не записываются в журнал WAL,поэтому невозможно,чтобы консультативный замок на первичном или резервном устройстве вступил в конфликт с воспроизведением WAL.Невозможно также приобрести консультативный замок на первичном и заставить его запустить аналогичный консультативный замок в режиме ожидания.Консультативные блокировки относятся только к тому серверу,на котором они приобретены.</target>
        </trans-unit>
        <trans-unit id="87db6f29dc76387bbaab5ded1909ba41ea3e370f" translate="yes" xml:space="preserve">
          <source>After a checkpoint has been made and the log flushed, the checkpoint's position is saved in the file &lt;code&gt;pg_control&lt;/code&gt;. Therefore, at the start of recovery, the server first reads &lt;code&gt;pg_control&lt;/code&gt; and then the checkpoint record; then it performs the REDO operation by scanning forward from the log location indicated in the checkpoint record. Because the entire content of data pages is saved in the log on the first page modification after a checkpoint (assuming &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is not disabled), all pages changed since the checkpoint will be restored to a consistent state.</source>
          <target state="translated">После того, как контрольная точка была создана и журнал очищен, положение контрольной точки сохраняется в файле &lt;code&gt;pg_control&lt;/code&gt; . Следовательно, в начале восстановления сервер сначала читает &lt;code&gt;pg_control&lt;/code&gt; , а затем запись контрольной точки; затем он выполняет операцию REDO, просматривая вперед от места журнала, указанного в записи контрольной точки. Поскольку все содержимое страниц данных сохраняется в журнале при изменении первой страницы после контрольной точки (при условии, что &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; не отключен), все страницы были изменены, так как контрольная точка будет восстановлена ​​до согласованного состояния.</target>
        </trans-unit>
        <trans-unit id="c70bb87984515ab084a4a6675924bc032765ff87" translate="yes" xml:space="preserve">
          <source>After a commit record has been written to disk on the primary, the WAL record is then sent to the standby. The standby sends reply messages each time a new batch of WAL data is written to disk, unless &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; is set to zero on the standby. In the case that &lt;code&gt;synchronous_commit&lt;/code&gt; is set to &lt;code&gt;remote_apply&lt;/code&gt;, the standby sends reply messages when the commit record is replayed, making the transaction visible. If the standby is chosen as a synchronous standby, according to the setting of &lt;code&gt;synchronous_standby_names&lt;/code&gt; on the primary, the reply messages from that standby will be considered along with those from other synchronous standbys to decide when to release transactions waiting for confirmation that the commit record has been received. These parameters allow the administrator to specify which standby servers should be synchronous standbys. Note that the configuration of synchronous replication is mainly on the master. Named standbys must be directly connected to the master; the master knows nothing about downstream standby servers using cascaded replication.</source>
          <target state="translated">После того, как запись фиксации была записана на диск на основном сервере, запись WAL отправляется на резервный. Резервный сервер отправляет ответные сообщения каждый раз, когда новый пакет данных WAL записывается на диск, если только &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; не установлен в ноль на резервном сервере . Если для параметра &lt;code&gt;synchronous_commit&lt;/code&gt; установлено значение &lt;code&gt;remote_apply&lt;/code&gt; , резервный сервер отправляет ответные сообщения, когда запись фиксации воспроизводится, что делает транзакцию видимой. Если резервный режим выбран как синхронный резервный, в соответствии с настройкой &lt;code&gt;synchronous_standby_names&lt;/code&gt; на первичном сервере ответные сообщения от этого резервного будут рассматриваться вместе с сообщениями от других синхронных резервных серверов, чтобы решить, когда освободить транзакции, ожидая подтверждения того, что запись фиксации была получена. Эти параметры позволяют администратору указать, какие резервные серверы должны быть синхронными резервными. Обратите внимание, что конфигурация синхронной репликации в основном выполняется на мастере. Именованные резервные серверы должны быть напрямую подключены к мастеру; Мастер ничего не знает о подчиненных резервных серверах, использующих каскадную репликацию.</target>
        </trans-unit>
        <trans-unit id="94241391dfbbfde4a951b39750ed3743aeb3267e" translate="yes" xml:space="preserve">
          <source>After a query has produced an output table (after the select list has been processed) it can optionally be sorted. If sorting is not chosen, the rows will be returned in an unspecified order. The actual order in that case will depend on the scan and join plan types and the order on disk, but it must not be relied on. A particular output ordering can only be guaranteed if the sort step is explicitly chosen.</source>
          <target state="translated">После того,как запрос создал выходную таблицу (после обработки списка выделенных),ее можно дополнительно отсортировать.Если сортировка не выбрана,строки будут возвращены в неуказанном порядке.Реальный порядок в этом случае будет зависеть от типов плана сканирования и объединения,а также от порядка на диске,но на него нельзя полагаться.Определенный выходной порядок может быть гарантирован только в том случае,если шаг сортировки выбран явно.</target>
        </trans-unit>
        <trans-unit id="3b97640c2ecb0afe6be98ec8bef630298c29b1bf" translate="yes" xml:space="preserve">
          <source>After a sequence is created, you use the functions &lt;code&gt;nextval&lt;/code&gt;, &lt;code&gt;currval&lt;/code&gt;, and &lt;code&gt;setval&lt;/code&gt; to operate on the sequence. These functions are documented in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">После создания последовательности вы используете функции &lt;code&gt;nextval&lt;/code&gt; , &lt;code&gt;currval&lt;/code&gt; и &lt;code&gt;setval&lt;/code&gt; для работы с последовательностью. Эти функции описаны в &lt;a href=&quot;functions-sequence&quot;&gt;Разделе 9.16&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff749f2ca9f8a705af6bd96ce00013a3fb590b4b" translate="yes" xml:space="preserve">
          <source>After a sequence is created, you use the functions &lt;code&gt;nextval&lt;/code&gt;, &lt;code&gt;currval&lt;/code&gt;, and &lt;code&gt;setval&lt;/code&gt; to operate on the sequence. These functions are documented in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6fe30bfc047dc5821b58053e75c58c27a7d060" translate="yes" xml:space="preserve">
          <source>After a successful rewind, the state of the target data directory is analogous to a base backup of the source data directory. Unlike taking a new base backup or using a tool like rsync, pg_rewind does not require comparing or copying unchanged relation blocks in the cluster. Only changed blocks from existing relation files are copied; all other files, including new relation files, configuration files, and WAL segments, are copied in full. As such the rewind operation is significantly faster than other approaches when the database is large and only a small fraction of blocks differ between the clusters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc113f99607193995354648154db9d5489f2fd2b" translate="yes" xml:space="preserve">
          <source>After an index is created, the system has to keep it synchronized with the table. This adds overhead to data manipulation operations. Therefore indexes that are seldom or never used in queries should be removed.</source>
          <target state="translated">После создания индекса система должна синхронизировать его с таблицей.Это добавляет накладных расходов к операциям по манипулированию данными.Поэтому индексы,которые редко или никогда не используются в запросах,должны быть удалены.</target>
        </trans-unit>
        <trans-unit id="07e3f54a730eab0090b9f9763615353b60509ba8" translate="yes" xml:space="preserve">
          <source>After completing the tests, it's recommended you disable the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter:</source>
          <target state="translated">После завершения тестов рекомендуется отключить параметр &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b07e5c0448618c87913bcee1323b05d5b460e37c" translate="yes" xml:space="preserve">
          <source>After creating partitions of &lt;code&gt;measurement_y2006m02&lt;/code&gt;, any data inserted into &lt;code&gt;measurement&lt;/code&gt; that is mapped to &lt;code&gt;measurement_y2006m02&lt;/code&gt; (or data that is directly inserted into &lt;code&gt;measurement_y2006m02&lt;/code&gt;, provided it satisfies its partition constraint) will be further redirected to one of its partitions based on the &lt;code&gt;peaktemp&lt;/code&gt; column. The partition key specified may overlap with the parent's partition key, although care should be taken when specifying the bounds of a sub-partition such that the set of data it accepts constitutes a subset of what the partition's own bounds allows; the system does not try to check whether that's really the case.</source>
          <target state="translated">После создания разделов &lt;code&gt;measurement_y2006m02&lt;/code&gt; любые данные, вставленные в &lt;code&gt;measurement&lt;/code&gt; , которое сопоставлено с &lt;code&gt;measurement_y2006m02&lt;/code&gt; (или данные, которые непосредственно вставляются в &lt;code&gt;measurement_y2006m02&lt;/code&gt; , при условии, что они удовлетворяют ограничению разделения), будут далее перенаправлены в один из его разделов на &lt;code&gt;peaktemp&lt;/code&gt; столбца пиковой температуры . Указанный ключ раздела может перекрываться с ключом раздела родителя, хотя следует проявлять осторожность при указании границ подраздела, чтобы набор данных, который он принимает, составлял подмножество того, что допускают собственные границы раздела; система не пытается проверить, действительно ли это так.</target>
        </trans-unit>
        <trans-unit id="db536621da1a6c52f06af534df944428be135246" translate="yes" xml:space="preserve">
          <source>After creating the function, we create a trigger which calls the trigger function:</source>
          <target state="translated">После создания функции мы создаем триггер,который вызывает функцию триггера:</target>
        </trans-unit>
        <trans-unit id="c393be77ecb9862e06e4a42080ca1b8d309670b1" translate="yes" xml:space="preserve">
          <source>After modifying that file, a reboot is required for the new settings to take effect.</source>
          <target state="translated">После изменения этого файла требуется перезагрузка,чтобы новые настройки вступили в силу.</target>
        </trans-unit>
        <trans-unit id="c876187243218ed419e1b156be87fd9454c80ab8" translate="yes" xml:space="preserve">
          <source>After passing the &lt;code&gt;WHERE&lt;/code&gt; filter, the derived input table might be subject to grouping, using the &lt;code&gt;GROUP BY&lt;/code&gt; clause, and elimination of group rows using the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">После прохождения фильтра &lt;code&gt;WHERE&lt;/code&gt; производная входная таблица может быть подвергнута группировке с использованием предложения &lt;code&gt;GROUP BY&lt;/code&gt; и исключению групповых строк с помощью предложения &lt;code&gt;HAVING&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="476a32ba88141aeb970e81601edc2ee511e8c4b9" translate="yes" xml:space="preserve">
          <source>After reaching the end of valid WAL, keep polling once per second for new WAL to appear.</source>
          <target state="translated">После достижения конца действительного WAL,продолжайте опрашивать один раз в секунду на появление нового WAL.</target>
        </trans-unit>
        <trans-unit id="fd721ac53a17faa8b9db323757ed059c923d71fc" translate="yes" xml:space="preserve">
          <source>After recompiling and running the new binary, check that your newly added probe is available by executing the following DTrace command. You should see similar output:</source>
          <target state="translated">После перекомпиляции и запуска нового двоичного файла проверьте,доступен ли вновь добавленный зонд,выполнив следующую команду DTrace.Вы должны увидеть аналогичный вывод:</target>
        </trans-unit>
        <trans-unit id="c206de8ceae00b19b0bbd697b5fe278bf3d62023" translate="yes" xml:space="preserve">
          <source>After restoring a backup, it is wise to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on each database so the query optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. For more advice on how to load large amounts of data into PostgreSQL efficiently, refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt;.</source>
          <target state="translated">После восстановления резервной копии целесообразно запустить &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; для каждой базы данных, чтобы оптимизатор запросов имел полезную статистику; см. &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Раздел 24.1.3&lt;/a&gt; и &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Раздел 24.1.6&lt;/a&gt; для получения дополнительной информации. Дополнительные советы по эффективной загрузке больших объемов данных в PostgreSQL см. В &lt;a href=&quot;populate&quot;&gt;Разделе 14.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="417976bf060ad8e20656ba39a451c14e19b1e474" translate="yes" xml:space="preserve">
          <source>After rolling back to a savepoint, it continues to be defined, so you can roll back to it several times. Conversely, if you are sure you won't need to roll back to a particular savepoint again, it can be released, so the system can free some resources. Keep in mind that either releasing or rolling back to a savepoint will automatically release all savepoints that were defined after it.</source>
          <target state="translated">После отката к точке сохранения,она продолжает определяться,так что вы можете откатиться к ней несколько раз.И наоборот,если вы уверены,что вам не придется откатываться к определенной точке сохранения снова,она может быть освобождена,так что система может освободить некоторые ресурсы.Имейте в виду,что либо освобождение,либо откат к точке сохранения автоматически освободит все точки сохранения,которые были определены после нее.</target>
        </trans-unit>
        <trans-unit id="39ee00792319dcfa46ab74c067181f9cb4e42b47" translate="yes" xml:space="preserve">
          <source>After running pg_rewind, WAL replay needs to complete for the data directory to be in a consistent state. When the target server is started again it will enter archive recovery and replay all WAL generated in the source server from the last checkpoint before the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and by configuring a suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cf5063e2afd451a505eeabbaaa31e6dea2f166" translate="yes" xml:space="preserve">
          <source>After running this command, it should be possible to start the server, but bear in mind that the database might contain inconsistent data due to partially-committed transactions. You should immediately dump your data, run &lt;code&gt;initdb&lt;/code&gt;, and reload. After reload, check for inconsistencies and repair as needed.</source>
          <target state="translated">После выполнения этой команды можно будет запустить сервер, но имейте в виду, что база данных может содержать противоречивые данные из-за частично зафиксированных транзакций. Вы должны немедленно выгрузить свои данные, запустить &lt;code&gt;initdb&lt;/code&gt; и перезагрузить. После перезагрузки проверьте наличие несоответствий и при необходимости отремонтируйте.</target>
        </trans-unit>
        <trans-unit id="f1751e378d5c61831bc66381dd026a28d4a7604f" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;auth-method&lt;/code&gt; field, there can be field(s) of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; that specify options for the authentication method. Details about which options are available for which authentication methods appear below.</source>
          <target state="translated">После поля &lt;code&gt;auth-method&lt;/code&gt; могут быть поля формы &lt;code&gt;name&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; , которые определяют параметры для метода аутентификации. Подробная информация о доступных вариантах и ​​методах аутентификации приводится ниже.</target>
        </trans-unit>
        <trans-unit id="129d74f6272df45af1d745e991e7a73feebafe5a" translate="yes" xml:space="preserve">
          <source>After the processing of the &lt;code&gt;FROM&lt;/code&gt; clause is done, each row of the derived virtual table is checked against the search condition. If the result of the condition is true, the row is kept in the output table, otherwise (i.e., if the result is false or null) it is discarded. The search condition typically references at least one column of the table generated in the &lt;code&gt;FROM&lt;/code&gt; clause; this is not required, but otherwise the &lt;code&gt;WHERE&lt;/code&gt; clause will be fairly useless.</source>
          <target state="translated">После завершения обработки предложения &lt;code&gt;FROM&lt;/code&gt; каждая строка производной виртуальной таблицы проверяется на соответствие условию поиска. Если результат условия истинен, строка сохраняется в выходной таблице, в противном случае (т. Е. Если результат ложный или нулевой) она отбрасывается. Условие поиска обычно ссылается как минимум на один столбец таблицы, созданной в предложении &lt;code&gt;FROM&lt;/code&gt; ; это не требуется, но иначе &lt;code&gt;WHERE&lt;/code&gt; будет бесполезным.</target>
        </trans-unit>
        <trans-unit id="7afbd68cfd57086d9de66444e71b66bfaedc388a" translate="yes" xml:space="preserve">
          <source>After the select list has been processed, the result table can optionally be subject to the elimination of duplicate rows. The &lt;code&gt;DISTINCT&lt;/code&gt; key word is written directly after &lt;code&gt;SELECT&lt;/code&gt; to specify this:</source>
          <target state="translated">После обработки списка выбора из таблицы результатов можно дополнительно удалить повторяющиеся строки. &lt;code&gt;DISTINCT&lt;/code&gt; слово ключ записывается непосредственно после &lt;code&gt;SELECT&lt;/code&gt; , чтобы указать это:</target>
        </trans-unit>
        <trans-unit id="6f94a805413e3bb85d7fa38665d29205c38f9186" translate="yes" xml:space="preserve">
          <source>After this command is executed, the index is &amp;ldquo;owned&amp;rdquo; by the constraint, in the same way as if the index had been built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command. In particular, dropping the constraint will make the index disappear too.</source>
          <target state="translated">После выполнения этой команды индекс &amp;laquo;принадлежит&amp;raquo; ограничению так же, как если бы индекс был создан с помощью обычной команды &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; или &lt;code&gt;ADD UNIQUE&lt;/code&gt; . В частности, при снятии ограничения индекс тоже исчезнет.</target>
        </trans-unit>
        <trans-unit id="5a54a1d7a070e112cd3e777d9befed8de7b72e73" translate="yes" xml:space="preserve">
          <source>Again connect to the database as a user with rights to run pg_stop_backup (superuser, or a user who has been granted EXECUTE on the function), and issue the command:</source>
          <target state="translated">Снова подключаемся к БД в качестве пользователя с правами на запуск pg_stop_backup (суперпользователь,или пользователь,которому назначена функция EXECUTE)и выдаем команду:</target>
        </trans-unit>
        <trans-unit id="89c328b5eae1533574b7b6b9cb4641c91474c438" translate="yes" xml:space="preserve">
          <source>Again the planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for &lt;code&gt;=&lt;/code&gt;, which is &lt;code&gt;eqsel&lt;/code&gt;. For equality estimation the histogram is not useful; instead the list of &lt;em&gt;most common values&lt;/em&gt; (MCVs) is used to determine the selectivity. Let's have a look at the MCVs, with some additional columns that will be useful later:</source>
          <target state="translated">Снова планировщик проверяет условие предложения &lt;code&gt;WHERE&lt;/code&gt; и ищет функцию селективности для &lt;code&gt;=&lt;/code&gt; , которая равна &lt;code&gt;eqsel&lt;/code&gt; . Для оценки равенства гистограмма бесполезна; вместо этого для определения селективности используется список &lt;em&gt;наиболее распространенных значений&lt;/em&gt; (MCV). Давайте посмотрим на MCV с некоторыми дополнительными столбцами, которые будут полезны позже:</target>
        </trans-unit>
        <trans-unit id="4c27783eb44bcd1d4c219fa9ccfc28e663471099" translate="yes" xml:space="preserve">
          <source>Again, a more realistic example:</source>
          <target state="translated">Опять же,более реалистичный пример:</target>
        </trans-unit>
        <trans-unit id="6c1eea13275ab96326295feeff11f71292c224b0" translate="yes" xml:space="preserve">
          <source>Again, a table alias is required. Assigning alias names to the columns of the &lt;code&gt;VALUES&lt;/code&gt; list is optional, but is good practice. For more information see &lt;a href=&quot;queries-values&quot;&gt;Section 7.7&lt;/a&gt;.</source>
          <target state="translated">Опять же, требуется псевдоним таблицы. Назначение псевдонимов столбцам списка &lt;code&gt;VALUES&lt;/code&gt; необязательно, но это хорошая практика. Для получения дополнительной информации см. &lt;a href=&quot;queries-values&quot;&gt;Раздел 7.7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa2e8717405811a7aefb85de6cf3250083c52ac2" translate="yes" xml:space="preserve">
          <source>Again, note that some of these commands are actually allowed during &quot;read only&quot; mode transactions on the primary.</source>
          <target state="translated">Опять же,обратите внимание,что некоторые из этих команд на самом деле разрешены во время транзакций в режиме &quot;только чтение&quot; на первичном.</target>
        </trans-unit>
        <trans-unit id="d75929b4f5b2f824a7a07da4899bf1820357b131" translate="yes" xml:space="preserve">
          <source>Again, see &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for more detail.</source>
          <target state="translated">Опять же, см. &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Главу 12&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="8820b9fd552bc40289d6bbf23d466ae2aeb85fb1" translate="yes" xml:space="preserve">
          <source>Again, see &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c2d4672afb28ef558326e3d56d8e571d70b6fe" translate="yes" xml:space="preserve">
          <source>Again, the argument &lt;code&gt;uppercase&lt;/code&gt; was omitted so it is set to &lt;code&gt;false&lt;/code&gt; implicitly. One advantage of using named notation is that the arguments may be specified in any order, for example:</source>
          <target state="translated">Опять же, &lt;code&gt;uppercase&lt;/code&gt; аргумента был опущен, поэтому для него неявно установлено значение &lt;code&gt;false&lt;/code&gt; . Одним из преимуществ использования именованной нотации является то, что аргументы могут быть указаны в любом порядке, например:</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="translated">Совокупные функции</target>
        </trans-unit>
        <trans-unit id="644f8b99c4c1166b7dd3dea3ff097223a8e3390b" translate="yes" xml:space="preserve">
          <source>Aggregate function (routine)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78066b1c350419b50af4d9f199ab1be3ff9a7bd9" translate="yes" xml:space="preserve">
          <source>Aggregate functions are an extension.</source>
          <target state="translated">Совокупные функции являются расширением.</target>
        </trans-unit>
        <trans-unit id="871c4bc7e83d3ebb5166fa9fb4f5c7870dcdec31" translate="yes" xml:space="preserve">
          <source>Aggregate functions that support &lt;em&gt;Partial Mode&lt;/em&gt; are eligible to participate in various optimizations, such as parallel aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c2d9b93a1fb3de5a512eb3000462da32b26df8" translate="yes" xml:space="preserve">
          <source>Aggregate functions which support &lt;em&gt;Partial Mode&lt;/em&gt; are eligible to participate in various optimizations, such as parallel aggregation.</source>
          <target state="translated">Агрегатные функции, поддерживающие &lt;em&gt;частичный режим&lt;/em&gt; , могут участвовать в различных оптимизациях, таких как параллельное агрегирование.</target>
        </trans-unit>
        <trans-unit id="90d68cd3e256fbe87b23e489f9c82e0bca666a22" translate="yes" xml:space="preserve">
          <source>Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching a &lt;code&gt;FILTER&lt;/code&gt; clause to the aggregate function call; see &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt; for more information. When a &lt;code&gt;FILTER&lt;/code&gt; clause is present, only those rows matching it are included in the input to that aggregate function.</source>
          <target state="translated">Агрегатные функции, если таковые используются, вычисляются для всех строк, составляющих каждую группу, производя отдельное значение для каждой группы. (Если есть агрегатные функции, но нет предложения &lt;code&gt;GROUP BY&lt;/code&gt; , запрос рассматривается как имеющий единственную группу, включающую все выбранные строки.) Набор строк, переданных каждой агрегатной функции, может быть дополнительно отфильтрован путем присоединения предложения &lt;code&gt;FILTER&lt;/code&gt; к агрегатной функции вызов; см. &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Раздел 4.2.7&lt;/a&gt; для получения дополнительной информации. Когда присутствует предложение &lt;code&gt;FILTER&lt;/code&gt; , только те строки, которые соответствуют ему, включаются во входные данные для этой агрегатной функции.</target>
        </trans-unit>
        <trans-unit id="cbff25b6bf81504908e5320d1af957a7ec74d3b6" translate="yes" xml:space="preserve">
          <source>Aggregate kind: &lt;code&gt;n&lt;/code&gt; for &amp;ldquo;normal&amp;rdquo; aggregates, &lt;code&gt;o&lt;/code&gt; for &amp;ldquo;ordered-set&amp;rdquo; aggregates, or &lt;code&gt;h&lt;/code&gt; for &amp;ldquo;hypothetical-set&amp;rdquo; aggregates</source>
          <target state="translated">Тип агрегата : &lt;code&gt;n&lt;/code&gt; для &amp;laquo;нормальных&amp;raquo; агрегатов, &lt;code&gt;o&lt;/code&gt; для агрегатов &amp;laquo;упорядоченный набор&amp;raquo; или &lt;code&gt;h&lt;/code&gt; для агрегатов &amp;laquo;гипотетический набор&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="113588f464cd4fe7bfbc7d7c65d0648a3eeb21d0" translate="yes" xml:space="preserve">
          <source>Aggregate: *</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d76c0a0d13e4564f62e4ef32c8d0ac5d3a9bd1e2" translate="yes" xml:space="preserve">
          <source>Aggregate: GROUP BY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fa6b402dc45ed045bd73c615623304375dc24b" translate="yes" xml:space="preserve">
          <source>Aggregate: GROUPING</source>
          <target state="translated">Совокупность:ГРУППАРИРОВАНИЕ</target>
        </trans-unit>
        <trans-unit id="bf655ffdd9634b84bf30927558cadb22681f9bbb" translate="yes" xml:space="preserve">
          <source>Aggregate: WITHIN GROUP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7717151bc6adba0544d963b5ecd779cf9aefbe1" translate="yes" xml:space="preserve">
          <source>Aggregate: array_agg</source>
          <target state="translated">Совокупность:array_agg</target>
        </trans-unit>
        <trans-unit id="7671fe3f4aa646a763a41cd74b0f33b4d9825d22" translate="yes" xml:space="preserve">
          <source>Aggregate: avg</source>
          <target state="translated">Совокупность:avg</target>
        </trans-unit>
        <trans-unit id="9464ad790968a8c3f29976c4cecb93cf8cb97818" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_and</source>
          <target state="translated">Совокупность:bit_and</target>
        </trans-unit>
        <trans-unit id="f4ff9c9094ce1f94db13530e24012163b5e11d40" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_or</source>
          <target state="translated">Совокупность:bit_or</target>
        </trans-unit>
        <trans-unit id="b9c262247be1030665a29ac642cf245ebfafdc8c" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_and</source>
          <target state="translated">Совокупность:bool_and</target>
        </trans-unit>
        <trans-unit id="a36b04811f8dfcb04687f062eee53e188ba68218" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_or</source>
          <target state="translated">Совокупность:bool_or</target>
        </trans-unit>
        <trans-unit id="6b938ae10da8a5049736d651f7bdf37fa7dd2ec6" translate="yes" xml:space="preserve">
          <source>Aggregate: corr</source>
          <target state="translated">Совокупность:бежать</target>
        </trans-unit>
        <trans-unit id="f67c8e60c07fff9ff21ed59ebe5883cf64966901" translate="yes" xml:space="preserve">
          <source>Aggregate: count</source>
          <target state="translated">Совокупность:считать</target>
        </trans-unit>
        <trans-unit id="a535e7f27744a217a4b4ebbcc5ce09395054c24d" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_pop</source>
          <target state="translated">Совокупность:covar_pop</target>
        </trans-unit>
        <trans-unit id="e42952cf656ba58f6dfa69af76b03eb6f4865935" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_samp</source>
          <target state="translated">Совокупность:covar_samp</target>
        </trans-unit>
        <trans-unit id="fc5ea10421b5c30ba97731125807dc2645fb9fc1" translate="yes" xml:space="preserve">
          <source>Aggregate: cume_dist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="affa989634b7b7f9316e718975ac524915a80100" translate="yes" xml:space="preserve">
          <source>Aggregate: cume_dist WITHIN GROUP</source>
          <target state="translated">Совокупность:cume_dist WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="5413552564b5ce9858645aad9d11f00224935ffb" translate="yes" xml:space="preserve">
          <source>Aggregate: dense_rank</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff732a0c7e39824a92acd57f902391a878f3abf" translate="yes" xml:space="preserve">
          <source>Aggregate: dense_rank WITHIN GROUP</source>
          <target state="translated">Совокупность:dense_rank WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="8dc8d8ebf59b788e17565bab2f4948b36d249316" translate="yes" xml:space="preserve">
          <source>Aggregate: every</source>
          <target state="translated">Совокупность:каждый</target>
        </trans-unit>
        <trans-unit id="cb574ceb369d625e53cf66f30a46474ab01c8d22" translate="yes" xml:space="preserve">
          <source>Aggregate: json_agg</source>
          <target state="translated">Совокупность:json_agg</target>
        </trans-unit>
        <trans-unit id="5daf429a167bfb1204d6816cc327273b7dff3d24" translate="yes" xml:space="preserve">
          <source>Aggregate: json_object_agg</source>
          <target state="translated">Совокупность:json_object_agg</target>
        </trans-unit>
        <trans-unit id="146ad7890c6afaeaa83cf4ce928bc658120656b5" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_agg</source>
          <target state="translated">Совокупность:jsonb_agg</target>
        </trans-unit>
        <trans-unit id="6f7d6e6ca2d445820090cd7f314ec40d5730bd62" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_object_agg</source>
          <target state="translated">Совокупность:jsonb_object_agg</target>
        </trans-unit>
        <trans-unit id="65e31a82796d0cddf371f7a0ba43aa2ede594f67" translate="yes" xml:space="preserve">
          <source>Aggregate: max</source>
          <target state="translated">Совокупность:макс.</target>
        </trans-unit>
        <trans-unit id="36d81566b6da93dc64aade9617077054e335a89e" translate="yes" xml:space="preserve">
          <source>Aggregate: min</source>
          <target state="translated">Совокупность:мин</target>
        </trans-unit>
        <trans-unit id="4eb5d44d93ed2f2a9cdcc0ef1679955c52d6f77c" translate="yes" xml:space="preserve">
          <source>Aggregate: mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c96cf40a4dc1d8d1ea12a0b1f5bcf59364dc827" translate="yes" xml:space="preserve">
          <source>Aggregate: mode WITHIN GROUP</source>
          <target state="translated">Совокупность:мода с группой WITHIN.</target>
        </trans-unit>
        <trans-unit id="3827ba089152343be605c81a6829b3adfab7a03f" translate="yes" xml:space="preserve">
          <source>Aggregate: percent_rank</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b5e1912aa5215dcec451af73485fcbfd34b50f" translate="yes" xml:space="preserve">
          <source>Aggregate: percent_rank WITHIN GROUP</source>
          <target state="translated">Совокупность:percent_rank WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="4071198c9c5d51f5904da94e25f898d0927a065a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_cont</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d40010d0c71e89dc5a258e985609a24fad7370a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_cont WITHIN GROUP</source>
          <target state="translated">Совокупность:percentile_cont WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="221d8437a4694e24ecacfafa477406400d56070a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_disc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c269fdb441e6262d2a37b019da9d266f3b3b083" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_disc WITHIN GROUP</source>
          <target state="translated">Совокупность:percentile_disc WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="780b4bfa2df2c728976c6499686f1e45a03cae9d" translate="yes" xml:space="preserve">
          <source>Aggregate: rank</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66604fc6a8764a0b6d82483c45c9ff5043d563ce" translate="yes" xml:space="preserve">
          <source>Aggregate: rank WITHIN GROUP</source>
          <target state="translated">Совокупность:Рейтинг &quot;WITHIN GROUP&quot;.</target>
        </trans-unit>
        <trans-unit id="08db334b9f771618e8d9956b3a35006958baa8aa" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgx</source>
          <target state="translated">Совокупность:regr_avgx</target>
        </trans-unit>
        <trans-unit id="f813e6eb9f1bd8f18122c9d3100e3e1329000930" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgy</source>
          <target state="translated">Совокупность:regr_avgy</target>
        </trans-unit>
        <trans-unit id="db3268966df89189e65fd222205de0442daba3c2" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_count</source>
          <target state="translated">Совокупность:regr_count</target>
        </trans-unit>
        <trans-unit id="4489b8487a16a39dde1e4d8b5fcd20f0950266f5" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_intercept</source>
          <target state="translated">Совокупность:regr_intercept</target>
        </trans-unit>
        <trans-unit id="17dd93536539876bbf56b59964ca4c7379d9ef8f" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_r2</source>
          <target state="translated">Совокупность:regr_r2</target>
        </trans-unit>
        <trans-unit id="bbd0902e24a6b13aeeb42be12d4c6ac689ac39d4" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_slope</source>
          <target state="translated">Совокупность:regr_slope</target>
        </trans-unit>
        <trans-unit id="83dbb5beff01870dc33ceaa7278e2d80cc920457" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxx</source>
          <target state="translated">Совокупность:regr_sxx</target>
        </trans-unit>
        <trans-unit id="ec7ca11bda1c42f1ba07c7f1bd8a0c3296064181" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxy</source>
          <target state="translated">Совокупность:regr_sxy</target>
        </trans-unit>
        <trans-unit id="f14b071a16428ce5a21dc895086399aaadc762a3" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_syy</source>
          <target state="translated">Агрегат:regr_syy</target>
        </trans-unit>
        <trans-unit id="c004eede3fbd79af583dbd185f768dfae4d466a6" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev</source>
          <target state="translated">Совокупность:стдев</target>
        </trans-unit>
        <trans-unit id="1d5e80f190137dd3cac84ce1a78d10780d5bce34" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_pop</source>
          <target state="translated">Совокупность:stddev_pop</target>
        </trans-unit>
        <trans-unit id="d3b157c6a46f69b3887530f9f9b22d6b9cb4a16e" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_samp</source>
          <target state="translated">Совокупность:stddev_samp</target>
        </trans-unit>
        <trans-unit id="2974203e91cce11e66f9221d5ec28297655cd0a8" translate="yes" xml:space="preserve">
          <source>Aggregate: string_agg</source>
          <target state="translated">Совокупность:string_agg</target>
        </trans-unit>
        <trans-unit id="ee008bd21c90b91f02271735e82b4e05772fdd98" translate="yes" xml:space="preserve">
          <source>Aggregate: sum</source>
          <target state="translated">Сумма:сумма</target>
        </trans-unit>
        <trans-unit id="7f9f090a85b6cef6189e9f1f572af2d4232d4c63" translate="yes" xml:space="preserve">
          <source>Aggregate: sum/N</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f2801430c2438881499cac7d09362a7b44215e" translate="yes" xml:space="preserve">
          <source>Aggregate: to_json</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a46ffd3d158ae27b092ee54bfe3724f518b2f3" translate="yes" xml:space="preserve">
          <source>Aggregate: var_pop</source>
          <target state="translated">Совокупность:var_pop</target>
        </trans-unit>
        <trans-unit id="3c7dc337d4d493d0b8b497185b09dab2dd6b0e40" translate="yes" xml:space="preserve">
          <source>Aggregate: var_samp</source>
          <target state="translated">Совокупность:var_samp</target>
        </trans-unit>
        <trans-unit id="51e197a4c87920c56f05e65ce1ba4b227834b071" translate="yes" xml:space="preserve">
          <source>Aggregate: variance</source>
          <target state="translated">Совокупность:разница</target>
        </trans-unit>
        <trans-unit id="a2fb0accd998c64e0241184b4242d48e43957e30" translate="yes" xml:space="preserve">
          <source>Aggregate: xmlagg</source>
          <target state="translated">Совокупность:xmlagg</target>
        </trans-unit>
        <trans-unit id="576d72bc3c483daa9c7746a2659f34dd5176aed8" translate="yes" xml:space="preserve">
          <source>Aggregated Argument Type(s)</source>
          <target state="translated">Обобщенный тип(ы)аргумента(ов)</target>
        </trans-unit>
        <trans-unit id="425a801b77a97dcec7fa5fa5f67892cad03a7787" translate="yes" xml:space="preserve">
          <source>Aggregated Logging</source>
          <target state="translated">Агрегированные лесозаготовки</target>
        </trans-unit>
        <trans-unit id="604697606446ca85390963f1caeb65a8c41712bd" translate="yes" xml:space="preserve">
          <source>Aggregates are also very useful in combination with &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For example, we can get the maximum low temperature observed in each city with:</source>
          <target state="translated">Агрегаты также очень полезны в сочетании с предложениями &lt;code&gt;GROUP BY&lt;/code&gt; . Например, мы можем получить максимальную низкую температуру, наблюдаемую в каждом городе, с помощью:</target>
        </trans-unit>
        <trans-unit id="8a83bb8f12f58dc63f8d8450952fc03b0bc1ffde" translate="yes" xml:space="preserve">
          <source>Aggregates that behave like &lt;code&gt;MIN&lt;/code&gt; or &lt;code&gt;MAX&lt;/code&gt; can sometimes be optimized by looking into an index instead of scanning every input row. If this aggregate can be so optimized, indicate it by specifying a &lt;em&gt;sort operator&lt;/em&gt;. The basic requirement is that the aggregate must yield the first element in the sort ordering induced by the operator; in other words:</source>
          <target state="translated">Агрегаты, которые ведут себя как &lt;code&gt;MIN&lt;/code&gt; или &lt;code&gt;MAX&lt;/code&gt; , иногда можно оптимизировать, просматривая индекс вместо сканирования каждой входной строки. Если этот агрегат можно оптимизировать таким образом, укажите это, указав &lt;em&gt;оператор сортировки&lt;/em&gt; . Основное требование состоит в том, что агрегат должен выдавать первый элемент в порядке сортировки, заданном оператором; другими словами:</target>
        </trans-unit>
        <trans-unit id="7ec048891025aea562b86e815620f42ae7adb619" translate="yes" xml:space="preserve">
          <source>Aggressive &lt;code&gt;VACUUM&lt;/code&gt; scans, regardless of what causes them, enable advancing the value for that table. Eventually, as all tables in all databases are scanned and their oldest multixact values are advanced, on-disk storage for older multixacts can be removed.</source>
          <target state="translated">Агрессивное сканирование &lt;code&gt;VACUUM&lt;/code&gt; , независимо от того, что его вызывает, позволяет увеличить значение для этой таблицы. В конце концов, так как все таблицы во всех базах данных сканируются и их самые старые значения мультиплексирования расширяются, дисковое хранилище для старых мультиплексоров может быть удалено.</target>
        </trans-unit>
        <trans-unit id="121abf3940fab2d8dbe9b94bbd289148bc06a85b" translate="yes" xml:space="preserve">
          <source>Aggressively &amp;ldquo;freeze&amp;rdquo; tuples.</source>
          <target state="translated">Агрессивно &amp;laquo;замораживайте&amp;raquo; кортежи.</target>
        </trans-unit>
        <trans-unit id="bcb017abcff2696033726df1d1faa6140cda30fa" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Postgres Professional, Russia</source>
          <target state="translated">Александр Коротков &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Москва, Postgres Professional, Россия</target>
        </trans-unit>
        <trans-unit id="aa44f40c0080e2d8f22aa729bc2aa695de07bb55" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">Александр Коротков &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Postgres Professional, Москва, Россия</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="9e3800ae71f3a62322201681fab38592cc7aac5f" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;aggregate functions&lt;/a&gt; can be used as window functions, but window functions can also be used to, for example, give ranks to each of the rows in the partition. Also known as &lt;em&gt;analytic functions&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1238bd88f43030284835da146c8f594a6e3253c8" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;pgcrypto&lt;/code&gt; functions run inside the database server. That means that all the data and passwords move between &lt;code&gt;pgcrypto&lt;/code&gt; and client applications in clear text. Thus you must:</source>
          <target state="translated">Все функции &lt;code&gt;pgcrypto&lt;/code&gt; выполняются на сервере базы данных. Это означает, что все данные и пароли перемещаются между &lt;code&gt;pgcrypto&lt;/code&gt; и клиентскими приложениями в виде открытого текста. Таким образом, вы должны:</target>
        </trans-unit>
        <trans-unit id="0b67ddd3a2de73817c7543968b2cc085a1a78542" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;storage&lt;/code&gt; values other than &lt;code&gt;plain&lt;/code&gt; imply that the functions of the data type can handle values that have been &lt;em&gt;toasted&lt;/em&gt;, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt;.</source>
          <target state="translated">Все значения &lt;code&gt;storage&lt;/code&gt; кроме &lt;code&gt;plain&lt;/code&gt; подразумевают, что функции типа данных могут обрабатывать значения, которые были &lt;em&gt;поджарены&lt;/em&gt; , как описано в &lt;a href=&quot;storage-toast&quot;&gt;Разделе 68.2&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Разделе 37.13.1&lt;/a&gt; . Заданное конкретное другое значение просто определяет стратегию хранения TOAST по умолчанию для столбцов с всплывающим типом данных; пользователи могут выбрать другие стратегии для отдельных столбцов, используя &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8dfd6e92427babe1e9a096720e962dca35e82cb" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;storage&lt;/code&gt; values other than &lt;code&gt;plain&lt;/code&gt; imply that the functions of the data type can handle values that have been &lt;em&gt;toasted&lt;/em&gt;, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d6e0687d278d53588734a1b582257aaee1502f" translate="yes" xml:space="preserve">
          <source>All Privileges</source>
          <target state="translated">Все привилегии</target>
        </trans-unit>
        <trans-unit id="bf637fbee55bb9d868af3ee61e448c31817bc7e1" translate="yes" xml:space="preserve">
          <source>All UPC, ISBN, ISMN and ISSN numbers can be represented as EAN13 numbers.</source>
          <target state="translated">Все номера UPC,ISBN,ISMN и ISSN могут быть представлены в виде номеров EAN13.</target>
        </trans-unit>
        <trans-unit id="f057cd68ee57e6fcf443add2a601584e9abb4486" translate="yes" xml:space="preserve">
          <source>All WAL records required for the backup must contain sufficient full-page writes, which requires you to enable &lt;code&gt;full_page_writes&lt;/code&gt; on the master and not to use a tool like pg_compresslog as &lt;code&gt;archive_command&lt;/code&gt; to remove full-page writes from WAL files.</source>
          <target state="translated">Все записи WAL, необходимые для резервного копирования, должны содержать достаточное количество полностраничных записей, что требует, чтобы вы &lt;code&gt;full_page_writes&lt;/code&gt; на главном сервере и не использовали такой инструмент, как pg_compresslog в качестве &lt;code&gt;archive_command&lt;/code&gt; , для удаления полностраничных записей из файлов WAL.</target>
        </trans-unit>
        <trans-unit id="32451a83c5b4d59ae6ed31b28d945b83e60fefc2" translate="yes" xml:space="preserve">
          <source>All WAL records required for the backup must contain sufficient full-page writes, which requires you to enable &lt;code&gt;full_page_writes&lt;/code&gt; on the primary and not to use a tool like pg_compresslog as &lt;code&gt;archive_command&lt;/code&gt; to remove full-page writes from WAL files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841cc9e5c025174354644ed418b19ab2df80e067" translate="yes" xml:space="preserve">
          <source>All arguments are specified in order. The result is upper case since &lt;code&gt;uppercase&lt;/code&gt; is specified as &lt;code&gt;true&lt;/code&gt;. Another example is:</source>
          <target state="translated">Все аргументы указаны по порядку. Результатом является верхний регистр, поскольку &lt;code&gt;uppercase&lt;/code&gt; указан как &lt;code&gt;true&lt;/code&gt; . Другой пример:</target>
        </trans-unit>
        <trans-unit id="64cfac4af128aada4a6d6bb5c11a90e45ce7a24e" translate="yes" xml:space="preserve">
          <source>All check constraints and not-null constraints on a parent table are automatically inherited by its children, unless explicitly specified otherwise with &lt;code&gt;NO INHERIT&lt;/code&gt; clauses. Other types of constraints (unique, primary key, and foreign key constraints) are not inherited.</source>
          <target state="translated">Все проверочные ограничения и ограничения, не &lt;code&gt;NO INHERIT&lt;/code&gt; нулю, в родительской таблице автоматически наследуются ее дочерними элементами , если явно не указано иное с помощью предложений NO INHERIT . Другие типы ограничений (ограничения уникальности, первичного ключа и внешнего ключа) не наследуются.</target>
        </trans-unit>
        <trans-unit id="337d6bdce5b053fd7a1885beaee3b7d63bb8f598" translate="yes" xml:space="preserve">
          <source>All columns will be filled with their default values, as if &lt;code&gt;DEFAULT&lt;/code&gt; were explicitly specified for each column. (An &lt;code&gt;OVERRIDING&lt;/code&gt; clause is not permitted in this form.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f96ca727311b0e1e924639300601036b23919a" translate="yes" xml:space="preserve">
          <source>All columns will be filled with their default values. (An &lt;code&gt;OVERRIDING&lt;/code&gt; clause is not permitted in this form.)</source>
          <target state="translated">Все столбцы будут заполнены значениями по умолчанию. (Предложение &lt;code&gt;OVERRIDING&lt;/code&gt; не разрешено в этой форме.)</target>
        </trans-unit>
        <trans-unit id="44d64899ac94e8442ee1baa672497f8a2ca162b4" translate="yes" xml:space="preserve">
          <source>All constraints on all children of the parent table are examined during constraint exclusion, so large numbers of children are likely to increase query planning time considerably. So the legacy inheritance based partitioning will work well with up to perhaps a hundred child tables; don't try to use many thousands of children.</source>
          <target state="translated">Все ограничения в отношении всех детей в таблице &quot;Родители&quot; изучаются во время исключения ограничений,поэтому большое число детей,вероятно,значительно увеличит время,затрачиваемое на планирование запросов.Таким образом,разметка,основанная на наследовании,будет хорошо работать с,возможно,сотней дочерних таблиц;не пытайтесь использовать много тысяч дочерних таблиц.</target>
        </trans-unit>
        <trans-unit id="153c80dc5116feea616ba3928be18ab8586f5a93" translate="yes" xml:space="preserve">
          <source>All current listen registrations for this session are cleared.</source>
          <target state="translated">Все текущие регистрации прослушивания для этой сессии очищены.</target>
        </trans-unit>
        <trans-unit id="e559ad46dfb12176f9ab6a5068fbbc335264dacf" translate="yes" xml:space="preserve">
          <source>All currently available prepared transactions are listed in the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">Все доступные в настоящее время подготовленные транзакции перечислены в системном представлении &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2778b518fdc9b5356b12e2a79dd08d30844b8366" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;FROM&lt;/code&gt; list are computed. (Each element in the &lt;code&gt;FROM&lt;/code&gt; list is a real or virtual table.) If more than one element is specified in the &lt;code&gt;FROM&lt;/code&gt; list, they are cross-joined together. (See &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">Вычисляются все элементы в списке &lt;code&gt;FROM&lt;/code&gt; . (Каждый элемент в списке &lt;code&gt;FROM&lt;/code&gt; является реальной или виртуальной таблицей.) Если в списке &lt;code&gt;FROM&lt;/code&gt; указано более одного элемента , они перекрестно объединяются. (См. &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;Пункт &lt;/a&gt; &lt;code&gt;FROM&lt;/code&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="14481956ddccdbae880b961dfaa2429f752c35d7" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;FROM&lt;/code&gt; list are computed. (Each element in the &lt;code&gt;FROM&lt;/code&gt; list is a real or virtual table.) If more than one element is specified in the &lt;code&gt;FROM&lt;/code&gt; list, they are cross-joined together. (See &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;FROM Clause&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3978f2f6a0fc6fd4b0827f0ebd212e7bcc3552c2" translate="yes" xml:space="preserve">
          <source>All failure, rebuild, and reindex cases will be reported by pg_upgrade if they affect your installation; post-upgrade scripts to rebuild tables and indexes will be generated automatically. If you are trying to automate the upgrade of many clusters, you should find that clusters with identical database schemas require the same post-upgrade steps for all cluster upgrades; this is because the post-upgrade steps are based on the database schemas, and not user data.</source>
          <target state="translated">Обо всех случаях отказа,восстановления и реиндексации будет сообщать pg_upgrade,если они повлияют на вашу установку;пост-обновленные скрипты для восстановления таблиц и индексов будут сгенерированы автоматически.Если вы пытаетесь автоматизировать обновление многих кластеров,вы должны обнаружить,что кластеры с идентичными схемами баз данных требуют одних и тех же шагов постобновления для всех обновлений кластеров;это происходит потому,что шаги постобновления основаны на схемах баз данных,а не на пользовательских данных.</target>
        </trans-unit>
        <trans-unit id="2887bc873471e44a6e402dab0ddec69892effbd0" translate="yes" xml:space="preserve">
          <source>All functions and operators used in an index definition must be &amp;ldquo;immutable&amp;rdquo;, that is, their results must depend only on their arguments and never on any outside influence (such as the contents of another table or the current time). This restriction ensures that the behavior of the index is well-defined. To use a user-defined function in an index expression or &lt;code&gt;WHERE&lt;/code&gt; clause, remember to mark the function immutable when you create it.</source>
          <target state="translated">Все функции и операторы, используемые в определении индекса, должны быть &amp;laquo;неизменяемыми&amp;raquo;, то есть их результаты должны зависеть только от их аргументов, а не от какого-либо внешнего влияния (например, содержимого другой таблицы или текущего времени). Это ограничение гарантирует, что поведение индекса четко определено. Чтобы использовать определяемую пользователем функцию в индексном выражении или &lt;code&gt;WHERE&lt;/code&gt; , не забудьте пометить функцию как неизменяемую при ее создании.</target>
        </trans-unit>
        <trans-unit id="3ef17a42f49f1b90a3d376b9b52494437e996867" translate="yes" xml:space="preserve">
          <source>All indexes in PostgreSQL are &lt;em&gt;secondary&lt;/em&gt; indexes, meaning that each index is stored separately from the table's main data area (which is called the table's &lt;em&gt;heap&lt;/em&gt; in PostgreSQL terminology). This means that in an ordinary index scan, each row retrieval requires fetching data from both the index and the heap. Furthermore, while the index entries that match a given indexable &lt;code&gt;WHERE&lt;/code&gt; condition are usually close together in the index, the table rows they reference might be anywhere in the heap. The heap-access portion of an index scan thus involves a lot of random access into the heap, which can be slow, particularly on traditional rotating media. (As described in &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt;, bitmap scans try to alleviate this cost by doing the heap accesses in sorted order, but that only goes so far.)</source>
          <target state="translated">Все индексы в PostgreSQL являются &lt;em&gt;вторичными&lt;/em&gt; индексами, что означает, что каждый индекс хранится отдельно от основной области данных таблицы (которая в терминологии PostgreSQL называется &lt;em&gt;кучей&lt;/em&gt; таблицы ). Это означает, что при обычном сканировании индекса для получения каждой строки требуется выборка данных как из индекса, так и из кучи. Кроме того, хотя записи индекса, которые соответствуют заданному индексируемому условию &lt;code&gt;WHERE&lt;/code&gt; , обычно находятся в индексе близко друг к другу, строки таблицы, на которые они ссылаются, могут находиться где угодно в куче. Таким образом, часть сканирования индекса, связанная с доступом к куче, включает в себя большой объем произвольного доступа к куче, который может быть медленным, особенно на традиционных вращающихся носителях. (Как описано в &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Разделе 11.5&lt;/a&gt;, сканирование растрового изображения пытается снизить эту стоимость, выполняя доступ к куче в отсортированном порядке, но это только пока.)</target>
        </trans-unit>
        <trans-unit id="db79cd41caf099a5fc97eb22b9bdb081eeb2153e" translate="yes" xml:space="preserve">
          <source>All it takes to get a BRIN access method working is to implement a few user-defined methods, which define the behavior of summary values stored in the index and the way they interact with scan keys. In short, BRIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">Для работы метода доступа к BRIN достаточно реализовать несколько пользовательских методов,определяющих поведение суммарных значений,хранящихся в индексе,и способ их взаимодействия с ключами сканирования.Короче говоря,BRIN сочетает в себе расширяемость с обобщением,повторным использованием кода и чистым интерфейсом.</target>
        </trans-unit>
        <trans-unit id="6e1a7f84a08ba9a0c97ee25a9736132689a50678" translate="yes" xml:space="preserve">
          <source>All it takes to get a GIN access method working is to implement a few user-defined methods, which define the behavior of keys in the tree and the relationships between keys, indexed items, and indexable queries. In short, GIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">Для работы метода GIN-доступа достаточно реализовать несколько пользовательских методов,определяющих поведение ключей в дереве и отношения между ключами,индексируемыми элементами и индексируемыми запросами.Одним словом,GIN сочетает в себе расширяемость с универсальностью,повторным использованием кода и чистым интерфейсом.</target>
        </trans-unit>
        <trans-unit id="932e4d059724c2d4b8d21124cf86633cf4ac8541" translate="yes" xml:space="preserve">
          <source>All it takes to get a GiST access method up and running is to implement several user-defined methods, which define the behavior of keys in the tree. Of course these methods have to be pretty fancy to support fancy queries, but for all the standard queries (B-trees, R-trees, etc.) they're relatively straightforward. In short, GiST combines extensibility along with generality, code reuse, and a clean interface.</source>
          <target state="translated">Все,что требуется для получения GiST-метода доступа,это реализация нескольких пользовательских методов,которые определяют поведение ключей в дереве.Конечно,эти методы должны быть довольно фантастическими для поддержки фантастических запросов,но для всех стандартных запросов (B-деревьев,R-деревьев и т.д.)они относительно просты.Одним словом,GiST сочетает в себе расширяемость с универсальностью,повторным использованием кода и чистым интерфейсом.</target>
        </trans-unit>
        <trans-unit id="f6f094a1f0d931ca3f860e1e2d7b887c4d3d20bd" translate="yes" xml:space="preserve">
          <source>All messages emitted by the PostgreSQL server are assigned five-character error codes that follow the SQL standard's conventions for &amp;ldquo;SQLSTATE&amp;rdquo; codes. Applications that need to know which error condition has occurred should usually test the error code, rather than looking at the textual error message. The error codes are less likely to change across PostgreSQL releases, and also are not subject to change due to localization of error messages. Note that some, but not all, of the error codes produced by PostgreSQL are defined by the SQL standard; some additional error codes for conditions not defined by the standard have been invented or borrowed from other databases.</source>
          <target state="translated">Всем сообщениям, отправляемым сервером PostgreSQL, присваиваются пятизначные коды ошибок, которые соответствуют соглашениям стандарта SQL для кодов &amp;laquo;SQLSTATE&amp;raquo;. Приложения, которым необходимо знать, какая ошибка возникла, обычно должны проверять код ошибки, а не просматривать текстовое сообщение об ошибке. Коды ошибок с меньшей вероятностью изменятся в разных выпусках PostgreSQL, а также не могут быть изменены из-за локализации сообщений об ошибках. Обратите внимание, что некоторые, но не все, коды ошибок, выдаваемые PostgreSQL, определены стандартом SQL; некоторые дополнительные коды ошибок для условий, не определенных стандартом, были изобретены или заимствованы из других баз данных.</target>
        </trans-unit>
        <trans-unit id="5f17dc4d29230530f8f45813d17f855f136a3816" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced by a transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidMultiXactId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">Все идентификаторы мультиплексирования до этого были заменены идентификаторами транзакции в этой таблице. Это используется для отслеживания того, нужно ли очистить таблицу, чтобы предотвратить зацикливание идентификатора multixact или разрешить &lt;code&gt;pg_multixact&lt;/code&gt; . Ноль ( &lt;code&gt;InvalidMultiXactId&lt;/code&gt; ), если отношение не является таблицей.</target>
        </trans-unit>
        <trans-unit id="2dede7220bdd3e91dec2b9b6615dd35bb3933921" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced with a transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; values.</source>
          <target state="translated">Все идентификаторы multixact до этого были заменены идентификаторами транзакции в этой базе данных. Это используется для отслеживания того, нужно ли очистить базу данных, чтобы предотвратить зацикливание идентификаторов multixact или разрешить &lt;code&gt;pg_multixact&lt;/code&gt; . Это минимум для таблицы &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;relminmxid&lt;/code&gt; значения.</target>
        </trans-unit>
        <trans-unit id="b6a1ec7b62542588df77c091f76d37462abbe3bd" translate="yes" xml:space="preserve">
          <source>All of the OID alias types for objects grouped by namespace accept schema-qualified names, and will display schema-qualified names on output if the object would not be found in the current search path without being qualified. The &lt;code&gt;regproc&lt;/code&gt; and &lt;code&gt;regoper&lt;/code&gt; alias types will only accept input names that are unique (not overloaded), so they are of limited use; for most uses &lt;code&gt;regprocedure&lt;/code&gt; or &lt;code&gt;regoperator&lt;/code&gt; are more appropriate. For &lt;code&gt;regoperator&lt;/code&gt;, unary operators are identified by writing &lt;code&gt;NONE&lt;/code&gt; for the unused operand.</source>
          <target state="translated">Все типы псевдонимов OID для объектов, сгруппированных по пространству имен, принимают имена, дополненные схемой, и будут отображать имена, уточненные схемой, на выходе, если объект не будет найден в текущем пути поиска без уточнения. В &lt;code&gt;regproc&lt;/code&gt; и &lt;code&gt;regoper&lt;/code&gt; типов псевдонимов будут принимать только входные имена , которые являются уникальными (не перегружено), поэтому они имеют ограниченное применение; для большинства применений более подходят &lt;code&gt;regprocedure&lt;/code&gt; или &lt;code&gt;regoperator&lt;/code&gt; . Для &lt;code&gt;regoperator&lt;/code&gt; унарные операторы идентифицируются записью &lt;code&gt;NONE&lt;/code&gt; для неиспользуемого операнда.</target>
        </trans-unit>
        <trans-unit id="37766175956ba6517dd475210dd4e291c6b94f05" translate="yes" xml:space="preserve">
          <source>All of the functions listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt; depend on the sort ordering specified by the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the associated window definition. Rows that are not distinct when considering only the &lt;code&gt;ORDER BY&lt;/code&gt; columns are said to be &lt;em&gt;peers&lt;/em&gt;. The four ranking functions (including &lt;code&gt;cume_dist&lt;/code&gt;) are defined so that they give the same answer for all peer rows.</source>
          <target state="translated">Все функции, перечисленные в &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Таблице 9.60,&lt;/a&gt; зависят от порядка сортировки, указанного в предложении &lt;code&gt;ORDER BY&lt;/code&gt; соответствующего определения окна. Строки, которые не различимы при рассмотрении только столбцов &lt;code&gt;ORDER BY&lt;/code&gt; , называются &lt;em&gt;одноранговыми&lt;/em&gt; . Четыре функции ранжирования (включая &lt;code&gt;cume_dist&lt;/code&gt; ) определены так, что они дают одинаковый ответ для всех одноранговых строк.</target>
        </trans-unit>
        <trans-unit id="6b3dc7a98e19d74a1c8b693082bcc2b7322b43f8" translate="yes" xml:space="preserve">
          <source>All of the functions listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt; depend on the sort ordering specified by the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the associated window definition. Rows that are not distinct when considering only the &lt;code&gt;ORDER BY&lt;/code&gt; columns are said to be &lt;em&gt;peers&lt;/em&gt;. The four ranking functions (including &lt;code&gt;cume_dist&lt;/code&gt;) are defined so that they give the same answer for all rows of a peer group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02fa4b0f473762a8721b052a178d80c186d067cd" translate="yes" xml:space="preserve">
          <source>All of the options except &lt;code&gt;convert-crlf&lt;/code&gt; apply only to encrypt functions. Decrypt functions get the parameters from the PGP data.</source>
          <target state="translated">Все параметры, кроме &lt;code&gt;convert-crlf&lt;/code&gt; , применяются только к функциям шифрования. Функции дешифрования получают параметры из данных PGP.</target>
        </trans-unit>
        <trans-unit id="592ca33a4522df17e0e57a59e6344510c5d4a80c" translate="yes" xml:space="preserve">
          <source>All of the policies constructed thus far have been permissive policies, meaning that when multiple policies are applied they are combined using the &amp;ldquo;OR&amp;rdquo; Boolean operator. While permissive policies can be constructed to only allow access to rows in the intended cases, it can be simpler to combine permissive policies with restrictive policies (which the records must pass and which are combined using the &amp;ldquo;AND&amp;rdquo; Boolean operator). Building on the example above, we add a restrictive policy to require the administrator to be connected over a local Unix socket to access the records of the &lt;code&gt;passwd&lt;/code&gt; table:</source>
          <target state="translated">Все политики, созданные до сих пор, были разрешительными, что означает, что при применении нескольких политик они объединяются с помощью логического оператора &amp;laquo;ИЛИ&amp;raquo;. Хотя разрешающие политики могут быть созданы так, чтобы разрешать доступ к строкам только в намеченных случаях, может быть проще комбинировать разрешительные политики с ограничительными (которые должны проходить записи и которые объединяются с помощью логического оператора &amp;laquo;И&amp;raquo;). Основываясь на приведенном выше примере, мы добавляем ограничительную политику, которая требует от администратора подключения через локальный сокет Unix для доступа к записям таблицы &lt;code&gt;passwd&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="068ae9ee084ab21fc5a8a7c0060d57cbf4e3473f" translate="yes" xml:space="preserve">
          <source>All of these &lt;code&gt;ORDER BY&lt;/code&gt; clauses specify the row's composite value, resulting in sorting the rows according to the rules described in &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Section 9.23.6&lt;/a&gt;. However, if &lt;code&gt;inventory_item&lt;/code&gt; contained a column named &lt;code&gt;c&lt;/code&gt;, the first case would be different from the others, as it would mean to sort by that column only. Given the column names previously shown, these queries are also equivalent to those above:</source>
          <target state="translated">Все эти предложения &lt;code&gt;ORDER BY&lt;/code&gt; определяют составное значение строки, в результате чего строки сортируются в соответствии с правилами, описанными в &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Разделе 9.23.6&lt;/a&gt; . Однако, если &lt;code&gt;inventory_item&lt;/code&gt; содержит столбец с именем &lt;code&gt;c&lt;/code&gt; , первый случай будет отличаться от других, так как это будет означать сортировку только по этому столбцу. Учитывая ранее показанные имена столбцов, эти запросы также эквивалентны приведенным выше:</target>
        </trans-unit>
        <trans-unit id="c8391ba1355f7ba958065513e77b352946c8ee3d" translate="yes" xml:space="preserve">
          <source>All of these &lt;code&gt;ORDER BY&lt;/code&gt; clauses specify the row's composite value, resulting in sorting the rows according to the rules described in &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Section 9.24.6&lt;/a&gt;. However, if &lt;code&gt;inventory_item&lt;/code&gt; contained a column named &lt;code&gt;c&lt;/code&gt;, the first case would be different from the others, as it would mean to sort by that column only. Given the column names previously shown, these queries are also equivalent to those above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf3c99355ffd14c50c6d5db9b1b5a423f1e1022" translate="yes" xml:space="preserve">
          <source>All of these fields are optional, except &lt;code&gt;commonName&lt;/code&gt;. It depends entirely on your CA's policy which of them would be included and which wouldn't. The meaning of these fields, however, is strictly defined by the X.500 and X.509 standards, so you cannot just assign arbitrary meaning to them.</source>
          <target state="translated">Все эти поля являются необязательными, кроме &lt;code&gt;commonName&lt;/code&gt; . Это полностью зависит от политики вашего центра сертификации, какие из них будут включены, а какие нет. Однако значение этих полей строго определено стандартами X.500 и X.509, поэтому вы не можете просто присвоить им произвольное значение.</target>
        </trans-unit>
        <trans-unit id="c6deee271f21fa5ab3c6f7bba891d40136e2c021" translate="yes" xml:space="preserve">
          <source>All of these operations will throw an error if a supplied array contains any NULL elements.</source>
          <target state="translated">Все эти операции приводят к ошибке,если поставляемый массив содержит какие-либо NULL элементы.</target>
        </trans-unit>
        <trans-unit id="d9b92f66d52bf42e15e05f0a8c5cb26f0298b448" translate="yes" xml:space="preserve">
          <source>All other parameters are described in detail under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">Все остальные параметры подробно описаны в разделе &lt;a href=&quot;sql-select&quot;&gt;ВЫБОР&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4df9c2d50326edae48634d605dfaf0fbdb01416" translate="yes" xml:space="preserve">
          <source>All parameter names are case-insensitive. Every parameter takes a value of one of five types: boolean, string, integer, floating point, or enumerated (enum). The type determines the syntax for setting the parameter:</source>
          <target state="translated">Имена всех параметров не чувствительны к регистру.Каждый параметр принимает значение одного из пяти типов:булевый,строковый,целочисленный,с плавающей точкой или перечисленный (enum).Тип определяет синтаксис для установки параметра:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
