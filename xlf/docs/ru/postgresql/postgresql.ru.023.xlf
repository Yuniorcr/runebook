<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="b6017b9e9e841e1ed3391e353ec7b6f77818cd5d" translate="yes" xml:space="preserve">
          <source>The slice syntaxes with omitted &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; can be used too, but only when updating an array value that is not NULL or zero-dimensional (otherwise, there is no existing subscript limit to substitute).</source>
          <target state="translated">Синтаксисы среза с опущенной &lt;code&gt;lower-bound&lt;/code&gt; и / или &lt;code&gt;upper-bound&lt;/code&gt; можно использовать, но только при обновлении значения массива, которое не является NULL или нуль-мерным (в противном случае нет существующего предела индекса для замены).</target>
        </trans-unit>
        <trans-unit id="b0a06932e4c9d25d4fab3d4aa77750dbf6cafc0f" translate="yes" xml:space="preserve">
          <source>The slot type - &lt;code&gt;physical&lt;/code&gt; or &lt;code&gt;logical&lt;/code&gt;</source>
          <target state="translated">Тип слота - &lt;code&gt;physical&lt;/code&gt; или &lt;code&gt;logical&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2a58ef414f79a96eef654d0cb5a2b339ceb599" translate="yes" xml:space="preserve">
          <source>The slot type: &lt;code&gt;physical&lt;/code&gt; or &lt;code&gt;logical&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4042361f65f02965ea45d409682bd67eb2ab934d" translate="yes" xml:space="preserve">
          <source>The sole disadvantage of increasing &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; (and &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; along with it) is that the &lt;code&gt;pg_xact&lt;/code&gt; and &lt;code&gt;pg_commit_ts&lt;/code&gt; subdirectories of the database cluster will take more space, because it must store the commit status and (if &lt;code&gt;track_commit_timestamp&lt;/code&gt; is enabled) timestamp of all transactions back to the &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; horizon. The commit status uses two bits per transaction, so if &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; is set to its maximum allowed value of two billion, &lt;code&gt;pg_xact&lt;/code&gt; can be expected to grow to about half a gigabyte and &lt;code&gt;pg_commit_ts&lt;/code&gt; to about 20GB. If this is trivial compared to your total database size, setting &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; to its maximum allowed value is recommended. Otherwise, set it depending on what you are willing to allow for &lt;code&gt;pg_xact&lt;/code&gt; and &lt;code&gt;pg_commit_ts&lt;/code&gt; storage. (The default, 200 million transactions, translates to about 50MB of &lt;code&gt;pg_xact&lt;/code&gt; storage and about 2GB of &lt;code&gt;pg_commit_ts&lt;/code&gt; storage.)</source>
          <target state="translated">Единственный недостаток увеличения &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; (и &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; вместе с ним) заключается в том, что подкаталоги &lt;code&gt;pg_xact&lt;/code&gt; и &lt;code&gt;pg_commit_ts&lt;/code&gt; кластера базы данных будут занимать больше места, потому что он должен хранить статус фиксации и (если &lt;code&gt;track_commit_timestamp&lt;/code&gt; включен) временные метки всех транзакций обратно в &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; горизонт. Статус фиксации использует два бита на транзакцию, поэтому, если &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; установлен на максимальное допустимое значение в два миллиарда, можно ожидать , что &lt;code&gt;pg_xact&lt;/code&gt; вырастет примерно до половины гигабайта и &lt;code&gt;pg_commit_ts&lt;/code&gt; примерно до 20 ГБ. Если это тривиально по сравнению с общим размером вашей базы данных, &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; установить autovacuum_freeze_max_age на максимально допустимое значение. В противном случае установите его в зависимости от того, что вы хотите разрешить для &lt;code&gt;pg_xact&lt;/code&gt; и &lt;code&gt;pg_commit_ts&lt;/code&gt; . (По умолчанию 200 миллионов транзакций соответствуют примерно 50 &lt;code&gt;pg_xact&lt;/code&gt; хранилища pg_xact и примерно 2 &lt;code&gt;pg_commit_ts&lt;/code&gt; хранилища pg_commit_ts .)</target>
        </trans-unit>
        <trans-unit id="420d354e00f2d98f43f69fb5c85b3c9d2f0a5c6c" translate="yes" xml:space="preserve">
          <source>The sort expression(s) can be any expression that would be valid in the query's select list. An example is:</source>
          <target state="translated">Выражение(и)сортировки может быть любым выражением,которое будет действительным в списке выбора запроса.В качестве примера можно привести следующее:</target>
        </trans-unit>
        <trans-unit id="af64fa9d73d05dafcf40b04a10bc43a2c675e4b9" translate="yes" xml:space="preserve">
          <source>The sort position of this enum value within its enum type</source>
          <target state="translated">Сортировочное положение этого перечислительного значения в пределах типа перечисления</target>
        </trans-unit>
        <trans-unit id="267381ff52d7207cad90e1b1efb3d2ae56d6e149" translate="yes" xml:space="preserve">
          <source>The source directory &lt;code&gt;contrib/intarray/bench&lt;/code&gt; contains a benchmark test suite, which can be run against an installed PostgreSQL server. (It also requires &lt;code&gt;DBD::Pg&lt;/code&gt; to be installed.) To run:</source>
          <target state="translated">Исходный каталог &lt;code&gt;contrib/intarray/bench&lt;/code&gt; содержит набор тестов производительности, который можно запускать на установленном сервере PostgreSQL. (Для этого также требуется установка &lt;code&gt;DBD::Pg&lt;/code&gt; .) Для запуска:</target>
        </trans-unit>
        <trans-unit id="f4b684dc4cf3d0e7f8017a75669ef677ed19f660" translate="yes" xml:space="preserve">
          <source>The source encoding name.</source>
          <target state="translated">Имя исходной кодировки.</target>
        </trans-unit>
        <trans-unit id="5b4632e063d85e50c766912ad7e51e33ef8bf318" translate="yes" xml:space="preserve">
          <source>The special &amp;ldquo;role&amp;rdquo; name &lt;code&gt;PUBLIC&lt;/code&gt; can be used to grant a privilege to every role on the system. Also, &amp;ldquo;group&amp;rdquo; roles can be set up to help manage privileges when there are many users of a database &amp;mdash; for details see &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt;.</source>
          <target state="translated">Специальное имя &amp;laquo;роли&amp;raquo; &lt;code&gt;PUBLIC&lt;/code&gt; может использоваться для предоставления привилегии каждой роли в системе. Кроме того, можно настроить &amp;laquo;групповые&amp;raquo; роли для помощи в управлении привилегиями при наличии большого количества пользователей базы данных - подробности см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;главе 21&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0711f789242d7822af841eb7515278a8210c6c3f" translate="yes" xml:space="preserve">
          <source>The special &amp;ldquo;role&amp;rdquo; name &lt;code&gt;PUBLIC&lt;/code&gt; can be used to grant a privilege to every role on the system. Also, &amp;ldquo;group&amp;rdquo; roles can be set up to help manage privileges when there are many users of a database &amp;mdash; for details see &lt;a href=&quot;https://www.postgresql.org/docs/13/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d534e247b3040487a992ce1f01908ab3c5c62964" translate="yes" xml:space="preserve">
          <source>The special entry &lt;code&gt;*&lt;/code&gt; matches any standby name.</source>
          <target state="translated">Специальная запись &lt;code&gt;*&lt;/code&gt; соответствует любому имени режима ожидания.</target>
        </trans-unit>
        <trans-unit id="31bc549a6a2aaa2d8b0391bf2c83e80b6eb59358" translate="yes" xml:space="preserve">
          <source>The special field name &lt;code&gt;*&lt;/code&gt; means &amp;ldquo;all fields&amp;rdquo;, as further explained in &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;.</source>
          <target state="translated">Специальное имя поля &lt;code&gt;*&lt;/code&gt; означает &amp;laquo;все поля&amp;raquo;, как &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;подробно&lt;/a&gt; описано в Разделе 8.16.5 .</target>
        </trans-unit>
        <trans-unit id="758ed933ac597fbff2a112b5d5781d2521256906" translate="yes" xml:space="preserve">
          <source>The special privileges of the object owner (i.e., the right to do &lt;code&gt;DROP&lt;/code&gt;, &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, etc.) are always implicit in being the owner, and cannot be granted or revoked. But the object owner can choose to revoke their own ordinary privileges, for example to make a table read-only for themselves as well as others.</source>
          <target state="translated">Специальные привилегии владельца объекта (т. &lt;code&gt;DROP&lt;/code&gt; Право выполнять DROP , &lt;code&gt;GRANT&lt;/code&gt; , &lt;code&gt;REVOKE&lt;/code&gt; и т. Д.) Всегда подразумеваются как владелец и не могут быть предоставлены или отозваны. Но владелец объекта может отозвать свои обычные привилегии, например, сделать таблицу доступной только для чтения для себя или других.</target>
        </trans-unit>
        <trans-unit id="c644ef37e4f8fad5de2f6806820052ad171113ce" translate="yes" xml:space="preserve">
          <source>The special table function &lt;code&gt;UNNEST&lt;/code&gt; may be called with any number of array parameters, and it returns a corresponding number of columns, as if &lt;code&gt;UNNEST&lt;/code&gt; (&lt;a href=&quot;functions-array&quot;&gt;Section 9.18&lt;/a&gt;) had been called on each parameter separately and combined using the &lt;code&gt;ROWS FROM&lt;/code&gt; construct.</source>
          <target state="translated">Специальная табличная функция &lt;code&gt;UNNEST&lt;/code&gt; может быть вызвана с любым количеством параметров массива, и она возвращает соответствующее количество столбцов, как если бы &lt;code&gt;UNNEST&lt;/code&gt; ( &lt;a href=&quot;functions-array&quot;&gt;раздел &lt;/a&gt;9.18 ) был вызван для каждого параметра отдельно и объединен с использованием конструкции &lt;code&gt;ROWS FROM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="394c1d359ef1d3b89124b30daad8e16a978cd018" translate="yes" xml:space="preserve">
          <source>The special table function &lt;code&gt;UNNEST&lt;/code&gt; may be called with any number of array parameters, and it returns a corresponding number of columns, as if &lt;code&gt;UNNEST&lt;/code&gt; (&lt;a href=&quot;functions-array&quot;&gt;Section 9.19&lt;/a&gt;) had been called on each parameter separately and combined using the &lt;code&gt;ROWS FROM&lt;/code&gt; construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3760930d6be21baabcd516fd8aaa6bbd0e31deb" translate="yes" xml:space="preserve">
          <source>The special values &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt; may be used when creating a range partition to indicate that there is no lower or upper bound on the column's value. For example, a partition defined using &lt;code&gt;FROM (MINVALUE) TO (10)&lt;/code&gt; allows any values less than 10, and a partition defined using &lt;code&gt;FROM (10) TO (MAXVALUE)&lt;/code&gt; allows any values greater than or equal to 10.</source>
          <target state="translated">Специальные значения &lt;code&gt;MINVALUE&lt;/code&gt; и &lt;code&gt;MAXVALUE&lt;/code&gt; могут использоваться при создании раздела диапазона, чтобы указать, что у значения столбца нет нижней или верхней границы. Например, раздел, определенный с помощью &lt;code&gt;FROM (MINVALUE) TO (10)&lt;/code&gt; допускает любые значения меньше 10, а раздел, определенный с помощью &lt;code&gt;FROM (10) TO (MAXVALUE)&lt;/code&gt; допускает любые значения, большие или равные 10.</target>
        </trans-unit>
        <trans-unit id="7e90fbaeae1d1655b1bb6f95cb13335bf4d3a214" translate="yes" xml:space="preserve">
          <source>The specially treated variables are:</source>
          <target state="translated">Специально обработанные переменные:</target>
        </trans-unit>
        <trans-unit id="1b586ed754bd73f7164a8d06b3ccf052091b7071" translate="yes" xml:space="preserve">
          <source>The specific data that a BRIN index will store, as well as the specific queries that the index will be able to satisfy, depend on the operator class selected for each column of the index. Data types having a linear sort order can have operator classes that store the minimum and maximum value within each block range, for instance; geometrical types might store the bounding box for all the objects in the block range.</source>
          <target state="translated">Конкретные данные,которые будет хранить индекс BRIN,а также конкретные запросы,которые индекс сможет удовлетворить,зависят от класса оператора,выбранного для каждого столбца индекса.Типы данных,имеющие линейный порядок сортировки,могут иметь операторские классы,которые хранят минимальное и максимальное значение в пределах каждого диапазона блоков,например;геометрические типы могут хранить ограничительную область для всех объектов в диапазоне блоков.</target>
        </trans-unit>
        <trans-unit id="c67370c9102fee266def76d5516bcf8df8f39414" translate="yes" xml:space="preserve">
          <source>The specific function that is referenced by a function call is determined using the following procedure.</source>
          <target state="translated">Конкретная функция,на которую делается ссылка при вызове функции,определяется с помощью следующей процедуры.</target>
        </trans-unit>
        <trans-unit id="d4491b1318b4f57536f43e332d74ca6d054454c5" translate="yes" xml:space="preserve">
          <source>The specific operator that is referenced by an operator expression is determined using the following procedure. Note that this procedure is indirectly affected by the precedence of the operators involved, since that will determine which sub-expressions are taken to be the inputs of which operators. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">Конкретный оператор, на который ссылается выражение оператора, определяется с помощью следующей процедуры. Обратите внимание, что на эту процедуру косвенно влияет приоритет задействованных операторов, поскольку от него будет зависеть, какие подвыражения будут входными данными для каких операторов. См. &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Раздел 4.1.6&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="56960e04e804eb4178adc815aab5ca82c4358153" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;index&lt;/code&gt; can be an integer, as well as an expression returning a single numeric value, which is automatically cast to integer. Index zero corresponds to the first array element. You can also use the &lt;code&gt;last&lt;/code&gt; keyword to denote the last array element, which is useful for handling arrays of unknown length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf52c4d6cf2c8133df1aca73cde50bf658361fd0" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;index&lt;/code&gt; can be an integer, as well as an expression returning a single numeric value, which is automatically cast to integer. Zero index corresponds to the first array element. You can also use the &lt;code&gt;last&lt;/code&gt; keyword to denote the last array element, which is useful for handling arrays of unknown length.</source>
          <target state="translated">Указанный &lt;code&gt;index&lt;/code&gt; может быть целым числом, а также выражением, возвращающим одно числовое значение, которое автоматически преобразуется в целое число. Нулевой индекс соответствует первому элементу массива. Вы также можете использовать ключевое слово &lt;code&gt;last&lt;/code&gt; для обозначения последнего элемента массива, что полезно для обработки массивов неизвестной длины.</target>
        </trans-unit>
        <trans-unit id="8859206cebb9c86d9bc85a5c793d72f97cbfcda7" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;role_name&lt;/code&gt; must be a role that the current session user is a member of. (If the session user is a superuser, any role can be selected.)</source>
          <target state="translated">Указанное &lt;code&gt;role_name&lt;/code&gt; должно быть ролью, членом которой является текущий пользователь сеанса. (Если пользователь сеанса является суперпользователем, можно выбрать любую роль.)</target>
        </trans-unit>
        <trans-unit id="afd818a1af1c31122dbe5ccb86326656bebfdabf" translate="yes" xml:space="preserve">
          <source>The specified locale and encoding settings must match, or an error will be reported.</source>
          <target state="translated">Указанная локаль и настройки кодирования должны совпадать,иначе будет сообщено об ошибке.</target>
        </trans-unit>
        <trans-unit id="0c30502cb792c5bd66e555818ae0268a7466dc40" translate="yes" xml:space="preserve">
          <source>The specified null string is sent by &lt;code&gt;COPY TO&lt;/code&gt; without adding any backslashes; conversely, &lt;code&gt;COPY FROM&lt;/code&gt; matches the input against the null string before removing backslashes. Therefore, a null string such as &lt;code&gt;\N&lt;/code&gt; cannot be confused with the actual data value &lt;code&gt;\N&lt;/code&gt; (which would be represented as &lt;code&gt;\\N&lt;/code&gt;).</source>
          <target state="translated">Указанная пустая строка отправляется &lt;code&gt;COPY TO&lt;/code&gt; без добавления обратной косой черты; и наоборот, &lt;code&gt;COPY FROM&lt;/code&gt; сопоставляет ввод с пустой строкой перед удалением обратной косой черты. Следовательно, пустую строку, такую ​​как &lt;code&gt;\N&lt;/code&gt; нельзя путать с фактическим значением данных &lt;code&gt;\N&lt;/code&gt; (которое будет представлено как &lt;code&gt;\\N&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d4785fdbe411a867de5dc30c6f6e2cd3e8ad8aa" translate="yes" xml:space="preserve">
          <source>The specified replication slot has to exist unless the option &lt;code&gt;-C&lt;/code&gt; is also used.</source>
          <target state="translated">Указанный слот репликации должен существовать, если также не используется опция &lt;code&gt;-C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe37bdbcd81870812798f7398d4fa3769b9383b0" translate="yes" xml:space="preserve">
          <source>The speed of the archiving command is unimportant as long as it can keep up with the average rate at which your server generates WAL data. Normal operation continues even if the archiving process falls a little behind. If archiving falls significantly behind, this will increase the amount of data that would be lost in the event of a disaster. It will also mean that the &lt;code&gt;pg_wal/&lt;/code&gt; directory will contain large numbers of not-yet-archived segment files, which could eventually exceed available disk space. You are advised to monitor the archiving process to ensure that it is working as you intend.</source>
          <target state="translated">Скорость команды архивирования не важна, если она может соответствовать средней скорости, с которой ваш сервер генерирует данные WAL. Нормальная работа продолжается, даже если процесс архивирования немного отстает. Если архивирование значительно отстает, это увеличит объем данных, которые будут потеряны в случае аварии. Это также будет означать, что &lt;code&gt;pg_wal/&lt;/code&gt; будет содержать большое количество еще не заархивированных файлов сегментов, которые в конечном итоге могут превысить доступное дисковое пространство. Рекомендуется следить за процессом архивирования, чтобы убедиться, что он работает так, как вы предполагаете.</target>
        </trans-unit>
        <trans-unit id="95c448049b38c97f5a095366eb9a582e60005694" translate="yes" xml:space="preserve">
          <source>The spi module provides several workable examples of using the &lt;a href=&quot;https://www.postgresql.org/docs/12/spi.html&quot;&gt;Server Programming Interface&lt;/a&gt; (SPI) and triggers. While these functions are of some value in their own right, they are even more useful as examples to modify for your own purposes. The functions are general enough to be used with any table, but you have to specify table and field names (as described below) while creating a trigger.</source>
          <target state="translated">Модуль spi предоставляет несколько рабочих примеров использования &lt;a href=&quot;https://www.postgresql.org/docs/12/spi.html&quot;&gt;интерфейса программирования сервера&lt;/a&gt; (SPI) и триггеров. Хотя эти функции имеют определенную ценность сами по себе, они даже более полезны в качестве примеров для изменения в ваших собственных целях. Эти функции достаточно общие, чтобы их можно было использовать с любой таблицей, но вы должны указать имена таблиц и полей (как описано ниже) при создании триггера.</target>
        </trans-unit>
        <trans-unit id="cab15a6018a42e58d3535f603f3afdd60d9e9dde" translate="yes" xml:space="preserve">
          <source>The spi module provides several workable examples of using the &lt;a href=&quot;https://www.postgresql.org/docs/13/spi.html&quot;&gt;Server Programming Interface&lt;/a&gt; (SPI) and triggers. While these functions are of some value in their own right, they are even more useful as examples to modify for your own purposes. The functions are general enough to be used with any table, but you have to specify table and field names (as described below) while creating a trigger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d51509dfcf1b638bd0142f5ba7e99e05ff8361" translate="yes" xml:space="preserve">
          <source>The standard B-tree operators are also provided, for example</source>
          <target state="translated">Стандартные операторы B-образных деревьев также предоставляются,например</target>
        </trans-unit>
        <trans-unit id="540592c3e626f7c31f8adb5673f9493bff1cdcb6" translate="yes" xml:space="preserve">
          <source>The standard PostgreSQL distribution does not include any Ispell configuration files. Dictionaries for a large number of languages are available from &lt;a href=&quot;https://www.cs.hmc.edu/~geoff/ispell.html&quot;&gt;Ispell&lt;/a&gt;. Also, some more modern dictionary file formats are supported &amp;mdash; &lt;a href=&quot;https://en.wikipedia.org/wiki/MySpell&quot;&gt;MySpell&lt;/a&gt; (OO &amp;lt; 2.0.1) and &lt;a href=&quot;https://sourceforge.net/projects/hunspell/&quot;&gt;Hunspell&lt;/a&gt; (OO &amp;gt;= 2.0.2). A large list of dictionaries is available on the &lt;a href=&quot;https://wiki.openoffice.org/wiki/Dictionaries&quot;&gt;OpenOffice Wiki&lt;/a&gt;.</source>
          <target state="translated">В стандартный дистрибутив PostgreSQL не входят файлы конфигурации Ispell. Словари для большого количества языков доступны в &lt;a href=&quot;https://www.cs.hmc.edu/~geoff/ispell.html&quot;&gt;Ispell&lt;/a&gt; . Также поддерживаются некоторые более современные форматы файлов словарей - &lt;a href=&quot;https://en.wikipedia.org/wiki/MySpell&quot;&gt;MySpell&lt;/a&gt; (OO &amp;lt;2.0.1) и &lt;a href=&quot;https://sourceforge.net/projects/hunspell/&quot;&gt;Hunspell&lt;/a&gt; (OO&amp;gt; = 2.0.2). Большой список словарей доступен в &lt;a href=&quot;https://wiki.openoffice.org/wiki/Dictionaries&quot;&gt;OpenOffice Wiki&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c31d1f8f49b866b6c41ce1d3be305d54cfca10f1" translate="yes" xml:space="preserve">
          <source>The standard allows transition tables to be used with column-specific &lt;code&gt;UPDATE&lt;/code&gt; triggers, but then the set of rows that should be visible in the transition tables depends on the trigger's column list. This is not currently implemented by PostgreSQL.</source>
          <target state="translated">Стандарт позволяет использовать таблицы перехода с триггерами &lt;code&gt;UPDATE&lt;/code&gt; для конкретных столбцов , но тогда набор строк, которые должны быть видны в таблицах перехода, зависит от списка столбцов триггера. В настоящее время PostgreSQL не поддерживает это.</target>
        </trans-unit>
        <trans-unit id="7abbb06bd2ac89072eb3b19d752092cab8a2a05f" translate="yes" xml:space="preserve">
          <source>The standard and predefined collations are in the schema &lt;code&gt;pg_catalog&lt;/code&gt;, like all predefined objects. User-defined collations should be created in user schemas. This also ensures that they are saved by &lt;code&gt;pg_dump&lt;/code&gt;.</source>
          <target state="translated">Стандартные и предопределенные сопоставления находятся в схеме &lt;code&gt;pg_catalog&lt;/code&gt; , как и все предопределенные объекты. В пользовательских схемах следует создавать определяемые пользователем параметры сортировки. Это также гарантирует их сохранение с помощью &lt;code&gt;pg_dump&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c4d54e7271038b160fc912ff3e59738441ec42e" translate="yes" xml:space="preserve">
          <source>The standard approach to doing case-insensitive matches in PostgreSQL has been to use the &lt;code&gt;lower&lt;/code&gt; function when comparing values, for example</source>
          <target state="translated">Стандартный подход к выполнению сопоставлений без учета регистра в PostgreSQL заключался в использовании &lt;code&gt;lower&lt;/code&gt; функции при сравнении значений, например</target>
        </trans-unit>
        <trans-unit id="66a45d5bab8320954db0c2f93584f58e956d983a" translate="yes" xml:space="preserve">
          <source>The standard comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for &lt;code&gt;jsonb&lt;/code&gt;, but not for &lt;code&gt;json&lt;/code&gt;. They follow the ordering rules for B-tree operations outlined at &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt;.</source>
          <target state="translated">Стандартные операторы сравнения, показанные в &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;таблице 9.1&lt;/a&gt; , доступны для &lt;code&gt;jsonb&lt;/code&gt; , но не для &lt;code&gt;json&lt;/code&gt; . Они следуют правилам упорядочивания операций с B-деревом, описанным в &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Разделе 8.14.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aecb6846cb8fa061d2893b8cbe3329208b79f989" translate="yes" xml:space="preserve">
          <source>The standard form of &lt;code&gt;VACUUM&lt;/code&gt; removes dead row versions in tables and indexes and marks the space available for future reuse. However, it will not return the space to the operating system, except in the special case where one or more pages at the end of a table become entirely free and an exclusive table lock can be easily obtained. In contrast, &lt;code&gt;VACUUM FULL&lt;/code&gt; actively compacts tables by writing a complete new version of the table file with no dead space. This minimizes the size of the table, but can take a long time. It also requires extra disk space for the new copy of the table, until the operation completes.</source>
          <target state="translated">Стандартная форма &lt;code&gt;VACUUM&lt;/code&gt; удаляет мертвые версии строк в таблицах и индексах и отмечает пространство, доступное для будущего повторного использования. Однако он не вернет пространство операционной системе, за исключением особого случая, когда одна или несколько страниц в конце таблицы становятся полностью свободными и монопольная блокировка таблицы может быть легко получена. Напротив, &lt;code&gt;VACUUM FULL&lt;/code&gt; активно сжимает таблицы, записывая полностью новую версию табличного файла без мертвого пространства. Это минимизирует размер стола, но может занять много времени. Также требуется дополнительное дисковое пространство для новой копии таблицы до завершения операции.</target>
        </trans-unit>
        <trans-unit id="64a9df6af803f6fb88db88a2c8492bf422359cc7" translate="yes" xml:space="preserve">
          <source>The standard only allows one function to be dropped per command.</source>
          <target state="translated">Стандарт допускает сброс только одной функции на каждую команду.</target>
        </trans-unit>
        <trans-unit id="f5dc058e6d69517b035378cc0545a3ff6bbf59c9" translate="yes" xml:space="preserve">
          <source>The standard only allows one procedure to be dropped per command.</source>
          <target state="translated">Стандарт позволяет сбросить только одну процедуру на одну команду.</target>
        </trans-unit>
        <trans-unit id="d079640bb3afa14420ec7729af4881846a5851ac" translate="yes" xml:space="preserve">
          <source>The standard only allows one routine to be dropped per command.</source>
          <target state="translated">Стандарт позволяет сбросить только одну рутину на каждую команду.</target>
        </trans-unit>
        <trans-unit id="d6f30578370e30868e083b5faa5f9ddb49a2e7ea" translate="yes" xml:space="preserve">
          <source>The standard requires parentheses around the subquery clause; in PostgreSQL, these parentheses are optional.</source>
          <target state="translated">Стандарт требует круглых скобок вокруг подзапросного выражения;в PostgreSQL эти скобки являются необязательными.</target>
        </trans-unit>
        <trans-unit id="037c9f0273cfeaa62d235fa64430e2ec604be3e9" translate="yes" xml:space="preserve">
          <source>The standard's definition of the behavior of temporary tables is widely ignored. PostgreSQL's behavior on this point is similar to that of several other SQL databases.</source>
          <target state="translated">Стандартное определение поведения временных таблиц широко игнорируется.Поведение PostgreSQL в этом вопросе похоже на поведение некоторых других баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="d958124d33ada3ecaa4ecf5cd2414a7d80adeee5" translate="yes" xml:space="preserve">
          <source>The statement subforms and actions available for &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; are a subset of those available for &lt;code&gt;ALTER TABLE&lt;/code&gt;, and have the same meaning when used for materialized views. See the descriptions for &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for details.</source>
          <target state="translated">Подформы операторов и действия, доступные для &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; , являются подмножеством тех, которые доступны для &lt;code&gt;ALTER TABLE&lt;/code&gt; , и имеют то же значение при использовании для материализованных представлений. Подробности см. В описании &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adf6cc4f8a6109f575b7d3519d3e9c33574716b7" translate="yes" xml:space="preserve">
          <source>The statistic-gathering target for this statistics object for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the maximum of the statistics target of the referenced columns, if set, or the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a85ce8c175ffd31b8c2d56822ffccc6660fc62f" translate="yes" xml:space="preserve">
          <source>The statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt; usually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. One or both of these can be omitted if &lt;code&gt;ANALYZE&lt;/code&gt; deems them uninteresting (for example, in a unique-key column, there are no common values) or if the column data type does not support the appropriate operators. There is more information about the statistics in &lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt;.</source>
          <target state="translated">Статистика, собираемая &lt;code&gt;ANALYZE&lt;/code&gt; , обычно включает список некоторых из наиболее распространенных значений в каждом столбце и гистограмму, показывающую приблизительное распределение данных в каждом столбце. Один или оба из них могут быть опущены, если &lt;code&gt;ANALYZE&lt;/code&gt; считает их неинтересными (например, в столбце с уникальным ключом нет общих значений) или если тип данных столбца не поддерживает соответствующие операторы. Более подробная информация о статистике представлена ​​в &lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;главе 24&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adfbbd6d85375712da67e76aabf75e7f5395de5a" translate="yes" xml:space="preserve">
          <source>The statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt; usually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. One or both of these can be omitted if &lt;code&gt;ANALYZE&lt;/code&gt; deems them uninteresting (for example, in a unique-key column, there are no common values) or if the column data type does not support the appropriate operators. There is more information about the statistics in &lt;a href=&quot;https://www.postgresql.org/docs/13/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238068c46fb76fc5b6da5477e8f4ec22c3889848" translate="yes" xml:space="preserve">
          <source>The statistics collector is active during recovery. All scans, reads, blocks, index usage, etc., will be recorded normally on the standby. Replayed actions will not duplicate their effects on primary, so replaying an insert will not increment the Inserts column of pg_stat_user_tables. The stats file is deleted at the start of recovery, so stats from primary and standby will differ; this is considered a feature, not a bug.</source>
          <target state="translated">Во время восстановления активен коллектор статистики.Все сканирования,чтения,блоки,использование индексов и т.д.будут записываться в обычном режиме ожидания.Воспроизводимые действия не будут дублировать свои эффекты на первичном,поэтому повторное воспроизведение вставки не увеличит столбец вставки pg_stat_user_tables.Статистический файл удаляется в начале восстановления,поэтому статистика из первичного и резервного будет отличаться;это считается особенностью,а не ошибкой.</target>
        </trans-unit>
        <trans-unit id="965711f627243ac89dbb9d9e575eab2acab52658" translate="yes" xml:space="preserve">
          <source>The statistics collector transmits the collected information to other PostgreSQL processes through temporary files. These files are stored in the directory named by the &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; parameter, &lt;code&gt;pg_stat_tmp&lt;/code&gt; by default. For better performance, &lt;code&gt;stats_temp_directory&lt;/code&gt; can be pointed at a RAM-based file system, decreasing physical I/O requirements. When the server shuts down cleanly, a permanent copy of the statistics data is stored in the &lt;code&gt;pg_stat&lt;/code&gt; subdirectory, so that statistics can be retained across server restarts. When recovery is performed at server start (e.g. after immediate shutdown, server crash, and point-in-time recovery), all statistics counters are reset.</source>
          <target state="translated">Сборщик статистики передает собранную информацию другим процессам PostgreSQL через временные файлы. Эти файлы хранятся в папке с именем по &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; параметра, &lt;code&gt;pg_stat_tmp&lt;/code&gt; по умолчанию. Для повышения производительности &lt;code&gt;stats_temp_directory&lt;/code&gt; может указывать на файловую систему на основе ОЗУ, что снижает требования к физическому вводу-выводу . Когда сервер завершает работу без ошибок, постоянная копия данных статистики сохраняется в подкаталоге &lt;code&gt;pg_stat&lt;/code&gt; , так что статистика может сохраняться при перезапусках сервера. Когда восстановление выполняется при запуске сервера (например, после немедленного завершения работы, сбоя сервера и восстановления на определенный момент времени), все счетчики статистики сбрасываются.</target>
        </trans-unit>
        <trans-unit id="ed6f0b5b68c60cb649e8a7cdfda530aaa032eb80" translate="yes" xml:space="preserve">
          <source>The statistics collector transmits the collected information to other PostgreSQL processes through temporary files. These files are stored in the directory named by the &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; parameter, &lt;code&gt;pg_stat_tmp&lt;/code&gt; by default. For better performance, &lt;code&gt;stats_temp_directory&lt;/code&gt; can be pointed at a RAM-based file system, decreasing physical I/O requirements. When the server shuts down cleanly, a permanent copy of the statistics data is stored in the &lt;code&gt;pg_stat&lt;/code&gt; subdirectory, so that statistics can be retained across server restarts. When recovery is performed at server start (e.g., after immediate shutdown, server crash, and point-in-time recovery), all statistics counters are reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d31102b772c217f86df5c917a56d333df998b96" translate="yes" xml:space="preserve">
          <source>The statistics gathered by the module are made available via a view named &lt;code&gt;pg_stat_statements&lt;/code&gt;. This view contains one row for each distinct database ID, user ID and query ID (up to the maximum number of distinct statements that the module can track). The columns of the view are shown in &lt;a href=&quot;pgstatstatements#PGSTATSTATEMENTS-COLUMNS&quot;&gt;Table F.21&lt;/a&gt;.</source>
          <target state="translated">Статистика, собранная модулем, доступна через представление с именем &lt;code&gt;pg_stat_statements&lt;/code&gt; . Это представление содержит по одной строке для каждого отдельного идентификатора базы данных, идентификатора пользователя и идентификатора запроса (до максимального количества отдельных операторов, которые модуль может отслеживать). Столбцы представления показаны в &lt;a href=&quot;pgstatstatements#PGSTATSTATEMENTS-COLUMNS&quot;&gt;Таблице F.21&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d129f0558b07e424e594be75be7478f28f34b280" translate="yes" xml:space="preserve">
          <source>The stop point must be after the ending time of the base backup, i.e., the end time of &lt;code&gt;pg_stop_backup&lt;/code&gt;. You cannot use a base backup to recover to a time when that backup was in progress. (To recover to such a time, you must go back to your previous base backup and roll forward from there.)</source>
          <target state="translated">Точка остановки должна быть позже времени окончания базовой резервной копии, т. &lt;code&gt;pg_stop_backup&lt;/code&gt; окончания pg_stop_backup . Вы не можете использовать базовую резервную копию для восстановления до времени, когда это резервное копирование выполнялось. (Чтобы восстановить это время, вы должны вернуться к предыдущей базовой резервной копии и выполнить откат оттуда.)</target>
        </trans-unit>
        <trans-unit id="991a8e15374d6e812a4e43376053e637a59638d9" translate="yes" xml:space="preserve">
          <source>The stopword file format is the same as already explained.</source>
          <target state="translated">Формат файла со стоп-слова тот же,что уже объяснялся.</target>
        </trans-unit>
        <trans-unit id="6a67abf97180ecab3e7785607a17892200ca122a" translate="yes" xml:space="preserve">
          <source>The storage alignment requirement of the data type. If specified, it must be &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, or &lt;code&gt;double&lt;/code&gt;; the default is &lt;code&gt;int4&lt;/code&gt;.</source>
          <target state="translated">Требование выравнивания хранилища для типа данных. Если указано, это должно быть &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;int2&lt;/code&gt; , &lt;code&gt;int4&lt;/code&gt; или &lt;code&gt;double&lt;/code&gt; ; по умолчанию - &lt;code&gt;int4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fb27d9289cba59d0dbea8d9a256bcf54f4d8f1d" translate="yes" xml:space="preserve">
          <source>The storage requirement for a short string (up to 126 bytes) is 1 byte plus the actual string, which includes the space padding in the case of &lt;code&gt;character&lt;/code&gt;. Longer strings have 4 bytes of overhead instead of 1. Long strings are compressed by the system automatically, so the physical requirement on disk might be less. Very long values are also stored in background tables so that they do not interfere with rapid access to shorter column values. In any case, the longest possible character string that can be stored is about 1 GB. (The maximum value that will be allowed for &lt;code&gt;n&lt;/code&gt; in the data type declaration is less than that. It wouldn't be useful to change this because with multibyte character encodings the number of characters and bytes can be quite different. If you desire to store long strings with no specific upper limit, use &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;character varying&lt;/code&gt; without a length specifier, rather than making up an arbitrary length limit.)</source>
          <target state="translated">Требование к хранению для короткой строки (до 126 байт) составляет 1 байт плюс фактическая строка, которая включает заполнение пробела в случае &lt;code&gt;character&lt;/code&gt; . Более длинные строки имеют 4 байта накладных расходов вместо 1. Длинные строки сжимаются системой автоматически, поэтому физические требования к диску могут быть меньше. Очень длинные значения также хранятся в фоновых таблицах, чтобы они не мешали быстрому доступу к более коротким значениям столбцов. В любом случае максимально длинная строка символов, которую можно сохранить, составляет около 1 ГБ. (Максимальное допустимое значение для &lt;code&gt;n&lt;/code&gt; в объявлении типа данных меньше этого. Было бы бесполезно менять это, потому что с многобайтовыми кодировками символов количество символов и байтов может быть совершенно другим. Если вы хотите хранить длинные строки без определенного верхнего предела, используйте &lt;code&gt;character varying&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; или символ без спецификатора длины, а не создавайте произвольный предел длины.)</target>
        </trans-unit>
        <trans-unit id="80d6814e5ec0e1d06f3de3ede9d15794bac11987" translate="yes" xml:space="preserve">
          <source>The storage strategy for the data type. If specified, must be &lt;code&gt;plain&lt;/code&gt;, &lt;code&gt;external&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, or &lt;code&gt;main&lt;/code&gt;; the default is &lt;code&gt;plain&lt;/code&gt;.</source>
          <target state="translated">Стратегия хранения для типа данных. Если указано, должно быть &lt;code&gt;plain&lt;/code&gt; , &lt;code&gt;external&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; или &lt;code&gt;main&lt;/code&gt; ; значение по умолчанию - &lt;code&gt;plain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b76e63a79625e26440cca8d9a00f3887da24e61" translate="yes" xml:space="preserve">
          <source>The stream format is determined by the output plugin specified when the slot was created.</source>
          <target state="translated">Формат потока определяется выходным плагином,заданным при создании слота.</target>
        </trans-unit>
        <trans-unit id="19380cfa586d87fdf911b110ff6bf4d13369bdea" translate="yes" xml:space="preserve">
          <source>The string constant can be written using either regular SQL notation or dollar-quoting.</source>
          <target state="translated">Строковая константа может быть написана как обычной SQL-нотацией,так и долларом.</target>
        </trans-unit>
        <trans-unit id="84091e9e070956556635627e5454034e5e1ceadb" translate="yes" xml:space="preserve">
          <source>The string constant's text is passed to the input conversion routine for the type called &lt;code&gt;type&lt;/code&gt;. The result is a constant of the indicated type. The explicit type cast can be omitted if there is no ambiguity as to the type the constant must be (for example, when it is assigned directly to a table column), in which case it is automatically coerced.</source>
          <target state="translated">Текст строковой константы передается подпрограмме преобразования ввода для типа с именем &lt;code&gt;type&lt;/code&gt; . Результат - константа указанного типа. Явное приведение типа может быть опущено, если нет двусмысленности в отношении типа, которым должна быть константа (например, когда она назначается непосредственно столбцу таблицы), и в этом случае она автоматически приводится в соответствие.</target>
        </trans-unit>
        <trans-unit id="c916cd87a0dd50984ecec5d10546dad9c3284d3a" translate="yes" xml:space="preserve">
          <source>The string must start with a &lt;code&gt;P&lt;/code&gt;, and may include a &lt;code&gt;T&lt;/code&gt; that introduces the time-of-day units. The available unit abbreviations are given in &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-ISO8601-UNITS&quot;&gt;Table 8.16&lt;/a&gt;. Units may be omitted, and may be specified in any order, but units smaller than a day must appear after &lt;code&gt;T&lt;/code&gt;. In particular, the meaning of &lt;code&gt;M&lt;/code&gt; depends on whether it is before or after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Строка должна начинаться с буквы &lt;code&gt;P&lt;/code&gt; и может включать букву &lt;code&gt;T&lt;/code&gt; , обозначающую единицы времени суток. Доступные сокращения единиц приведены в &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-ISO8601-UNITS&quot;&gt;таблице 8.16&lt;/a&gt; . Блоки могут быть опущены, и могут быть указаны в любом порядке, но единицы меньше , чем в день должны появиться после того, как &lt;code&gt;T&lt;/code&gt; . В частности, значение &lt;code&gt;M&lt;/code&gt; зависит от того, является ли оно до или после того, как &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5ac1d279bca8c92d106e249d73c9450bd51985a" translate="yes" xml:space="preserve">
          <source>The string used as &lt;code&gt;NAS Identifier&lt;/code&gt; in the RADIUS requests. This parameter can be used as a second parameter identifying for example which database user the user is attempting to authenticate as, which can be used for policy matching on the RADIUS server. If no identifier is specified, the default &lt;code&gt;postgresql&lt;/code&gt; will be used.</source>
          <target state="translated">Строка, используемая в качестве &lt;code&gt;NAS Identifier&lt;/code&gt; в запросах RADIUS. Этот параметр может использоваться как второй параметр, определяющий, например, пользователя базы данных, от имени которого пользователь пытается пройти аутентификацию, который может использоваться для сопоставления политик на сервере RADIUS. Если идентификатор не указан, будет использоваться &lt;code&gt;postgresql&lt;/code&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="b3ee7b9f09ddbdb9488305b75db66d9c52bca23d" translate="yes" xml:space="preserve">
          <source>The string value of an XML element is the concatenation, in document order, of all text nodes contained in that element and its descendants. The string value of an element with no descendant text nodes is an empty string (not &lt;code&gt;NULL&lt;/code&gt;). Any &lt;code&gt;xsi:nil&lt;/code&gt; attributes are ignored. Note that the whitespace-only &lt;code&gt;text()&lt;/code&gt; node between two non-text elements is preserved, and that leading whitespace on a &lt;code&gt;text()&lt;/code&gt; node is not flattened. The XPath 1.0 &lt;code&gt;string&lt;/code&gt; function may be consulted for the rules defining the string value of other XML node types and non-XML values.</source>
          <target state="translated">Строковое значение элемента XML - это объединение в порядке документа всех текстовых узлов, содержащихся в этом элементе и его потомках. Строковое значение элемента без текстовых узлов-потомков - это пустая строка (не &lt;code&gt;NULL&lt;/code&gt; ). Любые атрибуты &lt;code&gt;xsi:nil&lt;/code&gt; игнорируются. Обратите внимание, что узел &lt;code&gt;text()&lt;/code&gt; содержащий только пробелы, между двумя нетекстовыми элементами сохраняется, а ведущие пробелы в узле &lt;code&gt;text()&lt;/code&gt; не сглаживаются. К &lt;code&gt;string&lt;/code&gt; функции XPath 1.0 можно обратиться за правилами, определяющими строковое значение других типов узлов XML и значений, отличных от XML.</target>
        </trans-unit>
        <trans-unit id="2fec81f56bf595f634fb57f3910c670ede118c7c" translate="yes" xml:space="preserve">
          <source>The string-literal processor removes one level of backslashes, so that what arrives at the composite-value parser looks like &lt;code&gt;(&quot;\&quot;\\&quot;)&lt;/code&gt;. In turn, the string fed to the &lt;code&gt;text&lt;/code&gt; data type's input routine becomes &lt;code&gt;&quot;\&lt;/code&gt;. (If we were working with a data type whose input routine also treated backslashes specially, &lt;code&gt;bytea&lt;/code&gt; for example, we might need as many as eight backslashes in the command to get one backslash into the stored composite field.) Dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) can be used to avoid the need to double backslashes.</source>
          <target state="translated">Процессор строкового литерала удаляет один уровень обратной косой черты, так что то, что поступает в синтаксический анализатор составного значения, выглядит как &lt;code&gt;(&quot;\&quot;\\&quot;)&lt;/code&gt; . В свою очередь, строка, передаваемая в подпрограмму ввода &lt;code&gt;text&lt;/code&gt; типа данных, становится &lt;code&gt;&quot;\&lt;/code&gt; . (Если бы мы работали с типом данных, процедура ввода которого также специально обрабатывала обратную косую черту, например &lt;code&gt;bytea&lt;/code&gt; , нам может потребоваться до восьми обратных косых черт в команде, чтобы получить одну обратную косую черту в сохраненном составном поле.) Цитирование доллара (см &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;. 2.4&lt;/a&gt; ) можно использовать, чтобы избежать двойной обратной косой черты.</target>
        </trans-unit>
        <trans-unit id="6422f96b00c11494b4fcf618b39050902cb1b6e9" translate="yes" xml:space="preserve">
          <source>The strings to be used as &lt;code&gt;NAS Identifier&lt;/code&gt; in the RADIUS requests. This parameter can be used, for example, to identify which database cluster the user is attempting to connect to, which can be useful for policy matching on the RADIUS server. If no identifier is specified, the default &lt;code&gt;postgresql&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9c21921311be92ddd5f85cbd74e19f06bfbb6a" translate="yes" xml:space="preserve">
          <source>The structure &lt;code&gt;IndexAmRoutine&lt;/code&gt; is defined thus:</source>
          <target state="translated">Структура &lt;code&gt;IndexAmRoutine&lt;/code&gt; определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="1b7ec1adb20c9f7f9468502c9f11469bc8e03f67" translate="yes" xml:space="preserve">
          <source>The structure of a query plan is a tree of &lt;em&gt;plan nodes&lt;/em&gt;. Nodes at the bottom level of the tree are scan nodes: they return raw rows from a table. There are different types of scan nodes for different table access methods: sequential scans, index scans, and bitmap index scans. There are also non-table row sources, such as &lt;code&gt;VALUES&lt;/code&gt; clauses and set-returning functions in &lt;code&gt;FROM&lt;/code&gt;, which have their own scan node types. If the query requires joining, aggregation, sorting, or other operations on the raw rows, then there will be additional nodes above the scan nodes to perform these operations. Again, there is usually more than one possible way to do these operations, so different node types can appear here too. The output of &lt;code&gt;EXPLAIN&lt;/code&gt; has one line for each node in the plan tree, showing the basic node type plus the cost estimates that the planner made for the execution of that plan node. Additional lines might appear, indented from the node's summary line, to show additional properties of the node. The very first line (the summary line for the topmost node) has the estimated total execution cost for the plan; it is this number that the planner seeks to minimize.</source>
          <target state="translated">Структура плана запроса - это дерево &lt;em&gt;узлов плана&lt;/em&gt; . Узлы на нижнем уровне дерева являются узлами сканирования: они возвращают необработанные строки из таблицы. Существуют разные типы узлов сканирования для разных методов доступа к таблицам: последовательное сканирование, сканирование индекса и сканирование индекса битовой карты. Существуют также источники строк, не относящиеся к таблице, такие как предложения &lt;code&gt;VALUES&lt;/code&gt; и функции возврата набора в &lt;code&gt;FROM&lt;/code&gt; , которые имеют свои собственные типы узлов сканирования. Если запрос требует объединения, агрегирования, сортировки или других операций с необработанными строками, тогда над узлами сканирования будут дополнительные узлы для выполнения этих операций. Опять же, обычно существует несколько возможных способов выполнения этих операций, поэтому здесь также могут появляться разные типы узлов. Вывод &lt;code&gt;EXPLAIN&lt;/code&gt; имеет одну строку для каждого узла в дереве плана, показывающую базовый тип узла плюс оценки затрат, сделанные планировщиком для выполнения этого узла плана. Могут появиться дополнительные строки с отступом от итоговой строки узла, чтобы показать дополнительные свойства узла. Самая первая строка (итоговая строка для самого верхнего узла) содержит предполагаемую общую стоимость выполнения плана; именно это число планировщик стремится минимизировать.</target>
        </trans-unit>
        <trans-unit id="845e7bd65e68101aeef835121687192ee5165c8e" translate="yes" xml:space="preserve">
          <source>The sub-statements in &lt;code&gt;WITH&lt;/code&gt; are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in &lt;code&gt;WITH&lt;/code&gt;, the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same &lt;em&gt;snapshot&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;), so they cannot &amp;ldquo;see&amp;rdquo; one another's effects on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means that &lt;code&gt;RETURNING&lt;/code&gt; data is the only way to communicate changes between different &lt;code&gt;WITH&lt;/code&gt; sub-statements and the main query. An example of this is that in</source>
          <target state="translated">Подоператоры в &lt;code&gt;WITH&lt;/code&gt; выполняются одновременно друг с другом и с основным запросом. Следовательно, при использовании операторов изменения данных в &lt;code&gt;WITH&lt;/code&gt; порядок, в котором на самом деле происходят указанные обновления, непредсказуем. Все операторы выполняются с одним и тем же &lt;em&gt;снимком&lt;/em&gt; (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Главу 13&lt;/a&gt; ), поэтому они не могут &amp;laquo;видеть&amp;raquo; влияние друг друга на целевые таблицы. Это смягчает последствия непредсказуемости фактического порядка обновления строк и означает, что &lt;code&gt;RETURNING&lt;/code&gt; данных - единственный способ сообщить об изменениях между различными &lt;code&gt;WITH&lt;/code&gt; и основным запросом. Примером этого является то, что в</target>
        </trans-unit>
        <trans-unit id="12dd874db96a4d69f19603b298f230a8d71acc37" translate="yes" xml:space="preserve">
          <source>The sub-statements in &lt;code&gt;WITH&lt;/code&gt; are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in &lt;code&gt;WITH&lt;/code&gt;, the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same &lt;em&gt;snapshot&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;), so they cannot &amp;ldquo;see&amp;rdquo; one another's effects on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means that &lt;code&gt;RETURNING&lt;/code&gt; data is the only way to communicate changes between different &lt;code&gt;WITH&lt;/code&gt; sub-statements and the main query. An example of this is that in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11dad81d612edf5fd0a4215e04a5d2694b81901" translate="yes" xml:space="preserve">
          <source>The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery.</source>
          <target state="translated">Подзапрос может ссылаться на переменные из окружающего запроса,которые будут действовать как константы во время любой из оценок подзапроса.</target>
        </trans-unit>
        <trans-unit id="9047f1ac499137a7641446b4435a2058e7165f8c" translate="yes" xml:space="preserve">
          <source>The subquery must return a single column. If the subquery's output column is of a non-array type, the resulting one-dimensional array will have an element for each row in the subquery result, with an element type matching that of the subquery's output column. If the subquery's output column is of an array type, the result will be an array of the same type but one higher dimension; in this case all the subquery rows must yield arrays of identical dimensionality, else the result would not be rectangular.</source>
          <target state="translated">Подзапрос должен возвращать один столбец.Если столбец вывода подзапроса имеет тип,отличный от массива,то результирующий одномерный массив будет иметь элемент для каждой строки результата подзапроса с типом элемента,совпадающим с типом столбца вывода подзапроса.Если столбец вывода подзапроса имеет тип массива,то результатом будет массив того же типа,но на одно измерение выше;в этом случае все строки подзапроса должны давать массивы одинаковой размерности,иначе результат не будет прямоугольным.</target>
        </trans-unit>
        <trans-unit id="ad9a65e976a88e8f391a32410934cda1367df45d" translate="yes" xml:space="preserve">
          <source>The subquery will generally only be executed long enough to determine whether at least one row is returned, not all the way to completion. It is unwise to write a subquery that has side effects (such as calling sequence functions); whether the side effects occur might be unpredictable.</source>
          <target state="translated">Подзапрос,как правило,выполняется только достаточно долго,чтобы определить,возвращается ли хотя бы одна строка,а не весь путь до завершения.Неразумно писать подзапрос,который имеет побочные эффекты (например,вызов функций последовательности);могут ли возникнуть побочные эффекты быть непредсказуемыми.</target>
        </trans-unit>
        <trans-unit id="68c9d90ab99dc33425ce7d63877e33bcb6f1a254" translate="yes" xml:space="preserve">
          <source>The subscriber also requires the &lt;code&gt;max_replication_slots&lt;/code&gt; to be set. In this case it should be set to at least the number of subscriptions that will be added to the subscriber. &lt;code&gt;max_logical_replication_workers&lt;/code&gt; must be set to at least the number of subscriptions, again plus some reserve for the table synchronization. Additionally the &lt;code&gt;max_worker_processes&lt;/code&gt; may need to be adjusted to accommodate for replication workers, at least (&lt;code&gt;max_logical_replication_workers&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt;). Note that some extensions and parallel queries also take worker slots from &lt;code&gt;max_worker_processes&lt;/code&gt;.</source>
          <target state="translated">Подписчик также требует установки &lt;code&gt;max_replication_slots&lt;/code&gt; . В этом случае должно быть установлено как минимум количество подписок, которые будут добавлены к подписчику. &lt;code&gt;max_logical_replication_workers&lt;/code&gt; должен быть установлен как минимум на количество подписок, плюс некоторый резерв для синхронизации таблицы. Кроме того, возможно, потребуется настроить &lt;code&gt;max_worker_processes&lt;/code&gt; , чтобы приспособить их для работников репликации, по крайней мере ( &lt;code&gt;max_logical_replication_workers&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt; ). Обратите внимание, что некоторые расширения и параллельные запросы также берут рабочие слоты из &lt;code&gt;max_worker_processes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5061f785b5ca16b03e284f2d1ce17b7eeda1d830" translate="yes" xml:space="preserve">
          <source>The subscriber database behaves in the same way as any other PostgreSQL instance and can be used as a publisher for other databases by defining its own publications.</source>
          <target state="translated">База данных подписчиков ведет себя так же,как и любой другой экземпляр PostgreSQL,и может быть использована в качестве издателя для других баз данных,определяя свои собственные публикации.</target>
        </trans-unit>
        <trans-unit id="53e109de41793b3722661641499539600ee95867" translate="yes" xml:space="preserve">
          <source>The subscription apply process will run in the local database with the privileges of a superuser.</source>
          <target state="translated">Процесс применения подписки будет запущен в локальной базе данных с привилегиями суперпользователя.</target>
        </trans-unit>
        <trans-unit id="4cb7abebeb2fd700c8b2ec617037c9667107f4c0" translate="yes" xml:space="preserve">
          <source>The subscription is added using &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; and can be stopped/resumed at any time using the &lt;a href=&quot;sql-altersubscription&quot;&gt;ALTER SUBSCRIPTION&lt;/a&gt; command and removed using &lt;a href=&quot;sql-dropsubscription&quot;&gt;DROP SUBSCRIPTION&lt;/a&gt;.</source>
          <target state="translated">Подписка добавляется с помощью &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; и может быть остановлена ​​/ возобновлена ​​в любое время с помощью команды &lt;a href=&quot;sql-altersubscription&quot;&gt;ALTER SUBSCRIPTION&lt;/a&gt; и удалена с помощью &lt;a href=&quot;sql-dropsubscription&quot;&gt;DROP SUBSCRIPTION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="121044a7fb76fda9e0fbc21177fe11d696a1b02d" translate="yes" xml:space="preserve">
          <source>The subscription represents a replication connection to the publisher. As such this command does not only add definitions in the local catalogs but also creates a replication slot on the publisher.</source>
          <target state="translated">Подписка представляет собой соединение репликации с издателем.Таким образом,эта команда не только добавляет определения в локальные каталоги,но и создает слот для репликации на издателе.</target>
        </trans-unit>
        <trans-unit id="48011fd4928d8a9744bee30b18454a7d53e6f680" translate="yes" xml:space="preserve">
          <source>The subscripts of an array value built with &lt;code&gt;ARRAY&lt;/code&gt; always begin with one. For more information about arrays, see &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.</source>
          <target state="translated">Индексы значений массива, построенного с помощью &lt;code&gt;ARRAY&lt;/code&gt; , всегда начинаются с единицы. Для получения дополнительной информации о массивах см. &lt;a href=&quot;arrays&quot;&gt;Раздел 8.15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2334c3c5a694ddeb266347a848900f44f0cab917" translate="yes" xml:space="preserve">
          <source>The summarizing structure is bound in size by &lt;code&gt;maintenance_work_mem&lt;/code&gt;. In order to ensure that there is no more than a 2% probability of failure to detect an inconsistency for each heap tuple that should be represented in the index, approximately 2 bytes of memory are needed per tuple. As less memory is made available per tuple, the probability of missing an inconsistency slowly increases. This approach limits the overhead of verification significantly, while only slightly reducing the probability of detecting a problem, especially for installations where verification is treated as a routine maintenance task. Any single absent or malformed tuple has a new opportunity to be detected with each new verification attempt.</source>
          <target state="translated">Резюмирующая структура ограничена размером &lt;code&gt;maintenance_work_mem&lt;/code&gt; . Чтобы гарантировать, что вероятность сбоя при обнаружении несоответствия для каждого кортежа кучи, который должен быть представлен в индексе, составляет не более 2%, для каждого кортежа требуется примерно 2 байта памяти. Чем меньше памяти становится доступной для каждого кортежа, вероятность пропуска несоответствия медленно увеличивается. Такой подход значительно ограничивает накладные расходы на проверку, лишь немного уменьшая вероятность обнаружения проблемы, особенно для установок, где проверка рассматривается как рутинная задача обслуживания. Любой один отсутствующий или некорректный кортеж имеет новую возможность обнаруживаться при каждой новой попытке проверки.</target>
        </trans-unit>
        <trans-unit id="aa2efac8a5cca33663d7c228751b90df82bafbc8" translate="yes" xml:space="preserve">
          <source>The switch file &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; is created first, enabling archiving of completed WAL files to occur. After the backup the switch file is removed. Archived WAL files are then added to the backup so that both base backup and all required WAL files are part of the same tar file. Please remember to add error handling to your backup scripts.</source>
          <target state="translated">&lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; создается файл переключателя / var / lib / pgsql / backup_in_progress , что позволяет выполнять архивирование завершенных файлов WAL. После резервного копирования файл переключателя удаляется. Затем заархивированные файлы WAL добавляются в резервную копию, так что и базовая резервная копия, и все необходимые файлы WAL являются частью одного и того же файла tar. Не забудьте добавить обработку ошибок в свои сценарии резервного копирования.</target>
        </trans-unit>
        <trans-unit id="87700f6e1446d98115cf77b5305bf6c280312a5f" translate="yes" xml:space="preserve">
          <source>The symbol shown in the column &amp;ldquo;Condition Name&amp;rdquo; is the condition name to use in PL/pgSQL. Condition names can be written in either upper or lower case. (Note that PL/pgSQL does not recognize warning, as opposed to error, condition names; those are classes 00, 01, and 02.)</source>
          <target state="translated">Символ, показанный в столбце &amp;laquo;Имя условия&amp;raquo;, - это имя условия, которое следует использовать в PL / pgSQL. Имена условий могут быть написаны как в верхнем, так и в нижнем регистре. (Обратите внимание, что PL / pgSQL не распознает предупреждения, а не ошибки, имена условий; это классы 00, 01 и 02.)</target>
        </trans-unit>
        <trans-unit id="af2af0e19179d988e1c5bb09182f6b8329bf33d2" translate="yes" xml:space="preserve">
          <source>The synchronization workers are taken from the pool defined by &lt;code&gt;max_logical_replication_workers&lt;/code&gt;.</source>
          <target state="translated">Рабочие синхронизации берутся из пула, определенного параметром &lt;code&gt;max_logical_replication_workers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ff2f915045408cc48aad6178d8c49b4353ee6d4" translate="yes" xml:space="preserve">
          <source>The synchronous states of standby servers can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="translated">Синхронные состояния резервных серверов можно просмотреть с помощью представления &lt;code&gt;pg_stat_replication&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">Синтаксис</target>
        </trans-unit>
        <trans-unit id="8f181461d9c844d09a197734c97365af11fec6c2" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;CREATE TABLE&lt;/code&gt; allows the exact size of arrays to be specified, for example:</source>
          <target state="translated">Синтаксис &lt;code&gt;CREATE TABLE&lt;/code&gt; позволяет указывать точный размер массивов, например:</target>
        </trans-unit>
        <trans-unit id="966dbee44492fe4c1ad689fb4503c9e542bc2d3e" translate="yes" xml:space="preserve">
          <source>The syntax for a function call is the name of a function (possibly qualified with a schema name), followed by its argument list enclosed in parentheses:</source>
          <target state="translated">Синтаксис вызова функции-это имя функции (возможно,квалифицированное как имя схемы),за которым следует ее список аргументов,заключенный в круглые скобки:</target>
        </trans-unit>
        <trans-unit id="9827946ae401eb6c51ab3afdb1c21f5055ada0b5" translate="yes" xml:space="preserve">
          <source>The syntax for ordered-set aggregates allows &lt;code&gt;VARIADIC&lt;/code&gt; to be specified for both the last direct parameter and the last aggregated (&lt;code&gt;WITHIN GROUP&lt;/code&gt;) parameter. However, the current implementation restricts use of &lt;code&gt;VARIADIC&lt;/code&gt; in two ways. First, ordered-set aggregates can only use &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;, not other variadic array types. Second, if the last direct parameter is &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;, then there can be only one aggregated parameter and it must also be &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;. (In the representation used in the system catalogs, these two parameters are merged into a single &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; item, since &lt;code&gt;pg_proc&lt;/code&gt; cannot represent functions with more than one &lt;code&gt;VARIADIC&lt;/code&gt; parameter.) If the aggregate is a hypothetical-set aggregate, the direct arguments that match the &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameter are the hypothetical ones; any preceding parameters represent additional direct arguments that are not constrained to match the aggregated arguments.</source>
          <target state="translated">Синтаксис агрегатов упорядоченного набора позволяет &lt;code&gt;VARIADIC&lt;/code&gt; как для последнего прямого параметра, так и для последнего агрегированного параметра ( &lt;code&gt;WITHIN GROUP&lt;/code&gt; ). Однако текущая реализация ограничивает использование &lt;code&gt;VARIADIC&lt;/code&gt; двумя способами. Во-первых, агрегаты с упорядоченным набором могут использовать только &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; , а не другие типы массивов с переменным числом аргументов. Во-вторых, если последний прямой параметр &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; , то может быть только один агрегированный параметр, и он также должен быть &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; . (В представлении, используемом в системных каталогах, эти два параметра объединены в один &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; , поскольку &lt;code&gt;pg_proc&lt;/code&gt; не может представлять функции с более чем одним параметром &lt;code&gt;VARIADIC&lt;/code&gt; .) Если агрегат является агрегатом с гипотетическим набором, прямые аргументы, соответствующие параметру &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; являются гипотетическими; любые предыдущие параметры представляют дополнительные прямые аргументы, которые не ограничиваются соответствием агрегированным аргументам.</target>
        </trans-unit>
        <trans-unit id="d86a8075f285a9e5f082a7c58f078a97fe87d56b" translate="yes" xml:space="preserve">
          <source>The syntax is comparable to &lt;code&gt;CREATE TABLE&lt;/code&gt;, except that only field names and types can be specified; no constraints (such as &lt;code&gt;NOT NULL&lt;/code&gt;) can presently be included. Note that the &lt;code&gt;AS&lt;/code&gt; keyword is essential; without it, the system will think a different kind of &lt;code&gt;CREATE TYPE&lt;/code&gt; command is meant, and you will get odd syntax errors.</source>
          <target state="translated">Синтаксис сравним с &lt;code&gt;CREATE TABLE&lt;/code&gt; , за исключением того, что можно указать только имена и типы полей; никакие ограничения (такие как &lt;code&gt;NOT NULL&lt;/code&gt; ) в настоящее время не могут быть включены. Обратите внимание, что ключевое слово &lt;code&gt;AS&lt;/code&gt; имеет важное значение; без него система подумает, что имеется в виду другая команда &lt;code&gt;CREATE TYPE&lt;/code&gt; , и вы получите странные синтаксические ошибки.</target>
        </trans-unit>
        <trans-unit id="42c058b9d6546225c3baf16e3e4b8ff07bce7ea0" translate="yes" xml:space="preserve">
          <source>The syntax of constants for the numeric types is described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for more information. The following sections describe the types in detail.</source>
          <target state="translated">Синтаксис констант для числовых типов описан в &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;разделе 4.1.2&lt;/a&gt; . Числовые типы имеют полный набор соответствующих арифметических операторов и функций. Обратитесь к &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Главе 9&lt;/a&gt; для получения дополнительной информации. В следующих разделах подробно описаны типы.</target>
        </trans-unit>
        <trans-unit id="066ef2160f0ee25b4e61a233c1f3a6f5f1cba268" translate="yes" xml:space="preserve">
          <source>The syntax of constants for the numeric types is described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for more information. The following sections describe the types in detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3602bbafe5a0054bbc62eb9c26f3d0a2eca852d1" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; is</source>
          <target state="translated">Синтаксис &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; пункта&lt;/a&gt; является</target>
        </trans-unit>
        <trans-unit id="256ca2bba9fef3ff251261724a6f5b0ce7b90218" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt;&lt;/a&gt; clause is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8203a94af84f4e0e580fcba3501f0b24c27a5840" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;CREATE INDEX&lt;/code&gt; command normally requires writing parentheses around index expressions, as shown in the second example. The parentheses can be omitted when the expression is just a function call, as in the first example.</source>
          <target state="translated">Синтаксис команды &lt;code&gt;CREATE INDEX&lt;/code&gt; обычно требует заключения индексных выражений в круглые скобки, как показано во втором примере. Скобки можно опустить, если выражение представляет собой просто вызов функции, как в первом примере.</target>
        </trans-unit>
        <trans-unit id="c241abd813b7161dcc7e86ad91e10959de152091" translate="yes" xml:space="preserve">
          <source>The syntax of this command is similar to that of the SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. All options other than the data source/destination are as specified for &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;. Because of this, special parsing rules apply to the &lt;code&gt;\copy&lt;/code&gt; meta-command. Unlike most other meta-commands, the entire remainder of the line is always taken to be the arguments of &lt;code&gt;\copy&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">Синтаксис этой команды аналогичен синтаксису команды SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; . Все параметры, кроме источника / назначения данных, соответствуют параметрам &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; . Из-за этого к мета-команде &lt;code&gt;\copy&lt;/code&gt; применяются особые правила синтаксического анализа . В отличие от большинства других мета-команд, весь остаток строки всегда считается аргументом &lt;code&gt;\copy&lt;/code&gt; , и в аргументах не выполняется ни интерполяция переменных, ни расширение обратных кавычек.</target>
        </trans-unit>
        <trans-unit id="cd8d680d5b62b13099c9e19bc923e563b07e6d19" translate="yes" xml:space="preserve">
          <source>The syntax used so far requires you to remember the order of the columns. An alternative syntax allows you to list the columns explicitly:</source>
          <target state="translated">Используемый до сих пор синтаксис требует запоминания порядка следования колонок.Альтернативный синтаксис позволяет явным образом перечислять колонки:</target>
        </trans-unit>
        <trans-unit id="033030a62bda22a5de4a5aeea859f2505dc5e730" translate="yes" xml:space="preserve">
          <source>The syntax with &lt;code&gt;ORDER BY&lt;/code&gt; in the parameter list creates a special type of aggregate called an &lt;em&gt;ordered-set aggregate&lt;/em&gt;; or if &lt;code&gt;HYPOTHETICAL&lt;/code&gt; is specified, then a &lt;em&gt;hypothetical-set aggregate&lt;/em&gt; is created. These aggregates operate over groups of sorted values in order-dependent ways, so that specification of an input sort order is an essential part of a call. Also, they can have &lt;em&gt;direct&lt;/em&gt; arguments, which are arguments that are evaluated only once per aggregation rather than once per input row. Hypothetical-set aggregates are a subclass of ordered-set aggregates in which some of the direct arguments are required to match, in number and data types, the aggregated argument columns. This allows the values of those direct arguments to be added to the collection of aggregate-input rows as an additional &amp;ldquo;hypothetical&amp;rdquo; row.</source>
          <target state="translated">Синтаксис с &lt;code&gt;ORDER BY&lt;/code&gt; в списке параметров создает специальный тип агрегата, называемый агрегатом &lt;em&gt;упорядоченного набора&lt;/em&gt; ; или, если указан &lt;code&gt;HYPOTHETICAL&lt;/code&gt; , создается &lt;em&gt;агрегат гипотетического набора&lt;/em&gt; . Эти агрегаты работают с группами отсортированных значений в зависимости от порядка, поэтому указание порядка сортировки ввода является важной частью вызова. Также они могут иметь &lt;em&gt;прямой&lt;/em&gt;аргументы, которые являются аргументами, которые оцениваются только один раз для агрегирования, а не один раз для каждой входной строки. Агрегаты с гипотетическим набором являются подклассом агрегатов с упорядоченным набором, в которых некоторые прямые аргументы требуются для соответствия по количеству и типам данных столбцам агрегированных аргументов. Это позволяет добавлять значения этих прямых аргументов в коллекцию входных агрегированных строк в качестве дополнительной &amp;laquo;гипотетической&amp;raquo; строки.</target>
        </trans-unit>
        <trans-unit id="3670cc6e37bfe2baa6c265184cfb9070b0da0ca9" translate="yes" xml:space="preserve">
          <source>The syntaxes using &lt;code&gt;*&lt;/code&gt; are used for calling parameter-less aggregate functions as window functions, for example &lt;code&gt;count(*) OVER (PARTITION BY x ORDER BY y)&lt;/code&gt;. The asterisk (&lt;code&gt;*&lt;/code&gt;) is customarily not used for window-specific functions. Window-specific functions do not allow &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; to be used within the function argument list.</source>
          <target state="translated">Синтаксисы, в которых используется &lt;code&gt;*&lt;/code&gt; , используются для вызова агрегатных функций без параметров как оконных функций, например &lt;code&gt;count(*) OVER (PARTITION BY x ORDER BY y)&lt;/code&gt; . Звездочка ( &lt;code&gt;*&lt;/code&gt; ) обычно не используется для оконных функций. Специфичные для окна функции не позволяют использовать &lt;code&gt;DISTINCT&lt;/code&gt; или &lt;code&gt;ORDER BY&lt;/code&gt; в списке аргументов функции.</target>
        </trans-unit>
        <trans-unit id="5413e5588ef7474b4153013c25aed37daf2b6ac4" translate="yes" xml:space="preserve">
          <source>The system catalog &lt;code&gt;pg_language&lt;/code&gt; (see &lt;a href=&quot;catalog-pg-language&quot;&gt;Section 51.29&lt;/a&gt;) records information about the currently installed languages. Also, the psql command &lt;code&gt;\dL&lt;/code&gt; lists the installed languages.</source>
          <target state="translated">Системный каталог &lt;code&gt;pg_language&lt;/code&gt; (см. &lt;a href=&quot;catalog-pg-language&quot;&gt;Раздел 51.29&lt;/a&gt; ) записывает информацию об установленных в данный момент языках. Кроме того, команда psql &lt;code&gt;\dL&lt;/code&gt; выводит список установленных языков.</target>
        </trans-unit>
        <trans-unit id="2583bf948cb2199416aaa963439f3392af0c4543" translate="yes" xml:space="preserve">
          <source>The system catalog cache code (and most catalog-munging code in general) assumes that the fixed-length portions of all system catalog tuples are in fact present, because it maps this C struct declaration onto them. Thus, all variable-length fields and nullable fields must be placed at the end, and they cannot be accessed as struct fields. For example, if you tried to set &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typrelid&lt;/code&gt; to be NULL, it would fail when some piece of code tried to reference &lt;code&gt;typetup-&amp;gt;typrelid&lt;/code&gt; (or worse, &lt;code&gt;typetup-&amp;gt;typelem&lt;/code&gt;, because that follows &lt;code&gt;typrelid&lt;/code&gt;). This would result in random errors or even segmentation violations.</source>
          <target state="translated">Код кэша системного каталога (и большая часть кода, изменяющего каталог в целом) предполагает, что на самом деле присутствуют части фиксированной длины всех кортежей системного каталога, поскольку он отображает на них это объявление структуры C. Таким образом, все поля переменной длины и поля, допускающие значение NULL, должны быть помещены в конец, и к ним нельзя получить доступ как к полям структуры. Например, если вы пытались установить &lt;code&gt;pg_type&lt;/code&gt; . &lt;code&gt;typrelid&lt;/code&gt; значение typrelid равно NULL, произойдет сбой, если какой-либо фрагмент кода попытается сослаться на &lt;code&gt;typetup-&amp;gt;typrelid&lt;/code&gt; (или, что еще хуже, &lt;code&gt;typetup-&amp;gt;typelem&lt;/code&gt; , потому что это следует за &lt;code&gt;typrelid&lt;/code&gt; ). Это может привести к случайным ошибкам или даже нарушениям сегментации.</target>
        </trans-unit>
        <trans-unit id="bb485f21372d37054b0b92886fc6889e8d0f2f48" translate="yes" xml:space="preserve">
          <source>The system catalog schema, &lt;code&gt;pg_catalog&lt;/code&gt;, is always searched, whether it is mentioned in the path or not. If it is mentioned in the path then it will be searched in the specified order. If &lt;code&gt;pg_catalog&lt;/code&gt; is not in the path then it will be searched &lt;em&gt;before&lt;/em&gt; searching any of the path items.</source>
          <target state="translated">В схеме системного каталога, &lt;code&gt;pg_catalog&lt;/code&gt; , всегда выполняется поиск, независимо от того, упоминается она в пути или нет. Если он указан в пути, поиск будет выполняться в указанном порядке. Если &lt;code&gt;pg_catalog&lt;/code&gt; отсутствует в пути, он будет найден &lt;em&gt;перед&lt;/em&gt; поиском любого из элементов пути.</target>
        </trans-unit>
        <trans-unit id="dffb9af79cadde8378337d566688f00f092c9630" translate="yes" xml:space="preserve">
          <source>The system catalogs store information about which conversions, or &lt;em&gt;casts&lt;/em&gt;, exist between which data types, and how to perform those conversions. Additional casts can be added by the user with the &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt; command. (This is usually done in conjunction with defining new data types. The set of casts between built-in types has been carefully crafted and is best not altered.)</source>
          <target state="translated">Система каталогов хранить информацию о том, какие преобразования или &lt;em&gt;слепки&lt;/em&gt; , существуют между которыми типами данных, и как выполнять эти преобразования. Дополнительные приведения могут быть добавлены пользователем с помощью команды &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt; . (Обычно это делается вместе с определением новых типов данных. Набор преобразований между встроенными типами был тщательно продуман и лучше не менять.)</target>
        </trans-unit>
        <trans-unit id="94541a873b2d451108de2b46c0592e4902bdbb36" translate="yes" xml:space="preserve">
          <source>The system uses no more than &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 bytes of an identifier; longer names can be written in commands, but they will be truncated. By default, &lt;code&gt;NAMEDATALEN&lt;/code&gt; is 64 so the maximum identifier length is 63 bytes. If this limit is problematic, it can be raised by changing the &lt;code&gt;NAMEDATALEN&lt;/code&gt; constant in &lt;code&gt;src/include/pg_config_manual.h&lt;/code&gt;.</source>
          <target state="translated">Система использует не более &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1 байта идентификатора; в командах можно записывать более длинные имена, но они будут усечены. По умолчанию &lt;code&gt;NAMEDATALEN&lt;/code&gt; равен 64, поэтому максимальная длина идентификатора составляет 63 байта. Если этот предел проблематичен, его можно увеличить, изменив константу &lt;code&gt;NAMEDATALEN&lt;/code&gt; в &lt;code&gt;src/include/pg_config_manual.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18aee9967e71bb22ca6c7ef97d956490785417e5" translate="yes" xml:space="preserve">
          <source>The system view &lt;a href=&quot;view-pg-file-settings&quot;&gt;&lt;code&gt;pg_file_settings&lt;/code&gt;&lt;/a&gt; can be helpful for pre-testing changes to the configuration files, or for diagnosing problems if a SIGHUP signal did not have the desired effects.</source>
          <target state="translated">Системное представление &lt;a href=&quot;view-pg-file-settings&quot;&gt; &lt;code&gt;pg_file_settings&lt;/code&gt; &lt;/a&gt; может быть полезно для предварительного тестирования изменений в файлах конфигурации или для диагностики проблем, если сигнал SIGHUP не дал желаемых результатов.</target>
        </trans-unit>
        <trans-unit id="51af27f0b42d0a59cf04312463422fdaffc06293" translate="yes" xml:space="preserve">
          <source>The system view &lt;a href=&quot;view-pg-hba-file-rules&quot;&gt;&lt;code&gt;pg_hba_file_rules&lt;/code&gt;&lt;/a&gt; can be helpful for pre-testing changes to the &lt;code&gt;pg_hba.conf&lt;/code&gt; file, or for diagnosing problems if loading of the file did not have the desired effects. Rows in the view with non-null &lt;code&gt;error&lt;/code&gt; fields indicate problems in the corresponding lines of the file.</source>
          <target state="translated">Системное представление &lt;a href=&quot;view-pg-hba-file-rules&quot;&gt; &lt;code&gt;pg_hba_file_rules&lt;/code&gt; &lt;/a&gt; может быть полезно для предварительного тестирования изменений в &lt;code&gt;pg_hba.conf&lt;/code&gt; или для диагностики проблем, если загрузка файла не дала желаемых результатов. Строки в представлении с ненулевыми полями &lt;code&gt;error&lt;/code&gt; указывают на проблемы в соответствующих строках файла.</target>
        </trans-unit>
        <trans-unit id="0d1a0c3c602b5e69816adbc6a5f72656d7deb220" translate="yes" xml:space="preserve">
          <source>The system-wide startup file is named &lt;code&gt;psqlrc&lt;/code&gt; and is sought in the installation's &amp;ldquo;system configuration&amp;rdquo; directory, which is most reliably identified by running &lt;code&gt;pg_config --sysconfdir&lt;/code&gt;. By default this directory will be &lt;code&gt;../etc/&lt;/code&gt; relative to the directory containing the PostgreSQL executables. The name of this directory can be set explicitly via the &lt;code&gt;PGSYSCONFDIR&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;psqlrc&lt;/code&gt; файл запуска называется psqlrc и ищется в каталоге &amp;laquo;конфигурации системы&amp;raquo; установки, который наиболее надежно определяется путем выполнения &lt;code&gt;pg_config --sysconfdir&lt;/code&gt; . По умолчанию этот каталог будет &lt;code&gt;../etc/&lt;/code&gt; относительно каталога, содержащего исполняемые файлы PostgreSQL. Имя этого каталога можно задать явно с помощью переменной среды &lt;code&gt;PGSYSCONFDIR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9987d6e81d602450ad224137a711661462f4308" translate="yes" xml:space="preserve">
          <source>The table also shows that PostgreSQL's Repeatable Read implementation does not allow phantom reads. Stricter behavior is permitted by the SQL standard: the four isolation levels only define which phenomena must not happen, not which phenomena &lt;em&gt;must&lt;/em&gt; happen. The behavior of the available isolation levels is detailed in the following subsections.</source>
          <target state="translated">В таблице также показано, что реализация Repeatable Read в PostgreSQL не допускает фантомного чтения. Стандарт SQL допускает более строгое поведение: четыре уровня изоляции только определяют, какие явления не должны происходить, а какие &lt;em&gt;должны&lt;/em&gt; происходить. Поведение доступных уровней изоляции подробно описано в следующих подразделах.</target>
        </trans-unit>
        <trans-unit id="142b69e02a67de00ba841f641f5ef3fa34a277d2" translate="yes" xml:space="preserve">
          <source>The table definition above includes a primary key specification. This is useful to protect against accidentally importing the same information twice. The &lt;code&gt;COPY&lt;/code&gt; command commits all of the data it imports at one time, so any error will cause the entire import to fail. If you import a partial log file and later import the file again when it is complete, the primary key violation will cause the import to fail. Wait until the log is complete and closed before importing. This procedure will also protect against accidentally importing a partial line that hasn't been completely written, which would also cause &lt;code&gt;COPY&lt;/code&gt; to fail.</source>
          <target state="translated">Приведенное выше определение таблицы включает спецификацию первичного ключа. Это полезно для защиты от случайного импорта одной и той же информации дважды. Команда &lt;code&gt;COPY&lt;/code&gt; фиксирует все импортируемые данные за один раз, поэтому любая ошибка приведет к сбою всего импорта. Если вы импортируете частичный файл журнала, а затем снова импортируете файл, когда он будет завершен, нарушение первичного ключа приведет к сбою импорта. Перед импортом дождитесь завершения и закрытия журнала. Эта процедура также защитит от случайного импорта частичной строки, которая не была полностью записана, что также может привести к сбою &lt;code&gt;COPY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990156ac1571d648e7c5aa23d608c8979b58753e" translate="yes" xml:space="preserve">
          <source>The table is also vacuumed if the number of tuples inserted since the last vacuum has exceeded the defined insert threshold, which is defined as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b15dacbb7afc519b6433f93ec4919614f65b399" translate="yes" xml:space="preserve">
          <source>The table is partitioned by explicitly listing which key values appear in each partition.</source>
          <target state="translated">Таблица разбивается на разделы,явно указывая,какие ключевые значения появляются в каждом разделе.</target>
        </trans-unit>
        <trans-unit id="b51488835cbb40ee5da1ee3d9a8f7864d4b57976" translate="yes" xml:space="preserve">
          <source>The table is partitioned by specifying a modulus and a remainder for each partition. Each partition will hold the rows for which the hash value of the partition key divided by the specified modulus will produce the specified remainder.</source>
          <target state="translated">Таблица разбивается на разделы путем указания модуля и остатка для каждого раздела.Каждый раздел будет содержать строки,для которых хэш-значение ключа раздела,деленное на заданный модуль,приведет к указанному остатку.</target>
        </trans-unit>
        <trans-unit id="7c5e839b9bae27b38d6af54b60ca56e0b347f0f2" translate="yes" xml:space="preserve">
          <source>The table is partitioned into &amp;ldquo;ranges&amp;rdquo; defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions. For example, one might partition by date ranges, or by ranges of identifiers for particular business objects.</source>
          <target state="translated">Таблица разделена на &amp;laquo;диапазоны&amp;raquo;, определяемые ключевым столбцом или набором столбцов, без перекрытия между диапазонами значений, назначенными разным разделам. Например, можно разделить по диапазонам дат или по диапазонам идентификаторов для определенных бизнес-объектов.</target>
        </trans-unit>
        <trans-unit id="292e8b677c187c4d68b1ebe250d22a32e9af8561" translate="yes" xml:space="preserve">
          <source>The table or index that the described column belongs to</source>
          <target state="translated">Таблица или индекс,к которому принадлежит описанный столбец</target>
        </trans-unit>
        <trans-unit id="d142b3cf8f5a90793004bbdd69de61322293bd63" translate="yes" xml:space="preserve">
          <source>The table referenced by a referential integrity constraint</source>
          <target state="translated">Таблица,на которую ссылается ограничение на целостность.</target>
        </trans-unit>
        <trans-unit id="2a8191ca3a1df3ed6d1e85b59a92238d8c6f7d14" translate="yes" xml:space="preserve">
          <source>The table this column belongs to</source>
          <target state="translated">Таблица,к которой принадлежит этот столбец</target>
        </trans-unit>
        <trans-unit id="75cfe910e753a5d9a7438e22a49cad2342942a50" translate="yes" xml:space="preserve">
          <source>The table this constraint is on; 0 if not a table constraint</source>
          <target state="translated">Таблица,в которой находится это ограничение;0,если не ограничение таблицы</target>
        </trans-unit>
        <trans-unit id="2f088db11eed75527c26721e5e66e62e0678aeb6" translate="yes" xml:space="preserve">
          <source>The table this rule is for</source>
          <target state="translated">Таблица,для которой это правило</target>
        </trans-unit>
        <trans-unit id="ac24dc8d3f1364ef3223d38811cd0f1cdfc7bc70" translate="yes" xml:space="preserve">
          <source>The table this trigger is on</source>
          <target state="translated">Таблица,на которой этот триггер включен</target>
        </trans-unit>
        <trans-unit id="d2d2364aa6d119df4f431f30d6909fa91ae4a412" translate="yes" xml:space="preserve">
          <source>The table to which the policy applies</source>
          <target state="translated">Таблица,к которой применяется политика</target>
        </trans-unit>
        <trans-unit id="539b9dae513896d5721c3d82785ae25ab4799ccf" translate="yes" xml:space="preserve">
          <source>The tables added to a publication that publishes &lt;code&gt;UPDATE&lt;/code&gt; and/or &lt;code&gt;DELETE&lt;/code&gt; operations must have &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; defined. Otherwise those operations will be disallowed on those tables.</source>
          <target state="translated">Для таблиц, добавленных в публикацию, которая публикует операции &lt;code&gt;UPDATE&lt;/code&gt; и / или &lt;code&gt;DELETE&lt;/code&gt; , должна быть определена &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; . В противном случае эти операции с этими таблицами будут запрещены.</target>
        </trans-unit>
        <trans-unit id="367460ef7d1ca64d14464409850a0a51a7ab7dc7" translate="yes" xml:space="preserve">
          <source>The tables are matched between the publisher and the subscriber using the fully qualified table name. Replication to differently-named tables on the subscriber is not supported.</source>
          <target state="translated">Таблицы сопоставляются между издателем и абонентом,используя полностью квалифицированное название таблицы.Репликация на разные по названию таблицы на подписчика не поддерживается.</target>
        </trans-unit>
        <trans-unit id="f3c0314798fd15f5ed903ef71976f9e615a0bb52" translate="yes" xml:space="preserve">
          <source>The tablespace associated with a database is used to store the system catalogs of that database. Furthermore, it is the default tablespace used for tables, indexes, and temporary files created within the database, if no &lt;code&gt;TABLESPACE&lt;/code&gt; clause is given and no other selection is specified by &lt;code&gt;default_tablespace&lt;/code&gt; or &lt;code&gt;temp_tablespaces&lt;/code&gt; (as appropriate). If a database is created without specifying a tablespace for it, it uses the same tablespace as the template database it is copied from.</source>
          <target state="translated">Табличное пространство, связанное с базой данных, используется для хранения системных каталогов этой базы данных. Кроме того, это табличное пространство по умолчанию, используемое для таблиц, индексов и временных файлов, созданных в базе данных, если не задано предложение &lt;code&gt;TABLESPACE&lt;/code&gt; и не указан другой выбор в &lt;code&gt;default_tablespace&lt;/code&gt; или &lt;code&gt;temp_tablespaces&lt;/code&gt; (в зависимости от ситуации). Если база данных создается без указания табличного пространства для нее, она использует то же табличное пространство, что и база данных шаблона, из которой она копируется.</target>
        </trans-unit>
        <trans-unit id="cd0a83e9744372d73f37f6c31fa32edd33e0f557" translate="yes" xml:space="preserve">
          <source>The tablespace in which this relation is stored. If zero, the database's default tablespace is implied. (Not meaningful if the relation has no on-disk file.)</source>
          <target state="translated">Пространство таблиц,в котором хранится это отношение.Если ноль,то подразумевается табличное пространство БД по умолчанию.(Не имеет значения,если отношение не имеет файла на диске).</target>
        </trans-unit>
        <trans-unit id="91ace69fa784c06e03e2d35b1b8ec1909d7a7501" translate="yes" xml:space="preserve">
          <source>The tablespace in which to create the index. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; for indexes on temporary tables.</source>
          <target state="translated">Табличное пространство, в котором создается индекс. Если не указано, используется &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; или &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; для индексов временных таблиц.</target>
        </trans-unit>
        <trans-unit id="6945a89a0355036aac3b6ff63ff9fc68b1cb28a4" translate="yes" xml:space="preserve">
          <source>The tablespace to which the index will be moved.</source>
          <target state="translated">Пространство таблиц,в которое будет перемещен индекс.</target>
        </trans-unit>
        <trans-unit id="2fdf7a817dfba5e9f0aef01d7a04fe1bad9896f5" translate="yes" xml:space="preserve">
          <source>The tag, if any, of a dollar-quoted string follows the same rules as an unquoted identifier, except that it cannot contain a dollar sign. Tags are case sensitive, so &lt;code&gt;$tag$String content$tag$&lt;/code&gt; is correct, but &lt;code&gt;$TAG$String content$tag$&lt;/code&gt; is not.</source>
          <target state="translated">Тег, если таковой имеется, строки, заключенной в кавычки, подчиняется тем же правилам, что и идентификатор без кавычек, за исключением того, что он не может содержать знак доллара. Теги чувствительны к регистру, поэтому &lt;code&gt;$tag$String content$tag$&lt;/code&gt; верен, а &lt;code&gt;$TAG$String content$tag$&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="bef8aba7a1bcf650d04e76e3a3595346989e8039" translate="yes" xml:space="preserve">
          <source>The target column names can be listed in any order. If no list of column names is given at all, the default is all the columns of the table in their declared order; or the first &lt;code&gt;N&lt;/code&gt; column names, if there are only &lt;code&gt;N&lt;/code&gt; columns supplied by the &lt;code&gt;VALUES&lt;/code&gt; clause or &lt;code&gt;query&lt;/code&gt;. The values supplied by the &lt;code&gt;VALUES&lt;/code&gt; clause or &lt;code&gt;query&lt;/code&gt; are associated with the explicit or implicit column list left-to-right.</source>
          <target state="translated">Имена целевых столбцов могут быть перечислены в любом порядке. Если список имен столбцов не задан, по умолчанию используются все столбцы таблицы в их объявленном порядке; или первые &lt;code&gt;N&lt;/code&gt; имен столбцов, если есть только &lt;code&gt;N&lt;/code&gt; столбцов, предоставленных предложением &lt;code&gt;VALUES&lt;/code&gt; или &lt;code&gt;query&lt;/code&gt; . Значения, предоставленные предложением или &lt;code&gt;query&lt;/code&gt; &lt;code&gt;VALUES&lt;/code&gt; , связаны с явным или неявным списком столбцов слева направо.</target>
        </trans-unit>
        <trans-unit id="a52fa4d647d2a0e534fa04140c4a0531834e1437" translate="yes" xml:space="preserve">
          <source>The target function can be specified by name alone, or by name and arguments, for example &lt;code&gt;foo(integer, text)&lt;/code&gt;. The argument types must be given if there is more than one function of the same name.</source>
          <target state="translated">Целевая функция может быть указана только по имени или по имени и аргументам, например, &lt;code&gt;foo(integer, text)&lt;/code&gt; . Типы аргументов должны быть указаны, если существует более одной функции с одинаковым именем.</target>
        </trans-unit>
        <trans-unit id="6a83f3ee2747bb5a0ebf49f8f4cc7233f65fe3b6" translate="yes" xml:space="preserve">
          <source>The task of the &lt;em&gt;planner/optimizer&lt;/em&gt; is to create an optimal execution plan. A given SQL query (and hence, a query tree) can be actually executed in a wide variety of different ways, each of which will produce the same set of results. If it is computationally feasible, the query optimizer will examine each of these possible execution plans, ultimately selecting the execution plan that is expected to run the fastest.</source>
          <target state="translated">Задача &lt;em&gt;планировщика / оптимизатора&lt;/em&gt; - создать оптимальный план выполнения. Данный SQL-запрос (и, следовательно, дерево запросов) может быть фактически выполнен множеством различных способов, каждый из которых даст одинаковый набор результатов. Если это возможно с вычислительной точки зрения, оптимизатор запросов изучит каждый из этих возможных планов выполнения, в конечном итоге выбрав план выполнения, который, как ожидается, будет выполняться быстрее всего.</target>
        </trans-unit>
        <trans-unit id="d0cfcd2522974bd11b7e720b66ddba5e0dc99d8f" translate="yes" xml:space="preserve">
          <source>The technical difference between a &lt;code&gt;jsonb_ops&lt;/code&gt; and a &lt;code&gt;jsonb_path_ops&lt;/code&gt; GIN index is that the former creates independent index items for each key and value in the data, while the latter creates index items only for each value in the data. &lt;a href=&quot;#ftn.id-1.5.7.22.18.9.3&quot;&gt;&lt;sup id=&quot;id-1.5.7.22.18.9.3&quot;&gt;[6]&lt;/sup&gt;&lt;/a&gt; Basically, each &lt;code&gt;jsonb_path_ops&lt;/code&gt; index item is a hash of the value and the key(s) leading to it; for example to index &lt;code&gt;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&lt;/code&gt;, a single index item would be created incorporating all three of &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt; into the hash value. Thus a containment query looking for this structure would result in an extremely specific index search; but there is no way at all to find out whether &lt;code&gt;foo&lt;/code&gt; appears as a key. On the other hand, a &lt;code&gt;jsonb_ops&lt;/code&gt; index would create three index items representing &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt; separately; then to do the containment query, it would look for rows containing all three of these items. While GIN indexes can perform such an AND search fairly efficiently, it will still be less specific and slower than the equivalent &lt;code&gt;jsonb_path_ops&lt;/code&gt; search, especially if there are a very large number of rows containing any single one of the three index items.</source>
          <target state="translated">Техническая разница между &lt;code&gt;jsonb_path_ops&lt;/code&gt; GIN &lt;code&gt;jsonb_ops&lt;/code&gt; и jsonb_path_ops заключается в том, что первый создает независимые элементы индекса для каждого ключа и значения в данных, а второй создает элементы индекса только для каждого значения в данных. &lt;a href=&quot;#ftn.id-1.5.7.22.18.9.3&quot;&gt;&lt;sup id=&quot;id-1.5.7.22.18.9.3&quot;&gt;[6]&lt;/sup&gt;&lt;/a&gt; По сути, каждый &lt;code&gt;jsonb_path_ops&lt;/code&gt; индекса jsonb_path_ops является хешем значения и ключа (ов), ведущего к нему; например, для индексации &lt;code&gt;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&lt;/code&gt; создан один элемент индекса, включающий все три из &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; и &lt;code&gt;baz&lt;/code&gt; в хеш-значение. Таким образом, запрос включения, ищущий эту структуру, приведет к чрезвычайно специфическому поиску по индексу; но нет никакого способа узнать, &lt;code&gt;foo&lt;/code&gt; отображается как ключ. С другой стороны, индекс &lt;code&gt;jsonb_ops&lt;/code&gt; создаст три элемента индекса, представляющих отдельно &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; и &lt;code&gt;baz&lt;/code&gt; ; затем, чтобы выполнить запрос на включение, он будет искать строки, содержащие все три из этих элементов. Хотя индексы GIN могут выполнять такой поиск AND довольно эффективно, он все же будет менее конкретным и медленнее, чем эквивалентный поиск &lt;code&gt;jsonb_path_ops&lt;/code&gt; , особенно если имеется очень большое количество строк, содержащих один из трех элементов индекса.</target>
        </trans-unit>
        <trans-unit id="1c8f7bc59665b224be12f558ca16a9e07627bb77" translate="yes" xml:space="preserve">
          <source>The temporary table will be dropped at the end of the current transaction block.</source>
          <target state="translated">Временная таблица будет опущена в конце текущего блока транзакций.</target>
        </trans-unit>
        <trans-unit id="2e88ee252852e295414cf3850a24be66c227bee2" translate="yes" xml:space="preserve">
          <source>The temporary table will be dropped at the end of the current transaction block. When used on a partitioned table, this action drops its partitions and when used on tables with inheritance children, it drops the dependent children.</source>
          <target state="translated">Временная таблица будет опущена в конце текущего блока транзакций.При использовании на разбитой на разделы таблице данное действие выкидывает ее разделы,а при использовании на таблицах с дочерними процессами наследования выкидывает зависимые дочерние процессы.</target>
        </trans-unit>
        <trans-unit id="544789fd88fe85a89dc95a84868e683fa382498a" translate="yes" xml:space="preserve">
          <source>The term attribute is equivalent to column and is used for historical reasons.</source>
          <target state="translated">Термин атрибут эквивалентен столбцу и используется в исторических целях.</target>
        </trans-unit>
        <trans-unit id="a4a7c2d2771e24236d6f1bdd6761fd668754e8bc" translate="yes" xml:space="preserve">
          <source>The text representation of an &lt;code&gt;hstore&lt;/code&gt;, used for input and output, includes zero or more &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs separated by commas. Some examples:</source>
          <target state="translated">Текстовое представление &lt;code&gt;hstore&lt;/code&gt; , используемое для ввода и вывода, включает в себя ноль или более пар &lt;code&gt;key&lt;/code&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; разделенных запятыми. Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="98a0a387ebcc73eb1a002f76f9873cf6168a1347" translate="yes" xml:space="preserve">
          <source>The text-search functionality in PostgreSQL can also be used to speed up full-document searches of XML data. The necessary preprocessing support is, however, not yet available in the PostgreSQL distribution.</source>
          <target state="translated">Функциональность поиска текста в PostgreSQL также может быть использована для ускорения полнотекстового поиска XML-данных.Однако необходимая поддержка препроцессинга в дистрибутиве PostgreSQL пока недоступна.</target>
        </trans-unit>
        <trans-unit id="9535cead63cebae1ff29d54da604a76ade0e73e1" translate="yes" xml:space="preserve">
          <source>The textual label for this enum value</source>
          <target state="translated">Текстовая этикетка для этого перечислительного значения</target>
        </trans-unit>
        <trans-unit id="5d79225bbaf1bc36cb45016180fd38042b31a872" translate="yes" xml:space="preserve">
          <source>The thesaurus dictionary &lt;code&gt;thesaurus_astro&lt;/code&gt; does know the phrase &lt;code&gt;supernovae stars&lt;/code&gt;, but &lt;code&gt;ts_lexize&lt;/code&gt; fails since it does not parse the input text but treats it as a single token. Use &lt;code&gt;plainto_tsquery&lt;/code&gt; or &lt;code&gt;to_tsvector&lt;/code&gt; to test thesaurus dictionaries, for example:</source>
          <target state="translated">Словарь &lt;code&gt;thesaurus_astro&lt;/code&gt; знает фразу &lt;code&gt;supernovae stars&lt;/code&gt; , но &lt;code&gt;ts_lexize&lt;/code&gt; не работает, так как он не анализирует входной текст, а обрабатывает его как отдельный токен. Используйте &lt;code&gt;plainto_tsquery&lt;/code&gt; или &lt;code&gt;to_tsvector&lt;/code&gt; для тестирования словарей тезауруса, например:</target>
        </trans-unit>
        <trans-unit id="497ebaef7c7bb30921967269b6dd4bfd06472628" translate="yes" xml:space="preserve">
          <source>The thesaurus dictionary chooses the longest match if there are multiple phrases matching the input, and ties are broken by using the last definition.</source>
          <target state="translated">Тезаурусный словарь выбирает самое длинное совпадение,если на входе совпадает несколько фраз,а связи разрываются при использовании последнего определения.</target>
        </trans-unit>
        <trans-unit id="6384b1615ea61227de680b163bce3c7f613d4849" translate="yes" xml:space="preserve">
          <source>The third form changes the owner of the database. To alter the owner, you must own the database and also be a direct or indirect member of the new owning role, and you must have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. (Note that superusers have all these privileges automatically.)</source>
          <target state="translated">Третья форма меняет владельца базы данных. Чтобы изменить владельца, вы должны владеть базой данных, а также быть прямым или косвенным членом новой роли-владельца и иметь привилегию &lt;code&gt;CREATEDB&lt;/code&gt; . (Обратите внимание, что суперпользователи получают все эти привилегии автоматически.)</target>
        </trans-unit>
        <trans-unit id="fb3a4f1cf7c17f675b6c88c65b759e2c18503d10" translate="yes" xml:space="preserve">
          <source>The third form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a new range type, as described in &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;.</source>
          <target state="translated">Третья форма &lt;code&gt;CREATE TYPE&lt;/code&gt; создает новый тип диапазона, как описано в &lt;a href=&quot;rangetypes&quot;&gt;Разделе 8.17&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46e5d7ec29a414875ddb7427a1366569e134347d" translate="yes" xml:space="preserve">
          <source>The third parameter being &lt;code&gt;false&lt;/code&gt; tells &lt;code&gt;pg_start_backup&lt;/code&gt; to initiate a non-exclusive base backup.</source>
          <target state="translated">Третий параметр, &lt;code&gt;pg_start_backup&lt;/code&gt; значение &lt;code&gt;false&lt;/code&gt; , указывает pg_start_backup инициировать неисключительное базовое резервное копирование.</target>
        </trans-unit>
        <trans-unit id="43c4f141a3275bbc30bab46035e573f420cd4242" translate="yes" xml:space="preserve">
          <source>The third syntax was used before PostgreSQL version 9.6 and is still supported. It's the same as the first syntax with &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;num_sync&lt;/code&gt; equal to 1. For example, &lt;code&gt;FIRST 1 (s1, s2)&lt;/code&gt; and &lt;code&gt;s1, s2&lt;/code&gt; have the same meaning: either &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; is chosen as a synchronous standby.</source>
          <target state="translated">Третий синтаксис использовался до PostgreSQL версии 9.6 и до сих пор поддерживается. Это то же самое, что и первый синтаксис с &lt;code&gt;FIRST&lt;/code&gt; и &lt;code&gt;num_sync&lt;/code&gt; , равным 1. Например, &lt;code&gt;FIRST 1 (s1, s2)&lt;/code&gt; и &lt;code&gt;s1, s2&lt;/code&gt; имеют одинаковое значение: либо &lt;code&gt;s1&lt;/code&gt; , либо &lt;code&gt;s2&lt;/code&gt; выбирается в качестве синхронного резервного.</target>
        </trans-unit>
        <trans-unit id="bce8828bcc021e862db732b17b8f2b754b34f3cc" translate="yes" xml:space="preserve">
          <source>The third variant changes the name of the group. This is exactly equivalent to renaming the role with &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;.</source>
          <target state="translated">Третий вариант меняет название группы. Это в точности эквивалентно переименованию роли с помощью &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2d943d4346301a5cf1de51eecfb3a352a414893" translate="yes" xml:space="preserve">
          <source>The time at which the cursor was declared</source>
          <target state="translated">Время,когда был объявлен курсор.</target>
        </trans-unit>
        <trans-unit id="ec4185f356c4ef6086071a2e178362bf4f8c1b5e" translate="yes" xml:space="preserve">
          <source>The time at which the prepared statement was created</source>
          <target state="translated">Время,когда было подготовлено заявление.</target>
        </trans-unit>
        <trans-unit id="ffd5bbf754455019459a28dd71a5db592d1e512d" translate="yes" xml:space="preserve">
          <source>The time fields in a transition rule have the same format as the offset fields described previously, except that they cannot contain signs. They define the current local time at which the change to the other time occurs. If omitted, they default to &lt;code&gt;02:00:00&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e8bb2f344559ea1d916061668ce3e9aa5b7836" translate="yes" xml:space="preserve">
          <source>The time zone 7 hours west from UTC (equivalent to PDT). Positive values are east from UTC.</source>
          <target state="translated">Часовой пояс в 7 часах езды на запад от UTC (эквивалент PDT).Положительные значения находятся к востоку от UTC.</target>
        </trans-unit>
        <trans-unit id="ee80f641d8eab20953a3190cfb6422152c737dea" translate="yes" xml:space="preserve">
          <source>The time zone 8 hours west from UTC (equivalent to PST).</source>
          <target state="translated">Часовой пояс в 8 часах езды на запад от UTC (эквивалент PST).</target>
        </trans-unit>
        <trans-unit id="3d03995667dbda87e63122260f5c6f6cb9fe649a" translate="yes" xml:space="preserve">
          <source>The time zone for Berkeley, California.</source>
          <target state="translated">Часовой пояс для Беркли,Калифорния.</target>
        </trans-unit>
        <trans-unit id="668f3cdec134bede84a934a9af41142895f7b007" translate="yes" xml:space="preserve">
          <source>The time zone for Italy.</source>
          <target state="translated">Часовой пояс для Италии.</target>
        </trans-unit>
        <trans-unit id="c7ed4ff2c6ce4f9a9cd61b96f6374cf02812e246" translate="yes" xml:space="preserve">
          <source>The time zone offset from UTC, measured in seconds. Positive values correspond to time zones east of UTC, negative values to zones west of UTC. (Technically, PostgreSQL does not use UTC because leap seconds are not handled.)</source>
          <target state="translated">Смещение часового пояса от UTC,измеренное в секундах.Положительные значения соответствуют часовым поясам к востоку от UTC,отрицательные-зонам к западу от UTC.(Технически PostgreSQL не использует UTC,так как високосные секунды не обрабатываются).</target>
        </trans-unit>
        <trans-unit id="0ca5243d8e51420e24c77cdd1c3e577fee34053c" translate="yes" xml:space="preserve">
          <source>The time-of-day types are &lt;code&gt;time [ (p) ] without time zone&lt;/code&gt; and &lt;code&gt;time [ (p) ] with time zone&lt;/code&gt;. &lt;code&gt;time&lt;/code&gt; alone is equivalent to &lt;code&gt;time without time zone&lt;/code&gt;.</source>
          <target state="translated">Типы &lt;code&gt;time [ (p) ] without time zone&lt;/code&gt; суток: время [(p)] без часового пояса и &lt;code&gt;time [ (p) ] with time zone&lt;/code&gt; . только &lt;code&gt;time&lt;/code&gt; эквивалентно &lt;code&gt;time without time zone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="404ebb0f442feebec6561a16038577c2da51bc2d" translate="yes" xml:space="preserve">
          <source>The timeline for this range of WAL records, as an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e09ea608f1f50e50cadf98aabc877a7444e25e" translate="yes" xml:space="preserve">
          <source>The timeout is measured from the time a command arrives at the server until it is completed by the server. If multiple SQL statements appear in a single simple-Query message, the timeout is applied to each statement separately. (PostgreSQL versions before 13 usually treated the timeout as applying to the whole query string.) In extended query protocol, the timeout starts running when any query-related message (Parse, Bind, Execute, Describe) arrives, and it is canceled by completion of an Execute or Sync message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41de03730261b036dd783f63ba08317d9d3e641d" translate="yes" xml:space="preserve">
          <source>The timeout is measured from the time a command arrives at the server until it is completed by the server. In extended query protocol, the timeout starts running when any query-related message (Parse, Bind, Execute, Describe) arrives, and it is cancelled by completion of an Execute or Sync message.</source>
          <target state="translated">Таймаут измеряется с момента поступления команды на сервер до ее завершения сервером.В протоколе расширенного запроса таймаут начинается с момента поступления любого сообщения,связанного с запросом (Parse,Bind,Execute,Describe),и отменяется по завершению сообщения Execute или Sync.</target>
        </trans-unit>
        <trans-unit id="1f30fb914124c09d41ba75a819d8afdbb3ea8c79" translate="yes" xml:space="preserve">
          <source>The toast_tuple_target specifies the minimum tuple length required before we try to compress and/or move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This affects columns marked as External (for move), Main (for compression), or Extended (for both) and applies only to new tuples. There is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default block size will be 2040 bytes. Valid values are between 128 bytes and the (block size - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98b14f1fa1ca6a1d2cfd5fbd83b532ce899e731" translate="yes" xml:space="preserve">
          <source>The toast_tuple_target specifies the minimum tuple length required before we try to move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This only affects columns marked as either External or Extended and applies only to new tuples - there is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default blocksize will be 2040 bytes. Valid values are between 128 bytes and the (blocksize - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">Toast_tuple_target определяет минимальную длину кортежа,необходимую для перемещения длинных значений столбцов в таблицы TOAST,а также является целью,которую мы пытаемся уменьшить длину ниже,как только начинается тост.Это касается только столбцов,помеченных как External или Extended,и применяется только к новым кортежам-это не влияет на существующие строки.По умолчанию этот параметр настроен на разрешение не менее 4 кортежей на блок,что при размере блока по умолчанию составит 2040 байт.Допустимые значения-от 128 байт до (размер блока-заголовок),по умолчанию 8160 байт.Изменение этого значения может оказаться нецелесообразным для очень коротких или очень длинных строк.Обратите внимание,что настройка по умолчанию часто близка к оптимальной,и не исключено,что настройка этого параметра в некоторых случаях может иметь негативные последствия.Этот параметр не может быть установлен для таблиц TOAST.</target>
        </trans-unit>
        <trans-unit id="621d22a0cd204d89633ad09943ee84f1181db01e" translate="yes" xml:space="preserve">
          <source>The total number of columns in the index (duplicates &lt;code&gt;pg_class.relnatts&lt;/code&gt;); this number includes both key and included attributes</source>
          <target state="translated">Общее количество столбцов в индексе (дублирует &lt;code&gt;pg_class.relnatts&lt;/code&gt; ); это число включает как ключевые, так и включенные атрибуты</target>
        </trans-unit>
        <trans-unit id="f560f36dfc9d943beeddde2257c0e1b305d7ee85" translate="yes" xml:space="preserve">
          <source>The transaction ID epoch is not actually stored anywhere in the database except in the field that is set by &lt;code&gt;pg_resetwal&lt;/code&gt;, so any value will work so far as the database itself is concerned. You might need to adjust this value to ensure that replication systems such as Slony-I and Skytools work correctly &amp;mdash; if so, an appropriate value should be obtainable from the state of the downstream replicated database.</source>
          <target state="translated">Эпоха идентификатора транзакции фактически не сохраняется нигде в базе данных, кроме поля, установленного параметром &lt;code&gt;pg_resetwal&lt;/code&gt; , поэтому любое значение будет работать, если это касается самой базы данных. Возможно, вам потребуется настроить это значение, чтобы обеспечить правильную работу систем репликации, таких как Slony-I и Skytools - если это так, соответствующее значение должно быть получено из состояния реплицируемой нижестоящей базы данных.</target>
        </trans-unit>
        <trans-unit id="5c3634c8a4a4ce9f542309bb5a4cc86011569d07" translate="yes" xml:space="preserve">
          <source>The transaction access mode determines whether the transaction is read/write or read-only. Read/write is the default. When a transaction is read-only, the following SQL commands are disallowed: &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;COPY FROM&lt;/code&gt; if the table they would write to is not a temporary table; all &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;ALTER&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; commands; &lt;code&gt;COMMENT&lt;/code&gt;, &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;; and &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; and &lt;code&gt;EXECUTE&lt;/code&gt; if the command they would execute is among those listed. This is a high-level notion of read-only that does not prevent all writes to disk.</source>
          <target state="translated">Режим доступа к транзакции определяет, является ли транзакция доступной для чтения / записи или только для чтения. Чтение / запись по умолчанию. Когда транзакция доступна только для чтения, следующие команды SQL запрещены: &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; и &lt;code&gt;COPY FROM&lt;/code&gt; , если таблица, в которую они будут записывать, не является временной таблицей; все команды &lt;code&gt;CREATE&lt;/code&gt; , &lt;code&gt;ALTER&lt;/code&gt; и &lt;code&gt;DROP&lt;/code&gt; ; &lt;code&gt;COMMENT&lt;/code&gt; , &lt;code&gt;GRANT&lt;/code&gt; , &lt;code&gt;REVOKE&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; ; и &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; и &lt;code&gt;EXECUTE&lt;/code&gt; если команда, которую они будут выполнять, входит в список. Это высокоуровневое понятие &amp;laquo;только для чтения&amp;raquo;, которое не предотвращает все записи на диск.</target>
        </trans-unit>
        <trans-unit id="75f4c782782aa478238329da73889aa36680137b" translate="yes" xml:space="preserve">
          <source>The transaction identifier of the transaction that is to be committed.</source>
          <target state="translated">Идентификатор транзакции,которая должна быть совершена.</target>
        </trans-unit>
        <trans-unit id="cf987258f7d6ba8e2728a7ab480e418085360e38" translate="yes" xml:space="preserve">
          <source>The transaction identifier of the transaction that is to be rolled back.</source>
          <target state="translated">Идентификатор транзакции,подлежащей откату.</target>
        </trans-unit>
        <trans-unit id="9eeef0c349968aef779233f9f813d33249bc7a83" translate="yes" xml:space="preserve">
          <source>The transaction isolation level cannot be changed after the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of a transaction has been executed. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">Уровень изоляции транзакции не может быть изменен после выполнения первого запроса или оператора модификации данных ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; или &lt;code&gt;COPY&lt;/code&gt; ) транзакции. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Главу 13&lt;/a&gt; для получения дополнительной информации об изоляции транзакций и управлении параллелизмом.</target>
        </trans-unit>
        <trans-unit id="7fe24188c8709c03cdec891a49204bbf4cf162d4" translate="yes" xml:space="preserve">
          <source>The transaction isolation level cannot be changed after the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of a transaction has been executed. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3fff67b302c5509e4a3c68f6d878b34bcf063e" translate="yes" xml:space="preserve">
          <source>The transactional behavior of &lt;code&gt;RESET&lt;/code&gt; is the same as &lt;code&gt;SET&lt;/code&gt;: its effects will be undone by transaction rollback.</source>
          <target state="translated">Транзакционное поведение &lt;code&gt;RESET&lt;/code&gt; такое же, как и &lt;code&gt;SET&lt;/code&gt; : его эффекты будут отменены откатом транзакции.</target>
        </trans-unit>
        <trans-unit id="bd74e2a12fdda047e415ded6637d08f54eb6f6c6" translate="yes" xml:space="preserve">
          <source>The translation of login credentials in the local &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; to credentials in a remote data system defined by a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75001c08db137e17c60a1922c998f38549cfd962" translate="yes" xml:space="preserve">
          <source>The translations from internal enum values to textual labels are kept in the system catalog &lt;a href=&quot;catalog-pg-enum&quot;&gt;&lt;code&gt;pg_enum&lt;/code&gt;&lt;/a&gt;. Querying this catalog directly can be useful.</source>
          <target state="translated">Переводы из значений внутреннего перечисления в текстовые метки хранятся в системном каталоге &lt;a href=&quot;catalog-pg-enum&quot;&gt; &lt;code&gt;pg_enum&lt;/code&gt; &lt;/a&gt; . Может быть полезным запрос напрямую к этому каталогу.</target>
        </trans-unit>
        <trans-unit id="d50a1ac1c4a79cbe553bfb51786402f941c2b3ba" translate="yes" xml:space="preserve">
          <source>The trigger can be specified to fire before the operation is attempted on a row (before constraints are checked and the &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; is attempted); or after the operation has completed (after constraints are checked and the &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; has completed); or instead of the operation (in the case of inserts, updates or deletes on a view). If the trigger fires before or instead of the event, the trigger can skip the operation for the current row, or change the row being inserted (for &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; operations only). If the trigger fires after the event, all changes, including the effects of other triggers, are &amp;ldquo;visible&amp;rdquo; to the trigger.</source>
          <target state="translated">Можно указать триггер для срабатывания перед попыткой выполнения операции над строкой (перед проверкой ограничений и попыткой выполнения &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; ); или после завершения операции (после проверки ограничений и выполнения &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; ); или вместо операции (в случае вставки, обновления или удаления в представлении). Если триггер срабатывает до или вместо события, триггер может пропустить операцию для текущей строки или изменить вставляемую строку (для &lt;code&gt;INSERT&lt;/code&gt; и &lt;code&gt;UPDATE&lt;/code&gt; только операции). Если триггер срабатывает после события, все изменения, включая эффекты других триггеров, &amp;laquo;видны&amp;raquo; триггеру.</target>
        </trans-unit>
        <trans-unit id="360ddad9a8de88b17738a1bfb31175dc0ad50509" translate="yes" xml:space="preserve">
          <source>The trigger definition is the same as before. Note that each &lt;code&gt;IF&lt;/code&gt; test must exactly match the &lt;code&gt;CHECK&lt;/code&gt; constraint for its child table.</source>
          <target state="translated">Определение триггера такое же, как и раньше. Обратите внимание, что каждый тест &lt;code&gt;IF&lt;/code&gt; должен точно соответствовать ограничению &lt;code&gt;CHECK&lt;/code&gt; для своей дочерней таблицы.</target>
        </trans-unit>
        <trans-unit id="a810fcfc0902003d265053e230960c8ff8fc873c" translate="yes" xml:space="preserve">
          <source>The trigger firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;. Simply enabled triggers (the default) will fire when the replication role is &amp;ldquo;origin&amp;rdquo; (the default) or &amp;ldquo;local&amp;rdquo;. Triggers configured as &lt;code&gt;ENABLE REPLICA&lt;/code&gt; will only fire if the session is in &amp;ldquo;replica&amp;rdquo; mode, and triggers configured as &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; will fire regardless of the current replication role.</source>
          <target state="translated">На механизм срабатывания триггера также влияет конфигурационная переменная &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt; . Просто включенные триггеры (по умолчанию) срабатывают, когда роль репликации - &amp;laquo;источник&amp;raquo; (по умолчанию) или &amp;laquo;локальная&amp;raquo;. Триггеры, настроенные как &lt;code&gt;ENABLE REPLICA&lt;/code&gt; , будут срабатывать только в том случае, если сеанс находится в режиме &amp;laquo;реплика&amp;raquo;, а триггеры, настроенные как &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; , будут срабатывать независимо от текущей роли репликации.</target>
        </trans-unit>
        <trans-unit id="4f53bb9473c53f31ec2630d134ac2ab3b419880a" translate="yes" xml:space="preserve">
          <source>The trigger will only fire if at least one of the listed columns is mentioned as a target of the &lt;code&gt;UPDATE&lt;/code&gt; command or if one of the listed columns is a generated column that depends on a column that is the target of the &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">Триггер сработает только в том случае, если хотя бы один из перечисленных столбцов указан в качестве цели команды &lt;code&gt;UPDATE&lt;/code&gt; или если один из перечисленных столбцов является сгенерированным столбцом, который зависит от столбца, являющегося целью &lt;code&gt;UPDATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9812ac32136a445e04fcdb0d1e4cacff3be7be9" translate="yes" xml:space="preserve">
          <source>The two arguments must be of comparable types. To be specific, they are compared exactly as if you had written &lt;code&gt;value1 = value2&lt;/code&gt;, so there must be a suitable &lt;code&gt;=&lt;/code&gt; operator available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33dc8fc66a104f662e1e1ef39564cf253e0b3d0e" translate="yes" xml:space="preserve">
          <source>The two characters must be separated by whitespace, and any leading or trailing whitespace on a line is ignored.</source>
          <target state="translated">Эти два символа должны быть разделены пробелами,и любой ведущий или завершающий пробельный символ в строке игнорируется.</target>
        </trans-unit>
        <trans-unit id="76e9af5cad39e06c0aff7fc7950d58905fea1d7b" translate="yes" xml:space="preserve">
          <source>The two common uses of the &lt;code&gt;COLLATE&lt;/code&gt; clause are overriding the sort order in an &lt;code&gt;ORDER BY&lt;/code&gt; clause, for example:</source>
          <target state="translated">Два распространенных использования предложения &lt;code&gt;COLLATE&lt;/code&gt; - это переопределение порядка сортировки в предложении &lt;code&gt;ORDER BY&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="35a38d5de3cd4f9280a434f729b41435ab278e27" translate="yes" xml:space="preserve">
          <source>The two ranking functions currently available are:</source>
          <target state="translated">В настоящее время доступны две функции ранжирования:</target>
        </trans-unit>
        <trans-unit id="ce8dc1c8a536536645752666f7fffe721ce60a13" translate="yes" xml:space="preserve">
          <source>The two-parameter form of &lt;code&gt;obj_description&lt;/code&gt; returns the comment for a database object specified by its OID and the name of the containing system catalog. For example, &lt;code&gt;obj_description(123456,'pg_class')&lt;/code&gt; would retrieve the comment for the table with OID 123456. The one-parameter form of &lt;code&gt;obj_description&lt;/code&gt; requires only the object OID. It is deprecated since there is no guarantee that OIDs are unique across different system catalogs; therefore, the wrong comment might be returned.</source>
          <target state="translated">&lt;code&gt;obj_description&lt;/code&gt; форма obj_description возвращает комментарий для объекта базы данных, заданный его OID и именем содержащего системного каталога. Например, &lt;code&gt;obj_description(123456,'pg_class')&lt;/code&gt; получит комментарий для таблицы с OID 123456. Однопараметрическая форма &lt;code&gt;obj_description&lt;/code&gt; требует только OID объекта. Он устарел, поскольку нет гарантии, что OID уникальны в разных системных каталогах; следовательно, может быть возвращен неправильный комментарий.</target>
        </trans-unit>
        <trans-unit id="b4f339ae3cabb76936eb748863a60863a4f4f72e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;integer&lt;/code&gt; is the common choice, as it offers the best balance between range, storage size, and performance. The &lt;code&gt;smallint&lt;/code&gt; type is generally only used if disk space is at a premium. The &lt;code&gt;bigint&lt;/code&gt; type is designed to be used when the range of the &lt;code&gt;integer&lt;/code&gt; type is insufficient.</source>
          <target state="translated">Тип &lt;code&gt;integer&lt;/code&gt; является обычным выбором, так как он предлагает лучший баланс между диапазоном, размером хранилища и производительностью. Тип &lt;code&gt;smallint&lt;/code&gt; обычно используется только в том случае, если дисковое пространство ограничено. Тип &lt;code&gt;bigint&lt;/code&gt; предназначен для использования, когда диапазон &lt;code&gt;integer&lt;/code&gt; типа недостаточен.</target>
        </trans-unit>
        <trans-unit id="73f1593ff9d450e1b3a9d9ecf07b14639511ab2d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;numeric&lt;/code&gt; can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with &lt;code&gt;numeric&lt;/code&gt; values yield exact results where possible, e.g. addition, subtraction, multiplication. However, calculations on &lt;code&gt;numeric&lt;/code&gt; values are very slow compared to the integer types, or to the floating-point types described in the next section.</source>
          <target state="translated">Тип &lt;code&gt;numeric&lt;/code&gt; может хранить числа с очень большим количеством цифр. Особенно рекомендуется для хранения денежных сумм и других величин, где требуется точность. Вычисления с &lt;code&gt;numeric&lt;/code&gt; значениями по возможности дают точные результаты, например, сложение, вычитание, умножение. Однако вычисления &lt;code&gt;numeric&lt;/code&gt; значений очень медленны по сравнению с целочисленными типами или типами с плавающей запятой, описанными в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="d8ef95808394eeedcc4e8f80e7ae1d4796c0832d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;numeric&lt;/code&gt; can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with &lt;code&gt;numeric&lt;/code&gt; values yield exact results where possible, e.g., addition, subtraction, multiplication. However, calculations on &lt;code&gt;numeric&lt;/code&gt; values are very slow compared to the integer types, or to the floating-point types described in the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793233ae84eec2944804278e0981414a3f21b17d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;time with time zone&lt;/code&gt; is defined by the SQL standard, but the definition exhibits properties which lead to questionable usefulness. In most cases, a combination of &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, and &lt;code&gt;timestamp with time zone&lt;/code&gt; should provide a complete range of date/time functionality required by any application.</source>
          <target state="translated">Тип &lt;code&gt;time with time zone&lt;/code&gt; определяется стандартом SQL, но определение демонстрирует свойства, которые приводят к сомнительной полезности. В большинстве случаев комбинация &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;timestamp without time zone&lt;/code&gt; и &lt;code&gt;timestamp with time zone&lt;/code&gt; должна обеспечивать полный диапазон функций даты и времени, необходимых для любого приложения.</target>
        </trans-unit>
        <trans-unit id="a7b02ae1d94b05c4445fedeab1d5ea2204949c69" translate="yes" xml:space="preserve">
          <source>The type being created is an array; this specifies the type of the array elements.</source>
          <target state="translated">Создаваемый тип-это массив,который задает тип элементов массива.</target>
        </trans-unit>
        <trans-unit id="dec7ae5dcf41bac97c38ef83c552012b75a666d1" translate="yes" xml:space="preserve">
          <source>The type names &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;serial4&lt;/code&gt; are equivalent: both create &lt;code&gt;integer&lt;/code&gt; columns. The type names &lt;code&gt;bigserial&lt;/code&gt; and &lt;code&gt;serial8&lt;/code&gt; work the same way, except that they create a &lt;code&gt;bigint&lt;/code&gt; column. &lt;code&gt;bigserial&lt;/code&gt; should be used if you anticipate the use of more than 2&lt;sup&gt;31&lt;/sup&gt; identifiers over the lifetime of the table. The type names &lt;code&gt;smallserial&lt;/code&gt; and &lt;code&gt;serial2&lt;/code&gt; also work the same way, except that they create a &lt;code&gt;smallint&lt;/code&gt; column.</source>
          <target state="translated">Имена типов &lt;code&gt;serial&lt;/code&gt; и &lt;code&gt;serial4&lt;/code&gt; эквивалентны: оба создают &lt;code&gt;integer&lt;/code&gt; столбцы. Имена типов &lt;code&gt;bigserial&lt;/code&gt; и &lt;code&gt;serial8&lt;/code&gt; работают одинаково, за исключением того, что они создают столбец &lt;code&gt;bigint&lt;/code&gt; . &lt;code&gt;bigserial&lt;/code&gt; следует использовать, если вы ожидаете использования более 2 &lt;sup&gt;31&lt;/sup&gt; идентификаторов за время существования таблицы. Имена типов &lt;code&gt;smallserial&lt;/code&gt; и &lt;code&gt;serial2&lt;/code&gt; также работают одинаково, за исключением того, что они создают столбец &lt;code&gt;smallint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe751081daba63125cfc111c4d7f7c5219b07dce" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;.</source>
          <target state="translated">Тип столбца указывается записью &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ea7f76717a65c02b1bddcb00950b7e9f4876d9" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;. Using this feature can sometimes help make a function independent of changes to the definition of a table.</source>
          <target state="translated">Тип столбца указывается записью &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; . Использование этой функции может иногда помочь сделать функцию независимой от изменений в определении таблицы.</target>
        </trans-unit>
        <trans-unit id="b1ec982d03e7790491fadba1642490dfd8fdc55a" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;. Using this feature can sometimes help make a procedure independent of changes to the definition of a table.</source>
          <target state="translated">Тип столбца указывается записью &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; . Использование этой функции может иногда помочь сделать процедуру независимой от изменений в определении таблицы.</target>
        </trans-unit>
        <trans-unit id="f1e103307ad05526fdabd013a4e01ed05bfdbdb7" translate="yes" xml:space="preserve">
          <source>The type of event for which the backend is waiting, if any; otherwise NULL. Possible values are:</source>
          <target state="translated">Тип события,которого ждет бэкэнд,если таковой имеется;в противном случае NULL.Возможные значения:</target>
        </trans-unit>
        <trans-unit id="a8d405d6c92bbb1fd074ac96c8d3effed9604172" translate="yes" xml:space="preserve">
          <source>The type of event for which the backend is waiting, if any; otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9f096a38b6430fd5ddb4a740ecb24f54b601d1" translate="yes" xml:space="preserve">
          <source>The type of format conversion to use to produce the format specifier's output. The following types are supported:</source>
          <target state="translated">Тип преобразования формата,используемый для вывода спецификатора формата.Поддерживаются следующие типы:</target>
        </trans-unit>
        <trans-unit id="1ddd9e551f2a05479f6513f5110e44168eae5ec3" translate="yes" xml:space="preserve">
          <source>The type of object to which this label applies, as text.</source>
          <target state="translated">Тип объекта,к которому применяется эта метка,в виде текста.</target>
        </trans-unit>
        <trans-unit id="e0efbb84b508511a8c55e93462baf31f477709c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;decimal&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; are equivalent. Both types are part of the SQL standard.</source>
          <target state="translated">&lt;code&gt;decimal&lt;/code&gt; и &lt;code&gt;numeric&lt;/code&gt; типы эквивалентны. Оба типа являются частью стандарта SQL.</target>
        </trans-unit>
        <trans-unit id="929117e51025410290ad9a3ec11af66ca11a1c9b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; store whole numbers, that is, numbers without fractional components, of various ranges. Attempts to store values outside of the allowed range will result in an error.</source>
          <target state="translated">Типы &lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; и &lt;code&gt;bigint&lt;/code&gt; хранят целые числа, то есть числа без дробных компонентов, различных диапазонов. Попытки сохранить значения за пределами допустимого диапазона приведут к ошибке.</target>
        </trans-unit>
        <trans-unit id="f88d1600c2fa8cf210ddde6767edf800fcc4b8ae" translate="yes" xml:space="preserve">
          <source>The unallocated space. New item identifiers are allocated from the start of this area, new items from the end.</source>
          <target state="translated">Нераспределенное пространство.Новые идентификаторы элементов выделяются с начала этой области,новые элементы-с конца.</target>
        </trans-unit>
        <trans-unit id="c6ac986319e3f5efca56837ce99d1572cef0217f" translate="yes" xml:space="preserve">
          <source>The underlying data type of the domain. This can include array specifiers.</source>
          <target state="translated">Тип данных,лежащий в основе домена.Сюда могут входить спецификаторы массива.</target>
        </trans-unit>
        <trans-unit id="b1d964b1947580871a9afde80dd70168c2a16dc4" translate="yes" xml:space="preserve">
          <source>The union and difference operators will fail if the resulting range would need to contain two disjoint sub-ranges, as such a range cannot be represented.</source>
          <target state="translated">Соединительный и дифференциальный операторы не будут работать,если в результирующем диапазоне потребуется два разобщенных поддиапазона,так как такой диапазон не может быть представлен.</target>
        </trans-unit>
        <trans-unit id="50b30c7a19cffa1de56e373435e89e8ef50ced95" translate="yes" xml:space="preserve">
          <source>The units kB, MB, GB and TB used by the functions &lt;code&gt;pg_size_pretty&lt;/code&gt; and &lt;code&gt;pg_size_bytes&lt;/code&gt; are defined using powers of 2 rather than powers of 10, so 1kB is 1024 bytes, 1MB is 1024&lt;sup&gt;2&lt;/sup&gt; = 1048576 bytes, and so on.</source>
          <target state="translated">Единицы измерения кБ, МБ, ГБ и ТБ, используемые функциями &lt;code&gt;pg_size_pretty&lt;/code&gt; и &lt;code&gt;pg_size_bytes&lt;/code&gt; , определяются с использованием степени 2, а не степени 10, поэтому 1 КБ равен 1024 байтам, 1 МБ равен 1024, &lt;sup&gt;2&lt;/sup&gt; = 1048576 байтам и т. Д.</target>
        </trans-unit>
        <trans-unit id="e4ae2c5b2eeaa2e69e79b5cb262b5458e41e3c91" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; as an operator name is deprecated. It may be disallowed altogether in a future release.</source>
          <target state="translated">Использование &lt;code&gt;=&amp;gt;&lt;/code&gt; в качестве имени оператора не рекомендуется. В будущих версиях это может быть запрещено.</target>
        </trans-unit>
        <trans-unit id="5abb8578ec77c7960afe6e04fbf989b69b52b5fe" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;AND&lt;/code&gt; in the &lt;code&gt;BETWEEN&lt;/code&gt; syntax creates an ambiguity with the use of &lt;code&gt;AND&lt;/code&gt; as a logical operator. To resolve this, only a limited set of expression types are allowed as the second argument of a &lt;code&gt;BETWEEN&lt;/code&gt; clause. If you need to write a more complex sub-expression in &lt;code&gt;BETWEEN&lt;/code&gt;, write parentheses around the sub-expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c091c993d1f380ee067cec46b15b6ee688b73b" translate="yes" xml:space="preserve">
          <source>The use of explicit locking can increase the likelihood of &lt;em&gt;deadlocks&lt;/em&gt;, wherein two (or more) transactions each hold locks that the other wants. For example, if transaction 1 acquires an exclusive lock on table A and then tries to acquire an exclusive lock on table B, while transaction 2 has already exclusive-locked table B and now wants an exclusive lock on table A, then neither one can proceed. PostgreSQL automatically detects deadlock situations and resolves them by aborting one of the transactions involved, allowing the other(s) to complete. (Exactly which transaction will be aborted is difficult to predict and should not be relied upon.)</source>
          <target state="translated">Использование явной блокировки может увеличить вероятность возникновения &lt;em&gt;взаимоблокировок&lt;/em&gt; , когда каждая из двух (или более) транзакций удерживает блокировки, которые требуются другой. Например, если транзакция 1 получает эксклюзивную блокировку для таблицы A, а затем пытается получить эксклюзивную блокировку для таблицы B, в то время как транзакция 2 уже имеет эксклюзивную блокировку таблицы B и теперь хочет эксклюзивную блокировку для таблицы A, тогда ни один из них не может продолжить . PostgreSQL автоматически обнаруживает тупиковые ситуации и разрешает их, прерывая одну из задействованных транзакций, позволяя завершить другие. (Трудно предсказать, какая именно транзакция будет прервана, и на нее не следует полагаться.)</target>
        </trans-unit>
        <trans-unit id="8f0b3f4b5acb7da25097931a18b8f5ac621923d3" translate="yes" xml:space="preserve">
          <source>The use of huge pages results in smaller page tables and less CPU time spent on memory management, increasing performance. For more details about using huge pages on Linux, see &lt;a href=&quot;kernel-resources#LINUX-HUGE-PAGES&quot;&gt;Section 18.4.5&lt;/a&gt;.</source>
          <target state="translated">Использование огромных страниц приводит к меньшему размеру таблиц страниц и меньшему количеству процессорного времени, затрачиваемого на управление памятью, что увеличивает производительность. Для получения дополнительных сведений об использовании огромных страниц в Linux см. &lt;a href=&quot;kernel-resources#LINUX-HUGE-PAGES&quot;&gt;Раздел 18.4.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ce63f397bb5d8284bad24ef82b2459f7b090249" translate="yes" xml:space="preserve">
          <source>The use of this option is obsolete; all command-line options for server processes can be specified directly on the &lt;code&gt;postgres&lt;/code&gt; command line.</source>
          <target state="translated">Использование этой опции устарело; все параметры командной строки для серверных процессов можно указать непосредственно в командной строке &lt;code&gt;postgres&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09cf7166a8b226caae95159176b66ea236b91cf0" translate="yes" xml:space="preserve">
          <source>The user can select the commit mode of each transaction, so that it is possible to have both synchronous and asynchronous commit transactions running concurrently. This allows flexible trade-offs between performance and certainty of transaction durability. The commit mode is controlled by the user-settable parameter &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;, which can be changed in any of the ways that a configuration parameter can be set. The mode used for any one transaction depends on the value of &lt;code&gt;synchronous_commit&lt;/code&gt; when transaction commit begins.</source>
          <target state="translated">Пользователь может выбрать режим фиксации каждой транзакции, чтобы можно было одновременно выполнять синхронные и асинхронные транзакции фиксации. Это позволяет гибко выбирать между производительностью и надежностью транзакции. Режим фиксации управляется настраиваемым пользователем параметром &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; , который можно изменить любым из способов, которыми может быть установлен параметр конфигурации. Режим, используемый для любой транзакции, зависит от значения &lt;code&gt;synchronous_commit&lt;/code&gt; , когда начинается фиксация транзакции.</target>
        </trans-unit>
        <trans-unit id="58fdb850f0b7e6f4f12d81d3a2ab809c8e564bba" translate="yes" xml:space="preserve">
          <source>The user must have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the procedure in order to be allowed to invoke it.</source>
          <target state="translated">У пользователя должна быть привилегия &lt;code&gt;EXECUTE&lt;/code&gt; для процедуры, чтобы иметь возможность ее вызывать.</target>
        </trans-unit>
        <trans-unit id="c74ba756422b33951733fa9726163bde6e9f1367" translate="yes" xml:space="preserve">
          <source>The user must have &lt;code&gt;USAGE&lt;/code&gt; privilege for the procedural language, or must be a superuser if the language is untrusted. This is the same privilege requirement as for creating a function in the language.</source>
          <target state="translated">Пользователь должен иметь привилегию &lt;code&gt;USAGE&lt;/code&gt; для процедурного языка или должен быть суперпользователем, если язык не является доверенным. Это те же привилегии, что и для создания функции на языке.</target>
        </trans-unit>
        <trans-unit id="7355b734bfbb693399b1f5be80a21fc683a4208f" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the domain.</source>
          <target state="translated">Имя пользователя нового владельца домена.</target>
        </trans-unit>
        <trans-unit id="5b67af9ba18fb81e51e55c777748aa943b2fa8e5" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the event trigger.</source>
          <target state="translated">Имя пользователя нового владельца триггера события.</target>
        </trans-unit>
        <trans-unit id="aba5a7708c66551701c5165cf7ba963ffe31406d" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the foreign server.</source>
          <target state="translated">Имя пользователя нового владельца иностранного сервера.</target>
        </trans-unit>
        <trans-unit id="e794753392792d29db630aab48374584b0d3cb46" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the foreign-data wrapper.</source>
          <target state="translated">Имя пользователя нового владельца обертки иностранных данных.</target>
        </trans-unit>
        <trans-unit id="9764aeef0fe4bb5d4f2272e77d6962230b353685" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the materialized view.</source>
          <target state="translated">Имя пользователя нового владельца материализованного вида.</target>
        </trans-unit>
        <trans-unit id="2b0e8f2639c9d0e1c0e8fa04963b62d2820b7705" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the publication.</source>
          <target state="translated">Имя пользователя нового владельца публикации.</target>
        </trans-unit>
        <trans-unit id="2288b9ac65364d46e00039d4c94aae751493c3c0" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the sequence.</source>
          <target state="translated">Имя пользователя нового владельца последовательности.</target>
        </trans-unit>
        <trans-unit id="d54654fb52ccc22d099e9d7662a28009ae6c974d" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the statistics object.</source>
          <target state="translated">Имя пользователя нового владельца объекта статистики.</target>
        </trans-unit>
        <trans-unit id="c69e3a3d77712ec7eadabb2257570bc879c31fe4" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the subscription.</source>
          <target state="translated">Имя пользователя нового владельца подписки.</target>
        </trans-unit>
        <trans-unit id="6566e54be9aa4e4a755e403ba928be2a78bd2f0e" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the table.</source>
          <target state="translated">Имя пользователя нового владельца таблицы.</target>
        </trans-unit>
        <trans-unit id="5465925abc46b022486e34924312d36ae3fb4555" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the type.</source>
          <target state="translated">Имя пользователя нового владельца типа.</target>
        </trans-unit>
        <trans-unit id="a6eb245257eeab851862782e2a923bbc7e47c8d6" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the view.</source>
          <target state="translated">Имя пользователя нового владельца вида.</target>
        </trans-unit>
        <trans-unit id="ead32115822b14f6c36ec30a49fc2050b45d7ff6" translate="yes" xml:space="preserve">
          <source>The user name to connect as</source>
          <target state="translated">Имя пользователя для подключения как</target>
        </trans-unit>
        <trans-unit id="e907b500844d993a9893eddde6a23ad8e157309f" translate="yes" xml:space="preserve">
          <source>The user performing the lock on the view must have the corresponding privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the lock does not need any permissions on the underlying base relations.</source>
          <target state="translated">Пользователь,выполняющий блокировку представления,должен иметь соответствующую привилегию на представление.Кроме того,владелец представления должен иметь соответствующие привилегии на базовые отношения,но пользователь,выполняющий блокировку на представлении,не нуждается в каких-либо разрешениях на базовые отношения.</target>
        </trans-unit>
        <trans-unit id="7bfd48e694dd153c1235989f4fbd645fdacfec80" translate="yes" xml:space="preserve">
          <source>The user that creates the function becomes the owner of the function.</source>
          <target state="translated">Пользователь,который создает функцию,становится ее владельцем.</target>
        </trans-unit>
        <trans-unit id="96430e1e5477d00f6c76c64e1c8233d8001617e1" translate="yes" xml:space="preserve">
          <source>The user that creates the procedure becomes the owner of the procedure.</source>
          <target state="translated">Пользователь,который создает процедуру,становится ее владельцем.</target>
        </trans-unit>
        <trans-unit id="fa24870d0f9c850e93790c8855a7b4579bd41481" translate="yes" xml:space="preserve">
          <source>The user who defines a text search configuration becomes its owner.</source>
          <target state="translated">Пользователь,определяющий конфигурацию текстового поиска,становится его владельцем.</target>
        </trans-unit>
        <trans-unit id="f6d4088ee84ecfa3f7d22aab37f998c942ea2998" translate="yes" xml:space="preserve">
          <source>The user who defines a text search dictionary becomes its owner.</source>
          <target state="translated">Пользователь,определяющий текстовый поисковый словарь,становится его владельцем.</target>
        </trans-unit>
        <trans-unit id="ba174285d0ec0c6de6eab2554bacc234f431f1f5" translate="yes" xml:space="preserve">
          <source>The user who defines an operator class becomes its owner. Presently, the creating user must be a superuser. (This restriction is made because an erroneous operator class definition could confuse or even crash the server.)</source>
          <target state="translated">Пользователь,определяющий класс оператора,становится его владельцем.В настоящее время создающий пользователь должен быть суперпользователем.(Это ограничение сделано потому,что ошибочное определение класса оператора может сбить с толку или даже привести к аварийному завершению работы сервера).</target>
        </trans-unit>
        <trans-unit id="fbdfed285f07a1cecc02c081ebab06c65c95b2f7" translate="yes" xml:space="preserve">
          <source>The user who defines an operator family becomes its owner. Presently, the creating user must be a superuser. (This restriction is made because an erroneous operator family definition could confuse or even crash the server.)</source>
          <target state="translated">Пользователь,определяющий семейство операторов,становится его владельцем.В настоящее время создающий пользователь должен быть суперпользователем.(Это ограничение сделано потому,что ошибочное определение семейства операторов может сбить с толку или даже привести к аварийному завершению работы сервера).</target>
        </trans-unit>
        <trans-unit id="a72f845d3a0a4dd8ce3bae5ed1b2a783fa9c859b" translate="yes" xml:space="preserve">
          <source>The user who runs &lt;code&gt;CREATE EXTENSION&lt;/code&gt; becomes the owner of the extension for purposes of later privilege checks, and normally also becomes the owner of any objects created by the extension's script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49e64af112af0fce66c24196c6a87dd37d8a41a" translate="yes" xml:space="preserve">
          <source>The user's client (frontend) application that wants to perform database operations. Client applications can be very diverse in nature: a client could be a text-oriented tool, a graphical application, a web server that accesses the database to display web pages, or a specialized database maintenance tool. Some client applications are supplied with the PostgreSQL distribution; most are developed by users.</source>
          <target state="translated">Клиентское (front-end)приложение пользователя,которое хочет выполнять операции с базой данных.Клиентские приложения могут быть очень разнообразными по своей природе:клиент может быть текстовым инструментом,графическим приложением,веб-сервером,который получает доступ к базе данных для отображения веб-страниц,или специализированным инструментом для обслуживания базы данных.Некоторые клиентские приложения поставляются с дистрибутивом PostgreSQL;большинство из них разрабатывается пользователями.</target>
        </trans-unit>
        <trans-unit id="4b80e8348cd40d70e9a3578f00476d222916ac1c" translate="yes" xml:space="preserve">
          <source>The user's personal startup file is named &lt;code&gt;.psqlrc&lt;/code&gt; and is sought in the invoking user's home directory. On Windows, which lacks such a concept, the personal startup file is named &lt;code&gt;%APPDATA%\postgresql\psqlrc.conf&lt;/code&gt;. The location of the user's startup file can be set explicitly via the &lt;code&gt;PSQLRC&lt;/code&gt; environment variable.</source>
          <target state="translated">Личный файл запуска пользователя называется &lt;code&gt;.psqlrc&lt;/code&gt; и ищется в домашнем каталоге вызывающего пользователя. В Windows, в которой отсутствует такая концепция, личный файл запуска называется &lt;code&gt;%APPDATA%\postgresql\psqlrc.conf&lt;/code&gt; . Расположение файла запуска пользователя можно указать явно с помощью переменной среды &lt;code&gt;PSQLRC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3920cf489a63459b72dde1b92f7b717a8e6b52fd" translate="yes" xml:space="preserve">
          <source>The user, database, and (client) host items remain the same for the life of the client connection, but the activity indicator changes. The activity can be &lt;code&gt;idle&lt;/code&gt; (i.e., waiting for a client command), &lt;code&gt;idle in transaction&lt;/code&gt; (waiting for client inside a &lt;code&gt;BEGIN&lt;/code&gt; block), or a command type name such as &lt;code&gt;SELECT&lt;/code&gt;. Also, &lt;code&gt;waiting&lt;/code&gt; is appended if the server process is presently waiting on a lock held by another session. In the above example we can infer that process 15606 is waiting for process 15610 to complete its transaction and thereby release some lock. (Process 15610 must be the blocker, because there is no other active session. In more complicated cases it would be necessary to look into the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view to determine who is blocking whom.)</source>
          <target state="translated">Элементы хоста пользователя, базы данных и (клиента) остаются неизменными в течение всего срока действия клиентского соединения, но индикатор активности изменяется. Действие может быть &lt;code&gt;idle&lt;/code&gt; (то есть ожиданием команды клиента), &lt;code&gt;idle in transaction&lt;/code&gt; (ожиданием клиента внутри блока &lt;code&gt;BEGIN&lt;/code&gt; ) или именем типа команды, таким как &lt;code&gt;SELECT&lt;/code&gt; . Кроме того, &lt;code&gt;waiting&lt;/code&gt; добавляется, если серверный процесс в настоящее время ожидает блокировки, удерживаемой другим сеансом. В приведенном выше примере мы можем сделать вывод, что процесс 15606 ожидает, пока процесс 15610 завершит свою транзакцию и тем самым освободит некоторую блокировку. (Процесс 15610 должен быть блокирующим, потому что нет другого активного сеанса. В более сложных случаях необходимо изучить &lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt; системное представление, чтобы определить, кто кого блокирует.)</target>
        </trans-unit>
        <trans-unit id="13392321669f2c3fc39fecf0f89fb41cca2076a4" translate="yes" xml:space="preserve">
          <source>The usual comparison operators are available, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt;.</source>
          <target state="translated">Доступны обычные операторы сравнения, как показано в &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Таблице 9.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06a88b4eddcbb8d26f5f678e56a78a9bd14190d1" translate="yes" xml:space="preserve">
          <source>The usual goal of routine vacuuming is to do standard &lt;code&gt;VACUUM&lt;/code&gt;s often enough to avoid needing &lt;code&gt;VACUUM FULL&lt;/code&gt;. The autovacuum daemon attempts to work this way, and in fact will never issue &lt;code&gt;VACUUM FULL&lt;/code&gt;. In this approach, the idea is not to keep tables at their minimum size, but to maintain steady-state usage of disk space: each table occupies space equivalent to its minimum size plus however much space gets used up between vacuumings. Although &lt;code&gt;VACUUM FULL&lt;/code&gt; can be used to shrink a table back to its minimum size and return the disk space to the operating system, there is not much point in this if the table will just grow again in the future. Thus, moderately-frequent standard &lt;code&gt;VACUUM&lt;/code&gt; runs are a better approach than infrequent &lt;code&gt;VACUUM FULL&lt;/code&gt; runs for maintaining heavily-updated tables.</source>
          <target state="translated">Обычная цель рутинной чистки пылесосом - выполнять стандартные процедуры &lt;code&gt;VACUUM&lt;/code&gt; достаточно часто, чтобы избежать необходимости &lt;code&gt;VACUUM FULL&lt;/code&gt; . Демон автоочистки пытается работать таким образом и фактически никогда не выдаст &lt;code&gt;VACUUM FULL&lt;/code&gt; . В этом подходе идея состоит не в том, чтобы поддерживать минимальный размер таблиц, а в том, чтобы поддерживать постоянное использование дискового пространства: каждая таблица занимает пространство, эквивалентное ее минимальному размеру, плюс сколько бы места не использовалось между чистками. Хотя &lt;code&gt;VACUUM FULL&lt;/code&gt; можно использовать для сжатия таблицы до ее минимального размера и возврата дискового пространства операционной системе, в этом нет особого смысла, если таблица просто снова вырастет в будущем. Таким образом, среднечастотный стандартный &lt;code&gt;VACUUM&lt;/code&gt; прогоны - лучший подход, чем нечастые прогоны &lt;code&gt;VACUUM FULL&lt;/code&gt; для поддержки сильно обновляемых таблиц.</target>
        </trans-unit>
        <trans-unit id="8705eeb4c73510ec550152d0313d6eeffdb4ff7a" translate="yes" xml:space="preserve">
          <source>The usual interpretation of the &lt;code&gt;amproclefttype&lt;/code&gt; and &lt;code&gt;amprocrighttype&lt;/code&gt; fields is that they identify the left and right input types of the operator(s) that a particular support function supports. For some access methods these match the input data type(s) of the support function itself, for others not. There is a notion of &amp;ldquo;default&amp;rdquo; support functions for an index, which are those with &lt;code&gt;amproclefttype&lt;/code&gt; and &lt;code&gt;amprocrighttype&lt;/code&gt; both equal to the index operator class's &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="translated">Обычная интерпретация полей &lt;code&gt;amproclefttype&lt;/code&gt; и &lt;code&gt;amprocrighttype&lt;/code&gt; заключается в том, что они идентифицируют левый и правый типы ввода оператора (ов), которые поддерживает конкретная функция поддержки. Для некоторых методов доступа они соответствуют типу (ам) входных данных самой функции поддержки, для других - нет. Существует понятие &amp;laquo;стандартных&amp;raquo; функций поддержки для индекса, которые имеют значения &lt;code&gt;amproclefttype&lt;/code&gt; и &lt;code&gt;amprocrighttype&lt;/code&gt; , которые равны &lt;code&gt;opcintype&lt;/code&gt; класса операторов индекса .</target>
        </trans-unit>
        <trans-unit id="675415fe7638319c8a05abc3d9aab113c5086abb" translate="yes" xml:space="preserve">
          <source>The usual logical operators are available:</source>
          <target state="translated">Доступны обычные логические операторы:</target>
        </trans-unit>
        <trans-unit id="410b768bdab1d606d84345d16fb594b86774dec4" translate="yes" xml:space="preserve">
          <source>The utility command &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; can be used to start and shut down the &lt;code&gt;postgres&lt;/code&gt; server safely and comfortably.</source>
          <target state="translated">&lt;a href=&quot;app-pg-ctl&quot;&gt;Команду&lt;/a&gt; утилиты pg_ctl можно использовать для безопасного и удобного запуска и выключения сервера &lt;code&gt;postgres&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="914a00521ee94634aa555f79070e426ade88941f" translate="yes" xml:space="preserve">
          <source>The value can range from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;10000000000&lt;/code&gt;. When &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, index scans are never skipped during &lt;code&gt;VACUUM&lt;/code&gt; cleanup. The default value is &lt;code&gt;0.1&lt;/code&gt;.</source>
          <target state="translated">Значение может &lt;code&gt;10000000000&lt;/code&gt; диапазоне от &lt;code&gt;0&lt;/code&gt; до 10000000000 . Если для параметра &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; установлено значение &lt;code&gt;0&lt;/code&gt; , сканирование индекса никогда не пропускается во время очистки &lt;code&gt;VACUUM&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;0.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82bae1585ba067ff6aabd9ec822fffc256ffef0f" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;dynamic_library_path&lt;/code&gt; must be a list of absolute directory paths separated by colons (or semi-colons on Windows). If a list element starts with the special string &lt;code&gt;$libdir&lt;/code&gt;, the compiled-in PostgreSQL package library directory is substituted for &lt;code&gt;$libdir&lt;/code&gt;; this is where the modules provided by the standard PostgreSQL distribution are installed. (Use &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; to find out the name of this directory.) For example:</source>
          <target state="translated">Значение &lt;code&gt;dynamic_library_path&lt;/code&gt; должно быть списком абсолютных путей к каталогам, разделенных двоеточием (или точкой с запятой в Windows). Если элемент списка начинается со специальной строки &lt;code&gt;$libdir&lt;/code&gt; , каталог скомпилированной библиотеки пакетов PostgreSQL заменяется на &lt;code&gt;$libdir&lt;/code&gt; ; здесь устанавливаются модули, входящие в стандартный дистрибутив PostgreSQL. (Используйте &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; , чтобы узнать имя этого каталога.) Например:</target>
        </trans-unit>
        <trans-unit id="e2ece96ce583cb594781fa18e96e90c23a241cb2" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;search_path&lt;/code&gt; must be a comma-separated list of schema names. Any name that is not an existing schema, or is a schema for which the user does not have &lt;code&gt;USAGE&lt;/code&gt; permission, is silently ignored.</source>
          <target state="translated">Значение &lt;code&gt;search_path&lt;/code&gt; должно быть списком имен схем, разделенных запятыми. Любое имя, которое не является существующей схемой или является схемой, для которой пользователь не имеет разрешения &lt;code&gt;USAGE&lt;/code&gt; , игнорируется без уведомления.</target>
        </trans-unit>
        <trans-unit id="1885fd3acbde2dfc55224cb44032743ea0749cf2" translate="yes" xml:space="preserve">
          <source>The value is a list of names of tablespaces. When there is more than one name in the list, PostgreSQL chooses a random member of the list each time a temporary object is to be created; except that within a transaction, successively created temporary objects are placed in successive tablespaces from the list. If the selected element of the list is an empty string, PostgreSQL will automatically use the default tablespace of the current database instead.</source>
          <target state="translated">Значение представляет собой список имен табличных пространств.Когда в списке более одного имени,PostgreSQL каждый раз при создании временного объекта выбирает случайного члена списка,за исключением того,что внутри транзакции последовательно созданные временные объекты размещаются в последовательных табличных пространствах из списка.Если выбранный элемент списка-пустая строка,то PostgreSQL будет автоматически использовать табличное пространство текущей БД по умолчанию.</target>
        </trans-unit>
        <trans-unit id="99c82c62699420580e0ce37ee3df7912c1dd98bf" translate="yes" xml:space="preserve">
          <source>The value is either the name of a tablespace, or an empty string to specify using the default tablespace of the current database. If the value does not match the name of any existing tablespace, PostgreSQL will automatically use the default tablespace of the current database. If a nondefault tablespace is specified, the user must have &lt;code&gt;CREATE&lt;/code&gt; privilege for it, or creation attempts will fail.</source>
          <target state="translated">Значением является либо имя табличного пространства, либо пустая строка, которую необходимо указать с использованием табличного пространства по умолчанию для текущей базы данных. Если значение не совпадает с именем какого-либо существующего табличного пространства, PostgreSQL автоматически будет использовать табличное пространство по умолчанию текущей базы данных. Если указано табличное пространство не по умолчанию, пользователь должен иметь для него привилегию &lt;code&gt;CREATE&lt;/code&gt; , иначе попытки создания не удастся.</target>
        </trans-unit>
        <trans-unit id="35739a3ab0eff8d38722337e2254ec6c774352ae" translate="yes" xml:space="preserve">
          <source>The value might be quoted and schema-qualified. If no collation is derived for the argument expression, then a null value is returned. If the argument is not of a collatable data type, then an error is raised.</source>
          <target state="translated">Значение может быть приведено в кавычки и определено по схеме.Если для выражения аргумента не выведено сравнение,то возвращается нулевое значение.Если аргумент не имеет коллатируемого типа данных,то выдается ошибка.</target>
        </trans-unit>
        <trans-unit id="39c36934ef87435e122aa28a1e5f5b7fbbf50ca7" translate="yes" xml:space="preserve">
          <source>The value of either of these directories that is appropriate for the installation can be found out using &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt;.</source>
          <target state="translated">Значение любого из этих каталогов, подходящее для установки, можно узнать с помощью &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48b58f404c5ab41a010c449c8600d4f12fc88c78" translate="yes" xml:space="preserve">
          <source>The value of the last affected OID, as returned from an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;\lo_import&lt;/code&gt; command. This variable is only guaranteed to be valid until after the result of the next SQL command has been displayed. PostgreSQL servers since version 12 do not support OID system columns anymore, thus LASTOID will always be 0 following &lt;code&gt;INSERT&lt;/code&gt; when targeting such servers.</source>
          <target state="translated">Значение последнего затронутого OID, возвращенное &lt;code&gt;\lo_import&lt;/code&gt; &lt;code&gt;INSERT&lt;/code&gt; или \ lo_import . Эта переменная гарантированно действительна только до тех пор, пока не будет отображен результат следующей команды SQL. Серверы PostgreSQL, начиная с версии 12, больше не поддерживают системные столбцы OID, поэтому LASTOID всегда будет 0 после &lt;code&gt;INSERT&lt;/code&gt; при нацеливании на такие серверы.</target>
        </trans-unit>
        <trans-unit id="5b8285b6717f13b01f6793b29c8c9dedce0baef8" translate="yes" xml:space="preserve">
          <source>The value of the psql variable &lt;code&gt;name&lt;/code&gt;. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, above, for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c651921fd6703938e12fa970227922443e260428" translate="yes" xml:space="preserve">
          <source>The value of the psql variable &lt;code&gt;name&lt;/code&gt;. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; for details.</source>
          <target state="translated">Значение Psql переменного &lt;code&gt;name&lt;/code&gt; . См. Подробности в разделе &amp;laquo; &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Переменные&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cad357760c4befedd7f8fdaa593e68c359c8118" translate="yes" xml:space="preserve">
          <source>The value of the selected prompt variable is printed literally, except where a percent sign (&lt;code&gt;%&lt;/code&gt;) is encountered. Depending on the next character, certain other text is substituted instead. Defined substitutions are:</source>
          <target state="translated">Значение выбранной переменной приглашения печатается буквально, за исключением случаев, когда встречается знак процента ( &lt;code&gt;%&lt;/code&gt; ). В зависимости от следующего символа вместо него подставляется другой текст. Определенные замены:</target>
        </trans-unit>
        <trans-unit id="039fa537d91bfcd8e0c10a9f71f9137554b1d793" translate="yes" xml:space="preserve">
          <source>The value of this parameter is a time stamp in the same format accepted by the &lt;code&gt;timestamp with time zone&lt;/code&gt; data type, except that you cannot use a time zone abbreviation (unless the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; variable has been set earlier in the configuration file). Preferred style is to use a numeric offset from UTC, or you can write a full time zone name, e.g., &lt;code&gt;Europe/Helsinki&lt;/code&gt; not &lt;code&gt;EEST&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c0a0ed9f32ba0a19ec5847f3fbe4958f014ea1" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; setting. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">Значение этого параметра переопределяет настройку &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; . Значение по умолчанию &lt;code&gt;off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a4243c2cf710a88b014f758bc5617eddee2438a" translate="yes" xml:space="preserve">
          <source>The value to use for &lt;code&gt;old_version&lt;/code&gt; is determined by the extension's author, and might vary if there is more than one version of the old-style module that can be upgraded into an extension. For the standard additional modules supplied with pre-9.1 PostgreSQL, use &lt;code&gt;unpackaged&lt;/code&gt; for &lt;code&gt;old_version&lt;/code&gt; when updating a module to extension style.</source>
          <target state="translated">Значение, которое следует использовать для &lt;code&gt;old_version&lt;/code&gt; , определяется автором расширения и может отличаться, если существует более одной версии модуля старого стиля, которую можно обновить до расширения. Для стандартных дополнительных модулей , поставляемых с предварительной 9.1 PostgreSQL, используйте &lt;code&gt;unpackaged&lt;/code&gt; для &lt;code&gt;old_version&lt;/code&gt; при обновлении модуля в стиль расширения.</target>
        </trans-unit>
        <trans-unit id="29a25a9c8e901cbf1e213381b2fe324bdafd7520" translate="yes" xml:space="preserve">
          <source>The value to use for a template-specific option. If the value is not a simple identifier or number, it must be quoted (but you can always quote it, if you wish).</source>
          <target state="translated">Значение,которое необходимо использовать для конкретной опции шаблона.Если значение не является простым идентификатором или числом,оно должно быть процитировано (но вы всегда можете процитировать его,если хотите).</target>
        </trans-unit>
        <trans-unit id="97aba03e4cf10e442611ec122abb257717947453" translate="yes" xml:space="preserve">
          <source>The values in each record are separated by the &lt;code&gt;DELIMITER&lt;/code&gt; character. If the value contains the delimiter character, the &lt;code&gt;QUOTE&lt;/code&gt; character, the &lt;code&gt;NULL&lt;/code&gt; string, a carriage return, or line feed character, then the whole value is prefixed and suffixed by the &lt;code&gt;QUOTE&lt;/code&gt; character, and any occurrence within the value of a &lt;code&gt;QUOTE&lt;/code&gt; character or the &lt;code&gt;ESCAPE&lt;/code&gt; character is preceded by the escape character. You can also use &lt;code&gt;FORCE_QUOTE&lt;/code&gt; to force quotes when outputting non-&lt;code&gt;NULL&lt;/code&gt; values in specific columns.</source>
          <target state="translated">Значения в каждой записи разделяются символом &lt;code&gt;DELIMITER&lt;/code&gt; . Если значение содержит символ-разделитель, символ &lt;code&gt;QUOTE&lt;/code&gt; , строку &lt;code&gt;NULL&lt;/code&gt; , возврат каретки или символ перевода строки, то все значение имеет префикс и суффикс с помощью символа &lt;code&gt;QUOTE&lt;/code&gt; , а также любое вхождение в значении символа &lt;code&gt;QUOTE&lt;/code&gt; или &lt;code&gt;ESCAPE&lt;/code&gt; предшествует escape-символ. Вы также можете использовать &lt;code&gt;FORCE_QUOTE&lt;/code&gt; для принудительного ввода кавычек при выводе значений, отличных от &lt;code&gt;NULL&lt;/code&gt; , в определенных столбцах.</target>
        </trans-unit>
        <trans-unit id="08d03d5b23111b07a76c7aeb9df7ffb0e8eb87a7" translate="yes" xml:space="preserve">
          <source>The values stored in the free space map are not exact. They're rounded to precision of 1/256th of &lt;code&gt;BLCKSZ&lt;/code&gt; (32 bytes with default &lt;code&gt;BLCKSZ&lt;/code&gt;), and they're not kept fully up-to-date as tuples are inserted and updated.</source>
          <target state="translated">Значения, хранящиеся в карте свободного пространства, неточны. Они округлены с точностью до &lt;code&gt;BLCKSZ&lt;/code&gt; от BLCKSZ (32 байта со значением по умолчанию &lt;code&gt;BLCKSZ&lt;/code&gt; ) и не обновляются полностью по мере вставки и обновления кортежей.</target>
        </trans-unit>
        <trans-unit id="b6c08b4507fc75b276335a79d4dd41a78fcf9ac5" translate="yes" xml:space="preserve">
          <source>The variants to add and drop attributes are part of the SQL standard; the other variants are PostgreSQL extensions.</source>
          <target state="translated">Варианты добавления и отбрасывания атрибутов являются частью стандарта SQL;другие варианты-это расширения PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="90629b5d606371db9e2f9a38b9c003515b5bf970" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;\d&lt;/code&gt; commands accept a &lt;code&gt;pattern&lt;/code&gt; parameter to specify the object name(s) to be displayed. In the simplest case, a pattern is just the exact name of the object. The characters within a pattern are normally folded to lower case, just as in SQL names; for example, &lt;code&gt;\dt FOO&lt;/code&gt; will display the table named &lt;code&gt;foo&lt;/code&gt;. As in SQL names, placing double quotes around a pattern stops folding to lower case. Should you need to include an actual double quote character in a pattern, write it as a pair of double quotes within a double-quote sequence; again this is in accord with the rules for SQL quoted identifiers. For example, &lt;code&gt;\dt &quot;FOO&quot;&quot;BAR&quot;&lt;/code&gt; will display the table named &lt;code&gt;FOO&quot;BAR&lt;/code&gt; (not &lt;code&gt;foo&quot;bar&lt;/code&gt;). Unlike the normal rules for SQL names, you can put double quotes around just part of a pattern, for instance &lt;code&gt;\dt FOO&quot;FOO&quot;BAR&lt;/code&gt; will display the table named &lt;code&gt;fooFOObar&lt;/code&gt;.</source>
          <target state="translated">Различные команды &lt;code&gt;\d&lt;/code&gt; принимают параметр &lt;code&gt;pattern&lt;/code&gt; чтобы указать имя (имена) объекта для отображения. В простейшем случае шаблон - это просто точное имя объекта. Символы в шаблоне обычно переводятся в нижний регистр, как и в именах SQL; например, &lt;code&gt;\dt FOO&lt;/code&gt; отобразит таблицу с именем &lt;code&gt;foo&lt;/code&gt; . Как и в именах SQL, размещение шаблона в двойных кавычках прекращает сворачивание в нижний регистр. Если вам нужно включить в шаблон фактический символ двойной кавычки, запишите его как пару двойных кавычек внутри последовательности двойных кавычек; опять же, это соответствует правилам для идентификаторов в кавычках SQL. Например, &lt;code&gt;\dt &quot;FOO&quot;&quot;BAR&quot;&lt;/code&gt; отобразит таблицу с именем &lt;code&gt;FOO&quot;BAR&lt;/code&gt; (не &lt;code&gt;foo&quot;bar&lt;/code&gt; ). В отличие от обычных правил для имен SQL, вы можете заключить в двойные кавычки только часть шаблона, например, &lt;code&gt;\dt FOO&quot;FOO&quot;BAR&lt;/code&gt; отобразит таблицу с именем &lt;code&gt;fooFOObar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7768758b3213c172e932c01f8e8da70daa4ada7f" translate="yes" xml:space="preserve">
          <source>The various containment and existence operators, along with all other JSON operators and functions are documented in &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">Различные операторы включения и существования, а также все другие операторы и функции JSON описаны в &lt;a href=&quot;functions-json&quot;&gt;Разделе 9.15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f313c60885e972dab9c59de4db6a32bb9909c11" translate="yes" xml:space="preserve">
          <source>The various containment and existence operators, along with all other JSON operators and functions are documented in &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c7ea1665d58af0cc391c652b85b77be99d97f9" translate="yes" xml:space="preserve">
          <source>The various variants of &lt;code&gt;BETWEEN&lt;/code&gt; are implemented in terms of the ordinary comparison operators, and therefore will work for any data type(s) that can be compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e179b7076409c4b105a612d7c9bb99b67e607cd" translate="yes" xml:space="preserve">
          <source>The verbatim query string submitted to declare this cursor</source>
          <target state="translated">Строка дословного запроса,представленная для объявления этого курсора</target>
        </trans-unit>
        <trans-unit id="91cb72e2fa3dca24da98249febe148f7555e66ba" translate="yes" xml:space="preserve">
          <source>The version of the extension to install. This can be written as either an identifier or a string literal. The default version is whatever is specified in the extension's control file.</source>
          <target state="translated">Версия расширения для установки.Оно может быть записано как идентификатор или как строковый литерал.Версией по умолчанию является то,что указано в управляющем файле расширения.</target>
        </trans-unit>
        <trans-unit id="1f466ef09b06001ef2dbe51d7e047e29feba87d5" translate="yes" xml:space="preserve">
          <source>The vertical header, displayed as the leftmost column, contains the values found in column &lt;code&gt;colV&lt;/code&gt;, in the same order as in the query results, but with duplicates removed.</source>
          <target state="translated">Вертикальный заголовок, отображаемый как крайний левый столбец, содержит значения, найденные в столбце &lt;code&gt;colV&lt;/code&gt; , в том же порядке, что и в результатах запроса, но с удаленными дубликатами.</target>
        </trans-unit>
        <trans-unit id="ea52093b90b84d5b4fcb30b73c3186c808f82ec0" translate="yes" xml:space="preserve">
          <source>The very first process of an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;. It starts and manages the other auxiliary processes and creates &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend processes&lt;/a&gt; on demand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adcabe9624ff122085bfba5e28081fdc88cd247" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_config&lt;/code&gt; describes the compile-time configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries. It provides the same basic information as the &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; PostgreSQL client application.</source>
          <target state="translated">Представление &lt;code&gt;pg_config&lt;/code&gt; описывает параметры конфигурации времени компиляции установленной в данный момент версии PostgreSQL. Он предназначен, например, для использования пакетами программного обеспечения, которые хотят взаимодействовать с PostgreSQL, чтобы облегчить поиск необходимых файлов заголовков и библиотек. Он предоставляет ту же основную информацию, что и клиентское приложение &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="08ea6b2cfb240aa2a36ba0270a0c6bfcfe867503" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_file_settings&lt;/code&gt; provides a summary of the contents of the server's configuration file(s). A row appears in this view for each &amp;ldquo;name = value&amp;rdquo; entry appearing in the files, with annotations indicating whether the value could be applied successfully. Additional row(s) may appear for problems not linked to a &amp;ldquo;name = value&amp;rdquo; entry, such as syntax errors in the files.</source>
          <target state="translated">Представление &lt;code&gt;pg_file_settings&lt;/code&gt; предоставляет сводку содержимого файла (ов) конфигурации сервера. В этом представлении отображается строка для каждой записи &amp;laquo;имя = значение&amp;raquo;, появляющейся в файлах, с аннотациями, указывающими, можно ли успешно применить значение. Дополнительные строки могут отображаться для проблем, не связанных с записью &amp;laquo;имя = значение&amp;raquo;, таких как синтаксические ошибки в файлах.</target>
        </trans-unit>
        <trans-unit id="63d33a4b341777d328dc2c1f214857e8874dc6d9" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_group&lt;/code&gt; exists for backwards compatibility: it emulates a catalog that existed in PostgreSQL before version 8.1. It shows the names and members of all roles that are marked as not &lt;code&gt;rolcanlogin&lt;/code&gt;, which is an approximation to the set of roles that are being used as groups.</source>
          <target state="translated">Представление &lt;code&gt;pg_group&lt;/code&gt; существует для обратной совместимости: оно имитирует каталог, существовавший в PostgreSQL до версии 8.1. Он показывает имена и членов всех ролей, отмеченных как not &lt;code&gt;rolcanlogin&lt;/code&gt; , что приблизительно соответствует набору ролей, используемых в качестве групп.</target>
        </trans-unit>
        <trans-unit id="6dadc8f5b62fc6f506c2d65eb8b07e558e7c8b3f" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_hba_file_rules&lt;/code&gt; provides a summary of the contents of the client authentication configuration file, &lt;code&gt;pg_hba.conf&lt;/code&gt;. A row appears in this view for each non-empty, non-comment line in the file, with annotations indicating whether the rule could be applied successfully.</source>
          <target state="translated">Представление &lt;code&gt;pg_hba_file_rules&lt;/code&gt; предоставляет сводку содержимого файла конфигурации аутентификации клиента, &lt;code&gt;pg_hba.conf&lt;/code&gt; . В этом представлении отображается строка для каждой непустой, не содержащей комментариев строки в файле с аннотациями, указывающими, можно ли успешно применить правило.</target>
        </trans-unit>
        <trans-unit id="aac1873f6d2161781d725af8550ac62cddd3ae8a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_indexes&lt;/code&gt; provides access to useful information about each index in the database.</source>
          <target state="translated">Представление &lt;code&gt;pg_indexes&lt;/code&gt; обеспечивает доступ к полезной информации о каждом индексе в базе данных.</target>
        </trans-unit>
        <trans-unit id="c4a5f88ab67e15b0fb81ed88eb1f6933ddc8f95f" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_locks&lt;/code&gt; provides access to information about the locks held by active processes within the database server. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more discussion of locking.</source>
          <target state="translated">Представление &lt;code&gt;pg_locks&lt;/code&gt; обеспечивает доступ к информации о блокировках, удерживаемых активными процессами на сервере базы данных. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Главу 13&lt;/a&gt; для более подробного обсуждения блокировки.</target>
        </trans-unit>
        <trans-unit id="f25d4dc4f833f46aa9ec8087405622ced3b66529" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_locks&lt;/code&gt; provides access to information about the locks held by active processes within the database server. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more discussion of locking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042974f73615dd15fc09c5129e6b33aeeef53099" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_matviews&lt;/code&gt; provides access to useful information about each materialized view in the database.</source>
          <target state="translated">Представление &lt;code&gt;pg_matviews&lt;/code&gt; обеспечивает доступ к полезной информации о каждом материализованном представлении в базе данных.</target>
        </trans-unit>
        <trans-unit id="f35ab0d9ea2df46d55f4f8845455de38e126b0e5" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_policies&lt;/code&gt; provides access to useful information about each row-level security policy in the database.</source>
          <target state="translated">Представление &lt;code&gt;pg_policies&lt;/code&gt; предоставляет доступ к полезной информации о каждой политике безопасности на уровне строк в базе данных.</target>
        </trans-unit>
        <trans-unit id="43d0e1b7a1af60f6a8bef0840cbf55e0cd1189ae" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_prepared_xacts&lt;/code&gt; displays information about transactions that are currently prepared for two-phase commit (see &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; for details).</source>
          <target state="translated">В представлении &lt;code&gt;pg_prepared_xacts&lt;/code&gt; отображается информация о транзакциях, которые в настоящее время подготовлены для двухфазной фиксации (подробности см. В разделе &lt;a href=&quot;sql-prepare-transaction&quot;&gt;ПОДГОТОВКА ТРАНЗАКЦИИ&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5890e8d1e9f41b0cd60cd417fec506b423153a1c" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_publication_tables&lt;/code&gt; provides information about the mapping between publications and the tables they contain. Unlike the underlying catalog &lt;code&gt;pg_publication_rel&lt;/code&gt;, this view expands publications defined as &lt;code&gt;FOR ALL TABLES&lt;/code&gt;, so for such publications there will be a row for each eligible table.</source>
          <target state="translated">Представление &lt;code&gt;pg_publication_tables&lt;/code&gt; предоставляет информацию о сопоставлении публикаций и содержащихся в них таблиц. В отличие от базового каталога &lt;code&gt;pg_publication_rel&lt;/code&gt; , это представление расширяет публикации, определенные как &lt;code&gt;FOR ALL TABLES&lt;/code&gt; , поэтому для таких публикаций будет строка для каждой подходящей таблицы.</target>
        </trans-unit>
        <trans-unit id="e6f8a891f9c67ef2b6de308cc7563907a8fbe06b" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_roles&lt;/code&gt; provides access to information about database roles. This is simply a publicly readable view of &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt; that blanks out the password field.</source>
          <target state="translated">Представление &lt;code&gt;pg_roles&lt;/code&gt; обеспечивает доступ к информации о ролях базы данных. Это просто общедоступное представление &lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt; , в котором поле пароля отсутствует.</target>
        </trans-unit>
        <trans-unit id="be02d2530abee0307e3d8c75ed7462d6006d37d5" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_rules&lt;/code&gt; provides access to useful information about query rewrite rules.</source>
          <target state="translated">Представление &lt;code&gt;pg_rules&lt;/code&gt; обеспечивает доступ к полезной информации о правилах перезаписи запросов.</target>
        </trans-unit>
        <trans-unit id="8abbf138d7583623930f0cc0e4290da9934bc84a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_seclabels&lt;/code&gt; provides information about security labels. It as an easier-to-query version of the &lt;a href=&quot;catalog-pg-seclabel&quot;&gt;&lt;code&gt;pg_seclabel&lt;/code&gt;&lt;/a&gt; catalog.</source>
          <target state="translated">Представление &lt;code&gt;pg_seclabels&lt;/code&gt; предоставляет информацию о метках защиты. Это &lt;a href=&quot;catalog-pg-seclabel&quot;&gt; &lt;code&gt;pg_seclabel&lt;/code&gt; &lt;/a&gt; для запроса версия каталога pg_seclabel .</target>
        </trans-unit>
        <trans-unit id="9de8f57dd43c6ec5ae63346c8a1f92176c16d0d1" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_sequences&lt;/code&gt; provides access to useful information about each sequence in the database.</source>
          <target state="translated">Представление &lt;code&gt;pg_sequences&lt;/code&gt; обеспечивает доступ к полезной информации о каждой последовательности в базе данных.</target>
        </trans-unit>
        <trans-unit id="25e4f3261aeb43d1f5668204f1fb62fa4677a0bd" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_settings&lt;/code&gt; provides access to run-time parameters of the server. It is essentially an alternative interface to the &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; and &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; commands. It also provides access to some facts about each parameter that are not directly available from &lt;code&gt;SHOW&lt;/code&gt;, such as minimum and maximum values.</source>
          <target state="translated">Представление &lt;code&gt;pg_settings&lt;/code&gt; обеспечивает доступ к параметрам времени выполнения сервера. По сути, это альтернативный интерфейс для команд &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; и &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; . Он также обеспечивает доступ к некоторым фактам о каждом параметре, которые не доступны напрямую из &lt;code&gt;SHOW&lt;/code&gt; , например, минимальные и максимальные значения.</target>
        </trans-unit>
        <trans-unit id="7729b5ec7977be5f90c3408f6cef81a593faa4de" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_shadow&lt;/code&gt; exists for backwards compatibility: it emulates a catalog that existed in PostgreSQL before version 8.1. It shows properties of all roles that are marked as &lt;code&gt;rolcanlogin&lt;/code&gt; in &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Представление &lt;code&gt;pg_shadow&lt;/code&gt; существует для обратной совместимости: оно имитирует каталог, существовавший в PostgreSQL до версии 8.1. Он показывает свойства всех ролей, отмеченных как &lt;code&gt;rolcanlogin&lt;/code&gt; в &lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d15bc53a297402a714a0bba8855047689e420c4a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_stats&lt;/code&gt; provides access to the information stored in the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; catalog. This view allows access only to rows of &lt;code&gt;pg_statistic&lt;/code&gt; that correspond to tables the user has permission to read, and therefore it is safe to allow public read access to this view.</source>
          <target state="translated">Представление &lt;code&gt;pg_stats&lt;/code&gt; обеспечивает доступ к информации, хранящейся в каталоге &lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt; . Это представление разрешает доступ только к строкам &lt;code&gt;pg_statistic&lt;/code&gt; , которые соответствуют таблицам, на чтение которых у пользователя есть разрешение, и поэтому можно безопасно разрешить публичный доступ для чтения к этому представлению.</target>
        </trans-unit>
        <trans-unit id="8b10f73e0ee9172a27b8a2e39f5e546984d02189" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_stats_ext&lt;/code&gt; provides access to the information stored in the &lt;a href=&quot;catalog-pg-statistic-ext&quot;&gt;&lt;code&gt;pg_statistic_ext&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt;&lt;code&gt;pg_statistic_ext_data&lt;/code&gt;&lt;/a&gt; catalogs. This view allows access only to rows of &lt;code&gt;pg_statistic_ext&lt;/code&gt; and &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; that correspond to tables the user has permission to read, and therefore it is safe to allow public read access to this view.</source>
          <target state="translated">Представление &lt;code&gt;pg_stats_ext&lt;/code&gt; обеспечивает доступ к информации, хранящейся в каталогах &lt;a href=&quot;catalog-pg-statistic-ext&quot;&gt; &lt;code&gt;pg_statistic_ext&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt; &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; &lt;/a&gt; . Это представление разрешает доступ только к строкам &lt;code&gt;pg_statistic_ext&lt;/code&gt; и &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; , которые соответствуют таблицам, на чтение которых у пользователя есть разрешение, и поэтому можно безопасно разрешить публичный доступ для чтения к этому представлению.</target>
        </trans-unit>
        <trans-unit id="f40e73d682038b4cca53135af313b3e16f3f20f0" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_tables&lt;/code&gt; provides access to useful information about each table in the database.</source>
          <target state="translated">Представление &lt;code&gt;pg_tables&lt;/code&gt; предоставляет доступ к полезной информации о каждой таблице в базе данных.</target>
        </trans-unit>
        <trans-unit id="6619a281d707d2c59aad726e79eb743d37565afc" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; provides a list of time zone abbreviations that are currently recognized by the datetime input routines. The contents of this view change when the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; run-time parameter is modified.</source>
          <target state="translated">Представление &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; предоставляет список сокращений часовых поясов, которые в настоящее время распознаются подпрограммами ввода datetime. Содержимое этого представления изменяется при изменении параметра времени выполнения &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="779554f59d2b5af071b41b6375ef03ef95013941" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_timezone_names&lt;/code&gt; provides a list of time zone names that are recognized by &lt;code&gt;SET TIMEZONE&lt;/code&gt;, along with their associated abbreviations, UTC offsets, and daylight-savings status. (Technically, PostgreSQL does not use UTC because leap seconds are not handled.) Unlike the abbreviations shown in &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;&lt;code&gt;pg_timezone_abbrevs&lt;/code&gt;&lt;/a&gt;, many of these names imply a set of daylight-savings transition date rules. Therefore, the associated information changes across local DST boundaries. The displayed information is computed based on the current value of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;.</source>
          <target state="translated">Представление &lt;code&gt;pg_timezone_names&lt;/code&gt; предоставляет список имен часовых поясов, которые распознаются &lt;code&gt;SET TIMEZONE&lt;/code&gt; , вместе с соответствующими сокращениями, смещениями по Гринвичу и статусом перехода на летнее время. (Технически PostgreSQL не использует UTC, потому что дополнительные секунды не обрабатываются.) В отличие от сокращений, показанных в &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt; &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; &lt;/a&gt; , многие из этих имен подразумевают набор правил перехода на летнее время. Следовательно, связанная информация изменяется через локальные границы летнего времени. Отображаемая информация вычисляется на основе текущего значения &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0accb8d532196eb116802aaa4d92096a1d624fec" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_user&lt;/code&gt; provides access to information about database users. This is simply a publicly readable view of &lt;a href=&quot;view-pg-shadow&quot;&gt;&lt;code&gt;pg_shadow&lt;/code&gt;&lt;/a&gt; that blanks out the password field.</source>
          <target state="translated">Представление &lt;code&gt;pg_user&lt;/code&gt; предоставляет доступ к информации о пользователях базы данных. Это просто общедоступный вид &lt;a href=&quot;view-pg-shadow&quot;&gt; &lt;code&gt;pg_shadow&lt;/code&gt; &lt;/a&gt; , в котором поле пароля отсутствует.</target>
        </trans-unit>
        <trans-unit id="9af556d749b255c75a83063bd94ae2fbcc5e7542" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_user_mappings&lt;/code&gt; provides access to information about user mappings. This is essentially a publicly readable view of &lt;a href=&quot;catalog-pg-user-mapping&quot;&gt;&lt;code&gt;pg_user_mapping&lt;/code&gt;&lt;/a&gt; that leaves out the options field if the user has no rights to use it.</source>
          <target state="translated">Представление &lt;code&gt;pg_user_mappings&lt;/code&gt; предоставляет доступ к информации о сопоставлениях пользователей. По сути, это общедоступное представление &lt;a href=&quot;catalog-pg-user-mapping&quot;&gt; &lt;code&gt;pg_user_mapping&lt;/code&gt; ,&lt;/a&gt; которое не учитывает поле параметров, если у пользователя нет прав на его использование.</target>
        </trans-unit>
        <trans-unit id="ebac217e3082208e364c831d2d7b567e319b9c3e" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_views&lt;/code&gt; provides access to useful information about each view in the database.</source>
          <target state="translated">Представление &lt;code&gt;pg_views&lt;/code&gt; обеспечивает доступ к полезной информации о каждом представлении в базе данных.</target>
        </trans-unit>
        <trans-unit id="4817256584c648c50b28a16cee721735c1a52c24" translate="yes" xml:space="preserve">
          <source>The view definition must not contain &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, or &lt;code&gt;OFFSET&lt;/code&gt; clauses at the top level.</source>
          <target state="translated">Определение представления не должно содержать предложений &lt;code&gt;WITH&lt;/code&gt; , &lt;code&gt;DISTINCT&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; , &lt;code&gt;HAVING&lt;/code&gt; , &lt;code&gt;LIMIT&lt;/code&gt; или &lt;code&gt;OFFSET&lt;/code&gt; на верхнем уровне.</target>
        </trans-unit>
        <trans-unit id="ac73f4040a9b923ccad030c67910098b61fec109" translate="yes" xml:space="preserve">
          <source>The view definition must not contain set operations (&lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) at the top level.</source>
          <target state="translated">Определение представления не должно содержать операций над множеством ( &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; или &lt;code&gt;EXCEPT&lt;/code&gt; ) на верхнем уровне.</target>
        </trans-unit>
        <trans-unit id="c5066d83f9232becf3a59274519313c89ede3a33" translate="yes" xml:space="preserve">
          <source>The view must have exactly one entry in its &lt;code&gt;FROM&lt;/code&gt; list, which must be a table or another updatable view.</source>
          <target state="translated">Представление должно иметь ровно одну запись в своем списке &lt;code&gt;FROM&lt;/code&gt; , который должен быть таблицей или другим обновляемым представлением.</target>
        </trans-unit>
        <trans-unit id="baf2ef9470f50663334ce73cc7c64a2829052725" translate="yes" xml:space="preserve">
          <source>The view's select list must not contain any aggregates, window functions or set-returning functions.</source>
          <target state="translated">Список выбора представления не должен содержать агрегатов,функций окон или функций возврата к настройкам.</target>
        </trans-unit>
        <trans-unit id="130532d5707af5b172a46c66162c216e956933cf" translate="yes" xml:space="preserve">
          <source>The visibility map stores two bits per heap page. The first bit, if set, indicates that the page is all-visible, or in other words that the page does not contain any tuples that need to be vacuumed. This information can also be used by &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;index-only scans&lt;/em&gt;&lt;/a&gt; to answer queries using only the index tuple. The second bit, if set, means that all tuples on the page have been frozen. That means that even an anti-wraparound vacuum need not revisit the page.</source>
          <target state="translated">Карта видимости хранит два бита на страницу кучи. Первый бит, если он установлен, указывает, что страница является полностью видимой или, другими словами, страница не содержит кортежей, которые необходимо очистить. Эта информация также может использоваться &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;сканированием только индекса&lt;/em&gt;&lt;/a&gt; для ответа на запросы с использованием только кортежа индекса. Второй бит, если он установлен, означает, что все кортежи на странице заморожены. Это означает, что даже при пылесосе, предотвращающем обертывание, не нужно повторно посещать страницу.</target>
        </trans-unit>
        <trans-unit id="07214e8c015e87c0486ca72cfe80d8e537680c27" translate="yes" xml:space="preserve">
          <source>The web site of the Unicode Consortium.</source>
          <target state="translated">Веб-сайт консорциума &quot;Юникод&quot;.</target>
        </trans-unit>
        <trans-unit id="ac0772ef278780058ef7ad6f8b7ba38fa2811ad4" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;The&lt;/code&gt; was recognized by the &lt;code&gt;english_ispell&lt;/code&gt; dictionary as a stop word (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;Section 12.6.1&lt;/a&gt;) and will not be indexed. The spaces are discarded too, since the configuration provides no dictionaries at all for them.</source>
          <target state="translated">Слово &lt;code&gt;The&lt;/code&gt; было распознано словарем &lt;code&gt;english_ispell&lt;/code&gt; как стоп-слово ( &lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;раздел 12.6.1&lt;/a&gt; ) и не будет проиндексировано. Пробелы тоже отбрасываются, так как в конфигурации для них вообще нет словарей.</target>
        </trans-unit>
        <trans-unit id="59b558b7e67cfe3d7e609850ba39630cdfabc234" translate="yes" xml:space="preserve">
          <source>The words &lt;code&gt;INNER&lt;/code&gt; and &lt;code&gt;OUTER&lt;/code&gt; are optional in all forms. &lt;code&gt;INNER&lt;/code&gt; is the default; &lt;code&gt;LEFT&lt;/code&gt;, &lt;code&gt;RIGHT&lt;/code&gt;, and &lt;code&gt;FULL&lt;/code&gt; imply an outer join.</source>
          <target state="translated">Слова &lt;code&gt;INNER&lt;/code&gt; и &lt;code&gt;OUTER&lt;/code&gt; необязательны во всех формах. &lt;code&gt;INNER&lt;/code&gt; по умолчанию; &lt;code&gt;LEFT&lt;/code&gt; , &lt;code&gt;RIGHT&lt;/code&gt; и &lt;code&gt;FULL&lt;/code&gt; подразумевают внешнее соединение.</target>
        </trans-unit>
        <trans-unit id="0b4d99c273391963b8b35583f768d35f9926b320" translate="yes" xml:space="preserve">
          <source>The write-ahead log files are collected at the end of the backup. Therefore, it is necessary for the &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; parameter to be set high enough that the log is not removed before the end of the backup. If the log has been rotated when it's time to transfer it, the backup will fail and be unusable.</source>
          <target state="translated">Файлы журнала упреждающей записи собираются в конце резервного копирования. Следовательно, необходимо, чтобы параметр &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; был установлен достаточно высоким, чтобы журнал не удалялся до окончания резервного копирования. Если журнал был повернут, когда пришло время его переносить, резервная копия не удастся и будет непригодна для использования.</target>
        </trans-unit>
        <trans-unit id="bb82d1de22fb923c487c6dd4a9b8f7c1ca501443" translate="yes" xml:space="preserve">
          <source>The write-ahead log files are collected at the end of the backup. Therefore, it is necessary for the source server's &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt; parameter to be set high enough that the required log data is not removed before the end of the backup. If the required log data has been recycled before it's time to transfer it, the backup will fail and be unusable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7564fc67dee171caeeb2fce7f2a0e6bd4739d4" translate="yes" xml:space="preserve">
          <source>The write-ahead log is streamed over a regular PostgreSQL connection and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the stream.</source>
          <target state="translated">Журнал упреждающей записи передается через обычное соединение PostgreSQL и использует протокол репликации. Соединение должно быть выполнено с суперпользователем или пользователем, имеющим права &lt;code&gt;REPLICATION&lt;/code&gt; (см. &lt;a href=&quot;role-attributes&quot;&gt;Раздел 21.2&lt;/a&gt; ), а &lt;code&gt;pg_hba.conf&lt;/code&gt; должен разрешать соединение для репликации. Сервер также должен быть настроен с &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;максимальным значением max_wal_senders&lt;/a&gt; , чтобы оставить по крайней мере один сеанс доступным для потока.</target>
        </trans-unit>
        <trans-unit id="98bdbb8059522e13ab67d4f644a83a409dec157e" translate="yes" xml:space="preserve">
          <source>The write-ahead log is streamed over a regular PostgreSQL connection and uses the replication protocol. The connection must be made with a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;) or a superuser, and &lt;code&gt;pg_hba.conf&lt;/code&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432cd562d6efcb95d5dc25b8cd51ce86806b3431" translate="yes" xml:space="preserve">
          <source>The year field divided by 10</source>
          <target state="translated">Годовое поле,разделенное на 10</target>
        </trans-unit>
        <trans-unit id="e98cba09cda3a8f0612018162bdf75b308d8a647" translate="yes" xml:space="preserve">
          <source>The year field. Keep in mind there is no &lt;code&gt;0 AD&lt;/code&gt;, so subtracting &lt;code&gt;BC&lt;/code&gt; years from &lt;code&gt;AD&lt;/code&gt; years should be done with care.</source>
          <target state="translated">Поле года. Имейте в виду, что нет &lt;code&gt;0 AD&lt;/code&gt; , поэтому вычитание лет &lt;code&gt;BC&lt;/code&gt; &lt;code&gt;AD&lt;/code&gt; из лет нашей эры следует делать осторожно.</target>
        </trans-unit>
        <trans-unit id="3552e22363d1468b0aacd8c69df60173fa97d631" translate="yes" xml:space="preserve">
          <source>Then a second pass is performed to add tuples that were added while the first pass was running. This step is also done in a separate transaction for each index.</source>
          <target state="translated">Затем выполняется второй проход для добавления кортежей,которые были добавлены во время первого прохода.Этот шаг также выполняется в отдельной транзакции для каждого индекса.</target>
        </trans-unit>
        <trans-unit id="de263736bca031472680a6589ed91b77cebda41e" translate="yes" xml:space="preserve">
          <source>Then create a foreign server using &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;. In this example we wish to connect to a PostgreSQL server on host &lt;code&gt;192.83.123.89&lt;/code&gt; listening on port &lt;code&gt;5432&lt;/code&gt;. The database to which the connection is made is named &lt;code&gt;foreign_db&lt;/code&gt; on the remote server:</source>
          <target state="translated">Затем создайте сторонний сервер, используя &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt; . В этом примере мы хотим подключиться к серверу PostgreSQL на хосте &lt;code&gt;192.83.123.89&lt;/code&gt; ,который прослушивает порт &lt;code&gt;5432&lt;/code&gt; . База данных, к которой выполняется соединение, на удаленном сервере называется &lt;code&gt;foreign_db&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3a9fba163e98528da53932bde9ceaf387982416c" translate="yes" xml:space="preserve">
          <source>Then create a foreign server:</source>
          <target state="translated">Тогда создайте иностранный сервер:</target>
        </trans-unit>
        <trans-unit id="e43083876c3094d12a2389b25dd099144327f495" translate="yes" xml:space="preserve">
          <source>Then create the necessary functions:</source>
          <target state="translated">Затем создайте необходимые функции:</target>
        </trans-unit>
        <trans-unit id="2dddb885a6a2b1519c7054126c37d9c20d84517e" translate="yes" xml:space="preserve">
          <source>Then do:</source>
          <target state="translated">Тогда делай:</target>
        </trans-unit>
        <trans-unit id="4426056bca332e6c166eaec6ccb98cd595443c37" translate="yes" xml:space="preserve">
          <source>Then give the snapshot identifier in a &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; command at the beginning of the newly opened transaction:</source>
          <target state="translated">Затем укажите идентификатор снимка в команде &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; в начале вновь открытой транзакции:</target>
        </trans-unit>
        <trans-unit id="099f3b7a79e1e05797463b8b9b3322c6caaa4e61" translate="yes" xml:space="preserve">
          <source>Then in</source>
          <target state="translated">Затем</target>
        </trans-unit>
        <trans-unit id="ccb8ef6dada9fbef1512f58ed41d1e67ec739a68" translate="yes" xml:space="preserve">
          <source>Then issue the tablespace creation command inside PostgreSQL:</source>
          <target state="translated">Затем выдайте команду создания табличного пространства внутри PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="a0f76343f97548fdfb798c00512768e705a5ee06" translate="yes" xml:space="preserve">
          <source>Then on the publisher database:</source>
          <target state="translated">Затем в базе данных издателей:</target>
        </trans-unit>
        <trans-unit id="1d6e3db28b5d51e7392c9e84a5178977bac26570" translate="yes" xml:space="preserve">
          <source>Then psql's &lt;code&gt;\dp&lt;/code&gt; command would show:</source>
          <target state="translated">Тогда команда psql &lt;code&gt;\dp&lt;/code&gt; покажет:</target>
        </trans-unit>
        <trans-unit id="e40d95af0c8bcea8599638c011ae6dba5195ebe1" translate="yes" xml:space="preserve">
          <source>Then value &lt;code&gt;i&lt;/code&gt; between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; inclusive is drawn with probability: &lt;code&gt;f(i) - f(i + 1)&lt;/code&gt;.</source>
          <target state="translated">Затем с вероятностью отрисовывается значение &lt;code&gt;i&lt;/code&gt; между &lt;code&gt;min&lt;/code&gt; и &lt;code&gt;max&lt;/code&gt; включительно: &lt;code&gt;f(i) - f(i + 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="509703ffcaaed84d033fc9e94ce5a7937bf0da94" translate="yes" xml:space="preserve">
          <source>Then we create a GIN index to speed up the search:</source>
          <target state="translated">Затем мы создаем GIN-индекс,чтобы ускорить поиск:</target>
        </trans-unit>
        <trans-unit id="c623faac8eaf06e9450b38faf671811be2f6e1f9" translate="yes" xml:space="preserve">
          <source>Then we no longer have access to the public schema without explicit qualification. There is nothing special about the public schema except that it exists by default. It can be dropped, too.</source>
          <target state="translated">Тогда мы больше не имеем доступа к публичной схеме без явных оговорок.В публичной схеме нет ничего особенного,кроме того,что она существует по умолчанию.Ее тоже можно сбросить.</target>
        </trans-unit>
        <trans-unit id="0d0e01998d1caf45906467ce09eb6d9f85a24392" translate="yes" xml:space="preserve">
          <source>Then we will get these results:</source>
          <target state="translated">Тогда мы получим эти результаты:</target>
        </trans-unit>
        <trans-unit id="30348812ea695911ccd6ce73f8cff665d67bd9ad" translate="yes" xml:space="preserve">
          <source>Then you can use it in a &lt;code&gt;SELECT&lt;/code&gt; command, for instance:</source>
          <target state="translated">Затем вы можете использовать его в команде &lt;code&gt;SELECT&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="0c956d2a4c1c867a4aa753ae841035f68a38bb7b" translate="yes" xml:space="preserve">
          <source>Then you could name the files in the &lt;code&gt;conf.d&lt;/code&gt; directory like this:</source>
          <target state="translated">Затем вы можете назвать файлы в каталоге &lt;code&gt;conf.d&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="f4c7647dc71f8f47d91ed549387e0af6d05b17ea" translate="yes" xml:space="preserve">
          <source>Then, create a symbolic link to it in &lt;code&gt;/etc/rc3.d&lt;/code&gt; as &lt;code&gt;S99postgresql&lt;/code&gt;.</source>
          <target state="translated">Затем создайте на него символическую ссылку в &lt;code&gt;/etc/rc3.d&lt;/code&gt; как &lt;code&gt;S99postgresql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e196180497775135006d17c14fe064e7b2203578" translate="yes" xml:space="preserve">
          <source>Then, sign the request with the key to create a root certificate authority (using the default OpenSSL configuration file location on Linux):</source>
          <target state="translated">Затем подпишите запрос ключом для создания корневого центра сертификации (используя расположение файла конфигурации OpenSSL в Linux по умолчанию):</target>
        </trans-unit>
        <trans-unit id="50d0f1107bc900bc4a9d5405919a76e23f028a3e" translate="yes" xml:space="preserve">
          <source>There also exist local objects that do not belong to schemas; some examples are &lt;a href=&quot;glossary#GLOSSARY-EXTENSION&quot;&gt;extensions&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-CAST&quot;&gt;data type casts&lt;/a&gt;, and &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrappers&lt;/a&gt;. The names of such objects of the same type are enforced to be unique within the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5100635bf226727d046c206be142bf5ea8b71db2" translate="yes" xml:space="preserve">
          <source>There are a few built-in trigger functions that can be used to solve common problems without having to write your own trigger code; see &lt;a href=&quot;https://www.postgresql.org/docs/13/functions-trigger.html&quot;&gt;Section 9.28&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6f711b66bbac69a2f23c2445e625c076269156" translate="yes" xml:space="preserve">
          <source>There are a few restrictions on operator names, however:</source>
          <target state="translated">Однако существует несколько ограничений на имена операторов:</target>
        </trans-unit>
        <trans-unit id="e06308b22446d8ff8a3bec464184e0db33a1b8e3" translate="yes" xml:space="preserve">
          <source>There are a few restrictions on your choice of name:</source>
          <target state="translated">Есть несколько ограничений на выбор имени:</target>
        </trans-unit>
        <trans-unit id="e38ec4f8f8d1c9acce491ad6d51f28d3688ffbf6" translate="yes" xml:space="preserve">
          <source>There are a few solutions that do not fit into the above categories:</source>
          <target state="translated">Есть несколько решений,которые не вписываются в вышеперечисленные категории:</target>
        </trans-unit>
        <trans-unit id="f2d4b5a4acbfddfda3fa8af2f47936fbae4e67b7" translate="yes" xml:space="preserve">
          <source>There are a few things to be careful about when adding trace macros to the C code:</source>
          <target state="translated">Есть несколько вещей,с которыми нужно быть осторожным при добавлении макросов трассировки в код C:</target>
        </trans-unit>
        <trans-unit id="30225d755151e996e06d97ca5afb06ce57185f7a" translate="yes" xml:space="preserve">
          <source>There are a few things you need to do to simplify importing CSV log files:</source>
          <target state="translated">Есть несколько вещей,которые необходимо сделать,чтобы упростить импорт лог-файлов CSV:</target>
        </trans-unit>
        <trans-unit id="86f7d5ba0c83b5c117ed409216f966f9d7eef72d" translate="yes" xml:space="preserve">
          <source>There are also additional types of conflict that can occur with Hot Standby. These conflicts are &lt;em&gt;hard conflicts&lt;/em&gt; in the sense that queries might need to be canceled and, in some cases, sessions disconnected to resolve them. The user is provided with several ways to handle these conflicts. Conflict cases include:</source>
          <target state="translated">Есть также дополнительные типы конфликтов, которые могут возникнуть при горячем резервировании. Эти конфликты являются &lt;em&gt;жесткими конфликтами&lt;/em&gt; в том смысле, что может потребоваться отменить запросы и, в некоторых случаях, отключить сеансы для их разрешения. Пользователю предоставляется несколько способов разрешения этих конфликтов. Случаи конфликта включают:</target>
        </trans-unit>
        <trans-unit id="080fe8c96ab19e790a2ea0bd30b8130c9a87b676" translate="yes" xml:space="preserve">
          <source>There are also some built-in operator classes besides the default ones:</source>
          <target state="translated">Кроме классов операторов по умолчанию,существуют также некоторые встроенные классы операторов:</target>
        </trans-unit>
        <trans-unit id="b8bbd8454471c92fa3e16174c667ec63b3cc9c3f" translate="yes" xml:space="preserve">
          <source>There are also some comparison predicates, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-PRED-TABLE&quot;&gt;Table 9.2&lt;/a&gt;. These behave much like operators, but have special syntax mandated by the SQL standard.</source>
          <target state="translated">Есть также несколько предикатов сравнения, как показано в &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-PRED-TABLE&quot;&gt;таблице 9.2&lt;/a&gt; . Они во многом похожи на операторы, но имеют специальный синтаксис, предписанный стандартом SQL.</target>
        </trans-unit>
        <trans-unit id="11f3ba822c528ebdfeb9746d393a7742a7d6e349" translate="yes" xml:space="preserve">
          <source>There are cases in which the actual and estimated values won't match up well, but nothing is really wrong. One such case occurs when plan node execution is stopped short by a &lt;code&gt;LIMIT&lt;/code&gt; or similar effect. For example, in the &lt;code&gt;LIMIT&lt;/code&gt; query we used before,</source>
          <target state="translated">Бывают случаи, когда фактические и расчетные значения не совпадают, но на самом деле все в порядке. Один из таких случаев происходит, когда выполнение узла плана прекращается из-за &lt;code&gt;LIMIT&lt;/code&gt; или аналогичного эффекта. Например, в запросе &lt;code&gt;LIMIT&lt;/code&gt; ,который мы использовали ранее,</target>
        </trans-unit>
        <trans-unit id="626c9a7674dab9b044bc50641f2a4b064da217a4" translate="yes" xml:space="preserve">
          <source>There are certain operations that hold critical locks and should therefore complete as quickly as possible. Cost-based vacuum delays do not occur during such operations. Therefore it is possible that the cost accumulates far higher than the specified limit. To avoid uselessly long delays in such cases, the actual delay is calculated as &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * &lt;code&gt;accumulated_balance&lt;/code&gt; / &lt;code&gt;vacuum_cost_limit&lt;/code&gt; with a maximum of &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * 4.</source>
          <target state="translated">Есть определенные операции, которые содержат критические блокировки и поэтому должны выполняться как можно быстрее. Во время таких операций не возникает связанных с затратами задержек с вакуумом. Следовательно, возможно, что стоимость будет намного выше указанного лимита. Чтобы избежать бесцельно длительные задержки в таких случаях, фактическая задержка рассчитывается как &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * &lt;code&gt;accumulated_balance&lt;/code&gt; / &lt;code&gt;vacuum_cost_limit&lt;/code&gt; с максимумом &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * 4.</target>
        </trans-unit>
        <trans-unit id="49623fffc3b27e386ddb0902bf870bdd64aa14c1" translate="yes" xml:space="preserve">
          <source>There are different kinds of privileges: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REFERENCES&lt;/code&gt;, &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;CONNECT&lt;/code&gt;, &lt;code&gt;TEMPORARY&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, and &lt;code&gt;USAGE&lt;/code&gt;. The privileges applicable to a particular object vary depending on the object's type (table, function, etc). More detail about the meanings of these privileges appears below. The following sections and chapters will also show you how these privileges are used.</source>
          <target state="translated">Существуют разные виды привилегий: &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; , &lt;code&gt;REFERENCES&lt;/code&gt; , &lt;code&gt;TRIGGER&lt;/code&gt; , &lt;code&gt;CREATE&lt;/code&gt; , &lt;code&gt;CONNECT&lt;/code&gt; , &lt;code&gt;TEMPORARY&lt;/code&gt; , &lt;code&gt;EXECUTE&lt;/code&gt; и &lt;code&gt;USAGE&lt;/code&gt; . Привилегии, применимые к конкретному объекту, зависят от типа объекта (таблица, функция и т. Д.). Более подробная информация о значениях этих привилегий представлена ​​ниже. Следующие разделы и главы также покажут вам, как используются эти привилегии.</target>
        </trans-unit>
        <trans-unit id="2f4c8f7302f72ae7897c7273dc4e0796366f4575" translate="yes" xml:space="preserve">
          <source>There are examples in &lt;code&gt;refint.example&lt;/code&gt;.</source>
          <target state="translated">Примеры есть в &lt;code&gt;refint.example&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e74d4a0a2f4513529b90fbecc5989b2ddcb617e4" translate="yes" xml:space="preserve">
          <source>There are five forms of &lt;code&gt;CREATE TYPE&lt;/code&gt;, as shown in the syntax synopsis above. They respectively create a &lt;em&gt;composite type&lt;/em&gt;, an &lt;em&gt;enum type&lt;/em&gt;, a &lt;em&gt;range type&lt;/em&gt;, a &lt;em&gt;base type&lt;/em&gt;, or a &lt;em&gt;shell type&lt;/em&gt;. The first four of these are discussed in turn below. A shell type is simply a placeholder for a type to be defined later; it is created by issuing &lt;code&gt;CREATE TYPE&lt;/code&gt; with no parameters except for the type name. Shell types are needed as forward references when creating range types and base types, as discussed in those sections.</source>
          <target state="translated">Существует пять форм &lt;code&gt;CREATE TYPE&lt;/code&gt; , как показано в синтаксисе выше. Они создают соответственно &lt;em&gt;составной тип&lt;/em&gt; , в &lt;em&gt;тип перечисления&lt;/em&gt; , а &lt;em&gt;тип диапазона&lt;/em&gt; , а &lt;em&gt;базовый тип&lt;/em&gt; , или &lt;em&gt;тип оболочки&lt;/em&gt; . Первые четыре из них по очереди обсуждаются ниже. Тип оболочки - это просто заполнитель для типа, который будет определен позже; он создается с помощью команды &lt;code&gt;CREATE TYPE&lt;/code&gt; без параметров, кроме имени типа. Типы оболочки необходимы в качестве прямых ссылок при создании типов диапазонов и базовых типов, как описано в этих разделах.</target>
        </trans-unit>
        <trans-unit id="6b159eaf60b6b4119e8b7cbd7a662966676f50a3" translate="yes" xml:space="preserve">
          <source>There are five methods that an index operator class for GiST must provide, and five that are optional. Correctness of the index is ensured by proper implementation of the &lt;code&gt;same&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; methods, while efficiency (size and speed) of the index will depend on the &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; methods. Two optional methods are &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;decompress&lt;/code&gt;, which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow PostgreSQL data type rules here, see about &lt;code&gt;varlena&lt;/code&gt; for variable sized data). If the tree's internal data type exists at the SQL level, the &lt;code&gt;STORAGE&lt;/code&gt; option of the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command can be used. The optional eighth method is &lt;code&gt;distance&lt;/code&gt;, which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method &lt;code&gt;fetch&lt;/code&gt; is needed if the operator class wishes to support index-only scans, except when the &lt;code&gt;compress&lt;/code&gt; method is omitted. The optional tenth method &lt;code&gt;options&lt;/code&gt; is needed if the operator class provides the user-specified parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c0e123011cea9ffa5e9167dd8e734710858d21" translate="yes" xml:space="preserve">
          <source>There are five methods that an index operator class for GiST must provide, and four that are optional. Correctness of the index is ensured by proper implementation of the &lt;code&gt;same&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; methods, while efficiency (size and speed) of the index will depend on the &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; methods. Two optional methods are &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;decompress&lt;/code&gt;, which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow PostgreSQL data type rules here, see about &lt;code&gt;varlena&lt;/code&gt; for variable sized data). If the tree's internal data type exists at the SQL level, the &lt;code&gt;STORAGE&lt;/code&gt; option of the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command can be used. The optional eighth method is &lt;code&gt;distance&lt;/code&gt;, which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method &lt;code&gt;fetch&lt;/code&gt; is needed if the operator class wishes to support index-only scans, except when the &lt;code&gt;compress&lt;/code&gt; method is omitted.</source>
          <target state="translated">Есть пять методов, которые должен предоставить класс операторов индекса для GiST, и четыре необязательных. Корректность индекса обеспечивается за счет надлежащего осуществления &lt;code&gt;same&lt;/code&gt; , &lt;code&gt;consistent&lt;/code&gt; и &lt;code&gt;union&lt;/code&gt; методов, в то время как эффективность (размер и скорость) индекса будет зависеть от &lt;code&gt;penalty&lt;/code&gt; и &lt;code&gt;picksplit&lt;/code&gt; методов. Двумя дополнительными методами являются &lt;code&gt;compress&lt;/code&gt; и &lt;code&gt;decompress&lt;/code&gt; , которые позволяют индексу иметь внутренние данные дерева другого типа, чем данные, которые он индексирует. Листья должны относиться к индексированному типу данных, в то время как другие узлы дерева могут относиться к любой структуре C (но вам все равно придется следовать правилам типов данных PostgreSQL, см. О &lt;code&gt;varlena&lt;/code&gt; для данных переменного размера). Если внутренний тип данных дерева существует на уровне SQL, можно использовать параметр &lt;code&gt;STORAGE&lt;/code&gt; команды &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; . Необязательный восьмой метод - это &lt;code&gt;distance&lt;/code&gt; , которое необходимо, если класс оператора желает поддерживать упорядоченное сканирование (поиск ближайшего соседа). Необязательная &lt;code&gt;fetch&lt;/code&gt; девятого метода необходима, если класс оператора хочет поддерживать сканирование только по индексу, за исключением случаев, когда метод &lt;code&gt;compress&lt;/code&gt; опущен.</target>
        </trans-unit>
        <trans-unit id="29e9f9add6de4117c3f41e8f16d45114f4cd168c" translate="yes" xml:space="preserve">
          <source>There are five user-defined methods that an index operator class for SP-GiST must provide, and one is optional. All five mandatory methods follow the convention of accepting two &lt;code&gt;internal&lt;/code&gt; arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the mandatory methods just return &lt;code&gt;void&lt;/code&gt;, since all their results appear in the output struct; but &lt;code&gt;leaf_consistent&lt;/code&gt; additionally returns a &lt;code&gt;boolean&lt;/code&gt; result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method. The optional sixth method &lt;code&gt;compress&lt;/code&gt; accepts datum to be indexed as the only argument and returns a value suitable for physical storage in a leaf tuple.</source>
          <target state="translated">Есть пять определяемых пользователем методов, которые должен предоставлять класс операторов индекса для SP-GiST, и один из них является необязательным. Все пять обязательных методов следуют соглашению о принятии двух &lt;code&gt;internal&lt;/code&gt; аргументов, первый из которых является указателем на структуру C, содержащую входные значения для метода поддержки, а второй аргумент является указателем на структуру C, в которую должны быть помещены выходные значения. Четыре обязательных метода просто возвращают &lt;code&gt;void&lt;/code&gt; , поскольку все их результаты появляются в выходной структуре; но &lt;code&gt;leaf_consistent&lt;/code&gt; дополнительно возвращает &lt;code&gt;boolean&lt;/code&gt; результат. Методы не должны изменять какие-либо поля своих структур ввода. Во всех случаях структура вывода инициализируется нулями перед вызовом пользовательского метода. Необязательный шестой метод &lt;code&gt;compress&lt;/code&gt; принимает данные для индексации в качестве единственного аргумента и возвращает значение, подходящее для физического хранения в листовом кортеже.</target>
        </trans-unit>
        <trans-unit id="666f4f8fef47bb1c6205d9fa4aaa2bdc7c54c92a" translate="yes" xml:space="preserve">
          <source>There are five user-defined methods that an index operator class for SP-GiST must provide, and two are optional. All five mandatory methods follow the convention of accepting two &lt;code&gt;internal&lt;/code&gt; arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the mandatory methods just return &lt;code&gt;void&lt;/code&gt;, since all their results appear in the output struct; but &lt;code&gt;leaf_consistent&lt;/code&gt; returns a &lt;code&gt;boolean&lt;/code&gt; result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method. The optional sixth method &lt;code&gt;compress&lt;/code&gt; accepts a &lt;code&gt;datum&lt;/code&gt; to be indexed as the only argument and returns a value suitable for physical storage in a leaf tuple. The optional seventh method &lt;code&gt;options&lt;/code&gt; accepts an &lt;code&gt;internal&lt;/code&gt; pointer to a C struct, where opclass-specific parameters should be placed, and returns &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa03941817da7215f34f7c4059988c3830f85876" translate="yes" xml:space="preserve">
          <source>There are four fundamental SQL constructs requiring distinct type conversion rules in the PostgreSQL parser:</source>
          <target state="translated">В парсере PostgreSQL есть четыре фундаментальных SQL-конструкции,для которых требуются различные правила приведения типов:</target>
        </trans-unit>
        <trans-unit id="af078d5f8f920b3bd3ff699db4f54f596acf2a85" translate="yes" xml:space="preserve">
          <source>There are four methods that an operator class for BRIN must provide:</source>
          <target state="translated">Есть четыре метода,которые должен предоставить класс оператора для BRIN:</target>
        </trans-unit>
        <trans-unit id="dc37bd22ec5c580834570b2476e6fe4f24b8403a" translate="yes" xml:space="preserve">
          <source>There are minor differences in the interpretation of regular expression patterns used in &lt;code&gt;like_regex&lt;/code&gt; filters, as described in &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.15.2.2&lt;/a&gt;.</source>
          <target state="translated">Существуют незначительные различия в интерпретации шаблонов регулярных выражений, используемых в фильтрах &lt;code&gt;like_regex&lt;/code&gt; , как описано в &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Разделе 9.15.2.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d77bf2fc4587de107eca9fd91e0707c3fe21d0a" translate="yes" xml:space="preserve">
          <source>There are minor differences in the interpretation of regular expression patterns used in &lt;code&gt;like_regex&lt;/code&gt; filters, as described in &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.16.2.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d1e6b157368edb7a34c08bf06a60ee5f8744e9" translate="yes" xml:space="preserve">
          <source>There are not currently any commands that manipulate procedural language templates; to change the built-in information, a superuser must modify the table using ordinary &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;UPDATE&lt;/code&gt; commands.</source>
          <target state="translated">В настоящее время нет команд, управляющих шаблонами процедурного языка; чтобы изменить встроенную информацию, суперпользователь должен изменить таблицу с помощью обычных команд &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b7b9a654dddbbbf44432092fdfff639afd65c3" translate="yes" xml:space="preserve">
          <source>There are parallel variants of these operators for both the &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; types. The field/element/path extraction operators return the same type as their left-hand input (either &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;), except for those specified as returning &lt;code&gt;text&lt;/code&gt;, which coerce the value to text. The field/element/path extraction operators return NULL, rather than failing, if the JSON input does not have the right structure to match the request; for example if no such element exists. The field/element/path extraction operators that accept integer JSON array subscripts all support negative subscripting from the end of arrays.</source>
          <target state="translated">Существуют параллельные варианты этих операторов как для типов &lt;code&gt;json&lt;/code&gt; ,так и для &lt;code&gt;jsonb&lt;/code&gt; . Операторы извлечения поля / элемента / пути возвращают тот же тип, что и их левый ввод ( &lt;code&gt;json&lt;/code&gt; или &lt;code&gt;jsonb&lt;/code&gt; ), за исключением тех, которые указаны как возвращаемый &lt;code&gt;text&lt;/code&gt; , которые преобразуют значение в текст. Операторы извлечения поля / элемента / пути возвращают NULL, а не терпят неудачу, если входной файл JSON не имеет правильной структуры, соответствующей запросу; например, если такого элемента не существует. Все операторы извлечения поля / элемента / пути, которые принимают целочисленные индексы массива JSON, поддерживают отрицательные индексы с конца массивов.</target>
        </trans-unit>
        <trans-unit id="f87d9a17505cfd4cb8b88d986ea842eb4469f8b6" translate="yes" xml:space="preserve">
          <source>There are several &lt;code&gt;substr&lt;/code&gt; functions, one of which takes types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;. If called with a string constant of unspecified type, the system chooses the candidate function that accepts an argument of the preferred category &lt;code&gt;string&lt;/code&gt; (namely of type &lt;code&gt;text&lt;/code&gt;).</source>
          <target state="translated">Есть несколько функций &lt;code&gt;substr&lt;/code&gt; , одна из которых принимает типы &lt;code&gt;text&lt;/code&gt; и &lt;code&gt;integer&lt;/code&gt; . Если вызывается со строковой константой неопределенного типа, система выбирает функцию-кандидат, которая принимает аргумент &lt;code&gt;string&lt;/code&gt; предпочтительной категории (а именно &lt;code&gt;text&lt;/code&gt; типа ).</target>
        </trans-unit>
        <trans-unit id="4a86c45854efa996c6173d14634a86acbb0fae9b" translate="yes" xml:space="preserve">
          <source>There are several WAL-related configuration parameters that affect database performance. This section explains their use. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for general information about setting server configuration parameters.</source>
          <target state="translated">Есть несколько параметров конфигурации, связанных с WAL, которые влияют на производительность базы данных. В этом разделе объясняется их использование. Обратитесь к &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Главе 19&lt;/a&gt; для получения общей информации о настройке параметров конфигурации сервера.</target>
        </trans-unit>
        <trans-unit id="b72e63e0c980adc25f0dbe77097459ea5e3e677a" translate="yes" xml:space="preserve">
          <source>There are several WAL-related configuration parameters that affect database performance. This section explains their use. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for general information about setting server configuration parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a47baf0edabbb7ab4de9adfe99efaea9932730" translate="yes" xml:space="preserve">
          <source>There are several caveats to be aware of when using this option. Only one index name can be specified, and the &lt;code&gt;CASCADE&lt;/code&gt; option is not supported. (Thus, an index that supports a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint cannot be dropped this way.) Also, regular &lt;code&gt;DROP INDEX&lt;/code&gt; commands can be performed within a transaction block, but &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; cannot.</source>
          <target state="translated">При использовании этой опции следует помнить о нескольких предостережениях. Можно указать только одно имя индекса, опция &lt;code&gt;CASCADE&lt;/code&gt; не поддерживается. (Таким образом, индекс, который поддерживает ограничение &lt;code&gt;UNIQUE&lt;/code&gt; или &lt;code&gt;PRIMARY KEY&lt;/code&gt; , не может быть отброшен таким образом.) Кроме того, обычные команды &lt;code&gt;DROP INDEX&lt;/code&gt; могут выполняться в блоке транзакции, а &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="ce288b97182be46ed306ba70355423aaea68f94a" translate="yes" xml:space="preserve">
          <source>There are several caveats to be aware of when using this option. Only one index name can be specified, and the &lt;code&gt;CASCADE&lt;/code&gt; option is not supported. (Thus, an index that supports a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint cannot be dropped this way.) Also, regular &lt;code&gt;DROP INDEX&lt;/code&gt; commands can be performed within a transaction block, but &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; cannot. Lastly, indexes on partitioned tables cannot be dropped using this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91dcaac9ead3b10f651956a96badf0ae2f79aa1a" translate="yes" xml:space="preserve">
          <source>There are several common reasons the server might fail to start. Check the server's log file, or start it by hand (without redirecting standard output or standard error) and see what error messages appear. Below we explain some of the most common error messages in more detail.</source>
          <target state="translated">Есть несколько распространенных причин,по которым сервер может не запуститься.Проверьте лог-файл сервера или запустите его вручную (без перенаправления стандартного вывода или стандартной ошибки)и посмотрите,какие сообщения об ошибках появляются.Ниже мы более подробно объясним некоторые из наиболее распространенных сообщений об ошибках.</target>
        </trans-unit>
        <trans-unit id="9adbaa62a8322d6f35b205f33d65aadeb73701d5" translate="yes" xml:space="preserve">
          <source>There are several configuration parameters that control the behavior of &lt;code&gt;auto_explain&lt;/code&gt;. Note that the default behavior is to do nothing, so you must set at least &lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; if you want any results.</source>
          <target state="translated">Есть несколько параметров конфигурации, которые управляют поведением &lt;code&gt;auto_explain&lt;/code&gt; . Обратите внимание, что поведение по умолчанию - ничего не делать, поэтому вы должны установить как минимум &lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; , если вы хотите получить какие-либо результаты.</target>
        </trans-unit>
        <trans-unit id="d56877000af0d37b6fb862a08aad3882b83fec73" translate="yes" xml:space="preserve">
          <source>There are several distinct types of lockable objects: whole relations (e.g., tables), individual pages of relations, individual tuples of relations, transaction IDs (both virtual and permanent IDs), and general database objects (identified by class OID and object OID, in the same way as in &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_depend&lt;/code&gt;). Also, the right to extend a relation is represented as a separate lockable object, as is the right to update &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datfrozenxid&lt;/code&gt;. Also, &amp;ldquo;advisory&amp;rdquo; locks can be taken on numbers that have user-defined meanings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f07db15d474ec8167b00bf77d56e7101e3f26c7" translate="yes" xml:space="preserve">
          <source>There are several distinct types of lockable objects: whole relations (e.g., tables), individual pages of relations, individual tuples of relations, transaction IDs (both virtual and permanent IDs), and general database objects (identified by class OID and object OID, in the same way as in &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_depend&lt;/code&gt;). Also, the right to extend a relation is represented as a separate lockable object. Also, &amp;ldquo;advisory&amp;rdquo; locks can be taken on numbers that have user-defined meanings.</source>
          <target state="translated">Существует несколько различных типов блокируемых объектов: целые отношения (например, таблицы), отдельные страницы отношений, отдельные кортежи отношений, идентификаторы транзакций (как виртуальные, так и постоянные идентификаторы) и общие объекты базы данных (идентифицируемые по OID класса и OID объекта, так же, как в &lt;code&gt;pg_description&lt;/code&gt; или &lt;code&gt;pg_depend&lt;/code&gt; ). Кроме того, право на расширение отношения представлено как отдельный блокируемый объект. Кроме того, &amp;laquo;рекомендательные&amp;raquo; блокировки могут применяться к числам, которые имеют определенное пользователем значение.</target>
        </trans-unit>
        <trans-unit id="114cb14410efa6f2de15cd3a5be68d31fc1e555a" translate="yes" xml:space="preserve">
          <source>There are several limitations of Hot Standby. These can and probably will be fixed in future releases:</source>
          <target state="translated">Есть несколько ограничений Горячего резерва.Они могут и,возможно,будут исправлены в будущих релизах:</target>
        </trans-unit>
        <trans-unit id="faced4b79c9138d3cc4676d1e4253b24407642f4" translate="yes" xml:space="preserve">
          <source>There are several modifiers that can be put at the end of a non-star &lt;code&gt;lquery&lt;/code&gt; item to make it match more than just the exact match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6c3965c75b70506035e1130db0d24734cc5245" translate="yes" xml:space="preserve">
          <source>There are several modifiers that can be put at the end of a non-star label in &lt;code&gt;lquery&lt;/code&gt; to make it match more than just the exact match:</source>
          <target state="translated">Есть несколько модификаторов, которые можно поставить в конце метки без звездочки в &lt;code&gt;lquery&lt;/code&gt; чтобы она соответствовала не только точному совпадению:</target>
        </trans-unit>
        <trans-unit id="c65cdf0a50b535370cafd7a5d8814b1949feb7fa" translate="yes" xml:space="preserve">
          <source>There are several password-based authentication methods. These methods operate similarly but differ in how the users' passwords are stored on the server and how the password provided by a client is sent across the connection.</source>
          <target state="translated">Существует несколько методов аутентификации на основе пароля.Эти методы работают одинаково,но различаются тем,как пароли пользователей хранятся на сервере,и тем,как пароль,предоставленный клиентом,пересылается по соединению.</target>
        </trans-unit>
        <trans-unit id="82697895b0fc3864eed5346e0a502ff9ce90f8b6" translate="yes" xml:space="preserve">
          <source>There are several possible values of &lt;code&gt;context&lt;/code&gt;. In order of decreasing difficulty of changing the setting, they are:</source>
          <target state="translated">Есть несколько возможных значений &lt;code&gt;context&lt;/code&gt; . В порядке уменьшения сложности изменения настройки это:</target>
        </trans-unit>
        <trans-unit id="412101ab8ec853191b9bda2fa3098ca1192d7103" translate="yes" xml:space="preserve">
          <source>There are several reasons why one might want to use schemas:</source>
          <target state="translated">Есть несколько причин,по которым можно использовать схемы:</target>
        </trans-unit>
        <trans-unit id="47ec670ad87a5a65f5d73f50b758515c8d78f032" translate="yes" xml:space="preserve">
          <source>There are several settings which can cause the query planner not to generate a parallel query plan under any circumstances. In order for any parallel query plans whatsoever to be generated, the following settings must be configured as indicated.</source>
          <target state="translated">Существует несколько настроек,которые могут привести к тому,что планировщик запросов ни при каких обстоятельствах не будет генерировать параллельный план запросов.Для того чтобы сгенерировать любые планы параллельных запросов,необходимо настроить следующие параметры,как указано ниже.</target>
        </trans-unit>
        <trans-unit id="4a490c0d4b72a8988d006fa28baad623b333c2c3" translate="yes" xml:space="preserve">
          <source>There are several ways around this problem. One simple answer is to use &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; in sub-&lt;code&gt;SELECT&lt;/code&gt;s in row security policies. However, that requires granting &lt;code&gt;UPDATE&lt;/code&gt; privilege on the referenced table (here &lt;code&gt;users&lt;/code&gt;) to the affected users, which might be undesirable. (But another row security policy could be applied to prevent them from actually exercising that privilege; or the sub-&lt;code&gt;SELECT&lt;/code&gt; could be embedded into a security definer function.) Also, heavy concurrent use of row share locks on the referenced table could pose a performance problem, especially if updates of it are frequent. Another solution, practical if updates of the referenced table are infrequent, is to take an exclusive lock on the referenced table when updating it, so that no concurrent transactions could be examining old row values. Or one could just wait for all concurrent transactions to end after committing an update of the referenced table and before making changes that rely on the new security situation.</source>
          <target state="translated">Есть несколько способов обойти эту проблему. Один простой ответ - использовать &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; в подпрограммах &lt;code&gt;SELECT&lt;/code&gt; в политиках безопасности строк. Однако для этого требуется предоставить затронутым пользователям привилегию &lt;code&gt;UPDATE&lt;/code&gt; для указанной таблицы (здесь &lt;code&gt;users&lt;/code&gt; ), что может быть нежелательно. (Но может быть применена другая политика безопасности строк, чтобы предотвратить их фактическое использование этой привилегии; или вложенный &lt;code&gt;SELECT&lt;/code&gt; может быть встроен в функцию определения безопасности.) Кроме того, интенсивное одновременное использование блокировок совместного использования строк в указанной таблице может вызвать проблемы с производительностью, особенно если ее обновления часты. Другое решение, практичное, если обновления указанной таблицы происходят нечасто, состоит в том, чтобы принять исключительную блокировку указанной таблицы при ее обновлении, чтобы никакие параллельные транзакции не могли проверять старые значения строк. Или можно просто дождаться завершения всех параллельных транзакций после фиксации обновления указанной таблицы и перед внесением изменений, которые зависят от новой ситуации безопасности.</target>
        </trans-unit>
        <trans-unit id="78c41a8baf3f45e2e246f13ef8df748fedf21ff4" translate="yes" xml:space="preserve">
          <source>There are several ways to shut down the database server. Under the hood, they all reduce to sending a signal to the supervisor &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a65d46642b8ea0d625c08a9a29af3d8886f49e2" translate="yes" xml:space="preserve">
          <source>There are several ways to shut down the database server. You control the type of shutdown by sending different signals to the master &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">Есть несколько способов выключить сервер базы данных. Вы управляете типом завершения работы, отправляя различные сигналы &lt;code&gt;postgres&lt;/code&gt; процессу postgres .</target>
        </trans-unit>
        <trans-unit id="f2aaff5fcb38efacb1d58514b7509e951bb1187c" translate="yes" xml:space="preserve">
          <source>There are some basic assumptions that a btree operator family must satisfy:</source>
          <target state="translated">Существуют некоторые основные допущения,которым должно удовлетворять семейство операторов btree:</target>
        </trans-unit>
        <trans-unit id="0b521cdf532a9a953ad42c30cbfbc097cf6b1b08" translate="yes" xml:space="preserve">
          <source>There are three available prewarming methods. &lt;code&gt;prefetch&lt;/code&gt; issues asynchronous prefetch requests to the operating system, if this is supported, or throws an error otherwise. &lt;code&gt;read&lt;/code&gt; reads the requested range of blocks; unlike &lt;code&gt;prefetch&lt;/code&gt;, this is synchronous and supported on all platforms and builds, but may be slower. &lt;code&gt;buffer&lt;/code&gt; reads the requested range of blocks into the database buffer cache.</source>
          <target state="translated">Есть три доступных метода предварительного подогрева. &lt;code&gt;prefetch&lt;/code&gt; выдает асинхронные запросы предварительной выборки к операционной системе, если это поддерживается, или выдает ошибку в противном случае. &lt;code&gt;read&lt;/code&gt; читает запрошенный диапазон блоков; в отличие от &lt;code&gt;prefetch&lt;/code&gt; , это синхронно и поддерживается на всех платформах и сборках, но может быть медленнее. &lt;code&gt;buffer&lt;/code&gt; считывает запрошенный диапазон блоков в буферный кеш базы данных.</target>
        </trans-unit>
        <trans-unit id="cb805126a31ff8c55ee475c5fbc01109be8dd511" translate="yes" xml:space="preserve">
          <source>There are three kinds of &lt;em&gt;implicitly-typed constants&lt;/em&gt; in PostgreSQL: strings, bit strings, and numbers. Constants can also be specified with explicit types, which can enable more accurate representation and more efficient handling by the system. These alternatives are discussed in the following subsections.</source>
          <target state="translated">В PostgreSQL есть три вида &lt;em&gt;констант с неявной типизацией&lt;/em&gt; : строки, битовые строки и числа. Константы также могут быть указаны с явными типами, что может обеспечить более точное представление и более эффективную обработку системой. Эти альтернативы обсуждаются в следующих подразделах.</target>
        </trans-unit>
        <trans-unit id="30766d90eb25e2981c2e600b788f88cc0665cda4" translate="yes" xml:space="preserve">
          <source>There are three possible syntaxes for an operator invocation:</source>
          <target state="translated">Существует три возможных синтаксиса для вызова оператора:</target>
        </trans-unit>
        <trans-unit id="7ac1c9045fce554fb04868e602b7a9908c87947d" translate="yes" xml:space="preserve">
          <source>There are three separate approaches to pattern matching provided by PostgreSQL: the traditional SQL &lt;code&gt;LIKE&lt;/code&gt; operator, the more recent &lt;code&gt;SIMILAR TO&lt;/code&gt; operator (added in SQL:1999), and POSIX-style regular expressions. Aside from the basic &amp;ldquo;does this string match this pattern?&amp;rdquo; operators, functions are available to extract or replace matching substrings and to split a string at matching locations.</source>
          <target state="translated">В PostgreSQL есть три отдельных подхода к сопоставлению с образцом: традиционный оператор SQL &lt;code&gt;LIKE&lt;/code&gt; , последний оператор &lt;code&gt;SIMILAR TO&lt;/code&gt; (добавлен в SQL: 1999) и регулярные выражения в стиле POSIX. Помимо основного &amp;laquo;Соответствует ли эта строка этому шаблону?&amp;raquo; операторы, функции доступны для извлечения или замены совпадающих подстрок и для разделения строки в совпадающих местах.</target>
        </trans-unit>
        <trans-unit id="c74bdd55156d3b2783c8a6fd237fe0bceb9cfeef" translate="yes" xml:space="preserve">
          <source>There are two approaches to enforce that users provide a certificate during login.</source>
          <target state="translated">Существует два подхода к обеспечению того,чтобы пользователи предоставляли сертификат во время входа в систему.</target>
        </trans-unit>
        <trans-unit id="03a8c876ced91bb81f55235d3d3af76552bcc675" translate="yes" xml:space="preserve">
          <source>There are two categories of limitation to keep in mind: the restriction from XQuery to XPath for the functions specified in the SQL standard, and the restriction of XPath to version 1.0 for both the standard and the PostgreSQL-specific functions.</source>
          <target state="translated">Существует две категории ограничений,которые следует помнить:ограничение от XQuery до XPath для функций,указанных в стандарте SQL,и ограничение XPath до версии 1.0 как для стандартных функций,так и для функций,специфичных для PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="45979291689bf78b7c41886076f2033f33bb0dc2" translate="yes" xml:space="preserve">
          <source>There are two columns containing the city name. This is correct because the lists of columns from the &lt;code&gt;weather&lt;/code&gt; and &lt;code&gt;cities&lt;/code&gt; tables are concatenated. In practice this is undesirable, though, so you will probably want to list the output columns explicitly rather than using &lt;code&gt;*&lt;/code&gt;:</source>
          <target state="translated">Есть две колонки, содержащие название города. Это правильно, потому что списки столбцов из таблиц &lt;code&gt;weather&lt;/code&gt; и &lt;code&gt;cities&lt;/code&gt; объединены. Однако на практике это нежелательно, поэтому вы, вероятно, захотите явно указать выходные столбцы, а не использовать &lt;code&gt;*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="65ab8b09fb62c8b1237a292bc36db36c5b33b77b" translate="yes" xml:space="preserve">
          <source>There are two commonly used internal WAL functions: &lt;code&gt;XLogInsertRecord&lt;/code&gt; and &lt;code&gt;XLogFlush&lt;/code&gt;. &lt;code&gt;XLogInsertRecord&lt;/code&gt; is used to place a new record into the WAL buffers in shared memory. If there is no space for the new record, &lt;code&gt;XLogInsertRecord&lt;/code&gt; will have to write (move to kernel cache) a few filled WAL buffers. This is undesirable because &lt;code&gt;XLogInsertRecord&lt;/code&gt; is used on every database low level modification (for example, row insertion) at a time when an exclusive lock is held on affected data pages, so the operation needs to be as fast as possible. What is worse, writing WAL buffers might also force the creation of a new log segment, which takes even more time. Normally, WAL buffers should be written and flushed by an &lt;code&gt;XLogFlush&lt;/code&gt; request, which is made, for the most part, at transaction commit time to ensure that transaction records are flushed to permanent storage. On systems with high log output, &lt;code&gt;XLogFlush&lt;/code&gt; requests might not occur often enough to prevent &lt;code&gt;XLogInsertRecord&lt;/code&gt; from having to do writes. On such systems one should increase the number of WAL buffers by modifying the &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; parameter. When &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is set and the system is very busy, setting &lt;code&gt;wal_buffers&lt;/code&gt; higher will help smooth response times during the period immediately following each checkpoint.</source>
          <target state="translated">Обычно используются две внутренние функции WAL: &lt;code&gt;XLogInsertRecord&lt;/code&gt; и &lt;code&gt;XLogFlush&lt;/code&gt; . &lt;code&gt;XLogInsertRecord&lt;/code&gt; используется для помещения новой записи в буферы WAL в общей памяти. Если для новой записи нет места, &lt;code&gt;XLogInsertRecord&lt;/code&gt; должен будет записать (переместить в кэш ядра) несколько заполненных буферов WAL. Это нежелательно, потому что &lt;code&gt;XLogInsertRecord&lt;/code&gt; используется при каждой модификации низкого уровня базы данных (например, при вставке строки) в то время, когда на затронутых страницах данных удерживается монопольная блокировка, поэтому операция должна быть как можно быстрее. Что еще хуже, запись буферов WAL может также вызвать создание нового сегмента журнала, что займет еще больше времени. Обычно буферы WAL должны записываться и сбрасываться &lt;code&gt;XLogFlush&lt;/code&gt; , который по большей части выполняется во время фиксации транзакции, чтобы гарантировать, что записи транзакции будут сброшены в постоянное хранилище. В системах с большим объемом вывода &lt;code&gt;XLogFlush&lt;/code&gt; запросы XLogFlush могут происходить недостаточно часто, чтобы &lt;code&gt;XLogInsertRecord&lt;/code&gt; не выполнял записи. В таких системах необходимо увеличить количество буферов WAL, изменив параметр &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; . Когда установлен &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; и система очень занята, установка &lt;code&gt;wal_buffers&lt;/code&gt; высокого значения wal_buffers поможет сгладить время отклика в течение периода, следующего сразу после каждой контрольной точки.</target>
        </trans-unit>
        <trans-unit id="1612227459001e258e7447e0effe46078acfe3e4" translate="yes" xml:space="preserve">
          <source>There are two differences in the behavior of &lt;code&gt;string_to_array&lt;/code&gt; from pre-9.1 versions of PostgreSQL. First, it will return an empty (zero-element) array rather than &lt;code&gt;NULL&lt;/code&gt; when the input string is of zero length. Second, if the delimiter string is &lt;code&gt;NULL&lt;/code&gt;, the function splits the input into individual characters, rather than returning &lt;code&gt;NULL&lt;/code&gt; as before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e556036ec4c364c079311c21d04103cf4c7118b6" translate="yes" xml:space="preserve">
          <source>There are two differences in the behavior of &lt;code&gt;string_to_array&lt;/code&gt; from pre-9.1 versions of PostgreSQL. First, it will return an empty (zero-element) array rather than NULL when the input string is of zero length. Second, if the delimiter string is NULL, the function splits the input into individual characters, rather than returning NULL as before.</source>
          <target state="translated">Есть два отличия в поведении &lt;code&gt;string_to_array&lt;/code&gt; от версий PostgreSQL до 9.1. Во-первых, он вернет пустой (безэлементный) массив, а не NULL, если входная строка имеет нулевую длину. Во-вторых, если строка-разделитель NULL, функция разбивает ввод на отдельные символы, а не возвращает NULL, как раньше.</target>
        </trans-unit>
        <trans-unit id="9a38ac647b826e47337bf978dbd260eda2d37e47" translate="yes" xml:space="preserve">
          <source>There are two forms of the &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command. In the first form, the user supplies just the name of the desired language, and the PostgreSQL server consults the &lt;a href=&quot;catalog-pg-pltemplate&quot;&gt;&lt;code&gt;pg_pltemplate&lt;/code&gt;&lt;/a&gt; system catalog to determine the correct parameters. In the second form, the user supplies the language parameters along with the language name. The second form can be used to create a language that is not defined in &lt;code&gt;pg_pltemplate&lt;/code&gt;, but this approach is considered obsolescent.</source>
          <target state="translated">Есть две формы команды &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; . В первой форме пользователь предоставляет только имя желаемого языка, а сервер PostgreSQL &lt;a href=&quot;catalog-pg-pltemplate&quot;&gt; &lt;code&gt;pg_pltemplate&lt;/code&gt; &lt;/a&gt; системному каталогу pg_pltemplate, чтобы определить правильные параметры. Во второй форме пользователь предоставляет языковые параметры вместе с названием языка. Вторая форма может использоваться для создания языка, который не определен в &lt;code&gt;pg_pltemplate&lt;/code&gt; , но такой подход считается устаревшим.</target>
        </trans-unit>
        <trans-unit id="f9cc8590527e484357685c3a4d915bc501e931e5" translate="yes" xml:space="preserve">
          <source>There are two kinds of indexes that can be used to speed up full text searches. Note that indexes are not mandatory for full text searching, but in cases where a column is searched on a regular basis, an index is usually desirable.</source>
          <target state="translated">Существует два типа индексов,которые могут быть использованы для ускорения полнотекстового поиска.Обратите внимание,что индексы не являются обязательными для полнотекстового поиска,но в тех случаях,когда поиск по столбцу производится регулярно,обычно желательно использовать индекс.</target>
        </trans-unit>
        <trans-unit id="0b78b765f97cf8944029e53f4ab00dc6de355959" translate="yes" xml:space="preserve">
          <source>There are two methods that an operator class for GIN must provide:</source>
          <target state="translated">Есть два метода,которые должен предоставить класс оператора для GIN:</target>
        </trans-unit>
        <trans-unit id="2ebcfbeecc8c9e28432149890e115326d408ee9d" translate="yes" xml:space="preserve">
          <source>There are two other fixed-length character types in PostgreSQL, shown in &lt;a href=&quot;datatype-character#DATATYPE-CHARACTER-SPECIAL-TABLE&quot;&gt;Table 8.5&lt;/a&gt;. The &lt;code&gt;name&lt;/code&gt; type exists &lt;em&gt;only&lt;/em&gt; for the storage of identifiers in the internal system catalogs and is not intended for use by the general user. Its length is currently defined as 64 bytes (63 usable characters plus terminator) but should be referenced using the constant &lt;code&gt;NAMEDATALEN&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; source code. The length is set at compile time (and is therefore adjustable for special uses); the default maximum length might change in a future release. The type &lt;code&gt;&quot;char&quot;&lt;/code&gt; (note the quotes) is different from &lt;code&gt;char(1)&lt;/code&gt; in that it only uses one byte of storage. It is internally used in the system catalogs as a simplistic enumeration type.</source>
          <target state="translated">В PostgreSQL есть два других символьных типа фиксированной длины, показанные в &lt;a href=&quot;datatype-character#DATATYPE-CHARACTER-SPECIAL-TABLE&quot;&gt;Таблице 8.5&lt;/a&gt; . Тип &lt;code&gt;name&lt;/code&gt; существует &lt;em&gt;только&lt;/em&gt; для хранения идентификаторов во внутренних каталогах системы и не предназначен для использования обычным пользователем. Его длина в настоящее время определена как 64 байта (63 используемых символа плюс терминатор), но на него следует ссылаться, используя константу &lt;code&gt;NAMEDATALEN&lt;/code&gt; в исходном коде &lt;code&gt;C&lt;/code&gt; . Длина устанавливается во время компиляции (и, следовательно, регулируется для особых случаев); максимальная длина по умолчанию может измениться в будущем выпуске. Тип &lt;code&gt;&quot;char&quot;&lt;/code&gt; (обратите внимание на кавычки) отличается от &lt;code&gt;char(1)&lt;/code&gt; в том, что он использует только один байт памяти. Он используется внутри системных каталогов как упрощенный тип перечисления.</target>
        </trans-unit>
        <trans-unit id="1a65ab8661e9c6e6250372b71f3e4d52aadd8690" translate="yes" xml:space="preserve">
          <source>There are two restrictions, however, which make this method impractical, or at least inferior to the pg_dump method:</source>
          <target state="translated">Однако есть два ограничения,которые делают этот метод непрактичным или,по крайней мере,уступающим методу pg_dump:</target>
        </trans-unit>
        <trans-unit id="eb559c725c45849ac1890ba81d8ba70c6affbb84" translate="yes" xml:space="preserve">
          <source>There are two significant ways in which run times measured by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; can deviate from normal execution of the same query. First, since no output rows are delivered to the client, network transmission costs and I/O conversion costs are not included. Second, the measurement overhead added by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; can be significant, especially on machines with slow &lt;code&gt;gettimeofday()&lt;/code&gt; operating-system calls. You can use the &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; tool to measure the overhead of timing on your system.</source>
          <target state="translated">Время выполнения, измеренное с помощью &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; , может отличаться от нормального выполнения одного и того же запроса двумя важными способами . Во-первых, поскольку никакие выходные строки не доставляются клиенту, затраты на передачу по сети и затраты на преобразование ввода-вывода не включаются. Во-вторых, накладные расходы на измерения, добавленные &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; , могут быть значительными, особенно на машинах с медленными &lt;code&gt;gettimeofday()&lt;/code&gt; операционной системы gettimeofday () . Вы можете использовать инструмент &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; , чтобы измерить накладные расходы времени в вашей системе.</target>
        </trans-unit>
        <trans-unit id="e4b4937b46d88bd048aae10c82ed3779adc47d2b" translate="yes" xml:space="preserve">
          <source>There are two special cases of bracket expressions: the bracket expressions &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; are constraints, matching empty strings at the beginning and end of a word respectively. A word is defined as a sequence of word characters that is neither preceded nor followed by word characters. A word character is an &lt;code&gt;alnum&lt;/code&gt; character (as defined by the POSIX character class described above) or an underscore. This is an extension, compatible with but not specified by POSIX 1003.2, and should be used with caution in software intended to be portable to other systems. The constraint escapes described below are usually preferable; they are no more standard, but are easier to type.</source>
          <target state="translated">Есть два особых случая выражений в квадратных скобках: выражения в квадратных скобках &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; и &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; являются ограничениями, соответствующими пустым строкам в начале и конце слова соответственно. Слово определяется как последовательность символов слова, которой не предшествуют и не следуют символы слова. Символ слова - это знак &lt;code&gt;alnum&lt;/code&gt; (как определено классом символов POSIX, описанный выше) или подчеркивание. Это расширение, совместимое с POSIX 1003.2, но не определенное в нем, и его следует использовать с осторожностью в программном обеспечении, предназначенном для переноса в другие системы. Обычно предпочтительны переходы от ограничений, описанные ниже; они больше не стандартные, но их легче печатать.</target>
        </trans-unit>
        <trans-unit id="33967632431b8aaf7d1ba8660310b5c4fbf05d2a" translate="yes" xml:space="preserve">
          <source>There are two variants of &lt;code&gt;VACUUM&lt;/code&gt;: standard &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;VACUUM FULL&lt;/code&gt;. &lt;code&gt;VACUUM FULL&lt;/code&gt; can reclaim more disk space but runs much more slowly. Also, the standard form of &lt;code&gt;VACUUM&lt;/code&gt; can run in parallel with production database operations. (Commands such as &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; will continue to function normally, though you will not be able to modify the definition of a table with commands such as &lt;code&gt;ALTER TABLE&lt;/code&gt; while it is being vacuumed.) &lt;code&gt;VACUUM FULL&lt;/code&gt; requires exclusive lock on the table it is working on, and therefore cannot be done in parallel with other use of the table. Generally, therefore, administrators should strive to use standard &lt;code&gt;VACUUM&lt;/code&gt; and avoid &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="translated">Существует два варианта &lt;code&gt;VACUUM&lt;/code&gt; : стандартный &lt;code&gt;VACUUM&lt;/code&gt; и &lt;code&gt;VACUUM FULL&lt;/code&gt; . &lt;code&gt;VACUUM FULL&lt;/code&gt; может освободить больше дискового пространства, но работает намного медленнее. Кроме того, стандартная форма &lt;code&gt;VACUUM&lt;/code&gt; может работать параллельно с операциями производственной базы данных. (Такие команды, как &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; будут продолжать работать нормально, хотя вы не сможете изменить определение таблицы с помощью таких команд, как &lt;code&gt;ALTER TABLE&lt;/code&gt; , пока она очищается.) &lt;code&gt;VACUUM FULL&lt;/code&gt; требует исключительной блокировки таблицы, над которой он работает, и поэтому не может выполняться параллельно с другим использованием таблицы. Поэтому, как правило, администраторы должны стремиться использовать стандартный &lt;code&gt;VACUUM&lt;/code&gt; и избегать &lt;code&gt;VACUUM FULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="082cbad2612b1a539364141256cd8c079fbdd04c" translate="yes" xml:space="preserve">
          <source>There are two ways to acquire an advisory lock in PostgreSQL: at session level or at transaction level. Once acquired at session level, an advisory lock is held until explicitly released or the session ends. Unlike standard lock requests, session-level advisory lock requests do not honor transaction semantics: a lock acquired during a transaction that is later rolled back will still be held following the rollback, and likewise an unlock is effective even if the calling transaction fails later. A lock can be acquired multiple times by its owning process; for each completed lock request there must be a corresponding unlock request before the lock is actually released. Transaction-level lock requests, on the other hand, behave more like regular lock requests: they are automatically released at the end of the transaction, and there is no explicit unlock operation. This behavior is often more convenient than the session-level behavior for short-term usage of an advisory lock. Session-level and transaction-level lock requests for the same advisory lock identifier will block each other in the expected way. If a session already holds a given advisory lock, additional requests by it will always succeed, even if other sessions are awaiting the lock; this statement is true regardless of whether the existing lock hold and new request are at session level or transaction level.</source>
          <target state="translated">Есть два способа получить консультативный замок в PostgreSQL:на уровне сессии или на уровне транзакции.После приобретения на уровне сессии,консультативная блокировка удерживается до тех пор,пока явно не будет освобождена или пока сессия не завершится.В отличие от стандартных запросов блокировки,запросы на блокировку на уровне сессии не учитывают семантику транзакции:блокировка,полученная во время транзакции,которая позже откатывается,все равно будет удерживаться после отката,а также разблокировка будет эффективной,даже если вызывающая транзакция не сможет выполнить свою задачу позже.Блокировка может быть приобретена несколько раз собственным процессом;для каждого завершенного запроса на блокировку должен существовать соответствующий запрос на разблокировку,прежде чем блокировка будет действительно снята.Запросы на блокировку на уровне транзакций,с другой стороны,ведут себя скорее как обычные запросы блокировки:они автоматически освобождаются в конце транзакции,а явной операции разблокировки не происходит.Такое поведение часто более удобно,чем поведение на уровне сессии при кратковременном использовании консультативной блокировки.Запросы на блокировку сеансового и транзакционного уровней для одного и того же идентификатора информационной блокировки будут блокировать друг друга ожидаемым образом.Если сессия уже содержит заданную консультативную блокировку,то дополнительные запросы от нее всегда будут успешными,даже если другие сессии ожидают блокировки;это утверждение верно вне зависимости от того,на уровне сессии или транзакции находится ли существующая блокировка и новый запрос.</target>
        </trans-unit>
        <trans-unit id="d918b8ea922c6c6ee662eb9ab4cebb7da36eb443" translate="yes" xml:space="preserve">
          <source>There are two ways to define constraints: table constraints and column constraints. A column constraint is defined as part of a column definition. A table constraint definition is not tied to a particular column, and it can encompass more than one column. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column.</source>
          <target state="translated">Существует два способа определения ограничений:ограничения таблиц и ограничений столбцов.Ограничение столбца определяется как часть определения столбца.Определение ограничения таблицы не привязывается к конкретной колонке и может включать более одной колонки.Ограничение каждой колонки также может быть записано как ограничение таблицы;ограничение колонки-это только нотационное удобство для использования,когда ограничение затрагивает только одну колонку.</target>
        </trans-unit>
        <trans-unit id="3100ad6baa7faf64044c5fff315dddab6008581f" translate="yes" xml:space="preserve">
          <source>There are two ways to delete rows in a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in the &lt;code&gt;USING&lt;/code&gt; clause. Which technique is more appropriate depends on the specific circumstances.</source>
          <target state="translated">Есть два способа удалить строки в таблице, используя информацию, содержащуюся в других таблицах в базе данных: с помощью вложенных выборок или путем указания дополнительных таблиц в предложении &lt;code&gt;USING&lt;/code&gt; . Какой метод более уместен, зависит от конкретных обстоятельств.</target>
        </trans-unit>
        <trans-unit id="9d2cb602ac946da832fb98a751bc210a74312a33" translate="yes" xml:space="preserve">
          <source>There are two ways to modify a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in the &lt;code&gt;FROM&lt;/code&gt; clause. Which technique is more appropriate depends on the specific circumstances.</source>
          <target state="translated">Есть два способа изменить таблицу, используя информацию, содержащуюся в других таблицах в базе данных: с помощью вложенных выборок или путем указания дополнительных таблиц в предложении &lt;code&gt;FROM&lt;/code&gt; . Какой метод более уместен, зависит от конкретных обстоятельств.</target>
        </trans-unit>
        <trans-unit id="aa2e4ae09129d50722332a9a349176e58b93478a" translate="yes" xml:space="preserve">
          <source>There are various shortcut commands for &lt;code&gt;\pset&lt;/code&gt;. See &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\H&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\T&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;\pset&lt;/code&gt; есть различные команды быстрого доступа . См. &lt;code&gt;\a&lt;/code&gt; &lt;code&gt;\C&lt;/code&gt; , \ C , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , &lt;code&gt;\T&lt;/code&gt; и &lt;code&gt;\x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36d44242f8d38cae700147e3f10ad23b2c1671f8" translate="yes" xml:space="preserve">
          <source>There are various special syntax rules and behaviors associated with composite types in queries. These rules provide useful shortcuts, but can be confusing if you don't know the logic behind them.</source>
          <target state="translated">Существуют различные специальные синтаксические правила и поведение,связанные с композитными типами в запросах.Эти правила предоставляют полезные ярлыки,но могут ввести в заблуждение,если вы не знаете логики,лежащей в их основе.</target>
        </trans-unit>
        <trans-unit id="adeaa568e81b8c22d184926d9648a6a85b174068" translate="yes" xml:space="preserve">
          <source>There can be multiple &lt;code&gt;pg_basebackup&lt;/code&gt;s running at the same time, but it is better from a performance point of view to take only one backup, and copy the result.</source>
          <target state="translated">&lt;code&gt;pg_basebackup&lt;/code&gt; может быть запущено несколько pg_basebackup , но с точки зрения производительности лучше сделать только одну резервную копию и скопировать результат.</target>
        </trans-unit>
        <trans-unit id="20d4685d4d3e4d67053c5be3bcdf1498541d87e6" translate="yes" xml:space="preserve">
          <source>There can be multiple &lt;code&gt;pg_basebackup&lt;/code&gt;s running at the same time, but it is usually better from a performance point of view to take only one backup, and copy the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241118165bea21fbe830bef68a27cbb0152bef40" translate="yes" xml:space="preserve">
          <source>There is a &amp;ldquo;simple&amp;rdquo; form of &lt;code&gt;CASE&lt;/code&gt; expression that is a variant of the general form above:</source>
          <target state="translated">Существует &amp;laquo;простая&amp;raquo; форма выражения &lt;code&gt;CASE&lt;/code&gt; , которая является вариантом общей формы выше:</target>
        </trans-unit>
        <trans-unit id="0a329b25f5c93a21ac5ea836673c784c6afc768a" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;CREATE COLLATION&lt;/code&gt; statement in the SQL standard, but it is limited to copying an existing collation. The syntax to create a new collation is a PostgreSQL extension.</source>
          <target state="translated">В стандарте SQL есть оператор &lt;code&gt;CREATE COLLATION&lt;/code&gt; , но он ограничен копированием существующего сопоставления. Синтаксис для создания нового сопоставления - это расширение PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="74c08b98f45942b4395776e7da22b84f7266e5c2" translate="yes" xml:space="preserve">
          <source>There is a catch if you try to use conditional rules for complex view updates: there &lt;em&gt;must&lt;/em&gt; be an unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rule for each action you wish to allow on the view. If the rule is conditional, or is not &lt;code&gt;INSTEAD&lt;/code&gt;, then the system will still reject attempts to perform the update action, because it thinks it might end up trying to perform the action on the dummy table of the view in some cases. If you want to handle all the useful cases in conditional rules, add an unconditional &lt;code&gt;DO INSTEAD NOTHING&lt;/code&gt; rule to ensure that the system understands it will never be called on to update the dummy table. Then make the conditional rules non-&lt;code&gt;INSTEAD&lt;/code&gt;; in the cases where they are applied, they add to the default &lt;code&gt;INSTEAD NOTHING&lt;/code&gt; action. (This method does not currently work to support &lt;code&gt;RETURNING&lt;/code&gt; queries, however.)</source>
          <target state="translated">Если вы пытаетесь использовать условные правила для сложных обновлений представления, есть загвоздка: &lt;em&gt;должно&lt;/em&gt; быть безусловное правило &lt;code&gt;INSTEAD&lt;/code&gt; для каждого действия, которое вы хотите разрешить для представления. Если правило является условным или не является &lt;code&gt;INSTEAD&lt;/code&gt; , тогда система все равно будет отклонять попытки выполнить действие обновления, потому что она думает, что в некоторых случаях она может в конечном итоге попытаться выполнить действие над фиктивной таблицей представления. Если вы хотите обрабатывать все полезные случаи в условных правилах, добавьте безусловное правило &lt;code&gt;DO INSTEAD NOTHING&lt;/code&gt; , чтобы убедиться, что система понимает, что она никогда не будет вызвана для обновления фиктивной таблицы. Затем сделайте условные правила не- &lt;code&gt;INSTEAD&lt;/code&gt; ; в тех случаях, когда они применяются, они добавляют к стандартному &lt;code&gt;INSTEAD NOTHING&lt;/code&gt; действия. (Однако этот метод в настоящее время не поддерживает запросы &lt;code&gt;RETURNING&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="c21f127ac29ffa6b6d6cad86ad16cb8ebd82f4c7" translate="yes" xml:space="preserve">
          <source>There is a limit on how many columns a table can contain. Depending on the column types, it is between 250 and 1600. However, defining a table with anywhere near this many columns is highly unusual and often a questionable design.</source>
          <target state="translated">Существует ограничение на количество столбцов в таблице.В зависимости от типов столбцов,это от 250 до 1600.Однако,определение таблицы с таким количеством столбцов является крайне необычным и часто сомнительным.</target>
        </trans-unit>
        <trans-unit id="60f67c0e3cf6c026c3a97cec11f99b88526b93a6" translate="yes" xml:space="preserve">
          <source>There is a more general version of the FOLLOWED BY operator having the form &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer standing for the difference between the positions of the matching lexemes. &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; is the same as &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, while &lt;code&gt;&amp;lt;2&amp;gt;&lt;/code&gt; allows exactly one other lexeme to appear between the matches, and so on. The &lt;code&gt;phraseto_tsquery&lt;/code&gt; function makes use of this operator to construct a &lt;code&gt;tsquery&lt;/code&gt; that can match a multi-word phrase when some of the words are stop words. For example:</source>
          <target state="translated">Существует более общая версия оператора FOLLOWED BY, имеющая форму &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; , где &lt;code&gt;N&lt;/code&gt; - целое число, обозначающее разницу между позициями совпадающих лексем. &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; - это то же самое, что и &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; , а &lt;code&gt;&amp;lt;2&amp;gt;&lt;/code&gt; позволяет использовать ровно одну другую лексему между совпадениями и т. Д. Функция &lt;code&gt;phraseto_tsquery&lt;/code&gt; использует этот оператор для создания &lt;code&gt;tsquery&lt;/code&gt; который может соответствовать фразе из нескольких слов, когда некоторые из слов являются стоп-словами. Например:</target>
        </trans-unit>
        <trans-unit id="98845715e9aff2aab5a7e45eba23b610067562bc" translate="yes" xml:space="preserve">
          <source>There is a possibility that a concurrent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; on the row being moved will get a serialization failure error. Suppose session 1 is performing an &lt;code&gt;UPDATE&lt;/code&gt; on a partition key, and meanwhile a concurrent session 2 for which this row is visible performs an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operation on this row. In such case, session 2's &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; will detect the row movement and raise a serialization failure error (which always returns with an SQLSTATE code '40001'). Applications may wish to retry the transaction if this occurs. In the usual case where the table is not partitioned, or where there is no row movement, session 2 would have identified the newly updated row and carried out the &lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt; on this new row version.</source>
          <target state="translated">Существует вероятность того, что одновременное &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; перемещаемой строки приведет к ошибке ошибки сериализации. Предположим, что сеанс 1 выполняет &lt;code&gt;UPDATE&lt;/code&gt; ключа раздела, а одновременный сеанс 2, для которого эта строка видна, выполняет операцию &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; для этой строки. В таком случае &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; сеанса 2обнаружит перемещение строки и вызовет ошибку сбоя сериализации (которая всегда возвращается с кодом SQLSTATE '40001'). В этом случае приложения могут пожелать повторить транзакцию. В обычном случае, когда таблица не секционирована или не происходит перемещения строк, сеанс 2 идентифицировал бы новую обновленную строку и выполнил &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; для этой новой версии строки.</target>
        </trans-unit>
        <trans-unit id="e2fb3023d52c67871f97870f963ae3e2511e1afd" translate="yes" xml:space="preserve">
          <source>There is a queue that holds notifications that have been sent but not yet processed by all listening sessions. If this queue becomes full, transactions calling &lt;code&gt;NOTIFY&lt;/code&gt; will fail at commit. The queue is quite large (8GB in a standard installation) and should be sufficiently sized for almost every use case. However, no cleanup can take place if a session executes &lt;code&gt;LISTEN&lt;/code&gt; and then enters a transaction for a very long time. Once the queue is half full you will see warnings in the log file pointing you to the session that is preventing cleanup. In this case you should make sure that this session ends its current transaction so that cleanup can proceed.</source>
          <target state="translated">Есть очередь, в которой хранятся уведомления, которые были отправлены, но еще не обработаны всеми сеансами прослушивания. Если эта очередь заполняется, транзакции, вызывающие &lt;code&gt;NOTIFY&lt;/code&gt; , завершатся ошибкой при фиксации. Очередь довольно большая (8 ГБ при стандартной установке), и ее размер должен быть достаточным почти для каждого случая использования. Однако очистка не может произойти, если сеанс выполняет &lt;code&gt;LISTEN&lt;/code&gt; , а затем входит в транзакцию в течение очень долгого времени. Как только очередь будет заполнена наполовину, вы увидите предупреждения в файле журнала, указывающие на сеанс, препятствующий очистке. В этом случае вы должны убедиться, что этот сеанс завершает свою текущую транзакцию, чтобы можно было продолжить очистку.</target>
        </trans-unit>
        <trans-unit id="a6acd66eed300880ccbb1a71d22c7409bc533b1e" translate="yes" xml:space="preserve">
          <source>There is a race condition when first setting up a listening session: if concurrently-committing transactions are sending notify events, exactly which of those will the newly listening session receive? The answer is that the session will receive all events committed after an instant during the transaction's commit step. But that is slightly later than any database state that the transaction could have observed in queries. This leads to the following rule for using &lt;code&gt;LISTEN&lt;/code&gt;: first execute (and commit!) that command, then in a new transaction inspect the database state as needed by the application logic, then rely on notifications to find out about subsequent changes to the database state. The first few received notifications might refer to updates already observed in the initial database inspection, but this is usually harmless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f864b552f926f474ffeb07a0a68232c7a34815b" translate="yes" xml:space="preserve">
          <source>There is a second kind of identifier: the &lt;em&gt;delimited identifier&lt;/em&gt; or &lt;em&gt;quoted identifier&lt;/em&gt;. It is formed by enclosing an arbitrary sequence of characters in double-quotes (&lt;code&gt;&quot;&lt;/code&gt;). A delimited identifier is always an identifier, never a key word. So &lt;code&gt;&quot;select&quot;&lt;/code&gt; could be used to refer to a column or table named &amp;ldquo;select&amp;rdquo;, whereas an unquoted &lt;code&gt;select&lt;/code&gt; would be taken as a key word and would therefore provoke a parse error when used where a table or column name is expected. The example can be written with quoted identifiers like this:</source>
          <target state="translated">Есть второй вид идентификаторов: идентификатор с &lt;em&gt;разделителями&lt;/em&gt; или &lt;em&gt;идентификатор в кавычках&lt;/em&gt; . Он формируется путем заключения произвольной последовательности символов в двойные кавычки ( &lt;code&gt;&quot;&lt;/code&gt; ). Идентификатор с разделителями всегда является идентификатором, а не ключевым словом. Таким образом, &lt;code&gt;&quot;select&quot;&lt;/code&gt; может использоваться для ссылки на столбец или таблицу с именем&quot; select &quot;, в то время как неупомянут &lt;code&gt;select&lt;/code&gt; . будет принят в качестве ключевого слова и , следовательно , вызовет ошибку синтаксического анализа при использовании где таблица или имя столбца , как ожидается , пример можно записать с цитируемыми идентификаторами , как это:</target>
        </trans-unit>
        <trans-unit id="0ad93af24a4ac7faa267b7d3536c1e6d83e1bf68" translate="yes" xml:space="preserve">
          <source>There is a second standard system database named &lt;code&gt;template0&lt;/code&gt;. This database contains the same data as the initial contents of &lt;code&gt;template1&lt;/code&gt;, that is, only the standard objects predefined by your version of PostgreSQL. &lt;code&gt;template0&lt;/code&gt; should never be changed after the database cluster has been initialized. By instructing &lt;code&gt;CREATE DATABASE&lt;/code&gt; to copy &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt;, you can create a &amp;ldquo;pristine&amp;rdquo; user database (one where no user-defined objects exist and where the system objects have not been altered) that contains none of the site-local additions in &lt;code&gt;template1&lt;/code&gt;. This is particularly handy when restoring a &lt;code&gt;pg_dump&lt;/code&gt; dump: the dump script should be restored in a pristine database to ensure that one recreates the correct contents of the dumped database, without conflicting with objects that might have been added to &lt;code&gt;template1&lt;/code&gt; later on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e2749bbb2f806b8f89c17d420b1dde22c11b68" translate="yes" xml:space="preserve">
          <source>There is a second standard system database named &lt;code&gt;template0&lt;/code&gt;. This database contains the same data as the initial contents of &lt;code&gt;template1&lt;/code&gt;, that is, only the standard objects predefined by your version of PostgreSQL. &lt;code&gt;template0&lt;/code&gt; should never be changed after the database cluster has been initialized. By instructing &lt;code&gt;CREATE DATABASE&lt;/code&gt; to copy &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt;, you can create a &amp;ldquo;virgin&amp;rdquo; user database that contains none of the site-local additions in &lt;code&gt;template1&lt;/code&gt;. This is particularly handy when restoring a &lt;code&gt;pg_dump&lt;/code&gt; dump: the dump script should be restored in a virgin database to ensure that one recreates the correct contents of the dumped database, without conflicting with objects that might have been added to &lt;code&gt;template1&lt;/code&gt; later on.</source>
          <target state="translated">Существует вторая стандартная системная база данных с именем &lt;code&gt;template0&lt;/code&gt; . Эта база данных содержит те же данные, что и исходное содержимое &lt;code&gt;template1&lt;/code&gt; , то есть только стандартные объекты, предопределенные вашей версией PostgreSQL. &lt;code&gt;template0&lt;/code&gt; никогда не следует изменять после инициализации кластера базы данных. Инструктируя &lt;code&gt;CREATE DATABASE&lt;/code&gt; , чтобы скопировать &lt;code&gt;template0&lt;/code&gt; вместо &lt;code&gt;template1&lt;/code&gt; , вы можете создать &amp;laquo;девственный&amp;raquo; пользовательскую базу данных , которая не содержит ни один из локального сайта дополнений в &lt;code&gt;template1&lt;/code&gt; . Это особенно удобно при восстановлении &lt;code&gt;pg_dump&lt;/code&gt; .dump: сценарий дампа должен быть восстановлен в исходной базе данных, чтобы обеспечить воссоздание правильного содержимого выгруженной базы данных без конфликта с объектами, которые могли быть добавлены в &lt;code&gt;template1&lt;/code&gt; позже.</target>
        </trans-unit>
        <trans-unit id="c4adb0689e8eca60cac4109882f9fd73f05b7582" translate="yes" xml:space="preserve">
          <source>There is a separate server process called the &lt;em&gt;background writer&lt;/em&gt;, whose function is to issue writes of &amp;ldquo;dirty&amp;rdquo; (new or modified) shared buffers. It writes shared buffers so server processes handling user queries seldom or never need to wait for a write to occur. However, the background writer does cause a net overall increase in I/O load, because while a repeatedly-dirtied page might otherwise be written only once per checkpoint interval, the background writer might write it several times as it is dirtied in the same interval. The parameters discussed in this subsection can be used to tune the behavior for local needs.</source>
          <target state="translated">Существует отдельный серверный процесс, называемый &lt;em&gt;фоновой записью&lt;/em&gt; , функция которого заключается в выполнении записи &amp;laquo;грязных&amp;raquo; (новых или измененных) общих буферов. Он записывает общие буферы, поэтому серверные процессы, обрабатывающие пользовательские запросы, редко или никогда не должны ждать, пока произойдет запись. Однако фоновый писатель действительно вызывает чистое общее увеличение нагрузки ввода-вывода, потому что, хотя в противном случае многократно загрязненная страница могла бы быть записана только один раз за интервал контрольной точки, фоновая запись могла бы записать ее несколько раз, поскольку она загрязнялась в том же интервале. . Параметры, обсуждаемые в этом подразделе, можно использовать для настройки поведения в соответствии с местными потребностями.</target>
        </trans-unit>
        <trans-unit id="90974f119b06bcf646bf0eec46102bc09a0eac90" translate="yes" xml:space="preserve">
          <source>There is a simple variable-substitution facility for script files. Variable names must consist of letters (including non-Latin letters), digits, and underscores. Variables can be set by the command-line &lt;code&gt;-D&lt;/code&gt; option, explained above, or by the meta commands explained below. In addition to any variables preset by &lt;code&gt;-D&lt;/code&gt; command-line options, there are a few variables that are preset automatically, listed in &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;Table 257&lt;/a&gt;. A value specified for these variables using &lt;code&gt;-D&lt;/code&gt; takes precedence over the automatic presets. Once set, a variable's value can be inserted into a SQL command by writing &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt;. When running more than one client session, each session has its own set of variables. pgbench supports up to 255 variable uses in one statement.</source>
          <target state="translated">Для файлов сценариев существует простая возможность подстановки переменных. Имена переменных должны состоять из букв (включая нелатинские буквы), цифр и символов подчеркивания. Переменные можно установить с помощью параметра командной строки &lt;code&gt;-D&lt;/code&gt; , как описано выше, или с помощью мета-команд, описанных ниже. В дополнение к любым переменным, предустановленным параметрами командной строки &lt;code&gt;-D&lt;/code&gt; , есть несколько переменных, которые устанавливаются автоматически, перечисленные в &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;Таблице 257&lt;/a&gt; . Значение, указанное для этих переменных с помощью &lt;code&gt;-D&lt;/code&gt; , имеет приоритет над автоматическими предустановками. После установки значение переменной можно вставить в команду SQL, написав &lt;code&gt;:&lt;/code&gt; &lt;code&gt;variablename&lt;/code&gt; . При запуске более одного клиентского сеанса каждый сеанс имеет свой собственный набор переменных. pgbench поддерживает до 255 использований переменных в одном операторе.</target>
        </trans-unit>
        <trans-unit id="f9e27e33d86d73062aeb666fac5a6e70627179d3" translate="yes" xml:space="preserve">
          <source>There is a simple variable-substitution facility for script files. Variable names must consist of letters (including non-Latin letters), digits, and underscores. Variables can be set by the command-line &lt;code&gt;-D&lt;/code&gt; option, explained above, or by the meta commands explained below. In addition to any variables preset by &lt;code&gt;-D&lt;/code&gt; command-line options, there are a few variables that are preset automatically, listed in &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;Table 273&lt;/a&gt;. A value specified for these variables using &lt;code&gt;-D&lt;/code&gt; takes precedence over the automatic presets. Once set, a variable's value can be inserted into a SQL command by writing &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt;. When running more than one client session, each session has its own set of variables. pgbench supports up to 255 variable uses in one statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b40deac5f431c882b47bcec560aceab88cb2ea" translate="yes" xml:space="preserve">
          <source>There is a strong connection between the XQuery language and XPath versions 2.0 and later: any expression that is syntactically valid and executes successfully in both produces the same result (with a minor exception for expressions containing numeric character references or predefined entity references, which XQuery replaces with the corresponding character while XPath leaves them alone). But there is no such connection between these languages and XPath 1.0; it was an earlier language and differs in many respects.</source>
          <target state="translated">Существует тесная связь между языком XQuery и XPath версии 2.0 и выше:любое выражение,которое является синтаксически действительным и успешно выполняется в обоих случаях,дает один и тот же результат (с небольшим исключением для выражений,содержащих ссылки на числовые символы или предопределенные ссылки на сущности,которые XQuery заменяет на соответствующие символы,в то время как XPath оставляет их одни и те же).Но такой связи между этими языками и XPath 1.0 нет;это был более ранний язык и отличается во многом.</target>
        </trans-unit>
        <trans-unit id="c56c39bf47cf0690546e1095f601459a05ce75db" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; parameter, which determines the placement of temporary tables and indexes, as well as temporary files that are used for purposes such as sorting large data sets. This can be a list of tablespace names, rather than only one, so that the load associated with temporary objects can be spread over multiple tablespaces. A random member of the list is picked each time a temporary object is to be created.</source>
          <target state="translated">Существует также параметр &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; , который определяет размещение временных таблиц и индексов, а также временных файлов, которые используются для таких целей, как сортировка больших наборов данных. Это может быть список имен табличных пространств, а не только одно, так что нагрузка, связанная с временными объектами, может быть распределена по нескольким табличным пространствам. Случайный член списка выбирается каждый раз, когда создается временный объект.</target>
        </trans-unit>
        <trans-unit id="58b9a64bc7c6fc9848f60613899f8c2ff0dc12dc" translate="yes" xml:space="preserve">
          <source>There is also a non-default GIN operator class &lt;code&gt;gin__int_ops&lt;/code&gt; supporting the same operators.</source>
          <target state="translated">Существует также класс операторов GIN, &lt;code&gt;gin__int_ops&lt;/code&gt; от стандартного, gin__int_ops, поддерживающий те же операторы.</target>
        </trans-unit>
        <trans-unit id="3d6db9a7a400632bced3a61ed8d0f591628a4c78" translate="yes" xml:space="preserve">
          <source>There is also a single-argument &lt;code&gt;to_timestamp&lt;/code&gt; function; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TABLE&quot;&gt;Table 9.31&lt;/a&gt;.</source>
          <target state="translated">Также &lt;code&gt;to_timestamp&lt;/code&gt; функция to_timestamp с одним аргументом ; см. &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TABLE&quot;&gt;Таблицу 9.31&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41669b255a0d94f06b45d60440ba0720ed574d46" translate="yes" xml:space="preserve">
          <source>There is also a two-parameter version of &lt;code&gt;xslt_process&lt;/code&gt; which does not pass any parameters to the transformation.</source>
          <target state="translated">Существует также версия &lt;code&gt;xslt_process&lt;/code&gt; с двумя параметрами, которая не передает никаких параметров преобразованию.</target>
        </trans-unit>
        <trans-unit id="1ad78e13b5545fbac4993cd2573ccb0145f0260a" translate="yes" xml:space="preserve">
          <source>There is also an &lt;code&gt;include_if_exists&lt;/code&gt; directive, which acts the same as the &lt;code&gt;include&lt;/code&gt; directive, except when the referenced file does not exist or cannot be read. A regular &lt;code&gt;include&lt;/code&gt; will consider this an error condition, but &lt;code&gt;include_if_exists&lt;/code&gt; merely logs a message and continues processing the referencing configuration file.</source>
          <target state="translated">Также существует директива &lt;code&gt;include_if_exists&lt;/code&gt; , которая действует так же, как директива &lt;code&gt;include&lt;/code&gt; , за исключением случаев, когда указанный файл не существует или не может быть прочитан. Обычное &lt;code&gt;include&lt;/code&gt; будет рассматривать это как состояние ошибки, но &lt;code&gt;include_if_exists&lt;/code&gt; просто регистрирует сообщение и продолжает обработку ссылающегося файла конфигурации.</target>
        </trans-unit>
        <trans-unit id="87e6a166488f605dc208dade3f60cf2f1017cef3" translate="yes" xml:space="preserve">
          <source>There is also an exception to the exception: I/O conversion casts from composite types to string types cannot be invoked using functional syntax, but must be written in explicit cast syntax (either &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; notation). This exception was added because after the introduction of automatically-provided I/O conversion casts, it was found too easy to accidentally invoke such a cast when a function or column reference was intended.</source>
          <target state="translated">Существует также исключение из этого исключения: преобразования ввода-вывода из составных типов в строковые типы не могут быть вызваны с использованием функционального синтаксиса, но должны быть записаны в явном синтаксисе преобразования (в нотации &lt;code&gt;CAST&lt;/code&gt; или &lt;code&gt;::&lt;/code&gt; :). Это исключение было добавлено, потому что после введения автоматически предоставляемых преобразований ввода-вывода было обнаружено, что слишком легко случайно вызвать такое преобразование, когда предполагалась ссылка на функцию или столбец.</target>
        </trans-unit>
        <trans-unit id="10e49e8f0395261cca6c9bddfde366e5b44bc0fa" translate="yes" xml:space="preserve">
          <source>There is also an option to grant privileges on all objects of the same type within one or more schemas. This functionality is currently supported only for tables, sequences, functions, and procedures. &lt;code&gt;ALL TABLES&lt;/code&gt; also affects views and foreign tables, just like the specific-object &lt;code&gt;GRANT&lt;/code&gt; command. &lt;code&gt;ALL FUNCTIONS&lt;/code&gt; also affects aggregate and window functions, but not procedures, again just like the specific-object &lt;code&gt;GRANT&lt;/code&gt; command. Use &lt;code&gt;ALL ROUTINES&lt;/code&gt; to include procedures.</source>
          <target state="translated">Также существует возможность предоставить привилегии для всех объектов одного типа в одной или нескольких схемах. В настоящее время эта функция поддерживается только для таблиц, последовательностей, функций и процедур. &lt;code&gt;ALL TABLES&lt;/code&gt; также влияет на представления и сторонние таблицы, как и команда &lt;code&gt;GRANT&lt;/code&gt; для конкретного объекта . &lt;code&gt;ALL FUNCTIONS&lt;/code&gt; также влияет на агрегатные и оконные функции, но не на процедуры, опять же, как и команда &lt;code&gt;GRANT&lt;/code&gt; для конкретного объекта . Используйте &lt;code&gt;ALL ROUTINES&lt;/code&gt; чтобы включить процедуры.</target>
        </trans-unit>
        <trans-unit id="5a702bafff3c7f4c616d64a2b71bb4d856736202" translate="yes" xml:space="preserve">
          <source>There is also the prefix operator &lt;code&gt;^@&lt;/code&gt; and corresponding &lt;code&gt;starts_with&lt;/code&gt; function which covers cases when only searching by beginning of the string is needed.</source>
          <target state="translated">Также есть префиксный оператор &lt;code&gt;^@&lt;/code&gt; и соответствующая функция &lt;code&gt;starts_with&lt;/code&gt; которая охватывает случаи, когда нужен только поиск по началу строки.</target>
        </trans-unit>
        <trans-unit id="012b88356356711e33f301f2bb1596f7e0f835cc" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;autoinc.example&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;autoinc.example&lt;/code&gt; есть пример .</target>
        </trans-unit>
        <trans-unit id="93425455a73285f0e21d7315c96b601935f70ba0" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;insert_username.example&lt;/code&gt;.</source>
          <target state="translated">Пример есть в &lt;code&gt;insert_username.example&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16b24fdd30442f553bc5891f105491e9f92bd108" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;moddatetime.example&lt;/code&gt;.</source>
          <target state="translated">Пример есть в &lt;code&gt;moddatetime.example&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2b9c61965fcc66e74624ddfce72996d337e8786" translate="yes" xml:space="preserve">
          <source>There is an inherent ambiguity between octal character-entry escapes and back references, which is resolved by the following heuristics, as hinted at above. A leading zero always indicates an octal escape. A single non-zero digit, not followed by another digit, is always taken as a back reference. A multi-digit sequence not starting with a zero is taken as a back reference if it comes after a suitable subexpression (i.e., the number is in the legal range for a back reference), and otherwise is taken as octal.</source>
          <target state="translated">Существует присущая восьмеричным выходам символов и обратным ссылкам неоднозначность,которая разрешается следующими эвристическими методами,как намекнуло выше.Опережающий ноль всегда указывает на восьмеричный побег.За обратную ссылку всегда принимается одна ненулевая цифра,за которой не следует другая.Многозначная последовательность,не начинающаяся с нуля,принимается за обратную ссылку,если она идет после подходящего подвыражения (т.е.число находится в правовом диапазоне для обратной ссылки),и в противном случае принимается как восьмеричная.</target>
        </trans-unit>
        <trans-unit id="2d4f42c096704e40b12586b5cb5d82cbdaf1b311" translate="yes" xml:space="preserve">
          <source>There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, it specifies executing &lt;code&gt;pg_start_backup&lt;/code&gt; as quickly as possible. This forces an immediate checkpoint which will cause a spike in I/O operations, slowing any concurrently executing queries.</source>
          <target state="translated">Есть необязательный второй параметр типа &lt;code&gt;boolean&lt;/code&gt; . Если &lt;code&gt;true&lt;/code&gt; , он указывает выполнение &lt;code&gt;pg_start_backup&lt;/code&gt; как можно быстрее. Это вызывает немедленную контрольную точку, которая вызовет всплеск операций ввода-вывода, замедляя выполнение любых одновременно выполняемых запросов.</target>
        </trans-unit>
        <trans-unit id="ea377213a3bab4fda44e6ee45837c28d5e6303c2" translate="yes" xml:space="preserve">
          <source>There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If false, the function will return immediately after the backup is completed, without waiting for WAL to be archived. This behavior is only useful with backup software that independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. By default or when this parameter is true, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait for WAL to be archived when archiving is enabled. (On a standby, this means that it will wait only when &lt;code&gt;archive_mode&lt;/code&gt; = &lt;code&gt;always&lt;/code&gt;. If write activity on the primary is low, it may be useful to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary in order to trigger an immediate segment switch.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39681348944621b0cbdb87c4dd79d5e8a6ab1c87" translate="yes" xml:space="preserve">
          <source>There is another important concept associated with window functions: for each row, there is a set of rows within its partition called its &lt;em&gt;window frame&lt;/em&gt;. Some window functions act only on the rows of the window frame, rather than of the whole partition. By default, if &lt;code&gt;ORDER BY&lt;/code&gt; is supplied then the frame consists of all rows from the start of the partition up through the current row, plus any following rows that are equal to the current row according to the &lt;code&gt;ORDER BY&lt;/code&gt; clause. When &lt;code&gt;ORDER BY&lt;/code&gt; is omitted the default frame consists of all rows in the partition. &lt;a href=&quot;#ftn.id-1.4.5.6.9.5&quot;&gt;&lt;sup id=&quot;id-1.4.5.6.9.5&quot;&gt;[4]&lt;/sup&gt;&lt;/a&gt; Here is an example using &lt;code&gt;sum&lt;/code&gt;:</source>
          <target state="translated">Есть еще одна важная концепция, связанная с оконными функциями: для каждой строки есть набор строк в ее разделе, называемый ее &lt;em&gt;оконной рамкой&lt;/em&gt; . Некоторые оконные функции действуют только на строки оконной рамы, а не на весь раздел. По умолчанию, если указан &lt;code&gt;ORDER BY&lt;/code&gt; , то фрейм состоит из всех строк от начала раздела до текущей строки, плюс любые последующие строки, которые равны текущей строке в соответствии с предложением &lt;code&gt;ORDER BY&lt;/code&gt; . Если &lt;code&gt;ORDER BY&lt;/code&gt; опущен, фрейм по умолчанию состоит из всех строк в разделе. &lt;a href=&quot;#ftn.id-1.4.5.6.9.5&quot;&gt;&lt;sup id=&quot;id-1.4.5.6.9.5&quot;&gt;[4]&lt;/sup&gt;&lt;/a&gt; Вот пример использования &lt;code&gt;sum&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="64034dc768225bc4dcced9797dcc3830def63396" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f28370d7fe3178c0f150cc0dec3299397ce3c2af" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER COLLATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER COLLATION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7babd298f2e4c509f069c94f5602aeb995a6b57c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER CONVERSION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER CONVERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="928fd572e35641041e67b18e6e748efce3723a8c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="991bfb585377a575377a77fe428cfaf85a73d860" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER EVENT TRIGGER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d77ec038759f5fffa10b0b08001ebb09342372d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER GROUP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb57388d9f735799eb7b9b89ff35e3d5ef151e31" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER LANGUAGE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER LANGUAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1637168216f474c65041857a21d81b0e4a440e97" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="345d872d60a75b2e0f9d89245157411db046f3d0" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fcc86f4b1945452fb4d2e3306232b8ba831ba49" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc28991fbce6444e2838b4c5b330fc7e8b89d499" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER OPERATOR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2506d4e215504a7cdfcb1194c2679242cc54a59e" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER SCHEMA&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER SCHEMA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2964377f745afad2429ec74b207708196b68d312" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет команды &lt;code&gt;ALTER STATISTICS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c3931d89739bf4a90fd967b4f0a43fada449313" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TABLESPACE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER TABLESPACE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e24f943c01b48797aaba76a9060c58b771452dd4" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee71505e9ca52479c60dc800cccb5a32c56fe24" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d50e75d0db9753a5bb17ed4059457e195c3fbe78" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; оператора ALTER TEXT SEARCH PARSER .</target>
        </trans-unit>
        <trans-unit id="f2e5183222d4bb5c821f92f235643d98359507e9" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e08ef635bc500a8ffe34e71b4cb60735a3f59c83" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ANALYZE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;ANALYZE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab267186c8c406bf12491cd64160dcb07b24078" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CLUSTER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;CLUSTER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b29db8edfc564e2f37aa124a9094dedfa5dc75ca" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;COMMENT&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет команды &lt;code&gt;COMMENT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51ffc421257a5e488b200464e2482e6c0cb494cc" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;COPY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;COPY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1ea525f2af46d628097a5d99e04b04f3dea2225" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE DATABASE&lt;/code&gt; statement in the SQL standard. Databases are equivalent to catalogs, whose creation is implementation-defined.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;CREATE DATABASE&lt;/code&gt; . Базы данных эквивалентны каталогам, создание которых определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="1892a6f6e1f58d3b4418aa1f7caf04e29a8df179" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bd71c5d0a01b45b44b80fcee88ed4660e223ea1" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;CREATE GROUP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e39953cfa3881edf0f677e0b9a6a85f9dce8605d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет команды &lt;code&gt;CREATE STATISTICS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="502eb254142165b2715d9eff63db5d89a608e2d7" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;CREATE TEXT SEARCH CONFIGURATION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="609c741f2314d56bf655daef547dcb2a0644be82" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;CREATE TEXT SEARCH DICTIONARY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41df83262dc2c3b270bf89a5b823f9c05295e631" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; оператора CREATE TEXT SEARCH PARSER .</target>
        </trans-unit>
        <trans-unit id="ec4376bb5fb0542843f635e97909a4ca5d798c55" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adb922403a157a64a60a934905fa24aa07814119" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DO&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="453ae3f4ad66d52b89a14781b63b1f82ed5a0eba" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP AGGREGATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP AGGREGATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fec0e29fd940c929987502b958108c6376839288" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP CONVERSION&lt;/code&gt; statement in the SQL standard, but a &lt;code&gt;DROP TRANSLATION&lt;/code&gt; statement that goes along with the &lt;code&gt;CREATE TRANSLATION&lt;/code&gt; statement that is similar to the &lt;code&gt;CREATE CONVERSION&lt;/code&gt; statement in PostgreSQL.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP CONVERSION&lt;/code&gt; , но есть оператор &lt;code&gt;DROP TRANSLATION&lt;/code&gt; , который сопровождает оператор &lt;code&gt;CREATE TRANSLATION&lt;/code&gt; , аналогичный оператору &lt;code&gt;CREATE CONVERSION&lt;/code&gt; в PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="fb09b1464adf925f06c0292814700fb9b8091f6c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP DATABASE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP DATABASE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3c4c010988712d96dd1e79f98080f9432271062" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP EVENT TRIGGER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75623002e2b624abb982d948db215c1dd60a52cc" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP GROUP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27a5387a3bec15b9e950f163994562d5efac89f3" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP LANGUAGE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP LANGUAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3d30fcc924219aba17a45fb588c01476a1e9ff6" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR CLASS&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP OPERATOR CLASS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a4d8ad142bdd21f8d4bd8875a49f33849bf5d39" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR FAMILY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP OPERATOR FAMILY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20b4d42336169eb36dbc8e0af63669368391995e" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP OPERATOR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22ab45de26ec7860503bcd3c1a242a1a6a072838" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет команды &lt;code&gt;DROP STATISTICS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33a3a716e771311567ab1607e35bf61106da647f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP TEXT SEARCH CONFIGURATION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ff33e4bc1ee2eee7f638d4f9ffce00160a3d8ec" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;DROP TEXT SEARCH DICTIONARY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f0a322ac87aa6f316366f64468b6a33b449141" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL &lt;code&gt;DROP TEXT SEARCH PARSER&lt;/code&gt; оператора DROP TEXT SEARCH PARSER .</target>
        </trans-unit>
        <trans-unit id="caba21772330bd3e8d6bc5c0114bed4813577256" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL отсутствует оператор &lt;code&gt;DROP TEXT SEARCH TEMPLATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c6a0d8e969d6d60c24413dee9ec35d4707051d7" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;EXPLAIN&lt;/code&gt; statement defined in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;EXPLAIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3188600a38497d7445251ce699c39dbe875e80ee" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;LISTEN&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;LISTEN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89782cda07082f5c8f4d6514f108dab71bcfa4d2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;LOCK TABLE&lt;/code&gt; in the SQL standard, which instead uses &lt;code&gt;SET TRANSACTION&lt;/code&gt; to specify concurrency levels on transactions. PostgreSQL supports that too; see &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; for details.</source>
          <target state="translated">В стандарте SQL нет &lt;code&gt;LOCK TABLE&lt;/code&gt; , который вместо этого использует &lt;code&gt;SET TRANSACTION&lt;/code&gt; для определения уровней параллелизма для транзакций. PostgreSQL тоже поддерживает это; подробности см. в &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f784f25d51430ade6f35b2e081075babec2e0fe" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;MOVE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;MOVE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a168bea72d9806503f40f80aa12982ca9fd8601" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;NOTIFY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;NOTIFY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e1257ab0b3946084dffdd621f7db244f79c25f5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;REINDEX&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет команды &lt;code&gt;REINDEX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9129bb3a754d8cf06ba21c59dfcd6069ee5971c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;SECURITY LABEL&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет команды &lt;code&gt;SECURITY LABEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2c399b535d16a105f07135d4035417088b1dcc4" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;UNLISTEN&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет команды &lt;code&gt;UNLISTEN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a373be7f6f352e566798cf5a1903b201f8406b2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;VACUUM&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">В стандарте SQL нет оператора &lt;code&gt;VACUUM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaadde692acdf895866b856cf669a3d745361c1a" translate="yes" xml:space="preserve">
          <source>There is no alignment padding or any other extra data between fields.</source>
          <target state="translated">Между полями нет подкладки для выравнивания или любых других дополнительных данных.</target>
        </trans-unit>
        <trans-unit id="9d9b8c9e107ad42ee0fad08dd8f24c67ee8d865a" translate="yes" xml:space="preserve">
          <source>There is no automatic way to verify that all of the &lt;code&gt;CHECK&lt;/code&gt; constraints are mutually exclusive. It is safer to create code that generates child tables and creates and/or modifies associated objects than to write each by hand.</source>
          <target state="translated">Нет автоматического способа проверить, что все ограничения &lt;code&gt;CHECK&lt;/code&gt; являются взаимоисключающими. Безопаснее создавать код, который генерирует дочерние таблицы и создает и / или изменяет связанные объекты, чем писать каждый вручную.</target>
        </trans-unit>
        <trans-unit id="6a9b18acfad0da6c23024f7c2509d5457d17977e" translate="yes" xml:space="preserve">
          <source>There is no comparably easy way to determine a next OID that's beyond the largest one in the database, but fortunately it is not critical to get the next-OID setting right.</source>
          <target state="translated">Нет сравнительно простого способа определить следующий OID,который выходит за рамки самого большого в базе данных,но,к счастью,не критично правильно настроить следующий OID.</target>
        </trans-unit>
        <trans-unit id="4db36b67fac0c975746b2d641f8b3943a36d8046" translate="yes" xml:space="preserve">
          <source>There is no cross-checking of indexes against their heap relation during normal operation. Symptoms of heap corruption can be subtle.</source>
          <target state="translated">При нормальной работе нет перекрестной проверки индексов на их кучное соотношение.Симптомы повреждения кучи могут быть неуловимыми.</target>
        </trans-unit>
        <trans-unit id="e96dd49b9a313a343547338d49ed17c06a38c1a6" translate="yes" xml:space="preserve">
          <source>There is no dependent object; this type of entry is a signal that the system itself depends on the referenced object, and so that object must never be deleted. Entries of this type are created only by &lt;code&gt;initdb&lt;/code&gt;. The columns for the dependent object contain zeroes.</source>
          <target state="translated">Нет зависимого объекта; этот тип записи является сигналом того, что сама система зависит от объекта, на который имеется ссылка, и поэтому этот объект нельзя удалять. Записи этого типа создаются только &lt;code&gt;initdb&lt;/code&gt; . Столбцы для зависимого объекта содержат нули.</target>
        </trans-unit>
        <trans-unit id="70fc6506fe197311ab91bc28b3e88218eb7eab49" translate="yes" xml:space="preserve">
          <source>There is no general method of repairing problems that &lt;code&gt;amcheck&lt;/code&gt; detects. An explanation for the root cause of an invariant violation should be sought. &lt;a href=&quot;pageinspect&quot;&gt;pageinspect&lt;/a&gt; may play a useful role in diagnosing corruption that &lt;code&gt;amcheck&lt;/code&gt; detects. A &lt;code&gt;REINDEX&lt;/code&gt; may not be effective in repairing corruption.</source>
          <target state="translated">Не существует общего метода устранения проблем, которые обнаруживает &lt;code&gt;amcheck&lt;/code&gt; . Следует искать объяснение первопричины нарушения инварианта. &lt;a href=&quot;pageinspect&quot;&gt;pageinspect&lt;/a&gt; может сыграть полезную роль в диагностике повреждений, обнаруживаемых &lt;code&gt;amcheck&lt;/code&gt; . &lt;code&gt;REINDEX&lt;/code&gt; не может быть эффективным в восстановлении коррупции.</target>
        </trans-unit>
        <trans-unit id="f84235bff819237a1da91e8e95c005f22d0298e2" translate="yes" xml:space="preserve">
          <source>There is no length limit on the input strings.</source>
          <target state="translated">На входных строках нет ограничения по длине.</target>
        </trans-unit>
        <trans-unit id="4dbeb068f00ac522f4db315c80e9ac31689bfd87" translate="yes" xml:space="preserve">
          <source>There is no linguistic support, even for English. Regular expressions are not sufficient because they cannot easily handle derived words, e.g., &lt;code&gt;satisfies&lt;/code&gt; and &lt;code&gt;satisfy&lt;/code&gt;. You might miss documents that contain &lt;code&gt;satisfies&lt;/code&gt;, although you probably would like to find them when searching for &lt;code&gt;satisfy&lt;/code&gt;. It is possible to use &lt;code&gt;OR&lt;/code&gt; to search for multiple derived forms, but this is tedious and error-prone (some words can have several thousand derivatives).</source>
          <target state="translated">Нет лингвистической поддержки даже для английского. Регулярных выражений недостаточно, потому что они не могут легко обрабатывать производные слова, например, &lt;code&gt;satisfies&lt;/code&gt; и &lt;code&gt;satisfy&lt;/code&gt; . Вы можете пропустить документы, содержащие &lt;code&gt;satisfies&lt;/code&gt; , хотя вы, вероятно, захотите найти их при поиске &lt;code&gt;satisfy&lt;/code&gt; . Можно использовать &lt;code&gt;OR&lt;/code&gt; для поиска нескольких производных форм, но это утомительно и подвержено ошибкам (некоторые слова могут иметь несколько тысяч производных).</target>
        </trans-unit>
        <trans-unit id="56e118a7d0adfb0e635c9d07f655d84a8ad88c12" translate="yes" xml:space="preserve">
          <source>There is no mechanism to enforce uniqueness of standby names. In case of duplicates one of the matching standbys will be considered as higher priority, though exactly which one is indeterminate.</source>
          <target state="translated">Нет механизма,который обеспечивал бы уникальность резервных имен.В случае дубликатов один из дубликатов будет считаться более приоритетным,хотя точно какой из них является неопределенным.</target>
        </trans-unit>
        <trans-unit id="ee6e31417005e5059c60745bca02997125074c26" translate="yes" xml:space="preserve">
          <source>There is no need to grant privileges to the owner of an object (usually the user that created it), as the owner has all privileges by default. (The owner could, however, choose to revoke some of their own privileges for safety.)</source>
          <target state="translated">Нет необходимости предоставлять привилегии владельцу объекта (обычно пользователю,который его создал),так как по умолчанию владелец имеет все привилегии.(Владелец,однако,может отказаться от некоторых собственных привилегий в целях безопасности).</target>
        </trans-unit>
        <trans-unit id="30ae1505daac493ace3132ae554c6ea20c2ba190" translate="yes" xml:space="preserve">
          <source>There is no performance difference among these three types, apart from increased storage space when using the blank-padded type, and a few extra CPU cycles to check the length when storing into a length-constrained column. While &lt;code&gt;character(n)&lt;/code&gt; has performance advantages in some other database systems, there is no such advantage in PostgreSQL; in fact &lt;code&gt;character(n)&lt;/code&gt; is usually the slowest of the three because of its additional storage costs. In most situations &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;character varying&lt;/code&gt; should be used instead.</source>
          <target state="translated">Между этими тремя типами нет разницы в производительности, за исключением увеличенного пространства для хранения при использовании типа с заполнением пробелами и нескольких дополнительных циклов ЦП для проверки длины при сохранении в столбец с ограниченной длиной. Хотя у &lt;code&gt;character(n)&lt;/code&gt; есть преимущества в производительности в некоторых других системах баз данных, в PostgreSQL такого преимущества нет; Фактически, &lt;code&gt;character(n)&lt;/code&gt; обычно самый медленный из трех из-за дополнительных затрат на хранение. В большинстве случаев вместо этого следует использовать &lt;code&gt;character varying&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; или символы .</target>
        </trans-unit>
        <trans-unit id="8afc4737cc902a7afc20e4910e033de6ddabdb93" translate="yes" xml:space="preserve">
          <source>There is no restriction regarding how many database users a given operating system user can correspond to, nor vice versa. Thus, entries in a map should be thought of as meaning &amp;ldquo;this operating system user is allowed to connect as this database user&amp;rdquo;, rather than implying that they are equivalent. The connection will be allowed if there is any map entry that pairs the user name obtained from the external authentication system with the database user name that the user has requested to connect as.</source>
          <target state="translated">Нет никаких ограничений относительно того, скольким пользователям базы данных может соответствовать пользователь данной операционной системы, и наоборот. Таким образом, записи на карте следует рассматривать как означающие &amp;laquo;этому пользователю операционной системы разрешено подключаться как этот пользователь базы данных&amp;raquo;, а не как подразумевающие, что они эквивалентны. Соединение будет разрешено, если есть какая-либо запись в карте, которая связывает имя пользователя, полученное из внешней системы аутентификации, с именем пользователя базы данных, которое пользователь запросил для подключения.</target>
        </trans-unit>
        <trans-unit id="c6d6a72d9fa9097f88cd465d659b996359e6595c" translate="yes" xml:space="preserve">
          <source>There is no result row for the city of Hayward. This is because there is no matching entry in the &lt;code&gt;cities&lt;/code&gt; table for Hayward, so the join ignores the unmatched rows in the &lt;code&gt;weather&lt;/code&gt; table. We will see shortly how this can be fixed.</source>
          <target state="translated">Строка результатов для города Хейворд отсутствует. Это связано с тем, что в таблице &lt;code&gt;cities&lt;/code&gt; для Hayward нет соответствующей записи , поэтому объединение игнорирует несовпадающие строки в таблице &lt;code&gt;weather&lt;/code&gt; . Вскоре мы увидим, как это можно исправить.</target>
        </trans-unit>
        <trans-unit id="fb859432422d8124605fd6fa0a5ba7fbb347c338" translate="yes" xml:space="preserve">
          <source>There is no way to create an exclusion constraint spanning all partitions; it is only possible to constrain each leaf partition individually.</source>
          <target state="translated">Нет способа создать ограничение исключения,охватывающее все простенки;можно только ограничить каждый листовой простенок по отдельности.</target>
        </trans-unit>
        <trans-unit id="0394a27a4ae985b5c69a41210e1f40ba8b0d8944" translate="yes" xml:space="preserve">
          <source>There is one further implementation-level restriction that applies regardless of the operator class or collation used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b7fd66a2cb5b710dc5cc84ddcb5325f9ab68cf" translate="yes" xml:space="preserve">
          <source>There is one further implementation-level restriction that may be lifted in a future version of PostgreSQL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5bd62ec3737bfec14cadfb61679b8166c57b55" translate="yes" xml:space="preserve">
          <source>There is one row for each buffer in the shared cache. Unused buffers are shown with all fields null except &lt;code&gt;bufferid&lt;/code&gt;. Shared system catalogs are shown as belonging to database zero.</source>
          <target state="translated">Для каждого буфера в общем кэше есть одна строка. Неиспользуемые буферы отображаются со всеми &lt;code&gt;bufferid&lt;/code&gt; полями, кроме bufferid . Общие системные каталоги отображаются как принадлежащие нулевой базе данных.</target>
        </trans-unit>
        <trans-unit id="f45963e6e5833c88c83b3b4b867ec971de5358c8" translate="yes" xml:space="preserve">
          <source>There is only one &lt;code&gt;round&lt;/code&gt; function that takes two arguments; it takes a first argument of type &lt;code&gt;numeric&lt;/code&gt; and a second argument of type &lt;code&gt;integer&lt;/code&gt;. So the following query automatically converts the first argument of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt;:</source>
          <target state="translated">Есть только одна функция &lt;code&gt;round&lt;/code&gt; которая принимает два аргумента; он принимает первый аргумент &lt;code&gt;numeric&lt;/code&gt; типа и второй аргумент &lt;code&gt;integer&lt;/code&gt; типа . Таким образом, следующий запрос автоматически преобразует первый аргумент &lt;code&gt;integer&lt;/code&gt; типа в &lt;code&gt;numeric&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b9159e4fda642d08346e94fb2d3ac2dbc99a478a" translate="yes" xml:space="preserve">
          <source>There is only one factorial operator (postfix &lt;code&gt;!&lt;/code&gt;) defined in the standard catalog, and it takes an argument of type &lt;code&gt;bigint&lt;/code&gt;. The scanner assigns an initial type of &lt;code&gt;integer&lt;/code&gt; to the argument in this query expression:</source>
          <target state="translated">В стандартном каталоге определен только один факторный оператор (постфикс &lt;code&gt;!&lt;/code&gt; ), И он принимает аргумент типа &lt;code&gt;bigint&lt;/code&gt; . Сканер присваивает начальный тип &lt;code&gt;integer&lt;/code&gt; аргументу в этом выражении запроса:</target>
        </trans-unit>
        <trans-unit id="dd1f87be0e4d3b116fb1cbdcb6dc8732c5edc78d" translate="yes" xml:space="preserve">
          <source>There is only one square root operator (prefix &lt;code&gt;|/&lt;/code&gt;) defined in the standard catalog, and it takes an argument of type &lt;code&gt;double precision&lt;/code&gt;. The scanner assigns an initial type of &lt;code&gt;integer&lt;/code&gt; to the argument in this query expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0c7153374d6f701aba32a67304ea000734d416" translate="yes" xml:space="preserve">
          <source>There is presently no security mechanism for viewing comments: any user connected to a database can see all the comments for objects in that database. For shared objects such as databases, roles, and tablespaces, comments are stored globally so any user connected to any database in the cluster can see all the comments for shared objects. Therefore, don't put security-critical information in comments.</source>
          <target state="translated">В настоящее время не существует механизма защиты от просмотра комментариев:любой пользователь,подключенный к базе данных,может просмотреть все комментарии к объектам в этой базе данных.Для общих объектов,таких как базы данных,роли и табличные пространства,комментарии хранятся глобально,поэтому любой пользователь,подключенный к любой базе данных в кластере,может видеть все комментарии для общих объектов.Поэтому не помещайте критичную для безопасности информацию в комментарии.</target>
        </trans-unit>
        <trans-unit id="e848fe2ab9f9a42478fab56269c47dd1ce42078d" translate="yes" xml:space="preserve">
          <source>There is usually not much point in making more than one tablespace per logical file system, since you cannot control the location of individual files within a logical file system. However, PostgreSQL does not enforce any such limitation, and indeed it is not directly aware of the file system boundaries on your system. It just stores files in the directories you tell it to use.</source>
          <target state="translated">Обычно нет смысла делать более одного табличного пространства на логическую файловую систему,так как вы не можете контролировать расположение отдельных файлов в логической файловой системе.Тем не менее,PostgreSQL не навязывает никаких таких ограничений,и на самом деле он не знает непосредственно границ файловой системы в вашей системе.Он просто хранит файлы в каталогах,которые вы ему приказываете использовать.</target>
        </trans-unit>
        <trans-unit id="d953cfaaf0252b15b02b8c9a112ebe99c8fa7d20" translate="yes" xml:space="preserve">
          <source>There must also be matching child-table constraints for all &lt;code&gt;CHECK&lt;/code&gt; constraints of the parent, except those marked non-inheritable (that is, created with &lt;code&gt;ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT&lt;/code&gt;) in the parent, which are ignored; all child-table constraints matched must not be marked non-inheritable. Currently &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered, but this might change in the future.</source>
          <target state="translated">Также должны быть совпадающие ограничения дочерней таблицы для всех ограничений &lt;code&gt;CHECK&lt;/code&gt; родительского элемента, кроме отмеченных как ненаследуемые (то есть созданные с помощью &lt;code&gt;ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT&lt;/code&gt; ) в родительском элементе , которые игнорируются; все сопоставленные ограничения дочерних таблиц не должны быть помечены как ненаследуемые. В настоящее время &lt;code&gt;PRIMARY KEY&lt;/code&gt; &lt;code&gt;UNIQUE&lt;/code&gt; , PRIMARY KEY и &lt;code&gt;FOREIGN KEY&lt;/code&gt; не рассматриваются, но это может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="9d0ef1c54ee5da6f3a9bc0faf2941d2e26078541" translate="yes" xml:space="preserve">
          <source>There should be no extra overhead in the parser or executor if a query does not need implicit type conversion. That is, if a query is well-formed and the types already match, then the query should execute without spending extra time in the parser and without introducing unnecessary implicit conversion calls in the query.</source>
          <target state="translated">Если запрос не нуждается в неявном приведении типа,то дополнительных накладных расходов в синтаксическом анализаторе или исполнителе не должно быть.То есть,если запрос хорошо сформирован и типы уже совпадают,то запрос должен выполняться без лишних затрат времени в синтаксическом анализаторе и без внесения в запрос ненужных вызовов неявного приведения типов.</target>
        </trans-unit>
        <trans-unit id="934618c1781f2f0a9f6bb79bbcc267c826504412" translate="yes" xml:space="preserve">
          <source>There was formerly an &lt;code&gt;ALTER INDEX OWNER&lt;/code&gt; variant, but this is now ignored (with a warning). An index cannot have an owner different from its table's owner. Changing the table's owner automatically changes the index as well.</source>
          <target state="translated">Раньше был вариант &lt;code&gt;ALTER INDEX OWNER&lt;/code&gt; , но теперь он игнорируется (с предупреждением). У индекса не может быть владельца, отличного от владельца его таблицы. Смена владельца таблицы также автоматически изменяет индекс.</target>
        </trans-unit>
        <trans-unit id="eb82410dec70b2b3321bff0d1e9388c3bd8dfd33" translate="yes" xml:space="preserve">
          <source>There's no need to manually create indexes on unique columns; doing so would just duplicate the automatically-created index.</source>
          <target state="translated">Нет необходимости вручную создавать индексы на уникальных столбцах;это просто дублирует автоматически созданный индекс.</target>
        </trans-unit>
        <trans-unit id="dd1c3102c4930b5f2a44ebfcda5a098872c67837" translate="yes" xml:space="preserve">
          <source>Thesauruses are used during indexing so any change in the thesaurus dictionary's parameters &lt;em&gt;requires&lt;/em&gt; reindexing. For most other dictionary types, small changes such as adding or removing stopwords does not force reindexing.</source>
          <target state="translated">При индексировании используются тезаурусы, поэтому любое изменение параметров словаря тезауруса &lt;em&gt;требует&lt;/em&gt; переиндексации. Для большинства других типов словарей небольшие изменения, такие как добавление или удаление стоп-слов, не приводят к переиндексации.</target>
        </trans-unit>
        <trans-unit id="5f1ad8c9ce64bcda09c594082de2a500ef5cce09" translate="yes" xml:space="preserve">
          <source>These are actually just special cases of the general casting notations discussed next.</source>
          <target state="translated">На самом деле,это лишь отдельные случаи из общих кастинговых нотаций,которые будут обсуждаться далее.</target>
        </trans-unit>
        <trans-unit id="1ede3bb37d9693ab9536c9fcd48ebe3c46555fd8" translate="yes" xml:space="preserve">
          <source>These are good sources to start learning about various kinds of encoding systems.</source>
          <target state="translated">Это хорошие источники для того,чтобы начать изучать различные виды систем кодирования.</target>
        </trans-unit>
        <trans-unit id="8a4a0666760118b211b5b7d0b41910720c832114" translate="yes" xml:space="preserve">
          <source>These are less likely to be problematic than &lt;code&gt;search_path&lt;/code&gt;, but can be handled with function &lt;code&gt;SET&lt;/code&gt; options if the need arises.</source>
          <target state="translated">Они менее проблемны, чем &lt;code&gt;search_path&lt;/code&gt; , но могут быть обработаны с помощью параметров функции &lt;code&gt;SET&lt;/code&gt; , если возникнет необходимость.</target>
        </trans-unit>
        <trans-unit id="e09b98f630a14c95107bbc1d571768385072e6a7" translate="yes" xml:space="preserve">
          <source>These are some examples of valid numeric constants:</source>
          <target state="translated">Вот некоторые примеры действительных числовых констант:</target>
        </trans-unit>
        <trans-unit id="2d394fc649569a5eeeb4c5600c0f12014850ba1f" translate="yes" xml:space="preserve">
          <source>These are the steps to perform an upgrade with pg_upgrade:</source>
          <target state="translated">Это шаги для выполнения обновления с помощью pg_upgrade:</target>
        </trans-unit>
        <trans-unit id="f72a6870691351c5c2b87041a8d81f8e78b27456" translate="yes" xml:space="preserve">
          <source>These attributes inform the query optimizer about the behavior of the function. At most one choice can be specified. If none of these appear, &lt;code&gt;VOLATILE&lt;/code&gt; is the default assumption.</source>
          <target state="translated">Эти атрибуты информируют оптимизатор запросов о поведении функции. Можно указать не более одного варианта. Если ни один из них не появляются, &lt;code&gt;VOLATILE&lt;/code&gt; является предположение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f85846f94f84f78007c888a90fb32598de3ea04f" translate="yes" xml:space="preserve">
          <source>These caches can typically be disabled; however, the method for doing this varies by operating system and drive type:</source>
          <target state="translated">Обычно эти кэши могут быть отключены,однако способ их выполнения зависит от операционной системы и типа привода:</target>
        </trans-unit>
        <trans-unit id="484e4f03dd4a3ca589988330c2b61dd6c51084dd" translate="yes" xml:space="preserve">
          <source>These clauses alter attributes originally set by &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. For more information, see the &lt;code&gt;CREATE ROLE&lt;/code&gt; reference page.</source>
          <target state="translated">Эти предложения изменяют атрибуты, изначально установленные командой &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; . Для получения дополнительной информации см. Справочную страницу &lt;code&gt;CREATE ROLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae13d4d630a34fa139e9046de2cb8f6bc13b3a42" translate="yes" xml:space="preserve">
          <source>These clauses define a role's ability to create databases. If &lt;code&gt;CREATEDB&lt;/code&gt; is specified, the role being defined will be allowed to create new databases. Specifying &lt;code&gt;NOCREATEDB&lt;/code&gt; will deny a role the ability to create databases. If not specified, &lt;code&gt;NOCREATEDB&lt;/code&gt; is the default.</source>
          <target state="translated">Эти пункты определяют способность роли создавать базы данных. Если &lt;code&gt;CREATEDB&lt;/code&gt; , определяемой роли будет разрешено создавать новые базы данных. Указание &lt;code&gt;NOCREATEDB&lt;/code&gt; откажет роли в возможности создавать базы данных. Если не указано, по умолчанию используется &lt;code&gt;NOCREATEDB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="236a4db02b1fa5b8bc065150c9e1f92cd0c2db65" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role &amp;ldquo;inherits&amp;rdquo; the privileges of roles it is a member of. A role with the &lt;code&gt;INHERIT&lt;/code&gt; attribute can automatically use whatever database privileges have been granted to all roles it is directly or indirectly a member of. Without &lt;code&gt;INHERIT&lt;/code&gt;, membership in another role only grants the ability to &lt;code&gt;SET ROLE&lt;/code&gt; to that other role; the privileges of the other role are only available after having done so. If not specified, &lt;code&gt;INHERIT&lt;/code&gt; is the default.</source>
          <target state="translated">Эти пункты определяют, &amp;laquo;наследует&amp;raquo; ли роль привилегии ролей, членом которых она является. Роль с атрибутом &lt;code&gt;INHERIT&lt;/code&gt; может автоматически использовать любые привилегии базы данных, предоставленные всем ролям, членом которых она прямо или косвенно является. Без &lt;code&gt;INHERIT&lt;/code&gt; членство в другой роли дает возможность &lt;code&gt;SET ROLE&lt;/code&gt; только этой другой роли; привилегии другой роли становятся доступны только после этого. Если не указано, по умолчанию используется &lt;code&gt;INHERIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8f7e3712b4368e28fc6b45f7eab106b1e33840d" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role bypasses every row-level security (RLS) policy. &lt;code&gt;NOBYPASSRLS&lt;/code&gt; is the default. Note that pg_dump will set &lt;code&gt;row_security&lt;/code&gt; to &lt;code&gt;OFF&lt;/code&gt; by default, to ensure all contents of a table are dumped out. If the user running pg_dump does not have appropriate permissions, an error will be returned. The superuser and owner of the table being dumped always bypass RLS.</source>
          <target state="translated">Эти пункты определяют, обходит ли роль каждую политику безопасности на уровне строк (RLS). &lt;code&gt;NOBYPASSRLS&lt;/code&gt; - значение по умолчанию. Обратите внимание, что pg_dump по умолчанию устанавливает &lt;code&gt;row_security&lt;/code&gt; в значение &lt;code&gt;OFF&lt;/code&gt; , чтобы гарантировать, что все содержимое таблицы выгружено. Если у пользователя, запускающего pg_dump, нет соответствующих разрешений, будет возвращена ошибка. Суперпользователь и владелец выгружаемой таблицы всегда обходят RLS.</target>
        </trans-unit>
        <trans-unit id="1c4c9abff0ed7aed3c18b9b9a05141b1d9e0e976" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role bypasses every row-level security (RLS) policy. &lt;code&gt;NOBYPASSRLS&lt;/code&gt; is the default. You must be a superuser to create a new role having the &lt;code&gt;BYPASSRLS&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdfb1f660e91b5c6f6fdf7bb5b01ee2031a6647b" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified, &lt;code&gt;NOREPLICATION&lt;/code&gt; is the default.</source>
          <target state="translated">Эти пункты определяют, является ли роль ролью репликации. Роль должна иметь этот атрибут (или быть суперпользователем), чтобы иметь возможность подключаться к серверу в режиме репликации (физическая или логическая репликация), а также для создания или удаления слотов репликации. Роль, имеющая атрибут &lt;code&gt;REPLICATION&lt;/code&gt; , является очень привилегированной ролью, и ее следует использовать только для ролей, фактически используемых для репликации. Если не указано, по умолчанию используется &lt;code&gt;NOREPLICATION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f08ec67a75e039b1e1d579f9d114eb5649ed79b" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified, &lt;code&gt;NOREPLICATION&lt;/code&gt; is the default. You must be a superuser to create a new role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93cac2364d542f963f918606f10bb473c25cf54c" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is allowed to log in; that is, whether the role can be given as the initial session authorization name during client connection. A role having the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be thought of as a user. Roles without this attribute are useful for managing database privileges, but are not users in the usual sense of the word. If not specified, &lt;code&gt;NOLOGIN&lt;/code&gt; is the default, except when &lt;code&gt;CREATE ROLE&lt;/code&gt; is invoked through its alternative spelling &lt;a href=&quot;sql-createuser&quot;&gt;CREATE USER&lt;/a&gt;.</source>
          <target state="translated">Эти пункты определяют, разрешен ли вход роли; то есть, может ли роль быть назначена в качестве имени авторизации начального сеанса во время соединения с клиентом. Роль, имеющую атрибут &lt;code&gt;LOGIN&lt;/code&gt; , можно рассматривать как пользователя. Роли без этого атрибута полезны для управления привилегиями базы данных, но не являются пользователями в обычном смысле этого слова. Если не указано, по умолчанию используется &lt;code&gt;NOLOGIN&lt;/code&gt; , за исключением случаев, когда &lt;code&gt;CREATE ROLE&lt;/code&gt; вызывается через альтернативное написание &lt;a href=&quot;sql-createuser&quot;&gt;CREATE USER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="181b83412fd4eddb3ac3029828e16b7a9b6b98ef" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role will be permitted to create new roles (that is, execute &lt;code&gt;CREATE ROLE&lt;/code&gt;). A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can also alter and drop other roles. If not specified, &lt;code&gt;NOCREATEROLE&lt;/code&gt; is the default.</source>
          <target state="translated">Эти предложения определяют, будет ли роли разрешено создавать новые роли (то есть выполнять &lt;code&gt;CREATE ROLE&lt;/code&gt; ). Роль с привилегией &lt;code&gt;CREATEROLE&lt;/code&gt; также может изменять и удалять другие роли. Если не указано, по умолчанию используется &lt;code&gt;NOCREATEROLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e0e211b5e3eb630f6887dce4107cdd808855949" translate="yes" xml:space="preserve">
          <source>These clauses determine whether the new role is a &amp;ldquo;superuser&amp;rdquo;, who can override all access restrictions within the database. Superuser status is dangerous and should be used only when really needed. You must yourself be a superuser to create a new superuser. If not specified, &lt;code&gt;NOSUPERUSER&lt;/code&gt; is the default.</source>
          <target state="translated">Эти пункты определяют, является ли новая роль &amp;laquo;суперпользователем&amp;raquo;, который может отменять все ограничения доступа в базе данных. Статус суперпользователя опасен и должен использоваться только тогда, когда это действительно необходимо. Чтобы создать нового суперпользователя, вы сами должны быть суперпользователем. Если не указано, по умолчанию используется &lt;code&gt;NOSUPERUSER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6a59cdbb5e799d0fed1a4aa2596214d1849fd5f" translate="yes" xml:space="preserve">
          <source>These clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If the &lt;code&gt;refcolumn&lt;/code&gt; list is omitted, the primary key of the &lt;code&gt;reftable&lt;/code&gt; is used. The referenced columns must be the columns of a non-deferrable unique or primary key constraint in the referenced table. The user must have &lt;code&gt;REFERENCES&lt;/code&gt; permission on the referenced table (either the whole table, or the specific referenced columns). The addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table. Note that foreign key constraints cannot be defined between temporary tables and permanent tables.</source>
          <target state="translated">Эти предложения определяют ограничение внешнего ключа, которое требует, чтобы группа из одного или нескольких столбцов новой таблицы содержала только те значения, которые соответствуют значениям в указанном столбце (столбцах) некоторой строки указанной таблицы. Если список &lt;code&gt;refcolumn&lt;/code&gt; опущен, используется первичный ключ &lt;code&gt;reftable&lt;/code&gt; . Столбцы, на которые указывает ссылка, должны быть столбцами неотложного ограничения уникальности или первичного ключа в таблице, на которую указывает ссылка. У пользователя должно быть разрешение &lt;code&gt;REFERENCES&lt;/code&gt; для указанной таблицы (либо для всей таблицы, либо для определенных столбцов, на которые указывает ссылка). Для добавления ограничения внешнего ключа требуется &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; .заблокировать указанную таблицу. Обратите внимание, что ограничения внешнего ключа не могут быть определены между временными и постоянными таблицами.</target>
        </trans-unit>
        <trans-unit id="857c0ae8d220b45b3955f09362ef789a9a3402e5" translate="yes" xml:space="preserve">
          <source>These commands are defined in the SQL standard, except for the &lt;code&gt;DEFERRABLE&lt;/code&gt; transaction mode and the &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; form, which are PostgreSQL extensions.</source>
          <target state="translated">Эти команды определены в стандарте SQL, за исключением &lt;code&gt;DEFERRABLE&lt;/code&gt; транзакции DEFERRABLE и формы &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; , которые являются расширениями PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="7ad3dc4d8a64e61d33f79320b9d9d378ce755f14" translate="yes" xml:space="preserve">
          <source>These commands may be used to end SQL queries, taking the place of the terminating semicolon (&lt;code&gt;;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f08278f74b1bbe88f6fdde4ee30a3df428b62a8f" translate="yes" xml:space="preserve">
          <source>These comparison operators are available for all built-in data types that have a natural ordering, including numeric, string, and date/time types. In addition, arrays, composite types, and ranges can be compared if their component data types are comparable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a3af7e0da0acbd34de05752f110be6e0e62942" translate="yes" xml:space="preserve">
          <source>These configuration parameters provide a crude method of influencing the query plans chosen by the query optimizer. If the default plan chosen by the optimizer for a particular query is not optimal, a &lt;em&gt;temporary&lt;/em&gt; solution is to use one of these configuration parameters to force the optimizer to choose a different plan. Better ways to improve the quality of the plans chosen by the optimizer include adjusting the planner cost constants (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;), running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; manually, increasing the value of the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter, and increasing the amount of statistics collected for specific columns using &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;.</source>
          <target state="translated">Эти параметры конфигурации обеспечивают грубый метод влияния на планы запросов, выбранные оптимизатором запросов. Если план по умолчанию, выбранный оптимизатором для определенного запроса, не является оптимальным, &lt;em&gt;временным&lt;/em&gt; решением является использование одного из этих параметров конфигурации, чтобы заставить оптимизатор выбрать другой план. Лучшие способы улучшить качество планов, выбранных оптимизатором, включают настройку констант затрат планировщика (см. &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Раздел 19.7.2&lt;/a&gt; ), запуск &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; вручную, увеличение значения параметра конфигурации &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; и увеличение количества статистики, собираемой для определенных столбцов. используя &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97b05ff9bc8f45601af490580b1cf57f630e4008" translate="yes" xml:space="preserve">
          <source>These cost-based decisions will be made at plan time, not execution time. This means that when prepared statements are in use, and a generic plan is used (see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;), the values of the configuration parameters in effect at prepare time control the decisions, not the settings at execution time.</source>
          <target state="translated">Эти ориентированные на стоимость решения будут приниматься во время планирования, а не во время выполнения. Это означает, что, когда используются подготовленные операторы и используется общий план (см. &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; ), значения параметров конфигурации, действующие во время подготовки, управляют решениями, а не настройками во время выполнения.</target>
        </trans-unit>
        <trans-unit id="bd102e49cf8b96793cacdde24d32614ffb078540" translate="yes" xml:space="preserve">
          <source>These counts can be particularly valuable for filter conditions applied at join nodes. The &amp;ldquo;Rows Removed&amp;rdquo; line only appears when at least one scanned row, or potential join pair in the case of a join node, is rejected by the filter condition.</source>
          <target state="translated">Эти подсчеты могут быть особенно полезны для условий фильтрации, применяемых в узлах соединения. Строка &amp;laquo;Удаленные строки&amp;raquo; появляется только тогда, когда по крайней мере одна отсканированная строка или потенциальная пара соединения в случае узла соединения отклоняется условием фильтрации.</target>
        </trans-unit>
        <trans-unit id="9525af1114ee853e1be2e829b6746f11684a7213" translate="yes" xml:space="preserve">
          <source>These examples all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ee06a454af3afd2603bd1ff07db9463f13f34e" translate="yes" xml:space="preserve">
          <source>These examples show use of &lt;code&gt;position&lt;/code&gt; fields:</source>
          <target state="translated">Эти примеры показывают использование полей &lt;code&gt;position&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f944ac8005ce9ea42b0263baeef3f32035cd55b8" translate="yes" xml:space="preserve">
          <source>These examples show use of &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22989ebfc8062e1b7b80c3eb7a3f32777c7de5c" translate="yes" xml:space="preserve">
          <source>These examples would all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown.</source>
          <target state="translated">Во всех этих примерах будет указан один и тот же адрес. Для цифр от &lt;code&gt;a&lt;/code&gt; до &lt;code&gt;f&lt;/code&gt; можно использовать верхний и нижний регистр . Вывод всегда в первой из показанных форм.</target>
        </trans-unit>
        <trans-unit id="ef90197c0c87bcadf3fd64cda40bcfb6928639b3" translate="yes" xml:space="preserve">
          <source>These examples would all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown. The last six input formats that are mentioned above are not part of any standard. To convert a traditional 48 bit MAC address in EUI-48 format to modified EUI-64 format to be included as the host portion of an IPv6 address, use &lt;code&gt;macaddr8_set7bit&lt;/code&gt; as shown:</source>
          <target state="translated">Во всех этих примерах будет указан один и тот же адрес. Для цифр от &lt;code&gt;a&lt;/code&gt; до &lt;code&gt;f&lt;/code&gt; можно использовать верхний и нижний регистр . Вывод всегда в первой из показанных форм. Последние шесть форматов ввода, упомянутые выше, не являются частью какого-либо стандарта. Чтобы преобразовать традиционный 48-битный MAC-адрес в формате EUI-48 в модифицированный формат EUI-64, который будет включен в качестве хост-части адреса IPv6, используйте &lt;code&gt;macaddr8_set7bit&lt;/code&gt; , как показано:</target>
        </trans-unit>
        <trans-unit id="31279325b3351a8e4e53dffc8199d39f6d4f7fef" translate="yes" xml:space="preserve">
          <source>These fields do not apply to &lt;code&gt;local&lt;/code&gt; records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754aea8d14b67db99a02b25bbf6a65624166cf06" translate="yes" xml:space="preserve">
          <source>These fields only apply to &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;hostssl&lt;/code&gt;, and &lt;code&gt;hostnossl&lt;/code&gt; records.</source>
          <target state="translated">Эти поля применяются только к &lt;code&gt;hostssl&lt;/code&gt; &lt;code&gt;host&lt;/code&gt; , hostssl и &lt;code&gt;hostnossl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72eddf11f12dc6025be9e6bc42deb5078bd81869" translate="yes" xml:space="preserve">
          <source>These forms alter the sequence that underlies an existing identity column. &lt;code&gt;sequence_option&lt;/code&gt; is an option supported by &lt;a href=&quot;sql-altersequence&quot;&gt;ALTER SEQUENCE&lt;/a&gt; such as &lt;code&gt;INCREMENT BY&lt;/code&gt;.</source>
          <target state="translated">Эти формы изменяют последовательность, лежащую в основе существующего столбца идентификаторов. &lt;code&gt;sequence_option&lt;/code&gt; - это опция, поддерживаемая &lt;a href=&quot;sql-altersequence&quot;&gt;ALTER SEQUENCE,&lt;/a&gt; например &lt;code&gt;INCREMENT BY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94eb82c63d8a50cb48f48fc67bdfcbfef03ff87e" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is an identity column or change the generation attribute of an existing identity column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">Эти формы изменяют, является ли столбец столбцом идентификаторов или изменяют атрибут создания существующего столбца идентификаторов. См. &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="1bc8e996c262c353a8a23c5058e8d5716c2b27c6" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is an identity column or change the generation attribute of an existing identity column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details. Like &lt;code&gt;SET DEFAULT&lt;/code&gt;, these forms only affect the behavior of subsequent &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands; they do not cause rows already in the table to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41d9a5a685b55548689fcb598e8403262b9b305" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is marked to allow null values or to reject null values.</source>
          <target state="translated">Эти формы изменяют,будет ли столбец помечен как разрешающий нулевые значения или как отвергающий нулевые значения.</target>
        </trans-unit>
        <trans-unit id="93ec998a277e66396552c3ff5dd5565fd0687627" translate="yes" xml:space="preserve">
          <source>These forms change whether a domain is marked to allow NULL values or to reject NULL values. You can only &lt;code&gt;SET NOT NULL&lt;/code&gt; when the columns using the domain contain no null values.</source>
          <target state="translated">Эти формы изменяют, помечен ли домен, чтобы разрешить значения NULL или отклонить значения NULL. Вы можете установить &lt;code&gt;SET NOT NULL&lt;/code&gt; только в том случае, если столбцы, использующие домен, не содержат нулевых значений.</target>
        </trans-unit>
        <trans-unit id="e6fb1f760d0b7848e70cd0fa414aa5c5a55c2d88" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of event triggers. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. See also &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;.</source>
          <target state="translated">Эти формы настраивают срабатывание триггеров событий. Отключенный триггер по-прежнему известен системе, но не выполняется, когда происходит его запускающее событие. См. Также &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed16a2682c252a84ef2e6b9d1135068b069708b2" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of rewrite rules belonging to the table. A disabled rule is still known to the system, but is not applied during query rewriting. The semantics are as for disabled/enabled triggers. This configuration is ignored for &lt;code&gt;ON SELECT&lt;/code&gt; rules, which are always applied in order to keep views working even if the current session is in a non-default replication role.</source>
          <target state="translated">Эти формы настраивают срабатывание правил перезаписи, принадлежащих таблице. Отключенное правило по-прежнему известно системе, но не применяется во время перезаписи запроса. Семантика такая же, как для отключенных / включенных триггеров. Эта конфигурация игнорируется для правил &lt;code&gt;ON SELECT&lt;/code&gt; , которые всегда применяются для обеспечения работы представлений, даже если текущий сеанс находится в нестандартной роли репликации.</target>
        </trans-unit>
        <trans-unit id="78d1881ed192b61ccc8ca5381f7ecf2d5ccbebb4" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of trigger(s) belonging to the foreign table. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">Эти формы настраивают срабатывание триггера (ов), принадлежащего внешней таблице. Смотрите аналогичную форму &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="537c2d5f6bf4afe4d0ece015a719f2c170c94088" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of trigger(s) belonging to the table. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. For a deferred trigger, the enable status is checked when the event occurs, not when the trigger function is actually executed. One can disable or enable a single trigger specified by name, or all triggers on the table, or only user triggers (this option excludes internally generated constraint triggers such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints). Disabling or enabling internally generated constraint triggers requires superuser privileges; it should be done with caution since of course the integrity of the constraint cannot be guaranteed if the triggers are not executed.</source>
          <target state="translated">Эти формы конфигурируют стрельбу по триггеру(ам),принадлежащему(ым)таблице.Отключенный триггер все еще известен системе,но не выполняется,когда происходит его срабатывание.Для отложенного триггера статус разрешения проверяется при наступлении события,а не при фактическом выполнении функции триггера.Можно отключить или включить один триггер,заданный по имени,или все триггеры таблицы,или только пользовательские триггеры (эта опция исключает внутрисистемные триггеры ограничений,например,те,которые используются для реализации ограничений посторонних ключей или отложенных ограничений уникальности и исключения).Отключение или включение триггеров внутренних ограничений требует привилегий суперпользователя;это следует делать с осторожностью,так как,конечно,целостность ограничения не может быть гарантирована,если триггеры не выполняются.</target>
        </trans-unit>
        <trans-unit id="e52e37f61e3318ab7cf1d7a034b06767466f19cd" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table when the user is the table owner. If enabled, row level security policies will be applied when the user is the table owner. If disabled (the default) then row level security will not be applied when the user is the table owner. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">Эти формы управляют применением политик безопасности строк, принадлежащих таблице, когда пользователь является владельцем таблицы. Если этот параметр включен, политики безопасности на уровне строк будут применяться, когда пользователь является владельцем таблицы. Если отключено (по умолчанию), защита на уровне строк не будет применяться, если пользователь является владельцем таблицы. См. Также &lt;a href=&quot;sql-createpolicy&quot;&gt;СОЗДАТЬ ПОЛИТИКУ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8b1a193cdfbb05ae9fcb8caf7ab280345bebc71" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then a default-deny policy is applied. Note that policies can exist for a table even if row level security is disabled - in this case, the policies will NOT be applied and the policies will be ignored. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">Эти формы управляют применением политик безопасности строк, принадлежащих таблице. Если включено и для таблицы нет политик, применяется политика запрета по умолчанию. Обратите внимание, что политики могут существовать для таблицы, даже если защита на уровне строк отключена - в этом случае политики НЕ будут применяться, а политики будут игнорироваться. См. Также &lt;a href=&quot;sql-createpolicy&quot;&gt;СОЗДАТЬ ПОЛИТИКУ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb00f1090b2d9838bfed692cafa4246a07d423cf" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then a default-deny policy is applied. Note that policies can exist for a table even if row level security is disabled. In this case, the policies will &lt;em&gt;not&lt;/em&gt; be applied and the policies will be ignored. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de2d316d42b6299041b7b9b1fe769e5eb9fc501" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column (where removal is equivalent to setting the default value to NULL). The new default value will only apply in subsequent &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands; it does not cause rows already in the table to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ad545d11775ef6194d67bbd91b31263b043327" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column. A view column's default value is substituted into any &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command whose target is the view, before applying any rules or triggers for the view. The view's default will therefore take precedence over any default values from underlying relations.</source>
          <target state="translated">Эти формы устанавливают или удаляют значение по умолчанию для столбца. Значение по умолчанию для столбца представления подставляется в любую команду &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; , целью которой является представление, перед применением каких-либо правил или триггеров для представления. Следовательно, значение по умолчанию для представления будет иметь приоритет над любыми значениями по умолчанию из базовых отношений.</target>
        </trans-unit>
        <trans-unit id="a2f96c4d1ee03fc069f57f93ee22ce31fb12871d" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column. Default values only apply in subsequent &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands; they do not cause rows already in the table to change.</source>
          <target state="translated">Эти формы устанавливают или удаляют значение по умолчанию для столбца. Значения по умолчанию применяются только в последующих командах &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; ; они не вызывают изменения строк, уже имеющихся в таблице.</target>
        </trans-unit>
        <trans-unit id="c9f74070b70e1b37c8a8a55a2765bed5bb39ae4b" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a domain. Note that defaults only apply to subsequent &lt;code&gt;INSERT&lt;/code&gt; commands; they do not affect rows already in a table using the domain.</source>
          <target state="translated">Эти формы устанавливают или удаляют значение по умолчанию для домена. Обратите внимание, что значения по умолчанию применяются только к последующим командам &lt;code&gt;INSERT&lt;/code&gt; ; они не влияют на строки, уже находящиеся в таблице, использующей домен.</target>
        </trans-unit>
        <trans-unit id="c517087178e89eb8504bd404d1b9002cc9225010" translate="yes" xml:space="preserve">
          <source>These functions act like their counterparts described above without the &lt;code&gt;_tz&lt;/code&gt; suffix, except that these functions support comparisons of date/time values that require timezone-aware conversions. The example below requires interpretation of the date-only value &lt;code&gt;2015-08-02&lt;/code&gt; as a timestamp with time zone, so the result depends on the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting. Due to this dependency, these functions are marked as stable, which means these functions cannot be used in indexes. Their counterparts are immutable, and so can be used in indexes; but they will throw errors if asked to make such comparisons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1609442aa33410461ce94595a5363c37f09493d1" translate="yes" xml:space="preserve">
          <source>These functions are provided mostly for illustration purposes. You can create your own return types and functions based on the underlying &lt;code&gt;crosstab()&lt;/code&gt; function. There are two ways to do it:</source>
          <target state="translated">Эти функции представлены в основном в иллюстративных целях. Вы можете создавать свои собственные возвращаемые типы и функции на основе базовой функции &lt;code&gt;crosstab()&lt;/code&gt; . Сделать это можно двумя способами:</target>
        </trans-unit>
        <trans-unit id="b71ab786c550ccb22b4bc0a42b2b14940119395f" translate="yes" xml:space="preserve">
          <source>These functions check whether a &lt;code&gt;text&lt;/code&gt; string is well-formed XML, returning a Boolean result. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; checks for a well-formed document, while &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; checks for well-formed content. &lt;code&gt;xml_is_well_formed&lt;/code&gt; does the former if the &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt; configuration parameter is set to &lt;code&gt;DOCUMENT&lt;/code&gt;, or the latter if it is set to &lt;code&gt;CONTENT&lt;/code&gt;. This means that &lt;code&gt;xml_is_well_formed&lt;/code&gt; is useful for seeing whether a simple cast to type &lt;code&gt;xml&lt;/code&gt; will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of &lt;code&gt;XMLPARSE&lt;/code&gt; will succeed.</source>
          <target state="translated">Эти функции проверяют, является ли &lt;code&gt;text&lt;/code&gt; строка правильно сформированным XML, возвращая логический результат. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; проверяет правильно сформированный документ, а &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; проверяет правильно сформированный контент. &lt;code&gt;xml_is_well_formed&lt;/code&gt; выполняет первое, если для параметра конфигурации &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt; установлено значение &lt;code&gt;DOCUMENT&lt;/code&gt; , или второе, если для него установлено значение &lt;code&gt;CONTENT&lt;/code&gt; . Это означает, что &lt;code&gt;xml_is_well_formed&lt;/code&gt; полезно для проверки того, будет ли успешным простое приведение к типу &lt;code&gt;xml&lt;/code&gt; , тогда как две другие функции полезны для &lt;code&gt;XMLPARSE&lt;/code&gt; соответствующих вариантов XMLPARSE .</target>
        </trans-unit>
        <trans-unit id="1992890b76b79219185f1f21ec736953dc79e0bb" translate="yes" xml:space="preserve">
          <source>These functions check whether a &lt;code&gt;text&lt;/code&gt; string represents well-formed XML, returning a Boolean result. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; checks for a well-formed document, while &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; checks for well-formed content. &lt;code&gt;xml_is_well_formed&lt;/code&gt; does the former if the &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt; configuration parameter is set to &lt;code&gt;DOCUMENT&lt;/code&gt;, or the latter if it is set to &lt;code&gt;CONTENT&lt;/code&gt;. This means that &lt;code&gt;xml_is_well_formed&lt;/code&gt; is useful for seeing whether a simple cast to type &lt;code&gt;xml&lt;/code&gt; will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of &lt;code&gt;XMLPARSE&lt;/code&gt; will succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60a18e52593260f76cbca36e7fdad5953d14de4" translate="yes" xml:space="preserve">
          <source>These functions evaluate the XPath query on the supplied document, and cast the result to the specified type.</source>
          <target state="translated">Эти функции оценивают запрос XPath к поставляемому документу и приводят результат к указанному типу.</target>
        </trans-unit>
        <trans-unit id="b4542e502e3568b9c387481842c5701029f5b7b1" translate="yes" xml:space="preserve">
          <source>These functions ignore tables that are not readable by the current user. The database-wide functions additionally ignore schemas that the current user does not have &lt;code&gt;USAGE&lt;/code&gt; (lookup) privilege for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a3b49c368c625ddd8e1b267d172c4c23e85fb8" translate="yes" xml:space="preserve">
          <source>These functions only run a cipher over data; they don't have any advanced features of PGP encryption. Therefore they have some major problems:</source>
          <target state="translated">Эти функции запускают только шифр над данными;у них нет никаких расширенных возможностей PGP шифрования.Поэтому у них есть некоторые серьезные проблемы:</target>
        </trans-unit>
        <trans-unit id="2e87e18038a41ce286dc1540ea6ddc6645f709cb" translate="yes" xml:space="preserve">
          <source>These functions wrap/unwrap binary data into PGP ASCII-armor format, which is basically Base64 with CRC and additional formatting.</source>
          <target state="translated">Эти функции обёртывают/развёртывают двоичные данные в формат PGP ASCII-armor,который в основном Base64 с CRC и дополнительным форматированием.</target>
        </trans-unit>
        <trans-unit id="a69e2cf20fe43ca97cfd2d3152291de2a47cffbd" translate="yes" xml:space="preserve">
          <source>These instructions assume that your existing installation is under the &lt;code&gt;/usr/local/pgsql&lt;/code&gt; directory, and that the data area is in &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;. Substitute your paths appropriately.</source>
          <target state="translated">Эти инструкции предполагают, что ваша существующая установка находится в каталоге &lt;code&gt;/usr/local/pgsql&lt;/code&gt; , а область данных находится в &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; . Замените свои пути соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="4c32652f01e68dc2b9e4e1795da20ec44b710efa" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on casts.</source>
          <target state="translated">Эти ключевые слова не имеют никакого эффекта,так как нет никаких зависимостей от каст.</target>
        </trans-unit>
        <trans-unit id="bea3c1233d30126b2b7a88c0987f5eda6383c5d4" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on conversions.</source>
          <target state="translated">Эти ключевые слова не имеют никакого эффекта,так как нет никаких зависимостей от преобразования.</target>
        </trans-unit>
        <trans-unit id="0fd011ed971053a775e55c8199ea3272eca8d26f" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on policies.</source>
          <target state="translated">Эти ключевые слова не имеют никакого эффекта,поскольку нет никакой зависимости от политики.</target>
        </trans-unit>
        <trans-unit id="a6e707f7bc3e009a0e21e941c667a8cfc394f561" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on publications.</source>
          <target state="translated">Эти ключевые слова не имеют никакого эффекта,так как нет никакой зависимости от публикаций.</target>
        </trans-unit>
        <trans-unit id="32c4da55bd25afdbc9c41ed6381881695d3bb025" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on subscriptions.</source>
          <target state="translated">Эти ключевые слова не имеют никакого эффекта,так как нет никаких зависимостей от подписки.</target>
        </trans-unit>
        <trans-unit id="2c7609a430b2441baa8c916ed20ac5c190ce5d75" translate="yes" xml:space="preserve">
          <source>These messages are harmless and should be ignored.</source>
          <target state="translated">Эти сообщения безвредны и должны быть проигнорированы.</target>
        </trans-unit>
        <trans-unit id="0c905ac1adcf65ee4d503774195629e18e03ce45" translate="yes" xml:space="preserve">
          <source>These numbers are current as of the last &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; on the table. The planner then fetches the actual current number of pages in the table (this is a cheap operation, not requiring a table scan). If that is different from &lt;code&gt;relpages&lt;/code&gt; then &lt;code&gt;reltuples&lt;/code&gt; is scaled accordingly to arrive at a current number-of-rows estimate. In the example above, the value of &lt;code&gt;relpages&lt;/code&gt; is up-to-date so the rows estimate is the same as &lt;code&gt;reltuples&lt;/code&gt;.</source>
          <target state="translated">Эти числа актуальны на момент последнего &lt;code&gt;VACUUM&lt;/code&gt; или &lt;code&gt;ANALYZE&lt;/code&gt; в таблице. Затем планировщик извлекает фактическое текущее количество страниц в таблице (это дешевая операция, не требующая сканирования таблицы). Если это отличается от &lt;code&gt;relpages&lt;/code&gt; , то &lt;code&gt;reltuples&lt;/code&gt; масштабируется соответствующим образом, чтобы получить текущую оценку количества строк. В приведенном выше примере значение &lt;code&gt;relpages&lt;/code&gt; является актуальным, поэтому оценка строк такая же, как и &lt;code&gt;reltuples&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e10d3fa9498e1464949f282d6e93d894677beaed" translate="yes" xml:space="preserve">
          <source>These numbers are derived very straightforwardly. If you do:</source>
          <target state="translated">Эти числа выведены очень просто.Если ты это сделаешь:</target>
        </trans-unit>
        <trans-unit id="3ceb62071b97b9d98e29565b51240d61862b6aa6" translate="yes" xml:space="preserve">
          <source>These operations are also possible using &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. &lt;code&gt;ALTER INDEX&lt;/code&gt; is in fact just an alias for the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that apply to indexes.</source>
          <target state="translated">Эти операции также возможны с помощью &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; . &lt;code&gt;ALTER INDEX&lt;/code&gt; на самом деле является просто псевдонимом для форм &lt;code&gt;ALTER TABLE&lt;/code&gt; , которые применяются к индексам.</target>
        </trans-unit>
        <trans-unit id="545a0c8a716c900f9e4c80a9d1bee182bedf1b50" translate="yes" xml:space="preserve">
          <source>These operations are not as efficient as the SQL &lt;code&gt;COPY&lt;/code&gt; command with a file or program data source or destination, because all data must pass through the client/server connection. For large amounts of data the SQL command might be preferable.</source>
          <target state="translated">Эти операции не так эффективны, как команда SQL &lt;code&gt;COPY&lt;/code&gt; с источником или местом назначения данных файла или программы, потому что все данные должны проходить через соединение клиент / сервер. Для больших объемов данных предпочтительнее использовать команду SQL.</target>
        </trans-unit>
        <trans-unit id="127d5c1d5ec611dd1c5cea591e059868fdcde0f9" translate="yes" xml:space="preserve">
          <source>These operators do not make a lot of sense for any practical purpose but sorting. These operators first compare (a) to (c), and if these are equal, compare (b) to (d). That results in reasonably good sorting in most cases, which is useful if you want to use ORDER BY with this type.</source>
          <target state="translated">Эти операторы не имеют никакого смысла для какой-либо практической цели,кроме сортировки.Эти операторы сначала сравнивают (a)-(c),а если они равны,то сравнивают (b)-(d).Это приводит к достаточно хорошей сортировке в большинстве случаев,что полезно,если вы хотите использовать ORDER BY с этим типом.</target>
        </trans-unit>
        <trans-unit id="0263a47917171f02351f77d8e8b63fd3b27641de" translate="yes" xml:space="preserve">
          <source>These option names are recognized case-insensitively. Any unspecified options receive these defaults:</source>
          <target state="translated">Эти названия опций распознаются без учета регистра.Любые неуказанные опции получают эти значения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="97b00e5b641f2fbb1f110712d8ca4d9e2d1eb19a" translate="yes" xml:space="preserve">
          <source>These option names are recognized case-insensitively. You must double-quote string values if they contain spaces or commas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae23616e05cfe7a713aa38934f0f1dc39a127ad" translate="yes" xml:space="preserve">
          <source>These options can be used to control the names used in SQL statements sent to the remote PostgreSQL server. These options are needed when a foreign table is created with names different from the underlying remote table's names.</source>
          <target state="translated">Эти опции могут быть использованы для управления именами,используемыми в SQL операторах,посылаемых на удаленный PostgreSQL сервер.Эти опции необходимы,когда создается иностранная таблица с именами,отличными от имен базовой удаленной таблицы.</target>
        </trans-unit>
        <trans-unit id="d77fba085883250197e1d576feb3bfa1670ceb86" translate="yes" xml:space="preserve">
          <source>These options can only be specified for a foreign table or its columns, not in the options of the &lt;code&gt;file_fdw&lt;/code&gt; foreign-data wrapper, nor in the options of a server or user mapping using the wrapper.</source>
          <target state="translated">Эти параметры могут быть указаны только для &lt;code&gt;file_fdw&lt;/code&gt; таблицы или ее столбцов, но не в параметрах оболочки внешних данных file_fdw , а также в параметрах отображения сервера или пользователя с использованием оболочки.</target>
        </trans-unit>
        <trans-unit id="00c89bc3ee002172b7e73344d78285229be1f391" translate="yes" xml:space="preserve">
          <source>These parameters (except the XPath strings) are just substituted into a plain SQL SELECT statement, so you have some flexibility &amp;mdash; the statement is</source>
          <target state="translated">Эти параметры (кроме строк XPath) просто подставляются в простой оператор SQL SELECT, поэтому у вас есть некоторая гибкость - оператор</target>
        </trans-unit>
        <trans-unit id="c2aabd8f5a3412d7716945926dce543c9d86d614" translate="yes" xml:space="preserve">
          <source>These parameters can be set on any server that is to send replication data to one or more standby servers. The master is always a sending server, so these parameters must always be set on the master. The role and meaning of these parameters does not change after a standby becomes the master.</source>
          <target state="translated">Эти параметры могут быть установлены на любом сервере,который будет посылать данные репликации на один или несколько резервных серверов.Ведущий сервер всегда является сервером отправки,поэтому эти параметры всегда должны быть установлены на ведущем сервере.Роль и значение этих параметров не меняются после того,как резервный сервер становится ведущим.</target>
        </trans-unit>
        <trans-unit id="0c34294a4db205be8e19649f7f900fbda851ca14" translate="yes" xml:space="preserve">
          <source>These parameters can be set on the master/primary server that is to send replication data to one or more standby servers. Note that in addition to these parameters, &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; must be set appropriately on the master server, and optionally WAL archiving can be enabled as well (see &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVING&quot;&gt;Section 19.5.3&lt;/a&gt;). The values of these parameters on standby servers are irrelevant, although you may wish to set them there in preparation for the possibility of a standby becoming the master.</source>
          <target state="translated">Эти параметры могут быть установлены на главном / основном сервере, который должен отправлять данные репликации на один или несколько резервных серверов. Обратите внимание, что в дополнение к этим параметрам на &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;главном сервере&lt;/a&gt; должен быть соответствующим образом установлен wal_level , и при необходимости также может быть включено архивирование WAL (см. &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVING&quot;&gt;Раздел 19.5.3&lt;/a&gt; ). Значения этих параметров на резервных серверах не имеют значения, хотя вы можете захотеть установить их там, чтобы подготовиться к тому, что резервный сервер станет главным.</target>
        </trans-unit>
        <trans-unit id="4d75398d82f486d5c040810e5532c3a355a6c99c" translate="yes" xml:space="preserve">
          <source>These parameters control server-wide statistics collection features. When statistics collection is enabled, the data that is produced can be accessed via the &lt;code&gt;pg_stat&lt;/code&gt; and &lt;code&gt;pg_statio&lt;/code&gt; family of system views. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt; for more information.</source>
          <target state="translated">Эти параметры управляют функциями сбора статистики на сервере. Когда сбор статистики включен, к созданным данным можно получить доступ через семейство системных представлений &lt;code&gt;pg_stat&lt;/code&gt; и &lt;code&gt;pg_statio&lt;/code&gt; . Обратитесь к &lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;Главе 27&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="0d575b835ad7e47410bdf9d6f66f26ab665d0047" translate="yes" xml:space="preserve">
          <source>These parameters control server-wide statistics collection features. When statistics collection is enabled, the data that is produced can be accessed via the &lt;code&gt;pg_stat&lt;/code&gt; and &lt;code&gt;pg_statio&lt;/code&gt; family of system views. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7058fa11283b8e308dc5c38fd60ebf25607e531" translate="yes" xml:space="preserve">
          <source>These parameters enable various debugging output to be emitted. When set, they print the resulting parse tree, the query rewriter output, or the execution plan for each executed query. These messages are emitted at &lt;code&gt;LOG&lt;/code&gt; message level, so by default they will appear in the server log but will not be sent to the client. You can change that by adjusting &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; and/or &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt;. These parameters are off by default.</source>
          <target state="translated">Эти параметры позволяют выдавать различные отладочные данные. Если установлено, они распечатывают результирующее дерево синтаксического анализа, выходные данные средства перезаписи запросов или план выполнения для каждого выполненного запроса. Эти сообщения отправляются на уровне сообщений &lt;code&gt;LOG&lt;/code&gt; , поэтому по умолчанию они будут отображаться в журнале сервера, но не будут отправлены клиенту. Вы можете изменить это, &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;настроив client_min_messages&lt;/a&gt; и / или &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt; . По умолчанию эти параметры отключены.</target>
        </trans-unit>
        <trans-unit id="1defee4ea46ba6aaadce70e43d5781b50b0c40a2" translate="yes" xml:space="preserve">
          <source>These parameters must be set in &lt;code&gt;postgresql.conf&lt;/code&gt;. Typical usage might be:</source>
          <target state="translated">Эти параметры должны быть установлены в &lt;code&gt;postgresql.conf&lt;/code&gt; . Типичное использование может быть:</target>
        </trans-unit>
        <trans-unit id="51c50b20efcdf41bd58d1a6d4948e28cfd164232" translate="yes" xml:space="preserve">
          <source>These popular data structures were originally developed for in-memory usage. In main memory, they are usually designed as a set of dynamically allocated nodes linked by pointers. This is not suitable for direct storing on disk, since these chains of pointers can be rather long which would require too many disk accesses. In contrast, disk-based data structures should have a high fanout to minimize I/O. The challenge addressed by SP-GiST is to map search tree nodes to disk pages in such a way that a search need access only a few disk pages, even if it traverses many nodes.</source>
          <target state="translated">Эти популярные структуры данных изначально были разработаны для использования в памяти.В основной памяти они обычно проектируются как набор динамически распределяемых узлов,связанных указателями.Это не подходит для прямого хранения на диске,так как эти цепочки указателей могут быть довольно длинными,что потребует слишком много доступа к диску.В отличие от этого,структуры данных на диске должны иметь высокий разветвитель для минимизации ввода-вывода.Задача,решаемая SP-GiST,состоит в том,чтобы сопоставить узлы дерева поиска со страницами диска таким образом,чтобы поиск требовал доступа только к нескольким страницам диска,даже если он пересекает много узлов.</target>
        </trans-unit>
        <trans-unit id="929fc5ec9668da12721d514b3f6bf4c331845b00" translate="yes" xml:space="preserve">
          <source>These represent the IEEE 754 special values &amp;ldquo;infinity&amp;rdquo;, &amp;ldquo;negative infinity&amp;rdquo;, and &amp;ldquo;not-a-number&amp;rdquo;, respectively. When writing these values as constants in an SQL command, you must put quotes around them, for example &lt;code&gt;UPDATE table SET x = '-Infinity'&lt;/code&gt;. On input, these strings are recognized in a case-insensitive manner.</source>
          <target state="translated">Они представляют собой специальные значения IEEE 754 &amp;laquo;бесконечность&amp;raquo;, &amp;laquo;отрицательная бесконечность&amp;raquo; и &amp;laquo;не-число&amp;raquo;, соответственно. При записи этих значений как констант в команде SQL вы должны заключить их в кавычки, например &lt;code&gt;UPDATE table SET x = '-Infinity'&lt;/code&gt; . При вводе эти строки распознаются без учета регистра.</target>
        </trans-unit>
        <trans-unit id="f1107e48978793d7f588abce7216f17e213bc711" translate="yes" xml:space="preserve">
          <source>These rules are very similar to those for writing field values in composite-type literals. See &lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;Section 8.16.6&lt;/a&gt; for additional commentary.</source>
          <target state="translated">Эти правила очень похожи на правила записи значений полей в литералы составного типа. См. Дополнительные комментарии в &lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;Разделе 8.16.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f4ab75f18b56a1736b944ffdb026f1b2a9cc643" translate="yes" xml:space="preserve">
          <source>These semaphore-related settings are read-only as far as &lt;code&gt;sysctl&lt;/code&gt; is concerned, but can be set in &lt;code&gt;/boot/loader.conf&lt;/code&gt;:</source>
          <target state="translated">Эти настройки, связанные с семафором, доступны только для чтения, что касается &lt;code&gt;sysctl&lt;/code&gt; , но могут быть установлены в &lt;code&gt;/boot/loader.conf&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0eb1c6b354c2721dc2500c187dae9d22e4b37ec" translate="yes" xml:space="preserve">
          <source>These settings can be set from &lt;code&gt;postgresql.conf&lt;/code&gt;, or within a session via the &lt;code&gt;SET&lt;/code&gt; command. Any user is allowed to change their session-local value. Changes in &lt;code&gt;postgresql.conf&lt;/code&gt; will affect existing sessions only if no session-local value has been established with &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">Эти настройки можно установить из &lt;code&gt;postgresql.conf&lt;/code&gt; или в рамках сеанса с помощью команды &lt;code&gt;SET&lt;/code&gt; . Любой пользователь может изменить свое локальное значение сеанса. Изменения в &lt;code&gt;postgresql.conf&lt;/code&gt; повлияют на существующие сеансы только в том случае, если локальное значение сеанса не было установлено с помощью &lt;code&gt;SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0adef7245cebc3b52bd4dfc1694701eadaec06f1" translate="yes" xml:space="preserve">
          <source>These settings can be set from &lt;code&gt;postgresql.conf&lt;/code&gt;, or within a session via the &lt;code&gt;SET&lt;/code&gt; command; but only superusers can change them via &lt;code&gt;SET&lt;/code&gt;. Changes in &lt;code&gt;postgresql.conf&lt;/code&gt; will affect existing sessions only if no session-local value has been established with &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">Эти настройки могут быть установлены из &lt;code&gt;postgresql.conf&lt;/code&gt; или внутри сеанса с помощью команды &lt;code&gt;SET&lt;/code&gt; ; но только суперпользователи могут изменять их через &lt;code&gt;SET&lt;/code&gt; . Изменения в &lt;code&gt;postgresql.conf&lt;/code&gt; повлияют на существующие сеансы только в том случае, если локальное значение сеанса не было установлено с помощью &lt;code&gt;SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a83e5497c48f3fadb734c9a42de145288252b14" translate="yes" xml:space="preserve">
          <source>These settings can only be applied when the server starts, so any change requires restarting the server. Values for these settings are typically stored in the &lt;code&gt;postgresql.conf&lt;/code&gt; file, or passed on the command line when starting the server. Of course, settings with any of the lower &lt;code&gt;context&lt;/code&gt; types can also be set at server start time.</source>
          <target state="translated">Эти настройки могут применяться только при запуске сервера, поэтому любое изменение требует перезапуска сервера. Значения этих параметров обычно хранятся в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или передаются в командной строке при запуске сервера. Конечно, настройки с любым из нижних типов &lt;code&gt;context&lt;/code&gt; также могут быть установлены во время запуска сервера.</target>
        </trans-unit>
        <trans-unit id="02aa5756831dee127ec65944b5fa10a7b3de8a8e" translate="yes" xml:space="preserve">
          <source>These settings cannot be changed directly; they reflect internally determined values. Some of them may be adjustable by rebuilding the server with different configuration options, or by changing options supplied to &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">Эти настройки нельзя изменить напрямую; они отражают внутренние ценности. Некоторые из них можно настроить, перестроив сервер с другими параметрами конфигурации или изменив параметры, предоставленные для &lt;code&gt;initdb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="317e80ee1851e3545ba5ed374350ee15698895fc" translate="yes" xml:space="preserve">
          <source>These settings control how process titles of server processes are modified. Process titles are typically viewed using programs like ps or, on Windows, Process Explorer. See &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details.</source>
          <target state="translated">Эти настройки управляют изменением названий процессов серверных процессов. Заголовки процессов обычно просматриваются с помощью таких программ, как ps или Process Explorer в Windows. См &lt;a href=&quot;monitoring-ps&quot;&gt;раздел 27.1&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="c21f5b22d74359b34a233de933da88c1556b1754" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of a logical replication subscriber. Their values on the publisher are irrelevant.</source>
          <target state="translated">Эти настройки контролируют поведение абонента логической репликации.Их значения для издателя не имеют значения.</target>
        </trans-unit>
        <trans-unit id="51ac309dd49de1c6d6c04c1c54a256fdaeb98b75" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of a standby server that is to receive replication data. Their values on the master server are irrelevant.</source>
          <target state="translated">Эти параметры контролируют поведение резервного сервера,который должен получать данные репликации.Их значения на главном сервере не имеют значения.</target>
        </trans-unit>
        <trans-unit id="d40b8d037fb02f22e279e00bffd1ef98f7d8c44d" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of the &lt;em&gt;autovacuum&lt;/em&gt; feature. Refer to &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. Note that many of these settings can be overridden on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt;.</source>
          <target state="translated">Эти настройки управляют поведением функции &lt;em&gt;автоочистки&lt;/em&gt; . Обратитесь к &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Разделу 24.1.6&lt;/a&gt; за дополнительной информацией. Обратите внимание, что многие из этих параметров можно переопределить для каждой таблицы; см. &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Параметры хранения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c9c05e7e68e0c9931d3c483fab276d6098720bf" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of the built-in &lt;em&gt;streaming replication&lt;/em&gt; feature (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). Servers will be either a master or a standby server. Masters can send data, while standbys are always receivers of replicated data. When cascading replication (see &lt;a href=&quot;warm-standby#CASCADING-REPLICATION&quot;&gt;Section 26.2.7&lt;/a&gt;) is used, standby servers can also be senders, as well as receivers. Parameters are mainly for sending and standby servers, though some parameters have meaning only on the master server. Settings may vary across the cluster without problems if that is required.</source>
          <target state="translated">Эти настройки управляют поведением встроенной функции &lt;em&gt;потоковой репликации&lt;/em&gt; (см. &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Раздел 26.2.5&lt;/a&gt; ). Серверы будут либо главным, либо резервным. Мастера могут отправлять данные, а резервные всегда являются получателями реплицированных данных. Когда используется каскадная репликация (см. &lt;a href=&quot;warm-standby#CASCADING-REPLICATION&quot;&gt;Подраздел 26.2.7&lt;/a&gt; ), резервные серверы также могут быть как отправителями, так и получателями. Параметры в основном предназначены для отправляющего и резервного серверов, хотя некоторые параметры имеют значение только на главном сервере. При необходимости настройки могут без проблем изменяться в зависимости от кластера.</target>
        </trans-unit>
        <trans-unit id="631081e51e8d0c56dfb2edd79daea765216e4764" translate="yes" xml:space="preserve">
          <source>These settings will cause postmaster child processes to run with the normal OOM score adjustment of zero, so that the OOM killer can still target them at need. You could use some other value for &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; if you want the child processes to run with some other OOM score adjustment. (&lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; can also be omitted, in which case it defaults to zero.) If you do not set &lt;code&gt;PG_OOM_ADJUST_FILE&lt;/code&gt;, the child processes will run with the same OOM score adjustment as the postmaster, which is unwise since the whole point is to ensure that the postmaster has a preferential setting.</source>
          <target state="translated">Эти настройки приведут к тому, что дочерние процессы postmaster будут выполняться с нормальной корректировкой оценки OOM, равной нулю, так что убийца OOM все еще может нацеливаться на них при необходимости. Вы можете использовать другое значение для &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; , если хотите, чтобы дочерние процессы выполнялись с другой корректировкой оценки OOM. ( &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; также может быть опущено, и в этом случае оно по умолчанию равно нулю.) Если вы не установите &lt;code&gt;PG_OOM_ADJUST_FILE&lt;/code&gt; , дочерние процессы будут работать с той же корректировкой оценки OOM, что и постмастер, что неразумно, поскольку все дело в том, чтобы гарантировать, что postmaster имеет льготные настройки.</target>
        </trans-unit>
        <trans-unit id="8ab15e9b47def86730e35b3c5c50e0dfe3f834aa" translate="yes" xml:space="preserve">
          <source>These specify what the prompts psql issues should look like. See &lt;a href=&quot;app-psql#APP-PSQL-PROMPTING&quot;&gt;Prompting&lt;/a&gt; below.</source>
          <target state="translated">Они определяют, как должны выглядеть запросы psql. См. &lt;a href=&quot;app-psql#APP-PSQL-PROMPTING&quot;&gt;Раздел &amp;laquo;Подсказка&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="6086ed3e7f06eab1a2070198d662f5b66b1e6406" translate="yes" xml:space="preserve">
          <source>These trigger functions automatically compute a &lt;code&gt;tsvector&lt;/code&gt; column from one or more textual columns, under the control of parameters specified in the &lt;code&gt;CREATE TRIGGER&lt;/code&gt; command. An example of their use is:</source>
          <target state="translated">Эти триггерные функции автоматически вычисляют столбец &lt;code&gt;tsvector&lt;/code&gt; из одного или нескольких текстовых столбцов под управлением параметров, указанных в команде &lt;code&gt;CREATE TRIGGER&lt;/code&gt; . Пример их использования:</target>
        </trans-unit>
        <trans-unit id="26b286f322440c12ea3e3c031f3d293b77ba6582" translate="yes" xml:space="preserve">
          <source>These two fields can be used as an alternative to the &lt;code&gt;IP-address&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;mask-length&lt;/code&gt; notation. Instead of specifying the mask length, the actual mask is specified in a separate column. For example, &lt;code&gt;255.0.0.0&lt;/code&gt; represents an IPv4 CIDR mask length of 8, and &lt;code&gt;255.255.255.255&lt;/code&gt; represents a CIDR mask length of 32.</source>
          <target state="translated">Эти два поля могут использоваться как альтернатива нотации &lt;code&gt;IP-address&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;mask-length&lt;/code&gt; . Вместо указания длины маски фактическая маска указывается в отдельном столбце. Например, &lt;code&gt;255.0.0.0&lt;/code&gt; представляет длину маски CIDR IPv4, равную 8, а &lt;code&gt;255.255.255.255&lt;/code&gt; представляет длину маски CIDR, равную 32.</target>
        </trans-unit>
        <trans-unit id="b912ce7211a3c9dfe25f2009d32879c2b4a7718a" translate="yes" xml:space="preserve">
          <source>These variables are set at program start-up to reflect psql's version, respectively as a verbose string, a short string (e.g., &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt;, or &lt;code&gt;11beta1&lt;/code&gt;), and a number (e.g., &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;). They can be changed or unset.</source>
          <target state="translated">Эти переменные устанавливаются при запуске программы для отображения версии psql, соответственно, в виде подробной строки, короткой строки (например, &lt;code&gt;9.6.2&lt;/code&gt; , &lt;code&gt;10.1&lt;/code&gt; или &lt;code&gt;11beta1&lt;/code&gt; ) и числа (например, &lt;code&gt;90602&lt;/code&gt; или &lt;code&gt;100001&lt;/code&gt; ). Их можно изменить или отключить.</target>
        </trans-unit>
        <trans-unit id="d1888af9231d7dc7892d920d2796a7d30d3c432b" translate="yes" xml:space="preserve">
          <source>These will always return true or false, never a null value, even when the operand is null. A null input is treated as the logical value &amp;ldquo;unknown&amp;rdquo;. Notice that &lt;code&gt;IS UNKNOWN&lt;/code&gt; and &lt;code&gt;IS NOT UNKNOWN&lt;/code&gt; are effectively the same as &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt;, respectively, except that the input expression must be of Boolean type.</source>
          <target state="translated">Они всегда будут возвращать истину или ложь, никогда не будут возвращать нулевое значение, даже если операнд равен нулю. Нулевой вход рассматривается как логическое значение &amp;laquo;неизвестно&amp;raquo;. Обратите внимание, что &lt;code&gt;IS UNKNOWN&lt;/code&gt; и &lt;code&gt;IS NOT UNKNOWN&lt;/code&gt; фактически то же самое, что &lt;code&gt;IS NULL&lt;/code&gt; и &lt;code&gt;IS NOT NULL&lt;/code&gt; соответственно, за исключением того, что входное выражение должно быть логического типа.</target>
        </trans-unit>
        <trans-unit id="eb77a6f9b66e9a05805238727dad27ac972c149a" translate="yes" xml:space="preserve">
          <source>They are slow. As the amount of data is so small, this is the only way to make brute-forcing passwords hard.</source>
          <target state="translated">Они медленные.Поскольку объем данных настолько мал,это единственный способ сделать пароли жестким с помощью перебора.</target>
        </trans-unit>
        <trans-unit id="bf2c8c3d26564b271cd3b0f3cc01f4bc594ad56e" translate="yes" xml:space="preserve">
          <source>They don't handle text.</source>
          <target state="translated">Они не работают с текстом.</target>
        </trans-unit>
        <trans-unit id="89bd6007244204d4a23986add99e11b8144bb68e" translate="yes" xml:space="preserve">
          <source>They don't provide any integrity checking, to see if the encrypted data was modified.</source>
          <target state="translated">Они не обеспечивают проверку целостности,чтобы убедиться,что зашифрованные данные были изменены.</target>
        </trans-unit>
        <trans-unit id="108af784f0fd778d605e66d5a415819131da0024" translate="yes" xml:space="preserve">
          <source>They expect that users manage all encryption parameters themselves, even IV.</source>
          <target state="translated">Они ожидают,что пользователи сами будут управлять всеми параметрами шифрования,даже IV.</target>
        </trans-unit>
        <trans-unit id="0c2039617625e55d628a5303153737be520c2636" translate="yes" xml:space="preserve">
          <source>They include the algorithm type in the result, so passwords hashed with different algorithms can co-exist.</source>
          <target state="translated">Они включают в себя тип алгоритма в результате,поэтому пароли,хэшированные различными алгоритмами,могут сосуществовать.</target>
        </trans-unit>
        <trans-unit id="c3e7dceb3b44e3013034907236242ebd62f58f0d" translate="yes" xml:space="preserve">
          <source>They provide no ordering (ranking) of search results, which makes them ineffective when thousands of matching documents are found.</source>
          <target state="translated">Они не обеспечивают упорядочивания (ранжирования)результатов поиска,что делает их неэффективными при обнаружении тысяч совпадающих документов.</target>
        </trans-unit>
        <trans-unit id="2c267279c3829425820b5af53bc51b1aea00680d" translate="yes" xml:space="preserve">
          <source>They tend to be slow because there is no index support, so they must process all documents for every search.</source>
          <target state="translated">Они,как правило,работают медленно,потому что нет поддержки индекса,поэтому они должны обрабатывать все документы для каждого поиска.</target>
        </trans-unit>
        <trans-unit id="fc6b695f1b5d50d9c60b39def6c93072e73b0c7c" translate="yes" xml:space="preserve">
          <source>They use a random value, called the &lt;em&gt;salt&lt;/em&gt;, so that users having the same password will have different encrypted passwords. This is also an additional defense against reversing the algorithm.</source>
          <target state="translated">Они используют случайное значение, называемое &lt;em&gt;солью&lt;/em&gt; , поэтому у пользователей с одним и тем же паролем будут разные зашифрованные пароли. Это также дополнительная защита от изменения алгоритма.</target>
        </trans-unit>
        <trans-unit id="e85a3bee9adadb9e25e77dec1600e19104320bfe" translate="yes" xml:space="preserve">
          <source>They use user key directly as cipher key.</source>
          <target state="translated">Они используют ключ пользователя непосредственно в качестве ключа шифрования.</target>
        </trans-unit>
        <trans-unit id="8dbebd5ef75455c0a62f167f8fa030487ae4ceab" translate="yes" xml:space="preserve">
          <source>Things are more difficult if you need to recover from corruption of an index on a system table. In this case it's important for the system to not have used any of the suspect indexes itself. (Indeed, in this sort of scenario you might find that server processes are crashing immediately at start-up, due to reliance on the corrupted indexes.) To recover safely, the server must be started with the &lt;code&gt;-P&lt;/code&gt; option, which prevents it from using indexes for system catalog lookups.</source>
          <target state="translated">Дела обстоят сложнее, если вам нужно восстановить после повреждения индекса в системной таблице. В этом случае важно, чтобы система сама не использовала ни один из подозрительных индексов. (Действительно, в подобном сценарии вы можете обнаружить, что серверные процессы сразу же завершаются сбоем при запуске из-за использования поврежденных индексов.) Для безопасного восстановления сервер должен быть запущен с параметром &lt;code&gt;-P&lt;/code&gt; , который предотвращает его запуск. использование индексов для поиска в системном каталоге.</target>
        </trans-unit>
        <trans-unit id="96f7dee4533ea61962d64e3ad5a7fcf16ccab0dd" translate="yes" xml:space="preserve">
          <source>Third, turn on &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt;. For security reasons, the rules in &lt;code&gt;sepgsql-regtest&lt;/code&gt; are not enabled by default; the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter enables the rules needed to launch the regression tests. It can be turned on using the &lt;code&gt;setsebool&lt;/code&gt; command:</source>
          <target state="translated">В-третьих, включите &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; . По соображениям безопасности правила в &lt;code&gt;sepgsql-regtest&lt;/code&gt; по умолчанию не включены; &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; параметр позволяет правила , необходимые для запуска регрессионных тестов. Его можно включить с помощью команды &lt;code&gt;setsebool&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e8a4d63f55e2492f2cd42b3a9fb86caa1ca5e84c" translate="yes" xml:space="preserve">
          <source>Third-party applications can be put into separate schemas so they do not collide with the names of other objects.</source>
          <target state="translated">Приложения сторонних разработчиков можно поместить в отдельные схемы,чтобы они не сталкивались с именами других объектов.</target>
        </trans-unit>
        <trans-unit id="04297a9823a3a2086d546b9d671ec1f8ab29f655" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;WITH&lt;/code&gt; query will be folded, producing the same execution plan as</source>
          <target state="translated">Этот запрос &lt;code&gt;WITH&lt;/code&gt; будет свернут, создав тот же план выполнения, что и</target>
        </trans-unit>
        <trans-unit id="14ca478547dc2e8fab1f8f6bfce576b001fe2285" translate="yes" xml:space="preserve">
          <source>This access control mechanism is independent of the one described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;.</source>
          <target state="translated">Этот механизм контроля доступа не зависит от механизма, описанного в &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;главе 20&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5d11934ea2252677e8bf50febe72c8f70679b90" translate="yes" xml:space="preserve">
          <source>This access control mechanism is independent of the one described in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7fa7bd259660d0cb8e1608dc878af198c41a3a" translate="yes" xml:space="preserve">
          <source>This acquires a row-level lock on the row with the specified account number. Then, the second transaction executes:</source>
          <target state="translated">При этом в строке с указанным номером счета устанавливается блокировка на уровне рядов.Затем выполняется вторая транзакция:</target>
        </trans-unit>
        <trans-unit id="5cf940ef6c18dd4ff1a92a3955dc9c9d23c16666" translate="yes" xml:space="preserve">
          <source>This allows further operations to be performed on the data before it is dropped. For example, this is often a useful time to back up the data using &lt;code&gt;COPY&lt;/code&gt;, pg_dump, or similar tools. It might also be a useful time to aggregate data into smaller formats, perform other data manipulations, or run reports.</source>
          <target state="translated">Это позволяет выполнять дальнейшие операции с данными до их удаления. Например, это часто бывает полезным для резервного копирования данных с помощью &lt;code&gt;COPY&lt;/code&gt; , pg_dump или подобных инструментов. Это также может быть полезным временем для агрегирования данных в меньшие форматы, выполнения других манипуляций с данными или создания отчетов.</target>
        </trans-unit>
        <trans-unit id="7fb6b13498a74131eab9c57b3090da36c9ec9b3f" translate="yes" xml:space="preserve">
          <source>This allows sequential scans of large tables to synchronize with each other, so that concurrent scans read the same block at about the same time and hence share the I/O workload. When this is enabled, a scan might start in the middle of the table and then &amp;ldquo;wrap around&amp;rdquo; the end to cover all rows, so as to synchronize with the activity of scans already in progress. This can result in unpredictable changes in the row ordering returned by queries that have no &lt;code&gt;ORDER BY&lt;/code&gt; clause. Setting this parameter to &lt;code&gt;off&lt;/code&gt; ensures the pre-8.3 behavior in which a sequential scan always starts from the beginning of the table. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">Это позволяет синхронизировать последовательное сканирование больших таблиц друг с другом, так что одновременные сканирования читают один и тот же блок примерно в одно и то же время и, следовательно, разделяют рабочую нагрузку ввода-вывода. Когда этот параметр включен, сканирование может начинаться в середине таблицы, а затем &amp;laquo;оборачиваться&amp;raquo; до конца, чтобы охватить все строки, чтобы синхронизироваться с активностью уже выполняемого сканирования. Это может привести к непредсказуемым изменениям в порядке строк, возвращаемых запросами, не &lt;code&gt;ORDER BY&lt;/code&gt; предложения ORDER BY . Установка для этого параметра значения &lt;code&gt;off&lt;/code&gt; обеспечивает поведение до версии 8.3, при котором последовательное сканирование всегда начинается с начала таблицы. По умолчанию &lt;code&gt;on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="253b2ab3ed8967081995487ba9ee5b4826393d61" translate="yes" xml:space="preserve">
          <source>This and other array operators are further described in &lt;a href=&quot;functions-array&quot;&gt;Section 9.18&lt;/a&gt;. It can be accelerated by an appropriate index, as described in &lt;a href=&quot;indexes-types&quot;&gt;Section 11.2&lt;/a&gt;.</source>
          <target state="translated">Этот и другие операторы массива подробнее описаны в &lt;a href=&quot;functions-array&quot;&gt;Разделе 9.18&lt;/a&gt; . Его можно ускорить с помощью соответствующего индекса, как описано в &lt;a href=&quot;indexes-types&quot;&gt;Разделе 11.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a81f0db3b04480fe75e2e180f22423d163b36314" translate="yes" xml:space="preserve">
          <source>This and other array operators are further described in &lt;a href=&quot;functions-array&quot;&gt;Section 9.19&lt;/a&gt;. It can be accelerated by an appropriate index, as described in &lt;a href=&quot;indexes-types&quot;&gt;Section 11.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f7125f90456e96d69dc4420ff05c41c76b48ac" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses BSD Authentication to verify the password. BSD Authentication is used only to validate user name/password pairs. Therefore the user's role must already exist in the database before BSD Authentication can be used for authentication. The BSD Authentication framework is currently only available on OpenBSD.</source>
          <target state="translated">Этот метод аутентификации работает аналогично &lt;code&gt;password&lt;/code&gt; за исключением того, что он использует аутентификацию BSD для проверки пароля. Аутентификация BSD используется только для проверки пар имя пользователя / пароль. Следовательно, роль пользователя должна уже существовать в базе данных, прежде чем аутентификация BSD может использоваться для аутентификации. Структура аутентификации BSD в настоящее время доступна только в OpenBSD.</target>
        </trans-unit>
        <trans-unit id="b4a95a1004ec8979c4ed272cc869cffc8b380262" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses LDAP as the password verification method. LDAP is used only to validate the user name/password pairs. Therefore the user must already exist in the database before LDAP can be used for authentication.</source>
          <target state="translated">Этот метод аутентификации работает аналогично &lt;code&gt;password&lt;/code&gt; за исключением того, что в качестве метода проверки пароля используется LDAP. LDAP используется только для проверки пар имя пользователя / пароль. Поэтому пользователь должен уже существовать в базе данных, чтобы LDAP можно было использовать для аутентификации.</target>
        </trans-unit>
        <trans-unit id="14894f744e61a4d997e0bd55d2f4134698e24251" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses PAM (Pluggable Authentication Modules) as the authentication mechanism. The default PAM service name is &lt;code&gt;postgresql&lt;/code&gt;. PAM is used only to validate user name/password pairs and optionally the connected remote host name or IP address. Therefore the user must already exist in the database before PAM can be used for authentication. For more information about PAM, please read the &lt;a href=&quot;https://www.kernel.org/pub/linux/libs/pam/&quot;&gt;Linux-PAM Page&lt;/a&gt;.</source>
          <target state="translated">Этот метод аутентификации работает аналогично &lt;code&gt;password&lt;/code&gt; за исключением того, что в качестве механизма аутентификации он использует PAM (подключаемые модули аутентификации). Имя службы PAM по умолчанию - &lt;code&gt;postgresql&lt;/code&gt; . PAM используется только для проверки пар имя пользователя / пароль и, необязательно, имени подключенного удаленного хоста или IP-адреса. Поэтому пользователь должен уже существовать в базе данных, прежде чем PAM можно будет использовать для аутентификации. Для получения дополнительной информации о PAM, пожалуйста, прочтите &lt;a href=&quot;https://www.kernel.org/pub/linux/libs/pam/&quot;&gt;страницу Linux-PAM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd397f0c1d27e7e6f24266e4663491230029a1f" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses RADIUS as the password verification method. RADIUS is used only to validate the user name/password pairs. Therefore the user must already exist in the database before RADIUS can be used for authentication.</source>
          <target state="translated">Этот метод аутентификации работает аналогично &lt;code&gt;password&lt;/code&gt; за исключением того, что он использует RADIUS в качестве метода проверки пароля. RADIUS используется только для проверки пар имя пользователя / пароль. Поэтому пользователь должен уже существовать в базе данных, прежде чем RADIUS можно будет использовать для аутентификации.</target>
        </trans-unit>
        <trans-unit id="699ba79710348057cae6bc38a6f4967f7fef3d56" translate="yes" xml:space="preserve">
          <source>This authentication method uses SSL client certificates to perform authentication. It is therefore only available for SSL connections. When using this authentication method, the server will require that the client provide a valid, trusted certificate. No password prompt will be sent to the client. The &lt;code&gt;cn&lt;/code&gt; (Common Name) attribute of the certificate will be compared to the requested database user name, and if they match the login will be allowed. User name mapping can be used to allow &lt;code&gt;cn&lt;/code&gt; to be different from the database user name.</source>
          <target state="translated">Этот метод проверки подлинности использует сертификаты клиента SSL для проверки подлинности. Поэтому он доступен только для SSL-соединений. При использовании этого метода аутентификации сервер потребует, чтобы клиент предоставил действительный доверенный сертификат. Запрос пароля не будет отправлен клиенту. &lt;code&gt;cn&lt;/code&gt; (Common Name) атрибут сертификата будет сравниваться с запрашиваемым именем пользователя базы данных, и если они соответствуют Логин будет разрешено. Можно использовать сопоставление имен пользователей, чтобы позволить &lt;code&gt;cn&lt;/code&gt; отличаться от имени пользователя базы данных.</target>
        </trans-unit>
        <trans-unit id="5ac6c0054ced8ebe81d0f1a02772b68633401dc6" translate="yes" xml:space="preserve">
          <source>This behavior is desirable since it allows searches to work for both the whole compound word and for components. Here is another instructive example:</source>
          <target state="translated">Такое поведение желательно,так как позволяет осуществлять поиск как по всему составному слову,так и по компонентам.Вот еще один поучительный пример:</target>
        </trans-unit>
        <trans-unit id="286f6e80e06ffd51f385da7d2a7694b40cc44231" translate="yes" xml:space="preserve">
          <source>This can be convenient to be able to use operating-system-independent collation names in applications.</source>
          <target state="translated">Это может быть удобно,чтобы иметь возможность использовать не зависящие от операционной системы имена соединений в приложениях.</target>
        </trans-unit>
        <trans-unit id="2cb2c31cd20a3afc74e461bc50ba20daffd3b134" translate="yes" xml:space="preserve">
          <source>This can be implemented quite efficiently by GiST indexes, but not by GIN indexes.</source>
          <target state="translated">Это может быть реализовано достаточно эффективно с помощью индексов GiST,но не с помощью индексов GIN.</target>
        </trans-unit>
        <trans-unit id="30c9965536e9eb1807b9625445e1dc9ee486d49c" translate="yes" xml:space="preserve">
          <source>This can be implemented quite efficiently by GiST indexes, but not by GIN indexes. It will usually beat the first formulation when only a small number of the closest matches is wanted.</source>
          <target state="translated">Это может быть реализовано достаточно эффективно с помощью индексов GiST,но не с помощью индексов GIN.Обычно она бьет первую формулировку,когда требуется лишь небольшое количество ближайших совпадений.</target>
        </trans-unit>
        <trans-unit id="b19d203036cf7d45dfab0c4ad82ce10183e0940c" translate="yes" xml:space="preserve">
          <source>This can very quickly delete millions of records because it doesn't have to individually delete every record. Note however that the above command requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table.</source>
          <target state="translated">Это может очень быстро удалить миллионы записей, потому что не нужно удалять каждую запись отдельно. Однако обратите внимание, что указанная выше команда требует блокировки &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; для родительской таблицы.</target>
        </trans-unit>
        <trans-unit id="b3706a06d88bffe054b5b4e9ba07c3a2f69517db" translate="yes" xml:space="preserve">
          <source>This catalog only contains tables known to the subscription after running either &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; or &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt;.</source>
          <target state="translated">Этот каталог содержит только таблицы, известные подписке после запуска &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; или &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c00511a06e3429d3e3c63e91ce19e3a4e9397cad" translate="yes" xml:space="preserve">
          <source>This chapter explains the interface between the core PostgreSQL system and &lt;em&gt;table access methods&lt;/em&gt;, which manage the storage for tables. The core system knows little about these access methods beyond what is specified here, so it is possible to develop entirely new access method types by writing add-on code.</source>
          <target state="translated">В этой главе объясняется интерфейс между базовой системой PostgreSQL и &lt;em&gt;методами доступа&lt;/em&gt; к таблицам, которые управляют хранилищем таблиц. Базовая система мало знает об этих методах доступа, помимо указанного здесь, поэтому можно разработать совершенно новые типы методов доступа, написав дополнительный код.</target>
        </trans-unit>
        <trans-unit id="3bbb8116ccc75f5eb2a80776b0a4003df51db1c5" translate="yes" xml:space="preserve">
          <source>This chapter provides an overview of how to use SQL to perform simple operations. This tutorial is only intended to give you an introduction and is in no way a complete tutorial on SQL. Numerous books have been written on SQL, including &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;. You should be aware that some PostgreSQL language features are extensions to the standard.</source>
          <target state="translated">В этой главе представлен обзор того, как использовать SQL для выполнения простых операций. Это руководство предназначено только для ознакомления и никоим образом не является полным руководством по SQL. По SQL написано множество книг, включая &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt; . Вы должны знать, что некоторые возможности языка PostgreSQL являются расширениями стандарта.</target>
        </trans-unit>
        <trans-unit id="8dae2bfb234e1cafffdc1445672c01cdceebec98" translate="yes" xml:space="preserve">
          <source>This chapter provides an overview of how to use SQL to perform simple operations. This tutorial is only intended to give you an introduction and is in no way a complete tutorial on SQL. Numerous books have been written on SQL, including &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;. You should be aware that some PostgreSQL language features are extensions to the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4bef49f81ca7b2b6c1d960ddeae062fa5602386" translate="yes" xml:space="preserve">
          <source>This chapter will on occasion refer to examples found in &lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt; to change or improve them, so it will be useful to have read that chapter. Some examples from this chapter can also be found in &lt;code&gt;advanced.sql&lt;/code&gt; in the tutorial directory. This file also contains some sample data to load, which is not repeated here. (Refer to &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt; for how to use the file.)</source>
          <target state="translated">В этой главе время от времени будут ссылаться на примеры из &lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;главы 2,&lt;/a&gt; чтобы изменить или улучшить их, поэтому будет полезно прочитать эту главу. Некоторые примеры из этой главы также можно найти в &lt;code&gt;advanced.sql&lt;/code&gt; в каталоге руководства. Этот файл также содержит некоторые образцы данных для загрузки, которые здесь не повторяются. (См. &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Раздел 2.1,&lt;/a&gt; чтобы узнать, как использовать файл.)</target>
        </trans-unit>
        <trans-unit id="dabed7c214422d3752d4d13e0c2a45b4ba36ecbe" translate="yes" xml:space="preserve">
          <source>This chapter will on occasion refer to examples found in &lt;a href=&quot;https://www.postgresql.org/docs/13/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt; to change or improve them, so it will be useful to have read that chapter. Some examples from this chapter can also be found in &lt;code&gt;advanced.sql&lt;/code&gt; in the tutorial directory. This file also contains some sample data to load, which is not repeated here. (Refer to &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt; for how to use the file.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05316eb335b74f7f1d96b694767ed937c7a73d2" translate="yes" xml:space="preserve">
          <source>This clause allows selection of the tablespace in which the index associated with a &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt; constraint will be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary.</source>
          <target state="translated">Это предложение позволяет выбрать табличное пространство, в котором будет создан индекс, связанный с ограничением &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; или &lt;code&gt;EXCLUDE&lt;/code&gt; . Если не указано, используется &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; или &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces,&lt;/a&gt; если таблица временная.</target>
        </trans-unit>
        <trans-unit id="9a22b296ec30545018cebf2ee6b84bbc440b4d2a" translate="yes" xml:space="preserve">
          <source>This clause alters parameters originally set by &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;. See there for more information. The allowed options are &lt;code&gt;slot_name&lt;/code&gt; and &lt;code&gt;synchronous_commit&lt;/code&gt;</source>
          <target state="translated">Это предложение изменяет параметры, изначально установленные при &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; . Смотрите там для получения дополнительной информации. Допустимые параметры: &lt;code&gt;slot_name&lt;/code&gt; и &lt;code&gt;synchronous_commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dde9dc06154fb93b57360e4813d2af30753235f" translate="yes" xml:space="preserve">
          <source>This clause alters publication parameters originally set by &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;. See there for more information.</source>
          <target state="translated">Это предложение изменяет параметры публикации, изначально установленные командой &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; . Смотрите там для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="3a47a54fa61280e2ffdfce9d2640b5d9bb858deb" translate="yes" xml:space="preserve">
          <source>This clause alters the connection property originally set by &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;. See there for more information.</source>
          <target state="translated">Это предложение изменяет свойство соединения, изначально установленное &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; . Смотрите там для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="5d2fcb8e278e1a72c6a053d69e9530239790d3c7" translate="yes" xml:space="preserve">
          <source>This clause creates the column as a &lt;em&gt;generated column&lt;/em&gt;. The column cannot be written to, and when read the result of the specified expression will be returned.</source>
          <target state="translated">Это предложение создает столбец как &lt;em&gt;сгенерированный столбец&lt;/em&gt; . Запись в столбец невозможна, и при чтении будет возвращен результат указанного выражения.</target>
        </trans-unit>
        <trans-unit id="cd8eb7a6eec884310b19db2fe89fcdaa447cc6e8" translate="yes" xml:space="preserve">
          <source>This clause creates the column as an &lt;em&gt;identity column&lt;/em&gt;. It will have an implicit sequence attached to it and the column in new rows will automatically have values from the sequence assigned to it.</source>
          <target state="translated">Это предложение создает столбец как &lt;em&gt;столбец идентификации&lt;/em&gt; . К нему будет прикреплена неявная последовательность, и столбец в новых строках автоматически будет иметь значения из назначенной ему последовательности.</target>
        </trans-unit>
        <trans-unit id="da05955831bd605d103f99ab7132a00a6b982439" translate="yes" xml:space="preserve">
          <source>This clause indicates whether the following relation name is for the before-image transition relation or the after-image transition relation.</source>
          <target state="translated">Это положение указывает на то,является ли следующее название отношения для отношения перехода до изображения или после изображения.</target>
        </trans-unit>
        <trans-unit id="deddf49266216fee17210941a2dbf2f328be5ca2" translate="yes" xml:space="preserve">
          <source>This clause is only intended for compatibility with nonstandard SQL databases. Its use is discouraged in new applications.</source>
          <target state="translated">Данное положение предназначено только для совместимости с нестандартными базами данных SQL.Его использование не рекомендуется в новых приложениях.</target>
        </trans-unit>
        <trans-unit id="41393a74e45a6c0a80ff1bb273dd882f889e0a0f" translate="yes" xml:space="preserve">
          <source>This clause is only provided for compatibility with non-standard SQL databases. Its use is discouraged in new applications.</source>
          <target state="translated">Данное условие предусмотрено только для совместимости с нестандартными базами данных SQL.Его использование не рекомендуется в новых приложениях.</target>
        </trans-unit>
        <trans-unit id="22cd0887432e6ccdc3a45b9fc77bdb8214571dbc" translate="yes" xml:space="preserve">
          <source>This clause is useful for example when copying values between tables. Writing &lt;code&gt;INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1&lt;/code&gt; will copy from &lt;code&gt;tbl1&lt;/code&gt; all columns that are not identity columns in &lt;code&gt;tbl2&lt;/code&gt; while values for the identity columns in &lt;code&gt;tbl2&lt;/code&gt; will be generated by the sequences associated with &lt;code&gt;tbl2&lt;/code&gt;.</source>
          <target state="translated">Это предложение полезно, например, при копировании значений между таблицами. Запись &lt;code&gt;INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1&lt;/code&gt; скопирует из &lt;code&gt;tbl1&lt;/code&gt; все столбцы, которые не являются столбцами идентификаторов в &lt;code&gt;tbl2&lt;/code&gt; ,в то время как значения для столбцов идентификаторов в &lt;code&gt;tbl2&lt;/code&gt; будут сгенерированы последовательностями, связанными с &lt;code&gt;tbl2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4ccb1be36e739cedb50d44f85c522aa002c906" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a publication. The following parameters are supported:</source>
          <target state="translated">В этом пункте указываются необязательные параметры для публикации.Поддерживаются следующие параметры:</target>
        </trans-unit>
        <trans-unit id="0ab7a0e0c831da17344263c723c33e3ad9e5583a" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a subscription. The following parameters are supported:</source>
          <target state="translated">В этом пункте указываются необязательные параметры подписки.Поддерживаются следующие параметры:</target>
        </trans-unit>
        <trans-unit id="501055417d1a99c1021f58bb4344fd42a1fc3dfa" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a view; the following parameters are supported:</source>
          <target state="translated">В этом пункте указываются необязательные параметры представления;поддерживаются следующие параметры:</target>
        </trans-unit>
        <trans-unit id="959992a100adc135a448ff56a939c7cb03335c38" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for a table or index; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; below for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should not contain OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e5726eff7272a0b43b9a8622a25a1a4b88715e" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for a table or index; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should not contain OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">Это предложение определяет необязательные параметры хранения для таблицы или индекса; см. &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Параметры хранения&lt;/a&gt; для получения дополнительной информации. Для обратной совместимости предложение &lt;code&gt;WITH&lt;/code&gt; для таблицы может также включать &lt;code&gt;OIDS=FALSE&lt;/code&gt; , чтобы указать, что строки новой таблицы не должны содержать OID (идентификаторы объектов), &lt;code&gt;OIDS=TRUE&lt;/code&gt; больше не поддерживается.</target>
        </trans-unit>
        <trans-unit id="8e37f3a174a386383c959a305d30ae15361d5fa2" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new materialized view; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. All parameters supported for &lt;code&gt;CREATE TABLE&lt;/code&gt; are also supported for &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt;. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more information.</source>
          <target state="translated">Это предложение определяет необязательные параметры хранения для нового материализованного представления; см. &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Параметры хранения&lt;/a&gt; для получения дополнительной информации. Все параметры, поддерживаемые для &lt;code&gt;CREATE TABLE&lt;/code&gt; , также поддерживаются для &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; . См. &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="207b4757c66805d303f77232d29f374adc4dd287" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new materialized view; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; in the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for more information. All parameters supported for &lt;code&gt;CREATE TABLE&lt;/code&gt; are also supported for &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt;. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd2349edcbad3293d90a1b82afea4e43718f802" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new table; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should contain no OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">Это предложение определяет необязательные параметры хранения для новой таблицы; см. &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Параметры хранения&lt;/a&gt; для получения дополнительной информации. Для обратной совместимости предложение &lt;code&gt;WITH&lt;/code&gt; для таблицы может также включать &lt;code&gt;OIDS=FALSE&lt;/code&gt; , чтобы указать, что строки новой таблицы не должны содержать OID (идентификаторы объектов), &lt;code&gt;OIDS=TRUE&lt;/code&gt; больше не поддерживается.</target>
        </trans-unit>
        <trans-unit id="e578543445bd0cc923dce66a8dfdd41602ac897b" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new table; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; in the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should contain no OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9cf336be30ceb53b3db8168b3e8c1bdee3f553" translate="yes" xml:space="preserve">
          <source>This clause specifies options for the new foreign-data wrapper. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign-data wrapper's validator function. Option names must be unique.</source>
          <target state="translated">В этом пункте оговариваются опции для новой обертки иностранных данных.Допустимые имена и значения опций специфичны для каждой зарубежной обертки данных и проверяются с помощью функции валидатора зарубежной обертки данных.Имена опций должны быть уникальными.</target>
        </trans-unit>
        <trans-unit id="3f504297f50fca952ddee9289f583252aaad16be" translate="yes" xml:space="preserve">
          <source>This clause specifies the options for the server. The options typically define the connection details of the server, but the actual names and values are dependent on the server's foreign-data wrapper.</source>
          <target state="translated">В этом пункте указываются опции для сервера.Обычно опции определяют подробности соединения с сервером,но действительные имена и значения зависят от внешней оболочки данных сервера.</target>
        </trans-unit>
        <trans-unit id="553dd348cb64862c6f6c7f8e200b08ad63014f0b" translate="yes" xml:space="preserve">
          <source>This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper.</source>
          <target state="translated">В этом пункте указываются опции отображения пользователей.Обычно опции определяют фактическое имя пользователя и пароль отображения.Имена опций должны быть уникальными.Допустимые имена опций и их значения специфичны для серверной обертки иностранных данных.</target>
        </trans-unit>
        <trans-unit id="36dc1042b746c18fc663603f39f06075d4e8bad1" translate="yes" xml:space="preserve">
          <source>This clause specifies the type of access method to define. Only &lt;code&gt;TABLE&lt;/code&gt; and &lt;code&gt;INDEX&lt;/code&gt; are supported at present.</source>
          <target state="translated">В этом разделе указывается тип определяемого метода доступа. В настоящее время поддерживаются только &lt;code&gt;TABLE&lt;/code&gt; и &lt;code&gt;INDEX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7c9f34db6e75577cfa3e83dbdc6bf919fff89f9" translate="yes" xml:space="preserve">
          <source>This clause specifies whether or not the data produced by the query should be copied into the new table. If not, only the table structure is copied. The default is to copy the data.</source>
          <target state="translated">Данное положение определяет,должны ли данные,полученные в результате запроса,быть скопированы в новую таблицу или нет.Если нет,то копируется только структура таблицы.По умолчанию копируются данные.</target>
        </trans-unit>
        <trans-unit id="3d31ed888cfee0dc08f120a78ae32fb1759c0983" translate="yes" xml:space="preserve">
          <source>This clause specifies whether or not the materialized view should be populated at creation time. If not, the materialized view will be flagged as unscannable and cannot be queried until &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; is used.</source>
          <target state="translated">Это предложение указывает, следует ли заполнять материализованное представление во время создания. В противном случае материализованное представление будет помечено как не подлежащее сканированию, и его нельзя будет запросить до тех пор, пока не будет использоваться &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4795183bcf13c08ef4cb630d8902e21d5cf34ce" translate="yes" xml:space="preserve">
          <source>This color specification format is also used by other software packages such as GCC, GNU coreutils, and GNU grep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc6ac474993dbe5358c6881853df7fd2d4d9cd6" translate="yes" xml:space="preserve">
          <source>This column has a default expression or generation expression, in which case there will be a corresponding entry in the &lt;code&gt;pg_attrdef&lt;/code&gt; catalog that actually defines the expression. (Check &lt;code&gt;attgenerated&lt;/code&gt; to determine whether this is a default or a generation expression.)</source>
          <target state="translated">В этом столбце есть выражение по умолчанию или выражение генерации, и в этом случае в каталоге &lt;code&gt;pg_attrdef&lt;/code&gt; будет соответствующая запись, которая фактически определяет выражение. (Отметьте &lt;code&gt;attgenerated&lt;/code&gt; , чтобы определить, является ли это выражением по умолчанию или генерацией.)</target>
        </trans-unit>
        <trans-unit id="c2b7e0b12551b63f994a3beb30fdb6c9912fa294" translate="yes" xml:space="preserve">
          <source>This column has a one element array containing the value used when the column is entirely missing from the row, as happens when the column is added with a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; value after the row is created. The value is only used when &lt;code&gt;atthasmissing&lt;/code&gt; is true. If there is no value the column is null.</source>
          <target state="translated">Этот столбец имеет одноэлементный массив, содержащий значение, используемое, когда столбец полностью отсутствует в строке, как это происходит, когда столбец добавляется с энергонезависимым значением &lt;code&gt;DEFAULT&lt;/code&gt; после создания строки. Значение используется только тогда, когда &lt;code&gt;atthasmissing&lt;/code&gt; истинно. Если значение отсутствует, столбец является пустым.</target>
        </trans-unit>
        <trans-unit id="35ff62cc51341f34bf3df6fe15f16224e9f0ba2a" translate="yes" xml:space="preserve">
          <source>This column has a value which is used where the column is entirely missing from the row, as happens when a column is added with a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; value after the row is created. The actual value used is stored in the &lt;code&gt;attmissingval&lt;/code&gt; column.</source>
          <target state="translated">Этот столбец имеет значение, которое используется там, где столбец полностью отсутствует в строке, как это происходит, когда столбец добавляется с энергонезависимым значением &lt;code&gt;DEFAULT&lt;/code&gt; после создания строки. Фактическое используемое значение сохраняется в столбце &lt;code&gt;attmissingval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="111e19fea7f4514da864aef92d2fd3831ac7425b" translate="yes" xml:space="preserve">
          <source>This column has been dropped and is no longer valid. A dropped column is still physically present in the table, but is ignored by the parser and so cannot be accessed via SQL.</source>
          <target state="translated">Этот столбец был опущен и больше недействителен.Выпавший столбец все еще физически присутствует в таблице,но игнорируется парсером и поэтому не может быть доступен через SQL.</target>
        </trans-unit>
        <trans-unit id="b598ea81d21dfda8a3cd60afd34a658bae3f5740" translate="yes" xml:space="preserve">
          <source>This column is defined locally in the relation. Note that a column can be locally defined and inherited simultaneously.</source>
          <target state="translated">Этот столбец определяется локально в соотношении.Обратите внимание,что столбец может быть определен локально и наследуется одновременно.</target>
        </trans-unit>
        <trans-unit id="699529a66bde15ad8ad9a32706a761c81f8ea245" translate="yes" xml:space="preserve">
          <source>This command acquires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="translated">Эта команда получает блокировку &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ace2f59fb68bc1a8e1f61640a30167ef3925c24d" translate="yes" xml:space="preserve">
          <source>This command adds the &lt;code&gt;user.postgres&lt;/code&gt; project and sets the shared memory maximum for the &lt;code&gt;postgres&lt;/code&gt; user to 8GB, and takes effect the next time that user logs in, or when you restart PostgreSQL (not reload). The above assumes that PostgreSQL is run by the &lt;code&gt;postgres&lt;/code&gt; user in the &lt;code&gt;postgres&lt;/code&gt; group. No server reboot is required.</source>
          <target state="translated">Эта команда добавляет проект &lt;code&gt;user.postgres&lt;/code&gt; и устанавливает максимальный размер разделяемой памяти для пользователя &lt;code&gt;postgres&lt;/code&gt; равным 8 ГБ и вступает в силу при следующем входе пользователя в систему или при перезапуске PostgreSQL (без перезагрузки). Вышеуказанное предполагает, что PostgreSQL запускается пользователем &lt;code&gt;postgres&lt;/code&gt; в группе &lt;code&gt;postgres&lt;/code&gt; . Перезагрузка сервера не требуется.</target>
        </trans-unit>
        <trans-unit id="7d0a3c8a461143dd6e79fdea4b574da1733f08aa" translate="yes" xml:space="preserve">
          <source>This command begins a new transaction block. If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed. This is the same as the &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="translated">Эта команда начинает новый блок транзакции. Если указан уровень изоляции, режим чтения / записи или отложенный режим, новая транзакция будет иметь эти характеристики, как если бы была выполнена &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; . Это то же самое, что и команда &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62d4740f8d77efc3fe73e95e0f13203063c98ef5" translate="yes" xml:space="preserve">
          <source>This command can't be used to set &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;, nor parameters that are not allowed in &lt;code&gt;postgresql.conf&lt;/code&gt; (e.g., &lt;a href=&quot;runtime-config-preset&quot;&gt;preset options&lt;/a&gt;).</source>
          <target state="translated">Эту команду нельзя использовать для установки &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt; или параметров, которые не разрешены в &lt;code&gt;postgresql.conf&lt;/code&gt; (например, &lt;a href=&quot;runtime-config-preset&quot;&gt;предустановленных параметров&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e40f32b710aa4b5a2f3104aef12c4365c871f09" translate="yes" xml:space="preserve">
          <source>This command cannot be executed inside a transaction block. The prepared transaction is committed immediately.</source>
          <target state="translated">Эта команда не может быть выполнена внутри блока транзакций.Подготовленная транзакция совершается немедленно.</target>
        </trans-unit>
        <trans-unit id="20b731d4b786265bb5e3ab49dc8d1a8760feab6b" translate="yes" xml:space="preserve">
          <source>This command cannot be executed inside a transaction block. The prepared transaction is rolled back immediately.</source>
          <target state="translated">Эта команда не может быть выполнена внутри блока транзакций.Подготовленная транзакция откатывается немедленно.</target>
        </trans-unit>
        <trans-unit id="3a29d09c1029fd474b45e76bcdb5bbdf65bd3023" translate="yes" xml:space="preserve">
          <source>This command cannot be executed while connected to the target database. Thus, it might be more convenient to use the program &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; instead, which is a wrapper around this command.</source>
          <target state="translated">Эта команда не может быть выполнена при подключении к целевой базе данных. Таким образом, может быть удобнее использовать программу &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; , которая является оболочкой для этой команды.</target>
        </trans-unit>
        <trans-unit id="2e5d7b0191945449cf1438d09ec7519757af4913" translate="yes" xml:space="preserve">
          <source>This command complies with the behavior defined in the SQL standard, except for the limitation that, in PostgreSQL, it does not apply to &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints. Also, PostgreSQL checks non-deferrable uniqueness constraints immediately, not at end of statement as the standard would suggest.</source>
          <target state="translated">Эта команда соответствует поведению, определенному в стандарте SQL, за исключением ограничения, которое в PostgreSQL не распространяется на ограничения &lt;code&gt;NOT NULL&lt;/code&gt; и &lt;code&gt;CHECK&lt;/code&gt; . Кроме того, PostgreSQL проверяет неотложные ограничения уникальности немедленно, а не в конце оператора, как предполагает стандарт.</target>
        </trans-unit>
        <trans-unit id="d38352e381f4c256e7b517b01e9b0ccd61de188e" translate="yes" xml:space="preserve">
          <source>This command conforms to ISO/IEC 9075-9 (SQL/MED), except that the standard only allows one foreign table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b34603e56b93d743e26d620fe567201bf5d5d62" translate="yes" xml:space="preserve">
          <source>This command conforms to the ISO/IEC 9075-9 (SQL/MED), except that the standard only allows one foreign table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">Эта команда соответствует ISO / IEC 9075-9 (SQL / MED), за исключением того, что стандарт позволяет отбрасывать только одну стороннюю таблицу для каждой команды, кроме опции &lt;code&gt;IF EXISTS&lt;/code&gt; , которая является расширением PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="8f1f85c735f1b71966f80b17247cbce182c5909a" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except for the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">Эта команда соответствует стандарту SQL, за исключением опции &lt;code&gt;IF EXISTS&lt;/code&gt; , которая является расширением PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="468590b4d092b563617998d73f97b2171f1d8742" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;RETURNING&lt;/code&gt; clauses are PostgreSQL extensions, as is the ability to use &lt;code&gt;WITH&lt;/code&gt; with &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">Эта команда соответствует стандарту SQL, за исключением того, что предложения &lt;code&gt;FROM&lt;/code&gt; и &lt;code&gt;RETURNING&lt;/code&gt; являются расширениями PostgreSQL, как и возможность использования &lt;code&gt;WITH&lt;/code&gt; с &lt;code&gt;UPDATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf1546d77c97dbe67b0ddd8982d22b8e55974688" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;RETURNING&lt;/code&gt; clauses are PostgreSQL extensions, as is the ability to use &lt;code&gt;WITH&lt;/code&gt; with &lt;code&gt;DELETE&lt;/code&gt;.</source>
          <target state="translated">Эта команда соответствует стандарту SQL, за исключением того, что предложения &lt;code&gt;USING&lt;/code&gt; и &lt;code&gt;RETURNING&lt;/code&gt; являются расширениями PostgreSQL, как и возможность использования &lt;code&gt;WITH&lt;/code&gt; с &lt;code&gt;DELETE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="681caf8270b9ecf7b205e0a60ad45b051b0e81dd" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the standard only allows one table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">Эта команда соответствует стандарту SQL, за исключением того, что стандарт позволяет отбрасывать только одну таблицу для каждой команды, кроме опции &lt;code&gt;IF EXISTS&lt;/code&gt; , которая является расширением PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="93af22491b168f8df3ca39363ea91881304542c1" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the standard only allows one view to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">Эта команда соответствует стандарту SQL, за исключением того, что стандарт позволяет отбрасывать только одно представление для каждой команды, кроме опции &lt;code&gt;IF EXISTS&lt;/code&gt; , которая является расширением PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="4b31cc3350023fe9b74a561a1da0159f92b17624" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, with these PostgreSQL extensions:</source>
          <target state="translated">Эта команда соответствует стандарту SQL,с этими расширениями PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="dabcb37ca2e8b2f56629a8b0fd30a7a18fcbfc70" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard. The standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL allows it to be omitted.</source>
          <target state="translated">Эта команда соответствует стандарту SQL. Стандарт определяет, что ключевое слово &lt;code&gt;SAVEPOINT&lt;/code&gt; является обязательным, но PostgreSQL позволяет его опускать.</target>
        </trans-unit>
        <trans-unit id="f1c4c1beba4d7959f48fbfa14fde82110587427a" translate="yes" xml:space="preserve">
          <source>This command displays the execution plan that the PostgreSQL planner generates for the supplied statement. The execution plan shows how the table(s) referenced by the statement will be scanned &amp;mdash; by plain sequential scan, index scan, etc. &amp;mdash; and if multiple tables are referenced, what join algorithms will be used to bring together the required rows from each input table.</source>
          <target state="translated">Эта команда отображает план выполнения, который планировщик PostgreSQL создает для предоставленного оператора. План выполнения показывает, как будут сканироваться таблицы, на которые ссылается оператор - обычным последовательным сканированием, сканированием индекса и т.д. таблица ввода.</target>
        </trans-unit>
        <trans-unit id="4333b1355b5818f99bd58b5b127214feda5e5493" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command is executed immediately if you added a semicolon to it. Otherwise it is redisplayed; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8488cb1889e76b5a66add5218ab2ee79544199b3" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command waits in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">Эта команда выбирает и редактирует определение названной функции или процедуры в форме команды &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; или &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; . Редактирование происходит так же, как и для &lt;code&gt;\edit&lt;/code&gt; . После выхода из редактора обновленная команда ожидает в буфере запроса; введите точку с запятой или &lt;code&gt;\g&lt;/code&gt; чтобы отправить, или &lt;code&gt;\r&lt;/code&gt; чтобы отменить.</target>
        </trans-unit>
        <trans-unit id="f922604d6411c18a78b17a2c612a5b15141b9a3b" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command is executed immediately if you added a semicolon to it. Otherwise it is redisplayed; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf69a2b293c399676b07c902a79f2f6947b772dc" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command waits in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">Эта команда выбирает и редактирует определение именованного представления в форме команды &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; . Редактирование происходит так же, как и для &lt;code&gt;\edit&lt;/code&gt; . После выхода из редактора обновленная команда ожидает в буфере запроса; введите точку с запятой или &lt;code&gt;\g&lt;/code&gt; чтобы отправить, или &lt;code&gt;\r&lt;/code&gt; чтобы отменить.</target>
        </trans-unit>
        <trans-unit id="de8b3b98128e1d7cfa1ced8632fee4a04f5b0692" translate="yes" xml:space="preserve">
          <source>This command fetches and shows the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. The definition is printed to the current query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">Эта команда выбирает и показывает определение названной функции или процедуры в форме команды &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; или &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; . Определение выводится на текущий канал вывода запроса, как установлено &lt;code&gt;\o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c81c5ecf842f5babd90a21465ed15920d3fbf2d" translate="yes" xml:space="preserve">
          <source>This command fetches and shows the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. The definition is printed to the current query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">Эта команда выбирает и показывает определение именованного представления в форме команды &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; . Определение выводится на текущий канал вывода запроса, как установлено &lt;code&gt;\o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd85d7e6ea3b73ffb02cb31a536b30a7bacab224" translate="yes" xml:space="preserve">
          <source>This command is a PostgreSQL extension present for historical reasons. &lt;code&gt;ROLLBACK&lt;/code&gt; is the equivalent standard SQL command.</source>
          <target state="translated">Эта команда является расширением PostgreSQL по историческим причинам. &lt;code&gt;ROLLBACK&lt;/code&gt; - это эквивалентная стандартная команда SQL.</target>
        </trans-unit>
        <trans-unit id="2845ceac7504cffef12e499b57f5339a71e8d823" translate="yes" xml:space="preserve">
          <source>This command is functionally similar to &lt;a href=&quot;sql-selectinto&quot;&gt;SELECT INTO&lt;/a&gt;, but it is preferred since it is less likely to be confused with other uses of the &lt;code&gt;SELECT INTO&lt;/code&gt; syntax. Furthermore, &lt;code&gt;CREATE TABLE AS&lt;/code&gt; offers a superset of the functionality offered by &lt;code&gt;SELECT INTO&lt;/code&gt;.</source>
          <target state="translated">Эта команда функционально похожа на &lt;a href=&quot;sql-selectinto&quot;&gt;SELECT INTO&lt;/a&gt; , но она предпочтительна, поскольку ее менее вероятно перепутать с другими &lt;code&gt;SELECT INTO&lt;/code&gt; синтаксиса SELECT INTO . Кроме того, &lt;code&gt;CREATE TABLE AS&lt;/code&gt; предлагает расширенный набор функций, предлагаемых &lt;code&gt;SELECT INTO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f51d7c5a1147247ad39d7dd8578e7109e7bd269" translate="yes" xml:space="preserve">
          <source>This command is identical to &lt;code&gt;\echo&lt;/code&gt; except that the output will be written to psql's standard error channel, rather than standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eebc2c2dfbb338f54847defda6bbbbd05da85aa" translate="yes" xml:space="preserve">
          <source>This command is identical to &lt;code&gt;\echo&lt;/code&gt; except that the output will be written to the query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">Эта команда идентична &lt;code&gt;\echo&lt;/code&gt; за исключением того, что вывод будет записан в канал вывода запроса, как установлено &lt;code&gt;\o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6b1eb8df7cef0a6e41f20fd61cbd76e26932fed" translate="yes" xml:space="preserve">
          <source>This command is similar to the corresponding command in the SQL standard, apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension. But note that much of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command and the data type extension mechanisms in PostgreSQL differ from the SQL standard.</source>
          <target state="translated">Эта команда похожа на соответствующую команду в стандарте SQL, за исключением опции &lt;code&gt;IF EXISTS&lt;/code&gt; , которая является расширением PostgreSQL. Но обратите внимание, что большая часть команды &lt;code&gt;CREATE TYPE&lt;/code&gt; и механизмов расширения типов данных в PostgreSQL отличается от стандарта SQL.</target>
        </trans-unit>
        <trans-unit id="74399205e4f06569f7b7a41f319f8abd6da5004d" translate="yes" xml:space="preserve">
          <source>This command is unrelated to the SQL command &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;.</source>
          <target state="translated">Эта команда не связана с командой SQL &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="017757db6d9507e6b7436f7a9ae4e2248893c3e8" translate="yes" xml:space="preserve">
          <source>This command loads a shared library file into the PostgreSQL server's address space. If the file has been loaded already, the command does nothing. Shared library files that contain C functions are automatically loaded whenever one of their functions is called. Therefore, an explicit &lt;code&gt;LOAD&lt;/code&gt; is usually only needed to load a library that modifies the server's behavior through &amp;ldquo;hooks&amp;rdquo; rather than providing a set of functions.</source>
          <target state="translated">Эта команда загружает файл общей библиотеки в адресное пространство сервера PostgreSQL. Если файл уже загружен, команда ничего не делает. Файлы общей библиотеки, содержащие функции C, автоматически загружаются при вызове одной из их функций. Следовательно, явная &lt;code&gt;LOAD&lt;/code&gt; обычно требуется только для загрузки библиотеки, которая изменяет поведение сервера с помощью &amp;laquo;перехватчиков&amp;raquo;, а не предоставляет набор функций.</target>
        </trans-unit>
        <trans-unit id="58fcb6c8246e8a6d76583723b04afe1b09a7d9c3" translate="yes" xml:space="preserve">
          <source>This command may be used to end SQL queries, taking the place of the terminating semicolon (&lt;code&gt;;&lt;/code&gt;).</source>
          <target state="translated">Эта команда может использоваться для завершения SQL-запросов, заменяя завершающую точку с запятой ( &lt;code&gt;;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="677d2975d49fcc1351e4405fb4dd24f72ba0639a" translate="yes" xml:space="preserve">
          <source>This command must be used inside a transaction block. Use &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; to start one.</source>
          <target state="translated">Эта команда должна использоваться внутри блока транзакции. Используйте &lt;a href=&quot;sql-begin&quot;&gt;BEGIN,&lt;/a&gt; чтобы начать.</target>
        </trans-unit>
        <trans-unit id="6b6b0df46bdea049004d95ff3514fc627c0bf758" translate="yes" xml:space="preserve">
          <source>This command must not be used when the server is running. &lt;code&gt;pg_resetwal&lt;/code&gt; will refuse to start up if it finds a server lock file in the data directory. If the server crashed then a lock file might have been left behind; in that case you can remove the lock file to allow &lt;code&gt;pg_resetwal&lt;/code&gt; to run. But before you do so, make doubly certain that there is no server process still alive.</source>
          <target state="translated">Эту команду нельзя использовать, когда сервер работает. &lt;code&gt;pg_resetwal&lt;/code&gt; откажется запускаться, если обнаружит файл блокировки сервера в каталоге данных. Если сервер вышел из строя, то, возможно, остался файл блокировки; в этом случае вы можете удалить файл блокировки, чтобы разрешить &lt;code&gt;pg_resetwal&lt;/code&gt; . Но прежде чем вы это сделаете, дважды убедитесь, что ни один серверный процесс еще не активен.</target>
        </trans-unit>
        <trans-unit id="71df21dcefbc6a0e13c7dad07c76dab173b26ca8" translate="yes" xml:space="preserve">
          <source>This command only alters the behavior of constraints within the current transaction. Issuing this outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">Данная команда изменяет только поведение ограничений внутри текущей транзакции.Выдача ее за пределами блока транзакций выдает предупреждение и в противном случае не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="cd16c39418a0167a8c3018978b081238b82407a5" translate="yes" xml:space="preserve">
          <source>This command removes the procedural language &lt;code&gt;plsample&lt;/code&gt;:</source>
          <target state="translated">Эта команда удаляет процедурный язык &lt;code&gt;plsample&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="13a5e5db6761174aa48d67b3836a7c44b067d9bd" translate="yes" xml:space="preserve">
          <source>This command removes the square root function:</source>
          <target state="translated">Эта команда удаляет функцию квадратного корня:</target>
        </trans-unit>
        <trans-unit id="c8da0e72c154580e68779b6eda81a32e4cdad2c2" translate="yes" xml:space="preserve">
          <source>This command sets options affecting the output of query result tables. &lt;code&gt;option&lt;/code&gt; indicates which option is to be set. The semantics of &lt;code&gt;value&lt;/code&gt; vary depending on the selected option. For some options, omitting &lt;code&gt;value&lt;/code&gt; causes the option to be toggled or unset, as described under the particular option. If no such behavior is mentioned, then omitting &lt;code&gt;value&lt;/code&gt; just results in the current setting being displayed.</source>
          <target state="translated">Эта команда устанавливает параметры, влияющие на вывод таблиц результатов запроса. &lt;code&gt;option&lt;/code&gt; указывает, какой параметр должен быть установлен. Семантика &lt;code&gt;value&lt;/code&gt; зависит от выбранного варианта. Для некоторых опций пропуск &lt;code&gt;value&lt;/code&gt; приводит к тому, что опция будет переключаться или отключаться, как описано в разделе о конкретной опции. Если такое поведение не упоминается, то пропуск &lt;code&gt;value&lt;/code&gt; просто приводит к отображению текущего параметра.</target>
        </trans-unit>
        <trans-unit id="55b80b7eaaaf7b41602e63f2f9f3e4efa523bee3" translate="yes" xml:space="preserve">
          <source>This command sets the current user identifier of the current SQL session to be &lt;code&gt;role_name&lt;/code&gt;. The role name can be written as either an identifier or a string literal. After &lt;code&gt;SET ROLE&lt;/code&gt;, permissions checking for SQL commands is carried out as though the named role were the one that had logged in originally.</source>
          <target state="translated">Эта команда устанавливает текущий идентификатор пользователя текущего сеанса SQL как &lt;code&gt;role_name&lt;/code&gt; . Имя роли может быть записано как идентификатор или строковый литерал. После &lt;code&gt;SET ROLE&lt;/code&gt; проверка разрешений для команд SQL выполняется так, как если бы указанная роль была той, которая вошла в систему изначально.</target>
        </trans-unit>
        <trans-unit id="f7712990490e001a7ee650bc9d46804ef39e8a64" translate="yes" xml:space="preserve">
          <source>This command sets the session user identifier and the current user identifier of the current SQL session to be &lt;code&gt;user_name&lt;/code&gt;. The user name can be written as either an identifier or a string literal. Using this command, it is possible, for example, to temporarily become an unprivileged user and later switch back to being a superuser.</source>
          <target state="translated">Эта команда устанавливает идентификатор пользователя сеанса и идентификатор текущего пользователя текущего сеанса SQL как &lt;code&gt;user_name&lt;/code&gt; . Имя пользователя может быть записано как идентификатор или строковый литерал. Используя эту команду, можно, например, временно стать непривилегированным пользователем, а затем снова переключиться на суперпользователя.</target>
        </trans-unit>
        <trans-unit id="7c9ce1414108a89726b8871ae0b54d84b052aa18" translate="yes" xml:space="preserve">
          <source>This command will fail if any of &lt;code&gt;hstore&lt;/code&gt;'s objects are in use in the database, for example if any tables have columns of the &lt;code&gt;hstore&lt;/code&gt; type. Add the &lt;code&gt;CASCADE&lt;/code&gt; option to forcibly remove those dependent objects as well.</source>
          <target state="translated">Эта команда завершится ошибкой, если какой-либо из &lt;code&gt;hstore&lt;/code&gt; используется в базе данных, например, если какие-либо таблицы имеют столбцы типа &lt;code&gt;hstore&lt;/code&gt; . Добавьте параметр &lt;code&gt;CASCADE&lt;/code&gt; , чтобы принудительно удалить и эти зависимые объекты.</target>
        </trans-unit>
        <trans-unit id="6b862ff106f276a9375de8c6aab656803f7a4efb" translate="yes" xml:space="preserve">
          <source>This command will free storage associated with the materialized view &lt;code&gt;annual_statistics_basis&lt;/code&gt; and leave it in an unscannable state:</source>
          <target state="translated">Эта команда освободит хранилище, связанное с материализованным представлением &lt;code&gt;annual_statistics_basis&lt;/code&gt; и оставит его в состоянии, недоступном для сканирования:</target>
        </trans-unit>
        <trans-unit id="6c9c73632173fe8b7637783ced8159d79d16ea65" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that reference the configuration in &lt;code&gt;to_tsvector&lt;/code&gt; calls. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the text search configuration.</source>
          <target state="translated">Эта команда не будет выполнена успешно, если существуют какие-либо индексы, которые ссылаются на конфигурацию в &lt;code&gt;to_tsvector&lt;/code&gt; . Добавьте &lt;code&gt;CASCADE&lt;/code&gt; , чтобы удалить такие индексы вместе с конфигурацией текстового поиска.</target>
        </trans-unit>
        <trans-unit id="9b7e8e631e47d7a2498f014c562d775f4aa922d4" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that use operator classes within the family. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the operator family.</source>
          <target state="translated">Эта команда не будет выполнена успешно, если в семействе существуют какие-либо индексы, использующие классы операторов. Добавьте &lt;code&gt;CASCADE&lt;/code&gt; , чтобы удалить такие индексы вместе с семейством операторов.</target>
        </trans-unit>
        <trans-unit id="e344bd47bfc7344c009cae8df60f4f2d04ad7fee" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that use the operator class. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the operator class.</source>
          <target state="translated">Эта команда не будет выполнена, если существуют какие-либо индексы, использующие класс операторов. Добавьте &lt;code&gt;CASCADE&lt;/code&gt; , чтобы удалить такие индексы вместе с классом операторов.</target>
        </trans-unit>
        <trans-unit id="0a073ad25e0df8057b772f9939bb92486f83b429" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search configurations that use the dictionary. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such configurations along with the dictionary.</source>
          <target state="translated">Эта команда не будет выполнена, если существуют какие-либо существующие конфигурации текстового поиска, использующие словарь. Добавьте &lt;code&gt;CASCADE&lt;/code&gt; , чтобы удалить такие конфигурации вместе со словарем.</target>
        </trans-unit>
        <trans-unit id="98b8a535bcfac2a0dbcd407ddbfe551b50e04749" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search configurations that use the parser. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such configurations along with the parser.</source>
          <target state="translated">Эта команда не будет выполнена успешно, если существуют какие-либо существующие конфигурации текстового поиска, использующие анализатор. Добавьте &lt;code&gt;CASCADE&lt;/code&gt; , чтобы удалить такие конфигурации вместе с парсером.</target>
        </trans-unit>
        <trans-unit id="9140e2324a0907c1e9782d65b5e3ea71a6d9655e" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search dictionaries that use the template. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such dictionaries along with the template.</source>
          <target state="translated">Эта команда не будет выполнена успешно, если существуют какие-либо словари текстового поиска, использующие этот шаблон. Добавьте &lt;code&gt;CASCADE&lt;/code&gt; , чтобы такие словари удалялись вместе с шаблоном.</target>
        </trans-unit>
        <trans-unit id="17f6112c2268ba0c9663f367e376afa3756d596b" translate="yes" xml:space="preserve">
          <source>This command will perform archiving when &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; exists, and otherwise silently return zero exit status (allowing PostgreSQL to recycle the unwanted WAL file).</source>
          <target state="translated">Эта команда выполнит архивирование, когда существует &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; , и в противном случае автоматически вернет нулевой статус выхода (позволяя PostgreSQL повторно использовать ненужный файл WAL).</target>
        </trans-unit>
        <trans-unit id="08ffbb1ab36d371eef7c290033c779142e12ec33" translate="yes" xml:space="preserve">
          <source>This command will remove the index &lt;code&gt;title_idx&lt;/code&gt;:</source>
          <target state="translated">Эта команда удалит индекс &lt;code&gt;title_idx&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2078fd2a1ddd7b0f72d80b8a3d0cc32c019e717f" translate="yes" xml:space="preserve">
          <source>This command will remove the materialized view called &lt;code&gt;order_summary&lt;/code&gt;:</source>
          <target state="translated">Эта команда удалит материализованное представление с именем &lt;code&gt;order_summary&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a242c77a8ccd56ddace9304e1ec3ea12442c9d59" translate="yes" xml:space="preserve">
          <source>This command will remove the view called &lt;code&gt;kinds&lt;/code&gt;:</source>
          <target state="translated">Эта команда удалит представление, называемое &lt;code&gt;kinds&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d7ac7005486ff5a82c81e39d2a6985dcac07fb2" translate="yes" xml:space="preserve">
          <source>This command will replace the contents of the materialized view called &lt;code&gt;order_summary&lt;/code&gt; using the query from the materialized view's definition, and leave it in a scannable state:</source>
          <target state="translated">Эта команда заменит содержимое материализованного представления с именем &lt;code&gt;order_summary&lt;/code&gt; , используя запрос из определения материализованного представления, и оставит его в состоянии сканирования:</target>
        </trans-unit>
        <trans-unit id="21fb41393a4eea96218c35f555df78b95eb06e38" translate="yes" xml:space="preserve">
          <source>This command will return a sample of 100 rows from the table &lt;code&gt;my_table&lt;/code&gt; (unless the table does not have 100 visible rows, in which case all its rows are returned).</source>
          <target state="translated">Эта команда вернет образец из 100 строк из таблицы &lt;code&gt;my_table&lt;/code&gt; (если таблица не имеет 100 видимых строк, и в этом случае будут возвращены все ее строки).</target>
        </trans-unit>
        <trans-unit id="01ae94e8662537ac6716b276145364c5f4fb1046" translate="yes" xml:space="preserve">
          <source>This command will return as large a sample of &lt;code&gt;my_table&lt;/code&gt; as it can read in 1 second (1000 milliseconds). Of course, if the whole table can be read in under 1 second, all its rows will be returned.</source>
          <target state="translated">Эта команда вернет такой большой образец &lt;code&gt;my_table&lt;/code&gt; , который он может прочитать за 1 секунду (1000 миллисекунд). Конечно, если всю таблицу можно прочитать менее чем за 1 секунду, будут возвращены все ее строки.</target>
        </trans-unit>
        <trans-unit id="8973f1428f19cf5f51d43ae902ba0ec839e24687" translate="yes" xml:space="preserve">
          <source>This command will work independent of whether &lt;code&gt;foo&lt;/code&gt; is an aggregate, function, or procedure.</source>
          <target state="translated">Эта команда будет работать независимо от того, является ли &lt;code&gt;foo&lt;/code&gt; агрегатом, функцией или процедурой.</target>
        </trans-unit>
        <trans-unit id="8ac0fa233aac6a123e11329c2972c3833b6e69d2" translate="yes" xml:space="preserve">
          <source>This confirms there are 100 distinct combinations in the two columns, and all of them are about equally likely (1% frequency for each one). The base frequency is the frequency computed from per-column statistics, as if there were no multi-column statistics. Had there been any null values in either of the columns, this would be identified in the &lt;code&gt;nulls&lt;/code&gt; column.</source>
          <target state="translated">Это подтверждает, что в двух столбцах есть 100 различных комбинаций, и все они примерно одинаково вероятны (частота 1% для каждого из них). Базовая частота - это частота, вычисляемая на основе статистики по столбцам, как если бы статистики по нескольким столбцам не было. Если бы в любом из столбцов были какие-либо значения NULL, это было бы указано в столбце &lt;code&gt;nulls&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a75759d2d2d52e1dc2865efa8cf2fb6090b3f128" translate="yes" xml:space="preserve">
          <source>This constant is a two-dimensional, 3-by-3 array consisting of three subarrays of integers.</source>
          <target state="translated">Эта константа представляет собой двумерный массив 3 на 3,состоящий из трех подмассивов целых чисел.</target>
        </trans-unit>
        <trans-unit id="a1d39be831b881f732286b6571d19294d43d84bf" translate="yes" xml:space="preserve">
          <source>This constraint is defined locally for the relation. It is a non-inheritable constraint.</source>
          <target state="translated">Это ограничение определяется локально для отношения.Это ненаследуемое ограничение.</target>
        </trans-unit>
        <trans-unit id="ee0fafaed69e2c50c035d4176a4d38521e63e5d6" translate="yes" xml:space="preserve">
          <source>This constraint is defined locally for the relation. Note that a constraint can be locally defined and inherited simultaneously.</source>
          <target state="translated">Это ограничение определяется локально для отношения.Обратите внимание,что ограничение может быть локально определено и наследовано одновременно.</target>
        </trans-unit>
        <trans-unit id="677137c6fdb574fcaee9a2f495faececc7604ba8" translate="yes" xml:space="preserve">
          <source>This construct is similar to a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; row comparison, but it does not yield null for null inputs. Instead, any null value is considered unequal to (distinct from) any non-null value, and any two nulls are considered equal (not distinct). Thus the result will either be true or false, never null.</source>
          <target state="translated">Эта конструкция похожа на сравнение строк &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , но она не возвращает значение NULL для входных значений NULL. Вместо этого любое нулевое значение считается неравным (отличным от) любому ненулевому значению, а любые два нулевых значения считаются равными (не отличными). Таким образом, результат будет либо истинным, либо ложным, но никогда не будет нулевым.</target>
        </trans-unit>
        <trans-unit id="1020bde7bf73c7df63ce8acf0bfdb90bb93b7fcb" translate="yes" xml:space="preserve">
          <source>This construct is similar to a &lt;code&gt;=&lt;/code&gt; row comparison, but it does not yield null for null inputs. Instead, any null value is considered unequal to (distinct from) any non-null value, and any two nulls are considered equal (not distinct). Thus the result will always be either true or false, never null.</source>
          <target state="translated">Эта конструкция похожа на сравнение строк a &lt;code&gt;=&lt;/code&gt; , но не возвращает значение NULL для входных значений NULL. Вместо этого любое нулевое значение считается неравным (отличным от) любому ненулевому значению, а любые два нулевых значения считаются равными (не отличными). Таким образом, результат всегда будет либо истинным, либо ложным, но никогда не будет нулевым.</target>
        </trans-unit>
        <trans-unit id="33a306bcfd5b03d8e762816f623417a83fd23a93" translate="yes" xml:space="preserve">
          <source>This controls how many pages or tuples of a single relation can be predicate-locked before the lock is promoted to covering the whole relation. Values greater than or equal to zero mean an absolute limit, while negative values mean &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt; divided by the absolute value of this setting. The default is -2, which keeps the behavior from previous versions of PostgreSQL. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Это контролирует, сколько страниц или кортежей одного отношения может быть заблокировано по предикату, прежде чем блокировка будет повышена до охвата всего отношения. Значения больше или равные нулю означают абсолютный предел, а отрицательные значения означают &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction,&lt;/a&gt; деленное на абсолютное значение этого параметра. Значение по умолчанию - -2, что сохраняет поведение предыдущих версий PostgreSQL. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="37486631dcaede39c55161d228505d69d73e3e22" translate="yes" xml:space="preserve">
          <source>This controls how many rows on a single page can be predicate-locked before the lock is promoted to covering the whole page. The default is 2. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Это контролирует, сколько строк на одной странице может быть заблокировано по предикату, прежде чем блокировка будет распространена на всю страницу. По умолчанию - 2. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="b8a7a6bb04de3147a65fe3e69e114d351a95bdd3" translate="yes" xml:space="preserve">
          <source>This controls whether a quote mark can be represented by &lt;code&gt;\'&lt;/code&gt; in a string literal. The preferred, SQL-standard way to represent a quote mark is by doubling it (&lt;code&gt;''&lt;/code&gt;) but PostgreSQL has historically also accepted &lt;code&gt;\'&lt;/code&gt;. However, use of &lt;code&gt;\'&lt;/code&gt; creates security risks because in some client character set encodings, there are multibyte characters in which the last byte is numerically equivalent to ASCII &lt;code&gt;\&lt;/code&gt;. If client-side code does escaping incorrectly then a SQL-injection attack is possible. This risk can be prevented by making the server reject queries in which a quote mark appears to be escaped by a backslash. The allowed values of &lt;code&gt;backslash_quote&lt;/code&gt; are &lt;code&gt;on&lt;/code&gt; (allow &lt;code&gt;\'&lt;/code&gt; always), &lt;code&gt;off&lt;/code&gt; (reject always), and &lt;code&gt;safe_encoding&lt;/code&gt; (allow only if client encoding does not allow ASCII &lt;code&gt;\&lt;/code&gt; within a multibyte character). &lt;code&gt;safe_encoding&lt;/code&gt; is the default setting.</source>
          <target state="translated">Это контролирует, может ли кавычка быть представлена &lt;code&gt;\'&lt;/code&gt; в строковом литерале. Предпочтительный стандарт SQL для представления кавычек - это удвоение ( &lt;code&gt;''&lt;/code&gt; ), но PostgreSQL исторически также принимал &lt;code&gt;\'&lt;/code&gt; . Однако использование &lt;code&gt;\'&lt;/code&gt; создает риски для безопасности, потому что в некоторых кодировках клиентского набора символов есть многобайтовые символы, в которых последний байт численно эквивалентен ASCII &lt;code&gt;\&lt;/code&gt; . Если клиентский код сбегает неправильно, возможна атака с использованием SQL-инъекции. Этот риск можно предотвратить, если заставить сервер отклонять запросы, в которых кавычки заменяются обратной косой чертой. Допустимые значения &lt;code&gt;backslash_quote&lt;/code&gt; находятся &lt;code&gt;on&lt;/code&gt; (позволяют &lt;code&gt;\'&lt;/code&gt; always), &lt;code&gt;off&lt;/code&gt; (отклонять всегда) и &lt;code&gt;safe_encoding&lt;/code&gt; (разрешить, только если клиентская кодировка не позволяет ASCII &lt;code&gt;\&lt;/code&gt; внутри многобайтового символа). &lt;code&gt;safe_encoding&lt;/code&gt; - настройка по умолчанию.</target>
        </trans-unit>
        <trans-unit id="90ccb11174fcbc5e0dcaecf5ce4057bc44c37e08" translate="yes" xml:space="preserve">
          <source>This controls whether ordinary string literals (&lt;code&gt;'...'&lt;/code&gt;) treat backslashes literally, as specified in the SQL standard. Beginning in PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt; (prior releases defaulted to &lt;code&gt;off&lt;/code&gt;). Applications can check this parameter to determine how string literals will be processed. The presence of this parameter can also be taken as an indication that the escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;) is supported. Escape string syntax (&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;) should be used if an application desires backslashes to be treated as escape characters.</source>
          <target state="translated">Это контролирует, обрабатывают ли обычные строковые литералы ( &lt;code&gt;'...'&lt;/code&gt; ) обратную косую черту буквально, как указано в стандарте SQL. Начиная с PostgreSQL 9.1, по умолчанию &lt;code&gt;on&lt;/code&gt; (предыдущие выпуски по умолчанию для &lt;code&gt;off&lt;/code&gt; ). Приложения могут проверить этот параметр, чтобы определить, как будут обрабатываться строковые литералы. Наличие этого параметра также можно рассматривать как указание на то, что поддерживается синтаксис escape-строки ( &lt;code&gt;E'...'&lt;/code&gt; ). Синтаксис escape-строки ( &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;раздел 4.1.2.2&lt;/a&gt; ) следует использовать, если приложение хочет, чтобы обратная косая черта обрабатывалась как escape-символы.</target>
        </trans-unit>
        <trans-unit id="04ce8a3710d0e73d6eb9a44e5b7e7596e3b6ada8" translate="yes" xml:space="preserve">
          <source>This controls whether the array input parser recognizes unquoted &lt;code&gt;NULL&lt;/code&gt; as specifying a null array element. By default, this is &lt;code&gt;on&lt;/code&gt;, allowing array values containing null values to be entered. However, PostgreSQL versions before 8.2 did not support null values in arrays, and therefore would treat &lt;code&gt;NULL&lt;/code&gt; as specifying a normal array element with the string value &amp;ldquo;NULL&amp;rdquo;. For backward compatibility with applications that require the old behavior, this variable can be turned &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">Это контролирует, распознает ли синтаксический анализатор ввода массива некотируемый &lt;code&gt;NULL&lt;/code&gt; как указание на нулевой элемент массива. По умолчанию это &lt;code&gt;on&lt;/code&gt; , позволяя значение массива , содержащее значения нулевого быть введено. Однако версии PostgreSQL до 8.2 не поддерживали нулевые значения в массивах и поэтому рассматривали бы &lt;code&gt;NULL&lt;/code&gt; как указание обычного элемента массива со строковым значением &amp;laquo;NULL&amp;raquo;. Для обратной совместимости с приложениями, требующими старого поведения, эту переменную можно &lt;code&gt;off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a334bdaf5d7adfdeb7bdd6cc764b677eb1d1fc0d" translate="yes" xml:space="preserve">
          <source>This controls whether the constraint can be deferred. A constraint that is not deferrable will be checked immediately after every command. Checking of constraints that are deferrable can be postponed until the end of the transaction (using the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command). &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; is the default. Currently, only &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;EXCLUDE&lt;/code&gt;, and &lt;code&gt;REFERENCES&lt;/code&gt; (foreign key) constraints accept this clause. &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints are not deferrable. Note that deferrable constraints cannot be used as conflict arbitrators in an &lt;code&gt;INSERT&lt;/code&gt; statement that includes an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause.</source>
          <target state="translated">Это контролирует, можно ли отложить ограничение. Ограничение, которое нельзя отложить, будет проверяться сразу после каждой команды. Проверка откладываемых ограничений может быть отложена до конца транзакции (с помощью команды &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; ). &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; - значение по умолчанию. В настоящее время это предложение принимают только ограничения &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; , &lt;code&gt;EXCLUDE&lt;/code&gt; и &lt;code&gt;REFERENCES&lt;/code&gt; (внешний ключ). Ограничения &lt;code&gt;NOT NULL&lt;/code&gt; и &lt;code&gt;CHECK&lt;/code&gt; нельзя откладывать. Обратите внимание, что откладываемые ограничения не могут использоваться в качестве арбитров конфликта в &lt;code&gt;INSERT&lt;/code&gt; которая включает &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; . пункт.</target>
        </trans-unit>
        <trans-unit id="1918927d29af63f959f031de4a1383381d5530a7" translate="yes" xml:space="preserve">
          <source>This creates a security hazard when calling, via qualified name &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;, a variadic function found in a schema that permits untrusted users to create objects. A malicious user can take control and execute arbitrary SQL functions as though you executed them. Substitute a call bearing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, which bypasses this hazard. Calls populating &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameters often have no equivalent formulation containing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword. To issue those calls safely, the function's schema must permit only trusted users to create objects.</source>
          <target state="translated">Это создает угрозу безопасности при вызове через полное имя &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt; вариативной функции, обнаруженной в схеме, которая позволяет недоверенным пользователям создавать объекты. Злоумышленник может взять под контроль и выполнять произвольные функции SQL, как если бы вы их выполняли. Замените вызов &lt;code&gt;VARIADIC&lt;/code&gt; словом VARIADIC, чтобы избежать этой опасности. Вызовы, &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; параметры, часто не имеют эквивалентной формулировки, содержащей ключевое слово &lt;code&gt;VARIADIC&lt;/code&gt; . Для безопасного выполнения этих вызовов схема функции должна разрешать создание объектов только доверенным пользователям.</target>
        </trans-unit>
        <trans-unit id="0046336b7276ca25c455594eb1a8ba81761391eb" translate="yes" xml:space="preserve">
          <source>This creates a security hazard when calling, via qualified name &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[9]&lt;/sup&gt;&lt;/a&gt;, a variadic function found in a schema that permits untrusted users to create objects. A malicious user can take control and execute arbitrary SQL functions as though you executed them. Substitute a call bearing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, which bypasses this hazard. Calls populating &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameters often have no equivalent formulation containing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword. To issue those calls safely, the function's schema must permit only trusted users to create objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12540189cdbd640895d38788f65f9fbba1d76fa" translate="yes" xml:space="preserve">
          <source>This creates a table named &lt;code&gt;my_first_table&lt;/code&gt; with two columns. The first column is named &lt;code&gt;first_column&lt;/code&gt; and has a data type of &lt;code&gt;text&lt;/code&gt;; the second column has the name &lt;code&gt;second_column&lt;/code&gt; and the type &lt;code&gt;integer&lt;/code&gt;. The table and column names follow the identifier syntax explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-IDENTIFIERS&quot;&gt;Section 4.1.1&lt;/a&gt;. The type names are usually also identifiers, but there are some exceptions. Note that the column list is comma-separated and surrounded by parentheses.</source>
          <target state="translated">Это создает таблицу с именем &lt;code&gt;my_first_table&lt;/code&gt; с двумя столбцами. Первый столбец называется &lt;code&gt;first_column&lt;/code&gt; и имеет &lt;code&gt;text&lt;/code&gt; тип данных ; второй столбец имеет имя &lt;code&gt;second_column&lt;/code&gt; и &lt;code&gt;integer&lt;/code&gt; тип . Имена таблиц и столбцов соответствуют синтаксису идентификаторов, описанному в &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-IDENTIFIERS&quot;&gt;Разделе 4.1.1&lt;/a&gt; . Имена типов обычно также являются идентификаторами, но есть некоторые исключения. Обратите внимание, что список столбцов разделен запятыми и заключен в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="2df112a8a7b40124ef90c403fdef2c5ff1577746" translate="yes" xml:space="preserve">
          <source>This creates an availability hazard when calling, via qualified name&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;, any function found in a schema that permits untrusted users to create objects. A malicious user can create a function with the name of an existing function, replicating that function's parameters and appending novel parameters having default values. This precludes new calls to the original function. To forestall this hazard, place functions in schemas that permit only trusted users to create objects.</source>
          <target state="translated">Это создает угрозу доступности при вызове через полное имя &lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt; любой функции, обнаруженной в схеме, которая позволяет недоверенным пользователям создавать объекты. Злоумышленник может создать функцию с именем существующей функции, реплицируя параметры этой функции и добавляя новые параметры, имеющие значения по умолчанию. Это исключает новые вызовы исходной функции. Чтобы предотвратить эту опасность, разместите в схемах функции, которые позволяют создавать объекты только доверенным пользователям.</target>
        </trans-unit>
        <trans-unit id="a732ec34a93086b562c56c901a996da67bed793b" translate="yes" xml:space="preserve">
          <source>This creates an availability hazard when calling, via qualified name&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/a&gt;, any function found in a schema that permits untrusted users to create objects. A malicious user can create a function with the name of an existing function, replicating that function's parameters and appending novel parameters having default values. This precludes new calls to the original function. To forestall this hazard, place functions in schemas that permit only trusted users to create objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd08e31876bb0659f97fc74e6e81b5de962b395" translate="yes" xml:space="preserve">
          <source>This creates registry entries used by the event viewer, under the default event source named &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">Это создает записи реестра, используемые средством просмотра событий, в источнике событий по умолчанию с именем &lt;code&gt;PostgreSQL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2f685ce47d5796c5b17ed2dc2e9f2a95a1be4cb" translate="yes" xml:space="preserve">
          <source>This creates the scripts and compiles the C files containing user-defined functions and types. Then, to start the tutorial, do the following:</source>
          <target state="translated">При этом создаются скрипты и компилируются C-файлы,содержащие определяемые пользователем функции и типы.Затем,чтобы запустить учебное пособие,сделайте следующее:</target>
        </trans-unit>
        <trans-unit id="d9b31e3f2055cca38cc6b689ae9fad52cab29160" translate="yes" xml:space="preserve">
          <source>This design allows for both backwards-compatible header additions (add header extension chunks, or set low-order flag bits) and non-backwards-compatible changes (set high-order flag bits to signal such changes, and add supporting data to the extension area if needed).</source>
          <target state="translated">Такая конструкция позволяет добавлять заголовки как с обратной совместимостью (добавлять куски расширения заголовка или устанавливать биты флагов низкого порядка),так и не с обратной совместимостью (устанавливать биты флагов высокого порядка,чтобы сигнализировать о таких изменениях,и добавлять поддерживающие данные в область расширения,если это необходимо).</target>
        </trans-unit>
        <trans-unit id="d1507a2d26ed6cd13d8f06661be29be45050cd21" translate="yes" xml:space="preserve">
          <source>This dictionary template is used to create dictionaries that replace a word with a synonym. Phrases are not supported (use the thesaurus template (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;Section 12.6.4&lt;/a&gt;) for that). A synonym dictionary can be used to overcome linguistic problems, for example, to prevent an English stemmer dictionary from reducing the word &amp;ldquo;Paris&amp;rdquo; to &amp;ldquo;pari&amp;rdquo;. It is enough to have a &lt;code&gt;Paris paris&lt;/code&gt; line in the synonym dictionary and put it before the &lt;code&gt;english_stem&lt;/code&gt; dictionary. For example:</source>
          <target state="translated">Этот шаблон словаря используется для создания словарей, заменяющих слово синонимом. Фразы не поддерживаются (используйте для этого шаблон тезауруса ( &lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;раздел 12.6.4&lt;/a&gt; )). Словарь синонимов может использоваться для преодоления лингвистических проблем, например, чтобы не дать английскому стеммерному словарю сократить слово &amp;laquo;Paris&amp;raquo; до &amp;laquo;pari&amp;raquo;. Достаточно иметь строку &lt;code&gt;Paris paris&lt;/code&gt; в словаре синонимов и поставить ее перед словарем &lt;code&gt;english_stem&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="dfab7a227af58e60167bfee0ac87d5907b3ad3ee" translate="yes" xml:space="preserve">
          <source>This document answers frequently asked questions about SELinux. It focuses primarily on Fedora, but is not limited to Fedora.</source>
          <target state="translated">Этот документ дает ответы на часто задаваемые вопросы о SELinux.Он посвящен в основном Федоре,но не ограничивается Федорой.</target>
        </trans-unit>
        <trans-unit id="64f99dd7f4a8868a1752a291c897889c1028116d" translate="yes" xml:space="preserve">
          <source>This document provides a wide spectrum of knowledge to administer SELinux on your systems. It focuses primarily on Red Hat operating systems, but is not limited to them.</source>
          <target state="translated">Этот документ предоставляет широкий спектр знаний для администрирования SELinux на ваших системах.Он фокусируется в основном на операционных системах Red Hat,но не ограничивается ими.</target>
        </trans-unit>
        <trans-unit id="d69a24fba08d14e58aa301ec18364f049dd9f435" translate="yes" xml:space="preserve">
          <source>This does not prevent cleanup of dead rows which have reached the age specified by &lt;code&gt;old_snapshot_threshold&lt;/code&gt;.</source>
          <target state="translated">Это не препятствует очистке мертвых строк, которые достигли возраста, указанного в &lt;code&gt;old_snapshot_threshold&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34a33c8e067844a10adc4d1ec87dc8f9bed7f940" translate="yes" xml:space="preserve">
          <source>This does not work because &lt;code&gt;integer&lt;/code&gt; does not have an implicit cast to &lt;code&gt;text&lt;/code&gt;. An explicit cast will work, however:</source>
          <target state="translated">Это не работает, потому что &lt;code&gt;integer&lt;/code&gt; не имеет неявного &lt;code&gt;text&lt;/code&gt; в текст . Однако явное приведение будет работать:</target>
        </trans-unit>
        <trans-unit id="f8a11325d581fd69da8d48499eb1dc3e0e55ab89" translate="yes" xml:space="preserve">
          <source>This equivalence between functional notation and field notation makes it possible to use functions on composite types to implement &amp;ldquo;computed fields&amp;rdquo;.   An application using the last query above wouldn't need to be directly aware that &lt;code&gt;somefunc&lt;/code&gt; isn't a real column of the table.</source>
          <target state="translated">Эта эквивалентность между функциональной нотацией и нотацией полей позволяет использовать функции составных типов для реализации &amp;laquo;вычисляемых полей&amp;raquo;. Приложению, использующему последний запрос выше, не нужно напрямую знать, что &lt;code&gt;somefunc&lt;/code&gt; не является настоящим столбцом таблицы.</target>
        </trans-unit>
        <trans-unit id="cf34fbb91a15c4b2d08b406f2026ab198cd22a33" translate="yes" xml:space="preserve">
          <source>This evaluates query on document and wraps the result in XML tags. If the result is multivalued, the output will look like:</source>
          <target state="translated">Это вычисляет запрос на документ и обертывает результат в XML-теги.Если результат многозначен,то он будет выглядеть как результат:</target>
        </trans-unit>
        <trans-unit id="15ced5262cfea0d7c224d2d14022b915ded0c9bb" translate="yes" xml:space="preserve">
          <source>This example creates a composite type and uses it in a function definition:</source>
          <target state="translated">В этом примере создается составной тип и используется в определении функции:</target>
        </trans-unit>
        <trans-unit id="fd20b024051cecf699f47d6601ef377cbbceb783" translate="yes" xml:space="preserve">
          <source>This example creates a large object type and uses it in a table definition:</source>
          <target state="translated">В этом примере создается большой тип объекта и используется в определении таблицы:</target>
        </trans-unit>
        <trans-unit id="81988155ae08cfd1bb03bda3f7e767cd1d1e7982" translate="yes" xml:space="preserve">
          <source>This example creates a range type:</source>
          <target state="translated">В этом примере создается тип диапазона:</target>
        </trans-unit>
        <trans-unit id="29a86563a51e3572dd14a9d9255eda3ebb2201cc" translate="yes" xml:space="preserve">
          <source>This example creates an enumerated type and uses it in a table definition:</source>
          <target state="translated">В этом примере создается перечисленный тип и используется в определении таблицы:</target>
        </trans-unit>
        <trans-unit id="e15c416b1eb4a6e0ac422253fe9d7c571e4e1d98" translate="yes" xml:space="preserve">
          <source>This example creates the &lt;code&gt;us_postal_code&lt;/code&gt; data type and then uses the type in a table definition. A regular expression test is used to verify that the value looks like a valid US postal code:</source>
          <target state="translated">В этом примере создается &lt;code&gt;us_postal_code&lt;/code&gt; данных us_postal_code, а затем этот тип используется в определении таблицы. Проверка регулярного выражения используется для проверки того, что значение похоже на действительный почтовый индекс США:</target>
        </trans-unit>
        <trans-unit id="824e6c2d218cfa4fc262bbf54ecefd33c7e0d65c" translate="yes" xml:space="preserve">
          <source>This example creates the base data type &lt;code&gt;box&lt;/code&gt; and then uses the type in a table definition:</source>
          <target state="translated">В этом примере создается база данных типа &lt;code&gt;box&lt;/code&gt; , а затем использует тип в определении таблицы:</target>
        </trans-unit>
        <trans-unit id="434cf5265b6621f51d3d3b20b1a695bea28ca57d" translate="yes" xml:space="preserve">
          <source>This example for Unix systems sets the locale to Swedish (&lt;code&gt;sv&lt;/code&gt;) as spoken in Sweden (&lt;code&gt;SE&lt;/code&gt;). Other possibilities might include &lt;code&gt;en_US&lt;/code&gt; (U.S. English) and &lt;code&gt;fr_CA&lt;/code&gt; (French Canadian). If more than one character set can be used for a locale then the specifications can take the form &lt;code&gt;language_territory.codeset&lt;/code&gt;. For example, &lt;code&gt;fr_BE.UTF-8&lt;/code&gt; represents the French language (fr) as spoken in Belgium (BE), with a UTF-8 character set encoding.</source>
          <target state="translated">В этом примере для систем Unix в качестве языкового стандарта устанавливается шведский ( &lt;code&gt;sv&lt;/code&gt; ), как говорят в Швеции ( &lt;code&gt;SE&lt;/code&gt; ). Другие возможности могут включать &lt;code&gt;en_US&lt;/code&gt; (американский английский) и &lt;code&gt;fr_CA&lt;/code&gt; (французско-канадский). Если для языкового стандарта можно использовать более одного набора символов, тогда спецификации могут принимать форму &lt;code&gt;language_territory.codeset&lt;/code&gt; . Например, &lt;code&gt;fr_BE.UTF-8&lt;/code&gt; представляет французский язык (fr), на котором говорят в Бельгии (BE), с кодировкой набора символов UTF-8.</target>
        </trans-unit>
        <trans-unit id="5b2c48d8838d3c1575e17a1f1c1bf4b1c54be443" translate="yes" xml:space="preserve">
          <source>This example inserts into array columns:</source>
          <target state="translated">Этот пример вставляется в столбцы массива:</target>
        </trans-unit>
        <trans-unit id="42fa4c592cce0c22be8f54fb9056c02e69ce0496" translate="yes" xml:space="preserve">
          <source>This example inserts some rows into table &lt;code&gt;films&lt;/code&gt; from a table &lt;code&gt;tmp_films&lt;/code&gt; with the same column layout as &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">Этот пример вставляет несколько строк в таблице &lt;code&gt;films&lt;/code&gt; из таблицы &lt;code&gt;tmp_films&lt;/code&gt; с одной и тем же макетом столбца в качестве &lt;code&gt;films&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a463d9dae9db43b670ea9503d31a0e368fa4ee70" translate="yes" xml:space="preserve">
          <source>This example is equivalent to &lt;code&gt;FROM table1 AS alias_name&lt;/code&gt;. More interesting cases, which cannot be reduced to a plain join, arise when the subquery involves grouping or aggregation.</source>
          <target state="translated">Этот пример эквивалентен &lt;code&gt;FROM table1 AS alias_name&lt;/code&gt; . Более интересные случаи, которые нельзя свести к простому соединению, возникают, когда подзапрос включает группировку или агрегацию.</target>
        </trans-unit>
        <trans-unit id="be1a5f2f3b699d99e46d29b68340b721327b27dd" translate="yes" xml:space="preserve">
          <source>This example is, of course, oversimplified, but there's a lot of control possible in a transaction block through the use of savepoints. Moreover, &lt;code&gt;ROLLBACK TO&lt;/code&gt; is the only way to regain control of a transaction block that was put in aborted state by the system due to an error, short of rolling it back completely and starting again.</source>
          <target state="translated">Этот пример, конечно, слишком упрощен, но в блоке транзакции возможен большой контроль за счет использования точек сохранения. Более того, &lt;code&gt;ROLLBACK TO&lt;/code&gt; - это единственный способ восстановить контроль над блоком транзакции, который был переведен системой в состояние прерывания из-за ошибки, за исключением полного отката и повторного запуска.</target>
        </trans-unit>
        <trans-unit id="a7b74712a2cd7143b58e55978ebc0a1e029aad05" translate="yes" xml:space="preserve">
          <source>This example produces a set something like:</source>
          <target state="translated">Этот пример производит нечто вроде набора:</target>
        </trans-unit>
        <trans-unit id="bd0849ce5d2cb6e49bc1884469c044510632ded5" translate="yes" xml:space="preserve">
          <source>This example shows a session that performs verification of the 10 largest catalog indexes in the database &amp;ldquo;test&amp;rdquo;. Verification of the presence of heap tuples as index tuples is requested for the subset that are unique indexes. Since no error is raised, all indexes tested appear to be logically consistent. Naturally, this query could easily be changed to call &lt;code&gt;bt_index_check&lt;/code&gt; for every index in the database where verification is supported.</source>
          <target state="translated">В этом примере показан сеанс, в котором выполняется проверка 10 крупнейших индексов каталога в &amp;laquo;тестовой&amp;raquo; базе данных. Проверка наличия кортежей кучи как кортежей индекса требуется для подмножества, которое является уникальными индексами. Поскольку ошибки не возникают, все протестированные индексы кажутся логически согласованными. Естественно, этот запрос можно легко изменить, чтобы вызвать &lt;code&gt;bt_index_check&lt;/code&gt; для каждого индекса в базе данных, где поддерживается проверка.</target>
        </trans-unit>
        <trans-unit id="52eaa3c393eb8836501cf0b71b2390cbd556c111" translate="yes" xml:space="preserve">
          <source>This example shows how to use a function in the &lt;code&gt;FROM&lt;/code&gt; clause, both with and without a column definition list:</source>
          <target state="translated">В этом примере показано, как использовать функцию в предложении &lt;code&gt;FROM&lt;/code&gt; как со списком определения столбца, так и без него:</target>
        </trans-unit>
        <trans-unit id="faf001583d1938e7eac65338b42d5145eeba9d29" translate="yes" xml:space="preserve">
          <source>This example shows how to use a simple &lt;code&gt;WITH&lt;/code&gt; clause:</source>
          <target state="translated">В этом примере показано, как использовать простое предложение &lt;code&gt;WITH&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dd1b1ae7add544b9cdd447e36bf84ceb80a1e127" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;LATERAL&lt;/code&gt; to apply a set-returning function &lt;code&gt;get_product_names()&lt;/code&gt; for each row of the &lt;code&gt;manufacturers&lt;/code&gt; table:</source>
          <target state="translated">В этом примере &lt;code&gt;LATERAL&lt;/code&gt; используется для применения функции &lt;code&gt;get_product_names()&lt;/code&gt; возвращающей набор, для каждой строки таблицы &lt;code&gt;manufacturers&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36985cd8d425adbc4e1df7381c866befdc14c9f1" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;ROWS FROM&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eba8d9892663515b6cc219ad20715d37c9c5396" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;WITH RECURSIVE&lt;/code&gt; to find all subordinates (direct or indirect) of the employee Mary, and their level of indirectness, from a table that shows only direct subordinates:</source>
          <target state="translated">В этом примере &lt;code&gt;WITH RECURSIVE&lt;/code&gt; используется для поиска всех подчиненных (прямых или косвенных) сотрудника Мэри и их уровня косвенности из таблицы, в которой показаны только прямые подчиненные:</target>
        </trans-unit>
        <trans-unit id="625799a6daa4d3a32ad43aba61a387f19b4df04e" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;DEFAULT&lt;/code&gt; clause for the date columns rather than specifying a value:</source>
          <target state="translated">В этом примере вместо указания значения для столбцов даты используется предложение &lt;code&gt;DEFAULT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="33b1cc724cf1f567bbb040ff9e9078c758235297" translate="yes" xml:space="preserve">
          <source>This example uses the following data (also available in file &lt;code&gt;contrib/ltree/ltreetest.sql&lt;/code&gt; in the source distribution):</source>
          <target state="translated">В этом примере используются следующие данные (также доступные в файле &lt;code&gt;contrib/ltree/ltreetest.sql&lt;/code&gt; в исходном дистрибутиве):</target>
        </trans-unit>
        <trans-unit id="4a2eb1d66444608a417cb7a2c5c2fded452498b8" translate="yes" xml:space="preserve">
          <source>This example would remove all rows from tables &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. The number of affected rows reported to the client would only include rows removed from &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">В этом примере будут удалены все строки из таблиц &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; . Количество затронутых строк, сообщенное клиенту, будет включать только строки, удаленные из &lt;code&gt;bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="759fd9b05670f2874eee702f3df4de125c19d274" translate="yes" xml:space="preserve">
          <source>This example would use the standard Unicode collation in a nondeterministic way. In particular, this would allow strings in different normal forms to be compared correctly. More interesting examples make use of the ICU customization facilities explained above. For example:</source>
          <target state="translated">В этом примере стандартная уникодовая сверка будет использована недетерминированным образом.В частности,это позволило бы корректно сравнивать строки в различных нормальных формах.Более интересные примеры используют средства настройки ICU,описанные выше.Например:</target>
        </trans-unit>
        <trans-unit id="a370e5d62e07be8745753fc6bbcb3e1a1d2437da" translate="yes" xml:space="preserve">
          <source>This expanded version of the previous query shows the operator family each operator class belongs to:</source>
          <target state="translated">В данной расширенной версии предыдущего запроса отображается семейство операторов,к которому принадлежит каждый класс оператора:</target>
        </trans-unit>
        <trans-unit id="d891c30f21d694bab5f748d5f0b9dd9f8f629f4a" translate="yes" xml:space="preserve">
          <source>This expression returns the size of the track if it contains any segments with high heart rate values, or an empty sequence otherwise.</source>
          <target state="translated">Это выражение возвращает размер дорожки,если она содержит какие-либо сегменты с высокими значениями пульса,или пустую последовательность в противном случае.</target>
        </trans-unit>
        <trans-unit id="0d9bda9d80ab3b41fb483157cc1a94532dbac7fb" translate="yes" xml:space="preserve">
          <source>This expression yields true when two time periods (defined by their endpoints) overlap, false when they do not overlap. The endpoints can be specified as pairs of dates, times, or time stamps; or as a date, time, or time stamp followed by an interval. When a pair of values is provided, either the start or the end can be written first; &lt;code&gt;OVERLAPS&lt;/code&gt; automatically takes the earlier value of the pair as the start. Each time period is considered to represent the half-open interval &lt;code&gt;start&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;time&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;end&lt;/code&gt;, unless &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are equal in which case it represents that single time instant. This means for instance that two time periods with only an endpoint in common do not overlap.</source>
          <target state="translated">Это выражение возвращает истину, когда два периода времени (определяемые их конечными точками) перекрываются, и ложь, когда они не перекрываются. Конечные точки могут быть указаны как пары даты, времени или отметок времени; или как дату, время или отметку времени, за которой следует интервал. Когда предоставляется пара значений, сначала можно записать начало или конец; &lt;code&gt;OVERLAPS&lt;/code&gt; автоматически принимает более раннее значение пары как начало. Считается, что каждый период времени представляет собой полуоткрытый интервал &lt;code&gt;start&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;time&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;end&lt;/code&gt; , если только &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;end&lt;/code&gt; не равны, и в этом случае он представляет этот единственный момент времени. Это означает, например, что два периода времени только с общей конечной точкой не перекрываются.</target>
        </trans-unit>
        <trans-unit id="c11b883111f39a35c0f589a7362884a445b2f9be" translate="yes" xml:space="preserve">
          <source>This extensibility should not be confused with the extensibility of the other standard search trees in terms of the data they can handle. For example, PostgreSQL supports extensible B-trees and hash indexes. That means that you can use PostgreSQL to build a B-tree or hash over any data type you want. But B-trees only support range predicates (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;), and hash indexes only support equality queries.</source>
          <target state="translated">Эту расширяемость не следует путать с расширяемостью других стандартных деревьев поиска с точки зрения данных, которые они могут обрабатывать. Например, PostgreSQL поддерживает расширяемые B-деревья и хеш-индексы. Это означает, что вы можете использовать PostgreSQL для построения B-дерева или хеша для любого типа данных, который вам нужен. Но B-деревья поддерживают только предикаты диапазона ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; ), а хеш-индексы поддерживают только запросы равенства.</target>
        </trans-unit>
        <trans-unit id="25249be2bc655571c6b319a5e05ab9bf57e7f0ce" translate="yes" xml:space="preserve">
          <source>This extension won't build at all unless the installation was configured with &lt;code&gt;--with-openssl&lt;/code&gt;.</source>
          <target state="translated">Это расширение вообще не будет собираться, если установка не была настроена с помощью &lt;code&gt;--with-openssl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="985d874d57f888d6b7d33a42c3b39fe6c5d40324" translate="yes" xml:space="preserve">
          <source>This failure occurs because PostgreSQL treats multiple &lt;code&gt;UNION&lt;/code&gt;s as a nest of pairwise operations; that is, this input is the same as</source>
          <target state="translated">Этот сбой происходит из-за того, что PostgreSQL обрабатывает несколько &lt;code&gt;UNION&lt;/code&gt; как набор парных операций; то есть этот ввод такой же, как</target>
        </trans-unit>
        <trans-unit id="9dea5b639461b36e0d899f8204fb2b765c1a0fb6" translate="yes" xml:space="preserve">
          <source>This feature is disabled by default for manually issued &lt;code&gt;VACUUM&lt;/code&gt; commands. To enable it, set the &lt;code&gt;vacuum_cost_delay&lt;/code&gt; variable to a nonzero value.</source>
          <target state="translated">Эта функция по умолчанию отключена для команд &lt;code&gt;VACUUM&lt;/code&gt; ,вводимых вручную . Чтобы включить его, установите для переменной &lt;code&gt;vacuum_cost_delay&lt;/code&gt; ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="7554d4b1db763d2db35742e4df9b2b6a631440fa" translate="yes" xml:space="preserve">
          <source>This feature is intended as a temporary measure until a complete solution is found. At that time, this option will be removed.</source>
          <target state="translated">Эта функция предназначена в качестве временной меры до тех пор,пока не будет найдено полное решение.Тогда эта опция будет удалена.</target>
        </trans-unit>
        <trans-unit id="37d4c1ac5e0b12c58cdf26713648d8dd1dfac571" translate="yes" xml:space="preserve">
          <source>This feature was designed to allow parameters not normally known to PostgreSQL to be added by add-on modules (such as procedural languages). This allows extension modules to be configured in the standard ways.</source>
          <target state="translated">Эта функция была разработана для того,чтобы позволить добавлять параметры,которые обычно не известны PostgreSQL,с помощью дополнительных модулей (таких как процедурные языки).Это позволяет настраивать модули расширения стандартными способами.</target>
        </trans-unit>
        <trans-unit id="c6d9b959196517fcbab35a6da62247fb2b91ad04" translate="yes" xml:space="preserve">
          <source>This feature was shamelessly plagiarized from Bash.</source>
          <target state="translated">Эта функция была беззастенчиво плагиатирована от Бэша.</target>
        </trans-unit>
        <trans-unit id="9dd0c7f9cb881f24c299dc7cd6acc6e93722283f" translate="yes" xml:space="preserve">
          <source>This feature was shamelessly plagiarized from tcsh.</source>
          <target state="translated">Эта функция была беззастенчиво плагиатирована от tcsh.</target>
        </trans-unit>
        <trans-unit id="195725685743f0dba93fa9e927faaeac64a5e891" translate="yes" xml:space="preserve">
          <source>This field is not available in PostgreSQL releases prior to 8.3.</source>
          <target state="translated">Это поле недоступно в релизах PostgreSQL до 8.3.</target>
        </trans-unit>
        <trans-unit id="6136f38c2e93a8910734e7b6cf3ef3cea4cdbf88" translate="yes" xml:space="preserve">
          <source>This field only applies to &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;hostssl&lt;/code&gt;, and &lt;code&gt;hostnossl&lt;/code&gt; records.</source>
          <target state="translated">Это поле применяется только к &lt;code&gt;hostssl&lt;/code&gt; &lt;code&gt;host&lt;/code&gt; , hostssl и &lt;code&gt;hostnossl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bb02774d9e01b5ecb4a1f9ea9a8d0284469c4dd" translate="yes" xml:space="preserve">
          <source>This flag does not behave identically to the &lt;code&gt;-t&lt;/code&gt; flag of pg_dump. There is not currently any provision for wild-card matching in pg_restore, nor can you include a schema name within its &lt;code&gt;-t&lt;/code&gt;. And, while pg_dump's &lt;code&gt;-t&lt;/code&gt; flag will also dump subsidiary objects (such as indexes) of the selected table(s), pg_restore's &lt;code&gt;-t&lt;/code&gt; flag does not include such subsidiary objects.</source>
          <target state="translated">Этот флаг ведет себя не так, как флаг &lt;code&gt;-t&lt;/code&gt; в pg_dump. В настоящее время в pg_restore нет никаких условий для сопоставления подстановочных знаков, и вы не можете включить имя схемы в его &lt;code&gt;-t&lt;/code&gt; . И хотя флаг &lt;code&gt;-t&lt;/code&gt; pg_dump также будет сбрасывать вспомогательные объекты (например, индексы) выбранной таблицы (таблиц), флаг &lt;code&gt;-t&lt;/code&gt; pg_restore не включает такие вспомогательные объекты.</target>
        </trans-unit>
        <trans-unit id="238947e6bf1928a48d022f51eceab630f9f9ea68" translate="yes" xml:space="preserve">
          <source>This forces the checkpoint to be done as quickly as possible.</source>
          <target state="translated">Это заставляет сделать контрольно-пропускной пункт как можно быстрее.</target>
        </trans-unit>
        <trans-unit id="69aa54921685a649b05a319351142e3198d02907" translate="yes" xml:space="preserve">
          <source>This form adds a new &lt;code&gt;PRIMARY KEY&lt;/code&gt; or &lt;code&gt;UNIQUE&lt;/code&gt; constraint to a table based on an existing unique index. All the columns of the index will be included in the constraint.</source>
          <target state="translated">Эта форма добавляет в таблицу новое &lt;code&gt;PRIMARY KEY&lt;/code&gt; или &lt;code&gt;UNIQUE&lt;/code&gt; на основе существующего уникального индекса. Все столбцы индекса будут включены в ограничение.</target>
        </trans-unit>
        <trans-unit id="3ba31c86d5c7be29caf3e323f522bf84c40b7fcf" translate="yes" xml:space="preserve">
          <source>This form adds a new attribute to a composite type, using the same syntax as &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;.</source>
          <target state="translated">Эта форма добавляет новый атрибут к составному типу с использованием того же синтаксиса, что и &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0322ba886bea1157dcae5f05c22210a2d27f5b1" translate="yes" xml:space="preserve">
          <source>This form adds a new column to the foreign table, using the same syntax as &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. Unlike the case when adding a column to a regular table, nothing happens to the underlying storage: this action simply declares that some new column is now accessible through the foreign table.</source>
          <target state="translated">Эта форма добавляет новый столбец к сторонней таблице, используя тот же синтаксис, что и &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; . В отличие от случая добавления столбца в обычную таблицу, с базовым хранилищем ничего не происходит: это действие просто объявляет, что какой-то новый столбец теперь доступен через стороннюю таблицу.</target>
        </trans-unit>
        <trans-unit id="95c0b10fe4a25bd3c814ee981b4c421d53eaf37a" translate="yes" xml:space="preserve">
          <source>This form adds a new column to the table, using the same syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. If &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified and a column already exists with this name, no error is thrown.</source>
          <target state="translated">Эта форма добавляет в таблицу новый столбец с использованием того же синтаксиса, что и &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Если указано &lt;code&gt;IF NOT EXISTS&lt;/code&gt; и столбец с таким именем уже существует, ошибка не генерируется.</target>
        </trans-unit>
        <trans-unit id="b8ee63428230bf79c5e0942a3cc936820a6d5d6f" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a domain using the same syntax as &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. When a new constraint is added to a domain, all columns using that domain will be checked against the newly added constraint. These checks can be suppressed by adding the new constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option; the constraint can later be made valid using &lt;code&gt;ALTER DOMAIN ... VALIDATE CONSTRAINT&lt;/code&gt;. Newly inserted or updated rows are always checked against all constraints, even those marked &lt;code&gt;NOT VALID&lt;/code&gt;. &lt;code&gt;NOT VALID&lt;/code&gt; is only accepted for &lt;code&gt;CHECK&lt;/code&gt; constraints.</source>
          <target state="translated">Эта форма добавляет новое ограничение к домену с использованием того же синтаксиса, что и &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt; . Когда к домену добавляется новое ограничение, все столбцы, использующие этот домен, будут проверяться на соответствие вновь добавленному ограничению. Эти проверки можно подавить, добавив новое ограничение с помощью опции &lt;code&gt;NOT VALID&lt;/code&gt; ; ограничение можно позже сделать действительным с помощью &lt;code&gt;ALTER DOMAIN ... VALIDATE CONSTRAINT&lt;/code&gt; . Новые вставленные или обновленные строки всегда проверяются на соответствие всем ограничениям, даже если они отмечены как &lt;code&gt;NOT VALID&lt;/code&gt; . &lt;code&gt;NOT VALID&lt;/code&gt; принимается только для ограничений &lt;code&gt;CHECK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f1ef6b759daf52986e80a140fc1e8e6996a0c1e" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a foreign table, using the same syntax as &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. Currently only &lt;code&gt;CHECK&lt;/code&gt; constraints are supported.</source>
          <target state="translated">Эта форма добавляет новое ограничение к внешней таблице с использованием того же синтаксиса, что и &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; . В настоящее время поддерживаются только ограничения &lt;code&gt;CHECK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99cace79007308dc0d8e7331f85a19c72d625225" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a table using the same constraint syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, plus the option &lt;code&gt;NOT VALID&lt;/code&gt;, which is currently only allowed for foreign key and CHECK constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c743b0f8a6b250501ac85a73828ca722af7185" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a table using the same syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, plus the option &lt;code&gt;NOT VALID&lt;/code&gt;, which is currently only allowed for foreign key and CHECK constraints.</source>
          <target state="translated">Эта форма добавляет новое ограничение в таблицу с использованием того же синтаксиса, что и &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , плюс параметр &lt;code&gt;NOT VALID&lt;/code&gt; , который в настоящее время разрешен только для ограничений внешнего ключа и CHECK.</target>
        </trans-unit>
        <trans-unit id="4ce19ef3782b6ce0c5b9df7476cc0daa1dd41c54" translate="yes" xml:space="preserve">
          <source>This form adds a new value to an enum type. The new value's place in the enum's ordering can be specified as being &lt;code&gt;BEFORE&lt;/code&gt; or &lt;code&gt;AFTER&lt;/code&gt; one of the existing values. Otherwise, the new item is added at the end of the list of values.</source>
          <target state="translated">Эта форма добавляет новое значение к типу перечисления. Место нового значения в порядке перечисления может быть указано как &lt;code&gt;BEFORE&lt;/code&gt; или &lt;code&gt;AFTER&lt;/code&gt; одного из существующих значений. В противном случае новый элемент добавляется в конец списка значений.</target>
        </trans-unit>
        <trans-unit id="f6cf59f2735afa1f2d995a149ad05a9eb1b35eb7" translate="yes" xml:space="preserve">
          <source>This form adds an existing object to the extension. This is mainly useful in extension update scripts. The object will subsequently be treated as a member of the extension; notably, it can only be dropped by dropping the extension.</source>
          <target state="translated">Эта форма добавляет существующий объект в расширение.В основном это полезно в скриптах обновления расширений.Впоследствии объект будет рассматриваться как член расширения;в частности,он может быть удален только путем удаления расширения.</target>
        </trans-unit>
        <trans-unit id="595f54e5f3b774c232dc30ed51e46c90273688d9" translate="yes" xml:space="preserve">
          <source>This form adds the target foreign table as a new child of the specified parent table. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">Эта форма добавляет целевую стороннюю таблицу в качестве нового дочернего элемента указанной родительской таблицы. Смотрите аналогичную форму &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="927ec7cd6b47cc568c9f6a02695b9db39fd050a7" translate="yes" xml:space="preserve">
          <source>This form adds the target table as a new child of the specified parent table. Subsequently, queries against the parent will include records of the target table. To be added as a child, the target table must already contain all the same columns as the parent (it could have additional columns, too). The columns must have matching data types, and if they have &lt;code&gt;NOT NULL&lt;/code&gt; constraints in the parent then they must also have &lt;code&gt;NOT NULL&lt;/code&gt; constraints in the child.</source>
          <target state="translated">Эта форма добавляет целевую таблицу в качестве нового потомка указанной родительской таблицы. Впоследствии запросы к родительскому объекту будут включать записи целевой таблицы. Чтобы быть добавленной в качестве дочерней, целевая таблица должна уже содержать все те же столбцы, что и родительская (у нее также могут быть дополнительные столбцы). Столбцы должны иметь соответствующие типы данных, и если они имеют ограничения &lt;code&gt;NOT NULL&lt;/code&gt; в родительском элементе, тогда они также должны иметь ограничения &lt;code&gt;NOT NULL&lt;/code&gt; в дочернем элементе.</target>
        </trans-unit>
        <trans-unit id="d346519cab151e59ba4d85ab858ae6233fa9d98e" translate="yes" xml:space="preserve">
          <source>This form alters the attributes of a constraint that was previously created. Currently only foreign key constraints may be altered.</source>
          <target state="translated">Эта форма изменяет атрибуты ранее созданного ограничения.В настоящее время могут быть изменены только внешние ключевые ограничения.</target>
        </trans-unit>
        <trans-unit id="7c3d28a97b5f73f4ab63b75ff86f6835976075b5" translate="yes" xml:space="preserve">
          <source>This form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values using &lt;code&gt;FOR VALUES&lt;/code&gt; or as a default partition by using &lt;code&gt;DEFAULT&lt;/code&gt;. For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as if &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; had been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the target table. (See also &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.)</source>
          <target state="translated">Эта форма присоединяет существующую таблицу (которая сама может быть секционирована) как секция целевой таблицы. Таблица может быть присоединена как раздел для определенных значений с помощью &lt;code&gt;FOR VALUES&lt;/code&gt; или как раздел по умолчанию с помощью &lt;code&gt;DEFAULT&lt;/code&gt; . Для каждого индекса в целевой таблице будет создан соответствующий индекс в прикрепленной таблице; или, если эквивалентный индекс уже существует, он будет прикреплен к индексу целевой таблицы, как если бы был выполнен &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; . Обратите внимание, что если существующая таблица является сторонней таблицей, в настоящее время не разрешено присоединять таблицу в качестве раздела целевой таблицы, если в целевой таблице есть индексы &lt;code&gt;UNIQUE&lt;/code&gt; . (См. Также &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="1869ca7747dbe933e84af2c5cba71787701542d6" translate="yes" xml:space="preserve">
          <source>This form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values using &lt;code&gt;FOR VALUES&lt;/code&gt; or as a default partition by using &lt;code&gt;DEFAULT&lt;/code&gt;. For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as if &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; had been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the target table. (See also &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.) For each user-defined row-level trigger that exists in the target table, a corresponding one is created in the attached table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3fb037ad7936c80f6f29d8637098894917452d" translate="yes" xml:space="preserve">
          <source>This form can be used to create the foreign table as partition of the given parent table with specified partition bound values. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details. Note that it is currently not allowed to create the foreign table as a partition of the parent table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the parent table. (See also &lt;a href=&quot;sql-altertable&quot;&gt;&lt;code&gt;ALTER TABLE ATTACH PARTITION&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Эта форма может использоваться для создания сторонней таблицы как раздела данной родительской таблицы с указанными значениями привязки раздела. См. Аналогичную форму &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для более подробной информации. Обратите внимание, что в настоящее время нельзя создавать стороннюю таблицу в качестве раздела родительской таблицы, если в родительской таблице есть индексы &lt;code&gt;UNIQUE&lt;/code&gt; . (См. Также &lt;a href=&quot;sql-altertable&quot;&gt; &lt;code&gt;ALTER TABLE ATTACH PARTITION&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="17c7c9cbd670ca1e7d92be433f5a08452d27c094" translate="yes" xml:space="preserve">
          <source>This form changes one or more index-method-specific storage parameters for the index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details on the available parameters. Note that the index contents will not be modified immediately by this command; depending on the parameter you might need to rebuild the index with &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; to get the desired effects.</source>
          <target state="translated">Эта форма изменяет один или несколько параметров хранения, зависящих от метода индекса, для индекса. См. &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; для получения подробной информации о доступных параметрах. Обратите внимание, что содержимое индекса не будет немедленно изменено этой командой; в зависимости от параметра вам может потребоваться перестроить индекс с помощью &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX,&lt;/a&gt; чтобы получить желаемый эффект.</target>
        </trans-unit>
        <trans-unit id="85e33ac3b4ee94fcc601870b607686da66a411c8" translate="yes" xml:space="preserve">
          <source>This form changes one or more storage parameters for the table. See &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done with &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;, &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that forces a table rewrite. For planner related parameters, changes will take effect from the next time the table is locked so currently executing queries will not be affected.</source>
          <target state="translated">Эта форма изменяет один или несколько параметров хранения для таблицы. См. &amp;laquo; &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Параметры хранения&amp;raquo;&lt;/a&gt; для получения подробной информации о доступных параметрах. Обратите внимание, что содержимое таблицы не будет немедленно изменено этой командой; в зависимости от параметра вам может потребоваться переписать таблицу, чтобы получить желаемый эффект. Это можно сделать с помощью &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt; , &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; или одной из форм &lt;code&gt;ALTER TABLE&lt;/code&gt; , которая принудительно перезаписывает таблицу. Для параметров, связанных с планировщиком, изменения вступят в силу после следующей блокировки таблицы, поэтому текущие выполняемые запросы не будут затронуты.</target>
        </trans-unit>
        <trans-unit id="a90914d894dbf343cb6837e8578f6573c8aee615" translate="yes" xml:space="preserve">
          <source>This form changes one or more storage parameters for the table. See &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; in the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done with &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;, &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that forces a table rewrite. For planner related parameters, changes will take effect from the next time the table is locked so currently executing queries will not be affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83d3c0b4c77e2425087c239b0df05fcb0116826" translate="yes" xml:space="preserve">
          <source>This form changes the index's tablespace to the specified tablespace and moves the data file(s) associated with the index to the new tablespace. To change the tablespace of an index, you must own the index and have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new tablespace. All indexes in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all indexes to be moved and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move indexes owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs will not be moved by this command, use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER INDEX&lt;/code&gt; invocations instead if desired. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="translated">Эта форма изменяет табличное пространство индекса на указанное табличное пространство и перемещает файл (ы) данных, связанный с индексом, в новое табличное пространство. Чтобы изменить табличное пространство индекса, вы должны владеть индексом и иметь привилегию &lt;code&gt;CREATE&lt;/code&gt; для нового табличного пространства. Все индексы в текущей базе данных в табличном пространстве можно перемещать с помощью формы &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; , которая блокирует все перемещаемые индексы, а затем перемещает каждый из них. Эта форма также поддерживает &lt;code&gt;OWNED BY&lt;/code&gt; , которая перемещает только индексы, принадлежащие указанным ролям. Если указана опция &lt;code&gt;NOWAIT&lt;/code&gt; , команда завершится ошибкой, если она не сможет получить все требуемые блокировки немедленно. Обратите внимание, что системные каталоги не будут перемещены этой командой, используйте &lt;code&gt;ALTER DATABASE&lt;/code&gt; или вместо этого явные вызовы &lt;code&gt;ALTER INDEX&lt;/code&gt; , если это необходимо. См. Также &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c55be56dbc86b6d6779191aa5c394d5588fe660" translate="yes" xml:space="preserve">
          <source>This form changes the information which is written to the write-ahead log to identify rows which are updated or deleted. This option has no effect except when logical replication is in use. &lt;code&gt;DEFAULT&lt;/code&gt; (the default for non-system tables) records the old values of the columns of the primary key, if any. &lt;code&gt;USING INDEX&lt;/code&gt; records the old values of the columns covered by the named index, which must be unique, not partial, not deferrable, and include only columns marked &lt;code&gt;NOT NULL&lt;/code&gt;. &lt;code&gt;FULL&lt;/code&gt; records the old values of all columns in the row. &lt;code&gt;NOTHING&lt;/code&gt; records no information about the old row. (This is the default for system tables.) In all cases, no old values are logged unless at least one of the columns that would be logged differs between the old and new versions of the row.</source>
          <target state="translated">Эта форма изменяет информацию, которая записывается в журнал упреждающей записи, чтобы идентифицировать строки, которые обновляются или удаляются. Этот параметр не действует, за исключением случаев, когда используется логическая репликация. &lt;code&gt;DEFAULT&lt;/code&gt; (значение по умолчанию для несистемных таблиц) записывает старые значения столбцов первичного ключа, если таковые имеются. &lt;code&gt;USING INDEX&lt;/code&gt; записывает старые значения столбцов, охватываемых указанным индексом, которые должны быть уникальными, не частичными, не откладываемыми и включать только столбцы, отмеченные &lt;code&gt;NOT NULL&lt;/code&gt; . &lt;code&gt;FULL&lt;/code&gt; записывает старые значения всех столбцов в строке. &lt;code&gt;NOTHING&lt;/code&gt; не записывает никакой информации о старой строке. (Это значение по умолчанию для системных таблиц.) Во всех случаях старые значения не регистрируются, если хотя бы один из столбцов, которые должны быть зарегистрированы, не отличается в старой и новой версиях строки.</target>
        </trans-unit>
        <trans-unit id="d5fd7a415ae62d2432d673453426bcca0e434c22" translate="yes" xml:space="preserve">
          <source>This form changes the name of a constraint on a domain.</source>
          <target state="translated">Эта форма изменяет имя ограничения на домен.</target>
        </trans-unit>
        <trans-unit id="3a34d134067f8057fdc7eb4bd8e2afb5eac929d2" translate="yes" xml:space="preserve">
          <source>This form changes the name of the domain.</source>
          <target state="translated">Эта форма изменяет имя домена.</target>
        </trans-unit>
        <trans-unit id="bdaccc9f755620eea9c5a68106023cbc0c07f19d" translate="yes" xml:space="preserve">
          <source>This form changes the name of the type or the name of an individual attribute of a composite type.</source>
          <target state="translated">Эта форма изменяет имя типа или имя отдельного атрибута составного типа.</target>
        </trans-unit>
        <trans-unit id="8cfd4248390a30b80daebf0ff6ee06ccc365741e" translate="yes" xml:space="preserve">
          <source>This form changes the name of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33709234ccf296c21440f70a857148d5d605167b" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the domain to the specified user.</source>
          <target state="translated">Эта форма меняет владельца домена на указанного пользователя.</target>
        </trans-unit>
        <trans-unit id="33c8412b485a6292103c360edb753fe679de7f49" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the foreign table to the specified user.</source>
          <target state="translated">Эта форма меняет владельца зарубежной таблицы на указанного пользователя.</target>
        </trans-unit>
        <trans-unit id="bdda20046cb686daa61e8bfb091f3201cdd5da85" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the table, sequence, view, materialized view, or foreign table to the specified user.</source>
          <target state="translated">Эта форма изменяет владельца таблицы,последовательность,представление,материализованное представление или постороннюю таблицу для указанного пользователя.</target>
        </trans-unit>
        <trans-unit id="367a0875855c27e375e704da43453b6a64108026" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the type.</source>
          <target state="translated">Эта форма меняет владельца типа.</target>
        </trans-unit>
        <trans-unit id="6515faf0d6c7bfb31358723522828dadb55476f0" translate="yes" xml:space="preserve">
          <source>This form changes the schema of the domain. Any constraints associated with the domain are moved into the new schema as well.</source>
          <target state="translated">Эта форма изменяет схему домена.Любые ограничения,связанные с доменом,также переносятся в новую схему.</target>
        </trans-unit>
        <trans-unit id="9ceb0679036b94c23ce3c3c3726ad7d1600fd754" translate="yes" xml:space="preserve">
          <source>This form changes the table from unlogged to logged or vice-versa (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-UNLOGGED&quot;&gt;&lt;code&gt;UNLOGGED&lt;/code&gt;&lt;/a&gt;). It cannot be applied to a temporary table.</source>
          <target state="translated">Эта форма изменяет таблицу с незарегистрированной на зарегистрированную или наоборот (см. &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-UNLOGGED&quot;&gt; &lt;code&gt;UNLOGGED&lt;/code&gt; &lt;/a&gt; ). Его нельзя применить к временной таблице.</target>
        </trans-unit>
        <trans-unit id="b21eade6f7dd16e560cb3e285d036a4340eaa767" translate="yes" xml:space="preserve">
          <source>This form changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additional &lt;code&gt;SET TABLESPACE&lt;/code&gt; commands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards with &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; will use that tablespace, unless overridden by a &lt;code&gt;TABLESPACE&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413a825daa3f78a948f21b1ed732bd1afa98d9f3" translate="yes" xml:space="preserve">
          <source>This form changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additional &lt;code&gt;SET TABLESPACE&lt;/code&gt; commands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards with &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; will use that tablespace, unless the &lt;code&gt;TABLESPACE&lt;/code&gt; clause is used to override it.</source>
          <target state="translated">Эта форма изменяет табличное пространство таблицы на указанное табличное пространство и перемещает файл (ы) данных, связанный с таблицей, в новое табличное пространство. Индексы в таблице, если таковые имеются, не перемещаются; но их можно перемещать отдельно с помощью дополнительных команд &lt;code&gt;SET TABLESPACE&lt;/code&gt; . При применении к многораздельной таблице ничего не перемещается, но любые разделы, созданные впоследствии с помощью &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; , будут использовать это табличное пространство, если только предложение &lt;code&gt;TABLESPACE&lt;/code&gt; не используется для его переопределения.</target>
        </trans-unit>
        <trans-unit id="d606494af7f67be03bcb787fb49d4fbd5e3725e9" translate="yes" xml:space="preserve">
          <source>This form changes the type of a column of a foreign table. Again, this has no effect on any underlying storage: this action simply changes the type that PostgreSQL believes the column to have.</source>
          <target state="translated">Эта форма изменяет тип столбца иностранной таблицы.Опять же,это не влияет ни на какое базовое хранилище:это действие просто изменяет тип,который,по мнению PostgreSQL,имеет столбец.</target>
        </trans-unit>
        <trans-unit id="ef90ca77493d55255faa9c05a6d21e673fa262d6" translate="yes" xml:space="preserve">
          <source>This form changes the type of a column of a table. Indexes and simple table constraints involving the column will be automatically converted to use the new column type by reparsing the originally supplied expression. The optional &lt;code&gt;COLLATE&lt;/code&gt; clause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optional &lt;code&gt;USING&lt;/code&gt; clause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new. A &lt;code&gt;USING&lt;/code&gt; clause must be provided if there is no implicit or assignment cast from old to new type.</source>
          <target state="translated">Эта форма изменяет тип столбца таблицы. Индексы и простые ограничения таблицы, включающие столбец, будут автоматически преобразованы для использования нового типа столбца путем повторного анализа первоначально предоставленного выражения. Необязательное предложение &lt;code&gt;COLLATE&lt;/code&gt; определяет параметры сортировки для нового столбца; если он опущен, сортировка используется по умолчанию для нового типа столбца. Необязательное предложение &lt;code&gt;USING&lt;/code&gt; указывает, как вычислить новое значение столбца из старого; если он опущен, преобразование по умолчанию такое же, как преобразование присвоения из старого типа данных в новый. Предложение &lt;code&gt;USING&lt;/code&gt; должно быть предоставлено, если нет неявного преобразования или преобразования присваивания от старого к новому типу.</target>
        </trans-unit>
        <trans-unit id="f90f5c12001436438a106ce1bcbc9026c77d9b2f" translate="yes" xml:space="preserve">
          <source>This form changes the type of an attribute of a composite type.</source>
          <target state="translated">Эта форма изменяет тип атрибута составного типа.</target>
        </trans-unit>
        <trans-unit id="c4194cb65228a21c483f32a1d7544636b626b6d4" translate="yes" xml:space="preserve">
          <source>This form detaches specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached.</source>
          <target state="translated">Эта форма отсоединяет указанный раздел целевой таблицы.Отделенный раздел продолжает существовать как отдельная таблица,но больше не имеет никаких связей с таблицей,от которой он был отсоединен.Любые индексы,которые были прикреплены к индексам целевой таблицы,отделяются.</target>
        </trans-unit>
        <trans-unit id="e6073cfd81439f0b29a7e52096d2c9bbc8448ad6" translate="yes" xml:space="preserve">
          <source>This form detaches the specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached. Any triggers that were created as clones of those in the target table are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f649e2a380d4d6a7844e29c8bec08b60d14e121" translate="yes" xml:space="preserve">
          <source>This form dissociates a typed table from its type.</source>
          <target state="translated">Эта форма отделяет напечатанную таблицу от ее типа.</target>
        </trans-unit>
        <trans-unit id="41af815da8671345e4d0830589af85c8c9d1f4f9" translate="yes" xml:space="preserve">
          <source>This form drops a column from a foreign table. You will need to say &lt;code&gt;CASCADE&lt;/code&gt; if anything outside the table depends on the column; for example, views. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the column does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">Эта форма удаляет столбец из сторонней таблицы. Вам нужно будет сказать &lt;code&gt;CASCADE&lt;/code&gt; , если что-то за пределами таблицы зависит от столбца; например, просмотры. Если указано &lt;code&gt;IF EXISTS&lt;/code&gt; и столбец не существует, ошибка не генерируется. В этом случае вместо этого выдается уведомление.</target>
        </trans-unit>
        <trans-unit id="132c35990a8f9ff6a2087c8c4db6bfe5bc0d3b7f" translate="yes" xml:space="preserve">
          <source>This form drops a column from a table. Indexes and table constraints involving the column will be automatically dropped as well. Multivariate statistics referencing the dropped column will also be removed if the removal of the column would cause the statistics to contain data for only a single column. You will need to say &lt;code&gt;CASCADE&lt;/code&gt; if anything outside the table depends on the column, for example, foreign key references or views. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the column does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">Эта форма удаляет столбец из таблицы. Индексы и ограничения таблицы, касающиеся столбца, также будут автоматически удалены. Многовариантная статистика, относящаяся к отброшенному столбцу, также будет удалена, если удаление столбца приведет к тому, что статистика будет содержать данные только для одного столбца. Вам нужно будет сказать &lt;code&gt;CASCADE&lt;/code&gt; , если что-то вне таблицы зависит от столбца, например, ссылки на внешние ключи или представления. Если указано &lt;code&gt;IF EXISTS&lt;/code&gt; и столбец не существует, ошибка не генерируется. В этом случае вместо этого выдается уведомление.</target>
        </trans-unit>
        <trans-unit id="630cbfc87f5704d127bcc228848ac6a6604a8fb0" translate="yes" xml:space="preserve">
          <source>This form drops an attribute from a composite type. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the attribute does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">Эта форма удаляет атрибут из составного типа. Если указано &lt;code&gt;IF EXISTS&lt;/code&gt; и атрибут не существует, ошибка не генерируется. В этом случае вместо этого выдается уведомление.</target>
        </trans-unit>
        <trans-unit id="abbb33e28408b10284213af5010b6f9ed9616abd" translate="yes" xml:space="preserve">
          <source>This form drops constraints on a domain. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">Эта форма снимает ограничения для домена. Если указано &lt;code&gt;IF EXISTS&lt;/code&gt; и ограничение не существует, ошибка не генерируется. В этом случае вместо этого выдается уведомление.</target>
        </trans-unit>
        <trans-unit id="0562817256cba47f3678521e40341b9bb63428df" translate="yes" xml:space="preserve">
          <source>This form drops the specified constraint on a foreign table. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">Эта форма удаляет указанное ограничение на стороннюю таблицу. Если указано &lt;code&gt;IF EXISTS&lt;/code&gt; и ограничение не существует, ошибка не генерируется. В этом случае вместо этого выдается уведомление.</target>
        </trans-unit>
        <trans-unit id="ef5c32eb106661dab4fdce48beeb3716d53be331" translate="yes" xml:space="preserve">
          <source>This form drops the specified constraint on a table, along with any index underlying the constraint. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">Эта форма удаляет указанное ограничение в таблице вместе с любым индексом, лежащим в основе ограничения. Если указано &lt;code&gt;IF EXISTS&lt;/code&gt; и ограничение не существует, ошибка не генерируется. В этом случае вместо этого выдается уведомление.</target>
        </trans-unit>
        <trans-unit id="d6075d1245dd08cd17ae12d300569e914c015d02" translate="yes" xml:space="preserve">
          <source>This form is not currently supported on partitioned tables.</source>
          <target state="translated">В настоящее время эта форма не поддерживается на таблицах разделов.</target>
        </trans-unit>
        <trans-unit id="d8b11f2ae6d44cb1444622b88c46b7122c4666b1" translate="yes" xml:space="preserve">
          <source>This form is only applicable to base types. It allows adjustment of a subset of the base-type properties that can be set in &lt;code&gt;CREATE TYPE&lt;/code&gt;. Specifically, these properties can be changed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77a1a6b3b2aecc7300bf71dbd0467e9777098c6" translate="yes" xml:space="preserve">
          <source>This form is only usable with composite types. It changes the name of an individual attribute of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fef7209d0ef0917314ea35bb80cd3a32ecadf7" translate="yes" xml:space="preserve">
          <source>This form links the table to a composite type as though &lt;code&gt;CREATE TABLE OF&lt;/code&gt; had formed it. The table's list of column names and types must precisely match that of the composite type. The table must not inherit from any other table. These restrictions ensure that &lt;code&gt;CREATE TABLE OF&lt;/code&gt; would permit an equivalent table definition.</source>
          <target state="translated">Эта форма связывает таблицу с составным типом, как если бы она была создана командой &lt;code&gt;CREATE TABLE OF&lt;/code&gt; . Список имен столбцов и типов в таблице должен точно совпадать со списком составного типа. Таблица не должна наследовать ни от какой другой таблицы. Эти ограничения гарантируют, что &lt;code&gt;CREATE TABLE OF&lt;/code&gt; разрешит эквивалентное определение таблицы.</target>
        </trans-unit>
        <trans-unit id="80c03819073116dcc932622328193f2e17ef52d2" translate="yes" xml:space="preserve">
          <source>This form marks as valid a constraint that was previously marked as &lt;code&gt;NOT VALID&lt;/code&gt;. No action is taken to verify the constraint, but future queries will assume that it holds.</source>
          <target state="translated">Эта форма помечает как действительное ограничение, которое ранее было помечено как &lt;code&gt;NOT VALID&lt;/code&gt; . Никаких действий для проверки ограничения не предпринимается, но в будущих запросах предполагается, что оно выполняется.</target>
        </trans-unit>
        <trans-unit id="b14af7517538e421b68a1939c47cac2afc8ff879" translate="yes" xml:space="preserve">
          <source>This form marks the function as dependent on the extension, or no longer dependent on that extension if &lt;code&gt;NO&lt;/code&gt; is specified. A function that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058bcd5831cd602d111c74db2f7028e5e56ec71d" translate="yes" xml:space="preserve">
          <source>This form marks the index as dependent on the extension, or no longer dependent on that extension if &lt;code&gt;NO&lt;/code&gt; is specified. An index that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cec438622a098483a45173b222a4d5cd019672" translate="yes" xml:space="preserve">
          <source>This form marks the index as dependent on the extension, such that if the extension is dropped, the index will automatically be dropped as well.</source>
          <target state="translated">Эта форма помечает индекс как зависимый от расширения,так что если расширение будет опущено,то индекс также будет автоматически опущен.</target>
        </trans-unit>
        <trans-unit id="4faed3e54b7a44c7e7e8c551a8c0326f16df1512" translate="yes" xml:space="preserve">
          <source>This form moves the extension's objects into another schema. The extension has to be &lt;em&gt;relocatable&lt;/em&gt; for this command to succeed.</source>
          <target state="translated">Эта форма перемещает объекты расширения в другую схему. Для успешного выполнения этой команды расширение должно быть &lt;em&gt;перемещаемым&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d44749fe236086787bbeb370c7b120c56a308916" translate="yes" xml:space="preserve">
          <source>This form moves the foreign table into another schema.</source>
          <target state="translated">Эта форма переносит инородный стол в другую схему.</target>
        </trans-unit>
        <trans-unit id="343fe32ad6664d950886e22df1f9e56f6f16399d" translate="yes" xml:space="preserve">
          <source>This form moves the table into another schema. Associated indexes, constraints, and sequences owned by table columns are moved as well.</source>
          <target state="translated">Эта форма переносит таблицу в другую схему.Соответствующие индексы,ограничения и последовательности,принадлежащие столбцам таблицы,также перемещаются.</target>
        </trans-unit>
        <trans-unit id="4a25f7c9422516454200b0986e93d0f9a7b1cd24" translate="yes" xml:space="preserve">
          <source>This form moves the type into another schema.</source>
          <target state="translated">Эта форма переносит тип в другую схему.</target>
        </trans-unit>
        <trans-unit id="af28f23e1758f00a66bd13166257650c2c6c6e02" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; is a PostgreSQL extension. There is a &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; command in the SQL standard, but it is for adapting data types to client languages. That usage is not supported by PostgreSQL.</source>
          <target state="translated">Эта форма &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; является расширением PostgreSQL. В стандарте SQL есть команда &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; , но она предназначена для адаптации типов данных к клиентским языкам. Такое использование не поддерживается PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="6ab065126927246d3956d5f89c1fdf1ac5a9c01c" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;DROP TRANSFORM&lt;/code&gt; is a PostgreSQL extension. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for details.</source>
          <target state="translated">Эта форма &lt;code&gt;DROP TRANSFORM&lt;/code&gt; является расширением PostgreSQL. Подробнее см. &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09d38af3e512e1a4bd2fd33c7735f8320af47f2b" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;json_object&lt;/code&gt; takes keys and values pairwise from separate text arrays. Otherwise it is identical to the one-argument form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff5cb48fe56e9b363be562d91784fed1316defb" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;json_object&lt;/code&gt; takes keys and values pairwise from two separate arrays. In all other respects it is identical to the one-argument form.</source>
          <target state="translated">Эта форма &lt;code&gt;json_object&lt;/code&gt; попарно принимает ключи и значения из двух отдельных массивов. Во всем остальном она идентична форме с одним аргументом.</target>
        </trans-unit>
        <trans-unit id="e130ed2324ecc47cb96bb25ee04c4b0d13167363" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;ts_rewrite&lt;/code&gt; accepts a starting &lt;code&gt;query&lt;/code&gt; and a SQL &lt;code&gt;select&lt;/code&gt; command, which is given as a text string. The &lt;code&gt;select&lt;/code&gt; must yield two columns of &lt;code&gt;tsquery&lt;/code&gt; type. For each row of the &lt;code&gt;select&lt;/code&gt; result, occurrences of the first column value (the target) are replaced by the second column value (the substitute) within the current &lt;code&gt;query&lt;/code&gt; value. For example:</source>
          <target state="translated">Эта форма &lt;code&gt;ts_rewrite&lt;/code&gt; принимает начальный &lt;code&gt;query&lt;/code&gt; и команду &lt;code&gt;select&lt;/code&gt; SQL , которая дается в виде текстовой строки. &lt;code&gt;select&lt;/code&gt; должны дать две колонки &lt;code&gt;tsquery&lt;/code&gt; типа. Для каждой строки результата &lt;code&gt;select&lt;/code&gt; вхождения значения первого столбца (целевого) заменяются значением второго столбца (подстановкой) в текущем значении &lt;code&gt;query&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="d013efd17243813d551b63d4312494e00c1c1a6c" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;ts_rewrite&lt;/code&gt; simply applies a single rewrite rule: &lt;code&gt;target&lt;/code&gt; is replaced by &lt;code&gt;substitute&lt;/code&gt; wherever it appears in &lt;code&gt;query&lt;/code&gt;. For example:</source>
          <target state="translated">Эта форма &lt;code&gt;ts_rewrite&lt;/code&gt; просто применяет одно правило перезаписи: &lt;code&gt;target&lt;/code&gt; заменяется &lt;code&gt;substitute&lt;/code&gt; везде, где она появляется в &lt;code&gt;query&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="eb31fbf716a310edf9d2b4049a82ade012c42087" translate="yes" xml:space="preserve">
          <source>This form of the &lt;code&gt;AS&lt;/code&gt; clause is used for dynamically loadable C language functions when the function name in the C language source code is not the same as the name of the SQL function. The string &lt;code&gt;obj_file&lt;/code&gt; is the name of the shared library file containing the compiled C function, and is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. The string &lt;code&gt;link_symbol&lt;/code&gt; is the function's link symbol, that is, the name of the function in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL function being defined. The C names of all functions must be different, so you must give overloaded C functions different C names (for example, use the argument types as part of the C names).</source>
          <target state="translated">Эта форма предложения &lt;code&gt;AS&lt;/code&gt; используется для динамически загружаемых функций языка C, когда имя функции в исходном коде языка C не совпадает с именем функции SQL. Строка &lt;code&gt;obj_file&lt;/code&gt; - это имя файла общей библиотеки, содержащего скомпилированную функцию C, и интерпретируется как команда &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; . Строка &lt;code&gt;link_symbol&lt;/code&gt; - это символ ссылки функции, то есть имя функции в исходном коде языка C. Если символ ссылки опущен, предполагается, что он совпадает с именем определяемой функции SQL. Имена C всех функций должны быть разными, поэтому вы должны давать перегруженным функциям C разные имена C (например, использовать типы аргументов как часть имен C).</target>
        </trans-unit>
        <trans-unit id="2a04c3c78f722989a90da205ce8987d3f751510b" translate="yes" xml:space="preserve">
          <source>This form of the &lt;code&gt;AS&lt;/code&gt; clause is used for dynamically loadable C language procedures when the procedure name in the C language source code is not the same as the name of the SQL procedure. The string &lt;code&gt;obj_file&lt;/code&gt; is the name of the shared library file containing the compiled C procedure, and is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. The string &lt;code&gt;link_symbol&lt;/code&gt; is the procedure's link symbol, that is, the name of the procedure in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL procedure being defined.</source>
          <target state="translated">Эта форма предложения &lt;code&gt;AS&lt;/code&gt; используется для динамически загружаемых процедур языка C, когда имя процедуры в исходном коде языка C не совпадает с именем процедуры SQL. Строка &lt;code&gt;obj_file&lt;/code&gt; - это имя файла общей библиотеки, содержащего скомпилированную процедуру C, и интерпретируется как команда &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; . Строка &lt;code&gt;link_symbol&lt;/code&gt; - это символ ссылки процедуры, то есть имя процедуры в исходном коде языка C. Если символ ссылки опущен, предполагается, что он совпадает с именем определяемой процедуры SQL.</target>
        </trans-unit>
        <trans-unit id="9d61def8f9ec3856b91d045805fea7f90a02d4de" translate="yes" xml:space="preserve">
          <source>This form of the command cannot be executed inside a transaction block.</source>
          <target state="translated">Такая форма команды не может быть выполнена внутри блока транзакций.</target>
        </trans-unit>
        <trans-unit id="99f50353be2bb5b567c08b62d433e3835ac63124" translate="yes" xml:space="preserve">
          <source>This form only executes the function if column &lt;code&gt;balance&lt;/code&gt; has in fact changed value:</source>
          <target state="translated">Эта форма выполняет функцию, только если &lt;code&gt;balance&lt;/code&gt; столбца действительно изменил значение:</target>
        </trans-unit>
        <trans-unit id="f4473c42ad05dfd82fc106e9f90398e30bc2ce6b" translate="yes" xml:space="preserve">
          <source>This form removes a member object from the extension. This is mainly useful in extension update scripts. The object is not dropped, only disassociated from the extension.</source>
          <target state="translated">Эта форма удаляет объект участника из расширения.В основном это полезно в скриптах обновления расширений.Объект не удаляется,а только отделяется от расширения.</target>
        </trans-unit>
        <trans-unit id="eac856d748a6f647a905af09f04314ea23cd83c3" translate="yes" xml:space="preserve">
          <source>This form removes the most recently used &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; index specification from the table. This affects future cluster operations that don't specify an index.</source>
          <target state="translated">Эта форма удаляет из таблицы &lt;a href=&quot;sql-cluster&quot;&gt;последнюю&lt;/a&gt; использованную спецификацию индекса CLUSTER . Это повлияет на будущие операции кластера, в которых не указан индекс.</target>
        </trans-unit>
        <trans-unit id="b9adc8eb95719164761b79a5084426c7addf0749" translate="yes" xml:space="preserve">
          <source>This form removes the target foreign table from the list of children of the specified parent table.</source>
          <target state="translated">Эта форма удаляет целевую зарубежную таблицу из списка дочерних детей указанной родительской таблицы.</target>
        </trans-unit>
        <trans-unit id="9c78c98e24aa433ee20cbdef33df9ef970bae2bf" translate="yes" xml:space="preserve">
          <source>This form removes the target table from the list of children of the specified parent table. Queries against the parent table will no longer include records drawn from the target table.</source>
          <target state="translated">Эта форма удаляет целевую таблицу из списка дочерних элементов указанной родительской таблицы.Запросы к родительской таблице больше не будут включать записи,полученные из целевой таблицы.</target>
        </trans-unit>
        <trans-unit id="3c86659bd33298dbeea55e29cf320d1c3d50f459" translate="yes" xml:space="preserve">
          <source>This form renames a value of an enum type. The value's place in the enum's ordering is not affected. An error will occur if the specified value is not present or the new name is already present.</source>
          <target state="translated">Эта форма переименовывает значение типа перечисления.Место значения в заказе перечисления не меняется.Ошибка произойдет,если указанное значение отсутствует или новое имя уже присутствует.</target>
        </trans-unit>
        <trans-unit id="d4bbf5050bebdaa653a528317e3e5511397a3bd9" translate="yes" xml:space="preserve">
          <source>This form resets one or more index-method-specific storage parameters to their defaults. As with &lt;code&gt;SET&lt;/code&gt;, a &lt;code&gt;REINDEX&lt;/code&gt; might be needed to update the index entirely.</source>
          <target state="translated">Эта форма сбрасывает один или несколько параметров хранилища, зависящих от метода индекса, до значений по умолчанию. Как и в случае с &lt;code&gt;SET&lt;/code&gt; , для &lt;code&gt;REINDEX&lt;/code&gt; обновления индекса может потребоваться REINDEX .</target>
        </trans-unit>
        <trans-unit id="5e49ca11d0f33e0a64657337a16309c7010218e7" translate="yes" xml:space="preserve">
          <source>This form resets one or more storage parameters to their defaults. As with &lt;code&gt;SET&lt;/code&gt;, a table rewrite might be needed to update the table entirely.</source>
          <target state="translated">Эта форма сбрасывает один или несколько параметров хранения до значений по умолчанию. Как и в случае с &lt;code&gt;SET&lt;/code&gt; , для полного обновления таблицы может потребоваться перезапись таблицы.</target>
        </trans-unit>
        <trans-unit id="1d66d6fd49dacdab7eaf9fc3512115d0797c065d" translate="yes" xml:space="preserve">
          <source>This form selects the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations. It does not actually re-cluster the table.</source>
          <target state="translated">Эта форма выбирает индекс по умолчанию для будущих операций &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; . Фактически он не выполняет повторную кластеризацию таблицы.</target>
        </trans-unit>
        <trans-unit id="518ddc9b662de15607142c00b06214f51c6fca69" translate="yes" xml:space="preserve">
          <source>This form sets or resets per-attribute options. Currently, the only defined per-attribute options are &lt;code&gt;n_distinct&lt;/code&gt; and &lt;code&gt;n_distinct_inherited&lt;/code&gt;, which override the number-of-distinct-values estimates made by subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. &lt;code&gt;n_distinct&lt;/code&gt; affects the statistics for the table itself, while &lt;code&gt;n_distinct_inherited&lt;/code&gt; affects the statistics gathered for the table plus its inheritance children. When set to a positive value, &lt;code&gt;ANALYZE&lt;/code&gt; will assume that the column contains exactly the specified number of distinct nonnull values. When set to a negative value, which must be greater than or equal to -1, &lt;code&gt;ANALYZE&lt;/code&gt; will assume that the number of distinct nonnull values in the column is linear in the size of the table; the exact count is to be computed by multiplying the estimated table size by the absolute value of the given number. For example, a value of -1 implies that all values in the column are distinct, while a value of -0.5 implies that each value appears twice on the average. This can be useful when the size of the table changes over time, since the multiplication by the number of rows in the table is not performed until query planning time. Specify a value of 0 to revert to estimating the number of distinct values normally. For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">Эта форма устанавливает или сбрасывает параметры для каждого атрибута. В настоящее время единственными определенными параметрами для каждого атрибута являются &lt;code&gt;n_distinct&lt;/code&gt; и &lt;code&gt;n_distinct_inherited&lt;/code&gt; , которые переопределяют оценки количества различных значений, сделанные последующими операциями &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; . &lt;code&gt;n_distinct&lt;/code&gt; влияет на статистику для самой таблицы, в то время как &lt;code&gt;n_distinct_inherited&lt;/code&gt; влияет на статистику, собранную для таблицы и ее дочерних элементов наследования. Если установлено положительное значение, &lt;code&gt;ANALYZE&lt;/code&gt; предполагает, что столбец содержит точно указанное количество различных ненулевых значений. Если установлено отрицательное значение, которое должно быть больше или равно -1, &lt;code&gt;ANALYZE&lt;/code&gt; будет считать, что количество различных ненулевых значений в столбце линейно зависит от размера таблицы; точное количество должно быть вычислено путем умножения предполагаемого размера таблицы на абсолютное значение данного числа. Например, значение -1 означает, что все значения в столбце различны, а значение -0,5 означает, что каждое значение появляется в среднем дважды. Это может быть полезно, когда размер таблицы изменяется со временем, поскольку умножение на количество строк в таблице не выполняется до времени планирования запроса. Задайте значение 0, чтобы вернуться к оценке количества различных значений в обычном режиме. Дополнительную информацию об использовании статистики планировщиком запросов PostgreSQL см. В &lt;a href=&quot;planner-stats&quot;&gt;Разделе 14.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="895b894f198c38b8b568f74baad8144867fc06d4" translate="yes" xml:space="preserve">
          <source>This form sets or resets per-attribute options. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">Эта форма устанавливает или сбрасывает параметры для каждого атрибута. Смотрите аналогичную форму &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="740f7c9cb8ed05218d4d039f1aa9f624d452a1af" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations, though can be used only on index columns that are defined as an expression. Since expressions lack a unique name, we refer to them using the ordinal number of the index column. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">Эта форма устанавливает цель сбора статистики для каждого столбца для последующих операций &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; , хотя может использоваться только для столбцов индекса, которые определены как выражение. Поскольку у выражений нет уникального имени, мы обращаемся к ним, используя порядковый номер столбца индекса. Цель может быть установлена ​​в диапазоне от 0 до 10000; в качестве альтернативы установите его в -1, чтобы вернуться к использованию целевой статистики системы по умолчанию ( &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; ). Дополнительные сведения об использовании статистики планировщиком запросов PostgreSQL см. В &lt;a href=&quot;planner-stats&quot;&gt;Разделе 14.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25d5f18188deb36d3de2faca967992d3efc2b40a" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">Эта форма устанавливает цель сбора статистики по столбцам для последующих операций &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; . Смотрите аналогичную форму &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="6332f7067a3fb1b7b86c9dc56f927e587c384e78" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">Эта форма устанавливает цель сбора статистики по столбцам для последующих операций &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; . Цель может быть установлена ​​в диапазоне от 0 до 10000; в качестве альтернативы установите его в -1, чтобы вернуться к использованию целевой статистики системы по умолчанию ( &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; ). Дополнительную информацию об использовании статистики планировщиком запросов PostgreSQL см. В &lt;a href=&quot;planner-stats&quot;&gt;Разделе 14.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4211581d9cac601dcf30af9c236c2e568347e8dc" translate="yes" xml:space="preserve">
          <source>This form sets the storage mode for a column. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details. Note that the storage mode has no effect unless the table's foreign-data wrapper chooses to pay attention to it.</source>
          <target state="translated">Эта форма устанавливает режим хранения для столбца. Смотрите аналогичную форму &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; для более подробной информации. Обратите внимание, что режим хранения не действует, если оболочка сторонних данных таблицы не решит обратить на это внимание.</target>
        </trans-unit>
        <trans-unit id="647ec6a7abe325c2f43beddebcddae6af6d3e9e1" translate="yes" xml:space="preserve">
          <source>This form sets the storage mode for a column. This controls whether this column is held inline or in a secondary TOAST table, and whether the data should be compressed or not. &lt;code&gt;PLAIN&lt;/code&gt; must be used for fixed-length values such as &lt;code&gt;integer&lt;/code&gt; and is inline, uncompressed. &lt;code&gt;MAIN&lt;/code&gt; is for inline, compressible data. &lt;code&gt;EXTERNAL&lt;/code&gt; is for external, uncompressed data, and &lt;code&gt;EXTENDED&lt;/code&gt; is for external, compressed data. &lt;code&gt;EXTENDED&lt;/code&gt; is the default for most data types that support non-&lt;code&gt;PLAIN&lt;/code&gt; storage. Use of &lt;code&gt;EXTERNAL&lt;/code&gt; will make substring operations on very large &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;bytea&lt;/code&gt; values run faster, at the penalty of increased storage space. Note that &lt;code&gt;SET STORAGE&lt;/code&gt; doesn't itself change anything in the table, it just sets the strategy to be pursued during future table updates. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="translated">Эта форма устанавливает режим хранения для столбца. Это определяет, будет ли этот столбец оставаться встроенным или во вторичной таблице TOAST, и должны ли данные быть сжатыми или нет. &lt;code&gt;PLAIN&lt;/code&gt; должен использоваться для значений фиксированной длины, таких как &lt;code&gt;integer&lt;/code&gt; и является встроенным, без сжатия. &lt;code&gt;MAIN&lt;/code&gt; предназначен для встроенных сжимаемых данных. &lt;code&gt;EXTERNAL&lt;/code&gt; предназначен для внешних несжатых данных, а &lt;code&gt;EXTENDED&lt;/code&gt; - для внешних сжатых данных. &lt;code&gt;EXTENDED&lt;/code&gt; - это значение по умолчанию для большинства типов данных, которые не поддерживают &lt;code&gt;PLAIN&lt;/code&gt; хранилище. Использование &lt;code&gt;EXTERNAL&lt;/code&gt; будет выполнять операции с подстрокой для очень большого &lt;code&gt;text&lt;/code&gt; и &lt;code&gt;bytea&lt;/code&gt; значения работают быстрее, за счет увеличения объема памяти. Обратите внимание, что &lt;code&gt;SET STORAGE&lt;/code&gt; сам по себе ничего не меняет в таблице, он просто устанавливает стратегию, которой следует придерживаться во время будущих обновлений таблицы. См &lt;a href=&quot;storage-toast&quot;&gt;раздел 68.2&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ec13ec4434f4e2b65ae05d1be4e2e6176c623511" translate="yes" xml:space="preserve">
          <source>This form specifies a transition that always happens during the same month and on the same day of the week. &lt;code&gt;m&lt;/code&gt; identifies the month, from 1 to 12. &lt;code&gt;n&lt;/code&gt; specifies the &lt;code&gt;n&lt;/code&gt;'th occurrence of the weekday identified by &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; is a number between 1 and 4, or 5 meaning the last occurrence of that weekday in the month (which could be the fourth or the fifth). &lt;code&gt;d&lt;/code&gt; is a number between 0 and 6, with 0 indicating Sunday. For example, &lt;code&gt;M3.2.0&lt;/code&gt; means &amp;ldquo;the second Sunday in March&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909f4c3b4cbf68b6bdfe371c2a727fe6e1f1cf31" translate="yes" xml:space="preserve">
          <source>This form turns a stored generated column into a normal base column. Existing data in the columns is retained, but future changes will no longer apply the generation expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e59ee7d655fea5f293a39645cf958df6f59eaa" translate="yes" xml:space="preserve">
          <source>This form updates the extension to a newer version. The extension must supply a suitable update script (or series of scripts) that can modify the currently-installed version into the requested version.</source>
          <target state="translated">Эта форма обновляет расширение до более новой версии.Расширение должно поставлять подходящий сценарий обновления (или серию сценариев),который может модифицировать установленную в данный момент версию в запрошенную.</target>
        </trans-unit>
        <trans-unit id="54be61b37045a65ad5af5b24265bf2d2fe56613b" translate="yes" xml:space="preserve">
          <source>This form validates a constraint previously added as &lt;code&gt;NOT VALID&lt;/code&gt;, that is, it verifies that all values in table columns of the domain type satisfy the specified constraint.</source>
          <target state="translated">Эта форма проверяет ранее добавленное ограничение как &lt;code&gt;NOT VALID&lt;/code&gt; , то есть проверяет, что все значения в столбцах таблицы типа домена удовлетворяют указанному ограничению.</target>
        </trans-unit>
        <trans-unit id="7fae39d4d329b60aa027a709db925fb7a0b45aad" translate="yes" xml:space="preserve">
          <source>This form validates a foreign key or check constraint that was previously created as &lt;code&gt;NOT VALID&lt;/code&gt;, by scanning the table to ensure there are no rows for which the constraint is not satisfied. Nothing happens if the constraint is already marked valid. (See &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Notes&lt;/a&gt; below for an explanation of the usefulness of this command.)</source>
          <target state="translated">Эта форма проверяет внешний ключ или ограничение проверки, которое ранее было создано как &lt;code&gt;NOT VALID&lt;/code&gt; , путем сканирования таблицы, чтобы убедиться, что нет строк, для которых ограничение не выполняется. Ничего не происходит, если ограничение уже отмечено как действительное. (См. &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Примечания&lt;/a&gt; ниже для объяснения полезности этой команды.)</target>
        </trans-unit>
        <trans-unit id="6d527b3923e336e8d7e873c75f29f0a2a678c450" translate="yes" xml:space="preserve">
          <source>This format option is used for importing and exporting the Comma Separated Value (&lt;code&gt;CSV&lt;/code&gt;) file format used by many other programs, such as spreadsheets. Instead of the escaping rules used by PostgreSQL's standard text format, it produces and recognizes the common CSV escaping mechanism.</source>
          <target state="translated">Этот параметр формата используется для импорта и экспорта формата файла &lt;code&gt;CSV&lt;/code&gt; разделенных запятыми ( CSV ), используемого многими другими программами, такими как электронные таблицы. Вместо правил экранирования, используемых в стандартном текстовом формате PostgreSQL, он создает и распознает общий механизм экранирования CSV.</target>
        </trans-unit>
        <trans-unit id="792a63854d692e136337a8efffc52744faba871f" translate="yes" xml:space="preserve">
          <source>This function accepts, but does not require, the VARIADIC keyword. It tolerates both integer and numeric arguments:</source>
          <target state="translated">Эта функция принимает,но не требует ключевое слово VARIADIC.Она допускает использование как целочисленных,так и числовых аргументов:</target>
        </trans-unit>
        <trans-unit id="384addc1a1dba581b09ffbc6f99227a9381c9da3" translate="yes" xml:space="preserve">
          <source>This function applies the XSL stylesheet to the document and returns the transformed result. The &lt;code&gt;paramlist&lt;/code&gt; is a list of parameter assignments to be used in the transformation, specified in the form &lt;code&gt;a=1,b=2&lt;/code&gt;. Note that the parameter parsing is very simple-minded: parameter values cannot contain commas!</source>
          <target state="translated">Эта функция применяет таблицу стилей XSL к документу и возвращает преобразованный результат. &lt;code&gt;paramlist&lt;/code&gt; представляет собой список параметров заданий , которые будут использоваться в преобразовании, указано в виде &lt;code&gt;a=1,b=2&lt;/code&gt; . Обратите внимание, что синтаксический анализ параметров очень прост: значения параметров не могут содержать запятые!</target>
        </trans-unit>
        <trans-unit id="0ee207b4a33861c6094ba8a46213a951afdbd72c" translate="yes" xml:space="preserve">
          <source>This function calculates the Levenshtein distance between two strings:</source>
          <target state="translated">Эта функция вычисляет расстояние Левенштейна между двумя строками:</target>
        </trans-unit>
        <trans-unit id="c2569b9ec2f2f240b538364988cd2b660c7bc809" translate="yes" xml:space="preserve">
          <source>This function calculates the metaphone code of an input string:</source>
          <target state="translated">Эта функция вычисляет код метафона входной строки:</target>
        </trans-unit>
        <trans-unit id="b833dadc47320ce5093b7875a4e223019bb7f287" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;cover density&lt;/em&gt; ranking for the given document vector and query, as described in Clarke, Cormack, and Tudhope's &quot;Relevance Ranking for One to Three Term Queries&quot; in the journal &quot;Information Processing and Management&quot;, 1999. Cover density is similar to &lt;code&gt;ts_rank&lt;/code&gt; ranking except that the proximity of matching lexemes to each other is taken into consideration.</source>
          <target state="translated">Эта функция вычисляет рейтинг &lt;em&gt;плотности покрытия&lt;/em&gt; для заданного вектора документа и запроса, как описано в статье Кларка, Кормака и Тудхоупа &quot;Рейтинг релевантности для одно-трех срочных запросов&quot; в журнале &quot;Обработка и управление информацией&quot;, 1999. Плотность покрытия аналогична до &lt;code&gt;ts_rank&lt;/code&gt; , за исключением того, что учитывается близость совпадающих лексем друг к другу.</target>
        </trans-unit>
        <trans-unit id="83d7f3c8b4315f521db79931ac5b0419f7f02e44" translate="yes" xml:space="preserve">
          <source>This function generates a version 1 UUID but uses a random multicast MAC address instead of the real MAC address of the computer.</source>
          <target state="translated">Эта функция генерирует UUID версии 1,но использует случайный многоадресный MAC-адрес вместо реального MAC-адреса компьютера.</target>
        </trans-unit>
        <trans-unit id="0d47dfa9e9b8d5b7fbb04b1e480b39cea1dce637" translate="yes" xml:space="preserve">
          <source>This function generates a version 1 UUID. This involves the MAC address of the computer and a time stamp. Note that UUIDs of this kind reveal the identity of the computer that created the identifier and the time at which it did so, which might make it unsuitable for certain security-sensitive applications.</source>
          <target state="translated">Эта функция генерирует UUID версии 1.Она включает в себя MAC-адрес компьютера и метку времени.Обратите внимание,что UUID такого типа раскрывает идентичность компьютера,создавшего идентификатор,и время,в течение которого он это сделал,что может сделать его непригодным для определенных приложений,чувствительных к безопасности.</target>
        </trans-unit>
        <trans-unit id="0487e417e0c4d9dd43a18530572f4217e42f12de" translate="yes" xml:space="preserve">
          <source>This function generates a version 3 UUID in the given namespace using the specified input name. The namespace should be one of the special constants produced by the &lt;code&gt;uuid_ns_*()&lt;/code&gt; functions shown in &lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;Table F.33&lt;/a&gt;. (It could be any UUID in theory.) The name is an identifier in the selected namespace.</source>
          <target state="translated">Эта функция генерирует UUID версии 3 в заданном пространстве имен, используя указанное имя входа. Пространство имен должно быть одной из специальных констант, созданных &lt;code&gt;uuid_ns_*()&lt;/code&gt; показанными в &lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;Таблице F.33&lt;/a&gt; . (Теоретически это может быть любой UUID.) Имя - это идентификатор в выбранном пространстве имен.</target>
        </trans-unit>
        <trans-unit id="815458cef4730e8a9276e3ff8e0d57eb7d786adf" translate="yes" xml:space="preserve">
          <source>This function generates a version 4 UUID, which is derived entirely from random numbers.</source>
          <target state="translated">Эта функция генерирует UUID версии 4,который полностью вычисляется из случайных чисел.</target>
        </trans-unit>
        <trans-unit id="70e04d40259f3b4e398eaecf4565ce5668726dbd" translate="yes" xml:space="preserve">
          <source>This function generates a version 5 UUID, which works like a version 3 UUID except that SHA-1 is used as a hashing method. Version 5 should be preferred over version 3 because SHA-1 is thought to be more secure than MD5.</source>
          <target state="translated">Эта функция генерирует UUID версии 5,который работает как UUID версии 3,за исключением того,что SHA-1 используется в качестве метода хэширования.Версия 5 должна быть предпочтительнее версии 3,потому что SHA-1 считается более безопасным,чем MD5.</target>
        </trans-unit>
        <trans-unit id="e0a3bf72d056e543baff831854a2b9328ece5e35" translate="yes" xml:space="preserve">
          <source>This function is described in &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;Table 9.62&lt;/a&gt;.</source>
          <target state="translated">Эта функция описана в &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;Таблице 9.62&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9a6e7f01cec14b42f0b87924ed8025472ae1b3d" translate="yes" xml:space="preserve">
          <source>This function is really useful only if you have more than one trusted CA certificate in your server's certificate authority file, or if this CA has issued some intermediate certificate authority certificates.</source>
          <target state="translated">Эта функция действительно полезна только в том случае,если у вас есть более одного доверенного сертификата CA в файле центра сертификации вашего сервера,или если этот центр сертификации выпустил несколько промежуточных сертификатов центра сертификации.</target>
        </trans-unit>
        <trans-unit id="63ff3f7ccdd8e65ce06124599f3ab0770c0133c3" translate="yes" xml:space="preserve">
          <source>This function is restricted to superusers and members of the &lt;code&gt;pg_monitor&lt;/code&gt; role by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52438a2973580a90569d73e97b9438c5b2a81d3" translate="yes" xml:space="preserve">
          <source>This function is restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09caa14af8239e8fd0fef2257c67a191f1fcb7c5" translate="yes" xml:space="preserve">
          <source>This function is used implicitly when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a9fbad99c6b946ee2810aa1613797169567ed3" translate="yes" xml:space="preserve">
          <source>This function is used implicitly when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;jsonb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b67ed61bf91babfe5b1fd62f929a40f3153129" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code id=&quot;update&quot;&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3bba3a33d3476c85ef64f965448f29b348576cf" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code id=&quot;usage&quot;&gt;USAGE&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1d41d04bdf06be2e37d1f0ae8845458954a418" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">Для этой функции требуется привилегия &lt;code&gt;UPDATE&lt;/code&gt; для последовательности.</target>
        </trans-unit>
        <trans-unit id="e39f1ca89945df262cf69293c102551266551425" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the last used sequence.</source>
          <target state="translated">Для этой функции требуется привилегия &lt;code&gt;USAGE&lt;/code&gt; или &lt;code&gt;SELECT&lt;/code&gt; для последней использованной последовательности.</target>
        </trans-unit>
        <trans-unit id="9f01c920de003b371748d82ceb88ff4c45aff8e2" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">Для этой функции требуется привилегия &lt;code&gt;USAGE&lt;/code&gt; или &lt;code&gt;SELECT&lt;/code&gt; для последовательности.</target>
        </trans-unit>
        <trans-unit id="67164ea85a2954ef16cf5fcf220bb12c3b615043" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">Для этой функции требуется привилегия &lt;code&gt;USAGE&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; для последовательности.</target>
        </trans-unit>
        <trans-unit id="7e54a0efd46907c22c610b8b23cccd57e0bcbc37" translate="yes" xml:space="preserve">
          <source>This function requires lexeme positional information to perform its calculation. Therefore, it ignores any &amp;ldquo;stripped&amp;rdquo; lexemes in the &lt;code&gt;tsvector&lt;/code&gt;. If there are no unstripped lexemes in the input, the result will be zero. (See &lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;Section 12.4.1&lt;/a&gt; for more information about the &lt;code&gt;strip&lt;/code&gt; function and positional information in &lt;code&gt;tsvector&lt;/code&gt;s.)</source>
          <target state="translated">Эта функция требует позиционной информации лексемы для выполнения своего вычисления. Следовательно, он игнорирует любые &amp;laquo;урезанные&amp;raquo; лексемы в &lt;code&gt;tsvector&lt;/code&gt; . Если во входных данных нет развернутых лексем, результат будет нулевым. (См. &lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;Раздел 12.4.1&lt;/a&gt; для получения дополнительной информации о функции &lt;code&gt;strip&lt;/code&gt; и позиционной информации в &lt;code&gt;tsvector&lt;/code&gt; s.)</target>
        </trans-unit>
        <trans-unit id="c1856db892a00b2e43b297b0dbc4109fce353620" translate="yes" xml:space="preserve">
          <source>This function returns a value that can be approximately understood as the greatest similarity between the first string and any substring of the second string. However, this function does not add padding to the boundaries of the extent. Thus, the number of additional characters present in the second string is not considered, except for the mismatched word boundaries.</source>
          <target state="translated">Эта функция возвращает значение,которое может быть приблизительно понято как наибольшее сходство между первой строкой и любой подстрокой второй строки.Однако эта функция не добавляет отступов к границам степени.Таким образом,количество дополнительных символов,присутствующих во второй строке,не учитывается,за исключением несовпадения границ слов.</target>
        </trans-unit>
        <trans-unit id="0221605a1cce6baf0cb85c01f2888179ec394f70" translate="yes" xml:space="preserve">
          <source>This function returns a version 4 (random) UUID. This is the most commonly used type of UUID and is appropriate for most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aa18780b259bc2744ab8ff0666ff85306321c0" translate="yes" xml:space="preserve">
          <source>This function returns multiple values separated by the specified separator, for example &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; if separator is &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">Эта функция возвращает несколько значений , разделенных на указанный разделитель, например &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; , если сепаратор &lt;code&gt;,&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a92a46b380193cb9c54f2eb12d510b84b0bf579e" translate="yes" xml:space="preserve">
          <source>This function returns the value of the specified field in the certificate subject, or NULL if the field is not present. Field names are string constants that are converted into ASN1 object identifiers using the OpenSSL object database. The following values are acceptable:</source>
          <target state="translated">Данная функция возвращает значение указанного поля в субъекте сертификата,или NULL,если поле отсутствует.Имена полей-это строковые константы,которые преобразуются в идентификаторы объектов ASN1 с помощью объектной базы данных OpenSSL.Допустимы следующие значения:</target>
        </trans-unit>
        <trans-unit id="50cb6130584a2ccc2fd56083455360b1df842976" translate="yes" xml:space="preserve">
          <source>This function should be called with the same arguments as the return attributes of &lt;code&gt;heap_page_items&lt;/code&gt;.</source>
          <target state="translated">Эта функция должна вызываться с теми же аргументами, что и возвращаемые атрибуты &lt;code&gt;heap_page_items&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf22c93b0d832b9656f660c278a124c39df4dd9" translate="yes" xml:space="preserve">
          <source>This function terminates backup mode and performs an automatic switch to the next WAL segment. The reason for the switch is to arrange for the last WAL segment written during the backup interval to be ready to archive.</source>
          <target state="translated">Эта функция завершает режим резервного копирования и выполняет автоматический переход на следующий сегмент WAL.Причина переключения заключается в том,что последний записанный в интервале резервного копирования сегмент WAL должен быть готов к архивированию.</target>
        </trans-unit>
        <trans-unit id="2aad428f96b8431576d3176be3a80d4e1c2a4447" translate="yes" xml:space="preserve">
          <source>This function will be called to initialize dynamic shared memory at the beginning of a parallel scan. &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; will point to at least the number of bytes previously returned by &lt;code&gt;amestimateparallelscan&lt;/code&gt;, and this function may use that amount of space to store whatever data it wishes.</source>
          <target state="translated">Эта функция будет вызываться для инициализации динамической разделяемой памяти в начале параллельного сканирования. &lt;em&gt; &lt;code&gt;target&lt;/code&gt; &lt;/em&gt; будет указывать по крайней мере на количество байтов, ранее возвращенных &lt;code&gt;amestimateparallelscan&lt;/code&gt; , и эта функция может использовать это количество места для хранения любых данных, которые она пожелает.</target>
        </trans-unit>
        <trans-unit id="9031a619f108cfe873afc670225222a731f98ca3" translate="yes" xml:space="preserve">
          <source>This function's intention is to access a table &lt;code&gt;admin.pwds&lt;/code&gt;. But without the &lt;code&gt;SET&lt;/code&gt; clause, or with a &lt;code&gt;SET&lt;/code&gt; clause mentioning only &lt;code&gt;admin&lt;/code&gt;, the function could be subverted by creating a temporary table named &lt;code&gt;pwds&lt;/code&gt;.</source>
          <target state="translated">Эта функция предназначена для доступа к таблице &lt;code&gt;admin.pwds&lt;/code&gt; . Но без предложения &lt;code&gt;SET&lt;/code&gt; или с предложением &lt;code&gt;SET&lt;/code&gt; , в котором упоминается только &lt;code&gt;admin&lt;/code&gt; , функция может быть нарушена путем создания временной таблицы с именем &lt;code&gt;pwds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74eda98e312717a7e3761e1be3fed4cfe413013a" translate="yes" xml:space="preserve">
          <source>This function, if implemented, will be called when a parallel index scan must be restarted. It should reset any shared state set up by &lt;code&gt;aminitparallelscan&lt;/code&gt; such that the scan will be restarted from the beginning.</source>
          <target state="translated">Эта функция, если она реализована, будет вызываться при перезапуске параллельного сканирования индекса. Он должен сбросить любое общее состояние, установленное &lt;code&gt;aminitparallelscan&lt;/code&gt; , чтобы сканирование было перезапущено с самого начала.</target>
        </trans-unit>
        <trans-unit id="ba0d2d4c762ce91e9a46761e7e3115cef1d26dc7" translate="yes" xml:space="preserve">
          <source>This group of commands implements nestable conditional blocks, similarly to &lt;code&gt;psql&lt;/code&gt;'s &lt;a href=&quot;app-psql#PSQL-METACOMMAND-IF&quot;&gt;&lt;code&gt;\if&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt;&lt;/a&gt;. Conditional expressions are identical to those with &lt;code&gt;\set&lt;/code&gt;, with non-zero values interpreted as true.</source>
          <target state="translated">Эта группа команд реализует вложенности условных блоков, аналогично &lt;code&gt;psql&lt;/code&gt; &amp;laquo;ы , &lt;a href=&quot;app-psql#PSQL-METACOMMAND-IF&quot;&gt; &lt;code&gt;\if&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt; &lt;/a&gt; . Условные выражения идентичны выражениям с &lt;code&gt;\set&lt;/code&gt; , а ненулевые значения интерпретируются как истинные.</target>
        </trans-unit>
        <trans-unit id="a86a1c85779a67bdb4c07c083dc8d1a736ba45ad" translate="yes" xml:space="preserve">
          <source>This group of commands implements nestable conditional blocks. A conditional block must begin with an &lt;code&gt;\if&lt;/code&gt; and end with an &lt;code&gt;\endif&lt;/code&gt;. In between there may be any number of &lt;code&gt;\elif&lt;/code&gt; clauses, which may optionally be followed by a single &lt;code&gt;\else&lt;/code&gt; clause. Ordinary queries and other types of backslash commands may (and usually do) appear between the commands forming a conditional block.</source>
          <target state="translated">Эта группа команд реализует вложенные условные блоки. Условный блок должен начинаться с &lt;code&gt;\if&lt;/code&gt; и заканчиваться &lt;code&gt;\endif&lt;/code&gt; . Между ними может быть любое количество предложений &lt;code&gt;\elif&lt;/code&gt; , за которыми может следовать одно предложение &lt;code&gt;\else&lt;/code&gt; . Обычные запросы и другие типы команд с обратной косой чертой могут (и обычно появляются) между командами, образующими условный блок.</target>
        </trans-unit>
        <trans-unit id="44140a36cc7df2f1c3a52fdc81c7272717604999" translate="yes" xml:space="preserve">
          <source>This happens because an hour was skipped due to a change in daylight saving time at &lt;code&gt;2005-04-03 02:00:00&lt;/code&gt; in time zone &lt;code&gt;America/Denver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b11efb2c7cb913b726605094c75fda2e8cad938" translate="yes" xml:space="preserve">
          <source>This happens because the system cannot decide which of the several possible &lt;code&gt;~&lt;/code&gt; operators should be preferred. We can help it out with an explicit cast:</source>
          <target state="translated">Это происходит потому, что система не может решить, какой из нескольких возможных операторов &lt;code&gt;~&lt;/code&gt; следует предпочесть. Мы можем помочь с этим явным приведением:</target>
        </trans-unit>
        <trans-unit id="1adefa35377cadd1c8a75aec2fb42a29f31a0dd0" translate="yes" xml:space="preserve">
          <source>This has the same effect as casting each expression to the array element type individually. For more on casting, see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Section 4.2.9&lt;/a&gt;.</source>
          <target state="translated">Это имеет тот же эффект, что и приведение каждого выражения к типу элемента массива по отдельности. Подробнее о кастинге см. &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Раздел 4.2.9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a60511ea52748a75870fb82ff05a5c564394ceb2" translate="yes" xml:space="preserve">
          <source>This heuristic can be overridden, forcing the server to use either generic or custom plans, by setting &lt;code&gt;plan_cache_mode&lt;/code&gt; to &lt;code&gt;force_generic_plan&lt;/code&gt; or &lt;code&gt;force_custom_plan&lt;/code&gt; respectively. This setting is primarily useful if the generic plan's cost estimate is badly off for some reason, allowing it to be chosen even though its actual cost is much more than that of a custom plan.</source>
          <target state="translated">Эту эвристику можно переопределить, заставив сервер использовать общие или настраиваемые планы, установив для &lt;code&gt;plan_cache_mode&lt;/code&gt; значение &lt;code&gt;force_generic_plan&lt;/code&gt; или &lt;code&gt;force_custom_plan&lt;/code&gt; соответственно. Этот параметр в первую очередь полезен, если смета общего плана по какой-то причине сильно отличается, что позволяет выбрать его, даже если его фактическая стоимость намного больше, чем у индивидуального плана.</target>
        </trans-unit>
        <trans-unit id="3ceb81116f5e1034358e4c68c702f99fa463a7e9" translate="yes" xml:space="preserve">
          <source>This implies that if a table is not otherwise vacuumed, autovacuum will be invoked on it approximately once every &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; minus &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; transactions. For tables that are regularly vacuumed for space reclamation purposes, this is of little importance. However, for static tables (including tables that receive inserts, but no updates or deletes), there is no need to vacuum for space reclamation, so it can be useful to try to maximize the interval between forced autovacuums on very large static tables. Obviously one can do this either by increasing &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; or decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt;.</source>
          <target state="translated">Это означает, что если таблица не очищается иным образом, автоматическая очистка будет вызываться для нее примерно один раз за &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; транзакции &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; за вычетом операций Vacuum_freeze_min_age . Для столов, которые регулярно пылесосятся с целью освобождения места, это не имеет большого значения. Однако для статических таблиц (включая таблицы, которые получают вставки, но не обновляют или удаляют), нет необходимости вакуумировать для восстановления пространства, поэтому может быть полезно попытаться максимизировать интервал между принудительными автоочистками для очень больших статических таблиц. Очевидно, это можно сделать либо увеличив &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; , либо уменьшив &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="963c171b1310567729b0c667a3982a8159857c0a" translate="yes" xml:space="preserve">
          <source>This includes issues caused by the comparison rules of operating system collations changing. Comparisons of datums of a collatable type like &lt;code&gt;text&lt;/code&gt; must be immutable (just as all comparisons used for B-Tree index scans must be immutable), which implies that operating system collation rules must never change. Though rare, updates to operating system collation rules can cause these issues. More commonly, an inconsistency in the collation order between a master server and a standby server is implicated, possibly because the &lt;em&gt;major&lt;/em&gt; operating system version in use is inconsistent. Such inconsistencies will generally only arise on standby servers, and so can generally only be detected on standby servers.</source>
          <target state="translated">Сюда входят проблемы, вызванные изменением правил сравнения параметров сортировки операционной системы. Сравнения данных сопоставимого типа, такого как &lt;code&gt;text&lt;/code&gt; должны быть неизменными (так же, как все сравнения, используемые для сканирования индекса B-Tree, должны быть неизменными), что означает, что правила сопоставления операционной системы никогда не должны изменяться. Эти проблемы могут возникать, хотя и редко, но обновления правил сортировки операционной системы. Чаще всего подразумевается несогласованность в порядке сопоставления между главным и резервным серверами, возможно, из-за несовместимости &lt;em&gt;основной&lt;/em&gt; используемой версии операционной системы. Такие несоответствия обычно возникают только на резервных серверах, и поэтому обычно могут быть обнаружены только на резервных серверах.</target>
        </trans-unit>
        <trans-unit id="a867951badfb08df8a9bb92137e4c1059d9fe31b" translate="yes" xml:space="preserve">
          <source>This indicates that the &lt;code&gt;postgres&lt;/code&gt; process has been terminated due to memory pressure. Although existing database connections will continue to function normally, no new connections will be accepted. To recover, PostgreSQL will need to be restarted.</source>
          <target state="translated">Это указывает на то, что процесс &lt;code&gt;postgres&lt;/code&gt; был завершен из-за нехватки памяти. Хотя существующие соединения с базой данных будут продолжать нормально работать, новые соединения не будут приняты. Для восстановления необходимо перезапустить PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="0a372cfe5f8eb7d4853999840a603c1c28fd5394" translate="yes" xml:space="preserve">
          <source>This indicates that the most common combination of city and state is Washington in DC, with actual frequency (in the sample) about 0.35%. The base frequency of the combination (as computed from the simple per-column frequencies) is only 0.0027%, resulting in two orders of magnitude under-estimates.</source>
          <target state="translated">Это указывает на то,что наиболее распространенной комбинацией города и штата является Вашингтон в округе Колумбия,с фактической частотой (в выборке)около 0,35%.Базовая частота комбинации (вычисленная из простых частот на колонку)составляет всего 0.0027%,что на два порядка занижает оценку.</target>
        </trans-unit>
        <trans-unit id="e8fe534ccbaaf548c2b11e2912002e72aef917fa" translate="yes" xml:space="preserve">
          <source>This indicates that there are three combinations of columns that have 33178 distinct values: ZIP code and state; ZIP code and city; and ZIP code, city and state (the fact that they are all equal is expected given that ZIP code alone is unique in this table). On the other hand, the combination of city and state has only 27435 distinct values.</source>
          <target state="translated">Это указывает на то,что существуют три комбинации колонок,которые имеют 33178 различных значений:ZIP-код и состояние;ZIP-код и город;и ZIP-код,город и состояние (то,что все они равны,ожидается,учитывая,что только ZIP-код уникален в этой таблице).С другой стороны,комбинация города и штата имеет только 27435 различных значений.</target>
        </trans-unit>
        <trans-unit id="fc1f09ba473095924730f620c845acdb222d24ff" translate="yes" xml:space="preserve">
          <source>This involves changes in the backend function API, which is written in the C programming language. Such changes affect code that references backend functions deep inside the server.</source>
          <target state="translated">Это предполагает внесение изменений в API функции бэкэнда,написанное на языке программирования Си.Такие изменения затрагивают код,который ссылается на бекендовые функции глубоко внутри сервера.</target>
        </trans-unit>
        <trans-unit id="d9a4686c9a5bfa4e42613a92f3eda7d13c48363f" translate="yes" xml:space="preserve">
          <source>This is OK because the subquery is an independent computation that computes its own aggregate separately from what is happening in the outer query.</source>
          <target state="translated">Это нормально,потому что подзапрос является независимым вычислением,которое вычисляет свою собственную совокупность отдельно от того,что происходит во внешнем запросе.</target>
        </trans-unit>
        <trans-unit id="14697b498878040181d5bdcab2a50bb95e660328" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;printf&lt;/code&gt;-style string that is output at the beginning of each log line. &lt;code&gt;%&lt;/code&gt; characters begin &amp;ldquo;escape sequences&amp;rdquo; that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the log line. Some escapes are only recognized by session processes, and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dcf869a044613b3ca0ecf7baf516a8c7193977f" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;printf&lt;/code&gt;-style string that is output at the beginning of each log line. &lt;code&gt;%&lt;/code&gt; characters begin &amp;ldquo;escape sequences&amp;rdquo; that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the log line. Some escapes are only recognized by session processes, and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;'%m [%p] '&lt;/code&gt; which logs a time stamp and the process ID.</source>
          <target state="translated">Это строка в стиле &lt;code&gt;printf&lt;/code&gt; , которая выводится в начале каждой строки журнала. Символы &lt;code&gt;%&lt;/code&gt; начинают &amp;laquo;escape-последовательности&amp;raquo;, которые заменяются информацией о состоянии, как показано ниже. Нераспознанные escape-последовательности игнорируются. Остальные символы копируются прямо в строку журнала. Некоторые escape-последовательности распознаются только процессами сеанса и будут обрабатываться как пустые фоновыми процессами, такими как процесс главного сервера. Информация о состоянии может быть выровнена по левому или правому краю, указав числовой литерал после% и перед параметром. Отрицательное значение приведет к тому, что информация о состоянии будет дополнена справа пробелами, чтобы придать ей минимальную ширину, тогда как положительное значение будет дополняться слева. Заполнение может быть полезно для облегчения чтения файлов журналов. Этот параметр можно установить только в &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера. По умолчанию используется &lt;code&gt;'%m [%p] '&lt;/code&gt; котором регистрируются отметка времени и идентификатор процесса.</target>
        </trans-unit>
        <trans-unit id="8b34706e04777a657dce1a4607ff942e4ebc159f" translate="yes" xml:space="preserve">
          <source>This is a B-tree leaf page. All tuples that point to the table happen to be posting list tuples (all of which store a total of 100 6 byte TIDs). There is also a &amp;ldquo;high key&amp;rdquo; tuple at &lt;code&gt;itemoffset&lt;/code&gt; number 1. &lt;code&gt;ctid&lt;/code&gt; is used to store encoded information about each tuple in this example, though leaf page tuples often store a heap TID directly in the &lt;code&gt;ctid&lt;/code&gt; field instead. &lt;code&gt;tids&lt;/code&gt; is the list of TIDs stored as a posting list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9227695178f5037e0a0e506aca137b88f68d780" translate="yes" xml:space="preserve">
          <source>This is a Boolean option. If true, it specifies that values of the column should not be matched against the null string (that is, the table-level &lt;code&gt;null&lt;/code&gt; option). This has the same effect as listing the column in &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; option.</source>
          <target state="translated">Это логическая опция. Если true, он указывает, что значения столбца не должны сопоставляться с пустой строкой (то есть с параметром &lt;code&gt;null&lt;/code&gt; на уровне таблицы ). Это имеет тот же эффект, что и листинг столбца в &lt;code&gt;COPY&lt;/code&gt; &amp;laquo;s &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; варианта.</target>
        </trans-unit>
        <trans-unit id="bb0f72d78e70cfb965b94342147bb69a1649e537" translate="yes" xml:space="preserve">
          <source>This is a Boolean option. If true, it specifies that values of the column which match the null string are returned as &lt;code&gt;NULL&lt;/code&gt; even if the value is quoted. Without this option, only unquoted values matching the null string are returned as &lt;code&gt;NULL&lt;/code&gt;. This has the same effect as listing the column in &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORCE_NULL&lt;/code&gt; option.</source>
          <target state="translated">Это логическая опция. Если true, он указывает, что значения столбца, соответствующие нулевой строке, возвращаются как &lt;code&gt;NULL&lt;/code&gt; , даже если значение заключено в кавычки. Без этой опции только значения без кавычек, соответствующие нулевой строке, возвращаются как &lt;code&gt;NULL&lt;/code&gt; . Это имеет тот же эффект, что и листинг столбца в &lt;code&gt;COPY&lt;/code&gt; &amp;laquo;s &lt;code&gt;FORCE_NULL&lt;/code&gt; варианта.</target>
        </trans-unit>
        <trans-unit id="d9d802e79acd19a5807b524b5ff1cadf1072e9c9" translate="yes" xml:space="preserve">
          <source>This is a bad idea! Almost certainly, you'll be better off with a single non-partial index, declared like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2458d33e53e769de251317cb73941c93deac0112" translate="yes" xml:space="preserve">
          <source>This is a deprecated alias for &lt;code id=&quot;6462&quot;&gt;@&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89be01ecc4c51c231fa86cb87027e9f7e872252" translate="yes" xml:space="preserve">
          <source>This is a deprecated synonym for &lt;code id=&quot;6464&quot;&gt;@@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86fd356bbb6f1b1f6f6224d995b8d42e58695e06" translate="yes" xml:space="preserve">
          <source>This is a historical alias for &lt;code id=&quot;stddev_samp&quot;&gt;stddev_samp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e5af4d8a94f39f1b76df48d0e7c72e55e60307" translate="yes" xml:space="preserve">
          <source>This is a historical alias for &lt;code id=&quot;var_samp&quot;&gt;var_samp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952c5f2574e0ab3c7c85d004636983a1260b99d7" translate="yes" xml:space="preserve">
          <source>This is a list of acronyms commonly used in the PostgreSQL documentation and in discussions about PostgreSQL.</source>
          <target state="translated">Это список аббревиатур,обычно используемых в документации PostgreSQL и в обсуждениях о PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="cba6116424f9b26f41ff31a3536a10c997043100" translate="yes" xml:space="preserve">
          <source>This is a list of terms and their meaning in the context of PostgreSQL and relational database systems in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e0bd441cd585968a19e4596d1d9617026fbc74" translate="yes" xml:space="preserve">
          <source>This is a noise word.</source>
          <target state="translated">Это шумное слово.</target>
        </trans-unit>
        <trans-unit id="e3f9d4c5c7e93766f0b892911d84b9660f77ff3e" translate="yes" xml:space="preserve">
          <source>This is a non-standard syntax for &lt;code&gt;trim()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022e58efea267ae2631d535b60729a755677e2e4" translate="yes" xml:space="preserve">
          <source>This is a particularly efficient approach when there are few successful tests and many unsuccessful ones.</source>
          <target state="translated">Это особенно эффективный подход,когда есть несколько успешных тестов и много неудачных.</target>
        </trans-unit>
        <trans-unit id="9e8e468a2c09a5e3ff58be6bcf971fcb3102f2b3" translate="yes" xml:space="preserve">
          <source>This is a particularly efficient approach when there are few successful tests and many unsuccessful ones. It is also possible to allow only one null in a column by creating a unique partial index with an &lt;code&gt;IS NULL&lt;/code&gt; restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d2e6129737b2c23b111b25ce903c45a62a32f8" translate="yes" xml:space="preserve">
          <source>This is a sequence of three commands, one per line (although this is not required; more than one command can be on a line, and commands can usefully be split across lines).</source>
          <target state="translated">Это последовательность из трех команд,по одной на строку (хотя это и не обязательно;на строке может быть более одной команды,и команды можно с пользой разделить на строки).</target>
        </trans-unit>
        <trans-unit id="450f019da352d6f44183cb5a8fe197731201523e" translate="yes" xml:space="preserve">
          <source>This is a shortcut for setting &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; at once. If you specify this, you cannot specify either of those parameters.</source>
          <target state="translated">Это ярлык для одновременной установки &lt;code&gt;LC_COLLATE&lt;/code&gt; и &lt;code&gt;LC_CTYPE&lt;/code&gt; . Если вы укажете это, вы не сможете указать ни один из этих параметров.</target>
        </trans-unit>
        <trans-unit id="768c3e272a14bb422425810cd204ed41f4ba6629" translate="yes" xml:space="preserve">
          <source>This is a wrapper for the above function that uses &lt;code&gt;,&lt;/code&gt; as the separator.</source>
          <target state="translated">Это оболочка для вышеупомянутой функции , которая использует &lt;code&gt;,&lt;/code&gt; в качестве разделителя.</target>
        </trans-unit>
        <trans-unit id="b3c868d4182c583f463c71ff97e781747bf3a03c" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;\dp&lt;/code&gt; (&amp;ldquo;display privileges&amp;rdquo;).</source>
          <target state="translated">Это псевдоним для &lt;code&gt;\dp&lt;/code&gt; (&amp;laquo;права на отображение&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="a3bfb72cef070dc11f447b3386a7c2706bac36a5" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;\lo_list&lt;/code&gt;, which shows a list of large objects.</source>
          <target state="translated">Это псевдоним для &lt;code&gt;\lo_list&lt;/code&gt; , который показывает список больших объектов.</target>
        </trans-unit>
        <trans-unit id="e5418e1e26d985dcf636546c65d0611e01b93f2b" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;hash_murmur2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ba8cae4388de88507eba2b7275ccd60b950613" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;indnatts&lt;/code&gt; values that indicate which table columns this index indexes. For example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns make up the index entries. Key columns come before non-key (included) columns. A zero in this array indicates that the corresponding index attribute is an expression over the table columns, rather than a simple column reference.</source>
          <target state="translated">Это массив значений &lt;code&gt;indnatts&lt;/code&gt; , указывающих, какие столбцы таблицы индексируются. Например, значение &lt;code&gt;1 3&lt;/code&gt; будет означать, что первый и третий столбцы таблицы составляют записи индекса. Ключевые столбцы предшествуют неключевым (включенным) столбцам. Ноль в этом массиве указывает, что соответствующий атрибут индекса является выражением по столбцам таблицы, а не простой ссылкой на столбец.</target>
        </trans-unit>
        <trans-unit id="f5ae302c90a19a0498f7df9c475b24d33cb673e7" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;indnkeyatts&lt;/code&gt; values that store per-column flag bits. The meaning of the bits is defined by the index's access method.</source>
          <target state="translated">Это массив значений &lt;code&gt;indnkeyatts&lt;/code&gt; , в которых хранятся биты флагов для каждого столбца. Значение битов определяется методом доступа индекса.</target>
        </trans-unit>
        <trans-unit id="2fc49bd55fbc5bfa9dea1e28cd18c9a1ca88a7e4" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;partnatts&lt;/code&gt; values that indicate which table columns are part of the partition key. For example, a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns make up the partition key. A zero in this array indicates that the corresponding partition key column is an expression, rather than a simple column reference.</source>
          <target state="translated">Это массив значений &lt;code&gt;partnatts&lt;/code&gt; , указывающих, какие столбцы таблицы являются частью ключа раздела. Например, значение &lt;code&gt;1 3&lt;/code&gt; будет означать, что первый и третий столбцы таблицы составляют ключ раздела. Нуль в этом массиве указывает на то, что соответствующий столбец ключа раздела является выражением, а не простой ссылкой на колонке.</target>
        </trans-unit>
        <trans-unit id="85cb6ef5ec65368f349e99d1c5b167fcd51b032f" translate="yes" xml:space="preserve">
          <source>This is an example of creating a bloom index:</source>
          <target state="translated">Это пример создания индекса цветения:</target>
        </trans-unit>
        <trans-unit id="28e7b5364ece8bb74449b25a2f87fdcc6112556a" translate="yes" xml:space="preserve">
          <source>This is backward-compatible syntax for declaring a table &lt;code&gt;WITHOUT OIDS&lt;/code&gt;, creating a table &lt;code&gt;WITH OIDS&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">Это обратно совместимый синтаксис для объявления таблицы &lt;code&gt;WITHOUT OIDS&lt;/code&gt; , создание таблицы &lt;code&gt;WITH OIDS&lt;/code&gt; больше не поддерживается.</target>
        </trans-unit>
        <trans-unit id="f53c81b1fcb044c5d18d73e6543204df53f672fe" translate="yes" xml:space="preserve">
          <source>This is because a restriction placed in the &lt;code&gt;ON&lt;/code&gt; clause is processed &lt;em&gt;before&lt;/em&gt; the join, while a restriction placed in the &lt;code&gt;WHERE&lt;/code&gt; clause is processed &lt;em&gt;after&lt;/em&gt; the join. That does not matter with inner joins, but it matters a lot with outer joins.</source>
          <target state="translated">Это связано с тем, что ограничение, помещенное в предложении &lt;code&gt;ON&lt;/code&gt; , обрабатывается &lt;em&gt;перед&lt;/em&gt; объединением, в то время как ограничение, помещенное в &lt;code&gt;WHERE&lt;/code&gt; , обрабатывается &lt;em&gt;после&lt;/em&gt; соединения. Это не имеет значения для внутренних соединений, но имеет большое значение для внешних соединений.</target>
        </trans-unit>
        <trans-unit id="40e68e5962e0de07dffd697e9417724fccc9d63d" translate="yes" xml:space="preserve">
          <source>This is because if A had executed before B, B would have computed the sum 330, not 300, and similarly the other order would have resulted in a different sum computed by A.</source>
          <target state="translated">Это потому,что если бы A выполнил до B,то B вычислил бы сумму 330,а не 300,и аналогичным образом другой ордер привел бы к другой сумме,вычисленной A.</target>
        </trans-unit>
        <trans-unit id="75b15f8961b465e16b950c107a03d87b532671ad" translate="yes" xml:space="preserve">
          <source>This is commonly used for analysis over hierarchical data; e.g. total salary by department, division, and company-wide total.</source>
          <target state="translated">Это обычно используется для анализа иерархических данных;например,общая заработная плата по отделам,подразделениям и общая заработная плата по всей компании.</target>
        </trans-unit>
        <trans-unit id="acf1e54fe7c52b1e02149d6df39362598d17e105" translate="yes" xml:space="preserve">
          <source>This is commonly used for analysis over hierarchical data; e.g., total salary by department, division, and company-wide total.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19f8fd7239c9e470394caad32ebd804606ed7b1" translate="yes" xml:space="preserve">
          <source>This is effectively the same as setting the default to null. As a consequence, it is not an error to drop a default where one hadn't been defined, because the default is implicitly the null value.</source>
          <target state="translated">По сути,это то же самое,что и установка по умолчанию на ноль.Как следствие,не является ошибкой опускать значение по умолчанию там,где оно не было определено,потому что значение по умолчанию неявно является нулевым.</target>
        </trans-unit>
        <trans-unit id="41f2000975a0c863d9984d3c052ffa8b2b55e07d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code id=&quot;current_user&quot;&gt;current_user&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbe5e4acccc682de9944cdbcde670be36b81565" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;current_user&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d31603eaa916aca8762159f8bda194ec5b5313c" translate="yes" xml:space="preserve">
          <source>This is equivalent to considering that the lower bound is &amp;ldquo;minus infinity&amp;rdquo;, or the upper bound is &amp;ldquo;plus infinity&amp;rdquo;, respectively. But note that these infinite values are never values of the range's element type, and can never be part of the range. (So there is no such thing as an inclusive infinite bound &amp;mdash; if you try to write one, it will automatically be converted to an exclusive bound.)</source>
          <target state="translated">Это эквивалентно рассмотрению того, что нижняя граница равна &amp;laquo;минус бесконечности&amp;raquo; или верхняя граница равна &amp;laquo;плюс бесконечности&amp;raquo;, соответственно. Но обратите внимание, что эти бесконечные значения никогда не являются значениями типа элемента диапазона и никогда не могут быть частью диапазона. (Таким образом, не существует такой вещи, как инклюзивная бесконечная граница - если вы попытаетесь ее написать, она будет автоматически преобразована в исключительную границу.)</target>
        </trans-unit>
        <trans-unit id="32b4366f2bb306ae39f6ae123b6e52ebbaf45e22" translate="yes" xml:space="preserve">
          <source>This is false for internal languages (such as SQL) and true for user-defined languages. Currently, pg_dump still uses this to determine which languages need to be dumped, but this might be replaced by a different mechanism in the future.</source>
          <target state="translated">Это ложно для внутренних языков (таких как SQL)и верно для определяемых пользователем языков.В настоящее время pg_dump по-прежнему использует этот параметр для определения того,какие языки необходимо выдавливать,но в будущем он может быть заменён другим механизмом.</target>
        </trans-unit>
        <trans-unit id="909703c85505cd16ac2e43cb68b897cd4647ad6b" translate="yes" xml:space="preserve">
          <source>This is identical to &lt;code&gt;dow&lt;/code&gt; except for Sunday. This matches the ISO 8601 day of the week numbering.</source>
          <target state="translated">Это то же &lt;code&gt;dow&lt;/code&gt; за исключением воскресенья. Это соответствует нумерации дней недели ISO 8601.</target>
        </trans-unit>
        <trans-unit id="774c866f144b866c3887ecc3ab9eba1546c6554f" translate="yes" xml:space="preserve">
          <source>This is more useful if the expressions in the select list return varying results. For example, you could call a function this way:</source>
          <target state="translated">Это более полезно,если выражения в списке выбора возвращают различные результаты.Например,таким образом можно вызвать функцию:</target>
        </trans-unit>
        <trans-unit id="f9f2d8c3b689196c5d8ec8d4f5df566ae69faf2b" translate="yes" xml:space="preserve">
          <source>This is needed to avoid syntactic ambiguity. An example is:</source>
          <target state="translated">Это необходимо,чтобы избежать синтаксической двусмысленности.Например:</target>
        </trans-unit>
        <trans-unit id="9c677b482c1d51ad6809dd70f3013fed740bc81c" translate="yes" xml:space="preserve">
          <source>This is not as efficient as a partial index on the &lt;code&gt;amount&lt;/code&gt; column would be, since the system has to scan the entire index. Yet, if there are relatively few unbilled orders, using this partial index just to find the unbilled orders could be a win.</source>
          <target state="translated">Это не так эффективно, как частичный индекс по столбцу &lt;code&gt;amount&lt;/code&gt; , поскольку система должна сканировать весь индекс. Тем не менее, при относительно небольшом количестве невыплаченных заказов использование этого частичного индекса только для поиска невыплаченных заказов может быть выгодным.</target>
        </trans-unit>
        <trans-unit id="30d2d55c459297e19ddd1f07d0c1ebe65fd3794d" translate="yes" xml:space="preserve">
          <source>This is not especially useful since it has exactly the same result as the more conventional</source>
          <target state="translated">Это не особенно полезно,так как имеет точно такой же результат,как и более традиционные</target>
        </trans-unit>
        <trans-unit id="0322eac9bb3931b0da02327d4f96591febd87604" translate="yes" xml:space="preserve">
          <source>This is only a conceptual model. The join is usually performed in a more efficient manner than actually comparing each possible pair of rows, but this is invisible to the user.</source>
          <target state="translated">Это всего лишь концептуальная модель.Обычно соединение выполняется более эффективно,чем фактическое сравнение каждой возможной пары строк,но это невидимо пользователю.</target>
        </trans-unit>
        <trans-unit id="b8169801d92724560db318d90118c63ada145ffc" translate="yes" xml:space="preserve">
          <source>This is quite a different problem: how to estimate the selectivity when the value is &lt;em&gt;not&lt;/em&gt; in the MCV list. The approach is to use the fact that the value is not in the list, combined with the knowledge of the frequencies for all of the MCVs:</source>
          <target state="translated">Это совсем другая проблема: как оценить избирательность, когда значение &lt;em&gt;отсутствует&lt;/em&gt; в списке MCV. Подход состоит в том, чтобы использовать тот факт, что значение отсутствует в списке, в сочетании со знанием частот для всех MCV:</target>
        </trans-unit>
        <trans-unit id="f0d520c606037b870becb6e588d6da7dff0960ba" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;digest()&lt;/code&gt; but the hash can only be recalculated knowing the key. This prevents the scenario of someone altering data and also changing the hash to match.</source>
          <target state="translated">Это похоже на &lt;code&gt;digest()&lt;/code&gt; но хэш можно пересчитать, только зная ключ. Это предотвращает случай, когда кто-то изменяет данные, а также изменяет хэш для соответствия.</target>
        </trans-unit>
        <trans-unit id="53bd3331f309cfd6d8eeacec7a8068398ef70fcf" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Fast Shutdown&lt;/em&gt; mode. The server disallows new connections and sends all existing server processes SIGTERM, which will cause them to abort their current transactions and exit promptly. It then waits for all server processes to exit and finally shuts down. If the server is in online backup mode, backup mode will be terminated, rendering the backup useless.</source>
          <target state="translated">Это режим &lt;em&gt;быстрого выключения&lt;/em&gt; . Сервер запрещает новые соединения и отправляет всем существующим серверным процессам SIGTERM, что заставляет их прервать свои текущие транзакции и немедленно выйти. Затем он ожидает завершения всех серверных процессов и, наконец, завершает свою работу. Если сервер находится в режиме оперативного резервного копирования, режим резервного копирования будет прекращен, и резервное копирование станет бесполезным.</target>
        </trans-unit>
        <trans-unit id="9519f8334dda9bed264446e6f4818cc6899e6c5a" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Immediate Shutdown&lt;/em&gt; mode. The server will send SIGQUIT to all child processes and wait for them to terminate. If any do not terminate within 5 seconds, they will be sent SIGKILL. The master server process exits as soon as all child processes have exited, without doing normal database shutdown processing. This will lead to recovery (by replaying the WAL log) upon next start-up. This is recommended only in emergencies.</source>
          <target state="translated">Это режим &lt;em&gt;немедленного выключения&lt;/em&gt; . Сервер отправит SIGQUIT всем дочерним процессам и будет ждать их завершения. Если какие-либо из них не завершатся в течение 5 секунд, им будет отправлено SIGKILL. Процесс главного сервера завершается, как только завершаются все дочерние процессы, без выполнения нормальной обработки завершения работы базы данных. Это приведет к восстановлению (путем воспроизведения журнала WAL) при следующем запуске. Это рекомендуется только в экстренных случаях.</target>
        </trans-unit>
        <trans-unit id="64dec29096a90e2ac7b66bae5da2edc5f6e90310" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Smart Shutdown&lt;/em&gt; mode. After receiving SIGTERM, the server disallows new connections, but lets existing sessions end their work normally. It shuts down only after all of the sessions terminate. If the server is in online backup mode, it additionally waits until online backup mode is no longer active. While backup mode is active, new connections will still be allowed, but only to superusers (this exception allows a superuser to connect to terminate online backup mode). If the server is in recovery when a smart shutdown is requested, recovery and streaming replication will be stopped only after all regular sessions have terminated.</source>
          <target state="translated">Это режим &lt;em&gt;Smart Shutdown&lt;/em&gt; . После получения SIGTERM сервер запрещает новые подключения, но позволяет существующим сеансам нормально завершить свою работу. Он отключается только после завершения всех сеансов. Если сервер находится в режиме оперативного резервного копирования, он дополнительно ожидает, пока режим оперативного резервного копирования перестанет быть активным. Пока режим резервного копирования активен, новые подключения по-прежнему будут разрешены, но только для суперпользователей (это исключение позволяет суперпользователю подключиться для выхода из режима оперативного резервного копирования). Если сервер находится в состоянии восстановления, когда запрошено интеллектуальное отключение, восстановление и потоковая репликация будут остановлены только после завершения всех обычных сеансов.</target>
        </trans-unit>
        <trans-unit id="18b982c4dd6953b11d003392c392545d3b122dd7" translate="yes" xml:space="preserve">
          <source>This is the SQL standard's equivalent to &lt;code&gt;bool_and&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92dd6728f5fbf932d72131603602b0280b7afbb6" translate="yes" xml:space="preserve">
          <source>This is the amount of time to wait on a lock before checking to see if there is a deadlock condition. The check for deadlock is relatively expensive, so the server doesn't run it every time it waits for a lock. We optimistically assume that deadlocks are not common in production applications and just wait on the lock for a while before checking for a deadlock. Increasing this value reduces the amount of time wasted in needless deadlock checks, but slows down reporting of real deadlock errors. If this value is specified without units, it is taken as milliseconds. The default is one second (&lt;code&gt;1s&lt;/code&gt;), which is probably about the smallest value you would want in practice. On a heavily loaded server you might want to raise it. Ideally the setting should exceed your typical transaction time, so as to improve the odds that a lock will be released before the waiter decides to check for deadlock. Only superusers can change this setting.</source>
          <target state="translated">Это время ожидания блокировки перед проверкой наличия состояния взаимоблокировки. Проверка на взаимоблокировку относительно дорога, поэтому сервер не запускает ее каждый раз, когда ожидает блокировки. Мы оптимистично предполагаем, что взаимоблокировки не являются обычным явлением в производственных приложениях, и просто ожидаем блокировки некоторое время, прежде чем проверять наличие взаимоблокировки. Увеличение этого значения сокращает время, затрачиваемое на ненужные проверки взаимоблокировок, но замедляет создание отчетов о реальных ошибках взаимоблокировок. Если это значение указано без единиц измерения, оно принимается в миллисекундах. По умолчанию - одна секунда ( &lt;code&gt;1s&lt;/code&gt; ), что, вероятно, является наименьшим значением, которое вы хотели бы получить на практике. На сильно загруженном сервере вы можете поднять его. В идеале настройка должна превышать ваше типичное время транзакции, чтобы повысить вероятность того, что блокировка будет снята до того, как официант решит проверить наличие тупиковой блокировки. Только суперпользователи могут изменять этот параметр.</target>
        </trans-unit>
        <trans-unit id="66c8088759f9087b738e1b70d1cf37c8a1aae852" translate="yes" xml:space="preserve">
          <source>This is the default format.</source>
          <target state="translated">Это формат по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3ce226ef1a13e0c7b419788ac5e73819bf180bcb" translate="yes" xml:space="preserve">
          <source>This is the generic &amp;ldquo;I couldn't find a server to talk to&amp;rdquo; failure. It looks like the above when TCP/IP communication is attempted. A common mistake is to forget to configure the server to allow TCP/IP connections.</source>
          <target state="translated">Это типичная ошибка типа &amp;laquo;Я не могу найти сервер, с которым можно поговорить&amp;raquo;. Это похоже на приведенное выше, когда предпринимается попытка установления связи TCP / IP. Распространенная ошибка - забыть настроить сервер для разрешения TCP / IP-соединений.</target>
        </trans-unit>
        <trans-unit id="7a73a092e455b0519a284ead127b2916ee3a2346" translate="yes" xml:space="preserve">
          <source>This is the interval between updates to &lt;code&gt;autoprewarm.blocks&lt;/code&gt;. The default is 300 seconds. If set to 0, the file will not be dumped at regular intervals, but only when the server is shut down.</source>
          <target state="translated">Это интервал между обновлениями &lt;code&gt;autoprewarm.blocks&lt;/code&gt; . По умолчанию 300 секунд. Если установлено значение 0, файл не будет выгружаться через регулярные промежутки времени, а только при выключении сервера.</target>
        </trans-unit>
        <trans-unit id="7a967763949218bdd201f81e3734208d5693135c" translate="yes" xml:space="preserve">
          <source>This is the most secure of the currently provided methods, but it is not supported by older client libraries.</source>
          <target state="translated">Это наиболее безопасный из предоставляемых в настоящее время методов,но он не поддерживается старыми клиентскими библиотеками.</target>
        </trans-unit>
        <trans-unit id="281ee2a6d6b295f0c605c272cbd3a317a0476533" translate="yes" xml:space="preserve">
          <source>This is the price one pays for extensibility.</source>
          <target state="translated">Это цена,которую платят за растяжимость.</target>
        </trans-unit>
        <trans-unit id="e49d24e044b41980e036610f5fc7a5e4be7955e6" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pg_relpages(regclass)&lt;/code&gt;, except that the target relation is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">Это то же самое, что и &lt;code&gt;pg_relpages(regclass)&lt;/code&gt; , за исключением того, что целевое отношение указано как TEXT. Эта функция пока сохраняется из-за обратной совместимости и будет исключена в некоторых будущих версиях.</target>
        </trans-unit>
        <trans-unit id="64132a4b93c0dbcab91f77d1ac58e1693be7385b" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pgstatindex(regclass)&lt;/code&gt;, except that the target index is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">Это то же самое, что и &lt;code&gt;pgstatindex(regclass)&lt;/code&gt; , за исключением того, что целевой индекс указан как TEXT. Эта функция пока сохраняется из-за обратной совместимости и будет исключена в некоторых будущих версиях.</target>
        </trans-unit>
        <trans-unit id="54441c2148265c644b6e2c6b5762a5242346cb3d" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pgstattuple(regclass)&lt;/code&gt;, except that the target relation is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">Это то же самое, что и &lt;code&gt;pgstattuple(regclass)&lt;/code&gt; , за исключением того, что целевое отношение указано как TEXT. Эта функция пока сохраняется из-за обратной совместимости, и в некоторых будущих версиях она будет исключена.</target>
        </trans-unit>
        <trans-unit id="ece1f9875ce6ffc21558f8024d23103c3c5eb710" translate="yes" xml:space="preserve">
          <source>This is the same example using normalized ranking:</source>
          <target state="translated">Это тот же пример с использованием нормализованного рейтинга:</target>
        </trans-unit>
        <trans-unit id="b095631465e3260d63a74afe0d97ae2d96edf684" translate="yes" xml:space="preserve">
          <source>This is the same query as above, but we added a &lt;code&gt;LIMIT&lt;/code&gt; so that not all the rows need be retrieved, and the planner changed its mind about what to do. Notice that the total cost and row count of the Index Scan node are shown as if it were run to completion. However, the Limit node is expected to stop after retrieving only a fifth of those rows, so its total cost is only a fifth as much, and that's the actual estimated cost of the query. This plan is preferred over adding a Limit node to the previous plan because the Limit could not avoid paying the startup cost of the bitmap scan, so the total cost would be something over 25 units with that approach.</source>
          <target state="translated">Это тот же запрос, что и выше, но мы добавили &lt;code&gt;LIMIT&lt;/code&gt; , чтобы не все строки нужно было извлекать, и планировщик передумал, что делать. Обратите внимание, что общая стоимость и количество строк узла сканирования индекса отображаются так, как если бы он был выполнен до конца. Однако ожидается, что узел Limit остановится после получения только пятой части этих строк, поэтому его общая стоимость составляет только пятую часть от стоимости, и это фактическая расчетная стоимость запроса. Этот план предпочтительнее добавления узла Limit к предыдущему плану, потому что Limit не может избежать оплаты начальных затрат на сканирование растрового изображения, поэтому общая стоимость при таком подходе будет более 25 единиц.</target>
        </trans-unit>
        <trans-unit id="94cb90e2972cc12877867d7980fc980b09691ec3" translate="yes" xml:space="preserve">
          <source>This is transformed by the parser to effectively become:</source>
          <target state="translated">Это трансформируется парсером,чтобы эффективно стать:</target>
        </trans-unit>
        <trans-unit id="a05aa8321906cf1c74f9a81ad06926d222bf1181" translate="yes" xml:space="preserve">
          <source>This is used to specify that the foreign-data wrapper should no longer have a handler function.</source>
          <target state="translated">Это используется для того,чтобы указать,что обертка иностранных данных не должна больше иметь функцию обработчика.</target>
        </trans-unit>
        <trans-unit id="d0dd5b48b4b716a9453020ad47edd41a0fc5866a" translate="yes" xml:space="preserve">
          <source>This is used to specify that the foreign-data wrapper should no longer have a validator function.</source>
          <target state="translated">Это используется для того,чтобы указать,что в обертке посторонних данных больше не должна быть функции валидатора.</target>
        </trans-unit>
        <trans-unit id="d30d7211e06d7778bc4cd17adf8c8ca724a370e3" translate="yes" xml:space="preserve">
          <source>This is what you are most likely to get if you succeed in contacting the server, but it does not want to talk to you. As the message suggests, the server refused the connection request because it found no matching entry in its &lt;code&gt;pg_hba.conf&lt;/code&gt; configuration file.</source>
          <target state="translated">Это то, что вы, скорее всего, получите, если вам удастся связаться с сервером, но он не хочет с вами разговаривать. Как следует из сообщения, сервер отклонил запрос на соединение, поскольку не нашел соответствующей записи в своем &lt;code&gt;pg_hba.conf&lt;/code&gt; конфигурации pg_hba.conf .</target>
        </trans-unit>
        <trans-unit id="fa56032fee9f040556b310dd23691f09946834cc" translate="yes" xml:space="preserve">
          <source>This is wrong since it is not clear which child table the key value 200 belongs in.</source>
          <target state="translated">Это неправильно,так как неясно,к какой дочерней таблице принадлежит ключевое значение 200.</target>
        </trans-unit>
        <trans-unit id="0515e31998ba6bb73d0ddae64599b98492334cc8" translate="yes" xml:space="preserve">
          <source>This is, subtract the null fraction from one for each of the relations, and divide by the maximum of the numbers of distinct values. The number of rows that the join is likely to emit is calculated as the cardinality of the Cartesian product of the two inputs, multiplied by the selectivity:</source>
          <target state="translated">Это-вычитание нулевой доли из единицы для каждого из соотношений и деление на максимум чисел различных значений.Количество строк,которые может испустить соединение,вычисляется как кардинальность декартового произведения двух входов,умноженная на селективность:</target>
        </trans-unit>
        <trans-unit id="1465b8af61e8c0e09acc4cea2d200fe28f10de58" translate="yes" xml:space="preserve">
          <source>This key is always present on the last line of the backup manifest file. The associated value is a SHA256 checksum of all the preceding lines. We use a fixed checksum method here to make it possible for clients to do incremental parsing of the manifest. While a SHA256 checksum is significantly more expensive than a CRC32C checksum, the manifest should normally be small enough that the extra computation won't matter very much.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f72ee86e21efe6631404a3bf422fe90ce0b7b5" translate="yes" xml:space="preserve">
          <source>This key word is ignored.</source>
          <target state="translated">Это ключевое слово игнорируется.</target>
        </trans-unit>
        <trans-unit id="ccf5892ae182b1129c89233a93f9d2dff22e3a50" translate="yes" xml:space="preserve">
          <source>This keyword immediately precedes the declaration of one or two relation names that provide access to the transition relations of the triggering statement.</source>
          <target state="translated">Это ключевое слово непосредственно предшествует объявлению одного или двух названий отношений,которые обеспечивают доступ к переходным отношениям триггерного заявления.</target>
        </trans-unit>
        <trans-unit id="e080950e112255fe2f612123624be96d15f65967" translate="yes" xml:space="preserve">
          <source>This latter equivalence does not hold exactly when more than two tables appear, because &lt;code&gt;JOIN&lt;/code&gt; binds more tightly than comma. For example &lt;code&gt;FROM T1 CROSS JOIN T2 INNER JOIN T3 ON condition&lt;/code&gt; is not the same as &lt;code&gt;FROM T1, T2 INNER JOIN T3 ON condition&lt;/code&gt; because the &lt;code&gt;condition&lt;/code&gt; can reference &lt;code&gt;T1&lt;/code&gt; in the first case but not the second.</source>
          <target state="translated">Эта последняя эквивалентность не выполняется точно, когда появляется более двух таблиц, потому что &lt;code&gt;JOIN&lt;/code&gt; связывает более жестко, чем запятая. Например, &lt;code&gt;FROM T1 CROSS JOIN T2 INNER JOIN T3 ON condition&lt;/code&gt; отличается от условия &lt;code&gt;FROM T1, T2 INNER JOIN T3 ON condition&lt;/code&gt; поскольку &lt;code&gt;condition&lt;/code&gt; может ссылаться на &lt;code&gt;T1&lt;/code&gt; в первом случае, но не во втором.</target>
        </trans-unit>
        <trans-unit id="4445598676898e3b5c713e7c5758010ce357bcd1" translate="yes" xml:space="preserve">
          <source>This level is different from Read Committed in that a query in a repeatable read transaction sees a snapshot as of the start of the first non-transaction-control statement in the &lt;em&gt;transaction&lt;/em&gt;, not as of the start of the current statement within the transaction. Thus, successive &lt;code&gt;SELECT&lt;/code&gt; commands within a &lt;em&gt;single&lt;/em&gt; transaction see the same data, i.e., they do not see changes made by other transactions that committed after their own transaction started.</source>
          <target state="translated">Этот уровень отличается от Read Committed в том, что запрос в повторяющейся транзакции чтения видит моментальный снимок с момента начала первого оператора , не связанного с управлением &lt;em&gt;транзакцией&lt;/em&gt; , в &lt;em&gt;транзакции&lt;/em&gt; , а не с начала текущего оператора в транзакции. Таким образом, последовательные команды &lt;code&gt;SELECT&lt;/code&gt; в рамках &lt;em&gt;одной&lt;/em&gt; транзакции видят одни и те же данные, т. Е. Они не видят изменений, внесенных другими транзакциями, которые были зафиксированы после начала их собственной транзакции.</target>
        </trans-unit>
        <trans-unit id="1b43064679af2be0d9a41eca78e98514d704b879" translate="yes" xml:space="preserve">
          <source>This level of integrity protection using Serializable transactions does not yet extend to hot standby mode (&lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;). Because of that, those using hot standby may want to use Repeatable Read and explicit locking on the master.</source>
          <target state="translated">Этот уровень защиты целостности с использованием сериализуемых транзакций еще не распространяется на режим горячего резервирования ( &lt;a href=&quot;hot-standby&quot;&gt;раздел 26.5&lt;/a&gt; ). Из-за этого те, кто использует горячий резерв, могут захотеть использовать повторяющееся чтение и явную блокировку на главном устройстве.</target>
        </trans-unit>
        <trans-unit id="81dc2dc08c39c5d2f9e3dd37d41f417f52e2a9fc" translate="yes" xml:space="preserve">
          <source>This limits the usefulness of the &lt;code&gt;passwordcheck&lt;/code&gt; module, because in that case it can only try to guess the password. For this reason, &lt;code&gt;passwordcheck&lt;/code&gt; is not recommended if your security requirements are high. It is more secure to use an external authentication method such as GSSAPI (see &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) than to rely on passwords within the database.</source>
          <target state="translated">Это ограничивает полезность модуля проверки &lt;code&gt;passwordcheck&lt;/code&gt; , поскольку в этом случае он может только попытаться угадать пароль. По этой причине &lt;code&gt;passwordcheck&lt;/code&gt; не рекомендуется, если ваши требования безопасности высоки. Более безопасно использовать внешний метод аутентификации, такой как GSSAPI (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Главу 20&lt;/a&gt; ), чем полагаться на пароли в базе данных.</target>
        </trans-unit>
        <trans-unit id="2789c3cbaef768ecab4d3f60f01f3d79af1c2ea9" translate="yes" xml:space="preserve">
          <source>This limits the usefulness of the &lt;code&gt;passwordcheck&lt;/code&gt; module, because in that case it can only try to guess the password. For this reason, &lt;code&gt;passwordcheck&lt;/code&gt; is not recommended if your security requirements are high. It is more secure to use an external authentication method such as GSSAPI (see &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) than to rely on passwords within the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5e3d694aabd0836b4470958df1839ef5142811" translate="yes" xml:space="preserve">
          <source>This may be more intuitive if you are using &lt;code&gt;pg_ctl&lt;/code&gt; for starting and stopping the server (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;), so that &lt;code&gt;pg_ctl&lt;/code&gt; would be the sole command you use for managing the database server instance.</source>
          <target state="translated">Это может быть более интуитивно понятным, если вы используете &lt;code&gt;pg_ctl&lt;/code&gt; для запуска и остановки сервера (см. &lt;a href=&quot;server-start&quot;&gt;Раздел 18.3&lt;/a&gt; ), так что &lt;code&gt;pg_ctl&lt;/code&gt; будет единственной командой, которую вы используете для управления экземпляром сервера базы данных.</target>
        </trans-unit>
        <trans-unit id="dfa0eac4f1545a9ddc55a9ceb07c6c1edc0186f1" translate="yes" xml:space="preserve">
          <source>This means that the server was not started, or it was not started where &lt;code&gt;createdb&lt;/code&gt; expected it. Again, check the installation instructions or consult the administrator.</source>
          <target state="translated">Это означает, что сервер не был запущен или был запущен не там, где &lt;code&gt;createdb&lt;/code&gt; ожидал createdb . Снова проверьте инструкции по установке или проконсультируйтесь с администратором.</target>
        </trans-unit>
        <trans-unit id="ded18d2e27ab98a47b51417474a9c5eeb41e0e40" translate="yes" xml:space="preserve">
          <source>This mechanism prevents unencrypted data from being read from the drives if the drives or the entire computer is stolen. This does not protect against attacks while the file system is mounted, because when mounted, the operating system provides an unencrypted view of the data. However, to mount the file system, you need some way for the encryption key to be passed to the operating system, and sometimes the key is stored somewhere on the host that mounts the disk.</source>
          <target state="translated">Этот механизм предотвращает считывание с дисков незашифрованных данных в случае кражи дисков или всего компьютера.Это не защищает от атак во время монтирования файловой системы,поскольку при монтировании операционная система предоставляет незашифрованные данные.Однако для монтирования файловой системы вам понадобится какой-то способ передачи ключа шифрования операционной системе,и иногда ключ хранится где-то на хосте,который монтирует диск.</target>
        </trans-unit>
        <trans-unit id="4541818976374d79642c0f93c22dbb7a713f72ad" translate="yes" xml:space="preserve">
          <source>This method consolidates information in the tree. Given a set of entries, this function generates a new index entry that represents all the given entries.</source>
          <target state="translated">Этот метод консолидирует информацию в дереве.Получив набор записей,эта функция генерирует новую запись индекса,которая представляет все данные записи.</target>
        </trans-unit>
        <trans-unit id="bc385497c58aec7319cf4002de1bf0ca8c1d4cff" translate="yes" xml:space="preserve">
          <source>This method of upgrading can be performed using the built-in logical replication facilities as well as using external logical replication systems such as pglogical, Slony, Londiste, and Bucardo.</source>
          <target state="translated">Этот метод обновления может быть выполнен с использованием встроенных средств логической репликации,а также с использованием внешних систем логической репликации,таких как pglogical,Slony,Londiste и Bucardo.</target>
        </trans-unit>
        <trans-unit id="82b2800cab107f6d05df0ae989ccbd67016a0ee1" translate="yes" xml:space="preserve">
          <source>This might cause zero, one, or many rows to be updated. It is not an error to attempt an update that does not match any rows.</source>
          <target state="translated">Это может привести к обновлению нуля,одной или многих строк.Попытка обновления не является ошибкой и не соответствует ни одной строке.</target>
        </trans-unit>
        <trans-unit id="264f830b811a6d6b8c58c36cb7fd806990f75f99" translate="yes" xml:space="preserve">
          <source>This might produce log output such as:</source>
          <target state="translated">Это может привести к выходу журнала,например:</target>
        </trans-unit>
        <trans-unit id="b493978753faced6c574bfe3060740f6644ad55e" translate="yes" xml:space="preserve">
          <source>This mode is provided for those who insist on it, but you are not necessarily encouraged to use it. In particular, if you mix SQL and meta-commands on a line the order of execution might not always be clear to the inexperienced user.</source>
          <target state="translated">Этот режим предусмотрен для тех,кто настаивает на нем,но вы не обязательно должны его использовать.В частности,если вы смешиваете SQL и мета-команды на строке,то порядок их выполнения может не всегда быть понятен неопытному пользователю.</target>
        </trans-unit>
        <trans-unit id="3d9301bd35d933ed8044c02b82956382914754a7" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;cube&lt;/code&gt; for representing multidimensional cubes.</source>
          <target state="translated">Этот модуль реализует &lt;code&gt;cube&lt;/code&gt; типа данных для представления многомерных кубов.</target>
        </trans-unit>
        <trans-unit id="f8e33606e025a4455156d4072de6e226ed4b94f7" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;ltree&lt;/code&gt; for representing labels of data stored in a hierarchical tree-like structure. Extensive facilities for searching through label trees are provided.</source>
          <target state="translated">Этот модуль реализует тип данных &lt;code&gt;ltree&lt;/code&gt; для представления меток данных, хранящихся в иерархической древовидной структуре. Предоставляются широкие возможности для поиска в деревьях этикеток.</target>
        </trans-unit>
        <trans-unit id="e72760dc721284c431bb3ba272b6dca3b540e0f1" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;seg&lt;/code&gt; for representing line segments, or floating point intervals. &lt;code&gt;seg&lt;/code&gt; can represent uncertainty in the interval endpoints, making it especially useful for representing laboratory measurements.</source>
          <target state="translated">Этот модуль реализует тип данных &lt;code&gt;seg&lt;/code&gt; для представления линейных сегментов, или с плавающей точкой интервалов. &lt;code&gt;seg&lt;/code&gt; может представлять неопределенность в конечных точках интервала, что делает его особенно полезным для представления лабораторных измерений.</target>
        </trans-unit>
        <trans-unit id="2dd33542f64474fba94a46e6b605e9b2299f1bab" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;hstore&lt;/code&gt; data type for storing sets of key/value pairs within a single PostgreSQL value. This can be useful in various scenarios, such as rows with many attributes that are rarely examined, or semi-structured data. Keys and values are simply text strings.</source>
          <target state="translated">Этот модуль реализует &lt;code&gt;hstore&lt;/code&gt; данных hstore для хранения наборов пар ключ / значение в одном значении PostgreSQL. Это может быть полезно в различных сценариях, таких как строки со многими атрибутами, которые редко проверяются, или частично структурированные данные. Ключи и значения - это просто текстовые строки.</target>
        </trans-unit>
        <trans-unit id="de0a2c458306a9179b18df224706a81701d0af82" translate="yes" xml:space="preserve">
          <source>This module integrates with SELinux to provide an additional layer of security checking above and beyond what is normally provided by PostgreSQL. From the perspective of SELinux, this module allows PostgreSQL to function as a user-space object manager. Each table or function access initiated by a DML query will be checked against the system security policy. This check is in addition to the usual SQL permissions checking performed by PostgreSQL.</source>
          <target state="translated">Этот модуль интегрируется с SELinux для обеспечения дополнительного уровня проверки безопасности сверх того,что обычно предоставляется PostgreSQL.С точки зрения SELinux,этот модуль позволяет PostgreSQL функционировать как менеджер объектов в пользовательском пространстве.Каждый доступ к таблице или функции,инициированный DML-запросом,будет проверяться на соответствие системной политике безопасности.Эта проверка является дополнением к обычной проверке прав доступа к SQL,выполняемой PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="f7043a9bb620afd5b48f848b5741b06bf97dc549" translate="yes" xml:space="preserve">
          <source>This module is considered &amp;ldquo;trusted&amp;rdquo;, that is, it can be installed by non-superusers who have &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269393947826c6d71fccaff13c4be9c80ca40682" translate="yes" xml:space="preserve">
          <source>This module is sponsored by Delta-Soft Ltd., Moscow, Russia.</source>
          <target state="translated">Данный модуль спонсируется ООО &quot;Дельта-Софт&quot;,Москва,Россия.</target>
        </trans-unit>
        <trans-unit id="4056f705daa3e3fdd49196fac6596ba7b2aa2807" translate="yes" xml:space="preserve">
          <source>This module was inspired by Garrett A. Wollman's &lt;code&gt;isbn_issn&lt;/code&gt; code.</source>
          <target state="translated">Этот модуль был вдохновлен кодом &lt;code&gt;isbn_issn&lt;/code&gt; Гарретта А. Воллмана .</target>
        </trans-unit>
        <trans-unit id="141bf6865546870a10c076189dfdbdeb9f73407a" translate="yes" xml:space="preserve">
          <source>This naming convention establishes a clear order in which these files will be loaded. This is important because only the last setting encountered for a particular parameter while the server is reading configuration files will be used. In this example, something set in &lt;code&gt;conf.d/02server.conf&lt;/code&gt; would override a value set in &lt;code&gt;conf.d/01memory.conf&lt;/code&gt;.</source>
          <target state="translated">Это соглашение об именах устанавливает четкий порядок, в котором эти файлы будут загружены. Это важно, потому что будет использоваться только последний параметр, обнаруженный для конкретного параметра, когда сервер читает файлы конфигурации. В этом примере значение, заданное в &lt;code&gt;conf.d/02server.conf&lt;/code&gt; , переопределит значение, установленное в &lt;code&gt;conf.d/01memory.conf&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
