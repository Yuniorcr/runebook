<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d2256e3896ead62f77d423e731b976ceab4c8935" translate="yes" xml:space="preserve">
          <source>Includes the required write-ahead log files (WAL files) in the backup. This will include all write-ahead logs generated during the backup. Unless the method &lt;code&gt;none&lt;/code&gt; is specified, it is possible to start a postmaster directly in the extracted directory without the need to consult the log archive, thus making this a completely standalone backup.</source>
          <target state="translated">Включает необходимые файлы журнала упреждающей записи (файлы WAL) в резервную копию. Это будет включать все журналы упреждающей записи, созданные во время резервного копирования. Если метод &lt;code&gt;none&lt;/code&gt; указан, можно запустить почтмейстер непосредственно в извлеченном каталоге без необходимости обращаться к архиву журнала, что делает его полностью автономным резервным копированием.</target>
        </trans-unit>
        <trans-unit id="bba52d333ab18b6249842b58dabb5827d455ee93" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;csvlog&lt;/code&gt; in the &lt;code&gt;log_destination&lt;/code&gt; list provides a convenient way to import log files into a database table. This option emits log lines in comma-separated-values (CSV) format, with these columns: time stamp with milliseconds, user name, database name, process ID, client host:port number, session ID, per-session line number, command tag, session start time, virtual transaction ID, regular transaction ID, error severity, SQLSTATE code, error message, error message detail, hint, internal query that led to the error (if any), character count of the error position therein, error context, user query that led to the error (if any and enabled by &lt;code&gt;log_min_error_statement&lt;/code&gt;), character count of the error position therein, location of the error in the PostgreSQL source code (if &lt;code&gt;log_error_verbosity&lt;/code&gt; is set to &lt;code&gt;verbose&lt;/code&gt;), and application name. Here is a sample table definition for storing CSV-format log output:</source>
          <target state="translated">Включение &lt;code&gt;csvlog&lt;/code&gt; в список &lt;code&gt;log_destination&lt;/code&gt; обеспечивает удобный способ импорта файлов журнала в таблицу базы данных. Эта опция генерирует строки журнала в формате значений, разделенных запятыми (CSV), со следующими столбцами: отметка времени с миллисекундами, имя пользователя, имя базы данных, идентификатор процесса, клиентский хост: номер порта, идентификатор сеанса, номер строки для каждого сеанса, команда тег, время начала сеанса, идентификатор виртуальной транзакции, идентификатор обычной транзакции, серьезность ошибки, код SQLSTATE, сообщение об ошибке, подробное описание сообщения об ошибке, подсказка, внутренний запрос, который привел к ошибке (если таковой имеется), количество символов позиции ошибки в нем, ошибка контекст, запрос пользователя, который привел к ошибке (если есть и разрешено &lt;code&gt;log_min_error_statement&lt;/code&gt; ), количество символов положения ошибки в нем, местоположение ошибки в исходном коде PostgreSQL (если для &lt;code&gt;log_error_verbosity&lt;/code&gt; задано значение &lt;code&gt;verbose&lt;/code&gt; ) и имя приложения. Вот пример определения таблицы для хранения вывода журнала в формате CSV:</target>
        </trans-unit>
        <trans-unit id="3277b28011c125843d31a46c71b92575dd21118e" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;csvlog&lt;/code&gt; in the &lt;code&gt;log_destination&lt;/code&gt; list provides a convenient way to import log files into a database table. This option emits log lines in comma-separated-values (CSV) format, with these columns: time stamp with milliseconds, user name, database name, process ID, client host:port number, session ID, per-session line number, command tag, session start time, virtual transaction ID, regular transaction ID, error severity, SQLSTATE code, error message, error message detail, hint, internal query that led to the error (if any), character count of the error position therein, error context, user query that led to the error (if any and enabled by &lt;code&gt;log_min_error_statement&lt;/code&gt;), character count of the error position therein, location of the error in the PostgreSQL source code (if &lt;code&gt;log_error_verbosity&lt;/code&gt; is set to &lt;code&gt;verbose&lt;/code&gt;), application name, and backend type. Here is a sample table definition for storing CSV-format log output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c47c86c8d425f70d8b2151c0d809c6c1813e865" translate="yes" xml:space="preserve">
          <source>Increase &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; and &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt;; this reduces the frequency of checkpoints, but increases the storage requirements of &lt;code&gt;/pg_wal&lt;/code&gt;.</source>
          <target state="translated">Увеличьте &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; и &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt; ; это снижает частоту контрольных точек, но увеличивает требования к хранилищу &lt;code&gt;/pg_wal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="491d088ee8f4f607e5e1e928bb9bf8875f9a361a" translate="yes" xml:space="preserve">
          <source>Increases the size of the cube by the specified radius &lt;code&gt;r&lt;/code&gt; in at least &lt;code&gt;n&lt;/code&gt; dimensions. If the radius is negative the cube is shrunk instead. All defined dimensions are changed by the radius &lt;code&gt;r&lt;/code&gt;. Lower-left coordinates are decreased by &lt;code&gt;r&lt;/code&gt; and upper-right coordinates are increased by &lt;code&gt;r&lt;/code&gt;. If a lower-left coordinate is increased to more than the corresponding upper-right coordinate (this can only happen when &lt;code&gt;r&lt;/code&gt; &amp;lt; 0) than both coordinates are set to their average. If &lt;code&gt;n&lt;/code&gt; is greater than the number of defined dimensions and the cube is being enlarged (&lt;code&gt;r&lt;/code&gt; &amp;gt; 0), then extra dimensions are added to make &lt;code&gt;n&lt;/code&gt; altogether; 0 is used as the initial value for the extra coordinates. This function is useful for creating bounding boxes around a point for searching for nearby points.</source>
          <target state="translated">Увеличивает размер куба на указанный радиус &lt;code&gt;r&lt;/code&gt; как минимум в &lt;code&gt;n&lt;/code&gt; измерениях. Если радиус отрицательный, куб вместо этого сжимается. Все заданные размеры изменены на радиус &lt;code&gt;r&lt;/code&gt; . Координаты левого нижнего угла уменьшаются на &lt;code&gt;r&lt;/code&gt; , а координаты правого верхнего угла увеличиваются на &lt;code&gt;r&lt;/code&gt; . Если нижняя левая координата увеличивается до значения, превышающего соответствующую верхнюю правую координату (это может произойти только при &lt;code&gt;r&lt;/code&gt; &amp;lt;0), то обе координаты устанавливаются на свое среднее значение. Если &lt;code&gt;n&lt;/code&gt; больше, чем количество определенных измерений, и куб увеличивается ( &lt;code&gt;r&lt;/code&gt; &amp;gt; 0), то добавляются дополнительные измерения, чтобы сделать &lt;code&gt;n&lt;/code&gt; все вместе; 0 используется как начальное значение для дополнительных координат. Эта функция полезна для создания ограничивающих рамок вокруг точки для поиска ближайших точек.</target>
        </trans-unit>
        <trans-unit id="a6f168056ed493abc9b82ee898684e7de650c44e" translate="yes" xml:space="preserve">
          <source>Increases the size of the cube by the specified radius &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; in at least &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; dimensions. If the radius is negative the cube is shrunk instead. All defined dimensions are changed by the radius &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt;. Lower-left coordinates are decreased by &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; and upper-right coordinates are increased by &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt;. If a lower-left coordinate is increased to more than the corresponding upper-right coordinate (this can only happen when &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; &amp;lt; 0) than both coordinates are set to their average. If &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; is greater than the number of defined dimensions and the cube is being enlarged (&lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; &amp;gt; 0), then extra dimensions are added to make &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; altogether; 0 is used as the initial value for the extra coordinates. This function is useful for creating bounding boxes around a point for searching for nearby points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c0442f572435bb8c34c7304c10e685fc7ac4b3" translate="yes" xml:space="preserve">
          <source>Increment an integer, making use of an argument name, in PL/pgSQL:</source>
          <target state="translated">Измените целое число,используя имя аргумента,в PL/pgSQL:</target>
        </trans-unit>
        <trans-unit id="d5e6a1521753325e1f10aefe90f61ed951c60b45" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, and record the whole updated row along with current time in a log table:</source>
          <target state="translated">Дополните счет продаж продавца,который управляет учетной записью корпорации Acme,и запишите всю обновленную строку вместе с текущим временем в таблицу журнала:</target>
        </trans-unit>
        <trans-unit id="016cda80a0391be204d7aeb8cae7ec5708da297f" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, using the &lt;code&gt;FROM&lt;/code&gt; clause syntax:</source>
          <target state="translated">Увеличьте количество продаж продавца, который управляет учетной записью Acme Corporation, используя синтаксис предложения &lt;code&gt;FROM&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a4352e3ce439f57ce839ae2217c61914bab2036" translate="yes" xml:space="preserve">
          <source>Increment value of the sequence</source>
          <target state="translated">Увеличение значения последовательности</target>
        </trans-unit>
        <trans-unit id="0baba858aebf401bd8fc5997be9e51de35556b66" translate="yes" xml:space="preserve">
          <source>Independently of &lt;code&gt;max_wal_size&lt;/code&gt;, &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1 most recent WAL files are kept at all times. Also, if WAL archiving is used, old segments can not be removed or recycled until they are archived. If WAL archiving cannot keep up with the pace that WAL is generated, or if &lt;code&gt;archive_command&lt;/code&gt; fails repeatedly, old WAL files will accumulate in &lt;code&gt;pg_wal&lt;/code&gt; until the situation is resolved. A slow or failed standby server that uses a replication slot will have the same effect (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;).</source>
          <target state="translated">Независимо от &lt;code&gt;max_wal_size&lt;/code&gt; , &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1 самые последние файлы WAL хранятся всегда. Кроме того, если используется архивирование WAL, старые сегменты не могут быть удалены или переработаны, пока они не заархивированы. Если архивирование WAL не успевает за темпами генерации WAL или если &lt;code&gt;archive_command&lt;/code&gt; неоднократно дает сбой, старые файлы WAL будут накапливаться в &lt;code&gt;pg_wal&lt;/code&gt; , пока ситуация не будет разрешена. Медленный или отказавший резервный сервер, использующий слот репликации, будет иметь такой же эффект (см. &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Раздел 26.2.6&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac2969c439badc170cf6b29ba051a5583d528c7a" translate="yes" xml:space="preserve">
          <source>Independently of &lt;code&gt;max_wal_size&lt;/code&gt;, the most recent &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt; megabytes of WAL files plus one additional WAL file are kept at all times. Also, if WAL archiving is used, old segments can not be removed or recycled until they are archived. If WAL archiving cannot keep up with the pace that WAL is generated, or if &lt;code&gt;archive_command&lt;/code&gt; fails repeatedly, old WAL files will accumulate in &lt;code&gt;pg_wal&lt;/code&gt; until the situation is resolved. A slow or failed standby server that uses a replication slot will have the same effect (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdcb0b3a79497de0963b2de12972bc29faac57b" translate="yes" xml:space="preserve">
          <source>Index (relation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7301cd0f493014b9a0674c1f9a1816640cb05f" translate="yes" xml:space="preserve">
          <source>Index Access Method: Basic API Structure for Indexes</source>
          <target state="translated">Метод индексного доступа:Базовая структура API для индексов</target>
        </trans-unit>
        <trans-unit id="f78511aae833dc82a57faebbdb5be9d2b811c5ba" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Access Method Functions</source>
          <target state="translated">Метод индексного доступа:Функции метода доступа к индексам</target>
        </trans-unit>
        <trans-unit id="67844b6b086746a2175da308cd69b3a3322c8f8a" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Cost Estimation Functions</source>
          <target state="translated">Метод индексного доступа:Функции оценки стоимости индекса</target>
        </trans-unit>
        <trans-unit id="ed0cf00558f5f3be604eab3a16ea9444c680fa41" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Locking Considerations</source>
          <target state="translated">Метод индексного доступа:Учет блокировки индекса</target>
        </trans-unit>
        <trans-unit id="23bdd1e7799979f5184920ab721afb82ac1bc5bc" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Scanning</source>
          <target state="translated">Метод индексного доступа:Сканирование индексов</target>
        </trans-unit>
        <trans-unit id="1b3aa3923e02606cc47b91d3beb9e0be0fcf698b" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Uniqueness Checks</source>
          <target state="translated">Метод индексного доступа:Уникальность индекса Проверки</target>
        </trans-unit>
        <trans-unit id="5ec145b22f866c8350ec8fde02299443b400da81" translate="yes" xml:space="preserve">
          <source>Index Storage Parameters</source>
          <target state="translated">Параметры хранения индексов</target>
        </trans-unit>
        <trans-unit id="4e09dcdaddb1a9558501d09366dc72f53b93938b" translate="yes" xml:space="preserve">
          <source>Index Types</source>
          <target state="translated">Типы индексов</target>
        </trans-unit>
        <trans-unit id="f19762ba6cf5f18bb6bfea402f2aaa7605c7a6d9" translate="yes" xml:space="preserve">
          <source>Index access method operator class is for</source>
          <target state="translated">Оператор метода доступа к индексам класс оператора для</target>
        </trans-unit>
        <trans-unit id="aa270689b00c3b50db9d0d870a5d8e7c14e30f9d" translate="yes" xml:space="preserve">
          <source>Index access method operator family is for</source>
          <target state="translated">Оператор метода доступа к индексам семейство операторов для</target>
        </trans-unit>
        <trans-unit id="7f91618c60dc341c28ac1a80ab4b5e00b3b36fa4" translate="yes" xml:space="preserve">
          <source>Index access method specific data. Different methods store different data. Empty in ordinary tables.</source>
          <target state="translated">Данные по методу доступа к индексам.Разные методы хранят разные данные.Пустые в обычных таблицах.</target>
        </trans-unit>
        <trans-unit id="31a6a8a40d18f374bed6deff03fed3f43968a4d7" translate="yes" xml:space="preserve">
          <source>Index access methods must handle concurrent updates of the index by multiple processes. The core PostgreSQL system obtains &lt;code&gt;AccessShareLock&lt;/code&gt; on the index during an index scan, and &lt;code&gt;RowExclusiveLock&lt;/code&gt; when updating the index (including plain &lt;code&gt;VACUUM&lt;/code&gt;). Since these lock types do not conflict, the access method is responsible for handling any fine-grained locking it might need. An exclusive lock on the index as a whole will be taken only during index creation, destruction, or &lt;code&gt;REINDEX&lt;/code&gt;.</source>
          <target state="translated">Методы доступа к индексу должны обрабатывать одновременные обновления индекса несколькими процессами. Базовая система PostgreSQL получает &lt;code&gt;AccessShareLock&lt;/code&gt; для индекса во время сканирования индекса и &lt;code&gt;RowExclusiveLock&lt;/code&gt; при обновлении индекса (включая простой &lt;code&gt;VACUUM&lt;/code&gt; ). Поскольку эти типы блокировок не конфликтуют, метод доступа отвечает за обработку любой тонкой блокировки, которая может потребоваться. Исключительная блокировка индекса в целом будет принята только во время создания, уничтожения или &lt;code&gt;REINDEX&lt;/code&gt; индекса .</target>
        </trans-unit>
        <trans-unit id="411152cefe270170bdbd707fa7bb100f59936ac0" translate="yes" xml:space="preserve">
          <source>Index definition (a reconstructed &lt;code&gt;CREATE INDEX&lt;/code&gt; command)</source>
          <target state="translated">Определение индекса (реконструированная команда &lt;code&gt;CREATE INDEX&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fdde6507a698ff6040826cbe9781cf5e41a80789" translate="yes" xml:space="preserve">
          <source>Index expressions are relatively expensive to maintain, because the derived expression(s) must be computed for each row upon insertion and whenever it is updated. However, the index expressions are &lt;em&gt;not&lt;/em&gt; recomputed during an indexed search, since they are already stored in the index. In both examples above, the system sees the query as just &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; and so the speed of the search is equivalent to any other simple index query. Thus, indexes on expressions are useful when retrieval speed is more important than insertion and update speed.</source>
          <target state="translated">Индексные выражения относительно дороги в обслуживании, потому что производные выражения должны вычисляться для каждой строки при вставке и всякий раз, когда она обновляется. Однако выражения индекса &lt;em&gt;не&lt;/em&gt; вычисляются повторно во время поиска по индексу, поскольку они уже сохранены в индексе. В обоих приведенных выше примерах система видит запрос как просто &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; и поэтому скорость поиска эквивалентна любому другому простому запросу индекса. Таким образом, индексы для выражений полезны, когда скорость извлечения более важна, чем скорость вставки и обновления.</target>
        </trans-unit>
        <trans-unit id="137221474050ee597f18d1d2a9bf5cc8c57090b0" translate="yes" xml:space="preserve">
          <source>Index-Only Scans and Covering Indexes</source>
          <target state="translated">Сканирование только по индексам и покрытие индексов</target>
        </trans-unit>
        <trans-unit id="fa0d50739fe1e6ebbc17d0c70d81ac62acbaf58d" translate="yes" xml:space="preserve">
          <source>Indexable Operators</source>
          <target state="translated">Индексируемые операторы</target>
        </trans-unit>
        <trans-unit id="69a6a1b0f4ad606d0ae7c258868e72a29f0777ef" translate="yes" xml:space="preserve">
          <source>Indexed Data Type</source>
          <target state="translated">Индексированный тип данных</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="0b07dd7c1e4d64ef5d5ba2561b6e35701b2906b6" translate="yes" xml:space="preserve">
          <source>Indexes and foreign key constraints apply to single tables and not to their inheritance children, hence they have some &lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;caveats&lt;/a&gt; to be aware of.</source>
          <target state="translated">Ограничения индексов и внешнего ключа применяются к отдельным таблицам, а не к их потомкам наследования, поэтому у них есть некоторые &lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;предостережения,&lt;/a&gt; о которых следует помнить.</target>
        </trans-unit>
        <trans-unit id="e15643bd769ae7fcf2c35c27f2ab1732e1a9d5c1" translate="yes" xml:space="preserve">
          <source>Indexes can also be used to enforce uniqueness of a column's value, or the uniqueness of the combined values of more than one column.</source>
          <target state="translated">Индексы могут также использоваться для обеспечения уникальности значения столбца или уникальности комбинированных значений более чем одного столбца.</target>
        </trans-unit>
        <trans-unit id="94aa2c39061285d86804bbba30d7e52d694f4564" translate="yes" xml:space="preserve">
          <source>Indexes can also benefit &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands with search conditions. Indexes can moreover be used in join searches. Thus, an index defined on a column that is part of a join condition can also significantly speed up queries with joins.</source>
          <target state="translated">Индексы также могут использоваться командами &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; с условиями поиска. Кроме того, индексы можно использовать при поиске соединений. Таким образом, индекс, определенный для столбца, который является частью условия соединения, также может значительно ускорить запросы с соединениями.</target>
        </trans-unit>
        <trans-unit id="68c16c2b91128e4f41955f5ff646c75a169f39bb" translate="yes" xml:space="preserve">
          <source>Indexes can be used by simple index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, and the optimizer. In a bitmap scan the output of several indexes can be combined via AND or OR rules, so it is difficult to associate individual heap row fetches with specific indexes when a bitmap scan is used. Therefore, a bitmap scan increments the &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_read&lt;/code&gt; count(s) for the index(es) it uses, and it increments the &lt;code&gt;pg_stat_all_tables&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt; count for the table, but it does not affect &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt;. The optimizer also accesses indexes to check for supplied constants whose values are outside the recorded range of the optimizer statistics because the optimizer statistics might be stale.</source>
          <target state="translated">Индексы могут использоваться при простом сканировании индекса, сканировании индекса &amp;laquo;растрового изображения&amp;raquo; и в оптимизаторе. При сканировании растрового изображения вывод нескольких индексов может быть объединен с помощью правил И или ИЛИ, поэтому при сканировании растрового изображения трудно связать выборку отдельных строк кучи с конкретными индексами. Следовательно, сканирование по битовой карте увеличивает &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; . &lt;code&gt;idx_tup_read&lt;/code&gt; счетчиков для используемых индексов и увеличивает &lt;code&gt;pg_stat_all_tables&lt;/code&gt; . &lt;code&gt;idx_tup_fetch&lt;/code&gt; для таблицы, но не влияет на &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; . &lt;code&gt;idx_tup_fetch&lt;/code&gt; . Оптимизатор также обращается к индексам для проверки предоставленных констант, значения которых выходят за пределы записанного диапазона статистики оптимизатора, поскольку статистика оптимизатора может быть устаревшей.</target>
        </trans-unit>
        <trans-unit id="fe87987c8ecb565fcb320eb91d374313994665e6" translate="yes" xml:space="preserve">
          <source>Indexes can even concatenate columns:</source>
          <target state="translated">Индексы могут даже конкатенировать колонки:</target>
        </trans-unit>
        <trans-unit id="615b513b7bf8866eb4478326c86bda00dbb8833c" translate="yes" xml:space="preserve">
          <source>Indexes can not have multiple inheritance, since they can only inherit when using declarative partitioning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fee069b42975ecfc0bf523b8f7af8b0cf11b9bb" translate="yes" xml:space="preserve">
          <source>Indexes, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;UNIQUE&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints on the original table will be created on the new table. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named. (This behavior avoids possible duplicate-name failures for the new indexes.)</source>
          <target state="translated">Индексы, &lt;code&gt;PRIMARY KEY&lt;/code&gt; , &lt;code&gt;UNIQUE&lt;/code&gt; и &lt;code&gt;EXCLUDE&lt;/code&gt; для исходной таблицы будут созданы в новой таблице. Имена для новых индексов и ограничений выбираются в соответствии с правилами по умолчанию, независимо от того, как были названы оригиналы. (Такое поведение позволяет избежать возможных сбоев повторяющихся имен для новых индексов.)</target>
        </trans-unit>
        <trans-unit id="64accc47bb83e575341063f3658e1d1e7d2113e1" translate="yes" xml:space="preserve">
          <source>Indexing for &amp;ldquo;float ranges&amp;rdquo;</source>
          <target state="translated">Индексация &amp;laquo;диапазонов с плавающей запятой&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="d165c70b9c7feb2704f3285d8d27cbb3a58c3a91" translate="yes" xml:space="preserve">
          <source>Indexing for multidimensional cubes</source>
          <target state="translated">Индексирование для многомерных кубов</target>
        </trans-unit>
        <trans-unit id="b91462559e819269659f845aa92e7f5041a36896" translate="yes" xml:space="preserve">
          <source>Indexing for tree-like structures</source>
          <target state="translated">Индексирование для древовидных структур</target>
        </trans-unit>
        <trans-unit id="610e7a10148c311249b3bbd57cd9833a58b8714d" translate="yes" xml:space="preserve">
          <source>Indicates how the cast is performed. &lt;code&gt;f&lt;/code&gt; means that the function specified in the &lt;code&gt;castfunc&lt;/code&gt; field is used. &lt;code&gt;i&lt;/code&gt; means that the input/output functions are used. &lt;code&gt;b&lt;/code&gt; means that the types are binary-coercible, thus no conversion is required.</source>
          <target state="translated">Указывает, как выполняется приведение. &lt;code&gt;f&lt;/code&gt; означает, что используется функция, указанная в поле &lt;code&gt;castfunc&lt;/code&gt; . &lt;code&gt;i&lt;/code&gt; означает, что используются функции ввода / вывода. &lt;code&gt;b&lt;/code&gt; означает, что типы двоично-приводимые, поэтому преобразование не требуется.</target>
        </trans-unit>
        <trans-unit id="c8e4b2b3e4731dd79133b34f9f993d48a44e51e7" translate="yes" xml:space="preserve">
          <source>Indicates not to recurse creating indexes on partitions, if the table is partitioned. The default is to recurse.</source>
          <target state="translated">Показывает не повторять создание индексов на разделах,если таблица разбита на разделы.По умолчанию используется повторное создание индексов.</target>
        </trans-unit>
        <trans-unit id="c934b82eb6dc908677ffc76af2256f04ecf84094" translate="yes" xml:space="preserve">
          <source>Indicates role to which this role will be added immediately as a new member. Multiple roles to which this role will be added as a member can be specified by writing multiple &lt;code&gt;-g&lt;/code&gt; switches.</source>
          <target state="translated">Указывает роль, к которой эта роль будет немедленно добавлена ​​в качестве нового участника. Несколько ролей, к которым эта роль будет добавлена ​​в качестве члена, можно указать, написав несколько ключей &lt;code&gt;-g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bba08c6b0be5e0b5de1c5dd077ea609cb92072f0" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">Указывает, что функция принимает любой тип данных массива (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Подраздел 37.2.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eeaf761f967f3ec9a6c653153e34b899c18b98b6" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af32ec08da7863e95ebf028210e1919471adfda" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2f7fb68c39785b7c61d53497fe5cf5bd1568bd" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">Указывает, что функция принимает любой тип данных (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Подраздел 37.2.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3dcc0fc3f371079dcd8cbcbfff1f3968fc460f48" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be49c718755809ee9277f9ab09722e8b9a182ec" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f46df9b9c0db2bde38cb75f71fb9153783611d4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any enum data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;).</source>
          <target state="translated">Указывает, что функция принимает любой тип данных enum (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Раздел 37.2.5&lt;/a&gt; и &lt;a href=&quot;datatype-enum&quot;&gt;Раздел 8.7&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8fccdb3ecc85b5b077cee3a13e6c3bbb009743e7" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any enum data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bd42bb48f3fa999abde7cc36ebf5b6f5ac5c8d" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any input data type.</source>
          <target state="translated">Указывает,что функция принимает любой тип входных данных.</target>
        </trans-unit>
        <trans-unit id="4e38b6c5ff227f9cc8a0278ba387f1ee54390caf" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">Указывает, что функция принимает любой тип данных, не являющийся массивом (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Подраздел 37.2.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd2da16b809ae60477ecb6e3765117401057fff5" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67aeb7edc5c822452d3c7740dc6c35d51323bcb" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d9465560cf78be64ef72d2e6367284edb5463f" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="translated">Указывает, что функция принимает любой тип данных диапазона (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Раздел 37.2.5&lt;/a&gt; и &lt;a href=&quot;rangetypes&quot;&gt;Раздел 8.17&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="035276077ea5e5ea9bea1d81e40e660b2873cd5b" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af7c5b9171c91763d28f65430601eb54e6589ed" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e158daaace8eac02a3ccf2b3b765596ccc91e4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a null-terminated C string.</source>
          <target state="translated">Указывает на то,что функция принимает или возвращает нулевую C-строку.</target>
        </trans-unit>
        <trans-unit id="54761c9282026639ec5c8540cc79ebf4ba11462a" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a server-internal data type.</source>
          <target state="translated">Указывает,что функция принимает или возвращает внутренний тип данных сервера.</target>
        </trans-unit>
        <trans-unit id="89dc9ca8b4db982fb593e3e44e25350b25d82bea" translate="yes" xml:space="preserve">
          <source>Indicates that a function returns no value.</source>
          <target state="translated">Указывает на то,что функция не возвращает никаких значений.</target>
        </trans-unit>
        <trans-unit id="7d75608f451e28beb0733c0d6c1c5d589e592ee3" translate="yes" xml:space="preserve">
          <source>Indicates that data retrieved from the cursor should be unaffected by updates to the table(s) underlying the cursor that occur after the cursor is created. In PostgreSQL, this is the default behavior; so this key word has no effect and is only accepted for compatibility with the SQL standard.</source>
          <target state="translated">Указывает на то,что данные,извлеченные из курсора,не должны затрагиваться обновлениями таблицы (таблиц),лежащей под курсором,которые происходят после создания курсора.В PostgreSQL это поведение является поведением по умолчанию;поэтому это ключевое слово не имеет никакого эффекта и принимается только для совместимости со стандартом SQL.</target>
        </trans-unit>
        <trans-unit id="95cdb06015680fe563a8aa9dd541903933a11ad2" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in any context.</source>
          <target state="translated">Указывает на то,что кастинг может быть вызван неявно в любом контексте.</target>
        </trans-unit>
        <trans-unit id="0390d2ebad5b8b8a226d9901a34d76e7770b71be" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in assignment contexts.</source>
          <target state="translated">Указывает на то,что кастинг может быть вызван неявно в контекстах присваивания.</target>
        </trans-unit>
        <trans-unit id="3840502dacc9907db02fe8896c3bfeafcfa9e633" translate="yes" xml:space="preserve">
          <source>Indicates that the cast is an I/O conversion cast, performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type.</source>
          <target state="translated">Указывает на то,что приведение является преобразованием ввода/вывода,выполняемым вызовом выходной функции типа исходных данных и передачей результирующей строки во входную функцию типа исходных данных.</target>
        </trans-unit>
        <trans-unit id="01e358ef1ee49de64b80b741226b8d05654b1eb9" translate="yes" xml:space="preserve">
          <source>Indicates that the source type is binary-coercible to the target type, so no function is required to perform the cast.</source>
          <target state="translated">Указывает на то,что тип источника является двоично-смешивающимся с типом цели,поэтому для выполнения приведения не требуется никакой функции.</target>
        </trans-unit>
        <trans-unit id="4f0180a78d5a13ddfb20f673dc1c1a653a0dbf1c" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a hash join.</source>
          <target state="translated">Показывает,что этот оператор может поддерживать хэш-соединение.</target>
        </trans-unit>
        <trans-unit id="7f8be265aa5381d640f66bb0fbb51979d62652fa" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a merge join.</source>
          <target state="translated">Показывает,что этот оператор может поддерживать слияние.</target>
        </trans-unit>
        <trans-unit id="88982366e025d973d9fdcbf523cd379f45035c49" translate="yes" xml:space="preserve">
          <source>Indicates what contexts the cast can be invoked in. &lt;code&gt;e&lt;/code&gt; means only as an explicit cast (using &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; syntax). &lt;code&gt;a&lt;/code&gt; means implicitly in assignment to a target column, as well as explicitly. &lt;code&gt;i&lt;/code&gt; means implicitly in expressions, as well as the other cases.</source>
          <target state="translated">Указывает, в каких контекстах может быть вызвано приведение. &lt;code&gt;e&lt;/code&gt; означает только явное приведение (с использованием синтаксиса &lt;code&gt;CAST&lt;/code&gt; или &lt;code&gt;::&lt;/code&gt; :). &lt;code&gt;a&lt;/code&gt; означает неявное присваивание целевому столбцу, а также явно. &lt;code&gt;i&lt;/code&gt; означает неявно в выражениях, а также в других случаях.</target>
        </trans-unit>
        <trans-unit id="e1335256027d947c4a5d7cbed371240e3fa5176d" translate="yes" xml:space="preserve">
          <source>Indirect TOAST pointers simply point at a non-indirect varlena value stored somewhere in memory. This case was originally created merely as a proof of concept, but it is currently used during logical decoding to avoid possibly having to create physical tuples exceeding 1 GB (as pulling all out-of-line field values into the tuple might do). The case is of limited use since the creator of the pointer datum is entirely responsible that the referenced data survives for as long as the pointer could exist, and there is no infrastructure to help with this.</source>
          <target state="translated">Косвенные указатели TOAST просто указывают на непрямое значение varlena,хранящееся где-то в памяти.Изначально этот случай был создан просто как доказательство концепции,но в настоящее время он используется при логическом декодировании,чтобы избежать возможного создания физических кортежей,превышающих 1 ГБ (как это может сделать вытягивание всех значений внестрочных полей в кортеж).Случай ограниченного использования,так как создатель данных указателя несет полную ответственность за то,чтобы данные,на которые ссылаются,сохранялись до тех пор,пока указатель может существовать,и нет никакой инфраструктуры,которая могла бы помочь в этом.</target>
        </trans-unit>
        <trans-unit id="749d2a57690cd8938d324488d8b64d9826db075f" translate="yes" xml:space="preserve">
          <source>Individual leaf tuples and inner tuples must fit on a single index page (8kB by default). Therefore, when indexing values of variable-length data types, long values can only be supported by methods such as radix trees, in which each level of the tree includes a prefix that is short enough to fit on a page, and the final leaf level includes a suffix also short enough to fit on a page. The operator class should set &lt;code&gt;longValuesOK&lt;/code&gt; to true only if it is prepared to arrange for this to happen. Otherwise, the SP-GiST core will reject any request to index a value that is too large to fit on an index page.</source>
          <target state="translated">Отдельные конечные кортежи и внутренние кортежи должны помещаться на одной странице индекса (по умолчанию 8 КБ). Следовательно, при индексировании значений типов данных переменной длины длинные значения могут поддерживаться только такими методами, как основание системы счисления, в которых каждый уровень дерева включает префикс, достаточно короткий, чтобы поместиться на странице, и конечный конечный уровень. включает суффикс, также достаточно короткий, чтобы поместиться на странице. Класс оператора должен установить для &lt;code&gt;longValuesOK&lt;/code&gt; значение true только в том случае, если он подготовлен для этого. В противном случае ядро ​​SP-GiST отклонит любой запрос на индексирование значения, слишком большого для размещения на странице индекса.</target>
        </trans-unit>
        <trans-unit id="60182f316e9821f12c8e613a5f4a51ed0303f8be" translate="yes" xml:space="preserve">
          <source>Individual partitions are linked to the partitioned table with inheritance behind-the-scenes; however, it is not possible to use some of the generic features of inheritance (discussed below) with declaratively partitioned tables or their partitions. For example, a partition cannot have any parents other than the partitioned table it is a partition of, nor can a regular table inherit from a partitioned table making the latter its parent. That means partitioned tables and their partitions do not participate in inheritance with regular tables. Since a partition hierarchy consisting of the partitioned table and its partitions is still an inheritance hierarchy, all the normal rules of inheritance apply as described in &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; with some exceptions, most notably:</source>
          <target state="translated">Отдельные разделы связаны с многораздельной таблицей с незаметным наследованием; однако невозможно использовать некоторые из общих функций наследования (обсуждаемых ниже) с декларативно секционированными таблицами или их секциями. Например, у раздела не может быть никаких родителей, кроме многораздельной таблицы, частью которой она является, и обычная таблица не может наследовать от многораздельной таблицы, делая последнюю своей родительской. Это означает, что секционированные таблицы и их секции не участвуют в наследовании с обычными таблицами. Поскольку иерархия разделов, состоящая из многораздельной таблицы и ее разделов, по-прежнему является иерархией наследования, применяются все обычные правила наследования, как описано в &lt;a href=&quot;ddl-inherit&quot;&gt;Разделе 5.10,&lt;/a&gt; с некоторыми исключениями, в первую очередь:</target>
        </trans-unit>
        <trans-unit id="e8da164cdd479d1b5a117c145f315adf86e0bbc9" translate="yes" xml:space="preserve">
          <source>Individual state files in &lt;code&gt;pg_twophase&lt;/code&gt; are protected by CRC-32.</source>
          <target state="translated">Отдельные файлы состояний в &lt;code&gt;pg_twophase&lt;/code&gt; защищены CRC-32.</target>
        </trans-unit>
        <trans-unit id="10dbe9c3ced898e42dd1884b1b4e3f1dc8f408e3" translate="yes" xml:space="preserve">
          <source>Inexact means that some values cannot be converted exactly to the internal format and are stored as approximations, so that storing and retrieving a value might show slight discrepancies. Managing these errors and how they propagate through calculations is the subject of an entire branch of mathematics and computer science and will not be discussed here, except for the following points:</source>
          <target state="translated">Неточность означает,что некоторые значения не могут быть точно преобразованы во внутренний формат и хранятся в виде аппроксимаций,так что при хранении и извлечении значения могут наблюдаться небольшие расхождения.Управление этими ошибками и то,как они распространяются посредством вычислений,является предметом изучения целой отрасли математики и информатики и не будет обсуждаться здесь,за исключением следующих пунктов:</target>
        </trans-unit>
        <trans-unit id="4d7d8b040e79c74720337a20e81bb860b0667a32" translate="yes" xml:space="preserve">
          <source>Infinite line</source>
          <target state="translated">Бесконечная линия</target>
        </trans-unit>
        <trans-unit id="6f943c69647f371e6d494b5d1c35aba8e91e86d6" translate="yes" xml:space="preserve">
          <source>Information about text search configuration objects can be obtained in psql using a set of commands:</source>
          <target state="translated">Информацию об объектах настройки текстового поиска можно получить в psql с помощью набора команд:</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="40def20f80d8ba48037f621df42aa0343e15ee73" translate="yes" xml:space="preserve">
          <source>Inheritance does not automatically propagate data from &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;COPY&lt;/code&gt; commands to other tables in the inheritance hierarchy. In our example, the following &lt;code&gt;INSERT&lt;/code&gt; statement will fail:</source>
          <target state="translated">При наследовании данные из команд &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;COPY&lt;/code&gt; не передаются автоматически в другие таблицы в иерархии наследования. В нашем примере следующий оператор &lt;code&gt;INSERT&lt;/code&gt; завершится ошибкой:</target>
        </trans-unit>
        <trans-unit id="48cefe4735516b5da581e0949fa06f740d2b885b" translate="yes" xml:space="preserve">
          <source>Inheritance is a concept from object-oriented databases. It opens up interesting new possibilities of database design.</source>
          <target state="translated">Наследование-это понятие из объектно-ориентированных баз данных.Оно открывает новые интересные возможности проектирования баз данных.</target>
        </trans-unit>
        <trans-unit id="ad5cfb3ab229a84f8bd5bd34780ce3d5e37a4e03" translate="yes" xml:space="preserve">
          <source>Inherited queries perform access permission checks on the parent table only. Thus, for example, granting &lt;code&gt;UPDATE&lt;/code&gt; permission on the &lt;code&gt;cities&lt;/code&gt; table implies permission to update rows in the &lt;code&gt;capitals&lt;/code&gt; table as well, when they are accessed through &lt;code&gt;cities&lt;/code&gt;. This preserves the appearance that the data is (also) in the parent table. But the &lt;code&gt;capitals&lt;/code&gt; table could not be updated directly without an additional grant. In a similar way, the parent table's row security policies (see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;) are applied to rows coming from child tables during an inherited query. A child table's policies, if any, are applied only when it is the table explicitly named in the query; and in that case, any policies attached to its parent(s) are ignored.</source>
          <target state="translated">Унаследованные запросы выполняют проверку прав доступа только для родительской таблицы. Таким образом, например, предоставление разрешения &lt;code&gt;UPDATE&lt;/code&gt; для таблицы &lt;code&gt;cities&lt;/code&gt; подразумевает разрешение на обновление строк в таблице &lt;code&gt;capitals&lt;/code&gt; , когда к ним доступ осуществляется через &lt;code&gt;cities&lt;/code&gt; . Это сохраняет видимость того, что данные (также) находятся в родительской таблице. Но таблица &lt;code&gt;capitals&lt;/code&gt; не может быть обновлена ​​напрямую без дополнительного гранта. Аналогичным образом, политики безопасности строк родительской таблицы (см. &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Раздел 5.8&lt;/a&gt;) применяются к строкам, поступающим из дочерних таблиц во время унаследованного запроса. Политики дочерней таблицы, если таковые имеются, применяются только тогда, когда это таблица, явно названная в запросе; и в этом случае игнорируются любые политики, прикрепленные к его родительскому (-ым).</target>
        </trans-unit>
        <trans-unit id="1f25aac16509c63c647e201e6dca9b42be580c36" translate="yes" xml:space="preserve">
          <source>Initialization Options</source>
          <target state="translated">Опции инициализации</target>
        </trans-unit>
        <trans-unit id="02678e4e52eadddd5b615833652cf8428b2afe6a" translate="yes" xml:space="preserve">
          <source>Initialization option string for the template</source>
          <target state="translated">Опция инициализации для шаблона</target>
        </trans-unit>
        <trans-unit id="6528a9644e65de4c79a52fdab1106b0b771a6d92" translate="yes" xml:space="preserve">
          <source>Initialize the new cluster using &lt;code&gt;initdb&lt;/code&gt;. Again, use compatible &lt;code&gt;initdb&lt;/code&gt; flags that match the old cluster. Many prebuilt installers do this step automatically. There is no need to start the new cluster.</source>
          <target state="translated">Инициализируйте новый кластер с помощью &lt;code&gt;initdb&lt;/code&gt; . Опять же, используйте совместимые флаги &lt;code&gt;initdb&lt;/code&gt; , соответствующие старому кластеру. Многие готовые установщики делают этот шаг автоматически. Нет необходимости запускать новый кластер.</target>
        </trans-unit>
        <trans-unit id="2a5c551f4615e330d270ad5f3b0629fcdfcd3de2" translate="yes" xml:space="preserve">
          <source>Inner tuples are more complex, since they are branching points in the search tree. Each inner tuple contains a set of one or more &lt;em&gt;nodes&lt;/em&gt;, which represent groups of similar leaf values. A node contains a downlink that leads either to another, lower-level inner tuple, or to a short list of leaf tuples that all lie on the same index page. Each node normally has a &lt;em&gt;label&lt;/em&gt; that describes it; for example, in a radix tree the node label could be the next character of the string value. (Alternatively, an operator class can omit the node labels, if it works with a fixed set of nodes for all inner tuples; see &lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;Section 65.4.2&lt;/a&gt;.) Optionally, an inner tuple can have a &lt;em&gt;prefix&lt;/em&gt; value that describes all its members. In a radix tree this could be the common prefix of the represented strings. The prefix value is not necessarily really a prefix, but can be any data needed by the operator class; for example, in a quad-tree it can store the central point that the four quadrants are measured with respect to. A quad-tree inner tuple would then also contain four nodes corresponding to the quadrants around this central point.</source>
          <target state="translated">Внутренние кортежи более сложны, поскольку они являются точками ветвления в дереве поиска. Каждый внутренний кортеж содержит набор из одного или нескольких &lt;em&gt;узлов&lt;/em&gt; , которые представляют группы схожих значений листьев. Узел содержит нисходящую ссылку, которая ведет либо к другому внутреннему кортежу более низкого уровня, либо к короткому списку конечных кортежей, которые все лежат на одной странице индекса. Каждый узел обычно имеет &lt;em&gt;метку&lt;/em&gt; , описывающую его; например, в дереве счисления метка узла может быть следующим символом строкового значения. (В качестве альтернативы, класс операторов может опускать метки узлов, если он работает с фиксированным набором узлов для всех внутренних кортежей; см. &lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;Раздел 65.4.2&lt;/a&gt; .) При желании внутренний кортеж может иметь &lt;em&gt;префикс&lt;/em&gt;значение, описывающее всех его членов. В дереве счисления это может быть общий префикс представленных строк. Значение префикса на самом деле не обязательно является префиксом, но может быть любыми данными, необходимыми для класса оператора; например, в дереве квадрантов он может хранить центральную точку, относительно которой измеряются четыре квадранта. Тогда внутренний кортеж четырехугольного дерева также будет содержать четыре узла, соответствующих квадрантам вокруг этой центральной точки.</target>
        </trans-unit>
        <trans-unit id="0029fb34c419096901cb17ee7f69f8d100b925e7" translate="yes" xml:space="preserve">
          <source>Input Ordering</source>
          <target state="translated">Заказ входных данных</target>
        </trans-unit>
        <trans-unit id="c651bb8d20d59b648e5817a714d081c24490bd28" translate="yes" xml:space="preserve">
          <source>Input String</source>
          <target state="translated">Входная строка</target>
        </trans-unit>
        <trans-unit id="c42fb65381608e452debc58ec5ce5a7de90ede68" translate="yes" xml:space="preserve">
          <source>Input conversion function (binary format), or 0 if none</source>
          <target state="translated">Функция преобразования входа (двоичный формат),или 0,если нет.</target>
        </trans-unit>
        <trans-unit id="6ede32a74b25d24d933316273b8d1a1c5b311742" translate="yes" xml:space="preserve">
          <source>Input conversion function (text format)</source>
          <target state="translated">Функция преобразования входа (текстовый формат)</target>
        </trans-unit>
        <trans-unit id="445431b172a9cb689a043786c27d77bc63ec81f4" translate="yes" xml:space="preserve">
          <source>Input data is interpreted according to &lt;code&gt;ENCODING&lt;/code&gt; option or the current client encoding, and output data is encoded in &lt;code&gt;ENCODING&lt;/code&gt; or the current client encoding, even if the data does not pass through the client but is read from or written to a file directly by the server.</source>
          <target state="translated">Входные данные интерпретируются в соответствии с опцией &lt;code&gt;ENCODING&lt;/code&gt; или текущей клиентской кодировкой, а выходные данные кодируются в &lt;code&gt;ENCODING&lt;/code&gt; или текущей клиентской кодировке, даже если данные не проходят через клиент, а читаются или записываются в файл непосредственно сервером. .</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="aa563adcb5d00e2fc3a73ea58d9fd1b265968174" translate="yes" xml:space="preserve">
          <source>Insert a distributor, or do nothing for rows proposed for insertion when an existing, excluded row (a row with a matching constrained column or columns after before row insert triggers fire) exists. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column:</source>
          <target state="translated">Вставьте распределитель или ничего не делайте для строк, предлагаемых для вставки, если существует существующая исключенная строка (строка с совпадающим ограниченным столбцом или столбцами после срабатывания триггеров до вставки строки). В примере предполагается, что был определен уникальный индекс, ограничивающий значения, отображаемые в столбце &lt;code&gt;did&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1b0022e72f294401989398fe077aa7293c9d0864" translate="yes" xml:space="preserve">
          <source>Insert a new tuple into an existing index. The &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;isnull&lt;/code&gt; arrays give the key values to be indexed, and &lt;code&gt;heap_tid&lt;/code&gt; is the TID to be indexed. If the access method supports unique indexes (its &lt;code&gt;amcanunique&lt;/code&gt; flag is true) then &lt;code&gt;checkUnique&lt;/code&gt; indicates the type of uniqueness check to perform. This varies depending on whether the unique constraint is deferrable; see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt; for details. Normally the access method only needs the &lt;code&gt;heapRelation&lt;/code&gt; parameter when performing uniqueness checking (since then it will have to look into the heap to verify tuple liveness).</source>
          <target state="translated">Вставьте новый кортеж в существующий индекс. Эти &lt;code&gt;values&lt;/code&gt; и &lt;code&gt;isnull&lt;/code&gt; массивы дают ключевые значения , которые будут индексировать и &lt;code&gt;heap_tid&lt;/code&gt; является TID для индексации. Если метод доступа поддерживает уникальные индексы (его флаг &lt;code&gt;amcanunique&lt;/code&gt; имеет значение true), &lt;code&gt;checkUnique&lt;/code&gt; указывает тип проверки уникальности, которую необходимо выполнить. Это зависит от того, является ли ограничение уникальности откладываемым; подробности см. в &lt;a href=&quot;index-unique-checks&quot;&gt;Разделе 61.5&lt;/a&gt; . Обычно методу доступа требуется &lt;code&gt;heapRelation&lt;/code&gt; параметр heapRelation при выполнении проверки уникальности (с тех пор ему придется заглядывать в кучу, чтобы проверить живучесть кортежа).</target>
        </trans-unit>
        <trans-unit id="0f674319e8780ea4807c4a4acfb9e949fb5f9a9e" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;distributors&lt;/code&gt;, returning the sequence number generated by the &lt;code&gt;DEFAULT&lt;/code&gt; clause:</source>
          <target state="translated">Вставьте одну строку в &lt;code&gt;distributors&lt;/code&gt; таблиц , возвращая порядковый номер, сгенерированный предложением &lt;code&gt;DEFAULT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="632c13df9b06de5c5de5b6f56617f6d898fc7280" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">Вставьте одну строку в таблицу &lt;code&gt;films&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3892df53992670e16381ba584272763bbe059b7e" translate="yes" xml:space="preserve">
          <source>Insert new distributor if possible; otherwise &lt;code&gt;DO NOTHING&lt;/code&gt;. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column on a subset of rows where the &lt;code&gt;is_active&lt;/code&gt; Boolean column evaluates to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">Если возможно, вставьте нового дистрибьютора; иначе &lt;code&gt;DO NOTHING&lt;/code&gt; . В примере предполагается, что был определен уникальный индекс, который ограничивает значения, появляющиеся в столбце &lt;code&gt;did&lt;/code&gt; на подмножестве строк, в &lt;code&gt;is_active&lt;/code&gt; логический столбец is_active имеет значение &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="db80c622e1c5ed5095a7dd936600840392c749b3" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. Note that the special &lt;code&gt;excluded&lt;/code&gt; table is used to reference values originally proposed for insertion:</source>
          <target state="translated">При необходимости добавьте или обновите новых дистрибьюторов. Предполагается, что определен уникальный индекс, который ограничивает значения, отображаемые в столбце &lt;code&gt;did&lt;/code&gt; . Обратите внимание, что специальная &lt;code&gt;excluded&lt;/code&gt; таблица используется для ссылки на значения, изначально предложенные для вставки:</target>
        </trans-unit>
        <trans-unit id="449538b0ed8e6f507ea1c64d35164fae0d826023" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. &lt;code&gt;WHERE&lt;/code&gt; clause is used to limit the rows actually updated (any existing row not updated will still be locked, though):</source>
          <target state="translated">При необходимости добавьте или обновите новых дистрибьюторов. В примере предполагается, что был определен уникальный индекс, который ограничивает значения, отображаемые в столбце &lt;code&gt;did&lt;/code&gt; . Предложение &lt;code&gt;WHERE&lt;/code&gt; используется для ограничения фактически обновляемых строк (однако любая существующая не обновленная строка все равно будет заблокирована):</target>
        </trans-unit>
        <trans-unit id="ae6eaf6a32e43f0bf6ecef28e872215845bae1e6" translate="yes" xml:space="preserve">
          <source>Inserting</source>
          <target state="translated">Inserting</target>
        </trans-unit>
        <trans-unit id="0dd2b481ad724309af4e29174757be7f9ad67dd8" translate="yes" xml:space="preserve">
          <source>Inserting Data</source>
          <target state="translated">Вставка данных</target>
        </trans-unit>
        <trans-unit id="a58e264f985643a8003e2d8ae2f19f1f44151747" translate="yes" xml:space="preserve">
          <source>Insertion into a GIN index can be slow due to the likelihood of many keys being inserted for each item. So, for bulk insertions into a table it is advisable to drop the GIN index and recreate it after finishing bulk insertion.</source>
          <target state="translated">Вставка в GIN-индекс может быть медленной из-за вероятности того,что для каждого элемента будет вставлено много ключей.Поэтому для массовой вставки в таблицу рекомендуется опустить GIN-индекс и воссоздать его после завершения массовой вставки.</target>
        </trans-unit>
        <trans-unit id="a514639c0e9db066f2ca50c5677c9c0ad2871adb" translate="yes" xml:space="preserve">
          <source>Inside the crosstab grid, for each distinct value &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;colH&lt;/code&gt; and each distinct value &lt;code&gt;y&lt;/code&gt; of &lt;code&gt;colV&lt;/code&gt;, the cell located at the intersection &lt;code&gt;(x,y)&lt;/code&gt; contains the value of the &lt;code&gt;colD&lt;/code&gt; column in the query result row for which the value of &lt;code&gt;colH&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt; and the value of &lt;code&gt;colV&lt;/code&gt; is &lt;code&gt;y&lt;/code&gt;. If there is no such row, the cell is empty. If there are multiple such rows, an error is reported.</source>
          <target state="translated">Внутри перекрестном сеток, для каждого отдельного значения &lt;code&gt;x&lt;/code&gt; из &lt;code&gt;colH&lt;/code&gt; и каждое отдельное значение &lt;code&gt;y&lt;/code&gt; из &lt;code&gt;colV&lt;/code&gt; , клетка находится на пересечении &lt;code&gt;(x,y)&lt;/code&gt; содержит значение &lt;code&gt;colD&lt;/code&gt; столбца в результате запроса строки , для которых значение &lt;code&gt;colH&lt;/code&gt; является &lt;code&gt;x&lt;/code&gt; , а значение &lt;code&gt;colV&lt;/code&gt; равно &lt;code&gt;y&lt;/code&gt; . Если такой строки нет, ячейка пуста. Если таких строк несколько, выдается сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="b00cb7892b66a87132bdd26b6401b8b521c81e40" translate="yes" xml:space="preserve">
          <source>Inspect the contents of the database to ensure you have recovered to the desired state. If not, return to step 1. If all is well, allow your users to connect by restoring &lt;code&gt;pg_hba.conf&lt;/code&gt; to normal.</source>
          <target state="translated">Проверьте содержимое базы данных, чтобы убедиться, что вы вернулись в желаемое состояние. Если нет, вернитесь к шагу 1. Если все в порядке, разрешите пользователям подключаться, восстановив &lt;code&gt;pg_hba.conf&lt;/code&gt; до нормального состояния.</target>
        </trans-unit>
        <trans-unit id="bb93c6938a2011d934988eab5986d385a4c4d0be" translate="yes" xml:space="preserve">
          <source>Inspecting the MCV list is possible using &lt;code&gt;pg_mcv_list_items&lt;/code&gt; set-returning function.</source>
          <target state="translated">&lt;code&gt;pg_mcv_list_items&lt;/code&gt; списка MCV возможен с помощью функции возврата набора pg_mcv_list_items .</target>
        </trans-unit>
        <trans-unit id="ff17c423681bf713fcd55cb3b3eb644d120028a0" translate="yes" xml:space="preserve">
          <source>Inspired by the original &lt;code&gt;citext&lt;/code&gt; module by Donald Fraser.</source>
          <target state="translated">На основе оригинального модуля &lt;code&gt;citext&lt;/code&gt; Дональда Фрейзера.</target>
        </trans-unit>
        <trans-unit id="e2f807d3934f67c59236ce54638758a511971353" translate="yes" xml:space="preserve">
          <source>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g. &lt;code&gt;pgcrypto.so&lt;/code&gt;, whether they are from &lt;code&gt;contrib&lt;/code&gt; or some other source. Do not install the schema definitions, e.g. &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt;, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</source>
          <target state="translated">Установите любые пользовательские файлы общих объектов (или библиотеки DLL), используемые старым кластером, в новый кластер, например &lt;code&gt;pgcrypto.so&lt;/code&gt; , независимо от того , взяты ли они из &lt;code&gt;contrib&lt;/code&gt; или из другого источника. Не устанавливайте определения схемы, например &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt; , потому что они будут обновлены из старого кластера. Кроме того, любые пользовательские файлы полнотекстового поиска (словарь, синоним, тезаурус, стоп-слова) также должны быть скопированы в новый кластер.</target>
        </trans-unit>
        <trans-unit id="ad8735c38dbf2201c7954106ea9c90d304db5a72" translate="yes" xml:space="preserve">
          <source>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g., &lt;code&gt;pgcrypto.so&lt;/code&gt;, whether they are from &lt;code&gt;contrib&lt;/code&gt; or some other source. Do not install the schema definitions, e.g., &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt;, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0968ed3e41692f76e13c55e2d74df0fcf64b5b" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension into the current database, placing its objects in schema &lt;code&gt;addons&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a5a70619c2c19e2c9702b13c9847e5c653791a" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension into the current database:</source>
          <target state="translated">Установите расширение &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; в текущую базу данных:</target>
        </trans-unit>
        <trans-unit id="04f7a627a6509f6c7b363a56555a0d35366acc62" translate="yes" xml:space="preserve">
          <source>Install the &lt;code&gt;postgres_fdw&lt;/code&gt; extension using &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt;.</source>
          <target state="translated">Установите расширение &lt;code&gt;postgres_fdw&lt;/code&gt; с помощью &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9684579d3e7c9b1f5825f61e639d95625abccadc" translate="yes" xml:space="preserve">
          <source>Install the new server's binaries and support files. pg_upgrade is included in a default installation.</source>
          <target state="translated">Установите исполняемые файлы нового сервера и файлы поддержки.pg_upgrade включена в установку по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cb2992c5a571b6edb98a5bf527c86c020a33e35d" translate="yes" xml:space="preserve">
          <source>Install the new version of PostgreSQL as outlined in &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt;.</source>
          <target state="translated">Установите новую версию PostgreSQL, как описано в &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;Разделе 16.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7e4ec31b8bf1a9e0464c75a90e53710f79548e0" translate="yes" xml:space="preserve">
          <source>Install the new version of PostgreSQL as outlined in &lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90075fb521dd4d59c46ee65abf78d28b40851d8c" translate="yes" xml:space="preserve">
          <source>Install the same custom shared object files on the new standbys that you installed in the new primary cluster.</source>
          <target state="translated">Установите те же пользовательские разделяемые объектные файлы на новые подставки,которые вы установили в новом основном кластере.</target>
        </trans-unit>
        <trans-unit id="f0738ede58ba3533e9ba6fac10de77528d0eda5f" translate="yes" xml:space="preserve">
          <source>Installing an extension as superuser requires trusting that the extension's author wrote the extension installation script in a secure fashion. It is not terribly difficult for a malicious user to create trojan-horse objects that will compromise later execution of a carelessly-written extension script, allowing that user to acquire superuser privileges. However, trojan-horse objects are only hazardous if they are in the &lt;code&gt;search_path&lt;/code&gt; during script execution, meaning that they are in the extension's installation target schema or in the schema of some extension it depends on. Therefore, a good rule of thumb when dealing with extensions whose scripts have not been carefully vetted is to install them only into schemas for which CREATE privilege has not been and will not be granted to any untrusted users. Likewise for any extensions they depend on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a4641a5ec01b91ac5755c29e1f7d10ca370b2e" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_int&lt;/code&gt; extension creates a text search template &lt;code&gt;intdict_template&lt;/code&gt; and a dictionary &lt;code&gt;intdict&lt;/code&gt; based on it, with the default parameters. You can alter the parameters, for example</source>
          <target state="translated">При установке расширения &lt;code&gt;dict_int&lt;/code&gt; создается шаблон текстового поиска &lt;code&gt;intdict_template&lt;/code&gt; и словарь &lt;code&gt;intdict&lt;/code&gt; на его основе с параметрами по умолчанию. Вы можете изменить параметры, например</target>
        </trans-unit>
        <trans-unit id="88a4b249e71fce074c62157e59fbc27119675b0b" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_xsyn&lt;/code&gt; extension creates a text search template &lt;code&gt;xsyn_template&lt;/code&gt; and a dictionary &lt;code&gt;xsyn&lt;/code&gt; based on it, with default parameters. You can alter the parameters, for example</source>
          <target state="translated">При установке расширения &lt;code&gt;dict_xsyn&lt;/code&gt; создается шаблон текстового поиска &lt;code&gt;xsyn_template&lt;/code&gt; и словарь &lt;code&gt;xsyn&lt;/code&gt; на его основе с параметрами по умолчанию. Вы можете изменить параметры, например</target>
        </trans-unit>
        <trans-unit id="cf52efd63633f939852f89750e72d737a7ef8451" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;unaccent&lt;/code&gt; extension creates a text search template &lt;code&gt;unaccent&lt;/code&gt; and a dictionary &lt;code&gt;unaccent&lt;/code&gt; based on it. The &lt;code&gt;unaccent&lt;/code&gt; dictionary has the default parameter setting &lt;code&gt;RULES='unaccent'&lt;/code&gt;, which makes it immediately usable with the standard &lt;code&gt;unaccent.rules&lt;/code&gt; file. If you wish, you can alter the parameter, for example</source>
          <target state="translated">Установка расширения &lt;code&gt;unaccent&lt;/code&gt; создает на его основе шаблон текстового поиска без &lt;code&gt;unaccent&lt;/code&gt; и словарь без &lt;code&gt;unaccent&lt;/code&gt; . &lt;code&gt;unaccent&lt;/code&gt; словарь имеет параметры по умолчанию настройки в &lt;code&gt;RULES='unaccent'&lt;/code&gt; , что делает его можно использовать сразу со стандартным &lt;code&gt;unaccent.rules&lt;/code&gt; файлом. При желании вы можете изменить параметр, например</target>
        </trans-unit>
        <trans-unit id="5f97f8775628e86310829ab9e8c465258ab92a5e" translate="yes" xml:space="preserve">
          <source>Instance</source>
          <target state="translated">Instance</target>
        </trans-unit>
        <trans-unit id="5b4ebcd87748b86d7b51facd78d76e7b88a0adf7" translate="yes" xml:space="preserve">
          <source>Instead of an expression, &lt;code&gt;*&lt;/code&gt; can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can write &lt;code&gt;table_name.*&lt;/code&gt; as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names with &lt;code&gt;AS&lt;/code&gt;; the output column names will be the same as the table columns' names.</source>
          <target state="translated">Вместо выражения в выходном списке можно записать &lt;code&gt;*&lt;/code&gt; как сокращение для всех столбцов выбранных строк. Кроме того, вы можете записать &lt;code&gt;table_name.*&lt;/code&gt; Как сокращение для столбцов, поступающих только из этой таблицы. В этих случаях невозможно указать новые имена с помощью &lt;code&gt;AS&lt;/code&gt; ; имена выходных столбцов будут такими же, как имена столбцов таблицы.</target>
        </trans-unit>
        <trans-unit id="a6521c09d55a0d983da28cb3b1223e411f459cda" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;amgettuple&lt;/code&gt;, an index scan can be done with &lt;code&gt;amgetbitmap&lt;/code&gt; to fetch all tuples in one call. This can be noticeably more efficient than &lt;code&gt;amgettuple&lt;/code&gt; because it allows avoiding lock/unlock cycles within the access method. In principle &lt;code&gt;amgetbitmap&lt;/code&gt; should have the same effects as repeated &lt;code&gt;amgettuple&lt;/code&gt; calls, but we impose several restrictions to simplify matters. First of all, &lt;code&gt;amgetbitmap&lt;/code&gt; returns all tuples at once and marking or restoring scan positions isn't supported. Secondly, the tuples are returned in a bitmap which doesn't have any specific ordering, which is why &lt;code&gt;amgetbitmap&lt;/code&gt; doesn't take a &lt;code&gt;direction&lt;/code&gt; argument. (Ordering operators will never be supplied for such a scan, either.) Also, there is no provision for index-only scans with &lt;code&gt;amgetbitmap&lt;/code&gt;, since there is no way to return the contents of index tuples. Finally, &lt;code&gt;amgetbitmap&lt;/code&gt; does not guarantee any locking of the returned tuples, with implications spelled out in &lt;a href=&quot;index-locking&quot;&gt;Section 61.4&lt;/a&gt;.</source>
          <target state="translated">Вместо использования &lt;code&gt;amgettuple&lt;/code&gt; можно выполнить сканирование индекса с помощью &lt;code&gt;amgetbitmap&lt;/code&gt; , чтобы получить все кортежи за один вызов. Это может быть заметно более эффективным, чем &lt;code&gt;amgettuple&lt;/code&gt; , поскольку позволяет избежать циклов блокировки / разблокировки в методе доступа. В принципе, &lt;code&gt;amgetbitmap&lt;/code&gt; должен иметь те же эффекты, что и повторные вызовы &lt;code&gt;amgettuple&lt;/code&gt; , но мы налагаем несколько ограничений, чтобы упростить ситуацию. Во-первых, &lt;code&gt;amgetbitmap&lt;/code&gt; возвращает сразу все кортежи, а отметка или восстановление позиций сканирования не поддерживается. Во-вторых, кортежи возвращаются в растровом изображении, которое не имеет определенного порядка, поэтому &lt;code&gt;amgetbitmap&lt;/code&gt; не принимает &lt;code&gt;direction&lt;/code&gt; аргумент. (Операторы упорядочения также никогда не будут предоставлены для такого сканирования.) Кроме того, нет возможности для сканирования только индекса с помощью &lt;code&gt;amgetbitmap&lt;/code&gt; , поскольку нет способа вернуть содержимое кортежей индекса. Наконец, &lt;code&gt;amgetbitmap&lt;/code&gt; не гарантирует блокировку возвращаемых кортежей, последствия которой изложены в &lt;a href=&quot;index-locking&quot;&gt;Разделе 61.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d79849f61d583b44d9d0fdc8025d98ffb5bbfd35" translate="yes" xml:space="preserve">
          <source>Instead of writing &lt;code&gt;ONLY&lt;/code&gt; before the table name, you can write &lt;code&gt;*&lt;/code&gt; after the table name to explicitly specify that descendant tables are included. There is no real reason to use this syntax any more, because searching descendant tables is now always the default behavior. However, it is supported for compatibility with older releases.</source>
          <target state="translated">Вместо того, чтобы писать &lt;code&gt;ONLY&lt;/code&gt; перед именем таблицы, вы можете написать &lt;code&gt;*&lt;/code&gt; после имени таблицы, чтобы явно указать, что дочерние таблицы включены. Нет реальной причины использовать этот синтаксис больше, потому что поиск дочерних таблиц теперь всегда является поведением по умолчанию. Однако он поддерживается для совместимости со старыми выпусками.</target>
        </trans-unit>
        <trans-unit id="4a1635249102b1ddea4769929b8a71df3f648e09" translate="yes" xml:space="preserve">
          <source>Institute of Electrical and Electronics Engineers</source>
          <target state="translated">Институт инженеров по электротехнике и электронике</target>
        </trans-unit>
        <trans-unit id="e877a09ab092ea6de15878a42ea4226bbdc6693d" translate="yes" xml:space="preserve">
          <source>Integer bit mask indicating which arguments are not being included in the current grouping set</source>
          <target state="translated">Целобитная маска,указывающая,какие аргументы не включаются в текущий набор группировки</target>
        </trans-unit>
        <trans-unit id="03c1016d0a2fd0151189914ddf3d90f010d5ee41" translate="yes" xml:space="preserve">
          <source>Integer quotient of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt; (truncates towards zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897c83dd3fcb5ef382c1b65917bd9be2f5323fd2" translate="yes" xml:space="preserve">
          <source>Inter-Process Communication</source>
          <target state="translated">Межпроцессное взаимодействие</target>
        </trans-unit>
        <trans-unit id="d85d227df828a06ee1ce26f9f247a35c482de85a" translate="yes" xml:space="preserve">
          <source>Interesting idea for picking passwords.</source>
          <target state="translated">Интересная идея для подбора паролей.</target>
        </trans-unit>
        <trans-unit id="457737863c2801b7971002cd15c9223e0c9b404e" translate="yes" xml:space="preserve">
          <source>Interfacing with monitoring software to report errors</source>
          <target state="translated">Взаимодействие с программным обеспечением мониторинга для сообщения об ошибках</target>
        </trans-unit>
        <trans-unit id="bc34e531672634aab3b26d4017b45aa2bbc7b3db" translate="yes" xml:space="preserve">
          <source>Interfacing with other backup and recovery software</source>
          <target state="translated">Взаимодействие с другим программным обеспечением для резервного копирования и восстановления</target>
        </trans-unit>
        <trans-unit id="ec9a27bfbcfba0ca31c61c9c952115c2287d92f0" translate="yes" xml:space="preserve">
          <source>Intermediate certificates that chain up to existing root certificates can also appear in the &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; file if you wish to avoid storing them on clients (assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions). Certificate Revocation List (CRL) entries are also checked if the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087813fa40caa10b888af01dbc97f7437b81b67d" translate="yes" xml:space="preserve">
          <source>Intermediate certificates that chain up to existing root certificates can also appear in the &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; file if you wish to avoid storing them on clients (assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions). Certificate Revocation List (CRL) entries are also checked if the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; is set. (See &lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt; for diagrams showing SSL certificate usage.)</source>
          <target state="translated">Промежуточные сертификаты, которые &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;связаны&lt;/a&gt; с существующими корневыми сертификатами, также могут появиться в файле ssl_ca_file, если вы хотите избежать их хранения на клиентах (при условии, что корневой и промежуточный сертификаты были созданы с расширениями &lt;code&gt;v3_ca&lt;/code&gt; ). Записи списка отзыва сертификатов (CRL) также проверяются, если установлен параметр &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; . (См. &lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;Http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt; для диаграмм, показывающих использование сертификата SSL.)</target>
        </trans-unit>
        <trans-unit id="8784a00f8fa083e2a06f38fd51cc35a39bb77fca" translate="yes" xml:space="preserve">
          <source>Internal access to the system catalogs is not done using the isolation level of the current transaction. This means that newly created database objects such as tables are visible to concurrent Repeatable Read and Serializable transactions, even though the rows they contain are not. In contrast, queries that explicitly examine the system catalogs don't see rows representing concurrently created database objects, in the higher isolation levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ed083a1fd80d11b5474ab6a44b299da8513f67" translate="yes" xml:space="preserve">
          <source>Internal data structures such as &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;pg_subtrans&lt;/code&gt;, &lt;code&gt;pg_multixact&lt;/code&gt;, &lt;code&gt;pg_serial&lt;/code&gt;, &lt;code&gt;pg_notify&lt;/code&gt;, &lt;code&gt;pg_stat&lt;/code&gt;, &lt;code&gt;pg_snapshots&lt;/code&gt; are not directly checksummed, nor are pages protected by full page writes. However, where such data structures are persistent, WAL records are written that allow recent changes to be accurately rebuilt at crash recovery and those WAL records are protected as discussed above.</source>
          <target state="translated">Внутренние структуры данных, такие как &lt;code&gt;pg_xact&lt;/code&gt; , &lt;code&gt;pg_subtrans&lt;/code&gt; , &lt;code&gt;pg_multixact&lt;/code&gt; , &lt;code&gt;pg_serial&lt;/code&gt; , &lt;code&gt;pg_notify&lt;/code&gt; , &lt;code&gt;pg_stat&lt;/code&gt; , &lt;code&gt;pg_snapshots&lt;/code&gt; , напрямую не проверяются контрольной суммой, и страницы не защищены полной записью страницы. Однако там, где такие структуры данных являются постоянными, записываются записи WAL, позволяющие точно восстановить недавние изменения при восстановлении после сбоя, и эти записи WAL защищены, как описано выше.</target>
        </trans-unit>
        <trans-unit id="210293c0eebe094c6cf4191095ebf7c83ba53d58" translate="yes" xml:space="preserve">
          <source>Internal hash code, computed from the statement's parse tree</source>
          <target state="translated">Внутренний хэш-код,вычисленный из дерева разбора оператора.</target>
        </trans-unit>
        <trans-unit id="e2daadb2e211983a80b38897bed9d140e91cd8e5" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;interval&lt;/code&gt; values are stored as months, days, and seconds. This is done because the number of days in a month varies, and a day can have 23 or 25 hours if a daylight savings time adjustment is involved. The months and days fields are integers while the seconds field can store fractions. Because intervals are usually created from constant strings or &lt;code&gt;timestamp&lt;/code&gt; subtraction, this storage method works well in most cases, but can cause unexpected results:</source>
          <target state="translated">Внутренние значения &lt;code&gt;interval&lt;/code&gt; сохраняются в виде месяцев, дней и секунд. Это сделано потому, что количество дней в месяце варьируется, и в день может быть 23 или 25 часов, если задействована корректировка летнего времени. Поля месяцев и дней являются целыми числами, а в поле секунд могут храниться дроби. Поскольку интервалы обычно создаются из постоянных строк или вычитания &lt;code&gt;timestamp&lt;/code&gt; , этот метод хранения в большинстве случаев работает хорошо, но может привести к неожиданным результатам:</target>
        </trans-unit>
        <trans-unit id="95d68b94ef37a16fd1db6257f62457d5c440b435" translate="yes" xml:space="preserve">
          <source>Internally, a GIN index contains a B-tree index constructed over keys, where each key is an element of one or more indexed items (a member of an array, for example) and where each tuple in a leaf page contains either a pointer to a B-tree of heap pointers (a &amp;ldquo;posting tree&amp;rdquo;), or a simple list of heap pointers (a &amp;ldquo;posting list&amp;rdquo;) when the list is small enough to fit into a single index tuple along with the key value. &lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;Figure 66.1&lt;/a&gt; illustrates these components of a GIN index.</source>
          <target state="translated">Внутренне индекс GIN содержит индекс B-дерева, построенный по ключам, где каждый ключ является элементом одного или нескольких индексированных элементов (например, членом массива) и где каждый кортеж на листовой странице содержит либо указатель на B-дерево указателей кучи (&amp;laquo;дерево сообщений&amp;raquo;) или простой список указателей кучи (&amp;laquo;список сообщений&amp;raquo;), когда список достаточно мал, чтобы поместиться в один кортеж индекса вместе со значением ключа. &lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;На рисунке 66.1&lt;/a&gt; показаны эти компоненты индекса GIN.</target>
        </trans-unit>
        <trans-unit id="7c7cae0387037fdfc011139b31adb37771e499bb" translate="yes" xml:space="preserve">
          <source>Internally, all these types use the same representation (a 64-bit integer), and all are interchangeable. Multiple types are provided to control display formatting and to permit tighter validity checking of input that is supposed to denote one particular type of number.</source>
          <target state="translated">Внутри все эти типы используют одно и то же представление (64-битное целое число),и все они взаимозаменяемы.Для управления форматированием отображения и более жесткой проверки валидности ввода,который должен обозначать один конкретный тип числа,предусмотрено несколько типов.</target>
        </trans-unit>
        <trans-unit id="801996043d0146904ef0a7b7426c0b0decab6e65" translate="yes" xml:space="preserve">
          <source>Internally, an LSN is a 64-bit integer, representing a byte position in the write-ahead log stream. It is printed as two hexadecimal numbers of up to 8 digits each, separated by a slash; for example, &lt;code&gt;16/B374D848&lt;/code&gt;. The &lt;code&gt;pg_lsn&lt;/code&gt; type supports the standard comparison operators, like &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. Two LSNs can be subtracted using the &lt;code&gt;-&lt;/code&gt; operator; the result is the number of bytes separating those write-ahead log locations.</source>
          <target state="translated">Внутренне LSN - это 64-битное целое число, представляющее позицию байта в потоке журнала упреждающей записи. Он печатается как два шестнадцатеричных числа до 8 цифр каждое, разделенных косой чертой; например &lt;code&gt;16/B374D848&lt;/code&gt; . Тип &lt;code&gt;pg_lsn&lt;/code&gt; поддерживает стандартные операторы сравнения, такие как &lt;code&gt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;&lt;/code&gt; . Два LSN можно вычесть с помощью оператора &lt;code&gt;-&lt;/code&gt; ; результатом является количество байтов, разделяющих эти ячейки журнала упреждающей записи.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="68baab823cf9c4d570311e278e9e088b97918aa9" translate="yes" xml:space="preserve">
          <source>Internals: BRIN Indexes</source>
          <target state="translated">Интерналы:индексы BRIN</target>
        </trans-unit>
        <trans-unit id="30d8bd593f993584038a1e0fe42a81f00b0963a3" translate="yes" xml:space="preserve">
          <source>Internals: Catalogs</source>
          <target state="translated">Интерналы:Каталоги</target>
        </trans-unit>
        <trans-unit id="3af4bd3be7009ecb5492dd21a7a43e553ce2cd0e" translate="yes" xml:space="preserve">
          <source>Internals: GIN Indexes</source>
          <target state="translated">Интерналы:GIN-индексы</target>
        </trans-unit>
        <trans-unit id="dc575f859035c87eddb3703eb9f32faa91a064d5" translate="yes" xml:space="preserve">
          <source>Internals: Genetic Query Optimizer</source>
          <target state="translated">Интерналы:Генетический оптимизатор запросов</target>
        </trans-unit>
        <trans-unit id="2fdd0d171f1a82304db06140f5b0e0b132641e9d" translate="yes" xml:space="preserve">
          <source>Internals: GiST Indexes</source>
          <target state="translated">Интерналы:гистаршие индексы</target>
        </trans-unit>
        <trans-unit id="3353317a88b7d0fe5733c291ee0c6066760bb027" translate="yes" xml:space="preserve">
          <source>Internals: Index Access Method</source>
          <target state="translated">Интерналы:Метод индексного доступа</target>
        </trans-unit>
        <trans-unit id="2cfa78663fb409507ad30892f6c62ca88915c849" translate="yes" xml:space="preserve">
          <source>Internals: Physical Storage</source>
          <target state="translated">Интерналы:Физическое хранение</target>
        </trans-unit>
        <trans-unit id="72bd21b653073da0193a18c2b147b4e07c551c2d" translate="yes" xml:space="preserve">
          <source>Internals: SP-GiST Indexes</source>
          <target state="translated">Интерналы:Индексы SP-GiST</target>
        </trans-unit>
        <trans-unit id="9a4222dfc9fdc77f19f92dba6e20438075629f39" translate="yes" xml:space="preserve">
          <source>International Electrotechnical Commission</source>
          <target state="translated">Международная электротехническая комиссия</target>
        </trans-unit>
        <trans-unit id="efd83bf4b70a77811c228aa3f499876839b1a079" translate="yes" xml:space="preserve">
          <source>International Organization for Standardization</source>
          <target state="translated">Международная организация по стандартизации</target>
        </trans-unit>
        <trans-unit id="2bafd8d16b13f2565f9ae12e4063fa2d0cddcfb9" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">Международные стандартные книжные номера для отображения в новом формате дисплея EAN13.</target>
        </trans-unit>
        <trans-unit id="08b688b4eb6cf112f11ba47bac6e099bfb8d453f" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the old short display format</source>
          <target state="translated">Международные стандартные книжные номера для отображения в старом формате короткого дисплея.</target>
        </trans-unit>
        <trans-unit id="ebb2e09bb43f37cc7a01fd763ee8d3845536f4c8" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">Международные стандартные музыкальные номера для отображения в новом формате дисплея EAN13.</target>
        </trans-unit>
        <trans-unit id="ef34d5e58a9ceadea54e7a66e1ff9112f05b0da0" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the old short display format</source>
          <target state="translated">Международные стандартные музыкальные номера для отображения в старом формате короткого дисплея</target>
        </trans-unit>
        <trans-unit id="8dd6340c1b5827c9a707b92916af32dcdcd785bc" translate="yes" xml:space="preserve">
          <source>International Standard Serial Number</source>
          <target state="translated">Международный стандартный серийный номер</target>
        </trans-unit>
        <trans-unit id="4e1c1c5e087cdba177b1e3d204777d49f8f64412" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">Международные стандартные серийные номера,которые будут отображаться в новом формате дисплея EAN13.</target>
        </trans-unit>
        <trans-unit id="105b56360755198078a6d52573dd0840458a5750" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the old short display format</source>
          <target state="translated">Международные стандартные серийные номера для отображения в старом формате короткого дисплея.</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="8fa33d4271f21b38b9499a714668d1694939db92" translate="yes" xml:space="preserve">
          <source>Interpreting Results</source>
          <target state="translated">Интерпретация результатов</target>
        </trans-unit>
        <trans-unit id="27d548cba7b30ac38c7cf5611fd348dac11ee53d" translate="yes" xml:space="preserve">
          <source>Interpreting the actual data can only be done with information obtained from other tables, mostly &lt;code&gt;pg_attribute&lt;/code&gt;. The key values needed to identify field locations are &lt;code&gt;attlen&lt;/code&gt; and &lt;code&gt;attalign&lt;/code&gt;. There is no way to directly get a particular attribute, except when there are only fixed width fields and no null values. All this trickery is wrapped up in the functions &lt;em&gt;heap_getattr&lt;/em&gt;, &lt;em&gt;fastgetattr&lt;/em&gt; and &lt;em&gt;heap_getsysattr&lt;/em&gt;.</source>
          <target state="translated">Интерпретировать фактические данные можно только с помощью информации, полученной из других таблиц, в основном &lt;code&gt;pg_attribute&lt;/code&gt; . Ключевые значения, необходимые для определения местоположения полей, - это &lt;code&gt;attlen&lt;/code&gt; и &lt;code&gt;attalign&lt;/code&gt; . Невозможно напрямую получить конкретный атрибут, кроме случаев, когда есть только поля фиксированной ширины и нет нулевых значений. Вся эта хитрость заключена в функциях &lt;em&gt;heap_getattr&lt;/em&gt; , &lt;em&gt;fastgetattr&lt;/em&gt; и &lt;em&gt;heap_getsysattr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="24238f9afeb08c45bbce6cbe5bfc823ad38ca9fd" translate="yes" xml:space="preserve">
          <source>Intersects?</source>
          <target state="translated">Intersects?</target>
        </trans-unit>
        <trans-unit id="4e15cd1f984843596070878cf276c50b3a281208" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</source>
          <target state="translated">Интервал от &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; до &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264b54df84208c3c82823ada24d9901903b36609" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">Интервал от &lt;code&gt;x&lt;/code&gt; до &lt;code&gt;y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6c942376df50e42c9c8ec0a3deb9eba3459225b" translate="yes" xml:space="preserve">
          <source>Interval values can also be written as ISO 8601 time intervals, using either the &amp;ldquo;format with designators&amp;rdquo; of the standard's section 4.4.3.2 or the &amp;ldquo;alternative format&amp;rdquo; of section 4.4.3.3. The format with designators looks like this:</source>
          <target state="translated">Значения интервалов также могут быть записаны как временные интервалы ISO 8601, используя &amp;laquo;формат с указателями&amp;raquo; из раздела 4.4.3.2 стандарта или &amp;laquo;альтернативный формат&amp;raquo; из раздела 4.4.3.3. Формат с обозначениями выглядит так:</target>
        </trans-unit>
        <trans-unit id="e96fd04cfd40c6866ae4fadc2523f325bbca5474" translate="yes" xml:space="preserve">
          <source>Intuitively, the larger the &lt;code&gt;parameter&lt;/code&gt;, the more frequently values close to &lt;code&gt;min&lt;/code&gt; are accessed, and the less frequently values close to &lt;code&gt;max&lt;/code&gt; are accessed. The closer to 0 &lt;code&gt;parameter&lt;/code&gt; is, the flatter (more uniform) the access distribution. A crude approximation of the distribution is that the most frequent 1% values in the range, close to &lt;code&gt;min&lt;/code&gt;, are drawn &lt;code&gt;parameter&lt;/code&gt;% of the time. The &lt;code&gt;parameter&lt;/code&gt; value must be strictly positive.</source>
          <target state="translated">Интуитивно понятно, что чем больше &lt;code&gt;parameter&lt;/code&gt; , тем чаще обращаются к значениям, близким к &lt;code&gt;min&lt;/code&gt; , и тем реже обращаются к значениям, близким к &lt;code&gt;max&lt;/code&gt; . Чем ближе &lt;code&gt;parameter&lt;/code&gt; к 0 , тем более плоское (более равномерное) распределение доступа. Грубая аппроксимация распределения состоит в том, что наиболее частые значения 1% в диапазоне, близком к &lt;code&gt;min&lt;/code&gt; , отображаются &lt;code&gt;parameter&lt;/code&gt; % времени. Значение &lt;code&gt;parameter&lt;/code&gt; должно быть строго положительным.</target>
        </trans-unit>
        <trans-unit id="fa5dcf3086d32573b28d785efef236569ee934d3" translate="yes" xml:space="preserve">
          <source>Inverse cosine, result in degrees</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65156637d01418342819a73cb6f0c84ed3aadd9b" translate="yes" xml:space="preserve">
          <source>Inverse cosine, result in radians</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044acbc59a99d5be1dcd2df39272182f119202c9" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa52c84bd7eb12aa1c433c5d2762f1447b2f7569" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2adf2990a26a6381a709615ea39f05a1bb69453" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a2b17d6de61349537c2d6805d0dd47465a55e8" translate="yes" xml:space="preserve">
          <source>Inverse sine, result in degrees</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2443561103c4f30b566171f3e2681acb12058ea" translate="yes" xml:space="preserve">
          <source>Inverse sine, result in radians</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e43d0792058a59dfb9b5584a76b17083ea3f125" translate="yes" xml:space="preserve">
          <source>Inverse tangent of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt;, result in degrees</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43cbfde7a6966208306cd1536838dca692e6b35d" translate="yes" xml:space="preserve">
          <source>Inverse tangent of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt;, result in radians</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7267a29db6fb274a599fb9151d3055e43e152d" translate="yes" xml:space="preserve">
          <source>Inverse tangent, result in degrees</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e9282eef441e5d3e97532b28f7543960a0fda3" translate="yes" xml:space="preserve">
          <source>Inverse tangent, result in radians</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c4d2a44d0c1732fb4957da686a2c8c6fd4c621" translate="yes" xml:space="preserve">
          <source>Inverse transition function for moving-aggregate mode (zero if none)</source>
          <target state="translated">Функция обратного перехода для режима суммирования перемещений (ноль,если нет)</target>
        </trans-unit>
        <trans-unit id="28b7eaaae619dbbc89f335962aef4470def2f3e3" translate="yes" xml:space="preserve">
          <source>Invoke &lt;code&gt;VACUUM&lt;/code&gt; on the standard tables.</source>
          <target state="translated">Вызовите &lt;code&gt;VACUUM&lt;/code&gt; на стандартных таблицах.</target>
        </trans-unit>
        <trans-unit id="3018fd4dab61ebc08a8223638bc64040a2d9e057" translate="yes" xml:space="preserve">
          <source>Is above (allows touching)?</source>
          <target state="translated">Выше (позволяет прикасаться)?</target>
        </trans-unit>
        <trans-unit id="da6fc6925748c3c1aaf71338cad9d5f477a2383e" translate="yes" xml:space="preserve">
          <source>Is below (allows touching)?</source>
          <target state="translated">Внизу (позволяет прикасаться)?</target>
        </trans-unit>
        <trans-unit id="4cde919e343d25f19646be89eb578d4418ea8a44" translate="yes" xml:space="preserve">
          <source>Is collation visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa29522fdb9c9289837f5d8f7d870cd6a67b34d7" translate="yes" xml:space="preserve">
          <source>Is conversion visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94be39b60eecf97da6c05767e63714ce3bb576d4" translate="yes" xml:space="preserve">
          <source>Is first &lt;code&gt;tsquery&lt;/code&gt; contained in the second? (This considers only whether all the lexemes appearing in one query appear in the other, ignoring the combining operators.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1572ea1eb7fef37d46de7513f84f0e67fb37082" translate="yes" xml:space="preserve">
          <source>Is first object above second (allows edges to touch)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c505339eacef9319fd285351332723a55918638e" translate="yes" xml:space="preserve">
          <source>Is first object below second (allows edges to touch)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5bac705c5e60b2475e9b17e98087c0990a2c946" translate="yes" xml:space="preserve">
          <source>Is first object contained in or on second? Available for these pairs of types: (&lt;code id=&quot;point&quot;&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;), (&lt;code&gt;box&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;), (&lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;), (&lt;code&gt;circle&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e54349160763b512bf27d165196d02b1f67231a" translate="yes" xml:space="preserve">
          <source>Is first object strictly above second? (This operator is misnamed; it should be &lt;code id=&quot;1246262&quot;&gt;|&amp;gt;&amp;gt;&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba666af39de93d6cf6a684c0aa3dde8c77aa45b" translate="yes" xml:space="preserve">
          <source>Is first object strictly above second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a74a8665c56409f78bc9b13ad274898bb226d641" translate="yes" xml:space="preserve">
          <source>Is first object strictly below second? (This operator is misnamed; it should be &lt;code id=&quot;6060124&quot;&gt;&amp;lt;&amp;lt;|&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb75e79e36aeff0c7858d8fb478e380c0c08061" translate="yes" xml:space="preserve">
          <source>Is first object strictly below second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82493964e24c37744bf5de6c7abddd6d617b2dbe" translate="yes" xml:space="preserve">
          <source>Is first object strictly left of second? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb9750549fc2256498ec80ab691b24c888f4e5c" translate="yes" xml:space="preserve">
          <source>Is first object strictly right of second? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2352c4320a598b186beeca1fa33e9ebc446c5989" translate="yes" xml:space="preserve">
          <source>Is function visible in search path? (This also works for procedures and aggregates.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea56f04ac22e5eca73342cefd404d9c1b002af61" translate="yes" xml:space="preserve">
          <source>Is horizontal?</source>
          <target state="translated">Горизонтально?</target>
        </trans-unit>
        <trans-unit id="1818cd29919e00fd168940f58522c1a837de41d9" translate="yes" xml:space="preserve">
          <source>Is left argument a descendant of right (or equal)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6269d3f15bfebe74c5b103d510d2f6af4fbb1be" translate="yes" xml:space="preserve">
          <source>Is left argument an ancestor of right (or equal)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfb83cf12d958867b468135803b461105b5e313" translate="yes" xml:space="preserve">
          <source>Is left array contained in right array?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931e59a6570abe457c179e4beff2927ed26d2296" translate="yes" xml:space="preserve">
          <source>Is left operand contained in right?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571e67a163dd7cbf36b6a8d1f61104a0a31bbc98" translate="yes" xml:space="preserve">
          <source>Is line horizontal?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1926a606e864164a6ebd58c12b6d35ee6a87c25" translate="yes" xml:space="preserve">
          <source>Is line vertical?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae143f55d7c085448a695f852ae27520ec5aa08b" translate="yes" xml:space="preserve">
          <source>Is operator class visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5787d3510293778cafab6156a15c641287921cd" translate="yes" xml:space="preserve">
          <source>Is operator family visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c15be0091b6642fd23724ba17d912f27c02d8aa" translate="yes" xml:space="preserve">
          <source>Is operator visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ef905d97492d046c005a27265c8219bcc2fb0c" translate="yes" xml:space="preserve">
          <source>Is path closed?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692378f0378ddf6c5206700062aa1ea0e029afe6" translate="yes" xml:space="preserve">
          <source>Is path open?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fe9c5adbc8c22895dcd6a5a3619390deb9964a" translate="yes" xml:space="preserve">
          <source>Is perpendicular?</source>
          <target state="translated">Перпендикулярно?</target>
        </trans-unit>
        <trans-unit id="aee38f7bf2589d5e14735890024a26f0647e7b2b" translate="yes" xml:space="preserve">
          <source>Is row-level security active for the specified table in the context of the current user and current environment?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bd90c2bab054cba48ad1eb7ff2752205acec58" translate="yes" xml:space="preserve">
          <source>Is statistics object visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefaf9d6dfa31078880e5655df30026e38004358" translate="yes" xml:space="preserve">
          <source>Is strictly above?</source>
          <target state="translated">Строго выше?</target>
        </trans-unit>
        <trans-unit id="a05cc4a278817fbe41225c1212990f7a42609499" translate="yes" xml:space="preserve">
          <source>Is strictly below?</source>
          <target state="translated">Строго внизу?</target>
        </trans-unit>
        <trans-unit id="b70722f5747da5b37c94b2e21f108653a4a0d9d2" translate="yes" xml:space="preserve">
          <source>Is strictly left of?</source>
          <target state="translated">Строго осталось?</target>
        </trans-unit>
        <trans-unit id="c41dadb911bf56e59cfeff92444afa779a0c9714" translate="yes" xml:space="preserve">
          <source>Is strictly right of?</source>
          <target state="translated">Строго верно ли это?</target>
        </trans-unit>
        <trans-unit id="fd466dacfa71c9a3651034da3efd29046bfe7fec" translate="yes" xml:space="preserve">
          <source>Is subnet contained by or equal to subnet?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608df21f03573c35e537fec94e301c9c05a0ef8c" translate="yes" xml:space="preserve">
          <source>Is subnet strictly contained by subnet? This operator, and the next four, test for subnet inclusion. They consider only the network parts of the two addresses (ignoring any bits to the right of the netmasks) and determine whether one network is identical to or a subnet of the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46cc6fe87dd8470a9509c9da1c694aaec675334f" translate="yes" xml:space="preserve">
          <source>Is table visible in search path? (This works for all types of relations, including views, materialized views, indexes, sequences and foreign tables.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16dfcb2d9f33c5ed1d4f60e7e94de5cdb8bb497" translate="yes" xml:space="preserve">
          <source>Is text search configuration visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b171387fa6a48bfddce09bcc6374af3cb74ce2b7" translate="yes" xml:space="preserve">
          <source>Is text search dictionary visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8ecee88af93cf9199b28e0c89bec38e335e65b" translate="yes" xml:space="preserve">
          <source>Is text search parser visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7a21a45c17bac5fc36d8a030345a04d716413b" translate="yes" xml:space="preserve">
          <source>Is text search template visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0992b021bae889bee0f11abcbb95dee7929e73aa" translate="yes" xml:space="preserve">
          <source>Is the collation deterministic?</source>
          <target state="translated">Это детерминированно?</target>
        </trans-unit>
        <trans-unit id="8a25c1b43d537dd1a7d2ddd1e8080433f5e3eacd" translate="yes" xml:space="preserve">
          <source>Is the constraint deferrable?</source>
          <target state="translated">Ограничение может быть отложено?</target>
        </trans-unit>
        <trans-unit id="fef490f8fe9dee88c33c6a89d30667da1bd2fb9a" translate="yes" xml:space="preserve">
          <source>Is the constraint deferred by default?</source>
          <target state="translated">Отложено ли ограничение по умолчанию?</target>
        </trans-unit>
        <trans-unit id="f2477e67686fc75771da395271b903b89c805e05" translate="yes" xml:space="preserve">
          <source>Is the element contained in the range?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e41905df707985819a963b62a733ad231a70af" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; contained in the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56a2a69c3c21bd55c585fa99939bf4f7fc0147c" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; entirely to the left of the second? [a, b] &amp;lt;&amp;lt; [c, d] is true if b &amp;lt; c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8b00f339a2f532b4e9c2b55069412b977dc8e8" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; entirely to the right of the second? [a, b] &amp;gt;&amp;gt; [c, d] is true if a &amp;gt; d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea89b97de3ee5955142d5113dfb9dcdb02c115c" translate="yes" xml:space="preserve">
          <source>Is the first JSON value contained in the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d335f2a70cca44d7330f0d373f5cb2960385ef" translate="yes" xml:space="preserve">
          <source>Is the first array contained by the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c8facc78abfeb194236811a0926e5445b93180" translate="yes" xml:space="preserve">
          <source>Is the first cube contained in the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e609c817143333de1521a8cf7a158b827be99cd2" translate="yes" xml:space="preserve">
          <source>Is the first range contained by the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68559d84b5ac88d0e9e0f63a5f0039af51bf0f9e" translate="yes" xml:space="preserve">
          <source>Is the first range strictly left of the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2611d9965b16ffb44827feb465cfe43a1b6dc3" translate="yes" xml:space="preserve">
          <source>Is the first range strictly right of the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3225d84455e28cf3582ea057725108c97e83f30e" translate="yes" xml:space="preserve">
          <source>Is the given transaction ID &lt;em&gt;visible&lt;/em&gt; according to this snapshot (that is, was it completed before the snapshot was taken)? Note that this function will not give the correct answer for a subtransaction ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db516f5dadc3d5e25dea043648eeea3321f5ccdb" translate="yes" xml:space="preserve">
          <source>Is the page dirty?</source>
          <target state="translated">Страница грязная?</target>
        </trans-unit>
        <trans-unit id="7a5b28f2abec65dff2a005cef1bab93ce79757ac" translate="yes" xml:space="preserve">
          <source>Is the policy permissive or restrictive?</source>
          <target state="translated">Политика разрешительная или ограничительная?</target>
        </trans-unit>
        <trans-unit id="1c868da3e376b67ccb29be6664b407ae22b09b84" translate="yes" xml:space="preserve">
          <source>Is the range empty?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff182ac571c70913b62ea8bad05f34c331a87f89" translate="yes" xml:space="preserve">
          <source>Is the range's lower bound inclusive?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca739e6c1b1df7d98a703e7f4cf56e0c0b73eb1f" translate="yes" xml:space="preserve">
          <source>Is the range's lower bound infinite?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f822412dc56d423cd1651a21ff0e5c86774082" translate="yes" xml:space="preserve">
          <source>Is the range's upper bound inclusive?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6edd78c835bde36ba19726c52d54bb7fc15f1a47" translate="yes" xml:space="preserve">
          <source>Is the range's upper bound infinite?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a6303395c0e1b94086b05146ed59054275f0b9" translate="yes" xml:space="preserve">
          <source>Is type (or domain) visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272dd553360faca6d08c14d4f1b40a013a88fc82" translate="yes" xml:space="preserve">
          <source>Is vertical?</source>
          <target state="translated">Вертикально?</target>
        </trans-unit>
        <trans-unit id="616318d9db61d03876a33f8c27e6df459bd2eff6" translate="yes" xml:space="preserve">
          <source>Isolation</source>
          <target state="translated">Isolation</target>
        </trans-unit>
        <trans-unit id="04fa9226f0713bae8b60402f090506b8771675ec" translate="yes" xml:space="preserve">
          <source>Isolation Level</source>
          <target state="translated">Уровень изоляции</target>
        </trans-unit>
        <trans-unit id="5ef461ce76cd9304ad8686fa89152e4b6011f931" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries support splitting compound words; a useful feature. Notice that the affix file should specify a special flag using the &lt;code&gt;compoundwords controlled&lt;/code&gt; statement that marks dictionary words that can participate in compound formation:</source>
          <target state="translated">Словари Ispell поддерживают разбиение составных слов; полезная функция. Обратите внимание, что в файле аффиксов должен быть указан специальный флаг с помощью оператора, &lt;code&gt;compoundwords controlled&lt;/code&gt; словами, который отмечает слова из словаря, которые могут участвовать в образовании составных слов:</target>
        </trans-unit>
        <trans-unit id="a44764c80f1ba0b240d3f5d527b95ad90a01a872" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries usually recognize a limited set of words, so they should be followed by another broader dictionary; for example, a Snowball dictionary, which recognizes everything.</source>
          <target state="translated">Орфографические словари обычно распознают ограниченный набор слов,поэтому за ними должен следовать другой более широкий словарь;например,словарь Snowball,который распознает все.</target>
        </trans-unit>
        <trans-unit id="d78243d5b6a6182e6f2ddf831b4aabfb7caae3f0" translate="yes" xml:space="preserve">
          <source>Issues a verification prompt before doing anything destructive.</source>
          <target state="translated">Перед тем,как сделать что-либо разрушительное,выдает запрос на проверку.</target>
        </trans-unit>
        <trans-unit id="f4c1344e1b107a94e97cb2d1c0387b09d48b1998" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ABORT&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">Выдача &lt;code&gt;ABORT&lt;/code&gt; вне блока транзакции вызывает предупреждение и в противном случае не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="51092034eb6099bfab57ce2cf44c57b972ed851c" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;BEGIN&lt;/code&gt; when already inside a transaction block will provoke a warning message. The state of the transaction is not affected. To nest transactions within a transaction block, use savepoints (see &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;).</source>
          <target state="translated">Выдача &lt;code&gt;BEGIN&lt;/code&gt; уже внутри блока транзакции вызовет предупреждающее сообщение. На состояние транзакции это не влияет. Чтобы вложить транзакции в блок транзакции, используйте точки сохранения (см. &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c66e92badb172759ea8ab0365668fbc4bfcd29b" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;COMMIT&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message. &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; when not inside a transaction is an error.</source>
          <target state="translated">Выполнение &lt;code&gt;COMMIT&lt;/code&gt; вне транзакции не повредит, но вызовет предупреждающее сообщение. &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; вне транзакции является ошибкой.</target>
        </trans-unit>
        <trans-unit id="d8f2914a3de77623d7fcc2d76c1402e19f0682c2" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;END&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message.</source>
          <target state="translated">Выдача &lt;code&gt;END&lt;/code&gt; вне транзакции не причинит вреда, но вызовет предупреждающее сообщение.</target>
        </trans-unit>
        <trans-unit id="9a3f1f230232d57deb86f9d1d1a7e859eaa17234" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ROLLBACK&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect. &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; outside of a transaction block is an error.</source>
          <target state="translated">Выполнение &lt;code&gt;ROLLBACK&lt;/code&gt; вне блока транзакции вызывает предупреждение и в противном случае не имеет никакого эффекта. &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; вне блока транзакции - это ошибка.</target>
        </trans-unit>
        <trans-unit id="1dd72b5f30a56642ade69ef87bd0dd32591ebc8c" translate="yes" xml:space="preserve">
          <source>It can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only the &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, &lt;code&gt;EXCEPT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, &lt;code&gt;OFFSET&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;FOR&lt;/code&gt; locking clauses can be used with &lt;code&gt;TABLE&lt;/code&gt;; the &lt;code&gt;WHERE&lt;/code&gt; clause and any form of aggregation cannot be used.</source>
          <target state="translated">Его можно использовать как команду верхнего уровня или как вариант синтаксиса для экономии места в частях сложных запросов. Только &lt;code&gt;WITH&lt;/code&gt; , &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; , &lt;code&gt;EXCEPT&lt;/code&gt; , &lt;code&gt;ORDER BY&lt;/code&gt; , &lt;code&gt;LIMIT&lt;/code&gt; , &lt;code&gt;OFFSET&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; и &lt;code&gt;FOR&lt;/code&gt; фиксации положения могут быть использованы с &lt;code&gt;TABLE&lt;/code&gt; ; &lt;code&gt;WHERE&lt;/code&gt; положение и любая форма агрегации не могут быть использованы.</target>
        </trans-unit>
        <trans-unit id="985845c593d43702ba4580f789c62a95ef3e445a" translate="yes" xml:space="preserve">
          <source>It can return 2 special key IDs:</source>
          <target state="translated">Он может вернуть 2 специальных идентификатора ключа:</target>
        </trans-unit>
        <trans-unit id="e06e730d80da388853db0ab9a33a7b2a082e1e65" translate="yes" xml:space="preserve">
          <source>It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</source>
          <target state="translated">Он создает соединение в режиме репликации, поэтому на него распространяются те же ограничения, что и на &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt; , плюс ограничения для логической репликации (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Главу 48&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="34093efa4b222287cf39e63aac85890d7758d772" translate="yes" xml:space="preserve">
          <source>It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4e1383f1e9f315e70a9d76f0a1946de5a791a1" translate="yes" xml:space="preserve">
          <source>It does not matter which order the opposite corners of a cube are entered in. The &lt;code&gt;cube&lt;/code&gt; functions automatically swap values if needed to create a uniform &amp;ldquo;lower left &amp;mdash; upper right&amp;rdquo; internal representation. When the corners coincide, &lt;code&gt;cube&lt;/code&gt; stores only one corner along with an &amp;ldquo;is point&amp;rdquo; flag to avoid wasting space.</source>
          <target state="translated">Не имеет значения, в каком порядке вводятся противоположные углы куба. Функции &lt;code&gt;cube&lt;/code&gt; автоматически меняют местами значения, если это необходимо для создания единого внутреннего представления &amp;laquo;нижний левый - верхний правый&amp;raquo;. Когда углы совпадают, &lt;code&gt;cube&lt;/code&gt; сохраняет только один угол вместе с флагом &amp;laquo;точка&amp;raquo;, чтобы не тратить лишнее место.</target>
        </trans-unit>
        <trans-unit id="aeb260c8d10781feddd45ff6a16008fdceb285b4" translate="yes" xml:space="preserve">
          <source>It does so by first creating all possible &lt;em&gt;paths&lt;/em&gt; leading to the same result. For example if there is an index on a relation to be scanned, there are two paths for the scan. One possibility is a simple sequential scan and the other possibility is to use the index. Next the cost for the execution of each path is estimated and the cheapest path is chosen. The cheapest path is expanded into a complete plan that the executor can use.</source>
          <target state="translated">Для этого сначала создаются все возможные &lt;em&gt;пути,&lt;/em&gt; ведущие к одному и тому же результату. Например, если есть индекс для отношения, которое нужно просканировать, есть два пути для сканирования. Одна возможность - это простое последовательное сканирование, а другая возможность - использовать индекс. Затем оценивается стоимость выполнения каждого пути и выбирается самый дешевый путь. Самый дешевый путь расширяется до полного плана, который может использовать исполнитель.</target>
        </trans-unit>
        <trans-unit id="22062c54b59724e3ba4ff79971e8d1516ebd1cef" translate="yes" xml:space="preserve">
          <source>It does this by skipping pages that have only visible tuples according to the visibility map (if a page has the corresponding VM bit set, then it is assumed to contain no dead tuples). For such pages, it derives the free space value from the free space map, and assumes that the rest of the space on the page is taken up by live tuples.</source>
          <target state="translated">Он делает это,пропуская страницы,которые имеют только видимые кортежи в соответствии с картой видимости (если страница имеет соответствующий набор VM-битов,то предполагается,что она не содержит мертвых кортежей).Для таких страниц он извлекает значение свободного пространства из карты свободного пространства и предполагает,что остальная часть пространства на странице занята живыми кортежами.</target>
        </trans-unit>
        <trans-unit id="289bb6de0c119ae341fea7727f0ae465a6ffb7a2" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;not&lt;/em&gt; recommended that you override this behavior by changing the session-level settings of these parameters; that is likely to cause &lt;code&gt;postgres_fdw&lt;/code&gt; to malfunction.</source>
          <target state="translated">Это &lt;em&gt;не&lt;/em&gt; рекомендуется , чтобы переопределить это поведение путем изменения настроек уровня сеанса этих параметров; это может вызвать сбои в работе &lt;code&gt;postgres_fdw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1927f65da9f3267669c003e30b5762ebad0dc5a9" translate="yes" xml:space="preserve">
          <source>It is a good idea to save the database server's log output somewhere, rather than just discarding it via &lt;code&gt;/dev/null&lt;/code&gt;. The log output is invaluable when diagnosing problems. However, the log output tends to be voluminous (especially at higher debug levels) so you won't want to save it indefinitely. You need to &lt;em&gt;rotate&lt;/em&gt; the log files so that new log files are started and old ones removed after a reasonable period of time.</source>
          <target state="translated">Лучше всего сохранить где-нибудь вывод журнала сервера базы данных, а не просто отбрасывать его через &lt;code&gt;/dev/null&lt;/code&gt; . Вывод журнала неоценим при диагностике проблем. Однако вывод журнала имеет тенденцию быть большим (особенно на более высоких уровнях отладки), поэтому вы не захотите сохранять его бесконечно. Вам необходимо &lt;em&gt;повернуть&lt;/em&gt; файлы журналов так, чтобы новые файлы журналов запускались, а старые удалялись по прошествии разумного периода времени.</target>
        </trans-unit>
        <trans-unit id="45d3adbb3df378f5fff436872f95f728d888325a" translate="yes" xml:space="preserve">
          <source>It is advantageous if the log is located on a different disk from the main database files. This can be achieved by moving the &lt;code&gt;pg_wal&lt;/code&gt; directory to another location (while the server is shut down, of course) and creating a symbolic link from the original location in the main data directory to the new location.</source>
          <target state="translated">Желательно, чтобы журнал располагался на диске, отличном от основных файлов базы данных. Этого можно достичь, переместив каталог &lt;code&gt;pg_wal&lt;/code&gt; в другое место (конечно, при выключенном сервере) и создав символическую ссылку из исходного местоположения в основном каталоге данных в новое местоположение.</target>
        </trans-unit>
        <trans-unit id="25c2883a31f29210a79363008b59988d33c5a31b" translate="yes" xml:space="preserve">
          <source>It is advisable to set &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; to a reasonably large value (but not more than the amount of RAM you can dedicate to the &lt;code&gt;CLUSTER&lt;/code&gt; operation) before clustering.</source>
          <target state="translated">Перед кластеризацией рекомендуется установить для &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; достаточно большое значение (но не больше, чем объем RAM, который вы можете &lt;code&gt;CLUSTER&lt;/code&gt; операции CLUSTER ).</target>
        </trans-unit>
        <trans-unit id="f4c2ed49f12a870b96cb954dbc625ee0c439a239" translate="yes" xml:space="preserve">
          <source>It is advisable to test your proposed archive command to ensure that it indeed does not overwrite an existing file, &lt;em&gt;and that it returns nonzero status in this case&lt;/em&gt;. The example command above for Unix ensures this by including a separate &lt;code&gt;test&lt;/code&gt; step. On some Unix platforms, &lt;code&gt;cp&lt;/code&gt; has switches such as &lt;code&gt;-i&lt;/code&gt; that can be used to do the same thing less verbosely, but you should not rely on these without verifying that the right exit status is returned. (In particular, GNU &lt;code&gt;cp&lt;/code&gt; will return status zero when &lt;code&gt;-i&lt;/code&gt; is used and the target file already exists, which is &lt;em&gt;not&lt;/em&gt; the desired behavior.)</source>
          <target state="translated">Желательно протестировать предложенную вами команду архивирования, чтобы убедиться, что она действительно не перезаписывает существующий файл &lt;em&gt;и что в этом случае она возвращает ненулевой статус&lt;/em&gt; . В приведенном выше примере команды для Unix это обеспечивается включением отдельного шага &lt;code&gt;test&lt;/code&gt; . На некоторых платформах Unix в &lt;code&gt;cp&lt;/code&gt; есть такие переключатели, как &lt;code&gt;-i&lt;/code&gt; , которые можно использовать для менее подробного выполнения того же действия, но вы не должны полагаться на них, не убедившись, что возвращается правильный статус выхода. (В частности, GNU &lt;code&gt;cp&lt;/code&gt; вернет нулевой статус, если используется &lt;code&gt;-i&lt;/code&gt; и целевой файл уже существует, что &lt;em&gt;не&lt;/em&gt; является желаемым поведением.)</target>
        </trans-unit>
        <trans-unit id="5ccc1a490a09faccece314c281e5a4bacdabe99b" translate="yes" xml:space="preserve">
          <source>It is also important to consider the overhead of partitioning during query planning and execution. The query planner is generally able to handle partition hierarchies with up to a few thousand partitions fairly well, provided that typical queries allow the query planner to prune all but a small number of partitions. Planning times become longer and memory consumption becomes higher when more partitions remain after the planner performs partition pruning. This is particularly true for the &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands. Another reason to be concerned about having a large number of partitions is that the server's memory consumption may grow significantly over a period of time, especially if many sessions touch large numbers of partitions. That's because each partition requires its metadata to be loaded into the local memory of each session that touches it.</source>
          <target state="translated">Также важно учитывать накладные расходы на секционирование во время планирования и выполнения запроса. Планировщик запросов, как правило, может достаточно хорошо обрабатывать иерархии разделов с несколькими тысячами разделов при условии, что типичные запросы позволяют планировщику запросов сокращать все разделы, кроме небольшого. Время планирования увеличивается, а потребление памяти увеличивается, когда остается больше разделов после того, как планировщик выполняет сокращение разделов. Это особенно верно для &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; .команды. Еще одна причина для беспокойства по поводу большого количества разделов заключается в том, что потребление памяти сервером может значительно возрасти с течением времени, особенно если многие сеансы касаются большого количества разделов. Это потому, что каждый раздел требует, чтобы его метаданные загружались в локальную память каждого сеанса, который его касается.</target>
        </trans-unit>
        <trans-unit id="08e56c7bbb1c5c1ca45ba0adfbd971830db5b40e" translate="yes" xml:space="preserve">
          <source>It is also possible to access the file as a foreign table, using the supplied &lt;a href=&quot;file-fdw&quot;&gt;file_fdw&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a8c0ea8274eada7feb8d1cce002d08a07341cc" translate="yes" xml:space="preserve">
          <source>It is also possible to construct an array from the results of a subquery. In this form, the array constructor is written with the key word &lt;code&gt;ARRAY&lt;/code&gt; followed by a parenthesized (not bracketed) subquery. For example:</source>
          <target state="translated">Также возможно построить массив из результатов подзапроса. В этой форме конструктор массива записывается с ключевым словом &lt;code&gt;ARRAY&lt;/code&gt; , за которым следует подзапрос в скобках (не в квадратных скобках). Например:</target>
        </trans-unit>
        <trans-unit id="21db650c844a5c99fb809ce100bf6bab36b3a9c1" translate="yes" xml:space="preserve">
          <source>It is also possible to create a chain of trust that includes intermediate certificates:</source>
          <target state="translated">Также можно создать цепочку доверия,включающую промежуточные сертификаты:</target>
        </trans-unit>
        <trans-unit id="1bbde7dfe5218957bc7115e4bb121f93797376d5" translate="yes" xml:space="preserve">
          <source>It is also possible to implement record-based log shipping using this alternative method, though this requires custom development, and changes will still only become visible to hot standby queries after a full WAL file has been shipped.</source>
          <target state="translated">Также возможно реализовать пересылку логов на основе записей с помощью этого альтернативного метода,хотя это требует индивидуальной разработки,и изменения все равно будут видны для запросов в горячем резерве только после того,как будет отправлен полный WAL файл.</target>
        </trans-unit>
        <trans-unit id="a889ddd9646ac2e435b2d44d186929390a588c8e" translate="yes" xml:space="preserve">
          <source>It is also possible to insert the result of a query (which might be no rows, one row, or many rows):</source>
          <target state="translated">Также возможно вставить результат запроса (это может быть не одна строка,не одна и не много строк):</target>
        </trans-unit>
        <trans-unit id="23dc30a3752f1a0512f87d6b42f04212daedc525" translate="yes" xml:space="preserve">
          <source>It is also possible to make a backup while the server is stopped. In this case, you obviously cannot use &lt;code&gt;pg_start_backup&lt;/code&gt; or &lt;code&gt;pg_stop_backup&lt;/code&gt;, and you will therefore be left to your own devices to keep track of which backup is which and how far back the associated WAL files go. It is generally better to follow the continuous archiving procedure above.</source>
          <target state="translated">Также возможно сделать резервную копию, когда сервер остановлен. В этом случае вы, очевидно, не можете использовать &lt;code&gt;pg_start_backup&lt;/code&gt; или &lt;code&gt;pg_stop_backup&lt;/code&gt; , и, следовательно, вы будете предоставлены вашим собственным устройствам, чтобы отслеживать, какая резервная копия является какой и как далеко уходят связанные файлы WAL. Как правило, лучше следовать описанной выше процедуре непрерывного архивирования.</target>
        </trans-unit>
        <trans-unit id="6383187f9793f49474de63c9c18fca5ed6c8c44d" translate="yes" xml:space="preserve">
          <source>It is also possible to pass a page to &lt;code&gt;bt_page_items&lt;/code&gt; as a &lt;code&gt;bytea&lt;/code&gt; value. A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. So the last example could also be rewritten like this:</source>
          <target state="translated">Также возможно передать страницу в &lt;code&gt;bt_page_items&lt;/code&gt; как значение &lt;code&gt;bytea&lt;/code&gt; . Изображение страницы, полученное с помощью &lt;code&gt;get_raw_page&lt;/code&gt; , должно быть передано в качестве аргумента. Итак, последний пример можно было бы переписать так:</target>
        </trans-unit>
        <trans-unit id="44f6da252a14d7892790fa503a4f493737f34471" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type cast using a function-like syntax:</source>
          <target state="translated">Также можно задать приведение типа,используя функциональноподобный синтаксис:</target>
        </trans-unit>
        <trans-unit id="da0d70336d913c862f76912f7ff4b7d2cecbbfee" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type coercion using a function-like syntax:</source>
          <target state="translated">Также можно задать принуждение типа с помощью функционального синтаксиса:</target>
        </trans-unit>
        <trans-unit id="6ce33e1d5683bd1e633283bcca0d2a1c2815c050" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific database rather than to a role; see &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE&lt;/a&gt;. If there is a conflict, database-role-specific settings override role-specific ones, which in turn override database-specific ones.</source>
          <target state="translated">Также возможно привязать сеанс по умолчанию к конкретной базе данных, а не к роли; см. &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE&lt;/a&gt; . В случае конфликта параметры, относящиеся к роли базы данных, переопределяют параметры, относящиеся к конкретной роли, которые, в свою очередь, переопределяют параметры, относящиеся к конкретной базе данных.</target>
        </trans-unit>
        <trans-unit id="752073224562183bf86377a6f918beef1da4c653" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific role rather than to a database; see &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;. Role-specific settings override database-specific ones if there is a conflict.</source>
          <target state="translated">Также возможно привязать сеанс по умолчанию к конкретной роли, а не к базе данных; см. &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; . Параметры, относящиеся к роли, переопределяют параметры, относящиеся к базе данных, в случае конфликта.</target>
        </trans-unit>
        <trans-unit id="c7b08ca18ddba24ea9814754a2d56bec9634faff" translate="yes" xml:space="preserve">
          <source>It is also possible to use arbitrary expressions in the &lt;code&gt;ORDER BY&lt;/code&gt; clause, including columns that do not appear in the &lt;code&gt;SELECT&lt;/code&gt; output list. Thus the following statement is valid:</source>
          <target state="translated">Также можно использовать произвольные выражения в предложении &lt;code&gt;ORDER BY&lt;/code&gt; , включая столбцы, которые не отображаются в выходном списке &lt;code&gt;SELECT&lt;/code&gt; . Таким образом, верно следующее утверждение:</target>
        </trans-unit>
        <trans-unit id="f4e580c8b0c33e188baa71c64a617a90c70459e7" translate="yes" xml:space="preserve">
          <source>It is also possible to use logical replication methods to create a standby server with the updated version of PostgreSQL. This is possible because logical replication supports replication between different major versions of PostgreSQL. The standby can be on the same computer or a different computer. Once it has synced up with the master server (running the older version of PostgreSQL), you can switch masters and make the standby the master and shut down the older database instance. Such a switch-over results in only several seconds of downtime for an upgrade.</source>
          <target state="translated">Также возможно использовать методы логической репликации для создания резервного сервера с обновленной версией PostgreSQL.Это возможно благодаря тому,что логическая репликация поддерживает репликацию между различными основными версиями PostgreSQL.Резервный сервер может быть как на одном компьютере,так и на другом.После синхронизации с основным сервером (при запуске более старой версии PostgreSQL),вы можете переключить &quot;мастер-сервер&quot; и сделать &quot;резервный&quot; основным компьютером,а старый экземпляр базы данных выключить.Такое переключение приводит к тому,что обновление занимает всего несколько секунд.</target>
        </trans-unit>
        <trans-unit id="2f14f1cce0e64f81899ff66a139003d88acce025" translate="yes" xml:space="preserve">
          <source>It is an error to mix configuration options for simple bind with options for search+bind.</source>
          <target state="translated">Ошибкой является смешивание опций конфигурации для простой привязки с опциями для поиска+привязки.</target>
        </trans-unit>
        <trans-unit id="8a93dfee21deef6822077b576885ec96bea313d5" translate="yes" xml:space="preserve">
          <source>It is best not to use SIGKILL to shut down the server. Doing so will prevent the server from releasing shared memory and semaphores. Furthermore, SIGKILL kills the &lt;code&gt;postgres&lt;/code&gt; process without letting it relay the signal to its subprocesses, so it might be necessary to kill the individual subprocesses by hand as well.</source>
          <target state="translated">Лучше не использовать SIGKILL для выключения сервера. Это предотвратит освобождение сервером общей памяти и семафоров. Более того, SIGKILL убивает процесс &lt;code&gt;postgres&lt;/code&gt; , не позволяя ему ретранслировать сигнал своим подпроцессам, поэтому может потребоваться также убить отдельные подпроцессы вручную.</target>
        </trans-unit>
        <trans-unit id="03425b40ae836e9eabd64694b0fe5bdd09ab82f4" translate="yes" xml:space="preserve">
          <source>It is best not to use parallelism when restoring from an archive made with this option, because pg_restore will not know exactly which partition(s) a given archive data item will load data into. This could result in inefficiency due to lock conflicts between parallel jobs, or perhaps even reload failures due to foreign key constraints being set up before all the relevant data is loaded.</source>
          <target state="translated">Лучше не использовать параллелизм при восстановлении из архива,сделанного с этим вариантом,так как pg_restore не будет точно знать,в какой раздел(ы)данного элемента данных архива будут загружаться данные.Это может привести к неэффективности из-за конфликтов блокировки между параллельными заданиями,или,возможно,даже к сбоям при перезагрузке из-за того,что перед загрузкой всех релевантных данных будут установлены ограничения постороннего ключа.</target>
        </trans-unit>
        <trans-unit id="98e38adf41282f06a6bcba53d9fb2cad2cffe8b4" translate="yes" xml:space="preserve">
          <source>It is common for a client that executes &lt;code&gt;NOTIFY&lt;/code&gt; to be listening on the same notification channel itself. In that case it will get back a notification event, just like all the other listening sessions. Depending on the application logic, this could result in useless work, for example, reading a database table to find the same updates that that session just wrote out. It is possible to avoid such extra work by noticing whether the notifying session's server process PID (supplied in the notification event message) is the same as one's own session's PID (available from libpq). When they are the same, the notification event is one's own work bouncing back, and can be ignored.</source>
          <target state="translated">Обычно клиент, выполняющий &lt;code&gt;NOTIFY&lt;/code&gt; , прослушивает тот же канал уведомления. В этом случае он вернет событие уведомления, как и все другие сеансы прослушивания. В зависимости от логики приложения это может привести к бесполезной работе, например, к чтению таблицы базы данных для поиска тех же обновлений, которые только что записал этот сеанс. Можно избежать такой дополнительной работы, заметив, совпадает ли PID процесса уведомляющего сеанса серверного процесса (указанный в сообщении о событии уведомления) с PID вашего собственного сеанса (доступным в libpq). Когда они совпадают, событие уведомления - это возвращение собственной работы, и его можно игнорировать.</target>
        </trans-unit>
        <trans-unit id="c9caa8dc8a351442eebfc90a7900dd2df9e2e966" translate="yes" xml:space="preserve">
          <source>It is common to see slow queries running bad execution plans because multiple columns used in the query clauses are correlated. The planner normally assumes that multiple conditions are independent of each other, an assumption that does not hold when column values are correlated. Regular statistics, because of their per-individual-column nature, cannot capture any knowledge about cross-column correlation. However, PostgreSQL has the ability to compute &lt;em&gt;multivariate statistics&lt;/em&gt;, which can capture such information.</source>
          <target state="translated">Часто можно увидеть медленные запросы, выполняющие плохие планы выполнения, потому что несколько столбцов, используемых в предложениях запроса, коррелированы. Планировщик обычно предполагает, что несколько условий не зависят друг от друга, что не выполняется, когда значения столбцов коррелированы. Регулярная статистика из-за того, что она предназначена для отдельных столбцов, не может фиксировать какие-либо сведения о корреляции между столбцами. Однако PostgreSQL может вычислять &lt;em&gt;многовариантную статистику&lt;/em&gt; , которая может собирать такую ​​информацию.</target>
        </trans-unit>
        <trans-unit id="716e43860306866d146f9c899994b23176f3323e" translate="yes" xml:space="preserve">
          <source>It is difficult to formulate a general procedure for determining which indexes to create. There are a number of typical cases that have been shown in the examples throughout the previous sections. A good deal of experimentation is often necessary. The rest of this section gives some tips for that:</source>
          <target state="translated">Сложно сформулировать общую процедуру определения того,какие индексы создавать.Существует ряд типичных случаев,которые были показаны в примерах в предыдущих разделах.Часто возникает необходимость проведения большого количества экспериментов.В остальной части этого раздела приведены некоторые советы на этот счет:</target>
        </trans-unit>
        <trans-unit id="8e2e75db678536414073cb564abf9bafb8f65d0c" translate="yes" xml:space="preserve">
          <source>It is easy to find your largest tables and indexes using this information:</source>
          <target state="translated">С помощью этой информации можно легко найти самые большие таблицы и индексы:</target>
        </trans-unit>
        <trans-unit id="e1f4af27f8aaeea1d69cd838327e07079c59b331" translate="yes" xml:space="preserve">
          <source>It is encrypted using the public key and put into the session key packet.</source>
          <target state="translated">Он зашифрован с помощью открытого ключа и помещен в пакет ключей сеанса.</target>
        </trans-unit>
        <trans-unit id="c1facaa0d2b2d45958e470a68a811dfa56fbe0cc" translate="yes" xml:space="preserve">
          <source>It is especially fatal to use very small test data sets. While selecting 1000 out of 100000 rows could be a candidate for an index, selecting 1 out of 100 rows will hardly be, because the 100 rows probably fit within a single disk page, and there is no plan that can beat sequentially fetching 1 disk page.</source>
          <target state="translated">Особенно фатально использовать очень маленькие наборы тестовых данных.В то время как выбор 1000 из 100000 строк может быть кандидатом на индекс,выбор 1 из 100 строк вряд ли будет,потому что 100 строк,вероятно,поместятся в одну страницу диска,и нет плана,который может бить последовательно получить 1 дисковую страницу.</target>
        </trans-unit>
        <trans-unit id="19ad949d23432743231dc352c6a17b2b375d15f1" translate="yes" xml:space="preserve">
          <source>It is essential that the same parameters are passed in order to obtain matching XML data mappings and XML Schema documents.</source>
          <target state="translated">Очень важно,чтобы эти же параметры передавались для получения совпадающих отображений XML-данных и документов XML-схем.</target>
        </trans-unit>
        <trans-unit id="3a50daa221b6ada829c86621c1e1031f8d10ee63" translate="yes" xml:space="preserve">
          <source>It is even possible for repeated executions of the same &lt;code&gt;LIMIT&lt;/code&gt; query to return different subsets of the rows of a table, if there is not an &lt;code&gt;ORDER BY&lt;/code&gt; to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case.</source>
          <target state="translated">Возможно даже повторное выполнение одного и того же запроса &lt;code&gt;LIMIT&lt;/code&gt; для возврата различных подмножеств строк таблицы, если нет &lt;code&gt;ORDER BY&lt;/code&gt; для принудительного выбора детерминированного подмножества. Опять же, это не ошибка; Детерминизм результатов в таком случае просто не гарантируется.</target>
        </trans-unit>
        <trans-unit id="10042e013ab2c07aefb508d6fa86ca0af029f7db" translate="yes" xml:space="preserve">
          <source>It is frequently convenient to group users together to ease management of privileges: that way, privileges can be granted to, or revoked from, a group as a whole. In PostgreSQL this is done by creating a role that represents the group, and then granting &lt;em&gt;membership&lt;/em&gt; in the group role to individual user roles.</source>
          <target state="translated">Часто удобно группировать пользователей вместе, чтобы упростить управление привилегиями: таким образом, привилегии могут быть предоставлены или отозваны для группы в целом. В PostgreSQL это делается путем создания роли, представляющей группу, а затем предоставления &lt;em&gt;членства&lt;/em&gt; в этой групповой роли отдельным ролям пользователей.</target>
        </trans-unit>
        <trans-unit id="c7233cabce0e70bf9b6042d864213cd71aa539f4" translate="yes" xml:space="preserve">
          <source>It is generally recommended that the columns of a foreign table be declared with exactly the same data types, and collations if applicable, as the referenced columns of the remote table. Although &lt;code&gt;postgres_fdw&lt;/code&gt; is currently rather forgiving about performing data type conversions at need, surprising semantic anomalies may arise when types or collations do not match, due to the remote server interpreting &lt;code&gt;WHERE&lt;/code&gt; clauses slightly differently from the local server.</source>
          <target state="translated">Обычно рекомендуется объявлять столбцы сторонней таблицы с точно такими же типами данных и сопоставлениями, если это применимо, как столбцы удаленной таблицы, на которые имеются ссылки. Хотя &lt;code&gt;postgres_fdw&lt;/code&gt; в настоящее время довольно снисходительно относится к преобразованию типов данных при необходимости, могут возникнуть неожиданные семантические аномалии, когда типы или сопоставления не совпадают, из-за того, что удаленный сервер интерпретирует &lt;code&gt;WHERE&lt;/code&gt; несколько иначе, чем локальный сервер.</target>
        </trans-unit>
        <trans-unit id="e59537e8306049dacf2891d27c403a8ccf0ae6a3" translate="yes" xml:space="preserve">
          <source>It is generally recommended to use &lt;code&gt;FOR UPDATE&lt;/code&gt; if the cursor is intended to be used with &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; or &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt;. Using &lt;code&gt;FOR UPDATE&lt;/code&gt; prevents other sessions from changing the rows between the time they are fetched and the time they are updated. Without &lt;code&gt;FOR UPDATE&lt;/code&gt;, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; command will have no effect if the row was changed since the cursor was created.</source>
          <target state="translated">Обычно рекомендуется использовать &lt;code&gt;FOR UPDATE&lt;/code&gt; , если курсор предназначен для использования с &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; или &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt; . Использование &lt;code&gt;FOR UPDATE&lt;/code&gt; предотвращает изменение строк другими сеансами между моментом их выборки и временем их обновления. Без &lt;code&gt;FOR UPDATE&lt;/code&gt; последующая команда &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; не будет иметь никакого эффекта, если строка была изменена с момента создания курсора.</target>
        </trans-unit>
        <trans-unit id="a83872fa85fd0323d70dd24a91d302ff7029d1c0" translate="yes" xml:space="preserve">
          <source>It is good practice to create a role that has the &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; privileges, but is not a superuser, and then use this role for all routine management of databases and roles. This approach avoids the dangers of operating as a superuser for tasks that do not really require it.</source>
          <target state="translated">Рекомендуется создать роль с привилегиями &lt;code&gt;CREATEDB&lt;/code&gt; и &lt;code&gt;CREATEROLE&lt;/code&gt; , но не суперпользователем, а затем использовать эту роль для рутинного управления базами данных и ролями. Такой подход позволяет избежать опасностей, связанных с работой в качестве суперпользователя для задач, которые на самом деле этого не требуют.</target>
        </trans-unit>
        <trans-unit id="de68fd3161d79a0dbb9addbaa913d55e1165d0a6" translate="yes" xml:space="preserve">
          <source>It is important for the command to return a zero exit status only if it succeeds. The command &lt;em&gt;will&lt;/em&gt; be asked for file names that are not present in the archive; it must return nonzero when so asked. Examples:</source>
          <target state="translated">Важно, чтобы команда возвращала нулевой статус выхода только в случае успеха. У команды &lt;em&gt;будут&lt;/em&gt; запрошены имена файлов, которых нет в архиве; при запросе он должен возвращать ненулевое значение. Примеры:</target>
        </trans-unit>
        <trans-unit id="cf6c5b8023371ed1577875e84b0b18cba96de2de" translate="yes" xml:space="preserve">
          <source>It is important that the &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; string not appear in any key values, else &lt;code&gt;connectby&lt;/code&gt; may incorrectly report an infinite-recursion error. Note that if &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; is not provided, a default value of &lt;code&gt;~&lt;/code&gt; is used for recursion detection purposes.</source>
          <target state="translated">Важно, &lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt; строка &lt;em&gt;branch_delim&lt;/em&gt; не появлялась ни в одном значении ключа, иначе &lt;code&gt;connectby&lt;/code&gt; может неверно сообщить об ошибке бесконечной рекурсии. Обратите внимание, что если &lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt; не &lt;em&gt;указан&lt;/em&gt; , значение по умолчанию &lt;code&gt;~&lt;/code&gt; используется для целей обнаружения рекурсии.</target>
        </trans-unit>
        <trans-unit id="b1ae60071a0616a68a075f0ef2a5eb0bf24ed27b" translate="yes" xml:space="preserve">
          <source>It is important that the administrator select appropriate settings for &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;. The best choices vary depending on business priorities. For example if the server is primarily tasked as a High Availability server, then you will want low delay settings, perhaps even zero, though that is a very aggressive setting. If the standby server is tasked as an additional server for decision support queries then it might be acceptable to set the maximum delay values to many hours, or even -1 which means wait forever for queries to complete.</source>
          <target state="translated">Важно, чтобы администратор выбрал соответствующие настройки для &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; и &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; . Лучший выбор зависит от приоритетов бизнеса. Например, если сервер в первую очередь выполняет роль сервера высокой доступности, вам потребуются настройки низкой задержки, возможно, даже нулевые, хотя это очень агрессивная настройка. Если резервный сервер задан как дополнительный сервер для запросов поддержки принятия решений, тогда может быть приемлемо установить максимальные значения задержки в несколько часов или даже -1, что означает бесконечное ожидание завершения запросов.</target>
        </trans-unit>
        <trans-unit id="261ccf1229f9ce7bf8e5f6c3bd334b4a4c87db09" translate="yes" xml:space="preserve">
          <source>It is important that the archive command return zero exit status if and only if it succeeds. Upon getting a zero result, PostgreSQL will assume that the file has been successfully archived, and will remove or recycle it. However, a nonzero status tells PostgreSQL that the file was not archived; it will try again periodically until it succeeds.</source>
          <target state="translated">Важно,чтобы команда &quot;Архив&quot; возвращала нулевой статус выхода,если и только в случае успеха.Получив нулевой результат,PostgreSQL будет считать,что файл успешно архивирован,и удалит или переработает его.Однако,ненулевой статус сообщает PostgreSQL,что файл не был заархивирован;он будет периодически повторять попытки до тех пор,пока не будет получен положительный результат.</target>
        </trans-unit>
        <trans-unit id="696e699e4bfd8bcf4f4c70ae89306a775c1076ba" translate="yes" xml:space="preserve">
          <source>It is important that the command return nonzero exit status on failure. The command &lt;em&gt;will&lt;/em&gt; be called requesting files that are not present in the archive; it must return nonzero when so asked. This is not an error condition. An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">Важно, чтобы команда возвращала ненулевой статус выхода при ошибке. Команда &lt;em&gt;будет&lt;/em&gt; вызываться запросом файлов, которых нет в архиве; при запросе он должен возвращать ненулевое значение. Это не состояние ошибки. Исключением является то, что если команда была прервана сигналом (отличным от SIGTERM, который используется как часть завершения работы сервера базы данных) или ошибкой оболочки (например, команда не найдена), то восстановление будет прервано, и сервер будет не заводится.</target>
        </trans-unit>
        <trans-unit id="23edc6be4b94044ef5894353c32ee9e7375bcbf5" translate="yes" xml:space="preserve">
          <source>It is important to note that the ranking functions do not use any global information, so it is impossible to produce a fair normalization to 1% or 100% as sometimes desired. Normalization option 32 (&lt;code&gt;rank/(rank+1)&lt;/code&gt;) can be applied to scale all ranks into the range zero to one, but of course this is just a cosmetic change; it will not affect the ordering of the search results.</source>
          <target state="translated">Важно отметить, что функции ранжирования не используют никакой глобальной информации, поэтому невозможно произвести справедливую нормализацию до 1% или 100%, как иногда требуется. Параметр нормализации 32 ( &lt;code&gt;rank/(rank+1)&lt;/code&gt; ) может применяться для масштабирования всех рангов в диапазоне от нуля до единицы, но, конечно, это всего лишь косметическое изменение; это не повлияет на порядок результатов поиска.</target>
        </trans-unit>
        <trans-unit id="52fc312b2cbf7e2b75157d95cff3456da87ba73a" translate="yes" xml:space="preserve">
          <source>It is important to note that the validation which is performed by pg_verifybackup does not and can not include every check which will be performed by a running server when attempting to make use of the backup. Even if you use this tool, you should still perform test restores and verify that the resulting databases work as expected and that they appear to contain the correct data. However, pg_verifybackup can detect many problems that commonly occur due to storage problems or user error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6953b33213a41a821ecf81913686f5a307e4e2" translate="yes" xml:space="preserve">
          <source>It is important to store the server's stdout and stderr output somewhere, as shown above. It will help for auditing purposes and to diagnose problems. (See &lt;a href=&quot;logfile-maintenance&quot;&gt;Section 24.3&lt;/a&gt; for a more thorough discussion of log file handling.)</source>
          <target state="translated">Важно где-нибудь хранить выходные данные сервера и stdout, как показано выше. Это поможет в целях аудита и диагностики проблем. (См. &lt;a href=&quot;logfile-maintenance&quot;&gt;Раздел 24.3&lt;/a&gt; для более подробного обсуждения обработки файлов журнала.)</target>
        </trans-unit>
        <trans-unit id="0c277ac6ce904cf376b200217f724f1a32321205" translate="yes" xml:space="preserve">
          <source>It is important to understand before studying &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; that the fact that a key word is not reserved in PostgreSQL does not mean that the feature related to the word is not implemented. Conversely, the presence of a key word does not indicate the existence of a feature.</source>
          <target state="translated">Перед изучением &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Таблицы C.1&lt;/a&gt; важно понять, что тот факт, что ключевое слово не зарезервировано в PostgreSQL, не означает, что функция, связанная с этим словом, не реализована. И наоборот, наличие ключевого слова не указывает на наличие функции.</target>
        </trans-unit>
        <trans-unit id="2afb84d06182545308e408bb344e52041de5bb4d" translate="yes" xml:space="preserve">
          <source>It is important to understand that the &lt;code&gt;tsvector&lt;/code&gt; type itself does not perform any word normalization; it assumes the words it is given are normalized appropriately for the application. For example,</source>
          <target state="translated">Важно понимать, что &lt;code&gt;tsvector&lt;/code&gt; тип tsvector не выполняет никакой нормализации слов; предполагается, что введенные слова нормализованы соответствующим образом для приложения. Например,</target>
        </trans-unit>
        <trans-unit id="2fc0b9aee575bb88d3b3c3db08a354cd3df94678" translate="yes" xml:space="preserve">
          <source>It is important to understand the interaction between aggregates and SQL's &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses. The fundamental difference between &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; is this: &lt;code&gt;WHERE&lt;/code&gt; selects input rows before groups and aggregates are computed (thus, it controls which rows go into the aggregate computation), whereas &lt;code&gt;HAVING&lt;/code&gt; selects group rows after groups and aggregates are computed. Thus, the &lt;code&gt;WHERE&lt;/code&gt; clause must not contain aggregate functions; it makes no sense to try to use an aggregate to determine which rows will be inputs to the aggregates. On the other hand, the &lt;code&gt;HAVING&lt;/code&gt; clause always contains aggregate functions. (Strictly speaking, you are allowed to write a &lt;code&gt;HAVING&lt;/code&gt; clause that doesn't use aggregates, but it's seldom useful. The same condition could be used more efficiently at the &lt;code&gt;WHERE&lt;/code&gt; stage.)</source>
          <target state="translated">Важно понимать взаимодействие между агрегатами и предложениями &lt;code&gt;WHERE&lt;/code&gt; и &lt;code&gt;HAVING&lt;/code&gt; в SQL . Фундаментальное различие между &lt;code&gt;WHERE&lt;/code&gt; и &lt;code&gt;HAVING&lt;/code&gt; заключается в следующем: &lt;code&gt;WHERE&lt;/code&gt; выбирает входные строки до вычисления групп и агрегатов (таким образом, он контролирует, какие строки идут в агрегатное вычисление), тогда как &lt;code&gt;HAVING&lt;/code&gt; выбирает групповые строки после того, как группы и агрегаты вычислены. Таким образом, &lt;code&gt;WHERE&lt;/code&gt; не должно содержать агрегатных функций; Нет смысла пытаться использовать агрегат, чтобы определить, какие строки будут входными данными для агрегатов. С другой стороны, &lt;code&gt;HAVING&lt;/code&gt; предложение всегда содержит агрегатные функции. (Строго говоря, вам разрешено писать предложение &lt;code&gt;HAVING&lt;/code&gt; , которое не использует агрегаты, но оно редко бывает полезным. То же условие можно было бы более эффективно использовать на этапе &lt;code&gt;WHERE&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="d6f798bec767ce149f1b4884b54e8874f501f623" translate="yes" xml:space="preserve">
          <source>It is legitimate to create a &lt;code&gt;pg_cast&lt;/code&gt; entry in which the source and target types are the same, if the associated function takes more than one argument. Such entries represent &amp;ldquo;length coercion functions&amp;rdquo; that coerce values of the type to be legal for a particular type modifier value.</source>
          <target state="translated">&lt;code&gt;pg_cast&lt;/code&gt; создание записи pg_cast, в которой исходный и целевой типы совпадают, если связанная функция принимает более одного аргумента. Такие записи представляют собой &amp;laquo;функции приведения длины&amp;raquo;, которые приводят значения типа к допустимым для определенного значения модификатора типа.</target>
        </trans-unit>
        <trans-unit id="dbc1f490f7774fb666f596c4d1e1fe3642c52d33" translate="yes" xml:space="preserve">
          <source>It is likely that &lt;code&gt;pg_pltemplate&lt;/code&gt; will be removed in some future release of PostgreSQL, in favor of keeping this knowledge about procedural languages in their respective extension installation scripts.</source>
          <target state="translated">Вероятно, что &lt;code&gt;pg_pltemplate&lt;/code&gt; будет удален в каком-то будущем выпуске PostgreSQL, чтобы сохранить эти знания о процедурных языках в соответствующих сценариях установки расширений.</target>
        </trans-unit>
        <trans-unit id="6bb4f0fbbfb491190c393dc7c8ea60757b692676" translate="yes" xml:space="preserve">
          <source>It is normally not necessary to create casts between user-defined types and the standard string types (&lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char(n)&lt;/code&gt;, as well as user-defined types that are defined to be in the string category). PostgreSQL provides automatic I/O conversion casts for that. The automatic casts to string types are treated as assignment casts, while the automatic casts from string types are explicit-only. You can override this behavior by declaring your own cast to replace an automatic cast, but usually the only reason to do so is if you want the conversion to be more easily invokable than the standard assignment-only or explicit-only setting. Another possible reason is that you want the conversion to behave differently from the type's I/O function; but that is sufficiently surprising that you should think twice about whether it's a good idea. (A small number of the built-in types do indeed have different behaviors for conversions, mostly because of requirements of the SQL standard.)</source>
          <target state="translated">Обычно нет необходимости создавать приведение типов между пользовательскими типами и стандартными строковыми типами ( &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; и &lt;code&gt;char(n)&lt;/code&gt; , а также определяемые пользователем типы, которые определены как строковые). PostgreSQL обеспечивает для этого автоматические преобразования ввода-вывода. Автоматическое приведение к строковым типам обрабатывается как приведение присваивания, тогда как автоматическое приведение к строковым типам является только явным. Вы можете переопределить это поведение, объявив свое собственное приведение для замены автоматического приведения, но обычно единственная причина для этого - если вы хотите, чтобы преобразование было более легко вызываемым, чем стандартная настройка только для назначения или только для явного. Другая возможная причина состоит в том, что вы хотите, чтобы преобразование велось иначе, чем функция ввода-вывода типа; но это достаточно удивительно, что вам стоит дважды подумать, хорошая ли это идея. (У небольшого числа встроенных типов действительно есть разное поведение для конверсий,в основном из-за требований стандарта SQL.)</target>
        </trans-unit>
        <trans-unit id="f92a52d7559ea7c6c8c28ba12e1fa17dfea96688" translate="yes" xml:space="preserve">
          <source>It is not allowed to combine &lt;code&gt;connect&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;create_slot&lt;/code&gt;, or &lt;code&gt;copy_data&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Не разрешается комбинировать для параметра &lt;code&gt;connect&lt;/code&gt; set значение &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;create_slot&lt;/code&gt; или &lt;code&gt;copy_data&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="072c5ad8d293ff2ada18ad71b639cc19ab727e57" translate="yes" xml:space="preserve">
          <source>It is not currently allowed to &lt;code&gt;PREPARE&lt;/code&gt; a transaction that has executed any operations involving temporary tables or the session's temporary namespace, created any cursors &lt;code&gt;WITH HOLD&lt;/code&gt;, or executed &lt;code&gt;LISTEN&lt;/code&gt;, &lt;code&gt;UNLISTEN&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;. Those features are too tightly tied to the current session to be useful in a transaction to be prepared.</source>
          <target state="translated">В настоящее время не разрешено &lt;code&gt;PREPARE&lt;/code&gt; транзакцию, которая выполнила какие-либо операции, связанные с временными таблицами или временным пространством имен сеанса, создала любые курсоры с помощью &lt;code&gt;WITH HOLD&lt;/code&gt; или выполнила &lt;code&gt;LISTEN&lt;/code&gt; , &lt;code&gt;UNLISTEN&lt;/code&gt; или &lt;code&gt;NOTIFY&lt;/code&gt; . Эти функции слишком сильно привязаны к текущему сеансу, чтобы быть полезными в транзакции, которую нужно подготовить.</target>
        </trans-unit>
        <trans-unit id="683c463d18b1311e371770a1d3375c3bacddce8d" translate="yes" xml:space="preserve">
          <source>It is not important to which database you connect here since the script file created by pg_dumpall will contain the appropriate commands to create and connect to the saved databases. An exception is that if you specified &lt;code&gt;--clean&lt;/code&gt;, you must connect to the &lt;code&gt;postgres&lt;/code&gt; database initially; the script will attempt to drop other databases immediately, and that will fail for the database you are connected to.</source>
          <target state="translated">Неважно, к какой базе данных вы здесь подключаетесь, поскольку файл сценария, созданный pg_dumpall, будет содержать соответствующие команды для создания и подключения к сохраненным базам данных. Исключением является то, что если вы указали &lt;code&gt;--clean&lt;/code&gt; , вы должны сначала подключиться к базе данных &lt;code&gt;postgres&lt;/code&gt; ; сценарий попытается немедленно удалить другие базы данных, и это не удастся для базы данных, к которой вы подключены.</target>
        </trans-unit>
        <trans-unit id="1b796566a4506096f72ab10f4b43942e3c90636a" translate="yes" xml:space="preserve">
          <source>It is not necessary to add the root certificate to &lt;code&gt;server.crt&lt;/code&gt;. Instead, clients must have the root certificate of the server's certificate chain.</source>
          <target state="translated">Добавлять корневой сертификат в &lt;code&gt;server.crt&lt;/code&gt; не обязательно . Вместо этого у клиентов должен быть корневой сертификат цепочки сертификатов сервера.</target>
        </trans-unit>
        <trans-unit id="c4d12fc72842b14e61904a6ec6e02667bd4e3ff1" translate="yes" xml:space="preserve">
          <source>It is not necessary to be concerned about the amount of time it takes to make a base backup. However, if you normally run the server with &lt;code&gt;full_page_writes&lt;/code&gt; disabled, you might notice a drop in performance while the backup runs since &lt;code&gt;full_page_writes&lt;/code&gt; is effectively forced on during backup mode.</source>
          <target state="translated">Нет необходимости беспокоиться о количестве времени, необходимом для создания базовой резервной копии. Однако, если вы обычно запускаете сервер с отключенным &lt;code&gt;full_page_writes&lt;/code&gt; , вы можете заметить падение производительности во время резервного копирования, поскольку &lt;code&gt;full_page_writes&lt;/code&gt; фактически принудительно включается в режиме резервного копирования.</target>
        </trans-unit>
        <trans-unit id="aca7caa9402f8a163da6c6daa7fb30a56a74a363" translate="yes" xml:space="preserve">
          <source>It is not necessary to create table constraints describing partition boundary condition for partitions. Instead, partition constraints are generated implicitly from the partition bound specification whenever there is need to refer to them.</source>
          <target state="translated">Нет необходимости создавать табличные ограничения,описывающие состояние границы простенка для простенков.Вместо этого,ограничения простенков генерируются неявно из спецификации связанных простенков всякий раз,когда на них нужно сослаться.</target>
        </trans-unit>
        <trans-unit id="cf0a2da0ce7b363dca7ad51ebb38c128a6e8bc4b" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or for which the number of additional bytes of storage required is zero.</source>
          <target state="translated">Нет необходимости реализовывать эту функцию для методов доступа,которые не поддерживают параллельное сканирование или для которых количество требуемых дополнительных байт памяти равно нулю.</target>
        </trans-unit>
        <trans-unit id="81e24e9944e94aaaad52d26039e5ac57f4d46637" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or in cases where the shared memory space required needs no initialization.</source>
          <target state="translated">Нет необходимости реализовывать эту функцию для методов доступа,не поддерживающих параллельное сканирование,или в случаях,когда требуемое общее пространство памяти не нуждается в инициализации.</target>
        </trans-unit>
        <trans-unit id="57e901fbd76f488aaa546e02fcd890de2339da2b" translate="yes" xml:space="preserve">
          <source>It is not necessary to provide both of these functions. If one is not specified, the language-specific default behavior will be used if necessary. (To prevent a transformation in a certain direction from happening at all, you could also write a transform function that always errors out.)</source>
          <target state="translated">Нет необходимости обеспечивать обе эти функции.Если одна из них не указана,то при необходимости будет использовано языковое поведение по умолчанию.(Чтобы преобразование в определенном направлении вообще не происходило,можно также написать функцию преобразования,которая всегда ошибается).</target>
        </trans-unit>
        <trans-unit id="8c2adbe3f4bf051ef1858dcf0e81ceda3ba80d46" translate="yes" xml:space="preserve">
          <source>It is not necessary to replay the WAL entries all the way to the end. We could stop the replay at any point and have a consistent snapshot of the database as it was at that time. Thus, this technique supports &lt;em&gt;point-in-time recovery&lt;/em&gt;: it is possible to restore the database to its state at any time since your base backup was taken.</source>
          <target state="translated">Нет необходимости полностью воспроизводить записи WAL до конца. Мы могли остановить воспроизведение в любой момент и получить согласованный снимок базы данных в том виде, в котором она была на тот момент. Таким образом, этот метод поддерживает &lt;em&gt;восстановление на определенный момент времени&lt;/em&gt; : можно восстановить базу данных до ее состояния в любое время с момента создания базовой резервной копии.</target>
        </trans-unit>
        <trans-unit id="ff889e8c8e60f8ff7137e71a9bfef2608859eeae" translate="yes" xml:space="preserve">
          <source>It is not necessary to supply correct user name, password, or database name values to obtain the server status; however, if incorrect values are provided, the server will log a failed connection attempt.</source>
          <target state="translated">Для получения статуса сервера нет необходимости указывать правильные значения имени пользователя,пароля или имени базы данных,однако в случае указания неправильных значений сервер зарегистрирует неудачную попытку подключения.</target>
        </trans-unit>
        <trans-unit id="594a9711ffec0cdfe29afe713704c6029ca7c0e7" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the &lt;code&gt;sync&lt;/code&gt; mount option. The behavior of the &lt;code&gt;async&lt;/code&gt; option is sufficient, since PostgreSQL issues &lt;code&gt;fsync&lt;/code&gt; calls at appropriate times to flush the write caches. (This is analogous to how it works on a local file system.) However, it is strongly recommended to use the &lt;code&gt;sync&lt;/code&gt; export option on the NFS &lt;em&gt;server&lt;/em&gt; on systems where it exists (mainly Linux). Otherwise, an &lt;code&gt;fsync&lt;/code&gt; or equivalent on the NFS client is not actually guaranteed to reach permanent storage on the server, which could cause corruption similar to running with the parameter &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; off. The defaults of these mount and export options differ between vendors and versions, so it is recommended to check and perhaps specify them explicitly in any case to avoid any ambiguity.</source>
          <target state="translated">Нет необходимости использовать параметр монтирования &lt;code&gt;sync&lt;/code&gt; . Поведение параметра &lt;code&gt;async&lt;/code&gt; достаточно, поскольку PostgreSQL в подходящее время выдает вызовы &lt;code&gt;fsync&lt;/code&gt; для очистки кешей записи. (Это аналогично тому, как это работает в локальной файловой системе.) Однако настоятельно рекомендуется использовать параметр экспорта &lt;code&gt;sync&lt;/code&gt; на &lt;em&gt;сервере&lt;/em&gt; NFS в системах, где он существует (в основном, Linux). В противном случае не гарантируется , что &lt;code&gt;fsync&lt;/code&gt; или эквивалент на клиенте NFS достигнет постоянного хранилища на сервере, что может вызвать повреждение, подобное работе с параметром &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync.&lt;/a&gt;выкл. Значения по умолчанию для этих параметров монтирования и экспорта различаются между поставщиками и версиями, поэтому рекомендуется проверить и, возможно, указать их явно в любом случае, чтобы избежать какой-либо двусмысленности.</target>
        </trans-unit>
        <trans-unit id="c52dffeed651be2fa3f87bf20ee3f9a890f9417b" translate="yes" xml:space="preserve">
          <source>It is not possible to release a savepoint when the transaction is in an aborted state.</source>
          <target state="translated">Невозможно освободить точку сохранения,когда транзакция находится в прерванном состоянии.</target>
        </trans-unit>
        <trans-unit id="bfd22308dc33a27874305473df207d131e6a6cc4" translate="yes" xml:space="preserve">
          <source>It is not possible to specify an operator's lexical precedence in &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, because the parser's precedence behavior is hard-wired. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for precedence details.</source>
          <target state="translated">Невозможно указать лексический приоритет оператора в &lt;code&gt;CREATE OPERATOR&lt;/code&gt; , потому что поведение приоритета парсера жестко запрограммировано. См. &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Раздел 4.1.6&lt;/a&gt; для подробностей о приоритете.</target>
        </trans-unit>
        <trans-unit id="623a5826c4c93a0ee1b0b35f75bc29bfa6d59c5f" translate="yes" xml:space="preserve">
          <source>It is not possible to turn a regular table into a partitioned table or vice versa. However, it is possible to add a regular or partitioned table containing data as a partition of a partitioned table, or remove a partition from a partitioned table turning it into a standalone table; see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to learn more about the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; and &lt;code&gt;DETACH PARTITION&lt;/code&gt; sub-commands.</source>
          <target state="translated">Невозможно превратить обычную таблицу в секционированную или наоборот. Однако можно добавить обычную или многораздельную таблицу, содержащую данные, в качестве раздела многораздельной таблицы или удалить раздел из многораздельной таблицы, превратив ее в автономную таблицу; см. &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE,&lt;/a&gt; чтобы узнать больше о &lt;code&gt;ATTACH PARTITION&lt;/code&gt; и &lt;code&gt;DETACH PARTITION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2662bc57686704e0177490490462c24f0b6b158d" translate="yes" xml:space="preserve">
          <source>It is often a good idea to also omit from the backup the files within the cluster's &lt;code&gt;pg_replslot/&lt;/code&gt; directory, so that replication slots that exist on the master do not become part of the backup. Otherwise, the subsequent use of the backup to create a standby may result in indefinite retention of WAL files on the standby, and possibly bloat on the master if hot standby feedback is enabled, because the clients that are using those replication slots will still be connecting to and updating the slots on the master, not the standby. Even if the backup is only intended for use in creating a new master, copying the replication slots isn't expected to be particularly useful, since the contents of those slots will likely be badly out of date by the time the new master comes on line.</source>
          <target state="translated">Часто рекомендуется также исключить из резервной копии файлы в &lt;code&gt;pg_replslot/&lt;/code&gt; кластера , чтобы слоты репликации, существующие на главном сервере , не стали частью резервной копии. В противном случае последующее использование резервной копии для создания резервной копии может привести к неопределенному сроку хранения файлов WAL в резервной системе и, возможно, к раздутию на главном сервере, если включена обратная связь с горячим резервом, потому что клиенты, которые используют эти слоты репликации, все равно будут подключаться к обновлению слотов на главном, а не на резервном. Даже если резервная копия предназначена только для использования при создании нового мастера, копирование слотов репликации не будет особенно полезным, так как содержимое этих слотов, вероятно, будет сильно устаревшим к тому времени, когда новый мастер войдет в сеть. .</target>
        </trans-unit>
        <trans-unit id="d49711f89af35705bbf2891f981f944c8b5260d9" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the function definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the function definition must be escaped by doubling them.</source>
          <target state="translated">Часто бывает полезно использовать долларовые &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;кавычки&lt;/a&gt; (см. Раздел 4.1.2.4 ) для записи строки определения функции вместо обычного синтаксиса одинарных кавычек. Без использования долларовых кавычек любые одинарные кавычки или обратные косые черты в определении функции должны быть экранированы путем их удвоения.</target>
        </trans-unit>
        <trans-unit id="070ae03385b0624216e0f28d18b1063fb9896a1e" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the procedure definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the procedure definition must be escaped by doubling them.</source>
          <target state="translated">Часто бывает полезно использовать долларовые &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;кавычки&lt;/a&gt; (см. Раздел 4.1.2.4 ) для записи строки определения процедуры вместо обычного синтаксиса одинарных кавычек. Без использования долларовых кавычек любые одинарные кавычки или обратные косые черты в определении процедуры должны быть экранированы путем их дублирования.</target>
        </trans-unit>
        <trans-unit id="1037cf4994d8c1ebf0e5d5f237e680d00560257d" translate="yes" xml:space="preserve">
          <source>It is often particularly handy to &lt;code&gt;LEFT JOIN&lt;/code&gt; to a &lt;code&gt;LATERAL&lt;/code&gt; subquery, so that source rows will appear in the result even if the &lt;code&gt;LATERAL&lt;/code&gt; subquery produces no rows for them. For example, if &lt;code&gt;get_product_names()&lt;/code&gt; returns the names of products made by a manufacturer, but some manufacturers in our table currently produce no products, we could find out which ones those are like this:</source>
          <target state="translated">Часто бывает особенно удобно &lt;code&gt;LEFT JOIN&lt;/code&gt; с &lt;code&gt;LATERAL&lt;/code&gt; подзапросом, так что исходные строки будут отображаться в результате, даже если &lt;code&gt;LATERAL&lt;/code&gt; подзапрос не создает для них строк. Например, если &lt;code&gt;get_product_names()&lt;/code&gt; возвращает названия продуктов, произведенных производителем, но некоторые производители в нашей таблице в настоящее время не производят продуктов, мы можем выяснить, какие из них такие:</target>
        </trans-unit>
        <trans-unit id="25dd81b9b45b03c00d03cc26e891361c1cfb5adf" translate="yes" xml:space="preserve">
          <source>It is often preferable to use unique index inference rather than naming a constraint directly using &lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt;&lt;code&gt;constraint_name&lt;/code&gt;. Inference will continue to work correctly when the underlying index is replaced by another more or less equivalent index in an overlapping way, for example when using &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; before dropping the index being replaced.</source>
          <target state="translated">Часто предпочтительнее использовать вывод уникального индекса, а не &lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt; &lt;code&gt;constraint_name&lt;/code&gt; напрямую с помощью ON CONFLICT ON CONSTRAINT имя_ограничения . Вывод будет продолжать работать правильно, когда базовый индекс заменяется другим более или менее эквивалентным индексом с перекрытием, например, при использовании &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; перед удалением заменяемого индекса.</target>
        </trans-unit>
        <trans-unit id="f0921a8a84d9d3343d74c19f7c3f5f4b06b1c95a" translate="yes" xml:space="preserve">
          <source>It is possible for a &lt;code&gt;SELECT&lt;/code&gt; command running at the &lt;code&gt;READ COMMITTED&lt;/code&gt; transaction isolation level and using &lt;code&gt;ORDER BY&lt;/code&gt; and a locking clause to return rows out of order. This is because &lt;code&gt;ORDER BY&lt;/code&gt; is applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once the &lt;code&gt;SELECT&lt;/code&gt; unblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing the &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; clause in a sub-query, for example</source>
          <target state="translated">Вполне возможно , для &lt;code&gt;SELECT&lt;/code&gt; , команд выполнявшихся в &lt;code&gt;READ COMMITTED&lt;/code&gt; уровня изоляции транзакций и с использованием &lt;code&gt;ORDER BY&lt;/code&gt; и положения блокировки для возврата строк из строя. Это потому, что &lt;code&gt;ORDER BY&lt;/code&gt; применяется первым. Команда сортирует результат, но затем может заблокировать попытку получить блокировку для одной или нескольких строк. После того, как &lt;code&gt;SELECT&lt;/code&gt; разблокируется, некоторые из значений упорядочивающего столбца могли быть изменены, что привело к тому, что эти строки оказались не в порядке (хотя они в порядке с точки зрения исходных значений столбца). При необходимости это можно обойти, поместив предложение &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; в подзапрос, например</target>
        </trans-unit>
        <trans-unit id="312a8769f42a09f432ff89ed107b0b0a082956d5" translate="yes" xml:space="preserve">
          <source>It is possible for both the client and server to provide SSL certificates to each other. It takes some extra configuration on each side, but this provides stronger verification of identity than the mere use of passwords. It prevents a computer from pretending to be the server just long enough to read the password sent by the client. It also helps prevent &amp;ldquo;man in the middle&amp;rdquo; attacks where a computer between the client and server pretends to be the server and reads and passes all data between the client and server.</source>
          <target state="translated">И клиент, и сервер могут предоставлять друг другу сертификаты SSL. Для каждой стороны требуется дополнительная настройка, но это обеспечивает более надежную проверку личности, чем простое использование паролей. Это не позволяет компьютеру притворяться сервером достаточно долго, чтобы прочитать пароль, отправленный клиентом. Это также помогает предотвратить атаки типа &amp;laquo;человек посередине&amp;raquo;, когда компьютер между клиентом и сервером выдает себя за сервер, читает и передает все данные между клиентом и сервером.</target>
        </trans-unit>
        <trans-unit id="90f59c9a7c7c3d668eb0d91ba42953cad54439f7" translate="yes" xml:space="preserve">
          <source>It is possible for the &lt;code&gt;query&lt;/code&gt; (&lt;code&gt;SELECT&lt;/code&gt; statement) to also contain a &lt;code&gt;WITH&lt;/code&gt; clause. In such a case both sets of &lt;code&gt;with_query&lt;/code&gt; can be referenced within the &lt;code&gt;query&lt;/code&gt;, but the second one takes precedence since it is more closely nested.</source>
          <target state="translated">Это возможно для &lt;code&gt;query&lt;/code&gt; ( &lt;code&gt;SELECT&lt;/code&gt; , заявление) также содержат &lt;code&gt;WITH&lt;/code&gt; п. В таком случае оба набора &lt;code&gt;with_query&lt;/code&gt; можно ссылаться в &lt;code&gt;query&lt;/code&gt; , но второй один имеет преимущество , так как она более тесно вложенный.</target>
        </trans-unit>
        <trans-unit id="db7d99e745d7786411f8e352570962f202386c2e" translate="yes" xml:space="preserve">
          <source>It is possible for the parser to produce overlapping tokens from the same piece of text. As an example, a hyphenated word will be reported both as the entire word and as each component:</source>
          <target state="translated">Парсер может создавать перекрывающиеся маркеры из одного и того же фрагмента текста.В качестве примера,дефисованное слово будет сообщено и как целое слово,и как каждый компонент:</target>
        </trans-unit>
        <trans-unit id="2357da6f1597b1c38d9b19b97f4eaf9ba4d3b605" translate="yes" xml:space="preserve">
          <source>It is possible that the replication delay between servers exceeds the value of this parameter, in which case no delay is added. Note that the delay is calculated between the WAL time stamp as written on master and the current time on the standby. Delays in transfer because of network lag or cascading replication configurations may reduce the actual wait time significantly. If the system clocks on master and standby are not synchronized, this may lead to recovery applying records earlier than expected; but that is not a major issue because useful settings of this parameter are much larger than typical time deviations between servers.</source>
          <target state="translated">Возможно,что задержка репликации между серверами превышает значение этого параметра,в этом случае задержка не добавляется.Обратите внимание,что задержка вычисляется между меткой времени WAL,записанной на мастере,и текущим временем на дежурстве.Задержки при передаче из-за сетевой задержки или каскадной конфигурации репликации могут значительно сократить фактическое время ожидания.Если системные часы на мастере и в режиме ожидания не синхронизированы,это может привести к восстановлению,применяя записи раньше,чем ожидалось;но это не является серьезной проблемой,поскольку полезные настройки этого параметра намного больше,чем типичные отклонения во времени между серверами.</target>
        </trans-unit>
        <trans-unit id="f9e86aaa136a99713e8aa37be86f1493657e5f36" translate="yes" xml:space="preserve">
          <source>It is possible to access the two component numbers of a &lt;code&gt;point&lt;/code&gt; as though the point were an array with indexes 0 and 1. For example, if &lt;code&gt;t.p&lt;/code&gt; is a &lt;code&gt;point&lt;/code&gt; column then &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; retrieves the X coordinate and &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; changes the Y coordinate. In the same way, a value of type &lt;code&gt;box&lt;/code&gt; or &lt;code&gt;lseg&lt;/code&gt; can be treated as an array of two &lt;code&gt;point&lt;/code&gt; values.</source>
          <target state="translated">Можно получить доступ к двум номерам компонентов &lt;code&gt;point&lt;/code&gt; как если бы точка была массивом с индексами 0 и 1. Например, если &lt;code&gt;t.p&lt;/code&gt; является столбцом &lt;code&gt;point&lt;/code&gt; тогда &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; извлекает координату X и &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; изменяет координату Y. Таким же образом значение типа &lt;code&gt;box&lt;/code&gt; или &lt;code&gt;lseg&lt;/code&gt; можно рассматривать как массив из двух значений &lt;code&gt;point&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d05975d6f7f169fef234fa65303a022ea6de537" translate="yes" xml:space="preserve">
          <source>It is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, so that the values will be kept across reboots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd72ecc1dea1c97715f5cc99a51c3564620c9cb" translate="yes" xml:space="preserve">
          <source>It is possible to check the accuracy of the planner's estimates by using &lt;code&gt;EXPLAIN&lt;/code&gt;'s &lt;code&gt;ANALYZE&lt;/code&gt; option. With this option, &lt;code&gt;EXPLAIN&lt;/code&gt; actually executes the query, and then displays the true row counts and true run time accumulated within each plan node, along with the same estimates that a plain &lt;code&gt;EXPLAIN&lt;/code&gt; shows. For example, we might get a result like this:</source>
          <target state="translated">Можно проверить точность оценок в планировщике с помощью &lt;code&gt;EXPLAIN&lt;/code&gt; &amp;laquo;s &lt;code&gt;ANALYZE&lt;/code&gt; вариант. С этой опцией &lt;code&gt;EXPLAIN&lt;/code&gt; фактически выполняет запрос, а затем отображает истинное количество строк и истинное время выполнения, накопленное в каждом узле плана, вместе с теми же оценками, которые показывает простой &lt;code&gt;EXPLAIN&lt;/code&gt; . Например, мы можем получить такой результат:</target>
        </trans-unit>
        <trans-unit id="ed45fb50f823ca992b140dff1d81be186a3aef4d" translate="yes" xml:space="preserve">
          <source>It is possible to control the query planner to some extent by using the explicit &lt;code&gt;JOIN&lt;/code&gt; syntax. To see why this matters, we first need some background.</source>
          <target state="translated">Можно до некоторой степени управлять планировщиком запросов, используя явный синтаксис &lt;code&gt;JOIN&lt;/code&gt; . Чтобы понять, почему это важно, нам сначала понадобится немного предыстории.</target>
        </trans-unit>
        <trans-unit id="21ffb53e2d68da0c7954b41e98f5975f4ecf8084" translate="yes" xml:space="preserve">
          <source>It is possible to create a foreign-data wrapper with no handler function, but foreign tables using such a wrapper can only be declared, not accessed.</source>
          <target state="translated">Можно создать обертку посторонних данных без функции обработчика,но посторонние таблицы,используя такую обертку,можно только объявлять,а не обращаться к ним.</target>
        </trans-unit>
        <trans-unit id="d5bd3763bfcd5993518d08a6fc8f19894d8b599a" translate="yes" xml:space="preserve">
          <source>It is possible to create additional template databases, and indeed one can copy any database in a cluster by specifying its name as the template for &lt;code&gt;CREATE DATABASE&lt;/code&gt;. It is important to understand, however, that this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the source database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; during the copy operation, new connections to the source database are prevented.</source>
          <target state="translated">Можно создать дополнительные базы данных шаблонов, и действительно можно скопировать любую базу данных в кластере, указав ее имя в качестве шаблона для &lt;code&gt;CREATE DATABASE&lt;/code&gt; . Однако важно понимать, что это (пока) не предназначено в качестве универсального средства &amp;laquo; &lt;code&gt;COPY DATABASE&lt;/code&gt; &amp;raquo;. Основное ограничение заключается в том, что никакие другие сеансы не могут быть подключены к исходной базе данных во время ее копирования. &lt;code&gt;CREATE DATABASE&lt;/code&gt; завершится ошибкой, если при запуске существует какое-либо другое соединение; во время операции копирования новые подключения к исходной базе данных не допускаются.</target>
        </trans-unit>
        <trans-unit id="e68d9c04db6c0169a67f695c187f5caec6e9c6fb" translate="yes" xml:space="preserve">
          <source>It is possible to dispense with &lt;code&gt;SET TRANSACTION&lt;/code&gt; by instead specifying the desired &lt;code&gt;transaction_modes&lt;/code&gt; in &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt;. But that option is not available for &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt;.</source>
          <target state="translated">Можно обойтись без &lt;code&gt;SET TRANSACTION&lt;/code&gt; , указав вместо этого желаемые &lt;code&gt;transaction_modes&lt;/code&gt; в &lt;code&gt;BEGIN&lt;/code&gt; или &lt;code&gt;START TRANSACTION&lt;/code&gt; . Но эта опция недоступна для &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6a819090253f862f39b7dcfdb25432b06b91898" translate="yes" xml:space="preserve">
          <source>It is possible to do a full text search without an index. A simple query to print the &lt;code&gt;title&lt;/code&gt; of each row that contains the word &lt;code&gt;friend&lt;/code&gt; in its &lt;code&gt;body&lt;/code&gt; field is:</source>
          <target state="translated">Возможен полнотекстовый поиск без индекса. Простой запрос для печати &lt;code&gt;title&lt;/code&gt; каждой строки, содержащей слово &lt;code&gt;friend&lt;/code&gt; в поле &lt;code&gt;body&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6f136c23eebfd4cd415f6012b712c4df1242fdcd" translate="yes" xml:space="preserve">
          <source>It is possible to have authentication without encryption overhead by using &lt;code&gt;NULL-SHA&lt;/code&gt; or &lt;code&gt;NULL-MD5&lt;/code&gt; ciphers. However, a man-in-the-middle could read and pass communications between client and server. Also, encryption overhead is minimal compared to the overhead of authentication. For these reasons NULL ciphers are not recommended.</source>
          <target state="translated">Можно выполнить аутентификацию без накладных расходов на шифрование с помощью шифров &lt;code&gt;NULL-SHA&lt;/code&gt; или &lt;code&gt;NULL-MD5&lt;/code&gt; . Однако &amp;laquo;человек посередине&amp;raquo; может читать и передавать сообщения между клиентом и сервером. Кроме того, накладные расходы на шифрование минимальны по сравнению с накладными расходами на аутентификацию. По этим причинам использование NULL-шифров не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="c3a0ba5698f2b4b4f4b4ee88ac329603107cde1d" translate="yes" xml:space="preserve">
          <source>It is possible to log to stderr without using the logging collector; the log messages will just go to wherever the server's stderr is directed. However, that method is only suitable for low log volumes, since it provides no convenient way to rotate log files. Also, on some platforms not using the logging collector can result in lost or garbled log output, because multiple processes writing concurrently to the same log file can overwrite each other's output.</source>
          <target state="translated">Можно войти в stderr без использования коллектора журналов;сообщения журнала будут просто направляться туда,куда направляется stderr сервера.Однако,этот метод подходит только для небольших объемов логов,так как не предоставляет удобного способа поворота лог-файлов.Кроме того,на некоторых платформах,не использующих лог-коллектор,это может привести к потере или искажению вывода логов,так как несколько процессов,записывающих одновременно в один и тот же лог-файл,могут перезаписать вывод друг друга.</target>
        </trans-unit>
        <trans-unit id="3d8f4459b3f7e90845c901d21d257a7423c267d0" translate="yes" xml:space="preserve">
          <source>It is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e9a78df914fad0648da0a65b3ec648ec904013" translate="yes" xml:space="preserve">
          <source>It is possible to nest dollar-quoted string constants by choosing different tags at each nesting level. This is most commonly used in writing function definitions. For example:</source>
          <target state="translated">Гнездить строковые константы,котируемые в долларах США,можно,выбирая различные теги на каждом уровне гнездования.Это наиболее часто используется при написании определений функций.Например:</target>
        </trans-unit>
        <trans-unit id="a0a345a5b07bad2c1307139346533842f66f7f85" translate="yes" xml:space="preserve">
          <source>It is possible to omit the &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; of a slice specifier; the missing bound is replaced by the lower or upper limit of the array's subscripts. For example:</source>
          <target state="translated">Можно опустить &lt;code&gt;lower-bound&lt;/code&gt; и / или &lt;code&gt;upper-bound&lt;/code&gt; спецификатора среза; пропущенная граница заменяется нижней или верхней границей индексов массива. Например:</target>
        </trans-unit>
        <trans-unit id="0fbcc6e88bd4f468012c5b5e8934f903489fc504" translate="yes" xml:space="preserve">
          <source>It is possible to run &lt;code&gt;ANALYZE&lt;/code&gt; on specific tables and even just specific columns of a table, so the flexibility exists to update some statistics more frequently than others if your application requires it. In practice, however, it is usually best to just analyze the entire database, because it is a fast operation. &lt;code&gt;ANALYZE&lt;/code&gt; uses a statistically random sampling of the rows of a table rather than reading every single row.</source>
          <target state="translated">Можно запускать &lt;code&gt;ANALYZE&lt;/code&gt; для определенных таблиц и даже только для определенных столбцов таблицы, поэтому существует гибкость, позволяющая обновлять одни статистические данные чаще, чем другие, если этого требует ваше приложение. Однако на практике обычно лучше всего проанализировать всю базу данных, поскольку это быстрая операция. &lt;code&gt;ANALYZE&lt;/code&gt; использует статистически случайную выборку строк таблицы, а не чтение каждой отдельной строки.</target>
        </trans-unit>
        <trans-unit id="56b863d1457c5714b3cbf931bd78aab64ed29d7b" translate="yes" xml:space="preserve">
          <source>It is possible to set up more complex expression indexes wherein the configuration name is specified by another column, e.g.:</source>
          <target state="translated">Можно задавать более сложные индексы выражений,в которых имя конфигурации задается другим столбцом,например</target>
        </trans-unit>
        <trans-unit id="ab7995c28ab9203226049f19e6325626835b07f5" translate="yes" xml:space="preserve">
          <source>It is possible to use PostgreSQL's backup facilities to produce standalone hot backups. These are backups that cannot be used for point-in-time recovery, yet are typically much faster to backup and restore than pg_dump dumps. (They are also much larger than pg_dump dumps, so in some cases the speed advantage might be negated.)</source>
          <target state="translated">Возможно использовать средства резервного копирования PostgreSQL для создания автономных горячих резервных копий.Это резервные копии,которые не могут быть использованы для восстановления по времени,но обычно гораздо быстрее,чем дамп pg_dump.(Они также намного больше,чем дамп pg_dump,поэтому в некоторых случаях преимущество в скорости может быть сведено на нет).</target>
        </trans-unit>
        <trans-unit id="793bdae387c6386aab767254ea0495efd0a0f102" translate="yes" xml:space="preserve">
          <source>It is possible to use SELinux's dynamic domain transition feature to switch the security label of the client process, the client domain, to a new context, if that is allowed by the security policy. The client domain needs the &lt;code&gt;setcurrent&lt;/code&gt; permission and also &lt;code&gt;dyntransition&lt;/code&gt; from the old to the new domain.</source>
          <target state="translated">Можно использовать функцию динамического перехода домена SELinux для переключения метки безопасности клиентского процесса, клиентского домена, в новый контекст, если это разрешено политикой безопасности. Клиентскому домену требуется разрешение &lt;code&gt;setcurrent&lt;/code&gt; , а также &lt;code&gt;dyntransition&lt;/code&gt; от старого домена к новому.</target>
        </trans-unit>
        <trans-unit id="fea64923e6a1c45508b51b78c6ed3fd042a235d3" translate="yes" xml:space="preserve">
          <source>It is possible to use SSH to encrypt the network connection between clients and a PostgreSQL server. Done properly, this provides an adequately secure network connection, even for non-SSL-capable clients.</source>
          <target state="translated">Возможно использовать SSH для шифрования сетевого соединения между клиентами и сервером PostgreSQL.Если все сделано правильно,это обеспечивает достаточно безопасное сетевое соединение,даже для клиентов,не поддерживающих SSL.</target>
        </trans-unit>
        <trans-unit id="05887c55098593888d9b6548b102c0d07ee418cb" translate="yes" xml:space="preserve">
          <source>It is possible to use an NFS file system for storing the PostgreSQL data directory. PostgreSQL does nothing special for NFS file systems, meaning it assumes NFS behaves exactly like locally-connected drives. PostgreSQL does not use any functionality that is known to have nonstandard behavior on NFS, such as file locking.</source>
          <target state="translated">Для хранения каталога данных PostgreSQL можно использовать файловую систему NFS.PostgreSQL не делает ничего особенного для файловых систем NFS,то есть предполагает,что NFS ведет себя точно так же,как локально подключенные диски.PostgreSQL не использует функциональность,которая,как известно,имеет нестандартное поведение в NFS,например,блокировка файлов.</target>
        </trans-unit>
        <trans-unit id="d07d0d357ed59e4c40820ac16ee2111a412a9fe9" translate="yes" xml:space="preserve">
          <source>It is recommended that in a &lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; call, the access method further verify that the target row actually does have an existing entry in the index, and report error if not. This is a good idea because the index tuple values passed to &lt;code&gt;aminsert&lt;/code&gt; will have been recomputed. If the index definition involves functions that are not really immutable, we might be checking the wrong area of the index. Checking that the target row is found in the recheck verifies that we are scanning for the same tuple values as were used in the original insertion.</source>
          <target state="translated">Рекомендуется, чтобы при вызове &lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; метод доступа дополнительно проверял , действительно ли целевая строка имеет существующую запись в индексе, и сообщал об ошибке, если нет. Это хорошая идея, потому что значения кортежа индекса, переданные в &lt;code&gt;aminsert&lt;/code&gt; , будут пересчитаны. Если определение индекса включает в себя функции, которые на самом деле не являются неизменяемыми, возможно, мы проверяем неправильную область индекса. Проверка того, что целевая строка найдена при повторной проверке, подтверждает, что мы ищем те же значения кортежа, которые использовались при исходной вставке.</target>
        </trans-unit>
        <trans-unit id="302398642319ebf3c5925fc78db8e53f6245f737" translate="yes" xml:space="preserve">
          <source>It is recommended that the file name used in &lt;code&gt;COPY&lt;/code&gt; always be specified as an absolute path. This is enforced by the server in the case of &lt;code&gt;COPY TO&lt;/code&gt;, but for &lt;code&gt;COPY FROM&lt;/code&gt; you do have the option of reading from a file specified by a relative path. The path will be interpreted relative to the working directory of the server process (normally the cluster's data directory), not the client's working directory.</source>
          <target state="translated">Рекомендуется всегда указывать имя файла, используемое в &lt;code&gt;COPY&lt;/code&gt; , как абсолютный путь. Это принудительно выполняется сервером в случае &lt;code&gt;COPY TO&lt;/code&gt; , но для &lt;code&gt;COPY FROM&lt;/code&gt; у вас есть возможность чтения из файла, указанного относительным путем. Путь будет интерпретироваться относительно рабочего каталога серверного процесса (обычно каталога данных кластера), а не рабочего каталога клиента.</target>
        </trans-unit>
        <trans-unit id="fc0e534ffa8e632dc4cfe7cd8ad98fc538520874" translate="yes" xml:space="preserve">
          <source>It is recommended that you use the pg_dump and pg_dumpall programs from the &lt;em&gt;newer&lt;/em&gt; version of PostgreSQL, to take advantage of enhancements that might have been made in these programs. Current releases of the dump programs can read data from any server version back to 7.0.</source>
          <target state="translated">Рекомендуется использовать программы pg_dump и pg_dumpall из &lt;em&gt;более новой&lt;/em&gt; версии PostgreSQL, чтобы воспользоваться преимуществами улучшений, которые могли быть внесены в эти программы. Текущие выпуски программ дампа могут считывать данные с любой версии сервера до 7.0.</target>
        </trans-unit>
        <trans-unit id="9c852fda272f66e174a3889edb42521ecc91c452" translate="yes" xml:space="preserve">
          <source>It is redundant to use the &lt;code&gt;clientcert&lt;/code&gt; option with &lt;code&gt;cert&lt;/code&gt; authentication because &lt;code&gt;cert&lt;/code&gt; authentication is effectively &lt;code&gt;trust&lt;/code&gt; authentication with &lt;code&gt;clientcert=verify-full&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580dc3a7b05e5fa4e5a6d4851ec4e93eeb1cdf02" translate="yes" xml:space="preserve">
          <source>It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be resent from the publisher.</source>
          <target state="translated">Для логической репликации безопасно использовать &lt;code&gt;off&lt;/code&gt; : если подписчик теряет транзакции из-за отсутствия синхронизации, данные будут повторно отправлены издателем.</target>
        </trans-unit>
        <trans-unit id="b5365d46a8cd20c8ffe5a596a1e9394f61f94500" translate="yes" xml:space="preserve">
          <source>It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be sent again from the publisher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f5d0a01be6a99ad6990afcd555514ae6b7efcb" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that &lt;code&gt;earthdistance&lt;/code&gt; and &lt;code&gt;cube&lt;/code&gt; be installed in the same schema, and that that schema be one for which CREATE privilege has not been and will not be granted to any untrusted users. Otherwise there are installation-time security hazards if &lt;code&gt;earthdistance&lt;/code&gt;'s schema contains objects defined by a hostile user. Furthermore, when using &lt;code&gt;earthdistance&lt;/code&gt;'s functions after installation, the entire search path should contain only trusted schemas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a88889b7d21af89f699959f3df667165202cd6" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications generating &lt;code&gt;COPY&lt;/code&gt; data convert data newlines and carriage returns to the &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; sequences respectively. At present it is possible to represent a data carriage return by a backslash and carriage return, and to represent a data newline by a backslash and newline. However, these representations might not be accepted in future releases. They are also highly vulnerable to corruption if the &lt;code&gt;COPY&lt;/code&gt; file is transferred across different machines (for example, from Unix to Windows or vice versa).</source>
          <target state="translated">Настоятельно рекомендуется, чтобы приложения, генерирующие данные &lt;code&gt;COPY&lt;/code&gt; , преобразовывали символы новой строки и возврата каретки в последовательности &lt;code&gt;\n&lt;/code&gt; и &lt;code&gt;\r&lt;/code&gt; соответственно. В настоящее время можно представить возврат каретки данных с помощью обратной косой черты и возврата каретки, а новую строку данных - с помощью обратной косой черты и новой строки. Однако эти представления могут быть не приняты в будущих выпусках. Они также очень уязвимы для повреждения, если файл &lt;code&gt;COPY&lt;/code&gt; переносится на разные машины (например, с Unix на Windows или наоборот).</target>
        </trans-unit>
        <trans-unit id="d870a88dee5f04bff258cb0a3da6e5856609ce9f" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;hstore&lt;/code&gt;. Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027fad8c14749d5c9a12505629778b95ee9e9e46" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;ltree&lt;/code&gt;. Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d757720e64f735dd8e83c5c66b88db49094003f" translate="yes" xml:space="preserve">
          <source>It is typically used like this:</source>
          <target state="translated">Обычно его используют вот так:</target>
        </trans-unit>
        <trans-unit id="cb6eae65d1260158a9aaaa3278cf273df69fbee7" translate="yes" xml:space="preserve">
          <source>It is unwise to leave transactions in the prepared state for a long time. This will interfere with the ability of &lt;code&gt;VACUUM&lt;/code&gt; to reclaim storage, and in extreme cases could cause the database to shut down to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;). Keep in mind also that the transaction continues to hold whatever locks it held. The intended usage of the feature is that a prepared transaction will normally be committed or rolled back as soon as an external transaction manager has verified that other databases are also prepared to commit.</source>
          <target state="translated">Неразумно оставлять транзакции в подготовленном состоянии надолго. Это повлияет на способность &lt;code&gt;VACUUM&lt;/code&gt; освободить хранилище, а в крайних случаях может привести к отключению базы данных, чтобы предотвратить &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;повторение&lt;/a&gt; идентификатора транзакции (см. Раздел 24.1.5 ). Имейте в виду также, что транзакция продолжает удерживать любые блокировки, которые она удерживала. Предполагаемое использование этой функции состоит в том, что подготовленная транзакция обычно фиксируется или откатывается, как только внешний диспетчер транзакций проверяет, что другие базы данных также готовы к фиксации.</target>
        </trans-unit>
        <trans-unit id="a307e2692a3d4dc03f3b0a5f0050741c926c9763" translate="yes" xml:space="preserve">
          <source>It is up to the database designer to define the channel names that will be used in a given database and what each one means. Commonly, the channel name is the same as the name of some table in the database, and the notify event essentially means, &amp;ldquo;I changed this table, take a look at it to see what's new&amp;rdquo;. But no such association is enforced by the &lt;code&gt;NOTIFY&lt;/code&gt; and &lt;code&gt;LISTEN&lt;/code&gt; commands. For example, a database designer could use several different channel names to signal different sorts of changes to a single table. Alternatively, the payload string could be used to differentiate various cases.</source>
          <target state="translated">Разработчик базы данных должен определить имена каналов, которые будут использоваться в данной базе данных, и значение каждого из них. Обычно имя канала совпадает с именем некоторой таблицы в базе данных, а событие уведомления по существу означает: &amp;laquo;Я изменил эту таблицу, взгляните на нее, чтобы узнать, что нового&amp;raquo;. Но такие ассоциации не применяются командами &lt;code&gt;NOTIFY&lt;/code&gt; и &lt;code&gt;LISTEN&lt;/code&gt; . Например, разработчик базы данных может использовать несколько разных имен каналов, чтобы сигнализировать о разных видах изменений в одной таблице. В качестве альтернативы, строка полезной нагрузки может использоваться для различения различных случаев.</target>
        </trans-unit>
        <trans-unit id="c8b6810a1ee6954d361d4c3ec546cf2001eccf7f" translate="yes" xml:space="preserve">
          <source>It is up to the specific dictionary how it treats stop words. For example, &lt;code&gt;ispell&lt;/code&gt; dictionaries first normalize words and then look at the list of stop words, while &lt;code&gt;Snowball&lt;/code&gt; stemmers first check the list of stop words. The reason for the different behavior is an attempt to decrease noise.</source>
          <target state="translated">То, как он обрабатывает стоп-слова, зависит от конкретного словаря. Например, словари &lt;code&gt;ispell&lt;/code&gt; сначала нормализуют слова, а затем просматривают список стоп-слов, а стеммеры &lt;code&gt;Snowball&lt;/code&gt; сначала проверяют список стоп-слов. Причина различного поведения - попытка уменьшить шум.</target>
        </trans-unit>
        <trans-unit id="ea9210befc0db8269a2ec074f163712e284e5a63" translate="yes" xml:space="preserve">
          <source>It is usually possible to compare values of related data types as well; for example &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;bigint&lt;/code&gt; will work. Some cases of this sort are implemented directly by &amp;ldquo;cross-type&amp;rdquo; comparison operators, but if no such operator is available, the parser will coerce the less-general type to the more-general type and apply the latter's comparison operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04c713c711198819201fd61c74a6825a1ba7c14" translate="yes" xml:space="preserve">
          <source>It is usually wise to create the primary and standby servers so that they are as similar as possible, at least from the perspective of the database server. In particular, the path names associated with tablespaces will be passed across unmodified, so both primary and standby servers must have the same mount paths for tablespaces if that feature is used. Keep in mind that if &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; is executed on the primary, any new mount point needed for it must be created on the primary and all standby servers before the command is executed. Hardware need not be exactly the same, but experience shows that maintaining two identical systems is easier than maintaining two dissimilar ones over the lifetime of the application and system. In any case the hardware architecture must be the same &amp;mdash; shipping from, say, a 32-bit to a 64-bit system will not work.</source>
          <target state="translated">Обычно разумно создать основной и резервный серверы так, чтобы они были как можно более похожими, по крайней мере, с точки зрения сервера базы данных. В частности, имена путей, связанных с табличными пространствами, будут передаваться через неизмененные, поэтому и первичный, и резервный серверы должны иметь одинаковые пути монтирования для табличных пространств, если эта функция используется. Имейте в виду, что если &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;выполняется на первичном сервере, любая новая точка монтирования, необходимая для него, должна быть создана на первичном и всех резервных серверах до выполнения команды. Аппаратное обеспечение не обязательно должно быть абсолютно одинаковым, но опыт показывает, что поддерживать две идентичные системы проще, чем поддерживать две разные в течение всего срока службы приложения и системы. В любом случае аппаратная архитектура должна быть одинаковой - переход, скажем, с 32-битной системы на 64-битную не будет работать.</target>
        </trans-unit>
        <trans-unit id="2ca150da1f7706a6be21716f546b65e3672dbc4a" translate="yes" xml:space="preserve">
          <source>It is very difficult to avoid such problems, because of SQL's general assumption that a null value is a valid value of every data type. Best practice therefore is to design a domain's constraints so that a null value is allowed, and then to apply column &lt;code&gt;NOT NULL&lt;/code&gt; constraints to columns of the domain type as needed, rather than directly to the domain type.</source>
          <target state="translated">Избежать таких проблем очень сложно из-за общего предположения SQL о том, что нулевое значение является допустимым значением для каждого типа данных. Поэтому лучше всего разработать ограничения домена так, чтобы было разрешено значение NULL, а затем при необходимости применить ограничения &lt;code&gt;NOT NULL&lt;/code&gt; столбца к столбцам типа домена, а не непосредственно к типу домена.</target>
        </trans-unit>
        <trans-unit id="7ca67a8bc55b2440ee4642c5a3836e4f1be7ce5b" translate="yes" xml:space="preserve">
          <source>It is very difficult to enforce business rules regarding data integrity using Read Committed transactions because the view of the data is shifting with each statement, and even a single statement may not restrict itself to the statement's snapshot if a write conflict occurs.</source>
          <target state="translated">Очень сложно обеспечить соблюдение бизнес-правил в отношении целостности данных с помощью операций Read Committed,потому что вид данных меняется с каждым утверждением,и даже одно утверждение может не ограничиваться снимком утверждения,если возникает конфликт записи.</target>
        </trans-unit>
        <trans-unit id="c946419a4ac69d8f0e7011290f8155362fae2bbd" translate="yes" xml:space="preserve">
          <source>It is very easy to use pgbench to produce completely meaningless numbers. Here are some guidelines to help you get useful results.</source>
          <target state="translated">Очень просто использовать pgbench для производства абсолютно бессмысленных чисел.Вот некоторые рекомендации,которые помогут вам получить полезные результаты.</target>
        </trans-unit>
        <trans-unit id="8a18d874cf4b801c23ef52010af4733b69c843e7" translate="yes" xml:space="preserve">
          <source>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as a superuser or an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</source>
          <target state="translated">Очень важно настроить права доступа для репликации, чтобы только доверенные пользователи могли читать поток WAL, поскольку из него легко извлечь привилегированную информацию. Резервные серверы должны пройти аутентификацию на первичном сервере как суперпользователь или учетная запись с привилегией &lt;code&gt;REPLICATION&lt;/code&gt; . Для репликации рекомендуется создать выделенную учетную запись пользователя с правами &lt;code&gt;REPLICATION&lt;/code&gt; и &lt;code&gt;LOGIN&lt;/code&gt; . Хотя привилегия &lt;code&gt;REPLICATION&lt;/code&gt; дает очень высокие разрешения, она не позволяет пользователю изменять какие-либо данные в основной системе, что &lt;code&gt;SUPERUSER&lt;/code&gt; привилегия SUPERUSER .</target>
        </trans-unit>
        <trans-unit id="fee748fec5cbfe77ff2427ad0976951907c37cc5" translate="yes" xml:space="preserve">
          <source>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege or a superuser. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d630958bd06e172aebb494cef807db838ae776b4" translate="yes" xml:space="preserve">
          <source>It is very important to take care to avoid circular rules. For example, though each of the following two rule definitions are accepted by PostgreSQL, the &lt;code&gt;SELECT&lt;/code&gt; command would cause PostgreSQL to report an error because of recursive expansion of a rule:</source>
          <target state="translated">Очень важно избегать замкнутых правил. Например, хотя PostgreSQL принимает каждое из следующих двух определений правил, команда &lt;code&gt;SELECT&lt;/code&gt; заставит PostgreSQL сообщить об ошибке из-за рекурсивного раскрытия правила:</target>
        </trans-unit>
        <trans-unit id="5a1a313f5514df92e2599108b061f0b4f0a8e02d" translate="yes" xml:space="preserve">
          <source>It is widely considered good style to qualify all column names in a join query, so that the query won't fail if a duplicate column name is later added to one of the tables.</source>
          <target state="translated">Широко распространено мнение о хорошем стиле квалификации всех имен столбцов в совместном запросе,так что запрос не будет неудачным,если впоследствии к одной из таблиц будет добавлено дублирующее имя столбца.</target>
        </trans-unit>
        <trans-unit id="906e585ddeae75bc90c0d2a785d10b4e23e5052c" translate="yes" xml:space="preserve">
          <source>It is wise to be conservative about marking casts as implicit. An overabundance of implicit casting paths can cause PostgreSQL to choose surprising interpretations of commands, or to be unable to resolve commands at all because there are multiple possible interpretations. A good rule of thumb is to make a cast implicitly invokable only for information-preserving transformations between types in the same general type category. For example, the cast from &lt;code&gt;int2&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; can reasonably be implicit, but the cast from &lt;code&gt;float8&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; should probably be assignment-only. Cross-type-category casts, such as &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt;, are best made explicit-only.</source>
          <target state="translated">Разумно быть консервативным в отношении пометки приведений как неявных. Избыток неявных путей приведения может привести к тому, что PostgreSQL выберет неожиданные интерпретации команд или вообще не сможет разрешить команды из-за множества возможных интерпретаций. Хорошее практическое правило - сделать приведение неявно вызываемым только для сохраняющих информацию преобразований между типами в одной и той же общей категории типов. Например, приведение от &lt;code&gt;int2&lt;/code&gt; к &lt;code&gt;int4&lt;/code&gt; может быть разумно неявным, но приведение от &lt;code&gt;float8&lt;/code&gt; к &lt;code&gt;int4&lt;/code&gt; , вероятно, должно быть только присваиванием. &lt;code&gt;int4&lt;/code&gt; типов между категориями, например &lt;code&gt;text&lt;/code&gt; в int4 , лучше всего делать явным.</target>
        </trans-unit>
        <trans-unit id="323e3c36d34b28b8ba0133e0d8df50cff77d9ca5" translate="yes" xml:space="preserve">
          <source>It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. A useful alternative is to use Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;; then the server will check that the character conversion is possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5b3068c21100601581e786ee86ca3a3f0b7637" translate="yes" xml:space="preserve">
          <source>It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. When the server encoding is UTF-8, then the Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;, should be used instead. (The alternative would be doing the UTF-8 encoding by hand and writing out the bytes, which would be very cumbersome.)</source>
          <target state="translated">Вы несете ответственность за то, чтобы создаваемые вами байтовые последовательности, особенно при использовании восьмеричного или шестнадцатеричного escape-кода, составляли допустимые символы в кодировке серверного набора символов. Если кодировка сервера - UTF-8, то вместо них следует использовать экранирующие символы Unicode или альтернативный синтаксис экранирования Unicode, описанный в &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Разделе 4.1.2.3&lt;/a&gt; . (Альтернативой было бы выполнение кодировки UTF-8 вручную и запись байтов, что было бы очень громоздко.)</target>
        </trans-unit>
        <trans-unit id="570a15e9c9ce6ae9a6fe65bb5309393853fdf2d9" translate="yes" xml:space="preserve">
          <source>It joins two functions into a single &lt;code&gt;FROM&lt;/code&gt; target. &lt;code&gt;json_to_recordset()&lt;/code&gt; is instructed to return two columns, the first &lt;code&gt;integer&lt;/code&gt; and the second &lt;code&gt;text&lt;/code&gt;. The result of &lt;code&gt;generate_series()&lt;/code&gt; is used directly. The &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts the column values as integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e498293987ea55fea8d5b2403c8c230700d8887" translate="yes" xml:space="preserve">
          <source>It makes your SQL statements verbose, and you always have to remember to use &lt;code&gt;lower&lt;/code&gt; on both the column and the query value.</source>
          <target state="translated">Это делает ваши операторы SQL подробными, и вы всегда должны помнить, что нужно использовать &lt;code&gt;lower&lt;/code&gt; как для столбца, так и для значения запроса.</target>
        </trans-unit>
        <trans-unit id="ef32cc79ad6cb19406da947c5847a9365640d3e1" translate="yes" xml:space="preserve">
          <source>It may also be necessary to give the database server's operating system user permission to use huge pages by setting &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; via sysctl, and/or give permission to lock memory with &lt;code&gt;ulimit -l&lt;/code&gt;.</source>
          <target state="translated">Также может потребоваться предоставить пользователю операционной системы сервера базы данных разрешение на использование огромных страниц, установив &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; через sysctl и / или разрешив блокировать память с помощью &lt;code&gt;ulimit -l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c230567f694e16c717ab914422a39d27766ee1c7" translate="yes" xml:space="preserve">
          <source>It may be advisable to avoid using type and table names that begin with underscore. While the server will change generated array type names to avoid collisions with user-given names, there is still risk of confusion, particularly with old client software that may assume that type names beginning with underscores always represent arrays.</source>
          <target state="translated">Рекомендуется избегать использования названий типов и таблиц,которые начинаются с символа подчеркивания.Хотя сервер будет изменять сгенерированные имена типов массивов,чтобы избежать столкновений с именами,задаваемыми пользователем,все же существует риск путаницы,особенно в старом клиентском программном обеспечении,которое может предполагать,что имена типов,начинающиеся с символов подчеркивания,всегда представляют собой массивы.</target>
        </trans-unit>
        <trans-unit id="914462b7eb826c460762b58dc586f5544963cc18" translate="yes" xml:space="preserve">
          <source>It may be useful to adjust this size to control the granularity of WAL log shipping or archiving. Also, in databases with a high volume of WAL, the sheer number of WAL files per directory can become a performance and management problem. Increasing the WAL file size will reduce the number of WAL files.</source>
          <target state="translated">Может быть полезно настроить этот размер для контроля гранулярности отгрузки или архивирования журналов WAL.Кроме того,в базах данных с большим объемом WAL,огромное количество файлов WAL на каталог может стать проблемой производительности и управления.Увеличение размера файла WAL уменьшит количество файлов WAL.</target>
        </trans-unit>
        <trans-unit id="7c0fb5b044b855badd9b796e550a5309d125f9a8" translate="yes" xml:space="preserve">
          <source>It might, however, be necessary to modify the global &lt;code&gt;ulimit&lt;/code&gt; information in &lt;code&gt;/etc/security/limits&lt;/code&gt;, as the default hard limits for file sizes (&lt;code&gt;fsize&lt;/code&gt;) and numbers of files (&lt;code&gt;nofiles&lt;/code&gt;) might be too low.</source>
          <target state="translated">Однако может потребоваться изменить глобальную информацию &lt;code&gt;ulimit&lt;/code&gt; в &lt;code&gt;/etc/security/limits&lt;/code&gt; , поскольку жесткие ограничения по умолчанию для размеров файлов ( &lt;code&gt;fsize&lt;/code&gt; ) и количества файлов ( &lt;code&gt;nofiles&lt;/code&gt; ) могут быть слишком низкими.</target>
        </trans-unit>
        <trans-unit id="91b31f4b37ed5e598eb7def83710e2ca48bbe707" translate="yes" xml:space="preserve">
          <source>It should also be noted that because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities. These are not discussed here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff2052adc7cc9fd5e18f86ad66dfe1b9dfc242d" translate="yes" xml:space="preserve">
          <source>It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</source>
          <target state="translated">Также следует отметить, что формат WAL по умолчанию довольно громоздкий, поскольку включает в себя множество снимков страниц диска. Эти моментальные снимки страниц предназначены для поддержки восстановления после сбоя, поскольку нам может потребоваться исправить частично записанные страницы диска. В зависимости от аппаратного и программного обеспечения вашей системы, риск частичной записи может быть достаточно мал, чтобы его можно было игнорировать, и в этом случае вы можете значительно уменьшить общий объем архивированных журналов, отключив моментальные снимки страниц с &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;помощью&lt;/a&gt; параметра full_page_writes . (Прочтите примечания и предупреждения в &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Главе 29,&lt;/a&gt; прежде чем сделать это.) Отключение моментальных снимков страниц не препятствует использованию журналов для операций PITR. Область для будущих разработок - сжатие архивных данных WAL путем удаления ненужных копий страниц, даже если &lt;code&gt;full_page_writes&lt;/code&gt; горит. Тем временем администраторы могут захотеть уменьшить количество снимков страниц, включенных в WAL, увеличив параметры интервала контрольных точек, насколько это возможно.</target>
        </trans-unit>
        <trans-unit id="27800a360494c7320b8e3b3710d75e18bd41894b" translate="yes" xml:space="preserve">
          <source>It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af922062ac86a130253f6b4fd50587d3a97630cd" translate="yes" xml:space="preserve">
          <source>It should be fairly clear why a btree index requires these laws to hold within a single data type: without them there is no ordering to arrange the keys with. Also, index searches using a comparison key of a different data type require comparisons to behave sanely across two data types. The extensions to three or more data types within a family are not strictly required by the btree index mechanism itself, but the planner relies on them for optimization purposes.</source>
          <target state="translated">Должно быть достаточно понятно,почему индекс btree требует,чтобы эти законы хранились в пределах одного типа данных:без них нет порядка расположения ключей.Кроме того,поиск по индексам с использованием ключа сравнения другого типа данных требует,чтобы сравнения вели себя разумно по двум типам данных.Расширения до трех и более типов данных в пределах семейства строго не требуются самим механизмом индекса btree,но планировщик полагается на них в целях оптимизации.</target>
        </trans-unit>
        <trans-unit id="e49813f2476bbea73d4ff66119d7d7387c964091" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;code&gt;pg_cast&lt;/code&gt; does not represent every type conversion that the system knows how to perform; only those that cannot be deduced from some generic rule. For example, casting between a domain and its base type is not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;. Another important exception is that &amp;ldquo;automatic I/O conversion casts&amp;rdquo;, those performed using a data type's own I/O functions to convert to or from &lt;code&gt;text&lt;/code&gt; or other string types, are not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;.</source>
          <target state="translated">Следует отметить, что &lt;code&gt;pg_cast&lt;/code&gt; не представляет все преобразования типов, которые система знает, как выполнять; только те, которые не могут быть выведены из какого-либо общего правила. Например, преобразование между доменом и его базовым типом явно не представлено в &lt;code&gt;pg_cast&lt;/code&gt; . Другое важное исключение состоит в том, что &amp;laquo;автоматические преобразования ввода-вывода&amp;raquo;, выполняемые с использованием собственных функций ввода-вывода типа данных для преобразования в &lt;code&gt;text&lt;/code&gt; или другие строковые типы или из него , явно не представлены в &lt;code&gt;pg_cast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f75a2b78a5f5649b3ab9e555457464dd4adddae" translate="yes" xml:space="preserve">
          <source>It should be noted that a check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns. To ensure that a column does not contain null values, the not-null constraint described in the next section can be used.</source>
          <target state="translated">Следует отметить,что проверочное ограничение удовлетворяется,если проверочное выражение вычисляется как истинное или как нулевое значение.Так как большинство выражений будут оценивать до нулевого значения,если какой-либо операнд является нулевым,то они не будут препятствовать нулевым значениям в ограниченных столбцах.Для того чтобы убедиться,что столбец не содержит нулевого значения,можно использовать ограничение not-null,описанное в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="02935ea4ceb5538c0d2002f169c21bb8e60788b3" translate="yes" xml:space="preserve">
          <source>It should be noted that database superusers can access all objects regardless of object privilege settings. This is comparable to the rights of &lt;code&gt;root&lt;/code&gt; in a Unix system. As with &lt;code&gt;root&lt;/code&gt;, it's unwise to operate as a superuser except when absolutely necessary.</source>
          <target state="translated">Следует отметить, что суперпользователи базы данных могут получить доступ ко всем объектам независимо от настроек привилегий объекта. Это сопоставимо с правами &lt;code&gt;root&lt;/code&gt; в системе Unix. Как и в случае с &lt;code&gt;root&lt;/code&gt; , неразумно работать от имени суперпользователя, за исключением случаев крайней необходимости.</target>
        </trans-unit>
        <trans-unit id="8c98ab8e1a3d8f36aae75d2304e7a94b266eaa6f" translate="yes" xml:space="preserve">
          <source>It should be noted that except for &lt;code&gt;count&lt;/code&gt;, these functions return a null value when no rows are selected. In particular, &lt;code&gt;sum&lt;/code&gt; of no rows returns null, not zero as one might expect, and &lt;code&gt;array_agg&lt;/code&gt; returns null rather than an empty array when there are no input rows. The &lt;code&gt;coalesce&lt;/code&gt; function can be used to substitute zero or an empty array for null when necessary.</source>
          <target state="translated">Следует отметить, что, за исключением &lt;code&gt;count&lt;/code&gt; , эти функции возвращают нулевое значение, если строки не выбраны. В частности, &lt;code&gt;sum&lt;/code&gt; of no rows возвращает null, а не ноль, как можно было бы ожидать, а &lt;code&gt;array_agg&lt;/code&gt; возвращает null, а не пустой массив, когда нет входных строк. При необходимости функцию &lt;code&gt;coalesce&lt;/code&gt; можно использовать для замены нуля или пустого массива на null.</target>
        </trans-unit>
        <trans-unit id="fcddd727e8976d04c908eb345e29817691fb2925" translate="yes" xml:space="preserve">
          <source>It should be noted that log shipping is asynchronous, i.e., the WAL records are shipped after transaction commit. As a result, there is a window for data loss should the primary server suffer a catastrophic failure; transactions not yet shipped will be lost. The size of the data loss window in file-based log shipping can be limited by use of the &lt;code&gt;archive_timeout&lt;/code&gt; parameter, which can be set as low as a few seconds. However such a low setting will substantially increase the bandwidth required for file shipping. Streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) allows a much smaller window of data loss.</source>
          <target state="translated">Следует отметить, что доставка журналов является асинхронной, т. Е. Записи WAL отправляются после фиксации транзакции. В результате появляется окно для потери данных в случае катастрофического отказа основного сервера; еще не отправленные транзакции будут потеряны. Размер окна потери данных при доставке журналов на основе файлов можно ограничить с помощью параметра &lt;code&gt;archive_timeout&lt;/code&gt; , который можно установить на несколько секунд. Однако такой низкий параметр существенно увеличит полосу пропускания, необходимую для доставки файлов. Потоковая репликация (см. &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Раздел 26.2.5&lt;/a&gt; ) допускает гораздо меньшее окно потери данных.</target>
        </trans-unit>
        <trans-unit id="3fca8a3246e56f8200631a2d48d923a7438a3af3" translate="yes" xml:space="preserve">
          <source>It should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt;, as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3defdb9a09006209e803808debdc569c264d27e7" translate="yes" xml:space="preserve">
          <source>It won't use an index, unless you create a functional index using &lt;code&gt;lower&lt;/code&gt;.</source>
          <target state="translated">Он не будет использовать индекс, если вы не создадите функциональный индекс с помощью &lt;code&gt;lower&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b722c9c9f3f75689f42f0b53f218a01c48008e8" translate="yes" xml:space="preserve">
          <source>It would be better to instead create child tables as follows:</source>
          <target state="translated">Вместо этого лучше создать дочерние таблицы следующим образом:</target>
        </trans-unit>
        <trans-unit id="b3751c875e52c61621661f1961d94164268c168e" translate="yes" xml:space="preserve">
          <source>It's a matter of taste.</source>
          <target state="translated">Это дело вкуса.</target>
        </trans-unit>
        <trans-unit id="6308fac37b6f916e6aaeedec4f54478b5685b89a" translate="yes" xml:space="preserve">
          <source>It's advisable to create &lt;code&gt;ndistinct&lt;/code&gt; statistics objects only on combinations of columns that are actually used for grouping, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; cycles are just wasted.</source>
          <target state="translated">Рекомендуется создавать &lt;code&gt;ndistinct&lt;/code&gt; объекты статистики только для тех комбинаций столбцов, которые фактически используются для группировки и для которых неверное определение количества групп приводит к плохим планам. В противном случае циклы &lt;code&gt;ANALYZE&lt;/code&gt; будут потрачены впустую.</target>
        </trans-unit>
        <trans-unit id="695d14c6506a71cfb6f8af1b5d18b963ae0d4f6f" translate="yes" xml:space="preserve">
          <source>It's advisable to create MCV statistics objects only on combinations of columns that are actually used in conditions together, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; and planning cycles are just wasted.</source>
          <target state="translated">Рекомендуется создавать объекты статистики MCV только для комбинаций столбцов, которые фактически используются в условиях вместе, и для которых неправильная оценка количества групп приводит к плохим планам. В противном случае циклы &lt;code&gt;ANALYZE&lt;/code&gt; и планирования будут потрачены впустую.</target>
        </trans-unit>
        <trans-unit id="26d8635c1af4731c90f7caf11c20fceefa695a0b" translate="yes" xml:space="preserve">
          <source>It's also permissible to attach &lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; to integer columns to reference character set encodings, which are not currently represented as catalog OIDs, but have a set of values known to &lt;code&gt;genbki.pl&lt;/code&gt;.</source>
          <target state="translated">Также допустимо прикреплять &lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; к целочисленным столбцам для ссылки на кодировки набора символов, которые в настоящее время не представлены как каталоги OID, но имеют набор значений, известный &lt;code&gt;genbki.pl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42cd973aeb3dbef0c62ad2e81081d6f4bf4973db" translate="yes" xml:space="preserve">
          <source>It's also possible to select no escape character by writing &lt;code&gt;ESCAPE ''&lt;/code&gt;. This effectively disables the escape mechanism, which makes it impossible to turn off the special meaning of underscore and percent signs in the pattern.</source>
          <target state="translated">Также можно выбрать отсутствие escape-символа, написав &lt;code&gt;ESCAPE ''&lt;/code&gt; . Это эффективно отключает механизм перехода, что делает невозможным отключение специального значения знаков подчеркивания и процентов в шаблоне.</target>
        </trans-unit>
        <trans-unit id="8646be546a98ef8ea063cb9eec163a8d4548ff24" translate="yes" xml:space="preserve">
          <source>It's essential that the data types and other properties of the columns declared in &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; match the actual remote table. Column names must match as well, unless you attach &lt;code&gt;column_name&lt;/code&gt; options to the individual columns to show how they are named in the remote table. In many cases, use of &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt; is preferable to constructing foreign table definitions manually.</source>
          <target state="translated">Важно, чтобы типы данных и другие свойства столбцов, объявленных в &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; , соответствовали реальной удаленной таблице. Имена столбцов также должны совпадать, если вы не добавляете параметры &lt;code&gt;column_name&lt;/code&gt; к отдельным столбцам, чтобы показать, как они названы в удаленной таблице. Во многих случаях использование &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt; предпочтительнее создания определений сторонних таблиц вручную.</target>
        </trans-unit>
        <trans-unit id="a75f17e623d692c2b958fa72bc491d5871febb40" translate="yes" xml:space="preserve">
          <source>It's important to understand that the cost of an upper-level node includes the cost of all its child nodes. It's also important to realize that the cost only reflects things that the planner cares about. In particular, the cost does not consider the time spent transmitting result rows to the client, which could be an important factor in the real elapsed time; but the planner ignores it because it cannot change it by altering the plan. (Every correct plan will output the same row set, we trust.)</source>
          <target state="translated">Важно понимать,что стоимость узла верхнего уровня включает стоимость всех его дочерних узлов.Также важно понимать,что стоимость отражает только то,что волнует планировщика.В частности,стоимость не учитывает время,затраченное на передачу строк результата клиенту,что может быть важным фактором в реальном прошедшем времени;но планировщик игнорирует ее,потому что не может изменить ее,изменив план.(Мы верим,что каждый правильный план будет выдавать один и тот же набор строк).</target>
        </trans-unit>
        <trans-unit id="7c3ed76ba22932f8e0061fba8fda8ba6c6509eab" translate="yes" xml:space="preserve">
          <source>It's possible to control the statements in a transaction in a more granular fashion through the use of &lt;em&gt;savepoints&lt;/em&gt;. Savepoints allow you to selectively discard parts of the transaction, while committing the rest. After defining a savepoint with &lt;code&gt;SAVEPOINT&lt;/code&gt;, you can if needed roll back to the savepoint with &lt;code&gt;ROLLBACK TO&lt;/code&gt;. All the transaction's database changes between defining the savepoint and rolling back to it are discarded, but changes earlier than the savepoint are kept.</source>
          <target state="translated">Можно управлять операторами в транзакции более детально с помощью &lt;em&gt;точек сохранения&lt;/em&gt; . Точки сохранения позволяют выборочно отбрасывать части транзакции с фиксацией остальных. После определения точки сохранения с помощью &lt;code&gt;SAVEPOINT&lt;/code&gt; вы можете при необходимости откатиться к точке сохранения с помощью &lt;code&gt;ROLLBACK TO&lt;/code&gt; . Все изменения в базе данных транзакции между определением точки сохранения и откатом к ней отменяются, но изменения, внесенные до точки сохранения, сохраняются.</target>
        </trans-unit>
        <trans-unit id="af6b5757cbe3f9b4c6401b87c759f120734c17d1" translate="yes" xml:space="preserve">
          <source>It's recommended to run &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; before submitting catalog data patches. For convenience, you can simply change to &lt;code&gt;src/include/catalog/&lt;/code&gt; and run &lt;code&gt;make reformat-dat-files&lt;/code&gt;.</source>
          <target state="translated">Перед отправкой исправлений данных каталога рекомендуется запустить &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; . Для удобства вы можете просто изменить его на &lt;code&gt;src/include/catalog/&lt;/code&gt; и запустить &lt;code&gt;make reformat-dat-files&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f13f984e4f7daa459e845c3a4715f4638313970" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches.</source>
          <target state="translated">Мудро быть консервативным при добавлении неключевых столбцов к индексу,особенно широких столбцов.Если кортеж индекса превысит максимально допустимый для данного типа индекса размер,вставка данных будет неудачной.В любом случае,неключевые столбцы дублируют данные из таблицы индекса и раздувают размер индекса,тем самым потенциально замедляя поиск.</target>
        </trans-unit>
        <trans-unit id="e5c646abb35ed677e4428cd5146fe3efa3d6f1d7" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. Furthermore, B-tree deduplication is never used with indexes that have a non-key column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08237634e67b792c41b6dc72d01cf498506db594" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key payload columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. And remember that there is little point in including payload columns in an index unless the table changes slowly enough that an index-only scan is likely to not need to access the heap. If the heap tuple must be visited anyway, it costs nothing more to get the column's value from there. Other restrictions are that expressions are not currently supported as included columns, and that only B-tree and GiST indexes currently support included columns.</source>
          <target state="translated">Мудро быть консервативным в отношении добавления в индекс неключевых столбцов полезной нагрузки,особенно широких столбцов.Если кортеж индекса превысит максимально допустимый для данного типа индекса размер,вставка данных будет неудачной.В любом случае,неключевые столбцы дублируют данные из таблицы индекса и раздувают размер индекса,тем самым потенциально замедляя поиск.И помните,что нет смысла включать в индекс столбцы полезной нагрузки,если только таблица не изменяется достаточно медленно,чтобы сканирование только по индексу,скорее всего,не понадобилось для доступа к куче.Если кортеж кучи все равно должен быть посещен,то получить оттуда значение столбца больше ничего не стоит.Другие ограничения заключаются в том,что выражения в настоящее время не поддерживаются как включенные столбцы,и что только B-дерево и GiST-индексы в настоящее время поддерживают включенные столбцы.</target>
        </trans-unit>
        <trans-unit id="9682da0882fceeebec9d99753c1dc0306b85beab" translate="yes" xml:space="preserve">
          <source>It's worth noticing that the AND/OR/NOT operators mean something subtly different when they are within the arguments of a FOLLOWED BY operator than when they are not, because within FOLLOWED BY the exact position of the match is significant. For example, normally &lt;code&gt;!x&lt;/code&gt; matches only documents that do not contain &lt;code&gt;x&lt;/code&gt; anywhere. But &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; matches &lt;code&gt;y&lt;/code&gt; if it is not immediately after an &lt;code&gt;x&lt;/code&gt;; an occurrence of &lt;code&gt;x&lt;/code&gt; elsewhere in the document does not prevent a match. Another example is that &lt;code&gt;x &amp;amp; y&lt;/code&gt; normally only requires that &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; both appear somewhere in the document, but &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; requires &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to match at the same place, immediately before a &lt;code&gt;z&lt;/code&gt;. Thus this query behaves differently from &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt;, which will match a document containing two separate sequences &lt;code&gt;x z&lt;/code&gt; and &lt;code&gt;y z&lt;/code&gt;. (This specific query is useless as written, since &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; could not match at the same place; but with more complex situations such as prefix-match patterns, a query of this form could be useful.)</source>
          <target state="translated">Стоит отметить, что операторы AND / OR / NOT означают нечто слегка иное, когда они находятся в аргументах оператора FOLLOWED BY, чем когда они не являются, потому что внутри FOLLOWED BY важна точная позиция совпадения. Например, обычно &lt;code&gt;!x&lt;/code&gt; соответствует только документам, нигде не содержащим &lt;code&gt;x&lt;/code&gt; . Но &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; соответствует &lt;code&gt;y&lt;/code&gt; , если он не находится сразу после &lt;code&gt;x&lt;/code&gt; ; наличие &lt;code&gt;x&lt;/code&gt; в другом месте документа не препятствует совпадению. Другой пример: &lt;code&gt;x &amp;amp; y&lt;/code&gt; обычно требует, чтобы &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; оба появлялись где-то в документе, но &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; требует &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; совпадают в одном месте, непосредственно перед &lt;code&gt;z&lt;/code&gt; . Таким образом, этот запрос ведет себя иначе, чем &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt; , который соответствует документу, содержащему две отдельные последовательности &lt;code&gt;x z&lt;/code&gt; и &lt;code&gt;y z&lt;/code&gt; . (Этот конкретный запрос бесполезен в том виде, в каком он написан, поскольку &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; не могут совпадать в одном и том же месте; но в более сложных ситуациях, таких как шаблоны совпадения префиксов, запрос этой формы может быть полезен.)</target>
        </trans-unit>
        <trans-unit id="ecdda59aea5ee67d7d854c969ccf7f4f4b4a4c54" translate="yes" xml:space="preserve">
          <source>Item</source>
          <target state="translated">Item</target>
        </trans-unit>
        <trans-unit id="036b57986556b399e1579aa78767ca4cf343c8b5" translate="yes" xml:space="preserve">
          <source>ItemIdData</source>
          <target state="translated">ItemIdData</target>
        </trans-unit>
        <trans-unit id="a2965a078eaef7ee13c972baa85b167370cde26a" translate="yes" xml:space="preserve">
          <source>ItemPointerData</source>
          <target state="translated">ItemPointerData</target>
        </trans-unit>
        <trans-unit id="44d25b5d1b6d98c7d090ca3609aca11ae2815fa0" translate="yes" xml:space="preserve">
          <source>Items</source>
          <target state="translated">Items</target>
        </trans-unit>
        <trans-unit id="40f7cf3bbd8b78d82db16eda601698d7597b9ba5" translate="yes" xml:space="preserve">
          <source>J.5. Style Guide</source>
          <target state="translated">J.5.Руководство по стилю</target>
        </trans-unit>
        <trans-unit id="7685fa01b8b7b34ce179631444878fcbce78fa81" translate="yes" xml:space="preserve">
          <source>J2451187</source>
          <target state="translated">J2451187</target>
        </trans-unit>
        <trans-unit id="1f1062dcbb83b59e4f6f5cb50ef505afac199e0d" translate="yes" xml:space="preserve">
          <source>JDBC</source>
          <target state="translated">JDBC</target>
        </trans-unit>
        <trans-unit id="eb5d2f4a58038c71155ddcf3cea35dc3c6d34501" translate="yes" xml:space="preserve">
          <source>JIT</source>
          <target state="translated">JIT</target>
        </trans-unit>
        <trans-unit id="6a623f63efe8bb915b0cd81dd3786e0511e1c1a1" translate="yes" xml:space="preserve">
          <source>JIT compilation is beneficial primarily for long-running CPU-bound queries. Frequently these will be analytical queries. For short queries the added overhead of performing JIT compilation will often be higher than the time it can save.</source>
          <target state="translated">Компиляция JIT полезна,прежде всего,для долгосрочных запросов,связанных с процессором.Часто это будут аналитические запросы.Для коротких запросов накладные расходы,связанные с выполнением JIT-компиляции,часто будут выше,чем время,которое она может сэкономить.</target>
        </trans-unit>
        <trans-unit id="6f7646a5ebe2aff38f294e6e525f0ea1b56f8538" translate="yes" xml:space="preserve">
          <source>JOHAB</source>
          <target state="translated">JOHAB</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c731d9e245778a9537fc026bc57fb4f455f28593" translate="yes" xml:space="preserve">
          <source>JSON Functions and Operators</source>
          <target state="translated">Функции и операторы JSON</target>
        </trans-unit>
        <trans-unit id="95cc452498b3190abb79d4cdad349208be23c944" translate="yes" xml:space="preserve">
          <source>JSON Types</source>
          <target state="translated">Типы JSON</target>
        </trans-unit>
        <trans-unit id="f9bea7492dcebb5f109566d49e4bca935a7e0ff7" translate="yes" xml:space="preserve">
          <source>JSON Types: boolean</source>
          <target state="translated">JSON Типы:булевые</target>
        </trans-unit>
        <trans-unit id="22aff2decb9f95af65f4e2a85c938a9901c03229" translate="yes" xml:space="preserve">
          <source>JSON Types: null</source>
          <target state="translated">Типы JSON:нулевой</target>
        </trans-unit>
        <trans-unit id="b89570edbe3781b5bd3ad2ae7d37f0bf110fdf05" translate="yes" xml:space="preserve">
          <source>JSON Types: number</source>
          <target state="translated">JSON Типы:число</target>
        </trans-unit>
        <trans-unit id="205b72d84addc780073dacc96aedf0a7c5c2d3cc" translate="yes" xml:space="preserve">
          <source>JSON Types: string</source>
          <target state="translated">JSON Типы:строка</target>
        </trans-unit>
        <trans-unit id="6fb42476959dba43e5b647429008c3399be7120f" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826d7973fb0fe99520474814c729759899e1f084" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;null&lt;/code&gt; (note that, unlike in SQL, comparison to &lt;code&gt;null&lt;/code&gt; works normally)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5978544d202bc2b880af72e00c6ff1ea552f31" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c22c401963d3661a06e8b5108d657673586e05" translate="yes" xml:space="preserve">
          <source>JSON data is subject to the same concurrency-control considerations as any other data type when stored in a table. Although storing large documents is practicable, keep in mind that any update acquires a row-level lock on the whole row. Consider limiting JSON documents to a manageable size in order to decrease lock contention among updating transactions. Ideally, JSON documents should each represent an atomic datum that business rules dictate cannot reasonably be further subdivided into smaller datums that could be modified independently.</source>
          <target state="translated">Данные JSON при хранении в таблице подчиняются тем же соображениям параллельного контроля,что и любые другие типы данных.Несмотря на то,что хранение больших документов возможно,следует помнить,что любое обновление приобретает блокировку на уровне строк во всей строке.Рассмотрим возможность ограничения JSON-документов до управляемого размера,чтобы сократить количество споров о блокировке при обновлении транзакций.В идеале каждый из JSON-документов должен представлять собой атомарную дату,которую,согласно правилам ведения бизнеса,нельзя разумно далее подразделять на более мелкие данные,которые могут быть изменены независимо друг от друга.</target>
        </trans-unit>
        <trans-unit id="062e2dcdb89d67da750325f5a32e496783b448b0" translate="yes" xml:space="preserve">
          <source>JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt;, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">Типы данных JSON предназначены для хранения данных JSON (нотация объектов JavaScript), как указано в &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt; . Такие данные также могут быть сохранены в виде &lt;code&gt;text&lt;/code&gt; , но типы данных JSON имеют то преимущество, что каждое сохраненное значение является действительным в соответствии с правилами JSON. Также существуют различные специфичные для JSON функции и операторы, доступные для данных, хранящихся в этих типах данных; см. &lt;a href=&quot;functions-json&quot;&gt;Раздел 9.15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3439d51ccc84271989a1fe8ee4c05702a949e43b" translate="yes" xml:space="preserve">
          <source>JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt;, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b285244e0c7fb77cf325258e945007dbcb0bd79" translate="yes" xml:space="preserve">
          <source>JSON objects are better suited than arrays for testing containment or existence when there are many keys or elements involved, because unlike arrays they are internally optimized for searching, and do not need to be searched linearly.</source>
          <target state="translated">JSON-объекты лучше,чем массивы,подходят для тестирования локализации или существования при наличии множества ключей или элементов,потому что в отличие от массивов,они внутренне оптимизированы для поиска и не нуждаются в линейном поиске.</target>
        </trans-unit>
        <trans-unit id="ff7a8b7bee4833026249925bb4a7e075a31995d4" translate="yes" xml:space="preserve">
          <source>JSON primitive type</source>
          <target state="translated">JSON примитивный тип</target>
        </trans-unit>
        <trans-unit id="21d0c78d1738d7a3274678ad613fc7038b9e1cd3" translate="yes" xml:space="preserve">
          <source>JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding JSON item, or set of items, is returned. Path expressions are written in the SQL/JSON path language and can include arithmetic expressions and functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196dea5dbe3d820f7bdbd4775445b07993543c68" translate="yes" xml:space="preserve">
          <source>JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding SQL/JSON item is returned. Path expressions are written in the SQL/JSON path language and can also include arithmetic expressions and functions. Query functions treat the provided expression as a text string, so it must be enclosed in single quotes.</source>
          <target state="translated">Функции и операторы запросов JSON передают предоставленное выражение &lt;em&gt;пути механизму пути&lt;/em&gt; для оценки. Если выражение соответствует запрошенным данным JSON, возвращается соответствующий элемент SQL / JSON. Выражения пути написаны на языке путей SQL / JSON и могут также включать арифметические выражения и функции. Функции запросов обрабатывают предоставленное выражение как текстовую строку, поэтому оно должно быть заключено в одинарные кавычки.</target>
        </trans-unit>
        <trans-unit id="7af619b9c5342e6a889b85ca2cae08237b23f616" translate="yes" xml:space="preserve">
          <source>JSON: SQL/JSON Path Language</source>
          <target state="translated">JSON:Язык пути SQL/JSON</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="ebeb4b5ab2f3409935c06be07e3191bf0a5dc6cf" translate="yes" xml:space="preserve">
          <source>Jan-08-1999</source>
          <target state="translated">Jan-08-1999</target>
        </trans-unit>
        <trans-unit id="521a936bf91733c55274b55367cc8ed71292693f" translate="yes" xml:space="preserve">
          <source>Jan-08-99</source>
          <target state="translated">Jan-08-99</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="d6e52d181e7ba4487fe8643d957277cd1cbf82c7" translate="yes" xml:space="preserve">
          <source>January 18 in &lt;code&gt;MDY&lt;/code&gt; mode; rejected in other modes</source>
          <target state="translated">18 января в режиме &lt;code&gt;MDY&lt;/code&gt; ; отклонено в других режимах</target>
        </trans-unit>
        <trans-unit id="d1fb4cc8c23271615e96e586a4e1801c1ac84f25" translate="yes" xml:space="preserve">
          <source>January 2, 2003 in &lt;code&gt;MDY&lt;/code&gt; mode; February 1, 2003 in &lt;code&gt;DMY&lt;/code&gt; mode; February 3, 2001 in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">2 января 2003 г. в режиме &lt;code&gt;MDY&lt;/code&gt; ; 1 февраля 2003 г. в режиме &lt;code&gt;DMY&lt;/code&gt; ; 3 февраля 2001 г. в режиме &lt;code&gt;YMD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="397474e233d9068687b354fbdbc0b01176bcc2cc" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;MDY&lt;/code&gt; mode; August 1 in &lt;code&gt;DMY&lt;/code&gt; mode</source>
          <target state="translated">8 января в режиме &lt;code&gt;MDY&lt;/code&gt; ; 1 августа в режиме &lt;code&gt;DMY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2391ee88b9183f9c31234260c9722e2d62c959b0" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;YMD&lt;/code&gt; mode, else error</source>
          <target state="translated">8 января в режиме &lt;code&gt;YMD&lt;/code&gt; , иначе ошибка</target>
        </trans-unit>
        <trans-unit id="347ee622c39fd3015013d75c9106e7b8164231b7" translate="yes" xml:space="preserve">
          <source>January 8 in any mode</source>
          <target state="translated">8 января в любом режиме</target>
        </trans-unit>
        <trans-unit id="682c812bf69e66e4c213bdbcc9a0930f43e82030" translate="yes" xml:space="preserve">
          <source>January 8, 1999</source>
          <target state="translated">8 января 1999 года</target>
        </trans-unit>
        <trans-unit id="4444d015dc1b7e202a7ab992a769c820f60f9019" translate="yes" xml:space="preserve">
          <source>January 8, 99 BC</source>
          <target state="translated">8 января 99 г.до н.э.</target>
        </trans-unit>
        <trans-unit id="07425bcd86481aaf19f3e5b4016da2c9f5e1cec4" translate="yes" xml:space="preserve">
          <source>January 8, except error in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">8 января, кроме ошибки в режиме &lt;code&gt;YMD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9239c22d1d1c990ca8c206cb408b345a3ec8114c" translate="yes" xml:space="preserve">
          <source>Japanese</source>
          <target state="translated">Japanese</target>
        </trans-unit>
        <trans-unit id="21087b70eba36ef97c23b6fae1bc0502a8c7faff" translate="yes" xml:space="preserve">
          <source>Java Database Connectivity</source>
          <target state="translated">Подключаемость базы данных Java</target>
        </trans-unit>
        <trans-unit id="94e850a9fa9f98700106bfba6b5849640ea65567" translate="yes" xml:space="preserve">
          <source>JavaScript Object Notation</source>
          <target state="translated">Нотация объекта JavaScript</target>
        </trans-unit>
        <trans-unit id="66dc64282e7e424443c0ee036f6560a8429101fe" translate="yes" xml:space="preserve">
          <source>Jean-Luc Cooke Fortuna-based &lt;code&gt;/dev/random&lt;/code&gt; driver for Linux.</source>
          <target state="translated">Драйвер &lt;code&gt;/dev/random&lt;/code&gt; на основе Жан-Люка Кука Фортуны для Linux.</target>
        </trans-unit>
        <trans-unit id="076e3b3dd165a68d5a1635c764f91d575d41e991" translate="yes" xml:space="preserve">
          <source>Joe Conway</source>
          <target state="translated">Джо Конвей</target>
        </trans-unit>
        <trans-unit id="36223c3c072f8f4857df7670837893beb8c9ab05" translate="yes" xml:space="preserve">
          <source>John Gray &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Джон Грей &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="5253095e71e396147a5bb85865b313a4dfaabec4" translate="yes" xml:space="preserve">
          <source>Join queries of the kind seen thus far can also be written in this alternative form:</source>
          <target state="translated">В этой альтернативной форме могут быть также написаны запросы о присоединении,подобные тем,что мы видели до сих пор:</target>
        </trans-unit>
        <trans-unit id="5d51427844afa7a67c043cae62a1e058c08bf8eb" translate="yes" xml:space="preserve">
          <source>Join selectivity estimation function for this operator</source>
          <target state="translated">Функция оценки селективности присоединения для данного оператора</target>
        </trans-unit>
        <trans-unit id="60bbcdff104b8ef5971151f077f9a3a69bf41608" translate="yes" xml:space="preserve">
          <source>Joins of all types can be chained together, or nested: either or both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; can be joined tables. Parentheses can be used around &lt;code&gt;JOIN&lt;/code&gt; clauses to control the join order. In the absence of parentheses, &lt;code&gt;JOIN&lt;/code&gt; clauses nest left-to-right.</source>
          <target state="translated">Объединения всех типов могут быть объединены в цепочку или вложены: таблицы &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; или оба могут быть объединены. Для управления порядком соединения можно использовать круглые скобки вокруг предложений &lt;code&gt;JOIN&lt;/code&gt; . При отсутствии скобок предложения &lt;code&gt;JOIN&lt;/code&gt; располагаются слева направо.</target>
        </trans-unit>
        <trans-unit id="b737558468d75ca55b2d9185c0b55eacaea627a0" translate="yes" xml:space="preserve">
          <source>Jul</source>
          <target state="translated">Jul</target>
        </trans-unit>
        <trans-unit id="a78c0406ce3eb63581cbacb7e7085ef4cbc36ad9" translate="yes" xml:space="preserve">
          <source>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</source>
          <target state="translated">День Юлиана (целые дни с 24 ноября 4714 BC в полночь UTC)</target>
        </trans-unit>
        <trans-unit id="b597ea9fa797a2c2073652808359aeb10b763510" translate="yes" xml:space="preserve">
          <source>Julian date</source>
          <target state="translated">юлианское свидание</target>
        </trans-unit>
        <trans-unit id="df97a42549e5c0e1753b985126565531cc9f3c56" translate="yes" xml:space="preserve">
          <source>July</source>
          <target state="translated">July</target>
        </trans-unit>
        <trans-unit id="6d90df3be4d0d43b08e3fb47f55e09b5b06dae3e" translate="yes" xml:space="preserve">
          <source>Jun</source>
          <target state="translated">Jun</target>
        </trans-unit>
        <trans-unit id="a9db906761699b31567727716eaa6fd19ae5f5d5" translate="yes" xml:space="preserve">
          <source>June</source>
          <target state="translated">June</target>
        </trans-unit>
        <trans-unit id="7b1ddc607d5041d94adba7779845219a639a5e00" translate="yes" xml:space="preserve">
          <source>Just as in a non-parallel plan, the driving table may be joined to one or more other tables using a nested loop, hash join, or merge join. The inner side of the join may be any kind of non-parallel plan that is otherwise supported by the planner provided that it is safe to run within a parallel worker. Depending on the join type, the inner side may also be a parallel plan.</source>
          <target state="translated">Как и в непараллельном плане,движущийся стол может быть присоединен к одной или нескольким другим таблицам с помощью вложенного цикла,хэш-сочетания или слияния соединений.Внутренней стороной соединения может быть любой непараллельный план,поддерживаемый проектировщиком,при условии,что он безопасно работает внутри параллельного рабочего.В зависимости от типа соединения внутренней стороной может быть также параллельный план.</target>
        </trans-unit>
        <trans-unit id="dce656c6d5efc6ceb90feb56120166673a499a99" translate="yes" xml:space="preserve">
          <source>Just as in a table, every output column of a &lt;code&gt;SELECT&lt;/code&gt; has a name. In a simple &lt;code&gt;SELECT&lt;/code&gt; this name is just used to label the column for display, but when the &lt;code&gt;SELECT&lt;/code&gt; is a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, write &lt;code&gt;AS&lt;/code&gt;&lt;code&gt;output_name&lt;/code&gt; after the column's expression. (You can omit &lt;code&gt;AS&lt;/code&gt;, but only if the desired output name does not match any PostgreSQL keyword (see &lt;a href=&quot;sql-keywords-appendix&quot;&gt;Appendix C&lt;/a&gt;). For protection against possible future keyword additions, it is recommended that you always either write &lt;code&gt;AS&lt;/code&gt; or double-quote the output name.) If you do not specify a column name, a name is chosen automatically by PostgreSQL. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as &lt;code&gt;?column?&lt;/code&gt;.</source>
          <target state="translated">Как и в таблице, у каждого выходного столбца &lt;code&gt;SELECT&lt;/code&gt; есть имя. В простом &lt;code&gt;SELECT&lt;/code&gt; это имя используется только для обозначения столбца для отображения, но когда &lt;code&gt;SELECT&lt;/code&gt; является подзапросом более крупного запроса, имя рассматривается более крупным запросом как имя столбца виртуальной таблицы, созданной подзапросом. -запрос. Чтобы указать имя, которое будет использоваться для выходного столбца, напишите &lt;code&gt;AS&lt;/code&gt; &lt;code&gt;output_name&lt;/code&gt; после выражения столбца. (Вы можете опустить &lt;code&gt;AS&lt;/code&gt; , но только если желаемое выходное имя не соответствует ни одному ключевому слову PostgreSQL (см. &lt;a href=&quot;sql-keywords-appendix&quot;&gt;Приложение C&lt;/a&gt; ). Для защиты от возможных будущих добавлений ключевых слов рекомендуется всегда писать &lt;code&gt;AS&lt;/code&gt; или заключите имя вывода в двойные кавычки.) Если вы не укажете имя столбца, оно будет выбрано PostgreSQL автоматически. Если выражение столбца является простой ссылкой на столбец, то выбранное имя совпадает с именем этого столбца. В более сложных случаях может использоваться имя функции или типа, или система может использовать сгенерированное имя, такое как &lt;code&gt;?column?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="643851cd97b3016db737a7445d565c8fa4d8baef" translate="yes" xml:space="preserve">
          <source>Just as with indexes, a foreign key constraint can be checked &amp;ldquo;in bulk&amp;rdquo; more efficiently than row-by-row. So it might be useful to drop foreign key constraints, load data, and re-create the constraints. Again, there is a trade-off between data load speed and loss of error checking while the constraint is missing.</source>
          <target state="translated">Как и в случае с индексами, ограничение внешнего ключа можно проверять &amp;laquo;массово&amp;raquo; более эффективно, чем построчно. Поэтому было бы полезно отказаться от ограничений внешнего ключа, загрузить данные и воссоздать ограничения. Опять же, существует компромисс между скоростью загрузки данных и потерей проверки ошибок при отсутствии ограничения.</target>
        </trans-unit>
        <trans-unit id="22069315e577148c2b004f5dd6381d3b0deef8a4" translate="yes" xml:space="preserve">
          <source>Just-in-Time (JIT) compilation is the process of turning some form of interpreted program evaluation into a native program, and doing so at run time. For example, instead of using general-purpose code that can evaluate arbitrary SQL expressions to evaluate a particular SQL predicate like &lt;code&gt;WHERE a.col = 3&lt;/code&gt;, it is possible to generate a function that is specific to that expression and can be natively executed by the CPU, yielding a speedup.</source>
          <target state="translated">Компиляция &amp;laquo;точно в срок&amp;raquo; (JIT) - это процесс преобразования некоторой формы интерпретируемой оценки программы в собственную программу и выполнение этого во время выполнения. Например, вместо использования кода общего назначения, который может оценивать произвольные выражения SQL для оценки определенного предиката SQL, такого как &lt;code&gt;WHERE a.col = 3&lt;/code&gt; , можно сгенерировать функцию, которая является специфичной для этого выражения и может быть выполнена в исходном виде с помощью CPU, дающий ускорение.</target>
        </trans-unit>
        <trans-unit id="7af7e7edb636e51ba6b7f08c539611e4a0057634" translate="yes" xml:space="preserve">
          <source>Just-in-Time Compilation (JIT)</source>
          <target state="translated">Компиляция &quot;точно во время&quot; (JIT).</target>
        </trans-unit>
        <trans-unit id="299af5e109b0aae56134447e7dc2dcce5de37f34" translate="yes" xml:space="preserve">
          <source>Just-in-Time compilation</source>
          <target state="translated">Сборник &quot;Как раз вовремя</target>
        </trans-unit>
        <trans-unit id="ffa7300d92e16f73d505ed4698fdd4e962ca51c4" translate="yes" xml:space="preserve">
          <source>KAME kame/sys/crypto</source>
          <target state="translated">KAME kame/sys/crypto</target>
        </trans-unit>
        <trans-unit id="6b88dae842421fa69ad059376e38f360417c6965" translate="yes" xml:space="preserve">
          <source>KOI8-R</source>
          <target state="translated">KOI8-R</target>
        </trans-unit>
        <trans-unit id="ad190609bef1a0712934b8949ffb7c06fbaa6862" translate="yes" xml:space="preserve">
          <source>KOI8-U</source>
          <target state="translated">KOI8-U</target>
        </trans-unit>
        <trans-unit id="8f29952f92109ac24c1d37762ea2beef09083c31" translate="yes" xml:space="preserve">
          <source>KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">КайГай Кохей &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cd084d348b2278c1d6044754c142d3183367365" translate="yes" xml:space="preserve">
          <source>Keep in mind that all aggregate functions are evaluated before evaluating any &amp;ldquo;scalar&amp;rdquo; expressions in the &lt;code&gt;HAVING&lt;/code&gt; clause or &lt;code&gt;SELECT&lt;/code&gt; list. This means that, for example, a &lt;code&gt;CASE&lt;/code&gt; expression cannot be used to skip evaluation of an aggregate function; see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;.</source>
          <target state="translated">Имейте в виду, что все агрегатные функции оцениваются перед вычислением любых &amp;laquo;скалярных&amp;raquo; выражений в предложении &lt;code&gt;HAVING&lt;/code&gt; или списке &lt;code&gt;SELECT&lt;/code&gt; . Это означает, что, например, выражение &lt;code&gt;CASE&lt;/code&gt; не может использоваться для пропуска оценки агрегатной функции; см. &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;раздел 4.2.14&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a262b9c7138e1926e93240d562f76b55145fd596" translate="yes" xml:space="preserve">
          <source>Keep in mind that because &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; actually runs the query, any side-effects will happen as usual, even though whatever results the query might output are discarded in favor of printing the &lt;code&gt;EXPLAIN&lt;/code&gt; data. If you want to analyze a data-modifying query without changing your tables, you can roll the command back afterwards, for example:</source>
          <target state="translated">Имейте в виду, что, поскольку &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; фактически выполняет запрос, любые побочные эффекты будут происходить как обычно, даже если любые результаты, которые мог бы выдать запрос, отбрасываются в пользу печати данных &lt;code&gt;EXPLAIN&lt;/code&gt; . Если вы хотите проанализировать запрос, изменяющий данные, не изменяя свои таблицы, вы можете откатить команду назад, например:</target>
        </trans-unit>
        <trans-unit id="66b96c146884aa3a6a00a301b320c6680d6f4464" translate="yes" xml:space="preserve">
          <source>Keep in mind that by default, a regular expression can match just part of a string. It's usually wise to use &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;, as shown in the above example, to force the match to be to the entire system user name.</source>
          <target state="translated">Имейте в виду, что по умолчанию регулярное выражение может соответствовать только части строки. Обычно разумно использовать &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;$&lt;/code&gt; , как показано в приведенном выше примере, чтобы обеспечить совпадение со всем именем пользователя системы.</target>
        </trans-unit>
        <trans-unit id="c42b9dd519f94f2582e4a71f3f708e12c5a9653d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is important to specify the configuration name explicitly when creating &lt;code&gt;tsvector&lt;/code&gt; values inside triggers, so that the column's contents will not be affected by changes to &lt;code&gt;default_text_search_config&lt;/code&gt;. Failure to do this is likely to lead to problems such as search results changing after a dump and reload.</source>
          <target state="translated">Имейте в виду, что при создании значений &lt;code&gt;tsvector&lt;/code&gt; внутри триггеров важно явно указать имя конфигурации , чтобы на содержимое столбца не повлияли изменения в &lt;code&gt;default_text_search_config&lt;/code&gt; . Несоблюдение этого правила может привести к таким проблемам, как изменение результатов поиска после дампа и перезагрузки.</target>
        </trans-unit>
        <trans-unit id="f3ea22672b214f2b49222df5e8cffc5ea2a095eb" translate="yes" xml:space="preserve">
          <source>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal.</source>
          <target state="translated">Имейте в виду,что установка частичного индекса означает,что вы знаете,по крайней мере,столько же,сколько знает планировщик запросов,в частности,знаете,когда индекс может быть прибыльным.Формирование этих знаний требует опыта и понимания того,как работают индексы в PostgreSQL.В большинстве случаев преимущество частичного индекса перед обычным индексом будет минимальным.</target>
        </trans-unit>
        <trans-unit id="3bf0ca5e99386c2632aea1fa222371e26d7ffb9e" translate="yes" xml:space="preserve">
          <source>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal. There are cases where they are quite counterproductive, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX4&quot;&gt;Example 11.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef88fc4a4ab28c6433ccdb43fa109f84e6bdf441" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;hstore&lt;/code&gt; text format, when used for input, applies &lt;em&gt;before&lt;/em&gt; any required quoting or escaping. If you are passing an &lt;code&gt;hstore&lt;/code&gt; literal via a parameter, then no additional processing is needed. But if you're passing it as a quoted literal constant, then any single-quote characters and (depending on the setting of the &lt;code&gt;standard_conforming_strings&lt;/code&gt; configuration parameter) backslash characters need to be escaped correctly. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more on the handling of string constants.</source>
          <target state="translated">Имейте в виду, что текстовый формат &lt;code&gt;hstore&lt;/code&gt; , когда он используется для ввода, применяется &lt;em&gt;перед&lt;/em&gt; любым обязательным цитированием или экранированием. Если вы &lt;code&gt;hstore&lt;/code&gt; литерал hstore через параметр, дополнительная обработка не требуется. Но если вы передаете его как литеральную константу в кавычках, то любые символы одинарной кавычки и (в зависимости от настройки параметра конфигурации &lt;code&gt;standard_conforming_strings&lt;/code&gt; ) символы обратной косой черты должны быть экранированы правильно. См. &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Раздел 4.1.2.1&lt;/a&gt; для получения дополнительной информации об обработке строковых констант.</target>
        </trans-unit>
        <trans-unit id="3f96958d65d9c021639ce27dbbdb3f614f469552" translate="yes" xml:space="preserve">
          <source>Keep in mind that the delay parameters are compared to the elapsed time since the WAL data was received by the standby server. Thus, the grace period allowed to any one query on the standby is never more than the delay parameter, and could be considerably less if the standby has already fallen behind as a result of waiting for previous queries to complete, or as a result of being unable to keep up with a heavy update load.</source>
          <target state="translated">Помните,что параметры задержки сравниваются с истекшим временем,прошедшим с момента получения данных WAL резервным сервером.Таким образом,льготный период,разрешенный для любого одного запроса в режиме ожидания,никогда не превышает параметр задержки,и может быть значительно меньше,если в режиме ожидания уже произошло отставание в результате ожидания завершения предыдущих запросов,или в результате неспособности справиться с большой нагрузкой обновления.</target>
        </trans-unit>
        <trans-unit id="281e2d1f4654cd490bed6ab58e757285785a6b63" translate="yes" xml:space="preserve">
          <source>Keep in mind that the pattern argument of &lt;code&gt;like_regex&lt;/code&gt; is a JSON path string literal, written according to the rules given in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;. This means in particular that any backslashes you want to use in the regular expression must be doubled. For example, to match strings that contain only digits:</source>
          <target state="translated">Имейте в виду, что аргумент шаблона &lt;code&gt;like_regex&lt;/code&gt; - это строковый литерал пути JSON, записанный в соответствии с правилами, приведенными в &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Разделе 8.14.6&lt;/a&gt; . Это, в частности, означает, что любые обратные косые черты, которые вы хотите использовать в регулярном выражении, должны быть удвоены. Например, для сопоставления строк, содержащих только цифры:</target>
        </trans-unit>
        <trans-unit id="752b636fa6947f13347177c43e220a338c0e1d06" translate="yes" xml:space="preserve">
          <source>Keep in mind that the statement is actually executed when the &lt;code&gt;ANALYZE&lt;/code&gt; option is used. Although &lt;code&gt;EXPLAIN&lt;/code&gt; will discard any output that a &lt;code&gt;SELECT&lt;/code&gt; would return, other side effects of the statement will happen as usual. If you wish to use &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;EXECUTE&lt;/code&gt; statement without letting the command affect your data, use this approach:</source>
          <target state="translated">Имейте в виду, что оператор фактически выполняется, когда используется опция &lt;code&gt;ANALYZE&lt;/code&gt; . Хотя &lt;code&gt;EXPLAIN&lt;/code&gt; отбросит любой вывод, который вернет &lt;code&gt;SELECT&lt;/code&gt; , другие побочные эффекты инструкции будут происходить как обычно. Если вы хотите использовать &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; в &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;CREATE TABLE AS&lt;/code&gt; или &lt;code&gt;EXECUTE&lt;/code&gt; , не позволяя команде влиять на ваши данные, используйте следующий подход:</target>
        </trans-unit>
        <trans-unit id="1a83b7d50233b6c01f2847bb1d523d1444438ed5" translate="yes" xml:space="preserve">
          <source>Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, any user can issue arbitrary queries under the identity of any user not electing to protect itself individually. This pattern is acceptable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">Сохраните значение по умолчанию.Все пользователи получают неявный доступ к публичной схеме.Это симулирует ситуацию,когда схемы вообще недоступны,давая плавный переход из несхемного мира.Однако,любой пользователь может делать произвольные запросы под именем любого пользователя,не выбирающего индивидуальную защиту.Такая схема приемлема только в том случае,если в базе данных есть один пользователь или несколько взаимно доверяющих пользователей.</target>
        </trans-unit>
        <trans-unit id="7b02debd129668317e39732d6dfb75d3b401f787" translate="yes" xml:space="preserve">
          <source>Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, this is never a secure pattern. It is acceptable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c357ee3905e2cb6c0488939e3efd4649d18496" translate="yes" xml:space="preserve">
          <source>Keep the partitioning constraints simple, else the planner may not be able to prove that child tables might not need to be visited. Use simple equality conditions for list partitioning, or simple range tests for range partitioning, as illustrated in the preceding examples. A good rule of thumb is that partitioning constraints should contain only comparisons of the partitioning column(s) to constants using B-tree-indexable operators, because only B-tree-indexable column(s) are allowed in the partition key.</source>
          <target state="translated">Ограничения разметки должны быть простыми,иначе планировщик не сможет доказать,что дочерние таблицы,возможно,не нужно будет посещать.Используйте простые условия равенства для разбиения списка,или простые тесты диапазона для разбиения диапазона,как показано в предыдущих примерах.Хорошее эмпирическое правило заключается в том,что ограничения разметки должны содержать только сравнение столбцов (столбцов)разметки с константами с помощью операторов B-трех-индексируемых,так как в ключе раздела допускается только B-трех-индексируемых столбцов (столбцов).</target>
        </trans-unit>
        <trans-unit id="e2032a298b60ea58db844215a572d895ea523039" translate="yes" xml:space="preserve">
          <source>Kernels can also have system-wide limits on some resources.</source>
          <target state="translated">Ядра могут также иметь общесистемные ограничения на некоторые ресурсы.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="59dfe7e6cfc40d95e215dd77804938b17f6c9f40" translate="yes" xml:space="preserve">
          <source>Key Word</source>
          <target state="translated">Ключевое слово</target>
        </trans-unit>
        <trans-unit id="8e27223f630d5f11e0e66ca4d82327af33bd02f7" translate="yes" xml:space="preserve">
          <source>Key value of the row to start at</source>
          <target state="translated">Ключевое значение строки для начала</target>
        </trans-unit>
        <trans-unit id="fa701570481252ff476a0ecf4e2d51ece76ebca1" translate="yes" xml:space="preserve">
          <source>Key words and unquoted identifiers are case insensitive. Therefore:</source>
          <target state="translated">Ключевые слова и нецитируемые идентификаторы не чувствительны к регистру.Поэтому:</target>
        </trans-unit>
        <trans-unit id="dec66c5bf0f7fe4cc038ac871def8eb1ac31c146" translate="yes" xml:space="preserve">
          <source>Korean</source>
          <target state="translated">Korean</target>
        </trans-unit>
        <trans-unit id="2ceaa9727ea6aa546bde8ab43842a8c79efd8f8d" translate="yes" xml:space="preserve">
          <source>Korean (Hangul)</source>
          <target state="translated">корейский (хангыль)</target>
        </trans-unit>
        <trans-unit id="2bfe4366aec039158c13cdff560c53552a6ab2f8" translate="yes" xml:space="preserve">
          <source>LATIN1 with Euro and accents</source>
          <target state="translated">LATIN1 с евро и акцентами</target>
        </trans-unit>
        <trans-unit id="a3f57123a6c2ff10f831d7d1652f96a64aa8ede6" translate="yes" xml:space="preserve">
          <source>LC_COLLATE for this database</source>
          <target state="translated">LC_COLLATE для этой базы данных</target>
        </trans-unit>
        <trans-unit id="ccd2341e80cefe881c6b471888b83c35d3eedb65" translate="yes" xml:space="preserve">
          <source>LC_CTYPE for this database</source>
          <target state="translated">LC_CTYPE для этой базы данных</target>
        </trans-unit>
        <trans-unit id="d8343c683ae1584c96390fa627005bc1bb0719cd" translate="yes" xml:space="preserve">
          <source>LDAP</source>
          <target state="translated">LDAP</target>
        </trans-unit>
        <trans-unit id="d11fef55a0f4f7f77f5a743808a9e2af4cfab644" translate="yes" xml:space="preserve">
          <source>LDAP Authentication</source>
          <target state="translated">LDAP-аутентификация</target>
        </trans-unit>
        <trans-unit id="3af0c4862ddb95641f4519deb20c9bd92b5a696b" translate="yes" xml:space="preserve">
          <source>LDAP URLs are currently only supported with OpenLDAP, not on Windows.</source>
          <target state="translated">LDAP URL в настоящее время поддерживаются только с OpenLDAP,но не на Windows.</target>
        </trans-unit>
        <trans-unit id="a78f006babbca44fb715e5663d9cdd5f718dd110" translate="yes" xml:space="preserve">
          <source>LDAP authentication can operate in two modes. In the first mode, which we will call the simple bind mode, the server will bind to the distinguished name constructed as &lt;code&gt;prefix&lt;/code&gt;&lt;code&gt;username&lt;/code&gt;&lt;code&gt;suffix&lt;/code&gt;. Typically, the &lt;code&gt;prefix&lt;/code&gt; parameter is used to specify &lt;code&gt;cn=&lt;/code&gt;, or &lt;code&gt;DOMAIN&lt;/code&gt;&lt;code&gt;\&lt;/code&gt; in an Active Directory environment. &lt;code&gt;suffix&lt;/code&gt; is used to specify the remaining part of the DN in a non-Active Directory environment.</source>
          <target state="translated">Аутентификация LDAP может работать в двух режимах. В первом режиме, который мы будем называть режимом простого связывания, сервер будет связываться с отличительным именем, созданным как &lt;code&gt;prefix&lt;/code&gt; &lt;code&gt;suffix&lt;/code&gt; &lt;code&gt;username&lt;/code&gt; . Обычно параметр &lt;code&gt;prefix&lt;/code&gt; используется для указания &lt;code&gt;cn=&lt;/code&gt; или &lt;code&gt;DOMAIN&lt;/code&gt; &lt;code&gt;\&lt;/code&gt; в среде Active Directory. &lt;code&gt;suffix&lt;/code&gt; используется для указания оставшейся части DN в среде, отличной от Active Directory.</target>
        </trans-unit>
        <trans-unit id="9bd1b0f9c2859218ce1180337a2bd66b96113b2f" translate="yes" xml:space="preserve">
          <source>LIMIT and OFFSET</source>
          <target state="translated">ОГРАНИЧЕНИЕ и ОТКЛЮЧЕНИЕ</target>
        </trans-unit>
        <trans-unit id="9c6023564f6507b3ea5cad8e472da23961b9afbb" translate="yes" xml:space="preserve">
          <source>LISTEN</source>
          <target state="translated">LISTEN</target>
        </trans-unit>
        <trans-unit id="9814f182fea16d601141a37a9089918cd74f5452" translate="yes" xml:space="preserve">
          <source>LISTEN &amp;mdash; listen for a notification</source>
          <target state="translated">СЛУШАТЬ - прослушать уведомление</target>
        </trans-unit>
        <trans-unit id="8d0c622ff5ca1933ba98627381a4a7d1db679d31" translate="yes" xml:space="preserve">
          <source>LLVM has support for optimizing generated code. Some of the optimizations are cheap enough to be performed whenever JIT is used, while others are only beneficial for longer-running queries. See &lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https://llvm.org/docs/Passes.html#transform-passes&lt;/a&gt; for more details about optimizations.</source>
          <target state="translated">LLVM поддерживает оптимизацию сгенерированного кода. Некоторые из оптимизаций достаточно дешевы, чтобы их можно было выполнять всякий раз, когда используется JIT, тогда как другие полезны только для более длительных запросов. См. &lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;Https://llvm.org/docs/Passes.html#transform-passes&lt;/a&gt; для получения дополнительных сведений об оптимизации.</target>
        </trans-unit>
        <trans-unit id="97eb8c80f7fd9d9f6120c3bffd79e5e23e575196" translate="yes" xml:space="preserve">
          <source>LOAD</source>
          <target state="translated">LOAD</target>
        </trans-unit>
        <trans-unit id="ca2a082afa739ad45f7209a3186244665643f398" translate="yes" xml:space="preserve">
          <source>LOAD &amp;mdash; load a shared library file</source>
          <target state="translated">ЗАГРУЗИТЬ - загрузить файл общей библиотеки</target>
        </trans-unit>
        <trans-unit id="c37eb4cb935a6017aaaaaab327837c7d9bbbc004" translate="yes" xml:space="preserve">
          <source>LOCK</source>
          <target state="translated">LOCK</target>
        </trans-unit>
        <trans-unit id="92d4fa824b1bf5ae650f5b90867eff13a3a5fe0a" translate="yes" xml:space="preserve">
          <source>LOCK &amp;mdash; lock a table</source>
          <target state="translated">LOCK - заблокировать стол</target>
        </trans-unit>
        <trans-unit id="6b4bea52cbee20f8507b76217f199114a117089e" translate="yes" xml:space="preserve">
          <source>LSN</source>
          <target state="translated">LSN</target>
        </trans-unit>
        <trans-unit id="d1fca76fb082d22a2d8e514d1b3ce5e3ce9aa851" translate="yes" xml:space="preserve">
          <source>LSN: next byte after last byte of WAL record for last change to this page</source>
          <target state="translated">LSN:следующий байт после последнего байта записи WAL для последнего изменения этой страницы.</target>
        </trans-unit>
        <trans-unit id="f7d6ac021994cd293b3c94c2f6248d32ae9579b5" translate="yes" xml:space="preserve">
          <source>Lag times work automatically for physical replication. Logical decoding plugins may optionally emit tracking messages; if they do not, the tracking mechanism will simply display NULL lag.</source>
          <target state="translated">Время задержки работает автоматически для физической репликации.Логические плагины декодирования могут опционально выдавать сообщения об отслеживании;если они этого не делают,то механизм отслеживания будет просто отображать NULL лаг.</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="5e9465d239944a0fa40232e75aff84b43ba97385" translate="yes" xml:space="preserve">
          <source>Language of messages</source>
          <target state="translated">Язык сообщений</target>
        </trans-unit>
        <trans-unit id="ce146ba97ccf4a9eb00c4f7b7284970bf1503949" translate="yes" xml:space="preserve">
          <source>Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</source>
          <target state="translated">Большие объекты (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;Главу 34&lt;/a&gt; ) не реплицируются. Для этого нет никакого обходного пути, кроме хранения данных в обычных таблицах.</target>
        </trans-unit>
        <trans-unit id="f6b0e78c3e5e8149e57bd763e4fa479405b51a85" translate="yes" xml:space="preserve">
          <source>Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/13/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24b3c46d4ed7dfe7397ec67ef490f12c7f2d62a" translate="yes" xml:space="preserve">
          <source>Last system OID in the database; useful particularly to pg_dump</source>
          <target state="translated">Последний OID системы в базе данных;полезен,в частности,для pg_dump</target>
        </trans-unit>
        <trans-unit id="d8a8330f47a1d2121f7de4d246b07c539d85b887" translate="yes" xml:space="preserve">
          <source>Last time at which this table was analyzed by the autovacuum daemon</source>
          <target state="translated">Последний раз,когда эту таблицу анализировал демон-автовакуум.</target>
        </trans-unit>
        <trans-unit id="b5daedfbaeb26dce099e49150d7deba8ed7dd63c" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually analyzed</source>
          <target state="translated">Последний раз при ручном анализе этой таблицы</target>
        </trans-unit>
        <trans-unit id="d21dc8edf16ccb5721e0bc05e599292ce8cd64c2" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">Последний раз, когда эта таблица была очищена вручную (не считая &lt;code&gt;VACUUM FULL&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="32d602dc6c753beae99504e742b35637bae47172" translate="yes" xml:space="preserve">
          <source>Last time at which this table was vacuumed by the autovacuum daemon</source>
          <target state="translated">Последний раз,когда этот стол пылесосил демон-автомат.</target>
        </trans-unit>
        <trans-unit id="a6160372ad225c352ec7ffd4f36cad1f43f752fb" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location already received and flushed to disk, the initial value of this field being the first log location used when WAL receiver is started</source>
          <target state="translated">Последнее место записи журнала,уже полученное и промытое на диск,начальное значение этого поля является первым местом записи журнала,используемым при запуске приемника WAL</target>
        </trans-unit>
        <trans-unit id="1c2624daf23aae1afae71faf67ded93dc5500054" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location already received and written to disk, but not flushed. This should not be used for data integrity checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd26aafa1fbdf96a846556c081c9e292557ed50" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location flushed to disk by this standby server</source>
          <target state="translated">Последнее место записи журнала на диск этим резервным сервером.</target>
        </trans-unit>
        <trans-unit id="3196ac97aabe6b93efdbd9d951f27185a4510ea9" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location received, the initial value of this field being 0</source>
          <target state="translated">Последнее полученное местоположение журнала на заголовке записи,начальное значение этого поля равно 0</target>
        </trans-unit>
        <trans-unit id="7fce43ad04e1c6ea844b5017a38c520afa802611" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location replayed into the database on this standby server</source>
          <target state="translated">Последнее место записи журнала,воспроизведенное в базе данных на этом резервном сервере.</target>
        </trans-unit>
        <trans-unit id="0d3835b7f40d0e6e66b1e74e7de916b14d4f990d" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location reported to origin WAL sender</source>
          <target state="translated">Последнее местоположение журнала с заголовком записи,сообщенное отправителю WAL.</target>
        </trans-unit>
        <trans-unit id="ac1ae56d16c8b53cb449a2ee572fbfc684cbf5dd" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location sent on this connection</source>
          <target state="translated">Последнее место записи журнала,отправленное по этому соединению.</target>
        </trans-unit>
        <trans-unit id="bafcffd5bbf934c91f7d04975d6317a745ba4820" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location written to disk by this standby server</source>
          <target state="translated">Последнее место записи журнала вперед,записанное на диск этим резервным сервером.</target>
        </trans-unit>
        <trans-unit id="ba538f112903a51c4fdd1a1494e1875649a225bb" translate="yes" xml:space="preserve">
          <source>Latin/Arabic</source>
          <target state="translated">Latin/Arabic</target>
        </trans-unit>
        <trans-unit id="fd84929c694afd8b1b6d7503f4f8e1b23aed9285" translate="yes" xml:space="preserve">
          <source>Latin/Cyrillic</source>
          <target state="translated">Latin/Cyrillic</target>
        </trans-unit>
        <trans-unit id="e688538b3f17f5cc30931971a729f9f8fe4c1bdd" translate="yes" xml:space="preserve">
          <source>Latin/Greek</source>
          <target state="translated">Latin/Greek</target>
        </trans-unit>
        <trans-unit id="daa3f6da7a3a4e4229771dc7d3d5e346a4582850" translate="yes" xml:space="preserve">
          <source>Latin/Hebrew</source>
          <target state="translated">Latin/Hebrew</target>
        </trans-unit>
        <trans-unit id="d494f73e6e88daa7f95e93345a91fc4c8dc4fb69" translate="yes" xml:space="preserve">
          <source>Launch the main autoprewarm worker. This will normally happen automatically, but is useful if automatic prewarm was not configured at server startup time and you wish to start up the worker at a later time.</source>
          <target state="translated">Запустите главного работника автосервиса.Обычно это происходит автоматически,но это полезно,если автоматическая предварительная подогрев не была настроена во время запуска сервера,и вы хотите запустить работника позже.</target>
        </trans-unit>
        <trans-unit id="2c4136854685f9259aab343bbd1cc7a50348e3a5" translate="yes" xml:space="preserve">
          <source>Leaf page fragmentation</source>
          <target state="translated">Фрагментация листовых страниц</target>
        </trans-unit>
        <trans-unit id="5f877225069b04b69ebc49ed1c8ffc9db5e722b5" translate="yes" xml:space="preserve">
          <source>Leaf tuples of an SP-GiST tree contain values of the same data type as the indexed column. Leaf tuples at the root level will always contain the original indexed data value, but leaf tuples at lower levels might contain only a compressed representation, such as a suffix. In that case the operator class support functions must be able to reconstruct the original value using information accumulated from the inner tuples that are passed through to reach the leaf level.</source>
          <target state="translated">Листовые кортежи дерева SP-GiST содержат значения того же типа данных,что и индексируемый столбец.Листовые кортежи на корневом уровне всегда будут содержать исходное индексированное значение данных,однако листовые кортежи на более низких уровнях могут содержать только сжатое представление,например,суффикс.В этом случае функции поддержки операторского класса должны иметь возможность восстановить исходное значение,используя информацию,накопленную из внутренних кортежей,которые передаются на уровень листьев.</target>
        </trans-unit>
        <trans-unit id="5daa8198764e4eb159c9ea5a3939ed7ca08e926f" translate="yes" xml:space="preserve">
          <source>Least common multiple (the smallest strictly positive number that is an integral multiple of both inputs); returns &lt;code&gt;0&lt;/code&gt; if either input is zero; available for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9299c2aba089dc4590aa8606b111db26dae4554a" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of associated operator</source>
          <target state="translated">Тип входных данных левого входа ассоциированного оператора</target>
        </trans-unit>
        <trans-unit id="ed906ae901de1e3195028f0570c5ad60b2810880" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of operator</source>
          <target state="translated">Тип оператора левостороннего ввода данных</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="d8b851cee953f8d81c31ec69468e0ec20c2888c1" translate="yes" xml:space="preserve">
          <source>Length of aggregation interval (in seconds). May be used only with &lt;code&gt;-l&lt;/code&gt; option. With this option, the log contains per-interval summary data, as described below.</source>
          <target state="translated">Длина интервала агрегирования (в секундах). Может использоваться только с опцией &lt;code&gt;-l&lt;/code&gt; . С этой опцией журнал содержит сводные данные за интервал, как описано ниже.</target>
        </trans-unit>
        <trans-unit id="af6b0587a83fcd51886d616d3a32f3398d01980f" translate="yes" xml:space="preserve">
          <source>Length of binary string</source>
          <target state="translated">Длина двоичной строки</target>
        </trans-unit>
        <trans-unit id="ccfe4a6f325c29c147887556a7714e5ddcdfe308" translate="yes" xml:space="preserve">
          <source>Length of each signature (index entry) in bits. It is rounded up to the nearest multiple of &lt;code&gt;16&lt;/code&gt;. The default is &lt;code&gt;80&lt;/code&gt; bits and the maximum is &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">Длина каждой подписи (индексной записи) в битах. Оно округляется до ближайшего числа, кратного &lt;code&gt;16&lt;/code&gt; . По умолчанию - &lt;code&gt;80&lt;/code&gt; бит, максимальное - &lt;code&gt;4096&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12d4a8b76c20bac65c1a5a078f5f7a8e333266b4" translate="yes" xml:space="preserve">
          <source>Length or circumference</source>
          <target state="translated">Длина или окружность</target>
        </trans-unit>
        <trans-unit id="9d6ed670f3c04a36b7689b66ca5b25c4d52af652" translate="yes" xml:space="preserve">
          <source>Less likely to cause problems is the minimum size for shared memory segments (&lt;code&gt;SHMMIN&lt;/code&gt;), which should be at most approximately 32 bytes for PostgreSQL (it is usually just 1). The maximum number of segments system-wide (&lt;code&gt;SHMMNI&lt;/code&gt;) or per-process (&lt;code&gt;SHMSEG&lt;/code&gt;) are unlikely to cause a problem unless your system has them set to zero.</source>
          <target state="translated">С меньшей вероятностью возникнут проблемы с минимальным размером сегментов разделяемой памяти ( &lt;code&gt;SHMMIN&lt;/code&gt; ), который для PostgreSQL должен составлять не более 32 байтов (обычно это всего 1). Максимальное количество сегментов для всей системы ( &lt;code&gt;SHMMNI&lt;/code&gt; ) или для каждого процесса ( &lt;code&gt;SHMSEG&lt;/code&gt; ) вряд ли вызовет проблему, если в вашей системе они не установлены на ноль.</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">Менее чем</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88e84c79a2349d1ad4055f51a25c693dabaf88a" translate="yes" xml:space="preserve">
          <source>Less-than comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f01a7dce204970734b2b2a327ee36987199e47f" translate="yes" xml:space="preserve">
          <source>Less-than operator</source>
          <target state="translated">Менее чем оператор</target>
        </trans-unit>
        <trans-unit id="9f4307f8c5a910003114771823ca3aa6f1218371" translate="yes" xml:space="preserve">
          <source>Less-than-or-equal-to comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4576a6bc031e504cf481eb0d13f776e9d54832eb" translate="yes" xml:space="preserve">
          <source>Less-than-or-equal-to operator</source>
          <target state="translated">Меньше чем оператор или меньше.</target>
        </trans-unit>
        <trans-unit id="0ab7950f1f29b3334f76dd244ef5a7ba783b1b7f" translate="yes" xml:space="preserve">
          <source>Let's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. So we define a foreign key constraint in the orders table that references the products table:</source>
          <target state="translated">Предположим также,что у вас есть стол,в котором хранятся заказы на эту продукцию.Мы хотим убедиться,что таблица заказов содержит только те заказы продуктов,которые действительно существуют.Поэтому мы определяем в таблице ордеров ограничение постороннего ключа,которое ссылается на таблицу продуктов:</target>
        </trans-unit>
        <trans-unit id="4bb0a1a761abe6883839cec3e71ca469d8a65b69" translate="yes" xml:space="preserve">
          <source>Let's assume you have filled the table with data and want to take a look at it:</source>
          <target state="translated">Предположим,что вы заполнили таблицу данными и хотите взглянуть на нее:</target>
        </trans-unit>
        <trans-unit id="6bb447a9045c7cc0d5a93bdb00100d8f10c020e2" translate="yes" xml:space="preserve">
          <source>Let's consider a real-life astronomical example. We'll expand query &lt;code&gt;supernovae&lt;/code&gt; using table-driven rewriting rules:</source>
          <target state="translated">Рассмотрим реальный астрономический пример. Мы расширим запросы &lt;code&gt;supernovae&lt;/code&gt; используя правила перезаписи на основе таблиц:</target>
        </trans-unit>
        <trans-unit id="3450ae90635f5fd80bf01d11b0586d3e5b336518" translate="yes" xml:space="preserve">
          <source>Let's create two tables: A table &lt;code&gt;cities&lt;/code&gt; and a table &lt;code&gt;capitals&lt;/code&gt;. Naturally, capitals are also cities, so you want some way to show the capitals implicitly when you list all cities. If you're really clever you might invent some scheme like this:</source>
          <target state="translated">Создадим две таблицы: таблицу &lt;code&gt;cities&lt;/code&gt; и таблицу &lt;code&gt;capitals&lt;/code&gt; . Естественно, столицы также являются городами, поэтому вам нужен способ неявно отображать столицы при перечислении всех городов. Если вы действительно умны, вы можете придумать такую ​​схему:</target>
        </trans-unit>
        <trans-unit id="002106d5520b7ff0cea15ef411a279196063cbfa" translate="yes" xml:space="preserve">
          <source>Let's look at that command in detail. First is the key word &lt;code&gt;UPDATE&lt;/code&gt; followed by the table name. As usual, the table name can be schema-qualified, otherwise it is looked up in the path. Next is the key word &lt;code&gt;SET&lt;/code&gt; followed by the column name, an equal sign, and the new column value. The new column value can be any scalar expression, not just a constant. For example, if you want to raise the price of all products by 10% you could use:</source>
          <target state="translated">Давайте подробно рассмотрим эту команду. Сначала идет ключевое слово &lt;code&gt;UPDATE&lt;/code&gt; , за которым следует имя таблицы. Как обычно, имя таблицы может быть дополнено схемой, в противном случае оно ищется в пути. Далее следует ключевое слово &lt;code&gt;SET&lt;/code&gt; , за которым следует имя столбца, знак равенства и новое значение столбца. Новое значение столбца может быть любым скалярным выражением, а не только константой. Например, если вы хотите поднять цену на все товары на 10%, вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="66b99b3611a0c2fdc7f95a1799fb3492cd67f4e6" translate="yes" xml:space="preserve">
          <source>Let's look at the query from &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt; again, but this time with a MCV list created on the same set of columns (be sure to drop the functional dependencies, to make sure the planner uses the newly created statistics).</source>
          <target state="translated">Давайте снова посмотрим на запрос из &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Раздела 70.2.1&lt;/a&gt; , но на этот раз со списком MCV, созданным на том же наборе столбцов (обязательно отбросьте функциональные зависимости, чтобы планировщик использовал вновь созданную статистику).</target>
        </trans-unit>
        <trans-unit id="1612ac24f2069dd66f65838fc7336fa0b28c41cb" translate="yes" xml:space="preserve">
          <source>Let's move on to an example with a range condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">Перейдем к примеру с условием диапазона в &lt;code&gt;WHERE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e33f516fc6df811ac7dea3c6a71c77e25ecd5519" translate="yes" xml:space="preserve">
          <source>Let's start with a very simple query:</source>
          <target state="translated">Начнем с очень простого запроса:</target>
        </trans-unit>
        <trans-unit id="944a02000a7cd912b7786576975c692505293e37" translate="yes" xml:space="preserve">
          <source>Let's start with an example: suppose we are trying to build a data model for cities. Each state has many cities, but only one capital. We want to be able to quickly retrieve the capital city for any particular state. This can be done by creating two tables, one for state capitals and one for cities that are not capitals. However, what happens when we want to ask for data about a city, regardless of whether it is a capital or not? The inheritance feature can help to resolve this problem. We define the &lt;code&gt;capitals&lt;/code&gt; table so that it inherits from &lt;code&gt;cities&lt;/code&gt;:</source>
          <target state="translated">Начнем с примера: предположим, мы пытаемся построить модель данных для городов. В каждом штате много городов, но только одна столица. Мы хотим иметь возможность быстро найти столицу для любого конкретного штата. Это можно сделать, создав две таблицы, одну для столиц штатов и одну для городов, которые не являются столицами. Однако что происходит, когда мы хотим запросить данные о городе, независимо от того, является он столицей или нет? Функция наследования может помочь решить эту проблему. Мы определяем таблицу &lt;code&gt;capitals&lt;/code&gt; так, чтобы она унаследовала от &lt;code&gt;cities&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8936905c2cce98cf23701c4834f7f639d90f7b6d" translate="yes" xml:space="preserve">
          <source>Let's try joining two tables, using the columns we have been discussing:</source>
          <target state="translated">Давайте попробуем присоединиться к двум столам,используя колонки,которые мы обсуждали:</target>
        </trans-unit>
        <trans-unit id="fc56b91f6d327225a18362ab13575f562f30c691" translate="yes" xml:space="preserve">
          <source>Lexemes that have positions can further be labeled with a &lt;em&gt;weight&lt;/em&gt;, which can be &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. &lt;code&gt;D&lt;/code&gt; is the default and hence is not shown on output:</source>
          <target state="translated">Лексемы , которые имеют позицию дополнительно могут быть помечены с &lt;em&gt;весом&lt;/em&gt; , который может быть , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; или &lt;code&gt;D&lt;/code&gt; . &lt;code&gt;D&lt;/code&gt; - значение по умолчанию и поэтому не отображается на выходе: &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4de4e82a8494674ff2932d2f3ecffa7e7aa91c37" translate="yes" xml:space="preserve">
          <source>Lexical Structure</source>
          <target state="translated">Лексическая структура</target>
        </trans-unit>
        <trans-unit id="98b17490298c1db6b1bff4b00e76136ec7bbbbbf" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Comments</source>
          <target state="translated">Лексическая структура:Комментарии</target>
        </trans-unit>
        <trans-unit id="fba7d54766b9a41f8c00c3be52c20790571085f9" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Constants</source>
          <target state="translated">Лексическая структура:Константы</target>
        </trans-unit>
        <trans-unit id="0eb1a63288ed8a4eea2395df1dd364cf859d54a6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Identifiers and Key Words</source>
          <target state="translated">Лексическая структура:Идентификаторы и ключевые слова</target>
        </trans-unit>
        <trans-unit id="195802f293c2f60e26c9b9d1cca1271d02591bfe" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operator Precedence</source>
          <target state="translated">Лексическая структура:Приоритет оператора</target>
        </trans-unit>
        <trans-unit id="f3025dccc066fa7289f006eb8ae5b580e53548c6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operators</source>
          <target state="translated">Лексическая структура:Операторы</target>
        </trans-unit>
        <trans-unit id="820a42a37bd5d5e7546df4a06a9fad64993321ea" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Special Characters</source>
          <target state="translated">Лексическая структура:Специальные символы</target>
        </trans-unit>
        <trans-unit id="aa1c47b9be01b70fcc0a9ce52958782af56ce40a" translate="yes" xml:space="preserve">
          <source>Library API</source>
          <target state="translated">API библиотеки</target>
        </trans-unit>
        <trans-unit id="bc61796bcb48c2cc0906e22b19a382e56ac7241c" translate="yes" xml:space="preserve">
          <source>Licensed under the PostgreSQL License.</source>
          <target state="translated">Лицензия PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="70e96422ed9935802e683689abf5ed30f10484c2" translate="yes" xml:space="preserve">
          <source>Lightweight Directory Access Protocol</source>
          <target state="translated">Легкий протокол доступа к каталогам</target>
        </trans-unit>
        <trans-unit id="706c7257274a3b242ba385122feaad6c90232d40" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;%/&lt;/code&gt;, but the output is &lt;code&gt;~&lt;/code&gt; (tilde) if the database is your default database.</source>
          <target state="translated">Как &lt;code&gt;%/&lt;/code&gt; , но вывод будет &lt;code&gt;~&lt;/code&gt; (тильда), если база данных является вашей базой данных по умолчанию.</target>
        </trans-unit>
        <trans-unit id="01c5b4c11e3825cd811354418a5a2a2256d5f14a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--locale&lt;/code&gt;, but only sets the locale in the specified category.</source>
          <target state="translated">Подобно &lt;code&gt;--locale&lt;/code&gt; , но устанавливает языковой стандарт только в указанной категории.</target>
        </trans-unit>
        <trans-unit id="592d71b5f1a2fc02390509f112e2932ece3b2ce3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.**&lt;/code&gt;, but selects only the specified levels of the JSON hierarchy. Nesting levels are specified as integers. Level zero corresponds to the current object. To access the lowest nesting level, you can use the &lt;code&gt;last&lt;/code&gt; keyword. This is a PostgreSQL extension of the SQL/JSON standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bcb9cac0fa5cedaf3e22ad3fe9503230b5e0b4b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;LIKE&lt;/code&gt;, the &lt;code&gt;SIMILAR TO&lt;/code&gt; operator succeeds only if its pattern matches the entire string; this is unlike common regular expression behavior where the pattern can match any part of the string. Also like &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; uses &lt;code&gt;_&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; as wildcard characters denoting any single character and any string, respectively (these are comparable to &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;.*&lt;/code&gt; in POSIX regular expressions).</source>
          <target state="translated">Как и &lt;code&gt;LIKE&lt;/code&gt; , оператор &lt;code&gt;SIMILAR TO&lt;/code&gt; работает успешно, только если его шаблон соответствует всей строке; это отличается от обычного поведения регулярных выражений, когда шаблон может соответствовать любой части строки. Кроме того, как &lt;code&gt;LIKE&lt;/code&gt; , &lt;code&gt;SIMILAR TO&lt;/code&gt; использование &lt;code&gt;_&lt;/code&gt; и &lt;code&gt;%&lt;/code&gt; в качестве подстановочных знаков , обозначающих один любой символ и любой строки, соответственно (это сопоставимо с &lt;code&gt;.&lt;/code&gt; И &lt;code&gt;.*&lt;/code&gt; В POSIX регулярных выражений).</target>
        </trans-unit>
        <trans-unit id="85a2ab4c0cd63cc27de88b6c0b7fbce75e30b6bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;aggfinalmodify&lt;/code&gt;, but for the &lt;code&gt;aggmfinalfn&lt;/code&gt;</source>
          <target state="translated">Как &lt;code&gt;aggfinalmodify&lt;/code&gt; , но для &lt;code&gt;aggmfinalfn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059422d409e873d3ec537d586c30c482c509b6ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;penalty&lt;/code&gt;, the &lt;code&gt;picksplit&lt;/code&gt; function is crucial to good performance of the index. Designing suitable &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; implementations is where the challenge of implementing well-performing GiST indexes lies.</source>
          <target state="translated">Как и &lt;code&gt;penalty&lt;/code&gt; , функция &lt;code&gt;picksplit&lt;/code&gt; имеет решающее значение для хорошей производительности индекса. Разработка подходящих реализаций для &lt;code&gt;penalty&lt;/code&gt; и &lt;code&gt;picksplit&lt;/code&gt; - вот где проблема реализации хорошо работающих индексов GiST.</target>
        </trans-unit>
        <trans-unit id="2af7b72fbf0a8ccd43a00ff740a0fef8b75c0395" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pg_statistic&lt;/code&gt;, &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; should not be readable by the public, since the contents might be considered sensitive. (Example: most common combinations of values in columns might be quite interesting.) &lt;a href=&quot;view-pg-stats-ext&quot;&gt;&lt;code&gt;pg_stats_ext&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; (after joining with &lt;code&gt;pg_statistic_ext&lt;/code&gt;) that only exposes information about those tables and columns that are readable by the current user.</source>
          <target state="translated">Как и &lt;code&gt;pg_statistic&lt;/code&gt; , &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; не должна быть доступна для чтения широкой публике, поскольку ее содержимое может считаться конфиденциальным. (Пример: наиболее распространенные комбинации значений в столбцах могут быть весьма интересными.) &lt;a href=&quot;view-pg-stats-ext&quot;&gt; &lt;code&gt;pg_stats_ext&lt;/code&gt; &lt;/a&gt; - это общедоступное представление &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; (после соединения с &lt;code&gt;pg_statistic_ext&lt;/code&gt; ), которое предоставляет информацию только о тех таблицах и столбцах, которые доступны для чтения текущему пользователю.</target>
        </trans-unit>
        <trans-unit id="1e283f20748a53829b82b5760d76e1b1a5f034e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plainto_tsquery&lt;/code&gt;, the &lt;code&gt;phraseto_tsquery&lt;/code&gt; function will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">Как и &lt;code&gt;plainto_tsquery&lt;/code&gt; , функция &lt;code&gt;phraseto_tsquery&lt;/code&gt; не распознает операторы &lt;code&gt;tsquery&lt;/code&gt; , метки веса или метки соответствия префиксу во входных данных:</target>
        </trans-unit>
        <trans-unit id="176fba135c7656c6b09a34f8083ee1cb69b4df0d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;code&gt;toptag&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; но результат не &lt;code&gt;toptag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01344dcf6fdc7567e1ebfddcdc592af8624be340" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;em&gt;&lt;code&gt;toptag&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a092e16f9fe5baae3ebd61fa16eca90ce0ed31e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits both tags.</source>
          <target state="translated">Аналогично &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; но в результате оба тега отсутствуют.</target>
        </trans-unit>
        <trans-unit id="79231c4789ce70fc6a3cc412988cea4a45cfbcbb" translate="yes" xml:space="preserve">
          <source>Like GiST and SP-GiST, GIN can support many different user-defined indexing strategies, and the particular operators with which a GIN index can be used vary depending on the indexing strategy. As an example, the standard distribution of PostgreSQL includes a GIN operator class for arrays, which supports indexed queries using these operators:</source>
          <target state="translated">Как и GiST и SP-GiST,GIN может поддерживать множество различных пользовательских стратегий индексирования,а конкретные операторы,с которыми можно использовать GIN-индекс,отличаются в зависимости от стратегии индексирования.Например,стандартная дистрибуция PostgreSQL включает в себя класс GIN-оператора для массивов,который поддерживает индексированные запросы с использованием этих операторов:</target>
        </trans-unit>
        <trans-unit id="cd7904080c36090327450bf7ffd681d3be365b14" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST is meant to allow the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">Как и GiST,SP-GiST предназначен для разработки пользовательских типов данных с соответствующими методами доступа экспертом в области типа данных,а не экспертом по базам данных.</target>
        </trans-unit>
        <trans-unit id="48b6f9b32591a18a649f1f0d5dc992087748dd36" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST supports &amp;ldquo;nearest-neighbor&amp;rdquo; searches. For SP-GiST operator classes that support distance ordering, the corresponding operator is specified in the &amp;ldquo;Ordering Operators&amp;rdquo; column in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">Как и GiST, SP-GiST поддерживает поиск &amp;laquo;ближайшего соседа&amp;raquo;. Для классов операторов SP-GiST, поддерживающих дистанционное упорядочение, соответствующий оператор указан в столбце &amp;laquo;Операторы упорядочивания&amp;raquo; в &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;таблице 65.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60e4d14adfb5f143c50beb7e0713788626061776" translate="yes" xml:space="preserve">
          <source>Like a &lt;code&gt;CASE&lt;/code&gt; expression, &lt;code&gt;COALESCE&lt;/code&gt; only evaluates the arguments that are needed to determine the result; that is, arguments to the right of the first non-null argument are not evaluated. This SQL-standard function provides capabilities similar to &lt;code&gt;NVL&lt;/code&gt; and &lt;code&gt;IFNULL&lt;/code&gt;, which are used in some other database systems.</source>
          <target state="translated">Как и выражение &lt;code&gt;CASE&lt;/code&gt; , &lt;code&gt;COALESCE&lt;/code&gt; оценивает только те аргументы, которые необходимы для определения результата; то есть аргументы справа от первого ненулевого аргумента не оцениваются. Этот SQL-стандартная функция предоставляет возможности , аналогичные &lt;code&gt;NVL&lt;/code&gt; и &lt;code&gt;IFNULL&lt;/code&gt; , которые используются в некоторых других системах баз данных.</target>
        </trans-unit>
        <trans-unit id="1b49279f338ded2bdf03d1fe2fa28270882b8852" translate="yes" xml:space="preserve">
          <source>Like all locks in PostgreSQL, a complete list of advisory locks currently held by any session can be found in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">Как и все блокировки в PostgreSQL, полный список рекомендательных блокировок, удерживаемых в настоящее время любым сеансом, можно найти в системном представлении &lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41cf9a59f49a59843cd96e23e78a1ccf6b90562d" translate="yes" xml:space="preserve">
          <source>Like all statement-logging options, this option can add significant overhead.</source>
          <target state="translated">Как и все опции регистрации событий,эта опция может добавить значительные накладные расходы.</target>
        </trans-unit>
        <trans-unit id="59c02f2aa97036dbf7f53371e80651c744767251" translate="yes" xml:space="preserve">
          <source>Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt;. Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</source>
          <target state="translated">Как и любое другое клиентское приложение PostgreSQL, pg_dump по умолчанию будет подключаться к имени пользователя базы данных, которое совпадает с именем пользователя текущей операционной системы. Чтобы изменить это, укажите параметр &lt;code&gt;-U&lt;/code&gt; или установите переменную среды &lt;code&gt;PGUSER&lt;/code&gt; . Помните, что соединения pg_dump подчиняются обычным механизмам аутентификации клиентов (которые описаны в &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;главе 20&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab5911dcefb73651b71811a18cd1ea69e7e94d92" translate="yes" xml:space="preserve">
          <source>Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt;. Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9db72f7082c44e13743d7b5d39d781324396c03" translate="yes" xml:space="preserve">
          <source>Like most other relational database products, PostgreSQL supports &lt;em&gt;aggregate functions&lt;/em&gt;. An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt; (average), &lt;code&gt;max&lt;/code&gt; (maximum) and &lt;code&gt;min&lt;/code&gt; (minimum) over a set of rows.</source>
          <target state="translated">Как и большинство других продуктов для реляционных баз данных, PostgreSQL поддерживает &lt;em&gt;агрегатные функции&lt;/em&gt; . Агрегатная функция вычисляет один результат из нескольких входных строк. Например, есть агрегаты для вычисления &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;sum&lt;/code&gt; , &lt;code&gt;avg&lt;/code&gt; (среднее), &lt;code&gt;max&lt;/code&gt; (максимум) и &lt;code&gt;min&lt;/code&gt; (минимум) по набору строк.</target>
        </trans-unit>
        <trans-unit id="e7b37131745c0548a8d7bb256942b653bac4d0f2" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are requested.</source>
          <target state="translated">Подобно встроенному методу выборки &lt;code&gt;SYSTEM&lt;/code&gt; , &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; выполняет выборку на уровне блоков, так что выборка не является полностью случайной, но может подвергаться эффектам кластеризации, особенно если запрашивается только небольшое количество строк.</target>
        </trans-unit>
        <trans-unit id="2764b8aec49f0a51f07f507803e713795f179f24" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_TIME&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are selected.</source>
          <target state="translated">Подобно встроенному методу выборки &lt;code&gt;SYSTEM&lt;/code&gt; , &lt;code&gt;SYSTEM_TIME&lt;/code&gt; выполняет выборку на уровне блоков, поэтому выборка не является полностью случайной, но может подвергаться эффектам кластеризации, особенно если выбрано только небольшое количество строк.</target>
        </trans-unit>
        <trans-unit id="b3332deec758b17e6fd52517b579fa1eda61782d" translate="yes" xml:space="preserve">
          <source>Likewise, any sequence state changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e207e275fe1f2f0794d071fcc2006657d41ca30" translate="yes" xml:space="preserve">
          <source>Likewise, if the output column is an array type and the JSON value is a JSON array, the elements of the JSON array are converted to elements of the output array by recursive application of these rules.</source>
          <target state="translated">Аналогично,если выходной столбец является типом массива,а JSON-значение-это JSON-массив,то элементы JSON-массива преобразуются в элементы выходного массива путем рекурсивного применения этих правил.</target>
        </trans-unit>
        <trans-unit id="c63c5f8682585854b3af24acfaa10cdf34814785" translate="yes" xml:space="preserve">
          <source>Likewise, it is the operator class's responsibility that inner tuples do not grow too large to fit on an index page; this limits the number of child nodes that can be used in one inner tuple, as well as the maximum size of a prefix value.</source>
          <target state="translated">Точно так же и класс оператора несет ответственность за то,чтобы внутренние кортежи не росли слишком большими,чтобы поместиться на индексной странице;это ограничивает количество дочерних узлов,которые могут быть использованы в одном внутреннем кортеже,а также максимальный размер значения префикса.</target>
        </trans-unit>
        <trans-unit id="55246b1bbd1c53d922bbe5662b502ad39d3e6a6a" translate="yes" xml:space="preserve">
          <source>Likewise, the current session's temporary-table schema, &lt;code&gt;pg_temp_nnn&lt;/code&gt;, is always searched if it exists. It can be explicitly listed in the path by using the alias &lt;code&gt;pg_temp&lt;/code&gt;. If it is not listed in the path then it is searched first (even before &lt;code&gt;pg_catalog&lt;/code&gt;). However, the temporary schema is only searched for relation (table, view, sequence, etc) and data type names. It is never searched for function or operator names.</source>
          <target state="translated">Аналогичным образом, всегда ищется схема временной таблицы текущего сеанса &lt;code&gt;pg_temp_nnn&lt;/code&gt; , если она существует. Его можно явно &lt;code&gt;pg_temp&lt;/code&gt; в пути, используя псевдоним pg_temp . Если он не указан в пути, сначала выполняется поиск (даже до &lt;code&gt;pg_catalog&lt;/code&gt; ). Однако во временной схеме выполняется поиск только по именам отношений (таблица, представление, последовательность и т. Д.) И типам данных. Он никогда не ищется по именам функций или операторов.</target>
        </trans-unit>
        <trans-unit id="23e122f77e2123c0711252ea9a852e626bde8b4c" translate="yes" xml:space="preserve">
          <source>Likewise, while an aggregate final function is normally expected not to modify its input values, sometimes it is impractical to avoid modifying the transition-state argument. Such behavior must be declared using the &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; parameter. The &lt;code&gt;READ_WRITE&lt;/code&gt; value indicates that the final function modifies the transition state in unspecified ways. This value prevents use of the aggregate as a window function, and it also prevents merging of transition states for aggregate calls that share the same input values and transition functions. The &lt;code&gt;SHAREABLE&lt;/code&gt; value indicates that the transition function cannot be applied after the final function, but multiple final-function calls can be performed on the ending transition state value. This value prevents use of the aggregate as a window function, but it allows merging of transition states. (That is, the optimization of interest here is not applying the same final function repeatedly, but applying different final functions to the same ending transition state value. This is allowed as long as none of the final functions are marked &lt;code&gt;READ_WRITE&lt;/code&gt;.)</source>
          <target state="translated">Аналогичным образом, хотя обычно ожидается, что агрегированная конечная функция не будет изменять свои входные значения, иногда нецелесообразно избегать изменения аргумента переходного состояния. Такое поведение должно быть объявлено с &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; параметра FINALFUNC_MODIFY . Значение &lt;code&gt;READ_WRITE&lt;/code&gt; указывает, что последняя функция изменяет состояние перехода неуказанными способами. Это значение предотвращает использование агрегата в качестве оконной функции, а также предотвращает слияние переходных состояний для агрегированных вызовов, которые используют одни и те же входные значения и функции перехода. &lt;code&gt;SHAREABLE&lt;/code&gt; value указывает, что функция перехода не может быть применена после последней функции, но несколько вызовов final-function могут быть выполнены для значения конечного состояния перехода. Это значение предотвращает использование агрегата в качестве оконной функции, но позволяет объединять переходные состояния. (То есть интересующая здесь оптимизация заключается не в повторном применении одной и той же конечной функции, а в применении разных конечных функций к одному и тому же значению конечного состояния перехода. Это разрешено, пока ни одна из конечных функций не помечена как &lt;code&gt;READ_WRITE&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="b47563cbfdd571c38564d5b781eea43887f5700d" translate="yes" xml:space="preserve">
          <source>Limits and compatibility notes for the &lt;code&gt;xml&lt;/code&gt; data type can be found in &lt;a href=&quot;xml-limits-conformance&quot;&gt;Section D.3&lt;/a&gt;.</source>
          <target state="translated">Примечания по ограничениям и совместимости для типа данных &lt;code&gt;xml&lt;/code&gt; можно найти в &lt;a href=&quot;xml-limits-conformance&quot;&gt;Разделе D.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96d43f75faf24d1ca67c70ecd2f285a22f1af174" translate="yes" xml:space="preserve">
          <source>Line number of this rule in &lt;code&gt;pg_hba.conf&lt;/code&gt;</source>
          <target state="translated">Номер строки этого правила в &lt;code&gt;pg_hba.conf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="958c1e90be0b1ef7a3ea1a3a2ab4b6c7d005a8b7" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file the current value was set at (null for values set from sources other than configuration files, or when examined by a user who is neither a superuser or a member of &lt;code&gt;pg_read_all_settings&lt;/code&gt;).</source>
          <target state="translated">Номер строки в файле конфигурации, в котором было установлено текущее значение (null для значений, установленных из источников, отличных от файлов конфигурации, или при &lt;code&gt;pg_read_all_settings&lt;/code&gt; пользователем, который не является ни суперпользователем, ни членом pg_read_all_settings ).</target>
        </trans-unit>
        <trans-unit id="5b8f36e71eca1491bb5a406fd952255ee2d3703e" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file where the entry appears</source>
          <target state="translated">Номер строки в файле конфигурации,где появляется запись</target>
        </trans-unit>
        <trans-unit id="883c97e9c14ffbedf2267734a54bef543950a75e" translate="yes" xml:space="preserve">
          <source>Line segments are output using the first syntax.</source>
          <target state="translated">Сегменты линий выводятся с использованием первого синтаксиса.</target>
        </trans-unit>
        <trans-unit id="752729c6452eefd378564f7929186a93baad040b" translate="yes" xml:space="preserve">
          <source>Line segments are represented by pairs of points that are the endpoints of the segment. Values of type &lt;code&gt;lseg&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">Сегменты линии представлены парами точек, которые являются конечными точками сегмента. Значения типа &lt;code&gt;lseg&lt;/code&gt; указываются с использованием любого из следующих синтаксисов:</target>
        </trans-unit>
        <trans-unit id="16fbbc248c377444909f3461d6f0754204ffd781" translate="yes" xml:space="preserve">
          <source>Lines are represented by the linear equation &lt;code&gt;A&lt;/code&gt;x + &lt;code&gt;B&lt;/code&gt;y + &lt;code&gt;C&lt;/code&gt; = 0, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are not both zero. Values of type &lt;code&gt;line&lt;/code&gt; are input and output in the following form:</source>
          <target state="translated">Линии представлены линейным уравнением &lt;code&gt;A&lt;/code&gt; x + &lt;code&gt;B&lt;/code&gt; y + &lt;code&gt;C&lt;/code&gt; = 0, где &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; не равны нулю. Значения типа &lt;code&gt;line&lt;/code&gt; вводятся и выводятся в следующем виде:</target>
        </trans-unit>
        <trans-unit id="c8eb4d4a92219b0c43b53ed882184405007c09a3" translate="yes" xml:space="preserve">
          <source>Lines being skipped are parsed normally to identify queries and backslash commands, but queries are not sent to the server, and backslash commands other than conditionals (&lt;code&gt;\if&lt;/code&gt;, &lt;code&gt;\elif&lt;/code&gt;, &lt;code&gt;\else&lt;/code&gt;, &lt;code&gt;\endif&lt;/code&gt;) are ignored. Conditional commands are checked only for valid nesting. Variable references in skipped lines are not expanded, and backquote expansion is not performed either.</source>
          <target state="translated">Пропускаемые строки обычно анализируются для идентификации запросов и команд с обратной косой чертой, но запросы не отправляются на сервер, а команды с обратной косой чертой, кроме условных ( &lt;code&gt;\if&lt;/code&gt; , &lt;code&gt;\elif&lt;/code&gt; , &lt;code&gt;\else&lt;/code&gt; , &lt;code&gt;\endif&lt;/code&gt; ), игнорируются. Условные команды проверяются только на правильность вложенности. Ссылки на переменные в пропущенных строках не раскрываются, как и обратные кавычки.</target>
        </trans-unit>
        <trans-unit id="292bae73b4b4a6866d3b72fe56f7981ef97aafd8" translate="yes" xml:space="preserve">
          <source>Lines in the file can be commented out, deleted, and reordered. For example:</source>
          <target state="translated">Строки в файле могут быть закомментированы,удалены и переупорядочены.Например:</target>
        </trans-unit>
        <trans-unit id="5f388e9f9cc02768dd9a283f46d4fc51473f089e" translate="yes" xml:space="preserve">
          <source>Linguistic &amp;mdash; Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1f33913b1ca17a294498b513bfd39ae8063421" translate="yes" xml:space="preserve">
          <source>Linguistic - Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</source>
          <target state="translated">Лингвистический-словари орфографии пытаются свести вводимые слова к нормализованной форме;словари стеблера удаляют окончания слов</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="77cec0c3e9d8d25a57ec1badeff796c61ca86f12" translate="yes" xml:space="preserve">
          <source>List Partitioning</source>
          <target state="translated">Разбивка списка</target>
        </trans-unit>
        <trans-unit id="0f3458dce5820aca7e890c4b2003d0e275648e05" translate="yes" xml:space="preserve">
          <source>List all available databases, then exit. Other non-connection options are ignored. This is similar to the meta-command &lt;code&gt;\list&lt;/code&gt;.</source>
          <target state="translated">Перечислите все доступные базы данных и выйдите. Другие варианты без подключения игнорируются. Это похоже на мета-команду &lt;code&gt;\list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4286624f672002892b2ca95ea48f927cd5f85422" translate="yes" xml:space="preserve">
          <source>List information about tables or indexes in a partition tree for a given partitioned table or partitioned index, with one row for each partition. Information provided includes the name of the partition, the name of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The value of level begins at &lt;code&gt;0&lt;/code&gt; for the input table or index in its role as the root of the partition tree, &lt;code&gt;1&lt;/code&gt; for its partitions, &lt;code&gt;2&lt;/code&gt; for their partitions, and so on.</source>
          <target state="translated">Перечислить информацию о таблицах или индексах в дереве разделов для заданной многораздельной таблицы или многораздельного индекса, с одной строкой для каждого раздела. Предоставляемая информация включает имя раздела, имя его непосредственного родителя, логическое значение, указывающее, является ли раздел листом, и целое число, указывающее его уровень в иерархии. Значение level начинается с &lt;code&gt;0&lt;/code&gt; для входной таблицы или индекса в его роли как корня дерева разделов, &lt;code&gt;1&lt;/code&gt; для его разделов, &lt;code&gt;2&lt;/code&gt; для их разделов и так далее.</target>
        </trans-unit>
        <trans-unit id="f561011cb33daf6ca735d20bdacd8bd7a77bc262" translate="yes" xml:space="preserve">
          <source>List of database name(s) to which this rule applies</source>
          <target state="translated">Список имен БД,к которым применяется данное правило</target>
        </trans-unit>
        <trans-unit id="c88853b59f7b2d53c0a2755574e42ba43712f76a" translate="yes" xml:space="preserve">
          <source>List of user and group name(s) to which this rule applies</source>
          <target state="translated">Список имен пользователей и групп,к которым применяется данное правило.</target>
        </trans-unit>
        <trans-unit id="d7af7e299822395c971e66ef8de74b892601d575" translate="yes" xml:space="preserve">
          <source>List text search configurations (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">Список конфигураций текстового поиска (добавьте &lt;code&gt;+&lt;/code&gt; , чтобы узнать подробнее).</target>
        </trans-unit>
        <trans-unit id="75bf8723aef5bc601305334105eb67bae8708809" translate="yes" xml:space="preserve">
          <source>List text search dictionaries (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">Список словарей текстового поиска (добавьте &lt;code&gt;+&lt;/code&gt; для подробностей).</target>
        </trans-unit>
        <trans-unit id="f21d1140d1b1ac1f6965e01da259ebe5d03603ab" translate="yes" xml:space="preserve">
          <source>List text search parsers (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">Список парсеров текстового поиска (добавьте &lt;code&gt;+&lt;/code&gt; для подробностей).</target>
        </trans-unit>
        <trans-unit id="a1e1b832b491c08ce8f5b18d1ec93b64f07d2462" translate="yes" xml:space="preserve">
          <source>List text search templates (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">Список шаблонов текстового поиска (добавьте &lt;code&gt;+&lt;/code&gt; для подробностей).</target>
        </trans-unit>
        <trans-unit id="47ced8a7739926f8f4967c561a0debfd00799b0f" translate="yes" xml:space="preserve">
          <source>List the ancestor relations of the given partition, including the partition itself.</source>
          <target state="translated">Перечислите отношения предков данного раздела,включая сам раздел.</target>
        </trans-unit>
        <trans-unit id="1202ae63c3dc8af04c25238d78d5139577abc684" translate="yes" xml:space="preserve">
          <source>List the contents of a directory. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">Перечислите содержимое каталога.По умолчанию,эта функция доступна только для суперпользователей,но другим пользователям может быть предоставлен доступ к функции EXECUTE.</target>
        </trans-unit>
        <trans-unit id="1b401449c4e0d240387a616d5ffbd4a726f02619" translate="yes" xml:space="preserve">
          <source>List the databases in the server and show their names, owners, character set encodings, and access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only databases whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, database sizes, default tablespaces, and descriptions are also displayed. (Size information is only available for databases that the current user can connect to.)</source>
          <target state="translated">Перечислите базы данных на сервере и покажите их имена, владельцев, кодировки набора символов и права доступа. Если &lt;code&gt;pattern&lt;/code&gt; указан, только базы данных, имена которых соответствуют шаблону перечислены. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , также отображаются размеры базы данных, табличные пространства по умолчанию и описания. (Информация о размере доступна только для баз данных, к которым может подключиться текущий пользователь.)</target>
        </trans-unit>
        <trans-unit id="0247fd79dd91c3e0b751440d00b889937665ce82" translate="yes" xml:space="preserve">
          <source>List the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory</source>
          <target state="translated">Перечислить файлы журнала в каталоге &lt;code&gt;log_directory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38872979f824f8456260bf7fc7dc4180d1627b73" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL archive status directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">Укажите имя, размер и время последнего изменения файлов в каталоге состояния архива WAL. Доступ предоставляется членам роли &lt;code&gt;pg_monitor&lt;/code&gt; и может быть предоставлен другим ролям, не являющимся суперпользователем.</target>
        </trans-unit>
        <trans-unit id="216f390c14edafdef1abb92a2e408162ca22c8d7" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">Укажите имя, размер и время последнего изменения файлов в каталоге WAL. Доступ предоставляется членам роли &lt;code&gt;pg_monitor&lt;/code&gt; и может быть предоставлен другим ролям, не являющимся суперпользователем.</target>
        </trans-unit>
        <trans-unit id="74056411fa2a679687b641cd39f5e9f62ea8d563" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the log directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">Укажите имя, размер и время последнего изменения файлов в каталоге журнала. Доступ предоставляется членам роли &lt;code&gt;pg_monitor&lt;/code&gt; и может быть предоставлен другим ролям, не являющимся суперпользователем.</target>
        </trans-unit>
        <trans-unit id="26197e7b4127b303329ad5784e3d755d4742f8bd" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the temporary directory for &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt; is not provided, the &lt;code&gt;pg_default&lt;/code&gt; tablespace is used. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">Укажите имя, размер и время последнего изменения файлов во временном каталоге &lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt; . Если &lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt; не указано, &lt;code&gt;pg_default&lt;/code&gt; табличное пространство pg_default . Доступ предоставляется членам роли &lt;code&gt;pg_monitor&lt;/code&gt; и может быть предоставлен другим ролям, не являющимся суперпользователем.</target>
        </trans-unit>
        <trans-unit id="6c759b89899d2c028e05b2457d4bdd0b88affd68" translate="yes" xml:space="preserve">
          <source>List the table of contents of the archive. The output of this operation can be used as input to the &lt;code&gt;-L&lt;/code&gt; option. Note that if filtering switches such as &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-t&lt;/code&gt; are used with &lt;code&gt;-l&lt;/code&gt;, they will restrict the items listed.</source>
          <target state="translated">Вывести оглавление архива. Вывод этой операции можно использовать как ввод для опции &lt;code&gt;-L&lt;/code&gt; . Обратите внимание, что если параметры фильтрации, такие как &lt;code&gt;-n&lt;/code&gt; или &lt;code&gt;-t&lt;/code&gt; , используются с &lt;code&gt;-l&lt;/code&gt; , они ограничивают перечисленные элементы.</target>
        </trans-unit>
        <trans-unit id="c161fe12eda9cadc384d03d0ff29a932c7632490" translate="yes" xml:space="preserve">
          <source>Lists access methods. If &lt;code&gt;pattern&lt;/code&gt; is specified, only access methods whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each access method is listed with its associated handler function and description.</source>
          <target state="translated">Перечисляет методы доступа. Если &lt;code&gt;pattern&lt;/code&gt; указан, только методы доступа, имена которых соответствуют шаблону показаны. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , каждый метод доступа перечисляется с соответствующей функцией обработчика и описанием.</target>
        </trans-unit>
        <trans-unit id="b5da05aa6b417885b162fa263cf878dfa1640338" translate="yes" xml:space="preserve">
          <source>Lists aggregate functions, together with their return type and the data types they operate on. If &lt;code&gt;pattern&lt;/code&gt; is specified, only aggregates whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">Перечисляет агрегатные функции вместе с их типом возвращаемого значения и типами данных, с которыми они работают. Если &lt;code&gt;pattern&lt;/code&gt; указан, только агрегаты , чьи имена соответствуют шаблону показаны. По умолчанию отображаются только объекты, созданные пользователем; предоставить шаблон или модификатор &lt;code&gt;S&lt;/code&gt; для включения системных объектов.</target>
        </trans-unit>
        <trans-unit id="ba7e4d85e717101a207e6ece8fa5eae17728be95" translate="yes" xml:space="preserve">
          <source>Lists collations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only collations whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each collation is listed with its associated description, if any. Note that only collations usable with the current database's encoding are shown, so the results may vary in different databases of the same installation.</source>
          <target state="translated">Списки сопоставлений. Если &lt;code&gt;pattern&lt;/code&gt; указан, только чьи имена сортировки соответствуют шаблону в списке. По умолчанию отображаются только объекты, созданные пользователем; предоставить шаблон или модификатор &lt;code&gt;S&lt;/code&gt; для включения системных объектов. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , каждое сопоставление перечисляется с соответствующим описанием, если таковое имеется. Обратите внимание, что показаны только сопоставления, которые можно использовать с кодировкой текущей базы данных, поэтому результаты могут отличаться в разных базах данных одной и той же установки.</target>
        </trans-unit>
        <trans-unit id="6ed6b6d351ec0314d4901220593cc831623e426a" translate="yes" xml:space="preserve">
          <source>Lists conversions between character-set encodings. If &lt;code&gt;pattern&lt;/code&gt; is specified, only conversions whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">Перечисляет преобразования между кодировками набора символов. Если &lt;code&gt;pattern&lt;/code&gt; указан, только преобразования , чьи имена соответствуют шаблону в списке. По умолчанию отображаются только объекты, созданные пользователем; предоставить шаблон или модификатор &lt;code&gt;S&lt;/code&gt; для включения системных объектов. Если к имени команды добавлен знак &amp;laquo; &lt;code&gt;+&lt;/code&gt; &amp;raquo; , каждый объект отображается вместе с соответствующим описанием.</target>
        </trans-unit>
        <trans-unit id="b54152fa5b884f8f7bf428a2c5f3834496af64bd" translate="yes" xml:space="preserve">
          <source>Lists data types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only types whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each type is listed with its internal name and size, its allowed values if it is an &lt;code&gt;enum&lt;/code&gt; type, and its associated permissions. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">Перечисляет типы данных. Если &lt;code&gt;pattern&lt;/code&gt; указывается только типы, имена которых совпадают с шаблоном в списке. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , каждый тип перечисляется с его внутренним именем и размером, его допустимыми значениями, если это тип &lt;code&gt;enum&lt;/code&gt; , и соответствующими разрешениями. По умолчанию отображаются только объекты, созданные пользователем; предоставить шаблон или модификатор &lt;code&gt;S&lt;/code&gt; для включения системных объектов.</target>
        </trans-unit>
        <trans-unit id="1ed12c82d91396faa77acdf69ded0ffcf5a493ea" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\dg&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\du+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">Список ролей базы данных. (Поскольку понятия &amp;laquo;пользователи&amp;raquo; и &amp;laquo;группы&amp;raquo; были объединены в &amp;laquo;роли&amp;raquo;, эта команда теперь эквивалентна &lt;code&gt;\dg&lt;/code&gt; .) По умолчанию отображаются только роли, созданные пользователем; поставлять &lt;code&gt;S&lt;/code&gt; модификатор включать системные роли. Если &lt;code&gt;pattern&lt;/code&gt; указан, только те роли , чьи имена соответствуют шаблону , будут перечислены. Если используется форма &lt;code&gt;\du+&lt;/code&gt; , отображается дополнительная информация о каждой роли; в настоящее время это добавляет комментарий для каждой роли.</target>
        </trans-unit>
        <trans-unit id="e29d00c4605108f4d7ba7d0a5a262d70885a0257" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\du&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\dg+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">Список ролей базы данных. (Поскольку понятия &amp;laquo;пользователи&amp;raquo; и &amp;laquo;группы&amp;raquo; были объединены в &amp;laquo;роли&amp;raquo;, эта команда теперь эквивалентна &lt;code&gt;\du&lt;/code&gt; .) По умолчанию отображаются только роли, созданные пользователем; поставлять &lt;code&gt;S&lt;/code&gt; модификатор включать системные роли. Если &lt;code&gt;pattern&lt;/code&gt; указан, только те роли , чьи имена соответствуют шаблону , будут перечислены. Если используется форма &lt;code&gt;\dg+&lt;/code&gt; , отображается дополнительная информация о каждой роли; в настоящее время это добавляет комментарий для каждой роли.</target>
        </trans-unit>
        <trans-unit id="d0e3c51687d883f635b713be9df17a17913ec4be" translate="yes" xml:space="preserve">
          <source>Lists default access privilege settings. An entry is shown for each role (and schema, if applicable) for which the default privilege settings have been changed from the built-in defaults. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose role name or schema name matches the pattern are listed.</source>
          <target state="translated">Перечисляет настройки прав доступа по умолчанию. Запись отображается для каждой роли (и схемы, если применимо), для которой настройки привилегий по умолчанию были изменены по сравнению со встроенными значениями по умолчанию. Если &lt;code&gt;pattern&lt;/code&gt; указан, записи только чье имя роли или имя схемы совпадает с шаблоном в списке.</target>
        </trans-unit>
        <trans-unit id="ee1fa4ed6c7126c1942282c2d9a97fd2fb17066c" translate="yes" xml:space="preserve">
          <source>Lists defined configuration settings. These settings can be role-specific, database-specific, or both. &lt;code&gt;role-pattern&lt;/code&gt; and &lt;code&gt;database-pattern&lt;/code&gt; are used to select specific roles and databases to list, respectively. If omitted, or if &lt;code&gt;*&lt;/code&gt; is specified, all settings are listed, including those not role-specific or database-specific, respectively.</source>
          <target state="translated">Перечисляет определенные параметры конфигурации. Эти параметры могут быть связаны с ролями, базами данных или и тем, и другим. &lt;code&gt;role-pattern&lt;/code&gt; и &lt;code&gt;database-pattern&lt;/code&gt; используются для выбора конкретных ролей и баз данных в список, соответственно. Если этот параметр не указан или указан &lt;code&gt;*&lt;/code&gt; , отображаются все параметры, включая параметры, не зависящие от роли или базы данных, соответственно.</target>
        </trans-unit>
        <trans-unit id="417307de73c4769c24d10a4a74f461c675665a71" translate="yes" xml:space="preserve">
          <source>Lists domains. If &lt;code&gt;pattern&lt;/code&gt; is specified, only domains whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description.</source>
          <target state="translated">Список доменов. Если &lt;code&gt;pattern&lt;/code&gt; указан, только домены, имена которых соответствуют шаблону , будут показаны. По умолчанию отображаются только объекты, созданные пользователем; предоставить шаблон или модификатор &lt;code&gt;S&lt;/code&gt; для включения системных объектов. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , каждый объект перечисляется с соответствующими разрешениями и описанием.</target>
        </trans-unit>
        <trans-unit id="f274b8d8f8b448f365efc740c76106814f6e8672" translate="yes" xml:space="preserve">
          <source>Lists event triggers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those event triggers whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">Перечисляет триггеры событий. Если &lt;code&gt;pattern&lt;/code&gt; указан, только те триггеры событий, имена которых соответствуют шаблону , будут перечислены. Если к имени команды добавлен знак &amp;laquo; &lt;code&gt;+&lt;/code&gt; &amp;raquo; , каждый объект отображается вместе с соответствующим описанием.</target>
        </trans-unit>
        <trans-unit id="e79aeba25c72ede19da97f86bce69c0ff45f55b7" translate="yes" xml:space="preserve">
          <source>Lists foreign servers (mnemonic: &amp;ldquo;external servers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those servers whose name matches the pattern are listed. If the form &lt;code&gt;\des+&lt;/code&gt; is used, a full description of each server is shown, including the server's access privileges, type, version, options, and description.</source>
          <target state="translated">Список внешних серверов (мнемоника: &amp;laquo;внешние серверы&amp;raquo;). Если &lt;code&gt;pattern&lt;/code&gt; указан, только те серверы чье имя соответствует шаблону в списке. Если используется форма &lt;code&gt;\des+&lt;/code&gt; , отображается полное описание каждого сервера, включая права доступа к серверу, тип, версию, параметры и описание.</target>
        </trans-unit>
        <trans-unit id="78b8f146a38943cc21434e0badfc06780b279a22" translate="yes" xml:space="preserve">
          <source>Lists foreign tables (mnemonic: &amp;ldquo;external tables&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose table name or schema name matches the pattern are listed. If the form &lt;code&gt;\det+&lt;/code&gt; is used, generic options and the foreign table description are also displayed.</source>
          <target state="translated">Перечисляет внешние таблицы (мнемоника: &amp;laquo;внешние таблицы&amp;raquo;). Если &lt;code&gt;pattern&lt;/code&gt; указан, записи только чье имя таблицы или имя схемы совпадает с шаблоном в списке. Если используется форма &lt;code&gt;\det+&lt;/code&gt; , также отображаются общие параметры и описание сторонней таблицы.</target>
        </trans-unit>
        <trans-unit id="841607b805a28257bffdea756495ef2cb699e228" translate="yes" xml:space="preserve">
          <source>Lists foreign-data wrappers (mnemonic: &amp;ldquo;external wrappers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those foreign-data wrappers whose name matches the pattern are listed. If the form &lt;code&gt;\dew+&lt;/code&gt; is used, the access privileges, options, and description of the foreign-data wrapper are also shown.</source>
          <target state="translated">Перечисляет оболочки сторонних данных (мнемоника: &amp;laquo;внешние оболочки&amp;raquo;). Если &lt;code&gt;pattern&lt;/code&gt; указан, только те обертки иностранных данных чье имя соответствует шаблону в списке. Если используется форма &lt;code&gt;\dew+&lt;/code&gt; , также отображаются права доступа, параметры и описание оболочки сторонних данных.</target>
        </trans-unit>
        <trans-unit id="c91d07a0e33c78c3a0a76bd7d8280b785bbd7664" translate="yes" xml:space="preserve">
          <source>Lists functions, together with their result data types, argument data types, and function types, which are classified as &amp;ldquo;agg&amp;rdquo; (aggregate), &amp;ldquo;normal&amp;rdquo;, &amp;ldquo;procedure&amp;rdquo;, &amp;ldquo;trigger&amp;rdquo;, or &amp;ldquo;window&amp;rdquo;. To display only functions of specific type(s), add the corresponding letters &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; to the command. If &lt;code&gt;pattern&lt;/code&gt; is specified, only functions whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If the form &lt;code&gt;\df+&lt;/code&gt; is used, additional information about each function is shown, including volatility, parallel safety, owner, security classification, access privileges, language, source code and description.</source>
          <target state="translated">Перечисляет функции вместе с их типами данных результатов, типами данных аргументов и типами функций, которые классифицируются как &amp;laquo;агг&amp;raquo; (агрегат), &amp;laquo;нормальный&amp;raquo;, &amp;laquo;процедура&amp;raquo;, &amp;laquo;триггер&amp;raquo; или &amp;laquo;окно&amp;raquo;. Чтобы отображать только функции определенного типа (ов), добавьте к команде соответствующие буквы &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; или &lt;code&gt;w&lt;/code&gt; . Если &lt;code&gt;pattern&lt;/code&gt; указан, только функции, имена которых соответствуют шаблону показаны. По умолчанию отображаются только объекты, созданные пользователем; предоставить шаблон или модификатор &lt;code&gt;S&lt;/code&gt; для включения системных объектов. Если форма &lt;code&gt;\df+&lt;/code&gt; отображается дополнительная информация о каждой функции, включая изменчивость, параллельную безопасность, владельца, классификацию безопасности, права доступа, язык, исходный код и описание.</target>
        </trans-unit>
        <trans-unit id="24ae150e74e52548491a1b8532993c514778868d" translate="yes" xml:space="preserve">
          <source>Lists installed extensions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those extensions whose names match the pattern are listed. If the form &lt;code&gt;\dx+&lt;/code&gt; is used, all the objects belonging to each matching extension are listed.</source>
          <target state="translated">Список установленных расширений. Если &lt;code&gt;pattern&lt;/code&gt; указан, только те расширения, имена которых соответствуют шаблону , будут перечислены. Если используется форма &lt;code&gt;\dx+&lt;/code&gt; , будут перечислены все объекты, принадлежащие каждому соответствующему расширению.</target>
        </trans-unit>
        <trans-unit id="9786e0547a160a45eeaaa13b899d2ca350fd4bf0" translate="yes" xml:space="preserve">
          <source>Lists operator classes (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPCLASS&quot;&gt;Section 37.16.1&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator classes associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator classes associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator class is listed with its associated operator family and owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dabc9d2416e57fbb1a6fc125515b7843848c40ff" translate="yes" xml:space="preserve">
          <source>Lists operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPFAMILY&quot;&gt;Section 37.16.5&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator families associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator family is listed with its owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02fc530a920ec71e97da7b47a26de17857efd30a" translate="yes" xml:space="preserve">
          <source>Lists operators associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-STRATEGIES&quot;&gt;Section 37.16.2&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only members of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only members of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator is listed with its sort operator family (if it is an ordering operator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b91d850ae0056bf60018b5ebefbaf56889e4bca" translate="yes" xml:space="preserve">
          <source>Lists operators with their operand and result types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only operators whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional information about each operator is shown, currently just the name of the underlying function.</source>
          <target state="translated">Список операторов с их операндами и типами результатов. Если &lt;code&gt;pattern&lt;/code&gt; указан, только операторы, имена которых совпадают с шаблоном в списке. По умолчанию отображаются только объекты, созданные пользователем; предоставить шаблон или модификатор &lt;code&gt;S&lt;/code&gt; для включения системных объектов. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , отображается дополнительная информация о каждом операторе, в настоящее время это только имя базовой функции.</target>
        </trans-unit>
        <trans-unit id="b6dce10f054bc4a066d94e91eb2653d58925f8ed" translate="yes" xml:space="preserve">
          <source>Lists partitioned relations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose name matches the pattern are listed. The modifiers &lt;code&gt;t&lt;/code&gt; (tables) and &lt;code&gt;i&lt;/code&gt; (indexes) can be appended to the command, filtering the kind of relations to list. By default, partitioned tables and indexes are listed.</source>
          <target state="translated">Списки разделенных отношений. Если &lt;code&gt;pattern&lt;/code&gt; указан, записи только чье имя совпадает с шаблоном в списке. Модификаторы &lt;code&gt;t&lt;/code&gt; (таблицы) и &lt;code&gt;i&lt;/code&gt; (индексы) могут быть добавлены к команде, фильтруя тип отношений для списка. По умолчанию перечислены многораздельные таблицы и индексы.</target>
        </trans-unit>
        <trans-unit id="6639ac93b6964b1629641d3ad0795ccf6bdb89e2" translate="yes" xml:space="preserve">
          <source>Lists procedural languages. If &lt;code&gt;pattern&lt;/code&gt; is specified, only languages whose names match the pattern are listed. By default, only user-created languages are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each language is listed with its call handler, validator, access privileges, and whether it is a system object.</source>
          <target state="translated">Перечисляет процедурные языки. Если &lt;code&gt;pattern&lt;/code&gt; указан, только языки , имена которых соответствуют шаблону перечислены. По умолчанию отображаются только языки, созданные пользователем; подачи &lt;code&gt;S&lt;/code&gt; модификатор включает системные объекты. Если к имени команды добавляется &lt;code&gt;+&lt;/code&gt; , каждый язык перечисляется с указанием его обработчика вызовов, валидатора, прав доступа и того, является ли он системным объектом.</target>
        </trans-unit>
        <trans-unit id="d159d89b43261dc04712aa39d984b98a29983107" translate="yes" xml:space="preserve">
          <source>Lists replication publications. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those publications whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, the tables associated with each publication are shown as well.</source>
          <target state="translated">Перечисляет тиражные публикации. Если &lt;code&gt;pattern&lt;/code&gt; указан, только те публикации , чьи имена соответствуют шаблону , будут перечислены. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , также отображаются таблицы, связанные с каждой публикацией.</target>
        </trans-unit>
        <trans-unit id="5edfb1ad4f7a1bcdc13378e73525d95e092cfe45" translate="yes" xml:space="preserve">
          <source>Lists replication subscriptions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those subscriptions whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional properties of the subscriptions are shown.</source>
          <target state="translated">Список подписок на репликацию. Если &lt;code&gt;pattern&lt;/code&gt; указан, только те подписки , чьи имена соответствуют шаблону , будут перечислены. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , отображаются дополнительные свойства подписок.</target>
        </trans-unit>
        <trans-unit id="4fb239c1a080740cf10a3927b46a1262b5ea56d1" translate="yes" xml:space="preserve">
          <source>Lists schemas (namespaces). If &lt;code&gt;pattern&lt;/code&gt; is specified, only schemas whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description, if any.</source>
          <target state="translated">Список схем (пространств имен). Если &lt;code&gt;pattern&lt;/code&gt; указан, только схемы , чьи имена соответствуют шаблону в списке. По умолчанию отображаются только объекты, созданные пользователем; предоставить шаблон или модификатор &lt;code&gt;S&lt;/code&gt; для включения системных объектов. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , каждый объект перечисляется с соответствующими разрешениями и описанием, если таковое имеется.</target>
        </trans-unit>
        <trans-unit id="f82cdaaaa438cda917a1234e5b948d7815debbbb" translate="yes" xml:space="preserve">
          <source>Lists support functions associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only functions of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only functions of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, functions are displayed verbosely, with their actual parameter lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa2ebfeff5215f2bad04d9af2cdf2d89c158023" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">Перечисляет таблицы, представления и последовательности с соответствующими правами доступа. Если &lt;code&gt;pattern&lt;/code&gt; указан, только таблицы, представление и последовательность , чьи имена соответствуют шаблону перечислены.</target>
        </trans-unit>
        <trans-unit id="bb59616e451459bc316da05ad410acee2d59778b" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If a &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">Перечисляет таблицы, представления и последовательности с соответствующими правами доступа. Если &lt;code&gt;pattern&lt;/code&gt; указан, только таблицы, представление и последовательность , чьи имена соответствуют шаблону перечислены.</target>
        </trans-unit>
        <trans-unit id="ef7de3f6c539d5dd5da460845cd3a63bfcafc2bd" translate="yes" xml:space="preserve">
          <source>Lists tablespaces. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tablespaces whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each tablespace is listed with its associated options, on-disk size, permissions and description.</source>
          <target state="translated">Перечисляет табличные пространства. Если &lt;code&gt;pattern&lt;/code&gt; указан, только табличные , чьи имена соответствуют шаблону показаны. Если к имени команды добавлен &lt;code&gt;+&lt;/code&gt; , каждое табличное пространство перечисляется с соответствующими параметрами, размером на диске, разрешениями и описанием.</target>
        </trans-unit>
        <trans-unit id="762f36a63dc0b6ce665e3c2131b6edc15a3446da" translate="yes" xml:space="preserve">
          <source>Lists text search configurations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only configurations whose names match the pattern are shown. If the form &lt;code&gt;\dF+&lt;/code&gt; is used, a full description of each configuration is shown, including the underlying text search parser and the dictionary list for each parser token type.</source>
          <target state="translated">Перечисляет конфигурации текстового поиска. Если &lt;code&gt;pattern&lt;/code&gt; указан, только конфигурации, имена которых соответствуют шаблону показаны. Если используется форма &lt;code&gt;\dF+&lt;/code&gt; , отображается полное описание каждой конфигурации, включая базовый синтаксический анализатор текстового поиска и список словарей для каждого типа токена синтаксического анализатора.</target>
        </trans-unit>
        <trans-unit id="f6bb868ceb84c3b85646ce544e1a8e93f3c169f4" translate="yes" xml:space="preserve">
          <source>Lists text search dictionaries. If &lt;code&gt;pattern&lt;/code&gt; is specified, only dictionaries whose names match the pattern are shown. If the form &lt;code&gt;\dFd+&lt;/code&gt; is used, additional information is shown about each selected dictionary, including the underlying text search template and the option values.</source>
          <target state="translated">Список словарей текстового поиска. Если &lt;code&gt;pattern&lt;/code&gt; указывается только словари, имена которых соответствуют шаблону показаны. Если используется форма &lt;code&gt;\dFd+&lt;/code&gt; , отображается дополнительная информация о каждом выбранном словаре, включая базовый шаблон текстового поиска и значения параметров.</target>
        </trans-unit>
        <trans-unit id="ba01d174c5c6cab6bd3b44d816241b168a44d553" translate="yes" xml:space="preserve">
          <source>Lists text search parsers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only parsers whose names match the pattern are shown. If the form &lt;code&gt;\dFp+&lt;/code&gt; is used, a full description of each parser is shown, including the underlying functions and the list of recognized token types.</source>
          <target state="translated">Список парсеров текстового поиска. Если &lt;code&gt;pattern&lt;/code&gt; указан, только парсеры , чьи имена соответствуют шаблону показаны. Если используется форма &lt;code&gt;\dFp+&lt;/code&gt; полное описание каждого синтаксического анализатора, включая основные функции и список распознанных типов токенов.</target>
        </trans-unit>
        <trans-unit id="80703d2e971d1dc8cd3056fab4357086f4708060" translate="yes" xml:space="preserve">
          <source>Lists text search templates. If &lt;code&gt;pattern&lt;/code&gt; is specified, only templates whose names match the pattern are shown. If the form &lt;code&gt;\dFt+&lt;/code&gt; is used, additional information is shown about each template, including the underlying function names.</source>
          <target state="translated">Список шаблонов текстового поиска. Если &lt;code&gt;pattern&lt;/code&gt; указан только шаблоны, имена которых соответствуют шаблону показаны. Если используется форма &lt;code&gt;\dFt+&lt;/code&gt; , отображается дополнительная информация о каждом шаблоне, включая имена основных функций.</target>
        </trans-unit>
        <trans-unit id="1d9024892b5e72795e533219deec09ad897119d7" translate="yes" xml:space="preserve">
          <source>Lists the ancestor relations of the given partition, including the relation itself. Returns no rows if the relation does not exist or is not a partition or partitioned table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51bd1ab303ee9de03bdc15a672decf5bfa818c0" translate="yes" xml:space="preserve">
          <source>Lists the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78999412a6e9f781edbd7db90370d17b04826c4b" translate="yes" xml:space="preserve">
          <source>Lists the tables or indexes in the partition tree of the given partitioned table or partitioned index, with one row for each partition. Information provided includes the OID of the partition, the OID of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The level value is 0 for the input table or index, 1 for its immediate child partitions, 2 for their partitions, and so on. Returns no rows if the relation does not exist or is not a partition or partitioned table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a40588516c3a8604348670da0a879303a508a1" translate="yes" xml:space="preserve">
          <source>Lists type casts. If &lt;code&gt;pattern&lt;/code&gt; is specified, only casts whose source or target types match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">Перечисляет приведенные типы. Если &lt;code&gt;pattern&lt;/code&gt; указывается, отбрасывает только чей исходный или целевой типы соответствуют шаблону перечислены. Если к имени команды добавлен знак &amp;laquo; &lt;code&gt;+&lt;/code&gt; &amp;raquo; , каждый объект отображается вместе с соответствующим описанием.</target>
        </trans-unit>
        <trans-unit id="b23bce00d2c7c8d6375ab0cd2ad7f38f1f799075" translate="yes" xml:space="preserve">
          <source>Lists user mappings (mnemonic: &amp;ldquo;external users&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those mappings whose user names match the pattern are listed. If the form &lt;code&gt;\deu+&lt;/code&gt; is used, additional information about each mapping is shown.</source>
          <target state="translated">Перечисляет сопоставления пользователей (мнемоника: &amp;laquo;внешние пользователи&amp;raquo;). Если &lt;code&gt;pattern&lt;/code&gt; указан, только те отображения , чьи имена совпадают с пользователем шаблон перечислены. Если используется форма &lt;code&gt;\deu+&lt;/code&gt; , отображается дополнительная информация о каждом сопоставлении.</target>
        </trans-unit>
        <trans-unit id="fee8c64f75222b953355d11e92e46cafb863f042" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the function should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">Списки, которые преобразуют вызов функции, должны применяться. Преобразования конвертируют между типами SQL и типами данных, зависящими от языка; см. &lt;a href=&quot;sql-createtransform&quot;&gt;СОЗДАТЬ ТРАНСФОРМ&lt;/a&gt; . Реализации процедурного языка обычно имеют жестко заданные знания о встроенных типах, поэтому их не нужно здесь перечислять. Если реализация процедурного языка не знает, как обрабатывать тип и преобразование не предоставляется, она вернется к поведению по умолчанию для преобразования типов данных, но это зависит от реализации.</target>
        </trans-unit>
        <trans-unit id="c221c51fd4371df729302cc73086e8359e205a42" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the procedure should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">Списки, которые преобразуют вызов процедуры, должны применяться. Преобразования конвертируют между типами SQL и типами данных, зависящими от языка; см. &lt;a href=&quot;sql-createtransform&quot;&gt;СОЗДАТЬ ТРАНСФОРМ&lt;/a&gt; . Реализации процедурного языка обычно имеют жестко заданные знания о встроенных типах, поэтому их не нужно здесь перечислять. Если реализация процедурного языка не знает, как обрабатывать тип и преобразование не предоставляется, она вернется к поведению по умолчанию для преобразования типов данных, но это зависит от реализации.</target>
        </trans-unit>
        <trans-unit id="0c4bdf42add57a2eabb9fb37aeb6c28158bad4b3" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">Буквальный &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df214b5bbf763eb7922bad89d00442e94abbaf1f" translate="yes" xml:space="preserve">
          <source>Loading an extension essentially amounts to running the extension's script file. The script will typically create new SQL objects such as functions, data types, operators and index support methods. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; additionally records the identities of all the created objects, so that they can be dropped again if &lt;code&gt;DROP EXTENSION&lt;/code&gt; is issued.</source>
          <target state="translated">Загрузка расширения по сути сводится к запуску файла сценария расширения. Сценарий обычно создает новые объекты SQL, такие как функции, типы данных, операторы и методы поддержки индекса. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; дополнительно записывает идентификаторы всех созданных объектов, чтобы их можно было снова удалить, если выдается &lt;code&gt;DROP EXTENSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e93fcdb23625364e2abff318d75861520536fbf6" translate="yes" xml:space="preserve">
          <source>Loading an extension ordinarily requires the same privileges that would be required to create its component objects. For many extensions this means superuser privileges are needed. However, if the extension is marked &lt;em&gt;trusted&lt;/em&gt; in its control file, then it can be installed by any user who has &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database. In this case the extension object itself will be owned by the calling user, but the contained objects will be owned by the bootstrap superuser (unless the extension's script explicitly assigns them to the calling user). This configuration gives the calling user the right to drop the extension, but not to modify individual objects within it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324780c29ae9b46671035da5fbfcca3eeeaa0b74" translate="yes" xml:space="preserve">
          <source>Loading an extension requires the same privileges that would be required to create its component objects. For most extensions this means superuser or database owner privileges are needed. The user who runs &lt;code&gt;CREATE EXTENSION&lt;/code&gt; becomes the owner of the extension for purposes of later privilege checks, as well as the owner of any objects created by the extension's script.</source>
          <target state="translated">Для загрузки расширения требуются те же привилегии, которые потребуются для создания его объектов-компонентов. Для большинства расширений это означает, что необходимы привилегии суперпользователя или владельца базы данных. Пользователь, который запускает &lt;code&gt;CREATE EXTENSION&lt;/code&gt; , становится владельцем расширения для целей последующих проверок привилегий, а также владельцем любых объектов, созданных сценарием расширения.</target>
        </trans-unit>
        <trans-unit id="1ff55ba6c7cc873988ea156302dfd04284604724" translate="yes" xml:space="preserve">
          <source>Locale Support</source>
          <target state="translated">Местная поддержка</target>
        </trans-unit>
        <trans-unit id="1615ae9075efc2383f73fbc3997d85cdd39b60c0" translate="yes" xml:space="preserve">
          <source>Locale support is automatically initialized when a database cluster is created using &lt;code&gt;initdb&lt;/code&gt;. &lt;code&gt;initdb&lt;/code&gt; will initialize the database cluster with the locale setting of its execution environment by default, so if your system is already set to use the locale that you want in your database cluster then there is nothing else you need to do. If you want to use a different locale (or you are not sure which locale your system is set to), you can instruct &lt;code&gt;initdb&lt;/code&gt; exactly which locale to use by specifying the &lt;code&gt;--locale&lt;/code&gt; option. For example:</source>
          <target state="translated">Поддержка локали автоматически инициализируется при создании кластера базы данных с помощью &lt;code&gt;initdb&lt;/code&gt; . &lt;code&gt;initdb&lt;/code&gt; инициализирует кластер базы данных с настройкой языкового стандарта среды выполнения по умолчанию, поэтому, если ваша система уже настроена на использование языкового стандарта, который вы хотите использовать в кластере базы данных, вам больше ничего не нужно делать. Если вы хотите использовать другой языковой стандарт (или вы не уверены, какой языковой стандарт установлен в вашей системе), вы можете указать &lt;code&gt;initdb&lt;/code&gt; , какой именно языковой стандарт следует использовать, указав параметр &lt;code&gt;--locale&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b9fc941160f1b0396956bfd39853ec712bd8d1fb" translate="yes" xml:space="preserve">
          <source>Localization</source>
          <target state="translated">Localization</target>
        </trans-unit>
        <trans-unit id="405016b1820c348aea5cd317a6502812cdf4ad22" translate="yes" xml:space="preserve">
          <source>Location of root page (zero if none)</source>
          <target state="translated">Расположение корневой страницы (ноль,если нет)</target>
        </trans-unit>
        <trans-unit id="24d45a6df98cb6f2c1180b96048b79a73fa5f768" translate="yes" xml:space="preserve">
          <source>Location of specified substring</source>
          <target state="translated">Расположение указанной подстроки</target>
        </trans-unit>
        <trans-unit id="dbb39d513ae60400b7ebae4d62c9e5ac6f77044b" translate="yes" xml:space="preserve">
          <source>Location of specified substring (same as &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt;, but note the reversed argument order)</source>
          <target state="translated">Расположение указанной подстроки (то же, что и &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt; , но обратите внимание на обратный порядок аргументов)</target>
        </trans-unit>
        <trans-unit id="9c2e448b0989a5090dc489ea6de417d94cf811c0" translate="yes" xml:space="preserve">
          <source>LocationIndex</source>
          <target state="translated">LocationIndex</target>
        </trans-unit>
        <trans-unit id="891ebccd5baa32daed16fb5a0825ca7a4464931f" translate="yes" xml:space="preserve">
          <source>Lock</source>
          <target state="translated">Lock</target>
        </trans-unit>
        <trans-unit id="c804bf0349b9527944ec4a3fe74284d562dd49b7" translate="yes" xml:space="preserve">
          <source>Lock Management</source>
          <target state="translated">Управление замками</target>
        </trans-unit>
        <trans-unit id="9f5be0c66691f0334e7d2037502bfeef360b9c5d" translate="yes" xml:space="preserve">
          <source>Lock mode of lockers (more than one if multitransaction), an array of &lt;code&gt;Key Share&lt;/code&gt;, &lt;code&gt;Share&lt;/code&gt;, &lt;code&gt;For No Key Update&lt;/code&gt;, &lt;code&gt;No Key Update&lt;/code&gt;, &lt;code&gt;For Update&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;.</source>
          <target state="translated">Режим блокировки шкафчиков (более чем один , если multitransaction), массив &lt;code&gt;Key Share&lt;/code&gt; , &lt;code&gt;Share&lt;/code&gt; , &lt;code&gt;For No Key Update&lt;/code&gt; , &lt;code&gt;No Key Update&lt;/code&gt; , &lt;code&gt;For Update&lt;/code&gt; , &lt;code&gt;Update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9404601307758cbcb4a22750c03c625138fcfc8" translate="yes" xml:space="preserve">
          <source>Locking and Indexes</source>
          <target state="translated">Блокировка и индексы</target>
        </trans-unit>
        <trans-unit id="8804d3dd97270b8420c7ca1e904a01e8634cbbf1" translate="yes" xml:space="preserve">
          <source>Locking the regular and/or predicate lock manager could have some impact on database performance if this view is very frequently accessed. The locks are held only for the minimum amount of time necessary to obtain data from the lock managers, but this does not completely eliminate the possibility of a performance impact.</source>
          <target state="translated">Блокировка обычного и/или менеджер блокировки предикатов может иметь некоторое влияние на производительность базы данных,если к этому виду очень часто обращаются.Замки хранятся только в течение минимального времени,необходимого для получения данных от менеджеров замков,но это не полностью исключает возможность влияния на производительность.</target>
        </trans-unit>
        <trans-unit id="737c6c38b2b84007c82ea914cea8efb3178d5fdf" translate="yes" xml:space="preserve">
          <source>Log File Maintenance</source>
          <target state="translated">Обслуживание лог-файлов</target>
        </trans-unit>
        <trans-unit id="6d6b239b122bc0b05311eb6dfbfaaf45f232b9f3" translate="yes" xml:space="preserve">
          <source>Log Sequence Number, see &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;wal-internals&quot;&gt;WAL Internals&lt;/a&gt;.</source>
          <target state="translated">Порядковый номер журнала, см. &lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;wal-internals&quot;&gt;WAL Internals&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60c1e625e1e8d8bc204338911a42295c282dd7d9" translate="yes" xml:space="preserve">
          <source>Log file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0a509232d18cc09dfcbf97250e9485bbc40c4c" translate="yes" xml:space="preserve">
          <source>Log files contain human-readable text lines about events. Examples include login failures, long-running queries, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac059a4497d87893d31436f7f08f37f59c88514b" translate="yes" xml:space="preserve">
          <source>Log record</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d305d15801e1e955744206adafaf8f3e3d1bb78e" translate="yes" xml:space="preserve">
          <source>Log-Shipping Standby Servers</source>
          <target state="translated">Резервные серверы для отправки логов</target>
        </trans-unit>
        <trans-unit id="e22cd962d5d7b24a566d7837fcf6043185781e24" translate="yes" xml:space="preserve">
          <source>Logarithm of &lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt; to base &lt;em&gt;&lt;code&gt;b&lt;/code&gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567a04e87e0264325ea2d8341bf4b0ffb622ca3f" translate="yes" xml:space="preserve">
          <source>Logged</source>
          <target state="translated">Logged</target>
        </trans-unit>
        <trans-unit id="668f966ac31eb810f98d105493f1c5cdc3067858" translate="yes" xml:space="preserve">
          <source>Logger (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2445214b8389f14bf2045be1111d0264af049737" translate="yes" xml:space="preserve">
          <source>Logical Decoding</source>
          <target state="translated">Логическое декодирование</target>
        </trans-unit>
        <trans-unit id="e7e803ba6df9ebf5f542bc2b7ce91db2dc559f7e" translate="yes" xml:space="preserve">
          <source>Logical NOT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eac6118ebdd55aa38b41f70efdf532e567ffd8" translate="yes" xml:space="preserve">
          <source>Logical Operators</source>
          <target state="translated">Логические операторы</target>
        </trans-unit>
        <trans-unit id="e81affcc4578ce875d0e0b75ca689bf2f32a90ae" translate="yes" xml:space="preserve">
          <source>Logical Operators: AND</source>
          <target state="translated">Логические операторы:И</target>
        </trans-unit>
        <trans-unit id="43e083b90a70b3c47c8f0041d3ea2af4e65c51e3" translate="yes" xml:space="preserve">
          <source>Logical Operators: NOT</source>
          <target state="translated">Логические операторы:НЕ</target>
        </trans-unit>
        <trans-unit id="d639dd9302fac485c5ef253dceb1e3f97c540d72" translate="yes" xml:space="preserve">
          <source>Logical Operators: OR</source>
          <target state="translated">Логические операторы:ИЛИ</target>
        </trans-unit>
        <trans-unit id="87801dc1bcd5e1df0b7d1f2272c64ee5b039c930" translate="yes" xml:space="preserve">
          <source>Logical Repl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d8aa18dbe5d539b67385e1079b7cb40cef477e" translate="yes" xml:space="preserve">
          <source>Logical Replication</source>
          <target state="translated">Логическая репликация</target>
        </trans-unit>
        <trans-unit id="8922d517c58eafe0151a7cf981679470b4600e69" translate="yes" xml:space="preserve">
          <source>Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</source>
          <target state="translated">Логическое декодирование может использоваться для создания решений &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;синхронной репликации&lt;/a&gt; с тем же пользовательским интерфейсом, что и синхронная репликация для &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;потоковой репликации&lt;/a&gt; . Для этого необходимо использовать интерфейс потоковой репликации (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-walsender.html&quot;&gt;Раздел 48.3&lt;/a&gt; ) для потоковой передачи данных. Клиенты должны отправлять сообщения об &lt;code&gt;Standby status update (F)&lt;/code&gt; (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Раздел 52.4&lt;/a&gt; ), как это делают клиенты потоковой репликации.</target>
        </trans-unit>
        <trans-unit id="f503cf64b38f12bede3e30319a09deafda284c40" translate="yes" xml:space="preserve">
          <source>Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b10ab294a9b68fd1f46ed7bc6062a04492e6157" translate="yes" xml:space="preserve">
          <source>Logical group of the parameter</source>
          <target state="translated">Логическая группа параметра</target>
        </trans-unit>
        <trans-unit id="c580b15c66ecbba918b3e32fb395e268ced977ef" translate="yes" xml:space="preserve">
          <source>Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</source>
          <target state="translated">Логическая репликация позволяет серверу базы данных отправлять поток изменений данных на другой сервер. Логическая репликация PostgreSQL создает поток логических модификаций данных из WAL. Логическая репликация позволяет реплицировать изменения данных из отдельных таблиц. Для логической репликации не требуется, чтобы конкретный сервер был назначен главным или репликой, но данные могут передаваться в нескольких направлениях. Дополнительные сведения о логической репликации см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;главе 30&lt;/a&gt; . Через интерфейс логического декодирования ( &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;глава 48&lt;/a&gt; ) сторонние расширения также могут предоставлять аналогичные функции.</target>
        </trans-unit>
        <trans-unit id="efdfc15536907810b351505bdffe988864a38656" translate="yes" xml:space="preserve">
          <source>Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed65fe8b9917e90ed44964dea1e1dc23e674a9f1" translate="yes" xml:space="preserve">
          <source>Logical replication behaves similarly to normal DML operations in that the data will be updated even if it was changed locally on the subscriber node. If incoming data violates any constraints the replication will stop. This is referred to as a &lt;em&gt;conflict&lt;/em&gt;. When replicating &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations, missing data will not produce a conflict and such operations will simply be skipped.</source>
          <target state="translated">Логическая репликация ведет себя аналогично обычным операциям DML в том, что данные будут обновляться, даже если они были изменены локально на узле подписчика. Если входящие данные нарушают какие-либо ограничения, репликация останавливается. Это называется &lt;em&gt;конфликтом&lt;/em&gt; . При репликации операций &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; отсутствующие данные не вызовут конфликта, и такие операции будут просто пропущены.</target>
        </trans-unit>
        <trans-unit id="686d57c78ae4b376c0e25252dd6b05a5049c2f9c" translate="yes" xml:space="preserve">
          <source>Logical replication currently has the following restrictions or missing functionality. These might be addressed in future releases.</source>
          <target state="translated">Логическая репликация в настоящее время имеет следующие ограничения или недостающую функциональность.Они могут быть устранены в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="bc5341d79f09d707679a0da10e711069ef1d9d1a" translate="yes" xml:space="preserve">
          <source>Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</source>
          <target state="translated">Логическая репликация построена по архитектуре, аналогичной физической потоковой репликации (см. &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Раздел 26.2.5&lt;/a&gt; ). Это реализуется процессами &amp;laquo;walsender&amp;raquo; и &amp;laquo;apply&amp;raquo;. Процесс walsender запускает логическое декодирование (описанное в &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;главе 48&lt;/a&gt; ) WAL и загружает стандартный плагин логического декодирования (pgoutput). Плагин преобразует изменения, прочитанные из WAL, в протокол логической репликации (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-logical-replication.html&quot;&gt;Раздел 52.5&lt;/a&gt; ) и фильтрует данные в соответствии со спецификацией публикации. Затем данные непрерывно передаются с использованием протокола потоковой репликации исполнителю, который сопоставляет данные с локальными таблицами и применяет отдельные изменения по мере их получения в правильном транзакционном порядке.</target>
        </trans-unit>
        <trans-unit id="24f246c37056cfc3d645585b0f76929bd8ff75af" translate="yes" xml:space="preserve">
          <source>Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435079a68c735c2e34e8587daebbc03ec2b4108b" translate="yes" xml:space="preserve">
          <source>Logical replication requires several configuration options to be set.</source>
          <target state="translated">Логическая репликация требует установки нескольких опций конфигурации.</target>
        </trans-unit>
        <trans-unit id="e84a093ac80e997279a156ad3e78ff218f69bfc7" translate="yes" xml:space="preserve">
          <source>Logical replication starts by copying a snapshot of the data on the publisher database. Once that is done, changes on the publisher are sent to the subscriber as they occur in real time. The subscriber applies data in the order in which commits were made on the publisher so that transactional consistency is guaranteed for the publications within any single subscription.</source>
          <target state="translated">Логическая репликация начинается с копирования снимка данных в базу данных издателя.После этого изменения в базе данных издателя отправляются подписчику по мере их возникновения в режиме реального времени.Подписчик применяет данные в том порядке,в котором были сделаны фиксации на издателе,чтобы гарантировать согласованность транзакций для публикаций в рамках любой одной подписки.</target>
        </trans-unit>
        <trans-unit id="27b9470b0624c147b034592fe3f3a73182a2151c" translate="yes" xml:space="preserve">
          <source>Logical replication workers are taken from the pool defined by &lt;code&gt;max_worker_processes&lt;/code&gt;.</source>
          <target state="translated">Рабочие логической репликации берутся из пула, определенного параметром &lt;code&gt;max_worker_processes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a63c3a3aa22b3789bd62013d2f279dd236a57e8e" translate="yes" xml:space="preserve">
          <source>Londiste, Slony</source>
          <target state="translated">Лондист,Слони</target>
        </trans-unit>
        <trans-unit id="7ed5823bb2b8c30b7d42594563eaf3c04e339fc5" translate="yes" xml:space="preserve">
          <source>Look at &lt;code&gt;xsyn_sample.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt;, for an example.</source>
          <target state="translated">Посмотрите, например, на &lt;code&gt;xsyn_sample.rules&lt;/code&gt; , который установлен в &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca517b17b581321c398ee4798749fdb48a7ae7a7" translate="yes" xml:space="preserve">
          <source>Look at the new state of the data:</source>
          <target state="translated">Посмотрите на новое состояние данных:</target>
        </trans-unit>
        <trans-unit id="30d58e04409362da5a524652a2e000a29c4e8c15" translate="yes" xml:space="preserve">
          <source>Look for the best match.</source>
          <target state="translated">Ищите лучший матч.</target>
        </trans-unit>
        <trans-unit id="6a2e689d9886aec21b389565fdc3ad34371dc41e" translate="yes" xml:space="preserve">
          <source>Lookahead and lookbehind constraints cannot contain &lt;em&gt;back references&lt;/em&gt; (see &lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;Section 9.7.3.3&lt;/a&gt;), and all parentheses within them are considered non-capturing.</source>
          <target state="translated">Ограничения просмотра вперед и назад не могут содержать &lt;em&gt;обратных ссылок&lt;/em&gt; (см. &lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;Раздел 9.7.3.3&lt;/a&gt; ), и все круглые скобки в них считаются не захватывающими.</target>
        </trans-unit>
        <trans-unit id="5078c384be6b302db7193d0145acae3ffddd4617" translate="yes" xml:space="preserve">
          <source>Looks up a replication origin by name and returns the internal ID. If no such replication origin is found an error is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e8f3a9171c421d0883280c2cd97e28c0e45385" translate="yes" xml:space="preserve">
          <source>Lookup a replication origin by name and return the internal id. If no corresponding replication origin is found an error is thrown.</source>
          <target state="translated">Просмотрите происхождение репликации по имени и верните внутренний идентификатор.Если соответствующее происхождение репликации не найдено,то выдается ошибка.</target>
        </trans-unit>
        <trans-unit id="55e4cc0e110df2ac3459453907e4bd26c086ff4d" translate="yes" xml:space="preserve">
          <source>Lossiness causes performance degradation due to unnecessary fetches of table records that turn out to be false matches. Since random access to table records is slow, this limits the usefulness of GiST indexes. The likelihood of false matches depends on several factors, in particular the number of unique words, so using dictionaries to reduce this number is recommended.</source>
          <target state="translated">Потеря работоспособности приводит к снижению производительности за счет ненужных попыток извлечения записей из таблиц,которые оказываются ложными совпадениями.Поскольку случайный доступ к записям таблиц происходит медленно,это ограничивает полезность GiST-индексов.Вероятность ложных совпадений зависит от нескольких факторов,в частности от количества уникальных слов,поэтому рекомендуется использовать словари для уменьшения этого количества.</target>
        </trans-unit>
        <trans-unit id="1531c1daacaf1bc409855b8d1d0f55e08ee771dd" translate="yes" xml:space="preserve">
          <source>Low Value</source>
          <target state="translated">Низкая стоимость</target>
        </trans-unit>
        <trans-unit id="21ceb119d4d9e001890111b5576f7f16ef00c26f" translate="yes" xml:space="preserve">
          <source>Low level base backups can be made in a non-exclusive or an exclusive way. The non-exclusive method is recommended and the exclusive one is deprecated and will eventually be removed.</source>
          <target state="translated">Низкоуровневые базовые резервные копии могут быть сделаны неисключительным или эксклюзивным способом.Рекомендуется неисключительный метод,при этом эксклюзивный метод является устаревшим и в конечном итоге будет удален.</target>
        </trans-unit>
        <trans-unit id="bddc7c31834ef546bcfbe24e4c18d4afaf657eb8" translate="yes" xml:space="preserve">
          <source>Lowest transaction ID that was still active. All transaction IDs less than &lt;code&gt;xmin&lt;/code&gt; are either committed and visible, or rolled back and dead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="ac4243ecb01964253411eb3c09a126fc164e78e2" translate="yes" xml:space="preserve">
          <source>MAC (Media Access Control) address</source>
          <target state="translated">MAC (Media Access Control)адрес</target>
        </trans-unit>
        <trans-unit id="566c47d211683b88f50af170e2aa6203ef55b10a" translate="yes" xml:space="preserve">
          <source>MAC (Media Access Control) address (EUI-64 format)</source>
          <target state="translated">MAC (Media Access Control)адрес (формат EUI-64)</target>
        </trans-unit>
        <trans-unit id="b3c62ec9e889671f1211f3670d9feb61fe45a931" translate="yes" xml:space="preserve">
          <source>MAC addresses</source>
          <target state="translated">MAC-адреса</target>
        </trans-unit>
        <trans-unit id="22afa78dd9eba1a7e4c213c3623011af13b757a5" translate="yes" xml:space="preserve">
          <source>MAC addresses (EUI-64 format)</source>
          <target state="translated">MAC-адреса (формат EUI-64)</target>
        </trans-unit>
        <trans-unit id="1c27d6be2a8de3b4e76dde98311054d012ea27ef" translate="yes" xml:space="preserve">
          <source>MCV (most-common values) list statistics, serialized as &lt;code&gt;pg_mcv_list&lt;/code&gt; type</source>
          <target state="translated">Статистика списка MCV (наиболее распространенные значения), сериализованная как тип &lt;code&gt;pg_mcv_list&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b773bed04a48de200b96981bb79467413a222066" translate="yes" xml:space="preserve">
          <source>MD5</source>
          <target state="translated">MD5</target>
        </trans-unit>
        <trans-unit id="43a2b4962eca5b9cc86e8c34c251b4aaf74d69de" translate="yes" xml:space="preserve">
          <source>MD5 crypt</source>
          <target state="translated">гробница MD5</target>
        </trans-unit>
        <trans-unit id="b7800f24354ba47ad5de45633c8b73e60e95cf0f" translate="yes" xml:space="preserve">
          <source>MD5 hash and SHA1</source>
          <target state="translated">MD5 хэш и SHA1</target>
        </trans-unit>
        <trans-unit id="609399527c0412d282c04a9855b05c67f3f4ed44" translate="yes" xml:space="preserve">
          <source>MD5-based crypt</source>
          <target state="translated">склеп на основе MD5</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="ab3eeea11f18e2650760cfbc2a9ee637afed8340" translate="yes" xml:space="preserve">
          <source>MOVE &amp;mdash; position a cursor</source>
          <target state="translated">MOVE - установить курсор</target>
        </trans-unit>
        <trans-unit id="29f17acbc2455f9f492968fd0bda5a0de71679d9" translate="yes" xml:space="preserve">
          <source>MSVC</source>
          <target state="translated">MSVC</target>
        </trans-unit>
        <trans-unit id="a967eb92e41a009b9209426313752a674c43be15" translate="yes" xml:space="preserve">
          <source>MVCC</source>
          <target state="translated">MVCC</target>
        </trans-unit>
        <trans-unit id="f7f38fb90552f61a802690d695bfa4d9b25df00e" translate="yes" xml:space="preserve">
          <source>Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</source>
          <target state="translated">Ведение каталогов переводов сообщений требует постоянных усилий многих добровольцев, которые хотят, чтобы PostgreSQL хорошо говорил на их предпочитаемом языке. Если сообщения на вашем языке в настоящее время недоступны или переведены не полностью, мы будем благодарны за вашу помощь. Если вы хотите помочь, обратитесь к &lt;a href=&quot;https://www.postgresql.org/docs/12/nls.html&quot;&gt;главе 54&lt;/a&gt; или напишите в список рассылки разработчиков.</target>
        </trans-unit>
        <trans-unit id="7106741f20d440f998ee112429f77e03e33f6395" translate="yes" xml:space="preserve">
          <source>Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94de303bbef8935622224c5db48199c807ab7d71" translate="yes" xml:space="preserve">
          <source>Maintenance</source>
          <target state="translated">Maintenance</target>
        </trans-unit>
        <trans-unit id="dce34191f69ff984184a7501bc8f6215cc2b1283" translate="yes" xml:space="preserve">
          <source>Maintenance commands - &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;</source>
          <target state="translated">Команды обслуживания - &lt;code&gt;ANALYZE&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="292d556449f6baefbefbc7a2798464550e97b523" translate="yes" xml:space="preserve">
          <source>Maintenance commands: &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477597b3a5e3545e4aafdda2f2a69a40df682681" translate="yes" xml:space="preserve">
          <source>Major PostgreSQL releases regularly add new features that often change the layout of the system tables, but the internal data storage format rarely changes. pg_upgrade uses this fact to perform rapid upgrades by creating new system tables and simply reusing the old user data files. If a future major release ever changes the data storage format in a way that makes the old data format unreadable, pg_upgrade will not be usable for such upgrades. (The community will attempt to avoid such situations.)</source>
          <target state="translated">В основных релизах PostgreSQL регулярно добавляются новые функции,которые часто меняют компоновку системных таблиц,но внутренний формат хранения данных редко меняется.pg_upgrade использует этот факт для выполнения быстрого обновления путем создания новых системных таблиц и простого повторного использования старых пользовательских файлов данных.Если будущий основной выпуск когда-либо изменит формат хранения данных таким образом,что старый формат данных станет нечитаемым,pg_upgrade не будет использоваться для таких обновлений.(Сообщество постарается избежать таких ситуаций).</target>
        </trans-unit>
        <trans-unit id="634be9b233dfc40349e54f6799f11f557bdc5c75" translate="yes" xml:space="preserve">
          <source>Make a base backup of the primary server (see &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;), and load this data onto the standby.</source>
          <target state="translated">Сделайте базовую резервную копию первичного сервера (см. &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Раздел 25.3.2&lt;/a&gt; ) и загрузите эти данные на резервный.</target>
        </trans-unit>
        <trans-unit id="63a128e9fdffb0bd6c880f9009ba685205efe3c8" translate="yes" xml:space="preserve">
          <source>Make a password valid forever:</source>
          <target state="translated">Сделайте пароль действительным навсегда:</target>
        </trans-unit>
        <trans-unit id="3d352bc98e86554b9f8e7bb50ec4f35c4891b735" translate="yes" xml:space="preserve">
          <source>Make sure both database servers are stopped using, on Unix, e.g.:</source>
          <target state="translated">Убедитесь,что оба сервера баз данных остановлены,например,на Unix:</target>
        </trans-unit>
        <trans-unit id="b9eb7d5c96a8c5d308e0b19059ab781c2cbe473e" translate="yes" xml:space="preserve">
          <source>Make sure that your server keytab file is readable (and preferably only readable, not writable) by the PostgreSQL server account. (See also &lt;a href=&quot;postgres-user&quot;&gt;Section 18.1&lt;/a&gt;.) The location of the key file is specified by the &lt;a href=&quot;runtime-config-connection#GUC-KRB-SERVER-KEYFILE&quot;&gt;krb_server_keyfile&lt;/a&gt; configuration parameter. The default is &lt;code&gt;/usr/local/pgsql/etc/krb5.keytab&lt;/code&gt; (or whatever directory was specified as &lt;code&gt;sysconfdir&lt;/code&gt; at build time). For security reasons, it is recommended to use a separate keytab just for the PostgreSQL server rather than opening up permissions on the system keytab file.</source>
          <target state="translated">Убедитесь, что файл keytab вашего сервера доступен для чтения (и желательно только для чтения, но не для записи) учетной записью сервера PostgreSQL. (См. Также &lt;a href=&quot;postgres-user&quot;&gt;Раздел 18.1&lt;/a&gt; .) Местоположение ключевого файла определяется параметром конфигурации &lt;a href=&quot;runtime-config-connection#GUC-KRB-SERVER-KEYFILE&quot;&gt;krb_server_keyfile&lt;/a&gt; . По умолчанию это &lt;code&gt;/usr/local/pgsql/etc/krb5.keytab&lt;/code&gt; (или любой другой каталог, указанный как &lt;code&gt;sysconfdir&lt;/code&gt; во время сборки). По соображениям безопасности рекомендуется использовать отдельную вкладку ключей только для сервера PostgreSQL, а не открывать разрешения для системного файла таблицы ключей.</target>
        </trans-unit>
        <trans-unit id="c85ef738c1ba87c2190fc933e484d7ebb7fc1d3b" translate="yes" xml:space="preserve">
          <source>Make sure that your session does not hold more locks than necessary when calling &lt;code&gt;pg_sleep&lt;/code&gt; or its variants. Otherwise other sessions might have to wait for your sleeping process, slowing down the entire system.</source>
          <target state="translated">Убедитесь, что ваш сеанс не содержит больше блокировок, чем необходимо, при вызове &lt;code&gt;pg_sleep&lt;/code&gt; или его вариантов. В противном случае другим сеансам, возможно, придется дождаться вашего сна, что замедлит работу всей системы.</target>
        </trans-unit>
        <trans-unit id="d7b3ea8ab3afc4ab9fbece610d0afa1cdefe9215" translate="yes" xml:space="preserve">
          <source>Make sure the new binaries and support files are installed on all standby servers.</source>
          <target state="translated">Убедитесь,что новые исполняемые файлы и файлы поддержки установлены на всех резервных серверах.</target>
        </trans-unit>
        <trans-unit id="4be89cba4680b61369e645efc68f83ec81c167f1" translate="yes" xml:space="preserve">
          <source>Make sure the new standby data directories do &lt;em&gt;not&lt;/em&gt; exist or are empty. If initdb was run, delete the standby servers' new data directories.</source>
          <target state="translated">Убедитесь, что новые резервные каталоги данных &lt;em&gt;не&lt;/em&gt; существуют или пусты. Если была запущена initdb, удалите новые каталоги данных резервных серверов.</target>
        </trans-unit>
        <trans-unit id="173d02f923c11447cf74a27c2960de0e28e12c9b" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;initdb&lt;/code&gt; prompt for a password to give the database superuser. If you don't plan on using password authentication, this is not important. Otherwise you won't be able to use password authentication until you have a password set up.</source>
          <target state="translated">Заставляет &lt;code&gt;initdb&lt;/code&gt; запрашивать пароль для суперпользователя базы данных. Если вы не планируете использовать аутентификацию по паролю, это не важно. В противном случае вы не сможете использовать аутентификацию по паролю, пока не настроите пароль.</target>
        </trans-unit>
        <trans-unit id="792a9e540ae77e4ca51fdc9b34493d77aa427a96" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;initdb&lt;/code&gt; read the database superuser's password from a file. The first line of the file is taken as the password.</source>
          <target state="translated">Заставляет &lt;code&gt;initdb&lt;/code&gt; читать пароль суперпользователя базы данных из файла. В качестве пароля принимается первая строка файла.</target>
        </trans-unit>
        <trans-unit id="272e7aa108f37caed38de50c7bbbc12a4eeb39f5" translate="yes" xml:space="preserve">
          <source>Makes a cube with upper right and lower left coordinates as defined by the two arrays, which must be of the same length.</source>
          <target state="translated">Делает куб с правым верхним и левым нижним координатами,определенными двумя массивами,которые должны быть одинаковой длины.</target>
        </trans-unit>
        <trans-unit id="7896b684cd247a71e6d914ea864835f0a201cfd2" translate="yes" xml:space="preserve">
          <source>Makes a new cube by adding a dimension on to an existing cube, with the same values for both endpoints of the new coordinate. This is useful for building cubes piece by piece from calculated values.</source>
          <target state="translated">Создает новый куб,добавляя размерность к существующему кубу,с одинаковыми значениями для обеих конечных точек новой координаты.Это полезно при построении кубов по частям из вычисленных значений.</target>
        </trans-unit>
        <trans-unit id="43a84f11220bc7ec3aa6c412b1e43c3f1a62c52f" translate="yes" xml:space="preserve">
          <source>Makes a new cube by adding a dimension on to an existing cube. This is useful for building cubes piece by piece from calculated values.</source>
          <target state="translated">Делает новый куб,добавляя размер к существующему кубу.Это полезно для построения кубов по частям из вычисленных значений.</target>
        </trans-unit>
        <trans-unit id="cec244b05a82755211877f23eb89341a3e2a9049" translate="yes" xml:space="preserve">
          <source>Makes a new cube from an existing cube, using a list of dimension indexes from an array. Can be used to extract the endpoints of a single dimension, or to drop dimensions, or to reorder them as desired.</source>
          <target state="translated">Делает новый куб из существующего куба,используя список индексов измерений из массива.Может быть использован для извлечения конечных точек одного измерения,или для сброса размеров,или для их переупорядочивания по желанию.</target>
        </trans-unit>
        <trans-unit id="7c70237aa382dcfcb4e30da44d32fffb86de7855" translate="yes" xml:space="preserve">
          <source>Makes a one dimensional cube with both coordinates the same.</source>
          <target state="translated">Делает одномерный куб с обеими координатами одинаковыми.</target>
        </trans-unit>
        <trans-unit id="36186a49b5b2bc93a1e3ef40c1a52eabef758439" translate="yes" xml:space="preserve">
          <source>Makes a one dimensional cube.</source>
          <target state="translated">Делает одномерный куб.</target>
        </trans-unit>
        <trans-unit id="fa2638ba09b880989be4b7b3a19ea5c423840179" translate="yes" xml:space="preserve">
          <source>Makes a single-element array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae8d3b9540c85c4e0f867bbcd6f86be7f07d237" translate="yes" xml:space="preserve">
          <source>Makes a single-item &lt;code&gt;hstore&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c491ded092df3548669d7b1b5d203277eaee1f2e" translate="yes" xml:space="preserve">
          <source>Makes a zero-volume cube using the coordinates defined by the array.</source>
          <target state="translated">Делает куб нулевого объема,используя координаты,определенные массивом.</target>
        </trans-unit>
        <trans-unit id="fefd6a2a56f64d38ec0468fc161189ce50419761" translate="yes" xml:space="preserve">
          <source>Making liberal use of views is a key aspect of good SQL database design. Views allow you to encapsulate the details of the structure of your tables, which might change as your application evolves, behind consistent interfaces.</source>
          <target state="translated">Либеральное использование представлений является ключевым аспектом хорошего проектирования SQL баз данных.Представления позволяют инкапсулировать за последовательными интерфейсами детали структуры ваших таблиц,которые могут меняться по мере развития вашего приложения.</target>
        </trans-unit>
        <trans-unit id="f26b359ba37eb8a50cdf02456f39cff00b1155a4" translate="yes" xml:space="preserve">
          <source>Managing Databases</source>
          <target state="translated">Управление базами данных</target>
        </trans-unit>
        <trans-unit id="efd2c6be94610f9dd5980e65687b83de3d52e077" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources</source>
          <target state="translated">Управление ресурсами ядра</target>
        </trans-unit>
        <trans-unit id="9edd256f8994898f1394cd9f5902a2fe3a3418a1" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Linux Huge Pages</source>
          <target state="translated">Управление ресурсами Кернела:Огромные страницы Linux</target>
        </trans-unit>
        <trans-unit id="f84c08e43ab5092b16e87ebd218788d5283b9b4a" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Linux Memory Overcommit</source>
          <target state="translated">Управление ресурсами Кернела:Перерасход памяти Linux</target>
        </trans-unit>
        <trans-unit id="412c9a22726797c7f1da88a5ca11bb92ea162415" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Resource Limits</source>
          <target state="translated">Управление ресурсами Кернела:Ограничения по ресурсам</target>
        </trans-unit>
        <trans-unit id="fc3ccce80bea44ef80a6a994d4e4358186b901da" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Shared Memory and Semaphores</source>
          <target state="translated">Управление ресурсами Кернела:Общая память и семафоры</target>
        </trans-unit>
        <trans-unit id="67cd2bd0c8dc97a476e8e47ebb9371727475113d" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: systemd RemoveIPC</source>
          <target state="translated">Управление ресурсами ядра:systemd RemoveIPC</target>
        </trans-unit>
        <trans-unit id="67c48d67ef7ae304937a0a8de822ed104f4b2eb2" translate="yes" xml:space="preserve">
          <source>Manually set the WAL starting location by specifying the name of the next WAL segment file.</source>
          <target state="translated">Вручную установите начальное местоположение WAL,указав имя файла следующего сегмента WAL.</target>
        </trans-unit>
        <trans-unit id="6ccaa7bcfd25bcb3a947594b5b5ad3594bebb3be" translate="yes" xml:space="preserve">
          <source>Manually set the next OID.</source>
          <target state="translated">Вручную установите следующее OID.</target>
        </trans-unit>
        <trans-unit id="b11b4e5b2d203da27bc1c6504a10632af73bd3c8" translate="yes" xml:space="preserve">
          <source>Manually set the next and oldest multitransaction ID.</source>
          <target state="translated">Вручную установите следующий и самый старый идентификатор мультитранзакции.</target>
        </trans-unit>
        <trans-unit id="05fcb9c1e9b6c68d58ec688a6b55b68af75801bf" translate="yes" xml:space="preserve">
          <source>Manually set the next multitransaction offset.</source>
          <target state="translated">Вручную установите следующее смещение при многократном перемещении.</target>
        </trans-unit>
        <trans-unit id="14870c8a6c58f7f0c07765537e62008b75b3dc73" translate="yes" xml:space="preserve">
          <source>Manually set the next transaction ID's epoch.</source>
          <target state="translated">Вручную установите эпоху следующего идентификатора транзакции.</target>
        </trans-unit>
        <trans-unit id="4f4f1e99ced530ddd1fa0f7dac805a0ddcf54b22" translate="yes" xml:space="preserve">
          <source>Manually set the next transaction ID.</source>
          <target state="translated">Вручную установите следующий идентификатор транзакции.</target>
        </trans-unit>
        <trans-unit id="648bd7a8e83568d94a29f369df1e0064e881bb1c" translate="yes" xml:space="preserve">
          <source>Manually set the oldest and newest transaction IDs for which the commit time can be retrieved.</source>
          <target state="translated">Вручную установите самые старые и самые новые идентификаторы транзакций,для которых можно получить время фиксации.</target>
        </trans-unit>
        <trans-unit id="ff49c52c5651b25a87adf02de107946b0c6a1108" translate="yes" xml:space="preserve">
          <source>Manufacturers not currently having any products would not appear in the result, since it is an inner join. If we wished to include the names of such manufacturers in the result, we could do:</source>
          <target state="translated">Производители,у которых в настоящее время нет изделий,в результате не появятся,так как это внутреннее соединение.Если бы мы захотели включить в результат названия таких производителей,мы могли бы это сделать:</target>
        </trans-unit>
        <trans-unit id="5d400bc2fffdc5a10db82b688a6346e4cf189544" translate="yes" xml:space="preserve">
          <source>Many database systems have the notion of a one to many table. Such a table usually sits between two indexed tables, for example:</source>
          <target state="translated">Многие системы баз данных имеют понятие от одной до многих таблиц.Такая таблица обычно располагается,например,между двумя индексированными таблицами:</target>
        </trans-unit>
        <trans-unit id="95ffbad28eb7bf7f9a21d96e280ac0310171a900" translate="yes" xml:space="preserve">
          <source>Many developers consider explicitly listing the columns better style than relying on the order implicitly.</source>
          <target state="translated">Многие разработчики считают,что явное перечисление колонок лучше,чем неявная ссылка на порядок.</target>
        </trans-unit>
        <trans-unit id="1cb82d9eaa9bf285209fa61fc5831409cba350d7" translate="yes" xml:space="preserve">
          <source>Many failover systems use just two systems, the primary and the standby, connected by some kind of heartbeat mechanism to continually verify the connectivity between the two and the viability of the primary. It is also possible to use a third system (called a witness server) to prevent some cases of inappropriate failover, but the additional complexity might not be worthwhile unless it is set up with sufficient care and rigorous testing.</source>
          <target state="translated">Многие системы обхода отказа используют только две системы,первичную и дежурную,соединенные каким-то механизмом сердцебиения,чтобы постоянно проверять связь между ними и жизнеспособность первичной системы.Можно также использовать третью систему (называемую сервером свидетеля)для предотвращения некоторых случаев несоответствующего обхода отказа,но дополнительная сложность может оказаться нецелесообразной,если она не настроена с достаточной тщательностью и тщательным тестированием.</target>
        </trans-unit>
        <trans-unit id="de1e6960880fdbfac06a6878d8dd73d232d78b66" translate="yes" xml:space="preserve">
          <source>Many installations create their database clusters on file systems (volumes) other than the machine's &amp;ldquo;root&amp;rdquo; volume. If you choose to do this, it is not advisable to try to use the secondary volume's topmost directory (mount point) as the data directory. Best practice is to create a directory within the mount-point directory that is owned by the PostgreSQL user, and then create the data directory within that. This avoids permissions problems, particularly for operations such as pg_upgrade, and it also ensures clean failures if the secondary volume is taken offline.</source>
          <target state="translated">Многие установки создают свои кластеры баз данных в файловых системах (томах), отличных от &amp;laquo;корневого&amp;raquo; тома машины. Если вы решите это сделать, не рекомендуется пытаться использовать самый верхний каталог (точку монтирования) вторичного тома в качестве каталога данных. Лучше всего создать каталог в каталоге точки монтирования, который принадлежит пользователю PostgreSQL, а затем создать в нем каталог данных. Это позволяет избежать проблем с разрешениями, особенно для таких операций, как pg_upgrade, а также гарантирует чистые сбои, если вторичный том переводится в автономный режим.</target>
        </trans-unit>
        <trans-unit id="7998a6e83c9395997d176b8166f6ac50148a21ee" translate="yes" xml:space="preserve">
          <source>Many of the ARE extensions are borrowed from Perl, but some have been changed to clean them up, and a few Perl extensions are not present. Incompatibilities of note include &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;, the lack of special treatment for a trailing newline, the addition of complemented bracket expressions to the things affected by newline-sensitive matching, the restrictions on parentheses and back references in lookahead/lookbehind constraints, and the longest/shortest-match (rather than first-match) matching semantics.</source>
          <target state="translated">Многие расширения ARE заимствованы из Perl, но некоторые из них были изменены, чтобы очистить их, а некоторые расширения Perl отсутствуют. Примечания к несовместимости включают &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\B&lt;/code&gt; , отсутствие специальной обработки для завершающего символа новой строки, добавление выражений дополненных скобок к элементам, на которые влияет соответствие с учетом новой строки, ограничения на скобки и обратные ссылки в ограничениях просмотра вперед / назад и семантика сопоставления по самому длинному / кратчайшему (а не по первому совпадению).</target>
        </trans-unit>
        <trans-unit id="c2510bd4f5c7e075d877a23b92664b0d94264d01" translate="yes" xml:space="preserve">
          <source>Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt;. The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a non-UTF8 database encoding. In general, it is best to avoid mixing Unicode escapes in JSON with a non-UTF8 database encoding, if possible.</source>
          <target state="translated">Многие из функций обработки JSON, описанных в &lt;a href=&quot;functions-json&quot;&gt;Разделе 9.15&lt;/a&gt; , преобразуют escape-символы Unicode в обычные символы и, следовательно, будут выдавать те же типы ошибок, которые только что описаны, даже если их входные данные имеют тип &lt;code&gt;json&lt;/code&gt; ,а не &lt;code&gt;jsonb&lt;/code&gt; . Тот факт, что функция ввода &lt;code&gt;json&lt;/code&gt; не выполняет эти проверки, можно рассматривать как исторический артефакт, хотя он позволяет просто хранить (без обработки) escape-последовательности JSON Unicode в кодировке базы данных, отличной от UTF8. В общем, по возможности лучше избегать смешивания экранирования Unicode в JSON с кодировкой базы данных, отличной от UTF8.</target>
        </trans-unit>
        <trans-unit id="80b59991b11e3266fbd513366535241df81a8cf9" translate="yes" xml:space="preserve">
          <source>Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt;. The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a database encoding that does not support the represented characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ceba3684c41c44915004b6549907098b3d1192" translate="yes" xml:space="preserve">
          <source>Many of the above solutions allow multiple servers to handle multiple queries, but none allow a single query to use multiple servers to complete faster. This solution allows multiple servers to work concurrently on a single query. It is usually accomplished by splitting the data among servers and having each server execute its part of the query and return results to a central server where they are combined and returned to the user. Pgpool-II has this capability. Also, this can be implemented using the PL/Proxy tool set.</source>
          <target state="translated">Многие из вышеперечисленных решений позволяют нескольким серверам обрабатывать несколько запросов,но ни одно из них не позволяет одному запросу использовать несколько серверов для более быстрого завершения.Это решение позволяет нескольким серверам работать одновременно над одним запросом.Обычно это достигается путем разделения данных между серверами,когда каждый сервер выполняет свою часть запроса и возвращает результаты на центральный сервер,где они объединяются и возвращаются пользователю.Pgpool-II имеет такую возможность.Также,это может быть реализовано с помощью набора инструментов PL/Proxy.</target>
        </trans-unit>
        <trans-unit id="014eb2b75bf8a185a68dd7926fad4b4f2fb6f6a5" translate="yes" xml:space="preserve">
          <source>Many of the above solutions allow multiple servers to handle multiple queries, but none allow a single query to use multiple servers to complete faster. This solution allows multiple servers to work concurrently on a single query. It is usually accomplished by splitting the data among servers and having each server execute its part of the query and return results to a central server where they are combined and returned to the user. This can be implemented using the PL/Proxy tool set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686c93751e24bfbb5a5a8babbdffa0304da95e5d" translate="yes" xml:space="preserve">
          <source>Many of the meta-commands act on the &lt;em&gt;current query buffer&lt;/em&gt;. This is simply a buffer holding whatever SQL command text has been typed but not yet sent to the server for execution. This will include previous input lines as well as any text appearing before the meta-command on the same line.</source>
          <target state="translated">Многие мета-команды действуют на &lt;em&gt;текущий буфер запроса&lt;/em&gt; . Это просто буфер, содержащий любой текст команды SQL, который был набран, но еще не отправлен на сервер для выполнения. Это будет включать предыдущие строки ввода, а также любой текст, появляющийся перед метакомандой в той же строке.</target>
        </trans-unit>
        <trans-unit id="d0cfb05fe7e11967ff7a6d7fb5a62aee53e9651c" translate="yes" xml:space="preserve">
          <source>Many of these functions and operators will convert Unicode escapes in JSON strings to the appropriate single character. This is a non-issue if the input is type &lt;code&gt;jsonb&lt;/code&gt;, because the conversion was already done; but for &lt;code&gt;json&lt;/code&gt; input, this may result in throwing an error, as noted in &lt;a href=&quot;datatype-json&quot;&gt;Section 8.14&lt;/a&gt;.</source>
          <target state="translated">Многие из этих функций и операторов преобразуют escape-символы Unicode в строках JSON в соответствующий одиночный символ. Это не проблема, если &lt;code&gt;jsonb&lt;/code&gt; тип jsonb , потому что преобразование уже выполнено; но для ввода &lt;code&gt;json&lt;/code&gt; это может привести к ошибке, как указано в &lt;a href=&quot;datatype-json&quot;&gt;Разделе 8.14&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cd10805ee6287ed464e4a751e94e4711b1b75c0" translate="yes" xml:space="preserve">
          <source>Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</source>
          <target state="translated">Многие из этих функций имеют эквивалентные команды в протоколе репликации; см. &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Раздел 52.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9991bbe3c7f8082ad3aa4aa507145ca5c59d4fc" translate="yes" xml:space="preserve">
          <source>Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d54c9e108446dcc126d9b9edd300bc8f018b7c" translate="yes" xml:space="preserve">
          <source>Many of these operations are only sensible for one-dimensional arrays. Although they will accept input arrays of more dimensions, the data is treated as though it were a linear array in storage order.</source>
          <target state="translated">Многие из этих операций целесообразны только для одномерных массивов.Несмотря на то,что они принимают входные массивы большего размера,данные обрабатываются так,как будто это линейный массив в порядке хранения.</target>
        </trans-unit>
        <trans-unit id="747ffafd1658c72a0cfd879c2f486677fdad72db" translate="yes" xml:space="preserve">
          <source>Many people choose to use scripts to define their &lt;code&gt;archive_command&lt;/code&gt;, so that their &lt;code&gt;postgresql.conf&lt;/code&gt; entry looks very simple:</source>
          <target state="translated">Многие люди предпочитают использовать сценарии для определения своей команды &lt;code&gt;archive_command&lt;/code&gt; , поэтому запись в &lt;code&gt;postgresql.conf&lt;/code&gt; выглядит очень простой:</target>
        </trans-unit>
        <trans-unit id="871adaf8d8928b9b6cb8b32ef8db751f5c6cf9e4" translate="yes" xml:space="preserve">
          <source>Many programs produce strange and occasionally perverse CSV files, so the file format is more a convention than a standard. Thus you might encounter some files that cannot be imported using this mechanism, and &lt;code&gt;COPY&lt;/code&gt; might produce files that other programs cannot process.</source>
          <target state="translated">Многие программы создают странные и иногда искаженные файлы CSV, поэтому формат файла является скорее условным, чем стандартным. Таким образом, вы можете столкнуться с некоторыми файлами, которые нельзя импортировать с помощью этого механизма, и &lt;code&gt;COPY&lt;/code&gt; может создавать файлы, которые другие программы не могут обработать.</target>
        </trans-unit>
        <trans-unit id="c567b905d84b0a334ddbdf37ad683a15fc2dd4c4" translate="yes" xml:space="preserve">
          <source>Many routines are already defined within PostgreSQL itself, but user-defined ones can also be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aced3527162bd0f606c70ff2d552cd6071f17c5f" translate="yes" xml:space="preserve">
          <source>Many users consider it good practice to always list the column names.</source>
          <target state="translated">Многие пользователи считают хорошей практикой всегда перечислять названия столбцов.</target>
        </trans-unit>
        <trans-unit id="9e8ae0f81b2286e5d586c06978958263d9a26d81" translate="yes" xml:space="preserve">
          <source>Map different variations of a word to a canonical form using Snowball stemmer rules.</source>
          <target state="translated">С помощью правил Снежного кома сопоставьте различные вариации слова с канонической формой.</target>
        </trans-unit>
        <trans-unit id="8d7f24aaf39a33003cb1dd2dcc4e2ba52ecca563" translate="yes" xml:space="preserve">
          <source>Map different variations of a word to a canonical form using an Ispell dictionary.</source>
          <target state="translated">С помощью словаря заклинаний сопоставьте различные вариации слова с каноническим видом.</target>
        </trans-unit>
        <trans-unit id="7153d307c4a8dd126f6b081d2a4d9f2c3be33e38" translate="yes" xml:space="preserve">
          <source>Map phrases to a single word using a thesaurus.</source>
          <target state="translated">Фразы карты к одному слову с помощью тезауруса.</target>
        </trans-unit>
        <trans-unit id="9b24aee355a7838c5529c7490a65bac5367e010b" translate="yes" xml:space="preserve">
          <source>Map synonyms to a single word using Ispell.</source>
          <target state="translated">Карта синонимов одного слова,использующего заклинание.</target>
        </trans-unit>
        <trans-unit id="c4ba0822462e0c373aadd5360a69f205c2a7d036" translate="yes" xml:space="preserve">
          <source>Mar</source>
          <target state="translated">Mar</target>
        </trans-unit>
        <trans-unit id="433632ea5cd64cd163c3a390d5e531d33da3c5e5" translate="yes" xml:space="preserve">
          <source>March</source>
          <target state="translated">March</target>
        </trans-unit>
        <trans-unit id="531a1c0bf44a83aa6422d943626b2d77d47c5593" translate="yes" xml:space="preserve">
          <source>Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Марк Кирквуд &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b50963c78fd5ba0ee384ff4f9865fdb85cbddcd7" translate="yes" xml:space="preserve">
          <source>Mark a column as allowing, or not allowing, null values.</source>
          <target state="translated">Отметьте столбец как разрешающий или не разрешающий нулевые значения.</target>
        </trans-unit>
        <trans-unit id="45379fe0fd98739ca8b200f2546c07f11e0483e4" translate="yes" xml:space="preserve">
          <source>Mark current scan position. The access method need only support one remembered scan position per scan.</source>
          <target state="translated">Отметьте текущую позицию сканирования.Метод доступа должен поддерживать только одну запомненную позицию сканирования за сканирование.</target>
        </trans-unit>
        <trans-unit id="d89c04496b47c6c7add6d623e145d05e0e90beea" translate="yes" xml:space="preserve">
          <source>Mark the current session as replaying from the given origin, allowing replay progress to be tracked. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to revert. Can only be used if no previous origin is configured.</source>
          <target state="translated">Отметить текущий сеанс как воспроизведение из указанного источника, что позволяет отслеживать прогресс воспроизведения. Используйте &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; , чтобы вернуться. Может использоваться только в том случае, если не настроено предыдущее происхождение.</target>
        </trans-unit>
        <trans-unit id="3c353ba22d4916c50376ffc56136935d3788b393" translate="yes" xml:space="preserve">
          <source>Mark the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has previously been configured using &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt;.</source>
          <target state="translated">Отметьте текущую транзакцию как воспроизводящую транзакцию, зафиксированную с указанным LSN и временной меткой. Может быть вызван только в том случае, если источник репликации был предварительно настроен с помощью &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8026198ec726c859996827cb2a33d945433d7db7" translate="yes" xml:space="preserve">
          <source>Marko Kreen &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markokr@gmail.com&quot;&gt;markokr@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Марко Крин &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markokr@gmail.com&quot;&gt;markokr@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a8a93296bb3f7dbd2119f15415d0d529e99efc9" translate="yes" xml:space="preserve">
          <source>Marks the current session as replaying from the given origin, allowing replay progress to be tracked. Can only be used if no origin is currently selected. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to undo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f934292a8f9bb0e504a2267c5d57828e046b931" translate="yes" xml:space="preserve">
          <source>Marks the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has been selected using &lt;code&gt;pg_replication_origin_session_setup&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85793fe091f4b79ea4b1cbe55645a43cdb25119" translate="yes" xml:space="preserve">
          <source>Marks the publication as one that replicates changes for all tables in the database, including tables created in the future.</source>
          <target state="translated">Пометит публикацию как публикацию,которая воспроизводит изменения для всех таблиц в БД,включая таблицы,созданные в будущем.</target>
        </trans-unit>
        <trans-unit id="48783f4e8092ded2db7efb72ccd9468e6f9f40fe" translate="yes" xml:space="preserve">
          <source>Master (server)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbea724ab0ab5100a69e78a28b57720c1d6712f2" translate="yes" xml:space="preserve">
          <source>Master failure will never lose data</source>
          <target state="translated">Сбой мастера никогда не приведет к потере данных</target>
        </trans-unit>
        <trans-unit id="b17d5df13d0871fd4cf3c5923d856a866da06d96" translate="yes" xml:space="preserve">
          <source>Match the specified columns' values against the null string, even if it has been quoted, and if a match is found set the value to &lt;code&gt;NULL&lt;/code&gt;. In the default case where the null string is empty, this converts a quoted empty string into NULL. This option is allowed only in &lt;code&gt;COPY FROM&lt;/code&gt;, and only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">Сопоставьте значения указанных столбцов с пустой строкой, даже если она заключена в кавычки, и если совпадение найдено, установите значение &lt;code&gt;NULL&lt;/code&gt; . В случае по умолчанию, когда нулевая строка пуста, это преобразует пустую строку в кавычки в NULL. Эта опция разрешена только в режиме &lt;code&gt;COPY FROM&lt;/code&gt; и только при использовании формата &lt;code&gt;CSV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="53d751384b810e580b81b6af15ea342f4112abe1" translate="yes" xml:space="preserve">
          <source>Matches regular expression, case insensitive</source>
          <target state="translated">Совпадает с регулярным выражением,нечувствителен к регистру</target>
        </trans-unit>
        <trans-unit id="50df7b2381b68eae63b34b5f24c7004fae5bf76b" translate="yes" xml:space="preserve">
          <source>Matches regular expression, case sensitive</source>
          <target state="translated">Совпадает с регулярным выражением,чувствителен к регистру</target>
        </trans-unit>
        <trans-unit id="fccd01d6aebb595ebe777cc128bfd2f8fc6bb331" translate="yes" xml:space="preserve">
          <source>Materialized</source>
          <target state="translated">Materialized</target>
        </trans-unit>
        <trans-unit id="6c6539b1b3ecdc0ce5fd2e28965f4dde400d5218" translate="yes" xml:space="preserve">
          <source>Materialized view (relation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7844bff419f63af9d9cad339e25621693c32f323" translate="yes" xml:space="preserve">
          <source>Materialized view definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">Определение материализованного представления (реконструированный запрос &lt;code&gt;SELECT&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1636e8b4d786c74d148e1a7dc19345ad47a2c025" translate="yes" xml:space="preserve">
          <source>Mathematical operators are provided for many PostgreSQL types. For types without standard mathematical conventions (e.g., date/time types) we describe the actual behavior in subsequent sections.</source>
          <target state="translated">Математические операторы предусмотрены для многих типов PostgreSQL.Для типов без стандартных математических конвенций (например,типов дата/время)мы описываем фактическое поведение в последующих разделах.</target>
        </trans-unit>
        <trans-unit id="1001c24f338845a2ebfc01ab0741f854faa1aca1" translate="yes" xml:space="preserve">
          <source>Mathematical:  / 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d70e9435a7845b6f93f885d627357ee254fe09" translate="yes" xml:space="preserve">
          <source>Mathematical: !</source>
          <target state="translated">Математические:!</target>
        </trans-unit>
        <trans-unit id="fdaf7cc1ab57d2149690173f829e4f0c4dd36551" translate="yes" xml:space="preserve">
          <source>Mathematical: !!</source>
          <target state="translated">Математический:!!</target>
        </trans-unit>
        <trans-unit id="5e2823abc00a4631871d8a38e715d143884de402" translate="yes" xml:space="preserve">
          <source>Mathematical: !! 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5aaa56c60d256db29a89bc57b92703c0f7cb305" translate="yes" xml:space="preserve">
          <source>Mathematical: #</source>
          <target state="translated">Математический:#</target>
        </trans-unit>
        <trans-unit id="181ffc47f204d3f9ba3ff486f0f30c0c0ef1d5b9" translate="yes" xml:space="preserve">
          <source>Mathematical: %</source>
          <target state="translated">Математический:%</target>
        </trans-unit>
        <trans-unit id="ab7340ae469c4484dcc6f33a45b64f2dbe2c6ff3" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;amp;</source>
          <target state="translated">Математический: &amp;amp;</target>
        </trans-unit>
        <trans-unit id="c195fef9b5d30c42138e890a55d18aa8f3e74af3" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;gt;&amp;gt;</source>
          <target state="translated">Математический: &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="14a14395161c1fa4a496e90e3da92831d4e7dcdb" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;lt;&amp;lt;</source>
          <target state="translated">Математический: &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ddb29852cc33e3b226c0621b50ee13e25c0315f2" translate="yes" xml:space="preserve">
          <source>Mathematical: *</source>
          <target state="translated">Математический:*</target>
        </trans-unit>
        <trans-unit id="59ea67514b35bce8cb0c2fb98d96ab75e1042145" translate="yes" xml:space="preserve">
          <source>Mathematical: +</source>
          <target state="translated">Математический:+</target>
        </trans-unit>
        <trans-unit id="573654821f774c0055526f71d6224f85263be0a1" translate="yes" xml:space="preserve">
          <source>Mathematical: + 3.5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9634adf0f4c35060714ef3c74218c7741d96738c" translate="yes" xml:space="preserve">
          <source>Mathematical: -</source>
          <target state="translated">Математическое:-</target>
        </trans-unit>
        <trans-unit id="bc7be2afb633a5ef91761e59ad8b5a5f36c92a00" translate="yes" xml:space="preserve">
          <source>Mathematical: /</source>
          <target state="translated">Математический:/</target>
        </trans-unit>
        <trans-unit id="14509827aaea9ada84591d506dac7b95163f05fb" translate="yes" xml:space="preserve">
          <source>Mathematical: 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dcad53763c2d6ad82f715b19ab8fec7ddeae22b" translate="yes" xml:space="preserve">
          <source>Mathematical: 1 &amp;lt;&amp;lt; 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7f29cf58cb7d77da0870ecda08106919ba5797" translate="yes" xml:space="preserve">
          <source>Mathematical: 17 # 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba60cec6fd188d73cb4b2c6daf41d7e269b2755" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 * 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09b3f64871c9fa59aafabb2d8aac651ddf945f1" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 + 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a2737a7e89745b3ae76fb70bc9a67e72cce41a" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 - 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4ae222002ab6c8851226d9e26b9eb6997461fb" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 ^ 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1453f807f48dca3215386cb463d776ee41b48c5" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 ^ 3 ^ 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0910b16e152e2fe676e014eac4265186a97fa07e" translate="yes" xml:space="preserve">
          <source>Mathematical: 32 | 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7585f445437546f28802c19197028b4f366b5a52" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 !</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13db5517bdad3caace02ad3155beb1c731b5ca2" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 % 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a81ae0fa61623f6df83d0e9447d29d062d3a97" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 / 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f45fa3de4c530e7fd6305fbfcd48feef5d74a8" translate="yes" xml:space="preserve">
          <source>Mathematical: 5.0 / 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e8ff6a5010dabe71633aac622636270030f6a1" translate="yes" xml:space="preserve">
          <source>Mathematical: 8 &amp;gt;&amp;gt; 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1211cb8df037247151be58836d25635e55e30011" translate="yes" xml:space="preserve">
          <source>Mathematical: 91 &amp;amp; 15</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3196927fede8cfa3807fe6508ad4afd6a4dd5c10" translate="yes" xml:space="preserve">
          <source>Mathematical: @</source>
          <target state="translated">Математический:@</target>
        </trans-unit>
        <trans-unit id="ae31f2afe49c847bd7b50bc7534ffe77332ef912" translate="yes" xml:space="preserve">
          <source>Mathematical: @ -5.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dadfd5f33c390a7d584396b6077f56229e94a33" translate="yes" xml:space="preserve">
          <source>Mathematical: ^</source>
          <target state="translated">Математический:^</target>
        </trans-unit>
        <trans-unit id="20a199d0df7c3ce2a80fb78024a1d00c66d000a9" translate="yes" xml:space="preserve">
          <source>Mathematical: abs</source>
          <target state="translated">Математический:брюшной пресс</target>
        </trans-unit>
        <trans-unit id="df0e19fdb206e36a2205ad9d44520f7fee9d3470" translate="yes" xml:space="preserve">
          <source>Mathematical: acos</source>
          <target state="translated">Математический:акос</target>
        </trans-unit>
        <trans-unit id="f1cae65774f5f13f2e415042ed98b64f1dc67f0f" translate="yes" xml:space="preserve">
          <source>Mathematical: acosd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f713fa364b0d2333d09caea3c059cdf323feaaae" translate="yes" xml:space="preserve">
          <source>Mathematical: acosh</source>
          <target state="translated">Математический:акош</target>
        </trans-unit>
        <trans-unit id="15392ccce532b37463508b07d4825a05d6fb2837" translate="yes" xml:space="preserve">
          <source>Mathematical: asin</source>
          <target state="translated">Математический:асин</target>
        </trans-unit>
        <trans-unit id="4629299dfc93830669825b7184510d53113981f0" translate="yes" xml:space="preserve">
          <source>Mathematical: asind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe074bf9a455acf4922429fcb4f7cd46c3c843a" translate="yes" xml:space="preserve">
          <source>Mathematical: asinh</source>
          <target state="translated">Математический:асин</target>
        </trans-unit>
        <trans-unit id="83a2bb5d54e23969b5a04d6c088114146c9dc45d" translate="yes" xml:space="preserve">
          <source>Mathematical: atan</source>
          <target state="translated">Математический:атан</target>
        </trans-unit>
        <trans-unit id="c731e727bd85d0cc74cb9191f3962ed11a8f3b3b" translate="yes" xml:space="preserve">
          <source>Mathematical: atan2</source>
          <target state="translated">Математический:атан2</target>
        </trans-unit>
        <trans-unit id="5b918761ab75eba1fab60d1e4fd5336ac01d2bf8" translate="yes" xml:space="preserve">
          <source>Mathematical: atan2d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a929d56a5b59eb4bc6c164cae3d9675502095c0e" translate="yes" xml:space="preserve">
          <source>Mathematical: atand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583724a9264d7b0976ad47dcd14d4ac28456738f" translate="yes" xml:space="preserve">
          <source>Mathematical: atanh</source>
          <target state="translated">Математический:атан</target>
        </trans-unit>
        <trans-unit id="177cd0bc699b2203fdf2d4c75fe30163594d7b7e" translate="yes" xml:space="preserve">
          <source>Mathematical: cbrt</source>
          <target state="translated">Математический:cbrt</target>
        </trans-unit>
        <trans-unit id="2693815a9d6a69c69854809a47650e0275c1e989" translate="yes" xml:space="preserve">
          <source>Mathematical: ceil</source>
          <target state="translated">Математический:потолок</target>
        </trans-unit>
        <trans-unit id="d952c9a3323ba3a0a0aaeb01f24cc8dfd99821d9" translate="yes" xml:space="preserve">
          <source>Mathematical: ceiling</source>
          <target state="translated">Математический:потолок</target>
        </trans-unit>
        <trans-unit id="9db09acf97836fbc07512e622eb6635d3a02dc78" translate="yes" xml:space="preserve">
          <source>Mathematical: cos</source>
          <target state="translated">Математический:cos</target>
        </trans-unit>
        <trans-unit id="85e771e6ddf496ad7e9555f4d093d90654ec2a2a" translate="yes" xml:space="preserve">
          <source>Mathematical: cosd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9e7e216cc8b38acc3988effacc0b9c9f145f6e" translate="yes" xml:space="preserve">
          <source>Mathematical: cosh</source>
          <target state="translated">Математический:космос</target>
        </trans-unit>
        <trans-unit id="6bd28a5aa54b3401f41f88e5856f7384f5d30c00" translate="yes" xml:space="preserve">
          <source>Mathematical: cot</source>
          <target state="translated">Математический:раскладушка</target>
        </trans-unit>
        <trans-unit id="e063ca4c3718afe3730ed0658e8574f03540c88a" translate="yes" xml:space="preserve">
          <source>Mathematical: cotd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ccdbc8bc11a04cc3a6bf245df208da8e2cae56" translate="yes" xml:space="preserve">
          <source>Mathematical: degrees</source>
          <target state="translated">Математические:степени</target>
        </trans-unit>
        <trans-unit id="aca19fd89939c16cdb0569b07e58a53ad9349a7b" translate="yes" xml:space="preserve">
          <source>Mathematical: div</source>
          <target state="translated">Математический:div</target>
        </trans-unit>
        <trans-unit id="8af560e7bf42dc0411068f58a59ae9f72df77793" translate="yes" xml:space="preserve">
          <source>Mathematical: e</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e46d6487f521a5afb4ed4dd6a23a59fc059e6e5" translate="yes" xml:space="preserve">
          <source>Mathematical: exp</source>
          <target state="translated">Математическое:эксп</target>
        </trans-unit>
        <trans-unit id="5d515a5291a2aa6b90f086dc95105de6456c2b72" translate="yes" xml:space="preserve">
          <source>Mathematical: factorial</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="573fe26c7738f0584a8c6cbc5489e02fe641fddb" translate="yes" xml:space="preserve">
          <source>Mathematical: floor</source>
          <target state="translated">Математический:пол</target>
        </trans-unit>
        <trans-unit id="0875b243f27c954dcb0311da83af45540779329c" translate="yes" xml:space="preserve">
          <source>Mathematical: gcd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585a4c28147c569040ed981c6a2b550fc5404fd3" translate="yes" xml:space="preserve">
          <source>Mathematical: lcm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402d0cd4fdb985e3812799945b9fceb07540a0b6" translate="yes" xml:space="preserve">
          <source>Mathematical: ln</source>
          <target state="translated">Математический:ln</target>
        </trans-unit>
        <trans-unit id="85d8f0757c4bc05932d8f5d5e562c9da71c34f89" translate="yes" xml:space="preserve">
          <source>Mathematical: log</source>
          <target state="translated">Математический:журнал</target>
        </trans-unit>
        <trans-unit id="c83ba153e80e1ad83154d81618c218abe75464e9" translate="yes" xml:space="preserve">
          <source>Mathematical: log10</source>
          <target state="translated">Математический:log10</target>
        </trans-unit>
        <trans-unit id="b72fa934be334bbd661a4dd4724fb9f4f43c1c9b" translate="yes" xml:space="preserve">
          <source>Mathematical: min_scale</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342c1a68d26670cf3f8565a0897aa5cb7ba34b4e" translate="yes" xml:space="preserve">
          <source>Mathematical: mod</source>
          <target state="translated">Математический:мод</target>
        </trans-unit>
        <trans-unit id="1c34dfef32b83a1764b863b4bbe019d5862c9c11" translate="yes" xml:space="preserve">
          <source>Mathematical: pi</source>
          <target state="translated">Математический:пи</target>
        </trans-unit>
        <trans-unit id="886814dcb54a703998bbc0cf8f2f8499a7b62fa5" translate="yes" xml:space="preserve">
          <source>Mathematical: power</source>
          <target state="translated">Математический:власть</target>
        </trans-unit>
        <trans-unit id="256f270ce3f202545798a4267069da319d55bdce" translate="yes" xml:space="preserve">
          <source>Mathematical: radians</source>
          <target state="translated">Математический:радиан</target>
        </trans-unit>
        <trans-unit id="fa28188b7b4ce61e7fd1e57eb3d3850d1782d895" translate="yes" xml:space="preserve">
          <source>Mathematical: random</source>
          <target state="translated">Математический:случайный</target>
        </trans-unit>
        <trans-unit id="38618634f79b9464f7b75f0213cc7c4516883f3f" translate="yes" xml:space="preserve">
          <source>Mathematical: round</source>
          <target state="translated">Математический:круглый</target>
        </trans-unit>
        <trans-unit id="d57a36e95bfa64f5eb46d773fdde749c2cb84fc4" translate="yes" xml:space="preserve">
          <source>Mathematical: scale</source>
          <target state="translated">Математический:шкала</target>
        </trans-unit>
        <trans-unit id="bf096078393c2c98a0b1e6c717f74e687f878163" translate="yes" xml:space="preserve">
          <source>Mathematical: setseed</source>
          <target state="translated">Математический:сетид</target>
        </trans-unit>
        <trans-unit id="39f4ee6bf2c1ebbb6d092ca5116d3c60ea228290" translate="yes" xml:space="preserve">
          <source>Mathematical: sign</source>
          <target state="translated">Математический:знак</target>
        </trans-unit>
        <trans-unit id="21776ac559594087e48aa9a00b1065f77ca338fd" translate="yes" xml:space="preserve">
          <source>Mathematical: sin</source>
          <target state="translated">Математический:грех</target>
        </trans-unit>
        <trans-unit id="e9237291333d54a9e72bd4303ce991cb654f9866" translate="yes" xml:space="preserve">
          <source>Mathematical: sind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e2992e6f676f0cd18285a72f0c1e9d55b0d240" translate="yes" xml:space="preserve">
          <source>Mathematical: sinh</source>
          <target state="translated">Математический:синх</target>
        </trans-unit>
        <trans-unit id="aae7a6e9b70d02f4e993a9db74c8db3083ef0bfc" translate="yes" xml:space="preserve">
          <source>Mathematical: sqrt</source>
          <target state="translated">Математический:квадрат</target>
        </trans-unit>
        <trans-unit id="02a3ee3cf42cf2113efd88c1ad458433f9a69197" translate="yes" xml:space="preserve">
          <source>Mathematical: tan</source>
          <target state="translated">Математический:загар</target>
        </trans-unit>
        <trans-unit id="a12d29e8482347b79de73aeb0357bed2e637f2fc" translate="yes" xml:space="preserve">
          <source>Mathematical: tand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ac9c6f98336e23241f94c577f53cb99b066801" translate="yes" xml:space="preserve">
          <source>Mathematical: tanh</source>
          <target state="translated">Математический:танх</target>
        </trans-unit>
        <trans-unit id="4cead06e1e3ecd61366e9c73534c51a69696eb50" translate="yes" xml:space="preserve">
          <source>Mathematical: trim_scale</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd05d42d41de6870056e68c4ccd289ca842197c7" translate="yes" xml:space="preserve">
          <source>Mathematical: trunc</source>
          <target state="translated">Математический:усечение</target>
        </trans-unit>
        <trans-unit id="b3fcfe03e83f0fd3f41685d5a0a35fa941c16d42" translate="yes" xml:space="preserve">
          <source>Mathematical: width_bucket</source>
          <target state="translated">Математический:width_bucket</target>
        </trans-unit>
        <trans-unit id="102ae47fccbd9d1f7766efee6bfebf34706bb020" translate="yes" xml:space="preserve">
          <source>Mathematical: width_bucket, array::timestamptz)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa1e770f800f341e62dbc76cea5befa40e67f50" translate="yes" xml:space="preserve">
          <source>Mathematical: |</source>
          <target state="translated">Математический:|</target>
        </trans-unit>
        <trans-unit id="b18f08aa2ba95d26e5185b6a71ed15ce174e5b8f" translate="yes" xml:space="preserve">
          <source>Mathematical: |/</source>
          <target state="translated">Математический:|/</target>
        </trans-unit>
        <trans-unit id="b1d8eaf643a6e6b2e7be95b78f55ac71c3eeed5c" translate="yes" xml:space="preserve">
          <source>Mathematical: |/ 25.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e150fa17498f246e415139012baeb22d8f4d4a" translate="yes" xml:space="preserve">
          <source>Mathematical: ||/</source>
          <target state="translated">Математический:||/</target>
        </trans-unit>
        <trans-unit id="6da4178d25c27664a5aeecdd5149efed87a71eaa" translate="yes" xml:space="preserve">
          <source>Mathematical: ||/ 64.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eacd2f34aae3951141d12b3b8bacb1b57ee7e7b" translate="yes" xml:space="preserve">
          <source>Mathematical: ~</source>
          <target state="translated">Математический:~</target>
        </trans-unit>
        <trans-unit id="28cbee48973403ffe3820780daffa38b195ca4b1" translate="yes" xml:space="preserve">
          <source>Mathematical: ~1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95e85aed56318093b024674e217cae0bd30241d" translate="yes" xml:space="preserve">
          <source>Max</source>
          <target state="translated">Max</target>
        </trans-unit>
        <trans-unit id="eebfdb589d2a38f34e9a5e134f62af1ef891433d" translate="yes" xml:space="preserve">
          <source>Max Password Length</source>
          <target state="translated">Максимальная длина пароля</target>
        </trans-unit>
        <trans-unit id="462156397b99eeccfdb0f5b4ea63ec4407a809bc" translate="yes" xml:space="preserve">
          <source>Maximum allowed value of the parameter (null for non-numeric values)</source>
          <target state="translated">Максимально допустимое значение параметра (нулевое для нечисловых значений)</target>
        </trans-unit>
        <trans-unit id="f4c49a25b4f19cb0213949aa3e28ef3557be3a93" translate="yes" xml:space="preserve">
          <source>Maximum amount of time allowed to complete client authentication. If a would-be client has not completed the authentication protocol in this much time, the server closes the connection. This prevents hung clients from occupying a connection indefinitely. If this value is specified without units, it is taken as seconds. The default is one minute (&lt;code&gt;1m&lt;/code&gt;). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Максимальное время, разрешенное для завершения аутентификации клиента. Если потенциальный клиент не завершил протокол аутентификации за это время, сервер закрывает соединение. Это препятствует тому, чтобы зависшие клиенты занимали соединение бесконечно. Если это значение указано без единиц измерения, оно принимается в секундах. По умолчанию - одна минута ( &lt;code&gt;1m&lt;/code&gt; ). Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="16d4343ca4b0ff10b386fabaeb90ec48c83feb93" translate="yes" xml:space="preserve">
          <source>Maximum depth to descend to, or zero for unlimited depth</source>
          <target state="translated">Максимальная глубина для спуска до или ноль для неограниченной глубины</target>
        </trans-unit>
        <trans-unit id="6e382e12a5004b51a9fb6db4c19fb4ad8b8e10a3" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphore identifiers (i.e., sets)</source>
          <target state="translated">Максимальное количество семафорных идентификаторов (т.е.наборов)</target>
        </trans-unit>
        <trans-unit id="0c59e3da96b0612eb2065c185976ccb89f3be9d6" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphores per set</source>
          <target state="translated">Максимальное количество семафоров в наборе</target>
        </trans-unit>
        <trans-unit id="352ff6e41f28fb4dd9615ad5c6b893bc2f0820a2" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphores system-wide</source>
          <target state="translated">Максимальное количество семафоров в системе</target>
        </trans-unit>
        <trans-unit id="c815c1aa92e98505761f17e71fb912e2b0d50481" translate="yes" xml:space="preserve">
          <source>Maximum number of shared memory segments per process</source>
          <target state="translated">Максимальное количество сегментов общей памяти на процесс</target>
        </trans-unit>
        <trans-unit id="f5eb5768d25d1069e687fbff6c4cdff705aae7ad" translate="yes" xml:space="preserve">
          <source>Maximum number of shared memory segments system-wide</source>
          <target state="translated">Максимальное количество сегментов общей памяти в масштабе всей системы</target>
        </trans-unit>
        <trans-unit id="e4a5cf08c55be90a96549a51c4d65339bafeb337" translate="yes" xml:space="preserve">
          <source>Maximum number of synchronization workers per subscription. This parameter controls the amount of parallelism of the initial data copy during the subscription initialization or when new tables are added.</source>
          <target state="translated">Максимальное количество работников синхронизации за подписку.Данный параметр контролирует количество параллелизма исходной копии данных при инициализации подписки или при добавлении новых таблиц.</target>
        </trans-unit>
        <trans-unit id="cf9da86e68e4a7c2a1bc302b1edbdee46483b5d4" translate="yes" xml:space="preserve">
          <source>Maximum size of shared memory segment (bytes)</source>
          <target state="translated">Максимальный размер разделяемого сегмента памяти (байт)</target>
        </trans-unit>
        <trans-unit id="3bc5354a68835f6648f33d79497a82c72e86de3c" translate="yes" xml:space="preserve">
          <source>Maximum size to let the WAL grow during automatic checkpoints. This is a soft limit; WAL size can exceed &lt;code&gt;max_wal_size&lt;/code&gt; under special circumstances, such as heavy load, a failing &lt;code&gt;archive_command&lt;/code&gt;, or a high &lt;code&gt;wal_keep_size&lt;/code&gt; setting. If this value is specified without units, it is taken as megabytes. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78433a672e983d650938d0f8874ea0c01c8e279" translate="yes" xml:space="preserve">
          <source>Maximum size to let the WAL grow to between automatic WAL checkpoints. This is a soft limit; WAL size can exceed &lt;code&gt;max_wal_size&lt;/code&gt; under special circumstances, such as heavy load, a failing &lt;code&gt;archive_command&lt;/code&gt;, or a high &lt;code&gt;wal_keep_segments&lt;/code&gt; setting. If this value is specified without units, it is taken as megabytes. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Максимальный размер, до которого WAL может увеличиваться между автоматическими контрольными точками WAL. Это мягкий предел; Размер WAL может превышать &lt;code&gt;max_wal_size&lt;/code&gt; при особых обстоятельствах, таких как большая нагрузка, сбой &lt;code&gt;archive_command&lt;/code&gt; или высокий параметр &lt;code&gt;wal_keep_segments&lt;/code&gt; . Если это значение указано без единиц измерения, оно принимается в мегабайтах. По умолчанию - 1 ГБ. Увеличение этого параметра может увеличить время, необходимое для восстановления после сбоя. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="a6663cd5d04ec15d3d8cb068011883bb72c21769" translate="yes" xml:space="preserve">
          <source>Maximum time between automatic WAL checkpoints. If this value is specified without units, it is taken as seconds. The valid range is between 30 seconds and one day. The default is five minutes (&lt;code&gt;5min&lt;/code&gt;). Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Максимальное время между автоматическими контрольными точками WAL. Если это значение указано без единиц измерения, оно принимается в секундах. Допустимый диапазон - от 30 секунд до одного дня. По умолчанию - пять минут ( &lt;code&gt;5min&lt;/code&gt; минут ). Увеличение этого параметра может увеличить время, необходимое для восстановления после сбоя. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="a6f1ed8f82cbd62e299f9090b927f2f26026550f" translate="yes" xml:space="preserve">
          <source>Maximum time spent executing the statement, in milliseconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4455b92ac909b4c5503624f3e50369ecbf4e7112" translate="yes" xml:space="preserve">
          <source>Maximum time spent in the statement, in milliseconds</source>
          <target state="translated">Максимальное время,проведенное в выписке,в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="80cb793c865edc2335fb8eab0406dd5a5723c352" translate="yes" xml:space="preserve">
          <source>Maximum time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e356bc07e535e04e9d9c3334c083fcc3488e0bee" translate="yes" xml:space="preserve">
          <source>Maximum value of semaphore</source>
          <target state="translated">Максимальное значение семафора</target>
        </trans-unit>
        <trans-unit id="d73ff195380431a5bbd14d7218270378e35474ca" translate="yes" xml:space="preserve">
          <source>Maximum value of the sequence</source>
          <target state="translated">Максимальное значение последовательности</target>
        </trans-unit>
        <trans-unit id="c94f479833c5d401cffdfa7afe6c9c2d56448019" translate="yes" xml:space="preserve">
          <source>May</source>
          <target state="translated">May</target>
        </trans-unit>
        <trans-unit id="9a0ffa2f24694ff69c95e89a55aa229e9cda8b30" translate="yes" xml:space="preserve">
          <source>Mean time spent executing the statement, in milliseconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181d211e960e06792dfe28bfac1abd601a4c5a9d" translate="yes" xml:space="preserve">
          <source>Mean time spent in the statement, in milliseconds</source>
          <target state="translated">Время,проведенное в отчете,в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="e1349b1d8078a8f519127952739b8b28f7e70925" translate="yes" xml:space="preserve">
          <source>Mean time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="f0f833c6521b2d19b94ba8d0789e74dc9ccb5388" translate="yes" xml:space="preserve">
          <source>Measuring Executor Timing Overhead</source>
          <target state="translated">Надбавка на время измерения исполнителя</target>
        </trans-unit>
        <trans-unit id="1c83efb5aa232017e707b79cbf793fdfcf4c42d0" translate="yes" xml:space="preserve">
          <source>Member accessor that returns an object member with the specified key. If the key name is a named variable starting with &lt;code&gt;$&lt;/code&gt; or does not meet the JavaScript rules of an identifier, it must be enclosed in double quotes as a character string literal.</source>
          <target state="translated">Метод доступа к члену, который возвращает член объекта с указанным ключом. Если имя ключа представляет собой именованную переменную, начинающуюся с символа &lt;code&gt;$&lt;/code&gt; , или не соответствует правилам JavaScript для идентификатора, оно должно быть заключено в двойные кавычки как литерал символьной строки.</target>
        </trans-unit>
        <trans-unit id="016eb9bcfce0ff8bda70ffdf100d2c6f5e38a6fe" translate="yes" xml:space="preserve">
          <source>Member accessor that returns an object member with the specified key. If the key name matches some named variable starting with &lt;code&gt;$&lt;/code&gt; or does not meet the JavaScript rules for an identifier, it must be enclosed in double quotes to make it a string literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3e8f88c1e4c9777ada8c4e159672ef60421a6a" translate="yes" xml:space="preserve">
          <source>Merge join requires its input data to be sorted on the join keys. In this plan the &lt;code&gt;tenk1&lt;/code&gt; data is sorted by using an index scan to visit the rows in the correct order, but a sequential scan and sort is preferred for &lt;code&gt;onek&lt;/code&gt;, because there are many more rows to be visited in that table. (Sequential-scan-and-sort frequently beats an index scan for sorting many rows, because of the nonsequential disk access required by the index scan.)</source>
          <target state="translated">Соединение слиянием требует, чтобы его входные данные были отсортированы по ключам соединения. В этом плане данные &lt;code&gt;tenk1&lt;/code&gt; сортируются с использованием сканирования индекса для посещения строк в правильном порядке, но для &lt;code&gt;onek&lt;/code&gt; предпочтительнее последовательное сканирование и сортировка , поскольку в этой таблице есть намного больше строк, которые нужно посетить. (Последовательное сканирование и сортировка часто превосходит сканирование индекса при сортировке большого количества строк из-за непоследовательного доступа к диску, необходимого для сканирования индекса.)</target>
        </trans-unit>
        <trans-unit id="5df467aa951005c5f7e89731194b036d002c4227" translate="yes" xml:space="preserve">
          <source>Merge joins also have measurement artifacts that can confuse the unwary. A merge join will stop reading one input if it's exhausted the other input and the next key value in the one input is greater than the last key value of the other input; in such a case there can be no more matches and so no need to scan the rest of the first input. This results in not reading all of one child, with results like those mentioned for &lt;code&gt;LIMIT&lt;/code&gt;. Also, if the outer (first) child contains rows with duplicate key values, the inner (second) child is backed up and rescanned for the portion of its rows matching that key value. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; counts these repeated emissions of the same inner rows as if they were real additional rows. When there are many outer duplicates, the reported actual row count for the inner child plan node can be significantly larger than the number of rows that are actually in the inner relation.</source>
          <target state="translated">Объединения слиянием также имеют артефакты измерения, которые могут сбить с толку неосторожных. Соединение слиянием прекратит чтение одного ввода, если оно исчерпало другой ввод, и следующее значение ключа в одном вводе больше, чем последнее значение ключа другого ввода; в таком случае совпадений больше не может быть, и поэтому нет необходимости сканировать оставшуюся часть первого ввода. Это приводит к тому, что не читается весь один дочерний элемент, с результатами, подобными упомянутым для &lt;code&gt;LIMIT&lt;/code&gt; . Кроме того, если внешний (первый) дочерний элемент содержит строки с повторяющимися значениями ключа, внутренний (второй) дочерний элемент создается резервной копии и повторно проверяется для части его строк, соответствующей этому значению ключа. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; считает эти повторные выбросы одних и тех же внутренних строк, как если бы они были реальными дополнительными строками. Когда имеется много внешних дубликатов, сообщаемое фактическое количество строк для внутреннего дочернего узла плана может быть значительно больше, чем количество строк, которые фактически находятся во внутренней связи.</target>
        </trans-unit>
        <trans-unit id="7a6317b9601e7c09c328490aa43dfe87e04fe54d" translate="yes" xml:space="preserve">
          <source>Messages like this indicate that you contacted the server, and it is willing to talk to you, but not until you pass the authorization method specified in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file. Check the password you are providing, or check your Kerberos or ident software if the complaint mentions one of those authentication types.</source>
          <target state="translated">Подобные сообщения указывают на то, что вы связались с сервером, и он готов поговорить с вами, но не раньше, чем вы передадите метод авторизации, указанный в &lt;code&gt;pg_hba.conf&lt;/code&gt; . Проверьте пароль, который вы вводите, или проверьте свое программное обеспечение Kerberos или identity, если в жалобе упоминается один из этих типов аутентификации.</target>
        </trans-unit>
        <trans-unit id="9c2097f911138f2466e5f32e8351dcd5fd749692" translate="yes" xml:space="preserve">
          <source>Meta-Commands</source>
          <target state="translated">Meta-Commands</target>
        </trans-unit>
        <trans-unit id="f693f5960d30f7053e205f6d9a4425df858962e1" translate="yes" xml:space="preserve">
          <source>Metaphone, like Soundex, is based on the idea of constructing a representative code for an input string. Two strings are then deemed similar if they have the same codes.</source>
          <target state="translated">Метафон,как и Soundex,основан на идее построения представительного кода для входной строки.Затем две строки считаются похожими,если они имеют одинаковые коды.</target>
        </trans-unit>
        <trans-unit id="e1c1b37b805340abcc2257db6a661352b683548e" translate="yes" xml:space="preserve">
          <source>Method used for forcing WAL updates out to disk. If &lt;code&gt;fsync&lt;/code&gt; is off then this setting is irrelevant, since WAL file updates will not be forced out at all. Possible values are:</source>
          <target state="translated">Метод, используемый для принудительной загрузки обновлений WAL на диск. Если &lt;code&gt;fsync&lt;/code&gt; выключен, этот параметр не имеет значения, поскольку обновления файла WAL не будут принудительно выполняться. Возможные значения:</target>
        </trans-unit>
        <trans-unit id="628dc441c2bafa1afab14e359fb44c6e901b8f85" translate="yes" xml:space="preserve">
          <source>Michael J. Fromberger</source>
          <target state="translated">Майкл Дж.Фромбергер</target>
        </trans-unit>
        <trans-unit id="06fca8ee037d3a593497ab6d139577328dd86787" translate="yes" xml:space="preserve">
          <source>Microsoft Visual C</source>
          <target state="translated">Microsoft Visual C</target>
        </trans-unit>
        <trans-unit id="f0e91d657447be038c5b83745dffb09499d6baf9" translate="yes" xml:space="preserve">
          <source>Military abbreviation for UTC</source>
          <target state="translated">Военная аббревиатура для UTC</target>
        </trans-unit>
        <trans-unit id="7eb0cee888ab55b559592d38eec027e9118d7d35" translate="yes" xml:space="preserve">
          <source>Min</source>
          <target state="translated">Min</target>
        </trans-unit>
        <trans-unit id="0d47fa8c3e389b0763d87f2daa4ec6a50fb18dc1" translate="yes" xml:space="preserve">
          <source>Minimum allowed value of the parameter (null for non-numeric values)</source>
          <target state="translated">Минимально допустимое значение параметра (нулевое для нечисловых значений)</target>
        </trans-unit>
        <trans-unit id="c5ae78e276525910ef27ff7ddf6b5c2559e2cb00" translate="yes" xml:space="preserve">
          <source>Minimum number of concurrent open transactions to require before performing the &lt;code&gt;commit_delay&lt;/code&gt; delay. A larger value makes it more probable that at least one other transaction will become ready to commit during the delay interval. The default is five transactions.</source>
          <target state="translated">Минимальное количество одновременных открытых транзакций, которое требуется до выполнения задержки &lt;code&gt;commit_delay&lt;/code&gt; . Чем больше значение, тем выше вероятность того, что хотя бы еще одна транзакция станет готовой к фиксации в течение интервала задержки. По умолчанию - пять транзакций.</target>
        </trans-unit>
        <trans-unit id="0fb2ca68f01f33cc64d2c1311c2afe2326caa75d" translate="yes" xml:space="preserve">
          <source>Minimum scale (number of fractional decimal digits) needed to represent the supplied value precisely</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c373999e365b4d5993611993a45677502343dcde" translate="yes" xml:space="preserve">
          <source>Minimum size of shared memory segment (bytes)</source>
          <target state="translated">Минимальный размер сегмента общей памяти (байт)</target>
        </trans-unit>
        <trans-unit id="78afeaf9c6ff0f3ee6d2c5532d4ad21e157dee73" translate="yes" xml:space="preserve">
          <source>Minimum time spent executing the statement, in milliseconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613154c6477db737a4ffc935d45b4f35e3a112f3" translate="yes" xml:space="preserve">
          <source>Minimum time spent in the statement, in milliseconds</source>
          <target state="translated">Минимальное время,проведенное в отчете,в миллисекундах.</target>
        </trans-unit>
        <trans-unit id="f3052f7c6782d78980f79d735a2525db3585b208" translate="yes" xml:space="preserve">
          <source>Minimum time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9119800734f587e7d9508436d6ce2f949b6a319c" translate="yes" xml:space="preserve">
          <source>Minimum value of the sequence</source>
          <target state="translated">Минимальное значение последовательности</target>
        </trans-unit>
        <trans-unit id="f39b9975fa394daf9211460e65ad5e53c2e0737a" translate="yes" xml:space="preserve">
          <source>Minor releases never change the internal storage format and are always compatible with earlier and later minor releases of the same major version number. For example, version 10.1 is compatible with version 10.0 and version 10.6. Similarly, for example, 9.5.3 is compatible with 9.5.0, 9.5.1, and 9.5.6. To update between compatible versions, you simply replace the executables while the server is down and restart the server. The data directory remains unchanged &amp;mdash; minor upgrades are that simple.</source>
          <target state="translated">Второстепенные выпуски никогда не изменяют формат внутреннего хранилища и всегда совместимы с более ранними и более поздними второстепенными выпусками того же основного номера версии. Например, версия 10.1 совместима с версией 10.0 и версией 10.6. Точно так же, например, 9.5.3 совместима с 9.5.0, 9.5.1 и 9.5.6. Чтобы выполнить обновление между совместимыми версиями, вы просто заменяете исполняемые файлы, пока сервер не работает, и перезапускаете сервер. Каталог данных остается неизменным - мелкие обновления настолько просты.</target>
        </trans-unit>
        <trans-unit id="c1792a6389bbff158897922be21e2febd6b41e73" translate="yes" xml:space="preserve">
          <source>Minor updates to this package were made by Bruno Wolff III &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:bruno@wolff.to&quot;&gt;bruno@wolff.to&lt;/a&gt;&amp;gt;&lt;/code&gt; in August/September of 2002. These include changing the precision from single precision to double precision and adding some new functions.</source>
          <target state="translated">Незначительные обновления этого пакета были сделаны Бруно Вольфом III &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:bruno@wolff.to&quot;&gt;bruno@wolff.to&lt;/a&gt;&amp;gt;&lt;/code&gt; в августе / сентябре 2002 года. Они включают изменение точности с одинарной точности на двойную точность и добавление некоторых новых функций.</target>
        </trans-unit>
        <trans-unit id="026961d2894207df681418954ca48774a983ec15" translate="yes" xml:space="preserve">
          <source>Minus operator that iterates over the SQL/JSON sequence</source>
          <target state="translated">Оператор минус,выполняющий итерацию над последовательностью SQL/JSON</target>
        </trans-unit>
        <trans-unit id="dc6ddd468d33fb3431787f38241bee7260f00eb6" translate="yes" xml:space="preserve">
          <source>Minutes (in the time part)</source>
          <target state="translated">Минуты (в части времени)</target>
        </trans-unit>
        <trans-unit id="dc12f1b1cf6a0bbb2272d3d7ce2040c69a7ecda0" translate="yes" xml:space="preserve">
          <source>Mixed Interval</source>
          <target state="translated">Смешанный интервал</target>
        </trans-unit>
        <trans-unit id="70c257e1738553c63bcb8eca3e2dc0f60349ef49" translate="yes" xml:space="preserve">
          <source>Mixing temporary and permanent relations in the same partition tree is not allowed. Hence, if the partitioned table is permanent, so must be its partitions and likewise if the partitioned table is temporary. When using temporary relations, all members of the partition tree have to be from the same session.</source>
          <target state="translated">Смешивание временных и постоянных отношений в одном и том же дереве разделов не допускается.Следовательно,если таблица простенков является постоянной,то это должны быть и ее простенки,а также если таблица простенков является временной.При использовании временных отношений все члены дерева простенков должны быть из одного сеанса.</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="b543d8b0cd27fd8c88c5dd290fcb9193a6d18588" translate="yes" xml:space="preserve">
          <source>Modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FMMonth&lt;/code&gt; is the &lt;code&gt;Month&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;Table 9.26&lt;/a&gt; shows the modifier patterns for date/time formatting.</source>
          <target state="translated">К любому шаблону шаблона можно применить модификаторы, чтобы изменить его поведение. Например, &lt;code&gt;FMMonth&lt;/code&gt; - это шаблон &lt;code&gt;Month&lt;/code&gt; с модификатором &lt;code&gt;FM&lt;/code&gt; . &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;В таблице 9.26&lt;/a&gt; показаны шаблоны модификаторов для форматирования даты / времени.</target>
        </trans-unit>
        <trans-unit id="aa8e787d356e5a4bed4106486ef340d55a04bda6" translate="yes" xml:space="preserve">
          <source>Modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FMMonth&lt;/code&gt; is the &lt;code&gt;Month&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;Table 9.27&lt;/a&gt; shows the modifier patterns for date/time formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca58f6edfb3451890686c36bc73c14bf67559162" translate="yes" xml:space="preserve">
          <source>Modify an existing record using the values from an &lt;code&gt;hstore&lt;/code&gt;:</source>
          <target state="translated">Измените существующую запись, используя значения из &lt;code&gt;hstore&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f15aa8ca874492770383bfd8d9e19998f3752e1" translate="yes" xml:space="preserve">
          <source>Modifying Tables</source>
          <target state="translated">Модифицирующие таблицы</target>
        </trans-unit>
        <trans-unit id="a72464d357e833dd19b1829bd5b00731edf82afe" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Adding a Column</source>
          <target state="translated">Модифицирующие таблицы:Добавление колонны</target>
        </trans-unit>
        <trans-unit id="b0a82b15be32cf23af7a5403931cbba2c3a6b302" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Adding a Constraint</source>
          <target state="translated">Модифицирующие таблицы:Добавление ограничения</target>
        </trans-unit>
        <trans-unit id="8c76fff9cefc32ac15f30b5883253ecb9faf24b5" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Changing a Column&amp;#x27;s Data Type</source>
          <target state="translated">Изменение таблиц: изменение типа данных столбца</target>
        </trans-unit>
        <trans-unit id="bad9bdb3a7e14e2048b20553d6893b9f2daeb0f9" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Changing a Column&amp;#x27;s Default Value</source>
          <target state="translated">Изменение таблиц: изменение значения столбца по умолчанию</target>
        </trans-unit>
        <trans-unit id="8649a9592e4298a7e8e6b1abb9ef2b90d9a5be2a" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Removing a Column</source>
          <target state="translated">Модифицирующие таблицы:Удаление колонны</target>
        </trans-unit>
        <trans-unit id="98650a2f5b97076e75384a35883a830ea83870d0" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Removing a Constraint</source>
          <target state="translated">Модифицирующие таблицы:Удаление ограничений</target>
        </trans-unit>
        <trans-unit id="6ee7fe42d54596a2449882ee5313efaaa712af34" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Renaming a Column</source>
          <target state="translated">Модифицирующие таблицы:Переименование колонны</target>
        </trans-unit>
        <trans-unit id="dc81484063645f8a58302e10322fd29ad17f1b92" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Renaming a Table</source>
          <target state="translated">Модифицирующие таблицы:Переименование таблицы</target>
        </trans-unit>
        <trans-unit id="c1e625a012d4612de9e088d7c2a093342964bb1f" translate="yes" xml:space="preserve">
          <source>Modifying a partitioned table or a table with inheritance children fires statement-level triggers attached to the explicitly named table, but not statement-level triggers for its partitions or child tables. In contrast, row-level triggers are fired on the rows in affected partitions or child tables, even if they are not explicitly named in the query. If a statement-level trigger has been defined with transition relations named by a &lt;code&gt;REFERENCING&lt;/code&gt; clause, then before and after images of rows are visible from all affected partitions or child tables. In the case of inheritance children, the row images include only columns that are present in the table that the trigger is attached to. Currently, row-level triggers with transition relations cannot be defined on partitions or inheritance child tables.</source>
          <target state="translated">Изменение секционированной таблицы или таблицы с наследованием дочерних элементов запускает триггеры уровня операторов, прикрепленные к явно названной таблице, но не триггеры уровня операторов для ее разделов или дочерних таблиц. Напротив, триггеры на уровне строк срабатывают для строк в затронутых секциях или дочерних таблицах, даже если они явно не названы в запросе. Если триггер на уровне оператора был определен с отношениями перехода, названными предложением &lt;code&gt;REFERENCING&lt;/code&gt; , то изображения строк до и после него видны из всех затронутых секций или дочерних таблиц. В случае наследования дочерних элементов изображения строк включают только столбцы, которые присутствуют в таблице, к которой привязан триггер. В настоящее время триггеры на уровне строк с отношениями перехода не могут быть определены в дочерних таблицах разделов или наследования.</target>
        </trans-unit>
        <trans-unit id="5a03c6c23d3b223671b9d8eba84851fccb59e4a7" translate="yes" xml:space="preserve">
          <source>Module for storing (key, value) pairs</source>
          <target state="translated">Модуль для хранения (ключа,значения)пар</target>
        </trans-unit>
        <trans-unit id="8f46472981bee7fae7b3d41646aaa681175d3eb8" translate="yes" xml:space="preserve">
          <source>Modulo (remainder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0216fd9c439582b27771fa19ad3c81fdf577f4c0" translate="yes" xml:space="preserve">
          <source>Modulo (remainder); available for &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a0f28806f53fd75308c3f2a793267cf1428ae8" translate="yes" xml:space="preserve">
          <source>Modulus</source>
          <target state="translated">Modulus</target>
        </trans-unit>
        <trans-unit id="24b2a0993d0cfa93c44282d6bba72bcf58b300d6" translate="yes" xml:space="preserve">
          <source>Mon</source>
          <target state="translated">Mon</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="6463498da98840aa3b093c82890614171c30b5ef" translate="yes" xml:space="preserve">
          <source>Monetary Types</source>
          <target state="translated">Денежные виды</target>
        </trans-unit>
        <trans-unit id="881c22df54316f0107467a0277ce497e98935f6d" translate="yes" xml:space="preserve">
          <source>Monetary Types: money</source>
          <target state="translated">Денежные виды:деньги</target>
        </trans-unit>
        <trans-unit id="a81434589757e654444719de434c44e9adc0c708" translate="yes" xml:space="preserve">
          <source>Monitoring</source>
          <target state="translated">Monitoring</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="ca09870a2f60b20cbbb11a8f1bfa5c112c7f2481" translate="yes" xml:space="preserve">
          <source>Months (in the date part)</source>
          <target state="translated">Месяцы (в части даты)</target>
        </trans-unit>
        <trans-unit id="b362fae8ba4022e7ee2c51f663135e4f46fe57f1" translate="yes" xml:space="preserve">
          <source>More about &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;dropdb&lt;/code&gt; can be found in &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; and &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; respectively.</source>
          <target state="translated">Подробнее о &lt;code&gt;createdb&lt;/code&gt; и &lt;code&gt;dropdb&lt;/code&gt; можно найти в &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; и &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="7d8a150db9b3697af1b840b6b8689717b67bec26" translate="yes" xml:space="preserve">
          <source>More complex grouping operations than those described above are possible using the concept of &lt;em&gt;grouping sets&lt;/em&gt;. The data selected by the &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses is grouped separately by each specified grouping set, aggregates computed for each group just as for simple &lt;code&gt;GROUP BY&lt;/code&gt; clauses, and then the results returned. For example:</source>
          <target state="translated">Более сложные операции группирования, чем описанные выше, возможны с использованием концепции &lt;em&gt;наборов группировок&lt;/em&gt; . Данные, выбранные с помощью предложений &lt;code&gt;FROM&lt;/code&gt; и &lt;code&gt;WHERE&lt;/code&gt; , группируются отдельно по каждому указанному набору группировок, агрегаты вычисляются для каждой группы так же, как для простых предложений &lt;code&gt;GROUP BY&lt;/code&gt; , а затем возвращаются результаты. Например:</target>
        </trans-unit>
        <trans-unit id="32d9dc5690a3f6016671ea3b2ef25dc790df4069" translate="yes" xml:space="preserve">
          <source>More complex usage can produce undesirable results in Read Committed mode. For example, consider a &lt;code&gt;DELETE&lt;/code&gt; command operating on data that is being both added and removed from its restriction criteria by another command, e.g., assume &lt;code&gt;website&lt;/code&gt; is a two-row table with &lt;code&gt;website.hits&lt;/code&gt; equaling &lt;code&gt;9&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;:</source>
          <target state="translated">Более сложное использование может привести к нежелательным результатам в режиме Read Committed. Например, рассмотрим команду &lt;code&gt;DELETE&lt;/code&gt; , работающую с данными, которые одновременно добавляются и удаляются из критериев ограничения другой командой, например, предположим, что &lt;code&gt;website&lt;/code&gt; представляет собой таблицу с двумя строками, в которой &lt;code&gt;website.hits&lt;/code&gt; равно &lt;code&gt;9&lt;/code&gt; и &lt;code&gt;10&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aa123892162b2a296320ac735b855a11c0d07673" translate="yes" xml:space="preserve">
          <source>More details about window functions can be found in &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;, &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;, and the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; reference page.</source>
          <target state="translated">Более подробную информацию о оконных функциях можно найти в &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Разделе 4.2.8&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;Разделе 9.21&lt;/a&gt; , &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Разделе 7.2.5&lt;/a&gt; и на справочной странице &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61e5e0cc940bc717e85dc5f00f1f583f6b05a316" translate="yes" xml:space="preserve">
          <source>More details about window functions can be found in &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt;, &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;, and the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; reference page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf3214eaae892986b24caa3a28e76373d96aaab" translate="yes" xml:space="preserve">
          <source>More examples of using &lt;code&gt;jsonpath&lt;/code&gt; operators and methods within path expressions appear below in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.16.2.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b706c980fab74ceb0b82c89e1d0e57333d172c3f" translate="yes" xml:space="preserve">
          <source>More examples, including suitable input and output functions, are in &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html&quot;&gt;Section 37.13&lt;/a&gt;.</source>
          <target state="translated">Дополнительные примеры, включая подходящие функции ввода и вывода, находятся в &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html&quot;&gt;Разделе 37.13&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2b364915a6606c0ca2495dd2cb97f36c000aeda" translate="yes" xml:space="preserve">
          <source>More examples, including suitable input and output functions, are in &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html&quot;&gt;Section 37.13&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
