<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="e1a2d424d05fad0ce8a503aad44ed8e2890ec86d" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about accesses to that specific table. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-TABLES-VIEW&quot;&gt;pg_stat_all_tables&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка для каждой таблицы в текущей базе данных, показывающая статистику доступа к этой конкретной таблице. См. &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-TABLES-VIEW&quot;&gt;Pg_stat_all_tables&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="abc0444614ec30e98f25afeab84f356db8f57c5c" translate="yes" xml:space="preserve">
          <source>One row for each tracked function, showing statistics about executions of that function. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;&lt;code&gt;pg_stat_user_functions&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4f1c454b46b07db5b5caff74a33b9a88d14f14" translate="yes" xml:space="preserve">
          <source>One row for each tracked function, showing statistics about executions of that function. See &lt;a href=&quot;monitoring-stats#PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;pg_stat_user_functions&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка для каждой отслеживаемой функции, показывающая статистику выполнения этой функции. Подробнее см. &lt;a href=&quot;monitoring-stats#PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;Pg_stat_user_functions&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f68f712788d8659f6dc744778895e8637cccb9" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the WAL archiver process's activity. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ARCHIVER-VIEW&quot;&gt;&lt;code&gt;pg_stat_archiver&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a27e9764cf42abc447770a40b26ae4110256df1" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the WAL archiver process's activity. See &lt;a href=&quot;monitoring-stats#PG-STAT-ARCHIVER-VIEW&quot;&gt;pg_stat_archiver&lt;/a&gt; for details.</source>
          <target state="translated">Только одна строка, показывающая статистику активности процесса архиватора WAL. Подробности см. В &lt;a href=&quot;monitoring-stats#PG-STAT-ARCHIVER-VIEW&quot;&gt;pg_stat_archiver&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7159edec345b30dd16d1cfb1cd64291c8e94cf0f" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the background writer process's activity. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-BGWRITER-VIEW&quot;&gt;&lt;code&gt;pg_stat_bgwriter&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ff69da529511355514d8fad09917a768f3dfee" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the background writer process's activity. See &lt;a href=&quot;monitoring-stats#PG-STAT-BGWRITER-VIEW&quot;&gt;pg_stat_bgwriter&lt;/a&gt; for details.</source>
          <target state="translated">Только одна строка, показывающая статистику активности фонового процесса записи. Подробности см. В &lt;a href=&quot;monitoring-stats#PG-STAT-BGWRITER-VIEW&quot;&gt;pg_stat_bgwriter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60bbed9973e1e54e8a987346455e2156c0d06574" translate="yes" xml:space="preserve">
          <source>One row per SLRU, showing statistics of operations. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SLRU-VIEW&quot;&gt;&lt;code&gt;pg_stat_slru&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246692679d62f964e577891f2766cf44cbec4578" translate="yes" xml:space="preserve">
          <source>One row per WAL sender process, showing statistics about replication to that sender's connected standby server. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41761c4e3d769b5a97047d2af3c904ca9b99e019" translate="yes" xml:space="preserve">
          <source>One row per WAL sender process, showing statistics about replication to that sender's connected standby server. See &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка на процесс отправителя WAL, показывающая статистику репликации на подключенный резервный сервер отправителя. Подробнее см. &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;Pg_stat_replication&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e405939a7164c82deba654b8915f184314fd703" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about GSSAPI authentication and encryption used on this connection. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-GSSAPI-VIEW&quot;&gt;&lt;code&gt;pg_stat_gssapi&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04eefccf9acdca920d874c55aed10830947f2ad0" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about GSSAPI authentication and encryption used on this connection. See &lt;a href=&quot;monitoring-stats#PG-STAT-GSSAPI-VIEW&quot;&gt;pg_stat_gssapi&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка на каждое соединение (обычное и репликационное), показывающая информацию об аутентификации GSSAPI и шифровании, используемом для этого соединения. Подробности см. В &lt;a href=&quot;monitoring-stats#PG-STAT-GSSAPI-VIEW&quot;&gt;pg_stat_gssapi&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c6ee7f9f33f1b8de0af5ed4f012017f5739968" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about SSL used on this connection. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SSL-VIEW&quot;&gt;&lt;code&gt;pg_stat_ssl&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2500623059c396127b50986a7192b6dece4045" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about SSL used on this connection. See &lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;pg_stat_ssl&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка на каждое соединение (обычное и репликационное), показывающая информацию о SSL, используемом для этого соединения. Подробнее см. &lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;Pg_stat_ssl&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01cc5c68a8fa3b32b1a1b5f70dba90054b794d9e" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics about query cancels due to conflict with recovery on standby servers. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;&lt;code&gt;pg_stat_database_conflicts&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2bdd85f6f61ca9f60bf24ae4eb4fe127af69af" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics about query cancels due to conflict with recovery on standby servers. See &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка для каждой базы данных, показывающая статистику по всей базе данных об отменах запросов из-за конфликта с восстановлением на резервных серверах. Подробнее см. &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;Pg_stat_database_conflicts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28e4559145d57da7a6239ef820ede5cd25bacf3c" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt;&lt;code&gt;pg_stat_database&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ca9a3ad9c0527d7bf8067a93b52b4e199755b8" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics. See &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка для каждой базы данных, показывающая статистику всей базы данных. Подробнее см. &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;Pg_stat_database&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e295d72faf33e0deeaaee1f07b6d5d6544081e45" translate="yes" xml:space="preserve">
          <source>One row per server process, showing information related to the current activity of that process, such as state and current query. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ad092a9644445754a24d9ccf37920da6663d5c" translate="yes" xml:space="preserve">
          <source>One row per server process, showing information related to the current activity of that process, such as state and current query. See &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;pg_stat_activity&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка для каждого серверного процесса, показывающая информацию, относящуюся к текущей активности этого процесса, такую ​​как состояние и текущий запрос. Подробнее см. &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;Pg_stat_activity&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd0d7184c558c048e1447f27b2e4a45d43e212a8" translate="yes" xml:space="preserve">
          <source>One semantically-insignificant detail worth noting is that in &lt;code&gt;jsonb&lt;/code&gt;, numbers will be printed according to the behavior of the underlying &lt;code&gt;numeric&lt;/code&gt; type. In practice this means that numbers entered with &lt;code&gt;E&lt;/code&gt; notation will be printed without it, for example:</source>
          <target state="translated">Следует отметить одну семантически незначительную деталь: в &lt;code&gt;jsonb&lt;/code&gt; числа будут печататься в соответствии с поведением базового &lt;code&gt;numeric&lt;/code&gt; типа. На практике это означает, что числа, введенные с обозначением &lt;code&gt;E&lt;/code&gt; , будут напечатаны без него, например:</target>
        </trans-unit>
        <trans-unit id="7a6e275ed16c86e3b4c5fd635846a9ed4c51adbd" translate="yes" xml:space="preserve">
          <source>One server process blocks another if it either holds a lock that conflicts with the blocked process's lock request (hard block), or is waiting for a lock that would conflict with the blocked process's lock request and is ahead of it in the wait queue (soft block). When using parallel queries the result always lists client-visible process IDs (that is, &lt;code&gt;pg_backend_pid&lt;/code&gt; results) even if the actual lock is held or awaited by a child worker process. As a result of that, there may be duplicated PIDs in the result. Also note that when a prepared transaction holds a conflicting lock, it will be represented by a zero process ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee0b1a9ad748e96945cdf21735c3cba379b36e1" translate="yes" xml:space="preserve">
          <source>One should be wary of statements of the form</source>
          <target state="translated">Следует с осторожностью относиться к заявлениям в форме</target>
        </trans-unit>
        <trans-unit id="46a23970289c263b3e0e6e71fbc6ba26b97f5282" translate="yes" xml:space="preserve">
          <source>One should be wary that it is easy to misspell a POSIX-style time zone specification, since there is no check on the reasonableness of the zone abbreviation(s). For example, &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; will work, leaving the system effectively using a rather peculiar abbreviation for UTC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0503270d022d51df4a5d1385ddb363763c100a21" translate="yes" xml:space="preserve">
          <source>One should be wary that the POSIX-style time zone feature can lead to silently accepting bogus input, since there is no check on the reasonableness of the zone abbreviations. For example, &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; will work, leaving the system effectively using a rather peculiar abbreviation for UTC. Another issue to keep in mind is that in POSIX time zone names, positive offsets are used for locations &lt;em&gt;west&lt;/em&gt; of Greenwich. Everywhere else, PostgreSQL follows the ISO-8601 convention that positive timezone offsets are &lt;em&gt;east&lt;/em&gt; of Greenwich.</source>
          <target state="translated">Следует опасаться, что функция часового пояса в стиле POSIX может привести к молчаливому принятию поддельного ввода, поскольку нет проверки на разумность аббревиатуры зон. Например, &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; будет работать, оставляя систему эффективно использовать довольно своеобразную аббревиатуру для UTC. Еще одна проблема, о которой следует помнить, заключается в том, что в именах часовых поясов POSIX положительные смещения используются для местоположений к &lt;em&gt;западу&lt;/em&gt; от Гринвича. В остальном PostgreSQL следует соглашению ISO-8601 о положительном смещении часового пояса &lt;em&gt;к востоку&lt;/em&gt; от Гринвича.</target>
        </trans-unit>
        <trans-unit id="07761093680f0435d07de4dfbf3133e5f6e33451" translate="yes" xml:space="preserve">
          <source>One upgrade method is to dump data from one major version of PostgreSQL and reload it in another &amp;mdash; to do this, you must use a &lt;em&gt;logical&lt;/em&gt; backup tool like pg_dumpall; file system level backup methods will not work. (There are checks in place that prevent you from using a data directory with an incompatible version of PostgreSQL, so no great harm can be done by trying to start the wrong server version on a data directory.)</source>
          <target state="translated">Один из методов обновления - выгрузить данные из одной основной версии PostgreSQL и перезагрузить их в другой - для этого вы должны использовать инструмент &lt;em&gt;логического&lt;/em&gt; резервного копирования, например pg_dumpall; Методы резервного копирования на уровне файловой системы работать не будут. (Существуют проверки, которые не позволяют использовать каталог данных с несовместимой версией PostgreSQL, поэтому не может быть большого вреда, если попытаться запустить неправильную версию сервера в каталоге данных.)</target>
        </trans-unit>
        <trans-unit id="3c2ef0cb6e16fe638517e00044d9fddafd2f1f0e" translate="yes" xml:space="preserve">
          <source>One way to avoid this problem is to run PostgreSQL on a machine where you can be sure that other processes will not run the machine out of memory. If memory is tight, increasing the swap space of the operating system can help avoid the problem, because the out-of-memory (OOM) killer is invoked only when physical memory and swap space are exhausted.</source>
          <target state="translated">Один из способов избежать этой проблемы-запустить PostgreSQL на машине,где вы можете быть уверены,что другие процессы не запустят машину из памяти.Если память ограничена,увеличение пространства подкачки операционной системы может помочь избежать этой проблемы,потому что убийца вне памяти (OOM)вызывается только тогда,когда физическая память и пространство подкачки исчерпаны.</target>
        </trans-unit>
        <trans-unit id="cb720ead71b0312fba38d640c63f7a5801cc13dc" translate="yes" xml:space="preserve">
          <source>One way to do this is to shut down the server and start a single-user PostgreSQL server with the &lt;code&gt;-P&lt;/code&gt; option included on its command line. Then, &lt;code&gt;REINDEX DATABASE&lt;/code&gt;, &lt;code&gt;REINDEX SYSTEM&lt;/code&gt;, &lt;code&gt;REINDEX TABLE&lt;/code&gt;, or &lt;code&gt;REINDEX INDEX&lt;/code&gt; can be issued, depending on how much you want to reconstruct. If in doubt, use &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; to select reconstruction of all system indexes in the database. Then quit the single-user server session and restart the regular server. See the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page for more information about how to interact with the single-user server interface.</source>
          <target state="translated">Один из способов сделать это - выключить сервер и запустить однопользовательский сервер PostgreSQL с параметром &lt;code&gt;-P&lt;/code&gt; , включенным в его командную строку. Затем могут быть выданы &lt;code&gt;REINDEX DATABASE&lt;/code&gt; , &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; , &lt;code&gt;REINDEX TABLE&lt;/code&gt; или &lt;code&gt;REINDEX INDEX&lt;/code&gt; , в зависимости от того, сколько вы хотите восстановить. В случае сомнений используйте &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; , чтобы выбрать реконструкцию всех системных индексов в базе данных. Затем выйдите из сеанса однопользовательского сервера и перезапустите обычный сервер. См. Справочную страницу &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; для получения дополнительной информации о том, как взаимодействовать с однопользовательским серверным интерфейсом.</target>
        </trans-unit>
        <trans-unit id="76a318a5204a34131edd8add7164960e6a6851df" translate="yes" xml:space="preserve">
          <source>One way to look at variant plans is to force the planner to disregard whatever strategy it thought was the cheapest, using the enable/disable flags described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;. (This is a crude tool, but useful. See also &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.) For example, if we're unconvinced that sequential-scan-and-sort is the best way to deal with table &lt;code&gt;onek&lt;/code&gt; in the previous example, we could try</source>
          <target state="translated">Один из способов взглянуть на варианты планов - заставить планировщика игнорировать любую стратегию, которую он считал самой дешевой, используя флаги включения / отключения, описанные в &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Разделе 19.7.1&lt;/a&gt; . (Это грубый, но полезный инструмент. См. Также &lt;a href=&quot;explicit-joins&quot;&gt;Раздел 14.3&lt;/a&gt; .) Например, если мы не уверены, что последовательное сканирование и сортировка - лучший способ справиться с таблицей &lt;code&gt;onek&lt;/code&gt; в предыдущем примере, мы могли бы попробовать</target>
        </trans-unit>
        <trans-unit id="0391e7fdb45313d9e4e2f5f1634bb9ecb7a05ff9" translate="yes" xml:space="preserve">
          <source>One way to prevent spoofing of &lt;code&gt;local&lt;/code&gt; connections is to use a Unix domain socket directory (&lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt;) that has write permission only for a trusted local user. This prevents a malicious user from creating their own socket file in that directory. If you are concerned that some applications might still reference &lt;code&gt;/tmp&lt;/code&gt; for the socket file and hence be vulnerable to spoofing, during operating system startup create a symbolic link &lt;code&gt;/tmp/.s.PGSQL.5432&lt;/code&gt; that points to the relocated socket file. You also might need to modify your &lt;code&gt;/tmp&lt;/code&gt; cleanup script to prevent removal of the symbolic link.</source>
          <target state="translated">Один из способов предотвратить спуфинг &lt;code&gt;local&lt;/code&gt; подключений - использовать каталог сокетов домена Unix ( &lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt; ), который имеет разрешение на запись только для доверенного локального пользователя. Это предотвращает создание злоумышленником собственного файла сокета в этом каталоге. Если вы обеспокоены тем, что некоторые приложения могут по-прежнему ссылаться на &lt;code&gt;/tmp&lt;/code&gt; для файла сокета и, следовательно, быть уязвимыми для подделки, во время запуска операционной системы создайте символическую ссылку &lt;code&gt;/tmp/.s.PGSQL.5432&lt;/code&gt; , которая указывает на перемещенный файл сокета. Вам также может потребоваться изменить ваш сценарий очистки &lt;code&gt;/tmp&lt;/code&gt; , чтобы предотвратить удаление символической ссылки.</target>
        </trans-unit>
        <trans-unit id="839eb373f7e57c0c527b6ab4498f37574f9b1b5d" translate="yes" xml:space="preserve">
          <source>Online Analytical Processing</source>
          <target state="translated">Онлайн-аналитическая обработка</target>
        </trans-unit>
        <trans-unit id="9bc8e24fa431e83abb8ee45cbd92647ad8e714f7" translate="yes" xml:space="preserve">
          <source>Online Transaction Processing</source>
          <target state="translated">Обработка онлайн-транзакций</target>
        </trans-unit>
        <trans-unit id="0b59497ee41bee58e3cf2969b674c4903d4bc6b0" translate="yes" xml:space="preserve">
          <source>Online statistics:</source>
          <target state="translated">Статистика онлайн:</target>
        </trans-unit>
        <trans-unit id="95683a3aebf06f5e3b349d234f74e1173b887f29" translate="yes" xml:space="preserve">
          <source>Only an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock blocks a &lt;code&gt;SELECT&lt;/code&gt; (without &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt;) statement.</source>
          <target state="translated">Только блокировка &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; блокирует &lt;code&gt;SELECT&lt;/code&gt; (без &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6428d0603b66d67294f1af1eb460cffe5ea43327" translate="yes" xml:space="preserve">
          <source>Only calculate statistics for use by the optimizer (no vacuum), like &lt;code&gt;--analyze-only&lt;/code&gt;. Run several (currently three) stages of analyze with different configuration settings, to produce usable statistics faster.</source>
          <target state="translated">&lt;code&gt;--analyze-only&lt;/code&gt; статистику только для использования оптимизатором (без вакуума), например --analyze-only . Выполните несколько (в настоящее время три) этапов анализа с разными настройками конфигурации, чтобы быстрее получить полезную статистику.</target>
        </trans-unit>
        <trans-unit id="e4af2b2a347593a2587cd89d5c7edc042fe1b2ae" translate="yes" xml:space="preserve">
          <source>Only calculate statistics for use by the optimizer (no vacuum).</source>
          <target state="translated">Рассчитывайте только статистику для использования оптимизатором (без вакуума).</target>
        </trans-unit>
        <trans-unit id="1ff76f6d5463fac41b779622c32a96a9ae59972a" translate="yes" xml:space="preserve">
          <source>Only certain data types support TOAST &amp;mdash; there is no need to impose the overhead on data types that cannot produce large field values. To support TOAST, a data type must have a variable-length (&lt;em&gt;varlena&lt;/em&gt;) representation, in which, ordinarily, the first four-byte word of any stored value contains the total length of the value in bytes (including itself). TOAST does not constrain the rest of the data type's representation. The special representations collectively called &lt;em&gt;TOASTed values&lt;/em&gt; work by modifying or reinterpreting this initial length word. Therefore, the C-level functions supporting a TOAST-able data type must be careful about how they handle potentially TOASTed input values: an input might not actually consist of a four-byte length word and contents until after it's been &lt;em&gt;detoasted&lt;/em&gt;. (This is normally done by invoking &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; before doing anything with an input value, but in some cases more efficient approaches are possible. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt; for more detail.)</source>
          <target state="translated">Только определенные типы данных поддерживают TOAST - нет необходимости накладывать накладные расходы на типы данных, которые не могут создавать большие значения полей. Для поддержки TOAST тип данных должен иметь представление переменной длины ( &lt;em&gt;varlena&lt;/em&gt; ), в котором обычно первое четырехбайтовое слово любого сохраненного значения содержит общую длину значения в байтах (включая его самого). TOAST не ограничивает представление остальной части типа данных. Специальные представления, вместе называемые &lt;em&gt;значениями TOAST,&lt;/em&gt; работают путем изменения или переинтерпретации этого слова начальной длины. Следовательно, функции уровня C, поддерживающие тип данных, поддерживающий TOAST, должны быть осторожны в отношении того, как они обрабатывают потенциально TOAST-входные значения: входные данные могут фактически не состоять из слова и содержимого длиной четыре байта до тех пор, пока не будут выполнены.&lt;em&gt;Детский тост&lt;/em&gt; . (Обычно это делается путем вызова &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; перед тем, как что-либо делать с входным значением, но в некоторых случаях возможны более эффективные подходы. Подробнее см. &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Раздел 37.13.1&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="6ed75bf01a8cac9ceb181bdbf71cfb0dfa8f9324" translate="yes" xml:space="preserve">
          <source>Only certain data types support TOAST &amp;mdash; there is no need to impose the overhead on data types that cannot produce large field values. To support TOAST, a data type must have a variable-length (&lt;em&gt;varlena&lt;/em&gt;) representation, in which, ordinarily, the first four-byte word of any stored value contains the total length of the value in bytes (including itself). TOAST does not constrain the rest of the data type's representation. The special representations collectively called &lt;em&gt;TOASTed values&lt;/em&gt; work by modifying or reinterpreting this initial length word. Therefore, the C-level functions supporting a TOAST-able data type must be careful about how they handle potentially TOASTed input values: an input might not actually consist of a four-byte length word and contents until after it's been &lt;em&gt;detoasted&lt;/em&gt;. (This is normally done by invoking &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; before doing anything with an input value, but in some cases more efficient approaches are possible. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt; for more detail.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a5875a715917165876854e17c248ccf4f95f13" translate="yes" xml:space="preserve">
          <source>Only display records generated by the specified resource manager. If &lt;code&gt;list&lt;/code&gt; is passed as name, print a list of valid resource manager names, and exit.</source>
          <target state="translated">Отображать только записи, созданные указанным менеджером ресурсов. Если в качестве имени передан &lt;code&gt;list&lt;/code&gt; , распечатайте список допустимых имен диспетчеров ресурсов и выйдите.</target>
        </trans-unit>
        <trans-unit id="1eec6acc7fed503402488b3ba82909c46aae0483" translate="yes" xml:space="preserve">
          <source>Only display records marked with the given transaction ID.</source>
          <target state="translated">Отображать только записи,помеченные указанным идентификатором транзакции.</target>
        </trans-unit>
        <trans-unit id="df686aa57f8a0399728798091a1185e8914758e9" translate="yes" xml:space="preserve">
          <source>Only dump the named section. The section name can be &lt;code&gt;pre-data&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, or &lt;code&gt;post-data&lt;/code&gt;. This option can be specified more than once to select multiple sections. The default is to dump all sections.</source>
          <target state="translated">Выгрузить только названный раздел. Имя раздела может быть &lt;code&gt;pre-data&lt;/code&gt; , &lt;code&gt;data&lt;/code&gt; или &lt;code&gt;post-data&lt;/code&gt; . Этот параметр можно указать несколько раз, чтобы выбрать несколько разделов. По умолчанию сбрасываются все разделы.</target>
        </trans-unit>
        <trans-unit id="8c62a53b547108de76ccc1531107eb8cfedb9cfb" translate="yes" xml:space="preserve">
          <source>Only execute the vacuum or analyze commands on tables with a multixact ID age of at least &lt;code&gt;mxid_age&lt;/code&gt;. This setting is useful for prioritizing tables to process to prevent multixact ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;).</source>
          <target state="translated">Выполняйте команды очистки или анализа только для таблиц с возрастом идентификатора multixact не менее &lt;code&gt;mxid_age&lt;/code&gt; . Этот параметр полезен для приоритезации таблиц для обработки, чтобы предотвратить повторение множественных идентификаторов (см. &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Раздел 24.1.5.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="22cc7a345e3b6c6eac0bd069839bf36f1185ab25" translate="yes" xml:space="preserve">
          <source>Only execute the vacuum or analyze commands on tables with a transaction ID age of at least &lt;code&gt;xid_age&lt;/code&gt;. This setting is useful for prioritizing tables to process to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;xid_age&lt;/code&gt; или анализа только для таблиц с возрастом идентификатора транзакции не менее xid_age . Этот параметр полезен для приоритезации таблиц для обработки, чтобы предотвратить &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;повторение&lt;/a&gt; идентификатора транзакции (см. Раздел 24.1.5 ).</target>
        </trans-unit>
        <trans-unit id="30caad55acba8eaee72cd0eb2b22ca9a6e1cfcaa" translate="yes" xml:space="preserve">
          <source>Only has effect if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled.</source>
          <target state="translated">Действует, только если включены &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;контрольные суммы данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4930a6bbf0f1c4de7f538ff4072a1668f8d281a2" translate="yes" xml:space="preserve">
          <source>Only lowercase &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; spellings are accepted</source>
          <target state="translated">Только в нижнем регистре &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; правописание принимается</target>
        </trans-unit>
        <trans-unit id="5d755b459eeaa6b733e81509898e0f04066e3489" translate="yes" xml:space="preserve">
          <source>Only one comment string is stored for each object, so to modify a comment, issue a new &lt;code&gt;COMMENT&lt;/code&gt; command for the same object. To remove a comment, write &lt;code&gt;NULL&lt;/code&gt; in place of the text string. Comments are automatically dropped when their object is dropped.</source>
          <target state="translated">Для каждого объекта сохраняется только одна строка комментария, поэтому, чтобы изменить комментарий, введите новую команду &lt;code&gt;COMMENT&lt;/code&gt; для того же объекта. Чтобы удалить комментарий, напишите &lt;code&gt;NULL&lt;/code&gt; вместо текстовой строки. Комментарии удаляются автоматически, когда удаляется их объект.</target>
        </trans-unit>
        <trans-unit id="6b3d566bcef3dc1ca42fe3bd8ea05bbe930d19d6" translate="yes" xml:space="preserve">
          <source>Only one parameter may be supplied to the function in a &lt;code&gt;CREATE TRIGGER&lt;/code&gt; statement, and that is optional. If supplied it will be used for the channel name for the notifications. If omitted &lt;code&gt;tcn&lt;/code&gt; will be used for the channel name.</source>
          <target state="translated">В операторе &lt;code&gt;CREATE TRIGGER&lt;/code&gt; функции может быть передан только один параметр , и это необязательно. Если указано, оно будет использоваться в качестве имени канала для уведомлений. Если не &lt;code&gt;tcn&lt;/code&gt; , в качестве имени канала будет использоваться tcn .</target>
        </trans-unit>
        <trans-unit id="e6026da30f943934674a5eb09f1e0f0526ceb2de" translate="yes" xml:space="preserve">
          <source>Only one row, showing statistics about the WAL receiver from that receiver's connected server. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;&lt;code&gt;pg_stat_wal_receiver&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d2c18b8c742c722526abc3884826a2891d9cd5" translate="yes" xml:space="preserve">
          <source>Only one row, showing statistics about the WAL receiver from that receiver's connected server. See &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; for details.</source>
          <target state="translated">Только одна строка, показывающая статистику о получателе WAL с подключенного к нему сервера. Подробности см. В &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e141ed896712b895fe333210a9bdff25138d7ab" translate="yes" xml:space="preserve">
          <source>Only operator classes for &lt;code&gt;int4&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; are included with the module.</source>
          <target state="translated">В модуль включены только классы операторов для &lt;code&gt;int4&lt;/code&gt; и &lt;code&gt;text&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="109540637ae1151a05d5ef17fc0235346d4ed7ef" translate="yes" xml:space="preserve">
          <source>Only persistent base tables and partitioned tables can be part of a publication. Temporary tables, unlogged tables, foreign tables, materialized views, and regular views cannot be part of a publication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36554985b3656b4dddfbe30677cd178826516027" translate="yes" xml:space="preserve">
          <source>Only persistent base tables can be part of a publication. Temporary tables, unlogged tables, foreign tables, materialized views, regular views, and partitioned tables cannot be part of a publication. To replicate a partitioned table, add the individual partitions to the publication.</source>
          <target state="translated">Частью публикации могут быть только постоянные базовые таблицы.Временные таблицы,незарегистрированные таблицы,внешние таблицы,материализованные представления,регулярные представления и таблицы разделов не могут быть частью публикации.Для репликации таблицы разделов добавьте в публикацию отдельные разделы.</target>
        </trans-unit>
        <trans-unit id="b0f9131e0157ccbc9f71702565357129b8273efc" translate="yes" xml:space="preserve">
          <source>Only restore the named section. The section name can be &lt;code&gt;pre-data&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, or &lt;code&gt;post-data&lt;/code&gt;. This option can be specified more than once to select multiple sections. The default is to restore all sections.</source>
          <target state="translated">Восстановите только названный раздел. Имя раздела может быть &lt;code&gt;pre-data&lt;/code&gt; , &lt;code&gt;data&lt;/code&gt; или &lt;code&gt;post-data&lt;/code&gt; . Этот параметр можно указать несколько раз, чтобы выбрать несколько разделов. По умолчанию восстанавливаются все разделы.</target>
        </trans-unit>
        <trans-unit id="9d94341e83b6e3cc09be7f96d9ae2bbdbd997a3f" translate="yes" xml:space="preserve">
          <source>Only roles that have the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be used as the initial role name for a database connection. A role with the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be considered the same as a &amp;ldquo;database user&amp;rdquo;. To create a role with login privilege, use either:</source>
          <target state="translated">Только роли, которые имеют атрибут &lt;code&gt;LOGIN&lt;/code&gt; , могут использоваться в качестве начального имени роли для соединения с базой данных. Роль с атрибутом &lt;code&gt;LOGIN&lt;/code&gt; может рассматриваться как &amp;laquo;пользователь базы данных&amp;raquo;. Чтобы создать роль с привилегиями входа в систему, используйте:</target>
        </trans-unit>
        <trans-unit id="d85fc142dd33473e697f51542b02c504f67a9b35" translate="yes" xml:space="preserve">
          <source>Only shared libraries specifically intended to be used with PostgreSQL can be loaded this way. Every PostgreSQL-supported library has a &amp;ldquo;magic block&amp;rdquo; that is checked to guarantee compatibility. For this reason, non-PostgreSQL libraries cannot be loaded in this way. You might be able to use operating-system facilities such as &lt;code&gt;LD_PRELOAD&lt;/code&gt; for that.</source>
          <target state="translated">Таким образом можно загружать только разделяемые библиотеки, специально предназначенные для использования с PostgreSQL. В каждой поддерживаемой PostgreSQL библиотеке есть &amp;laquo;волшебный блок&amp;raquo;, который проверяется на совместимость. По этой причине библиотеки, не относящиеся к PostgreSQL, не могут быть загружены таким способом. Возможно, вы сможете использовать для этого средства операционной системы, такие как &lt;code&gt;LD_PRELOAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf905053544478968750f95521ca3e30e70375f" translate="yes" xml:space="preserve">
          <source>Only superusers can alter foreign-data wrappers. Additionally, only superusers can own foreign-data wrappers.</source>
          <target state="translated">Только суперпользователи могут изменять обертку иностранных данных.Кроме того,только суперпользователи могут владеть иностранными обертками данных.</target>
        </trans-unit>
        <trans-unit id="b9d1a65de15d43acfd7df441e250838c198f3037" translate="yes" xml:space="preserve">
          <source>Only superusers can call &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">Только суперпользователи могут вызывать &lt;code&gt;CHECKPOINT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b3d5ff53d3f29afdf3319b912d99cf3260a4f77" translate="yes" xml:space="preserve">
          <source>Only superusers can change this setting, because it affects the messages sent to the server log as well as to the client, and an improper value might obscure the readability of the server logs.</source>
          <target state="translated">Только суперпользователи могут изменить эту настройку,так как она влияет на сообщения,отправляемые как на серверный лог,так и на клиента,а неправильное значение может затушевать читабельность логов сервера.</target>
        </trans-unit>
        <trans-unit id="b2be6ed45f348313973635f2ddfd082cf6f9717d" translate="yes" xml:space="preserve">
          <source>Only superusers can create event triggers.</source>
          <target state="translated">Только суперпользователи могут создавать триггеры событий.</target>
        </trans-unit>
        <trans-unit id="2ae5bc67902361297a54dbc3f2c9fc4cdf0facde" translate="yes" xml:space="preserve">
          <source>Only superusers can create foreign-data wrappers.</source>
          <target state="translated">Только суперпользователи могут создавать обертки иностранных данных.</target>
        </trans-unit>
        <trans-unit id="a0a550e0a836899716e0fe5ebdbfaa0d54059384" translate="yes" xml:space="preserve">
          <source>Only superusers can define new access methods.</source>
          <target state="translated">Только суперпользователи могут определять новые методы доступа.</target>
        </trans-unit>
        <trans-unit id="d11423b98472dc3dca65de17ed52b8e73990fa3d" translate="yes" xml:space="preserve">
          <source>Only superusers can use &lt;code&gt;ALTER SYSTEM&lt;/code&gt;. Also, since this command acts directly on the file system and cannot be rolled back, it is not allowed inside a transaction block or function.</source>
          <target state="translated">Только суперпользователи могут использовать &lt;code&gt;ALTER SYSTEM&lt;/code&gt; . Кроме того, поскольку эта команда действует непосредственно в файловой системе и не может быть отменена, ее нельзя использовать внутри блока транзакции или функции.</target>
        </trans-unit>
        <trans-unit id="d0b0ed2869d7ce3fc0379f4c0080abfebb839775" translate="yes" xml:space="preserve">
          <source>Only superusers may connect to foreign servers without password authentication, so always specify the &lt;code&gt;password&lt;/code&gt; option for user mappings belonging to non-superusers.</source>
          <target state="translated">Только суперпользователи могут подключаться к сторонним серверам без аутентификации по паролю, поэтому всегда указывайте параметр &lt;code&gt;password&lt;/code&gt; для сопоставлений пользователей, принадлежащих не суперпользователям.</target>
        </trans-unit>
        <trans-unit id="9674d9c7cf6a8e522bf949d4719f88f50cf734f7" translate="yes" xml:space="preserve">
          <source>Only superusers may create or modify user mappings with the &lt;code&gt;sslcert&lt;/code&gt; or &lt;code&gt;sslkey&lt;/code&gt; settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add5aed352ded84ef9a29f07c8afce866831ef29" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;=&lt;/code&gt; operator is supported for search. But it is possible to add support for arrays with union and intersection operations in the future.</source>
          <target state="translated">Для поиска поддерживается только оператор &lt;code&gt;=&lt;/code&gt; . Но в будущем можно добавить поддержку массивов с операциями объединения и пересечения.</target>
        </trans-unit>
        <trans-unit id="a2c2cf173b45b1ac1a32e3ec0d5fe77ba32623c7" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;ANALYZE&lt;/code&gt; and &lt;code&gt;VERBOSE&lt;/code&gt; options can be specified, and only in that order, without surrounding the option list in parentheses. Prior to PostgreSQL 9.0, the unparenthesized syntax was the only one supported. It is expected that all new options will be supported only in the parenthesized syntax.</source>
          <target state="translated">Могут быть указаны только параметры &lt;code&gt;ANALYZE&lt;/code&gt; и &lt;code&gt;VERBOSE&lt;/code&gt; , и только в таком порядке, без заключения списка параметров в круглые скобки. До PostgreSQL 9.0 поддерживался только синтаксис без скобок. Ожидается, что все новые параметры будут поддерживаться только в синтаксисе в скобках.</target>
        </trans-unit>
        <trans-unit id="60a1039af88ab14d5161dbfac50ade9fe96eaa30" translate="yes" xml:space="preserve">
          <source>Only the custom and directory archive formats are supported with this option. The input must be a regular file or directory (not, for example, a pipe or standard input). Also, multiple jobs cannot be used together with the option &lt;code&gt;--single-transaction&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5022f8e7bdd77bf8c02d9d1490318561a8027b6a" translate="yes" xml:space="preserve">
          <source>Only the custom and directory archive formats are supported with this option. The input must be a regular file or directory (not, for example, a pipe). This option is ignored when emitting a script rather than connecting directly to a database server. Also, multiple jobs cannot be used together with the option &lt;code&gt;--single-transaction&lt;/code&gt;.</source>
          <target state="translated">С этой опцией поддерживаются только пользовательские форматы и архивы каталогов. На входе должен быть обычный файл или каталог (не, например, канал). Этот параметр игнорируется при запуске сценария вместо прямого подключения к серверу базы данных. Кроме того, несколько заданий нельзя использовать вместе с параметром &lt;code&gt;--single-transaction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e47b4720ff6f0582001899cb68bf4bdb2a0ac11" translate="yes" xml:space="preserve">
          <source>Only the owner of the database, or a superuser, can drop a database. Dropping a database removes all objects that were contained within the database. The destruction of a database cannot be undone.</source>
          <target state="translated">Только владелец базы данных или суперпользователь может бросить базу данных.При падении базы данных удаляются все объекты,которые содержались в ней.Уничтожение базы данных не может быть отменено.</target>
        </trans-unit>
        <trans-unit id="992702029b9e3a50c611dc6825669adb061c4f3f" translate="yes" xml:space="preserve">
          <source>Only the specified timeline is displayed (or the default, if none is specified). Records in other timelines are ignored.</source>
          <target state="translated">Отображается только указанная временная шкала (или по умолчанию,если она не указана).Записи в других временных рамках игнорируются.</target>
        </trans-unit>
        <trans-unit id="0e8a66b6f0be3b6d7c6a27438485bc034b86bede" translate="yes" xml:space="preserve">
          <source>Only validate checksums in the relation with filenode &lt;code&gt;filenode&lt;/code&gt;.</source>
          <target state="translated">Проверяйте только контрольные суммы в отношении файлового &lt;code&gt;filenode&lt;/code&gt; файлового узла .</target>
        </trans-unit>
        <trans-unit id="e0b885bbfd4f3bfc263123d67cbabd608309adfe" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity</source>
          <target state="translated">Открытая связь с базой данных</target>
        </trans-unit>
        <trans-unit id="904b1a9c4f30cf27ea883ca5fa7d3ff036c36eb9" translate="yes" xml:space="preserve">
          <source>Open interval with lower bound &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Открытый интервал с нижней границей &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a8b4a983dd22778ee9f002679eacd86bf69191d" translate="yes" xml:space="preserve">
          <source>Open interval with upper bound &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">Открытый интервал с верхней границей &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45de3417dc1987111074bc170202fbf751c567d8" translate="yes" xml:space="preserve">
          <source>Open path</source>
          <target state="translated">Открытый путь</target>
        </trans-unit>
        <trans-unit id="db3951317261fd51cb4c1a3e01c4748b4896c421" translate="yes" xml:space="preserve">
          <source>OpenBSD</source>
          <target state="translated">OpenBSD</target>
        </trans-unit>
        <trans-unit id="50ef244d7dd70cb29f22ada32d04825a64fc9036" translate="yes" xml:space="preserve">
          <source>OpenBSD sys/crypto</source>
          <target state="translated">OpenBSD sys/crypto</target>
        </trans-unit>
        <trans-unit id="e301ca795081a87c0033bddb2e90503f9f7929d2" translate="yes" xml:space="preserve">
          <source>OpenPGP message format.</source>
          <target state="translated">Формат сообщений OpenPGP.</target>
        </trans-unit>
        <trans-unit id="2188261ca504497d39a1689d5dff920fe8b50f79" translate="yes" xml:space="preserve">
          <source>OpenSSL names for the most common curves are: &lt;code&gt;prime256v1&lt;/code&gt; (NIST P-256), &lt;code&gt;secp384r1&lt;/code&gt; (NIST P-384), &lt;code&gt;secp521r1&lt;/code&gt; (NIST P-521). The full list of available curves can be shown with the command &lt;code&gt;openssl ecparam -list_curves&lt;/code&gt;. Not all of them are usable in TLS though.</source>
          <target state="translated">Имена OpenSSL для наиболее распространенных кривых: &lt;code&gt;prime256v1&lt;/code&gt; (NIST P-256), &lt;code&gt;secp384r1&lt;/code&gt; (NIST P-384), &lt;code&gt;secp521r1&lt;/code&gt; (NIST P-521). Полный список доступных кривых можно просмотреть с помощью команды &lt;code&gt;openssl ecparam -list_curves&lt;/code&gt; . Однако не все из них можно использовать в TLS.</target>
        </trans-unit>
        <trans-unit id="5c972fdff495c397d3150e0515793a7f4559382c" translate="yes" xml:space="preserve">
          <source>OpenSSL supports a wide range of ciphers and authentication algorithms, of varying strength. While a list of ciphers can be specified in the OpenSSL configuration file, you can specify ciphers specifically for use by the database server by modifying &lt;a href=&quot;runtime-config-connection#GUC-SSL-CIPHERS&quot;&gt;ssl_ciphers&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">OpenSSL поддерживает широкий спектр шифров и алгоритмов аутентификации различной степени сложности. Хотя список шифров может быть указан в файле конфигурации OpenSSL, вы можете указать шифрование специально для использования сервером базы данных, изменив &lt;a href=&quot;runtime-config-connection#GUC-SSL-CIPHERS&quot;&gt;ssl_ciphers&lt;/a&gt; в &lt;code&gt;postgresql.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3b0974ebaa95408edcf74b52711fc4f50a804a3" translate="yes" xml:space="preserve">
          <source>Operations such as TRUNCATE which normally affect a table and all of its inheritance children will cascade to all partitions, but may also be performed on an individual partition. Note that dropping a partition with &lt;code&gt;DROP TABLE&lt;/code&gt; requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table.</source>
          <target state="translated">Такие операции, как TRUNCATE, которые обычно влияют на таблицу и все ее дочерние элементы наследования, будут каскадно применяться ко всем разделам, но также могут выполняться на отдельном разделе. Обратите внимание, что для удаления раздела с помощью &lt;code&gt;DROP TABLE&lt;/code&gt; требуется установить блокировку &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; для родительской таблицы.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="b07cfafa5cefef04cd848e7642b8acf9013a81e6" translate="yes" xml:space="preserve">
          <source>Operator Classes and Operator Families</source>
          <target state="translated">Классы операторов и семьи операторов</target>
        </trans-unit>
        <trans-unit id="b398f34e06d00a1a82db7c5bd5884749c340c3d5" translate="yes" xml:space="preserve">
          <source>Operator Strategy 1</source>
          <target state="translated">Стратегия оператора 1</target>
        </trans-unit>
        <trans-unit id="244ef231d648a8011796f75d8ba0c200ff67c490" translate="yes" xml:space="preserve">
          <source>Operator Strategy 10</source>
          <target state="translated">Стратегия оператора 10</target>
        </trans-unit>
        <trans-unit id="aa5d9755365c2952ee3e6f612eacdbdd1a1d7624" translate="yes" xml:space="preserve">
          <source>Operator Strategy 11</source>
          <target state="translated">Стратегия оператора 11</target>
        </trans-unit>
        <trans-unit id="d4a97822fa5fff84d7420e13e887c2193e9890f0" translate="yes" xml:space="preserve">
          <source>Operator Strategy 12</source>
          <target state="translated">Стратегия оператора 12</target>
        </trans-unit>
        <trans-unit id="84afbc51b4cffb9fe60bc11408d20fc3c75207ff" translate="yes" xml:space="preserve">
          <source>Operator Strategy 2</source>
          <target state="translated">Стратегия оператора 2</target>
        </trans-unit>
        <trans-unit id="32970bd5b0dc670174fa5e603b715a1879812041" translate="yes" xml:space="preserve">
          <source>Operator Strategy 20</source>
          <target state="translated">Стратегия оператора 20</target>
        </trans-unit>
        <trans-unit id="151eb78f3e104abebf3876024563a961e2605d2c" translate="yes" xml:space="preserve">
          <source>Operator Strategy 21</source>
          <target state="translated">Стратегия оператора 21</target>
        </trans-unit>
        <trans-unit id="8684f3d138a78992a0b771dfbb423682326c65f8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 22</source>
          <target state="translated">Стратегия оператора 22</target>
        </trans-unit>
        <trans-unit id="71205740f8d9e86efeb0bd151835d85c0a6b3446" translate="yes" xml:space="preserve">
          <source>Operator Strategy 23</source>
          <target state="translated">Стратегия оператора 23</target>
        </trans-unit>
        <trans-unit id="e0c4fa7b818964dd91a014987dc2cbf9d0f35f95" translate="yes" xml:space="preserve">
          <source>Operator Strategy 3</source>
          <target state="translated">Стратегия оператора 3</target>
        </trans-unit>
        <trans-unit id="c0698fd0a94af9d76a35b8038b94b51dc5055fa5" translate="yes" xml:space="preserve">
          <source>Operator Strategy 4</source>
          <target state="translated">Стратегия оператора 4</target>
        </trans-unit>
        <trans-unit id="7f6f8898348de22423f28b86e1d340d71a2b39e6" translate="yes" xml:space="preserve">
          <source>Operator Strategy 5</source>
          <target state="translated">Стратегия оператора 5</target>
        </trans-unit>
        <trans-unit id="3b8f252bde4d01adf4e5020737ab0f39249112c8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 6, 18</source>
          <target state="translated">Стратегия оператора 6,18</target>
        </trans-unit>
        <trans-unit id="63882822a5b9fac73c626ceb2fedd6c07953d3d2" translate="yes" xml:space="preserve">
          <source>Operator Strategy 7</source>
          <target state="translated">Стратегия оператора 7</target>
        </trans-unit>
        <trans-unit id="614f640543a97c56dc41fc006e5e6df302593992" translate="yes" xml:space="preserve">
          <source>Operator Strategy 7, 13, 16, 24, 25</source>
          <target state="translated">Стратегия оператора 7,13,16,24,25</target>
        </trans-unit>
        <trans-unit id="f5666e86d614f20d9c6c6d654b73870444a0a7b8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 8, 14, 26, 27</source>
          <target state="translated">Стратегия оператора 8,14,26,27</target>
        </trans-unit>
        <trans-unit id="6bd466b077248c905be85a30157069ea7d392f05" translate="yes" xml:space="preserve">
          <source>Operator Strategy 9</source>
          <target state="translated">Стратегия оператора 9</target>
        </trans-unit>
        <trans-unit id="23a5e32675db7a6dae8947caf6f8b77d2fb419f2" translate="yes" xml:space="preserve">
          <source>Operator class member</source>
          <target state="translated">Член операторского класса</target>
        </trans-unit>
        <trans-unit id="a154991f482d1ef020b50f829693f6a3e7645883" translate="yes" xml:space="preserve">
          <source>Operator classes are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">Классы операторов подробно описаны в &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Разделе 37.16&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c63c649d8246e4687f509dd0b4cd3e53d324b319" translate="yes" xml:space="preserve">
          <source>Operator classes are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58080c4fb9795121bf1294991f50a6dd258005c4" translate="yes" xml:space="preserve">
          <source>Operator classes that implement completely different semantics are also possible, provided implementations of the four main support functions described above are written. Note that backwards compatibility across major releases is not guaranteed: for example, additional support functions might be required in later releases.</source>
          <target state="translated">Также возможны операторские классы,реализующие совершенно другую семантику,при условии написания реализаций четырех основных функций поддержки,описанных выше.Обратите внимание,что обратная совместимость в основных релизах не гарантируется:например,в более поздних релизах могут потребоваться дополнительные функции поддержки.</target>
        </trans-unit>
        <trans-unit id="eb753b5f274e2276c93849eb8d4d017ef67b8b0d" translate="yes" xml:space="preserve">
          <source>Operator families are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Семейства&lt;/a&gt; операторов подробно описаны в Разделе 37.16 .</target>
        </trans-unit>
        <trans-unit id="85e043feb1fde1f2ad0490d4b9f478c590c6ae0a" translate="yes" xml:space="preserve">
          <source>Operator families are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089453e64460e24c4860d90b978d73331899e626" translate="yes" xml:space="preserve">
          <source>Operator family containing the operator class</source>
          <target state="translated">Семейство операторов,содержащее класс оператора</target>
        </trans-unit>
        <trans-unit id="d001f433bb040727266e2e45232ebf1b96c87507" translate="yes" xml:space="preserve">
          <source>Operator purpose, either &lt;code&gt;s&lt;/code&gt; for search or &lt;code&gt;o&lt;/code&gt; for ordering</source>
          <target state="translated">Оператор назначения, либо &lt;code&gt;s&lt;/code&gt; для поиска или &lt;code&gt;o&lt;/code&gt; для заказа</target>
        </trans-unit>
        <trans-unit id="912efd8e18516ea9637e59e441f7f7a9add7dc7b" translate="yes" xml:space="preserve">
          <source>Operator strategy number</source>
          <target state="translated">Номер стратегии оператора</target>
        </trans-unit>
        <trans-unit id="2e8cb1b3b6dd7d5c36991fdde1327aa3fa525b70" translate="yes" xml:space="preserve">
          <source>Operator/Element</source>
          <target state="translated">Operator/Element</target>
        </trans-unit>
        <trans-unit id="2d08499adb61cbc2e5aa0edb02bd1f8b9de48e7f" translate="yes" xml:space="preserve">
          <source>Operator/Method</source>
          <target state="translated">Operator/Method</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="245cf7f12c2bf5a2fc5aaf31f347829fe389252a" translate="yes" xml:space="preserve">
          <source>Operators are represented by &lt;code&gt;oprname(lefttype,righttype)&lt;/code&gt;, writing the type names exactly as they appear in the &lt;code&gt;pg_operator.dat&lt;/code&gt; entry's &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields. (Write &lt;code&gt;0&lt;/code&gt; for the omitted operand of a unary operator.)</source>
          <target state="translated">Операторы представлены &lt;code&gt;oprname(lefttype,righttype)&lt;/code&gt; , записывая имена типов точно так, как они появляются в &lt;code&gt;pg_operator.dat&lt;/code&gt; &lt;code&gt;oprleft&lt;/code&gt; и &lt;code&gt;oprright&lt;/code&gt; записи pg_operator.dat . (Напишите &lt;code&gt;0&lt;/code&gt; для пропущенного операнда унарного оператора.)</target>
        </trans-unit>
        <trans-unit id="1f5c0ba13f00010cbbfefca8a52453ff0cb4b539" translate="yes" xml:space="preserve">
          <source>Optimality of the query plan</source>
          <target state="translated">Оптимальность плана запроса</target>
        </trans-unit>
        <trans-unit id="5b15e9cc0d575ead9ee77f9021833cc95443ec95" translate="yes" xml:space="preserve">
          <source>Optimizer</source>
          <target state="translated">Optimizer</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="30ea09691f79f4f3b53ede4678ab841460419294" translate="yes" xml:space="preserve">
          <source>Optional data-manipulation: compression, conversion to UTF-8, and/or conversion of line-endings.</source>
          <target state="translated">Дополнительная манипуляция данными:сжатие,преобразование в UTF-8 и/или преобразование линейных окончаний.</target>
        </trans-unit>
        <trans-unit id="dda0500e72a6b8d9415eee2d2bd9c2b4bddc1e78" translate="yes" xml:space="preserve">
          <source>Optional key words. They have no effect.</source>
          <target state="translated">Необязательные ключевые слова.Они не имеют никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="be700c602b6a0f91e2d0a7efd9323b26ffbdc0e3" translate="yes" xml:space="preserve">
          <source>Optional parameters can be written in any order, not only the order illustrated above.</source>
          <target state="translated">Дополнительные параметры могут быть записаны в любом порядке,а не только в порядке,показанном выше.</target>
        </trans-unit>
        <trans-unit id="a1ddbf1be07fc433b776138e1087ccfcfc7bb295" translate="yes" xml:space="preserve">
          <source>Optional planner support function for this function (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt;)</source>
          <target state="translated">Дополнительная функция поддержки планировщика для этой функции (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Раздел 37.11&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a2e97703c74b74734bc3d703b229e2fffbfe125d" translate="yes" xml:space="preserve">
          <source>Optional planner support function for this function (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd16c799a777633af7110bcb3365acd2d2f9b6f" translate="yes" xml:space="preserve">
          <source>Optional server type, potentially useful to foreign-data wrappers.</source>
          <target state="translated">Необязательный тип сервера,потенциально полезен для оберток иностранных данных.</target>
        </trans-unit>
        <trans-unit id="23e65fc5f0e4b9be1c8551d9648425aede4fa734" translate="yes" xml:space="preserve">
          <source>Optional server version, potentially useful to foreign-data wrappers.</source>
          <target state="translated">Дополнительная серверная версия,потенциально полезная для оберток иностранных данных.</target>
        </trans-unit>
        <trans-unit id="8080182e2b9ea49c9096dd85079cd9c704e16363" translate="yes" xml:space="preserve">
          <source>Optionally one can add the key word &lt;code&gt;ASC&lt;/code&gt; (ascending) or &lt;code&gt;DESC&lt;/code&gt; (descending) after any expression in the &lt;code&gt;ORDER BY&lt;/code&gt; clause. If not specified, &lt;code&gt;ASC&lt;/code&gt; is assumed by default. Alternatively, a specific ordering operator name can be specified in the &lt;code&gt;USING&lt;/code&gt; clause. An ordering operator must be a less-than or greater-than member of some B-tree operator family. &lt;code&gt;ASC&lt;/code&gt; is usually equivalent to &lt;code&gt;USING &amp;lt;&lt;/code&gt; and &lt;code&gt;DESC&lt;/code&gt; is usually equivalent to &lt;code&gt;USING &amp;gt;&lt;/code&gt;. (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)</source>
          <target state="translated">При желании можно добавить ключевое слово &lt;code&gt;ASC&lt;/code&gt; (по возрастанию) или &lt;code&gt;DESC&lt;/code&gt; (по убыванию) после любого выражения в предложении &lt;code&gt;ORDER BY&lt;/code&gt; . Если не указано, по умолчанию предполагается &lt;code&gt;ASC&lt;/code&gt; . В качестве альтернативы в предложении &lt;code&gt;USING&lt;/code&gt; можно указать конкретное имя оператора упорядочивания . Оператор упорядочивания должен быть членом некоторого семейства операторов B-дерева как &amp;laquo;меньше или больше&amp;raquo;. &lt;code&gt;ASC&lt;/code&gt; обычно эквивалентно &lt;code&gt;USING &amp;lt;&lt;/code&gt; , а &lt;code&gt;DESC&lt;/code&gt; обычно эквивалентно &lt;code&gt;USING &amp;gt;&lt;/code&gt; . (Но создатель определяемого пользователем типа данных может точно определить порядок сортировки по умолчанию, и он может соответствовать операторам с другими именами.)</target>
        </trans-unit>
        <trans-unit id="25a8ce77c093de9028c29694dad75d1d0b46f922" translate="yes" xml:space="preserve">
          <source>Optionally specifies an existing replication slot to be used when connecting to the sending server via streaming replication to control resource removal on the upstream node (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). This parameter can only be set at server start. This setting has no effect if &lt;code&gt;primary_conninfo&lt;/code&gt; is not set.</source>
          <target state="translated">Необязательно указывает существующий слот репликации, который будет использоваться при подключении к отправляющему серверу через потоковую репликацию для управления удалением ресурсов на вышестоящем узле (см. &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Раздел 26.2.6&lt;/a&gt; ). Этот параметр можно установить только при запуске сервера. Этот параметр не действует, если не задано значение &lt;code&gt;primary_conninfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96c92ada09a34799bdf814b9347c979dbca22b37" translate="yes" xml:space="preserve">
          <source>Optionally specifies an existing replication slot to be used when connecting to the sending server via streaming replication to control resource removal on the upstream node (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. If this parameter is changed while the WAL receiver process is running, that process is signaled to shut down and expected to restart with the new setting. This setting has no effect if &lt;code&gt;primary_conninfo&lt;/code&gt; is not set or the server is not in standby mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e1a54cb19d7f45ef6c62130cbc0ebd54aaaeaa" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can include subcommands to create objects within the new schema. The subcommands are treated essentially the same as separate commands issued after creating the schema, except that if the &lt;code&gt;AUTHORIZATION&lt;/code&gt; clause is used, all the created objects will be owned by that user.</source>
          <target state="translated">При желании &lt;code&gt;CREATE SCHEMA&lt;/code&gt; может включать подкоманды для создания объектов в новой схеме. Подкоманды обрабатываются по существу так же, как отдельные команды, выдаваемые после создания схемы, за исключением того, что если используется предложение &lt;code&gt;AUTHORIZATION&lt;/code&gt; , все созданные объекты будут принадлежать этому пользователю.</target>
        </trans-unit>
        <trans-unit id="f83f2be43194c5b280c1fd15656c0623344c2afd" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;GLOBAL&lt;/code&gt; or &lt;code&gt;LOCAL&lt;/code&gt; can be written before &lt;code&gt;TEMPORARY&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt;. This presently makes no difference in PostgreSQL and is deprecated; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;Compatibility&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb213cf60cad5118b118598f7c3788d5e4cf965c" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;GLOBAL&lt;/code&gt; or &lt;code&gt;LOCAL&lt;/code&gt; can be written before &lt;code&gt;TEMPORARY&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt;. This presently makes no difference in PostgreSQL and is deprecated; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;Compatibility&lt;/a&gt;.</source>
          <target state="translated">По желанию, &lt;code&gt;GLOBAL&lt;/code&gt; или &lt;code&gt;LOCAL&lt;/code&gt; можно написать перед &lt;code&gt;TEMPORARY&lt;/code&gt; или &lt;code&gt;TEMP&lt;/code&gt; . В настоящее время это не имеет значения в PostgreSQL и считается устаревшим; см. &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;Совместимость&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a86b4b1bbae5190193648607744f965bba9ad7dc" translate="yes" xml:space="preserve">
          <source>Optionally, a B-tree operator family may provide &lt;code&gt;options&lt;/code&gt; (&amp;ldquo;operator class specific options&amp;rdquo;) support functions, registered under support function number 5. These functions define a set of user-visible parameters that control operator class behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbcd7d9ec5c4025e28ab09de1e1dc49ba23c52a" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;code&gt;equalimage&lt;/code&gt; (&amp;ldquo;equality implies image equality&amp;rdquo;) support functions, registered under support function number 4. These functions allow the core code to determine when it is safe to apply the btree deduplication optimization. Currently, &lt;code&gt;equalimage&lt;/code&gt; functions are only called when building or rebuilding an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ce22db7991e92cf37c1757c548b3362a7ca1aa" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;em&gt;in_range&lt;/em&gt; support function(s), registered under support function number 3. These are not used during btree index operations; rather, they extend the semantics of the operator family so that it can support window clauses containing the &lt;code&gt;RANGE&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;RANGE&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame bound types (see &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;). Fundamentally, the extra information provided is how to add or subtract an &lt;code&gt;offset&lt;/code&gt; value in a way that is compatible with the family's data ordering.</source>
          <target state="translated">Необязательно, семейство операторов btree может предоставлять функцию (-ы) поддержки &lt;em&gt;in_range&lt;/em&gt; , зарегистрированную под функцией поддержки номер 3. Они не используются во время операций индекса btree; скорее, они расширяют семантику семейства операторов, чтобы оно могло поддерживать предложения окна, содержащие типы границ кадра &lt;code&gt;RANGE&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; и &lt;code&gt;RANGE&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; (см. &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;раздел 4.2.8&lt;/a&gt; ). По сути, предоставляется дополнительная информация о том, как добавить или вычесть значение &lt;code&gt;offset&lt;/code&gt; способом, совместимым с порядком данных в семействе.</target>
        </trans-unit>
        <trans-unit id="478c790850d122e707e8f7883dedaa4fc2abbd82" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;em&gt;sort support&lt;/em&gt; function(s), registered under support function number 2. These functions allow implementing comparisons for sorting purposes in a more efficient way than naively calling the comparison support function. The APIs involved in this are defined in &lt;code&gt;src/include/utils/sortsupport.h&lt;/code&gt;.</source>
          <target state="translated">Необязательно, семейство операторов btree может предоставлять функцию (-ы) &lt;em&gt;поддержки сортировки&lt;/em&gt; , зарегистрированную под функцией поддержки номер 2. Эти функции позволяют осуществлять сравнения для целей сортировки более эффективным способом, чем простой вызов функции поддержки сравнения. Участвующие в этом API определены в &lt;code&gt;src/include/utils/sortsupport.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d0b1d8f44651eff9c08018d57dc26658e0d79ec" translate="yes" xml:space="preserve">
          <source>Optionally, an operator class for GIN can supply the following method:</source>
          <target state="translated">В качестве опции операторский класс для GIN может поставлять следующий метод:</target>
        </trans-unit>
        <trans-unit id="555fcafecaac1b7a79da77571a044c4fcd960ef4" translate="yes" xml:space="preserve">
          <source>Optionally, integer &lt;em&gt;positions&lt;/em&gt; can be attached to lexemes:</source>
          <target state="translated">При желании к лексемам можно добавлять целые &lt;em&gt;позиции&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="ba2c90dde0ab03dd101be9fe39552cd35bcc19fc" translate="yes" xml:space="preserve">
          <source>Optionally, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with one or more weight letters, which restricts them to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes with one of those weights:</source>
          <target state="translated">По желанию, лексемы в &lt;code&gt;tsquery&lt;/code&gt; могут быть помечены одним или несколькими весовыми буквами, что ограничивает их соответствие только лексемам &lt;code&gt;tsvector&lt;/code&gt; с одним из этих весов:</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="bfb2e74b331377cdefa56e8103510af4757e8e75" translate="yes" xml:space="preserve">
          <source>Options are named to be similar to GnuPG. An option's value should be given after an equal sign; separate options from each other with commas. For example:</source>
          <target state="translated">Опции названы так,чтобы быть похожими на GnuPG.Значение опциона должно быть дано после знака равенства;отделяйте опционы друг от друга запятыми.Например:</target>
        </trans-unit>
        <trans-unit id="01c5d645df020042965df6656c79fbcb52302c6d" translate="yes" xml:space="preserve">
          <source>Options for Single-User Mode</source>
          <target state="translated">Опции для режима одиночного пользователя</target>
        </trans-unit>
        <trans-unit id="2cc6e913a91a4d81d0ee2eacb713152c147c5122" translate="yes" xml:space="preserve">
          <source>Options for Windows</source>
          <target state="translated">Опции для Windows</target>
        </trans-unit>
        <trans-unit id="0807432116c5005f30d6e9cc2d8f5760b3400db2" translate="yes" xml:space="preserve">
          <source>Options specified for authentication method, if any</source>
          <target state="translated">Опции,указанные для метода аутентификации,если таковые имеются</target>
        </trans-unit>
        <trans-unit id="2ba952bec3ffacb85d251e04c62c8891e8cc4022" translate="yes" xml:space="preserve">
          <source>Options to be associated with the new foreign table or one of its columns. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign-data wrapper's validator function. Duplicate option names are not allowed (although it's OK for a table option and a column option to have the same name).</source>
          <target state="translated">Варианты,которые необходимо связать с новой иностранной таблицей или одной из ее колонок.Допустимые имена и значения опций специфичны для каждой зарубежной обертки данных и проверяются с помощью функции валидатора зарубежной обертки данных.Дублированные имена опций не допускаются (хотя для опции &quot;Таблица&quot; и опции &quot;Столбец&quot; допустимо одно и то же имя).</target>
        </trans-unit>
        <trans-unit id="ea0cc8f54bce88ccfd10bba527220a016a032c30" translate="yes" xml:space="preserve">
          <source>Options to be used during the import. The allowed option names and values are specific to each foreign data wrapper.</source>
          <target state="translated">Опции,которые будут использоваться во время импорта.Допустимые имена и значения опций специфичны для каждой зарубежной обертки данных.</target>
        </trans-unit>
        <trans-unit id="9a0c5ecf28319808109742741597da1a162506e4" translate="yes" xml:space="preserve">
          <source>Or, if no array size is to be specified:</source>
          <target state="translated">Или,если размер массива не должен быть указан:</target>
        </trans-unit>
        <trans-unit id="57f20b026b33a5f996b1722a8963058f7f139ed9" translate="yes" xml:space="preserve">
          <source>Order in which the entries are processed (1..&lt;code&gt;n&lt;/code&gt;)</source>
          <target state="translated">Порядок обработки записей (1 .. &lt;code&gt;n&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6b71865e60556421edb3dc5a27a33115f8d23b2c" translate="yes" xml:space="preserve">
          <source>Order in which to consult this entry (lower &lt;code&gt;mapseqno&lt;/code&gt;s first)</source>
          <target state="translated">Порядок, в котором следует обращаться к этой записи ( &lt;code&gt;mapseqno&lt;/code&gt; нижний mapseqno s)</target>
        </trans-unit>
        <trans-unit id="9032c5927654c6b139387affcba7ab64e16f3699" translate="yes" xml:space="preserve">
          <source>Ordering Operators</source>
          <target state="translated">Заказ операторов</target>
        </trans-unit>
        <trans-unit id="bb496dd08aebe7c50e13b0f636e3490f9e72e352" translate="yes" xml:space="preserve">
          <source>Ordinarily a cast must have different source and target data types. However, it is allowed to declare a cast with identical source and target types if it has a cast implementation function with more than one argument. This is used to represent type-specific length coercion functions in the system catalogs. The named function is used to coerce a value of the type to the type modifier value given by its second argument.</source>
          <target state="translated">Обычно гипс должен иметь разные типы исходных и целевых данных.Однако,допускается объявление приведения с одинаковыми исходными и целевыми типами,если у него есть функция реализации приведения с более чем одним аргументом.Это используется для представления в системных каталогах функций принуждения по длине для конкретных типов.Именованная функция используется для принуждения значения типа к значению модификатора типа,заданному его вторым аргументом.</target>
        </trans-unit>
        <trans-unit id="23ae1f89c4cafddef64330187ff525b64ad51110" translate="yes" xml:space="preserve">
          <source>Ordinarily, PostgreSQL functions are expected to be true functions that do not modify their input values. However, an aggregate transition function, &lt;em&gt;when used in the context of an aggregate&lt;/em&gt;, is allowed to cheat and modify its transition-state argument in place. This can provide substantial performance benefits compared to making a fresh copy of the transition state each time.</source>
          <target state="translated">Обычно ожидается, что функции PostgreSQL будут настоящими функциями, которые не изменяют свои входные значения. Однако агрегатной функции перехода, &lt;em&gt;когда она используется в контексте агрегата&lt;/em&gt; , разрешено обманывать и изменять свой аргумент состояния перехода на месте. Это может обеспечить значительные преимущества в производительности по сравнению с созданием новой копии переходного состояния каждый раз.</target>
        </trans-unit>
        <trans-unit id="7c0095250f58080cd4f7b0263a9f790d13029e21" translate="yes" xml:space="preserve">
          <source>Ordinarily, if a date/time string is syntactically valid but contains out-of-range field values, an error will be thrown. For example, input specifying the 31st of February will be rejected.</source>
          <target state="translated">Обычно,если строка даты/времени является синтаксически корректной,но содержит значения полей вне диапазона,будет выдана ошибка.Например,ввод с указанием 31 февраля будет отклонен.</target>
        </trans-unit>
        <trans-unit id="d469c00e9517d285e5591f4a6f0cfdb929fc4475" translate="yes" xml:space="preserve">
          <source>Ordinarily, only the object's owner (or a superuser) can grant or revoke privileges on an object. However, it is possible to grant a privilege &amp;ldquo;with grant option&amp;rdquo;, which gives the recipient the right to grant it in turn to others. If the grant option is subsequently revoked then all who received the privilege from that recipient (directly or through a chain of grants) will lose the privilege. For details see the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; reference pages.</source>
          <target state="translated">Обычно только владелец объекта (или суперпользователь) может предоставлять или отзывать права доступа к объекту. Однако можно предоставить привилегию &amp;laquo;с опцией предоставления&amp;raquo;, которая дает получателю право предоставлять ее, в свою очередь, другим. Если опция предоставления впоследствии будет отменена, то все, кто получил привилегию от этого получателя (напрямую или через цепочку грантов), потеряют эту привилегию. Для получения подробной информации см. Справочные страницы &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; и &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1198b431d5751f4a8f2d46d9894c80568e5c546c" translate="yes" xml:space="preserve">
          <source>Ordinarily, the input rows are fed to the aggregate function in an unspecified order. In many cases this does not matter; for example, &lt;code&gt;min&lt;/code&gt; produces the same result no matter what order it receives the inputs in. However, some aggregate functions (such as &lt;code&gt;array_agg&lt;/code&gt; and &lt;code&gt;string_agg&lt;/code&gt;) produce results that depend on the ordering of the input rows. When using such an aggregate, the optional &lt;code&gt;order_by_clause&lt;/code&gt; can be used to specify the desired ordering. The &lt;code&gt;order_by_clause&lt;/code&gt; has the same syntax as for a query-level &lt;code&gt;ORDER BY&lt;/code&gt; clause, as described in &lt;a href=&quot;queries-order&quot;&gt;Section 7.5&lt;/a&gt;, except that its expressions are always just expressions and cannot be output-column names or numbers. For example:</source>
          <target state="translated">Обычно входные строки передаются в агрегатную функцию в неопределенном порядке. Во многих случаях это не имеет значения; например, &lt;code&gt;min&lt;/code&gt; дает один и тот же результат независимо от того, в каком порядке он получает входные данные. Однако некоторые агрегатные функции (такие как &lt;code&gt;array_agg&lt;/code&gt; и &lt;code&gt;string_agg&lt;/code&gt; ) дают результаты, которые зависят от порядка входных строк. При использовании такого агрегата можно использовать необязательное предложение &lt;code&gt;order_by_clause&lt;/code&gt; для указания желаемого порядка. Предложение &lt;code&gt;order_by_clause&lt;/code&gt; имеет тот же синтаксис, что и предложение &lt;code&gt;ORDER BY&lt;/code&gt; уровня запроса , как описано в &lt;a href=&quot;queries-order&quot;&gt;Разделе 7.5.&lt;/a&gt;, за исключением того, что его выражения всегда являются просто выражениями и не могут быть именами или числами выходных столбцов. Например:</target>
        </trans-unit>
        <trans-unit id="2a1751155e24c2b7f81369ad2aa106588546c4f5" translate="yes" xml:space="preserve">
          <source>Ordinarily, the user must have the PostgreSQL superuser privilege to register a new language. However, the owner of a database can register a new language within that database if the language is listed in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog and is marked as allowed to be created by database owners (&lt;code&gt;tmpldbacreate&lt;/code&gt; is true). The default is that trusted languages can be created by database owners, but this can be adjusted by superusers by modifying the contents of &lt;code&gt;pg_pltemplate&lt;/code&gt;. The creator of a language becomes its owner and can later drop it, rename it, or assign it to a new owner.</source>
          <target state="translated">Обычно для регистрации нового языка пользователь должен иметь привилегию суперпользователя PostgreSQL. Однако владелец базы данных может зарегистрировать новый язык в этой базе данных, если язык указан в каталоге &lt;code&gt;pg_pltemplate&lt;/code&gt; и помечен как разрешенный для создания владельцами базы данных ( &lt;code&gt;tmpldbacreate&lt;/code&gt; истинно). По умолчанию доверенные языки могут быть созданы владельцами баз данных, но суперпользователи могут это изменить, изменив содержимое &lt;code&gt;pg_pltemplate&lt;/code&gt; . Создатель языка становится его владельцем и позже может удалить его, переименовать или назначить новому владельцу.</target>
        </trans-unit>
        <trans-unit id="d31ebd6359b908a6b08b46621a9edc9ed8848a84" translate="yes" xml:space="preserve">
          <source>Ordinarily, there will be only a single WAL range. However, if a backup is taken from a standby which switches timelines during the backup due to an upstream promotion, it is possible for multiple ranges to be present, each with a different timeline. There will never be multiple WAL ranges present for the same timeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49558321bc55879a8f79a252d13bd83f15cac2ec" translate="yes" xml:space="preserve">
          <source>Ordinary comparison operators yield null (signifying &amp;ldquo;unknown&amp;rdquo;), not true or false, when either input is null. For example, &lt;code&gt;7 = NULL&lt;/code&gt; yields null, as does &lt;code&gt;7 &amp;lt;&amp;gt; NULL&lt;/code&gt;. When this behavior is not suitable, use the &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; predicates:</source>
          <target state="translated">Обычные операторы сравнения возвращают значение NULL (что означает &amp;laquo;неизвестно&amp;raquo;), а не истина или ложь, если любой из входных данных равен нулю. Например, &lt;code&gt;7 = NULL&lt;/code&gt; дает значение NULL, как и &lt;code&gt;7 &amp;lt;&amp;gt; NULL&lt;/code&gt; . Если такое поведение не подходит, используйте предикаты &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f51e9682012527e72ed015353424811e9ad8a4d" translate="yes" xml:space="preserve">
          <source>Ordinary text is allowed in &lt;code&gt;to_char&lt;/code&gt; templates and will be output literally. You can put a substring in double quotes to force it to be interpreted as literal text even if it contains template patterns. For example, in &lt;code&gt;'&quot;Hello Year &quot;YYYY'&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; will be replaced by the year data, but the single &lt;code&gt;Y&lt;/code&gt; in &lt;code&gt;Year&lt;/code&gt; will not be. In &lt;code&gt;to_date&lt;/code&gt;, &lt;code&gt;to_number&lt;/code&gt;, and &lt;code&gt;to_timestamp&lt;/code&gt;, literal text and double-quoted strings result in skipping the number of characters contained in the string; for example &lt;code&gt;&quot;XX&quot;&lt;/code&gt; skips two input characters (whether or not they are &lt;code&gt;XX&lt;/code&gt;).</source>
          <target state="translated">Обычный текст разрешен в шаблонах &lt;code&gt;to_char&lt;/code&gt; и будет выводиться буквально. Вы можете заключить подстроку в двойные кавычки, чтобы заставить ее интерпретироваться как буквальный текст, даже если она содержит шаблоны шаблонов. Например, в &lt;code&gt;'&quot;Hello Year &quot;YYYY'&lt;/code&gt; , то &lt;code&gt;YYYY&lt;/code&gt; будет заменен данными года, но единственный &lt;code&gt;Y&lt;/code&gt; в &lt;code&gt;Year&lt;/code&gt; не будет. В &lt;code&gt;to_date&lt;/code&gt; , &lt;code&gt;to_number&lt;/code&gt; и &lt;code&gt;to_timestamp&lt;/code&gt; буквальный текст и строки в двойных кавычках приводят к пропуску количества символов, содержащихся в строке; например, &lt;code&gt;&quot;XX&quot;&lt;/code&gt; пропускает два входных символа (независимо от того, являются они &lt;code&gt;XX&lt;/code&gt; или нет ).</target>
        </trans-unit>
        <trans-unit id="47deb2333130b0b71a558b913d84907ec715a39c" translate="yes" xml:space="preserve">
          <source>Original UNIX crypt</source>
          <target state="translated">Оригинальный склеп UNIX</target>
        </trans-unit>
        <trans-unit id="728421f1a8e764e582012583a50320fee679ab3e" translate="yes" xml:space="preserve">
          <source>Original author: Gene Selkov, Jr. &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:selkovjr@mcs.anl.gov&quot;&gt;selkovjr@mcs.anl.gov&lt;/a&gt;&amp;gt;&lt;/code&gt;, Mathematics and Computer Science Division, Argonne National Laboratory.</source>
          <target state="translated">Первоначальный автор: Джин Сельков младший &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:selkovjr@mcs.anl.gov&quot;&gt;selkovjr@mcs.anl.gov&lt;/a&gt;&amp;gt;&lt;/code&gt; , Отдел математики и информатики, Аргоннская национальная лаборатория.</target>
        </trans-unit>
        <trans-unit id="15c3cbc7d90ec04ca02171128016ae7aa1d06c07" translate="yes" xml:space="preserve">
          <source>Original version by Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;. Rewritten in version 8.4 to suit new FSM implementation by Heikki Linnakangas &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Оригинальная версия &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt; Марком Кирквудом &amp;lt; markir@paradise.net.nz &amp;gt; . Переписано в версии 8.4 для соответствия новой реализации &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt;&amp;gt;&lt;/code&gt; Хейкки Линнакангас &amp;lt; heikki@enterprisedb.com &amp;gt;</target>
        </trans-unit>
        <trans-unit id="6c3f5ca5b9a803aee38134c4fbdc2dd67fcb8f9e" translate="yes" xml:space="preserve">
          <source>Other clients and libraries might provide their own mechanisms, via the shell or otherwise, that allow the user to alter session settings without direct use of SQL commands.</source>
          <target state="translated">Другие клиенты и библиотеки могут предоставлять свои собственные механизмы,через оболочку или иным образом,которые позволяют пользователю изменять настройки сессии без прямого использования команд SQL.</target>
        </trans-unit>
        <trans-unit id="1b025a6555e41ac8947f0005aa2f96a2fbcedc20" translate="yes" xml:space="preserve">
          <source>Other database systems might advance these values more frequently.</source>
          <target state="translated">Другие системы баз данных могли бы чаще продвигать эти значения.</target>
        </trans-unit>
        <trans-unit id="16dab4fb6d3b76123e52d90af3ba7c8bf6cdec38" translate="yes" xml:space="preserve">
          <source>Other dependency flavors might be needed in future.</source>
          <target state="translated">В будущем могут понадобиться и другие вкусы зависимости.</target>
        </trans-unit>
        <trans-unit id="d54e9e4d1cedbb61d73910e1c0331a6b34276e3c" translate="yes" xml:space="preserve">
          <source>Other dependency flavors might be needed in future. Note in particular that the current definition only supports roles as referenced objects.</source>
          <target state="translated">В будущем могут понадобиться и другие вкусы зависимости.Обратите внимание,в частности,что текущее определение поддерживает только роли как объекты,на которые есть ссылки.</target>
        </trans-unit>
        <trans-unit id="b090b2cc862f6eb58c39020ceea8daeedfe6f7b3" translate="yes" xml:space="preserve">
          <source>Other digest algorithms</source>
          <target state="translated">Другие алгоритмы дайджеста</target>
        </trans-unit>
        <trans-unit id="dd97a9c89af824879fb23956d987ca3355ff4cc8" translate="yes" xml:space="preserve">
          <source>Other libraries can also be preloaded. By preloading a shared library, the library startup time is avoided when the library is first used. However, the time to start each new server process might increase slightly, even if that process never uses the library. So this parameter is recommended only for libraries that will be used in most sessions. Also, changing this parameter requires a server restart, so this is not the right setting to use for short-term debugging tasks, say. Use &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; for that instead.</source>
          <target state="translated">Также можно предварительно загрузить другие библиотеки. Предварительная загрузка разделяемой библиотеки позволяет избежать времени запуска библиотеки при первом использовании библиотеки. Однако время запуска каждого нового серверного процесса может немного увеличиться, даже если этот процесс никогда не использует библиотеку. Поэтому этот параметр рекомендуется только для библиотек, которые будут использоваться в большинстве сеансов. Кроме того, изменение этого параметра требует перезапуска сервера, так что это не тот параметр, который, скажем, можно использовать для краткосрочных задач отладки. Вместо этого используйте &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c67ab500e2007fcfd325e1fcf258d410b75fddd" translate="yes" xml:space="preserve">
          <source>Other notes for &lt;code&gt;log_min_duration_statement&lt;/code&gt; apply also to this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b92deff69f1b0201e91466736d1490cd0ff7c6" translate="yes" xml:space="preserve">
          <source>Other object types, such as &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;roles&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-TABLESPACE&quot;&gt;tablespaces&lt;/a&gt;, replication origins, subscriptions for logical replication, and databases themselves are not local SQL objects since they exist entirely outside of any specific database; they are called &lt;em&gt;global objects&lt;/em&gt;. The names of such objects are enforced to be unique within the whole database cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6d149d1176a026cafb96a0f82667c8ba54a10c" translate="yes" xml:space="preserve">
          <source>Other options are also available:</source>
          <target state="translated">Также доступны и другие опции:</target>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="translated">Другие варианты:</target>
        </trans-unit>
        <trans-unit id="c97d8649180973af39b8407abdf8e46bf80d94a0" translate="yes" xml:space="preserve">
          <source>Other punctuation is ignored. So like &lt;code&gt;plainto_tsquery&lt;/code&gt; and &lt;code&gt;phraseto_tsquery&lt;/code&gt;, the &lt;code&gt;websearch_to_tsquery&lt;/code&gt; function will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da25b0d9d5dc45c67ed8cb3f27503780b4aa4443" translate="yes" xml:space="preserve">
          <source>Other recommended kernel setting changes for database servers which will have a large number of connections are:</source>
          <target state="translated">Другие рекомендуемые изменения в настройках ядра для серверов баз данных,которые будут иметь большое количество подключений:</target>
        </trans-unit>
        <trans-unit id="3903dba9afe98748981ae8bb62ee1e14b5b5b0bf" translate="yes" xml:space="preserve">
          <source>Other scan types, such as scans of non-btree indexes, may support parallel scans in the future.</source>
          <target state="translated">Другие типы сканирования,такие как сканирование несвободных индексов,могут поддерживать параллельное сканирование в будущем.</target>
        </trans-unit>
        <trans-unit id="c88c65d71407192da2177c969f1b4c3e1b24c5ec" translate="yes" xml:space="preserve">
          <source>Other systems may only allow setting the time source on boot. On older Linux systems the &quot;clock&quot; kernel setting is the only way to make this sort of change. And even on some more recent ones, the only option you'll see for a clock source is &quot;jiffies&quot;. Jiffies are the older Linux software clock implementation, which can have good resolution when it's backed by fast enough timing hardware, as in this example:</source>
          <target state="translated">Другие системы могут разрешать установку источника времени только при загрузке.На старых системах Linux настройка ядра &quot;часы&quot;-единственный способ сделать такие изменения.И даже на некоторых более свежих системах,единственный вариант,который вы увидите в исходном тексте часов-&quot;jiffies&quot;.Jiffies-это старая программная реализация часов Linux,которая может иметь хорошее разрешение,когда она поддерживается достаточно быстрым временем аппаратного обеспечения,как в этом примере:</target>
        </trans-unit>
        <trans-unit id="4a2d21cbb1de6f88a1dcf3d541f364a9e95c1127" translate="yes" xml:space="preserve">
          <source>Other than configuration of the negotiation behavior, GSSAPI encryption requires no setup beyond that which is necessary for GSSAPI authentication. (For more information on configuring that, see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt;.)</source>
          <target state="translated">Помимо настройки поведения согласования, шифрование GSSAPI не требует дополнительных настроек, кроме тех, которые необходимы для аутентификации GSSAPI. (Для получения дополнительной информации о настройке см. &lt;a href=&quot;gssapi-auth&quot;&gt;Раздел 20.6&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="d21779594b1e9934ec89f12215df7e04fc45898b" translate="yes" xml:space="preserve">
          <source>Other ways of looking at the statistics can be set up by writing queries that use the same underlying statistics access functions used by the standard views shown above. For details such as the functions' names, consult the definitions of the standard views. (For example, in psql you could issue &lt;code&gt;\d+ pg_stat_activity&lt;/code&gt;.) The access functions for per-database statistics take a database OID as an argument to identify which database to report on. The per-table and per-index functions take a table or index OID. The functions for per-function statistics take a function OID. Note that only tables, indexes, and functions in the current database can be seen with these functions.</source>
          <target state="translated">Можно настроить другие способы просмотра статистики, написав запросы, использующие те же базовые функции доступа к статистике, которые используются в стандартных представлениях, показанных выше. Для получения дополнительных сведений, таких как имена функций, обратитесь к определениям стандартных представлений. (Например, в psql вы можете выполнить &lt;code&gt;\d+ pg_stat_activity&lt;/code&gt; .) Функции доступа для статистики по каждой базе данных принимают OID базы данных в качестве аргумента, чтобы определить, по какой базе данных составлять отчет. Функции для таблиц и индексов принимают OID таблицы или индекса. Функции для статистики по функциям принимают OID функции. Обратите внимание, что с этими функциями можно увидеть только таблицы, индексы и функции в текущей базе данных.</target>
        </trans-unit>
        <trans-unit id="5209293ce5b675774d27db322f4e25b9f78fde50" translate="yes" xml:space="preserve">
          <source>Other, less commonly used, options are also available:</source>
          <target state="translated">Другие,менее распространенные варианты также доступны:</target>
        </trans-unit>
        <trans-unit id="86f791018da698782167efe67330f3a311425f18" translate="yes" xml:space="preserve">
          <source>Otherwise the date field ordering is assumed to follow the &lt;code&gt;DateStyle&lt;/code&gt; setting: mm-dd-yy, dd-mm-yy, or yy-mm-dd. Throw an error if a month or day field is found to be out of range.</source>
          <target state="translated">В противном случае предполагается, что &lt;code&gt;DateStyle&lt;/code&gt; настройке DateStyle : мм-дд-гг, дд-мм-гг или гг-мм-дд. Выдает ошибку, если поле месяца или дня оказывается вне допустимого диапазона.</target>
        </trans-unit>
        <trans-unit id="456174149b4fb59cccb0b858ebfab00191262c8b" translate="yes" xml:space="preserve">
          <source>Otherwise, all input expressions must have the same implicit collation derivation or the default collation. If any non-default collation is present, that is the result of the collation combination. Otherwise, the result is the default collation.</source>
          <target state="translated">В противном случае все входные выражения должны иметь одну и ту же неявную сверку или сверку по умолчанию.Если присутствует какая-либо комбинация не по умолчанию,то это результат комбинации.В противном случае результатом будет комбинация по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d7ebacc516a1689e9342c3f059955ce6038791c1" translate="yes" xml:space="preserve">
          <source>Otherwise, choose the last non-unknown input type that allows all the preceding non-unknown inputs to be implicitly converted to it. (There always is such a type, since at least the first type in the list must satisfy this condition.)</source>
          <target state="translated">В противном случае,выберите последний неизвестный тип входа,который позволяет неявно преобразовывать в него все предыдущие неизвестные входы.(Такой тип существует всегда,так как,по крайней мере,первый тип в списке должен удовлетворять этому условию).</target>
        </trans-unit>
        <trans-unit id="c834d57b171be985e3943329b0a6b22664e27dab" translate="yes" xml:space="preserve">
          <source>Otherwise, color is not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c2a604b8999f698fdb4a51e3a4309645319d17" translate="yes" xml:space="preserve">
          <source>Otherwise, if the JSON value is a string literal, the contents of the string are fed to the input conversion function for the column's data type.</source>
          <target state="translated">В противном случае,если значение JSON является строковым литералом,содержимое строки подается в входную функцию преобразования для типа данных столбца.</target>
        </trans-unit>
        <trans-unit id="8a7f14af2eabfd7eaf13755e5438dd8fa6b532ed" translate="yes" xml:space="preserve">
          <source>Otherwise, if the JSON value is a string, the contents of the string are fed to the input conversion function for the column's data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bead17837ca29580c9cb15e38f0a813be5d9242" translate="yes" xml:space="preserve">
          <source>Otherwise, the ordinary text representation of the JSON value is fed to the input conversion function for the column's data type.</source>
          <target state="translated">В противном случае обычное текстовое представление значения JSON подается на вход функции преобразования для типа данных столбца.</target>
        </trans-unit>
        <trans-unit id="c91502e459c401481e3ca0162bbcb613cfb57d2b" translate="yes" xml:space="preserve">
          <source>Otherwise, try to convert the expression to the target type. This is possible if an &lt;em&gt;assignment cast&lt;/em&gt; between the two types is registered in the &lt;code&gt;pg_cast&lt;/code&gt; catalog (see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;). Alternatively, if the expression is an unknown-type literal, the contents of the literal string will be fed to the input conversion routine for the target type.</source>
          <target state="translated">В противном случае попробуйте преобразовать выражение в целевой тип. Это возможно, если приведение &lt;em&gt;присваивания&lt;/em&gt; между двумя типами зарегистрировано в каталоге &lt;code&gt;pg_cast&lt;/code&gt; (см. &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt; ). В качестве альтернативы, если выражение является литералом неизвестного типа, содержимое строки литерала будет передано подпрограмме преобразования ввода для целевого типа.</target>
        </trans-unit>
        <trans-unit id="43c3af901aa493d7824a6ced3329413231661c11" translate="yes" xml:space="preserve">
          <source>Out-of-line values are divided (after compression if used) into chunks of at most &lt;code&gt;TOAST_MAX_CHUNK_SIZE&lt;/code&gt; bytes (by default this value is chosen so that four chunk rows will fit on a page, making it about 2000 bytes). Each chunk is stored as a separate row in the TOAST table belonging to the owning table. Every TOAST table has the columns &lt;code&gt;chunk_id&lt;/code&gt; (an OID identifying the particular TOASTed value), &lt;code&gt;chunk_seq&lt;/code&gt; (a sequence number for the chunk within its value), and &lt;code&gt;chunk_data&lt;/code&gt; (the actual data of the chunk). A unique index on &lt;code&gt;chunk_id&lt;/code&gt; and &lt;code&gt;chunk_seq&lt;/code&gt; provides fast retrieval of the values. A pointer datum representing an out-of-line on-disk TOASTed value therefore needs to store the OID of the TOAST table in which to look and the OID of the specific value (its &lt;code&gt;chunk_id&lt;/code&gt;). For convenience, pointer datums also store the logical datum size (original uncompressed data length) and physical stored size (different if compression was applied). Allowing for the varlena header bytes, the total size of an on-disk TOAST pointer datum is therefore 18 bytes regardless of the actual size of the represented value.</source>
          <target state="translated">&lt;code&gt;TOAST_MAX_CHUNK_SIZE&lt;/code&gt; значения делятся (после сжатия, если используется) на фрагменты размером не более TOAST_MAX_CHUNK_SIZE байтов (по умолчанию это значение выбрано таким образом, чтобы четыре строки фрагментов поместились на странице, что составляет около 2000 байтов). Каждый фрагмент хранится как отдельная строка в таблице TOAST, принадлежащей таблице-владельцу. Каждая таблица TOAST имеет столбцы &lt;code&gt;chunk_id&lt;/code&gt; (OID, идентифицирующий конкретное значение TOASTed), &lt;code&gt;chunk_seq&lt;/code&gt; (порядковый номер фрагмента внутри его значения) и &lt;code&gt;chunk_data&lt;/code&gt; (фактические данные фрагмента). Уникальный индекс для &lt;code&gt;chunk_id&lt;/code&gt; и &lt;code&gt;chunk_seq&lt;/code&gt; обеспечивает быстрый поиск значений. Таким образом, датум указателя, представляющий внешнее значение TOAST на диске, должен хранить OID таблицы TOAST, в которой нужно искать, и OID конкретного значения (его &lt;code&gt;chunk_id&lt;/code&gt; ). Для удобства датумы указателя также хранят размер логических данных (исходная длина несжатых данных) и физический размер сохраненных данных (отличается, если применялось сжатие). С учетом байтов заголовка varlena общий размер данных указателя TOAST на диске составляет 18 байтов независимо от фактического размера представленного значения.</target>
        </trans-unit>
        <trans-unit id="97c53cd2b521753c0d717a86dd39f58035793149" translate="yes" xml:space="preserve">
          <source>Output Length</source>
          <target state="translated">Выходная длина</target>
        </trans-unit>
        <trans-unit id="afe32b815eb6ac2d448375f1b337e892bc780a8c" translate="yes" xml:space="preserve">
          <source>Output Result</source>
          <target state="translated">Выходной результат</target>
        </trans-unit>
        <trans-unit id="a19289a8a65e3eaa1c70019f70d69f0ccdc7e3cc" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards compatible, but depending on the history of the objects in the dump, might not restore properly.</source>
          <target state="translated">Выведите стандартные команды &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; вместо команд &lt;code&gt;ALTER OWNER&lt;/code&gt; , чтобы определить владельца объекта. Это делает дамп более совместимым со стандартами, но в зависимости от истории объектов в дампе может не восстанавливаться должным образом.</target>
        </trans-unit>
        <trans-unit id="8d49ccd8d61f0c2e0d773215d12c820e621fe051" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards-compatible, but depending on the history of the objects in the dump, might not restore properly.</source>
          <target state="translated">Выведите стандартные команды &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; вместо команд &lt;code&gt;ALTER OWNER&lt;/code&gt; , чтобы определить владельца объекта. Это делает дамп более совместимым со стандартами, но в зависимости от истории объектов в дампе может не восстанавливаться должным образом.</target>
        </trans-unit>
        <trans-unit id="4625db4629522bcdf0c7c483ff44db087396b6a5" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards-compatible, but depending on the history of the objects in the dump, might not restore properly. Also, a dump using &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; will certainly require superuser privileges to restore correctly, whereas &lt;code&gt;ALTER OWNER&lt;/code&gt; requires lesser privileges.</source>
          <target state="translated">Выведите стандартные команды &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; вместо команд &lt;code&gt;ALTER OWNER&lt;/code&gt; , чтобы определить владельца объекта. Это делает дамп более совместимым со стандартами, но в зависимости от истории объектов в дампе может не восстанавливаться должным образом. Кроме того, дамп с использованием &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; определенно потребует прав суперпользователя для правильного восстановления, тогда как &lt;code&gt;ALTER OWNER&lt;/code&gt; требует меньших прав.</target>
        </trans-unit>
        <trans-unit id="2005b7d907d65c19aff7a047dfc1b1dcc52ef1ca" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;tar&lt;/code&gt;-format archive suitable for input into pg_restore. The tar format is compatible with the directory format: extracting a tar-format archive produces a valid directory-format archive. However, the tar format does not support compression. Also, when using tar format the relative order of table data items cannot be changed during restore.</source>
          <target state="translated">Выведите архив в формате &lt;code&gt;tar&lt;/code&gt; , подходящий для ввода в pg_restore. Формат tar совместим с форматом каталогов: при распаковке архива в формате tar получается действительный архив в формате каталога. Однако формат tar не поддерживает сжатие. Кроме того, при использовании формата tar относительный порядок элементов данных таблицы не может быть изменен во время восстановления.</target>
        </trans-unit>
        <trans-unit id="2eb830dc0187c951bb3c38e2fc9ae11b3f83d2a4" translate="yes" xml:space="preserve">
          <source>Output a custom-format archive suitable for input into pg_restore. Together with the directory output format, this is the most flexible output format in that it allows manual selection and reordering of archived items during restore. This format is also compressed by default.</source>
          <target state="translated">Вывести пользовательский формат архива,подходящий для ввода в pg_restore.Вместе с форматом вывода каталога это наиболее гибкий формат вывода,поскольку он позволяет вручную выбирать и переупорядочивать архивированные элементы при восстановлении.По умолчанию этот формат также сжимается.</target>
        </trans-unit>
        <trans-unit id="314bcb0a58dea88f5b77ecfb141e26b87d6cd0bf" translate="yes" xml:space="preserve">
          <source>Output a directory-format archive suitable for input into pg_restore. This will create a directory with one file for each table and blob being dumped, plus a so-called Table of Contents file describing the dumped objects in a machine-readable format that pg_restore can read. A directory format archive can be manipulated with standard Unix tools; for example, files in an uncompressed archive can be compressed with the gzip tool. This format is compressed by default and also supports parallel dumps.</source>
          <target state="translated">Выведите архив в формате каталога,подходящий для ввода в pg_restore.При этом будет создан каталог с одним файлом для каждой таблицы и блоба,а также так называемый файл Содержания,описывающий выбрасываемые объекты в машиночитаемом формате,который может быть прочитан pg_restore.Архивом формата каталога можно манипулировать с помощью стандартных инструментов Unix;например,файлы в несжатом архиве можно сжимать с помощью инструмента gzip.Этот формат сжимается по умолчанию и также поддерживает параллельные дампы.</target>
        </trans-unit>
        <trans-unit id="9af173b4747fa54411d828576f57ede6b623e6c6" translate="yes" xml:space="preserve">
          <source>Output a plain-text SQL script file (the default).</source>
          <target state="translated">Вывод простого текстового файла SQL-скрипта (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="8bdf0890d1e63cc1cfc92f91594ac95c633ba722" translate="yes" xml:space="preserve">
          <source>Output commands to clean (drop) database objects prior to outputting the commands for creating them. (Unless &lt;code&gt;--if-exists&lt;/code&gt; is also specified, restore might generate some harmless error messages, if any objects were not present in the destination database.)</source>
          <target state="translated">Команды вывода для очистки (удаления) объектов базы данных перед выводом команд для их создания. (Если также не указан параметр &lt;code&gt;--if-exists&lt;/code&gt; , при восстановлении могут генерироваться безобидные сообщения об ошибках, если какие-либо объекты не присутствуют в целевой базе данных.)</target>
        </trans-unit>
        <trans-unit id="48cd5d324665dcd708893b4a104e4fb4fecb1e8f" translate="yes" xml:space="preserve">
          <source>Output conversion function (binary format), or 0 if none</source>
          <target state="translated">Выходная функция преобразования (двоичный формат),или 0,если нет.</target>
        </trans-unit>
        <trans-unit id="3bc8730df1e12ab656e0ea8398920726728cdbcd" translate="yes" xml:space="preserve">
          <source>Output conversion function (text format)</source>
          <target state="translated">Выходная функция преобразования (текстовый формат)</target>
        </trans-unit>
        <trans-unit id="2d850ce6c63d0f20826daa05520cced6f2083334" translate="yes" xml:space="preserve">
          <source>Output detailed information about backup blocks.</source>
          <target state="translated">Выводит подробную информацию о резервных блоках.</target>
        </trans-unit>
        <trans-unit id="babad7640e9f136cd19423d495f4b1ee0fee89a9" translate="yes" xml:space="preserve">
          <source>Output is always in the standard form.</source>
          <target state="translated">Выход всегда в стандартной форме.</target>
        </trans-unit>
        <trans-unit id="7835db447bc76230b5b0d736b2d78c671d7100a1" translate="yes" xml:space="preserve">
          <source>Outputs</source>
          <target state="translated">Outputs</target>
        </trans-unit>
        <trans-unit id="cdfe59de620bc8ec7ec39dbaf869451006fe122e" translate="yes" xml:space="preserve">
          <source>Outputs information about the current database connection.</source>
          <target state="translated">Выводит информацию о текущем подключении к базе данных.</target>
        </trans-unit>
        <trans-unit id="a3ae7cd3ba4b5d3440099a3b3e44c0885cc411f2" translate="yes" xml:space="preserve">
          <source>Overlaps or is left of &amp;mdash; This might be better read as &amp;ldquo;does not extend to right of&amp;rdquo;. It is true when b &amp;lt;= d.</source>
          <target state="translated">Перекрывается или находится слева - это лучше читать как &amp;laquo;не простирается вправо&amp;raquo;. Верно, когда b &amp;lt;= d.</target>
        </trans-unit>
        <trans-unit id="e3d201e01172e474738c7662f57e70ca764bc088" translate="yes" xml:space="preserve">
          <source>Overlaps or is right of &amp;mdash; This might be better read as &amp;ldquo;does not extend to left of&amp;rdquo;. It is true when a &amp;gt;= c.</source>
          <target state="translated">Перекрывается или находится справа - это лучше читать как &amp;laquo;не простирается слева от&amp;raquo;. Верно, когда a&amp;gt; = c.</target>
        </trans-unit>
        <trans-unit id="7af34d74e482413c9143a47da7e672969aed843a" translate="yes" xml:space="preserve">
          <source>Overlaps? (One point in common makes this true.)</source>
          <target state="translated">Перекрытия? (Один общий пункт делает это правдой.)</target>
        </trans-unit>
        <trans-unit id="cb2f163ccc20cb7388203cf1edbc6860b44ea0f0" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Overloading</target>
        </trans-unit>
        <trans-unit id="a2fd113f354ec9ec1edb291682b81f94fe430ddc" translate="yes" xml:space="preserve">
          <source>Owner of the collation</source>
          <target state="translated">Владелец сопоставления</target>
        </trans-unit>
        <trans-unit id="b7eb54933c030e119dce1086dc82e09c41077f94" translate="yes" xml:space="preserve">
          <source>Owner of the configuration</source>
          <target state="translated">Владелец конфигурации</target>
        </trans-unit>
        <trans-unit id="a47511340c90f2c223a36694793ee22b0651e345" translate="yes" xml:space="preserve">
          <source>Owner of the conversion</source>
          <target state="translated">Владелец конверсии</target>
        </trans-unit>
        <trans-unit id="9adb637b26bc7a0111112afdc905c0fa9b433b1f" translate="yes" xml:space="preserve">
          <source>Owner of the database, usually the user who created it</source>
          <target state="translated">Владелец базы данных,обычно пользователь,который ее создал.</target>
        </trans-unit>
        <trans-unit id="1e1395f6076a153ad4fcc55b23348741788d9a0e" translate="yes" xml:space="preserve">
          <source>Owner of the dictionary</source>
          <target state="translated">Владелец словаря</target>
        </trans-unit>
        <trans-unit id="873852f61944660a0d123bafc40c1182f58cd2a5" translate="yes" xml:space="preserve">
          <source>Owner of the event trigger</source>
          <target state="translated">Владелец триггера события</target>
        </trans-unit>
        <trans-unit id="e618675166fd8eccc064277b88953a8fdc0951cf" translate="yes" xml:space="preserve">
          <source>Owner of the extended statistics</source>
          <target state="translated">Владелец расширенной статистики</target>
        </trans-unit>
        <trans-unit id="0e0062122acfc3428eb36e8494aa91cdda1bb823" translate="yes" xml:space="preserve">
          <source>Owner of the extension</source>
          <target state="translated">Владелец пристройки</target>
        </trans-unit>
        <trans-unit id="1b3fd58bbcd1cbede99d727eb332a616ef746459" translate="yes" xml:space="preserve">
          <source>Owner of the foreign server</source>
          <target state="translated">Владелец иностранного сервера</target>
        </trans-unit>
        <trans-unit id="4abeec384f4e4e4fd2630496e361931c03792e90" translate="yes" xml:space="preserve">
          <source>Owner of the foreign-data wrapper</source>
          <target state="translated">Владелец обёртки с иностранными данными.</target>
        </trans-unit>
        <trans-unit id="045ebe36026cc33372375251adb04267dd08a6f9" translate="yes" xml:space="preserve">
          <source>Owner of the function</source>
          <target state="translated">Владелец функции</target>
        </trans-unit>
        <trans-unit id="3de3b296802701c83666e4a9e6c77ad8e092b09c" translate="yes" xml:space="preserve">
          <source>Owner of the language</source>
          <target state="translated">Владелец языка</target>
        </trans-unit>
        <trans-unit id="5f358242f17294414495cbc231ac35ed8a7ef36f" translate="yes" xml:space="preserve">
          <source>Owner of the large object</source>
          <target state="translated">Владелец крупного объекта</target>
        </trans-unit>
        <trans-unit id="08c133834660a3f3265245c9248f60f1979449d5" translate="yes" xml:space="preserve">
          <source>Owner of the namespace</source>
          <target state="translated">Владелец пространства имён</target>
        </trans-unit>
        <trans-unit id="f3d409145414a207ad5ab1a06298cf4de3e3d79d" translate="yes" xml:space="preserve">
          <source>Owner of the operator</source>
          <target state="translated">Владелец оператора</target>
        </trans-unit>
        <trans-unit id="4fe1d02890b80f29d14de9cf7c7d720b98ec4436" translate="yes" xml:space="preserve">
          <source>Owner of the operator class</source>
          <target state="translated">Владелец класса оператора</target>
        </trans-unit>
        <trans-unit id="34a092b8bf19aa76f83af3f5f7f00fd4abe9f1da" translate="yes" xml:space="preserve">
          <source>Owner of the operator family</source>
          <target state="translated">Владелец семьи операторов</target>
        </trans-unit>
        <trans-unit id="530840c2bedf8afbc58ec145a817bd5855b5da2c" translate="yes" xml:space="preserve">
          <source>Owner of the publication</source>
          <target state="translated">Владелец публикации</target>
        </trans-unit>
        <trans-unit id="f104f465825a18941861fe36eee16972af35d0fd" translate="yes" xml:space="preserve">
          <source>Owner of the relation</source>
          <target state="translated">Владелец отношения</target>
        </trans-unit>
        <trans-unit id="d2d338d2c9f46fc9058acd6bf8b505d62cfd7125" translate="yes" xml:space="preserve">
          <source>Owner of the statistics object</source>
          <target state="translated">Владелец объекта статистики</target>
        </trans-unit>
        <trans-unit id="27aa59e6a53863d7fc75c728e631589d9ef875ce" translate="yes" xml:space="preserve">
          <source>Owner of the subscription</source>
          <target state="translated">Владелец подписки</target>
        </trans-unit>
        <trans-unit id="3ca261d2ecfb68a9f64ba043ec469131179f4f2d" translate="yes" xml:space="preserve">
          <source>Owner of the tablespace, usually the user who created it</source>
          <target state="translated">Владелец табличного пространства,обычно пользователь,который его создал.</target>
        </trans-unit>
        <trans-unit id="451938c2f2732dd84e3e87dd05cdd4be024d9498" translate="yes" xml:space="preserve">
          <source>Owner of the type</source>
          <target state="translated">Владелец типа</target>
        </trans-unit>
        <trans-unit id="7a88ac00bf4b0ee2c311712a067ae74712fb2321" translate="yes" xml:space="preserve">
          <source>Ownership of objects can be transferred one at a time using &lt;code&gt;ALTER&lt;/code&gt; commands, for example:</source>
          <target state="translated">Право собственности на объекты можно передавать по одному с помощью команд &lt;code&gt;ALTER&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="880684f9ec2b7a622ac555da2f5f06938c962c51" translate="yes" xml:space="preserve">
          <source>P''(t)</source>
          <target state="translated">P''(t)</target>
        </trans-unit>
        <trans-unit id="6c4b4caa40b248d284230f88cbcd7f13476b2cac" translate="yes" xml:space="preserve">
          <source>P(t)</source>
          <target state="translated">P(t)</target>
        </trans-unit>
        <trans-unit id="f8475eae73fea7de999190d28ead30c11cd46b3b" translate="yes" xml:space="preserve">
          <source>P-1Y-2M3DT-4H-5M-6S</source>
          <target state="translated">P-1Y-2M3DT-4H-5M-6S</target>
        </trans-unit>
        <trans-unit id="637e5ac0a44e83d198f6482aad52a4ee2c33076a" translate="yes" xml:space="preserve">
          <source>P-1Y-2M3D​T-4H-5M-6S</source>
          <target state="translated">P-1Y-2M3D​T-4H-5M-6S</target>
        </trans-unit>
        <trans-unit id="c066b74bc2c03f3472bba6e63d39e90c2e2d20c7" translate="yes" xml:space="preserve">
          <source>P0001-02-03T04:05:06</source>
          <target state="translated">P0001-02-03T04:05:06</target>
        </trans-unit>
        <trans-unit id="579e8ed8bf53a5860299c4787471ee73ec431b5e" translate="yes" xml:space="preserve">
          <source>P1Y2M</source>
          <target state="translated">P1Y2M</target>
        </trans-unit>
        <trans-unit id="bd1aaf321a587301c665f6a19e72881af023a930" translate="yes" xml:space="preserve">
          <source>P1Y2M3DT4H5M6S</source>
          <target state="translated">P1Y2M3DT4H5M6S</target>
        </trans-unit>
        <trans-unit id="9ba0b6685e5baca573f3acd95f81a092797985f3" translate="yes" xml:space="preserve">
          <source>P3DT4H5M6S</source>
          <target state="translated">P3DT4H5M6S</target>
        </trans-unit>
        <trans-unit id="1dc752ba52c4ea05107706b7e03df6ab354e39ff" translate="yes" xml:space="preserve">
          <source>PAM</source>
          <target state="translated">PAM</target>
        </trans-unit>
        <trans-unit id="388c2af7f59c6eee722356ebc329cec67a8389d7" translate="yes" xml:space="preserve">
          <source>PAM Authentication</source>
          <target state="translated">PAM-аутентификация</target>
        </trans-unit>
        <trans-unit id="9e8eaf2f87853067037437397fcd30a4aa337b20" translate="yes" xml:space="preserve">
          <source>PAM service name.</source>
          <target state="translated">Имя сервиса PAM.</target>
        </trans-unit>
        <trans-unit id="0bfd8f66160aa4b77dcdec5d43e4805495e07e18" translate="yes" xml:space="preserve">
          <source>PGP Public-Key encryption</source>
          <target state="translated">PGP шифрование с открытым ключом</target>
        </trans-unit>
        <trans-unit id="76646f05da6bf5eb4fecf712e1a4c9bffc428604" translate="yes" xml:space="preserve">
          <source>PGP Symmetric encryption</source>
          <target state="translated">симметричное шифрование PGP</target>
        </trans-unit>
        <trans-unit id="4e09cf6b34360609cb4cdd2c5b437e8b7854a05d" translate="yes" xml:space="preserve">
          <source>PGSQL</source>
          <target state="translated">PGSQL</target>
        </trans-unit>
        <trans-unit id="3ba27c9c3666ed10b53aa3320fe270149336d75a" translate="yes" xml:space="preserve">
          <source>PGXS</source>
          <target state="translated">PGXS</target>
        </trans-unit>
        <trans-unit id="dde57e820d65c87a0777da46aba7cd35a0c8436a" translate="yes" xml:space="preserve">
          <source>PID</source>
          <target state="translated">PID</target>
        </trans-unit>
        <trans-unit id="feee1d9b13144a255359aea6e303897e613b068c" translate="yes" xml:space="preserve">
          <source>PITR</source>
          <target state="translated">PITR</target>
        </trans-unit>
        <trans-unit id="3238a2c23ec52b54d1a9d62034bcdec3628b7db6" translate="yes" xml:space="preserve">
          <source>PL</source>
          <target state="translated">PL</target>
        </trans-unit>
        <trans-unit id="beec5d503ed58c40992ce7fab4af575b48a55538" translate="yes" xml:space="preserve">
          <source>PL/pgSQL handles output parameters in &lt;code&gt;CALL&lt;/code&gt; commands differently; see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;Section 42.6.3&lt;/a&gt;.</source>
          <target state="translated">PL / pgSQL по- разному обрабатывает выходные параметры в командах &lt;code&gt;CALL&lt;/code&gt; ; см. &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;Раздел 42.6.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17b76a5d14c8b2c49a6ac06895875148d89695c0" translate="yes" xml:space="preserve">
          <source>PL/pgSQL handles output parameters in &lt;code&gt;CALL&lt;/code&gt; commands differently; see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;Section 42.6.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23507e798d66fee0b05313c2a15e15ff93e82f20" translate="yes" xml:space="preserve">
          <source>POSIX</source>
          <target state="translated">POSIX</target>
        </trans-unit>
        <trans-unit id="4e03c943de4a471ff8d7eb0aea61351231577229" translate="yes" xml:space="preserve">
          <source>POSIX Time Zone Specifications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f586c4a0642bd8530bd206b6d1e6d9b7d935f68f" translate="yes" xml:space="preserve">
          <source>POSIX interprets character classes such as &lt;code&gt;\w&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;) according to the prevailing locale (which you can control by attaching a &lt;code&gt;COLLATE&lt;/code&gt; clause to the operator or function). XQuery specifies these classes by reference to Unicode character properties, so equivalent behavior is obtained only with a locale that follows the Unicode rules.</source>
          <target state="translated">POSIX интерпретирует классы символов, такие как &lt;code&gt;\w&lt;/code&gt; (см. &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Таблицу 9.20&lt;/a&gt; ), в соответствии с преобладающей локалью (которой вы можете управлять, &lt;code&gt;COLLATE&lt;/code&gt; предложение COLLATE к оператору или функции). XQuery определяет эти классы посредством ссылки на свойства символов Юникода, поэтому эквивалентное поведение достигается только с локалью, которая следует правилам Юникода.</target>
        </trans-unit>
        <trans-unit id="63465644013ae752eee8a21083fea8ac69dc57b1" translate="yes" xml:space="preserve">
          <source>POSIX interprets character classes such as &lt;code&gt;\w&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;) according to the prevailing locale (which you can control by attaching a &lt;code&gt;COLLATE&lt;/code&gt; clause to the operator or function). XQuery specifies these classes by reference to Unicode character properties, so equivalent behavior is obtained only with a locale that follows the Unicode rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e102feaa5742be5a0f3d3fc50f40fceae7d340a6" translate="yes" xml:space="preserve">
          <source>POSIX regular expressions provide a more powerful means for pattern matching than the &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;SIMILAR TO&lt;/code&gt; operators. Many Unix tools such as &lt;code&gt;egrep&lt;/code&gt;, &lt;code&gt;sed&lt;/code&gt;, or &lt;code&gt;awk&lt;/code&gt; use a pattern matching language that is similar to the one described here.</source>
          <target state="translated">Регулярные выражения POSIX предоставляют более мощные средства сопоставления с образцом, чем операторы &lt;code&gt;LIKE&lt;/code&gt; и &lt;code&gt;SIMILAR TO&lt;/code&gt; . Многие инструменты Unix, такие как &lt;code&gt;egrep&lt;/code&gt; , &lt;code&gt;sed&lt;/code&gt; или &lt;code&gt;awk&lt;/code&gt; , используют язык сопоставления с образцом, аналогичный описанному здесь.</target>
        </trans-unit>
        <trans-unit id="46e0e2f3d2a15c3b14b95e0c1c7504bef70da246" translate="yes" xml:space="preserve">
          <source>POSIX-style time zone specification</source>
          <target state="translated">спецификация часового пояса в стиле POSIX</target>
        </trans-unit>
        <trans-unit id="66e2f96d2e144c19219f34885e8aed66af8ec26f" translate="yes" xml:space="preserve">
          <source>PREPARE</source>
          <target state="translated">PREPARE</target>
        </trans-unit>
        <trans-unit id="497f657a7bd6c59491c1afe2f14778a0325e0aeb" translate="yes" xml:space="preserve">
          <source>PREPARE &amp;mdash; prepare a statement for execution</source>
          <target state="translated">PREPARE - подготовить заявление к исполнению</target>
        </trans-unit>
        <trans-unit id="37fb488fc1130c92529c23ebb00239237637a743" translate="yes" xml:space="preserve">
          <source>PREPARE TRANSACTION</source>
          <target state="translated">ГОТОВИТЬ СДЕЛКУ</target>
        </trans-unit>
        <trans-unit id="a6c4ba5ff6212b5c43bdc5722e0f091244559eda" translate="yes" xml:space="preserve">
          <source>PREPARE TRANSACTION &amp;mdash; prepare the current transaction for two-phase commit</source>
          <target state="translated">PREPARE TRANSACTION - подготовить текущую транзакцию к двухфазной фиксации</target>
        </trans-unit>
        <trans-unit id="5ddcb3afaebc491f73714dc172d37266e6be3bda" translate="yes" xml:space="preserve">
          <source>Packaging and deployment scripts should be careful to create the &lt;code&gt;postgres&lt;/code&gt; user as a system user by using &lt;code&gt;useradd -r&lt;/code&gt;, &lt;code&gt;adduser --system&lt;/code&gt;, or equivalent.</source>
          <target state="translated">Сценарии упаковки и развертывания должны быть осторожны, чтобы создать пользователя &lt;code&gt;postgres&lt;/code&gt; как системного пользователя, используя &lt;code&gt;useradd -r&lt;/code&gt; , &lt;code&gt;adduser --system&lt;/code&gt; или аналогичные.</target>
        </trans-unit>
        <trans-unit id="a10c2d221e8eba42e9b331576d9daca086bdfe95" translate="yes" xml:space="preserve">
          <source>Packet containing a session key &amp;mdash; either symmetric-key or public-key encrypted.</source>
          <target state="translated">Пакет, содержащий сеансовый ключ - зашифрованный с симметричным или открытым ключом.</target>
        </trans-unit>
        <trans-unit id="fe9ad910809dee7861d17df7e5f096ed938e0ab2" translate="yes" xml:space="preserve">
          <source>Packet containing data encrypted with the session key.</source>
          <target state="translated">Пакет,содержащий данные,зашифрованные ключом сеанса.</target>
        </trans-unit>
        <trans-unit id="5dd9f751429eb18847bb4ae66caf8a2fda2b0c20" translate="yes" xml:space="preserve">
          <source>Page checksum</source>
          <target state="translated">Контрольная сумма страницы</target>
        </trans-unit>
        <trans-unit id="10d741089ed07914a82a77ba0b90a6a76cd492d4" translate="yes" xml:space="preserve">
          <source>Page number of this page within its large object (counting from zero)</source>
          <target state="translated">Номер страницы этой страницы в ее большом объекте (отсчитывается от нуля)</target>
        </trans-unit>
        <trans-unit id="fc5666da83404ee33adbe94f98f1c6ba4503d3c8" translate="yes" xml:space="preserve">
          <source>Page number targeted by the lock within the relation, or null if the target is not a relation page or tuple</source>
          <target state="translated">Номер страницы,на которую нацелен замок внутри отношения,или ноль,если цель не является страницей отношения или кортежом</target>
        </trans-unit>
        <trans-unit id="05fe9679957eb1665689044c2d47f231b7b99aa3" translate="yes" xml:space="preserve">
          <source>Page number within the relation</source>
          <target state="translated">Номер страницы в соотношении</target>
        </trans-unit>
        <trans-unit id="2b355a7b15353314735e75b8e122c5ae1fcd5a22" translate="yes" xml:space="preserve">
          <source>Page size and layout version number information</source>
          <target state="translated">Размер страницы и номер версии макета</target>
        </trans-unit>
        <trans-unit id="a03c41b78d25bf18f06cd333e2c95e267c66a660" translate="yes" xml:space="preserve">
          <source>PageHeaderData</source>
          <target state="translated">PageHeaderData</target>
        </trans-unit>
        <trans-unit id="2750093ba2a279af4331fd53d0a8cee7be245d4f" translate="yes" xml:space="preserve">
          <source>PageXLogRecPtr</source>
          <target state="translated">PageXLogRecPtr</target>
        </trans-unit>
        <trans-unit id="d90de0896be6c5efa3c782fa286f1c3cdb9a7b50" translate="yes" xml:space="preserve">
          <source>Parallel Plans</source>
          <target state="translated">Параллельные планы</target>
        </trans-unit>
        <trans-unit id="686414fccc150dceb0e9f56ace196fdc729a14bb" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Aggregation</source>
          <target state="translated">Параллельные планы:Параллельная агрегация</target>
        </trans-unit>
        <trans-unit id="b75e7cdb23627ee4086ddf3246e9c894f0ce11d0" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Append</source>
          <target state="translated">Параллельные планы:Параллельное приложение</target>
        </trans-unit>
        <trans-unit id="976b16b543b8304722b64b1a24c59b4c0b79488f" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Joins</source>
          <target state="translated">Параллельные планы:Параллельные соединения</target>
        </trans-unit>
        <trans-unit id="9010e7d56024ae4a3d31f2d2290191dd0b36e537" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Plan Tips</source>
          <target state="translated">Параллельные планы:Советы по параллельным планам</target>
        </trans-unit>
        <trans-unit id="039109d587d0e62745986a2cf6f26a04992e1351" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Scans</source>
          <target state="translated">Параллельные планы:Параллельное сканирование</target>
        </trans-unit>
        <trans-unit id="cfafb44924e6a5f388ef259a64814a132f966833" translate="yes" xml:space="preserve">
          <source>Parallel Query</source>
          <target state="translated">Параллельный запрос</target>
        </trans-unit>
        <trans-unit id="82124baa3b5560bbd5720a4765dc2466961bc53a" translate="yes" xml:space="preserve">
          <source>Parallel Safety</source>
          <target state="translated">Параллельная безопасность</target>
        </trans-unit>
        <trans-unit id="0fe56d7979154496310d56ea233bf1c11643ddc4" translate="yes" xml:space="preserve">
          <source>Parallel Safety: Parallel Labeling for Functions and Aggregates</source>
          <target state="translated">Параллельная безопасность:Маркировка параллелей для функций и агрегатов</target>
        </trans-unit>
        <trans-unit id="5ab3e8fa2d7856e75083b2a36c41793361958622" translate="yes" xml:space="preserve">
          <source>Parallel aggregation is not supported in all situations. Each aggregate must be &lt;a href=&quot;parallel-safety&quot;&gt;safe&lt;/a&gt; for parallelism and must have a combine function. If the aggregate has a transition state of type &lt;code&gt;internal&lt;/code&gt;, it must have serialization and deserialization functions. See &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; for more details. Parallel aggregation is not supported if any aggregate function call contains &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; clause and is also not supported for ordered set aggregates or when the query involves &lt;code&gt;GROUPING SETS&lt;/code&gt;. It can only be used when all joins involved in the query are also part of the parallel portion of the plan.</source>
          <target state="translated">Параллельное агрегирование поддерживается не во всех ситуациях. Каждый агрегат должен быть &lt;a href=&quot;parallel-safety&quot;&gt;безопасным&lt;/a&gt; для параллелизма и иметь функцию комбинирования. Если агрегат имеет переходное состояние типа &lt;code&gt;internal&lt;/code&gt; , он должен иметь функции сериализации и десериализации. См. &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; для более подробной информации. Параллельное агрегирование не поддерживается, если какой-либо вызов агрегатной функции содержит предложение &lt;code&gt;DISTINCT&lt;/code&gt; или &lt;code&gt;ORDER BY&lt;/code&gt; , а также не поддерживается для агрегатов упорядоченного набора или когда запрос включает &lt;code&gt;GROUPING SETS&lt;/code&gt; . Его можно использовать только в том случае, если все соединения, участвующие в запросе, также являются частью параллельной части плана.</target>
        </trans-unit>
        <trans-unit id="04d6d9331b5a5aaad9590228fe97b2a4cfe26295" translate="yes" xml:space="preserve">
          <source>Parallel index builds may benefit from increasing &lt;code&gt;maintenance_work_mem&lt;/code&gt; where an equivalent serial index build will see little or no benefit. Note that &lt;code&gt;maintenance_work_mem&lt;/code&gt; may influence the number of worker processes requested, since parallel workers must have at least a &lt;code&gt;32MB&lt;/code&gt; share of the total &lt;code&gt;maintenance_work_mem&lt;/code&gt; budget. There must also be a remaining &lt;code&gt;32MB&lt;/code&gt; share for the leader process. Increasing &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt; may allow more workers to be used, which will reduce the time needed for index creation, so long as the index build is not already I/O bound. Of course, there should also be sufficient CPU capacity that would otherwise lie idle.</source>
          <target state="translated">Построение параллельного индекса может выиграть от увеличения значения &lt;code&gt;maintenance_work_mem&lt;/code&gt; , когда эквивалентное построение последовательного индекса принесет мало пользы или не принесет никакой пользы. Обратите внимание, что &lt;code&gt;maintenance_work_mem&lt;/code&gt; может влиять на количество запрошенных рабочих процессов, поскольку параллельные рабочие должны иметь по крайней мере &lt;code&gt;32MB&lt;/code&gt; доли от общего бюджета &lt;code&gt;maintenance_work_mem&lt;/code&gt; . Также должны быть оставшиеся &lt;code&gt;32MB&lt;/code&gt; для процесса лидера. Увеличение &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_main maintenance_workers&lt;/a&gt; может позволить использовать больше воркеров , что сократит время, необходимое для создания индекса, если построение индекса еще не привязано к вводу-выводу. Конечно, также должна быть достаточная мощность процессора, которая в противном случае простаивала бы.</target>
        </trans-unit>
        <trans-unit id="8d1ebc235cfc864b875140b5812bbbb72ec9bf92" translate="yes" xml:space="preserve">
          <source>Parallel query</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="09be2449f5c7874ea156950916c870b9f0c9269d" translate="yes" xml:space="preserve">
          <source>Parameter type (&lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">Тип параметра ( &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;real&lt;/code&gt; или &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="044b6f8bb6500f64950a5a00b3fc891db56006e8" translate="yes" xml:space="preserve">
          <source>Parameter value assumed at server startup if the parameter is not otherwise set</source>
          <target state="translated">Значение параметра,принятое при вводе сервера в эксплуатацию,если параметр не установлен иным образом.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="2f389ed6f97b68ab045fe7feae01a113660deba4" translate="yes" xml:space="preserve">
          <source>Parameters - &lt;code&gt;SHOW&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, &lt;code&gt;RESET&lt;/code&gt;</source>
          <target state="translated">Параметры - &lt;code&gt;SHOW&lt;/code&gt; , &lt;code&gt;SET&lt;/code&gt; , &lt;code&gt;RESET&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d605d3acb20f72158d3fdf0384d4816df27da77" translate="yes" xml:space="preserve">
          <source>Parameters set in this way provide default values for the cluster. The settings seen by active sessions will be these values unless they are overridden. The following sections describe ways in which the administrator or user can override these defaults.</source>
          <target state="translated">Параметры,установленные таким образом,предоставляют значения по умолчанию для кластера.Параметры,видимые активными сессиями,будут этими значениями,если только они не будут переопределены.Следующие разделы описывают способы,с помощью которых администратор или пользователь могут переопределить эти значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b9f24c90be4904850b86a1b21d3ff1448827c68d" translate="yes" xml:space="preserve">
          <source>Parent trigger that this trigger is cloned from, zero if not a clone; this happens when partitions are created or attached to a partitioned table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c46bf34fcbc732066fd8d85a736b2f71975d85" translate="yes" xml:space="preserve">
          <source>Parentheses (&lt;code&gt;()&lt;/code&gt;) have their usual meaning to group expressions and enforce precedence. In some cases parentheses are required as part of the fixed syntax of a particular SQL command.</source>
          <target state="translated">Круглые скобки ( &lt;code&gt;()&lt;/code&gt; ) имеют обычное значение для группировки выражений и обеспечения приоритета. В некоторых случаях круглые скобки требуются как часть фиксированного синтаксиса конкретной команды SQL.</target>
        </trans-unit>
        <trans-unit id="98e95b8350c1e439f335fb041362e108a0725712" translate="yes" xml:space="preserve">
          <source>Parentheses &lt;code&gt;()&lt;/code&gt; can be used to group items into a single logical item.</source>
          <target state="translated">Круглые скобки &lt;code&gt;()&lt;/code&gt; можно использовать для группировки элементов в один логический элемент.</target>
        </trans-unit>
        <trans-unit id="6bd6d9306fafc7f371b0f3c8451bd6a999eda172" translate="yes" xml:space="preserve">
          <source>Parentheses are used to resolve ambiguities. In the following example, the first statement assigns the alias &lt;code&gt;b&lt;/code&gt; to the second instance of &lt;code&gt;my_table&lt;/code&gt;, but the second statement assigns the alias to the result of the join:</source>
          <target state="translated">Круглые скобки используются для устранения двусмысленностей. В следующем примере первая инструкция назначает псевдоним &lt;code&gt;b&lt;/code&gt; второму экземпляру &lt;code&gt;my_table&lt;/code&gt; , но вторая инструкция присваивает псевдоним результату соединения:</target>
        </trans-unit>
        <trans-unit id="8a18942798320d682a81a99742ced66e1f7dcd4f" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to control nesting of the &lt;code&gt;tsquery&lt;/code&gt; operators. Without parentheses, &lt;code&gt;|&lt;/code&gt; binds least tightly, then &lt;code&gt;&amp;amp;&lt;/code&gt;, then &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt; most tightly.</source>
          <target state="translated">Скобки можно использовать для управления вложением операторов &lt;code&gt;tsquery&lt;/code&gt; . Без скобок, &lt;code&gt;|&lt;/code&gt; связывается наименее плотно, затем &lt;code&gt;&amp;amp;&lt;/code&gt; , затем &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; и &lt;code&gt;!&lt;/code&gt; наиболее плотно.</target>
        </trans-unit>
        <trans-unit id="0de9a8d461cec2b96e138a5742063451fce829dd" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to enforce grouping of these operators. In the absence of parentheses, &lt;code&gt;!&lt;/code&gt; (NOT) binds most tightly, &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) next most tightly, then &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), with &lt;code&gt;|&lt;/code&gt; (OR) binding the least tightly.</source>
          <target state="translated">Круглые скобки могут использоваться для принудительного группирования этих операторов. При отсутствии скобок &lt;code&gt;!&lt;/code&gt; (НЕ) связывается наиболее плотно, затем &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (СЛЕДУЕТ) наиболее плотно, затем &lt;code&gt;&amp;amp;&lt;/code&gt; (И) с &lt;code&gt;|&lt;/code&gt; (ИЛИ) связывание наименее крепко.</target>
        </trans-unit>
        <trans-unit id="1050a7f51685a531fe35b29d9845b1171bb5126c" translate="yes" xml:space="preserve">
          <source>Parentheses, which can be used to provide filter expressions or define the order of path evaluation.</source>
          <target state="translated">Круглые скобки,которые могут быть использованы для предоставления выражений фильтров или определения порядка оценки путей.</target>
        </trans-unit>
        <trans-unit id="dde89c96be949ecdb36498952ab75fb083c95513" translate="yes" xml:space="preserve">
          <source>Parse and validate the reloptions array for an index. This is called only when a non-null reloptions array exists for the index. &lt;em&gt;&lt;code&gt;reloptions&lt;/code&gt;&lt;/em&gt; is a &lt;code&gt;text&lt;/code&gt; array containing entries of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt;. The function should construct a &lt;code&gt;bytea&lt;/code&gt; value, which will be copied into the &lt;code&gt;rd_options&lt;/code&gt; field of the index's relcache entry. The data contents of the &lt;code&gt;bytea&lt;/code&gt; value are open for the access method to define; most of the standard access methods use struct &lt;code&gt;StdRdOptions&lt;/code&gt;. When &lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is true, the function should report a suitable error message if any of the options are unrecognized or have invalid values; when &lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is false, invalid entries should be silently ignored. (&lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is false when loading options already stored in &lt;code&gt;pg_catalog&lt;/code&gt;; an invalid entry could only be found if the access method has changed its rules for options, and in that case ignoring obsolete entries is appropriate.) It is OK to return NULL if default behavior is wanted.</source>
          <target state="translated">Разберите и проверьте массив повторных отображений для индекса. Это вызывается, только если для индекса существует ненулевой массив повторных операций. &lt;em&gt; &lt;code&gt;reloptions&lt;/code&gt; &lt;/em&gt; - это &lt;code&gt;text&lt;/code&gt; массив, содержащий записи в форме &lt;code&gt;name&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; . Функция должна построить &lt;code&gt;bytea&lt;/code&gt; значение, которое будет скопировано в &lt;code&gt;rd_options&lt;/code&gt; поле relcache вступления индекса. Содержимое данных &lt;code&gt;bytea&lt;/code&gt; значения открыто для определения метода доступа; большинство стандартных методов доступа используют struct &lt;code&gt;StdRdOptions&lt;/code&gt; . Если &lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt; истинна, функция должна сообщать подходящее сообщение об ошибке, если какой-либо из параметров не распознан или имеет недопустимые значения; когда&lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt; является ложным, недопустимые записи следует игнорировать. (&lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt; является ложной при загрузке параметров, уже сохраненных в &lt;code&gt;pg_catalog&lt;/code&gt; ; недопустимая запись может быть обнаружена только в том случае, если метод доступа изменил свои правила для параметров, и в этом случае игнорирование устаревших записей уместно.) Можно вернуть NULL, если поведение по умолчанию разыскивается.</target>
        </trans-unit>
        <trans-unit id="e963287c4fec77476e5d1bf8476b1e7cc102ae88" translate="yes" xml:space="preserve">
          <source>Parse system include files as well.</source>
          <target state="translated">Разбор системных включаемых файлов также.</target>
        </trans-unit>
        <trans-unit id="0c8772d05d1a8b9d8d78cf0c1c4a6eb499eca0c8" translate="yes" xml:space="preserve">
          <source>Parser Stage</source>
          <target state="translated">Парсерная стадия</target>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="284615f8b9e452b1f47ea07fb3256c3c1e7eaa1e" translate="yes" xml:space="preserve">
          <source>Parses the given document and returns true if the document is well-formed XML. (Note: this is an alias for the standard PostgreSQL function &lt;code&gt;xml_is_well_formed()&lt;/code&gt;. The name &lt;code&gt;xml_valid()&lt;/code&gt; is technically incorrect since validity and well-formedness have different meanings in XML.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58d58ace5fa0761b582d29360f9eac7d42ba9f0" translate="yes" xml:space="preserve">
          <source>Parsing for arguments stops at the end of the line, or when another unquoted backslash is found. An unquoted backslash is taken as the beginning of a new meta-command. The special sequence &lt;code&gt;\\&lt;/code&gt; (two backslashes) marks the end of arguments and continues parsing SQL commands, if any. That way SQL and psql commands can be freely mixed on a line. But in any case, the arguments of a meta-command cannot continue beyond the end of the line.</source>
          <target state="translated">Анализ аргументов останавливается в конце строки или при обнаружении другой обратной косой черты без кавычек. Обратная косая черта без кавычек считается началом новой метакоманды. Специальная последовательность &lt;code&gt;\\&lt;/code&gt; (две обратные косые черты) отмечает конец аргументов и продолжает анализ команд SQL, если они есть. Таким образом, команды SQL и psql можно свободно смешивать в строке. Но в любом случае аргументы метакоманды не могут продолжаться за пределами конца строки.</target>
        </trans-unit>
        <trans-unit id="07c159051320590e27d53f2ca68bc5552c059bb0" translate="yes" xml:space="preserve">
          <source>Part II. The SQL Language</source>
          <target state="translated">Часть II.Язык SQL</target>
        </trans-unit>
        <trans-unit id="ed99b73ba1d17331570cbb8c11cb9612833219a4" translate="yes" xml:space="preserve">
          <source>Part III. Server Administration</source>
          <target state="translated">Часть III.Администрирование сервера</target>
        </trans-unit>
        <trans-unit id="233b8f2c1ff53528b0a2395bfd96a5533e5bf211" translate="yes" xml:space="preserve">
          <source>Part VII. Internals</source>
          <target state="translated">Часть VII.Интерналы .</target>
        </trans-unit>
        <trans-unit id="1c0b1424932f39a83140c4ab14b4b9ddde6b4f52" translate="yes" xml:space="preserve">
          <source>Part VIII. Appendixes</source>
          <target state="translated">Часть VIII.Приложения</target>
        </trans-unit>
        <trans-unit id="53657ace24d508d9d61d6689474a05a11f116ca4" translate="yes" xml:space="preserve">
          <source>Partial (including parallel) aggregation is currently not supported for ordered-set aggregates. Also, it will never be used for aggregate calls that include &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; clauses, since those semantics cannot be supported during partial aggregation.</source>
          <target state="translated">Частичное (включая параллельное) агрегирование в настоящее время не поддерживается для агрегатов упорядоченного набора. Кроме того, он никогда не будет использоваться для вызовов агрегирования, которые включают предложения &lt;code&gt;DISTINCT&lt;/code&gt; или &lt;code&gt;ORDER BY&lt;/code&gt; , поскольку эта семантика не может поддерживаться во время частичного агрегирования.</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">Частичные индексы</target>
        </trans-unit>
        <trans-unit id="21eb60b5918acacccb4909c31bcd93a4758e3020" translate="yes" xml:space="preserve">
          <source>Partial Mode</source>
          <target state="translated">Частичный режим</target>
        </trans-unit>
        <trans-unit id="f7fabd14af4eb6ccfa3f503f4e268b2ad2693497" translate="yes" xml:space="preserve">
          <source>Partial indexes also have interesting interactions with index-only scans. Consider the partial index shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;:</source>
          <target state="translated">Частичные индексы также могут взаимодействовать со сканированием только индекса. Рассмотрим частичный индекс, показанный в &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;примере 11.3&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="943df06a52fbfe34ca375a62898de53e7d01f42f" translate="yes" xml:space="preserve">
          <source>Partition</source>
          <target state="translated">Partition</target>
        </trans-unit>
        <trans-unit id="7a5ba09370f100d4b05c522688c9cba42e037f6a" translate="yes" xml:space="preserve">
          <source>Partition pruning can be disabled using the &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;Сокращение&lt;/a&gt; разделов можно отключить с помощью параметра enable_partition_pruning .</target>
        </trans-unit>
        <trans-unit id="2325b1acc0d3782c122e1bc1c9eed9984fc2f19a" translate="yes" xml:space="preserve">
          <source>Partition pruning can be performed not only during the planning of a given query, but also during its execution. This is useful as it can allow more partitions to be pruned when clauses contain expressions whose values are not known at query planning time, for example, parameters defined in a &lt;code&gt;PREPARE&lt;/code&gt; statement, using a value obtained from a subquery, or using a parameterized value on the inner side of a nested loop join. Partition pruning during execution can be performed at any of the following times:</source>
          <target state="translated">Сокращение разделов может выполняться не только во время планирования данного запроса, но и во время его выполнения. Это полезно, так как позволяет сократить количество разделов, когда предложения содержат выражения, значения которых неизвестны во время планирования запроса, например, параметры, определенные в операторе &lt;code&gt;PREPARE&lt;/code&gt; , с использованием значения, полученного из подзапроса, или с использованием параметризованного значения на внутренняя сторона соединения вложенного цикла. Обрезку раздела во время выполнения можно выполнить в любое из следующих периодов:</target>
        </trans-unit>
        <trans-unit id="a5a934d5fd56ebc9886a2336d4cf199c8f485ebd" translate="yes" xml:space="preserve">
          <source>Partitioned table (relation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25be32546f15fa3443a67e839c875e6c98ffb53d" translate="yes" xml:space="preserve">
          <source>Partitioned tables do not support &lt;code&gt;EXCLUDE&lt;/code&gt; constraints; however, you can define these constraints on individual partitions.</source>
          <target state="translated">Секционированные таблицы не поддерживают ограничения &lt;code&gt;EXCLUDE&lt;/code&gt; ; однако вы можете определить эти ограничения для отдельных разделов.</target>
        </trans-unit>
        <trans-unit id="cdd1ab913d96a23c99606f41fe3792bb2b1fe894" translate="yes" xml:space="preserve">
          <source>Partitioning of big collections and the proper use of GIN and GiST indexes allows the implementation of very fast searches with online update. Partitioning can be done at the database level using table inheritance, or by distributing documents over servers and collecting external search results, e.g. via &lt;a href=&quot;ddl-foreign-data&quot;&gt;Foreign Data&lt;/a&gt; access. The latter is possible because ranking functions use only local information.</source>
          <target state="translated">Разделение больших коллекций и правильное использование индексов GIN и GiST позволяет осуществлять очень быстрый поиск с онлайн-обновлением. Разделение может быть выполнено на уровне базы данных с использованием наследования таблиц или путем распределения документов по серверам и сбора результатов внешнего поиска, например, через доступ к &lt;a href=&quot;ddl-foreign-data&quot;&gt;внешним данным&lt;/a&gt; . Последнее возможно, потому что функции ранжирования используют только локальную информацию.</target>
        </trans-unit>
        <trans-unit id="a24ec4cff1b6c6f9a0a6c355299a351c0f004fce" translate="yes" xml:space="preserve">
          <source>Partitioning of big collections and the proper use of GIN and GiST indexes allows the implementation of very fast searches with online update. Partitioning can be done at the database level using table inheritance, or by distributing documents over servers and collecting external search results, e.g., via &lt;a href=&quot;ddl-foreign-data&quot;&gt;Foreign Data&lt;/a&gt; access. The latter is possible because ranking functions use only local information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0bffd921d00f01c704a415da77618af1ad1157" translate="yes" xml:space="preserve">
          <source>Partitioning refers to splitting what is logically one large table into smaller physical pieces. Partitioning can provide several benefits:</source>
          <target state="translated">Под разделением понимается разбиение того,что логически представляет собой одну большую таблицу на более мелкие физические части.Разбиение на разделы может дать несколько преимуществ:</target>
        </trans-unit>
        <trans-unit id="7c73b5aa4d6c05a53fb97d25c9d92f2517cfd521" translate="yes" xml:space="preserve">
          <source>Partitioning strategy; &lt;code&gt;h&lt;/code&gt; = hash partitioned table, &lt;code&gt;l&lt;/code&gt; = list partitioned table, &lt;code&gt;r&lt;/code&gt; = range partitioned table</source>
          <target state="translated">Стратегия разделения; &lt;code&gt;h&lt;/code&gt; = хеш-секционированная таблица, &lt;code&gt;l&lt;/code&gt; = секционированная таблица со списком, &lt;code&gt;r&lt;/code&gt; = секционированная таблица по диапазонам</target>
        </trans-unit>
        <trans-unit id="ac39e0014a08ee6c92f0e5cdb5959d966b4de171" translate="yes" xml:space="preserve">
          <source>Partitions can also be foreign tables, although they have some limitations that normal tables do not; see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; for more information.</source>
          <target state="translated">Разделы также могут быть сторонними таблицами, хотя у них есть некоторые ограничения, которых нет у обычных таблиц; см. &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="742a14b2e0099a02fc2828373fdc246b43a7d658" translate="yes" xml:space="preserve">
          <source>Partitions cannot have columns that are not present in the parent. It is not possible to specify columns when creating partitions with &lt;code&gt;CREATE TABLE&lt;/code&gt;, nor is it possible to add columns to partitions after-the-fact using &lt;code&gt;ALTER TABLE&lt;/code&gt;. Tables may be added as a partition with &lt;code&gt;ALTER TABLE ... ATTACH PARTITION&lt;/code&gt; only if their columns exactly match the parent.</source>
          <target state="translated">Разделы не могут иметь столбцы, которых нет в родительском элементе. Невозможно указать столбцы при создании разделов с помощью &lt;code&gt;CREATE TABLE&lt;/code&gt; , а также невозможно добавить столбцы к разделам постфактум с помощью &lt;code&gt;ALTER TABLE&lt;/code&gt; . Таблицы могут быть добавлены как раздел с помощью &lt;code&gt;ALTER TABLE ... ATTACH PARTITION&lt;/code&gt; только если их столбцы точно соответствуют родительскому.</target>
        </trans-unit>
        <trans-unit id="90542a9f44eb209be50c576524ab51cf75180838" translate="yes" xml:space="preserve">
          <source>Partitions may themselves be defined as partitioned tables, using what is called &lt;em&gt;sub-partitioning&lt;/em&gt;. Partitions may have their own indexes, constraints and default values, distinct from those of other partitions. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on creating partitioned tables and partitions.</source>
          <target state="translated">Разделы сами по себе могут быть определены как разделенные таблицы с использованием так называемого &lt;em&gt;разделения на разделы&lt;/em&gt; . Разделы могут иметь свои собственные индексы, ограничения и значения по умолчанию, отличные от индексов других разделов. См. &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для получения дополнительных сведений о создании многораздельных таблиц и разделов.</target>
        </trans-unit>
        <trans-unit id="0fe4b4dd2ad3e0c4391acf69fe76d976b85276f5" translate="yes" xml:space="preserve">
          <source>Partitions thus created are in every way normal PostgreSQL tables (or, possibly, foreign tables). It is possible to specify a tablespace and storage parameters for each partition separately.</source>
          <target state="translated">Созданные таким образом разделы во всех отношениях являются обычными таблицами PostgreSQL (или,возможно,иными таблицами).Для каждого раздела можно отдельно указать пространство таблиц и параметры хранения.</target>
        </trans-unit>
        <trans-unit id="88b62432a05ee62c1b6215e5aa74e2720815cc44" translate="yes" xml:space="preserve">
          <source>Parts of the GEQO module are adapted from D. Whitley's Genitor algorithm.</source>
          <target state="translated">Части модуля GEQO адаптированы по алгоритму Генератора Д.Уитли.</target>
        </trans-unit>
        <trans-unit id="f1c5d9114d4f8eeeec0857bd19317d948e267875" translate="yes" xml:space="preserve">
          <source>Pass the option &lt;code&gt;name&lt;/code&gt; to the output plugin with, if specified, the option value &lt;code&gt;value&lt;/code&gt;. Which options exist and their effects depends on the used output plugin.</source>
          <target state="translated">Передайте &lt;code&gt;name&lt;/code&gt; опции в плагин вывода с, если указано, значением &lt;code&gt;value&lt;/code&gt; опции . Какие параметры существуют и их действие зависит от используемого модуля вывода.</target>
        </trans-unit>
        <trans-unit id="adee4d3938c90062826aa15c6cd38c8f321a8960" translate="yes" xml:space="preserve">
          <source>Password (possibly encrypted); null if none. See &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt; for details of how encrypted passwords are stored.</source>
          <target state="translated">Пароль (возможно, зашифрованный); null, если нет. См. &lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt; для получения подробной информации о том, как хранятся зашифрованные пароли.</target>
        </trans-unit>
        <trans-unit id="99366622edd98624e0f268beb5dfad9b43284c50" translate="yes" xml:space="preserve">
          <source>Password (possibly encrypted); null if none. The format depends on the form of encryption used.</source>
          <target state="translated">Пароль (возможно,зашифрованный);ноль,если нет.Формат зависит от используемой формы шифрования.</target>
        </trans-unit>
        <trans-unit id="e6148812de885ba8e1911ccd743a2dc2463667a7" translate="yes" xml:space="preserve">
          <source>Password Authentication</source>
          <target state="translated">Аутентификация по паролю</target>
        </trans-unit>
        <trans-unit id="e8e30ae74424dc989ae9149964d67afb93a52bdb" translate="yes" xml:space="preserve">
          <source>Password Encryption</source>
          <target state="translated">Шифрование пароля</target>
        </trans-unit>
        <trans-unit id="36eca0e0aafbe2102ac86aee3d25cb85966cbaa6" translate="yes" xml:space="preserve">
          <source>Password expiry time (only used for password authentication)</source>
          <target state="translated">Время истечения срока действия пароля (используется только для аутентификации пароля)</target>
        </trans-unit>
        <trans-unit id="de5ff361027e5b08609865471d6dc5846a389286" translate="yes" xml:space="preserve">
          <source>Password expiry time (only used for password authentication); null if no expiration</source>
          <target state="translated">Время истечения срока действия пароля (используется только для аутентификации пароля);ноль,если срок действия не истек.</target>
        </trans-unit>
        <trans-unit id="238db8fa438548c1928f9502d7d8e1e30eb6d531" translate="yes" xml:space="preserve">
          <source>Password for the user to run the service as.</source>
          <target state="translated">Пароль для пользователя,чтобы запустить службу как.</target>
        </trans-unit>
        <trans-unit id="3fa38ad80d289fe4c73a95809bdea71d6cbf450b" translate="yes" xml:space="preserve">
          <source>Password for user to bind to the directory with to perform the search when doing search+bind authentication.</source>
          <target state="translated">Пароль для привязки пользователя к каталогу с целью выполнения поиска при выполнении поиска+привязки аутентификации.</target>
        </trans-unit>
        <trans-unit id="d33984b00815ba0da90a3eeaeb545efb634cbde4" translate="yes" xml:space="preserve">
          <source>Path construction using functions:</source>
          <target state="translated">Построение пути с использованием функций:</target>
        </trans-unit>
        <trans-unit id="463f854670c23f477bbd78e96423f8e31931e339" translate="yes" xml:space="preserve">
          <source>Path literals of JSON primitive types: Unicode text, numeric, true, false, or null.</source>
          <target state="translated">Путевые буквы примитивных типов JSON:Юникодный текст,числовой,истинный,ложный или нулевой.</target>
        </trans-unit>
        <trans-unit id="7b6339b7ad3d2b4abc5be8c19dc30583042c4165" translate="yes" xml:space="preserve">
          <source>Path of a Query</source>
          <target state="translated">Путь запроса</target>
        </trans-unit>
        <trans-unit id="266a8e23c8475feda63519f1c3d2f320f2aaac65" translate="yes" xml:space="preserve">
          <source>Path of shared library that implements language</source>
          <target state="translated">Путь к общей библиотеке,реализующей язык</target>
        </trans-unit>
        <trans-unit id="6a3675336ca9e8caece923ce6c69021ab35c9b34" translate="yes" xml:space="preserve">
          <source>Path variables listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-VARIABLES&quot;&gt;Table 8.24&lt;/a&gt;.</source>
          <target state="translated">Переменные пути перечислены в &lt;a href=&quot;datatype-json#TYPE-JSONPATH-VARIABLES&quot;&gt;Таблице 8.24&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55707d92267c5187de428b55c28d908802787d98" translate="yes" xml:space="preserve">
          <source>Paths are output using the first or second syntax, as appropriate.</source>
          <target state="translated">Пути выводятся с использованием первого или второго синтаксиса,в зависимости от ситуации.</target>
        </trans-unit>
        <trans-unit id="d21eb60eb90443c1e0fde7a365afe587f415ae66" translate="yes" xml:space="preserve">
          <source>Paths are represented by lists of connected points. Paths can be &lt;em&gt;open&lt;/em&gt;, where the first and last points in the list are considered not connected, or &lt;em&gt;closed&lt;/em&gt;, where the first and last points are considered connected.</source>
          <target state="translated">Пути представлены списками связанных точек. Пути могут быть &lt;em&gt;открытыми&lt;/em&gt; , когда первая и последняя точки в списке считаются несвязанными, или &lt;em&gt;закрытыми&lt;/em&gt; , когда первая и последняя точки считаются связанными.</target>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="535ab3a1c5459ace2d0b0bcb8fc022e58a4100d9" translate="yes" xml:space="preserve">
          <source>Pattern Matching</source>
          <target state="translated">Совпадение образов</target>
        </trans-unit>
        <trans-unit id="1a43195d59d6b988e5bc825ea91ee5fa2ee54455" translate="yes" xml:space="preserve">
          <source>Pattern Matching: LIKE</source>
          <target state="translated">Сопоставление образов:LIKE</target>
        </trans-unit>
        <trans-unit id="577a01dd1c0e8f649068e70f9cf054970915cb36" translate="yes" xml:space="preserve">
          <source>Pattern Matching: POSIX Regular Expressions</source>
          <target state="translated">Сопоставление с образцом:Регулярные выражения POSIX</target>
        </trans-unit>
        <trans-unit id="1aca0dbf2888e4f1bc7d10adb1a49bb94a808a60" translate="yes" xml:space="preserve">
          <source>Pattern Matching: SIMILAR TO Regular Expressions</source>
          <target state="translated">Сопоставление с образцом:от симиляра до регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="2cca6a6a36d34faa5c5f178fbe489846badc8fb5" translate="yes" xml:space="preserve">
          <source>Pattern matching operators (&lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt;, and POSIX-style regular expressions); locales affect both case insensitive matching and the classification of characters by character-class regular expressions</source>
          <target state="translated">Операторы сопоставления с образцом ( регулярные выражения в стиле &lt;code&gt;LIKE&lt;/code&gt; , &lt;code&gt;SIMILAR TO&lt;/code&gt; и POSIX); локали влияют как на нечувствительность к регистру, так и на классификацию символов регулярными выражениями символьного класса</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="ca382c16294c214dbe3191677fc4669d70c86654" translate="yes" xml:space="preserve">
          <source>Pauses recovery immediately (restricted to superusers by default, but other users can be granted EXECUTE to run the function).</source>
          <target state="translated">Немедленно приостанавливает восстановление (по умолчанию оно ограничено для суперпользователей,но другим пользователям может быть предоставлено право EXECUTE на запуск функции).</target>
        </trans-unit>
        <trans-unit id="9d18ff4f9325c1d261553975b88e0f79d832a0bc" translate="yes" xml:space="preserve">
          <source>Pauses recovery. While recovery is paused, no further database changes are applied. If hot standby is active, all new queries will see the same consistent snapshot of the database, and no further query conflicts will be generated until recovery is resumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a0f150ca4476ed5b576c007ac1865d1fb8bb74" translate="yes" xml:space="preserve">
          <source>Peer Authentication</source>
          <target state="translated">Однородная аутентификация</target>
        </trans-unit>
        <trans-unit id="7140c44c7da9185cfa0b73cd8cc49f9de3bc1489" translate="yes" xml:space="preserve">
          <source>Peer authentication is only available on operating systems providing the &lt;code&gt;getpeereid()&lt;/code&gt; function, the &lt;code&gt;SO_PEERCRED&lt;/code&gt; socket parameter, or similar mechanisms. Currently that includes Linux, most flavors of BSD including macOS, and Solaris.</source>
          <target state="translated">Одноранговая аутентификация доступна только в операционных системах, предоставляющих &lt;code&gt;getpeereid()&lt;/code&gt; , параметр сокета &lt;code&gt;SO_PEERCRED&lt;/code&gt; или аналогичные механизмы. В настоящее время это Linux, большинство разновидностей BSD, включая macOS, и Solaris.</target>
        </trans-unit>
        <trans-unit id="a4e88cdf6f01c061fef4d5d033c1f84e81c460db" translate="yes" xml:space="preserve">
          <source>Peer authentication is usually recommendable for local connections, though trust authentication might be sufficient in some circumstances. Password authentication is the easiest choice for remote connections. All the other options require some kind of external security infrastructure (usually an authentication server or a certificate authority for issuing SSL certificates), or are platform-specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cdd79a05b9da966c26a1f6a5e99a7a9fb8d64a3" translate="yes" xml:space="preserve">
          <source>Per-Command Policies</source>
          <target state="translated">Политика в соответствии с мандатом</target>
        </trans-unit>
        <trans-unit id="ed1d3a75054b9592b198ba465dda151b09c333ea" translate="yes" xml:space="preserve">
          <source>Per-Statement Latencies</source>
          <target state="translated">Задержки в подаче заявления</target>
        </trans-unit>
        <trans-unit id="db0ae07882c18b5649ee33de907e97a3481ed614" translate="yes" xml:space="preserve">
          <source>Per-Transaction Logging</source>
          <target state="translated">Записи в журнал по каждой операции</target>
        </trans-unit>
        <trans-unit id="f973c235a702ba0b4882340692bc401f9c1e7c7c" translate="yes" xml:space="preserve">
          <source>Per-index value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-CLEANUP-INDEX-SCALE-FACTOR&quot;&gt;vacuum_cleanup_index_scale_factor&lt;/a&gt;.</source>
          <target state="translated">Значение индекса для &lt;a href=&quot;runtime-config-client#GUC-VACUUM-CLEANUP-INDEX-SCALE-FACTOR&quot;&gt;Vacuum_cleanup_index_scale_factor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6aee541129a013df791c695dddfe4b66f3b0804a" translate="yes" xml:space="preserve">
          <source>Per-table granularity</source>
          <target state="translated">Перспективная гранулярность</target>
        </trans-unit>
        <trans-unit id="df6300430e05243fb8623c3dacf21a834f4ec9db" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR&quot;&gt;autovacuum_analyze_scale_factor&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR&quot;&gt;Табличное&lt;/a&gt; значение параметра autovacuum_analyze_scale_factor .</target>
        </trans-unit>
        <trans-unit id="13bcc410c7f9ecd5027e7aabb4054809e94a5637" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-THRESHOLD&quot;&gt;autovacuum_analyze_threshold&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-THRESHOLD&quot;&gt;Табличное&lt;/a&gt; значение параметра autovacuum_analyze_threshold .</target>
        </trans-unit>
        <trans-unit id="b4cc49570c37ddaf0ad982835227bdfeb5fb34fc" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; parameters that are larger than the system-wide setting (it can only be set smaller).</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;Табличное&lt;/a&gt; значение параметра autovacuum_freeze_max_age . Обратите внимание , что автовакууминг будет игнорировать за столом &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; параметры, которые больше , чем установка общесистемного (он может только быть установлен меньше).</target>
        </trans-unit>
        <trans-unit id="adc3bbc6bde46e7a977a3d025522a0b130c2221c" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; parameters that are larger than the system-wide setting (it can only be set smaller).</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;Табличное&lt;/a&gt; значение параметра autovacuum_multixact_freeze_max_age . Обратите внимание , что автовакууминг будет игнорировать за столом &lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; параметры, которые больше , чем установка общесистемного (он может только быть установлен меньше).</target>
        </trans-unit>
        <trans-unit id="52ee90bf83a221126d345af63a697f023bf7aaf2" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-DELAY&quot;&gt;autovacuum_vacuum_cost_delay&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-DELAY&quot;&gt;Табличное&lt;/a&gt; значение параметра autovacuum_vacuum_cost_delay .</target>
        </trans-unit>
        <trans-unit id="b8f18627239c76784b53c354db6754ba7815a1a8" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-LIMIT&quot;&gt;autovacuum_vacuum_cost_limit&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-LIMIT&quot;&gt;Табличное&lt;/a&gt; значение параметра autovacuum_vacuum_cost_limit .</target>
        </trans-unit>
        <trans-unit id="4d12e56fad0fc8cfde31ec88733d4a8a4914d22d" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_insert_scale_factor&lt;/a&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66effb5fc4a6d26e983439f8ea5df04cb08e89f" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD&quot;&gt;autovacuum_vacuum_insert_threshold&lt;/a&gt; parameter. The special value of -1 may be used to disable insert vacuums on the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd4eed61fa80fd43095c3741dd5dd959fac77e2" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;Табличное&lt;/a&gt; значение параметра autovacuum_vacuum_scale_factor .</target>
        </trans-unit>
        <trans-unit id="4413713442ca0dbea5e7f8130793f8e4a24e0cef" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;Табличное&lt;/a&gt; значение параметра autovacuum_vacuum_threshold .</target>
        </trans-unit>
        <trans-unit id="3d2800f8c07e42c6c33e28d11f8d0822c4287722" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;log_autovacuum_min_duration&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;Табличное&lt;/a&gt; значение параметра log_autovacuum_min_duration .</target>
        </trans-unit>
        <trans-unit id="223ad5e2d00a73119ddde400e71e2b1ba9280ccb" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;vacuum_freeze_min_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt; parameters that are larger than half the system-wide &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;Табличное&lt;/a&gt; значение параметра vacuum_freeze_min_age . Обратите внимание , что автовакууминг будет игнорировать за стол &lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt; параметров, которые больше половины всей системы &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; обстановки.</target>
        </trans-unit>
        <trans-unit id="68a4d3118ea45821db0cebd7519f0ea146995887" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;Табличное&lt;/a&gt; значение для параметра vac_freeze_table_age .</target>
        </trans-unit>
        <trans-unit id="aed713d91e51cd08cd23d16d2810e44fceb208ef" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt; parameters that are larger than half the system-wide &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;Табличное&lt;/a&gt; значение параметра vac_multixact_freeze_min_age . Обратите внимание, что автоматическая очистка будет игнорировать параметры &lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt; для отдельных таблиц , которые превышают половину общесистемной настройки &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d6a639607b9fecb0af2c41612e5b2768fa56a2e" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;Табличное&lt;/a&gt; значение для параметра vac_multixact_freeze_table_age .</target>
        </trans-unit>
        <trans-unit id="e975b3d41bbeabc6eb00c97d7e30fbafd1d2457e" translate="yes" xml:space="preserve">
          <source>Percentage of dead tuples</source>
          <target state="translated">Процент мертвых кортежей</target>
        </trans-unit>
        <trans-unit id="b0cd75c0030dceadd02cefb1f4f8cdfe1c43c19b" translate="yes" xml:space="preserve">
          <source>Percentage of free space</source>
          <target state="translated">Процент от свободного места</target>
        </trans-unit>
        <trans-unit id="026e26a6ed3d13c32e91d16667b4fce6169c8f91" translate="yes" xml:space="preserve">
          <source>Percentage of live tuples</source>
          <target state="translated">Процент живых кортежей</target>
        </trans-unit>
        <trans-unit id="20574a809cad3d22e4de78bb07a64ea3c84d8769" translate="yes" xml:space="preserve">
          <source>Percentage of table scanned</source>
          <target state="translated">Процент сканированного стола</target>
        </trans-unit>
        <trans-unit id="cecafd6247612c74017c4324067017c519c963f3" translate="yes" xml:space="preserve">
          <source>Perform &amp;ldquo;full&amp;rdquo; vacuuming.</source>
          <target state="translated">Выполните &amp;laquo;полную&amp;raquo; уборку.</target>
        </trans-unit>
        <trans-unit id="feca8a5ed5223a5437966dd095f2b42b084450e7" translate="yes" xml:space="preserve">
          <source>Perform SCRAM-SHA-256 authentication to verify the user's password. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="translated">Выполните аутентификацию SCRAM-SHA-256, чтобы проверить пароль пользователя. См &lt;a href=&quot;auth-password&quot;&gt;раздел 20.5&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="cee9d96cd6bf238088136c000e640e78e06aa374" translate="yes" xml:space="preserve">
          <source>Perform SCRAM-SHA-256 or MD5 authentication to verify the user's password. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="translated">Выполните аутентификацию SCRAM-SHA-256 или MD5, чтобы проверить пароль пользователя. См &lt;a href=&quot;auth-password&quot;&gt;раздел 20.5&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="7e17faacf8a7556f475f5c4f9f96ab42fd904d29" translate="yes" xml:space="preserve">
          <source>Perform a variable assignment, like the &lt;code&gt;\set&lt;/code&gt; meta-command. Note that you must separate name and value, if any, by an equal sign on the command line. To unset a variable, leave off the equal sign. To set a variable with an empty value, use the equal sign but leave off the value. These assignments are done during command line processing, so variables that reflect connection state will get overwritten later.</source>
          <target state="translated">Выполните присвоение переменной, как &lt;code&gt;\set&lt;/code&gt; . Обратите внимание, что вы должны разделить имя и значение, если они есть, знаком равенства в командной строке. Чтобы отключить переменную, не ставьте знак равенства. Чтобы установить переменную с пустым значением, используйте знак равенства, но опускайте значение. Эти назначения выполняются во время обработки командной строки, поэтому переменные, отражающие состояние подключения, позже будут перезаписаны.</target>
        </trans-unit>
        <trans-unit id="fb9e20f68ce84ca1bc08bc43d32bfdf37750e58d" translate="yes" xml:space="preserve">
          <source>Perform index vacuum and index cleanup phases of &lt;code&gt;VACUUM&lt;/code&gt; in parallel using &lt;code&gt;integer&lt;/code&gt; background workers (for the details of each vacuum phase, please refer to &lt;a href=&quot;progress-reporting#VACUUM-PHASES&quot;&gt;Table 27.37&lt;/a&gt;). The number of workers used to perform the operation is equal to the number of indexes on the relation that support parallel vacuum which is limited by the number of workers specified with &lt;code&gt;PARALLEL&lt;/code&gt; option if any which is further limited by &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;. An index can participate in parallel vacuum if and only if the size of the index is more than &lt;a href=&quot;runtime-config-query#GUC-MIN-PARALLEL-INDEX-SCAN-SIZE&quot;&gt;min_parallel_index_scan_size&lt;/a&gt;. Please note that it is not guaranteed that the number of parallel workers specified in &lt;code&gt;integer&lt;/code&gt; will be used during execution. It is possible for a vacuum to run with fewer workers than specified, or even with no workers at all. Only one worker can be used per index. So parallel workers are launched only when there are at least &lt;code&gt;2&lt;/code&gt; indexes in the table. Workers for vacuum are launched before the start of each phase and exit at the end of the phase. These behaviors might change in a future release. This option can't be used with the &lt;code&gt;FULL&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34d3d05facf882ae3a691abd30e8b6cd4a6e677" translate="yes" xml:space="preserve">
          <source>Perform just a selected set of the normal initialization steps. &lt;code&gt;init_steps&lt;/code&gt; specifies the initialization steps to be performed, using one character per step. Each step is invoked in the specified order. The default is &lt;code&gt;dtgvp&lt;/code&gt;. The available steps are:</source>
          <target state="translated">Выполните только выбранный набор обычных шагов инициализации. &lt;code&gt;init_steps&lt;/code&gt; определяет шаги инициализации, которые должны быть выполнены, используя один символ на шаг. Каждый шаг вызывается в указанном порядке. По умолчанию - &lt;code&gt;dtgvp&lt;/code&gt; . Доступные шаги:</target>
        </trans-unit>
        <trans-unit id="5f6bc160364e3493898bf7d6bb17edbe09454bda" translate="yes" xml:space="preserve">
          <source>Perform no vacuuming before running the test. This option is &lt;em&gt;necessary&lt;/em&gt; if you are running a custom test scenario that does not include the standard tables &lt;code&gt;pgbench_accounts&lt;/code&gt;, &lt;code&gt;pgbench_branches&lt;/code&gt;, &lt;code&gt;pgbench_history&lt;/code&gt;, and &lt;code&gt;pgbench_tellers&lt;/code&gt;.</source>
          <target state="translated">Перед запуском теста не вакуумируйте. Эта опция &lt;em&gt;необходима,&lt;/em&gt; если вы запускаете собственный тестовый сценарий, который не включает стандартные таблицы &lt;code&gt;pgbench_accounts&lt;/code&gt; , &lt;code&gt;pgbench_branches&lt;/code&gt; , &lt;code&gt;pgbench_history&lt;/code&gt; и &lt;code&gt;pgbench_tellers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a366494657843694e57b5bad59c50324f01a651" translate="yes" xml:space="preserve">
          <source>Perform no vacuuming during initialization. (This option suppresses the &lt;code&gt;v&lt;/code&gt; initialization step, even if it was specified in &lt;code&gt;-I&lt;/code&gt;.)</source>
          <target state="translated">Во время инициализации не вакуумируйте. (Эта опция подавляет шаг инициализации &lt;code&gt;v&lt;/code&gt; , даже если он был указан в &lt;code&gt;-I&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="ae7a93c9cfd5aa5e2e72b1ed16236cb5de67de61" translate="yes" xml:space="preserve">
          <source>Perform the backup, using any convenient file-system-backup tool such as tar or cpio (not pg_dump or pg_dumpall). It is neither necessary nor desirable to stop normal operation of the database while you do this. See &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP-DATA&quot;&gt;Section 25.3.3.3&lt;/a&gt; for things to consider during this backup.</source>
          <target state="translated">Выполните резервное копирование с помощью любого удобного инструмента для резервного копирования файловой системы, такого как tar или cpio (не pg_dump или pg_dumpall). При этом нет необходимости и нежелательно останавливать нормальную работу базы данных. См. &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP-DATA&quot;&gt;Раздел 25.3.3.3,&lt;/a&gt; чтобы учесть, что следует учитывать при резервном копировании.</target>
        </trans-unit>
        <trans-unit id="d0828d0154023185a4f3f08252e7050a26fc998a" translate="yes" xml:space="preserve">
          <source>Perform the same operation and return the updated entries:</source>
          <target state="translated">Выполните ту же операцию и верните обновленные записи:</target>
        </trans-unit>
        <trans-unit id="ca80079033f0036f2ec138c62dcdab998ede3b1d" translate="yes" xml:space="preserve">
          <source>Perform the same operation, using a sub-select in the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">Выполните ту же операцию, используя подвыборку в &lt;code&gt;WHERE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6d4af32e4acc11996347bfaec82c71604728dd29" translate="yes" xml:space="preserve">
          <source>Performance Tips</source>
          <target state="translated">Советы по производительности</target>
        </trans-unit>
        <trans-unit id="fc8d14b954dfe439eb5ef6988b32004ef49622c0" translate="yes" xml:space="preserve">
          <source>Performs a frontend (client) copy. This is an operation that runs an SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command, but instead of the server reading or writing the specified file, psql reads or writes the file and routes the data between the server and the local file system. This means that file accessibility and privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="translated">Выполняет внешнюю (клиентскую) копию. Это операция, которая запускает команду SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; , но вместо того, чтобы сервер считывал или записывал указанный файл, psql считывает или записывает файл и направляет данные между сервером и локальной файловой системой. Это означает, что доступ к файлам и привилегии принадлежат локальному пользователю, а не серверу, и привилегии суперпользователя SQL не требуются.</target>
        </trans-unit>
        <trans-unit id="6c344e1248da1978bc3644d43b9d891fff2e39be" translate="yes" xml:space="preserve">
          <source>Peter Eisentraut &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter_e@gmx.net&quot;&gt;peter_e@gmx.net&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Питер Эйзентраут &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter_e@gmx.net&quot;&gt;peter_e@gmx.net&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da078a3d051b083b829b48a189bf09b75dac6cd7" translate="yes" xml:space="preserve">
          <source>Peter Mount &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@retep.org.uk&quot;&gt;peter@retep.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Питер Маунт &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@retep.org.uk&quot;&gt;peter@retep.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac972e7b24283f21a917e63d12ab81c028b6b619" translate="yes" xml:space="preserve">
          <source>Phantom Read</source>
          <target state="translated">Фантомное чтение</target>
        </trans-unit>
        <trans-unit id="f6371a4980dacd0f821ddeb75bac77ae4886ba72" translate="yes" xml:space="preserve">
          <source>Phase</source>
          <target state="translated">Phase</target>
        </trans-unit>
        <trans-unit id="042205072874b99f497a9509acb6db1b05f17fb3" translate="yes" xml:space="preserve">
          <source>Physical Storage: Database File Layout</source>
          <target state="translated">Физическое хранение:Макет файла базы данных</target>
        </trans-unit>
        <trans-unit id="3fc82c3858fa9eb0fe848a4e73244b155ecf922b" translate="yes" xml:space="preserve">
          <source>Physical Storage: Database Page Layout</source>
          <target state="translated">Физическое хранение:Макет страницы базы данных</target>
        </trans-unit>
        <trans-unit id="bb5882e77d3988624189c0ed4e594bfe45615e1a" translate="yes" xml:space="preserve">
          <source>Physical Storage: Free Space Map</source>
          <target state="translated">Физическое хранение:Карта свободного пространства</target>
        </trans-unit>
        <trans-unit id="1aa3f80bb2e1afaf99e1bd935f3605582854ea4b" translate="yes" xml:space="preserve">
          <source>Physical Storage: Initialization Fork</source>
          <target state="translated">Физическое хранение:Вилка инициализации</target>
        </trans-unit>
        <trans-unit id="365026e65b63752c65e5cd29c199d84c6b17ab3e" translate="yes" xml:space="preserve">
          <source>Physical Storage: TOAST</source>
          <target state="translated">Физическое хранение:TOAST</target>
        </trans-unit>
        <trans-unit id="2b725586447f2023155afd853eb7071d04362c03" translate="yes" xml:space="preserve">
          <source>Physical Storage: Visibility Map</source>
          <target state="translated">Физическое хранение:Видимость Карта</target>
        </trans-unit>
        <trans-unit id="27e67533896359d51a605428384ec08a0b4ccbfe" translate="yes" xml:space="preserve">
          <source>Physical relation length in bytes</source>
          <target state="translated">Длина физического соотношения в байтах</target>
        </trans-unit>
        <trans-unit id="53d91fab1719e32b08f04ca110073dde614b240a" translate="yes" xml:space="preserve">
          <source>Physical relation length in bytes (exact)</source>
          <target state="translated">Длина физического соотношения в байтах (точная)</target>
        </trans-unit>
        <trans-unit id="2d0ec6f0ef721a8a8cb1c82f207caf7adfca229f" translate="yes" xml:space="preserve">
          <source>Place the database cluster's data directory in a memory-backed file system (i.e. RAM disk). This eliminates all database disk I/O, but limits data storage to the amount of available memory (and perhaps swap).</source>
          <target state="translated">Поместите каталог данных кластера БД в файловую систему с памятью (т.е.на RAM-диск).Это устранит все входы/выходы диска БД,но ограничит хранение данных объемом доступной памяти (и,возможно,подкачки).</target>
        </trans-unit>
        <trans-unit id="763b9aa0654971e3e19fdea85c60c9a6639631aa" translate="yes" xml:space="preserve">
          <source>Place the database cluster's data directory in a memory-backed file system (i.e., RAM disk). This eliminates all database disk I/O, but limits data storage to the amount of available memory (and perhaps swap).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb237570f0f7f892d4ed491876f26dd479a782a" translate="yes" xml:space="preserve">
          <source>Placing &lt;code&gt;ORDER BY&lt;/code&gt; within the aggregate's regular argument list, as described so far, is used when ordering the input rows for general-purpose and statistical aggregates, for which ordering is optional. There is a subclass of aggregate functions called &lt;em&gt;ordered-set aggregates&lt;/em&gt; for which an &lt;code&gt;order_by_clause&lt;/code&gt; is &lt;em&gt;required&lt;/em&gt;, usually because the aggregate's computation is only sensible in terms of a specific ordering of its input rows. Typical examples of ordered-set aggregates include rank and percentile calculations. For an ordered-set aggregate, the &lt;code&gt;order_by_clause&lt;/code&gt; is written inside &lt;code&gt;WITHIN GROUP (...)&lt;/code&gt;, as shown in the final syntax alternative above. The expressions in the &lt;code&gt;order_by_clause&lt;/code&gt; are evaluated once per input row just like regular aggregate arguments, sorted as per the &lt;code&gt;order_by_clause&lt;/code&gt;'s requirements, and fed to the aggregate function as input arguments. (This is unlike the case for a non-&lt;code&gt;WITHIN GROUP&lt;/code&gt;&lt;code&gt;order_by_clause&lt;/code&gt;, which is not treated as argument(s) to the aggregate function.) The argument expressions preceding &lt;code&gt;WITHIN GROUP&lt;/code&gt;, if any, are called &lt;em&gt;direct arguments&lt;/em&gt; to distinguish them from the &lt;em&gt;aggregated arguments&lt;/em&gt; listed in the &lt;code&gt;order_by_clause&lt;/code&gt;. Unlike regular aggregate arguments, direct arguments are evaluated only once per aggregate call, not once per input row. This means that they can contain variables only if those variables are grouped by &lt;code&gt;GROUP BY&lt;/code&gt;; this restriction is the same as if the direct arguments were not inside an aggregate expression at all. Direct arguments are typically used for things like percentile fractions, which only make sense as a single value per aggregation calculation. The direct argument list can be empty; in this case, write just &lt;code&gt;()&lt;/code&gt; not &lt;code&gt;(*)&lt;/code&gt;. (PostgreSQL will actually accept either spelling, but only the first way conforms to the SQL standard.)</source>
          <target state="translated">Размещение &lt;code&gt;ORDER BY&lt;/code&gt; в обычном списке аргументов агрегата, как описано выше, используется при упорядочивании входных строк для общих и статистических агрегатов, для которых упорядочение является необязательным. Существует подкласс агрегатных функций , называемых &lt;em&gt;упорядоченных набор агрегатов&lt;/em&gt; , для которых &lt;code&gt;order_by_clause&lt;/code&gt; это &lt;em&gt;требуются&lt;/em&gt; , как правило , из расчета совокупного является разумным только с точки зрения конкретного упорядочения входных строк. Типичные примеры агрегатов упорядоченного набора включают вычисления ранга и процентилей. Для агрегата с упорядоченным набором предложение &lt;code&gt;order_by_clause&lt;/code&gt; записывается внутри &lt;code&gt;WITHIN GROUP (...)&lt;/code&gt; , как показано в последней альтернативе синтаксиса выше. Выражения в &lt;code&gt;order_by_clause&lt;/code&gt; оцениваются один раз в строке ввода, как обычные агрегатных аргументы, отсортированных в соответствии с &lt;code&gt;order_by_clause&lt;/code&gt; &amp;laquo;s требования и питал к агрегатной функции в качестве входных аргументов. (Это отличается от случая для предложения &lt;code&gt;order_by_clause&lt;/code&gt; , отличного от WITHIN &lt;code&gt;WITHIN GROUP&lt;/code&gt; , которое не рассматривается как аргумент (ы) для агрегатной функции.) Выражения аргументов, предшествующие &lt;code&gt;WITHIN GROUP&lt;/code&gt; , если таковые имеются, называются &lt;em&gt;прямыми аргументами,&lt;/em&gt; чтобы отличать их от &lt;em&gt;агрегированных аргументов.&lt;/em&gt; перечислено в разделе &lt;code&gt;order_by_clause&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;. В отличие от обычных агрегатных аргументов, прямые аргументы оцениваются только один раз за вызов агрегата, а не один раз за входную строку. Это означает, что они могут содержать переменные, только если эти переменные сгруппированы по &lt;code&gt;GROUP BY&lt;/code&gt; ; это ограничение такое же, как если бы прямые аргументы вообще не находились внутри агрегатного выражения. Прямые аргументы обычно используются для таких вещей, как процентильные дроби, которые имеют смысл только как единое значение для расчета агрегирования. Список прямых аргументов может быть пустым; в этом случае пишите просто &lt;code&gt;()&lt;/code&gt; ,а не &lt;code&gt;(*)&lt;/code&gt; . (PostgreSQL фактически принимает любое написание, но только первый способ соответствует стандарту SQL.)</target>
        </trans-unit>
        <trans-unit id="050a736fd59911f8226167a2c6f31c24c2830d29" translate="yes" xml:space="preserve">
          <source>Placing the function in a &lt;code&gt;LATERAL&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; item keeps it from being invoked more than once per row. &lt;code&gt;m.*&lt;/code&gt; is still expanded into &lt;code&gt;m.a, m.b, m.c&lt;/code&gt;, but now those variables are just references to the output of the &lt;code&gt;FROM&lt;/code&gt; item. (The &lt;code&gt;LATERAL&lt;/code&gt; keyword is optional here, but we show it to clarify that the function is getting &lt;code&gt;x&lt;/code&gt; from &lt;code&gt;some_table&lt;/code&gt;.)</source>
          <target state="translated">Размещение функции в элементе &lt;code&gt;LATERAL&lt;/code&gt; &lt;code&gt;FROM&lt;/code&gt; предотвращает ее повторный вызов для каждой строки. &lt;code&gt;m.*&lt;/code&gt; по-прежнему расширяется до &lt;code&gt;m.a, m.b, m.c&lt;/code&gt; , но теперь эти переменные являются просто ссылками на вывод элемента &lt;code&gt;FROM&lt;/code&gt; . (The &lt;code&gt;LATERAL&lt;/code&gt; необязательное ключевое слово здесь, но мы покажем это уточнить , что функция получает &lt;code&gt;x&lt;/code&gt; от &lt;code&gt;some_table&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="b4a1219ff91be25a0770f7df590b928d12b8a2c5" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;) simply reclaims space and makes it available for re-use. This form of the command can operate in parallel with normal reading and writing of the table, as an exclusive lock is not obtained. However, extra space is not returned to the operating system (in most cases); it's just kept available for re-use within the same table. &lt;code&gt;VACUUM FULL&lt;/code&gt; rewrites the entire contents of the table into a new disk file with no extra space, allowing unused space to be returned to the operating system. This form is much slower and requires an exclusive lock on each table while it is being processed.</source>
          <target state="translated">Обычный &lt;code&gt;VACUUM&lt;/code&gt; (без &lt;code&gt;FULL&lt;/code&gt; ) просто освобождает пространство и делает его доступным для повторного использования. Эта форма команды может работать параллельно с обычным чтением и записью таблицы, поскольку исключительная блокировка не достигается. Однако лишнее пространство операционной системе не возвращается (в большинстве случаев); он просто доступен для повторного использования в той же таблице. &lt;code&gt;VACUUM FULL&lt;/code&gt; перезаписывает все содержимое таблицы в новый дисковый файл без лишнего пространства, позволяя вернуть неиспользуемое пространство операционной системе. Эта форма работает намного медленнее и требует исключительной блокировки каждой таблицы во время ее обработки.</target>
        </trans-unit>
        <trans-unit id="cdc70d31ed5da3eee47809b4dd230782b8f8497b" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;) simply reclaims space and makes it available for re-use. This form of the command can operate in parallel with normal reading and writing of the table, as an exclusive lock is not obtained. However, extra space is not returned to the operating system (in most cases); it's just kept available for re-use within the same table. It also allows us to leverage multiple CPUs in order to process indexes. This feature is known as &lt;em&gt;parallel vacuum&lt;/em&gt;. To disable this feature, one can use &lt;code&gt;PARALLEL&lt;/code&gt; option and specify parallel workers as zero. &lt;code&gt;VACUUM FULL&lt;/code&gt; rewrites the entire contents of the table into a new disk file with no extra space, allowing unused space to be returned to the operating system. This form is much slower and requires an exclusive lock on each table while it is being processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8499132893d83a3f2ae11d9668e227a0e6596484" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; may not be satisfactory when a table contains large numbers of dead row versions as a result of massive update or delete activity. If you have such a table and you need to reclaim the excess disk space it occupies, you will need to use &lt;code&gt;VACUUM FULL&lt;/code&gt;, or alternatively &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the table-rewriting variants of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. These commands rewrite an entire new copy of the table and build new indexes for it. All these options require exclusive lock. Note that they also temporarily use extra disk space approximately equal to the size of the table, since the old copies of the table and indexes can't be released until the new ones are complete.</source>
          <target state="translated">Обычный &lt;code&gt;VACUUM&lt;/code&gt; может быть неудовлетворительным, если таблица содержит большое количество версий мертвых строк в результате массового обновления или удаления. Если у вас есть такая таблица и вам нужно освободить лишнее дисковое пространство, которое она занимает, вам нужно будет использовать &lt;code&gt;VACUUM FULL&lt;/code&gt; или, альтернативно, &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER,&lt;/a&gt; или один из вариантов перезаписи таблиц &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; . Эти команды полностью переписывают новую копию таблицы и строят для нее новые индексы. Все эти опции требуют эксклюзивной блокировки. Обратите внимание, что они также временно используют дополнительное дисковое пространство, примерно равное размеру таблицы, поскольку старые копии таблицы и индексов не могут быть освобождены, пока не будут созданы новые.</target>
        </trans-unit>
        <trans-unit id="a9dba597737e71648392c996cea122250f0bead7" translate="yes" xml:space="preserve">
          <source>Plan nodes to which an &lt;code&gt;InitPlan&lt;/code&gt; is attached.</source>
          <target state="translated">Узлы планирования, к которым прикреплен &lt;code&gt;InitPlan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bae7f24c9eebd1039795f1be6ffdf3da89d373b" translate="yes" xml:space="preserve">
          <source>Plan nodes which reference a correlated &lt;code&gt;SubPlan&lt;/code&gt;.</source>
          <target state="translated">Узлы плана, которые ссылаются на коррелированный &lt;code&gt;SubPlan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd8eca8ef866c5503502580ce3a00558f59a9928" translate="yes" xml:space="preserve">
          <source>Plannable queries (that is, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;) are combined into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry whenever they have identical query structures according to an internal hash calculation. Typically, two queries will be considered the same for this purpose if they are semantically equivalent except for the values of literal constants appearing in the query. Utility commands (that is, all other commands) are compared strictly on the basis of their textual query strings, however.</source>
          <target state="translated">Планируемые запросы (то есть &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; ) объединяются в одну запись &lt;code&gt;pg_stat_statements&lt;/code&gt; всякий раз, когда они имеют идентичные структуры запроса в соответствии с внутренним вычислением хэша. Обычно для этой цели два запроса будут считаться одинаковыми, если они семантически эквивалентны, за исключением значений литеральных констант, появляющихся в запросе. Однако служебные команды (то есть все остальные команды) сравниваются строго на основе их текстовых строк запроса.</target>
        </trans-unit>
        <trans-unit id="1c065dbb4470e9d21b7a921d317fd42a4a204fc8" translate="yes" xml:space="preserve">
          <source>Planner Statistics and Security</source>
          <target state="translated">Статистика планирования и безопасности</target>
        </trans-unit>
        <trans-unit id="20ef8925a22326d996284c55f97493dce8cb35b8" translate="yes" xml:space="preserve">
          <source>Planner/Optimizer</source>
          <target state="translated">Planner/Optimizer</target>
        </trans-unit>
        <trans-unit id="88b7699abe5df4b9c91f2b6e5ea1aabcde7ea7fc" translate="yes" xml:space="preserve">
          <source>Plans and resources - &lt;code&gt;PREPARE&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DEALLOCATE&lt;/code&gt;, &lt;code&gt;DISCARD&lt;/code&gt;</source>
          <target state="translated">Планы и ресурсы - &lt;code&gt;PREPARE&lt;/code&gt; , &lt;code&gt;EXECUTE&lt;/code&gt; , &lt;code&gt;DEALLOCATE&lt;/code&gt; , &lt;code&gt;DISCARD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e7c7717c711ec0c456d95556daba5b3b636c0d1" translate="yes" xml:space="preserve">
          <source>Plans and resources: &lt;code&gt;PREPARE&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DEALLOCATE&lt;/code&gt;, &lt;code&gt;DISCARD&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e74c5b37f496e9f5820d20828439504e47ddb6" translate="yes" xml:space="preserve">
          <source>Please enter all the commands shown above so you have some data to work with in the following sections.</source>
          <target state="translated">Пожалуйста,введите все команды,показанные выше,чтобы у Вас были некоторые данные для работы в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="a932052bd8c1c2c9d99c8557aa55ac6cb1e71319" translate="yes" xml:space="preserve">
          <source>Please note that you may see some or all of the following notifications depending on the particular versions you have of libselinux and selinux-policy:</source>
          <target state="translated">Пожалуйста,обратите внимание,что вы можете увидеть некоторые или все из следующих уведомлений в зависимости от конкретных версий libselinux и selinux-policy:</target>
        </trans-unit>
        <trans-unit id="0db2f66cabcb72c7d5c5552d7794e37b6384e5d6" translate="yes" xml:space="preserve">
          <source>Please note the following points when using the generic WAL record facility:</source>
          <target state="translated">Пожалуйста,обратите внимание на следующие моменты при использовании общей системы записи WAL:</target>
        </trans-unit>
        <trans-unit id="86f9d988d7b8b2829ff9e18a117a22f3c6c12cda" translate="yes" xml:space="preserve">
          <source>Pluggable Authentication Modules</source>
          <target state="translated">Подключаемые модули аутентификации</target>
        </trans-unit>
        <trans-unit id="3dfb3c336b3693041700e2e10c00427b27b0180f" translate="yes" xml:space="preserve">
          <source>Plugins and extensions - &lt;code&gt;LOAD&lt;/code&gt;</source>
          <target state="translated">Плагины и расширения - &lt;code&gt;LOAD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfc627985ddf6332a8ae76b6d6e7fac5e923c727" translate="yes" xml:space="preserve">
          <source>Plugins and extensions: &lt;code&gt;LOAD&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efefb1be830f67be53a399ad23055160dfbce160" translate="yes" xml:space="preserve">
          <source>Plus operator that iterates over the SQL/JSON sequence</source>
          <target state="translated">Плюс оператор,выполняющий итерацию над последовательностью SQL/JSON</target>
        </trans-unit>
        <trans-unit id="65afde293357ae741287178244c36bbcce3cc736" translate="yes" xml:space="preserve">
          <source>Point on a plane</source>
          <target state="translated">Точка в самолете</target>
        </trans-unit>
        <trans-unit id="609adbe0655f07f14c79208d551f8d9718fabd23" translate="yes" xml:space="preserve">
          <source>Point or box of intersection</source>
          <target state="translated">Точка или коробка пересечения</target>
        </trans-unit>
        <trans-unit id="09812b4d0aeaa487df4bde731b3996675a249aaa" translate="yes" xml:space="preserve">
          <source>Points are output using the first syntax.</source>
          <target state="translated">Точки выводятся с использованием первого синтаксиса.</target>
        </trans-unit>
        <trans-unit id="44c9844a5c8235f295a2612b30b79553235db5c0" translate="yes" xml:space="preserve">
          <source>Points are the fundamental two-dimensional building block for geometric types. Values of type &lt;code&gt;point&lt;/code&gt; are specified using either of the following syntaxes:</source>
          <target state="translated">Точки - это фундаментальный двухмерный строительный блок для геометрических типов. Значения типа &lt;code&gt;point&lt;/code&gt; указываются с использованием любого из следующих синтаксисов:</target>
        </trans-unit>
        <trans-unit id="7f6158e808f6832883a61fff6f7473e7ffa8d937" translate="yes" xml:space="preserve">
          <source>Points to note:</source>
          <target state="translated">Очки для заметки:</target>
        </trans-unit>
        <trans-unit id="da968837807c4a4627a6c38281eebcac2e2aa0b7" translate="yes" xml:space="preserve">
          <source>Policies are created using the &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; command, altered using the &lt;a href=&quot;sql-alterpolicy&quot;&gt;ALTER POLICY&lt;/a&gt; command, and dropped using the &lt;a href=&quot;sql-droppolicy&quot;&gt;DROP POLICY&lt;/a&gt; command. To enable and disable row security for a given table, use the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command.</source>
          <target state="translated">Политики создаются с помощью команды &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; , изменяются с помощью команды &lt;a href=&quot;sql-alterpolicy&quot;&gt;ALTER POLICY&lt;/a&gt; и удаляются с помощью команды &lt;a href=&quot;sql-droppolicy&quot;&gt;DROP POLICY&lt;/a&gt; . Чтобы включить или отключить защиту строк для данной таблицы, используйте команду &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1624c281a60434d712e179fdb6ff898796130b43" translate="yes" xml:space="preserve">
          <source>Policies can be applied for specific commands or for specific roles. The default for newly created policies is that they apply for all commands and roles, unless otherwise specified. Multiple policies may apply to a single command; see below for more details. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;Table 256&lt;/a&gt; summarizes how the different types of policy apply to specific commands.</source>
          <target state="translated">Политики можно применять для определенных команд или для определенных ролей. По умолчанию вновь созданные политики применяются ко всем командам и ролям, если не указано иное. К одной команде может применяться несколько политик; Подробности смотрите ниже. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;В таблице 256&lt;/a&gt; показано, как разные типы политики применяются к конкретным командам.</target>
        </trans-unit>
        <trans-unit id="ea4ac1b26dd811200c863a2d28d42117a994a64e" translate="yes" xml:space="preserve">
          <source>Policies can be applied for specific commands or for specific roles. The default for newly created policies is that they apply for all commands and roles, unless otherwise specified. Multiple policies may apply to a single command; see below for more details. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;Table 272&lt;/a&gt; summarizes how the different types of policy apply to specific commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9218496f73981d3e04361890ce5e81c103eeff2b" translate="yes" xml:space="preserve">
          <source>Policies stored in &lt;code&gt;pg_policy&lt;/code&gt; are applied only when &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relrowsecurity&lt;/code&gt; is set for their table.</source>
          <target state="translated">Политики, хранящиеся в &lt;code&gt;pg_policy&lt;/code&gt; , применяются только тогда, когда &lt;code&gt;pg_class&lt;/code&gt; . Для их стола установлена &lt;code&gt;relrowsecurity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64fe90225d9ffc87de024a67667003d6e6192eb8" translate="yes" xml:space="preserve">
          <source>Policy names are per-table. Therefore, one policy name can be used for many different tables and have a definition for each table which is appropriate to that table.</source>
          <target state="translated">Названия политик указаны для каждой таблицы.Поэтому одно имя политики может использоваться для множества различных таблиц и иметь определение для каждой таблицы,соответствующее этой таблице.</target>
        </trans-unit>
        <trans-unit id="a028a9272b54da3da6db504ed096a2910de4d948" translate="yes" xml:space="preserve">
          <source>Polygon (similar to closed path)</source>
          <target state="translated">Полигон (похожий на замкнутый путь)</target>
        </trans-unit>
        <trans-unit id="358c4e4d5755c21f01067425fdfdaf1bfdcb7099" translate="yes" xml:space="preserve">
          <source>Polygons are output using the first syntax.</source>
          <target state="translated">Полигоны выводятся с использованием первого синтаксиса.</target>
        </trans-unit>
        <trans-unit id="7fb66bc5a7ec5dcfcc725c19a5a1e5c03cd32e7e" translate="yes" xml:space="preserve">
          <source>Polygons are represented by lists of points (the vertexes of the polygon). Polygons are very similar to closed paths, but are stored differently and have their own set of support routines.</source>
          <target state="translated">Многоугольники представлены списками точек (вершин многоугольника).Полигоны очень похожи на закрытые пути,но хранятся по-разному и имеют свой собственный набор поддерживающих процедур.</target>
        </trans-unit>
        <trans-unit id="931d8d1ab098337b34a524e4f5275bb68856723d" translate="yes" xml:space="preserve">
          <source>Popular examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274e42ad6449f3252ec5038abe402083876dea88" translate="yes" xml:space="preserve">
          <source>Populating a Database</source>
          <target state="translated">Пополнение базы данных</target>
        </trans-unit>
        <trans-unit id="367461ddb82787c5535ecce370eaabdc51b55d46" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent executing the statement, in milliseconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbc9b4eb9f4bb4e95de4acb2d6d7f0b43e20913" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent in the statement, in milliseconds</source>
          <target state="translated">Стандартное отклонение времени,затраченного населением на отчет,в миллисекундах</target>
        </trans-unit>
        <trans-unit id="75494ee8f234525fd82a1234cd1d741493f67113" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384cecb2d7b1b2012eaea272977d2cf0c551884e" translate="yes" xml:space="preserve">
          <source>Port number of the PostgreSQL instance this WAL receiver is connected to.</source>
          <target state="translated">Номер порта экземпляра PostgreSQL,к которому подключен этот WAL приемник.</target>
        </trans-unit>
        <trans-unit id="008e62801aaa400319958b2b2b06cc2182c60162" translate="yes" xml:space="preserve">
          <source>Port number on LDAP server to connect to. If no port is specified, the LDAP library's default port setting will be used.</source>
          <target state="translated">Номер порта на LDAP сервере для подключения.Если порт не указан,будет использоваться настройка порта библиотеки LDAP по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c75704d05c6e22d0fdf67c00eb401f9b1c6b139b" translate="yes" xml:space="preserve">
          <source>Portable Operating System Interface</source>
          <target state="translated">Портативный интерфейс операционной системы</target>
        </trans-unit>
        <trans-unit id="e7c56d55f410fd275aaccf8ba063a18761b3e5c0" translate="yes" xml:space="preserve">
          <source>Position values in &lt;code&gt;tsvector&lt;/code&gt; must be greater than 0 and no more than 16,383</source>
          <target state="translated">Значения позиции в &lt;code&gt;tsvector&lt;/code&gt; должны быть больше 0 и не больше 16,383</target>
        </trans-unit>
        <trans-unit id="bbb340fe5bf8594afaa03b969bb8e8f82eef71df" translate="yes" xml:space="preserve">
          <source>Positional notation is the traditional mechanism for passing arguments to functions in PostgreSQL. An example is:</source>
          <target state="translated">Позиционная нотация-это традиционный механизм передачи аргументов в функции PostgreSQL.Примером может служить</target>
        </trans-unit>
        <trans-unit id="dd8bd0b5027f70c1cefa9f905da80fd30083ef2a" translate="yes" xml:space="preserve">
          <source>Possible</source>
          <target state="translated">Possible</target>
        </trans-unit>
        <trans-unit id="6db8a7e83593975ece623b8f9b3fe94d53e8a1b1" translate="yes" xml:space="preserve">
          <source>Possible limitations of the &lt;code&gt;query&lt;/code&gt; clause are documented under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">Возможные ограничения предложения &lt;code&gt;query&lt;/code&gt; описаны в разделе &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">Возможные значения:</target>
        </trans-unit>
        <trans-unit id="e46bf54baa1011e163ced28f70574e61876f70d3" translate="yes" xml:space="preserve">
          <source>Possible variants of the above queries are:</source>
          <target state="translated">Возможны варианты вышеуказанных запросов:</target>
        </trans-unit>
        <trans-unit id="92818ef9b703eafdfca9b984fb83c6ed173e8358" translate="yes" xml:space="preserve">
          <source>Possibly, your site administrator has already created a database for your use. In that case you can omit this step and skip ahead to the next section.</source>
          <target state="translated">Возможно,администратор вашего сайта уже создал базу данных для вашего пользования.В этом случае вы можете опустить этот шаг и перейти к следующему разделу.</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="d31a3cecdd68dfe451de7f17fd71f41b5ec2d2b2" translate="yes" xml:space="preserve">
          <source>PostgreSQL B-Tree indexes are multi-level tree structures, where each level of the tree can be used as a doubly-linked list of pages. A single metapage is stored in a fixed position at the start of the first segment file of the index. All other pages are either leaf pages or internal pages. Leaf pages are the pages on the lowest level of the tree. All other levels consist of internal pages. Each leaf page contains tuples that point to table rows. Each internal page contains tuples that point to the next level down in the tree. Typically, over 99% of all pages are leaf pages. Both internal pages and leaf pages use the standard page format described in &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5bb15ce4cd87c929efa330565ff6d28cd04381" translate="yes" xml:space="preserve">
          <source>PostgreSQL Client Applications</source>
          <target state="translated">Клиентские приложения PostgreSQL</target>
        </trans-unit>
        <trans-unit id="c24f12993bca195ad8365e3a9f46bba7d548c46e" translate="yes" xml:space="preserve">
          <source>PostgreSQL Error Codes</source>
          <target state="translated">Коды ошибок PostgreSQL</target>
        </trans-unit>
        <trans-unit id="179caa7e2f2ae5bcccafd6de1029390b28df93ea" translate="yes" xml:space="preserve">
          <source>PostgreSQL Extension System</source>
          <target state="translated">Система расширения PostgreSQL</target>
        </trans-unit>
        <trans-unit id="bde4caa4f627d1ed1cd6258230a52653ae368364" translate="yes" xml:space="preserve">
          <source>PostgreSQL Limits</source>
          <target state="translated">Пределы PostgreSQL</target>
        </trans-unit>
        <trans-unit id="831c73ba52cb3a865742b364e490e3d33fd67271" translate="yes" xml:space="preserve">
          <source>PostgreSQL Log Sequence Number</source>
          <target state="translated">Номер последовательности журнала PostgreSQL</target>
        </trans-unit>
        <trans-unit id="d6e7156cbc0b3b93da375064bee0966e60cdb8ac" translate="yes" xml:space="preserve">
          <source>PostgreSQL Rule System</source>
          <target state="translated">Система правил PostgreSQL</target>
        </trans-unit>
        <trans-unit id="452e61af45168fd75ac971dbf646f72b427da732" translate="yes" xml:space="preserve">
          <source>PostgreSQL Server Applications</source>
          <target state="translated">Серверные приложения PostgreSQL</target>
        </trans-unit>
        <trans-unit id="67fae22a18c43950aa1922954f1d91e59073538b" translate="yes" xml:space="preserve">
          <source>PostgreSQL User Account</source>
          <target state="translated">Учетная запись пользователя PostgreSQL</target>
        </trans-unit>
        <trans-unit id="2764cd9d3bf007f792e3e2fc4a68faeb55344442" translate="yes" xml:space="preserve">
          <source>PostgreSQL accesses certain on-disk information via &lt;em&gt;SLRU&lt;/em&gt; (simple least-recently-used) caches. The &lt;code&gt;pg_stat_slru&lt;/code&gt; view will contain one row for each tracked SLRU cache, showing statistics about access to cached pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ec2d5a5859a9a3bd680edc1c2f24695d8620d3" translate="yes" xml:space="preserve">
          <source>PostgreSQL actually treats every SQL statement as being executed within a transaction. If you do not issue a &lt;code&gt;BEGIN&lt;/code&gt; command, then each individual statement has an implicit &lt;code&gt;BEGIN&lt;/code&gt; and (if successful) &lt;code&gt;COMMIT&lt;/code&gt; wrapped around it. A group of statements surrounded by &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; is sometimes called a &lt;em&gt;transaction block&lt;/em&gt;.</source>
          <target state="translated">PostgreSQL фактически рассматривает каждый оператор SQL как выполняемый в рамках транзакции. Если вы не вводите команду &lt;code&gt;BEGIN&lt;/code&gt; , тогда каждый отдельный оператор имеет неявные &lt;code&gt;BEGIN&lt;/code&gt; и (в случае успеха) &lt;code&gt;COMMIT&lt;/code&gt; , обернутые вокруг него. Группа операторов, окруженная &lt;code&gt;BEGIN&lt;/code&gt; и &lt;code&gt;COMMIT&lt;/code&gt; , иногда называется &lt;em&gt;блоком транзакции&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a08fed9d9b5168502be31cd2bf857824ed3fb1b6" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; to be used as &lt;code&gt;WITH&lt;/code&gt; queries. This is not found in the SQL standard.</source>
          <target state="translated">PostgreSQL позволяет использовать &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; как запросы &lt;code&gt;WITH&lt;/code&gt; . Этого нет в стандарте SQL.</target>
        </trans-unit>
        <trans-unit id="4ae0ed23837a44ee80fff5d2d48a225d0adbd095" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a function call to be written directly as a member of the &lt;code&gt;FROM&lt;/code&gt; list. In the SQL standard it would be necessary to wrap such a function call in a sub-&lt;code&gt;SELECT&lt;/code&gt;; that is, the syntax &lt;code&gt;FROM func(...) alias&lt;/code&gt; is approximately equivalent to &lt;code&gt;FROM LATERAL (SELECT func(...)) alias&lt;/code&gt;. Note that &lt;code&gt;LATERAL&lt;/code&gt; is considered to be implicit; this is because the standard requires &lt;code&gt;LATERAL&lt;/code&gt; semantics for an &lt;code&gt;UNNEST()&lt;/code&gt; item in &lt;code&gt;FROM&lt;/code&gt;. PostgreSQL treats &lt;code&gt;UNNEST()&lt;/code&gt; the same as other set-returning functions.</source>
          <target state="translated">PostgreSQL позволяет записывать вызов функции непосредственно как член списка &lt;code&gt;FROM&lt;/code&gt; . В стандарте SQL было бы необходимо заключить такой вызов функции во вложенный &lt;code&gt;SELECT&lt;/code&gt; ; то есть синтаксис &lt;code&gt;FROM func(...) alias&lt;/code&gt; приблизительно эквивалентен псевдониму &lt;code&gt;FROM LATERAL (SELECT func(...)) alias&lt;/code&gt; . Обратите внимание, что &lt;code&gt;LATERAL&lt;/code&gt; считается неявным; это потому, что стандарт требует &lt;code&gt;LATERAL&lt;/code&gt; семантики для &lt;code&gt;UNNEST()&lt;/code&gt; в &lt;code&gt;FROM&lt;/code&gt; . PostgreSQL обрабатывает &lt;code&gt;UNNEST()&lt;/code&gt; же, как и другие функции, возвращающие набор.</target>
        </trans-unit>
        <trans-unit id="1fec2c228fe0347b7815e3014f29d97d5a87acca" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a table of no columns to be created (for example, &lt;code&gt;CREATE TABLE foo();&lt;/code&gt;). This is an extension from the SQL standard, which does not allow zero-column tables. Zero-column tables are not in themselves very useful, but disallowing them creates odd special cases for &lt;code&gt;ALTER TABLE DROP COLUMN&lt;/code&gt;, so it seems cleaner to ignore this spec restriction.</source>
          <target state="translated">PostgreSQL позволяет создавать таблицы без столбцов (например, &lt;code&gt;CREATE TABLE foo();&lt;/code&gt; ). Это расширение стандарта SQL, которое не позволяет использовать таблицы с нулевым столбцом. Таблицы с нулевым столбцом сами по себе не очень полезны, но их запрет создает странные особые случаи для &lt;code&gt;ALTER TABLE DROP COLUMN&lt;/code&gt; , поэтому кажется более правильным игнорировать это ограничение спецификации.</target>
        </trans-unit>
        <trans-unit id="5a502e4f8d9c2660f0a8eba2540286883c5cd8c9" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a table to have more than one identity column. The standard specifies that a table can have at most one identity column. This is relaxed mainly to give more flexibility for doing schema changes or migrations. Note that the &lt;code&gt;INSERT&lt;/code&gt; command supports only one override clause that applies to the entire statement, so having multiple identity columns with different behaviors is not well supported.</source>
          <target state="translated">PostgreSQL позволяет таблице иметь более одного столбца идентификаторов. Стандарт определяет, что таблица может иметь не более одного столбца идентификаторов. Это ослаблено в основном для большей гибкости при изменении схемы или миграции. Обратите внимание, что команда &lt;code&gt;INSERT&lt;/code&gt; поддерживает только одно предложение переопределения, которое применяется ко всему оператору, поэтому наличие нескольких столбцов идентификаторов с различным поведением не поддерживается.</target>
        </trans-unit>
        <trans-unit id="b3ae4855b2a3e72640693b7d20d3ad5d9fb47042" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a trailing &lt;code&gt;*&lt;/code&gt; to be written to explicitly specify the non-&lt;code&gt;ONLY&lt;/code&gt; behavior of including child tables. The standard does not allow this.</source>
          <target state="translated">PostgreSQL позволяет записывать завершающий &lt;code&gt;*&lt;/code&gt; , чтобы явно указать не &lt;code&gt;ONLY&lt;/code&gt; поведение включения дочерних таблиц. Стандарт не допускает этого.</target>
        </trans-unit>
        <trans-unit id="0222c8fe2334be83692d30a209d5aa08ec24134f" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows an object owner to revoke their own ordinary privileges: for example, a table owner can make the table read-only to themselves by revoking their own &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;TRUNCATE&lt;/code&gt; privileges. This is not possible according to the SQL standard. The reason is that PostgreSQL treats the owner's privileges as having been granted by the owner to themselves; therefore they can revoke them too. In the SQL standard, the owner's privileges are granted by an assumed entity &amp;ldquo;_SYSTEM&amp;rdquo;. Not being &amp;ldquo;_SYSTEM&amp;rdquo;, the owner cannot revoke these rights.</source>
          <target state="translated">PostgreSQL позволяет владельцу объекта отзывать свои обычные привилегии: например, владелец таблицы может сделать таблицу доступной только для чтения, отозвав свои собственные привилегии &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; и &lt;code&gt;TRUNCATE&lt;/code&gt; . Это невозможно в соответствии со стандартом SQL. Причина в том, что PostgreSQL рассматривает права владельца как предоставленные им самим; поэтому они тоже могут их отозвать. В стандарте SQL права владельца предоставляются предполагаемой сущностью &amp;laquo;_SYSTEM&amp;raquo;. Не являясь &amp;laquo;_SYSTEM&amp;raquo;, владелец не может отозвать эти права.</target>
        </trans-unit>
        <trans-unit id="d75f3d8cbebcea3de67f82faaf69d14b5b967380" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows columns of a table to be defined as variable-length multidimensional arrays. Arrays of any built-in or user-defined base type, enum type, composite type, range type, or domain can be created.</source>
          <target state="translated">PostgreSQL позволяет определять столбцы таблицы как многомерные массивы переменной длины.Можно создавать массивы любого встроенного или заданного пользователем базового типа,типа перечисления,составного типа,типа диапазона или домена.</target>
        </trans-unit>
        <trans-unit id="06987dbdd7bcd6dca55a6bfbcab96569673d7620" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows conversion between any two character sets for which a conversion function is listed in the &lt;a href=&quot;catalog-pg-conversion&quot;&gt;&lt;code&gt;pg_conversion&lt;/code&gt;&lt;/a&gt; system catalog. PostgreSQL comes with some predefined conversions, as summarized in &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;Table 23.2&lt;/a&gt; and shown in more detail in &lt;a href=&quot;multibyte#BUILTIN-CONVERSIONS-TABLE&quot;&gt;Table 23.3&lt;/a&gt;. You can create a new conversion using the SQL command &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt;. (To be used for automatic client/server conversions, a conversion must be marked as &amp;ldquo;default&amp;rdquo; for its character set pair.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbdf4cafaaa4dcf65d19eea36b6d2663f13d7b7" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows database sessions to synchronize their snapshots. A &lt;em&gt;snapshot&lt;/em&gt; determines which data is visible to the transaction that is using the snapshot. Synchronized snapshots are necessary when two or more sessions need to see identical content in the database. If two sessions just start their transactions independently, there is always a possibility that some third transaction commits between the executions of the two &lt;code&gt;START TRANSACTION&lt;/code&gt; commands, so that one session sees the effects of that transaction and the other does not.</source>
          <target state="translated">PostgreSQL позволяет сеансам базы данных синхронизировать свои снимки. &lt;em&gt;Снимок&lt;/em&gt; определяет , который виден данные транзакции , которая использует снимок. Синхронизированные моментальные снимки необходимы, когда двум или более сеансам необходимо видеть идентичный контент в базе данных. Если два сеанса просто начинают свои транзакции независимо друг от друга, всегда существует вероятность того, что какая-то третья транзакция зафиксируется между выполнением двух команд &lt;code&gt;START TRANSACTION&lt;/code&gt; , так что один сеанс видит эффекты этой транзакции, а другой - нет.</target>
        </trans-unit>
        <trans-unit id="2f376988cf3adab23de6270e27f2d8af7b43d3dc" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows expressions with prefix and postfix unary (one-argument) operators, as well as binary (two-argument) operators. Like functions, operators can be overloaded, so the same problem of selecting the right operator exists.</source>
          <target state="translated">PostgreSQL позволяет использовать выражения с префиксными и постфиксными унарными (однопараметрическими)операторами,а также двоичными (двухпараметрическими)операторами.Как и функции,операторы могут быть перегружены,поэтому существует такая же проблема выбора нужного оператора.</target>
        </trans-unit>
        <trans-unit id="38e06aff61270fa25d3a83fecc14dbc49c17fa73" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows function &lt;em&gt;overloading&lt;/em&gt;; that is, the same name can be used for several different functions so long as they have distinct input argument types. Whether or not you use it, this capability entails security precautions when calling functions in databases where some users mistrust other users; see &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL допускает &lt;em&gt;перегрузку&lt;/em&gt; функций ; то есть одно и то же имя может использоваться для нескольких разных функций, если у них разные типы входных аргументов. Независимо от того, используете ли вы ее или нет, эта возможность предполагает меры безопасности при вызове функций в базах данных, где некоторые пользователи не доверяют другим пользователям; см. &lt;a href=&quot;typeconv-func&quot;&gt;Раздел 10.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="885786b4f5cdfbf8b703cb2cdbcec19a632c472d" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows functions that have named parameters to be called using either &lt;em&gt;positional&lt;/em&gt; or &lt;em&gt;named&lt;/em&gt; notation. Named notation is especially useful for functions that have a large number of parameters, since it makes the associations between parameters and actual arguments more explicit and reliable. In positional notation, a function call is written with its argument values in the same order as they are defined in the function declaration. In named notation, the arguments are matched to the function parameters by name and can be written in any order. For each notation, also consider the effect of function argument types, documented in &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL позволяет вызывать функции с именованными параметрами, используя &lt;em&gt;позиционную&lt;/em&gt; или &lt;em&gt;именованную&lt;/em&gt; нотацию. Именованная нотация особенно полезна для функций с большим количеством параметров, поскольку она делает связи между параметрами и фактическими аргументами более явными и надежными. В позиционной записи вызов функции записывается со значениями аргументов в том же порядке, в каком они определены в объявлении функции. В именованной нотации аргументы соответствуют параметрам функции по имени и могут быть записаны в любом порядке. Для каждой нотации также рассмотрите влияние типов аргументов функции, описанное в &lt;a href=&quot;typeconv-func&quot;&gt;Разделе 10.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccedf68ac95013795d6781ac353bb002bbdac9bd" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows identifier syntax (&lt;code&gt;&quot;rolename&quot;&lt;/code&gt;), while the SQL standard requires the role name to be written as a string literal. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="translated">PostgreSQL допускает синтаксис идентификатора ( &lt;code&gt;&quot;rolename&quot;&lt;/code&gt; ), тогда как стандарт SQL требует, чтобы имя роли было записано в виде строкового литерала. SQL не разрешает эту команду во время транзакции; PostgreSQL не накладывает этого ограничения, потому что для этого нет причин. &lt;code&gt;SESSION&lt;/code&gt; и &lt;code&gt;LOCAL&lt;/code&gt; модификаторы расширение PostgreSQL, как это &lt;code&gt;RESET&lt;/code&gt; синтаксиса.</target>
        </trans-unit>
        <trans-unit id="aee304bddb0add35cce98f16acc2e91d76460499" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows one to omit the &lt;code&gt;FROM&lt;/code&gt; clause. It has a straightforward use to compute the results of simple expressions:</source>
          <target state="translated">PostgreSQL позволяет опускать предложение &lt;code&gt;FROM&lt;/code&gt; . Его легко использовать для вычисления результатов простых выражений:</target>
        </trans-unit>
        <trans-unit id="d0eb6de17c126effc5a1502158efa04db9cdf59d" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows only one character set encoding per database. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 will be allowed.</source>
          <target state="translated">PostgreSQL позволяет кодировать только один набор символов для каждой базы данных.Поэтому невозможно жесткое соответствие типов JSON спецификации,если только кодировка БД не UTF8.Попытки напрямую включить символы,которые не могут быть представлены в кодировке БД,будут неудачными;наоборот,будут разрешены символы,которые могут быть представлены в кодировке БД,но не в кодировке UTF8.</target>
        </trans-unit>
        <trans-unit id="6f4d7c19f392d3d32e2ae22627f8334829c75a1e" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows the application developer to specify the durability level required via replication. This can be specified for the system overall, though it can also be specified for specific users or connections, or even individual transactions.</source>
          <target state="translated">PostgreSQL позволяет разработчику приложения задать необходимый уровень прочности с помощью репликации.Этот уровень может быть указан для системы в целом,хотя он также может быть указан для конкретных пользователей или соединений,или даже для отдельных транзакций.</target>
        </trans-unit>
        <trans-unit id="67e964073140451a310c8055af1d484d7e584b05" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows you to specify time zones in three different forms:</source>
          <target state="translated">PostgreSQL позволяет задавать часовые пояса в трех различных формах:</target>
        </trans-unit>
        <trans-unit id="2091ac924b203b9490fe163a62e56fac7f983c3f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also accepts &amp;ldquo;escape&amp;rdquo; string constants, which are an extension to the SQL standard. An escape string constant is specified by writing the letter &lt;code&gt;E&lt;/code&gt; (upper or lower case) just before the opening single quote, e.g., &lt;code&gt;E'foo'&lt;/code&gt;. (When continuing an escape string constant across lines, write &lt;code&gt;E&lt;/code&gt; only before the first opening quote.) Within an escape string, a backslash character (&lt;code&gt;\&lt;/code&gt;) begins a C-like &lt;em&gt;backslash escape&lt;/em&gt; sequence, in which the combination of backslash and following character(s) represent a special byte value, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-BACKSLASH-TABLE&quot;&gt;Table 4.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL также принимает строковые константы &amp;laquo;escape&amp;raquo;, которые являются расширением стандарта SQL. Константа escape-строки указывается путем записи буквы &lt;code&gt;E&lt;/code&gt; (в верхнем или нижнем регистре) непосредственно перед открывающей одинарной &lt;code&gt;E'foo'&lt;/code&gt; , например E'foo ' . (При продолжении константы escape-строки между строками, пишите &lt;code&gt;E&lt;/code&gt; только перед первой открывающей кавычкой.) Внутри escape-строки символ обратной косой черты ( &lt;code&gt;\&lt;/code&gt; ) начинает &lt;em&gt;escape-&lt;/em&gt; последовательность, подобную C , в которой комбинация обратной косой черты и следующего символа ( s) представляют собой особое значение байта, как показано в &lt;a href=&quot;sql-syntax-lexical#SQL-BACKSLASH-TABLE&quot;&gt;таблице 4.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8e26c666446bf180bc1b3bdb6835476bef38f80" translate="yes" xml:space="preserve">
          <source>PostgreSQL also accepts the following alternative forms for input: use of upper-case digits, the standard format surrounded by braces, omitting some or all hyphens, adding a hyphen after any group of four digits. Examples are:</source>
          <target state="translated">PostgreSQL также принимает следующие альтернативные формы ввода:использование заглавных цифр,стандартный формат,окруженный фигурными скобками,опускание некоторых или всех дефисов,добавление дефиса после любой группы из четырёх цифр.Примерами являются:</target>
        </trans-unit>
        <trans-unit id="d551afc59236ea284f4ca849fa7d2277a7469049" translate="yes" xml:space="preserve">
          <source>PostgreSQL also has native support for using GSSAPI to encrypt client/server communications for increased security. Support requires that a GSSAPI implementation (such as MIT krb5) is installed on both client and server systems, and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL также имеет встроенную поддержку использования GSSAPI для шифрования связи клиент / сервер для повышения безопасности. Для поддержки требуется, чтобы реализация GSSAPI (например, MIT krb5) была установлена ​​как на клиентских, так и на серверных системах, и чтобы поддержка в PostgreSQL была включена во время сборки (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Главу 16&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd43f6c5eff3afed0ef2482d92caa74dc0ae8b00" translate="yes" xml:space="preserve">
          <source>PostgreSQL also has native support for using GSSAPI to encrypt client/server communications for increased security. Support requires that a GSSAPI implementation (such as MIT krb5) is installed on both client and server systems, and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7d486aaa9f91eb610db7317aa89991dcace483" translate="yes" xml:space="preserve">
          <source>PostgreSQL also protects against some kinds of data corruption on storage devices that may occur because of hardware errors or media failure over time, such as reading/writing garbage data.</source>
          <target state="translated">PostgreSQL также защищает от некоторых видов повреждений данных на устройствах хранения,которые могут возникнуть из-за аппаратных ошибок или сбоя носителя со временем,например,чтение/запись мусорных данных.</target>
        </trans-unit>
        <trans-unit id="bc4957185fda95801e3489431ec80f6cc95ed9d3" translate="yes" xml:space="preserve">
          <source>PostgreSQL also provides functions that return the start time of the current statement, as well as the actual current time at the instant the function is called. The complete list of non-SQL-standard time functions is:</source>
          <target state="translated">PostgreSQL также предоставляет функции,которые возвращают время начала текущего оператора,а также фактическое текущее время в момент вызова функции.Полный список не-SQL-функций со стандартным временем:</target>
        </trans-unit>
        <trans-unit id="dd1b1c906496b16c3b9719d59a4575ea64702a53" translate="yes" xml:space="preserve">
          <source>PostgreSQL also provides the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; for UUIDs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c105cc11eec562c7842e40a45124c8ca33cfca" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports &lt;em&gt;mixed&lt;/em&gt; notation, which combines positional and named notation. In this case, positional parameters are written first and named parameters appear after them.</source>
          <target state="translated">PostgreSQL также поддерживает &lt;em&gt;смешанную&lt;/em&gt; нотацию, в которой сочетаются позиционная и именованная нотации. В этом случае сначала записываются позиционные параметры, а после них появляются именованные параметры.</target>
        </trans-unit>
        <trans-unit id="ca59eb947715e169590d0f69e1f5c9da2f5d3e56" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports a parameter to strip the realm from the principal. This method is supported for backwards compatibility and is strongly discouraged as it is then impossible to distinguish different users with the same user name but coming from different realms. To enable this, set &lt;code&gt;include_realm&lt;/code&gt; to 0. For simple single-realm installations, doing that combined with setting the &lt;code&gt;krb_realm&lt;/code&gt; parameter (which checks that the principal's realm matches exactly what is in the &lt;code&gt;krb_realm&lt;/code&gt; parameter) is still secure; but this is a less capable approach compared to specifying an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL также поддерживает параметр для удаления области из принципала. Этот метод поддерживается для обратной совместимости и настоятельно не рекомендуется, поскольку в этом случае невозможно различить разных пользователей с одним и тем же именем пользователя, но из разных областей. Чтобы включить это, установите для &lt;code&gt;include_realm&lt;/code&gt; значение 0. Для простых установок с одной сферой выполнение этого в сочетании с установкой параметра &lt;code&gt;krb_realm&lt;/code&gt; (который проверяет, что область главного пользователя точно соответствует тому, что &lt;code&gt;krb_realm&lt;/code&gt; параметре krb_realm ) по-прежнему безопасно; но это менее эффективный подход по сравнению с указанием явного отображения в &lt;code&gt;pg_ident.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b477944494e7d8e126d3d69b3ea2e26c69eb1df" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports another type of escape syntax for strings that allows specifying arbitrary Unicode characters by code point. A Unicode escape string constant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case letter U followed by ampersand) immediately before the opening quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;'foo'&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the string &lt;code&gt;'data'&lt;/code&gt; could be written as</source>
          <target state="translated">PostgreSQL также поддерживает другой тип escape-синтаксиса для строк, который позволяет указывать произвольные символы Unicode по кодовой точке. Константа escape-строки Unicode начинается с &lt;code&gt;U&amp;amp;&lt;/code&gt; (заглавная или строчная буква U, за которой следует амперсанд) непосредственно перед открывающей кавычкой, без пробелов между ними, например &lt;code&gt;U&amp;amp;'foo'&lt;/code&gt; . (Обратите внимание, что это создает двусмысленность с оператором &lt;code&gt;&amp;amp;&lt;/code&gt; . Используйте пробелы вокруг оператора, чтобы избежать этой проблемы.) Внутри кавычек символы Юникода могут быть указаны в экранированной форме, записав обратную косую черту, за которой следует четырехзначный шестнадцатеричный номер кодовой точки или в качестве альтернативы обратная косая черта, за которой следует знак плюс, за которым следует шестизначный шестнадцатеричный номер кодовой точки. Например, строка &lt;code&gt;'data'&lt;/code&gt; можно было бы записать как</target>
        </trans-unit>
        <trans-unit id="8b4d1cfe50623e59a66d0a1accf91a989fc0e27f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports reporting dynamic information about exactly what is going on in the system right now, such as the exact command currently being executed by other server processes, and which other connections exist in the system. This facility is independent of the collector process.</source>
          <target state="translated">PostgreSQL также поддерживает передачу динамической информации о том,что именно происходит в системе в данный момент,например,точная команда,выполняемая в настоящее время другими серверными процессами,и какие другие соединения существуют в системе.Эта возможность не зависит от процесса коллекционирования.</target>
        </trans-unit>
        <trans-unit id="478c7623d400e727e3280b1e79d887e002061f8f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports the SQL-standard notations &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;float(p)&lt;/code&gt; for specifying inexact numeric types. Here, &lt;code&gt;p&lt;/code&gt; specifies the minimum acceptable precision in &lt;em&gt;binary&lt;/em&gt; digits. PostgreSQL accepts &lt;code&gt;float(1)&lt;/code&gt; to &lt;code&gt;float(24)&lt;/code&gt; as selecting the &lt;code&gt;real&lt;/code&gt; type, while &lt;code&gt;float(25)&lt;/code&gt; to &lt;code&gt;float(53)&lt;/code&gt; select &lt;code&gt;double precision&lt;/code&gt;. Values of &lt;code&gt;p&lt;/code&gt; outside the allowed range draw an error. &lt;code&gt;float&lt;/code&gt; with no precision specified is taken to mean &lt;code&gt;double precision&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL также поддерживает стандартные нотации SQL &lt;code&gt;float&lt;/code&gt; и &lt;code&gt;float(p)&lt;/code&gt; для указания неточных числовых типов. Здесь &lt;code&gt;p&lt;/code&gt; указывает минимально допустимую точность &lt;em&gt;двоичных&lt;/em&gt; цифр. PostgreSQL принимает значения от &lt;code&gt;float(1)&lt;/code&gt; до &lt;code&gt;float(24)&lt;/code&gt; как выбор &lt;code&gt;real&lt;/code&gt; типа, а от &lt;code&gt;float(25)&lt;/code&gt; до &lt;code&gt;float(53)&lt;/code&gt; выбирает &lt;code&gt;double precision&lt;/code&gt; . Значения &lt;code&gt;p&lt;/code&gt; вне допустимого диапазона приводят к ошибке. &lt;code&gt;float&lt;/code&gt; без указанной точности означает &lt;code&gt;double precision&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de648c643b7990a2f17212f7c4a34e709bba19e4" translate="yes" xml:space="preserve">
          <source>PostgreSQL always initially presumes that a regular expression follows the ARE rules. However, the more limited ERE or BRE rules can be chosen by prepending an &lt;em&gt;embedded option&lt;/em&gt; to the RE pattern, as described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt;. This can be useful for compatibility with applications that expect exactly the POSIX 1003.2 rules.</source>
          <target state="translated">PostgreSQL всегда изначально предполагает, что регулярное выражение следует правилам ARE. Однако можно выбрать более ограниченные правила ERE или BRE, &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;добавив&lt;/a&gt; к шаблону RE &lt;em&gt;встроенную опцию&lt;/em&gt; , как описано в Разделе 9.7.3.4 . Это может быть полезно для совместимости с приложениями, которые точно соответствуют правилам POSIX 1003.2.</target>
        </trans-unit>
        <trans-unit id="54903aca24fd73df3d0ecfd618b2abc92e61f984" translate="yes" xml:space="preserve">
          <source>PostgreSQL assumes that &lt;code&gt;CHECK&lt;/code&gt; constraints' conditions are immutable, that is, they will always give the same result for the same input row. This assumption is what justifies examining &lt;code&gt;CHECK&lt;/code&gt; constraints only when rows are inserted or updated, and not at other times. (The warning above about not referencing other table data is really a special case of this restriction.)</source>
          <target state="translated">PostgreSQL предполагает, что условия ограничений &lt;code&gt;CHECK&lt;/code&gt; неизменяемы, то есть они всегда будут давать одинаковый результат для одной и той же входной строки. Это предположение оправдывает изучение ограничений &lt;code&gt;CHECK&lt;/code&gt; только тогда, когда строки вставляются или обновляются, а не в другое время. (Приведенное выше предупреждение об отсутствии ссылок на другие данные таблицы на самом деле является частным случаем этого ограничения.)</target>
        </trans-unit>
        <trans-unit id="ff088d9be54485de195a863d4cf5285816323947" translate="yes" xml:space="preserve">
          <source>PostgreSQL assumes that &lt;code&gt;CHECK&lt;/code&gt; constraints' conditions are immutable, that is, they will always give the same result for the same input value. This assumption is what justifies examining &lt;code&gt;CHECK&lt;/code&gt; constraints only when a value is first converted to be of a domain type, and not at other times. (This is essentially the same as the treatment of table &lt;code&gt;CHECK&lt;/code&gt; constraints, as described in &lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-CHECK-CONSTRAINTS&quot;&gt;Section 5.4.1&lt;/a&gt;.)</source>
          <target state="translated">PostgreSQL предполагает, что условия ограничений &lt;code&gt;CHECK&lt;/code&gt; неизменяемы, то есть они всегда будут давать один и тот же результат для одного и того же входного значения. Это предположение оправдывает &lt;code&gt;CHECK&lt;/code&gt; ограничений CHECK только тогда, когда значение сначала преобразуется в доменный тип, а не в другое время. (По сути, это то же самое, что и обработка ограничений таблицы &lt;code&gt;CHECK&lt;/code&gt; , как описано в &lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-CHECK-CONSTRAINTS&quot;&gt;Разделе 5.4.1&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a2bff8b5a2ca5d91db2860fea9c0dad6138d0027" translate="yes" xml:space="preserve">
          <source>PostgreSQL automatically creates a unique index when a unique constraint or primary key is defined for a table. The index covers the columns that make up the primary key or unique constraint (a multicolumn index, if appropriate), and is the mechanism that enforces the constraint.</source>
          <target state="translated">PostgreSQL автоматически создает уникальный индекс,когда для таблицы определено уникальное ограничение или первичный ключ.Индекс охватывает столбцы,которые составляют первичный ключ или уникальное ограничение (многоколоночный индекс,если необходимо),и является механизмом,который обеспечивает соблюдение ограничения.</target>
        </trans-unit>
        <trans-unit id="f26b59affbadfc237829843f54d3c4584d266882" translate="yes" xml:space="preserve">
          <source>PostgreSQL automatically creates an index for each unique constraint and primary key constraint to enforce uniqueness. Thus, it is not necessary to create an index explicitly for primary key columns. (See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for more information.)</source>
          <target state="translated">PostgreSQL автоматически создает индекс для каждого ограничения уникальности и ограничения первичного ключа, чтобы обеспечить уникальность. Таким образом, нет необходимости явно создавать индекс для столбцов первичного ключа. (См. &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; для получения дополнительной информации.)</target>
        </trans-unit>
        <trans-unit id="0b81b71597df376d9c14681a44f3238d9b5f3ccb" translate="yes" xml:space="preserve">
          <source>PostgreSQL can accept time zone specifications that are written according to the POSIX standard's rules for the &lt;code&gt;TZ&lt;/code&gt; environment variable. POSIX time zone specifications are inadequate to deal with the complexity of real-world time zone history, but there are sometimes reasons to use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71faf5408aef54cef3ab5e08ed45e5e43ecd20a6" translate="yes" xml:space="preserve">
          <source>PostgreSQL can build indexes while leveraging multiple CPUs in order to process the table rows faster. This feature is known as &lt;em&gt;parallel index build&lt;/em&gt;. For index methods that support building indexes in parallel (currently, only B-tree), &lt;code&gt;maintenance_work_mem&lt;/code&gt; specifies the maximum amount of memory that can be used by each index build operation as a whole, regardless of how many worker processes were started. Generally, a cost model automatically determines how many worker processes should be requested, if any.</source>
          <target state="translated">PostgreSQL может создавать индексы, используя несколько процессоров, чтобы быстрее обрабатывать строки таблицы. Эта функция известна как построение &lt;em&gt;параллельного индекса&lt;/em&gt; . Для методов индекса, поддерживающих параллельное построение индексов (в настоящее время только B-дерево), &lt;code&gt;maintenance_work_mem&lt;/code&gt; указывает максимальный объем памяти, который может использоваться каждой операцией построения индекса в целом, независимо от того, сколько рабочих процессов было запущено. Как правило, модель затрат автоматически определяет, сколько рабочих процессов должно быть запрошено, если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="b61a24efb840bbdfd7121333fc936cd259d1497d" translate="yes" xml:space="preserve">
          <source>PostgreSQL can sometimes exhaust various operating system resource limits, especially when multiple copies of the server are running on the same system, or in very large installations. This section explains the kernel resources used by PostgreSQL and the steps you can take to resolve problems related to kernel resource consumption.</source>
          <target state="translated">PostgreSQL иногда может исчерпать различные ограничения на ресурсы операционной системы,особенно когда несколько копий сервера работают на одной системе,или в очень больших установках.Этот раздел объясняет ресурсы ядра,используемые PostgreSQL,и шаги,которые вы можете предпринять для решения проблем,связанных с потреблением ресурсов ядра.</target>
        </trans-unit>
        <trans-unit id="b2e725f00d6a809e37502a0cf8c2fc8a68d3f58c" translate="yes" xml:space="preserve">
          <source>PostgreSQL comes with the following built-in range types:</source>
          <target state="translated">PostgreSQL поставляется со следующими встроенными типами диапазонов:</target>
        </trans-unit>
        <trans-unit id="cb387a6689d06faa79aaca21b4c8e065a066ab23" translate="yes" xml:space="preserve">
          <source>PostgreSQL considers distinct collation objects to be incompatible even when they have identical properties. Thus for example,</source>
          <target state="translated">PostgreSQL считает несовместимыми отдельные объекты сопоставления,даже если они имеют одинаковые свойства.Так,например,</target>
        </trans-unit>
        <trans-unit id="390d5417e842d1a1814896813c380671ee3b4fd0" translate="yes" xml:space="preserve">
          <source>PostgreSQL creates a temporary variable of data type &lt;code&gt;stype&lt;/code&gt; to hold the current internal state of the aggregate. At each input row, the aggregate argument value(s) are calculated and the state transition function is invoked with the current state value and the new argument value(s) to calculate a new internal state value. After all the rows have been processed, the final function is invoked once to calculate the aggregate's return value. If there is no final function then the ending state value is returned as-is.</source>
          <target state="translated">PostgreSQL создает временную переменную типа данных &lt;code&gt;stype&lt;/code&gt; для хранения текущего внутреннего состояния агрегата. В каждой входной строке вычисляются агрегированные значения аргументов и вызывается функция перехода состояний с текущим значением состояния и новым значением (значениями) аргумента для вычисления нового значения внутреннего состояния. После обработки всех строк последняя функция вызывается один раз для вычисления возвращаемого значения агрегата. Если конечной функции нет, значение конечного состояния возвращается как есть.</target>
        </trans-unit>
        <trans-unit id="14a71a515034c71c679dfb591fbd291cd9591d60" translate="yes" xml:space="preserve">
          <source>PostgreSQL currently does not support multi-character collating elements. This information describes possible future behavior.</source>
          <target state="translated">PostgreSQL в настоящее время не поддерживает многосимвольные элементы коллекционирования.Эта информация описывает возможное будущее поведение.</target>
        </trans-unit>
        <trans-unit id="7e2fde7f5f9c9a2ecbda1c45fded6817737c8d70" translate="yes" xml:space="preserve">
          <source>PostgreSQL database passwords are separate from operating system user passwords. The password for each database user is stored in the &lt;code&gt;pg_authid&lt;/code&gt; system catalog. Passwords can be managed with the SQL commands &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, e.g., &lt;strong&gt;&lt;code&gt;CREATE ROLE foo WITH LOGIN PASSWORD 'secret'&lt;/code&gt;&lt;/strong&gt;, or the psql command &lt;code&gt;\password&lt;/code&gt;. If no password has been set up for a user, the stored password is null and password authentication will always fail for that user.</source>
          <target state="translated">Пароли базы данных PostgreSQL отделены от паролей пользователей операционной системы. Пароль для каждого пользователя базы данных хранится в системном каталоге &lt;code&gt;pg_authid&lt;/code&gt; . Паролями можно управлять с помощью команд SQL &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; и &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; , например, &lt;strong&gt; &lt;code&gt;CREATE ROLE foo WITH LOGIN PASSWORD 'secret'&lt;/code&gt; &lt;/strong&gt; или psql command &lt;code&gt;\password&lt;/code&gt; . Если для пользователя не установлен пароль, сохраненный пароль является нулевым, и аутентификация по паролю для этого пользователя всегда будет неудачной.</target>
        </trans-unit>
        <trans-unit id="ae07be10ad05f8eb77e791ce859f3046663e8d9e" translate="yes" xml:space="preserve">
          <source>PostgreSQL databases require periodic maintenance known as &lt;em&gt;vacuuming&lt;/em&gt;. For many installations, it is sufficient to let vacuuming be performed by the &lt;em&gt;autovacuum daemon&lt;/em&gt;, which is described in &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;. You might need to adjust the autovacuuming parameters described there to obtain best results for your situation. Some database administrators will want to supplement or replace the daemon's activities with manually-managed &lt;code&gt;VACUUM&lt;/code&gt; commands, which typically are executed according to a schedule by cron or Task Scheduler scripts. To set up manually-managed vacuuming properly, it is essential to understand the issues discussed in the next few subsections. Administrators who rely on autovacuuming may still wish to skim this material to help them understand and adjust autovacuuming.</source>
          <target state="translated">Базы данных PostgreSQL требуют периодического обслуживания, известного как &lt;em&gt;очистка&lt;/em&gt; . Для многих установок достаточно, чтобы &lt;em&gt;очистка выполнялась демоном автоочистки&lt;/em&gt; , который описан в &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Разделе 24.1.6&lt;/a&gt; . Возможно, вам придется отрегулировать описанные здесь параметры автовакуумирования, чтобы получить наилучшие результаты для вашей ситуации. Некоторые администраторы баз данных захотят дополнить или заменить действия демона управляемым вручную &lt;code&gt;VACUUM&lt;/code&gt; команды, которые обычно выполняются по расписанию скриптами cron или Task Scheduler. Чтобы правильно настроить управляемую вручную очистку, важно понимать вопросы, обсуждаемые в следующих нескольких подразделах. Администраторы, которые полагаются на автоматическую очистку, могут по-прежнему просматривать этот материал, чтобы помочь им понять и настроить автоматическую очистку.</target>
        </trans-unit>
        <trans-unit id="0b15ec468b17952447cfdd51a679958ed70d2e48" translate="yes" xml:space="preserve">
          <source>PostgreSQL devises a &lt;em&gt;query plan&lt;/em&gt; for each query it receives. Choosing the right plan to match the query structure and the properties of the data is absolutely critical for good performance, so the system includes a complex &lt;em&gt;planner&lt;/em&gt; that tries to choose good plans. You can use the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command to see what query plan the planner creates for any query. Plan-reading is an art that requires some experience to master, but this section attempts to cover the basics.</source>
          <target state="translated">PostgreSQL разрабатывает &lt;em&gt;план запроса&lt;/em&gt; для каждого полученного запроса. Выбор правильного плана, соответствующего структуре запроса и свойствам данных, абсолютно важен для хорошей производительности, поэтому система включает в себя сложный &lt;em&gt;планировщик,&lt;/em&gt; который пытается выбрать хорошие планы. Вы можете использовать команду &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN,&lt;/a&gt; чтобы увидеть, какой план запроса создает планировщик для любого запроса. Чтение плана - это искусство, для овладения которым требуется некоторый опыт, но в этом разделе мы попытаемся охватить основы.</target>
        </trans-unit>
        <trans-unit id="c6bdc7ca1f027f4e423efc6001869a2aac8718c0" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not have an explicit &lt;code&gt;OPEN&lt;/code&gt; cursor statement; a cursor is considered open when it is declared. Use the &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; statement to declare a cursor.</source>
          <target state="translated">PostgreSQL не имеет явного оператора &lt;code&gt;OPEN&lt;/code&gt; курсора; курсор считается открытым при его объявлении. Используйте &lt;a href=&quot;sql-declare&quot;&gt;оператор DECLARE,&lt;/a&gt; чтобы объявить курсор.</target>
        </trans-unit>
        <trans-unit id="0dfef93504eab39387d43751a55a477c2955176f" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not offer this type of replication, though PostgreSQL two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;) can be used to implement this in application code or middleware.</source>
          <target state="translated">PostgreSQL не предлагает этот тип репликации, хотя двухфазная фиксация PostgreSQL ( &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; и &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt; ) может использоваться для реализации этого в коде приложения или промежуточном программном обеспечении.</target>
        </trans-unit>
        <trans-unit id="bcb2a401b7b0ac69a360f9b7c695ed89ed9ebff0" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not protect against correctable memory errors and it is assumed you will operate using RAM that uses industry standard Error Correcting Codes (ECC) or better protection.</source>
          <target state="translated">PostgreSQL не защищает от исправляемых ошибок памяти,и предполагается,что вы будете работать с оперативной памятью,которая использует стандартные для отрасли коды для исправления ошибок (ECC)или лучшую защиту.</target>
        </trans-unit>
        <trans-unit id="13d3dc2372c98003c5a49c2b15eff6ff46f18e90" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not protect against correctable memory errors and it is assumed you will operate using RAM that uses industry standard Error Correcting Codes (ECC) or better protection. However, ECC memory is typically only immune to single-bit errors, and should not be assumed to provide &lt;em&gt;absolute&lt;/em&gt; protection against failures that result in memory corruption.</source>
          <target state="translated">PostgreSQL не защищает от исправимых ошибок памяти, и предполагается, что вы будете работать с оперативной памятью, которая использует стандартные коды исправления ошибок (ECC) или лучшую защиту. Однако память ECC обычно невосприимчива только к однобитовым ошибкам, и не следует полагать, что она обеспечивает &lt;em&gt;абсолютную&lt;/em&gt; защиту от сбоев, которые приводят к повреждению памяти.</target>
        </trans-unit>
        <trans-unit id="1217e1656a3a27412f47a2f27ca6ddad0011cb8d" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not provide the system software required to identify a failure on the primary and notify the standby database server. Many such tools exist and are well integrated with the operating system facilities required for successful failover, such as IP address migration.</source>
          <target state="translated">PostgreSQL не предоставляет системного программного обеспечения,необходимого для выявления сбоя на основном и уведомления резервного сервера баз данных.Многие такие инструменты существуют и хорошо интегрированы с средствами операционной системы,необходимыми для успешного обхода отказа,например,миграция IP-адресов.</target>
        </trans-unit>
        <trans-unit id="1d796e67fd8db9494e77a87bae072c969985dce1" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not support &lt;code&gt;CHECK&lt;/code&gt; constraints that reference table data other than the new or updated row being checked. While a &lt;code&gt;CHECK&lt;/code&gt; constraint that violates this rule may appear to work in simple tests, it cannot guarantee that the database will not reach a state in which the constraint condition is false (due to subsequent changes of the other row(s) involved). This would cause a database dump and reload to fail. The reload could fail even when the complete database state is consistent with the constraint, due to rows not being loaded in an order that will satisfy the constraint. If possible, use &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;EXCLUDE&lt;/code&gt;, or &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints to express cross-row and cross-table restrictions.</source>
          <target state="translated">PostgreSQL не поддерживает ограничения &lt;code&gt;CHECK&lt;/code&gt; , которые ссылаются на данные таблицы, кроме проверяемой новой или обновленной строки. Хотя ограничение &lt;code&gt;CHECK&lt;/code&gt; , которое нарушает это правило, может показаться работающим в простых тестах, оно не может гарантировать, что база данных не достигнет состояния, в котором условие ограничения является ложным (из-за последующих изменений других задействованных строк). Это приведет к сбою дампа базы данных и перезагрузки. Повторная загрузка может завершиться ошибкой, даже если полное состояние базы данных соответствует ограничению, поскольку строки загружаются не в том порядке, который удовлетворяет ограничению. Если возможно, используйте ограничения &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;EXCLUDE&lt;/code&gt; или &lt;code&gt;FOREIGN KEY&lt;/code&gt; , чтобы выразить ограничения между строками и таблицами.</target>
        </trans-unit>
        <trans-unit id="cef8ed11bde695868953cc0c745e366d96215f8a" translate="yes" xml:space="preserve">
          <source>PostgreSQL doesn't remember any information about modified rows in memory, so there is no limit on the number of rows locked at one time. However, locking a row might cause a disk write, e.g., &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; modifies selected rows to mark them locked, and so will result in disk writes.</source>
          <target state="translated">PostgreSQL не запоминает никакой информации об измененных строках в памяти, поэтому нет ограничений на количество строк, заблокированных за один раз. Однако блокировка строки может вызвать запись на диск, например, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; изменяет выбранные строки, чтобы пометить их заблокированными, что приведет к записи на диск.</target>
        </trans-unit>
        <trans-unit id="63ab1d6406e057a762f3f310fecdc3a3bbd6104e" translate="yes" xml:space="preserve">
          <source>PostgreSQL endeavors to be compatible with the SQL standard definitions for typical usage. However, the SQL standard has an odd mix of date and time types and capabilities. Two obvious problems are:</source>
          <target state="translated">PostgreSQL старается быть совместимым со стандартными определениями SQL для типичного использования.Тем не менее,стандарт SQL имеет нечетное сочетание типов даты и времени и возможностей.Две очевидные проблемы:</target>
        </trans-unit>
        <trans-unit id="66d120b7abdf73ead6dc3fd9f48bfc40f4f89b99" translate="yes" xml:space="preserve">
          <source>PostgreSQL enforces SQL uniqueness constraints using &lt;em&gt;unique indexes&lt;/em&gt;, which are indexes that disallow multiple entries with identical keys. An access method that supports this feature sets &lt;code&gt;amcanunique&lt;/code&gt; true. (At present, only b-tree supports it.) Columns listed in the &lt;code&gt;INCLUDE&lt;/code&gt; clause are not considered when enforcing uniqueness.</source>
          <target state="translated">PostgreSQL применяет ограничения &lt;em&gt;уникальности&lt;/em&gt; SQL с помощью &lt;em&gt;уникальных индексов&lt;/em&gt; , которые являются индексами, запрещающими несколько записей с одинаковыми ключами. Метод доступа, поддерживающий эту функцию, устанавливает &lt;code&gt;amcanunique&lt;/code&gt; true. (В настоящее время это поддерживает только b-tree.) Столбцы, перечисленные в предложении &lt;code&gt;INCLUDE&lt;/code&gt; , не учитываются при обеспечении уникальности.</target>
        </trans-unit>
        <trans-unit id="46cf5e94b98f5acb847fc69a661150beb395793b" translate="yes" xml:space="preserve">
          <source>PostgreSQL grants privileges on some types of objects to &lt;code&gt;PUBLIC&lt;/code&gt; by default when the objects are created. No privileges are granted to &lt;code&gt;PUBLIC&lt;/code&gt; by default on tables, table columns, sequences, foreign data wrappers, foreign servers, large objects, schemas, or tablespaces. For other types of objects, the default privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt; are as follows: &lt;code&gt;CONNECT&lt;/code&gt; and &lt;code&gt;TEMPORARY&lt;/code&gt; (create temporary tables) privileges for databases; &lt;code&gt;EXECUTE&lt;/code&gt; privilege for functions and procedures; and &lt;code&gt;USAGE&lt;/code&gt; privilege for languages and data types (including domains). The object owner can, of course, &lt;code&gt;REVOKE&lt;/code&gt; both default and expressly granted privileges. (For maximum security, issue the &lt;code&gt;REVOKE&lt;/code&gt; in the same transaction that creates the object; then there is no window in which another user can use the object.) Also, these default privilege settings can be overridden using the &lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT PRIVILEGES&lt;/a&gt; command.</source>
          <target state="translated">PostgreSQL по умолчанию предоставляет &lt;code&gt;PUBLIC&lt;/code&gt; привилегии на некоторые типы объектов при создании объектов. &lt;code&gt;PUBLIC&lt;/code&gt; по умолчанию не получает никаких привилегий для таблиц, столбцов таблиц, последовательностей, оболочек сторонних данных, внешних серверов, больших объектов, схем или табличных пространств. Для других типов объектов привилегии по умолчанию, предоставленные &lt;code&gt;PUBLIC&lt;/code&gt; , следующие: привилегии &lt;code&gt;CONNECT&lt;/code&gt; и &lt;code&gt;TEMPORARY&lt;/code&gt; (создание временных таблиц) для баз данных; Привилегия &lt;code&gt;EXECUTE&lt;/code&gt; для функций и процедур; и привилегия &lt;code&gt;USAGE&lt;/code&gt; для языков и типов данных (включая домены). Владелец объекта, конечно, может &lt;code&gt;REVOKE&lt;/code&gt; как по умолчанию, так и явно предоставленные привилегии. (Для максимальной безопасности выполните &lt;code&gt;REVOKE&lt;/code&gt; в той же транзакции, которая создает объект; тогда не будет окна, в котором другой пользователь мог бы использовать объект.) Кроме того, эти настройки привилегий по умолчанию можно переопределить с помощью команды &lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT PRIVILEGES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a3b4b281714f98b0b025baa01ab2e4079267b58" translate="yes" xml:space="preserve">
          <source>PostgreSQL handles column expansion by actually transforming the first form into the second. So, in this example, &lt;code&gt;myfunc()&lt;/code&gt; would get invoked three times per row with either syntax. If it's an expensive function you may wish to avoid that, which you can do with a query like:</source>
          <target state="translated">PostgreSQL обрабатывает расширение столбцов, фактически преобразовывая первую форму во вторую. Итак, в этом примере &lt;code&gt;myfunc()&lt;/code&gt; будет вызываться три раза для каждой строки с любым синтаксисом. Если это дорогостоящая функция, вы можете избежать ее, что можно сделать с помощью такого запроса:</target>
        </trans-unit>
        <trans-unit id="df3dd7b1a171b6d6a80edc47008e7fbb158239c5" translate="yes" xml:space="preserve">
          <source>PostgreSQL handles temporary tables in a way rather different from the standard; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">PostgreSQL обрабатывает временные таблицы не так, как стандартные; см &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="6d2f14dc9f7becae572a0674a0a8f299b6b7b7aa" translate="yes" xml:space="preserve">
          <source>PostgreSQL has a rich set of native data types available to users. Users can add new types to PostgreSQL using the &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; command.</source>
          <target state="translated">PostgreSQL имеет богатый набор собственных типов данных, доступных пользователям. Пользователи могут добавлять новые типы в PostgreSQL с помощью команды &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78dda5739ec01795bd873fabe7ba9d163840acc7" translate="yes" xml:space="preserve">
          <source>PostgreSQL has an optional but highly recommended feature called &lt;em&gt;autovacuum&lt;/em&gt;, whose purpose is to automate the execution of &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; commands. When enabled, autovacuum checks for tables that have had a large number of inserted, updated or deleted tuples. These checks use the statistics collection facility; therefore, autovacuum cannot be used unless &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; is set to &lt;code&gt;true&lt;/code&gt;. In the default configuration, autovacuuming is enabled and the related configuration parameters are appropriately set.</source>
          <target state="translated">PostgreSQL имеет необязательную, но настоятельно рекомендуемую функцию под названием &lt;em&gt;autovacuum&lt;/em&gt; , цель которой - автоматизировать выполнение команд &lt;code&gt;VACUUM&lt;/code&gt; и &lt;code&gt;ANALYZE&lt;/code&gt; . Если этот параметр включен, автоматическая очистка проверяет наличие таблиц, в которые было вставлено, обновлено или удалено большое количество кортежей. Эти проверки используют средство сбора статистики; следовательно, автоочистка не может использоваться, если &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; не установлен в &lt;code&gt;true&lt;/code&gt; . В конфигурации по умолчанию автоочистка включена, и соответствующие параметры конфигурации установлены соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="745a9a5fff0d46d735897a2bfe230fa0dcd833f5" translate="yes" xml:space="preserve">
          <source>PostgreSQL has builtin support to perform JIT compilation using &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; when PostgreSQL is built with &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt;&lt;code&gt;--with-llvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL имеет встроенную поддержку для выполнения JIT-компиляции с использованием &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM,&lt;/a&gt; когда PostgreSQL &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt; &lt;code&gt;--with-llvm&lt;/code&gt; &lt;/a&gt; с --with-llvm .</target>
        </trans-unit>
        <trans-unit id="f7ea341e1bda684ee6450441ed6006b9a4d3fe3f" translate="yes" xml:space="preserve">
          <source>PostgreSQL has builtin support to perform JIT compilation using &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; when PostgreSQL is built with &lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt;&lt;code&gt;--with-llvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f59e9103489b1a27d73e875b095c1816ff90ee6" translate="yes" xml:space="preserve">
          <source>PostgreSQL has many features not touched upon in this tutorial introduction, which has been oriented toward newer users of SQL. These features are discussed in more detail in the remainder of this book.</source>
          <target state="translated">Во введении к этому учебному пособию,ориентированному на более новых пользователей SQL,не затрагиваются многие функции PostgreSQL.Более подробно эти функции рассматриваются в оставшейся части книги.</target>
        </trans-unit>
        <trans-unit id="34f532154e5db2109f00a916c27e879723393e79" translate="yes" xml:space="preserve">
          <source>PostgreSQL has native support for using SSL connections to encrypt client/server communications for increased security. This requires that OpenSSL is installed on both client and server systems and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL имеет встроенную поддержку использования SSL-соединений для шифрования связи клиент / сервер для повышения безопасности. Для этого требуется, чтобы OpenSSL был установлен как на клиентской, так и на серверной системе и чтобы поддержка PostgreSQL была включена во время сборки (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Главу 16&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="640330cf66c03ad2dde6227a20793bf15623446d" translate="yes" xml:space="preserve">
          <source>PostgreSQL has native support for using SSL connections to encrypt client/server communications for increased security. This requires that OpenSSL is installed on both client and server systems and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac22150741f7b1e7ae0c9084c74a767cc69f4028" translate="yes" xml:space="preserve">
          <source>PostgreSQL has the ability to report the progress of certain commands during command execution. Currently, the only commands which support progress reporting are &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html#PROTOCOL-REPLICATION-BASE-BACKUP&quot;&gt;BASE_BACKUP&lt;/a&gt; (i.e., replication command that &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; issues to take a base backup). This may be expanded in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cee738042d576fe56c5cf2614b5d2a89ef2ed35" translate="yes" xml:space="preserve">
          <source>PostgreSQL has the ability to report the progress of certain commands during command execution. Currently, the only commands which support progress reporting are &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt;. This may be expanded in the future.</source>
          <target state="translated">PostgreSQL имеет возможность сообщать о ходе выполнения определенных команд во время выполнения команд. В настоящее время единственными командами, поддерживающими отчеты о ходе выполнения, являются &lt;code&gt;CREATE INDEX&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; и &lt;code&gt;CLUSTER&lt;/code&gt; . В будущем это может быть расширено.</target>
        </trans-unit>
        <trans-unit id="a153bd140b6eee429afa97ad0154361013ce149c" translate="yes" xml:space="preserve">
          <source>PostgreSQL implements portions of the SQL/MED specification, allowing you to access data that resides outside PostgreSQL using regular SQL queries. Such data is referred to as &lt;em&gt;foreign data&lt;/em&gt;. (Note that this usage is not to be confused with foreign keys, which are a type of constraint within the database.)</source>
          <target state="translated">PostgreSQL реализует части спецификации SQL / MED, позволяя вам получать доступ к данным, которые находятся вне PostgreSQL, с помощью обычных SQL-запросов. Такие данные называются &lt;em&gt;сторонними данными&lt;/em&gt; . (Обратите внимание, что это использование не следует путать с внешними ключами, которые представляют собой тип ограничения в базе данных.)</target>
        </trans-unit>
        <trans-unit id="45ba54515ef38ae8443e32276665e58fc7c44f3d" translate="yes" xml:space="preserve">
          <source>PostgreSQL implements table inheritance, which can be a useful tool for database designers. (SQL:1999 and later define a type inheritance feature, which differs in many respects from the features described here.)</source>
          <target state="translated">PostgreSQL реализует наследование таблиц,что может быть полезным инструментом для проектировщиков баз данных.(SQL:1999 и более поздние версии определяют функцию наследования типа,которая во многом отличается от описанных здесь).</target>
        </trans-unit>
        <trans-unit id="9a4293b24f0d18f72db2fd6c1c67a47c9fab41ed" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a program &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; that has the same functionality as &lt;code&gt;CREATE ROLE&lt;/code&gt; (in fact, it calls this command) but can be run from the command shell.</source>
          <target state="translated">PostgreSQL включает программу &lt;a href=&quot;app-createuser&quot;&gt;createuser,&lt;/a&gt; которая имеет ту же функциональность, что и &lt;code&gt;CREATE ROLE&lt;/code&gt; (фактически, она вызывает эту команду), но может запускаться из командной оболочки.</target>
        </trans-unit>
        <trans-unit id="84114ad3110b572f55729ff61c07b1a5d40daec3" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a program &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; that has the same functionality as this command (in fact, it calls this command) but can be run from the command shell.</source>
          <target state="translated">PostgreSQL включает программу &lt;a href=&quot;app-dropuser&quot;&gt;dropuser,&lt;/a&gt; которая имеет ту же функциональность, что и эта команда (фактически, она вызывает эту команду), но может запускаться из командной оболочки.</target>
        </trans-unit>
        <trans-unit id="682b0969ef85f21e73efd9cc0f1d64eca421eb6a" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a sizable set of built-in data types that fit many applications. Users can also define their own data types. Most built-in data types have obvious names and semantics, so we defer a detailed explanation to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;. Some of the frequently used data types are &lt;code&gt;integer&lt;/code&gt; for whole numbers, &lt;code&gt;numeric&lt;/code&gt; for possibly fractional numbers, &lt;code&gt;text&lt;/code&gt; for character strings, &lt;code&gt;date&lt;/code&gt; for dates, &lt;code&gt;time&lt;/code&gt; for time-of-day values, and &lt;code&gt;timestamp&lt;/code&gt; for values containing both date and time.</source>
          <target state="translated">PostgreSQL включает значительный набор встроенных типов данных, которые подходят для многих приложений. Пользователи также могут определять свои собственные типы данных. Большинство встроенных типов данных имеют очевидные имена и семантику, поэтому мы отложим подробное объяснение до &lt;a href=&quot;datatype&quot;&gt;главы 8&lt;/a&gt; . Некоторые из часто используемых типов данных - это &lt;code&gt;integer&lt;/code&gt; для целых чисел, &lt;code&gt;numeric&lt;/code&gt; для возможных дробных чисел, &lt;code&gt;text&lt;/code&gt; для символьных строк, &lt;code&gt;date&lt;/code&gt; для дат, &lt;code&gt;time&lt;/code&gt; для значений &lt;code&gt;timestamp&lt;/code&gt; дня и метка времени для значений, содержащих как дату, так и время.</target>
        </trans-unit>
        <trans-unit id="735559b54f06b3f3f206e8111b18e4ea8d9566e4" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes an &amp;ldquo;autovacuum&amp;rdquo; facility which can automate routine vacuum maintenance. For more information about automatic and manual vacuuming, see &lt;a href=&quot;routine-vacuuming&quot;&gt;Section 24.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL включает функцию &amp;laquo;автоочистки&amp;raquo;, которая может автоматизировать рутинное обслуживание вакуума. Для получения дополнительной информации об автоматическом и ручном вакуумировании см. &lt;a href=&quot;routine-vacuuming&quot;&gt;Раздел 24.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffa60848047cd6b07df3ba1987237f159ca48b0a" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes an implementation of the standard btree (multi-way balanced tree) index data structure. Any data type that can be sorted into a well-defined linear order can be indexed by a btree index. The only limitation is that an index entry cannot exceed approximately one-third of a page (after TOAST compression, if applicable).</source>
          <target state="translated">PostgreSQL включает в себя реализацию стандартной структуры индексных данных btree (multi-way balanced tree).Любой тип данных,который может быть отсортирован в четко определенный линейный порядок,может быть проиндексирован по индексу btree.Единственным ограничением является то,что запись индекса не может превышать примерно одну треть страницы (после сжатия TOAST,если применимо).</target>
        </trans-unit>
        <trans-unit id="d6a78d8c03890ed632c11d38bfbd22f9d27d3999" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes one function to generate a UUID:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821fe06f71c1808348a7b91e09179799740b9a95" translate="yes" xml:space="preserve">
          <source>PostgreSQL is a &lt;em&gt;relational database management system&lt;/em&gt; (RDBMS). That means it is a system for managing data stored in &lt;em&gt;relations&lt;/em&gt;. Relation is essentially a mathematical term for &lt;em&gt;table&lt;/em&gt;. The notion of storing data in tables is so commonplace today that it might seem inherently obvious, but there are a number of other ways of organizing databases. Files and directories on Unix-like operating systems form an example of a hierarchical database. A more modern development is the object-oriented database.</source>
          <target state="translated">PostgreSQL - это &lt;em&gt;система управления реляционными базами данных&lt;/em&gt; (СУБД). Это означает, что это система для управления данными, хранящимися в &lt;em&gt;отношениях&lt;/em&gt; . Отношение - это, по сути, математический термин для обозначения &lt;em&gt;таблицы&lt;/em&gt; . Идея хранения данных в таблицах сегодня настолько распространена, что может показаться очевидной по своей сути, но существует ряд других способов организации баз данных. Файлы и каталоги в Unix-подобных операционных системах образуют пример иерархической базы данных. Более современная разработка - объектно-ориентированная база данных.</target>
        </trans-unit>
        <trans-unit id="9cfd426182152d61be1e2778a072f15bc552fcab" translate="yes" xml:space="preserve">
          <source>PostgreSQL is implemented using a simple &amp;ldquo;process per user&amp;rdquo; client/server model. In this model there is one &lt;em&gt;client process&lt;/em&gt; connected to exactly one &lt;em&gt;server process&lt;/em&gt;. As we do not know ahead of time how many connections will be made, we have to use a &lt;em&gt;master process&lt;/em&gt; that spawns a new server process every time a connection is requested. This master process is called &lt;code&gt;postgres&lt;/code&gt; and listens at a specified TCP/IP port for incoming connections. Whenever a request for a connection is detected the &lt;code&gt;postgres&lt;/code&gt; process spawns a new server process. The server tasks communicate with each other using &lt;em&gt;semaphores&lt;/em&gt; and &lt;em&gt;shared memory&lt;/em&gt; to ensure data integrity throughout concurrent data access.</source>
          <target state="translated">PostgreSQL реализован с использованием простой клиент-серверной модели &amp;laquo;процесс на пользователя&amp;raquo;. В этой модели есть один &lt;em&gt;клиентский процесс,&lt;/em&gt; связанный ровно с одним &lt;em&gt;серверным процессом&lt;/em&gt; . Поскольку мы заранее не знаем, сколько соединений будет выполнено, мы должны использовать &lt;em&gt;главный процесс,&lt;/em&gt; который порождает новый серверный процесс каждый раз, когда запрашивается соединение. Этот главный процесс называется &lt;code&gt;postgres&lt;/code&gt; и прослушивает указанный порт TCP / IP для входящих подключений. Каждый раз, когда обнаруживается запрос на соединение, процесс &lt;code&gt;postgres&lt;/code&gt; порождает новый серверный процесс. Серверные задачи взаимодействуют друг с другом с помощью &lt;em&gt;семафоров&lt;/em&gt; и &lt;em&gt;общей памяти.&lt;/em&gt; для обеспечения целостности данных при одновременном доступе к данным.</target>
        </trans-unit>
        <trans-unit id="e5b0c6c6215c78ea032d3a013c7f4ae434fd6519" translate="yes" xml:space="preserve">
          <source>PostgreSQL is more flexible in handling date/time input than the SQL standard requires. See &lt;a href=&quot;https://www.postgresql.org/docs/12/datetime-appendix.html&quot;&gt;Appendix B&lt;/a&gt; for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.</source>
          <target state="translated">PostgreSQL более гибок в обработке ввода даты и времени, чем того требует стандарт SQL. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/datetime-appendix.html&quot;&gt;Приложение B&lt;/a&gt; для получения точных правил синтаксического анализа ввода даты / времени и распознанных текстовых полей, включая месяцы, дни недели и часовые пояса.</target>
        </trans-unit>
        <trans-unit id="e736d3c1e26ee5e1fae5c95f8dd1c63e5c415e11" translate="yes" xml:space="preserve">
          <source>PostgreSQL is more flexible in handling date/time input than the SQL standard requires. See &lt;a href=&quot;https://www.postgresql.org/docs/13/datetime-appendix.html&quot;&gt;Appendix B&lt;/a&gt; for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c828eb4cf5a62919aaf9e56822812dfeb42eacd5" translate="yes" xml:space="preserve">
          <source>PostgreSQL is very extensible and allows new data types, functions, operators and other database objects to be defined; see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;Chapter 37&lt;/a&gt;. In fact the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;). To reduce that overhead, JIT compilation can inline the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</source>
          <target state="translated">PostgreSQL очень расширяемый и позволяет определять новые типы данных, функции, операторы и другие объекты базы данных; см. &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;главу 37&lt;/a&gt; . Фактически встроенные объекты реализуются с использованием почти тех же механизмов. Эта расширяемость подразумевает некоторые накладные расходы, например, из-за вызовов функций (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Раздел 37.3&lt;/a&gt; ). Чтобы уменьшить эти накладные расходы, JIT-компиляция может встраивать тела небольших функций в выражения, использующие их. Это позволяет оптимизировать значительный процент накладных расходов.</target>
        </trans-unit>
        <trans-unit id="b06ee715ba9fc1a2cac6f18f375e3b7a31953a1c" translate="yes" xml:space="preserve">
          <source>PostgreSQL is very extensible and allows new data types, functions, operators and other database objects to be defined; see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend.html&quot;&gt;Chapter 37&lt;/a&gt;. In fact the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;). To reduce that overhead, JIT compilation can inline the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bf58dffda176b2af709bb0e9bb018d0b319b34" translate="yes" xml:space="preserve">
          <source>PostgreSQL lets you reference columns of other tables in the &lt;code&gt;WHERE&lt;/code&gt; condition by specifying the other tables in the &lt;code&gt;USING&lt;/code&gt; clause. For example, to delete all films produced by a given producer, one can do:</source>
          <target state="translated">PostgreSQL позволяет ссылаться на столбцы других таблиц в условии &lt;code&gt;WHERE&lt;/code&gt; , указав другие таблицы в предложении &lt;code&gt;USING&lt;/code&gt; . Например, чтобы удалить все фильмы, снятые данным продюсером, можно:</target>
        </trans-unit>
        <trans-unit id="575317fbf767c3750ee89eec8e188302800f4189" translate="yes" xml:space="preserve">
          <source>PostgreSQL makes use of symbolic links to simplify the implementation of tablespaces. This means that tablespaces can be used &lt;em&gt;only&lt;/em&gt; on systems that support symbolic links.</source>
          <target state="translated">PostgreSQL использует символические ссылки для упрощения реализации табличных пространств. Это означает, что табличные пространства можно использовать &lt;em&gt;только&lt;/em&gt; в системах, поддерживающих символические ссылки.</target>
        </trans-unit>
        <trans-unit id="c0ca6dd2831d7be94912fd0050870a1cb327936d" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers a way to specify how to divide a table into pieces called partitions. The table that is divided is referred to as a &lt;em&gt;partitioned table&lt;/em&gt;. The specification consists of the &lt;em&gt;partitioning method&lt;/em&gt; and a list of columns or expressions to be used as the &lt;em&gt;partition key&lt;/em&gt;.</source>
          <target state="translated">PostgreSQL предлагает способ указать, как разделить таблицу на части, называемые разделами. Разделенная таблица называется разделенной &lt;em&gt;таблицей&lt;/em&gt; . Спецификация состоит из &lt;em&gt;метода разделения&lt;/em&gt; и списка столбцов или выражений, которые будут использоваться в качестве &lt;em&gt;ключа раздела&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="891f5d2a022ddd1dd671a070027ea1cff8f75e34" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers built-in support for the following forms of partitioning:</source>
          <target state="translated">PostgreSQL предлагает встроенную поддержку следующих форм разметки:</target>
        </trans-unit>
        <trans-unit id="5662adc70468d34652ede9f811304c570cee30e3" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers data types to store IPv4, IPv6, and MAC addresses, as shown in &lt;a href=&quot;datatype-net-types#DATATYPE-NET-TYPES-TABLE&quot;&gt;Table 8.21&lt;/a&gt;. It is better to use these types instead of plain text types to store network addresses, because these types offer input error checking and specialized operators and functions (see &lt;a href=&quot;functions-net&quot;&gt;Section 9.12&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL предлагает типы данных для хранения IPv4, IPv6 и MAC-адресов, как показано в &lt;a href=&quot;datatype-net-types#DATATYPE-NET-TYPES-TABLE&quot;&gt;Таблице 8.21&lt;/a&gt; . Эти типы лучше использовать вместо типов обычного текста для хранения сетевых адресов, потому что эти типы предлагают проверку ошибок ввода и специализированные операторы и функции (см. &lt;a href=&quot;functions-net&quot;&gt;Раздел 9.12&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="84c215e752220c438a12a8423b6fe5998d9faf4a" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers encryption at several levels, and provides flexibility in protecting data from disclosure due to database server theft, unscrupulous administrators, and insecure networks. Encryption might also be required to secure sensitive data such as medical records or financial transactions.</source>
          <target state="translated">PostgreSQL предлагает шифрование на нескольких уровнях и обеспечивает гибкость в защите данных от разглашения из-за кражи серверов баз данных,недобросовестных администраторов и небезопасных сетей.Шифрование также может потребоваться для защиты конфиденциальных данных,таких как медицинские документы или финансовые транзакции.</target>
        </trans-unit>
        <trans-unit id="69f5fb450ee35fca9053db0e9cf0fee2e325d788" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers two types for storing JSON data: &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt;. To implement efficient query mechanisms for these data types, PostgreSQL also provides the &lt;code&gt;jsonpath&lt;/code&gt; data type described in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL предлагает два типа для хранения данных JSON: &lt;code&gt;json&lt;/code&gt; и &lt;code&gt;jsonb&lt;/code&gt; . Чтобы реализовать эффективные механизмы запросов для этих типов данных, PostgreSQL также предоставляет &lt;code&gt;jsonpath&lt;/code&gt; данных jsonpath, описанный в &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Разделе 8.14.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="926dbd334c49f127c9efe79cdb0a9983f9b87b3a" translate="yes" xml:space="preserve">
          <source>PostgreSQL only allows the execution of a user-defined function for the triggered action. The standard allows the execution of a number of other SQL commands, such as &lt;code&gt;CREATE TABLE&lt;/code&gt;, as the triggered action. This limitation is not hard to work around by creating a user-defined function that executes the desired commands.</source>
          <target state="translated">PostgreSQL разрешает выполнение только определенной пользователем функции для инициированного действия. Стандарт разрешает выполнение ряда других команд SQL, таких как &lt;code&gt;CREATE TABLE&lt;/code&gt; , в качестве инициируемого действия. Это ограничение нетрудно обойти, создав пользовательскую функцию, которая выполняет желаемые команды.</target>
        </trans-unit>
        <trans-unit id="43083b6336b02575039a2d9d8f76b5988935b20e" translate="yes" xml:space="preserve">
          <source>PostgreSQL procedural language libraries can be preloaded in this way, typically by using the syntax &lt;code&gt;'$libdir/plXXX'&lt;/code&gt; where &lt;code&gt;XXX&lt;/code&gt; is &lt;code&gt;pgsql&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt;, &lt;code&gt;tcl&lt;/code&gt;, or &lt;code&gt;python&lt;/code&gt;.</source>
          <target state="translated">Таким образом можно предварительно &lt;code&gt;'$libdir/plXXX'&lt;/code&gt; библиотеки процедурного языка PostgreSQL, обычно используя синтаксис $ libdir / plXXX, где &lt;code&gt;XXX&lt;/code&gt; - это &lt;code&gt;pgsql&lt;/code&gt; , &lt;code&gt;perl&lt;/code&gt; , &lt;code&gt;tcl&lt;/code&gt; или &lt;code&gt;python&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f59dd80e652539f7d5e5bc6cc2d156491128c008" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a JIT implementation based on LLVM. The interface to the JIT provider is pluggable and the provider can be changed without recompiling (although currently, the build process only provides inlining support data for LLVM). The active provider is chosen via the setting &lt;a href=&quot;runtime-config-client#GUC-JIT-PROVIDER&quot;&gt;jit_provider&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL предоставляет реализацию JIT на основе LLVM. Интерфейс поставщика JIT является подключаемым, и поставщик может быть изменен без перекомпиляции (хотя в настоящее время процесс сборки предоставляет только встраиваемые данные поддержки для LLVM). Активный провайдер выбирается через настройку &lt;a href=&quot;runtime-config-client#GUC-JIT-PROVIDER&quot;&gt;jit_provider&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe91789313046ec6475705a372e78ba71b0024c0" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a function to inspect complex statistics defined using the &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command.</source>
          <target state="translated">PostgreSQL предоставляет функцию для проверки сложной статистики, определенной с помощью команды &lt;code&gt;CREATE STATISTICS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46fdddf06cc7902f32855be5f7713801b1905af6" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a means for creating locks that have application-defined meanings. These are called &lt;em&gt;advisory locks&lt;/em&gt;, because the system does not enforce their use &amp;mdash; it is up to the application to use them correctly. Advisory locks can be useful for locking strategies that are an awkward fit for the MVCC model. For example, a common use of advisory locks is to emulate pessimistic locking strategies typical of so-called &amp;ldquo;flat file&amp;rdquo; data management systems. While a flag stored in a table could be used for the same purpose, advisory locks are faster, avoid table bloat, and are automatically cleaned up by the server at the end of the session.</source>
          <target state="translated">PostgreSQL предоставляет средства для создания блокировок, которые имеют значение, определяемое приложением. Они называются &lt;em&gt;рекомендательными блокировками&lt;/em&gt; , потому что система не требует их использования - это зависит от приложения, чтобы использовать их правильно. Консультативные блокировки могут быть полезны для стратегий блокировки, которые не подходят для модели MVCC. Например, обычно рекомендательные блокировки используются для имитации стратегий пессимистических блокировок, типичных для так называемых систем управления данными &amp;laquo;плоских файлов&amp;raquo;. Хотя флаг, хранящийся в таблице, можно использовать для той же цели, рекомендательные блокировки выполняются быстрее, предотвращают раздувание таблицы и автоматически очищаются сервером в конце сеанса.</target>
        </trans-unit>
        <trans-unit id="0cfb1fbdc7aff0cefa972216042683bcba69e5d6" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a number of functions that return values related to the current date and time. These SQL-standard functions all return values based on the start time of the current transaction:</source>
          <target state="translated">PostgreSQL предоставляет ряд функций,которые возвращают значения,связанные с текущей датой и временем.Эти стандартные SQL-функции возвращают все значения,основанные на времени начала текущей транзакции:</target>
        </trans-unit>
        <trans-unit id="b4d4d96a6016bf1a3419a8adde28df6d7f17d284" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a rich set of tools for developers to manage concurrent access to data. Internally, data consistency is maintained by using a multiversion model (Multiversion Concurrency Control, MVCC). This means that each SQL statement sees a snapshot of data (a &lt;em&gt;database version&lt;/em&gt;) as it was some time ago, regardless of the current state of the underlying data. This prevents statements from viewing inconsistent data produced by concurrent transactions performing updates on the same data rows, providing &lt;em&gt;transaction isolation&lt;/em&gt; for each database session. MVCC, by eschewing the locking methodologies of traditional database systems, minimizes lock contention in order to allow for reasonable performance in multiuser environments.</source>
          <target state="translated">PostgreSQL предоставляет разработчикам богатый набор инструментов для управления одновременным доступом к данным. На внутреннем уровне согласованность данных поддерживается с помощью многоверсионной модели (Multiversion Concurrency Control, MVCC). Это означает, что каждый оператор SQL видит моментальный снимок данных ( &lt;em&gt;версию базы данных&lt;/em&gt; ), каким он был некоторое время назад, независимо от текущего состояния базовых данных. Это предотвращает просмотр инструкциями несогласованных данных, созданных параллельными транзакциями, выполняющими обновления одних и тех же строк данных, обеспечивая &lt;em&gt;изоляцию транзакций&lt;/em&gt; для каждого сеанса базы данных. MVCC, избегая методологий блокировок традиционных систем баз данных, сводит к минимуму конкуренцию блокировок, чтобы обеспечить приемлемую производительность в многопользовательских средах.</target>
        </trans-unit>
        <trans-unit id="1ecdd68232ab41018a2aebf2b36bf6bfee6f90a3" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a set of default roles which provide access to certain, commonly needed, privileged capabilities and information. Administrators can GRANT these roles to users and/or other roles in their environment, providing those users with access to the specified capabilities and information.</source>
          <target state="translated">PostgreSQL предоставляет набор ролей по умолчанию,которые обеспечивают доступ к определенным,часто необходимым,привилегированным возможностям и информации.Администраторы могут GRANT эти роли для пользователей и/или других ролей в их среде,предоставляя этим пользователям доступ к определенным возможностям и информации.</target>
        </trans-unit>
        <trans-unit id="12a7e7c8c66bad39574adedb86e60a5508ed2a12" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides facilities to support dynamic tracing of the database server. This allows an external utility to be called at specific points in the code and thereby trace execution.</source>
          <target state="translated">PostgreSQL предоставляет средства для поддержки динамического отслеживания сервера базы данных.Это позволяет вызывать внешнюю утилиту в определенных точках кода и тем самым отслеживать выполнение.</target>
        </trans-unit>
        <trans-unit id="93788cdb40903d97aaf58bdd1f296a2d0af57e6d" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides predefined dictionaries for many languages. There are also several predefined templates that can be used to create new dictionaries with custom parameters. Each predefined dictionary template is described below. If no existing template is suitable, it is possible to create new ones; see the &lt;code&gt;contrib/&lt;/code&gt; area of the PostgreSQL distribution for examples.</source>
          <target state="translated">PostgreSQL предоставляет предопределенные словари для многих языков. Также существует несколько предопределенных шаблонов, которые можно использовать для создания новых словарей с настраиваемыми параметрами. Каждый предопределенный шаблон словаря описан ниже. Если ни один из существующих шаблонов не подходит, можно создавать новые; см. примеры в &lt;code&gt;contrib/&lt;/code&gt; area дистрибутива PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="abe4b5b2c2d17d1440228c909b7105d20d3d03a0" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides several features for breaking down complex &lt;code&gt;postgresql.conf&lt;/code&gt; files into sub-files. These features are especially useful when managing multiple servers with related, but not identical, configurations.</source>
          <target state="translated">PostgreSQL предоставляет несколько функций для разделения сложных файлов &lt;code&gt;postgresql.conf&lt;/code&gt; на подфайлы. Эти функции особенно полезны при управлении несколькими серверами со связанными, но не идентичными конфигурациями.</target>
        </trans-unit>
        <trans-unit id="12ddc3899973df221c8322e34a526586b23ebfaa" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides several index types: B-tree, Hash, GiST, SP-GiST, GIN and BRIN. Each index type uses a different algorithm that is best suited to different types of queries. By default, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command creates B-tree indexes, which fit the most common situations.</source>
          <target state="translated">PostgreSQL предоставляет несколько типов индексов: B-tree, Hash, GiST, SP-GiST, GIN и BRIN. Каждый тип индекса использует свой алгоритм, который лучше всего подходит для разных типов запросов. По умолчанию команда &lt;code&gt;CREATE INDEX&lt;/code&gt; создает индексы B-дерева, которые подходят для наиболее распространенных ситуаций.</target>
        </trans-unit>
        <trans-unit id="4d643a989351582bdcc707ed3905be058a733c4a" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides storage and comparison functions for UUIDs, but the core database does not include any function for generating UUIDs, because no single algorithm is well suited for every application. The &lt;a href=&quot;uuid-ossp&quot;&gt;uuid-ossp&lt;/a&gt; module provides functions that implement several standard algorithms. The &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module also provides a generation function for random UUIDs. Alternatively, UUIDs could be generated by client applications or other libraries invoked through a server-side function.</source>
          <target state="translated">PostgreSQL предоставляет функции хранения и сравнения для UUID, но основная база данных не включает никаких функций для генерации UUID, потому что ни один алгоритм не подходит для каждого приложения. Модуль &lt;a href=&quot;uuid-ossp&quot;&gt;uuid-ossp&lt;/a&gt; предоставляет функции, реализующие несколько стандартных алгоритмов. Модуль &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; также предоставляет функцию генерации случайных UUID. В качестве альтернативы, UUID могут быть сгенерированы клиентскими приложениями или другими библиотеками, вызываемыми через функцию на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="a8055d8a3fe512bf9a836cadb5eae9c2e8b86c5c" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the function &lt;code&gt;to_tsvector&lt;/code&gt; for converting a document to the &lt;code&gt;tsvector&lt;/code&gt; data type.</source>
          <target state="translated">PostgreSQL предоставляет функцию &lt;code&gt;to_tsvector&lt;/code&gt; для преобразования документа в &lt;code&gt;tsvector&lt;/code&gt; данных tsvector .</target>
        </trans-unit>
        <trans-unit id="987c367c1a1efc0cb03cfb3dd34409cf91adaf69" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, &lt;code&gt;phraseto_tsquery&lt;/code&gt; and &lt;code&gt;websearch_to_tsquery&lt;/code&gt; for converting a query to the &lt;code&gt;tsquery&lt;/code&gt; data type. &lt;code&gt;to_tsquery&lt;/code&gt; offers access to more features than either &lt;code&gt;plainto_tsquery&lt;/code&gt; or &lt;code&gt;phraseto_tsquery&lt;/code&gt;, but it is less forgiving about its input. &lt;code&gt;websearch_to_tsquery&lt;/code&gt; is a simplified version of &lt;code&gt;to_tsquery&lt;/code&gt; with an alternative syntax, similar to the one used by web search engines.</source>
          <target state="translated">PostgreSQL предоставляет функции &lt;code&gt;to_tsquery&lt;/code&gt; , &lt;code&gt;plainto_tsquery&lt;/code&gt; , &lt;code&gt;phraseto_tsquery&lt;/code&gt; и &lt;code&gt;websearch_to_tsquery&lt;/code&gt; для преобразования запроса в &lt;code&gt;tsquery&lt;/code&gt; данных tsquery . &lt;code&gt;to_tsquery&lt;/code&gt; предлагает доступ к большему количеству функций, чем &lt;code&gt;plainto_tsquery&lt;/code&gt; или &lt;code&gt;phraseto_tsquery&lt;/code&gt; , но он менее снисходительно относится к своему вводу. &lt;code&gt;websearch_to_tsquery&lt;/code&gt; - это упрощенная версия &lt;code&gt;to_tsquery&lt;/code&gt; с альтернативным синтаксисом, аналогичным синтаксису, используемому поисковыми системами в Интернете.</target>
        </trans-unit>
        <trans-unit id="d433b9e1cb0cc5f1366352a11ce9410f17e6d0fd" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the index methods B-tree, hash, GiST, SP-GiST, GIN, and BRIN. Users can also define their own index methods, but that is fairly complicated.</source>
          <target state="translated">PostgreSQL предоставляет методы индексирования B-дерева,хэша,GiST,SP-GiST,GIN и BRIN.Пользователи также могут определять свои собственные методы индексирования,но это довольно сложно.</target>
        </trans-unit>
        <trans-unit id="bed8f31d13fc879249d79e50cd113d8dd0d3c306" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the standard SQL type &lt;code&gt;boolean&lt;/code&gt;; see &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-TABLE&quot;&gt;Table 8.19&lt;/a&gt;. The &lt;code&gt;boolean&lt;/code&gt; type can have several states: &amp;ldquo;true&amp;rdquo;, &amp;ldquo;false&amp;rdquo;, and a third state, &amp;ldquo;unknown&amp;rdquo;, which is represented by the SQL null value.</source>
          <target state="translated">PostgreSQL предоставляет стандартный &lt;code&gt;boolean&lt;/code&gt; тип SQL ; см. &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-TABLE&quot;&gt;Таблицу 8.19&lt;/a&gt; . &lt;code&gt;boolean&lt;/code&gt; тип может иметь несколько состояний: &amp;laquo;истинный&amp;raquo;, &amp;laquo;ложные&amp;raquo;, и третье состояние, &amp;laquo;неизвестно&amp;raquo;, который представлен значением SQL нуля.</target>
        </trans-unit>
        <trans-unit id="112d712cbd3f4abfdabfc159cdc6a3584db95c15" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides three SQL commands to establish configuration defaults. The already-mentioned &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command provides a SQL-accessible means of changing global defaults; it is functionally equivalent to editing &lt;code&gt;postgresql.conf&lt;/code&gt;. In addition, there are two commands that allow setting of defaults on a per-database or per-role basis:</source>
          <target state="translated">PostgreSQL предоставляет три команды SQL для установки значений конфигурации по умолчанию. Уже упомянутая команда &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; предоставляет доступные для SQL средства изменения глобальных значений по умолчанию; Функционально это эквивалентно редактированию &lt;code&gt;postgresql.conf&lt;/code&gt; . Кроме того, есть две команды, которые позволяют устанавливать значения по умолчанию для каждой базы данных или каждой роли:</target>
        </trans-unit>
        <trans-unit id="d071c1667c54c5d765a697ea20deb60db45601b3" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language &lt;em&gt;documents&lt;/em&gt; to locate those that best match a &lt;em&gt;query&lt;/em&gt;. The &lt;code&gt;tsvector&lt;/code&gt; type represents a document in a form optimized for text search; the &lt;code&gt;tsquery&lt;/code&gt; type similarly represents a text query. &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; provides a detailed explanation of this facility, and &lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt; summarizes the related functions and operators.</source>
          <target state="translated">PostgreSQL предоставляет два типа данных, которые предназначены для поддержки полнотекстового поиска, который является активность поиска по коллекции естественно-языковых &lt;em&gt;документов&lt;/em&gt; , чтобы найти те , которые наилучшим образом соответствовать &lt;em&gt;запросу&lt;/em&gt; . Тип &lt;code&gt;tsvector&lt;/code&gt; представляет документ в форме, оптимизированной для текстового поиска; &lt;code&gt;tsquery&lt;/code&gt; типа так же представляет собой текстовый запрос. &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;В главе 12&lt;/a&gt; дается подробное объяснение этой возможности, а в &lt;a href=&quot;functions-textsearch&quot;&gt;разделе 9.13&lt;/a&gt; кратко описаны связанные функции и операторы.</target>
        </trans-unit>
        <trans-unit id="fc076effaac188434f505c3be6fa39f626918c7e" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language &lt;em&gt;documents&lt;/em&gt; to locate those that best match a &lt;em&gt;query&lt;/em&gt;. The &lt;code&gt;tsvector&lt;/code&gt; type represents a document in a form optimized for text search; the &lt;code&gt;tsquery&lt;/code&gt; type similarly represents a text query. &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; provides a detailed explanation of this facility, and &lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt; summarizes the related functions and operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5de0e98d735e8c10c90f072b5e772ac6f8ca44" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two functions introduced in SQL:2006, but in variants that use the XPath 1.0 language, rather than XML Query as specified for them in the standard.</source>
          <target state="translated">PostgreSQL предоставляет две функции,представленные в SQL:2006,но в вариантах,использующих язык XPath 1.0,а не XML Query,как это указано для них в стандарте.</target>
        </trans-unit>
        <trans-unit id="6e29f8f292e01eb034e6335e7938f34ec555db8f" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides various lock modes to control concurrent access to data in tables. These modes can be used for application-controlled locking in situations where MVCC does not give the desired behavior. Also, most PostgreSQL commands automatically acquire locks of appropriate modes to ensure that referenced tables are not dropped or modified in incompatible ways while the command executes. (For example, &lt;code&gt;TRUNCATE&lt;/code&gt; cannot safely be executed concurrently with other operations on the same table, so it obtains an exclusive lock on the table to enforce that.)</source>
          <target state="translated">PostgreSQL предоставляет различные режимы блокировки для управления одновременным доступом к данным в таблицах. Эти режимы можно использовать для блокировки, управляемой приложением, в ситуациях, когда MVCC не дает желаемого поведения. Кроме того, большинство команд PostgreSQL автоматически устанавливает блокировки соответствующих режимов, чтобы гарантировать, что таблицы, на которые есть ссылки, не удаляются или не изменяются несовместимыми способами во время выполнения команды. (Например, &lt;code&gt;TRUNCATE&lt;/code&gt; не может безопасно выполняться одновременно с другими операциями в той же таблице, поэтому он получает исключительную блокировку таблицы, чтобы обеспечить это.)</target>
        </trans-unit>
        <trans-unit id="a2a834b0e992b83325c457a9496be0432049ea8a" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides various methods for authenticating users:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca67cd10f6b55fba07fefeab32464592e84bd50" translate="yes" xml:space="preserve">
          <source>PostgreSQL reads the system-wide OpenSSL configuration file. By default, this file is named &lt;code&gt;openssl.cnf&lt;/code&gt; and is located in the directory reported by &lt;code&gt;openssl version -d&lt;/code&gt;. This default can be overridden by setting environment variable &lt;code&gt;OPENSSL_CONF&lt;/code&gt; to the name of the desired configuration file.</source>
          <target state="translated">PostgreSQL читает общесистемный файл конфигурации OpenSSL. По умолчанию этот файл называется &lt;code&gt;openssl.cnf&lt;/code&gt; и находится в каталоге, о котором сообщает &lt;code&gt;openssl version -d&lt;/code&gt; . Это значение по умолчанию можно изменить, установив в переменной среды &lt;code&gt;OPENSSL_CONF&lt;/code&gt; имя желаемого файла конфигурации.</target>
        </trans-unit>
        <trans-unit id="0e141c534293f75601bff1fea667fc64a4f6c7d7" translate="yes" xml:space="preserve">
          <source>PostgreSQL recognizes functional dependency (allowing columns to be omitted from &lt;code&gt;GROUP BY&lt;/code&gt;) only when a table's primary key is included in the &lt;code&gt;GROUP BY&lt;/code&gt; list. The SQL standard specifies additional conditions that should be recognized.</source>
          <target state="translated">PostgreSQL распознает функциональную зависимость (разрешая исключение столбцов из &lt;code&gt;GROUP BY&lt;/code&gt; ) только тогда, когда первичный ключ таблицы включен в список &lt;code&gt;GROUP BY&lt;/code&gt; . Стандарт SQL определяет дополнительные условия, которые следует учитывать.</target>
        </trans-unit>
        <trans-unit id="d151da8167491478df86aef81ab6d8ffea35f9fb" translate="yes" xml:space="preserve">
          <source>PostgreSQL releases before 7.4 used a different binary file format.</source>
          <target state="translated">PostgreSQL,выпущенный до версии 7.4,использовал другой формат двоичных файлов.</target>
        </trans-unit>
        <trans-unit id="b128f368f0a60d65746b559a252c4dc977c1b44f" translate="yes" xml:space="preserve">
          <source>PostgreSQL releases prior to 8.1 would accept queries of this form, and add an implicit entry to the query's &lt;code&gt;FROM&lt;/code&gt; clause for each table referenced by the query. This is no longer allowed.</source>
          <target state="translated">В выпусках PostgreSQL до 8.1 можно было принимать запросы этой формы и добавлять неявную запись в предложение &lt;code&gt;FROM&lt;/code&gt; запроса для каждой таблицы, на которую ссылается запрос. Это больше не разрешено.</target>
        </trans-unit>
        <trans-unit id="63fb6169ba8a1a0f974f4aea96b8b4aa6c3f1759" translate="yes" xml:space="preserve">
          <source>PostgreSQL requires a few bytes of System V shared memory (typically 48 bytes, on 64-bit platforms) for each copy of the server. On most modern operating systems, this amount can easily be allocated. However, if you are running many copies of the server or you explicitly configure the server to use large amounts of System V shared memory (see &lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-DYNAMIC-SHARED-MEMORY-TYPE&quot;&gt;dynamic_shared_memory_type&lt;/a&gt;), it may be necessary to increase &lt;code&gt;SHMALL&lt;/code&gt;, which is the total amount of System V shared memory system-wide. Note that &lt;code&gt;SHMALL&lt;/code&gt; is measured in pages rather than bytes on many systems.</source>
          <target state="translated">PostgreSQL требует несколько байтов разделяемой памяти System V (обычно 48 байтов на 64-битных платформах) для каждой копии сервера. В большинстве современных операционных систем эту сумму легко выделить. Однако, если вы запускаете много копий сервера или явно настраиваете сервер для использования большого количества разделяемой памяти System V (см. &lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;Shared_memory_type&lt;/a&gt; и &lt;a href=&quot;runtime-config-resource#GUC-DYNAMIC-SHARED-MEMORY-TYPE&quot;&gt;dynamic_shared_memory_type&lt;/a&gt; ), может потребоваться увеличить &lt;code&gt;SHMALL&lt;/code&gt; , который является общим объемом разделяемой памяти System V. память в масштабе всей системы. Обратите внимание, что во многих системах &lt;code&gt;SHMALL&lt;/code&gt; измеряется в страницах, а не в байтах.</target>
        </trans-unit>
        <trans-unit id="c2c20c79653dcae8f8fc047710211c040521d5bc" translate="yes" xml:space="preserve">
          <source>PostgreSQL requires the operating system to provide inter-process communication (IPC) features, specifically shared memory and semaphores. Unix-derived systems typically provide &amp;ldquo;System V&amp;rdquo; IPC, &amp;ldquo;POSIX&amp;rdquo; IPC, or both. Windows has its own implementation of these features and is not discussed here.</source>
          <target state="translated">PostgreSQL требует, чтобы операционная система обеспечивала функции межпроцессного взаимодействия (IPC), в частности общую память и семафоры. Системы, производные от Unix, обычно предоставляют IPC &amp;laquo;System V&amp;raquo;, IPC &amp;laquo;POSIX&amp;raquo; или и то, и другое. В Windows есть собственная реализация этих функций, которая здесь не обсуждается.</target>
        </trans-unit>
        <trans-unit id="36d337a94d7ba7a46b07377e19460ac78dd155d2" translate="yes" xml:space="preserve">
          <source>PostgreSQL streaming replication is asynchronous by default. If the primary server crashes then some transactions that were committed may not have been replicated to the standby server, causing data loss. The amount of data loss is proportional to the replication delay at the time of failover.</source>
          <target state="translated">По умолчанию потоковая репликация PostgreSQL является асинхронной.В случае сбоя основного сервера некоторые транзакции,которые были совершены,возможно,не были реплицированы на резервный сервер,что привело к потере данных.Количество потерь данных пропорционально задержке репликации в момент обхода отказа.</target>
        </trans-unit>
        <trans-unit id="7c42d1cce1b2b6028e2490c0570386d5f856bca2" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports a powerful &lt;em&gt;rule system&lt;/em&gt; for the specification of &lt;em&gt;views&lt;/em&gt; and ambiguous &lt;em&gt;view updates&lt;/em&gt;. Originally the PostgreSQL rule system consisted of two implementations:</source>
          <target state="translated">PostgreSQL поддерживает мощную &lt;em&gt;систему правил&lt;/em&gt; для спецификации &lt;em&gt;представлений&lt;/em&gt; и неоднозначных &lt;em&gt;обновлений представлений&lt;/em&gt; . Первоначально система правил PostgreSQL состояла из двух реализаций:</target>
        </trans-unit>
        <trans-unit id="2241743d9fa8eb9bf19ded10e2bc6c68ceaf9df2" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports automatic character set conversion between server and client for certain character set combinations. The conversion information is stored in the &lt;code&gt;pg_conversion&lt;/code&gt; system catalog. PostgreSQL comes with some predefined conversions, as shown in &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;Table 23.2&lt;/a&gt;. You can create a new conversion using the SQL command &lt;code&gt;CREATE CONVERSION&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL поддерживает автоматическое преобразование набора символов между сервером и клиентом для определенных комбинаций набора символов. Информация о преобразовании хранится в системном каталоге &lt;code&gt;pg_conversion&lt;/code&gt; . PostgreSQL поставляется с некоторыми предопределенными преобразованиями, как показано в &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;Таблице 23.2&lt;/a&gt; . Вы можете создать новое преобразование, используя команду SQL &lt;code&gt;CREATE CONVERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="debb294ce8d55fb3d9baa6257891a19adad25190" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports automatic character set conversion between server and client for many combinations of character sets (&lt;a href=&quot;multibyte#MULTIBYTE-CONVERSIONS-SUPPORTED&quot;&gt;Section 23.3.4&lt;/a&gt; shows which ones).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c3b9018391e76aa16042a998f014061b76d5bb" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports basic table partitioning. This section describes why and how to implement partitioning as part of your database design.</source>
          <target state="translated">PostgreSQL поддерживает базовую разметку таблиц.В этом разделе описано,зачем и как реализовать разметку как часть проектирования вашей базы данных.</target>
        </trans-unit>
        <trans-unit id="1e97f638eb1274873aa3e4e622cb72d93b7b7f24" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports building indexes without locking out writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;CREATE INDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table, and in addition it must wait for all existing transactions that could potentially modify or use the index to terminate. Thus this method requires more total work than a standard index build and takes significantly longer to complete. However, since it allows normal operations to continue while the index is built, this method is useful for adding new indexes in a production environment. Of course, the extra CPU and I/O load imposed by the index creation might slow other operations.</source>
          <target state="translated">PostgreSQL поддерживает создание индексов без блокировки записи. Этот метод вызывается путем указания опции &lt;code&gt;CONCURRENTLY&lt;/code&gt; для &lt;code&gt;CREATE INDEX&lt;/code&gt; . Когда используется этот параметр, PostgreSQL должен выполнить два сканирования таблицы и, кроме того, дождаться всех существующих транзакций, которые потенциально могут изменить или использовать индекс для завершения. Таким образом, этот метод требует больше работы, чем стандартное построение индекса, и занимает значительно больше времени. Однако, поскольку он позволяет продолжать нормальные операции во время построения индекса, этот метод полезен для добавления новых индексов в производственной среде. Конечно, дополнительная нагрузка на ЦП и ввод-вывод, вызванная созданием индекса, может замедлить другие операции.</target>
        </trans-unit>
        <trans-unit id="bf603007c3689d71b489ed77c1b75a8fa44bed1c" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports parallel aggregation by aggregating in two stages. First, each process participating in the parallel portion of the query performs an aggregation step, producing a partial result for each group of which that process is aware. This is reflected in the plan as a &lt;code&gt;Partial Aggregate&lt;/code&gt; node. Second, the partial results are transferred to the leader via &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt;. Finally, the leader re-aggregates the results across all workers in order to produce the final result. This is reflected in the plan as a &lt;code&gt;Finalize Aggregate&lt;/code&gt; node.</source>
          <target state="translated">PostgreSQL поддерживает параллельное агрегирование путем агрегирования в два этапа. Во-первых, каждый процесс, участвующий в параллельной части запроса, выполняет этап агрегирования, выдавая частичный результат для каждой группы, о которой этот процесс знает. Это отражено в плане как узел &lt;code&gt;Partial Aggregate&lt;/code&gt; . Во-вторых, частичные результаты передаются лидеру через &lt;code&gt;Gather&lt;/code&gt; или &lt;code&gt;Gather Merge&lt;/code&gt; . Наконец, лидер повторно объединяет результаты по всем работникам, чтобы получить окончательный результат. Это отражено в плане как узел &lt;code&gt;Finalize Aggregate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98c96f2dead7b89b38c3c2461ff7cd5a4376ae6d" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports rebuilding indexes with minimum locking of writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;REINDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table for each index that needs to be rebuilt and wait for termination of all existing transactions that could potentially use the index. This method requires more total work than a standard index rebuild and takes significantly longer to complete as it needs to wait for unfinished transactions that might modify the index. However, since it allows normal operations to continue while the index is being rebuilt, this method is useful for rebuilding indexes in a production environment. Of course, the extra CPU, memory and I/O load imposed by the index rebuild may slow down other operations.</source>
          <target state="translated">PostgreSQL поддерживает перестройку индексов с минимальной блокировкой записи. Этот метод вызывается путем указания параметра &lt;code&gt;CONCURRENTLY&lt;/code&gt; в &lt;code&gt;REINDEX&lt;/code&gt; . Когда используется эта опция, PostgreSQL должен выполнить два сканирования таблицы для каждого индекса, который необходимо перестроить, и дождаться завершения всех существующих транзакций, которые потенциально могут использовать индекс. Этот метод требует больше общей работы, чем стандартное перестроение индекса, и требует значительно больше времени для завершения, так как необходимо ждать незавершенных транзакций, которые могут изменить индекс. Однако, поскольку он позволяет продолжать нормальные операции во время перестроения индекса, этот метод полезен для перестроения индексов в производственной среде. Конечно, дополнительная нагрузка на ЦП, память и ввод-вывод, вызванная перестроением индекса, может замедлить другие операции.</target>
        </trans-unit>
        <trans-unit id="b659630282ce6fbd7aba80155fab2795874d42d4" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports row-level access, but &lt;code&gt;sepgsql&lt;/code&gt; does not.</source>
          <target state="translated">PostgreSQL поддерживает доступ на уровне строк, а &lt;code&gt;sepgsql&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="ef19df889c26aff47b13a779090fcd37550d60bb" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports several methods for logging server messages, including stderr, csvlog and syslog. On Windows, eventlog is also supported. Set this parameter to a list of desired log destinations separated by commas. The default is to log to stderr only. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">PostgreSQL поддерживает несколько методов регистрации сообщений сервера, включая stderr, csvlog и syslog. В Windows также поддерживается журнал событий. Задайте для этого параметра список желаемых мест назначения журнала, разделенных запятыми. По умолчанию выполняется вход только в stderr. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="51899fa8eebb3b3aa74bb4a137479eee2fd66147" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports several special date/time input values for convenience, as shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-TABLE&quot;&gt;Table 8.13&lt;/a&gt;. The values &lt;code&gt;infinity&lt;/code&gt; and &lt;code&gt;-infinity&lt;/code&gt; are specially represented inside the system and will be displayed unchanged; but the others are simply notational shorthands that will be converted to ordinary date/time values when read. (In particular, &lt;code&gt;now&lt;/code&gt; and related strings are converted to a specific time value as soon as they are read.) All of these values need to be enclosed in single quotes when used as constants in SQL commands.</source>
          <target state="translated">PostgreSQL для удобства поддерживает несколько специальных вводных значений даты и времени, как показано в &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-TABLE&quot;&gt;Таблице 8.13&lt;/a&gt; . Значения &lt;code&gt;infinity&lt;/code&gt; и &lt;code&gt;-infinity&lt;/code&gt; специально представлены внутри системы и будут отображаться без изменений; но остальные представляют собой просто условные обозначения, которые при чтении будут преобразованы в обычные значения даты / времени. (В частности, &lt;code&gt;now&lt;/code&gt; и связанные строки преобразуются в определенное значение времени, как только они прочитаны.) Все эти значения должны быть заключены в одинарные кавычки при использовании в качестве констант в командах SQL.</target>
        </trans-unit>
        <trans-unit id="f6c41dd3d36631eef9a60ad49bfd703137d3f4d8" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the full set of SQL date and time types, shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;Table 8.9&lt;/a&gt;. The operations available on these data types are described in &lt;a href=&quot;functions-datetime&quot;&gt;Section 9.9&lt;/a&gt;. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced (see &lt;a href=&quot;datetime-units-history&quot;&gt;Section B.5&lt;/a&gt; for more information).</source>
          <target state="translated">PostgreSQL поддерживает полный набор типов даты и времени SQL, показанный в &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;Таблице 8.9&lt;/a&gt; . Операции, доступные для этих типов данных, описаны в &lt;a href=&quot;functions-datetime&quot;&gt;Разделе 9.9&lt;/a&gt; . Даты отсчитываются по григорианскому календарю, даже за годы до того, как этот календарь был введен ( дополнительную информацию см. В &lt;a href=&quot;datetime-units-history&quot;&gt;разделе B.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="20349ba6e468e9df9a098ab6e794e103ce905a08" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the full set of SQL date and time types, shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;Table 8.9&lt;/a&gt;. The operations available on these data types are described in &lt;a href=&quot;functions-datetime&quot;&gt;Section 9.9&lt;/a&gt;. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced (see &lt;a href=&quot;datetime-units-history&quot;&gt;Section B.6&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14a3d6cb75702f32d5dc071e65c1dc41ad01772" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the standard SQL types &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;char(N)&lt;/code&gt;, &lt;code&gt;varchar(N)&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, and &lt;code&gt;interval&lt;/code&gt;, as well as other types of general utility and a rich set of geometric types. PostgreSQL can be customized with an arbitrary number of user-defined data types. Consequently, type names are not key words in the syntax, except where required to support special cases in the SQL standard.</source>
          <target state="translated">PostgreSQL поддерживает стандартные типы SQL &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;real&lt;/code&gt; , &lt;code&gt;double precision&lt;/code&gt; , &lt;code&gt;char(N)&lt;/code&gt; , &lt;code&gt;varchar(N)&lt;/code&gt; , &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;timestamp&lt;/code&gt; и &lt;code&gt;interval&lt;/code&gt; , а также другие типы общих служебных программ и богатый набор геометрических типов. PostgreSQL можно настроить с произвольным количеством определяемых пользователем типов данных. Следовательно, имена типов не являются ключевыми словами в синтаксисе, за исключением случаев, когда это требуется для поддержки особых случаев в стандарте SQL.</target>
        </trans-unit>
        <trans-unit id="0d51b565fec4c2b0e44f5a1d45ac9c129a9f5580" translate="yes" xml:space="preserve">
          <source>PostgreSQL treats the settings &lt;code&gt;origin&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; the same internally. Third-party replication systems may use these two values for their internal purposes, for example using &lt;code&gt;local&lt;/code&gt; to designate a session whose changes should not be replicated.</source>
          <target state="translated">PostgreSQL обрабатывает настройки &lt;code&gt;origin&lt;/code&gt; и &lt;code&gt;local&lt;/code&gt; те же внутренне. Сторонние системы репликации могут использовать эти два значения для своих внутренних целей, например, используя &lt;code&gt;local&lt;/code&gt; для обозначения сеанса, изменения которого не должны реплицироваться.</target>
        </trans-unit>
        <trans-unit id="749a4f6a11ea83f98676b6594e8c9efc963bc390" translate="yes" xml:space="preserve">
          <source>PostgreSQL type</source>
          <target state="translated">Тип PostgreSQL</target>
        </trans-unit>
        <trans-unit id="47a27d79e52ae2c7462f626790ad2829a449a676" translate="yes" xml:space="preserve">
          <source>PostgreSQL uses a fixed page size (commonly 8 kB), and does not allow tuples to span multiple pages. Therefore, it is not possible to store very large field values directly. To overcome this limitation, large field values are compressed and/or broken up into multiple physical rows. This happens transparently to the user, with only small impact on most of the backend code. The technique is affectionately known as TOAST (or &amp;ldquo;the best thing since sliced bread&amp;rdquo;). The TOAST infrastructure is also used to improve handling of large data values in-memory.</source>
          <target state="translated">PostgreSQL использует фиксированный размер страницы (обычно 8 КБ) и не позволяет кортежам занимать несколько страниц. Следовательно, невозможно напрямую хранить очень большие значения полей. Чтобы преодолеть это ограничение, большие значения полей сжимаются и / или разбиваются на несколько физических строк. Это происходит прозрачно для пользователя и лишь незначительно влияет на большую часть внутреннего кода. Техника ласково известна как TOAST (или &amp;laquo;лучшее после нарезанного хлеба&amp;raquo;). Инфраструктура TOAST также используется для улучшения обработки больших значений данных в памяти.</target>
        </trans-unit>
        <trans-unit id="e1529abe3421ea489100f9759672bf8f68aa03a3" translate="yes" xml:space="preserve">
          <source>PostgreSQL version information. See also &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num&lt;/a&gt; for a machine-readable version.</source>
          <target state="translated">Информация о версии PostgreSQL. См. Также &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num&lt;/a&gt; для машиночитаемой версии.</target>
        </trans-unit>
        <trans-unit id="79b79e94e250861d3a37b2b81991c08edde567f2" translate="yes" xml:space="preserve">
          <source>PostgreSQL versions before 9.5 used slightly different operator precedence rules. In particular, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; used to be treated as generic operators; &lt;code&gt;IS&lt;/code&gt; tests used to have higher priority; and &lt;code&gt;NOT BETWEEN&lt;/code&gt; and related constructs acted inconsistently, being taken in some cases as having the precedence of &lt;code&gt;NOT&lt;/code&gt; rather than &lt;code&gt;BETWEEN&lt;/code&gt;. These rules were changed for better compliance with the SQL standard and to reduce confusion from inconsistent treatment of logically equivalent constructs. In most cases, these changes will result in no behavioral change, or perhaps in &amp;ldquo;no such operator&amp;rdquo; failures which can be resolved by adding parentheses. However there are corner cases in which a query might change behavior without any parsing error being reported. If you are concerned about whether these changes have silently broken something, you can test your application with the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-OPERATOR-PRECEDENCE-WARNING&quot;&gt;operator_precedence_warning&lt;/a&gt; turned on to see if any warnings are logged.</source>
          <target state="translated">В версиях PostgreSQL до 9.5 использовались несколько иные правила приоритета операторов. В частности, &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; и &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; используется для рассматриваться в качестве общих операторов; Тесты &lt;code&gt;IS&lt;/code&gt; имели более высокий приоритет; и &lt;code&gt;NOT BETWEEN&lt;/code&gt; и связанные конструкции действовали непоследовательно, в некоторых случаях считаясь имеющими приоритет &lt;code&gt;NOT&lt;/code&gt; , а не &lt;code&gt;BETWEEN&lt;/code&gt; . Эти правила были изменены для лучшего соответствия стандарту SQL и уменьшения путаницы из-за непоследовательной обработки логически эквивалентных конструкций. В большинстве случаев эти изменения не приведут к изменению поведения или, возможно, к сбоям &amp;laquo;нет такого оператора&amp;raquo;, которые можно устранить, добавив скобки. Однако есть угловые случаи, когда запрос может изменить поведение без сообщения об ошибке синтаксического анализа. Если вас беспокоит, не нарушили ли эти изменения что-либо, вы можете протестировать свое приложение с включенным параметром конфигурации &lt;a href=&quot;runtime-config-compatible#GUC-OPERATOR-PRECEDENCE-WARNING&quot;&gt;operator_precedence_warning,&lt;/a&gt; чтобы увидеть, регистрируются ли какие-либо предупреждения.</target>
        </trans-unit>
        <trans-unit id="b12aba1a6149cc1a1cc6de75b2d9db3d7327f976" translate="yes" xml:space="preserve">
          <source>PostgreSQL versions before 9.6 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan.</source>
          <target state="translated">Версии PostgreSQL до 9.6 не давали никаких гарантий относительно сроков оценки выходных выражений в сравнении с сортировкой и ограничением;это зависело от формы выбранного плана запроса.</target>
        </trans-unit>
        <trans-unit id="a330d6e333f0e705b7dbdae815c080baf029fd11" translate="yes" xml:space="preserve">
          <source>PostgreSQL will accept &lt;code&gt;BY VALUE&lt;/code&gt; or &lt;code&gt;BY REF&lt;/code&gt; in an &lt;code&gt;XMLEXISTS&lt;/code&gt; or &lt;code&gt;XMLTABLE&lt;/code&gt; construct, but it ignores them. The &lt;code&gt;xml&lt;/code&gt; data type holds a character-string serialized representation, so there is no node identity to preserve, and passing is always effectively &lt;code&gt;BY VALUE&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL принимает &lt;code&gt;BY VALUE&lt;/code&gt; или &lt;code&gt;BY REF&lt;/code&gt; в конструкциях &lt;code&gt;XMLEXISTS&lt;/code&gt; или &lt;code&gt;XMLTABLE&lt;/code&gt; , но игнорирует их. Тип данных &lt;code&gt;xml&lt;/code&gt; содержит сериализованное представление в виде символьной строки, поэтому нет идентификатора узла, который нужно сохранить, и передача всегда осуществляется по &lt;code&gt;BY VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46668d602303093fd5436b07b8510921686fe19b" translate="yes" xml:space="preserve">
          <source>PostgreSQL will allow superusers to create databases with &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding even when &lt;code&gt;LC_CTYPE&lt;/code&gt; is not &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt;. As noted above, &lt;code&gt;SQL_ASCII&lt;/code&gt; does not enforce that the data stored in the database has any particular encoding, and so this choice poses risks of locale-dependent misbehavior. Using this combination of settings is deprecated and may someday be forbidden altogether.</source>
          <target state="translated">PostgreSQL позволит суперпользователям создавать базы данных с кодировкой &lt;code&gt;SQL_ASCII&lt;/code&gt; , даже если &lt;code&gt;LC_CTYPE&lt;/code&gt; не соответствует &lt;code&gt;C&lt;/code&gt; или &lt;code&gt;POSIX&lt;/code&gt; . Как отмечалось выше, &lt;code&gt;SQL_ASCII&lt;/code&gt; не требует , чтобы данные, хранящиеся в базе данных , имели какую-либо конкретную кодировку, и поэтому этот выбор создает риски неправильного поведения, зависящего от локали. Использование этой комбинации настроек устарело и когда-нибудь может быть вообще запрещено.</target>
        </trans-unit>
        <trans-unit id="b4c3b94e027418ea1293e7cfc1afc35261ba39ee" translate="yes" xml:space="preserve">
          <source>PostgreSQL will apply this expansion behavior to any composite-valued expression, although as shown &lt;a href=&quot;rowtypes#ROWTYPES-ACCESSING&quot;&gt;above&lt;/a&gt;, you need to write parentheses around the value that &lt;code&gt;.*&lt;/code&gt; is applied to whenever it's not a simple table name. For example, if &lt;code&gt;myfunc()&lt;/code&gt; is a function returning a composite type with columns &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then these two queries have the same result:</source>
          <target state="translated">PostgreSQL применит это поведение расширения к любому выражению с составным значением, хотя, как показано &lt;a href=&quot;rowtypes#ROWTYPES-ACCESSING&quot;&gt;выше&lt;/a&gt; , вам нужно заключить в круглые скобки значение, к которому применяется &lt;code&gt;.*&lt;/code&gt; , Если это не простое имя таблицы. Например, если &lt;code&gt;myfunc()&lt;/code&gt; - это функция, возвращающая составной тип со столбцами &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , то эти два запроса имеют одинаковый результат:</target>
        </trans-unit>
        <trans-unit id="c89f6a3f1560a7bd4653723f3e72dbf1311168a6" translate="yes" xml:space="preserve">
          <source>PostgreSQL will attempt to convert the column's default value (if any) to the new type, as well as any constraints that involve the column. But these conversions might fail, or might produce surprising results. It's often best to drop any constraints on the column before altering its type, and then add back suitably modified constraints afterwards.</source>
          <target state="translated">PostgreSQL попытается преобразовать значение столбца по умолчанию (если таковое имеется)в новый тип,а также все ограничения,связанные с этим столбцом.Однако эти преобразования могут оказаться неудачными или дать неожиданные результаты.Часто лучше всего снять любые ограничения на колонку,прежде чем изменять ее тип,а затем добавить обратно соответствующие измененные ограничения.</target>
        </trans-unit>
        <trans-unit id="23adfa969a97323ee3ec177a7dcb8f6884bb3a0c" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;a href=&quot;mvcc-intro&quot;&gt;MVCC&lt;/a&gt; transaction semantics depend on being able to compare transaction ID (XID) numbers: a row version with an insertion XID greater than the current transaction's XID is &amp;ldquo;in the future&amp;rdquo; and should not be visible to the current transaction. But since transaction IDs have limited size (32 bits) a cluster that runs for a long time (more than 4 billion transactions) would suffer &lt;em&gt;transaction ID wraparound&lt;/em&gt;: the XID counter wraps around to zero, and all of a sudden transactions that were in the past appear to be in the future &amp;mdash; which means their output become invisible. In short, catastrophic data loss. (Actually the data is still there, but that's cold comfort if you cannot get at it.) To avoid this, it is necessary to vacuum every table in every database at least once every two billion transactions.</source>
          <target state="translated">Семантика транзакции &lt;a href=&quot;mvcc-intro&quot;&gt;MVCC&lt;/a&gt; PostgreSQL зависит от возможности сравнивать номера идентификаторов транзакций (XID): версия строки с XID вставки, большим, чем XID текущей транзакции, находится &amp;laquo;в будущем&amp;raquo; и не должна быть видна для текущей транзакции. Но поскольку идентификаторы транзакций имеют ограниченный размер (32 бита), кластер, который работает долгое время (более 4 миллиардов транзакций), будет страдать от &lt;em&gt;переноса идентификатора транзакции.&lt;/em&gt;: счетчик XID возвращается к нулю, и внезапно транзакции, которые были в прошлом, оказываются в будущем, а это означает, что их вывод становится невидимым. Короче, катастрофическая потеря данных. (На самом деле данные все еще там, но это холодное утешение, если вы не можете до них добраться.) Чтобы избежать этого, необходимо очищать каждую таблицу в каждой базе данных не реже одного раза в два миллиарда транзакций.</target>
        </trans-unit>
        <trans-unit id="d01ad7a96af1c4c37b0765a65b29de55d59ec177" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; command has to process each table on a regular basis for several reasons:</source>
          <target state="translated">Команда PostgreSQL &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; должна обрабатывать каждую таблицу на регулярной основе по нескольким причинам:</target>
        </trans-unit>
        <trans-unit id="1d397eedb2e425cb61e6640819576e2ece268547" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;em&gt;statistics collector&lt;/em&gt; is a subsystem that supports collection and reporting of information about server activity. Presently, the collector can count accesses to tables and indexes in both disk-block and individual-row terms. It also tracks the total number of rows in each table, and information about vacuum and analyze actions for each table. It can also count calls to user-defined functions and the total time spent in each one.</source>
          <target state="translated">&lt;em&gt;Сборщик статистики&lt;/em&gt; PostgreSQL - это подсистема, которая поддерживает сбор и создание отчетов об активности сервера. В настоящее время сборщик может подсчитывать доступы к таблицам и индексам как в единицах дисковых блоков, так и в единицах отдельных строк. Он также отслеживает общее количество строк в каждой таблице, а также информацию о вакууме и действиях анализа для каждой таблицы. Он также может подсчитывать вызовы пользовательских функций и общее время, потраченное на каждую из них.</target>
        </trans-unit>
        <trans-unit id="fa34938a4c0bdb7ddaed6ea9437aad3e7e7c20a7" translate="yes" xml:space="preserve">
          <source>PostgreSQL's JIT implementation can inline the bodies of functions of types &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt;, as well as operators based on such functions. To do so for functions in extensions, the definitions of those functions need to be made available. When using &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; to build an extension against a server that has been compiled with LLVM JIT support, the relevant files will be built and installed automatically.</source>
          <target state="translated">Реализация JIT PostgreSQL может встраивать тела функций типов &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;internal&lt;/code&gt; , а также операторов, основанных на таких функциях. Чтобы сделать это для функций в расширениях, необходимо сделать доступными определения этих функций. При использовании &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; для создания расширения для сервера, который был скомпилирован с поддержкой LLVM JIT, соответствующие файлы будут созданы и установлены автоматически.</target>
        </trans-unit>
        <trans-unit id="cbfface12059fe15d4ea1c0663b32afd132d460b" translate="yes" xml:space="preserve">
          <source>PostgreSQL's JIT implementation can inline the bodies of functions of types &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt;, as well as operators based on such functions. To do so for functions in extensions, the definitions of those functions need to be made available. When using &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; to build an extension against a server that has been compiled with LLVM JIT support, the relevant files will be built and installed automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ce9be22eb538937b290524f1a893fff9a3a342" translate="yes" xml:space="preserve">
          <source>PostgreSQL's foreign-data functionality is still under active development. Optimization of queries is primitive (and mostly left to the wrapper, too). Thus, there is considerable room for future performance improvements.</source>
          <target state="translated">Функциональность внешних данных PostgreSQL все еще находится в стадии активной разработки.Оптимизация запросов примитивна (и в основном оставлена на обертку).Таким образом,есть значительный простор для дальнейшего повышения производительности.</target>
        </trans-unit>
        <trans-unit id="045ba636eac8c350bd9d92d07f5b544b6d689ef6" translate="yes" xml:space="preserve">
          <source>PostgreSQL's implementation of SQL/JSON path language has the following deviations from the SQL/JSON standard:</source>
          <target state="translated">Реализация языка пути SQL/JSON в PostgreSQL имеет следующие отклонения от стандарта SQL/JSON:</target>
        </trans-unit>
        <trans-unit id="49d790f2e543677fa7af238d2ad2b0bee3041d87" translate="yes" xml:space="preserve">
          <source>PostgreSQL's implementation of the SQL/JSON path language has the following deviations from the SQL/JSON standard:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6512655ce0206ad2e55af59128437c19a85eef8" translate="yes" xml:space="preserve">
          <source>PostgreSQL's regular expressions are implemented using a software package written by Henry Spencer. Much of the description of regular expressions below is copied verbatim from his manual.</source>
          <target state="translated">Регулярные выражения PostgreSQL реализованы с помощью программного пакета,написанного Генри Спенсером.Большая часть описания регулярных выражений,приведенного ниже,дословно скопирована из его руководства.</target>
        </trans-unit>
        <trans-unit id="8b89dce84ea21263b16697e60b4c1b4c85d27493" translate="yes" xml:space="preserve">
          <source>PostgreSQL's text search features are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;.</source>
          <target state="translated">Возможности текстового поиска PostgreSQL подробно описаны в &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;главе 12&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d7207a8f75323c89ab9632a9dcc5793d725c97" translate="yes" xml:space="preserve">
          <source>PostgreSQL's text search features are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f6a42a4fb0039de8b2fce0531aa5cf8bf17009" translate="yes" xml:space="preserve">
          <source>PostgreSQL-style typecast</source>
          <target state="translated">Типовое представление в стиле PostgreSQL</target>
        </trans-unit>
        <trans-unit id="ee3a796a1951d3ab475d28807f6598608b0104af" translate="yes" xml:space="preserve">
          <source>Postmaster (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b427c5cf5eb995bfcd7725e3fbf7217d1adcbd" translate="yes" xml:space="preserve">
          <source>Poul-Henning Kamp</source>
          <target state="translated">Лагерь Поул-Хеннинг</target>
        </trans-unit>
        <trans-unit id="17ae45bd355f880cc7401f24ea563dca0df2e7d4" translate="yes" xml:space="preserve">
          <source>Pre-loaded catalog rows must have preassigned OIDs if there are OID references to them in other pre-loaded rows. A preassigned OID is also needed if the row's OID must be referenced from C code. If neither case applies, the &lt;code&gt;oid&lt;/code&gt; metadata field can be omitted, in which case the bootstrap code assigns an OID automatically. In practice we usually preassign OIDs for all or none of the pre-loaded rows in a given catalog, even if only some of them are actually cross-referenced.</source>
          <target state="translated">Предварительно загруженные строки каталога должны иметь предварительно назначенные OID, если на них есть ссылки OID в других предварительно загруженных строках. Предварительно назначенный OID также необходим, если на OID строки нужно ссылаться из кода C. Если ни один из случаев не подходит, поле метаданных &lt;code&gt;oid&lt;/code&gt; можно опустить, и в этом случае код начальной загрузки автоматически присваивает OID. На практике мы обычно заранее назначаем OID для всех или ни для одной из предварительно загруженных строк в данном каталоге, даже если на самом деле есть перекрестные ссылки только на некоторые из них.</target>
        </trans-unit>
        <trans-unit id="3509ce167d8714af0e6b496635d49ac549f353e8" translate="yes" xml:space="preserve">
          <source>Pre-packaged versions of PostgreSQL will typically create a suitable user account automatically during package installation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="24fe09a1cf90d17df4307cd57797792c845342fc" translate="yes" xml:space="preserve">
          <source>Predicate locks in PostgreSQL, like in most other database systems, are based on data actually accessed by a transaction. These will show up in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view with a &lt;code&gt;mode&lt;/code&gt; of &lt;code&gt;SIReadLock&lt;/code&gt;. The particular locks acquired during execution of a query will depend on the plan used by the query, and multiple finer-grained locks (e.g., tuple locks) may be combined into fewer coarser-grained locks (e.g., page locks) during the course of the transaction to prevent exhaustion of the memory used to track the locks. A &lt;code&gt;READ ONLY&lt;/code&gt; transaction may be able to release its SIRead locks before completion, if it detects that no conflicts can still occur which could lead to a serialization anomaly. In fact, &lt;code&gt;READ ONLY&lt;/code&gt; transactions will often be able to establish that fact at startup and avoid taking any predicate locks. If you explicitly request a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction, it will block until it can establish this fact. (This is the &lt;em&gt;only&lt;/em&gt; case where Serializable transactions block but Repeatable Read transactions don't.) On the other hand, SIRead locks often need to be kept past transaction commit, until overlapping read write transactions complete.</source>
          <target state="translated">Блокировки предикатов в PostgreSQL, как и в большинстве других систем баз данных, основаны на данных, к которым действительно обращается транзакция. Они будут отображаться в &lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt; зрения системы с &lt;code&gt;mode&lt;/code&gt; в &lt;code&gt;SIReadLock&lt;/code&gt; . Конкретные блокировки, полученные во время выполнения запроса, будут зависеть от плана, используемого запросом, и несколько более мелких блокировок (например, блокировок кортежей) могут быть объединены в меньшее количество более грубых блокировок (например, блокировок страниц) в течение транзакция для предотвращения исчерпания памяти, используемой для отслеживания блокировок. &lt;code&gt;READ ONLY&lt;/code&gt; сделка может быть в состоянии выпустить свои SIRead замки до завершения, если он обнаружит , что никаких конфликтов не могут еще произойти , что может привести к сериализации аномалии. Фактически, &lt;code&gt;READ ONLY&lt;/code&gt; транзакции часто могут установить этот факт при запуске и избежать любых предикатных блокировок. Если вы явно запросите &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; , она будет заблокирована до тех пор, пока не сможет установить этот факт. (Это &lt;em&gt;единственный&lt;/em&gt; случай, когда сериализуемые транзакции блокируются, а транзакции повторного чтения - нет.) С другой стороны, блокировки SIRead часто необходимо сохранять после фиксации транзакции, пока не завершатся перекрывающиеся транзакции чтения и записи.</target>
        </trans-unit>
        <trans-unit id="8515d3fdb655d3e82744bca30feb482862c14535" translate="yes" xml:space="preserve">
          <source>Predicate/Value</source>
          <target state="translated">Predicate/Value</target>
        </trans-unit>
        <trans-unit id="7a2a4f6fed53f092f075c647902092f49dff565c" translate="yes" xml:space="preserve">
          <source>Prepare all statements before using them. Libecpg will keep a cache of prepared statements and reuse a statement if it gets executed again. If the cache runs full, libecpg will free the least used statement.</source>
          <target state="translated">Подготовьте все заявления,прежде чем использовать их.Libecpg будет хранить кэш подготовленных утверждений и повторно использовать утверждение,если оно будет выполнено снова.Если кэш будет заполнен,libecpg освободит наименее использованное утверждение.</target>
        </trans-unit>
        <trans-unit id="805b0426cd8c493c6395add1e59cb6d57cc782f6" translate="yes" xml:space="preserve">
          <source>Prepare for an index scan. The &lt;code&gt;nkeys&lt;/code&gt; and &lt;code&gt;norderbys&lt;/code&gt; parameters indicate the number of quals and ordering operators that will be used in the scan; these may be useful for space allocation purposes. Note that the actual values of the scan keys aren't provided yet. The result must be a palloc'd struct. For implementation reasons the index access method &lt;em&gt;must&lt;/em&gt; create this struct by calling &lt;code&gt;RelationGetIndexScan()&lt;/code&gt;. In most cases &lt;code&gt;ambeginscan&lt;/code&gt; does little beyond making that call and perhaps acquiring locks; the interesting parts of index-scan startup are in &lt;code&gt;amrescan&lt;/code&gt;.</source>
          <target state="translated">Подготовьтесь к сканированию индекса. Параметры &lt;code&gt;nkeys&lt;/code&gt; и &lt;code&gt;norderbys&lt;/code&gt; указывают количество операторов quals и упорядочивания, которые будут использоваться при сканировании; они могут быть полезны для целей распределения пространства. Обратите внимание, что фактические значения ключей сканирования еще не предоставлены. Результатом должна быть структура palloc'd. По причинам реализации метод доступа к индексу &lt;em&gt;должен&lt;/em&gt; создать эту структуру, вызвав &lt;code&gt;RelationGetIndexScan()&lt;/code&gt; . В большинстве случаев &lt;code&gt;ambeginscan&lt;/code&gt; мало что делает, кроме выполнения этого вызова и, возможно, получения блокировок; интересные части запуска сканирования индекса находятся в &lt;code&gt;amrescan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1badb6123149d2dd80187b1001e17317e0376a45" translate="yes" xml:space="preserve">
          <source>Prepare for performing on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">Подготовка к выполнению он-лайн резервного копирования (по умолчанию она ограничена суперпользователями,но другим пользователям может быть предоставлено EXECUTE для выполнения функции)</target>
        </trans-unit>
        <trans-unit id="ea6420d9e6ea0b317eaaff702554d4ab07b95961" translate="yes" xml:space="preserve">
          <source>Prepare the current transaction for two-phase commit, using &lt;code&gt;foobar&lt;/code&gt; as the transaction identifier:</source>
          <target state="translated">Подготовьте текущую транзакцию к двухфазной фиксации, используя &lt;code&gt;foobar&lt;/code&gt; в качестве идентификатора транзакции:</target>
        </trans-unit>
        <trans-unit id="5eccdbb667192934bc79ff3dadac066bfd3213f5" translate="yes" xml:space="preserve">
          <source>Prepared statements (either explicitly prepared or implicitly generated, for example by PL/pgSQL) can be executed using custom or generic plans. Custom plans are made afresh for each execution using its specific set of parameter values, while generic plans do not rely on the parameter values and can be re-used across executions. Thus, use of a generic plan saves planning time, but if the ideal plan depends strongly on the parameter values then a generic plan may be inefficient. The choice between these options is normally made automatically, but it can be overridden with &lt;code&gt;plan_cache_mode&lt;/code&gt;. The allowed values are &lt;code&gt;auto&lt;/code&gt; (the default), &lt;code&gt;force_custom_plan&lt;/code&gt; and &lt;code&gt;force_generic_plan&lt;/code&gt;. This setting is considered when a cached plan is to be executed, not when it is prepared. For more information see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="translated">Подготовленные операторы (явно подготовленные или неявно сгенерированные, например, PL / pgSQL) могут выполняться с использованием пользовательских или общих планов. Настраиваемые планы создаются заново для каждого выполнения с использованием определенного набора значений параметров, в то время как общие планы не зависят от значений параметров и могут повторно использоваться при выполнении. Таким образом, использование общего плана экономит время планирования, но если идеальный план сильно зависит от значений параметров, общий план может оказаться неэффективным. Выбор между этими параметрами обычно делается автоматически, но его можно &lt;code&gt;plan_cache_mode&lt;/code&gt; с помощью plan_cache_mode . Допустимые значения: &lt;code&gt;auto&lt;/code&gt; (по умолчанию), &lt;code&gt;force_custom_plan&lt;/code&gt; и &lt;code&gt;force_generic_plan&lt;/code&gt; .. Этот параметр учитывается при выполнении кэшированного плана, а не при его подготовке. Для получения дополнительной информации см. &lt;a href=&quot;sql-prepare&quot;&gt;ПОДГОТОВКА&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d2d9ca4ec55b877233447dcb48943c2ef02e7aa" translate="yes" xml:space="preserve">
          <source>Prepared statements can take parameters: values that are substituted into the statement when it is executed. When creating the prepared statement, refer to parameters by position, using &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. A corresponding list of parameter data types can optionally be specified. When a parameter's data type is not specified or is declared as &lt;code&gt;unknown&lt;/code&gt;, the type is inferred from the context in which the parameter is first referenced (if possible). When executing the statement, specify the actual values for these parameters in the &lt;code&gt;EXECUTE&lt;/code&gt; statement. Refer to &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; for more information about that.</source>
          <target state="translated">Подготовленные операторы могут принимать параметры: значения, которые подставляются в оператор при его выполнении. При создании подготовленного оператора обращайтесь к параметрам по позиции, используя &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; и т. Д. При необходимости можно указать соответствующий список типов данных параметров. Если тип данных параметра не указан или объявлен как &lt;code&gt;unknown&lt;/code&gt; , тип определяется из контекста, в котором параметр впервые упоминается (если это возможно). При выполнении инструкции укажите фактические значения этих параметров в инструкции &lt;code&gt;EXECUTE&lt;/code&gt; . Обратитесь к &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; для получения дополнительной информации об этом.</target>
        </trans-unit>
        <trans-unit id="23037ec79dcb923a75cebd6186549d643c581e91" translate="yes" xml:space="preserve">
          <source>Prepared statements only last for the duration of the current database session. When the session ends, the prepared statement is forgotten, so it must be recreated before being used again. This also means that a single prepared statement cannot be used by multiple simultaneous database clients; however, each client can create their own prepared statement to use. Prepared statements can be manually cleaned up using the &lt;a href=&quot;sql-deallocate&quot;&gt;DEALLOCATE&lt;/a&gt; command.</source>
          <target state="translated">Подготовленные операторы действуют только в течение текущего сеанса базы данных. Когда сеанс заканчивается, подготовленный оператор забывается, поэтому перед повторным использованием его необходимо создать заново. Это также означает, что один подготовленный оператор не может использоваться несколькими клиентами базы данных одновременно; однако каждый клиент может создать свой собственный подготовленный оператор для использования. Подготовленные операторы можно очистить вручную с помощью команды &lt;a href=&quot;sql-deallocate&quot;&gt;DEALLOCATE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a483a03c91ae871a21f8ef97015a97d796c2feb5" translate="yes" xml:space="preserve">
          <source>Prepared statements potentially have the largest performance advantage when a single session is being used to execute a large number of similar statements. The performance difference will be particularly significant if the statements are complex to plan or rewrite, e.g. if the query involves a join of many tables or requires the application of several rules. If the statement is relatively simple to plan and rewrite but relatively expensive to execute, the performance advantage of prepared statements will be less noticeable.</source>
          <target state="translated">Готовые заявления потенциально имеют наибольшее преимущество в производительности,когда один сеанс используется для выполнения большого количества аналогичных заявлений.Разница в производительности будет особенно существенной,если операторы сложны в планировании или перезаписи,например,если запрос включает в себя соединение многих таблиц или требует применения нескольких правил.Если оператор относительно прост в планировании и перезаписи,но относительно дорог в выполнении,то преимущество в производительности подготовленных операторов будет менее заметным.</target>
        </trans-unit>
        <trans-unit id="7a94a7cd86cc26d07584643894920d2ea393b742" translate="yes" xml:space="preserve">
          <source>Prepared statements potentially have the largest performance advantage when a single session is being used to execute a large number of similar statements. The performance difference will be particularly significant if the statements are complex to plan or rewrite, e.g., if the query involves a join of many tables or requires the application of several rules. If the statement is relatively simple to plan and rewrite but relatively expensive to execute, the performance advantage of prepared statements will be less noticeable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753ab9dddcfb8d57e3e410ee3c11bd1e55a46a27" translate="yes" xml:space="preserve">
          <source>Prepares the server to begin an on-line backup. The only required parameter is an arbitrary user-defined label for the backup. (Typically this would be the name under which the backup dump file will be stored.) If the optional second parameter is given as &lt;code&gt;true&lt;/code&gt;, it specifies executing &lt;code&gt;pg_start_backup&lt;/code&gt; as quickly as possible. This forces an immediate checkpoint which will cause a spike in I/O operations, slowing any concurrently executing queries. The optional third parameter specifies whether to perform an exclusive or non-exclusive backup (default is exclusive).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d9df46eddb7f24ca7fe8fbfe8e2dbda8bfc576" translate="yes" xml:space="preserve">
          <source>Prepends an element to the beginning of an array (same as the &lt;code&gt;anyelement&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;anyarray&lt;/code&gt; operator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e489d5458780c56ecec5255859ffa473005ad5" translate="yes" xml:space="preserve">
          <source>Presently, &lt;code&gt;COPY TO&lt;/code&gt; will never emit an octal or hex-digits backslash sequence, but it does use the other sequences listed above for those control characters.</source>
          <target state="translated">В настоящее время &lt;code&gt;COPY TO&lt;/code&gt; никогда не будет генерировать восьмеричную или шестнадцатеричную обратную косую черту, но он использует другие последовательности, перечисленные выше для этих управляющих символов.</target>
        </trans-unit>
        <trans-unit id="aa75b2cb1f42b5b78ef47e3bac6d7cbc20568a8c" translate="yes" xml:space="preserve">
          <source>Presently, &lt;code&gt;ON SELECT&lt;/code&gt; rules must be unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules and must have actions that consist of a single &lt;code&gt;SELECT&lt;/code&gt; command. Thus, an &lt;code&gt;ON SELECT&lt;/code&gt; rule effectively turns the table into a view, whose visible contents are the rows returned by the rule's &lt;code&gt;SELECT&lt;/code&gt; command rather than whatever had been stored in the table (if anything). It is considered better style to write a &lt;code&gt;CREATE VIEW&lt;/code&gt; command than to create a real table and define an &lt;code&gt;ON SELECT&lt;/code&gt; rule for it.</source>
          <target state="translated">В настоящее время правила &lt;code&gt;ON SELECT&lt;/code&gt; должны быть безусловными правилами &lt;code&gt;INSTEAD&lt;/code&gt; и должны иметь действия, состоящие из одной команды &lt;code&gt;SELECT&lt;/code&gt; . Таким образом, правило &lt;code&gt;ON SELECT&lt;/code&gt; эффективно превращает таблицу в представление, видимым содержимым которого являются строки, возвращаемые командой &lt;code&gt;SELECT&lt;/code&gt; правила, а не то, что было сохранено в таблице (если что-либо). Считается, что лучше написать команду &lt;code&gt;CREATE VIEW&lt;/code&gt; , чем создавать настоящую таблицу и определять для нее правило &lt;code&gt;ON SELECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52172a45fa35ea47ee37481a7598605f94332941" translate="yes" xml:space="preserve">
          <source>Presently, all data values in a binary-format file are assumed to be in binary format (format code one). It is anticipated that a future extension might add a header field that allows per-column format codes to be specified.</source>
          <target state="translated">В настоящее время все значения данных в файле двоичного формата предполагаются в двоичном формате (код формата один).Предполагается,что будущее расширение может добавить поле заголовка,позволяющее указывать коды формата на столбец.</target>
        </trans-unit>
        <trans-unit id="07a55fa2dfc20be04c1afe40194156f4b790bc71" translate="yes" xml:space="preserve">
          <source>Presently, if a rule action contains a &lt;code&gt;NOTIFY&lt;/code&gt; command, the &lt;code&gt;NOTIFY&lt;/code&gt; command will be executed unconditionally, that is, the &lt;code&gt;NOTIFY&lt;/code&gt; will be issued even if there are not any rows that the rule should apply to. For example, in:</source>
          <target state="translated">В настоящее время, если действие правила содержит команду &lt;code&gt;NOTIFY&lt;/code&gt; , команда &lt;code&gt;NOTIFY&lt;/code&gt; будет выполняться безоговорочно, то есть &lt;code&gt;NOTIFY&lt;/code&gt; будет выдано, даже если нет строк, к которым должно применяться правило. Например, в:</target>
        </trans-unit>
        <trans-unit id="70f8a5644dc2d0fd28dd5618b027e4363107a89a" translate="yes" xml:space="preserve">
          <source>Presently, the commands emitted for &lt;code&gt;--disable-triggers&lt;/code&gt; must be done as superuser. So you should also specify a superuser name with &lt;code&gt;-S&lt;/code&gt; or, preferably, run pg_restore as a PostgreSQL superuser.</source>
          <target state="translated">В настоящее время команды, выдаваемые для &lt;code&gt;--disable-triggers&lt;/code&gt; , должны выполняться от имени суперпользователя. Поэтому вы также должны указать имя суперпользователя с &lt;code&gt;-S&lt;/code&gt; или, желательно, запустить pg_restore как суперпользователь PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="48866779c6574ae0eb32e070be6be5c56e3ca440" translate="yes" xml:space="preserve">
          <source>Presently, the commands emitted for &lt;code&gt;--disable-triggers&lt;/code&gt; must be done as superuser. So, you should also specify a superuser name with &lt;code&gt;-S&lt;/code&gt;, or preferably be careful to start the resulting script as a superuser.</source>
          <target state="translated">В настоящее время команды, выдаваемые для &lt;code&gt;--disable-triggers&lt;/code&gt; , должны выполняться от имени суперпользователя. Таким образом, вы также должны указать имя суперпользователя с помощью &lt;code&gt;-S&lt;/code&gt; или, желательно, быть осторожным, чтобы запустить получившийся скрипт как суперпользователь.</target>
        </trans-unit>
        <trans-unit id="334d01d9c8e3bbf43f71d7eda4f0774b3bc44f64" translate="yes" xml:space="preserve">
          <source>Preset Options</source>
          <target state="translated">Предустановленные параметры</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="ee7bdb0dff39839c1fd827f5826a7bfd60c2d7e2" translate="yes" xml:space="preserve">
          <source>Prevent dumping of access privileges (grant/revoke commands).</source>
          <target state="translated">Предотвращение демпинга привилегий доступа (команды разрешения/отзыва).</target>
        </trans-unit>
        <trans-unit id="a0771736ef9369c38d7919dcb8f69f80ef4855cc" translate="yes" xml:space="preserve">
          <source>Prevent restoration of access privileges (grant/revoke commands).</source>
          <target state="translated">Предотвращение восстановления привилегий доступа (команды разрешения/отзыва).</target>
        </trans-unit>
        <trans-unit id="233b752a1d979d1b03bfc00189d385eb81deac5c" translate="yes" xml:space="preserve">
          <source>Preventing Server Spoofing</source>
          <target state="translated">Предотвращение подмены сервера</target>
        </trans-unit>
        <trans-unit id="1a94269e22003d091ed6391f5e761e1543872045" translate="yes" xml:space="preserve">
          <source>Prevents issuing a password prompt. If the server requires password authentication and a password is not available by other means such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bdc61ee10f118e8dbdacdf82251ed8db7cccd4" translate="yes" xml:space="preserve">
          <source>Prevents the creation of a temporary replication slot for the backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b615ec81ab4e47bd0f90f57d3f7154275428abd" translate="yes" xml:space="preserve">
          <source>Prevents the server from estimating the total amount of backup data that will be streamed, resulting in the &lt;code&gt;backup_total&lt;/code&gt; column in the &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view always being &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97befde20e55eaecab9bab9cc63c02e247c4a9f" translate="yes" xml:space="preserve">
          <source>Previous releases failed to preserve a lock which is upgraded by a later savepoint. For example, this code:</source>
          <target state="translated">Предыдущие выпуски не смогли сохранить замок,который обновляется более поздней точкой сохранения.Например,этот код:</target>
        </trans-unit>
        <trans-unit id="7ed4a0fe2451468df117ba30c37470ca22149ca7" translate="yes" xml:space="preserve">
          <source>Primary (server)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4bbf8103efddb82c7e4b9fff8c530d57422a504" translate="yes" xml:space="preserve">
          <source>Primary key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e203068f90ee842092a40f00034de5e2bf0c940" translate="yes" xml:space="preserve">
          <source>Primary keys are useful both for documentation purposes and for client applications. For example, a GUI application that allows modifying row values probably needs to know the primary key of a table to be able to identify rows uniquely. There are also various ways in which the database system makes use of a primary key if one has been declared; for example, the primary key defines the default target column(s) for foreign keys referencing its table.</source>
          <target state="translated">Первичные ключи полезны как для документации,так и для клиентских приложений.Например,GUI-приложение,позволяющее изменять значения строк,вероятно,должно знать первичный ключ таблицы,чтобы иметь возможность уникально идентифицировать строки.Существуют также различные способы,которыми система БД использует первичный ключ,если он был объявлен;например,первичный ключ определяет целевой столбец (столбцы)по умолчанию для иностранных ключей,ссылающихся на его таблицу.</target>
        </trans-unit>
        <trans-unit id="302096a883e851361a7c65e770ac4a2f93b77640" translate="yes" xml:space="preserve">
          <source>Primary keys can span more than one column; the syntax is similar to unique constraints:</source>
          <target state="translated">Первичные ключи могут занимать более одного столбца;синтаксис аналогичен уникальным ограничениям:</target>
        </trans-unit>
        <trans-unit id="54c622f5b5e8c75c7d4757c68339aa2e8b25f7fc" translate="yes" xml:space="preserve">
          <source>Primary log file name, or log in the requested format, currently in use by the logging collector</source>
          <target state="translated">Имя первичного лог-файла,или регистрация в запрашиваемом формате,используемом в настоящее время коллектором лог-файлов.</target>
        </trans-unit>
        <trans-unit id="4a03aad5c247b986acad6d97b6927c2a6ffb1095" translate="yes" xml:space="preserve">
          <source>Primitive JSON values are compared using the same comparison rules as for the underlying PostgreSQL data type. Strings are compared using the default database collation.</source>
          <target state="translated">Примитивные значения JSON сравниваются по тем же правилам сравнения,что и для базового типа данных PostgreSQL.Сравнение строк выполняется с использованием стандартного сравнения баз данных.</target>
        </trans-unit>
        <trans-unit id="9f9dd23572b66164559cf3545fb93e79c89e5d8a" translate="yes" xml:space="preserve">
          <source>Principal used to authenticate this connection, or NULL if GSSAPI was not used to authenticate this connection. This field is truncated if the principal is longer than &lt;code&gt;NAMEDATALEN&lt;/code&gt; (64 characters in a standard build).</source>
          <target state="translated">Принципал, используемый для аутентификации этого соединения, или NULL, если GSSAPI не использовался для аутентификации этого соединения. Это поле усекается, если основной &lt;code&gt;NAMEDATALEN&lt;/code&gt; длиннее NAMEDATALEN (64 символа в стандартной сборке).</target>
        </trans-unit>
        <trans-unit id="a7e7318f55e0c844d9e1050c000b470ae6a8596e" translate="yes" xml:space="preserve">
          <source>Print additional information including the version and the &quot;include&quot; path.</source>
          <target state="translated">Распечатайте дополнительную информацию,включая версию и путь &quot;включить&quot;.</target>
        </trans-unit>
        <trans-unit id="e8de0f5082ac6065288eac684400de412407c144" translate="yes" xml:space="preserve">
          <source>Print all nonempty input lines to standard output as they are read. (This does not apply to lines read interactively.) This is equivalent to setting the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">Вывести все непустые строки ввода в стандартный вывод по мере их чтения. (Это не относится к строкам, читаемым в интерактивном режиме.) Это эквивалентно установке переменной &lt;code&gt;ECHO&lt;/code&gt; на &lt;code&gt;all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebb9a1e5bbdb1243d5e4a31dff31eebe9fc06f03" translate="yes" xml:space="preserve">
          <source>Print debugging output from the bootstrap backend and a few other messages of lesser interest for the general public. The bootstrap backend is the program &lt;code&gt;initdb&lt;/code&gt; uses to create the catalog tables. This option generates a tremendous amount of extremely boring output.</source>
          <target state="translated">Распечатайте отладочные данные из бэкэнда начальной загрузки и несколько других сообщений, представляющих меньший интерес для широкой публики. Бэкэнд начальной загрузки - это программа, которую &lt;code&gt;initdb&lt;/code&gt; использует для создания таблиц каталога. Эта опция генерирует огромное количество чрезвычайно скучных результатов.</target>
        </trans-unit>
        <trans-unit id="a7c370355f00f0bd758a9808623b790c218141fd" translate="yes" xml:space="preserve">
          <source>Print debugging output.</source>
          <target state="translated">Вывод на печать результатов отладки.</target>
        </trans-unit>
        <trans-unit id="f0d63d35347e807b3cd5630fcccfcb97aefdff03" translate="yes" xml:space="preserve">
          <source>Print detailed information during processing.</source>
          <target state="translated">Во время обработки распечатайте подробную информацию.</target>
        </trans-unit>
        <trans-unit id="c073dbd6b543c579fb650eb5ea8d11e57c402573" translate="yes" xml:space="preserve">
          <source>Print failed SQL commands to standard error output. This is equivalent to setting the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;errors&lt;/code&gt;.</source>
          <target state="translated">Вывести неудачные команды SQL в стандартный вывод ошибок. Это эквивалентно установке переменной &lt;code&gt;ECHO&lt;/code&gt; на &lt;code&gt;errors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="597bb464eafa276a5ad0cc91e76eaf6190c85748" translate="yes" xml:space="preserve">
          <source>Print lots of debug logging output on &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">Распечатайте много выходных данных журнала отладки на &lt;code&gt;stderr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a75f64b677ea04810bae39f5467bba0bd440ec28" translate="yes" xml:space="preserve">
          <source>Print only errors, no informational messages.</source>
          <target state="translated">Печатайте только ошибки,никаких информационных сообщений.</target>
        </trans-unit>
        <trans-unit id="4f01f9df20b27d4321c4eb47d64e1ce581df8c21" translate="yes" xml:space="preserve">
          <source>Print psql's command line history to &lt;code&gt;filename&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is omitted, the history is written to the standard output (using the pager if appropriate). This command is not available if psql was built without Readline support.</source>
          <target state="translated">Распечатать историю командной строки psql в &lt;code&gt;filename&lt;/code&gt; . Если &lt;code&gt;filename&lt;/code&gt; не указано, история записывается на стандартный вывод (при необходимости с помощью пейджера). Эта команда недоступна, если psql был собран без поддержки Readline.</target>
        </trans-unit>
        <trans-unit id="827ff74717cfd2b965ff32b6c6548085dff68335" translate="yes" xml:space="preserve">
          <source>Print the clusterdb version and exit.</source>
          <target state="translated">Распечатайте версию clusterdb и выйдите.</target>
        </trans-unit>
        <trans-unit id="f6d64dc0309d9d3b50923addc35c2349b3a13866" translate="yes" xml:space="preserve">
          <source>Print the createdb version and exit.</source>
          <target state="translated">Распечатайте созданную версию и выйдите.</target>
        </trans-unit>
        <trans-unit id="f9c1069309fb6fad15e176f641cc5f92410a215f" translate="yes" xml:space="preserve">
          <source>Print the createuser version and exit.</source>
          <target state="translated">Распечатайте версию создателя и выйдите.</target>
        </trans-unit>
        <trans-unit id="6ca986b09253f90ac05485c4d1b53fd88df68efc" translate="yes" xml:space="preserve">
          <source>Print the current query buffer to the standard output. If the current query buffer is empty, the most recently executed query is printed instead.</source>
          <target state="translated">Вывод текущего буфера запроса на стандартный вывод.Если буфер текущего запроса пуст,то вместо него выводится последний выполненный запрос.</target>
        </trans-unit>
        <trans-unit id="1947bab167f53773caffcdb3abd24d61e23f4340" translate="yes" xml:space="preserve">
          <source>Print the dropdb version and exit.</source>
          <target state="translated">Распечатайте версию dropdb и выйдите.</target>
        </trans-unit>
        <trans-unit id="c27b83ad0e23795e57b1563b077c538c9ab60bb3" translate="yes" xml:space="preserve">
          <source>Print the dropuser version and exit.</source>
          <target state="translated">Распечатайте версию дроплюсера и выйдите.</target>
        </trans-unit>
        <trans-unit id="e9eeca2b3e3f27d8960033787d850e4053105026" translate="yes" xml:space="preserve">
          <source>Print the ecpg version and exit.</source>
          <target state="translated">Распечатайте версию ecpg и выйдите.</target>
        </trans-unit>
        <trans-unit id="657af6d675a70187bdfd892abd1e767e65979526" translate="yes" xml:space="preserve">
          <source>Print the initdb version and exit.</source>
          <target state="translated">Распечатать версию initdb и выйти.</target>
        </trans-unit>
        <trans-unit id="a31c7045982c28354a2311d649532f2714d0cd52" translate="yes" xml:space="preserve">
          <source>Print the location of C header files for server programming.</source>
          <target state="translated">Распечатайте расположение заголовочных файлов C для серверного программирования.</target>
        </trans-unit>
        <trans-unit id="c7399f9aea54b81806345b5fe9d88c09f2b217c4" translate="yes" xml:space="preserve">
          <source>Print the location of C header files of the client interfaces.</source>
          <target state="translated">Распечатайте расположение заголовочных файлов C клиентских интерфейсов.</target>
        </trans-unit>
        <trans-unit id="595d5d7d00e3b9031bcf9b394461136007040d8b" translate="yes" xml:space="preserve">
          <source>Print the location of HTML documentation files.</source>
          <target state="translated">Распечатайте расположение файлов HTML-документации.</target>
        </trans-unit>
        <trans-unit id="2c45a54aeef843a3b47abadef8be23a9c8c5faa3" translate="yes" xml:space="preserve">
          <source>Print the location of architecture-independent support files.</source>
          <target state="translated">Распечатайте расположение архитектурно-независимых файлов поддержки.</target>
        </trans-unit>
        <trans-unit id="6938b263f35a6474ff201cc4e757d0f937313671" translate="yes" xml:space="preserve">
          <source>Print the location of documentation files.</source>
          <target state="translated">Распечатайте расположение файлов документации.</target>
        </trans-unit>
        <trans-unit id="38bf4c616b7c56d3f58464d10d1a64af7f6e8779" translate="yes" xml:space="preserve">
          <source>Print the location of dynamically loadable modules, or where the server would search for them. (Other architecture-dependent data files might also be installed in this directory.)</source>
          <target state="translated">Распечатайте расположение динамически загружаемых модулей или место,где сервер будет их искать.(В этом каталоге могут быть установлены и другие файлы данных,зависящие от архитектуры).</target>
        </trans-unit>
        <trans-unit id="53148cc85f0f5372b92b4adab97d78f0cf599385" translate="yes" xml:space="preserve">
          <source>Print the location of extension makefiles.</source>
          <target state="translated">Распечатайте расположение расширенных макетов.</target>
        </trans-unit>
        <trans-unit id="4dee3cc7ede35752aad16661b510c6ddc2cb5087" translate="yes" xml:space="preserve">
          <source>Print the location of locale support files. (This will be an empty string if locale support was not configured when PostgreSQL was built.)</source>
          <target state="translated">Распечатайте расположение файлов поддержки локали.(Это будет пустая строка,если на момент сборки PostgreSQL поддержка локали не была сконфигурирована).</target>
        </trans-unit>
        <trans-unit id="8935ed932264eb12d05dc3d54390bc5894e6a109" translate="yes" xml:space="preserve">
          <source>Print the location of manual pages.</source>
          <target state="translated">Распечатайте расположение страниц с инструкциями.</target>
        </trans-unit>
        <trans-unit id="5c6b2cdac40039c6a4b46eed898e35031563c475" translate="yes" xml:space="preserve">
          <source>Print the location of object code libraries.</source>
          <target state="translated">Распечатайте расположение библиотек объектного кода.</target>
        </trans-unit>
        <trans-unit id="cc4be32137a130cb7e8939f72a35980a1297a7e0" translate="yes" xml:space="preserve">
          <source>Print the location of other C header files.</source>
          <target state="translated">Распечатайте расположение других заголовочных файлов C.</target>
        </trans-unit>
        <trans-unit id="348ec650580d85aaddcb30661d2eb9345e76019a" translate="yes" xml:space="preserve">
          <source>Print the location of system-wide configuration files.</source>
          <target state="translated">Распечатайте расположение общесистемных конфигурационных файлов.</target>
        </trans-unit>
        <trans-unit id="4773e766d5cc8cfc3ce755cd29aeb486a0dd05ae" translate="yes" xml:space="preserve">
          <source>Print the location of user executables. Use this, for example, to find the &lt;code&gt;psql&lt;/code&gt; program. This is normally also the location where the &lt;code&gt;pg_config&lt;/code&gt; program resides.</source>
          <target state="translated">Вывести расположение исполняемых файлов пользователя. Используйте это, например, чтобы найти программу &lt;code&gt;psql&lt;/code&gt; . Обычно это также место, где &lt;code&gt;pg_config&lt;/code&gt; программа pg_config .</target>
        </trans-unit>
        <trans-unit id="53049ab5ef89f22bb5a6370fb0f7681de3a90603" translate="yes" xml:space="preserve">
          <source>Print the names of the files that would have been removed on &lt;code&gt;stdout&lt;/code&gt; (performs a dry run).</source>
          <target state="translated">Выведите имена файлов, которые были бы удалены на стандартный &lt;code&gt;stdout&lt;/code&gt; (выполняет пробный запуск).</target>
        </trans-unit>
        <trans-unit id="9c56e3a83e3c5d8c7d0ed82cb15ca361eb64f1dd" translate="yes" xml:space="preserve">
          <source>Print the options that were given to the &lt;code&gt;configure&lt;/code&gt; script when PostgreSQL was configured for building. This can be used to reproduce the identical configuration, or to find out with what options a binary package was built. (Note however that binary packages often contain vendor-specific custom patches.) See also the examples below.</source>
          <target state="translated">Распечатайте параметры, которые были даны сценарию &lt;code&gt;configure&lt;/code&gt; при настройке PostgreSQL для сборки. Это можно использовать для воспроизведения идентичной конфигурации или для того, чтобы узнать, с какими опциями был собран бинарный пакет. (Обратите внимание, однако, что бинарные пакеты часто содержат специальные исправления для конкретных производителей.) См. Также примеры ниже.</target>
        </trans-unit>
        <trans-unit id="b85724f77cfb0e7f274dc964acb424d6648ba3f5" translate="yes" xml:space="preserve">
          <source>Print the pg_archivecleanup version and exit.</source>
          <target state="translated">Распечатать версию pg_archivecleanup и выйти.</target>
        </trans-unit>
        <trans-unit id="74b744744ac1bd9386b12893ce62c91739371ca7" translate="yes" xml:space="preserve">
          <source>Print the pg_basebackup version and exit.</source>
          <target state="translated">Распечатать версию pg_basebackup и выйти.</target>
        </trans-unit>
        <trans-unit id="1fca2718d1cfc02986e8abfd6906319ca68c5805" translate="yes" xml:space="preserve">
          <source>Print the pg_checksums version and exit.</source>
          <target state="translated">Распечатать версию pg_checksums и выйти.</target>
        </trans-unit>
        <trans-unit id="bff35bc331305f42d0adc605e5c4b58b8bea0e9f" translate="yes" xml:space="preserve">
          <source>Print the pg_ctl version and exit.</source>
          <target state="translated">Распечатать версию pg_ctl и выйти.</target>
        </trans-unit>
        <trans-unit id="2f2c8e42d192d577eaeaaebcc2a4ef29dbe17a60" translate="yes" xml:space="preserve">
          <source>Print the pg_dump version and exit.</source>
          <target state="translated">Распечатать версию pg_dump и выйти.</target>
        </trans-unit>
        <trans-unit id="711f70c380c99649a9e35f12c5de7cf7f0629905" translate="yes" xml:space="preserve">
          <source>Print the pg_dumpall version and exit.</source>
          <target state="translated">Распечатать версию pg_dumpall и выйти.</target>
        </trans-unit>
        <trans-unit id="8234e166090222ac3be3d5f09ddf8625331bebb7" translate="yes" xml:space="preserve">
          <source>Print the pg_isready version and exit.</source>
          <target state="translated">Распечатать версию pg_isready и выйти.</target>
        </trans-unit>
        <trans-unit id="521a97d4453901044173e646cb65a707141a7eb2" translate="yes" xml:space="preserve">
          <source>Print the pg_receivewal version and exit.</source>
          <target state="translated">Распечатать версию pg_receivewal и выйти.</target>
        </trans-unit>
        <trans-unit id="8fea9240f920d019a51b3b8ffd1d91229e6f0d5d" translate="yes" xml:space="preserve">
          <source>Print the pg_recvlogical version and exit.</source>
          <target state="translated">Распечатайте pg_recvlogical версию и выйдите.</target>
        </trans-unit>
        <trans-unit id="70b6553fafd53c48b770a9da4d3ec37d70a8b1bd" translate="yes" xml:space="preserve">
          <source>Print the pg_restore version and exit.</source>
          <target state="translated">Распечатать версию pg_restore и выйти.</target>
        </trans-unit>
        <trans-unit id="6c61b85690c18a6b2ca1bca9177c45ff31b5bf02" translate="yes" xml:space="preserve">
          <source>Print the pg_test_fsync version and exit.</source>
          <target state="translated">Распечатать версию pg_test_fsync и выйти.</target>
        </trans-unit>
        <trans-unit id="b30cd37e82aef2f652a2277ade9f7c97f25f875b" translate="yes" xml:space="preserve">
          <source>Print the pg_test_timing version and exit.</source>
          <target state="translated">Распечатать версию pg_test_timing и выйти.</target>
        </trans-unit>
        <trans-unit id="e08a7072f490e6a4e9bfb50e943fdf0655a61477" translate="yes" xml:space="preserve">
          <source>Print the pg_verifybackup version and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75796fa54df85333380d1e7052d5f64abec4dce" translate="yes" xml:space="preserve">
          <source>Print the pg_waldump version and exit.</source>
          <target state="translated">Распечатать версию pg_waldump и выйти.</target>
        </trans-unit>
        <trans-unit id="835f88fb67301afbc19bedf23ff78555f1978387" translate="yes" xml:space="preserve">
          <source>Print the pgbench version and exit.</source>
          <target state="translated">Распечатайте версию pgbench и выйдите.</target>
        </trans-unit>
        <trans-unit id="f24e000355bdd04337ccc4fe4d288fbdae421623" translate="yes" xml:space="preserve">
          <source>Print the postgres version and exit.</source>
          <target state="translated">Распечатайте версию postgres и выйдите.</target>
        </trans-unit>
        <trans-unit id="a240d07648994ecf31009ecc7c34fcbc6cd8c620" translate="yes" xml:space="preserve">
          <source>Print the psql version and exit.</source>
          <target state="translated">Распечатайте версию для psql и выйдите.</target>
        </trans-unit>
        <trans-unit id="9739b8f99cc181f488382f72fe14dfc0f6cbc479" translate="yes" xml:space="preserve">
          <source>Print the reindexdb version and exit.</source>
          <target state="translated">Распечатать версию reindexdb и выйти.</target>
        </trans-unit>
        <trans-unit id="ecaad77a21e5cec5eaf16f12e5d3692f68b6cf4f" translate="yes" xml:space="preserve">
          <source>Print the vacuumdb version and exit.</source>
          <target state="translated">Распечатать версию вакуумного дБ и выйти.</target>
        </trans-unit>
        <trans-unit id="860a0a17430dffac960ad73d395384c352d45cdd" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CC&lt;/code&gt; variable that was used for building PostgreSQL. This shows the C compiler used.</source>
          <target state="translated">Выведите значение переменной &lt;code&gt;CC&lt;/code&gt; , которая использовалась для сборки PostgreSQL. Это показывает используемый компилятор C.</target>
        </trans-unit>
        <trans-unit id="7872c242661cddddfe9f42b05b47dc0212422396" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows C compiler switches.</source>
          <target state="translated">Выведите значение переменной &lt;code&gt;CFLAGS&lt;/code&gt; , которая использовалась для сборки PostgreSQL. Это показывает переключатели компилятора C.</target>
        </trans-unit>
        <trans-unit id="04b3c2f0676508a38269ff7567031f4ef2b568d8" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CFLAGS_SL&lt;/code&gt; variable that was used for building PostgreSQL. This shows extra C compiler switches used for building shared libraries.</source>
          <target state="translated">Вывести значение &lt;code&gt;CFLAGS_SL&lt;/code&gt; переменной , которая была использована для построения PostgreSQL. Здесь показаны дополнительные переключатели компилятора C, используемые для создания общих библиотек.</target>
        </trans-unit>
        <trans-unit id="7c0bdef9295fb7af405415912b5de766b9d4853d" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CPPFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows C compiler switches needed at preprocessing time (typically, &lt;code&gt;-I&lt;/code&gt; switches).</source>
          <target state="translated">Вывести значение &lt;code&gt;CPPFLAGS&lt;/code&gt; переменной , которая была использована для построения PostgreSQL. Это показывает переключатели компилятора C, необходимые во время предварительной обработки (обычно переключатели &lt;code&gt;-I&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0696181ec9c948b2b028ffaf665cb6bea3b893d7" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches.</source>
          <target state="translated">Вывести значение &lt;code&gt;LDFLAGS&lt;/code&gt; переменной , которая была использована для построения PostgreSQL. Это показывает переключатели компоновщика.</target>
        </trans-unit>
        <trans-unit id="6bb0fe5ffeea6cad2f014a2a3a3b8da60923296c" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS_EX&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches used for building executables only.</source>
          <target state="translated">Вывести значение &lt;code&gt;LDFLAGS_EX&lt;/code&gt; переменной , которая была использована для построения PostgreSQL. Здесь показаны переключатели компоновщика, используемые только для сборки исполняемых файлов.</target>
        </trans-unit>
        <trans-unit id="afbd4079f245521defb38cf6819d6a459fcf80ee" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS_SL&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches used for building shared libraries only.</source>
          <target state="translated">Вывести значение &lt;code&gt;LDFLAGS_SL&lt;/code&gt; переменной , которая была использована для построения PostgreSQL. Здесь показаны переключатели компоновщика, используемые только для создания общих библиотек.</target>
        </trans-unit>
        <trans-unit id="6ca57dae88c29583c5d57897894867bc83f03e6b" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LIBS&lt;/code&gt; variable that was used for building PostgreSQL. This normally contains &lt;code&gt;-l&lt;/code&gt; switches for external libraries linked into PostgreSQL.</source>
          <target state="translated">Выведите значение переменной &lt;code&gt;LIBS&lt;/code&gt; , которая использовалась для сборки PostgreSQL. Обычно он содержит ключи &lt;code&gt;-l&lt;/code&gt; для внешних библиотек, связанных с PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="8570b6b8795434406c72b8b33b0f9520fcd7b330" translate="yes" xml:space="preserve">
          <source>Print the version of PostgreSQL.</source>
          <target state="translated">Распечатать версию PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="c7df780f62e4b06755a28e7503d78d06b7b6aac8" translate="yes" xml:space="preserve">
          <source>Print time information and other statistics at the end of each command. This is useful for benchmarking or for use in tuning the number of buffers.</source>
          <target state="translated">Печать информации о времени и другой статистики в конце каждой команды.Это полезно для бенчмаркинга или для настройки количества буферов.</target>
        </trans-unit>
        <trans-unit id="7df4a5fb243017c5e16941bc4e0dfea430b29b29" translate="yes" xml:space="preserve">
          <source>Print timing statistics for each query relating to each of the major system modules. This option cannot be used together with the &lt;code&gt;-s&lt;/code&gt; option.</source>
          <target state="translated">Распечатайте статистику времени для каждого запроса, относящегося к каждому из основных модулей системы. Этот параметр нельзя использовать вместе с параметром &lt;code&gt;-s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85a0746f8a9b8ded581582b11332c0023bccc928" translate="yes" xml:space="preserve">
          <source>Print verbose debugging output that is mostly useful for developers debugging pg_rewind.</source>
          <target state="translated">Распечатайте подробный отладочный вывод,который,в основном,полезен для разработчиков,занимающихся отладкой pg_rewind.</target>
        </trans-unit>
        <trans-unit id="97b0c0a03f737e5ff32021d5ed70701853641a62" translate="yes" xml:space="preserve">
          <source>Prints a detailed vacuum activity report for each table.</source>
          <target state="translated">Печатает подробный отчет о вакуумной активности для каждого стола.</target>
        </trans-unit>
        <trans-unit id="fdb87a5e1b1bdc10bff754f8e203de6fe5cda103" translate="yes" xml:space="preserve">
          <source>Prints a progress report as each index is reindexed.</source>
          <target state="translated">Печатает отчет о проделанной работе по мере реиндексации каждого индекса.</target>
        </trans-unit>
        <trans-unit id="aa656d5b9337debc039cad558013cd97db922af4" translate="yes" xml:space="preserve">
          <source>Prints a progress report as each table is clustered.</source>
          <target state="translated">Печатает отчет о проделанной работе по мере группировки каждой таблицы.</target>
        </trans-unit>
        <trans-unit id="dd907f7d58905d750186d058c3a6deb80e3a4b4f" translate="yes" xml:space="preserve">
          <source>Prints the argument to stderr, and returns the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b2b40104cd92cd0c519f2553360402afa05710" translate="yes" xml:space="preserve">
          <source>Prints the arguments to the standard output, separated by one space and followed by a newline. This can be useful to intersperse information in the output of scripts. For example:</source>
          <target state="translated">Печатает аргументы на стандартный вывод,разделенный одним пробелом и сопровождаемый новой строкой.Это может быть полезно для интерферирования информации в выводах скриптов.Например:</target>
        </trans-unit>
        <trans-unit id="54169614c32fc13e7741fdc14ac2684c64e4dad5" translate="yes" xml:space="preserve">
          <source>Prints the evaluated arguments to standard output, separated by spaces and followed by a newline. This can be useful to intersperse information in the output of scripts. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f1bb5606479758154dc8298304bb8f734e9529b" translate="yes" xml:space="preserve">
          <source>Prints the pg_basebackup version and exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89aa4d95dc992bd35115af766260f55953c5bc3" translate="yes" xml:space="preserve">
          <source>Prints the value of the named run-time parameter, and exits. (See the &lt;code&gt;-c&lt;/code&gt; option above for details.) This can be used on a running server, and returns values from &lt;code&gt;postgresql.conf&lt;/code&gt;, modified by any parameters supplied in this invocation. It does not reflect parameters supplied when the cluster was started.</source>
          <target state="translated">Печатает значение указанного параметра времени выполнения и завершает работу. (Для получения дополнительной информации см. Параметр &lt;code&gt;-c&lt;/code&gt; выше.) Его можно использовать на работающем сервере и возвращает значения из &lt;code&gt;postgresql.conf&lt;/code&gt; , измененные любыми параметрами, указанными в этом вызове. Он не отражает параметры, предоставленные при запуске кластера.</target>
        </trans-unit>
        <trans-unit id="4dcba485023d207a9206ea5fc3e3c00fb561414e" translate="yes" xml:space="preserve">
          <source>Prior releases of PostgreSQL also had an R-tree index method. This method has been removed because it had no significant advantages over the GiST method. If &lt;code&gt;USING rtree&lt;/code&gt; is specified, &lt;code&gt;CREATE INDEX&lt;/code&gt; will interpret it as &lt;code&gt;USING gist&lt;/code&gt;, to simplify conversion of old databases to GiST.</source>
          <target state="translated">В предыдущих выпусках PostgreSQL также был метод индексации R-tree. Этот метод был удален, поскольку он не имел существенных преимуществ перед методом GiST. Если &lt;code&gt;USING rtree&lt;/code&gt; , &lt;code&gt;CREATE INDEX&lt;/code&gt; будет интерпретировать его как &lt;code&gt;USING gist&lt;/code&gt; , чтобы упростить преобразование старых баз данных в GiST.</target>
        </trans-unit>
        <trans-unit id="3bafe92248149caf71bc79d94b8990987f12cfb7" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 10, this rule did not exist, and unspecified-type literals in a &lt;code&gt;SELECT&lt;/code&gt; output list were left as type &lt;code&gt;unknown&lt;/code&gt;. That had assorted bad consequences, so it's been changed.</source>
          <target state="translated">До PostgreSQL 10 это правило не существовало, и литералы неопределенного типа в выходном списке &lt;code&gt;SELECT&lt;/code&gt; оставались как тип &lt;code&gt;unknown&lt;/code&gt; . Это имело ряд плохих последствий, поэтому все изменилось.</target>
        </trans-unit>
        <trans-unit id="35b1eb24223c97f90cf161ff4a23f9a4840e576e" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 12, it was possible to skip arbitrary text in the input string using non-letter or non-digit characters. For example, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy-MM-DD')&lt;/code&gt; used to work. Now you can only use letter characters for this purpose. For example, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyytMMtDDt')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy&quot;y&quot;MM&quot;m&quot;DD&quot;d&quot;')&lt;/code&gt; skip &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">До PostgreSQL 12 можно было пропускать произвольный текст во входной строке, используя небуквенные или нецифровые символы. Например, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy-MM-DD')&lt;/code&gt; раньше работало. Теперь для этой цели можно использовать только буквенные символы. Например, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyytMMtDDt')&lt;/code&gt; и &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy&quot;y&quot;MM&quot;m&quot;DD&quot;d&quot;')&lt;/code&gt; пропускают &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="857acef4a685e40620b468c416dd0a4e24020172" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 8.2, the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; cases were not handled per SQL specification. A comparison like &lt;code&gt;ROW(a,b) &amp;lt; ROW(c,d)&lt;/code&gt; was implemented as &lt;code&gt;a &amp;lt; c AND b &amp;lt; d&lt;/code&gt; whereas the correct behavior is equivalent to &lt;code&gt;a &amp;lt; c OR (a = c AND b &amp;lt; d)&lt;/code&gt;.</source>
          <target state="translated">До PostgreSQL 8.2 случаи &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;gt;=&lt;/code&gt; не обрабатывались согласно спецификации SQL. Сравнение типа &lt;code&gt;ROW(a,b) &amp;lt; ROW(c,d)&lt;/code&gt; было реализовано как &lt;code&gt;a &amp;lt; c AND b &amp;lt; d&lt;/code&gt; тогда как правильное поведение эквивалентно &lt;code&gt;a &amp;lt; c OR (a = c AND b &amp;lt; d)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ebe12687d87000c523fc24a0eeeef23def50ea6" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were called &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;, respectively. These names are still available, but are deprecated and will eventually be removed. Notice that the old names are reversed from the convention formerly followed by the core geometric data types!</source>
          <target state="translated">До PostgreSQL 8.2 операторы включения &lt;code&gt;@&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;@&lt;/code&gt; назывались &lt;code&gt;@&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; соответственно. Эти имена все еще доступны, но устарели и в конечном итоге будут удалены. Обратите внимание на то, что старые имена перевернуты из соглашения, за которым ранее следовали основные геометрические типы данных!</target>
        </trans-unit>
        <trans-unit id="5348a6ba1728be7d24665ecab38998e34ce72cc3" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 9.0, there was no permission structure associated with large objects. As a result, &lt;code&gt;pg_largeobject&lt;/code&gt; was publicly readable and could be used to obtain the OIDs (and contents) of all large objects in the system. This is no longer the case; use &lt;a href=&quot;catalog-pg-largeobject-metadata&quot;&gt;&lt;code&gt;pg_largeobject_metadata&lt;/code&gt;&lt;/a&gt; to obtain a list of large object OIDs.</source>
          <target state="translated">До PostgreSQL 9.0 не было структуры разрешений, связанной с большими объектами. В результате &lt;code&gt;pg_largeobject&lt;/code&gt; стал общедоступным и мог использоваться для получения OID (и содержимого) всех больших объектов в системе. Это уже не так; используйте &lt;a href=&quot;catalog-pg-largeobject-metadata&quot;&gt; &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; &lt;/a&gt; для получения списка OID больших объектов.</target>
        </trans-unit>
        <trans-unit id="b601cf233ea62fc96a74bc628fe24fcc3e36d22e" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 9.3, only System V shared memory was used, so the amount of System V shared memory required to start the server was much larger. If you are running an older version of the server, please consult the documentation for your server version.</source>
          <target state="translated">До PostgreSQL 9.3 использовалась только разделяемая память System V,поэтому объем разделяемой памяти System V,необходимый для запуска сервера,был значительно больше.Если вы используете более старую версию сервера,обратитесь к документации по вашей серверной версии.</target>
        </trans-unit>
        <trans-unit id="aa951ebcd4fe7e0105a5593fae4e308d45c56780" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL version 9.1, a request for the Serializable transaction isolation level provided exactly the same behavior described here. To retain the legacy Serializable behavior, Repeatable Read should now be requested.</source>
          <target state="translated">До версии 9.1 PostgreSQL запрос на уровень изоляции транзакции Serializable обеспечивал точно такое же поведение,описанное здесь.Чтобы сохранить прежнее поведение Serializable,теперь необходимо запросить Repeatable Read.</target>
        </trans-unit>
        <trans-unit id="284364f281ed56be49bcacf7f01665e2a0a6fd04" translate="yes" xml:space="preserve">
          <source>Priority of this standby server for being chosen as the synchronous standby in a priority-based synchronous replication. This has no effect in a quorum-based synchronous replication.</source>
          <target state="translated">Приоритет этого резервного сервера для выбора в качестве синхронного резервного в синхронной репликации на основе приоритетов.Это не влияет на синхронную репликацию на основе кворума.</target>
        </trans-unit>
        <trans-unit id="515ede092cef3c82a110d9534d9f8d3d6afc3135" translate="yes" xml:space="preserve">
          <source>Privilege</source>
          <target state="translated">Privilege</target>
        </trans-unit>
        <trans-unit id="f10ec7ea8e1d8b3a37e319a1b22811778ff9078d" translate="yes" xml:space="preserve">
          <source>Privilege and Ownership - &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;REASSIGN&lt;/code&gt;</source>
          <target state="translated">Привилегия и право собственности - &lt;code&gt;GRANT&lt;/code&gt; , &lt;code&gt;REVOKE&lt;/code&gt; , &lt;code&gt;REASSIGN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9010c080ebbc337d2462d6350ec168e7027ffdcc" translate="yes" xml:space="preserve">
          <source>Privilege and Ownership: &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;REASSIGN&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3a5e762db24187db518d22a3b23c1896a649d9" translate="yes" xml:space="preserve">
          <source>Privileges</source>
          <target state="translated">Privileges</target>
        </trans-unit>
        <trans-unit id="2a58093a093ab7a9a99a1645efb525934d0d372c" translate="yes" xml:space="preserve">
          <source>Privileges are only checked once at the start of a replication connection. They are not re-checked as each change record is read from the publisher, nor are they re-checked for each change when applied.</source>
          <target state="translated">Привилегии проверяются только один раз в начале соединения репликации.Они не проверяются повторно,так как каждая запись изменения считывается с издателя,и не проверяются повторно для каждого изменения,когда оно применяется.</target>
        </trans-unit>
        <trans-unit id="1787c604579783f25be8d303f900f7717e89e48f" translate="yes" xml:space="preserve">
          <source>Privileges on databases, tablespaces, schemas, and languages are PostgreSQL extensions.</source>
          <target state="translated">Привилегии для баз данных,табличных пространств,схем и языков являются расширениями PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="46289836967711686edf2dff70a298178c49970e" translate="yes" xml:space="preserve">
          <source>Probe that fires after dirty buffers have been written to the kernel, and before starting to issue fsync requests.</source>
          <target state="translated">Возможно,это происходит после того,как грязные буферы были записаны в ядро,и перед тем,как начать выдавать запросы fsync.</target>
        </trans-unit>
        <trans-unit id="53ee2024c54dc2129f5d4dce9249284ce7d962e4" translate="yes" xml:space="preserve">
          <source>Probe that fires after each buffer is written during checkpoint. arg0 is the ID number of the buffer.</source>
          <target state="translated">Возможно,это происходит после того,как каждый буфер будет записан во время контрольной точки.arg0-это идентификационный номер буфера.</target>
        </trans-unit>
        <trans-unit id="3c4f6900a8f3d94a47b827dad74ca58a7f090a3e" translate="yes" xml:space="preserve">
          <source>Probe that fires anytime the server process updates its &lt;code&gt;pg_stat_activity&lt;/code&gt;.&lt;code&gt;status&lt;/code&gt;. arg0 is the new status string.</source>
          <target state="translated">Зонд, который срабатывает каждый раз, когда серверный процесс обновляет свой &lt;code&gt;pg_stat_activity&lt;/code&gt; . &lt;code&gt;status&lt;/code&gt; . arg0 - это новая строка состояния.</target>
        </trans-unit>
        <trans-unit id="453f8db7eb85902c8d7efba2100824b715baeb8d" translate="yes" xml:space="preserve">
          <source>Probe that fires at the start of a new transaction. arg0 is the transaction ID.</source>
          <target state="translated">Зонд,который срабатывает при запуске новой транзакции.Аргумент0-ID транзакции.</target>
        </trans-unit>
        <trans-unit id="3a3aefacb2b30c73490e38f66077f014ccc50ebf" translate="yes" xml:space="preserve">
          <source>Probe that fires before issuing any write request for a shared buffer. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</source>
          <target state="translated">Зонд,который срабатывает перед отправкой запроса на запись в общий буфер.arg0 и arg1 содержат вилку и номера блоков страницы.arg2,arg3 и arg4 содержат OID-ы табличного пространства,БД и связи,идентифицирующие связь.</target>
        </trans-unit>
        <trans-unit id="33d263a06d1f645788a7d9cc687ecf761651c94e" translate="yes" xml:space="preserve">
          <source>Probe that fires when a WAL record is inserted. arg0 is the resource manager (rmid) for the record. arg1 contains the info flags.</source>
          <target state="translated">Сигнал срабатывает,когда вставляется запись WAL.arg0-менеджер ресурсов (rmid)для записи.arg1 содержит информационные флаги.</target>
        </trans-unit>
        <trans-unit id="9f1168c24751c9cc0c2a8a2c6b3927e1a19c2275" translate="yes" xml:space="preserve">
          <source>Probe that fires when a WAL segment switch is requested.</source>
          <target state="translated">Зонд срабатывает при запросе переключателя сегмента WAL.</target>
        </trans-unit>
        <trans-unit id="8e4d476400e68096572772c60276c43e69c8a62b" translate="yes" xml:space="preserve">
          <source>Probe that fires when a block read is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is the number of bytes actually read, while arg7 is the number requested (if these are different it indicates trouble).</source>
          <target state="translated">Зонд, который срабатывает, когда чтение блока завершено. arg0 и arg1 содержат номера вилки и блока страницы. arg2, arg3 и arg4 содержат идентификаторы OID табличного пространства, базы данных и отношения, идентифицирующие отношение. arg5 - это идентификатор серверной части, создавшей временное отношение для локального буфера, или &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) для общего буфера. arg6 - это количество фактически прочитанных байтов, а arg7 - это запрошенное число (если они разные, это указывает на проблему).</target>
        </trans-unit>
        <trans-unit id="bec87f01b3c4ae7574229debd84c5fd432c77b1a" translate="yes" xml:space="preserve">
          <source>Probe that fires when a block write is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is the number of bytes actually written, while arg7 is the number requested (if these are different it indicates trouble).</source>
          <target state="translated">Зонд, который срабатывает, когда запись блока завершена. arg0 и arg1 содержат номера вилки и блока страницы. arg2, arg3 и arg4 содержат идентификаторы OID табличного пространства, базы данных и отношения, идентифицирующие отношение. arg5 - это идентификатор серверной части, создавшей временное отношение для локального буфера, или &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) для общего буфера. arg6 - это количество фактически записанных байтов, а arg7 - это запрошенное число (если они разные, это указывает на проблему).</target>
        </trans-unit>
        <trans-unit id="46f91b3dd629f638c1e5b0918321dc6a1503deb9" translate="yes" xml:space="preserve">
          <source>Probe that fires when a buffer read is complete. arg0 and arg1 contain the fork and block numbers of the page (if this is a relation extension request, arg1 now contains the block number of the newly added block). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read. arg7 is true if the buffer was found in the pool, false if not.</source>
          <target state="translated">Зонд, который срабатывает, когда чтение буфера завершено. arg0 и arg1 содержат номера разветвления и блока страницы (если это запрос на расширение отношения, arg1 теперь содержит номер блока вновь добавленного блока). arg2, arg3 и arg4 содержат идентификаторы OID табличного пространства, базы данных и отношения, идентифицирующие отношение. arg5 - это идентификатор серверной части, создавшей временное отношение для локального буфера, или &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) для общего буфера. arg6 истинно для запроса расширения отношения, ложно для обычного чтения. arg7 имеет значение true, если буфер был найден в пуле, и false в противном случае.</target>
        </trans-unit>
        <trans-unit id="58ba85ae8dc3ff12abd986e1bbe24ce88cd6ffee" translate="yes" xml:space="preserve">
          <source>Probe that fires when a buffer read is started. arg0 and arg1 contain the fork and block numbers of the page (but arg1 will be -1 if this is a relation extension request). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read.</source>
          <target state="translated">Зонд, срабатывающий при запуске чтения буфера. arg0 и arg1 содержат номера вилки и блока страницы (но arg1 будет -1, если это запрос на расширение отношения). arg2, arg3 и arg4 содержат идентификаторы OID табличного пространства, базы данных и отношения, идентифицирующие отношение. arg5 - это идентификатор серверной части, создавшей временную связь для локального буфера, или &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) для общего буфера. arg6 истинно для запроса расширения отношения, ложно для обычного чтения.</target>
        </trans-unit>
        <trans-unit id="0fbe84f59555154d75e50194b6717675ebf83d0f" translate="yes" xml:space="preserve">
          <source>Probe that fires when a checkpoint is complete. (The probes listed next fire in sequence during checkpoint processing.) arg0 is the number of buffers written. arg1 is the total number of buffers. arg2, arg3 and arg4 contain the number of WAL files added, removed and recycled respectively.</source>
          <target state="translated">Зонд стреляет,когда контрольно-пропускной пункт закончен.(Зонды,перечисленные следующим по порядку пожаром при обработке контрольной точки.)arg0-количество записанных буферов.arg1-общее количество буферов.arg2,arg3 и arg4 содержат количество файлов WAL,добавленных,удаленных и переработанных соответственно.</target>
        </trans-unit>
        <trans-unit id="23fe54bf3cce9571085cc7cf6504d3feaa949415" translate="yes" xml:space="preserve">
          <source>Probe that fires when a checkpoint is started. arg0 holds the bitwise flags used to distinguish different checkpoint types, such as shutdown, immediate or force.</source>
          <target state="translated">arg0 содержит битовые флаги,используемые для различения различных типов контрольно-пропускных пунктов,таких как выключение,немедленное или принудительное выключение.</target>
        </trans-unit>
        <trans-unit id="93bbd1ca880ff804d869958124aceb46cced58c3" translate="yes" xml:space="preserve">
          <source>Probe that fires when a deadlock is found by the deadlock detector.</source>
          <target state="translated">Зонд горит при обнаружении тупика детектором.</target>
        </trans-unit>
        <trans-unit id="cd2095b8769349eb00b3e4c4c59eb7c9f09aa65d" translate="yes" xml:space="preserve">
          <source>Probe that fires when a dirty WAL buffer write is complete.</source>
          <target state="translated">Звук срабатывает,когда запись в грязный буфер WAL завершена.</target>
        </trans-unit>
        <trans-unit id="e06e64448ac61e5f30e9d0aae09a59b087a40467" translate="yes" xml:space="preserve">
          <source>Probe that fires when a dirty-buffer write is complete. The arguments are the same as for &lt;code&gt;buffer-write-dirty-start&lt;/code&gt;.</source>
          <target state="translated">Зонд, который срабатывает после завершения записи грязного буфера. Аргументы такие же, как для &lt;code&gt;buffer-write-dirty-start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc7ff5d60d95edecd39d25ce953e04898f2adf03" translate="yes" xml:space="preserve">
          <source>Probe that fires when a request for a heavyweight lock (lmgr lock) has begun to wait because the lock is not available. arg0 through arg3 are the tag fields identifying the object being locked. arg4 indicates the type of object being locked. arg5 indicates the lock type being requested.</source>
          <target state="translated">Звук срабатывает,когда запрос на блокировку в тяжелом весе (блокировка lmgr)начинает ждать,потому что блокировка недоступна.arg0-arg3-это поля меток,идентифицирующие блокируемый объект.arg4-это тип блокируемого объекта.arg5-это тип блокируемого объекта,запрашиваемого.</target>
        </trans-unit>
        <trans-unit id="4162528ebd10f947261c421936db3a10071c6bda" translate="yes" xml:space="preserve">
          <source>Probe that fires when a request for a heavyweight lock (lmgr lock) has finished waiting (i.e., has acquired the lock). The arguments are the same as for &lt;code&gt;lock-wait-start&lt;/code&gt;.</source>
          <target state="translated">Зонд, который срабатывает, когда запрос на тяжелую блокировку (блокировка lmgr) завершил ожидание (т. Е. Получил блокировку). Аргументы те же, что и для &lt;code&gt;lock-wait-start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c611257e152cea80f6cfc845709b8d0de904351c" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process begins to write a dirty WAL buffer because no more WAL buffer space is available. (If this happens often, it implies that &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; is too small.)</source>
          <target state="translated">Зонд, который срабатывает, когда серверный процесс начинает записывать грязный буфер WAL из-за отсутствия доступного пространства буфера WAL. (Если это происходит часто, это означает, что &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; слишком мал.)</target>
        </trans-unit>
        <trans-unit id="f78264e8172fbf9d18964b5de63c4b5c50a37b93" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process begins to write a dirty buffer. (If this happens often, it implies that &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; is too small or the background writer control parameters need adjustment.) arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</source>
          <target state="translated">Зонд, который срабатывает, когда серверный процесс начинает записывать грязный буфер. (Если это происходит часто, это означает, что &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; слишком мал или параметры управления фоновой записи нуждаются в настройке.) Arg0 и arg1 содержат номера вилки и блока страницы. arg2, arg3 и arg4 содержат идентификаторы OID табличного пространства, базы данных и отношения, идентифицирующие отношение.</target>
        </trans-unit>
        <trans-unit id="ab6028b90f757cbb259294d12f57f8c712860524" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process has been released from its wait for an LWLock (it does not actually have the lock yet). arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">Возможно,это происходит,когда серверный процесс освобождается от ожидания LWLock (на самом деле он еще не имеет блокировки).arg0-это транш LWLock.arg1-это режим запрошенной блокировки,либо эксклюзивный,либо общий.</target>
        </trans-unit>
        <trans-unit id="327d56ed2b9d3f4cc36bd9b948fbb4da61129ae8" translate="yes" xml:space="preserve">
          <source>Probe that fires when a sort is complete. arg0 is true for external sort, false for internal sort. arg1 is the number of disk blocks used for an external sort, or kilobytes of memory used for an internal sort.</source>
          <target state="translated">Возможно,это срабатывает,когда сортировка завершена.arg0 верен для внешней сортировки,false-для внутренней.arg1-это количество дисковых блоков,используемых для внешней сортировки,или килобайт памяти,используемый для внутренней сортировки.</target>
        </trans-unit>
        <trans-unit id="4a9847b929f87d2af0af81f9222c2554ede52eda" translate="yes" xml:space="preserve">
          <source>Probe that fires when a sort operation is started. arg0 indicates heap, index or datum sort. arg1 is true for unique-value enforcement. arg2 is the number of key columns. arg3 is the number of kilobytes of work memory allowed. arg4 is true if random access to the sort result is required. arg5 indicates serial when &lt;code&gt;0&lt;/code&gt;, parallel worker when &lt;code&gt;1&lt;/code&gt;, or parallel leader when &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Зонд, который срабатывает при запуске операции сортировки. arg0 указывает на кучу, индекс или сортировку данных. arg1 истинен для принудительного применения уникального значения. arg2 - количество ключевых столбцов. arg3 - это допустимое количество килобайт рабочей памяти. arg4 истинно, если требуется произвольный доступ к результату сортировки. arg5 указывает последовательный, когда &lt;code&gt;0&lt;/code&gt; , параллельный рабочий, когда &lt;code&gt;1&lt;/code&gt; , или параллельный лидер, когда &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a6c578cf9ebf6dafcb797b30e10c8c0ea10449f" translate="yes" xml:space="preserve">
          <source>Probe that fires when a transaction completes successfully. arg0 is the transaction ID.</source>
          <target state="translated">Скорее всего,это срабатывает при успешном завершении транзакции.arg0-это идентификатор транзакции.</target>
        </trans-unit>
        <trans-unit id="4a8dcaad5632a5c029ca8a4cd70eeafe1ca847b1" translate="yes" xml:space="preserve">
          <source>Probe that fires when a transaction completes unsuccessfully. arg0 is the transaction ID.</source>
          <target state="translated">Возможно,это срабатывает,когда транзакция завершается неудачно.Аргумент0-это идентификатор транзакции.</target>
        </trans-unit>
        <trans-unit id="17050254a1180d83c2f09021018121a20c9a108c" translate="yes" xml:space="preserve">
          <source>Probe that fires when a write request is complete. (Note that this just reflects the time to pass the data to the kernel; it's typically not actually been written to disk yet.) The arguments are the same as for &lt;code&gt;buffer-flush-start&lt;/code&gt;.</source>
          <target state="translated">Зонд, который срабатывает, когда запрос на запись завершен. (Обратите внимание, что это просто отражает время, необходимое для передачи данных в ядро; обычно они еще не были записаны на диск.) Аргументы такие же, как для &lt;code&gt;buffer-flush-start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e023e6af3bb6f75b33af22efff6aa6afa3fd941" translate="yes" xml:space="preserve">
          <source>Probe that fires when all dirty buffers have been written. arg0 is the total number of buffers. arg1 is the number of buffers actually written by the checkpoint process. arg2 is the number that were expected to be written (arg1 of &lt;code&gt;buffer-sync-start&lt;/code&gt;); any difference reflects other processes flushing buffers during the checkpoint.</source>
          <target state="translated">Зонд, который срабатывает, когда записаны все грязные буферы. arg0 - общее количество буферов. arg1 - количество буферов, фактически записанных процессом контрольной точки. arg2 - это число, которое должно было быть записано (arg1 of &lt;code&gt;buffer-sync-start&lt;/code&gt; ); любая разница отражает другие процессы, очищающие буферы во время контрольной точки.</target>
        </trans-unit>
        <trans-unit id="466cfd0176351b56d635f32f0410727040245d40" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock has been acquired. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">Арго0-это транш LWLock.Арго1-это запрашиваемый режим блокировки,либо эксклюзивный,либо общий.</target>
        </trans-unit>
        <trans-unit id="6121be81d01b11fd11854f3cc9d63c7a9a5f1cbf" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock has been released (but note that any released waiters have not yet been awakened). arg0 is the LWLock's tranche.</source>
          <target state="translated">Заметим,что стреляет,когда LWLock был освобожден (но обратите внимание,что все освобожденные официанты еще не были разбужены).arg0-это транш LWLock.</target>
        </trans-unit>
        <trans-unit id="eee4a231a6a278d84a4bf21d96cfbf0b033695e4" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was not immediately available and a server process has begun to wait for the lock to become available. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">Возможно,это происходит,когда LWLock не был сразу доступен и серверный процесс начал ждать,пока блокировка станет доступной.arg0-это транш LWLock.arg1-это запрашиваемый режим блокировки,либо эксклюзивный,либо совместно используемый.</target>
        </trans-unit>
        <trans-unit id="32b5dee951d8d8bbcc4c527b18fd9921e80f05ea" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was not successfully acquired when the caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">Арго0-это транш LWLock.Арго1-это запрашиваемый режим блокировки,либо эксклюзивный,либо общий.</target>
        </trans-unit>
        <trans-unit id="29ccd443bca3bd38a197795375408911c2de33c3" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was successfully acquired when the caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">Арго0-это транш LWLock.Арго1-это запрашиваемый режим блокировки,либо эксклюзивный,либо общий.</target>
        </trans-unit>
        <trans-unit id="9fe33e9001aca2852cd9dca52b36bdbecb7c1f32" translate="yes" xml:space="preserve">
          <source>Probe that fires when beginning to read a block from a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer.</source>
          <target state="translated">Зонд, который срабатывает, когда начинает читать блок из отношения. arg0 и arg1 содержат номера вилки и блока страницы. arg2, arg3 и arg4 содержат идентификаторы OID табличного пространства, базы данных и отношения, идентифицирующие отношение. arg5 - это идентификатор серверной части, создавшей временную связь для локального буфера, или &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) для общего буфера.</target>
        </trans-unit>
        <trans-unit id="d3f7e8aeab722a5eb71c03e5e72e466f6f7d683f" translate="yes" xml:space="preserve">
          <source>Probe that fires when beginning to write a block to a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer.</source>
          <target state="translated">Зонд, срабатывающий при начале записи блока в отношение. arg0 и arg1 содержат номера вилки и блока страницы. arg2, arg3 и arg4 содержат идентификаторы OID табличного пространства, базы данных и отношения, идентифицирующие отношение. arg5 - это идентификатор серверной части, создавшей временную связь для локального буфера, или &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) для общего буфера.</target>
        </trans-unit>
        <trans-unit id="9cef86798a06a87b1e53005af8b7cffd9544c2ff" translate="yes" xml:space="preserve">
          <source>Probe that fires when syncing of buffers to disk is complete.</source>
          <target state="translated">Звук срабатывает,когда синхронизация буферов с диском завершена.</target>
        </trans-unit>
        <trans-unit id="7e4496f8bfaa3cf215e7723d1b3f6a6a44062ac3" translate="yes" xml:space="preserve">
          <source>Probe that fires when the CLOG portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;clog-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">Зонд, который срабатывает, когда завершена часть CLOG контрольной точки. arg0 имеет то же значение, что и для &lt;code&gt;clog-checkpoint-start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ce40580bfe3cc60932d40bba9c3a62201a4d419" translate="yes" xml:space="preserve">
          <source>Probe that fires when the CLOG portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">Аргумент 0 верен для обычной контрольно-пропускной точки,false-для контрольно-пропускной точки выключения.</target>
        </trans-unit>
        <trans-unit id="f127e8e58e69f04b50616b0e221c7c59b7f1f3d1" translate="yes" xml:space="preserve">
          <source>Probe that fires when the MultiXact portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;multixact-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">Зонд, который срабатывает, когда часть MultiXact контрольной точки завершена. arg0 имеет то же значение, что и для &lt;code&gt;multixact-checkpoint-start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7db7d3684151dd5b3ccf2213972ecca8de60eb5e" translate="yes" xml:space="preserve">
          <source>Probe that fires when the MultiXact portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">Сработает при запуске MultiXact части контрольно-пропускного пункта.arg0 верно для обычной контрольно-пропускной точки,false для контрольно-пропускного пункта выключения.</target>
        </trans-unit>
        <trans-unit id="19d184e6d4448ad19f4409d088d396f7df8c32d3" translate="yes" xml:space="preserve">
          <source>Probe that fires when the SUBTRANS portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;subtrans-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">Зонд, который срабатывает, когда часть SUBTRANS контрольной точки завершена. arg0 имеет то же значение, что и для &lt;code&gt;subtrans-checkpoint-start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="406309c24a9ce7d667e2ff79d8bf7268a9ff9831" translate="yes" xml:space="preserve">
          <source>Probe that fires when the SUBTRANS portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">Аргумент 0 верен для нормальной контрольно-пропускной точки,false-для контрольно-пропускной точки выключения.</target>
        </trans-unit>
        <trans-unit id="2d124d93cd049bd0371700c2959bdf0770b013e0" translate="yes" xml:space="preserve">
          <source>Probe that fires when the buffer-writing portion of a checkpoint is started. arg0 holds the bitwise flags used to distinguish different checkpoint types, such as shutdown, immediate or force.</source>
          <target state="translated">Может быть,это срабатывает,когда начинается запись в буфер.arg0 содержит битовые флаги,используемые для различения различных типов контрольно-пропускных пунктов,таких как выключение,немедленное или принудительное выключение.</target>
        </trans-unit>
        <trans-unit id="931b1ed777e93c094dcd52151780b666556374f1" translate="yes" xml:space="preserve">
          <source>Probe that fires when the execution of a query is complete.</source>
          <target state="translated">Зонд срабатывает,когда выполнение запроса завершено.</target>
        </trans-unit>
        <trans-unit id="6643c1646d73651ecf6358eff359f77c5055c16d" translate="yes" xml:space="preserve">
          <source>Probe that fires when the execution of a query is started.</source>
          <target state="translated">Звук срабатывает,когда начинается выполнение запроса.</target>
        </trans-unit>
        <trans-unit id="0944a082320c7bc732281e77e7ca49f36f32c834" translate="yes" xml:space="preserve">
          <source>Probe that fires when the parsing of a query is complete. arg0 is the query string.</source>
          <target state="translated">Звонок срабатывает после завершения разбора запроса.arg0-это строка запроса.</target>
        </trans-unit>
        <trans-unit id="d96fa9e5daed0c63d0c0481d8ca8ebbe0a261583" translate="yes" xml:space="preserve">
          <source>Probe that fires when the parsing of a query is started. arg0 is the query string.</source>
          <target state="translated">Звонок срабатывает,когда начинается разбор запроса.arg0-строка запроса.</target>
        </trans-unit>
        <trans-unit id="9452ef2f9dd8e46c1c62afe77724fc190b423661" translate="yes" xml:space="preserve">
          <source>Probe that fires when the planning of a query is complete.</source>
          <target state="translated">Зонд срабатывает,когда планирование запроса завершено.</target>
        </trans-unit>
        <trans-unit id="a1d4370c7121e9a518ec9800f508633ae2640459" translate="yes" xml:space="preserve">
          <source>Probe that fires when the planning of a query is started.</source>
          <target state="translated">Звук срабатывает,когда начинается планирование запроса.</target>
        </trans-unit>
        <trans-unit id="96a4a695589b1af8e96af229876a85b1ac6a6721" translate="yes" xml:space="preserve">
          <source>Probe that fires when the processing of a query is complete. arg0 is the query string.</source>
          <target state="translated">Звонок срабатывает,когда обработка запроса завершена.arg0-это строка запроса.</target>
        </trans-unit>
        <trans-unit id="17d08bdfb5f9889597cd8fad97751d8760642495" translate="yes" xml:space="preserve">
          <source>Probe that fires when the processing of a query is started. arg0 is the query string.</source>
          <target state="translated">Звонок срабатывает,когда начинается обработка запроса.arg0-строка запроса.</target>
        </trans-unit>
        <trans-unit id="eab217356aa735f20b49ab127f241495b6ade066" translate="yes" xml:space="preserve">
          <source>Probe that fires when the rewriting of a query is complete. arg0 is the query string.</source>
          <target state="translated">Звонок срабатывает,когда перезаписывание запроса завершено.arg0-строка запроса.</target>
        </trans-unit>
        <trans-unit id="a428364242cf9691158e2fd27eee09f0cdf33ee9" translate="yes" xml:space="preserve">
          <source>Probe that fires when the rewriting of a query is started. arg0 is the query string.</source>
          <target state="translated">Звонок срабатывает,когда начинается перезапись запроса.arg0-это строка запроса.</target>
        </trans-unit>
        <trans-unit id="21185778a7abdae335897b758940d7f751d2a6f0" translate="yes" xml:space="preserve">
          <source>Probe that fires when the two-phase portion of a checkpoint is complete.</source>
          <target state="translated">Зонд стреляет,когда двухфазная часть контрольно-пропускного пункта завершена.</target>
        </trans-unit>
        <trans-unit id="0b37c215587e2b196fc6e3605c0952c5abaaeaa4" translate="yes" xml:space="preserve">
          <source>Probe that fires when the two-phase portion of a checkpoint is started.</source>
          <target state="translated">Зонд стреляет при запуске двухфазной части контрольно-пропускного пункта.</target>
        </trans-unit>
        <trans-unit id="64dbe1e4375ac3d8c100dcc3b4624e32ba635dcb" translate="yes" xml:space="preserve">
          <source>Probe that fires when we begin to write dirty buffers during checkpoint (after identifying which buffers must be written). arg0 is the total number of buffers. arg1 is the number that are currently dirty and need to be written.</source>
          <target state="translated">Стреляет,когда мы начинаем записывать грязные буферы во время контрольной точки (после определения,какие буферы должны быть записаны).arg0-это общее количество буферов.arg1-это число,которое в данный момент является грязным и которое необходимо записать.</target>
        </trans-unit>
        <trans-unit id="0e17699a3879dd39ab092b19091e781ba0c3179a" translate="yes" xml:space="preserve">
          <source>Procedural Languages (server-side)</source>
          <target state="translated">Процедурные языки (серверная сторона)</target>
        </trans-unit>
        <trans-unit id="d23b357b75ad2622370788956db89d9cceb43ba0" translate="yes" xml:space="preserve">
          <source>Procedural languages are local to individual databases. However, a language can be installed into the &lt;code&gt;template1&lt;/code&gt; database, which will cause it to be available automatically in all subsequently-created databases.</source>
          <target state="translated">Процедурные языки являются локальными для отдельных баз данных. Однако язык можно установить в базу данных &lt;code&gt;template1&lt;/code&gt; , что приведет к тому, что он будет автоматически доступен во всех создаваемых впоследствии базах данных.</target>
        </trans-unit>
        <trans-unit id="dc9339747734b918985c0542808ea173cf36ca7c" translate="yes" xml:space="preserve">
          <source>Procedure (routine)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c80cc4229f5a9d3da6a7c3b6c8547ced65049640" translate="yes" xml:space="preserve">
          <source>Process ID</source>
          <target state="translated">идентификатор процесса</target>
        </trans-unit>
        <trans-unit id="be2c2eb824ea5b51d9b5bce07c9b40cd34577acf" translate="yes" xml:space="preserve">
          <source>Process ID of a WAL sender process</source>
          <target state="translated">Идентификатор процесса отправителя WAL</target>
        </trans-unit>
        <trans-unit id="41767044d1edbdb5cf9f2dae1fdd49d59e940ebf" translate="yes" xml:space="preserve">
          <source>Process ID of a WAL sender process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af10df8d6082fa39f1e4f58ff138720439c3d068" translate="yes" xml:space="preserve">
          <source>Process ID of a backend</source>
          <target state="translated">Идентификатор процесса бэкэнда</target>
        </trans-unit>
        <trans-unit id="373864156198cbd9c04a34d7ab3e6735c02719d2" translate="yes" xml:space="preserve">
          <source>Process ID of a backend or WAL sender process</source>
          <target state="translated">Идентификатор процесса отправителя бэкэнда или WAL</target>
        </trans-unit>
        <trans-unit id="c5da887d9f68351aff22198bf3916a2bd05dd9d7" translate="yes" xml:space="preserve">
          <source>Process ID of backend.</source>
          <target state="translated">Идентификатор процесса бэкэнда.</target>
        </trans-unit>
        <trans-unit id="1aca36c0622a2538e27d8bf063d83ca00390c145" translate="yes" xml:space="preserve">
          <source>Process ID of the WAL receiver process</source>
          <target state="translated">Идентификатор процесса приемника WAL</target>
        </trans-unit>
        <trans-unit id="5d7d2e19d28ca6186fcc59c93b80889377f993f2" translate="yes" xml:space="preserve">
          <source>Process ID of the locker currently being waited for.</source>
          <target state="translated">Идентификатор процесса шкафчика,который в настоящее время находится в ожидании.</target>
        </trans-unit>
        <trans-unit id="f0648fb422c9ce57f595e096435bf789668b2752" translate="yes" xml:space="preserve">
          <source>Process ID of the parallel group leader, if this process is a parallel query worker. &lt;code&gt;NULL&lt;/code&gt; if this process is a parallel group leader or does not participate in parallel query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01681ffc812bd9e058f3a6c5baf1409c4f0ba3bc" translate="yes" xml:space="preserve">
          <source>Process ID of the server process attached to the current session</source>
          <target state="translated">Идентификатор процесса сервера,подключенного к текущей сессии</target>
        </trans-unit>
        <trans-unit id="af8e0118b6d9e8d86d67cf0400739aba8210dd2b" translate="yes" xml:space="preserve">
          <source>Process ID of the server process handling the current session</source>
          <target state="translated">Идентификатор процесса сервера,обрабатывающего текущую сессию</target>
        </trans-unit>
        <trans-unit id="03fbcc6f1367738e610a0cace02a8fd6438fb048" translate="yes" xml:space="preserve">
          <source>Process ID of the server process holding or awaiting this lock, or null if the lock is held by a prepared transaction</source>
          <target state="translated">Идентификатор процесса сервера,удерживающего или ожидающего этот замок,или нулевой,если замок удерживается подготовленной транзакцией</target>
        </trans-unit>
        <trans-unit id="999d9e41cb5cf7f111cc6e19904f6e291da38b6e" translate="yes" xml:space="preserve">
          <source>Process ID of the subscription worker process</source>
          <target state="translated">Идентификатор процесса подписчика</target>
        </trans-unit>
        <trans-unit id="e1f52d5447d8eaecbf7bddfce74b35d1ffb039b9" translate="yes" xml:space="preserve">
          <source>Process ID of this backend</source>
          <target state="translated">Идентификатор процесса этого бэкэнда</target>
        </trans-unit>
        <trans-unit id="d15b210cc1e134700f907b8b25d7b1043aa0ca7b" translate="yes" xml:space="preserve">
          <source>Process ID(s) that are blocking specified server process ID from acquiring a lock</source>
          <target state="translated">ID(ы)процесса,которые блокируют определенный ID процесса сервера от получения блокировки</target>
        </trans-unit>
        <trans-unit id="6f132a3ada7bb531c167b75bc5eeea4c4aebfc18" translate="yes" xml:space="preserve">
          <source>Process ID(s) that are blocking specified server process ID from acquiring a safe snapshot</source>
          <target state="translated">ID(ы)процесса,которые блокируют указанный ID процесса сервера от получения безопасного снимка</target>
        </trans-unit>
        <trans-unit id="f9b1d2668cc983dbc740512036c3c2a0339f13e5" translate="yes" xml:space="preserve">
          <source>Process IDs of locking backends (more than one if multitransaction)</source>
          <target state="translated">Идентификаторы процесса блокировки бэкэндов (более одного в случае мультитранзакции)</target>
        </trans-unit>
        <trans-unit id="f966bc3f73e4a99fa5d7b7c8751d4573456fa586" translate="yes" xml:space="preserve">
          <source>Process Identifier</source>
          <target state="translated">Идентификатор процесса</target>
        </trans-unit>
        <trans-unit id="23fe74f2755c9dfea4c7fb3bc31b2e29d2cbcd59" translate="yes" xml:space="preserve">
          <source>Process header files. When this option is specified, the output file extension becomes &lt;code&gt;.h&lt;/code&gt; not &lt;code&gt;.c&lt;/code&gt;, and the default input file extension is &lt;code&gt;.pgh&lt;/code&gt; not &lt;code&gt;.pgc&lt;/code&gt;. Also, the &lt;code&gt;-c&lt;/code&gt; option is forced on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a6aac2feb7c0acbdd36ece9c6b8ffa6edac4ab" translate="yes" xml:space="preserve">
          <source>Process of an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; which acts on behalf of a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;client session&lt;/a&gt; and handles its requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9404f1b149e0fa2944f7fe7f5a9758a8f27d7f2a" translate="yes" xml:space="preserve">
          <source>Process start time stamp</source>
          <target state="translated">Штемпель времени запуска процесса</target>
        </trans-unit>
        <trans-unit id="2fc3c183e1dc7c192411203ba9cdff758c852d48" translate="yes" xml:space="preserve">
          <source>Process within an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;, which runs system- or user-supplied code. Serves as infrastructure for several features in PostgreSQL, such as &lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;logical replication&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-PARALLEL-QUERY&quot;&gt;parallel queries&lt;/a&gt;. In addition, &lt;a href=&quot;glossary#GLOSSARY-EXTENSION&quot;&gt;Extensions&lt;/a&gt; can add custom background worker processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b87f820c5635b5c920ad2cf5059d2207d8f59e5" translate="yes" xml:space="preserve">
          <source>Produce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows. This is the default action.</source>
          <target state="translated">Появление ошибки,указывающей на то,что удаление или обновление приведет к нарушению ограничений постороннего ключа.Если ограничение отложено,то эта ошибка будет выдана во время проверки ограничения,если все еще существуют какие-либо ссылающиеся строки.Это действие является действием по умолчанию.</target>
        </trans-unit>
        <trans-unit id="19db911f45836f08f67324db7d1d1b7713f59b5d" translate="yes" xml:space="preserve">
          <source>Produce an error indicating that the deletion or update would create a foreign key constraint violation. This is the same as &lt;code&gt;NO ACTION&lt;/code&gt; except that the check is not deferrable.</source>
          <target state="translated">Выдает ошибку, указывающую, что удаление или обновление приведет к нарушению ограничения внешнего ключа. Это то же самое, что и &lt;code&gt;NO ACTION&lt;/code&gt; , за исключением того, что проверка не может быть отложена.</target>
        </trans-unit>
        <trans-unit id="595741604d266c8ba7ee063d34ab349a2aac4f77" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns, where &lt;code&gt;N&lt;/code&gt; is determined by the row type specified in the calling query</source>
          <target state="translated">Создает &amp;laquo;сводную таблицу&amp;raquo;, содержащую имена строк и &lt;code&gt;N&lt;/code&gt; столбцов значений, где &lt;code&gt;N&lt;/code&gt; определяется типом строки, указанным в вызывающем запросе.</target>
        </trans-unit>
        <trans-unit id="d19d956161f313325e8c8fa1383c1d5dc4285689" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns, where &lt;code&gt;N&lt;/code&gt; is determined by the row type specified in the calling query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7d934bad462d22e3d780a0512ef5f70c8fefe7" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns. &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt; are predefined, but you can create additional &lt;code&gt;crosstabN&lt;/code&gt; functions as described below</source>
          <target state="translated">Создает &amp;laquo;сводную таблицу&amp;raquo;, содержащую имена строк плюс &lt;code&gt;N&lt;/code&gt; столбцов значений. &lt;code&gt;crosstab2&lt;/code&gt; , &lt;code&gt;crosstab3&lt;/code&gt; и &lt;code&gt;crosstab4&lt;/code&gt; предопределены, но вы можете создать дополнительные функции &lt;code&gt;crosstabN&lt;/code&gt; как описано ниже.</target>
        </trans-unit>
        <trans-unit id="6827b61996dcfecd3a6bdd8ecd7849189131e707" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns. &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt; are predefined, but you can create additional &lt;code&gt;crosstabN&lt;/code&gt; functions as described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953361f0fb07cbbdc30a8c3d39ada8d75e41aa1b" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; with the value columns specified by a second query</source>
          <target state="translated">Создает &amp;laquo;сводную таблицу&amp;raquo; со столбцами значений, указанными во втором запросе.</target>
        </trans-unit>
        <trans-unit id="2796ff43fdf0371172e3aca0613ef5e330539f10" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; with the value columns specified by a second query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb96fffad25790b78f8b2fd976762cd22e0262e" translate="yes" xml:space="preserve">
          <source>Produces a representation of a hierarchical tree structure</source>
          <target state="translated">Производит представление иерархической древовидной структуры</target>
        </trans-unit>
        <trans-unit id="6073947dcba4d43cc98e457a1a526968941edbfc" translate="yes" xml:space="preserve">
          <source>Produces a representation of a hierarchical tree structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f50ebfc9183ee48a90532a8dbfb3653ac19c72" translate="yes" xml:space="preserve">
          <source>Produces a representation of the indexable portion of a &lt;code&gt;tsquery&lt;/code&gt;. A result that is empty or just &lt;code id=&quot;t&quot;&gt;T&lt;/code&gt; indicates a non-indexable query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cf09a7cb7a5d996def491486e555116c8e56fe" translate="yes" xml:space="preserve">
          <source>Produces a set of normally distributed random values</source>
          <target state="translated">Производит набор нормально распределенных случайных величин</target>
        </trans-unit>
        <trans-unit id="315b9480dccd3ac225db648897293892f773f54e" translate="yes" xml:space="preserve">
          <source>Produces a set of normally distributed random values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3d37859bb87e00841bf5b68801363110571121" translate="yes" xml:space="preserve">
          <source>Produces no output, but tells non-session processes to stop at this point in the string; ignored by session processes</source>
          <target state="translated">Не производит никакого вывода,но говорит несеансовым процессам остановиться в этой точке строки;игнорируется сеансовыми процессами</target>
        </trans-unit>
        <trans-unit id="c4cc122a953a1ad9e9d147019c31d589653986fa" translate="yes" xml:space="preserve">
          <source>Produces the intersection of two cubes.</source>
          <target state="translated">Производит пересечение двух кубов.</target>
        </trans-unit>
        <trans-unit id="bc2b03c140585a107e123dbad9c7907236c487ae" translate="yes" xml:space="preserve">
          <source>Produces the union of two cubes.</source>
          <target state="translated">Производит союз двух кубов.</target>
        </trans-unit>
        <trans-unit id="3a873ea551f5b656a037c9a2775158084055a3fb" translate="yes" xml:space="preserve">
          <source>Programs using C code with embedded SQL have to be linked against the &lt;code&gt;libecpg&lt;/code&gt; library, for example using the linker options &lt;code&gt;-L/usr/local/pgsql/lib -lecpg&lt;/code&gt;.</source>
          <target state="translated">Программы, использующие код C со встроенным SQL, должны быть связаны с библиотекой &lt;code&gt;libecpg&lt;/code&gt; , например, с помощью параметров компоновщика &lt;code&gt;-L/usr/local/pgsql/lib -lecpg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62babe4510e8d8a8ee8afda900ec73acd0a5dab6" translate="yes" xml:space="preserve">
          <source>Progress Reporting</source>
          <target state="translated">Отчетность о проделанной работе</target>
        </trans-unit>
        <trans-unit id="3d02226c16e2d7d25eeaba8bd347cdb833f33050" translate="yes" xml:space="preserve">
          <source>Promotes a physical standby server. With &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; set to &lt;code&gt;true&lt;/code&gt; (the default), the function waits until promotion is completed or &lt;em&gt;&lt;code&gt;wait_seconds&lt;/code&gt;&lt;/em&gt; seconds have passed, and returns &lt;code&gt;true&lt;/code&gt; if promotion is successful and &lt;code&gt;false&lt;/code&gt; otherwise. If &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; is set to &lt;code&gt;false&lt;/code&gt;, the function returns &lt;code&gt;true&lt;/code&gt; immediately after sending &lt;code&gt;SIGUSR1&lt;/code&gt; to the postmaster to trigger the promotion. This function is restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">Повышает физический резервный сервер. Если для параметра &lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt; установлено значение &lt;code&gt;true&lt;/code&gt; (по умолчанию), функция ждет, пока продвижение не завершится или &lt;em&gt; &lt;code&gt;wait_seconds&lt;/code&gt; &lt;/em&gt; секунды &lt;em&gt;wait_seconds&lt;/em&gt; , и возвращает &lt;code&gt;true&lt;/code&gt; , если продвижение прошло успешно, и &lt;code&gt;false&lt;/code&gt; в противном случае. Если для параметра &lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt; установлено значение &lt;code&gt;false&lt;/code&gt; , функция возвращает значение &lt;code&gt;true&lt;/code&gt; сразу после отправки &lt;code&gt;SIGUSR1&lt;/code&gt; постмастеру, чтобы запустить продвижение. Эта функция по умолчанию доступна только суперпользователям, но другим пользователям может быть предоставлен EXECUTE для запуска функции.</target>
        </trans-unit>
        <trans-unit id="377afe4fc3a70d640cc41e476917292a950a7519" translate="yes" xml:space="preserve">
          <source>Promotes a standby server to primary status. With &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; set to &lt;code&gt;true&lt;/code&gt; (the default), the function waits until promotion is completed or &lt;em&gt;&lt;code&gt;wait_seconds&lt;/code&gt;&lt;/em&gt; seconds have passed, and returns &lt;code&gt;true&lt;/code&gt; if promotion is successful and &lt;code&gt;false&lt;/code&gt; otherwise. If &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; is set to &lt;code&gt;false&lt;/code&gt;, the function returns &lt;code&gt;true&lt;/code&gt; immediately after sending a &lt;code&gt;SIGUSR1&lt;/code&gt; signal to the postmaster to trigger promotion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310745705e4b51911f7ad05e685132e85803b43c" translate="yes" xml:space="preserve">
          <source>Prompt for confirmation before actually removing the user, and prompt for the user name if none is specified on the command line.</source>
          <target state="translated">Запрос на подтверждение перед фактическим удалением пользователя и запрос имени пользователя,если оно не указано в командной строке.</target>
        </trans-unit>
        <trans-unit id="a4139dbdd33b4ca75eb092bf7d5f911f9e520f3e" translate="yes" xml:space="preserve">
          <source>Prompt for the user name if none is specified on the command line, and also prompt for whichever of the options &lt;code&gt;-d&lt;/code&gt;/&lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;/&lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;/&lt;code&gt;-S&lt;/code&gt; is not specified on the command line. (This was the default behavior up to PostgreSQL 9.1.)</source>
          <target state="translated">Запрашивать имя пользователя, если оно не указано в командной строке, а также запрашивать, какой из параметров &lt;code&gt;-d&lt;/code&gt; / &lt;code&gt;-D&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; / &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; / &lt;code&gt;-S&lt;/code&gt; не указан в командной строке. (Это было поведение по умолчанию до PostgreSQL 9.1.)</target>
        </trans-unit>
        <trans-unit id="4d970e24b22fc0f6e277e6e1b9c10241b2293ff1" translate="yes" xml:space="preserve">
          <source>Prompting</source>
          <target state="translated">Prompting</target>
        </trans-unit>
        <trans-unit id="7b9401a5b590107a8b6c6f9423644051eff19629" translate="yes" xml:space="preserve">
          <source>Prompts can contain terminal control characters which, for example, change the color, background, or style of the prompt text, or change the title of the terminal window. In order for the line editing features of Readline to work properly, these non-printing control characters must be designated as invisible by surrounding them with &lt;code&gt;%[&lt;/code&gt; and &lt;code&gt;%]&lt;/code&gt;. Multiple pairs of these can occur within the prompt. For example:</source>
          <target state="translated">Подсказки могут содержать управляющие символы терминала, которые, например, изменяют цвет, фон или стиль текста подсказки или меняют заголовок окна терминала. Для правильной работы функций редактирования строк в Readline, эти непечатаемые управляющие символы должны быть обозначены как невидимые, заключив их в &lt;code&gt;%[&lt;/code&gt; и &lt;code&gt;%]&lt;/code&gt; . В приглашении может появиться несколько таких пар. Например:</target>
        </trans-unit>
        <trans-unit id="068e4f6fa6576b1f7eb180c4d966c9c332e88e9a" translate="yes" xml:space="preserve">
          <source>Prompts the user to supply text, which is assigned to the variable &lt;code&gt;name&lt;/code&gt;. An optional prompt string, &lt;code&gt;text&lt;/code&gt;, can be specified. (For multiword prompts, surround the text with single quotes.)</source>
          <target state="translated">Предлагающий пользователь текст предложения, который присваивается переменным &lt;code&gt;name&lt;/code&gt; . Можно указать необязательную строку приглашения, &lt;code&gt;text&lt;/code&gt; . (Для подсказок, состоящих из нескольких слов, заключите текст в одинарные кавычки.)</target>
        </trans-unit>
        <trans-unit id="25a719c409be1921beafe5e788d439d93b07f5ff" translate="yes" xml:space="preserve">
          <source>Protocol head</source>
          <target state="translated">протокольный глава</target>
        </trans-unit>
        <trans-unit id="1a9320a6ee345a64538cc41c73838b336f61862b" translate="yes" xml:space="preserve">
          <source>Protocol to use for submitting queries to the server:</source>
          <target state="translated">Протокол,используемый для отправки запросов на сервер:</target>
        </trans-unit>
        <trans-unit id="c1ac8c14d0bafdecefeefa05418d3e4bf8d46ea4" translate="yes" xml:space="preserve">
          <source>Provide an extension that will be stripped from all file names before deciding if they should be deleted. This is typically useful for cleaning up archives that have been compressed during storage, and therefore have had an extension added by the compression program. For example: &lt;code&gt;-x .gz&lt;/code&gt;.</source>
          <target state="translated">Укажите расширение, которое будет удалено из всех имен файлов, прежде чем решать, следует ли их удалить. Обычно это полезно для очистки архивов, которые были сжаты во время хранения и, следовательно, были добавлены расширением программой сжатия. Например: &lt;code&gt;-x .gz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c7f8ac0c8dc8b2a3526acf0eb6df53ded419c3" translate="yes" xml:space="preserve">
          <source>Provide information about extensions of client certificate: extension name, extension value, and if it is a critical extension.</source>
          <target state="translated">Предоставьте информацию о расширениях клиентского сертификата:имя расширения,значение расширения,и если это критическое расширение.</target>
        </trans-unit>
        <trans-unit id="7bc2350bc3b2039d9e0afed6b3606b6e8d63eb56" translate="yes" xml:space="preserve">
          <source>Provide the correct path to the database directory with &lt;code&gt;-D&lt;/code&gt;, or make sure that the environment variable &lt;code&gt;PGDATA&lt;/code&gt; is set. Also specify the name of the particular database you want to work in.</source>
          <target state="translated">Укажите правильный путь к каталогу базы данных с помощью &lt;code&gt;-D&lt;/code&gt; или убедитесь, что установлена ​​переменная среды &lt;code&gt;PGDATA&lt;/code&gt; . Также укажите имя конкретной базы данных, с которой вы хотите работать.</target>
        </trans-unit>
        <trans-unit id="7fba2085619c6e697d55f8299ef0ca805ea435a8" translate="yes" xml:space="preserve">
          <source>Provider of the collation: &lt;code&gt;d&lt;/code&gt; = database default, &lt;code&gt;c&lt;/code&gt; = libc, &lt;code&gt;i&lt;/code&gt; = icu</source>
          <target state="translated">Поставщик сопоставления: &lt;code&gt;d&lt;/code&gt; = база данных по умолчанию, &lt;code&gt;c&lt;/code&gt; = libc, &lt;code&gt;i&lt;/code&gt; = icu</target>
        </trans-unit>
        <trans-unit id="b0a624c98e3417bfbf37f095267adcc37f1bdf46" translate="yes" xml:space="preserve">
          <source>Provider-specific version of the collation. This is recorded when the collation is created and then checked when it is used, to detect changes in the collation definition that could lead to data corruption.</source>
          <target state="translated">Специфическая для провайдера версия сверки.Это записывается при создании сопоставления,а затем проверяется при его использовании,чтобы выявить изменения в определении сопоставления,которые могут привести к повреждению данных.</target>
        </trans-unit>
        <trans-unit id="813380993db87b7b78063d3b522dabe042e0e038" translate="yes" xml:space="preserve">
          <source>Provides information implicitly requested by the user, e.g., output from &lt;code&gt;VACUUM VERBOSE&lt;/code&gt;.</source>
          <target state="translated">Предоставляет информацию, неявно запрошенную пользователем, например, вывод из &lt;code&gt;VACUUM VERBOSE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de28296ee358cb5c7a7c1493346ff358cf83bc56" translate="yes" xml:space="preserve">
          <source>Provides information that might be helpful to users, e.g., notice of truncation of long identifiers.</source>
          <target state="translated">Предоставляет информацию,которая может быть полезна пользователям,например,уведомление об усечении длинных идентификаторов.</target>
        </trans-unit>
        <trans-unit id="b544ef7e317c450388c8e22bbca337ffb169c783" translate="yes" xml:space="preserve">
          <source>Provides successively-more-detailed information for use by developers.</source>
          <target state="translated">Предоставляет последовательно более подробную информацию для использования разработчиками.</target>
        </trans-unit>
        <trans-unit id="4085a3488b9b927970106c990aa79f6421cbdb9c" translate="yes" xml:space="preserve">
          <source>Provides warnings of likely problems, e.g., &lt;code&gt;COMMIT&lt;/code&gt; outside a transaction block.</source>
          <target state="translated">Предоставляет предупреждения о вероятных проблемах, например, &lt;code&gt;COMMIT&lt;/code&gt; вне блока транзакции.</target>
        </trans-unit>
        <trans-unit id="ff659eeee4de0858f88b33fd3f4e7746d59a5ad2" translate="yes" xml:space="preserve">
          <source>Pseudo-Types</source>
          <target state="translated">Pseudo-Types</target>
        </trans-unit>
        <trans-unit id="4ece916bc1c6f84ddff998832df4ef0ea2024f0a" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: any</source>
          <target state="translated">Псевдо-типы:любой</target>
        </trans-unit>
        <trans-unit id="b47d9ee644ffb538aa98ee437eec99c988a8d15d" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyarray</source>
          <target state="translated">Псевдо-типы:anyarray</target>
        </trans-unit>
        <trans-unit id="54a7e454a263cbffc9189e0007bfd9b7424c0230" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1fcd8d0a37fb97a6ae1915b033c556308cf2f68" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatiblearray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e05bbac8a7e912d1c04921f6f4547ac37465d26" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatiblenonarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934be7c6aaed34ba9e8da8c91bad2e35901f6935" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatiblerange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e5a6f841dae2418964bcaa84aa6a0a7f245549" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyelement</source>
          <target state="translated">Псевдо-типы:любой элемент</target>
        </trans-unit>
        <trans-unit id="7a3f6d920428a6c8e5967a26fb4e46758728f6a5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyenum</source>
          <target state="translated">Псевдо-типы:anyenum</target>
        </trans-unit>
        <trans-unit id="84a873dc734548a1fe95e38fb333bb6d8bee10ef" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anynonarray</source>
          <target state="translated">Псевдо-типы:любой неонаррей</target>
        </trans-unit>
        <trans-unit id="3f53e360e11fbb973d5b222308c28fd5706c50dd" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyrange</source>
          <target state="translated">Псевдо-типы:любой диапазон</target>
        </trans-unit>
        <trans-unit id="df7657db40732623a8894c06b0028cc7640273e5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: cstring</source>
          <target state="translated">Псевдо-типы:струна</target>
        </trans-unit>
        <trans-unit id="facd216b2d58500521e9c80e073f3f02e67f467b" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: event_trigger</source>
          <target state="translated">Псевдо-типы:event_trigger</target>
        </trans-unit>
        <trans-unit id="0c5c3ab69652fb55ae765ca8240e7c3bf40db9ce" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: fdw_handler</source>
          <target state="translated">Псевдо-типы:fdw_handler</target>
        </trans-unit>
        <trans-unit id="8d96c1feed021f0bd14872d446a70c55ec2a02e1" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: index_am_handler</source>
          <target state="translated">Псевдо-типы:index_am_handler</target>
        </trans-unit>
        <trans-unit id="8be67788a823313be97039f4a4b82ee6108f4b0f" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: internal</source>
          <target state="translated">Псевдотипы:внутренние</target>
        </trans-unit>
        <trans-unit id="c054109c5cb702aee10dbb32b0def25f56488525" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: language_handler</source>
          <target state="translated">Псевдотипы:language_handler</target>
        </trans-unit>
        <trans-unit id="20a35bc47475d7650010ce766369afc8aabfb683" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: opaque</source>
          <target state="translated">Псевдотипы:непрозрачный</target>
        </trans-unit>
        <trans-unit id="3674c8f90a9e09b98f639dae572ceb4253fed389" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: pg_ddl_command</source>
          <target state="translated">Псевдо-типы:pg_ddl_command</target>
        </trans-unit>
        <trans-unit id="c0325a47d21e05370cdf2a42ac118a73e10a48da" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: record</source>
          <target state="translated">Псевдо-типы:запись</target>
        </trans-unit>
        <trans-unit id="5724b565e2f347bb8125e3c1275c349af6b7742b" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: table_am_handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51593e94e15db79bb52c20320be4240d42cc899" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: trigger</source>
          <target state="translated">Псевдо-типы:триггер</target>
        </trans-unit>
        <trans-unit id="4e60d0c02309d5445a01602a98db4ff91365738e" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: tsm_handler</source>
          <target state="translated">Псевдо-типы:tsm_handler</target>
        </trans-unit>
        <trans-unit id="17a7daa819e8dc7b6c6317f25efa7b50fffc1bab" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: unknown</source>
          <target state="translated">Псевдотипы:неизвестно</target>
        </trans-unit>
        <trans-unit id="ad3dfebd9fb48eb5727ce6fe6f50844a86efc6a5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: void</source>
          <target state="translated">Псевдотипы:пустота</target>
        </trans-unit>
        <trans-unit id="6c4dc2e4c074e37178229f858d4eb2dfaf30038f" translate="yes" xml:space="preserve">
          <source>Pseudo-types</source>
          <target state="translated">Pseudo-types</target>
        </trans-unit>
        <trans-unit id="cfb71764f58cd5ce25681b038025973a34e3322a" translate="yes" xml:space="preserve">
          <source>Pseudocode for a suitable &lt;code&gt;restore_command&lt;/code&gt; is:</source>
          <target state="translated">Псевдокод для подходящей команды &lt;code&gt;restore_command&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="88d402501992d3fecf47cb438f8e35c65835d25d" translate="yes" xml:space="preserve">
          <source>PuTTY</source>
          <target state="translated">PuTTY</target>
        </trans-unit>
        <trans-unit id="e00441c49bf6cb62a4a537860a47c6b85de694f6" translate="yes" xml:space="preserve">
          <source>Publication</source>
          <target state="translated">Publication</target>
        </trans-unit>
        <trans-unit id="1c3179d96f0fdc556230a1396cdf463d5208ef82" translate="yes" xml:space="preserve">
          <source>Publications are different from schemas and do not affect how the table is accessed. Each table can be added to multiple publications if needed. Publications may currently only contain tables. Objects must be added explicitly, except when a publication is created for &lt;code&gt;ALL TABLES&lt;/code&gt;.</source>
          <target state="translated">Публикации отличаются от схем и не влияют на доступ к таблице. При необходимости каждую таблицу можно добавить в несколько публикаций. В настоящее время публикации могут содержать только таблицы. Объекты необходимо добавлять явно, за исключением случаев, когда публикация создается для &lt;code&gt;ALL TABLES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58589c3756a9812c4f0f3e4873d1e342581ef4c0" translate="yes" xml:space="preserve">
          <source>Publications can choose to limit the changes they produce to any combination of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;TRUNCATE&lt;/code&gt;, similar to how triggers are fired by particular event types. By default, all operation types are replicated.</source>
          <target state="translated">Публикации могут ограничить вносимые ими изменения любой комбинацией &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; и &lt;code&gt;TRUNCATE&lt;/code&gt; , аналогично тому, как триггеры запускаются при определенных типах событий. По умолчанию реплицируются все типы операций.</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="18900d3584ded79ec60330adb7d33689eb4bab06" translate="yes" xml:space="preserve">
          <source>Put all query output into file &lt;code&gt;filename&lt;/code&gt;. This is equivalent to the command &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">Поместите весь вывод запроса в файл &lt;code&gt;filename&lt;/code&gt; . Это эквивалентно команде &lt;code&gt;\o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="877e59f50b56dd32ce7ae2762957d53396b6d9d9" translate="yes" xml:space="preserve">
          <source>Qualified joins</source>
          <target state="translated">Квалифицированные соединения</target>
        </trans-unit>
        <trans-unit id="3eb467853e78723a75783ad177cb3b81ed614c2e" translate="yes" xml:space="preserve">
          <source>Qualified names are tedious to write, and it's often best not to wire a particular schema name into applications anyway. Therefore tables are often referred to by &lt;em&gt;unqualified names&lt;/em&gt;, which consist of just the table name. The system determines which table is meant by following a &lt;em&gt;search path&lt;/em&gt;, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database.</source>
          <target state="translated">Полные имена писать утомительно, и часто лучше не привязывать конкретное имя схемы к приложениям. Поэтому таблицы часто обозначаются &lt;em&gt;неполными именами&lt;/em&gt; , которые состоят только из имени таблицы. Система определяет, какая таблица имеется в виду, следуя &lt;em&gt;пути поиска&lt;/em&gt; , который представляет собой список схем для поиска. Первая соответствующая таблица в пути поиска выбирается как требуемая. Если в пути поиска нет совпадений, выдается сообщение об ошибке, даже если совпадающие имена таблиц существуют в других схемах в базе данных.</target>
        </trans-unit>
        <trans-unit id="29bac22a5e177f5c85c1a4ee3241bc0678be6667" translate="yes" xml:space="preserve">
          <source>Quantifier</source>
          <target state="translated">Quantifier</target>
        </trans-unit>
        <trans-unit id="5370954c958801abba850882cd6534802d171dbc" translate="yes" xml:space="preserve">
          <source>Quantities of days, hours, minutes, and seconds can be specified without explicit unit markings. For example, &lt;code&gt;'1 12:59:10'&lt;/code&gt; is read the same as &lt;code&gt;'1 day 12 hours 59 min 10 sec'&lt;/code&gt;. Also, a combination of years and months can be specified with a dash; for example &lt;code&gt;'200-10'&lt;/code&gt; is read the same as &lt;code&gt;'200 years 10 months'&lt;/code&gt;. (These shorter forms are in fact the only ones allowed by the SQL standard, and are used for output when &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt;.)</source>
          <target state="translated">Количество дней, часов, минут и секунд можно указывать без явной разметки единиц измерения. Например, &lt;code&gt;'1 12:59:10'&lt;/code&gt; читается так же, как &lt;code&gt;'1 day 12 hours 59 min 10 sec'&lt;/code&gt; . Также через тире можно указать сочетание лет и месяцев; например, &lt;code&gt;'200-10'&lt;/code&gt; читается так же, как &lt;code&gt;'200 years 10 months'&lt;/code&gt; . (Эти более короткие формы фактически являются единственными, разрешенными стандартом SQL, и используются для вывода, когда &lt;code&gt;IntervalStyle&lt;/code&gt; установлен на &lt;code&gt;sql_standard&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="a618b4be8d3ac72545f3085fe616d342b7139fba" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="translated">Query</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">Планирование запросов</target>
        </trans-unit>
        <trans-unit id="b65f94596db8e112e4f92d4f1acdc4bb922a6268" translate="yes" xml:space="preserve">
          <source>Query access - &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;COPY TO&lt;/code&gt;</source>
          <target state="translated">Доступ к запросу - &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;COPY TO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b64c3246eb985e6edb480b51e216c4c9b501e9cb" translate="yes" xml:space="preserve">
          <source>Query access: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;COPY TO&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0b645346d8b6276dfe9ec30dfc16f0625329b2" translate="yes" xml:space="preserve">
          <source>Query performance can be improved dramatically in certain situations, particularly when most of the heavily accessed rows of the table are in a single partition or a small number of partitions. The partitioning substitutes for leading columns of indexes, reducing index size and making it more likely that the heavily-used parts of the indexes fit in memory.</source>
          <target state="translated">Производительность запросов может быть значительно повышена в определенных ситуациях,особенно когда большинство строк таблицы с интенсивным доступом находятся в одном разделе или небольшом количестве разделов.Разбиение на разделы заменяет ведущие столбцы индексов,уменьшая размер индексов и повышая вероятность того,что тяжело используемые части индексов поместятся в память.</target>
        </trans-unit>
        <trans-unit id="1478c128e274ba1bf11d8cef131aa61f63dfccc5" translate="yes" xml:space="preserve">
          <source>Query planner</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198d3f9fde17e740d63372e1985f338979a36a67" translate="yes" xml:space="preserve">
          <source>Query tree (in the form of a &lt;code&gt;nodeToString()&lt;/code&gt; representation) for the rule's action</source>
          <target state="translated">Дерево запросов (в виде представления &lt;code&gt;nodeToString()&lt;/code&gt; ) для действия правила</target>
        </trans-unit>
        <trans-unit id="a6002c5c363574bc4fe16e6079b6e23f671de172" translate="yes" xml:space="preserve">
          <source>Querying this view is similar to using &lt;code&gt;SHOW ALL&lt;/code&gt; but provides more detail. It is also more flexible, since it's possible to specify filter conditions or join against other relations.</source>
          <target state="translated">Запрос этого представления аналогичен использованию &lt;code&gt;SHOW ALL&lt;/code&gt; , но обеспечивает более подробную информацию. Это также более гибко, поскольку можно указать условия фильтрации или объединить с другими отношениями.</target>
        </trans-unit>
        <trans-unit id="33208d59d48811565117bf5ce172585c48018ea8" translate="yes" xml:space="preserve">
          <source>Quick Setup</source>
          <target state="translated">Быстрая настройка</target>
        </trans-unit>
        <trans-unit id="d17b23cd28367fcd27d5f878512b5e25587ec17b" translate="yes" xml:space="preserve">
          <source>Quits the psql program. In a script file, only execution of that script is terminated.</source>
          <target state="translated">Выходит из программы psql.В файле скрипта завершается только выполнение этого скрипта.</target>
        </trans-unit>
        <trans-unit id="472cc72a1798e7f5b5bbceeb0bca7885d9d12809" translate="yes" xml:space="preserve">
          <source>Quoted identifiers can contain any character, except the character with code zero. (To include a double quote, write two double quotes.) This allows constructing table or column names that would otherwise not be possible, such as ones containing spaces or ampersands. The length limitation still applies.</source>
          <target state="translated">Котируемые идентификаторы могут содержать любой символ,кроме символа с кодовым нулем.(Чтобы включить двойную кавычку,напишите две двойную кавычки.)Это позволяет построить имена таблиц или столбцов,которые иначе были бы невозможны,например,содержащие пробелы или амперсанды.Ограничение по длине остается в силе.</target>
        </trans-unit>
        <trans-unit id="9a777f2b79b97851a7b855a9429a5ebde18f036d" translate="yes" xml:space="preserve">
          <source>Quoting an identifier also makes it case-sensitive, whereas unquoted names are always folded to lower case. For example, the identifiers &lt;code&gt;FOO&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt;, and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; are considered the same by PostgreSQL, but &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; are different from these three and each other. (The folding of unquoted names to lower case in PostgreSQL is incompatible with the SQL standard, which says that unquoted names should be folded to upper case. Thus, &lt;code&gt;foo&lt;/code&gt; should be equivalent to &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; not &lt;code&gt;&quot;foo&quot;&lt;/code&gt; according to the standard. If you want to write portable applications you are advised to always quote a particular name or never quote it.)</source>
          <target state="translated">Цитирование идентификатора также делает его чувствительным к регистру, тогда как имена без кавычек всегда переводятся в нижний регистр. Например, идентификаторы &lt;code&gt;FOO&lt;/code&gt; , &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;&quot;foo&quot;&lt;/code&gt; считаются в PostgreSQL одинаковыми, но &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; и &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; отличаются от этих трех и друг от друга. (Сворачивание имен без кавычек в нижний регистр в PostgreSQL несовместимо со стандартом SQL, который гласит, что имена без кавычек следует переводить в верхний регистр. Таким образом, &lt;code&gt;foo&lt;/code&gt; должно быть эквивалентно &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; не &lt;code&gt;&quot;foo&quot;&lt;/code&gt; соответствии со стандартом. Если вы хотите писать портативные приложения, вам рекомендуется всегда указывать конкретное имя или никогда не цитировать его.)</target>
        </trans-unit>
        <trans-unit id="115088ecccb3000708edba51535672720b3a9ec6" translate="yes" xml:space="preserve">
          <source>Quoting rules for lexemes are the same as described previously for lexemes in &lt;code&gt;tsvector&lt;/code&gt;; and, as with &lt;code&gt;tsvector&lt;/code&gt;, any required normalization of words must be done before converting to the &lt;code&gt;tsquery&lt;/code&gt; type. The &lt;code&gt;to_tsquery&lt;/code&gt; function is convenient for performing such normalization:</source>
          <target state="translated">Правила цитирования для лексем такие же, как описано ранее для лексем в &lt;code&gt;tsvector&lt;/code&gt; ; и, как и в случае с &lt;code&gt;tsvector&lt;/code&gt; , любая необходимая нормализация слов должна быть выполнена до преобразования в тип &lt;code&gt;tsquery&lt;/code&gt; . Функция &lt;code&gt;to_tsquery&lt;/code&gt; удобна для выполнения такой нормализации:</target>
        </trans-unit>
        <trans-unit id="b79583615e1227273c81a5db2662b19ad81511a9" translate="yes" xml:space="preserve">
          <source>RADIUS Authentication</source>
          <target state="translated">RADIUS-аутентификация</target>
        </trans-unit>
        <trans-unit id="a954f117477515ead533688d7e4ca8e606782c1a" translate="yes" xml:space="preserve">
          <source>RAM which is used by the processes common to an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;. It mirrors parts of &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; files, provides a transient area for &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt;, and stores additional common information. Note that shared memory belongs to the complete instance, not to a single database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7edcf4d8bc4d16588d07b8848c85c166b827fdc9" translate="yes" xml:space="preserve">
          <source>RD-Tree for one-dimensional array of int4 values</source>
          <target state="translated">RD-дерево для одномерного массива значений int4</target>
        </trans-unit>
        <trans-unit id="ff426c74c79867f7bf13e61c4f68d776339590f2" translate="yes" xml:space="preserve">
          <source>RDBMS</source>
          <target state="translated">RDBMS</target>
        </trans-unit>
        <trans-unit id="633fabe87d723214b65f1db2d624431f04c32334" translate="yes" xml:space="preserve">
          <source>REASSIGN OWNED</source>
          <target state="translated">ПРЕДСТАВЛЯЕМАЯ СОБСТВЕННОСТЬ</target>
        </trans-unit>
        <trans-unit id="7b6e0d55ca8c5d1c174cbdd39c8e88014cc1d924" translate="yes" xml:space="preserve">
          <source>REASSIGN OWNED &amp;mdash; change the ownership of database objects owned by a database role</source>
          <target state="translated">REASSIGN OWNED - изменить владельца объектов базы данных, принадлежащих роли базы данных</target>
        </trans-unit>
        <trans-unit id="d9cbb3a44e5994b48186107b069ebdee3f1ded8c" translate="yes" xml:space="preserve">
          <source>REFRESH MATERIALIZED VIEW</source>
          <target state="translated">ОБНОВЛЁННЫЙ МАТЕРИАЛИЗОВАННЫЙ ВИД</target>
        </trans-unit>
        <trans-unit id="044770dd01baff51d49560ba1c3262f9b7a5e296" translate="yes" xml:space="preserve">
          <source>REFRESH MATERIALIZED VIEW &amp;mdash; replace the contents of a materialized view</source>
          <target state="translated">REFRESH MATERIALIZED VIEW - заменить содержимое материализованного представления</target>
        </trans-unit>
        <trans-unit id="5345e769e7d2d5a04080b106526b4188c28b2947" translate="yes" xml:space="preserve">
          <source>REINDEX</source>
          <target state="translated">REINDEX</target>
        </trans-unit>
        <trans-unit id="d68887fcf8498472cf8183721de3d160d3d8a3bb" translate="yes" xml:space="preserve">
          <source>REINDEX &amp;mdash; rebuild indexes</source>
          <target state="translated">REINDEX - перестроить индексы</target>
        </trans-unit>
        <trans-unit id="bec39b2581dc86d96ef7eb4b59715b2db9fb5b98" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT</source>
          <target state="translated">ТОЧКА СОХРАНЕНИЯ</target>
        </trans-unit>
        <trans-unit id="d33a2b2590d58d2a81b75053789ac9fe4aed380a" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT &amp;mdash; destroy a previously defined savepoint</source>
          <target state="translated">RELEASE SAVEPOINT - уничтожить ранее определенную точку сохранения</target>
        </trans-unit>
        <trans-unit id="995f2d9ddfbe7ab63a2a7ddd59856b61ae272710" translate="yes" xml:space="preserve">
          <source>RESET</source>
          <target state="translated">RESET</target>
        </trans-unit>
        <trans-unit id="c157890fb1f2fab533caebe2d7bbafd037ee3504" translate="yes" xml:space="preserve">
          <source>RESET &amp;mdash; restore the value of a run-time parameter to the default value</source>
          <target state="translated">СБРОС - восстановить значение параметра времени выполнения до значения по умолчанию</target>
        </trans-unit>
        <trans-unit id="d173eb30e8b9fe61478a02d722cdc111a632ca90" translate="yes" xml:space="preserve">
          <source>REVOKE</source>
          <target state="translated">REVOKE</target>
        </trans-unit>
        <trans-unit id="6d5e97f2b0b3bc9eba1622d19f4c033f547d2f10" translate="yes" xml:space="preserve">
          <source>REVOKE &amp;mdash; remove access privileges</source>
          <target state="translated">REVOKE - удалить права доступа</target>
        </trans-unit>
        <trans-unit id="285e88316b0d14455ae0c18a656f7e4c2153f4a5" translate="yes" xml:space="preserve">
          <source>RFC</source>
          <target state="translated">RFC</target>
        </trans-unit>
        <trans-unit id="709f9208ad6c95b7efb1b7aea432fe35dfaffef8" translate="yes" xml:space="preserve">
          <source>RFC 3629</source>
          <target state="translated">RFC 3629</target>
        </trans-unit>
        <trans-unit id="bf1bf54df970aa71d56934027fc34edd568d7730" translate="yes" xml:space="preserve">
          <source>RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by &lt;code&gt;\uXXXX&lt;/code&gt;. In the input function for the &lt;code&gt;json&lt;/code&gt; type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness (that is, that four hex digits follow &lt;code&gt;\u&lt;/code&gt;). However, the input function for &lt;code&gt;jsonb&lt;/code&gt; is stricter: it disallows Unicode escapes for characters that cannot be represented in the database encoding. The &lt;code&gt;jsonb&lt;/code&gt; type also rejects &lt;code&gt;\u0000&lt;/code&gt; (because that cannot be represented in PostgreSQL's &lt;code&gt;text&lt;/code&gt; type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes are converted to the equivalent single character for storage; this includes folding surrogate pairs into a single character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9a9191aa9d2f384e00599efbf540e0c6906e72" translate="yes" xml:space="preserve">
          <source>RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by &lt;code&gt;\uXXXX&lt;/code&gt;. In the input function for the &lt;code&gt;json&lt;/code&gt; type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness (that is, that four hex digits follow &lt;code&gt;\u&lt;/code&gt;). However, the input function for &lt;code&gt;jsonb&lt;/code&gt; is stricter: it disallows Unicode escapes for non-ASCII characters (those above &lt;code&gt;U+007F&lt;/code&gt;) unless the database encoding is UTF8. The &lt;code&gt;jsonb&lt;/code&gt; type also rejects &lt;code&gt;\u0000&lt;/code&gt; (because that cannot be represented in PostgreSQL's &lt;code&gt;text&lt;/code&gt; type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes are converted to the equivalent ASCII or UTF8 character for storage; this includes folding surrogate pairs into a single character.</source>
          <target state="translated">RFC 7159 позволяет строкам JSON содержать escape-последовательности Unicode, обозначенные как &lt;code&gt;\uXXXX&lt;/code&gt; . Во входной функции для типа &lt;code&gt;json&lt;/code&gt; экранирование Unicode разрешено независимо от кодировки базы данных и проверяется только на синтаксическую правильность (то есть, что за &lt;code&gt;\u&lt;/code&gt; следуют четыре шестнадцатеричные цифры ). Однако функция ввода для &lt;code&gt;jsonb&lt;/code&gt; более строгая: она запрещает экранирование Unicode для символов, отличных от ASCII (выше &lt;code&gt;U+007F&lt;/code&gt; ), если только кодировка базы данных не UTF8. Тип &lt;code&gt;jsonb&lt;/code&gt; также отклоняет &lt;code&gt;\u0000&lt;/code&gt; (потому что это не может быть представлено в &lt;code&gt;text&lt;/code&gt; PostgreSQLtype) и настаивает на том, чтобы любое использование суррогатных пар Unicode для обозначения символов за пределами базовой многоязычной плоскости Unicode было правильным. Допустимые escape-символы Unicode преобразуются в эквивалентные символы ASCII или UTF8 для хранения; это включает сворачивание суррогатных пар в один символ.</target>
        </trans-unit>
        <trans-unit id="f7efe490a5991ad892dcbf815cf18cb496f3a528" translate="yes" xml:space="preserve">
          <source>RFC 7159 specifies that JSON strings should be encoded in UTF8. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 will be allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce42e824f2163751d62c49d3226c338efa1179d" translate="yes" xml:space="preserve">
          <source>ROLLBACK</source>
          <target state="translated">ROLLBACK</target>
        </trans-unit>
        <trans-unit id="59a24d752da80d40b19238fcc5ec55b82fdc443e" translate="yes" xml:space="preserve">
          <source>ROLLBACK &amp;mdash; abort the current transaction</source>
          <target state="translated">ROLLBACK - прервать текущую транзакцию</target>
        </trans-unit>
        <trans-unit id="e90e1449c7ef5b8820b08718a11f2da71c8d13be" translate="yes" xml:space="preserve">
          <source>ROLLBACK PREPARED</source>
          <target state="translated">ОБРАТНАЯ ПЕРЕМОТКА</target>
        </trans-unit>
        <trans-unit id="48a2a83386a59b9b2fdad5e2cd3606242846748b" translate="yes" xml:space="preserve">
          <source>ROLLBACK PREPARED &amp;mdash; cancel a transaction that was earlier prepared for two-phase commit</source>
          <target state="translated">ROLLBACK PREPARED - отменить транзакцию, которая ранее была подготовлена ​​для двухфазной фиксации.</target>
        </trans-unit>
        <trans-unit id="61b9b7603e40508bc503ee4691737e409606fd90" translate="yes" xml:space="preserve">
          <source>ROLLBACK TO SAVEPOINT</source>
          <target state="translated">ОТКАТ К ТОЧКЕ СОХРАНЕНИЯ</target>
        </trans-unit>
        <trans-unit id="d35ebfad8fd6f928fec74d3875a90f0020c24317" translate="yes" xml:space="preserve">
          <source>ROLLBACK TO SAVEPOINT &amp;mdash; roll back to a savepoint</source>
          <target state="translated">ROLLBACK TO SAVEPOINT - откат к точке сохранения.</target>
        </trans-unit>
        <trans-unit id="5a8f649047eb74a2e378d2089854762723ab49ef" translate="yes" xml:space="preserve">
          <source>ROW EXCLUSIVE</source>
          <target state="translated">НИКТОРЫЙ ЭКСКЛЮЗИВ</target>
        </trans-unit>
        <trans-unit id="14cb7a6b49bc39b1cc0a49d9f930265fc065d308" translate="yes" xml:space="preserve">
          <source>ROW SHARE</source>
          <target state="translated">ТЕПЛОИЗЛОРОВЫЙ РЕЗУЛЬТАТ</target>
        </trans-unit>
        <trans-unit id="498fa9be2d32c469ac4cde84af98396f043472d9" translate="yes" xml:space="preserve">
          <source>Random access to mechanical disk storage is normally much more expensive than four times sequential access. However, a lower default is used (4.0) because the majority of random accesses to disk, such as indexed reads, are assumed to be in cache. The default value can be thought of as modeling random access as 40 times slower than sequential, while expecting 90% of random reads to be cached.</source>
          <target state="translated">Случайный доступ к механическим дисковым хранилищам обычно намного дороже,чем четырехкратный последовательный доступ.Однако используется более низкое значение по умолчанию (4.0),поскольку предполагается,что большинство случайных обращений к диску,таких как проиндексированные чтения,находятся в кэш-памяти.Значение по умолчанию можно рассматривать как моделирование случайного доступа,так как оно в 40 раз медленнее последовательного,в то время как предполагается,что кэшируется 90% случайных чтений.</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="a12932077f1a02e9d49ac217bf48adda8287e429" translate="yes" xml:space="preserve">
          <source>Range Partitioning</source>
          <target state="translated">Разбивка диапазона</target>
        </trans-unit>
        <trans-unit id="150371fe63779db9b501fedeeefe579700f1d7d0" translate="yes" xml:space="preserve">
          <source>Range Types</source>
          <target state="translated">Типы диапазона</target>
        </trans-unit>
        <trans-unit id="53d929e1fb8ce766a0948419773ae86cbb9a3971" translate="yes" xml:space="preserve">
          <source>Range Types: daterange</source>
          <target state="translated">Типы диапазона:диапазон данных</target>
        </trans-unit>
        <trans-unit id="a3693b9f49e1d1bce857f56deb98c373c7aef619" translate="yes" xml:space="preserve">
          <source>Range Types: int4range</source>
          <target state="translated">Типы диапазона:int4range</target>
        </trans-unit>
        <trans-unit id="8a82ac3da25ee609b2aeb0f2103e7ae7eeded8ea" translate="yes" xml:space="preserve">
          <source>Range Types: int8range</source>
          <target state="translated">Типы диапазона:int8range</target>
        </trans-unit>
        <trans-unit id="744cc477872918910432194727cf36fb5632f253" translate="yes" xml:space="preserve">
          <source>Range Types: numrange</source>
          <target state="translated">Типы диапазона:нумерация</target>
        </trans-unit>
        <trans-unit id="f03184b38e676b9e59d518680c29ef81d475b159" translate="yes" xml:space="preserve">
          <source>Range Types: tsrange</source>
          <target state="translated">Типы диапазона Типы:апельсиновый</target>
        </trans-unit>
        <trans-unit id="010e27d6ddc0ef1f60c30945a5ab60be84e20b61" translate="yes" xml:space="preserve">
          <source>Range Types: tstzrange</source>
          <target state="translated">Типы диапазона:tstzrange</target>
        </trans-unit>
        <trans-unit id="19eccf536154da069167603ea475b5f422e59b33" translate="yes" xml:space="preserve">
          <source>Range and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details).</source>
          <target state="translated">Для разбиения по диапазонам и спискам требуется класс операторов btree, а для разбиения по хешу требуется класс операторов хеширования. Если класс оператора не указан явно, будет использоваться класс оператора соответствующего типа по умолчанию; если класс оператора по умолчанию не существует, возникает ошибка. Когда используется хеш-секционирование, используемый класс оператора должен реализовывать функцию поддержки 2 (подробности см. &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;В Подразделе 37.16.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8895dad393fa948899c08b946bd0ebf4934f19ea" translate="yes" xml:space="preserve">
          <source>Range and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48652fff66c0aa4370d5c8fba0d573037de8ea3f" translate="yes" xml:space="preserve">
          <source>Range types</source>
          <target state="translated">Типы ассортимента</target>
        </trans-unit>
        <trans-unit id="152d9f920b5a18dd2e34c468823a545e1a1c8d0c" translate="yes" xml:space="preserve">
          <source>Range types are data types representing a range of values of some element type (called the range's &lt;em&gt;subtype&lt;/em&gt;). For instance, ranges of &lt;code&gt;timestamp&lt;/code&gt; might be used to represent the ranges of time that a meeting room is reserved. In this case the data type is &lt;code&gt;tsrange&lt;/code&gt; (short for &amp;ldquo;timestamp range&amp;rdquo;), and &lt;code&gt;timestamp&lt;/code&gt; is the subtype. The subtype must have a total order so that it is well-defined whether element values are within, before, or after a range of values.</source>
          <target state="translated">Типы диапазонов - это типы данных, представляющие диапазон значений некоторого типа элемента (называемого &lt;em&gt;подтипом&lt;/em&gt; диапазона ). Например, диапазоны &lt;code&gt;timestamp&lt;/code&gt; могут использоваться для представления диапазонов времени, в течение которых зарезервирован конференц-зал. В этом случае тип данных - &lt;code&gt;tsrange&lt;/code&gt; (сокращение от &amp;laquo;диапазон отметок времени&amp;raquo;), а &lt;code&gt;timestamp&lt;/code&gt; - подтип. Подтип должен иметь общий порядок, чтобы было четко определено, находятся ли значения элементов в пределах, до или после диапазона значений.</target>
        </trans-unit>
        <trans-unit id="10501cb18e09508ff10076b64f0cc428df172882" translate="yes" xml:space="preserve">
          <source>Range types are useful because they represent many element values in a single range value, and because concepts such as overlapping ranges can be expressed clearly. The use of time and date ranges for scheduling purposes is the clearest example; but price ranges, measurement ranges from an instrument, and so forth can also be useful.</source>
          <target state="translated">Типы диапазонов полезны,поскольку они представляют многие значения элементов в одном диапазоне,а также потому,что такие понятия,как перекрывающиеся диапазоны,могут быть четко выражены.Использование диапазонов времени и даты для составления расписания является наиболее наглядным примером;но ценовые диапазоны,диапазоны измерения от инструмента и т.д.также могут быть полезны.</target>
        </trans-unit>
        <trans-unit id="e16fe42dfe025a7c0b1d71163b5e1f4ac592f248" translate="yes" xml:space="preserve">
          <source>Range: &amp;#x27;[2011-01-01,2011-03-01)&amp;#x27;::tsrange @&amp;gt; &amp;#x27;2011-01-10&amp;#x27;::timestamp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a5ac13ea7278862eadf429fec1a6d53e07ac45" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;amp;</source>
          <target state="translated">Ассортимент: &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="5138aeeb99cbf6ebff075b87fadb3ac93d6e5193" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;gt;</source>
          <target state="translated">Диапазон: &amp;amp;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d72ae278ac597396584e8c02a1741c100edfca80" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;lt;</source>
          <target state="translated">Диапазон: &amp;amp; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e3887b799dded8092c6301d5be1aefa3d0dd6d3a" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;</source>
          <target state="translated">Диапазон:&amp;gt;</target>
        </trans-unit>
        <trans-unit id="798e0e9e88e4e32e73dc02d11defb73693566666" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;&amp;gt;</source>
          <target state="translated">Диапазон: &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8e6946ee5453b7aafe3852ad6a413e04bbe70b3f" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;=</source>
          <target state="translated">Диапазон:&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="50827e59e82c8b9b94902deba9c0cd7d740e2584" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;</source>
          <target state="translated">Диапазон: &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f6f037363a29496f0699d11afa7d6227f3803584" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;&amp;gt;</source>
          <target state="translated">Диапазон: &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6f6f0031a9d4355c819448b50757c3487642b742" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;&amp;lt;</source>
          <target state="translated">Диапазон: &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="278020aa13725565b03e23b783ab30ead6a5d971" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;=</source>
          <target state="translated">Диапазон: &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="8fd029989c2ed32bcffaf5576523df4934fcb6aa" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;@</source>
          <target state="translated">Диапазон: &amp;lt;@</target>
        </trans-unit>
        <trans-unit id="519ae404f51d7cdda5157d728a679f6ac34e633b" translate="yes" xml:space="preserve">
          <source>Range: *</source>
          <target state="translated">Диапазон:*</target>
        </trans-unit>
        <trans-unit id="2eb640bcc9834e28157d86493366688f7c5d38a2" translate="yes" xml:space="preserve">
          <source>Range: +</source>
          <target state="translated">Диапазон:+</target>
        </trans-unit>
        <trans-unit id="c8e5cef097bd3910fe5e0190257f34cad206f4c2" translate="yes" xml:space="preserve">
          <source>Range: -</source>
          <target state="translated">Диапазон:-</target>
        </trans-unit>
        <trans-unit id="b30626f6a47ecd0abac84acd28b5ffc7444c5618" translate="yes" xml:space="preserve">
          <source>Range: -|-</source>
          <target state="translated">Диапазон:-|-</target>
        </trans-unit>
        <trans-unit id="1c3066fd7e6819e63ddca17dcd69c108489cf890" translate="yes" xml:space="preserve">
          <source>Range: 42 &amp;lt;@ int4range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7943ac61251b0e439e59453d3c9bd4d92cbe7db" translate="yes" xml:space="preserve">
          <source>Range: =</source>
          <target state="translated">Диапазон:=</target>
        </trans-unit>
        <trans-unit id="5c9fd1a7ffb6cd6aed893574001127ea193ec53e" translate="yes" xml:space="preserve">
          <source>Range: @&amp;gt;</source>
          <target state="translated">Диапазон: @&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5345a847755c33035bc2591758bc060d8da94779" translate="yes" xml:space="preserve">
          <source>Range: NULL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83729c8bd9a31e069f9cad56b7e2bfe6d4220671" translate="yes" xml:space="preserve">
          <source>Range: int4range &amp;lt;@ int4range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6abcc684ac42f015a5d77cb6bf7ae1803faa802" translate="yes" xml:space="preserve">
          <source>Range: int4range @&amp;gt; int4range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cbb9c6dd7fa8194a072796ecd9b741b996bd7a3" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;amp;&amp;amp; int8range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0bb91169217b4e29cfb76dc5581d25ed6b251b" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;amp;&amp;gt; int8range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9df88e5abad3c50f6d014794683bf550b4afb2" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;amp;&amp;lt; int8range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00a7aa8e9c2301c9240fdd0b4875fa5651174d5" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;gt;&amp;gt; int8range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3040a7f95f19ee36e36e4e5ae3a596d709298aa3" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;lt;&amp;lt; int8range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d06790af02020de10dd09609a797d037f242e11" translate="yes" xml:space="preserve">
          <source>Range: int8range * int8range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c4e2dbf1d6156da3d7eac97068e72a3e022465" translate="yes" xml:space="preserve">
          <source>Range: int8range - int8range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df42bdba4fe9375d8ecde65d144985e2fa123da" translate="yes" xml:space="preserve">
          <source>Range: isempty</source>
          <target state="translated">Диапазон:пустой</target>
        </trans-unit>
        <trans-unit id="9447a77bf49896166cdfa5ac004b88e4656caa30" translate="yes" xml:space="preserve">
          <source>Range: isempty)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf1b8f7817c42e33a217bf084388d7956ddb800" translate="yes" xml:space="preserve">
          <source>Range: lower</source>
          <target state="translated">Диапазон:ниже</target>
        </trans-unit>
        <trans-unit id="3534ccb32cb9b587caf3133de3f56d8a17947373" translate="yes" xml:space="preserve">
          <source>Range: lower)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41561998090e13cce0a01b7784c0b3af97242f0c" translate="yes" xml:space="preserve">
          <source>Range: lower_inc</source>
          <target state="translated">Диапазон:нижний_цинк</target>
        </trans-unit>
        <trans-unit id="49ede64eaa7a5da6409899cef575840c6dedca3b" translate="yes" xml:space="preserve">
          <source>Range: lower_inc)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc53727481a0808617729c756b990601f85da64" translate="yes" xml:space="preserve">
          <source>Range: lower_inf</source>
          <target state="translated">Диапазон:lower_inf</target>
        </trans-unit>
        <trans-unit id="2a99c9126b3c8019058e523ae759bf66bab6b3d8" translate="yes" xml:space="preserve">
          <source>Range: lower_inf&amp;#x27;::daterange)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34730d102b3ffad4351ea1715389e7a70c0cc7ec" translate="yes" xml:space="preserve">
          <source>Range: numrange + numrange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1e61e3344f0ee0e36aee5f2d966cf254ba621b" translate="yes" xml:space="preserve">
          <source>Range: numrange -|- numrange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ace460c813343c7a659f92c463b48f8e9497c10" translate="yes" xml:space="preserve">
          <source>Range: range_merge</source>
          <target state="translated">Диапазон:range_merge</target>
        </trans-unit>
        <trans-unit id="25aa728cd66f80690db18e571734403309e220fa" translate="yes" xml:space="preserve">
          <source>Range: range_merge&amp;#x27;::int4range, &amp;#x27;[3,4)&amp;#x27;::int4range)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f28a3c6d0b4768f8b324bd884ab8839d0315ae6" translate="yes" xml:space="preserve">
          <source>Range: upper</source>
          <target state="translated">Диапазон:верхний</target>
        </trans-unit>
        <trans-unit id="04161af92454051c0f045081c7825aa3a8e93a1f" translate="yes" xml:space="preserve">
          <source>Range: upper)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="254cd3d46f3b050314f0a32b8ccaf21bfef8428c" translate="yes" xml:space="preserve">
          <source>Range: upper_inc</source>
          <target state="translated">Диапазон:top_inc</target>
        </trans-unit>
        <trans-unit id="96dc0693990a3ee24e3cb9591cf140f45bea8755" translate="yes" xml:space="preserve">
          <source>Range: upper_inc)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a1bf88678aec9c8e638569577cf68508681fb4" translate="yes" xml:space="preserve">
          <source>Range: upper_inf</source>
          <target state="translated">Диапазон:upper_inf</target>
        </trans-unit>
        <trans-unit id="97b0a2bf6f728a07761880c6d6ff4cec56f9089c" translate="yes" xml:space="preserve">
          <source>Range: upper_inf&amp;#x27;::daterange)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16773cb5b6a39b09024cc881604849b2ada6e7b5" translate="yes" xml:space="preserve">
          <source>Ranking attempts to measure how relevant documents are to a particular query, so that when there are many matches the most relevant ones can be shown first. PostgreSQL provides two predefined ranking functions, which take into account lexical, proximity, and structural information; that is, they consider how often the query terms appear in the document, how close together the terms are in the document, and how important is the part of the document where they occur. However, the concept of relevancy is vague and very application-specific. Different applications might require additional information for ranking, e.g., document modification time. The built-in ranking functions are only examples. You can write your own ranking functions and/or combine their results with additional factors to fit your specific needs.</source>
          <target state="translated">Ранжирование пытается измерить,насколько релевантны документы для конкретного запроса,чтобы при большом количестве совпадений сначала можно было показать наиболее релевантные документы.PostgreSQL предоставляет две предопределенные функции ранжирования,которые учитывают лексическую,близостную и структурную информацию;т.е.они учитывают,как часто термины запроса появляются в документе,как близко они находятся друг к другу в документе и насколько важна та часть документа,в которой они встречаются.Однако понятие релевантности является расплывчатым и очень специфичным для применения.Различным заявкам может потребоваться дополнительная информация для ранжирования,например,время модификации документа.Встроенные функции ранжирования являются только примерами.Вы можете написать свои собственные функции ранжирования и/или объединить их результаты с дополнительными факторами в соответствии с вашими конкретными потребностями.</target>
        </trans-unit>
        <trans-unit id="6d643b0d7aa4393d4d9da3687d8322d0a81e0cab" translate="yes" xml:space="preserve">
          <source>Ranking can be expensive since it requires consulting the &lt;code&gt;tsvector&lt;/code&gt; of each matching document, which can be I/O bound and therefore slow. Unfortunately, it is almost impossible to avoid since practical queries often result in large numbers of matches.</source>
          <target state="translated">Ранжирование может быть дорогостоящим, поскольку требует &lt;code&gt;tsvector&lt;/code&gt; к tsvector каждого совпадающего документа, который может быть связан с вводом- выводом и, следовательно, медленным. К сожалению, избежать этого практически невозможно, поскольку практические запросы часто приводят к большому количеству совпадений.</target>
        </trans-unit>
        <trans-unit id="19afdfa41a0ed827f969267ae295f3b913f28c70" translate="yes" xml:space="preserve">
          <source>Ranks vectors based on the frequency of their matching lexemes.</source>
          <target state="translated">Ранговые векторы,основанные на частоте их совпадения с лексемами.</target>
        </trans-unit>
        <trans-unit id="236c736d2b53bb667d136c499a0d1ba402fdd25d" translate="yes" xml:space="preserve">
          <source>Rather than look at &lt;code&gt;pg_statistic&lt;/code&gt; directly, it's better to look at its view &lt;a href=&quot;view-pg-stats&quot;&gt;&lt;code&gt;pg_stats&lt;/code&gt;&lt;/a&gt; when examining the statistics manually. &lt;code&gt;pg_stats&lt;/code&gt; is designed to be more easily readable. Furthermore, &lt;code&gt;pg_stats&lt;/code&gt; is readable by all, whereas &lt;code&gt;pg_statistic&lt;/code&gt; is only readable by a superuser. (This prevents unprivileged users from learning something about the contents of other people's tables from the statistics. The &lt;code&gt;pg_stats&lt;/code&gt; view is restricted to show only rows about tables that the current user can read.) For example, we might do:</source>
          <target state="translated">Вместо того, чтобы смотреть непосредственно на &lt;code&gt;pg_statistic&lt;/code&gt; , лучше смотреть на его представление &lt;a href=&quot;view-pg-stats&quot;&gt; &lt;code&gt;pg_stats&lt;/code&gt; &lt;/a&gt; при изучении статистики вручную. &lt;code&gt;pg_stats&lt;/code&gt; разработан для облегчения чтения. Кроме того, &lt;code&gt;pg_stats&lt;/code&gt; доступен для чтения всем, тогда как &lt;code&gt;pg_statistic&lt;/code&gt; доступен для чтения только суперпользователю. (Это не позволяет непривилегированным пользователям узнать что-либо о содержимом таблиц других людей из статистики. Представление &lt;code&gt;pg_stats&lt;/code&gt; ограничено отображением только строк о таблицах, которые текущий пользователь может читать.) Например, мы могли бы сделать:</target>
        </trans-unit>
        <trans-unit id="e2bec5c61f15a407e756ab05a685ad23bb7e5511" translate="yes" xml:space="preserve">
          <source>Raw encryption</source>
          <target state="translated">сырое шифрование</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
