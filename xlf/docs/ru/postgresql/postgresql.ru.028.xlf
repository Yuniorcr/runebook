<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="95363da9cd107f5dcc6d6108200a75dee0fecc9d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;client_id&lt;/code&gt; indicates which client session ran the transaction, &lt;code&gt;transaction_no&lt;/code&gt; counts how many transactions have been run by that session, &lt;code&gt;time&lt;/code&gt; is the total elapsed transaction time in microseconds, &lt;code&gt;script_no&lt;/code&gt; identifies which script file was used (useful when multiple scripts were specified with &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;-b&lt;/code&gt;), and &lt;code&gt;time_epoch&lt;/code&gt;/&lt;code&gt;time_us&lt;/code&gt; are a Unix-epoch time stamp and an offset in microseconds (suitable for creating an ISO 8601 time stamp with fractional seconds) showing when the transaction completed. The &lt;code&gt;schedule_lag&lt;/code&gt; field is the difference between the transaction's scheduled start time, and the time it actually started, in microseconds. It is only present when the &lt;code&gt;--rate&lt;/code&gt; option is used. When both &lt;code&gt;--rate&lt;/code&gt; and &lt;code&gt;--latency-limit&lt;/code&gt; are used, the &lt;code&gt;time&lt;/code&gt; for a skipped transaction will be reported as &lt;code&gt;skipped&lt;/code&gt;.</source>
          <target state="translated">где &lt;code&gt;client_id&lt;/code&gt; указывает, в каком клиентском сеансе была запущена транзакция, &lt;code&gt;transaction_no&lt;/code&gt; подсчитывает, сколько транзакций было выполнено этим сеансом, &lt;code&gt;time&lt;/code&gt; - это общее прошедшее время транзакции в микросекундах, &lt;code&gt;script_no&lt;/code&gt; указывает, какой файл сценария использовался (полезно, когда несколько сценариев были указаны с &lt;code&gt;-f&lt;/code&gt; или &lt;code&gt;-b&lt;/code&gt; ), а &lt;code&gt;time_epoch&lt;/code&gt; / &lt;code&gt;time_us&lt;/code&gt; - отметка времени эпохи Unix и смещение в микросекундах (подходит для создания отметки времени ISO 8601 с дробными секундами), показывающее, когда транзакция завершена. &lt;code&gt;schedule_lag&lt;/code&gt; - это разница между запланированным временем начала транзакции и временем ее фактического начала в микросекундах. Он присутствует только при &lt;code&gt;--rate&lt;/code&gt; опции --rate . Когда используются оба параметра &lt;code&gt;--rate&lt;/code&gt; и &lt;code&gt;--latency-limit&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; пропущенной транзакции будет считаться &lt;code&gt;skipped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15575bf8bc20a17322a91c6a004375b23fe3bede" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;collation&lt;/code&gt; is a possibly schema-qualified identifier. The &lt;code&gt;COLLATE&lt;/code&gt; clause binds tighter than operators; parentheses can be used when necessary.</source>
          <target state="translated">где &lt;code&gt;collation&lt;/code&gt; - это, возможно, идентификатор с указанием схемы. Предложение &lt;code&gt;COLLATE&lt;/code&gt; связывает более жестко, чем операторы; при необходимости можно использовать круглые скобки.</target>
        </trans-unit>
        <trans-unit id="cd38ffefd9af14e03f114a3c898a1682942460e2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is any expression that evaluates to a result of type &lt;code&gt;boolean&lt;/code&gt;. Any row that does not satisfy this condition will be eliminated from the output. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.</source>
          <target state="translated">где &lt;code&gt;condition&lt;/code&gt; - это любое выражение, результатом которого является &lt;code&gt;boolean&lt;/code&gt; тип . Любая строка, не удовлетворяющая этому условию, будет исключена из вывода. Строка удовлетворяет условию, если она возвращает истину, когда фактические значения строки подставляются для любых ссылок на переменные.</target>
        </trans-unit>
        <trans-unit id="883e212f0298979617ff0fdf44518bd05a084205" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is any expression that evaluates to a result of type &lt;code&gt;boolean&lt;/code&gt;. Any row that does not satisfy this condition will not be inserted to the table. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.</source>
          <target state="translated">где &lt;code&gt;condition&lt;/code&gt; - это любое выражение, результатом которого является &lt;code&gt;boolean&lt;/code&gt; тип . Любая строка, не удовлетворяющая этому условию, не будет вставлена ​​в таблицу. Строка удовлетворяет условию, если она возвращает истину, когда фактические значения строки подставляются для любых ссылок на переменные.</target>
        </trans-unit>
        <trans-unit id="50d757545c644d09173ed3fc8ac85d6de14f6f0b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is the same as specified for the &lt;code&gt;WHERE&lt;/code&gt; clause.</source>
          <target state="translated">где &lt;code&gt;condition&lt;/code&gt; такое же, как указано в &lt;code&gt;WHERE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e39ffa4c4736dc3798858fa334aa10d101b9ea1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;config_name&lt;/code&gt; is a column in the &lt;code&gt;pgweb&lt;/code&gt; table. This allows mixed configurations in the same index while recording which configuration was used for each index entry. This would be useful, for example, if the document collection contained documents in different languages. Again, queries that are meant to use the index must be phrased to match, e.g., &lt;code&gt;WHERE to_tsvector(config_name, body) @@ 'a &amp;amp; b'&lt;/code&gt;.</source>
          <target state="translated">где &lt;code&gt;config_name&lt;/code&gt; - столбец в таблице &lt;code&gt;pgweb&lt;/code&gt; . Это позволяет смешивать конфигурации в одном индексе при записи того, какая конфигурация использовалась для каждой записи индекса. Это было бы полезно, например, если бы коллекция документов содержала документы на разных языках. Опять же, запросы, которые предназначены для использования индекса, должны быть сформулированы так, чтобы соответствовать, например, &lt;code&gt;WHERE to_tsvector(config_name, body) @@ 'a &amp;amp; b'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e33c809b5aed59b29d15e3755cf042bcd7cf972" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;dbname&lt;/code&gt; is the name of the already-created database to test in. (You may also need &lt;code&gt;-h&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, and/or &lt;code&gt;-U&lt;/code&gt; options to specify how to connect to the database server.)</source>
          <target state="translated">где &lt;code&gt;dbname&lt;/code&gt; - это имя уже созданной базы данных для тестирования. (Вам также могут потребоваться параметры &lt;code&gt;-h&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; и / или &lt;code&gt;-U&lt;/code&gt; , чтобы указать, как подключиться к серверу базы данных.)</target>
        </trans-unit>
        <trans-unit id="2efafe66fc0fb01790e7b075da02f4b34a5191f4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;delim&lt;/code&gt; is the delimiter character for the type, as recorded in its &lt;code&gt;pg_type&lt;/code&gt; entry. Among the standard data types provided in the PostgreSQL distribution, all use a comma (&lt;code&gt;,&lt;/code&gt;), except for type &lt;code&gt;box&lt;/code&gt; which uses a semicolon (&lt;code&gt;;&lt;/code&gt;). Each &lt;code&gt;val&lt;/code&gt; is either a constant of the array element type, or a subarray. An example of an array constant is:</source>
          <target state="translated">где &lt;code&gt;delim&lt;/code&gt; - это символ-разделитель для типа, как записано в записи &lt;code&gt;pg_type&lt;/code&gt; . Среди стандартных типов данных, представленных в дистрибутиве PostgreSQL, все используют запятую ( &lt;code&gt;,&lt;/code&gt; ), за исключением &lt;code&gt;box&lt;/code&gt; типа, в котором используется точка с запятой ( &lt;code&gt;;&lt;/code&gt; ). Каждый &lt;code&gt;val&lt;/code&gt; является либо константой типа элемента массива, либо подмассивом. Пример константы массива:</target>
        </trans-unit>
        <trans-unit id="cc0c370cc6c4db09350c38f91dbc0ead530523ea" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;digits&lt;/code&gt; is one or more decimal digits (0 through 9). At least one digit must be before or after the decimal point, if one is used. At least one digit must follow the exponent marker (&lt;code&gt;e&lt;/code&gt;), if one is present. There cannot be any spaces or other characters embedded in the constant. Note that any leading plus or minus sign is not actually considered part of the constant; it is an operator applied to the constant.</source>
          <target state="translated">где &lt;code&gt;digits&lt;/code&gt; - это одна или несколько десятичных цифр (от 0 до 9). По крайней мере, одна цифра должна быть до или после десятичной точки, если она используется. По крайней мере, одна цифра должна следовать за маркером экспоненты ( &lt;code&gt;e&lt;/code&gt; ), если он присутствует. В константу не может быть пробелов или других символов. Обратите внимание, что любой предшествующий знак плюс или минус фактически не считается частью константы; это оператор, применяемый к константе.</target>
        </trans-unit>
        <trans-unit id="bfd7fccfedd66d19eee35d6037183fff7ab24667" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;documents&lt;/code&gt; is a table that has a text field &lt;code&gt;bodytext&lt;/code&gt; that we wish to search. The reason for using the &lt;code&gt;simple&lt;/code&gt; configuration with the &lt;code&gt;to_tsvector&lt;/code&gt; function, instead of using a language-specific configuration, is that we want a list of the original (unstemmed) words.</source>
          <target state="translated">где &lt;code&gt;documents&lt;/code&gt; - это таблица с &lt;code&gt;bodytext&lt;/code&gt; текстом текстового поля, в котором мы хотим выполнить поиск. Причина использования &lt;code&gt;simple&lt;/code&gt; конфигурации с функцией &lt;code&gt;to_tsvector&lt;/code&gt; вместо использования специфической для языка конфигурации заключается в том, что нам нужен список исходных (без стеблей) слов.</target>
        </trans-unit>
        <trans-unit id="9a039bb227f52a1b9a93d81d62221c9b30047689" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;dumpfile&lt;/code&gt; is the file output by the pg_dump command. The database &lt;code&gt;dbname&lt;/code&gt; will not be created by this command, so you must create it yourself from &lt;code&gt;template0&lt;/code&gt; before executing psql (e.g., with &lt;code&gt;createdb -T template0 dbname&lt;/code&gt;). psql supports options similar to pg_dump for specifying the database server to connect to and the user name to use. See the &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; reference page for more information. Non-text file dumps are restored using the &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; utility.</source>
          <target state="translated">где &lt;code&gt;dumpfile&lt;/code&gt; - это файл, выводимый командой pg_dump. База данных &lt;code&gt;dbname&lt;/code&gt; не будет создана этой командой, поэтому вы должны создать ее самостоятельно из &lt;code&gt;template0&lt;/code&gt; перед выполнением psql (например, с &lt;code&gt;createdb -T template0 dbname&lt;/code&gt; ). psql поддерживает параметры, аналогичные pg_dump, для указания сервера базы данных для подключения и имени пользователя для использования. См. Справочную страницу по &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; для получения дополнительной информации. &lt;a href=&quot;app-pgrestore&quot;&gt;Дампы нетекстовых&lt;/a&gt; файлов восстанавливаются с помощью утилиты pg_restore .</target>
        </trans-unit>
        <trans-unit id="e33127f2af6130f52a3e81c11a87546a1d4d1276" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;frame_start&lt;/code&gt; and &lt;code&gt;frame_end&lt;/code&gt; can be one of</source>
          <target state="translated">где &lt;code&gt;frame_start&lt;/code&gt; и &lt;code&gt;frame_end&lt;/code&gt; могут быть одним из</target>
        </trans-unit>
        <trans-unit id="2f4a0bb9f112237b3006e826384b66b73f19342f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;interval_start&lt;/code&gt; is the start of the interval (as a Unix epoch time stamp), &lt;code&gt;num_transactions&lt;/code&gt; is the number of transactions within the interval, &lt;code&gt;sum_latency&lt;/code&gt; is the sum of the transaction latencies within the interval, &lt;code&gt;sum_latency_2&lt;/code&gt; is the sum of squares of the transaction latencies within the interval, &lt;code&gt;min_latency&lt;/code&gt; is the minimum latency within the interval, and &lt;code&gt;max_latency&lt;/code&gt; is the maximum latency within the interval. The next fields, &lt;code&gt;sum_lag&lt;/code&gt;, &lt;code&gt;sum_lag_2&lt;/code&gt;, &lt;code&gt;min_lag&lt;/code&gt;, and &lt;code&gt;max_lag&lt;/code&gt;, are only present if the &lt;code&gt;--rate&lt;/code&gt; option is used. They provide statistics about the time each transaction had to wait for the previous one to finish, i.e. the difference between each transaction's scheduled start time and the time it actually started. The very last field, &lt;code&gt;skipped&lt;/code&gt;, is only present if the &lt;code&gt;--latency-limit&lt;/code&gt; option is used, too. It counts the number of transactions skipped because they would have started too late. Each transaction is counted in the interval when it was committed.</source>
          <target state="translated">где &lt;code&gt;interval_start&lt;/code&gt; - это начало интервала (как метка времени эпохи Unix), &lt;code&gt;num_transactions&lt;/code&gt; - количество транзакций в пределах интервала, &lt;code&gt;sum_latency&lt;/code&gt; - сумма задержек транзакций в пределах интервала, &lt;code&gt;sum_latency_2&lt;/code&gt; - сумма квадратов задержек транзакций в пределах интервал, &lt;code&gt;min_latency&lt;/code&gt; - это минимальная задержка в пределах интервала, а &lt;code&gt;max_latency&lt;/code&gt; - максимальная задержка в пределах интервала. Следующие поля, &lt;code&gt;sum_lag&lt;/code&gt; , &lt;code&gt;sum_lag_2&lt;/code&gt; , &lt;code&gt;min_lag&lt;/code&gt; и &lt;code&gt;max_lag&lt;/code&gt; , присутствуют только в том случае, если параметр &lt;code&gt;--rate&lt;/code&gt; опция используется. Они предоставляют статистику о времени, в течение которого каждая транзакция должна была ждать завершения предыдущей, т. Е. Разницу между запланированным временем начала каждой транзакции и временем ее фактического запуска. Самое последнее &lt;code&gt;skipped&lt;/code&gt; поле присутствует только в том случае, если также &lt;code&gt;--latency-limit&lt;/code&gt; опция --latency-limit . Он подсчитывает количество пропущенных транзакций, потому что они были начаты слишком поздно. Каждая транзакция засчитывается в интервале времени, когда она была зафиксирована.</target>
        </trans-unit>
        <trans-unit id="21a535125ba922f6008364af8c73fa378c746f74" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;interval_start&lt;/code&gt; is the start of the interval (as a Unix epoch time stamp), &lt;code&gt;num_transactions&lt;/code&gt; is the number of transactions within the interval, &lt;code&gt;sum_latency&lt;/code&gt; is the sum of the transaction latencies within the interval, &lt;code&gt;sum_latency_2&lt;/code&gt; is the sum of squares of the transaction latencies within the interval, &lt;code&gt;min_latency&lt;/code&gt; is the minimum latency within the interval, and &lt;code&gt;max_latency&lt;/code&gt; is the maximum latency within the interval. The next fields, &lt;code&gt;sum_lag&lt;/code&gt;, &lt;code&gt;sum_lag_2&lt;/code&gt;, &lt;code&gt;min_lag&lt;/code&gt;, and &lt;code&gt;max_lag&lt;/code&gt;, are only present if the &lt;code&gt;--rate&lt;/code&gt; option is used. They provide statistics about the time each transaction had to wait for the previous one to finish, i.e., the difference between each transaction's scheduled start time and the time it actually started. The very last field, &lt;code&gt;skipped&lt;/code&gt;, is only present if the &lt;code&gt;--latency-limit&lt;/code&gt; option is used, too. It counts the number of transactions skipped because they would have started too late. Each transaction is counted in the interval when it was committed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02521c4b560914d5a494676dd3a10eaddf5a2d27" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;label&lt;/code&gt; is any string you want to use to uniquely identify this backup operation. &lt;code&gt;pg_start_backup&lt;/code&gt; creates a &lt;em&gt;backup label&lt;/em&gt; file, called &lt;code&gt;backup_label&lt;/code&gt;, in the cluster directory with information about your backup, including the start time and label string. The function also creates a &lt;em&gt;tablespace map&lt;/em&gt; file, called &lt;code&gt;tablespace_map&lt;/code&gt;, in the cluster directory with information about tablespace symbolic links in &lt;code&gt;pg_tblspc/&lt;/code&gt; if one or more such link is present. Both files are critical to the integrity of the backup, should you need to restore from it.</source>
          <target state="translated">где &lt;code&gt;label&lt;/code&gt; - это любая строка, которую вы хотите использовать для однозначной идентификации этой операции резервного копирования. &lt;code&gt;pg_start_backup&lt;/code&gt; создает файл &lt;em&gt;метки резервной копии с&lt;/em&gt; именем &lt;code&gt;backup_label&lt;/code&gt; в каталоге кластера с информацией о вашей резервной копии, включая время начала и строку метки. Функция также создает файл &lt;em&gt;карты табличного пространства&lt;/em&gt; , называемый &lt;code&gt;tablespace_map&lt;/code&gt; , в каталоге кластера с информацией о символических ссылках табличных пространств в &lt;code&gt;pg_tblspc/&lt;/code&gt; если присутствует одна или несколько таких ссылок. Оба файла критически важны для целостности резервной копии, если вам потребуется восстановить из нее.</target>
        </trans-unit>
        <trans-unit id="2632c6a394b4c5afed578e3db6104be70d7c969c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;label&lt;/code&gt; is any string you want to use to uniquely identify this backup operation. The connection calling &lt;code&gt;pg_start_backup&lt;/code&gt; must be maintained until the end of the backup, or the backup will be automatically aborted.</source>
          <target state="translated">где &lt;code&gt;label&lt;/code&gt; - это любая строка, которую вы хотите использовать для однозначной идентификации этой операции резервного копирования. Соединение, вызывающее &lt;code&gt;pg_start_backup&lt;/code&gt; , должно поддерживаться до конца резервного копирования, иначе резервное копирование будет автоматически прервано.</target>
        </trans-unit>
        <trans-unit id="14ec95115d9949716f5574166b53e4a99c82ef40" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;lock_strength&lt;/code&gt; can be one of</source>
          <target state="translated">где &lt;code&gt;lock_strength&lt;/code&gt; может быть одним из</target>
        </trans-unit>
        <trans-unit id="bc24930f3c49a2f1c610c96b58a313a1bb2f6567" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;name&lt;/code&gt; follows the usual rules for SQL identifiers. The current role automatically becomes the owner of the new database. It is the privilege of the owner of a database to remove it later (which also removes all the objects in it, even if they have a different owner).</source>
          <target state="translated">где &lt;code&gt;name&lt;/code&gt; следует обычным правилам для идентификаторов SQL. Текущая роль автоматически становится владельцем новой базы данных. Владелец базы данных имеет право удалить ее позже (что также удаляет все объекты в ней, даже если у них другой владелец).</target>
        </trans-unit>
        <trans-unit id="2e04d3386ac5dbafbf688329834c2f0edf9b1b29" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;num_sync&lt;/code&gt; is the number of synchronous standbys that transactions need to wait for replies from, and &lt;code&gt;standby_name&lt;/code&gt; is the name of a standby server. &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;ANY&lt;/code&gt; specify the method to choose synchronous standbys from the listed servers.</source>
          <target state="translated">где &lt;code&gt;num_sync&lt;/code&gt; - это количество синхронных резервных серверов, от которых транзакции должны ожидать ответов, а &lt;code&gt;standby_name&lt;/code&gt; - это имя резервного сервера. &lt;code&gt;FIRST&lt;/code&gt; и &lt;code&gt;ANY&lt;/code&gt; указывают метод выбора синхронных резервных серверов из перечисленных серверов.</target>
        </trans-unit>
        <trans-unit id="051ce8638a4cb0df58ccc78d0226c857003f3754" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;old_cluster&lt;/code&gt; and &lt;code&gt;new_cluster&lt;/code&gt; are relative to the current directory on the primary, and &lt;code&gt;remote_dir&lt;/code&gt; is &lt;em&gt;above&lt;/em&gt; the old and new cluster directories on the standby. The directory structure under the specified directories on the primary and standbys must match. Consult the rsync manual page for details on specifying the remote directory, e.g.</source>
          <target state="translated">где &lt;code&gt;old_cluster&lt;/code&gt; и &lt;code&gt;new_cluster&lt;/code&gt; относятся к текущему каталогу на первичном &lt;code&gt;remote_dir&lt;/code&gt; , а remote_dir находится &lt;em&gt;над&lt;/em&gt; старым и новым каталогами кластера на резервном сервере . Структура каталогов в указанных каталогах на основном и резервном серверах должна совпадать. Обратитесь к странице руководства rsync для получения подробной информации об указании удаленного каталога, например</target>
        </trans-unit>
        <trans-unit id="a7b5550c4042ab7be1b02d82ee60cb4e972c7064" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;old_cluster&lt;/code&gt; and &lt;code&gt;new_cluster&lt;/code&gt; are relative to the current directory on the primary, and &lt;code&gt;remote_dir&lt;/code&gt; is &lt;em&gt;above&lt;/em&gt; the old and new cluster directories on the standby. The directory structure under the specified directories on the primary and standbys must match. Consult the rsync manual page for details on specifying the remote directory, e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6995f4e58e8fe029424bd429b077f2eb8c3fe1f6" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;p&lt;/code&gt; is an optional precision specification giving the number of fractional digits in the seconds field. Precision can be specified for &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, and &lt;code&gt;interval&lt;/code&gt; types, and can range from 0 to 6. If no precision is specified in a constant specification, it defaults to the precision of the literal value (but not more than 6 digits).</source>
          <target state="translated">где &lt;code&gt;p&lt;/code&gt; - необязательная спецификация точности, дающая количество цифр дробной части в поле секунд. Точность может быть указана для типов &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;timestamp&lt;/code&gt; и &lt;code&gt;interval&lt;/code&gt; в диапазоне от 0 до 6. Если в спецификации константы не указана точность, по умолчанию используется точность буквального значения (но не более 6 цифр).</target>
        </trans-unit>
        <trans-unit id="3ae43e1773ab7435ea942bef4aab35ea977ed17e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;quantity&lt;/code&gt; is a number (possibly signed); &lt;code&gt;unit&lt;/code&gt; is &lt;code&gt;microsecond&lt;/code&gt;, &lt;code&gt;millisecond&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;, &lt;code&gt;minute&lt;/code&gt;, &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;week&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, &lt;code&gt;millennium&lt;/code&gt;, or abbreviations or plurals of these units; &lt;code&gt;direction&lt;/code&gt; can be &lt;code&gt;ago&lt;/code&gt; or empty. The at sign (&lt;code&gt;@&lt;/code&gt;) is optional noise. The amounts of the different units are implicitly added with appropriate sign accounting. &lt;code&gt;ago&lt;/code&gt; negates all the fields. This syntax is also used for interval output, if &lt;a href=&quot;runtime-config-client#GUC-INTERVALSTYLE&quot;&gt;IntervalStyle&lt;/a&gt; is set to &lt;code&gt;postgres_verbose&lt;/code&gt;.</source>
          <target state="translated">где &lt;code&gt;quantity&lt;/code&gt; - это число (возможно, со знаком); &lt;code&gt;unit&lt;/code&gt; - &lt;code&gt;microsecond&lt;/code&gt; , &lt;code&gt;millisecond&lt;/code&gt; , &lt;code&gt;second&lt;/code&gt; , &lt;code&gt;minute&lt;/code&gt; , &lt;code&gt;hour&lt;/code&gt; , &lt;code&gt;day&lt;/code&gt; , &lt;code&gt;week&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;decade&lt;/code&gt; , &lt;code&gt;century&lt;/code&gt; , &lt;code&gt;millennium&lt;/code&gt; или сокращения или множественное число этих единиц; &lt;code&gt;direction&lt;/code&gt; может быть &lt;code&gt;ago&lt;/code&gt; или пустым. Знак ( &lt;code&gt;@&lt;/code&gt; ) - необязательный шум. Суммы различных единиц неявно суммируются с учетом соответствующего знака. &lt;code&gt;ago&lt;/code&gt; отменяет все поля. Этот синтаксис также используется для вывода интервала, если &lt;a href=&quot;runtime-config-client#GUC-INTERVALSTYLE&quot;&gt;IntervalStyle&lt;/a&gt; установлен на &lt;code&gt;postgres_verbose&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb85a9d1ba20986c4eabc4c0cc672867a0082382" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;salt&lt;/code&gt;, &lt;code&gt;StoredKey&lt;/code&gt; and &lt;code&gt;ServerKey&lt;/code&gt; are in Base64 encoded format. This format is the same as that specified by RFC 5803.</source>
          <target state="translated">где &lt;code&gt;salt&lt;/code&gt; , &lt;code&gt;StoredKey&lt;/code&gt; и &lt;code&gt;ServerKey&lt;/code&gt; находятся в кодированном формате Base64. Этот формат совпадает с форматом, указанным в RFC 5803.</target>
        </trans-unit>
        <trans-unit id="902cd914b55268a7f42373967de3300fb2a6df74" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;search_condition&lt;/code&gt; is any value expression (see &lt;a href=&quot;sql-expressions&quot;&gt;Section 4.2&lt;/a&gt;) that returns a value of type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">где &lt;code&gt;search_condition&lt;/code&gt; - любое выражение значения (см. &lt;a href=&quot;sql-expressions&quot;&gt;раздел 4.2&lt;/a&gt; ), которое возвращает значение типа &lt;code&gt;boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cab206ed9f849b266fa8bbb5c105eda41d171c2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;window_definition&lt;/code&gt; has the syntax</source>
          <target state="translated">где &lt;code&gt;window_definition&lt;/code&gt; имеет синтаксис</target>
        </trans-unit>
        <trans-unit id="1ffcb73100c9208f3d73e7359a7710f21793aea4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;window_name&lt;/code&gt; is a name that can be referenced from &lt;code&gt;OVER&lt;/code&gt; clauses or subsequent window definitions, and &lt;code&gt;window_definition&lt;/code&gt; is</source>
          <target state="translated">где &lt;code&gt;window_name&lt;/code&gt; - это имя, на которое можно ссылаться из предложений &lt;code&gt;OVER&lt;/code&gt; или последующих определений окон, а &lt;code&gt;window_definition&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="05865f2594ddc7befb862529cd119701ff24e8ac" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are the respective coordinates, as floating-point numbers.</source>
          <target state="translated">где &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; - соответствующие координаты в виде чисел с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="63a67aa07860e75ed55512e599efa11799c590cd" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x&lt;/code&gt; is a single character with no other significance, matches that character</source>
          <target state="translated">где &lt;code&gt;x&lt;/code&gt; - одиночный символ, не имеющий другого значения, соответствует этому символу</target>
        </trans-unit>
        <trans-unit id="2cfc72d3af1bb50704e8aee07809af6321faa971" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;xsi&lt;/code&gt; is the XML namespace prefix for XML Schema Instance. An appropriate namespace declaration will be added to the result value. If false, columns containing null values are simply omitted from the output.</source>
          <target state="translated">где &lt;code&gt;xsi&lt;/code&gt; - это префикс пространства имен XML для экземпляра схемы XML. Соответствующее объявление пространства имен будет добавлено к результату. Если false, столбцы, содержащие нулевые значения, просто не выводятся.</target>
        </trans-unit>
        <trans-unit id="cbd4a92c9b71cd49ffa17bbdcc8f19ea4f09000a" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;nextval()&lt;/code&gt; function supplies successive values from a &lt;em&gt;sequence object&lt;/em&gt; (see &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;). This arrangement is sufficiently common that there's a special shorthand for it:</source>
          <target state="translated">где функция &lt;code&gt;nextval()&lt;/code&gt; предоставляет последовательные значения из &lt;em&gt;объекта последовательности&lt;/em&gt; (см. &lt;a href=&quot;functions-sequence&quot;&gt;Раздел 9.16&lt;/a&gt; ). Такое расположение достаточно распространено, поэтому для него есть специальное сокращение:</target>
        </trans-unit>
        <trans-unit id="7bd08f9310fcb14cbd5436b568512ce2df9ab484" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;nextval()&lt;/code&gt; function supplies successive values from a &lt;em&gt;sequence object&lt;/em&gt; (see &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt;). This arrangement is sufficiently common that there's a special shorthand for it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f13f6d0c9013e1b5a9453aad6e84166421dc49f" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;operator&lt;/code&gt; token follows the syntax rules of &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-OPERATORS&quot;&gt;Section 4.1.3&lt;/a&gt;, or is one of the key words &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, and &lt;code&gt;NOT&lt;/code&gt;, or is a qualified operator name in the form:</source>
          <target state="translated">где токен &lt;code&gt;operator&lt;/code&gt; соответствует правилам синтаксиса &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-OPERATORS&quot;&gt;Раздела 4.1.3&lt;/a&gt; , или является одним из ключевых слов &lt;code&gt;AND&lt;/code&gt; , &lt;code&gt;OR&lt;/code&gt; и &lt;code&gt;NOT&lt;/code&gt; , или является квалифицированным именем оператора в форме:</target>
        </trans-unit>
        <trans-unit id="8a017c95f90d3833011c4cbc0c74fcbcfe44ef42" translate="yes" xml:space="preserve">
          <source>where the archive directory is physically located on the standby server, so that the &lt;code&gt;archive_command&lt;/code&gt; is accessing it across NFS, but the files are local to the standby. This will:</source>
          <target state="translated">где каталог архива физически расположен на резервном сервере, так что команда &lt;code&gt;archive_command&lt;/code&gt; обращается к нему через NFS, но файлы являются локальными для резервного сервера . Это будет:</target>
        </trans-unit>
        <trans-unit id="a6b4be2958f0bb91c3ed3c4e4583c088a4832f4d" translate="yes" xml:space="preserve">
          <source>where the colon (&lt;code&gt;:&lt;/code&gt;) symbol acts as a delimiter between a phrase and its replacement.</source>
          <target state="translated">где двоеточие ( &lt;code&gt;:&lt;/code&gt; ) символ выступает в качестве разделителя между фразой и его заменой.</target>
        </trans-unit>
        <trans-unit id="e11e7f071949ee7312e3026921c20a83a618fe45" translate="yes" xml:space="preserve">
          <source>where the comment begins with &lt;code&gt;/*&lt;/code&gt; and extends to the matching occurrence of &lt;code&gt;*/&lt;/code&gt;. These block comments nest, as specified in the SQL standard but unlike C, so that one can comment out larger blocks of code that might contain existing block comments.</source>
          <target state="translated">где комментарий начинается с &lt;code&gt;/*&lt;/code&gt; и продолжается до соответствующего вхождения &lt;code&gt;*/&lt;/code&gt; . Эти комментарии к блокам вкладываются, как указано в стандарте SQL, но в отличие от C, так что можно закомментировать большие блоки кода, которые могут содержать существующие комментарии блоков.</target>
        </trans-unit>
        <trans-unit id="8e7c67b39887933602dcee06120320113183300a" translate="yes" xml:space="preserve">
          <source>where the component fields are:</source>
          <target state="translated">где поля компонентов:</target>
        </trans-unit>
        <trans-unit id="0a5be562692973652e8751f219be291ae87f74a1" translate="yes" xml:space="preserve">
          <source>where the file name for the source file must be available on the machine running the backend process, not the client, since the backend process reads the file directly. You can read more about the &lt;code&gt;COPY&lt;/code&gt; command in &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;.</source>
          <target state="translated">где имя файла для исходного файла должно быть доступно на машине, на которой выполняется внутренний процесс, а не на клиенте, поскольку внутренний процесс читает файл напрямую. Вы можете узнать больше о команде &lt;code&gt;COPY&lt;/code&gt; в &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aca0a6010ee58659cb962578b12187acb232c0bd" translate="yes" xml:space="preserve">
          <source>where the format of a table mapping depends on the &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; parameter as explained above.</source>
          <target state="translated">где формат отображения таблицы зависит от параметра &lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; ,&lt;/em&gt; как описано выше.</target>
        </trans-unit>
        <trans-unit id="c322d4fb81e0c24a81de070751209570b9a21fe2" translate="yes" xml:space="preserve">
          <source>where the points are the end points of the line segments comprising the boundary of the polygon.</source>
          <target state="translated">где точки являются конечными точками отрезков прямой,образующих границу многоугольника.</target>
        </trans-unit>
        <trans-unit id="f3a39e39e3dc55cc38a327aeb589b6bbda39e7f5" translate="yes" xml:space="preserve">
          <source>where the points are the end points of the line segments comprising the path. Square brackets (&lt;code&gt;[]&lt;/code&gt;) indicate an open path, while parentheses (&lt;code&gt;()&lt;/code&gt;) indicate a closed path. When the outermost parentheses are omitted, as in the third through fifth syntaxes, a closed path is assumed.</source>
          <target state="translated">где точки - это конечные точки отрезков прямой, составляющих путь. Квадратные скобки ( &lt;code&gt;[]&lt;/code&gt; ) указывают на открытый путь, а круглые скобки ( &lt;code&gt;()&lt;/code&gt; ) указывают на закрытый путь. Когда крайние круглые скобки опущены, как в синтаксисах с третьего по пятый, предполагается, что путь закрыт.</target>
        </trans-unit>
        <trans-unit id="8b49a312334fd1bdab104f06f0ce7761910dd239" translate="yes" xml:space="preserve">
          <source>where the recursive self-reference must appear on the right-hand side of the &lt;code&gt;UNION&lt;/code&gt;. Only one recursive self-reference is permitted per query. Recursive data-modifying statements are not supported, but you can use the results of a recursive &lt;code&gt;SELECT&lt;/code&gt; query in a data-modifying statement. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; for an example.</source>
          <target state="translated">где рекурсивная ссылка на себя должна находиться в правой части &lt;code&gt;UNION&lt;/code&gt; . Для каждого запроса разрешена только одна рекурсивная ссылка на себя. Рекурсивные операторы изменения данных не поддерживаются, но вы можете использовать результаты рекурсивного запроса &lt;code&gt;SELECT&lt;/code&gt; в операторе изменения данных. См. Пример в &lt;a href=&quot;queries-with&quot;&gt;Разделе 7.8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dab6fc9fba9dce67d798f2e3e758f073548c0c8" translate="yes" xml:space="preserve">
          <source>where the schema mapping is as above.</source>
          <target state="translated">где схемное отображение,как указано выше.</target>
        </trans-unit>
        <trans-unit id="382029671c1699461f42fe369fd317b19afaa4b7" translate="yes" xml:space="preserve">
          <source>where the vacuum base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;, the vacuum scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;, and the number of tuples is &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltuples&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9fff4ccdc17ba4f1e6aa42fae36f876c94b66d" translate="yes" xml:space="preserve">
          <source>where the vacuum base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;, the vacuum scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;, and the number of tuples is &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltuples&lt;/code&gt;. The number of obsolete tuples is obtained from the statistics collector; it is a semi-accurate count updated by each &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; operation. (It is only semi-accurate because some information might be lost under heavy load.) If the &lt;code&gt;relfrozenxid&lt;/code&gt; value of the table is more than &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; transactions old, an aggressive vacuum is performed to freeze old tuples and advance &lt;code&gt;relfrozenxid&lt;/code&gt;; otherwise, only pages that have been modified since the last vacuum are scanned.</source>
          <target state="translated">где базовый порог вакуума - &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt; , масштабный коэффициент вакуума - &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt; , а количество кортежей - &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;reltuples&lt;/code&gt; . Количество устаревших кортежей получается из сборщика статистики; это полуточный счетчик, обновляемый каждой операцией &lt;code&gt;UPDATE&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; . (Это только &lt;code&gt;relfrozenxid&lt;/code&gt; потому что некоторая информация может быть потеряна при большой нагрузке.) Если значение relfrozenxid таблицы больше, чем &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; транзакции Vacuum_freeze_table_age , выполняется агрессивная очистка , чтобы заморозить старые кортежи и продвинуть &lt;code&gt;relfrozenxid&lt;/code&gt; ; в противном случае сканируются только страницы, которые были изменены с момента последней очистки.</target>
        </trans-unit>
        <trans-unit id="2c431885a457348236e447edee84410e42626acc" translate="yes" xml:space="preserve">
          <source>where the vacuum insert base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD&quot;&gt;autovacuum_vacuum_insert_threshold&lt;/a&gt;, and vacuum insert scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_insert_scale_factor&lt;/a&gt;. Such vacuums may allow portions of the table to be marked as &lt;em&gt;all visible&lt;/em&gt; and also allow tuples to be frozen, which can reduce the work required in subsequent vacuums. For tables which receive &lt;code&gt;INSERT&lt;/code&gt; operations but no or almost no &lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt; operations, it may be beneficial to lower the table's &lt;a href=&quot;sql-createtable#RELOPTION-AUTOVACUUM-FREEZE-MIN-AGE&quot;&gt;autovacuum_freeze_min_age&lt;/a&gt; as this may allow tuples to be frozen by earlier vacuums. The number of obsolete tuples and the number of inserted tuples are obtained from the statistics collector; it is a semi-accurate count updated by each &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; operation. (It is only semi-accurate because some information might be lost under heavy load.) If the &lt;code&gt;relfrozenxid&lt;/code&gt; value of the table is more than &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; transactions old, an aggressive vacuum is performed to freeze old tuples and advance &lt;code&gt;relfrozenxid&lt;/code&gt;; otherwise, only pages that have been modified since the last vacuum are scanned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9d5d3d104047e0064d4303bd59ec16810bf890" translate="yes" xml:space="preserve">
          <source>where your own login name is mentioned. This will happen if the administrator has not created a PostgreSQL user account for you. (PostgreSQL user accounts are distinct from operating system user accounts.) If you are the administrator, see &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt; for help creating accounts. You will need to become the operating system user under which PostgreSQL was installed (usually &lt;code&gt;postgres&lt;/code&gt;) to create the first user account. It could also be that you were assigned a PostgreSQL user name that is different from your operating system user name; in that case you need to use the &lt;code&gt;-U&lt;/code&gt; switch or set the &lt;code&gt;PGUSER&lt;/code&gt; environment variable to specify your PostgreSQL user name.</source>
          <target state="translated">где упоминается ваше собственное имя для входа. Это произойдет, если администратор не создал для вас учетную запись пользователя PostgreSQL. (Учетные записи пользователей PostgreSQL отличаются от учетных записей пользователей операционной системы.) Если вы являетесь администратором, см. &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;Главу 21&lt;/a&gt; для получения помощи по созданию учетных записей. Вам нужно будет стать пользователем операционной системы, под которой был установлен PostgreSQL (обычно &lt;code&gt;postgres&lt;/code&gt; ), чтобы создать первую учетную запись пользователя. Также может быть, что вам было присвоено имя пользователя PostgreSQL, отличное от имени пользователя вашей операционной системы; в этом случае вам нужно использовать переключатель &lt;code&gt;-U&lt;/code&gt; или установить &lt;code&gt;PGUSER&lt;/code&gt; среды PGUSER, чтобы указать ваше имя пользователя PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="0112d5560695a821c035d2d69c40472d94f7f8cb" translate="yes" xml:space="preserve">
          <source>where your own login name is mentioned. This will happen if the administrator has not created a PostgreSQL user account for you. (PostgreSQL user accounts are distinct from operating system user accounts.) If you are the administrator, see &lt;a href=&quot;https://www.postgresql.org/docs/13/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt; for help creating accounts. You will need to become the operating system user under which PostgreSQL was installed (usually &lt;code&gt;postgres&lt;/code&gt;) to create the first user account. It could also be that you were assigned a PostgreSQL user name that is different from your operating system user name; in that case you need to use the &lt;code&gt;-U&lt;/code&gt; switch or set the &lt;code&gt;PGUSER&lt;/code&gt; environment variable to specify your PostgreSQL user name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1cf5f67d7b1357c152874d6df8382f05565c46" translate="yes" xml:space="preserve">
          <source>which displays per-product sales totals in only the top sales regions. The &lt;code&gt;WITH&lt;/code&gt; clause defines two auxiliary statements named &lt;code&gt;regional_sales&lt;/code&gt; and &lt;code&gt;top_regions&lt;/code&gt;, where the output of &lt;code&gt;regional_sales&lt;/code&gt; is used in &lt;code&gt;top_regions&lt;/code&gt; and the output of &lt;code&gt;top_regions&lt;/code&gt; is used in the primary &lt;code&gt;SELECT&lt;/code&gt; query. This example could have been written without &lt;code&gt;WITH&lt;/code&gt;, but we'd have needed two levels of nested sub-&lt;code&gt;SELECT&lt;/code&gt;s. It's a bit easier to follow this way.</source>
          <target state="translated">который отображает итоги продаж по продуктам только в самых популярных регионах. &lt;code&gt;WITH&lt;/code&gt; разделом определяет две вспомогательных утверждений , названное &lt;code&gt;regional_sales&lt;/code&gt; и &lt;code&gt;top_regions&lt;/code&gt; , где выход &lt;code&gt;regional_sales&lt;/code&gt; используется в &lt;code&gt;top_regions&lt;/code&gt; и выход &lt;code&gt;top_regions&lt;/code&gt; используется в первичном &lt;code&gt;SELECT&lt;/code&gt; , запрос. Этот пример можно было бы написать без &lt;code&gt;WITH&lt;/code&gt; , но нам потребовалось бы два уровня вложенных под- &lt;code&gt;SELECT&lt;/code&gt; . По этому пути немного проще.</target>
        </trans-unit>
        <trans-unit id="bae8a1a20973cccefd7c610839e91bd3974b4005" translate="yes" xml:space="preserve">
          <source>which finds the ten places closest to a given target point. The ability to do this is again dependent on the particular operator class being used. In &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;, operators that can be used in this way are listed in the column &amp;ldquo;Ordering Operators&amp;rdquo;.</source>
          <target state="translated">который находит десять мест, ближайших к заданной целевой точке. Возможность сделать это снова зависит от конкретного используемого класса операторов. В &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Таблице 64.1&lt;/a&gt; операторы, которые можно использовать таким образом, перечислены в столбце &amp;laquo;Операторы упорядочивания&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8dfde0f1cc2ebaaf170e42acdfe9b417e65a8fd3" translate="yes" xml:space="preserve">
          <source>which gives us one output row per city. Each aggregate result is computed over the table rows matching that city. We can filter these grouped rows using &lt;code&gt;HAVING&lt;/code&gt;:</source>
          <target state="translated">что дает нам одну строку вывода для каждого города. Каждый совокупный результат вычисляется по строкам таблицы, соответствующим этому городу. Мы можем фильтровать эти сгруппированные строки, используя &lt;code&gt;HAVING&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="18b9fcfc65791db8244d0ec78c95baca6172d630" translate="yes" xml:space="preserve">
          <source>which gives us the same results for only the cities that have all &lt;code&gt;temp_lo&lt;/code&gt; values below 40. Finally, if we only care about cities whose names begin with &amp;ldquo;&lt;code&gt;S&lt;/code&gt;&amp;rdquo;, we might do:</source>
          <target state="translated">что дает нам те же результаты только для городов, у которых все значения &lt;code&gt;temp_lo&lt;/code&gt; ниже 40. Наконец, если нас интересуют только города, названия которых начинаются с &amp;laquo; &lt;code&gt;S&lt;/code&gt; &amp;raquo;, мы могли бы сделать:</target>
        </trans-unit>
        <trans-unit id="689a2e02b1a49db16b3b1be754391d4fc8da64e0" translate="yes" xml:space="preserve">
          <source>which is executed as:</source>
          <target state="translated">которая исполняется как:</target>
        </trans-unit>
        <trans-unit id="f15875e884530dd30ab6d27db56535aa74c98f64" translate="yes" xml:space="preserve">
          <source>which obtains the 50th percentile, or median, value of the &lt;code&gt;income&lt;/code&gt; column from table &lt;code&gt;households&lt;/code&gt;. Here, &lt;code&gt;0.5&lt;/code&gt; is a direct argument; it would make no sense for the percentile fraction to be a value varying across rows.</source>
          <target state="translated">который получает 50-й процентиль или медианное значение столбца &lt;code&gt;income&lt;/code&gt; из таблицы &lt;code&gt;households&lt;/code&gt; . Здесь &lt;code&gt;0.5&lt;/code&gt; - прямой аргумент; было бы бессмысленно, чтобы процентная доля была величиной, меняющейся по строкам.</target>
        </trans-unit>
        <trans-unit id="f6ee8c6433c23fa17a7f1946c5c1b26470b55b09" translate="yes" xml:space="preserve">
          <source>which refers to a function with zero arguments, whereas the first variant can refer to a function with any number of arguments, including zero, as long as the name is unique.</source>
          <target state="translated">которая ссылается на функцию с нулевыми аргументами,в то время как первый вариант может ссылаться на функцию с любым количеством аргументов,включая ноль,при условии,что имя уникально.</target>
        </trans-unit>
        <trans-unit id="0e899e70b75b90b65729658ed54cd0ca39432992" translate="yes" xml:space="preserve">
          <source>which returns:</source>
          <target state="translated">который возвращается:</target>
        </trans-unit>
        <trans-unit id="74cad75d5e4f20aa31f501f8fefdc21abad67352" translate="yes" xml:space="preserve">
          <source>which shows that the planner thinks that sorting &lt;code&gt;onek&lt;/code&gt; by index-scanning is about 12% more expensive than sequential-scan-and-sort. Of course, the next question is whether it's right about that. We can investigate that using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, as discussed below.</source>
          <target state="translated">который показывает, что планировщик считает, что сортировка &lt;code&gt;onek&lt;/code&gt; методом сканирования индекса примерно на 12% дороже, чем последовательное сканирование и сортировка. Конечно, следующий вопрос - правда ли это? Мы можем исследовать это с помощью &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; , как описано ниже.</target>
        </trans-unit>
        <trans-unit id="7c0656a99c8833cfc345dd27d0b6820caa432991" translate="yes" xml:space="preserve">
          <source>which we wish to display like</source>
          <target state="translated">который мы хотим показать как</target>
        </trans-unit>
        <trans-unit id="c282db8639e1ae34ff018f3c72116a8c43100b68" translate="yes" xml:space="preserve">
          <source>which will copy archivable WAL segments to the directory &lt;code&gt;/mnt/server/archivedir&lt;/code&gt;. (This is an example, not a recommendation, and might not work on all platforms.) After the &lt;code&gt;%p&lt;/code&gt; and &lt;code&gt;%f&lt;/code&gt; parameters have been replaced, the actual command executed might look like this:</source>
          <target state="translated">который скопирует архивируемые сегменты WAL в каталог &lt;code&gt;/mnt/server/archivedir&lt;/code&gt; . (Это пример, а не рекомендация, и он может работать не на всех платформах.) После замены параметров &lt;code&gt;%p&lt;/code&gt; и &lt;code&gt;%f&lt;/code&gt; фактическая выполняемая команда может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="0a169e40949af2620c4e85dda15d79975492e73f" translate="yes" xml:space="preserve">
          <source>which will copy previously archived WAL segments from the directory &lt;code&gt;/mnt/server/archivedir&lt;/code&gt;. Of course, you can use something much more complicated, perhaps even a shell script that requests the operator to mount an appropriate tape.</source>
          <target state="translated">который скопирует ранее заархивированные сегменты WAL из каталога &lt;code&gt;/mnt/server/archivedir&lt;/code&gt; . Конечно, вы можете использовать что-то гораздо более сложное, возможно, даже сценарий оболочки, который просит оператора смонтировать соответствующую ленту.</target>
        </trans-unit>
        <trans-unit id="26cd6a2051ea99afa4a27d84b6ed47beb5036a7c" translate="yes" xml:space="preserve">
          <source>which will leave the server running in the foreground. This must be done while logged into the PostgreSQL user account. Without &lt;code&gt;-D&lt;/code&gt;, the server will try to use the data directory named by the environment variable &lt;code&gt;PGDATA&lt;/code&gt;. If that variable is not provided either, it will fail.</source>
          <target state="translated">что оставит сервер работающим на переднем плане. Это необходимо сделать, войдя в учетную запись пользователя PostgreSQL. Без &lt;code&gt;-D&lt;/code&gt; сервер попытается использовать каталог данных, названный переменной среды &lt;code&gt;PGDATA&lt;/code&gt; . Если эта переменная также не указана, произойдет сбой.</target>
        </trans-unit>
        <trans-unit id="c4e8f14819326dd3aae3a2cf53d737470310c24e" translate="yes" xml:space="preserve">
          <source>which will match the stemmed form of &lt;code&gt;postgraduate&lt;/code&gt;.</source>
          <target state="translated">который будет соответствовать основной форме &lt;code&gt;postgraduate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ff082187c1d02a1fdad2296ffb917870a45b03c" translate="yes" xml:space="preserve">
          <source>which would allow a box value's component numbers to be accessed by subscripting. Otherwise the type behaves the same as before.</source>
          <target state="translated">что позволило бы получить доступ к номерам компонентов ячейки.В противном случае тип ведет себя так же,как и раньше.</target>
        </trans-unit>
        <trans-unit id="df5d2347727e9e14fc56d97420272403e963b0b6" translate="yes" xml:space="preserve">
          <source>which would be a valid value of the &lt;code&gt;inventory_item&lt;/code&gt; type defined above. To make a field be NULL, write no characters at all in its position in the list. For example, this constant specifies a NULL third field:</source>
          <target state="translated">которое будет допустимым значением типа &lt;code&gt;inventory_item&lt;/code&gt; , определенного выше. Чтобы поле было NULL, не пишите никаких символов в его позиции в списке. Например, эта константа определяет третье поле NULL:</target>
        </trans-unit>
        <trans-unit id="9a3be0245636efccdc3c57134520df09a0e4a0a4" translate="yes" xml:space="preserve">
          <source>white space and comments cannot appear within multi-character symbols, such as &lt;code&gt;(?:&lt;/code&gt;</source>
          <target state="translated">пробелы и комментарии не могут появляться в многосимвольных символах, таких как &lt;code&gt;(?:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b43caaeffd6a470ec3896dc284dda83445964f79" translate="yes" xml:space="preserve">
          <source>white space or &lt;code&gt;#&lt;/code&gt; within a bracket expression is retained</source>
          <target state="translated">пробел или &lt;code&gt;#&lt;/code&gt; в выражении в квадратных скобках сохраняется</target>
        </trans-unit>
        <trans-unit id="52b07ed610fcda069d74b3a411d9e935637def49" translate="yes" xml:space="preserve">
          <source>will be allowed if the cast from type &lt;code&gt;integer&lt;/code&gt; to type &lt;code&gt;text&lt;/code&gt; is marked &lt;code&gt;AS ASSIGNMENT&lt;/code&gt;, otherwise not. (We generally use the term &lt;em&gt;assignment cast&lt;/em&gt; to describe this kind of cast.)</source>
          <target state="translated">будет разрешено, если приведение типа &lt;code&gt;integer&lt;/code&gt; к &lt;code&gt;text&lt;/code&gt; типа помечено как &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; , в противном случае - нет. (Обычно мы используем термин &amp;laquo;приведение &lt;em&gt;присваивания&amp;raquo;&lt;/em&gt; для описания этого вида приведения.)</target>
        </trans-unit>
        <trans-unit id="e7b329bd0ae166b219c0dac7856440cebddc7bef" translate="yes" xml:space="preserve">
          <source>will be parsed as:</source>
          <target state="translated">будет разобрано как:</target>
        </trans-unit>
        <trans-unit id="fcc5b8ad0d43009e11ed531b9ba723b81a61922b" translate="yes" xml:space="preserve">
          <source>will draw an error even though the &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;POSIX&lt;/code&gt; collations have identical behaviors. Mixing stripped and non-stripped collation names is therefore not recommended.</source>
          <target state="translated">выведет ошибку, даже если параметры сортировки &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;POSIX&lt;/code&gt; имеют идентичное поведение. Поэтому не рекомендуется смешивать имена параметров сортировки с разделением и без.</target>
        </trans-unit>
        <trans-unit id="8ea301593a0a7ff485b37c9d6c155df86be3bfc8" translate="yes" xml:space="preserve">
          <source>will lock only rows having &lt;code&gt;col1 = 5&lt;/code&gt;, even though that condition is not textually within the sub-query.</source>
          <target state="translated">заблокирует только строки с &lt;code&gt;col1 = 5&lt;/code&gt; , даже если это условие не текстуально в подзапросе.</target>
        </trans-unit>
        <trans-unit id="b9075f9f3f87909783fee359888bd2c471dea042" translate="yes" xml:space="preserve">
          <source>will only process the master table.</source>
          <target state="translated">будет обрабатывать только главный стол.</target>
        </trans-unit>
        <trans-unit id="166a3172a29e9b1013bd7227d7fa350d195805cd" translate="yes" xml:space="preserve">
          <source>will remove the domain part for users with system user names that end with &lt;code&gt;@mydomain.com&lt;/code&gt;, and allow any user whose system name ends with &lt;code&gt;@otherdomain.com&lt;/code&gt; to log in as &lt;code&gt;guest&lt;/code&gt;.</source>
          <target state="translated">удалит часть домена для пользователей с системными именами пользователей, заканчивающимися на &lt;code&gt;@mydomain.com&lt;/code&gt; , и позволит любому пользователю, системное имя которого заканчивается на &lt;code&gt;@otherdomain.com&lt;/code&gt; войти в систему в качестве &lt;code&gt;guest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e42965869a7de1a0b4c9e3864a5bad5ded3e3510" translate="yes" xml:space="preserve">
          <source>will require effort proportional to the size of the table: PostgreSQL will need to scan either the entire table or the entirety of an index that includes all rows in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733025f436e0af6dc9df77a7ba625859cbbf72ca" translate="yes" xml:space="preserve">
          <source>will require effort proportional to the size of the table: PostgreSQL will need to scan either the entire table or the entirety of an index which includes all rows in the table.</source>
          <target state="translated">потребуют усилий,пропорциональных размеру таблицы:PostgreSQL должен будет сканировать либо всю таблицу,либо весь индекс,включающий все строки таблицы.</target>
        </trans-unit>
        <trans-unit id="91e07485ce9849ddc161bb7d803839b8f2cfb477" translate="yes" xml:space="preserve">
          <source>will result in the three SQL commands being individually sent to the server, with each one's results being displayed before continuing to the next command. However, a semicolon entered as &lt;code&gt;\;&lt;/code&gt; will not trigger command processing, so that the command before it and the one after are effectively combined and sent to the server in one request. So for example</source>
          <target state="translated">приведет к тому, что три команды SQL будут по отдельности отправлены на сервер, и результаты каждой будут отображаться перед переходом к следующей команде. Однако точка с запятой вводится как &lt;code&gt;\;&lt;/code&gt; не будет запускать обработку команды, поэтому команда перед ней и команда после нее эффективно объединяются и отправляются на сервер в одном запросе. Так например</target>
        </trans-unit>
        <trans-unit id="047ba62edd680e2d56a13904abdabc4188cb005b" translate="yes" xml:space="preserve">
          <source>will return a table of two columns and three rows. It's effectively equivalent to:</source>
          <target state="translated">вернет таблицу из двух столбцов и трех строк.Это фактически эквивалентно:</target>
        </trans-unit>
        <trans-unit id="6cf8c1d7fdc60299e5a5cb3f3300a0c91cf43fb7" translate="yes" xml:space="preserve">
          <source>will start the server in the background and put the output into the named log file. The &lt;code&gt;-D&lt;/code&gt; option has the same meaning here as for &lt;code&gt;postgres&lt;/code&gt;. &lt;code&gt;pg_ctl&lt;/code&gt; is also capable of stopping the server.</source>
          <target state="translated">запустит сервер в фоновом режиме и поместит результат в указанный файл журнала. Параметр &lt;code&gt;-D&lt;/code&gt; здесь имеет то же значение, что и для &lt;code&gt;postgres&lt;/code&gt; . &lt;code&gt;pg_ctl&lt;/code&gt; также может останавливать сервер.</target>
        </trans-unit>
        <trans-unit id="7130bc171fc84062054c81f8bc4460528312537b" translate="yes" xml:space="preserve">
          <source>with hot standby</source>
          <target state="translated">с горячим резервом</target>
        </trans-unit>
        <trans-unit id="af6d8270bf9a28cb0890365af8ad9fbaf343522d" translate="yes" xml:space="preserve">
          <source>with sync off</source>
          <target state="translated">с синхронизацией</target>
        </trans-unit>
        <trans-unit id="3a3cc3c4fb4b36db89f9594987cae52aab437928" translate="yes" xml:space="preserve">
          <source>with sync on</source>
          <target state="translated">с синхронизацией</target>
        </trans-unit>
        <trans-unit id="9370d4f218264e82510fdcf2db2c6328e076bb0c" translate="yes" xml:space="preserve">
          <source>with the default &lt;code&gt;BLCKSZ&lt;/code&gt; of 8192 bytes</source>
          <target state="translated">со значением по умолчанию &lt;code&gt;BLCKSZ&lt;/code&gt; 8192 байта</target>
        </trans-unit>
        <trans-unit id="1fcb8a613e6e45488de8c47b5f45118a3ee76969" translate="yes" xml:space="preserve">
          <source>without any precision or scale creates a column in which numeric values of any precision and scale can be stored, up to the implementation limit on precision. A column of this kind will not coerce input values to any particular scale, whereas &lt;code&gt;numeric&lt;/code&gt; columns with a declared scale will coerce input values to that scale. (The SQL standard requires a default scale of 0, i.e., coercion to integer precision. We find this a bit useless. If you're concerned about portability, always specify the precision and scale explicitly.)</source>
          <target state="translated">без какой-либо точности или масштаба создает столбец, в котором могут храниться числовые значения любой точности и масштаба, вплоть до предела точности реализации. Столбец такого типа не будет приводить входные значения к какому-либо конкретному масштабу, тогда как &lt;code&gt;numeric&lt;/code&gt; столбцы с объявленным масштабом будут приводить входные значения к этому масштабу. (Стандарт SQL требует шкалы по умолчанию, равной 0, т. Е. Приведения к целочисленной точности. Мы считаем это немного бесполезным. Если вас беспокоит переносимость, всегда указывайте точность и масштаб явно.)</target>
        </trans-unit>
        <trans-unit id="db48d21b6765af674c2d86f7d7085037c147d319" translate="yes" xml:space="preserve">
          <source>would fail to preserve the &lt;code&gt;FOR UPDATE&lt;/code&gt; lock after the &lt;code&gt;ROLLBACK TO&lt;/code&gt;. This has been fixed in release 9.3.</source>
          <target state="translated">не сможет сохранить блокировку &lt;code&gt;FOR UPDATE&lt;/code&gt; после &lt;code&gt;ROLLBACK TO&lt;/code&gt; . Это было исправлено в версии 9.3.</target>
        </trans-unit>
        <trans-unit id="d993c428e713634961b14ab1031f2202eb8ab483" translate="yes" xml:space="preserve">
          <source>would query the table &lt;code&gt;my_table&lt;/code&gt;. Note that this may be unsafe: the value of the variable is copied literally, so it can contain unbalanced quotes, or even backslash commands. You must make sure that it makes sense where you put it.</source>
          <target state="translated">запросит таблицу &lt;code&gt;my_table&lt;/code&gt; . Обратите внимание, что это может быть небезопасно: значение переменной копируется буквально, поэтому оно может содержать несбалансированные кавычки или даже команды с обратной косой чертой. Вы должны убедиться, что это имеет смысл.</target>
        </trans-unit>
        <trans-unit id="4fb1884d01fa0af9488b72c839058eb9b1cd3ec9" translate="yes" xml:space="preserve">
          <source>www.openwall.com</source>
          <target state="translated">www.openwall.com</target>
        </trans-unit>
        <trans-unit id="ee60015c8f586443db97ad8f39f2b79227b8fd01" translate="yes" xml:space="preserve">
          <source>xact</source>
          <target state="translated">xact</target>
        </trans-unit>
        <trans-unit id="30e2ca63aa35fbb6880b2c6d43d8e5e3aa97095e" translate="yes" xml:space="preserve">
          <source>xml2</source>
          <target state="translated">xml2</target>
        </trans-unit>
        <trans-unit id="f94d7d22277dd8bae275a25a490b99203cccb3b3" translate="yes" xml:space="preserve">
          <source>y-intercept of the least-squares-fit linear equation determined by the (&lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;) pairs</source>
          <target state="translated">Y-пересечение линейного уравнения методом наименьших квадратов, определяемого парами ( &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="150f912c47bfa78eaad7a19807fcef6747d4b800" translate="yes" xml:space="preserve">
          <source>year (4 or more digits)</source>
          <target state="translated">год (4 и более цифры)</target>
        </trans-unit>
        <trans-unit id="611de26b771af738f57fb9b6c8721bb546f69f99" translate="yes" xml:space="preserve">
          <source>year (4 or more digits) with comma</source>
          <target state="translated">год (4 и более цифры)с запятой</target>
        </trans-unit>
        <trans-unit id="127cd8c2aa50e43e37fcd0ad357fa69ed4e6f270" translate="yes" xml:space="preserve">
          <source>year 99 BC</source>
          <target state="translated">99 год до н.э.</target>
        </trans-unit>
        <trans-unit id="d468eeeab09a5f89dd95cca8a1d68fbf5b52784a" translate="yes" xml:space="preserve">
          <source>year and day of year</source>
          <target state="translated">год и день года</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="b7caf4dc1da846acd815fdde550fbd1677a60c12" translate="yes" xml:space="preserve">
          <source>yes (Note 1)</source>
          <target state="translated">да (примечание 1)</target>
        </trans-unit>
        <trans-unit id="a6e931eb3e1e969efa57eb9a58fd4f25fd4cb2e1" translate="yes" xml:space="preserve">
          <source>you will find that &lt;code&gt;tenk1&lt;/code&gt; has 358 disk pages and 10000 rows. The estimated cost is computed as (disk pages read * &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;) + (rows scanned * &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;). By default, &lt;code&gt;seq_page_cost&lt;/code&gt; is 1.0 and &lt;code&gt;cpu_tuple_cost&lt;/code&gt; is 0.01, so the estimated cost is (358 * 1.0) + (10000 * 0.01) = 458.</source>
          <target state="translated">вы обнаружите, что &lt;code&gt;tenk1&lt;/code&gt; имеет 358 дисковых страниц и 10000 строк. Ориентировочная стоимость рассчитывается как (прочитанные страницы диска * &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; ) + (отсканированные строки * &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt; ). По умолчанию &lt;code&gt;seq_page_cost&lt;/code&gt; составляет 1,0, а &lt;code&gt;cpu_tuple_cost&lt;/code&gt; - 0,01, поэтому расчетная стоимость составляет (358 * 1,0) + (10000 * 0,01) = 458.</target>
        </trans-unit>
        <trans-unit id="1982d2d3e9d46b67ceb2b6b1086e041a7f7ce8a9" translate="yes" xml:space="preserve">
          <source>zero octet</source>
          <target state="translated">нулевой октет</target>
        </trans-unit>
        <trans-unit id="5aab974202bf0788f59e7ce97b96b6b4d59e6caf" translate="yes" xml:space="preserve">
          <source>{A,B,C}</source>
          <target state="translated">{A,B,C}</target>
        </trans-unit>
        <trans-unit id="f751f41a86686962c7eb6a6c72d7aead8c2eed66" translate="yes" xml:space="preserve">
          <source>~ ! @ # % ^ &amp;amp; | ` ?</source>
          <target state="translated">~! @ #% ^ &amp;amp; | `?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
