<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="2fd647ad9469bb58fc1688a31c856ba421945ca2" translate="yes" xml:space="preserve">
          <source>All queries in the &lt;code&gt;WITH&lt;/code&gt; list are computed. These effectively serve as temporary tables that can be referenced in the &lt;code&gt;FROM&lt;/code&gt; list. A &lt;code&gt;WITH&lt;/code&gt; query that is referenced more than once in &lt;code&gt;FROM&lt;/code&gt; is computed only once, unless specified otherwise with &lt;code&gt;NOT MATERIALIZED&lt;/code&gt;. (See &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;&lt;code&gt;WITH&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">Все запросы в списке &lt;code&gt;WITH&lt;/code&gt; вычисляются. Они фактически служат временными таблицами, на которые можно ссылаться в списке &lt;code&gt;FROM&lt;/code&gt; . &lt;code&gt;WITH&lt;/code&gt; запрос , на который ссылается более чем один раз в &lt;code&gt;FROM&lt;/code&gt; вычисляется только один раз, если не указано иное с &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; . (См. &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;Пункт &lt;/a&gt; &lt;code&gt;WITH&lt;/code&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="d5d88441c9f02c86f8bfc47e2413965c87d4afdf" translate="yes" xml:space="preserve">
          <source>All queries in the &lt;code&gt;WITH&lt;/code&gt; list are computed. These effectively serve as temporary tables that can be referenced in the &lt;code&gt;FROM&lt;/code&gt; list. A &lt;code&gt;WITH&lt;/code&gt; query that is referenced more than once in &lt;code&gt;FROM&lt;/code&gt; is computed only once, unless specified otherwise with &lt;code&gt;NOT MATERIALIZED&lt;/code&gt;. (See &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;WITH Clause&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f087ce49a12f5467c1e1d2b10a821f36bb151962" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit.</source>
          <target state="translated">Все строки во временной таблице будут удаляться в конце каждого блока транзакции. По сути, автоматический &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; выполняется при каждой фиксации.</target>
        </trans-unit>
        <trans-unit id="2033a72b30b992b55fdec7e008bb0316322a754e" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit. When used on a partitioned table, this is not cascaded to its partitions.</source>
          <target state="translated">Все строки во временной таблице будут удаляться в конце каждого блока транзакции. По сути, автоматический &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; выполняется при каждой фиксации. При использовании в многораздельной таблице она не передается каскадом на ее разделы.</target>
        </trans-unit>
        <trans-unit id="6dcf0dcfbfdd9c5f88b82f71ae9c913b23c0891e" translate="yes" xml:space="preserve">
          <source>All rows inserted into a partitioned table will be routed to one of the &lt;em&gt;partitions&lt;/em&gt; based on the value of the partition key. Each partition has a subset of the data defined by its &lt;em&gt;partition bounds&lt;/em&gt;. The currently supported partitioning methods are range, list, and hash.</source>
          <target state="translated">Все строки, вставленные в многораздельную таблицу, будут направлены в один из &lt;em&gt;разделов в&lt;/em&gt; зависимости от значения ключа раздела. У каждого раздела есть подмножество данных, определяемое его &lt;em&gt;границами&lt;/em&gt; . В настоящее время поддерживаются следующие методы разделения: диапазон, список и хэш.</target>
        </trans-unit>
        <trans-unit id="4513787ec30b4d30ebbb9895538f30d98e3df810" translate="yes" xml:space="preserve">
          <source>All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</source>
          <target state="translated">Все стандартные и предопределенные сопоставления детерминированы, все определяемые пользователем сопоставления по умолчанию детерминированы. Хотя недетерминированные сопоставления дают более &amp;laquo;правильное&amp;raquo; поведение, особенно с учетом всех возможностей Unicode и его многих особых случаев, они также имеют некоторые недостатки. Прежде всего, их использование приводит к снижению производительности. Кроме того, некоторые операции невозможны с недетерминированными сопоставлениями, например операции сопоставления с образцом. Поэтому их следует использовать только в тех случаях, когда они особо нужны.</target>
        </trans-unit>
        <trans-unit id="25b4cbd01fbf767d95283abe0881812c05362a17" translate="yes" xml:space="preserve">
          <source>All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Note, in particular, that B-tree cannot use deduplication with indexes that use a nondeterministic collation. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33701db90942013a1dfc5834530a8ecffe185cf9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction.</source>
          <target state="translated">Все операторы текущей транзакции могут видеть только строки,зафиксированные до того,как в этой транзакции был выполнен первый запрос или оператор модификации данных.</target>
        </trans-unit>
        <trans-unit id="2e14dc15c0e8ebe018dfe9b3ade39c8f85c910d9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction. If a pattern of reads and writes among concurrent serializable transactions would create a situation which could not have occurred for any serial (one-at-a-time) execution of those transactions, one of them will be rolled back with a &lt;code&gt;serialization_failure&lt;/code&gt; error.</source>
          <target state="translated">Все операторы текущей транзакции могут видеть только строки, зафиксированные до того, как в этой транзакции был выполнен первый запрос или оператор изменения данных. Если последовательность операций чтения и записи среди параллельных сериализуемых транзакций создаст ситуацию, которая не могла бы возникнуть при каком-либо последовательном (по одному) выполнении этих транзакций, одна из них будет отменена с ошибкой &lt;code&gt;serialization_failure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="333b8b7d294d7e593e47c576e136baad90efa83c" translate="yes" xml:space="preserve">
          <source>All system-defined SQL objects reside in schema &lt;code&gt;pg_catalog&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd69152cf9c28ea6bdb8489a69a762ca6be86225" translate="yes" xml:space="preserve">
          <source>All systems would have the same &lt;code&gt;shared.conf&lt;/code&gt;. Each server with a particular amount of memory could share the same &lt;code&gt;memory.conf&lt;/code&gt;; you might have one for all servers with 8GB of RAM, another for those having 16GB. And finally &lt;code&gt;server.conf&lt;/code&gt; could have truly server-specific configuration information in it.</source>
          <target state="translated">У всех систем будет один и тот же &lt;code&gt;shared.conf&lt;/code&gt; . Каждый сервер с определенным объемом памяти может использовать один и тот же &lt;code&gt;memory.conf&lt;/code&gt; ; у вас может быть один для всех серверов с 8 ГБ ОЗУ, другой для тех, у кого 16 ГБ. И, наконец, &lt;code&gt;server.conf&lt;/code&gt; может содержать действительно специфичную для сервера информацию о конфигурации.</target>
        </trans-unit>
        <trans-unit id="fdb84efbad86954ba5aa82c861c3c65c57c671dd" translate="yes" xml:space="preserve">
          <source>All table rows are structured in the same way. There is a fixed-size header (occupying 23 bytes on most machines), followed by an optional null bitmap, an optional object ID field, and the user data. The header is detailed in &lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;Table 68.4&lt;/a&gt;. The actual user data (columns of the row) begins at the offset indicated by &lt;code&gt;t_hoff&lt;/code&gt;, which must always be a multiple of the MAXALIGN distance for the platform. The null bitmap is only present if the &lt;em&gt;HEAP_HASNULL&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If it is present it begins just after the fixed header and occupies enough bytes to have one bit per data column (that is, the number of bits that equals the attribute count in &lt;code&gt;t_infomask2&lt;/code&gt;). In this list of bits, a 1 bit indicates not-null, a 0 bit is a null. When the bitmap is not present, all columns are assumed not-null. The object ID is only present if the &lt;em&gt;HEAP_HASOID_OLD&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If present, it appears just before the &lt;code&gt;t_hoff&lt;/code&gt; boundary. Any padding needed to make &lt;code&gt;t_hoff&lt;/code&gt; a MAXALIGN multiple will appear between the null bitmap and the object ID. (This in turn ensures that the object ID is suitably aligned.)</source>
          <target state="translated">Все строки таблицы имеют одинаковую структуру. Существует заголовок фиксированного размера (занимающий 23 байта на большинстве машин), за которым следует необязательный нулевой битовый массив, необязательное поле идентификатора объекта и данные пользователя. Заголовок подробно описан в &lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;Таблице 68.4&lt;/a&gt; . Фактические данные пользователя (столбцы строки) начинаются со смещения, указанного &lt;code&gt;t_hoff&lt;/code&gt; , которое всегда должно быть кратным расстоянию MAXALIGN для платформы. Нулевой битовый &lt;em&gt;массив&lt;/em&gt; присутствует только в том случае, если бит &lt;em&gt;HEAP_HASNULL&lt;/em&gt; установлен в &lt;code&gt;t_infomask&lt;/code&gt; . Если он присутствует, он начинается сразу после фиксированного заголовка и занимает достаточно байтов, чтобы иметь один бит на столбец данных (то есть количество битов, равное количеству атрибутов в &lt;code&gt;t_infomask2&lt;/code&gt; ). В этом списке битов 1 бит указывает на ненулевое значение, бит 0 - на null. Если битовая карта отсутствует, все столбцы считаются ненулевыми. Идентификатор объекта присутствует, только если бит &lt;em&gt;HEAP_HASOID_OLD&lt;/em&gt; установлен в &lt;code&gt;t_infomask&lt;/code&gt; . Если присутствует, то появляется непосредственно перед границей &lt;code&gt;t_hoff&lt;/code&gt; . Любое заполнение, необходимое для того, чтобы сделать &lt;code&gt;t_hoff&lt;/code&gt; кратным MAXALIGN, появится между нулевым растровым изображением и идентификатором объекта. (Это, в свою очередь, обеспечивает правильное выравнивание идентификатора объекта.)</target>
        </trans-unit>
        <trans-unit id="07e8311d5ee709346fa3f96903022cdc35bc8edc" translate="yes" xml:space="preserve">
          <source>All tables in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all tables to be moved first and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move tables owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs are not moved by this command; use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER TABLE&lt;/code&gt; invocations instead if desired. The &lt;code&gt;information_schema&lt;/code&gt; relations are not considered part of the system catalogs and will be moved. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="translated">Все таблицы в текущей базе данных в табличном пространстве можно перемещать с помощью формы &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; , которая блокирует все таблицы для перемещения сначала, а затем перемещает каждую из них. Эта форма также поддерживает &lt;code&gt;OWNED BY&lt;/code&gt; , который перемещает только таблицы, принадлежащие указанным ролям. Если указана опция &lt;code&gt;NOWAIT&lt;/code&gt; , команда завершится ошибкой, если она не сможет получить все требуемые блокировки немедленно. Обратите внимание, что системные каталоги не перемещаются этой командой; Использование &lt;code&gt;ALTER DATABASE&lt;/code&gt; или явные &lt;code&gt;ALTER TABLE&lt;/code&gt; вызовы вместо этого , если это необходимо. Отношения &lt;code&gt;information_schema&lt;/code&gt; не считаются частью системных каталогов и будут перемещены. См. Также &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fba1b0761d495deac6051791b1b8f0b77af030f7" translate="yes" xml:space="preserve">
          <source>All the GiST support methods are normally called in short-lived memory contexts; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will get reset after each tuple is processed. It is therefore not very important to worry about pfree'ing everything you palloc. However, in some cases it's useful for a support method to cache data across repeated calls. To do that, allocate the longer-lived data in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt;, and keep a pointer to it in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt;. Such data will survive for the life of the index operation (e.g., a single GiST index scan, index build, or index tuple insertion). Be careful to pfree the previous value when replacing a &lt;code&gt;fn_extra&lt;/code&gt; value, or the leak will accumulate for the duration of the operation.</source>
          <target state="translated">Все методы поддержки GiST обычно вызываются в краткосрочных контекстах памяти; то есть &lt;code&gt;CurrentMemoryContext&lt;/code&gt; будет сбрасываться после обработки каждого кортежа. Поэтому не очень важно беспокоиться о том, чтобы освободить все, что вы перемещаете. Однако в некоторых случаях для метода поддержки полезно кэшировать данные при повторных вызовах. Для этого выделите более долгоживущие данные в &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt; и сохраните указатель на них в &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt; . Такие данные сохранятся в течение всего срока действия индексной операции (например, одно сканирование индекса GiST, построение индекса или вставка кортежа индекса). Будьте осторожны, чтобы освободить предыдущее значение при замене значения &lt;code&gt;fn_extra&lt;/code&gt; , иначе утечка будет накапливаться в течение всей операции.</target>
        </trans-unit>
        <trans-unit id="1775f572f652b9b020df7dce36fbde055a9f9549" translate="yes" xml:space="preserve">
          <source>All the SP-GiST support methods are normally called in a short-lived memory context; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will be reset after processing of each tuple. It is therefore not very important to worry about pfree'ing everything you palloc. (The &lt;code&gt;config&lt;/code&gt; method is an exception: it should try to avoid leaking memory. But usually the &lt;code&gt;config&lt;/code&gt; method need do nothing but assign constants into the passed parameter struct.)</source>
          <target state="translated">Все методы поддержки SP-GiST обычно вызываются в контексте краткосрочной памяти; то есть &lt;code&gt;CurrentMemoryContext&lt;/code&gt; будет сброшен после обработки каждого кортежа. Поэтому не очень важно беспокоиться о том, чтобы освободить все, что вы перемещаете. (Метод &lt;code&gt;config&lt;/code&gt; является исключением: он должен избегать утечки памяти. Но обычно метод &lt;code&gt;config&lt;/code&gt; ничего не делает, кроме присваивания констант в переданную структуру параметров.)</target>
        </trans-unit>
        <trans-unit id="45bde084b879a44097ffbb7f22a89ae3a6f15f28" translate="yes" xml:space="preserve">
          <source>All the actions except &lt;code&gt;RENAME&lt;/code&gt; and &lt;code&gt;SET SCHEMA&lt;/code&gt; can be combined into a list of multiple alterations to apply in parallel. For example, it is possible to add several columns and/or alter the type of several columns in a single command.</source>
          <target state="translated">Все действия, кроме &lt;code&gt;RENAME&lt;/code&gt; и &lt;code&gt;SET SCHEMA&lt;/code&gt; , можно объединить в список из нескольких изменений, которые будут применяться параллельно. Например, можно добавить несколько столбцов и / или изменить тип нескольких столбцов в одной команде.</target>
        </trans-unit>
        <trans-unit id="510081c46bee5d125d10e16db44ba6aa06aa8209" translate="yes" xml:space="preserve">
          <source>All the aggregates listed in &lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;Table 9.57&lt;/a&gt; ignore null values in their sorted input. For those that take a &lt;code&gt;fraction&lt;/code&gt; parameter, the fraction value must be between 0 and 1; an error is thrown if not. However, a null fraction value simply produces a null result.</source>
          <target state="translated">Все агрегаты, перечисленные в &lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;таблице 9.57,&lt;/a&gt; игнорируют нулевые значения в своих отсортированных входных данных. Для тех , которые принимают на &lt;code&gt;fraction&lt;/code&gt; параметр, значение фракции должно быть между 0 и 1; в противном случае выдается ошибка. Однако значение нулевой дроби просто дает нулевой результат.</target>
        </trans-unit>
        <trans-unit id="51ab62b62647a9e48b750694e717b8b41fe65f92" translate="yes" xml:space="preserve">
          <source>All the backslash commands of a given conditional block must appear in the same source file. If EOF is reached on the main input file or an &lt;code&gt;\include&lt;/code&gt;-ed file before all local &lt;code&gt;\if&lt;/code&gt;-blocks have been closed, then psql will raise an error.</source>
          <target state="translated">Все команды с обратной косой чертой данного условного блока должны появляться в одном исходном файле. Если EOF достигается в основном входном файле или файле &lt;code&gt;\include&lt;/code&gt; -ed до закрытия всех локальных &lt;code&gt;\if&lt;/code&gt; -blocks, то psql выдаст ошибку.</target>
        </trans-unit>
        <trans-unit id="c3df3ceb9c111c6a03e79138ef843c3f5502324f" translate="yes" xml:space="preserve">
          <source>All the constraints that refer to the index are changed to refer to the new index definition, and the names of the indexes are changed. At this point, &lt;code&gt;pg_index.indisvalid&lt;/code&gt; is switched to &amp;ldquo;true&amp;rdquo; for the new index and to &amp;ldquo;false&amp;rdquo; for the old, and a cache invalidation is done causing all sessions that referenced the old index to be invalidated.</source>
          <target state="translated">Все ограничения, относящиеся к индексу, изменяются, чтобы ссылаться на новое определение индекса, и имена индексов изменяются. На этом этапе &lt;code&gt;pg_index.indisvalid&lt;/code&gt; переключается на &amp;laquo;true&amp;raquo; для нового индекса и на &amp;laquo;false&amp;raquo; для старого, и выполняется аннулирование кеша, в результате чего все сеансы, ссылающиеся на старый индекс, становятся недействительными.</target>
        </trans-unit>
        <trans-unit id="58e9eb20e27c19e1e0424c58bd8a9c7b575ba760" translate="yes" xml:space="preserve">
          <source>All the date/time data types also accept the special literal value &lt;code&gt;now&lt;/code&gt; to specify the current date and time (again, interpreted as the transaction start time). Thus, the following three all return the same result:</source>
          <target state="translated">Все типы данных даты / времени также принимают специальное буквальное значение &lt;code&gt;now&lt;/code&gt; , чтобы указать текущую дату и время (опять же, интерпретируемое как время начала транзакции). Таким образом, следующие три возвращают один и тот же результат:</target>
        </trans-unit>
        <trans-unit id="04a9db0f3580dacac057df2d96a2b53bd9011eea" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt;.</source>
          <target state="translated">Все подробности можно найти в &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7055165401c8e4a16f7e52ca1e39b100c0c219f9" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt;.</source>
          <target state="translated">Все подробности можно найти в &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11f6c8098d40647f8499682bcc9a9b6ba89c0f7d" translate="yes" xml:space="preserve">
          <source>All the forms of ALTER TABLE that act on a single table, except &lt;code&gt;RENAME&lt;/code&gt;, &lt;code&gt;SET SCHEMA&lt;/code&gt;, &lt;code&gt;ATTACH PARTITION&lt;/code&gt;, and &lt;code&gt;DETACH PARTITION&lt;/code&gt; can be combined into a list of multiple alterations to be applied together. For example, it is possible to add several columns and/or alter the type of several columns in a single command. This is particularly useful with large tables, since only one pass over the table need be made.</source>
          <target state="translated">Все формы ALTER TABLE, которые работают с одной таблицей, за исключением &lt;code&gt;RENAME&lt;/code&gt; , &lt;code&gt;SET SCHEMA&lt;/code&gt; , &lt;code&gt;ATTACH PARTITION&lt;/code&gt; и &lt;code&gt;DETACH PARTITION&lt;/code&gt; , могут быть объединены в список из нескольких изменений, которые будут применяться вместе. Например, можно добавить несколько столбцов и / или изменить тип нескольких столбцов в одной команде. Это особенно полезно для больших таблиц, так как нужно сделать только один проход по таблице.</target>
        </trans-unit>
        <trans-unit id="f31e857d83f608bd0b8b4018bcb4f55f12705482" translate="yes" xml:space="preserve">
          <source>All the functions and operators described below that take &lt;code&gt;time&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt; inputs actually come in two variants: one that takes &lt;code&gt;time with time zone&lt;/code&gt; or &lt;code&gt;timestamp with time zone&lt;/code&gt;, and one that takes &lt;code&gt;time without time zone&lt;/code&gt; or &lt;code&gt;timestamp without time zone&lt;/code&gt;. For brevity, these variants are not shown separately. Also, the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; operators come in commutative pairs (for example both date + integer and integer + date); we show only one of each such pair.</source>
          <target state="translated">Все функции и операторы, описанные ниже, которые принимают &lt;code&gt;timestamp&lt;/code&gt; &lt;code&gt;time&lt;/code&gt; или отметки времени, на самом деле бывают двух вариантов: один, который принимает &lt;code&gt;time with time zone&lt;/code&gt; или &lt;code&gt;timestamp with time zone&lt;/code&gt; , и другой, который принимает &lt;code&gt;time without time zone&lt;/code&gt; или &lt;code&gt;timestamp without time zone&lt;/code&gt; . Для краткости эти варианты отдельно не показаны. Кроме того, операторы &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;*&lt;/code&gt; входят в коммутативные пары (например, как дата + целое число, так и целое число + дата); мы показываем только по одному из каждой такой пары.</target>
        </trans-unit>
        <trans-unit id="782a3c585f1fd27c2deebeab5aeef9142292fec9" translate="yes" xml:space="preserve">
          <source>All the items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; as well as &lt;code&gt;jsonb_insert&lt;/code&gt; except the last item must be present in the &lt;code&gt;target&lt;/code&gt;. If &lt;code&gt;create_missing&lt;/code&gt; is false, all items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; must be present. If these conditions are not met the &lt;code&gt;target&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">Все элементы параметра &lt;code&gt;path&lt;/code&gt; &lt;code&gt;jsonb_set&lt;/code&gt; , а также &lt;code&gt;jsonb_insert&lt;/code&gt; , кроме последнего элемента, должны присутствовать в &lt;code&gt;target&lt;/code&gt; . Если &lt;code&gt;create_missing&lt;/code&gt; - false, должны присутствовать все элементы параметра &lt;code&gt;path&lt;/code&gt; &lt;code&gt;jsonb_set&lt;/code&gt; . Если эти условия не выполняются, &lt;code&gt;target&lt;/code&gt; возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="16b021d730b6ad62e07cfcc798d60a9ae4e55f2d" translate="yes" xml:space="preserve">
          <source>All the other details are the same as explained in the previous item.</source>
          <target state="translated">Все остальные детали такие же,как и в предыдущем пункте.</target>
        </trans-unit>
        <trans-unit id="58d1929aa1a1a6a3046413da0a4c92627889c5ff" translate="yes" xml:space="preserve">
          <source>All the text search functions that accept an optional &lt;code&gt;regconfig&lt;/code&gt; argument will use the configuration specified by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; when that argument is omitted.</source>
          <target state="translated">Все функции текстового поиска, которые принимают необязательный аргумент &lt;code&gt;regconfig&lt;/code&gt; , будут использовать конфигурацию, указанную &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config,&lt;/a&gt; если этот аргумент опущен.</target>
        </trans-unit>
        <trans-unit id="5fd8eaf630761d65327b4b1a07fcbae46e8425a5" translate="yes" xml:space="preserve">
          <source>All these actions are performed using the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command, whose reference page contains details beyond those given here.</source>
          <target state="translated">Все эти действия выполняются с помощью команды &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; , справочная страница которой содержит подробности помимо приведенных здесь.</target>
        </trans-unit>
        <trans-unit id="b94dc0adfca08e05341c41a7517a1ba1c57ee9cc" translate="yes" xml:space="preserve">
          <source>All these functions are intended to be used to lock application-defined resources, which can be identified either by a single 64-bit key value or two 32-bit key values (note that these two key spaces do not overlap). If another session already holds a conflicting lock on the same resource identifier, the functions will either wait until the resource becomes available, or return a &lt;code&gt;false&lt;/code&gt; result, as appropriate for the function. Locks can be either shared or exclusive: a shared lock does not conflict with other shared locks on the same resource, only with exclusive locks. Locks can be taken at session level (so that they are held until released or the session ends) or at transaction level (so that they are held until the current transaction ends; there is no provision for manual release). Multiple session-level lock requests stack, so that if the same resource identifier is locked three times there must then be three unlock requests to release the resource in advance of session end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fddab2dff735a90badf611e7a98983fea7c65273" translate="yes" xml:space="preserve">
          <source>All these functions require object OIDs to identify the object to be checked. If you want to test an object by name, it is convenient to use the OID alias types (&lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, or &lt;code&gt;regdictionary&lt;/code&gt;), for example:</source>
          <target state="translated">Все эти функции требуют OID объекта для идентификации проверяемого объекта. Если вы хотите протестировать объект по имени, удобно использовать типы псевдонимов OID ( &lt;code&gt;regclass&lt;/code&gt; , &lt;code&gt;regtype&lt;/code&gt; , &lt;code&gt;regprocedure&lt;/code&gt; , &lt;code&gt;regoperator&lt;/code&gt; , &lt;code&gt;regconfig&lt;/code&gt; или &lt;code&gt;regdictionary&lt;/code&gt; ), например:</target>
        </trans-unit>
        <trans-unit id="5eb86c80e753870bd74e864dca4813e41a9bf81c" translate="yes" xml:space="preserve">
          <source>All this is encrypted with the session key and placed in the data packet.</source>
          <target state="translated">Все это шифруется ключом сеанса и помещается в пакет данных.</target>
        </trans-unit>
        <trans-unit id="79ae9218d6216a25f546357f769737d4eb8e6a9b" translate="yes" xml:space="preserve">
          <source>All this is happening within the transaction block, so none of it is visible to other database sessions. When and if you commit the transaction block, the committed actions become visible as a unit to other sessions, while the rolled-back actions never become visible at all.</source>
          <target state="translated">Все это происходит в блоке транзакций,поэтому ни один из них не виден другим сеансам БД.Когда и если вы совершаете блок транзакции,то совершенные действия становятся видимыми как единое целое для других сеансов,в то время как откатные действия никогда не становятся видимыми вообще.</target>
        </trans-unit>
        <trans-unit id="f5fad09671c41f98ab40f3e4d5ed6015e3ae8fcb" translate="yes" xml:space="preserve">
          <source>All timezone-aware dates and times are stored internally in UTC. They are converted to local time in the zone specified by the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; configuration parameter before being displayed to the client.</source>
          <target state="translated">Все даты и время с учетом часовых поясов хранятся внутри в формате UTC. Они преобразуются в местное время в зоне, указанной параметром конфигурации &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone,&lt;/a&gt; перед отображением для клиента.</target>
        </trans-unit>
        <trans-unit id="d5322b3927e2a3af2ef8b19f81ff10045b29cd91" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfrozenxid&lt;/code&gt; values.</source>
          <target state="translated">Все идентификаторы транзакции до этого были заменены постоянным (&amp;laquo;замороженным&amp;raquo;) идентификатором транзакции в этой базе данных. Это используется для отслеживания того, нужно ли очистить базу данных, чтобы предотвратить &lt;code&gt;pg_xact&lt;/code&gt; идентификатора транзакции или разрешить сжатие pg_xact . Это минимум для таблицы &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;relfrozenxid&lt;/code&gt; значения.</target>
        </trans-unit>
        <trans-unit id="086e1ad2933d663306e6cec529b31029a01389df" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidTransactionId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">Все идентификаторы транзакции до этого были заменены постоянным (&amp;laquo;замороженным&amp;raquo;) идентификатором транзакции в этой таблице. Это используется для отслеживания того, нужно ли очистить таблицу, чтобы предотвратить &lt;code&gt;pg_xact&lt;/code&gt; идентификатора транзакции или разрешить сжатие pg_xact . Ноль ( &lt;code&gt;InvalidTransactionId&lt;/code&gt; ), если отношение не является таблицей.</target>
        </trans-unit>
        <trans-unit id="f420391c504d54ccc175474041008eed502760b8" translate="yes" xml:space="preserve">
          <source>All type conversion rules are designed with several principles in mind:</source>
          <target state="translated">Все правила приведения типов разработаны с учетом нескольких принципов:</target>
        </trans-unit>
        <trans-unit id="109d3489123ca72cb87beebd6d4f929a800626a1" translate="yes" xml:space="preserve">
          <source>All values must be single-quoted. Escape single quotes used within a value with a backslash. Backslashes meant as data can, but need not, be doubled; this follows Perl's rules for simple quoted literals. Note that backslashes appearing as data will be treated as escapes by the bootstrap scanner, according to the same rules as for escape string constants (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;); for example &lt;code&gt;\t&lt;/code&gt; converts to a tab character. If you actually want a backslash in the final value, you will need to write four of them: Perl strips two, leaving &lt;code&gt;\\&lt;/code&gt; for the bootstrap scanner to see.</source>
          <target state="translated">Все значения должны быть заключены в одинарные кавычки. Избегайте использования одинарных кавычек внутри значения с помощью обратной косой черты. Обратные косые черты, обозначающие данные, можно, но не обязательно, удвоить; это следует правилам Perl для простых литералов в кавычках. Обратите внимание, что обратная косая черта, появляющаяся как данные, будет рассматриваться сканером начальной загрузки как escape-символы в соответствии с теми же правилами, что и для констант escape-строки (см. &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Раздел 4.1.2.2&lt;/a&gt; ); например &lt;code&gt;\t&lt;/code&gt; преобразуется в символ табуляции. Если вам действительно нужна обратная косая черта в окончательном значении, вам нужно будет написать четыре из них: Perl удаляет два, оставляя &lt;code&gt;\\&lt;/code&gt; для просмотра сканером начальной загрузки.</target>
        </trans-unit>
        <trans-unit id="b86517f687c2cdb1c2c9f1b4d883ebc3f627ec3f" translate="yes" xml:space="preserve">
          <source>All weather records belonging to Hayward are removed.</source>
          <target state="translated">Все записи о погоде,принадлежащие Хэйворду,удалены.</target>
        </trans-unit>
        <trans-unit id="ad7019350bb4e8cf04fe867a5271fe82db68f450" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Andrey Oktyabrski did a great work on adding new functions and operations.</source>
          <target state="translated">Всю работу проделали Теодор Сигаев ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; ) и Олег Бартунов ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ). См. &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;Http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; для получения дополнительной информации. Андрей Октябрьский отлично поработал над добавлением новых функций и операций.</target>
        </trans-unit>
        <trans-unit id="4288707b0efed23059331a4d938505610024687d" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Authors would like to thank Eugeny Rodichev for helpful discussions. Comments and bug reports are welcome.</source>
          <target state="translated">Всю работу проделали Теодор Сигаев ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt; ) и Олег Бартунов ( &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ). См. &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;Http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; для получения дополнительной информации. Авторы выражают благодарность Евгению Родичеву за полезные обсуждения. Комментарии и сообщения об ошибках приветствуются.</target>
        </trans-unit>
        <trans-unit id="f34719d5f269658e4173abae81da05904e2f90b4" translate="yes" xml:space="preserve">
          <source>Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.</source>
          <target state="translated">Разрешить выполнение программ на сервере базы данных как пользователю,который работает с базой данных,так и с COPY и другими функциями,которые позволяют выполнять программы на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="cb7c466538ce28419fa5a720e552c9faf281f480" translate="yes" xml:space="preserve">
          <source>Allow question mark as placeholder for compatibility reasons. This used to be the default long ago.</source>
          <target state="translated">Разрешите поставить знак вопроса в качестве владельца по соображениям совместимости.Давным-давно это было по умолчанию.</target>
        </trans-unit>
        <trans-unit id="45c4206b6f2ee2080c8508868577dbea292b358b" translate="yes" xml:space="preserve">
          <source>Allow reading files from any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">Разрешить чтение файлов из любого места,к которому база данных может получить доступ на сервере с помощью COPY и других функций доступа к файлам.</target>
        </trans-unit>
        <trans-unit id="4f03ae30c79df36f9c350de6f69bb0b74ebd9a17" translate="yes" xml:space="preserve">
          <source>Allow the connection unconditionally. This method allows anyone that can connect to the PostgreSQL database server to login as any PostgreSQL user they wish, without the need for a password or any other authentication. See &lt;a href=&quot;auth-trust&quot;&gt;Section 20.4&lt;/a&gt; for details.</source>
          <target state="translated">Разрешить соединение безоговорочно. Этот метод позволяет любому, кто может подключиться к серверу базы данных PostgreSQL, войти в систему как любой пользователь PostgreSQL по своему желанию, без необходимости ввода пароля или какой-либо другой аутентификации. Смотрите &lt;a href=&quot;auth-trust&quot;&gt;раздел 20.4&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="015b98532a3fe432082ea0986c77ac2b5c3dbd03" translate="yes" xml:space="preserve">
          <source>Allow writing to files in any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">Разрешить запись в файлы в любом месте,к которому база данных может получить доступ на сервере с помощью COPY и других функций доступа к файлам.</target>
        </trans-unit>
        <trans-unit id="f8d71f61a1ee50e974ca597aaf1819fc96625f9e" translate="yes" xml:space="preserve">
          <source>Allowed Access</source>
          <target state="translated">Разрешенный доступ</target>
        </trans-unit>
        <trans-unit id="76b9c247fd0d4d88ff31bffe6ae1c77fef7baa54" translate="yes" xml:space="preserve">
          <source>Allowed values of an enum parameter (null for non-enum values)</source>
          <target state="translated">Разрешенные значения перечислительного параметра (нулевые для неперечисленных значений)</target>
        </trans-unit>
        <trans-unit id="52773c9887de8a80602d4df5e04153e486ddd9ba" translate="yes" xml:space="preserve">
          <source>Allowed, but not in PG</source>
          <target state="translated">Разрешено,но не в PG</target>
        </trans-unit>
        <trans-unit id="70154177253445e1612a606653b6fcdbcd216626" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; of a row from a table, view, etc. (In practice, any nontrivial &lt;code&gt;DELETE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to delete.)</source>
          <target state="translated">Позволяет &lt;a href=&quot;sql-delete&quot;&gt;УДАЛИТЬ&lt;/a&gt; строку из таблицы, представления и т. Д. (На практике для любой нетривиальной команды &lt;code&gt;DELETE&lt;/code&gt; также потребуется привилегия &lt;code&gt;SELECT&lt;/code&gt; , поскольку она должна ссылаться на столбцы таблицы, чтобы определить, какие строки следует удалить.)</target>
        </trans-unit>
        <trans-unit id="892a331d54a97c6a90c5cbe15f359d1d4e9d66bd" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; of a new row into a table, view, etc. Can be granted on specific column(s), in which case only those columns may be assigned to in the &lt;code&gt;INSERT&lt;/code&gt; command (other columns will therefore receive default values). Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROM.</source>
          <target state="translated">Разрешает &lt;a href=&quot;sql-insert&quot;&gt;ВСТАВИТЬ&lt;/a&gt; новую строку в таблицу, представление и т. Д. Может быть предоставлено для определенного столбца (столбцов), и в этом случае только эти столбцы могут быть назначены в команде &lt;code&gt;INSERT&lt;/code&gt; (поэтому другие столбцы получат значения по умолчанию). Также позволяет использовать &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROM.</target>
        </trans-unit>
        <trans-unit id="91a5de46959e59448d7fbb7e22418ff9bdc9f1e0" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; from any column, or specific column(s), of a table, view, materialized view, or other table-like object. Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TO. This privilege is also needed to reference existing column values in &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;. For sequences, this privilege also allows use of the &lt;code&gt;currval&lt;/code&gt; function. For large objects, this privilege allows the object to be read.</source>
          <target state="translated">Позволяет &lt;a href=&quot;sql-select&quot;&gt;ВЫБРАТЬ&lt;/a&gt; из любого столбца или определенного столбца (столбцов) таблицы, представления, материализованного представления или другого табличного объекта. Также позволяет использовать &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TO. Эта привилегия также необходима для ссылки на существующие значения столбцов в &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; или &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; . Для последовательностей эта привилегия также позволяет использовать функцию &lt;code&gt;currval&lt;/code&gt; . Для больших объектов эта привилегия позволяет читать объект.</target>
        </trans-unit>
        <trans-unit id="504fe161b61ac15d1f6a3f6705ae69c3e419baf8" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; on a table, view, etc.</source>
          <target state="translated">Позволяет &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; для таблицы, просмотра и т. Д.</target>
        </trans-unit>
        <trans-unit id="82bfc74ea2d5fe544ab86144ec140977da660bfb" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; of any column, or specific column(s), of a table, view, etc. (In practice, any nontrivial &lt;code&gt;UPDATE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to update, and/or to compute new values for columns.) &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; also require this privilege on at least one column, in addition to the &lt;code&gt;SELECT&lt;/code&gt; privilege. For sequences, this privilege allows use of the &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; functions. For large objects, this privilege allows writing or truncating the object.</source>
          <target state="translated">Разрешает &lt;a href=&quot;sql-update&quot;&gt;ОБНОВЛЕНИЕ&lt;/a&gt; любого столбца или определенного столбца (столбцов) таблицы, представления и т. Д. (На практике для любой нетривиальной команды &lt;code&gt;UPDATE&lt;/code&gt; также потребуется привилегия &lt;code&gt;SELECT&lt;/code&gt; , поскольку она должна ссылаться на столбцы таблицы, чтобы определить, какие строки следует обновить, и / или для вычисления новых значений для столбцов.) &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; и &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; также требуют этой привилегии по крайней мере для одного столбца в дополнение к привилегии &lt;code&gt;SELECT&lt;/code&gt; . Для последовательностей эта привилегия позволяет использовать функции &lt;code&gt;nextval&lt;/code&gt; и &lt;code&gt;setval&lt;/code&gt; . Для больших объектов эта привилегия позволяет писать или обрезать объект.</target>
        </trans-unit>
        <trans-unit id="8b7544659291101bf531ad89a7c0f68e28dd25e9" translate="yes" xml:space="preserve">
          <source>Allows calling a function or procedure, including use of any operators that are implemented on top of the function. This is the only type of privilege that is applicable to functions and procedures.</source>
          <target state="translated">Позволяет вызывать функции или процедуры,включая использование любых операторов,которые реализованы поверх функции.Это единственный тип привилегий,применимый к функциям и процедурам.</target>
        </trans-unit>
        <trans-unit id="572f9c4ee818f964a8f341a7ab3b49d87de0de38" translate="yes" xml:space="preserve">
          <source>Allows creation of a foreign key constraint referencing a table, or specific column(s) of a table.</source>
          <target state="translated">Позволяет создать ограничение по внешнему ключу,ссылающемуся на таблицу или конкретный столбец (столбцы)таблицы.</target>
        </trans-unit>
        <trans-unit id="3f1fc4350d1383af032d326e29b30797181bb0ee" translate="yes" xml:space="preserve">
          <source>Allows creation of a trigger on a table, view, etc.</source>
          <target state="translated">Позволяет создавать триггер на таблице,представлении и т.д.</target>
        </trans-unit>
        <trans-unit id="d221a1c104e0d63607ae68533525fac6cb3d90ab" translate="yes" xml:space="preserve">
          <source>Allows definition of user-visible parameters that control operator class behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd1d90a2a8e348dc3397a5abdad6812b9706afc" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details.</source>
          <target state="translated">Позволяет сопоставить имена пользователей системы и базы данных. См &lt;a href=&quot;auth-username-maps&quot;&gt;раздел 20.2&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="62730a57186fa6b4b57c86a98eed1f6819a0f0da" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a GSSAPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">Позволяет сопоставить имена пользователей системы и базы данных. См &lt;a href=&quot;auth-username-maps&quot;&gt;раздел 20.2&lt;/a&gt; для деталей. Для участника GSSAPI / Kerberos, такого как &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (или, реже, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; ), имя пользователя, используемое для сопоставления, - &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (или &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; . соответственно), если для &lt;code&gt;include_realm&lt;/code&gt; не установлено значение 0, и в этом случае &lt;code&gt;username&lt;/code&gt; (или &lt;code&gt;username/hostbased&lt;/code&gt; ) - это то, что отображается как имя пользователя системы при сопоставлении.</target>
        </trans-unit>
        <trans-unit id="3a8e3ba433eb210e869a35f227d0944a825933f7" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a SSPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">Позволяет сопоставить имена пользователей системы и базы данных. См &lt;a href=&quot;auth-username-maps&quot;&gt;раздел 20.2&lt;/a&gt; для деталей. Для участника SSPI / Kerberos, такого как &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (или, реже, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; ), имя пользователя, используемое для сопоставления, - &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (или &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; соответственно), если для &lt;code&gt;include_realm&lt;/code&gt; не было установлено значение 0, и в этом случае &lt;code&gt;username&lt;/code&gt; (или &lt;code&gt;username/hostbased&lt;/code&gt; ) - это то, что отображается как имя пользователя системы при сопоставлении.</target>
        </trans-unit>
        <trans-unit id="20552df65c50fc0052b6d2499b3762b86d6eff44" translate="yes" xml:space="preserve">
          <source>Allows modification of the structure of system tables as well as certain other risky actions on system tables. This is otherwise not allowed even for superusers. Ill-advised use of this setting can cause irretrievable data loss or seriously corrupt the database system. Only superusers can change this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64278e6ff1ecca0c4404ebfb33c1f4ece933ea1" translate="yes" xml:space="preserve">
          <source>Allows modification of the structure of system tables. This is used by &lt;code&gt;initdb&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">Позволяет изменять структуру системных таблиц. Это используется &lt;code&gt;initdb&lt;/code&gt; . Этот параметр можно установить только при запуске сервера.</target>
        </trans-unit>
        <trans-unit id="f71053472aff6714ed79ad6bf71416990ec41156" translate="yes" xml:space="preserve">
          <source>Allows multiple master servers</source>
          <target state="translated">Позволяет несколько главных серверов</target>
        </trans-unit>
        <trans-unit id="7e9d5d5ab57892df439ee070a4596c150e6f73e7" translate="yes" xml:space="preserve">
          <source>Allows remote clients to connect via TCP/IP (Internet domain) connections. Without this option, only local connections are accepted. This option is equivalent to setting &lt;code&gt;listen_addresses&lt;/code&gt; to &lt;code&gt;*&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; or via &lt;code&gt;-h&lt;/code&gt;.</source>
          <target state="translated">Позволяет удаленным клиентам подключаться через TCP / IP (Интернет-домен). Без этой опции принимаются только локальные соединения. Эта опция эквивалентна установке параметра &lt;code&gt;listen_addresses&lt;/code&gt; на &lt;code&gt;*&lt;/code&gt; в &lt;code&gt;postgresql.conf&lt;/code&gt; или через &lt;code&gt;-h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="003e89305b8189195bfe70e6a4f7ecd0e58a566e" translate="yes" xml:space="preserve">
          <source>Allows sampling the duration of completed statements that ran for at least the specified amount of time. This produces the same kind of log entries as &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt;, but only for a subset of the executed statements, with sample rate controlled by &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT-SAMPLE-RATE&quot;&gt;log_statement_sample_rate&lt;/a&gt;. For example, if you set it to &lt;code&gt;100ms&lt;/code&gt; then all SQL statements that run 100ms or longer will be considered for sampling. Enabling this parameter can be helpful when the traffic is too high to log all queries. If this value is specified without units, it is taken as milliseconds. Setting this to zero samples all statement durations. &lt;code&gt;-1&lt;/code&gt; (the default) disables sampling statement durations. Only superusers can change this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63eeac10a55f83f249e5c5462559d1f7da0f93f8" translate="yes" xml:space="preserve">
          <source>Allows temporary tables to be created while using the database.</source>
          <target state="translated">Позволяет создавать временные таблицы при использовании БД.</target>
        </trans-unit>
        <trans-unit id="08e9a64b986b6e59ae70cdec6ed43f46a0d1ac74" translate="yes" xml:space="preserve">
          <source>Allows the grantee to connect to the database. This privilege is checked at connection startup (in addition to checking any restrictions imposed by &lt;code&gt;pg_hba.conf&lt;/code&gt;).</source>
          <target state="translated">Разрешает грантополучателю подключиться к базе данных. Эта привилегия проверяется при запуске соединения (помимо проверки любых ограничений, налагаемых &lt;code&gt;pg_hba.conf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="755cae42faeb86185341cbd11d37dba18dac7fda" translate="yes" xml:space="preserve">
          <source>Allows the leader process to execute the query plan under &lt;code&gt;Gather&lt;/code&gt; and &lt;code&gt;Gather Merge&lt;/code&gt; nodes instead of waiting for worker processes. The default is &lt;code&gt;on&lt;/code&gt;. Setting this value to &lt;code&gt;off&lt;/code&gt; reduces the likelihood that workers will become blocked because the leader is not reading tuples fast enough, but requires the leader process to wait for worker processes to start up before the first tuples can be produced. The degree to which the leader can help or hinder performance depends on the plan type, number of workers and query duration.</source>
          <target state="translated">Позволяет ведущему процессу выполнять план запроса в узлах &lt;code&gt;Gather&lt;/code&gt; и &lt;code&gt;Gather Merge&lt;/code&gt; вместо ожидания рабочих процессов. По умолчанию &lt;code&gt;on&lt;/code&gt; . Установка этого значения на &lt;code&gt;off&lt;/code&gt; снижает вероятность того, что рабочие процессы будут заблокированы, потому что ведущий не читает кортежи достаточно быстро, но требует, чтобы ведущий процесс ждал запуска рабочих процессов, прежде чем первые кортежи могут быть созданы. Степень, в которой лидер может помочь или снизить производительность, зависит от типа плана, количества рабочих и продолжительности запроса.</target>
        </trans-unit>
        <trans-unit id="65de6c1d93f488d023688afb5ecd9e64a2816fb2" translate="yes" xml:space="preserve">
          <source>Allows the structure of system tables to be modified. This is used by &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">Позволяет изменять структуру системных таблиц. Это используется &lt;code&gt;initdb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3d21c22361245b017a84ef20398543e1812a86" translate="yes" xml:space="preserve">
          <source>Allows the use of parallel queries for testing purposes even in cases where no performance benefit is expected. The allowed values of &lt;code&gt;force_parallel_mode&lt;/code&gt; are &lt;code&gt;off&lt;/code&gt; (use parallel mode only when it is expected to improve performance), &lt;code&gt;on&lt;/code&gt; (force parallel query for all queries for which it is thought to be safe), and &lt;code&gt;regress&lt;/code&gt; (like &lt;code&gt;on&lt;/code&gt;, but with additional behavior changes as explained below).</source>
          <target state="translated">Позволяет использовать параллельные запросы для целей тестирования даже в тех случаях, когда не ожидается увеличения производительности. Допустимые значения &lt;code&gt;force_parallel_mode&lt;/code&gt; находятся &lt;code&gt;off&lt;/code&gt; (режим использования параллельно только тогда , когда ожидаются улучшение производительности), &lt;code&gt;on&lt;/code&gt; (силу параллельных запросов для всех запросов , для которых , как считается, быть безопасными), и &lt;code&gt;regress&lt;/code&gt; (как &lt;code&gt;on&lt;/code&gt; , но с дополнительными изменениями в поведении как объяснено ниже).</target>
        </trans-unit>
        <trans-unit id="8f83e0d9b7de16d5d69bb100f20671e8c51dd641" translate="yes" xml:space="preserve">
          <source>Allows users in the same group as the cluster owner to read all cluster files created by &lt;code&gt;initdb&lt;/code&gt;. This option is ignored on Windows as it does not support POSIX-style group permissions.</source>
          <target state="translated">Позволяет пользователям в той же группе, что и владелец кластера, читать все файлы кластера, созданные &lt;code&gt;initdb&lt;/code&gt; . Этот параметр игнорируется в Windows, поскольку он не поддерживает разрешения для групп в стиле POSIX.</target>
        </trans-unit>
        <trans-unit id="4cc45bc94d25b1e0d694fb6d8a93df9410ca68c9" translate="yes" xml:space="preserve">
          <source>Almost all &lt;code&gt;DROP&lt;/code&gt; commands in PostgreSQL support specifying &lt;code&gt;CASCADE&lt;/code&gt;. Of course, the nature of the possible dependencies varies with the type of the object. You can also write &lt;code&gt;RESTRICT&lt;/code&gt; instead of &lt;code&gt;CASCADE&lt;/code&gt; to get the default behavior, which is to prevent dropping objects that any other objects depend on.</source>
          <target state="translated">Почти все команды &lt;code&gt;DROP&lt;/code&gt; в PostgreSQL поддерживают указание &lt;code&gt;CASCADE&lt;/code&gt; . Конечно, характер возможных зависимостей зависит от типа объекта. Вы также можете написать &lt;code&gt;RESTRICT&lt;/code&gt; вместо &lt;code&gt;CASCADE&lt;/code&gt; , чтобы получить поведение по умолчанию, то есть предотвратить удаление объектов, от которых зависят любые другие объекты.</target>
        </trans-unit>
        <trans-unit id="328cfccc1cde2a65060e2ec7ece0e64b0b2e4b32" translate="yes" xml:space="preserve">
          <source>Also be careful when making up test data, which is often unavoidable when the application is not yet in production. Values that are very similar, completely random, or inserted in sorted order will skew the statistics away from the distribution that real data would have.</source>
          <target state="translated">Также будьте осторожны при составлении тестовых данных,что часто неизбежно,когда приложение еще не находится в производстве.Значения,которые очень похожи,полностью случайны или вставлены в отсортированном порядке,будут искажать статистику от распределения,которое имели бы реальные данные.</target>
        </trans-unit>
        <trans-unit id="1e6eb3c256a63ce7e1a4b490a67bfd7124a09fa5" translate="yes" xml:space="preserve">
          <source>Also calculate statistics for use by the optimizer.</source>
          <target state="translated">Также вычисляется статистика для использования оптимизатором.</target>
        </trans-unit>
        <trans-unit id="1310f648148c138c431f0390dd1598c9ea4cf18b" translate="yes" xml:space="preserve">
          <source>Also known as &lt;em&gt;WAL segment&lt;/em&gt; or &lt;em&gt;WAL segment file&lt;/em&gt;. Each of the sequentially-numbered files that provide storage space for &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. The files are all of the same predefined size and are written in sequential order, interspersing changes as they occur in multiple simultaneous sessions. If the system crashes, the files are read in order, and each of the changes is replayed to restore the system to the state it was in before the crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5b262e2738c5ae943ae295de4ef09eb42b98a8" translate="yes" xml:space="preserve">
          <source>Also note that some element types, such as &lt;code&gt;timestamp&lt;/code&gt;, have a notion of &quot;infinity&quot;, which is just another value that can be stored. This is different from &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt;, which are not real values that can be stored, but rather they are ways of saying that the value is unbounded. &lt;code&gt;MAXVALUE&lt;/code&gt; can be thought of as being greater than any other value, including &quot;infinity&quot; and &lt;code&gt;MINVALUE&lt;/code&gt; as being less than any other value, including &quot;minus infinity&quot;. Thus the range &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; is not an empty range; it allows precisely one value to be stored &amp;mdash; &quot;infinity&quot;.</source>
          <target state="translated">Также обратите внимание, что некоторые типы элементов, такие как &lt;code&gt;timestamp&lt;/code&gt; , имеют понятие &amp;laquo;бесконечность&amp;raquo;, которое является просто еще одним значением, которое можно сохранить. Это отличается от &lt;code&gt;MINVALUE&lt;/code&gt; и &lt;code&gt;MAXVALUE&lt;/code&gt; , которые не являются реальными значениями, которые могут быть сохранены, а скорее являются способами сказать, что значение не ограничено. &lt;code&gt;MAXVALUE&lt;/code&gt; можно рассматривать как большее, чем любое другое значение, включая &amp;laquo;бесконечность&amp;raquo;, а &lt;code&gt;MINVALUE&lt;/code&gt; как меньшее, чем любое другое значение, включая &amp;laquo;минус бесконечность&amp;raquo;. Таким образом, диапазон &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; не является пустым диапазоном; он позволяет хранить ровно одно значение - &amp;laquo;бесконечность&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7722ff63b95d490d6107aefdee57299789fdc839" translate="yes" xml:space="preserve">
          <source>Also of note to those converting from other environments is the fact that &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; does not ensure that a concurrent transaction will not update or delete a selected row. To do that in PostgreSQL you must actually update the row, even if no values need to be changed. &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;&lt;em&gt;temporarily blocks&lt;/em&gt; other transactions from acquiring the same lock or executing an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; which would affect the locked row, but once the transaction holding this lock commits or rolls back, a blocked transaction will proceed with the conflicting operation unless an actual &lt;code&gt;UPDATE&lt;/code&gt; of the row was performed while the lock was held.</source>
          <target state="translated">Также для тех, кто выполняет преобразование из других сред, следует отметить тот факт, что &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; не гарантирует, что параллельная транзакция не обновит или не удалит выбранную строку. Для этого в PostgreSQL вы должны фактически обновить строку, даже если значения изменять не нужно. &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; &lt;em&gt;временно блокирует&lt;/em&gt; другие транзакции от получения той же блокировки или выполнения &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; , которые могут повлиять на заблокированную строку, но как только транзакция, содержащая эту блокировку, фиксируется или откатывается, заблокированная транзакция продолжит конфликтную операцию, если только не будет выполнено фактическое &lt;code&gt;UPDATE&lt;/code&gt; ряда выполнялось при удерживании замка.</target>
        </trans-unit>
        <trans-unit id="89140b7833f6956c6f82e686c2158ff1b251e443" translate="yes" xml:space="preserve">
          <source>Also see the prefix operator &lt;code&gt;^@&lt;/code&gt; and corresponding &lt;code&gt;starts_with&lt;/code&gt; function, which are useful in cases where simply matching the beginning of a string is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ae5053feb0121ca9119b68bf8c270c3a3bfe40" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;INHERITS&lt;/code&gt;, columns and constraints copied by &lt;code&gt;LIKE&lt;/code&gt; are not merged with similarly named columns and constraints. If the same name is specified explicitly or in another &lt;code&gt;LIKE&lt;/code&gt; clause, an error is signaled.</source>
          <target state="translated">Также, в отличие от &lt;code&gt;INHERITS&lt;/code&gt; , столбцы и ограничения, скопированные &lt;code&gt;LIKE&lt;/code&gt; , не объединяются с одноименными столбцами и ограничениями. Если то же имя указано явно или в другом предложении &lt;code&gt;LIKE&lt;/code&gt; , выдается сигнал об ошибке.</target>
        </trans-unit>
        <trans-unit id="4bd7db918c0ec048fb1da60e94aef9f53bffd77b" translate="yes" xml:space="preserve">
          <source>Also you can use an index on the &lt;code&gt;t&lt;/code&gt; column for word similarity or strict word similarity. Typical queries are:</source>
          <target state="translated">Также вы можете использовать индекс в столбце &lt;code&gt;t&lt;/code&gt; для определения сходства слов или строгого сходства слов. Типичные запросы:</target>
        </trans-unit>
        <trans-unit id="d4ce61ad95c8576f718ac10e1c2327127884475a" translate="yes" xml:space="preserve">
          <source>Also you can use the standard SQL syntax &lt;code&gt;SET NAMES&lt;/code&gt; for this purpose:</source>
          <target state="translated">Также для этой цели можно использовать стандартный синтаксис SQL &lt;code&gt;SET NAMES&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a6c555a30398b57943351e6fa4960aad56c86fc4" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;*&lt;/code&gt; can be attached to a lexeme to specify prefix matching:</source>
          <target state="translated">Кроме того, &lt;code&gt;*&lt;/code&gt; можно добавить к лексеме, чтобы указать соответствие префикса:</target>
        </trans-unit>
        <trans-unit id="9a92606f5ea158e9240f422542ed2e1cf20e61fc" translate="yes" xml:space="preserve">
          <source>Also, GIN index supports &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, which perform &lt;code&gt;jsonpath&lt;/code&gt; matching.</source>
          <target state="translated">Кроме того, индекс GIN поддерживает &lt;code&gt;@@&lt;/code&gt; и &lt;code&gt;@?&lt;/code&gt; операторы, которые выполняют сопоставление &lt;code&gt;jsonpath&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33ec741b0c71e2493174674607bdd7cee851a3f4" translate="yes" xml:space="preserve">
          <source>Also, a reverse lookup is necessary to implement the suffix matching feature, because the actual client host name needs to be known in order to match it against the pattern.</source>
          <target state="translated">Кроме того,для реализации функции сопоставления суффиксов необходим обратный поиск,так как действительное имя хоста клиента должно быть известно,чтобы сопоставить его с шаблоном.</target>
        </trans-unit>
        <trans-unit id="dbee7ce8bd2c9aaff2ced252585c86f91ebda134" translate="yes" xml:space="preserve">
          <source>Also, a trigger definition can specify a Boolean &lt;code&gt;WHEN&lt;/code&gt; condition, which will be tested to see whether the trigger should be fired. In row-level triggers the &lt;code&gt;WHEN&lt;/code&gt; condition can examine the old and/or new values of columns of the row. Statement-level triggers can also have &lt;code&gt;WHEN&lt;/code&gt; conditions, although the feature is not so useful for them since the condition cannot refer to any values in the table.</source>
          <target state="translated">Кроме того, в определении триггера можно указать логическое условие &lt;code&gt;WHEN&lt;/code&gt; , которое будет проверено, чтобы определить, следует ли запускать триггер. В триггерах на уровне строки условие &lt;code&gt;WHEN&lt;/code&gt; может проверять старые и / или новые значения столбцов строки. Триггеры на уровне оператора также могут иметь условия &lt;code&gt;WHEN&lt;/code&gt; , хотя эта функция для них не так полезна, поскольку условие не может ссылаться ни на какие значения в таблице.</target>
        </trans-unit>
        <trans-unit id="51c091c0aef22b8b4cc2fa3614299c508ab0362c" translate="yes" xml:space="preserve">
          <source>Also, by default there is limited information available about the selectivity of functions. However, if you create an expression index that uses a function call, useful statistics will be gathered about the function, which can greatly improve query plans that use the expression index.</source>
          <target state="translated">Кроме того,по умолчанию имеется ограниченная информация о селективности функций.Однако,если вы создадите индекс выражений,использующих вызов функции,то будет собрана полезная статистика о функции,которая может значительно улучшить планы запросов,использующих индекс выражений.</target>
        </trans-unit>
        <trans-unit id="918098440d0526280449d26ec531d4e4ea959670" translate="yes" xml:space="preserve">
          <source>Also, for B-tree indexes, a freshly-constructed index is slightly faster to access than one that has been updated many times because logically adjacent pages are usually also physically adjacent in a newly built index. (This consideration does not apply to non-B-tree indexes.) It might be worthwhile to reindex periodically just to improve access speed.</source>
          <target state="translated">Кроме того,для индексов B-дерева доступ к свежему индексу несколько быстрее,чем к индексу,который обновлялся много раз,потому что логически соседние страницы обычно также физически соседствуют в только что построенном индексе.(Это соображение не относится к индексам не B-дерева.)Возможно,было бы целесообразно периодически проводить реиндексацию только для того,чтобы увеличить скорость доступа.</target>
        </trans-unit>
        <trans-unit id="be3a3382ab5cfef83a6b9ee1e118c05d47eb696d" translate="yes" xml:space="preserve">
          <source>Also, for data types for which there is a natural distance metric, &lt;code&gt;btree_gist&lt;/code&gt; defines a distance operator &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and provides GiST index support for nearest-neighbor searches using this operator. Distance operators are provided for &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float4&lt;/code&gt;, &lt;code&gt;float8&lt;/code&gt;, &lt;code&gt;timestamp with time zone&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, &lt;code&gt;time without time zone&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, and &lt;code&gt;money&lt;/code&gt;.</source>
          <target state="translated">Кроме того, для типов данных, для которых существует метрика естественного расстояния, &lt;code&gt;btree_gist&lt;/code&gt; определяет оператор расстояния &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; и обеспечивает поддержку индекса GiST для поиска ближайшего соседа с использованием этого оператора. Операторы расстояния предоставляются для &lt;code&gt;int2&lt;/code&gt; , &lt;code&gt;int4&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;float4&lt;/code&gt; , &lt;code&gt;float8&lt;/code&gt; , &lt;code&gt;timestamp with time zone&lt;/code&gt; , &lt;code&gt;timestamp without time zone&lt;/code&gt; , &lt;code&gt;time without time zone&lt;/code&gt; , &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;interval&lt;/code&gt; , &lt;code&gt;oid&lt;/code&gt; и &lt;code&gt;money&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf0cd04ab9ab1bc3d1ec06d42e614cb3d497974a" translate="yes" xml:space="preserve">
          <source>Also, if you are using prepared transactions, the &lt;code&gt;virtualtransaction&lt;/code&gt; column can be joined to the &lt;code&gt;transaction&lt;/code&gt; column of the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; view to get more information on prepared transactions that hold locks. (A prepared transaction can never be waiting for a lock, but it continues to hold the locks it acquired while running.) For example:</source>
          <target state="translated">Кроме того, если вы используете подготовленные транзакции, столбец &lt;code&gt;virtualtransaction&lt;/code&gt; может быть присоединен к столбцу &lt;code&gt;transaction&lt;/code&gt; представления &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; ,&lt;/a&gt; чтобы получить дополнительную информацию о подготовленных транзакциях, содержащих блокировки. (Подготовленная транзакция никогда не может ожидать блокировки, но она продолжает удерживать блокировки, полученные во время выполнения.) Например:</target>
        </trans-unit>
        <trans-unit id="2258b90b04fd050fcb19ba25fa34dc828faad6f7" translate="yes" xml:space="preserve">
          <source>Also, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with &lt;code&gt;*&lt;/code&gt; to specify prefix matching:</source>
          <target state="translated">Кроме того, лексемы в &lt;code&gt;tsquery&lt;/code&gt; могут быть помечены &lt;code&gt;*&lt;/code&gt; , чтобы указать соответствие префикса:</target>
        </trans-unit>
        <trans-unit id="d1e5125c3a43842c6c788a2be18af72f0169e16b" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;myschema&lt;/code&gt; is the first element in the path, new objects would by default be created in it.</source>
          <target state="translated">Кроме того, поскольку &lt;code&gt;myschema&lt;/code&gt; является первым элементом в пути, по умолчанию в нем будут создаваться новые объекты.</target>
        </trans-unit>
        <trans-unit id="706af9f63feb30c802747e00ad8bdfe7aa3a186c" translate="yes" xml:space="preserve">
          <source>Also, some element types have a notion of &amp;ldquo;infinity&amp;rdquo;, but that is just another value so far as the range type mechanisms are concerned. For example, in timestamp ranges, &lt;code&gt;[today,]&lt;/code&gt; means the same thing as &lt;code&gt;[today,)&lt;/code&gt;. But &lt;code&gt;[today,infinity]&lt;/code&gt; means something different from &lt;code&gt;[today,infinity)&lt;/code&gt; &amp;mdash; the latter excludes the special &lt;code&gt;timestamp&lt;/code&gt; value &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">Кроме того, некоторые типы элементов имеют понятие &amp;laquo;бесконечность&amp;raquo;, но это всего лишь другое значение, касающееся механизмов типов диапазона. Например, в диапазонах временных меток &lt;code&gt;[today,]&lt;/code&gt; означает то же, что и &lt;code&gt;[today,)&lt;/code&gt; . Но &lt;code&gt;[today,infinity]&lt;/code&gt; означает нечто иное, чем &lt;code&gt;[today,infinity)&lt;/code&gt; - последнее исключает специальное значение &lt;code&gt;timestamp&lt;/code&gt; &lt;code&gt;infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00fb5de01709ab2f402939d3439d7bfb11e30b51" translate="yes" xml:space="preserve">
          <source>Also, system catalogs may contain rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;BootstrapTransactionId&lt;/code&gt; (1), indicating that they were inserted during the first phase of initdb. Like &lt;code&gt;FrozenTransactionId&lt;/code&gt;, this special XID is treated as older than every normal XID.</source>
          <target state="translated">Кроме того, системные каталоги могут содержать строки с &lt;code&gt;xmin&lt;/code&gt; , равным &lt;code&gt;BootstrapTransactionId&lt;/code&gt; (1), что указывает на то, что они были вставлены на первом этапе initdb. Как и &lt;code&gt;FrozenTransactionId&lt;/code&gt; , этот специальный XID считается более старым, чем любой обычный XID.</target>
        </trans-unit>
        <trans-unit id="93ed94df22ab24f81f04b111c95a216ff81d38c0" translate="yes" xml:space="preserve">
          <source>Also, the Unicode escape syntax for string constants only works when the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is turned on. This is because otherwise this syntax could confuse clients that parse the SQL statements to the point that it could lead to SQL injections and similar security issues. If the parameter is set to off, this syntax will be rejected with an error message.</source>
          <target state="translated">Кроме того, escape-синтаксис Unicode для строковых констант работает только тогда, когда включен параметр конфигурации &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; . Это связано с тем, что в противном случае этот синтаксис может запутать клиентов, которые анализируют операторы SQL, до такой степени, что это может привести к инъекциям SQL и аналогичным проблемам безопасности. Если параметр отключен, этот синтаксис будет отклонен с сообщением об ошибке.</target>
        </trans-unit>
        <trans-unit id="58147b7f84be2ece7907815ce52ec7ae85d6c7bf" translate="yes" xml:space="preserve">
          <source>Also, there is no concept of a &lt;code&gt;public&lt;/code&gt; schema in the SQL standard. For maximum conformance to the standard, you should not use the &lt;code&gt;public&lt;/code&gt; schema.</source>
          <target state="translated">Кроме того, в стандарте SQL отсутствует концепция &lt;code&gt;public&lt;/code&gt; схемы. Для максимального соответствия стандарту не следует использовать &lt;code&gt;public&lt;/code&gt; схему.</target>
        </trans-unit>
        <trans-unit id="e584a70e0fd9b688e02349b1f5470dd3aa568b45" translate="yes" xml:space="preserve">
          <source>Also, these output format options can be set for just one query by using &lt;code&gt;\g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae58275d441413bb378869b203fcfca0525ccf0" translate="yes" xml:space="preserve">
          <source>Also, unlike a regular &lt;code&gt;Append&lt;/code&gt; node, which can only have partial children when used within a parallel plan, a &lt;code&gt;Parallel Append&lt;/code&gt; node can have both partial and non-partial child plans. Non-partial children will be scanned by only a single process, since scanning them more than once would produce duplicate results. Plans that involve appending multiple results sets can therefore achieve coarse-grained parallelism even when efficient partial plans are not available. For example, consider a query against a partitioned table which can be only be implemented efficiently by using an index that does not support parallel scans. The planner might choose a &lt;code&gt;Parallel Append&lt;/code&gt; of regular &lt;code&gt;Index Scan&lt;/code&gt; plans; each individual index scan would have to be executed to completion by a single process, but different scans could be performed at the same time by different processes.</source>
          <target state="translated">Кроме того, в отличие от обычного узла &lt;code&gt;Append&lt;/code&gt; , который может иметь только частичные дочерние элементы при использовании в параллельном плане, узел &lt;code&gt;Parallel Append&lt;/code&gt; может иметь как частичные, так и неполные дочерние планы. Неполные дочерние объекты будут сканироваться только одним процессом, так как сканирование их более одного раза приведет к дублированию результатов. Таким образом, планы, которые включают добавление нескольких наборов результатов, могут обеспечить крупномасштабный параллелизм, даже если эффективные частичные планы недоступны. Например, рассмотрим запрос к многораздельной таблице, который можно эффективно реализовать только с помощью индекса, не поддерживающего параллельное сканирование. Планировщик может выбрать &lt;code&gt;Parallel Append&lt;/code&gt; обычного &lt;code&gt;Index Scan&lt;/code&gt; планы; каждое отдельное сканирование индекса должно быть выполнено до конца одним процессом, но разные просмотры могут выполняться одновременно разными процессами.</target>
        </trans-unit>
        <trans-unit id="b84c371dd525a0259c19e76190985b0466e52c07" translate="yes" xml:space="preserve">
          <source>Also, unlike a regular &lt;code&gt;Append&lt;/code&gt; node, which can only have partial children when used within a parallel plan, a &lt;code&gt;Parallel Append&lt;/code&gt; node can have both partial and non-partial child plans. Non-partial children will be scanned by only a single process, since scanning them more than once would produce duplicate results. Plans that involve appending multiple results sets can therefore achieve coarse-grained parallelism even when efficient partial plans are not available. For example, consider a query against a partitioned table which can only be implemented efficiently by using an index that does not support parallel scans. The planner might choose a &lt;code&gt;Parallel Append&lt;/code&gt; of regular &lt;code&gt;Index Scan&lt;/code&gt; plans; each individual index scan would have to be executed to completion by a single process, but different scans could be performed at the same time by different processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e805152c6a1ae1d9757b9c8152236b48ab4b4867" translate="yes" xml:space="preserve">
          <source>Also, you can force a segment switch manually with &lt;code&gt;pg_switch_wal&lt;/code&gt; if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt;.</source>
          <target state="translated">Кроме того, вы можете принудительно переключить сегмент вручную с помощью &lt;code&gt;pg_switch_wal&lt;/code&gt; , если хотите, чтобы только что завершенная транзакция была заархивирована как можно скорее. Другие служебные функции, связанные с управлением WAL, перечислены в &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Табл. 9.84&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68eb2f93808c112d45a946f93f2d0964eca95823" translate="yes" xml:space="preserve">
          <source>Also, you can force a segment switch manually with &lt;code&gt;pg_switch_wal&lt;/code&gt; if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbace446db7c85291e8910dc869f82f6687c559" translate="yes" xml:space="preserve">
          <source>Also, you can write several possibly-modified labels separated with &lt;code&gt;|&lt;/code&gt; (OR) to match any of those labels, and you can put &lt;code&gt;!&lt;/code&gt; (NOT) at the start to match any label that doesn't match any of the alternatives.</source>
          <target state="translated">Кроме того, вы можете написать несколько меток с возможным изменением, разделенных символом &lt;code&gt;|&lt;/code&gt; (ИЛИ) для соответствия любому из этих ярлыков, и вы можете поставить &lt;code&gt;!&lt;/code&gt; (НЕ) в начале, чтобы соответствовать любому ярлыку, который не соответствует ни одной из альтернатив.</target>
        </trans-unit>
        <trans-unit id="71f210fdceeda15fb7f9067d7b92e4afb40e583b" translate="yes" xml:space="preserve">
          <source>Also, you can write several possibly-modified non-star items separated with &lt;code&gt;|&lt;/code&gt; (OR) to match any of those items, and you can put &lt;code&gt;!&lt;/code&gt; (NOT) at the start of a non-star group to match any label that doesn't match any of the alternatives. A quantifier, if any, goes at the end of the group; it means some number of matches for the group as a whole (that is, some number of labels matching or not matching any of the alternatives).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b36099e7952ab489f13b56454238da5e639dbc6" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, add connection options:</source>
          <target state="translated">Измените server &lt;code&gt;foo&lt;/code&gt; , добавьте параметры подключения:</target>
        </trans-unit>
        <trans-unit id="a729ebcf94a23a3c93f6e08f02b494c47b57ffb8" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, change version, change &lt;code&gt;host&lt;/code&gt; option:</source>
          <target state="translated">Изменить сервер &lt;code&gt;foo&lt;/code&gt; , изменить версию, изменить параметр &lt;code&gt;host&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="530e5f9a6ec30da1a641c6dc46a96ff1039a1901" translate="yes" xml:space="preserve">
          <source>Alter the current session user instead of an explicitly identified role.</source>
          <target state="translated">Изменить пользователя текущей сессии вместо явно определенной роли.</target>
        </trans-unit>
        <trans-unit id="7d634d2fd0bd3ab5f5b0921201011f77ef8d5f96" translate="yes" xml:space="preserve">
          <source>Alter the current user instead of an explicitly identified role.</source>
          <target state="translated">Изменение текущего пользователя вместо явно определенной роли.</target>
        </trans-unit>
        <trans-unit id="2e8aee10a5d127f616d1a417fe30c8e06fd3852f" translate="yes" xml:space="preserve">
          <source>Alternative Method for Log Shipping</source>
          <target state="translated">Альтернативный способ перевозки бревен</target>
        </trans-unit>
        <trans-unit id="8cd965c3bba9ba8b09a134d95e9a1fe544bc4537" translate="yes" xml:space="preserve">
          <source>Alternative location for the command history file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">Альтернативное расположение файла истории команд. Выполняется раскрытие тильды ( &lt;code&gt;~&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0c3a5aa0af507c3b23d9de2d04bd2190286c2e39" translate="yes" xml:space="preserve">
          <source>Alternative location of the user's &lt;code&gt;.psqlrc&lt;/code&gt; file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">Альтернативное расположение файла &lt;code&gt;.psqlrc&lt;/code&gt; пользователя . Выполняется раскрытие тильды ( &lt;code&gt;~&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2541ab725e8ecd177759c1c8be6f800623e60558" translate="yes" xml:space="preserve">
          <source>Alternative spelling for &lt;code&gt;TEMPORARY&lt;/code&gt;.</source>
          <target state="translated">Альтернативное написание слова &lt;code&gt;TEMPORARY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af1d73d4699e1562f8a1d0921440facf6a0e5f14" translate="yes" xml:space="preserve">
          <source>Alternative syntaxes for referencing ordered-set aggregates are described under &lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATE&lt;/a&gt;.</source>
          <target state="translated">Альтернативные синтаксисы для ссылки на агрегаты упорядоченного набора описаны в &lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23e53579bffe248a96cd7c7da0e62e9be194d4f8" translate="yes" xml:space="preserve">
          <source>Alternatively, C-style block comments can be used:</source>
          <target state="translated">В качестве альтернативы можно использовать комментарии к блоку в стиле С:</target>
        </trans-unit>
        <trans-unit id="7ff9d2f8aa56be6c9fb839910a0ca959de998790" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;code&gt;time_zone_name&lt;/code&gt; can be given, referencing a zone name defined in the IANA timezone database. The zone's definition is consulted to see whether the abbreviation is or has been in use in that zone, and if so, the appropriate meaning is used &amp;mdash; that is, the meaning that was currently in use at the timestamp whose value is being determined, or the meaning in use immediately before that if it wasn't current at that time, or the oldest meaning if it was used only after that time. This behavior is essential for dealing with abbreviations whose meaning has historically varied. It is also allowed to define an abbreviation in terms of a zone name in which that abbreviation does not appear; then using the abbreviation is just equivalent to writing out the zone name.</source>
          <target state="translated">В качестве &lt;code&gt;time_zone_name&lt;/code&gt; можно указать time_zone_name , ссылаясь на имя зоны, определенное в базе данных часовых поясов IANA. С определением зоны обращаются, чтобы узнать, использовалось ли сокращение в этой зоне, и если да, то используется соответствующее значение, то есть значение, которое использовалось в данный момент для метки времени, значение которой определяется, или значение, используемое непосредственно перед этим, если оно не было актуальным в то время, или самое старое значение, если оно использовалось только после этого времени. Такое поведение важно для работы с сокращениями, значение которых исторически менялось. Также разрешено определять аббревиатуру в виде названия зоны, в которой это сокращение не появляется; тогда использование аббревиатуры эквивалентно написанию имени зоны.</target>
        </trans-unit>
        <trans-unit id="15a06f8c724e47a1d8815847200662f59207ad21" translate="yes" xml:space="preserve">
          <source>Alternatively, a regular server session can be started with &lt;code&gt;-P&lt;/code&gt; included in its command line options. The method for doing this varies across clients, but in all libpq-based clients, it is possible to set the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable to &lt;code&gt;-P&lt;/code&gt; before starting the client. Note that while this method does not require locking out other clients, it might still be wise to prevent other users from connecting to the damaged database until repairs have been completed.</source>
          <target state="translated">В качестве альтернативы, обычный сеанс сервера может быть запущен с &lt;code&gt;-P&lt;/code&gt; , включенным в его параметры командной строки. Метод для этого зависит от клиентов, но во всех клиентах на основе libpq можно установить для переменной среды &lt;code&gt;PGOPTIONS&lt;/code&gt; значение &lt;code&gt;-P&lt;/code&gt; перед запуском клиента. Обратите внимание, что хотя этот метод не требует блокировки других клиентов, все же может быть разумным запретить другим пользователям подключаться к поврежденной базе данных до тех пор, пока не будет завершен ремонт.</target>
        </trans-unit>
        <trans-unit id="d114129fd255b4feb38503a136823f1a3243ffae" translate="yes" xml:space="preserve">
          <source>Alternatively, an arbitrary expression can determine what rows are to be considered distinct:</source>
          <target state="translated">В качестве альтернативы,произвольное выражение может определить,какие строки следует считать отличными:</target>
        </trans-unit>
        <trans-unit id="a31da7f4a4f7c70e9c7e0520f23700364a2f38f8" translate="yes" xml:space="preserve">
          <source>Alternatively, any of the following forms can be used for input:</source>
          <target state="translated">В качестве альтернативы для ввода можно использовать любую из следующих форм:</target>
        </trans-unit>
        <trans-unit id="33e9e4beffd0551e6388808105bbbc2dfb18bd73" translate="yes" xml:space="preserve">
          <source>Alternatively, bit-string constants can be specified in hexadecimal notation, using a leading &lt;code&gt;X&lt;/code&gt; (upper or lower case), e.g., &lt;code&gt;X'1FF'&lt;/code&gt;. This notation is equivalent to a bit-string constant with four binary digits for each hexadecimal digit.</source>
          <target state="translated">В качестве альтернативы константы битовой строки могут быть указаны в шестнадцатеричной системе счисления, используя &lt;code&gt;X'1FF'&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; (в верхнем или нижнем регистре), например, X'1FF ' . Эта нотация эквивалентна константе битовой строки с четырьмя двоичными цифрами для каждой шестнадцатеричной цифры.</target>
        </trans-unit>
        <trans-unit id="251d43a6c1d9b6a2f5aefc3ac8e6be39b17e09eb" translate="yes" xml:space="preserve">
          <source>Alternatively, if only one character is given on a line, instances of that character are deleted; this is useful in languages where accents are represented by separate characters.</source>
          <target state="translated">В качестве альтернативы,если в строке указан только один символ,экземпляры этого символа удаляются;это полезно в языках,где акценты представлены отдельными символами.</target>
        </trans-unit>
        <trans-unit id="d591ed10c7ebb943dc2bac83e217250069a02625" translate="yes" xml:space="preserve">
          <source>Alternatively, if the operator class does not provide a &lt;code&gt;compare&lt;/code&gt; method, GIN will look up the default btree operator class for the index key data type, and use its comparison function. It is recommended to specify the comparison function in a GIN operator class that is meant for just one data type, as looking up the btree operator class costs a few cycles. However, polymorphic GIN operator classes (such as &lt;code&gt;array_ops&lt;/code&gt;) typically cannot specify a single comparison function.</source>
          <target state="translated">В качестве альтернативы, если класс операторов не предоставляет метод &lt;code&gt;compare&lt;/code&gt; , GIN будет искать класс операторов btree по умолчанию для типа данных ключа индекса и использовать свою функцию сравнения. Рекомендуется указывать функцию сравнения в классе операторов GIN, который предназначен только для одного типа данных, поскольку поиск класса операторов btree требует нескольких циклов. Однако полиморфные классы операторов GIN (такие как &lt;code&gt;array_ops&lt;/code&gt; ) обычно не могут указывать одну функцию сравнения.</target>
        </trans-unit>
        <trans-unit id="72ceaece99de5916dec6956aa5625927bc2fa200" translate="yes" xml:space="preserve">
          <source>Alternatively, if the user account was created incorrectly or cannot be changed, it is recommended to set</source>
          <target state="translated">В качестве альтернативы,если учетная запись пользователя была создана некорректно или не может быть изменена,рекомендуется задать параметр</target>
        </trans-unit>
        <trans-unit id="60d8933bc73d549d63a859713e0214c4534a9558" translate="yes" xml:space="preserve">
          <source>Alternatively, one may want to create and populate the new child table before adding it to the table hierarchy. This could allow data to be loaded, checked, and transformed before being made visible to queries on the parent table.</source>
          <target state="translated">Кроме того,можно создать и заполнить новую дочернюю таблицу перед добавлением ее в иерархию таблиц.Это может позволить загружать,проверять и преобразовывать данные перед тем,как сделать их видимыми для запросов в родительской таблице.</target>
        </trans-unit>
        <trans-unit id="3ff1004e1f07326010cba19c9e266164c058052f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; command can be used to reassign ownership of all objects owned by the role-to-be-dropped to a single other role. Because &lt;code&gt;REASSIGN OWNED&lt;/code&gt; cannot access objects in other databases, it is necessary to run it in each database that contains objects owned by the role. (Note that the first such &lt;code&gt;REASSIGN OWNED&lt;/code&gt; will change the ownership of any shared-across-databases objects, that is databases or tablespaces, that are owned by the role-to-be-dropped.)</source>
          <target state="translated">В качестве альтернативы можно использовать команду &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; для переназначения владения всеми объектами, принадлежащими удаляемой роли, одной другой роли. Поскольку &lt;code&gt;REASSIGN OWNED&lt;/code&gt; не может получить доступ к объектам в других базах данных, необходимо запустить его в каждой базе данных, содержащей объекты, принадлежащие данной роли. (Обратите внимание, что первый такой &lt;code&gt;REASSIGN OWNED&lt;/code&gt; изменит владельца любых объектов, совместно используемых базами данных, то есть баз данных или табличных пространств, которые принадлежат удаляемой роли.)</target>
        </trans-unit>
        <trans-unit id="0e1e66b725216c8606cc4bf9032cf0c74ece07f1" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;generate_subscripts&lt;/code&gt; function can be used. For example:</source>
          <target state="translated">В качестве альтернативы можно использовать функцию &lt;code&gt;generate_subscripts&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="15fba016cd90434c268101e2e3dcfba0bf0a2532" translate="yes" xml:space="preserve">
          <source>Alternatively, use the &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; parameter:</source>
          <target state="translated">В качестве альтернативы используйте параметр &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0f4a86811d0aa22382b5cf9bd26c67192af09d76" translate="yes" xml:space="preserve">
          <source>Alternatively, use the short commands:</source>
          <target state="translated">В качестве альтернативы используйте короткие команды:</target>
        </trans-unit>
        <trans-unit id="65a8f599c00acf998716acc089534f17921d2aa4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can run &lt;code&gt;initdb&lt;/code&gt; via the &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; program like so:</source>
          <target state="translated">В качестве альтернативы вы можете запустить &lt;code&gt;initdb&lt;/code&gt; через программу &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="98a5c461c82a79025a521674df6f9b47d5588e09" translate="yes" xml:space="preserve">
          <source>Alternatively, you could modify &lt;code&gt;passwordcheck&lt;/code&gt; to reject pre-encrypted passwords, but forcing users to set their passwords in clear text carries its own security risks.</source>
          <target state="translated">В качестве альтернативы вы можете изменить проверку &lt;code&gt;passwordcheck&lt;/code&gt; чтобы отклонять предварительно зашифрованные пароли, но принуждение пользователей устанавливать свои пароли в открытом виде несет в себе собственные риски безопасности.</target>
        </trans-unit>
        <trans-unit id="5a5bc9685c86de23aa2f7e6abe79e2df58ea2f24" translate="yes" xml:space="preserve">
          <source>Alternatively, you might prefer to use an external log rotation program if you have one that you are already using with other server software. For example, the rotatelogs tool included in the Apache distribution can be used with PostgreSQL. One way to do this is to pipe the server's stderr output to the desired program. If you start the server with &lt;code&gt;pg_ctl&lt;/code&gt;, then stderr is already redirected to stdout, so you just need a pipe command, for example:</source>
          <target state="translated">В качестве альтернативы вы можете предпочесть использовать внешнюю программу ротации журналов, если у вас есть программа, которую вы уже используете с другим серверным программным обеспечением. Например, инструмент rotatelogs, включенный в дистрибутив Apache, можно использовать с PostgreSQL. Один из способов сделать это - направить вывод stderr сервера в нужную программу. Если вы запускаете сервер с помощью &lt;code&gt;pg_ctl&lt;/code&gt; , то stderr уже перенаправлен на stdout, поэтому вам просто нужна команда pipe, например:</target>
        </trans-unit>
        <trans-unit id="a4473ced05716c4f54d00426c2fe62cbfc81eb98" translate="yes" xml:space="preserve">
          <source>Alternatively, you'll get this when attempting Unix-domain socket communication to a local server:</source>
          <target state="translated">В качестве альтернативы,вы получите это при попытке соединения Unix-доменных сокетов с локальным сервером:</target>
        </trans-unit>
        <trans-unit id="3070b53c6b7161861f801a0276cbe1623e985387" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; attempts to verify that existing stored data satisfies the new constraint, this check is not bulletproof, because the command cannot &amp;ldquo;see&amp;rdquo; table rows that are newly inserted or updated and not yet committed. If there is a hazard that concurrent operations might insert bad data, the way to proceed is to add the constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option, commit that command, wait until all transactions started before that commit have finished, and then issue &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; to search for data violating the constraint. This method is reliable because once the constraint is committed, all new transactions are guaranteed to enforce it against new values of the domain type.</source>
          <target state="translated">Хотя &lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; пытается проверить, удовлетворяют ли существующие сохраненные данные новому ограничению, эта проверка не является пуленепробиваемой, поскольку команда не может &amp;laquo;видеть&amp;raquo; строки таблицы, которые были недавно вставлены или обновлены и еще не зафиксированы. Если существует опасность того, что параллельные операции могут вставить неверные данные, способ продолжить - добавить ограничение с помощью параметра &lt;code&gt;NOT VALID&lt;/code&gt; , зафиксировать эту команду, дождаться завершения всех транзакций, запущенных до завершения этой фиксации, а затем выполнить &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; для поиска данных, нарушающих ограничение. Этот метод надежен, потому что после фиксации ограничения все новые транзакции гарантированно применяют его к новым значениям типа домена.</target>
        </trans-unit>
        <trans-unit id="6e4d5c62b36bd1bff5096ffffc66d8713544d380" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;COALESCE&lt;/code&gt;, &lt;code&gt;GREATEST&lt;/code&gt;, and &lt;code&gt;LEAST&lt;/code&gt; are syntactically similar to functions, they are not ordinary functions, and thus cannot be used with explicit &lt;code&gt;VARIADIC&lt;/code&gt; array arguments.</source>
          <target state="translated">Хотя &lt;code&gt;COALESCE&lt;/code&gt; , &lt;code&gt;GREATEST&lt;/code&gt; и &lt;code&gt;LEAST&lt;/code&gt; синтаксически похожи на функции, они не являются обычными функциями и, следовательно, не могут использоваться с явными &lt;code&gt;VARIADIC&lt;/code&gt; массива VARIADIC .</target>
        </trans-unit>
        <trans-unit id="757c32acfdc3edc5e4ae1b7ef733e95e7cd6d851" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;FOR UPDATE&lt;/code&gt; appears in the SQL standard, the standard allows it only as an option of &lt;code&gt;DECLARE CURSOR&lt;/code&gt;. PostgreSQL allows it in any &lt;code&gt;SELECT&lt;/code&gt; query as well as in sub-&lt;code&gt;SELECT&lt;/code&gt;s, but this is an extension. The &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; and &lt;code&gt;FOR KEY SHARE&lt;/code&gt; variants, as well as the &lt;code&gt;NOWAIT&lt;/code&gt; and &lt;code&gt;SKIP LOCKED&lt;/code&gt; options, do not appear in the standard.</source>
          <target state="translated">Хотя &lt;code&gt;FOR UPDATE&lt;/code&gt; присутствует в стандарте SQL, стандарт допускает его только как опцию &lt;code&gt;DECLARE CURSOR&lt;/code&gt; . PostgreSQL допускает это в любом запросе &lt;code&gt;SELECT&lt;/code&gt; , а также в подпунктах &lt;code&gt;SELECT&lt;/code&gt; , но это расширение. &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; , &lt;code&gt;FOR SHARE&lt;/code&gt; и &lt;code&gt;FOR KEY SHARE&lt;/code&gt; вариантов, а также &lt;code&gt;NOWAIT&lt;/code&gt; и &lt;code&gt;SKIP LOCKED&lt;/code&gt; варианты, не отображаются в стандарте.</target>
        </trans-unit>
        <trans-unit id="53588eb1af9a260bf16537d83fb7f9095237ab92" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;initdb&lt;/code&gt; will attempt to create the specified data directory, it might not have permission if the parent directory of the desired data directory is root-owned. To initialize in such a setup, create an empty data directory as root, then use &lt;code&gt;chown&lt;/code&gt; to assign ownership of that directory to the database user account, then &lt;code&gt;su&lt;/code&gt; to become the database user to run &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">Хотя &lt;code&gt;initdb&lt;/code&gt; попытается создать указанный каталог данных, он может не иметь разрешения, если родительский каталог нужного каталога данных принадлежит пользователю root. Для инициализации в такой настройке создайте пустой каталог данных как root, затем используйте &lt;code&gt;chown&lt;/code&gt; , чтобы назначить владение этим каталогом учетной записи пользователя базы данных, затем &lt;code&gt;su&lt;/code&gt; , чтобы стать пользователем базы данных для запуска &lt;code&gt;initdb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c9e9e73d67adcca66915f7f142192b4fd5640e0" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL does not attempt to enforce constraints on foreign tables, it does assume that they are correct for purposes of query optimization. If there are rows visible in the foreign table that do not satisfy a declared constraint, queries on the table might produce incorrect answers. It is the user's responsibility to ensure that the constraint definition matches reality.</source>
          <target state="translated">Несмотря на то,что PostgreSQL не пытается навязать ограничения на внешние таблицы,он предполагает,что они корректны для целей оптимизации запросов.Если во внешней таблице видны строки,не удовлетворяющие объявленным ограничениям,то запросы по таблице могут давать неверные ответы.Ответственность за соответствие определения ограничения реальности лежит на пользователе.</target>
        </trans-unit>
        <trans-unit id="d1a0d48f05bfdc6cec6860f8c1c04ca18ef39017" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL supports Julian Date notation for input and output of dates (and also uses Julian dates for some internal datetime calculations), it does not observe the nicety of having dates run from noon to noon. PostgreSQL treats a Julian Date as running from midnight to midnight.</source>
          <target state="translated">Несмотря на то,что PostgreSQL поддерживает юлианскую нотацию даты для ввода и вывода дат (а также использует юлианские даты для некоторых внутренних вычислений даты),он не соблюдает нюансов,когда даты выполняются с полудня до полудня.PostgreSQL считает,что юлианская дата работает с полуночи до полуночи.</target>
        </trans-unit>
        <trans-unit id="aa5958132d1510aabee9c8eff036ee687a13c3b5" translate="yes" xml:space="preserve">
          <source>Although all built-in WAL-logged modules have their own types of WAL records, there is also a generic WAL record type, which describes changes to pages in a generic way. This is useful for extensions that provide custom access methods, because they cannot register their own WAL redo routines.</source>
          <target state="translated">Хотя все встроенные модули WAL-журнала имеют свои собственные типы записей WAL,существует также общий тип записи WAL,который описывает изменения страниц в общем виде.Это полезно для расширений,которые предоставляют пользовательские методы доступа,потому что они не могут зарегистрировать свои собственные процедуры WAL redo.</target>
        </trans-unit>
        <trans-unit id="d6ab224f94330d8699a9bed333303bd23f1e0345" translate="yes" xml:space="preserve">
          <source>Although enum types are primarily intended for static sets of values, there is support for adding new values to an existing enum type, and for renaming values (see &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;). Existing values cannot be removed from an enum type, nor can the sort ordering of such values be changed, short of dropping and re-creating the enum type.</source>
          <target state="translated">Хотя типы перечисления в первую очередь предназначены для статических наборов значений, существует поддержка для добавления новых значений к существующему типу перечисления и для переименования значений (см. &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt; ). Существующие значения нельзя удалить из типа перечисления, а также нельзя изменить порядок сортировки таких значений, за исключением удаления и повторного создания типа перечисления.</target>
        </trans-unit>
        <trans-unit id="94ec3fef4f0a92e5c738b8e891b93184d80ce08d" translate="yes" xml:space="preserve">
          <source>Although indexes in PostgreSQL do not need maintenance or tuning, it is still important to check which indexes are actually used by the real-life query workload. Examining index usage for an individual query is done with the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command; its application for this purpose is illustrated in &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt;. It is also possible to gather overall statistics about index usage in a running server, as described in &lt;a href=&quot;monitoring-stats&quot;&gt;Section 27.2&lt;/a&gt;.</source>
          <target state="translated">Хотя индексы в PostgreSQL не нуждаются в обслуживании или настройке, все же важно проверить, какие индексы фактически используются реальной рабочей нагрузкой запросов. Проверка использования индекса для отдельного запроса выполняется с помощью команды &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; ; его применение для этой цели показано в &lt;a href=&quot;using-explain&quot;&gt;Разделе 14.1&lt;/a&gt; . Также можно собрать общую статистику об использовании индекса на работающем сервере, как описано в &lt;a href=&quot;monitoring-stats&quot;&gt;Разделе 27.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b565c24300a11b353aca42f1a3c2fd6f15be280e" translate="yes" xml:space="preserve">
          <source>Although inheritance is frequently useful, it has not been integrated with unique constraints or foreign keys, which limits its usefulness. See &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; for more detail.</source>
          <target state="translated">Хотя наследование часто бывает полезным, оно не было интегрировано с уникальными ограничениями или внешними ключами, что ограничивает его полезность. См. &lt;a href=&quot;ddl-inherit&quot;&gt;Раздел 5.10&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="d3850ba882b09b2bdad99e045dd0ac52d33bb527" translate="yes" xml:space="preserve">
          <source>Although it is possible to copy a database other than &lt;code&gt;template1&lt;/code&gt; by specifying its name as the template, this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the template database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; otherwise, new connections to the template database are locked out until &lt;code&gt;CREATE DATABASE&lt;/code&gt; completes. See &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt; for more information.</source>
          <target state="translated">Хотя можно скопировать базу данных, отличную от &lt;code&gt;template1&lt;/code&gt; , указав ее имя в качестве шаблона, это (пока) не предназначено как универсальная возможность &amp;laquo; &lt;code&gt;COPY DATABASE&lt;/code&gt; &amp;raquo;. Основное ограничение заключается в том, что никакие другие сеансы не могут быть подключены к базе данных шаблона во время ее копирования. &lt;code&gt;CREATE DATABASE&lt;/code&gt; завершится ошибкой, если при запуске существует какое-либо другое соединение; в противном случае новые подключения к базе данных шаблона блокируются до завершения &lt;code&gt;CREATE DATABASE&lt;/code&gt; . См. &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Раздел 22.3&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="9f2cb95ff60fc4e9f012557faa268bb5d908ed75" translate="yes" xml:space="preserve">
          <source>Although most forms of &lt;code&gt;ADD table_constraint&lt;/code&gt; require an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock, &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; requires only a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock. Note that &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; also acquires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table, in addition to the lock on the table on which the constraint is declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7a4620dd953ee89678c8af93ba6b1281ecf21b" translate="yes" xml:space="preserve">
          <source>Although per-column tweaking of &lt;code&gt;ANALYZE&lt;/code&gt; frequency might not be very productive, you might find it worthwhile to do per-column adjustment of the level of detail of the statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt;. Columns that are heavily used in &lt;code&gt;WHERE&lt;/code&gt; clauses and have highly irregular data distributions might require a finer-grain data histogram than other columns. See &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;, or change the database-wide default using the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter.</source>
          <target state="translated">Хотя настройка частоты &lt;code&gt;ANALYZE&lt;/code&gt; по столбцам может быть не очень продуктивной, вы можете счесть целесообразным выполнить настройку уровня детализации статистики, собираемой &lt;code&gt;ANALYZE&lt;/code&gt; , по столбцам . Столбцы, которые активно используются в &lt;code&gt;WHERE&lt;/code&gt; и имеют крайне нерегулярное распределение данных, могут потребовать гистограммы данных с более мелким зерном, чем другие столбцы. См. &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; или измените значение по умолчанию для всей базы данных с помощью параметра конфигурации &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="072197dff3ba1069a6848a4f3fc276518f8dd8e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;date&lt;/code&gt; type cannot have an associated time zone, the &lt;code&gt;time&lt;/code&gt; type can. Time zones in the real world have little meaning unless associated with a date as well as a time, since the offset can vary through the year with daylight-saving time boundaries.</source>
          <target state="translated">Хотя тип &lt;code&gt;date&lt;/code&gt; не может иметь связанный часовой пояс, тип &lt;code&gt;time&lt;/code&gt; может. Часовые пояса в реальном мире имеют мало значения, если они не связаны с датой, а также временем, поскольку смещение может меняться в течение года с границами перехода на летнее время.</target>
        </trans-unit>
        <trans-unit id="28fdae260b7b429ca2fc81de6c0ad8518d3a56e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;jsonb_path_ops&lt;/code&gt; operator class supports only queries with the &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, it has notable performance advantages over the default operator class &lt;code&gt;jsonb_ops&lt;/code&gt;. A &lt;code&gt;jsonb_path_ops&lt;/code&gt; index is usually much smaller than a &lt;code&gt;jsonb_ops&lt;/code&gt; index over the same data, and the specificity of searches is better, particularly when queries contain keys that appear frequently in the data. Therefore search operations typically perform better than with the default operator class.</source>
          <target state="translated">Хотя &lt;code&gt;jsonb_path_ops&lt;/code&gt; операторов jsonb_path_ops поддерживает только запросы с &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;@@&lt;/code&gt; и &lt;code&gt;@?&lt;/code&gt; операторов, он имеет заметные преимущества в производительности по сравнению с классом операторов по умолчанию &lt;code&gt;jsonb_ops&lt;/code&gt; . &lt;code&gt;jsonb_path_ops&lt;/code&gt; индекс, как правило , гораздо меньше , чем &lt;code&gt;jsonb_ops&lt;/code&gt; индекс по тем же данным, и специфика поиска лучше, особенно когда запросы содержат ключи , которые появляются часто в данных. Поэтому операции поиска обычно работают лучше, чем с классом операторов по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b3909c49c0f3069cf4fdb831ccd03572195110f1" translate="yes" xml:space="preserve">
          <source>Although the error conditions possible on the client side are quite varied and application-dependent, a few of them might be directly related to how the server was started. Conditions other than those shown below should be documented with the respective client application.</source>
          <target state="translated">Хотя возможные условия ошибок на стороне клиента довольно разнообразны и зависят от приложений,некоторые из них могут быть напрямую связаны с тем,как сервер был запущен.Условия,отличные от показанных ниже,должны быть задокументированы с соответствующим клиентским приложением.</target>
        </trans-unit>
        <trans-unit id="707d4aa12dd0762aad5c962d956cb0615faa21aa" translate="yes" xml:space="preserve">
          <source>Although the main point of a prepared statement is to avoid repeated parse analysis and planning of the statement, PostgreSQL will force re-analysis and re-planning of the statement before using it whenever database objects used in the statement have undergone definitional (DDL) changes since the previous use of the prepared statement. Also, if the value of &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; changes from one use to the next, the statement will be re-parsed using the new &lt;code&gt;search_path&lt;/code&gt;. (This latter behavior is new as of PostgreSQL 9.3.) These rules make use of a prepared statement semantically almost equivalent to re-submitting the same query text over and over, but with a performance benefit if no object definitions are changed, especially if the best plan remains the same across uses. An example of a case where the semantic equivalence is not perfect is that if the statement refers to a table by an unqualified name, and then a new table of the same name is created in a schema appearing earlier in the &lt;code&gt;search_path&lt;/code&gt;, no automatic re-parse will occur since no object used in the statement changed. However, if some other change forces a re-parse, the new table will be referenced in subsequent uses.</source>
          <target state="translated">Хотя основная цель подготовленного оператора - избежать повторного анализа синтаксического анализа и планирования оператора, PostgreSQL заставит повторно проанализировать и перепланировать оператор перед его использованием всякий раз, когда объекты базы данных, используемые в операторе, претерпели изменения определения (DDL). с момента предыдущего использования подготовленного оператора. Кроме того, если значение &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; изменяется от одного использования к другому, оператор будет повторно проанализирован с использованием нового &lt;code&gt;search_path&lt;/code&gt; .. (Это последнее поведение является новым в PostgreSQL 9.3.) Эти правила используют подготовленный оператор, семантически почти эквивалентный повторной отправке одного и того же текста запроса снова и снова, но с выигрышем в производительности, если определения объектов не меняются, особенно если лучший план остается неизменным при использовании. Примером случая, когда семантическая эквивалентность не идеальна, является то, что если оператор ссылается на таблицу по неквалифицированному имени, а затем создается новая таблица с тем же именем в схеме, появившейся ранее в &lt;code&gt;search_path&lt;/code&gt; , автоматического повторного использования не будет. синтаксический анализ будет выполняться, поскольку ни один объект, используемый в операторе, не изменился. Однако, если какое-либо другое изменение вызывает повторный синтаксический анализ, новая таблица будет ссылаться на последующие использования.</target>
        </trans-unit>
        <trans-unit id="7b64c47c816d918ee8eceb31b5a14f4992da7fb7" translate="yes" xml:space="preserve">
          <source>Although the syntax of &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; resembles that of the SQL standard, the effect is not the same. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them. PostgreSQL instead requires each session to issue its own &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; command for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard's approach constrains all instances of a given temporary table name to have the same table structure.</source>
          <target state="translated">Хотя синтаксис &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; похож на синтаксис стандарта SQL, эффект не тот. В стандарте временные таблицы определяются только один раз и автоматически существуют (начиная с пустого содержимого) в каждом сеансе, который в них нуждается. PostgreSQL вместо этого требует, чтобы каждый сеанс запускал свою собственную команду &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; для каждой используемой временной таблицы. Это позволяет различным сеансам использовать одно и то же имя временной таблицы для разных целей, тогда как стандартный подход ограничивает все экземпляры данного имени временной таблицы одинаковой структурой таблицы.</target>
        </trans-unit>
        <trans-unit id="9eb832cbf2f7969f569f8af2de92f22dbf429240" translate="yes" xml:space="preserve">
          <source>Although the system will let you set &lt;code&gt;random_page_cost&lt;/code&gt; to less than &lt;code&gt;seq_page_cost&lt;/code&gt;, it is not physically sensible to do so. However, setting them equal makes sense if the database is entirely cached in RAM, since in that case there is no penalty for touching pages out of sequence. Also, in a heavily-cached database you should lower both values relative to the CPU parameters, since the cost of fetching a page already in RAM is much smaller than it would normally be.</source>
          <target state="translated">Хотя система позволяет вам установить &lt;code&gt;random_page_cost&lt;/code&gt; меньше, чем &lt;code&gt;seq_page_cost&lt;/code&gt; , это физически нецелесообразно . Однако их равное значение имеет смысл, если база данных полностью кэшируется в ОЗУ, поскольку в этом случае нет штрафа за несогласованное касание страниц. Кроме того, в сильно кэшированной базе данных следует снизить оба значения относительно параметров ЦП, поскольку затраты на выборку страницы, уже находящейся в ОЗУ, намного меньше, чем обычно.</target>
        </trans-unit>
        <trans-unit id="f375eb3005a104e4e3133bc9460b959aca6d956c" translate="yes" xml:space="preserve">
          <source>Although these queries will work without an index, most applications will find this approach too slow, except perhaps for occasional ad-hoc searches. Practical use of text searching usually requires creating an index.</source>
          <target state="translated">Хотя эти запросы будут работать без индекса,большинство приложений сочтут такой подход слишком медленным,за исключением,возможно,случайных специальных поисков.Практическое использование текстового поиска обычно требует создания индекса.</target>
        </trans-unit>
        <trans-unit id="d6a53bc14c2fd9a760550de48fb80767bf99cae5" translate="yes" xml:space="preserve">
          <source>Although this query runs much faster than with either of the single indexes, we pay a large penalty in index size. Each of the single-column btree indexes occupies 214 MB, so the total space needed is over 1.2GB, more than 8 times the space used by the bloom index.</source>
          <target state="translated">Несмотря на то,что этот запрос выполняется намного быстрее,чем с любым из единичных индексов,мы платим большой штраф в размере индекса.Каждый из одноколоночных btree индексов занимает 214 МБ,таким образом,общая необходимая площадь составляет более 1,2 ГБ,что более чем в 8 раз превышает площадь,используемую цветным индексом.</target>
        </trans-unit>
        <trans-unit id="a490262673b6e67e6cc0b4de26fba601b493618f" translate="yes" xml:space="preserve">
          <source>Although this query runs much faster than with either of the single indexes, we pay a penalty in index size. Each of the single-column btree indexes occupies 2 MB, so the total space needed is 12 MB, eight times the space used by the bloom index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1200f8928e7bfeba98e8bc2cff21bdd8b6159a1f" translate="yes" xml:space="preserve">
          <source>Although this query's restrictions are superficially similar to the previous example, the semantics are different because a row must be emitted for each row of A that has no matching row in the join of B and C. Therefore the planner has no choice of join order here: it must join B to C and then join A to that result. Accordingly, this query takes less time to plan than the previous query. In other cases, the planner might be able to determine that more than one join order is safe. For example, given:</source>
          <target state="translated">Хотя ограничения этого запроса поверхностно похожи на предыдущий пример,семантика отличается,потому что строка должна быть излучена для каждой строки A,которая не имеет совпадающего ряда в соединении B и C.Поэтому у планировщика нет выбора порядка соединения здесь:он должен соединить B с C,а затем соединить A с этим результатом.Соответственно,этот запрос занимает меньше времени для планирования,чем предыдущий.В других случаях планировщик может определить,что более чем один порядок соединения безопасен.Например,учитывая:</target>
        </trans-unit>
        <trans-unit id="7ef8d68c90c214bb77efeec7b9a407cfbeffef4b" translate="yes" xml:space="preserve">
          <source>Although tuples are a lockable type of object, information about row-level locks is stored on disk, not in memory, and therefore row-level locks normally do not appear in this view. If a process is waiting for a row-level lock, it will usually appear in the view as waiting for the permanent transaction ID of the current holder of that row lock.</source>
          <target state="translated">Хотя кортежи-это объект блокируемого типа,информация о блокировках уровня рядов хранится на диске,а не в памяти,поэтому блокировки уровня рядов обычно не отображаются в этом виде.Если процесс ждет блокировки на уровне рядов,он обычно отображается в виде ожидания постоянного идентификатора транзакции текущего владельца блокировки этого ряда.</target>
        </trans-unit>
        <trans-unit id="72059384cd793d17d014692386f1a5b268fab6d4" translate="yes" xml:space="preserve">
          <source>Although you can use any output format with this feature, the default &lt;code&gt;aligned&lt;/code&gt; format tends to look bad because each group of &lt;code&gt;FETCH_COUNT&lt;/code&gt; rows will be formatted separately, leading to varying column widths across the row groups. The other output formats work better.</source>
          <target state="translated">Хотя вы можете использовать любой выходной формат с этой функцией, &lt;code&gt;aligned&lt;/code&gt; по умолчанию формат имеет тенденцию выглядеть плохо, потому что каждая группа строк &lt;code&gt;FETCH_COUNT&lt;/code&gt; будет отформатирована отдельно, что приведет к различной ширине столбцов в группах строк. Другие форматы вывода работают лучше.</target>
        </trans-unit>
        <trans-unit id="29489a7d34435843e1ff1804b48da3fef28fc6ed" translate="yes" xml:space="preserve">
          <source>Although you cannot update a sequence directly, you can use a query like:</source>
          <target state="translated">Хотя вы не можете обновлять последовательность напрямую,вы можете использовать запрос типа:</target>
        </trans-unit>
        <trans-unit id="d408d29d181fe5f178e0df0934db0a473f3e4b2d" translate="yes" xml:space="preserve">
          <source>Always -1 in storage, but when loaded into a row descriptor in memory this might be updated to cache the offset of the attribute within the row</source>
          <target state="translated">Всегда -1 в хранилище,но при загрузке в дескриптор строки в памяти он может быть обновлен для кэширования смещения атрибута внутри строки</target>
        </trans-unit>
        <trans-unit id="6dadde15ce0973a00fe9eb264f6b51766c085e93" translate="yes" xml:space="preserve">
          <source>Always run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; first. This command collects statistics about the distribution of the values in the table. This information is required to estimate the number of rows returned by a query, which is needed by the planner to assign realistic costs to each possible query plan. In absence of any real statistics, some default values are assumed, which are almost certain to be inaccurate. Examining an application's index usage without having run &lt;code&gt;ANALYZE&lt;/code&gt; is therefore a lost cause. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">Всегда сначала запускайте &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; . Эта команда собирает статистику о распределении значений в таблице. Эта информация требуется для оценки количества строк, возвращаемых запросом, что необходимо планировщику для назначения реалистичных затрат на каждый возможный план запроса. В отсутствие реальной статистики предполагаются некоторые значения по умолчанию, которые почти наверняка неточны. Поэтому изучение использования индекса приложением без запуска &lt;code&gt;ANALYZE&lt;/code&gt; - безнадежное дело. См. &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Раздел 24.1.3&lt;/a&gt; и &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Раздел 24.1.6&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="fee90b9468a8f0a4929baba6bf4b3942f402f50f" translate="yes" xml:space="preserve">
          <source>Always run the pg_upgrade binary of the new server, not the old one. pg_upgrade requires the specification of the old and new cluster's data and executable (&lt;code&gt;bin&lt;/code&gt;) directories. You can also specify user and port values, and whether you want the data files linked or cloned instead of the default copy behavior.</source>
          <target state="translated">Всегда запускайте двоичный файл pg_upgrade нового сервера, а не старого. pg_upgrade требует указания старых и новых каталогов данных и исполняемых файлов ( &lt;code&gt;bin&lt;/code&gt; ) кластера . Вы также можете указать значения пользователя и порта, а также указать, хотите ли вы, чтобы файлы данных были связаны или клонированы вместо поведения копирования по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ed314eaaeb4f7d7933efa77539bb6dd24179fb4e" translate="yes" xml:space="preserve">
          <source>American National Standards Institute</source>
          <target state="translated">Американский национальный институт стандартов</target>
        </trans-unit>
        <trans-unit id="9b0f6aa450d937f102baa99a591a10b175502ace" translate="yes" xml:space="preserve">
          <source>American Standard Code for Information Interchange</source>
          <target state="translated">Американский стандартный код для информационного обмена</target>
        </trans-unit>
        <trans-unit id="f772502aac0c6acdc4a93caa9a6a863fee25bd39" translate="yes" xml:space="preserve">
          <source>Among all relational operators the most difficult one to process and optimize is the &lt;em&gt;join&lt;/em&gt;. The number of possible query plans grows exponentially with the number of joins in the query. Further optimization effort is caused by the support of a variety of &lt;em&gt;join methods&lt;/em&gt; (e.g., nested loop, hash join, merge join in PostgreSQL) to process individual joins and a diversity of &lt;em&gt;indexes&lt;/em&gt; (e.g., B-tree, hash, GiST and GIN in PostgreSQL) as access paths for relations.</source>
          <target state="translated">Среди всех реляционных операторов сложнее всего обрабатывать и оптимизировать &lt;em&gt;соединение&lt;/em&gt; . Число возможных планов запроса растет экспоненциально с увеличением числа соединений в запросе. Дальнейшие усилия по оптимизации вызваны поддержкой множества &lt;em&gt;методов объединения&lt;/em&gt; (например, вложенного цикла, хэш-соединения, объединения слиянием в PostgreSQL) для обработки отдельных объединений и разнообразия &lt;em&gt;индексов&lt;/em&gt; (например, B-дерево, хеш, GiST и GIN в PostgreSQL) как пути доступа к отношениям.</target>
        </trans-unit>
        <trans-unit id="a06f60f435b117a486b4b9306faa4f936e74dfd4" translate="yes" xml:space="preserve">
          <source>Amount of data streamed. This counter only advances when the phase is &lt;code&gt;streaming database files&lt;/code&gt; or &lt;code&gt;transferring wal files&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb98c34253bd6741e222de32790839f4b0bbf938" translate="yes" xml:space="preserve">
          <source>An &amp;ldquo;ordering&amp;rdquo; operator entry indicates that an index of this operator family can be scanned to return rows in the order represented by &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Such an operator could return any sortable data type, though again its left-hand input type must match the index's column data type. The exact semantics of the &lt;code&gt;ORDER BY&lt;/code&gt; are specified by the &lt;code&gt;amopsortfamily&lt;/code&gt; column, which must reference a B-tree operator family for the operator's result type.</source>
          <target state="translated">&amp;laquo;Упорядочение&amp;raquo; запись оператор указывает на то, что индекс этого оператора семейства могут быть отсканированы , чтобы возвращать строки в порядке , представленного &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; . Такой оператор может возвращать любой сортируемый тип данных, хотя опять же его левый тип ввода должен соответствовать типу данных столбца индекса. Точная семантика &lt;code&gt;ORDER BY&lt;/code&gt; определяется &lt;code&gt;amopsortfamily&lt;/code&gt; , который должен ссылаться на семейство операторов B-дерева для типа результата оператора.</target>
        </trans-unit>
        <trans-unit id="6d377056771f89a3a21b9faebc41fe3335e17744" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attribute&lt;/a&gt; found in a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;view&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1279b86476578e5585aff75989181f73dcffd4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=&lt;/code&gt; operator must be an equivalence relation; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; of the data type:</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; Оператор должен быть отношением эквивалентности; то есть для всех ненулевых значений &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; типа данных:</target>
        </trans-unit>
        <trans-unit id="c4237e342da22e5fcef0feed597ee14805fa3aa4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;equalimage&lt;/code&gt; function must have the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009a293231558c68203740163c433bc30d08defc" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;in_range&lt;/code&gt; function must have the signature</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; функция должна иметь подпись</target>
        </trans-unit>
        <trans-unit id="89039523af081d32fe0dcce5afd61336bd5c01d2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;options&lt;/code&gt; support function must have the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857fc13a44d4059f0989bb54c261a11965498b57" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;unaccent&lt;/code&gt; dictionary accepts the following options:</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; словарь принимает следующие параметры:</target>
        </trans-unit>
        <trans-unit id="044945d1a76181f7c4bcb8b32669d47c02d34474" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;aggregate expression&lt;/em&gt; represents the application of an aggregate function across the rows selected by a query. An aggregate function reduces multiple inputs to a single output value, such as the sum or average of the inputs. The syntax of an aggregate expression is one of the following:</source>
          <target state="translated">&lt;em&gt;Агрегатное выражение&lt;/em&gt; представляет собой применение совокупной функции по строкам , выбранных запросом. Агрегатная функция сокращает несколько входов до одного выходного значения, такого как сумма или среднее значение входов. Синтаксис агрегатного выражения может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="9cf57ce9f4c43bfd5a2501334071928e81cfc082" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;operator class&lt;/em&gt; can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is in &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; and in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">Для каждого столбца индекса можно указать &lt;em&gt;класс оператора&lt;/em&gt; . Класс операторов определяет операторы, которые будут использоваться индексом для этого столбца. Например, индекс B-дерева для четырехбайтовых целых чисел будет использовать класс &lt;code&gt;int4_ops&lt;/code&gt; ; этот класс операторов включает функции сравнения для четырехбайтовых целых чисел. На практике обычно достаточно класса операторов по умолчанию для типа данных столбца. Суть наличия классов операторов состоит в том, что для некоторых типов данных может быть более одного значимого упорядочивания. Например, мы могли бы захотеть отсортировать тип данных комплексного числа либо по абсолютному значению, либо по действительной части. Мы могли бы сделать это, определив два класса операторов для типа данных, а затем выбрав соответствующий класс при создании индекса. Более подробная информация о классах операторов находится в&lt;a href=&quot;indexes-opclass&quot;&gt;Раздел 11.10&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Раздел 37.16&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cd3ddc4485e8a07b58b1b313130fa7a0d1e8729" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;operator class&lt;/em&gt; with optional parameters can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is in &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; and in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d61fa80ff015b13be4db7ffab694d479aec5c7" translate="yes" xml:space="preserve">
          <source>An ARE can begin with &lt;em&gt;embedded options&lt;/em&gt;: a sequence &lt;code&gt;(?&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;xyz&lt;/code&gt; is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options &amp;mdash; in particular, they can override the case-sensitivity behavior implied by a regex operator, or the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function. The available option letters are shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;. Note that these same option letters are used in the &lt;code&gt;flags&lt;/code&gt; parameters of regex functions.</source>
          <target state="translated">ARE может начинаться со &lt;em&gt;встроенных параметров&lt;/em&gt; : последовательность &lt;code&gt;(?&lt;/code&gt; &lt;code&gt;xyz&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; (где &lt;code&gt;xyz&lt;/code&gt; - один или несколько буквенных символов) определяет параметры, влияющие на остальную часть RE. Эти параметры переопределяют любые ранее определенные параметры - в частности, они могут переопределять поведение чувствительности к регистру, подразумеваемое оператором регулярного выражения, или параметром &lt;code&gt;flags&lt;/code&gt; функции регулярного выражения. Буквы доступных вариантов показаны в &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Табл. 9.23&lt;/a&gt; . Обратите внимание, что эти же буквы параметров используются в параметрах &lt;code&gt;flags&lt;/code&gt; функций регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="451a7edefd1d33d9d12316f5963ee8b77dc6c002" translate="yes" xml:space="preserve">
          <source>An ARE can begin with &lt;em&gt;embedded options&lt;/em&gt;: a sequence &lt;code&gt;(?&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;xyz&lt;/code&gt; is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options &amp;mdash; in particular, they can override the case-sensitivity behavior implied by a regex operator, or the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function. The available option letters are shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;. Note that these same option letters are used in the &lt;code&gt;flags&lt;/code&gt; parameters of regex functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8303919571de789ee40617113cb585782a02b887" translate="yes" xml:space="preserve">
          <source>An IP address range is specified using standard numeric notation for the range's starting address, then a slash (&lt;code&gt;/&lt;/code&gt;) and a CIDR mask length. The mask length indicates the number of high-order bits of the client IP address that must match. Bits to the right of this should be zero in the given IP address. There must not be any white space between the IP address, the &lt;code&gt;/&lt;/code&gt;, and the CIDR mask length.</source>
          <target state="translated">Диапазон IP-адресов указывается с использованием стандартной цифровой записи для начального адреса диапазона, затем косой черты ( &lt;code&gt;/&lt;/code&gt; ) и длины маски CIDR. Длина маски указывает количество старших битов IP-адреса клиента, которые должны совпадать. Биты справа от этого должны быть нулевыми в данном IP-адресе. Между IP-адресом, символом &lt;code&gt;/&lt;/code&gt; и длиной маски CIDR не должно быть пробелов .</target>
        </trans-unit>
        <trans-unit id="4d44878e850b43c3405e5eb1f7f363ec736fdcdb" translate="yes" xml:space="preserve">
          <source>An RE can begin with one of two special &lt;em&gt;director&lt;/em&gt; prefixes. If an RE begins with &lt;code&gt;***:&lt;/code&gt;, the rest of the RE is taken as an ARE. (This normally has no effect in PostgreSQL, since REs are assumed to be AREs; but it does have an effect if ERE or BRE mode had been specified by the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function.) If an RE begins with &lt;code&gt;***=&lt;/code&gt;, the rest of the RE is taken to be a literal string, with all characters considered ordinary characters.</source>
          <target state="translated">RE может начинаться с одного из двух специальных префиксов &lt;em&gt;директора&lt;/em&gt; . Если RE начинается с &lt;code&gt;***:&lt;/code&gt; , остальная часть RE принимается как ARE. (Обычно это не действует в PostgreSQL, поскольку предполагается, что RE являются ARE; но он имеет эффект, если режим ERE или BRE был указан параметром &lt;code&gt;flags&lt;/code&gt; для функции регулярного выражения.) Если RE начинается с &lt;code&gt;***=&lt;/code&gt; остальная часть RE принимается за буквальную строку, в которой все символы считаются обычными.</target>
        </trans-unit>
        <trans-unit id="f92f9e66ed8af2bcc3cdde26f5c0bbb45e8250e2" translate="yes" xml:space="preserve">
          <source>An RE cannot end with a backslash (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">RE не может заканчиваться обратной косой чертой ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="081369b9016058fa6fc78b0eda53f1fad864ebdf" translate="yes" xml:space="preserve">
          <source>An RE consisting of two or more branches connected by the &lt;code&gt;|&lt;/code&gt; operator is always greedy.</source>
          <target state="translated">RE, состоящий из двух или более ветвей, соединенных &lt;code&gt;|&lt;/code&gt; оператор всегда жадный.</target>
        </trans-unit>
        <trans-unit id="d49fecf670a244dc0b1f819b231bb69a34573ff1" translate="yes" xml:space="preserve">
          <source>An RFC 4516 LDAP URL. This is an alternative way to write some of the other LDAP options in a more compact and standard form. The format is</source>
          <target state="translated">URL LDAP RFC 4516.Это альтернативный способ написания некоторых других вариантов LDAP в более компактной и стандартной форме.Формат</target>
        </trans-unit>
        <trans-unit id="f7312c64a5fb73a6994e92da5b12fd76cc61e03e" translate="yes" xml:space="preserve">
          <source>An SHA1 hash of the random prefix and data is appended.</source>
          <target state="translated">Добавляется SHA1-хэш случайного префикса и данных.</target>
        </trans-unit>
        <trans-unit id="c3a965fc350f5f7dc5c4c1f8d246e2c0ef7db3f8" translate="yes" xml:space="preserve">
          <source>An SQL command that is used to allow a &lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;user&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;role&lt;/a&gt; to access specific objects within the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6dc35165836f5ddf8c81146786e84d00be18739" translate="yes" xml:space="preserve">
          <source>An SQL command used to add new data into a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8802fb5ebf1fb183b8afc9517e0fb8a334aaa1ec" translate="yes" xml:space="preserve">
          <source>An SQL command used to modify &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; that may already exist in a specified &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;. It cannot create or remove rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2cced83fa51a6d9077bcc4256624ffa5277885e" translate="yes" xml:space="preserve">
          <source>An SQL command which removes &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; from a given &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fe55953856dbcea542a9b75d2a05e987bd7029" translate="yes" xml:space="preserve">
          <source>An SQL statement defining an object to be created within the schema. Currently, only &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE VIEW&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE SEQUENCE&lt;/code&gt;, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and &lt;code&gt;GRANT&lt;/code&gt; are accepted as clauses within &lt;code&gt;CREATE SCHEMA&lt;/code&gt;. Other kinds of objects may be created in separate commands after the schema is created.</source>
          <target state="translated">Оператор SQL, определяющий объект, который должен быть создан в схеме. В настоящее время в &lt;code&gt;CREATE SCHEMA&lt;/code&gt; в качестве предложений принимаются только &lt;code&gt;CREATE TABLE&lt;/code&gt; , &lt;code&gt;CREATE VIEW&lt;/code&gt; , &lt;code&gt;CREATE INDEX&lt;/code&gt; , &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; , &lt;code&gt;CREATE TRIGGER&lt;/code&gt; и &lt;code&gt;GRANT&lt;/code&gt; . Другие виды объектов могут быть созданы в отдельных командах после создания схемы.</target>
        </trans-unit>
        <trans-unit id="48fae02660a1ba4984826c61b82cac7e0aec9ce9" translate="yes" xml:space="preserve">
          <source>An SQL/JSON path expression is typically written in an SQL query as an SQL character string literal, so it must be enclosed in single quotes, and any single quotes desired within the value must be doubled (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;). Some forms of path expressions require string literals within them. These embedded string literals follow JavaScript/ECMAScript conventions: they must be surrounded by double quotes, and backslash escapes may be used within them to represent otherwise-hard-to-type characters. In particular, the way to write a double quote within an embedded string literal is &lt;code&gt;\&quot;&lt;/code&gt;, and to write a backslash itself, you must write &lt;code&gt;\\&lt;/code&gt;. Other special backslash sequences include those recognized in JSON strings: &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\v&lt;/code&gt; for various ASCII control characters, and &lt;code&gt;\uNNNN&lt;/code&gt; for a Unicode character identified by its 4-hex-digit code point. The backslash syntax also includes two cases not allowed by JSON: &lt;code&gt;\xNN&lt;/code&gt; for a character code written with only two hex digits, and &lt;code&gt;\u{N...}&lt;/code&gt; for a character code written with 1 to 6 hex digits.</source>
          <target state="translated">Выражение пути SQL / JSON обычно записывается в запросе SQL в виде строкового литерала символов SQL, поэтому оно должно быть заключено в одинарные кавычки, а любые одинарные кавычки, желаемые в значении, должны быть удвоены (см. &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Раздел 4.1.2.1&lt;/a&gt; ). Некоторые формы выражений пути требуют внутри себя строковых литералов. Эти встроенные строковые литералы следуют соглашениям JavaScript / ECMAScript: они должны быть заключены в двойные кавычки, а в них могут использоваться символы обратной косой черты для представления символов, которые иначе трудно ввести. В частности, способ записи двойной кавычки во встроенном строковом литерале - &lt;code&gt;\&quot;&lt;/code&gt; , а для записи самой обратной косой черты необходимо написать &lt;code&gt;\\&lt;/code&gt; . Другие специальные последовательности обратной косой черты включают те, которые распознаются в строках JSON: &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , &lt;code&gt;\v&lt;/code&gt; для различных управляющих символов ASCII и &lt;code&gt;\uNNNN&lt;/code&gt; для символа Unicode, идентифицируемого его 4-х шестнадцатеричной кодовой точкой. Синтаксис обратной косой черты также включает два случая, не разрешенных JSON: &lt;code&gt;\xNN&lt;/code&gt; для кода символа, записанного только с двумя шестнадцатеричными цифрами, и &lt;code&gt;\u{N...}&lt;/code&gt; для кода символа, записанного с помощью от 1 до 6 шестнадцатеричных цифр.</target>
        </trans-unit>
        <trans-unit id="a47144dcc7f07df67a82e2f341e637ce0d341143" translate="yes" xml:space="preserve">
          <source>An additional caveat, if the goal is to avoid recalculating &lt;code&gt;f(x)&lt;/code&gt;, is that the planner won't necessarily match uses of &lt;code&gt;f(x)&lt;/code&gt; that aren't in indexable &lt;code&gt;WHERE&lt;/code&gt; clauses to the index column. It will usually get this right in simple queries such as shown above, but not in queries that involve joins. These deficiencies may be remedied in future versions of PostgreSQL.</source>
          <target state="translated">Дополнительное предостережение, если цель состоит в том, чтобы избежать повторного вычисления &lt;code&gt;f(x)&lt;/code&gt; , заключается в том, что планировщик не обязательно будет сопоставлять использование &lt;code&gt;f(x)&lt;/code&gt; которое отсутствует в индексируемых &lt;code&gt;WHERE&lt;/code&gt; для столбца индекса. Обычно это выполняется в простых запросах, таких как показанные выше, но не в запросах, включающих соединения. Эти недостатки могут быть исправлены в будущих версиях PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="7407a4adf6d27ef60782fee33abc21dda639d1bb" translate="yes" xml:space="preserve">
          <source>An additional expectation is that &lt;code&gt;in_range&lt;/code&gt; functions should, if practical, avoid throwing an error if &lt;code&gt;base&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;base&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; would overflow. The correct comparison result can be determined even if that value would be out of the data type's range. Note that if the data type includes concepts such as &amp;ldquo;infinity&amp;rdquo; or &amp;ldquo;NaN&amp;rdquo;, extra care may be needed to ensure that &lt;code&gt;in_range&lt;/code&gt;'s results agree with the normal sort order of the operator family.</source>
          <target state="translated">Дополнительное ожидание состоит в том, что функции &lt;code&gt;in_range&lt;/code&gt; должны, если это возможно, избегать выдачи ошибки, если &lt;code&gt;base&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; или &lt;code&gt;base&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; будут переполнены. Правильный результат сравнения может быть определен, даже если это значение будет вне диапазона типа данных. Обратите внимание, что если тип данных включает такие понятия, как &amp;laquo;бесконечность&amp;raquo; или &amp;laquo;NaN&amp;raquo;, может потребоваться дополнительная осторожность, чтобы гарантировать, что результаты &lt;code&gt;in_range&lt;/code&gt; соответствуют нормальному порядку сортировки семейства операторов.</target>
        </trans-unit>
        <trans-unit id="eb253cb4aa708d5943b4ee75823919dac326e149" translate="yes" xml:space="preserve">
          <source>An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic &lt;em&gt;type categories&lt;/em&gt;, including &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timespan&lt;/code&gt;, &lt;code&gt;geometric&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and user-defined. (For a list see &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.63&lt;/a&gt;; but note it is also possible to create custom type categories.) Within each category there can be one or more &lt;em&gt;preferred types&lt;/em&gt;, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534defd7e745925ed14ebff65872ea3017b9134a" translate="yes" xml:space="preserve">
          <source>An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic &lt;em&gt;type categories&lt;/em&gt;, including &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timespan&lt;/code&gt;, &lt;code&gt;geometric&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and user-defined. (For a list see &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;; but note it is also possible to create custom type categories.) Within each category there can be one or more &lt;em&gt;preferred types&lt;/em&gt;, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way.</source>
          <target state="translated">Дополнительная эвристика, предоставляемая синтаксическим анализатором, позволяет улучшить определение правильного поведения приведения типов среди групп типов, которые имеют неявные приведения. Типы данных делятся на несколько основных &lt;em&gt;категорий типов&lt;/em&gt; , включая &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , цепочки &lt;code&gt;bitstring&lt;/code&gt; , &lt;code&gt;datetime&lt;/code&gt; , &lt;code&gt;timespan&lt;/code&gt; , &lt;code&gt;geometric&lt;/code&gt; , &lt;code&gt;network&lt;/code&gt; и определяемые пользователем. (Список см. В &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Таблице 51.64&lt;/a&gt; ; но обратите внимание, что также можно создавать категории пользовательских типов.) Внутри каждой категории может быть один или несколько &lt;em&gt;предпочтительных типов.&lt;/em&gt;, которые предпочтительны при выборе возможных типов. При тщательном выборе предпочтительных типов и доступных неявных приведений можно гарантировать, что неоднозначные выражения (с несколькими вариантами синтаксического анализа) могут быть разрешены полезным способом.</target>
        </trans-unit>
        <trans-unit id="7fc0f4d6b418b13b44c7318de707eba4cc69a20d" translate="yes" xml:space="preserve">
          <source>An additional property of most of the OID alias types is the creation of dependencies. If a constant of one of these types appears in a stored expression (such as a column default expression or view), it creates a dependency on the referenced object. For example, if a column has a default expression &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt;, PostgreSQL understands that the default expression depends on the sequence &lt;code&gt;my_seq&lt;/code&gt;; the system will not let the sequence be dropped without first removing the default expression. &lt;code&gt;regrole&lt;/code&gt; is the only exception for the property. Constants of this type are not allowed in such expressions.</source>
          <target state="translated">Дополнительным свойством большинства типов псевдонимов OID является создание зависимостей. Если константа одного из этих типов появляется в сохраненном выражении (таком как выражение или представление столбца по умолчанию), она создает зависимость от объекта, на который имеется ссылка. Например, если в столбце есть выражение по умолчанию &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt; , PostgreSQL понимает, что выражение по умолчанию зависит от последовательности &lt;code&gt;my_seq&lt;/code&gt; ; система не позволит отбросить последовательность без предварительного удаления выражения по умолчанию. &lt;code&gt;regrole&lt;/code&gt; является единственным исключением для собственности. В таких выражениях нельзя использовать константы этого типа.</target>
        </trans-unit>
        <trans-unit id="458e50f0c0fe0a599acde7428114320c8fb97644" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;moving-aggregate mode&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Section 37.12.1&lt;/a&gt;. This requires specifying the &lt;code&gt;MSFUNC&lt;/code&gt;, &lt;code&gt;MINVFUNC&lt;/code&gt;, and &lt;code&gt;MSTYPE&lt;/code&gt; parameters, and optionally the &lt;code&gt;MSSPACE&lt;/code&gt;, &lt;code&gt;MFINALFUNC&lt;/code&gt;, &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;, &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt;, and &lt;code&gt;MINITCOND&lt;/code&gt; parameters. Except for &lt;code&gt;MINVFUNC&lt;/code&gt;, these parameters work like the corresponding simple-aggregate parameters without &lt;code&gt;M&lt;/code&gt;; they define a separate implementation of the aggregate that includes an inverse transition function.</source>
          <target state="translated">Агрегат может дополнительно поддерживать &lt;em&gt;режим движущегося агрегата&lt;/em&gt; , как описано в &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Разделе 37.12.1&lt;/a&gt; . Для этого необходимо указать параметры &lt;code&gt;MSFUNC&lt;/code&gt; , &lt;code&gt;MINVFUNC&lt;/code&gt; и &lt;code&gt;MSTYPE&lt;/code&gt; и, необязательно, параметры &lt;code&gt;MSSPACE&lt;/code&gt; , &lt;code&gt;MFINALFUNC&lt;/code&gt; , &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; , &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt; и &lt;code&gt;MINITCOND&lt;/code&gt; . За исключением &lt;code&gt;MINVFUNC&lt;/code&gt; , эти параметры работают как соответствующие параметры простого агрегирования без &lt;code&gt;M&lt;/code&gt; ; они определяют отдельную реализацию агрегата, которая включает функцию обратного перехода.</target>
        </trans-unit>
        <trans-unit id="29fb09a88b1e0b362734b37fcd73ac91f7b1c450" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;moving-aggregate mode&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Section 37.12.1&lt;/a&gt;. This requires specifying the &lt;code&gt;MSFUNC&lt;/code&gt;, &lt;code&gt;MINVFUNC&lt;/code&gt;, and &lt;code&gt;MSTYPE&lt;/code&gt; parameters, and optionally the &lt;code&gt;MSSPACE&lt;/code&gt;, &lt;code&gt;MFINALFUNC&lt;/code&gt;, &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;, &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt;, and &lt;code&gt;MINITCOND&lt;/code&gt; parameters. Except for &lt;code&gt;MINVFUNC&lt;/code&gt;, these parameters work like the corresponding simple-aggregate parameters without &lt;code&gt;M&lt;/code&gt;; they define a separate implementation of the aggregate that includes an inverse transition function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d679ad2d9aaa3f73ccadb1adf16347c9d1df070" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;partial aggregation&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Section 37.12.4&lt;/a&gt;. This requires specifying the &lt;code&gt;COMBINEFUNC&lt;/code&gt; parameter. If the &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, it's usually also appropriate to provide the &lt;code&gt;SERIALFUNC&lt;/code&gt; and &lt;code&gt;DESERIALFUNC&lt;/code&gt; parameters so that parallel aggregation is possible. Note that the aggregate must also be marked &lt;code&gt;PARALLEL SAFE&lt;/code&gt; to enable parallel aggregation.</source>
          <target state="translated">Агрегат может дополнительно поддерживать &lt;em&gt;частичное агрегирование&lt;/em&gt; , как описано в &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Подразделе 37.12.4&lt;/a&gt; . Для этого необходимо указать параметр &lt;code&gt;COMBINEFUNC&lt;/code&gt; . Если &lt;code&gt;state_data_type&lt;/code&gt; является &lt;code&gt;internal&lt;/code&gt; , обычно также целесообразно предоставить параметры &lt;code&gt;SERIALFUNC&lt;/code&gt; и &lt;code&gt;DESERIALFUNC&lt;/code&gt; , чтобы было возможно параллельное агрегирование. Обратите внимание, что агрегат также должен быть помечен как &lt;code&gt;PARALLEL SAFE&lt;/code&gt; чтобы включить параллельное агрегирование.</target>
        </trans-unit>
        <trans-unit id="f7e84609c5356ef9572b92f634b5a8669d5cf54b" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;partial aggregation&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Section 37.12.4&lt;/a&gt;. This requires specifying the &lt;code&gt;COMBINEFUNC&lt;/code&gt; parameter. If the &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, it's usually also appropriate to provide the &lt;code&gt;SERIALFUNC&lt;/code&gt; and &lt;code&gt;DESERIALFUNC&lt;/code&gt; parameters so that parallel aggregation is possible. Note that the aggregate must also be marked &lt;code&gt;PARALLEL SAFE&lt;/code&gt; to enable parallel aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfc7ac5613e772bc99452f1945c3b220614eb51" translate="yes" xml:space="preserve">
          <source>An aggregate expression</source>
          <target state="translated">Совокупное выражение</target>
        </trans-unit>
        <trans-unit id="e0807075b6b78aa07561f78a847dd6293e2860ad" translate="yes" xml:space="preserve">
          <source>An aggregate expression can only appear in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; command. It is forbidden in other clauses, such as &lt;code&gt;WHERE&lt;/code&gt;, because those clauses are logically evaluated before the results of aggregates are formed.</source>
          <target state="translated">Агрегатное выражение может появляться только в списке результатов или в предложении &lt;code&gt;HAVING&lt;/code&gt; команды &lt;code&gt;SELECT&lt;/code&gt; . Это запрещено в других предложениях, таких как &lt;code&gt;WHERE&lt;/code&gt; , потому что эти предложения логически вычисляются до формирования результатов агрегатов.</target>
        </trans-unit>
        <trans-unit id="d5cc6417758e002213e0379735846ccb8b7a9410" translate="yes" xml:space="preserve">
          <source>An aggregate function can provide an initial condition, that is, an initial value for the internal state value. This is specified and stored in the database as a value of type &lt;code&gt;text&lt;/code&gt;, but it must be a valid external representation of a constant of the state value data type. If it is not supplied then the state value starts out null.</source>
          <target state="translated">Агрегатная функция может предоставить начальное условие, то есть начальное значение для значения внутреннего состояния. Он указывается и сохраняется в базе данных как значение типа &lt;code&gt;text&lt;/code&gt; , но должно быть допустимым внешним представлением константы типа данных значения состояния. Если он не указан, значение состояния начинается с нуля.</target>
        </trans-unit>
        <trans-unit id="4c0a9d3ddcc76a8af6ce90bf3fe2aed9cae7fe77" translate="yes" xml:space="preserve">
          <source>An aggregate function is identified by its name and input data type(s). Two aggregates in the same schema can have the same name if they operate on different input types. The name and input data type(s) of an aggregate must also be distinct from the name and input data type(s) of every ordinary function in the same schema. This behavior is identical to overloading of ordinary function names (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;).</source>
          <target state="translated">Агрегатная функция идентифицируется по ее имени и типу входных данных. Два агрегата в одной схеме могут иметь одно и то же имя, если они работают с разными типами ввода. Имя и тип (ы) входных данных агрегата также должны отличаться от имени и типа (ов) входных данных каждой обычной функции в той же схеме. Это поведение идентично перегрузке обычных имен функций (см. &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2b3e0e3a20d60ad454bd8cd7d186466b528e1274" translate="yes" xml:space="preserve">
          <source>An aggregate function whose &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt; can participate in parallel aggregation only if it has a &lt;code&gt;serialfunc&lt;/code&gt; function, which must serialize the aggregate state into a &lt;code&gt;bytea&lt;/code&gt; value for transmission to another process. This function must take a single argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;bytea&lt;/code&gt;. A corresponding &lt;code&gt;deserialfunc&lt;/code&gt; is also required.</source>
          <target state="translated">Агрегатная функция, у которой &lt;code&gt;state_data_type&lt;/code&gt; является &lt;code&gt;internal&lt;/code&gt; может участвовать в параллельной агрегации только в том случае, если у нее есть функция &lt;code&gt;serialfunc&lt;/code&gt; , которая должна сериализовать агрегированное состояние в значение &lt;code&gt;bytea&lt;/code&gt; для передачи другому процессу. Эта функция должна принимать один аргумент типа &lt;code&gt;internal&lt;/code&gt; и возвращаемого типа &lt;code&gt;bytea&lt;/code&gt; . Также требуется соответствующая &lt;code&gt;deserialfunc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df00344c6606cf49c7be60428adf4c46220a9708" translate="yes" xml:space="preserve">
          <source>An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the column added by &lt;code&gt;ORDINALITY&lt;/code&gt; if present.</source>
          <target state="translated">Псевдоним может быть указан так же, как и для таблицы. Если записан псевдоним, список псевдонимов столбцов также может быть написан для предоставления замещающих имен для одного или нескольких атрибутов составного типа возвращаемого значения функции, включая столбец, добавленный &lt;code&gt;ORDINALITY&lt;/code&gt; , если он присутствует.</target>
        </trans-unit>
        <trans-unit id="a0250a12b43f45cb324a618ef9cdbd68812da4e5" translate="yes" xml:space="preserve">
          <source>An alternative backup strategy is to directly copy the files that PostgreSQL uses to store the data in the database; &lt;a href=&quot;creating-cluster&quot;&gt;Section 18.2&lt;/a&gt; explains where these files are located. You can use whatever method you prefer for doing file system backups; for example:</source>
          <target state="translated">Альтернативная стратегия резервного копирования - прямое копирование файлов, которые PostgreSQL использует для хранения данных в базе данных; &lt;a href=&quot;creating-cluster&quot;&gt;В разделе 18.2&lt;/a&gt; объясняется, где находятся эти файлы. Вы можете использовать любой метод резервного копирования файловой системы; например:</target>
        </trans-unit>
        <trans-unit id="b61de693c26d02887a03f9b9c2b1cd2f4c796982" translate="yes" xml:space="preserve">
          <source>An alternative file-system backup approach is to make a &amp;ldquo;consistent snapshot&amp;rdquo; of the data directory, if the file system supports that functionality (and you are willing to trust that it is implemented correctly). The typical procedure is to make a &amp;ldquo;frozen snapshot&amp;rdquo; of the volume containing the database, then copy the whole data directory (not just parts, see above) from the snapshot to a backup device, then release the frozen snapshot. This will work even while the database server is running. However, a backup created in this way saves the database files in a state as if the database server was not properly shut down; therefore, when you start the database server on the backed-up data, it will think the previous server instance crashed and will replay the WAL log. This is not a problem; just be aware of it (and be sure to include the WAL files in your backup). You can perform a &lt;code&gt;CHECKPOINT&lt;/code&gt; before taking the snapshot to reduce recovery time.</source>
          <target state="translated">Альтернативный подход к резервному копированию файловой системы заключается в создании &amp;laquo;согласованного снимка&amp;raquo; каталога данных, если файловая система поддерживает эту функцию (и вы готовы верить, что она реализована правильно). Типичная процедура состоит в том, чтобы сделать &amp;laquo;замороженный снимок&amp;raquo; тома, содержащего базу данных, затем скопировать весь каталог данных (а не только его части, см. Выше) из снимка на устройство резервного копирования, а затем освободить замороженный снимок. Это будет работать даже во время работы сервера базы данных. Однако резервная копия, созданная таким образом, сохраняет файлы базы данных в таком состоянии, как если бы сервер базы данных не был выключен должным образом; поэтому, когда вы запускаете сервер базы данных с данными из резервной копии, он будет думать, что предыдущий экземпляр сервера вышел из строя, и воспроизведет журнал WAL. Это не является проблемой;просто помните об этом (и обязательно включите файлы WAL в свою резервную копию). Вы можете выполнить &lt;code&gt;CHECKPOINT&lt;/code&gt; прежде чем делать снимок, чтобы сократить время восстановления.</target>
        </trans-unit>
        <trans-unit id="c3c3283b5d81a417bf78d55aa00de334b32f532e" translate="yes" xml:space="preserve">
          <source>An alternative syntax, which conforms to the SQL standard by using the keyword &lt;code&gt;ARRAY&lt;/code&gt;, can be used for one-dimensional arrays. &lt;code&gt;pay_by_quarter&lt;/code&gt; could have been defined as:</source>
          <target state="translated">Альтернативный синтаксис, соответствующий стандарту SQL с использованием ключевого слова &lt;code&gt;ARRAY&lt;/code&gt; , может использоваться для одномерных массивов. &lt;code&gt;pay_by_quarter&lt;/code&gt; можно было бы определить как:</target>
        </trans-unit>
        <trans-unit id="638c7c832e5e9b62d5fb5f6d733b2905e931d645" translate="yes" xml:space="preserve">
          <source>An alternative to the built-in standby mode described in the previous sections is to use a &lt;code&gt;restore_command&lt;/code&gt; that polls the archive location. This was the only option available in versions 8.4 and below. See the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module for a reference implementation of this.</source>
          <target state="translated">Альтернативой встроенному режиму ожидания, описанному в предыдущих разделах, является использование команды &lt;code&gt;restore_command&lt;/code&gt; , которая опрашивает расположение архива. Это был единственный вариант, доступный в версиях 8.4 и ниже. См. Справочную реализацию этого в модуле &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b7165adb636504ac5f79579ceffb000f734741" translate="yes" xml:space="preserve">
          <source>An alternative to the built-in standby mode described in the previous sections is to use a &lt;code&gt;restore_command&lt;/code&gt; that polls the archive location. This was the only option available in versions 8.4 and below. See the &lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module for a reference implementation of this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa59772716d4044140c10df2d8b7a5924c081417" translate="yes" xml:space="preserve">
          <source>An alternative way to specify connection parameters is in a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string or a URI, which is used instead of a database name. This mechanism give you very wide control over the connection. For example:</source>
          <target state="translated">Альтернативный способ указать параметры подключения - это строка &lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt; или URI, который используется вместо имени базы данных. Этот механизм дает вам очень широкий контроль над подключением. Например:</target>
        </trans-unit>
        <trans-unit id="8ec33e5bc23fcb877ba4c42aa95a3a9f21f59a6d" translate="yes" xml:space="preserve">
          <source>An arbitrary identifier that later identifies this transaction for &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. The identifier must be written as a string literal, and must be less than 200 bytes long. It must not be the same as the identifier used for any currently prepared transaction.</source>
          <target state="translated">Произвольный идентификатор, который позже идентифицирует эту транзакцию для &lt;code&gt;COMMIT PREPARED&lt;/code&gt; или &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; . Идентификатор должен быть записан в виде строкового литерала и должен быть меньше 200 байт. Он не должен совпадать с идентификатором, используемым для любой готовой в данный момент транзакции.</target>
        </trans-unit>
        <trans-unit id="154d8a4c4e542e35a1befe68e1484bcdb9bfce9b" translate="yes" xml:space="preserve">
          <source>An arbitrary name given to this particular prepared statement. It must be unique within a single session and is subsequently used to execute or deallocate a previously prepared statement.</source>
          <target state="translated">Произвольное название,данное данному конкретному подготовленному заявлению.Оно должно быть уникальным в рамках одного сеанса и впоследствии используется для выполнения или перемещения ранее подготовленного заявления.</target>
        </trans-unit>
        <trans-unit id="8cfd518cee734d4e6e12ef304061cfa2c5efcc5d" translate="yes" xml:space="preserve">
          <source>An array can also be constructed by using the functions &lt;code&gt;array_prepend&lt;/code&gt;, &lt;code&gt;array_append&lt;/code&gt;, or &lt;code&gt;array_cat&lt;/code&gt;. The first two only support one-dimensional arrays, but &lt;code&gt;array_cat&lt;/code&gt; supports multidimensional arrays. Some examples:</source>
          <target state="translated">Массив также можно создать с помощью функций &lt;code&gt;array_prepend&lt;/code&gt; , &lt;code&gt;array_append&lt;/code&gt; или &lt;code&gt;array_cat&lt;/code&gt; . Первые два поддерживают только одномерные массивы, но &lt;code&gt;array_cat&lt;/code&gt; поддерживает многомерные массивы. Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="b9253fad046b597c92ebf100d62457d49600956f" translate="yes" xml:space="preserve">
          <source>An array can also be updated at a single element:</source>
          <target state="translated">Массив также может быть обновлен одним элементом:</target>
        </trans-unit>
        <trans-unit id="207ba5c2689d9a2decbdf9a201e85765c620f79a" translate="yes" xml:space="preserve">
          <source>An array constructor</source>
          <target state="translated">Массивный конструктор</target>
        </trans-unit>
        <trans-unit id="22dde08afcbb8b9d32ea23d688400ce811c7d712" translate="yes" xml:space="preserve">
          <source>An array constructor is an expression that builds an array value using values for its member elements. A simple array constructor consists of the key word &lt;code&gt;ARRAY&lt;/code&gt;, a left square bracket &lt;code&gt;[&lt;/code&gt;, a list of expressions (separated by commas) for the array element values, and finally a right square bracket &lt;code&gt;]&lt;/code&gt;. For example:</source>
          <target state="translated">Конструктор массива - это выражение, которое строит значение массива, используя значения для его элементов-членов. Простой конструктор массива состоит из ключевого слова &lt;code&gt;ARRAY&lt;/code&gt; , левой квадратной скобки &lt;code&gt;[&lt;/code&gt; , списка выражений (разделенных запятыми) для значений элементов массива и, наконец, правой квадратной скобки &lt;code&gt;]&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="7dbcd90a7826ddce4d84f03c4037551f65cc619b" translate="yes" xml:space="preserve">
          <source>An array containing codes for the enabled statistic kinds; valid values are: &lt;code&gt;d&lt;/code&gt; for n-distinct statistics, &lt;code&gt;f&lt;/code&gt; for functional dependency statistics, and &lt;code&gt;m&lt;/code&gt; for most common values (MCV) list statistics</source>
          <target state="translated">Массив, содержащий коды для включенных видов статистики; допустимые значения: &lt;code&gt;d&lt;/code&gt; для n различных статистик, &lt;code&gt;f&lt;/code&gt; для статистики функциональной зависимости и &lt;code&gt;m&lt;/code&gt; для статистики списка наиболее распространенных значений (MCV)</target>
        </trans-unit>
        <trans-unit id="27ac7c03cbb87eb7b9fd6d5d5942fb204a13357b" translate="yes" xml:space="preserve">
          <source>An array containing the IDs of the roles in this group</source>
          <target state="translated">Массив,содержащий идентификаторы ролей в этой группе</target>
        </trans-unit>
        <trans-unit id="96036220e810514b07282609308d02f0cce74ab2" translate="yes" xml:space="preserve">
          <source>An array of attribute numbers, indicating which table columns are covered by this statistics object; for example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns are covered</source>
          <target state="translated">Массив номеров атрибутов, указывающий, какие столбцы таблицы покрываются данным объектом статистики; например значение &lt;code&gt;1 3&lt;/code&gt; будет означать, что первый и третий столбцы таблицы покрыты</target>
        </trans-unit>
        <trans-unit id="b19c35ad447cc03eaa08f8712bc2b7258decc833" translate="yes" xml:space="preserve">
          <source>An array slice expression likewise yields null if the array itself or any of the subscript expressions are null. However, in other cases such as selecting an array slice that is completely outside the current array bounds, a slice expression yields an empty (zero-dimensional) array instead of null. (This does not match non-slice behavior and is done for historical reasons.) If the requested slice partially overlaps the array bounds, then it is silently reduced to just the overlapping region instead of returning null.</source>
          <target state="translated">Выражение среза массива также дает нулевой результат,если сам массив или любое из выражений абонемента являются нулевыми.Однако в других случаях,например,при выборе среза массива,который полностью выходит за границы текущего массива,выражение среза дает пустой (нулевой)массив вместо нуля.(Это не соответствует поведению неслайсов и делается по историческим причинам.)Если запрашиваемый срез частично перекрывает границы массива,то вместо возврата нуля он беззвучно сводится к простому перекрытию.</target>
        </trans-unit>
        <trans-unit id="1acc2bad9c714dff64f3a38358f5e30f839c8b6c" translate="yes" xml:space="preserve">
          <source>An array subscript expression will return null if either the array itself or any of the subscript expressions are null. Also, null is returned if a subscript is outside the array bounds (this case does not raise an error). For example, if &lt;code&gt;schedule&lt;/code&gt; currently has the dimensions &lt;code&gt;[1:3][1:2]&lt;/code&gt; then referencing &lt;code&gt;schedule[3][3]&lt;/code&gt; yields NULL. Similarly, an array reference with the wrong number of subscripts yields a null rather than an error.</source>
          <target state="translated">Выражение нижнего индекса массива вернет null, если либо сам массив, либо любое из выражений нижнего индекса имеют значение null. Кроме того, значение null возвращается, если нижний индекс находится за пределами массива (в этом случае ошибка не возникает). Например, если &lt;code&gt;schedule&lt;/code&gt; настоящее время имеет размеры &lt;code&gt;[1:3][1:2]&lt;/code&gt; , то ссылка на &lt;code&gt;schedule[3][3]&lt;/code&gt; дает NULL. Точно так же ссылка на массив с неправильным количеством индексов дает ноль, а не ошибку.</target>
        </trans-unit>
        <trans-unit id="0832096d10a386e248df7b28cfa12adfe25aab94" translate="yes" xml:space="preserve">
          <source>An array value can be replaced completely:</source>
          <target state="translated">Значение массива может быть заменено полностью:</target>
        </trans-unit>
        <trans-unit id="af4fc25fcb8b1fcdab019c9c24576221478e42a1" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes all arguments (including &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments); however, if all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripting is 1-based, whereas for historical reasons &lt;code&gt;proargtypes&lt;/code&gt; is subscripted from 0.</source>
          <target state="translated">Массив с типами данных аргументов функции. Сюда входят все аргументы (включая аргументы &lt;code&gt;OUT&lt;/code&gt; и &lt;code&gt;INOUT&lt;/code&gt; ); однако, если все аргументы являются аргументами &lt;code&gt;IN&lt;/code&gt; , это поле будет пустым. Обратите внимание, что индекс &lt;code&gt;proargtypes&lt;/code&gt; с 1, тогда как по историческим причинам индекс proargtypes начинается с 0.</target>
        </trans-unit>
        <trans-unit id="b1056fb2643af14679cc3ecd97ee8851fd6939a7" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes only input arguments (including &lt;code&gt;INOUT&lt;/code&gt; and &lt;code&gt;VARIADIC&lt;/code&gt; arguments), and thus represents the call signature of the function.</source>
          <target state="translated">Массив с типами данных аргументов функции. Это включает только входные аргументы (включая аргументы &lt;code&gt;INOUT&lt;/code&gt; и &lt;code&gt;VARIADIC&lt;/code&gt; ) и, таким образом, представляет сигнатуру вызова функции.</target>
        </trans-unit>
        <trans-unit id="56e64d796da368f4732fec1eac245d18f34b8c2b" translate="yes" xml:space="preserve">
          <source>An array with the modes of the function arguments, encoded as &lt;code&gt;i&lt;/code&gt; for &lt;code&gt;IN&lt;/code&gt; arguments, &lt;code&gt;o&lt;/code&gt; for &lt;code&gt;OUT&lt;/code&gt; arguments, &lt;code&gt;b&lt;/code&gt; for &lt;code&gt;INOUT&lt;/code&gt; arguments, &lt;code&gt;v&lt;/code&gt; for &lt;code&gt;VARIADIC&lt;/code&gt; arguments, &lt;code&gt;t&lt;/code&gt; for &lt;code&gt;TABLE&lt;/code&gt; arguments. If all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">Массив с режимами аргументов функции, закодированный как &lt;code&gt;i&lt;/code&gt; для аргументов &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; для аргументов &lt;code&gt;OUT&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; для аргументов &lt;code&gt;INOUT&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; для аргументов &lt;code&gt;VARIADIC&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; для аргументов &lt;code&gt;TABLE&lt;/code&gt; . Если все аргументы являются аргументами &lt;code&gt;IN&lt;/code&gt; , это поле будет пустым. Обратите внимание, что индексы соответствуют позициям &lt;code&gt;proallargtypes&lt;/code&gt; ,а не &lt;code&gt;proargtypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19750404179dcfe4198dc9453208db71584c69d3" translate="yes" xml:space="preserve">
          <source>An array with the names of the function arguments. Arguments without a name are set to empty strings in the array. If none of the arguments have a name, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">Массив с именами аргументов функции. Аргументы без имени устанавливаются как пустые строки в массиве. Если ни один из аргументов не имеет имени, это поле будет пустым. Обратите внимание, что индексы соответствуют позициям &lt;code&gt;proallargtypes&lt;/code&gt; ,а не &lt;code&gt;proargtypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f01a907c7341c3e9fdd4bc077438737e13efc650" translate="yes" xml:space="preserve">
          <source>An asterisk (&lt;code&gt;*&lt;/code&gt;) can be placed at the end of a synonym in the configuration file. This indicates that the synonym is a prefix. The asterisk is ignored when the entry is used in &lt;code&gt;to_tsvector()&lt;/code&gt;, but when it is used in &lt;code&gt;to_tsquery()&lt;/code&gt;, the result will be a query item with the prefix match marker (see &lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;Section 12.3.2&lt;/a&gt;). For example, suppose we have these entries in &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt;:</source>
          <target state="translated">Звездочку ( &lt;code&gt;*&lt;/code&gt; ) можно поставить в конце синонима в файле конфигурации. Это указывает на то, что синоним является префиксом. Звездочка игнорируется, когда запись используется в &lt;code&gt;to_tsvector()&lt;/code&gt; , но когда она используется в &lt;code&gt;to_tsquery()&lt;/code&gt; , результатом будет элемент запроса с маркером соответствия префикса (см. &lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;Раздел 12.3.2&lt;/a&gt; ). Например, предположим, что у нас есть эти записи в &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c86af8f966441072cea93666c92eea93103579c8" translate="yes" xml:space="preserve">
          <source>An automatically updatable view may contain a mix of updatable and non-updatable columns. A column is updatable if it is a simple reference to an updatable column of the underlying base relation; otherwise the column is read-only, and an error will be raised if an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; statement attempts to assign a value to it.</source>
          <target state="translated">Автоматически обновляемое представление может содержать как обновляемые, так и необновляемые столбцы. Столбец является обновляемым, если это простая ссылка на обновляемый столбец основного базового отношения; в противном случае столбец доступен только для чтения, и если оператор &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; попытается присвоить ему значение, возникнет ошибка .</target>
        </trans-unit>
        <trans-unit id="e72cb7e6b41938a2b612c62d6738c18d8f8e1034" translate="yes" xml:space="preserve">
          <source>An element with a certain name and data type found within a &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuple&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13229daa72676e5cc65b4f01d9a20d25d5a2a7d0" translate="yes" xml:space="preserve">
          <source>An encrypted PGP message consists of 2 parts, or &lt;em&gt;packets&lt;/em&gt;:</source>
          <target state="translated">Зашифрованное сообщение PGP состоит из 2 частей или &lt;em&gt;пакетов&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="09f724c84938e490e8dc9343f32211856b8b0d2e" translate="yes" xml:space="preserve">
          <source>An entry given in IPv4 format will match only IPv4 connections, and an entry given in IPv6 format will match only IPv6 connections, even if the represented address is in the IPv4-in-IPv6 range. Note that entries in IPv6 format will be rejected if the system's C library does not have support for IPv6 addresses.</source>
          <target state="translated">Запись,представленная в формате IPv4,будет соответствовать только соединениям IPv4,а запись,представленная в формате IPv6,будет соответствовать только соединениям IPv6,даже если представленный адрес находится в диапазоне IPv4-in-IPv6.Обратите внимание,что записи в формате IPv6 будут отклонены,если С-библиотека системы не поддерживает IPv6-адреса.</target>
        </trans-unit>
        <trans-unit id="938494e5885c658c095719a63c4ba845fac9421d" translate="yes" xml:space="preserve">
          <source>An entry's &lt;code&gt;amopmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family (including &lt;code&gt;amopmethod&lt;/code&gt; here is an intentional denormalization of the catalog structure for performance reasons). Also, &lt;code&gt;amoplefttype&lt;/code&gt; and &lt;code&gt;amoprighttype&lt;/code&gt; must match the &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields of the referenced &lt;code&gt;pg_operator&lt;/code&gt; entry.</source>
          <target state="translated">Въездной в &lt;code&gt;amopmethod&lt;/code&gt; должен соответствовать &lt;code&gt;opfmethod&lt;/code&gt; его содержащего семейства операторов ( в том числе &lt;code&gt;amopmethod&lt;/code&gt; здесь является преднамеренной денормализация из каталога структуры для повышения производительности). Кроме того , &lt;code&gt;amoplefttype&lt;/code&gt; и &lt;code&gt;amoprighttype&lt;/code&gt; должны соответствовать &lt;code&gt;oprleft&lt;/code&gt; и &lt;code&gt;oprright&lt;/code&gt; полей ссылочного &lt;code&gt;pg_operator&lt;/code&gt; записи.</target>
        </trans-unit>
        <trans-unit id="d1d1086ba8d92dc57d5ff412fcf067dd0fa10959" translate="yes" xml:space="preserve">
          <source>An enum value occupies four bytes on disk. The length of an enum value's textual label is limited by the &lt;code&gt;NAMEDATALEN&lt;/code&gt; setting compiled into PostgreSQL; in standard builds this means at most 63 bytes.</source>
          <target state="translated">Значение перечисления занимает четыре байта на диске. Длина текстовой метки значения перечисления ограничена параметром &lt;code&gt;NAMEDATALEN&lt;/code&gt; , скомпилированным в PostgreSQL; в стандартных сборках это означает не более 63 байтов.</target>
        </trans-unit>
        <trans-unit id="7d926b20cea28dde9ab53148cbd01bb72e3b71c1" translate="yes" xml:space="preserve">
          <source>An error like:</source>
          <target state="translated">Ошибка типа..:</target>
        </trans-unit>
        <trans-unit id="1642e5d8f757211902e7fce377a379427b2967a5" translate="yes" xml:space="preserve">
          <source>An established line of communication between a client process and a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend&lt;/a&gt; process, usually over a network, supporting a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;session&lt;/a&gt;. This term is sometimes used as a synonym for session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f7ed75cabe931d593b5e23922ed970c7f9a2c6" translate="yes" xml:space="preserve">
          <source>An event trigger function is declared to return &lt;code&gt;event_trigger.&lt;/code&gt;</source>
          <target state="translated">Объявлена ​​функция триггера события, возвращающая &lt;code&gt;event_trigger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d03b1b3e9330df5ef72cedfa521226e3904563" translate="yes" xml:space="preserve">
          <source>An example command to insert a row would be:</source>
          <target state="translated">Пример команды для вставки строки будет:</target>
        </trans-unit>
        <trans-unit id="d3e47d13cc2aa85cb2cac79171bd5ba58c06a033" translate="yes" xml:space="preserve">
          <source>An example implementation of my_options() and parameters use from other support functions are given below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77db1d337bb2340f6b1a45dac50171d5552245cf" translate="yes" xml:space="preserve">
          <source>An example is:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="ab2ae23169c6ecf2d8724ae3dd48f5aec7d41be5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a priority-based multiple synchronous standbys is:</source>
          <target state="translated">Пример &lt;code&gt;synchronous_standby_names&lt;/code&gt; для нескольких синхронных резервных серверов на основе приоритета:</target>
        </trans-unit>
        <trans-unit id="a98fc82d0f241f92e10ef779f12a66f98cdb0af5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a quorum-based multiple synchronous standbys is:</source>
          <target state="translated">Пример &lt;code&gt;synchronous_standby_names&lt;/code&gt; для нескольких синхронных резервных серверов на основе кворума:</target>
        </trans-unit>
        <trans-unit id="dd7d7ba1d423d1278de206e487f072bf081d0594" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are rows in the table that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER TABLE&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against all table rows.</source>
          <target state="translated">Примером распространенного способа опровергнуть это предположение является ссылка на пользовательскую функцию в выражении &lt;code&gt;CHECK&lt;/code&gt; , а затем изменение поведения этой функции. PostgreSQL не запрещает этого, но он не заметит, если в таблице есть строки, которые теперь нарушают ограничение &lt;code&gt;CHECK&lt;/code&gt; . Это приведет к сбою последующего дампа базы данных и перезагрузки. Рекомендуемый способ обработки такого изменения - сбросить ограничение (с помощью &lt;code&gt;ALTER TABLE&lt;/code&gt; ), скорректировать определение функции и повторно добавить ограничение, тем самым перепроверив его по всем строкам таблицы.</target>
        </trans-unit>
        <trans-unit id="0fc2dcac68631535509b1c9851983c8f16591ded" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are stored values of the domain type that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER DOMAIN&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against stored data.</source>
          <target state="translated">Примером распространенного способа опровергнуть это предположение является ссылка на пользовательскую функцию в выражении &lt;code&gt;CHECK&lt;/code&gt; , а затем изменение поведения этой функции. PostgreSQL не запрещает этого, но он не заметит, если есть сохраненные значения типа домена, которые теперь нарушают ограничение &lt;code&gt;CHECK&lt;/code&gt; . Это приведет к сбою последующего дампа базы данных и перезагрузки. Рекомендуемый способ обработки такого изменения - сбросить ограничение (с помощью &lt;code&gt;ALTER DOMAIN&lt;/code&gt; ), настроить определение функции и повторно добавить ограничение, тем самым перепроверив его с сохраненными данными.</target>
        </trans-unit>
        <trans-unit id="f4d8042a8aacf4dd946a6de3a479fedbae68b9bb" translate="yes" xml:space="preserve">
          <source>An example of an ordered-set aggregate call is:</source>
          <target state="translated">Пример упорядоченного совокупного вызова:</target>
        </trans-unit>
        <trans-unit id="9b9fd9076643bacdf456e68d66e8b722bd4cc414" translate="yes" xml:space="preserve">
          <source>An example of the problem situation is an administrator on the primary server running &lt;code&gt;DROP TABLE&lt;/code&gt; on a table that is currently being queried on the standby server. Clearly the standby query cannot continue if the &lt;code&gt;DROP TABLE&lt;/code&gt; is applied on the standby. If this situation occurred on the primary, the &lt;code&gt;DROP TABLE&lt;/code&gt; would wait until the other query had finished. But when &lt;code&gt;DROP TABLE&lt;/code&gt; is run on the primary, the primary doesn't have information about what queries are running on the standby, so it will not wait for any such standby queries. The WAL change records come through to the standby while the standby query is still running, causing a conflict. The standby server must either delay application of the WAL records (and everything after them, too) or else cancel the conflicting query so that the &lt;code&gt;DROP TABLE&lt;/code&gt; can be applied.</source>
          <target state="translated">Примером проблемной ситуации является администратор на первичном сервере, запускающий &lt;code&gt;DROP TABLE&lt;/code&gt; для таблицы, которая в настоящее время запрашивается на резервном сервере. Очевидно, что резервный запрос не может быть продолжен, если к резервному приложению применена &lt;code&gt;DROP TABLE&lt;/code&gt; . Если эта ситуация произошла на первичном &lt;code&gt;DROP TABLE&lt;/code&gt; , DROP TABLE будет ждать завершения другого запроса. Но когда &lt;code&gt;DROP TABLE&lt;/code&gt; выполняется на первичном сервере, первичный не имеет информации о том, какие запросы выполняются на резервном сервере, поэтому он не будет ждать таких резервных запросов. Записи изменений WAL поступают в резервный сервер, в то время как резервный запрос все еще выполняется, вызывая конфликт. Резервный сервер должен либо отложить применение записей WAL (и всего после них), либо отменить конфликтующий запрос, чтобы можно было применить &lt;code&gt;DROP TABLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0584ea6554a34671913f19351974da1f1774aa3" translate="yes" xml:space="preserve">
          <source>An example of what this means:</source>
          <target state="translated">Пример того,что это значит:</target>
        </trans-unit>
        <trans-unit id="24ac5f040ccbfd7714847e1bf2aa5f6494899ae9" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; could be undesirable is</source>
          <target state="translated">Примером, когда &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; может быть нежелательным, является</target>
        </trans-unit>
        <trans-unit id="17447c2100c81f31ba62252077dc9a9361cd71f9" translate="yes" xml:space="preserve">
          <source>An example with one unspecified argument:</source>
          <target state="translated">Пример с одним неуказанным аргументом:</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Пример:</target>
        </trans-unit>
        <trans-unit id="79f0ca45e1236a1cb1c9feb4290eadf0487b4ef6" translate="yes" xml:space="preserve">
          <source>An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">Исключением является то,что если команда была прервана сигналом (кроме SIGTERM,который используется как часть выключения сервера БД)или ошибкой командной оболочки (например,команда не найдена),то восстановление прервется и сервер не запустится.</target>
        </trans-unit>
        <trans-unit id="fcd7932740e5471bcd0a087d5b26ec1edd628fbb" translate="yes" xml:space="preserve">
          <source>An explicit attribute name need not be specified if the attribute value is a column reference, in which case the column's name will be used as the attribute name by default. In other cases, the attribute must be given an explicit name. So this example is valid:</source>
          <target state="translated">Явное имя атрибута не обязательно должно быть указано,если значение атрибута является ссылкой на колонку,в этом случае имя колонки будет использоваться в качестве имени атрибута по умолчанию.В других случаях атрибуту должно быть дано явное имя.Таким образом,данный пример является корректным:</target>
        </trans-unit>
        <trans-unit id="a0537d02ca5df21a5cff0228c3c1f8c6cfa4f59b" translate="yes" xml:space="preserve">
          <source>An explicit type cast can usually be omitted if there is no ambiguity as to the type that a value expression must produce (for example, when it is assigned to a table column); the system will automatically apply a type cast in such cases. However, automatic casting is only done for casts that are marked &amp;ldquo;OK to apply implicitly&amp;rdquo; in the system catalogs. Other casts must be invoked with explicit casting syntax. This restriction is intended to prevent surprising conversions from being applied silently.</source>
          <target state="translated">Явное приведение типа обычно может быть опущено, если нет двусмысленности в отношении типа, который должно генерировать выражение значения (например, когда оно присваивается столбцу таблицы); в таких случаях система автоматически применяет приведение типа. Однако автоматическое преобразование выполняется только для тех преобразований, которые помечены как &amp;laquo;ОК для неявного применения&amp;raquo; в системных каталогах. Другие приведения типов должны вызываться с явным синтаксисом приведения типов. Это ограничение предназначено для предотвращения скрытого применения неожиданных преобразований.</target>
        </trans-unit>
        <trans-unit id="8eb162f28e2597cd06bef15cc6b421aa23ae9738" translate="yes" xml:space="preserve">
          <source>An expression based on one or more columns of the table. The expression usually must be written with surrounding parentheses, as shown in the syntax. However, the parentheses can be omitted if the expression has the form of a function call.</source>
          <target state="translated">Выражение,основанное на одной или нескольких колонках таблицы.Выражение обычно должно быть написано с окружающими круглыми скобками,как показано в синтаксисе.Однако круглые скобки могут быть опущены,если выражение имеет форму вызова функции.</target>
        </trans-unit>
        <trans-unit id="dfb3ba678ed8043b837cdccde74a8dfa30c47a0d" translate="yes" xml:space="preserve">
          <source>An expression or integer constant indicating how to sort the result rows. This expression can refer to the columns of the &lt;code&gt;VALUES&lt;/code&gt; result as &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. For more details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">Выражение или целочисленная константа, указывающая, как сортировать строки результатов. Это выражение может ссылаться на столбцы результата &lt;code&gt;VALUES&lt;/code&gt; как &lt;code&gt;column1&lt;/code&gt; , &lt;code&gt;column2&lt;/code&gt; и т. Д. Дополнительные сведения см. &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; разделе ORDER BY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2f105d127b4d4c78a65c31c4341d9a688ca047d" translate="yes" xml:space="preserve">
          <source>An expression or integer constant indicating how to sort the result rows. This expression can refer to the columns of the &lt;code&gt;VALUES&lt;/code&gt; result as &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. For more details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2a060cd8aff34f17e0e2630c016f3f2cecf035" translate="yes" xml:space="preserve">
          <source>An expression or value to assign to the corresponding column.</source>
          <target state="translated">Выражение или значение для присвоения соответствующей колонке.</target>
        </trans-unit>
        <trans-unit id="346258a0cd22cd6472088d2210ee4c5f296cc7a7" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be deleted.</source>
          <target state="translated">Выражение, возвращающее значение типа &lt;code&gt;boolean&lt;/code&gt; . Будут удалены только строки, для которых это выражение возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b5a1cfe641c92cec7cffaf0f485f58266a8e8c9" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated, although all rows will be locked when the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; action is taken. Note that &lt;code&gt;condition&lt;/code&gt; is evaluated last, after a conflict has been identified as a candidate to update.</source>
          <target state="translated">Выражение, возвращающее значение типа &lt;code&gt;boolean&lt;/code&gt; . Будут обновлены только строки, для которых это выражение возвращает &lt;code&gt;true&lt;/code&gt; , хотя все строки будут заблокированы при выполнении действия &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; . Обратите внимание, что &lt;code&gt;condition&lt;/code&gt; оценивается в последнюю очередь после того, как конфликт был идентифицирован как кандидат на обновление.</target>
        </trans-unit>
        <trans-unit id="51d351d5b4985c09126cf102d05f81d64ae9d961" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated.</source>
          <target state="translated">Выражение, возвращающее значение типа &lt;code&gt;boolean&lt;/code&gt; . Будут обновлены только строки, для которых это выражение возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6469ea06c0d7a0f1185226a5a8416487a9a270db" translate="yes" xml:space="preserve">
          <source>An expression to assign to the column. The expression can use the old values of this and other columns in the table.</source>
          <target state="translated">Выражение для присвоения колонке.Выражение может использовать старые значения этой и других колонок таблицы.</target>
        </trans-unit>
        <trans-unit id="8157c1c94fdd707dcc3e7f541c66bda5c99059b6" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;DELETE&lt;/code&gt; command after each row is deleted. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;USING&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">Выражение, которое будет вычислено и возвращено командой &lt;code&gt;DELETE&lt;/code&gt; после удаления каждой строки. Выражение может использовать любые имена столбцов таблицы с именем &lt;code&gt;table_name&lt;/code&gt; или таблиц, перечисленных в &lt;code&gt;USING&lt;/code&gt; . Напишите &lt;code&gt;*&lt;/code&gt; , чтобы вернуть все столбцы.</target>
        </trans-unit>
        <trans-unit id="05948f44935d2d1795c3b150edf4c95d54d4a6f0" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;INSERT&lt;/code&gt; command after each row is inserted or updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns of the inserted or updated row(s).</source>
          <target state="translated">Выражение, которое будет вычислено и возвращено командой &lt;code&gt;INSERT&lt;/code&gt; после вставки или обновления каждой строки. Выражение может использовать любые имена столбцов таблицы с именем &lt;code&gt;table_name&lt;/code&gt; . Напишите &lt;code&gt;*&lt;/code&gt; , чтобы вернуть все столбцы вставленной или обновленной строки (строк).</target>
        </trans-unit>
        <trans-unit id="711a38c8f40969b059c836aa598a46d28bd6408a" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;UPDATE&lt;/code&gt; command after each row is updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;FROM&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">Выражение, которое будет вычислено и возвращено командой &lt;code&gt;UPDATE&lt;/code&gt; после обновления каждой строки. Выражение может использовать любые имена столбцов таблицы с именем &lt;code&gt;table_name&lt;/code&gt; или таблиц, перечисленных в &lt;code&gt;FROM&lt;/code&gt; . Напишите &lt;code&gt;*&lt;/code&gt; , чтобы вернуть все столбцы.</target>
        </trans-unit>
        <trans-unit id="1a2196f96cc62fad9b61f7b17e09f3003661a8d1" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">Выражение,которое будет использоваться в качестве значения по умолчанию,если параметр не указан.Выражение должно быть принудительным к типу аргумента параметра.Все входные параметры,следующие за параметром со значением по умолчанию,также должны иметь значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="33129ed19c1151cbd1e641d74c28498304306825" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. Only input (including &lt;code&gt;INOUT&lt;/code&gt;) parameters can have a default value. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">Выражение, которое будет использоваться как значение по умолчанию, если параметр не указан. Выражение должно быть приводимым к типу аргумента параметра. Только входные параметры (включая &lt;code&gt;INOUT&lt;/code&gt; ) могут иметь значение по умолчанию. Все входные параметры, следующие за параметром со значением по умолчанию, также должны иметь значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e3cc897e9290dc3056730f190eeba85a57f89dca" translate="yes" xml:space="preserve">
          <source>An external program can call the &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; function (see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' &lt;code&gt;restore_command&lt;/code&gt; scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies &amp;mdash; then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the &lt;code&gt;restore_command&lt;/code&gt; script with the data copying program.</source>
          <target state="translated">Внешняя программа может вызвать &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; (см. &lt;a href=&quot;functions-admin&quot;&gt;Раздел 9.26&lt;/a&gt; ), чтобы узнать имя файла и точное смещение в байтах текущего конца WAL. Затем он может напрямую обращаться к файлу WAL и копировать данные с последнего известного конца WAL через текущий конец на резервные серверы. При таком подходе окном потери данных является время цикла опроса программы копирования, которое может быть очень маленьким, и нет потери полосы пропускания из-за принудительного архивирования частично используемых файлов сегментов. Обратите внимание, что команда &lt;code&gt;restore_command&lt;/code&gt; резервных серверовсценарии могут работать только с целыми файлами WAL, поэтому инкрементально копируемые данные обычно не доступны для резервных серверов. Это полезно только тогда, когда основной умирает - тогда последний частичный файл WAL передается на резервный, прежде чем разрешить ему подняться. Правильная реализация этого процесса требует взаимодействия сценария &lt;code&gt;restore_command&lt;/code&gt; с программой копирования данных.</target>
        </trans-unit>
        <trans-unit id="e349b01fb7be05aa32f87d20348ac32cf9165b0a" translate="yes" xml:space="preserve">
          <source>An external program can call the &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; function (see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' &lt;code&gt;restore_command&lt;/code&gt; scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies &amp;mdash; then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the &lt;code&gt;restore_command&lt;/code&gt; script with the data copying program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b6e6917365cf5b071c6d2030b18320b138edde" translate="yes" xml:space="preserve">
          <source>An immediate-mode shutdown is equivalent to a server crash, and will therefore cause loss of any unflushed asynchronous commits.</source>
          <target state="translated">Мгновенное выключение эквивалентно отказу сервера и,следовательно,приведет к потере любых неразбрызганных асинхронных коммитов.</target>
        </trans-unit>
        <trans-unit id="40eea77fc7125e69a1e10d852d75c5913c0b8a4f" translate="yes" xml:space="preserve">
          <source>An important advantage of pg_dump over the other backup methods described later is that pg_dump's output can generally be re-loaded into newer versions of PostgreSQL, whereas file-level backups and continuous archiving are both extremely server-version-specific. pg_dump is also the only method that will work when transferring a database to a different machine architecture, such as going from a 32-bit to a 64-bit server.</source>
          <target state="translated">Важным преимуществом pg_dump перед другими методами резервного копирования,описанными ниже,является то,что вывод pg_dump обычно может быть перезагружен в более новые версии PostgreSQL,в то время как резервное копирование на уровне файлов и непрерывное архивирование крайне специфичны для серверных версий.pg_dump также является единственным методом,который будет работать при переносе базы данных на другую машинную архитектуру,например,при переходе с 32-битного на 64-битный сервер.</target>
        </trans-unit>
        <trans-unit id="779e5fbc91351efe2bbe3fc71a519dfce1b2cb29" translate="yes" xml:space="preserve">
          <source>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. These locations can be retrieved using &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; on the primary and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby, respectively (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; and &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the &lt;code&gt;ps&lt;/code&gt; command (see &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details).</source>
          <target state="translated">Важным индикатором работоспособности потоковой репликации является количество записей WAL, созданных на первичном сервере, но еще не примененных в резервном. Вы можете рассчитать это отставание, сравнив текущее местоположение записи WAL на первичном сервере с последним расположением WAL, полученным резервным. Эти местоположения можно получить, используя &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; на первичном и &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; на резервном, соответственно (подробности см. В &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Таблице 9.84&lt;/a&gt; и &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Таблице 9.85&lt;/a&gt; ). Последнее место приема WAL в резервном режиме также отображается в статусе процесса получателя WAL, отображаемого с помощью команды &lt;code&gt;ps&lt;/code&gt; (подробности см. В &lt;a href=&quot;monitoring-ps&quot;&gt;Разделе 27.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e354ee44c574fe1a74c62c071de207a2e99bd9d" translate="yes" xml:space="preserve">
          <source>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. These locations can be retrieved using &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; on the primary and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby, respectively (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt; and &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt; for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the &lt;code&gt;ps&lt;/code&gt; command (see &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8738ccf906ae7704aa616ed666eef87dd66384c2" translate="yes" xml:space="preserve">
          <source>An important restriction, however, is that each database's character set must be compatible with the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; (character classification) and &lt;code&gt;LC_COLLATE&lt;/code&gt; (string sort order) locale settings. For &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; locale, any character set is allowed, but for other libc-provided locales there is only one character set that will work correctly. (On Windows, however, UTF-8 encoding can be used with any locale.) If you have ICU support configured, ICU-provided locales can be used with most but not all server-side encodings.</source>
          <target state="translated">Однако важным ограничением является то, что набор символов каждой базы данных должен быть совместим с параметрами локали базы данных &lt;code&gt;LC_CTYPE&lt;/code&gt; (классификация символов) и &lt;code&gt;LC_COLLATE&lt;/code&gt; (порядок сортировки строк). Для локали &lt;code&gt;C&lt;/code&gt; или &lt;code&gt;POSIX&lt;/code&gt; разрешен любой набор символов, но для других локалей, предоставляемых libc, существует только один набор символов, который будет работать правильно. (В Windows, однако, кодировка UTF-8 может использоваться с любой локалью.) Если у вас настроена поддержка ICU, локали, предоставляемые ICU, могут использоваться с большинством, но не со всеми кодировками на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="0f5ae435c6587408d50bbebe9d66abc0ceb67394" translate="yes" xml:space="preserve">
          <source>An index access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;index_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a palloc'd struct of type &lt;code&gt;IndexAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the index access method. The &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, includes fields specifying assorted fixed properties of the access method, such as whether it can support multicolumn indexes. More importantly, it contains pointers to support functions for the access method, which do all of the real work to access indexes. These support functions are plain C functions and are not visible or callable at the SQL level. The support functions are described in &lt;a href=&quot;index-functions&quot;&gt;Section 61.2&lt;/a&gt;.</source>
          <target state="translated">Должна быть объявлена ​​функция обработчика метода доступа к индексу, чтобы принимать единственный аргумент типа &lt;code&gt;internal&lt;/code&gt; и возвращать &lt;code&gt;index_am_handler&lt;/code&gt; псевдотипа . Аргумент - это фиктивное значение, которое просто служит для предотвращения прямого вызова функций-обработчиков из команд SQL. Результатом функции должна быть структура palloc'd типа &lt;code&gt;IndexAmRoutine&lt;/code&gt; , которая содержит все, что необходимо знать основному коду для использования метода доступа к индексу. Структура &lt;code&gt;IndexAmRoutine&lt;/code&gt; , также называемая &lt;em&gt;структурой API&lt;/em&gt; метода доступа&lt;em&gt;&lt;/em&gt;, включает поля, определяющие различные фиксированные свойства метода доступа, например, поддерживает ли он многостолбцовые индексы. Что еще более важно, он содержит указатели для поддержки функций метода доступа, которые выполняют всю реальную работу по доступу к индексам. Эти вспомогательные функции являются простыми функциями C и не видны и не вызываются на уровне SQL. Функции поддержки описаны в &lt;a href=&quot;index-functions&quot;&gt;Разделе 61.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb532d7978fa5df32b453f561220dfbe06086e40" translate="yes" xml:space="preserve">
          <source>An index access method handler is declared to return &lt;code&gt;index_am_handler&lt;/code&gt;.</source>
          <target state="translated">Объявлен обработчик метода доступа к &lt;code&gt;index_am_handler&lt;/code&gt; возвращающий index_am_handler .</target>
        </trans-unit>
        <trans-unit id="7b07d3910aeda52b29f538101381247d79d370d4" translate="yes" xml:space="preserve">
          <source>An index can be defined on more than one column of a table. For example, if you have a table of this form:</source>
          <target state="translated">Индекс может быть определен более чем в одном столбце таблицы.Например,если у вас есть таблица такой формы:</target>
        </trans-unit>
        <trans-unit id="c6cedebd8f5962a85979ac8b01f76ed8117fa855" translate="yes" xml:space="preserve">
          <source>An index can support only one collation per index column. If multiple collations are of interest, multiple indexes may be needed.</source>
          <target state="translated">Индекс может поддерживать только одну сверку на столбец индекса.Если интерес представляют несколько сопоставлений,может потребоваться несколько индексов.</target>
        </trans-unit>
        <trans-unit id="af32b6cb0c87ebb15770ca088fe87a22f82c7725" translate="yes" xml:space="preserve">
          <source>An index column need not be just a column of the underlying table, but can be a function or scalar expression computed from one or more columns of the table. This feature is useful to obtain fast access to tables based on the results of computations.</source>
          <target state="translated">Столбец индекса должен быть не просто столбцом базовой таблицы,а может быть функцией или скалярным выражением,вычисленным из одного или нескольких столбцов таблицы.Эта функция полезна для получения быстрого доступа к таблицам по результатам вычислений.</target>
        </trans-unit>
        <trans-unit id="38f15f32a54b60a4d97bf16f8c60ceef26c5914e" translate="yes" xml:space="preserve">
          <source>An index definition can specify an &lt;em&gt;operator class&lt;/em&gt; for each column of an index.</source>
          <target state="translated">В определении индекса можно указать &lt;em&gt;класс оператора&lt;/em&gt; для каждого столбца индекса.</target>
        </trans-unit>
        <trans-unit id="0ef2323f17ff30aac9494d8039a3c3612271c42a" translate="yes" xml:space="preserve">
          <source>An index field can be an expression computed from the values of one or more columns of the table row. This feature can be used to obtain fast access to data based on some transformation of the basic data. For example, an index computed on &lt;code&gt;upper(col)&lt;/code&gt; would allow the clause &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; to use an index.</source>
          <target state="translated">Поле индекса может быть выражением, вычисленным на основе значений одного или нескольких столбцов строки таблицы. Эта функция может использоваться для получения быстрого доступа к данным на основе некоторого преобразования основных данных. Например, индекс, вычисленный для &lt;code&gt;upper(col)&lt;/code&gt; , позволит предложению &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; использовать индекс.</target>
        </trans-unit>
        <trans-unit id="3aeae44b3c790fd037b93e2535adf3aedad79c0a" translate="yes" xml:space="preserve">
          <source>An index has become &amp;ldquo;bloated&amp;rdquo;, that is it contains many empty or nearly-empty pages. This can occur with B-tree indexes in PostgreSQL under certain uncommon access patterns. &lt;code&gt;REINDEX&lt;/code&gt; provides a way to reduce the space consumption of the index by writing a new version of the index without the dead pages. See &lt;a href=&quot;routine-reindex&quot;&gt;Section 24.2&lt;/a&gt; for more information.</source>
          <target state="translated">Индекс стал &amp;laquo;раздутым&amp;raquo;, то есть содержит много пустых или почти пустых страниц. Это может происходить с индексами B-дерева в PostgreSQL при определенных необычных схемах доступа. &lt;code&gt;REINDEX&lt;/code&gt; позволяет сократить занимаемое индексом пространство за счет записи новой версии индекса без мертвых страниц. См. &lt;a href=&quot;routine-reindex&quot;&gt;Раздел 24.2&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="121b8423d6baa50b53be4c3d49a8a3b7e064ae7d" translate="yes" xml:space="preserve">
          <source>An index has become corrupted, and no longer contains valid data. Although in theory this should never happen, in practice indexes can become corrupted due to software bugs or hardware failures. &lt;code&gt;REINDEX&lt;/code&gt; provides a recovery method.</source>
          <target state="translated">Индекс поврежден и больше не содержит действительных данных. Хотя теоретически этого никогда не должно происходить, на практике индексы могут быть повреждены из-за программных ошибок или сбоев оборудования. &lt;code&gt;REINDEX&lt;/code&gt; предоставляет метод восстановления.</target>
        </trans-unit>
        <trans-unit id="fd114c1d6538ba92c251db5881779687c2ba09a7" translate="yes" xml:space="preserve">
          <source>An index scan must maintain a pin on the index page holding the item last returned by &lt;code&gt;amgettuple&lt;/code&gt;, and &lt;code&gt;ambulkdelete&lt;/code&gt; cannot delete entries from pages that are pinned by other backends. The need for this rule is explained below.</source>
          <target state="translated">При сканировании индекса на странице индекса должен сохраняться пин-код, содержащий элемент, последний раз возвращенный &lt;code&gt;amgettuple&lt;/code&gt; , и &lt;code&gt;ambulkdelete&lt;/code&gt; не может удалять записи со страниц, закрепленных другими бэкэндами. Необходимость этого правила объясняется ниже.</target>
        </trans-unit>
        <trans-unit id="091f10c301d94d87ecd9a27b3366c6d6b064df7e" translate="yes" xml:space="preserve">
          <source>An index stored in ascending order with nulls first can satisfy either &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; or &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; depending on which direction it is scanned in.</source>
          <target state="translated">Индекс, хранящийся в порядке возрастания с нулями вначале, может удовлетворять либо &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; , либо &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; в зависимости от того, в каком направлении он сканируется.</target>
        </trans-unit>
        <trans-unit id="4b9a05a65dbb6edc07d784a35f9d93afabbd7c69" translate="yes" xml:space="preserve">
          <source>An individual index is defined by a &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt; entry that describes it as a physical relation, plus a &lt;a href=&quot;catalog-pg-index&quot;&gt;&lt;code&gt;pg_index&lt;/code&gt;&lt;/a&gt; entry that shows the logical content of the index &amp;mdash; that is, the set of index columns it has and the semantics of those columns, as captured by the associated operator classes. The index columns (key values) can be either simple columns of the underlying table or expressions over the table rows. The index access method normally has no interest in where the index key values come from (it is always handed precomputed key values) but it will be very interested in the operator class information in &lt;code&gt;pg_index&lt;/code&gt;. Both of these catalog entries can be accessed as part of the &lt;code&gt;Relation&lt;/code&gt; data structure that is passed to all operations on the index.</source>
          <target state="translated">Индивидуальный индекс определяется &lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt; которая описывает его как физическое отношение, плюс &lt;a href=&quot;catalog-pg-index&quot;&gt; &lt;code&gt;pg_index&lt;/code&gt; &lt;/a&gt; которая показывает логическое содержимое индекса, то есть набор столбцов индекса, которые он имеет, и семантику этих столбцов, как зафиксировано ассоциированные классы операторов. Столбцы индекса (значения ключа) могут быть либо простыми столбцами базовой таблицы, либо выражениями по строкам таблицы. Метод доступа к индексу обычно не интересуется, откуда берутся значения ключа индекса (ему всегда передаются предварительно вычисленные значения ключа), но он будет очень заинтересован в информации о классе операторов в &lt;code&gt;pg_index&lt;/code&gt; . Обе эти записи каталога могут быть доступны как часть &lt;code&gt;Relation&lt;/code&gt; структура данных, которая передается всем операциям с индексом.</target>
        </trans-unit>
        <trans-unit id="c51c50438ea0481d3519a43885b20aa32e128cb3" translate="yes" xml:space="preserve">
          <source>An input argument for the procedure call. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for the full details on function and procedure call syntax, including use of named parameters.</source>
          <target state="translated">Входной аргумент для вызова процедуры. См. &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Раздел 4.3&lt;/a&gt; для получения полной информации о синтаксисе вызова функций и процедур, включая использование именованных параметров.</target>
        </trans-unit>
        <trans-unit id="73ddb8fe436cada6d2cfbe35b934979d06f7b361" translate="yes" xml:space="preserve">
          <source>An input data type on which the aggregate function operates. To reference a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. To reference an ordered-set aggregate function, write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications.</source>
          <target state="translated">Тип входных данных, с которым работает агрегатная функция. Чтобы сослаться на агрегатную функцию с нулевым аргументом, напишите &lt;code&gt;*&lt;/code&gt; вместо списка спецификаций аргументов. Чтобы сослаться на агрегатную функцию с упорядоченным набором, укажите &lt;code&gt;ORDER BY&lt;/code&gt; между спецификациями прямого и агрегированного аргументов.</target>
        </trans-unit>
        <trans-unit id="8a9fa698ac8ae654cf211647b74f7c8723ee0347" translate="yes" xml:space="preserve">
          <source>An input data type on which this aggregate function operates. To create a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. (An example of such an aggregate is &lt;code&gt;count(*)&lt;/code&gt;.)</source>
          <target state="translated">Тип входных данных, с которым работает эта агрегатная функция. Чтобы создать агрегатную функцию с нулевым аргументом, напишите &lt;code&gt;*&lt;/code&gt; вместо списка спецификаций аргументов. (Примером такого агрегата является &lt;code&gt;count(*)&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="2c437a292efa6b573c836047b51a1cf9f32df694" translate="yes" xml:space="preserve">
          <source>An introduction to the btree index implementation can be found in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt;.</source>
          <target state="translated">Введение в реализацию индекса btree можно найти в &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d220b2360555baed12a7c95e72685b6f39b9dd" translate="yes" xml:space="preserve">
          <source>An n-dimensional cube represented by a pair of its diagonally opposite corners</source>
          <target state="translated">n-мерный куб,представленный парой его диагонально противоположных углов.</target>
        </trans-unit>
        <trans-unit id="49b0e219e8853ca29533ecae37f9efd990522911" translate="yes" xml:space="preserve">
          <source>An object can be assigned to a new owner with an &lt;code&gt;ALTER&lt;/code&gt; command of the appropriate kind for the object, for example</source>
          <target state="translated">Объект может быть назначен новому владельцу с помощью команды &lt;code&gt;ALTER&lt;/code&gt; соответствующего типа для объекта, например</target>
        </trans-unit>
        <trans-unit id="261a27538e7f1d6cc0124e706ea14d5684e6fe5c" translate="yes" xml:space="preserve">
          <source>An object's owner can choose to revoke their own ordinary privileges, for example to make a table read-only for themselves as well as others. But owners are always treated as holding all grant options, so they can always re-grant their own privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd7347c4e72d5111690a2e6b553a4bb95eecefbe" translate="yes" xml:space="preserve">
          <source>An obsolete type name that formerly served many of the above purposes.</source>
          <target state="translated">Устаревшее имя типа,которое раньше служило многим из вышеперечисленных целей.</target>
        </trans-unit>
        <trans-unit id="e67e0cc488404bddd9185d257d8376a78bb5f89d" translate="yes" xml:space="preserve">
          <source>An older syntax based on &quot;:=&quot; is supported for backward compatibility:</source>
          <target state="translated">Старый синтаксис,основанный на &quot;:=&quot;,поддерживается для обратной совместимости:</target>
        </trans-unit>
        <trans-unit id="a2ec14d06c6e5e0d12a30237502776f169012b3d" translate="yes" xml:space="preserve">
          <source>An open cursor's name.</source>
          <target state="translated">Имя открытого курсора.</target>
        </trans-unit>
        <trans-unit id="fdaf617bcf458038608559aa52135b2d0fb280c4" translate="yes" xml:space="preserve">
          <source>An operation and SQL keyword used in &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt; for combining data from multiple &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907b1845a90ba08c2bd64d8aae44246179e07fc0" translate="yes" xml:space="preserve">
          <source>An operator class for BRIN can optionally specify the following method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82dcbae2eb28872acc9a82bc62d7f28fc52dc06" translate="yes" xml:space="preserve">
          <source>An operator class for GIN can optionally supply the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d15480825e451d724a77515f8cbd596240aa64" translate="yes" xml:space="preserve">
          <source>An operator class for bloom indexes requires only a hash function for the indexed data type and an equality operator for searching. This example shows the operator class definition for the &lt;code&gt;text&lt;/code&gt; data type:</source>
          <target state="translated">Классу операторов для индексов Блума требуется только хеш-функция для индексированного типа данных и оператор равенства для поиска. В этом примере показано определение класса операторов для &lt;code&gt;text&lt;/code&gt; типа данных:</target>
        </trans-unit>
        <trans-unit id="6eb7653b3723c58c344a731c25071cc3711f5e86" translate="yes" xml:space="preserve">
          <source>An operator class is actually just a subset of a larger structure called an &lt;em&gt;operator family&lt;/em&gt;. In cases where several data types have similar behaviors, it is frequently useful to define cross-data-type operators and allow these to work with indexes. To do this, the operator classes for each of the types must be grouped into the same operator family. The cross-type operators are members of the family, but are not associated with any single class within the family.</source>
          <target state="translated">Класс операторов - это просто подмножество более крупной структуры, называемой &lt;em&gt;семейством операторов&lt;/em&gt; . В случаях, когда несколько типов данных имеют похожее поведение, часто бывает полезно определить операторы перекрестных типов данных и разрешить им работать с индексами. Для этого классы операторов для каждого из типов должны быть сгруппированы в одно и то же семейство операторов. Операторы перекрестного типа являются членами семейства, но не связаны ни с одним классом в семействе.</target>
        </trans-unit>
        <trans-unit id="f7d235f30c792ff196a94c50c4549a98a2d7a764" translate="yes" xml:space="preserve">
          <source>An operator class must also provide a function to check if an indexed item matches the query. It comes in two flavors, a Boolean &lt;code&gt;consistent&lt;/code&gt; function, and a ternary &lt;code&gt;triConsistent&lt;/code&gt; function. &lt;code&gt;triConsistent&lt;/code&gt; covers the functionality of both, so providing &lt;code&gt;triConsistent&lt;/code&gt; alone is sufficient. However, if the Boolean variant is significantly cheaper to calculate, it can be advantageous to provide both. If only the Boolean variant is provided, some optimizations that depend on refuting index items before fetching all the keys are disabled.</source>
          <target state="translated">Класс оператора должен также предоставлять функцию для проверки соответствия индексированного элемента запросу. Он бывает двух &lt;code&gt;triConsistent&lt;/code&gt; логической &lt;code&gt;consistent&lt;/code&gt; функции и троичной функции triConsistent . &lt;code&gt;triConsistent&lt;/code&gt; покрывает функциональность обоих, поэтому достаточно предоставить только &lt;code&gt;triConsistent&lt;/code&gt; . Однако, если логический вариант значительно дешевле вычислить, может быть выгодно предоставить оба. Если предоставляется только логический вариант, некоторые оптимизации, которые зависят от опровержения элементов индекса перед выборкой всех ключей, отключаются.</target>
        </trans-unit>
        <trans-unit id="6e523c5f9d2c574da0fb6483337cb467c258e68f" translate="yes" xml:space="preserve">
          <source>An operator class's &lt;code&gt;opcmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family. Also, there must be no more than one &lt;code&gt;pg_opclass&lt;/code&gt; row having &lt;code&gt;opcdefault&lt;/code&gt; true for any given combination of &lt;code&gt;opcmethod&lt;/code&gt; and &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opcmethod&lt;/code&gt; класса операторов должен соответствовать &lt;code&gt;opfmethod&lt;/code&gt; содержащего его семейства операторов. Кроме того , не должно быть не более чем один &lt;code&gt;pg_opclass&lt;/code&gt; ряд имеет &lt;code&gt;opcdefault&lt;/code&gt; справедливо для любой заданной комбинации &lt;code&gt;opcmethod&lt;/code&gt; и &lt;code&gt;opcintype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a6550b54250a9ead01f2b3553646b2303a4a1ed" translate="yes" xml:space="preserve">
          <source>An operator invocation</source>
          <target state="translated">Вызов оператора</target>
        </trans-unit>
        <trans-unit id="61b072351eb6c6fa27b9ae84a318cc236116df90" translate="yes" xml:space="preserve">
          <source>An operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">Имя оператора представляет собой последовательность до &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1 (по умолчанию 63) символов из следующего списка:</target>
        </trans-unit>
        <trans-unit id="d3a80b67bf09fd16cb2674622b6e5dcf9a0716b6" translate="yes" xml:space="preserve">
          <source>An operator used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot would show the &lt;code&gt;&amp;lt;&lt;/code&gt; operator that defines the sort order of the data.</source>
          <target state="translated">Оператор, используемый для получения статистики, хранящейся в &lt;code&gt;N&lt;/code&gt; - м &amp;laquo;слоте&amp;raquo;. Например, в слоте гистограммы будет отображаться оператор &lt;code&gt;&amp;lt;&lt;/code&gt; , определяющий порядок сортировки данных.</target>
        </trans-unit>
        <trans-unit id="36745dfcd4a31015998a201702d690d18fcba0c2" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;+&lt;/code&gt; produces more details.</source>
          <target state="translated">Необязательный &lt;code&gt;+&lt;/code&gt; дает более подробную информацию.</target>
        </trans-unit>
        <trans-unit id="15280e346b927d3a2d54ca3d61b3ae948a862eb2" translate="yes" xml:space="preserve">
          <source>An optional collation for the domain. If no collation is specified, the underlying data type's default collation is used. The underlying type must be collatable if &lt;code&gt;COLLATE&lt;/code&gt; is specified.</source>
          <target state="translated">Необязательные параметры сортировки для домена. Если сопоставление не указано, используется сопоставление по умолчанию для базового типа данных. Если указан &lt;code&gt;COLLATE&lt;/code&gt; , базовый тип должен быть сопоставимым .</target>
        </trans-unit>
        <trans-unit id="60e65907bee0f7f6070fd34b3f416cb8bb6f6e36" translate="yes" xml:space="preserve">
          <source>An optional comma-separated list of arguments to be provided to the function when the trigger is executed. The arguments are literal string constants. Simple names and numeric constants can be written here, too, but they will all be converted to strings. Please check the description of the implementation language of the trigger function to find out how these arguments can be accessed within the function; it might be different from normal function arguments.</source>
          <target state="translated">Необязательный разделенный запятыми список аргументов,который должен быть предоставлен функции при выполнении триггера.Аргументами являются буквенные строковые константы.Здесь также могут быть записаны простые имена и числовые константы,но все они будут преобразованы в строки.Пожалуйста,ознакомьтесь с описанием языка реализации триггерной функции,чтобы узнать,как эти аргументы могут быть доступны внутри функции;это может отличаться от обычных аргументов функции.</target>
        </trans-unit>
        <trans-unit id="c4ca636c20fca55bda068decba0ca12e4c60f9d3" translate="yes" xml:space="preserve">
          <source>An optional list of columns to be copied. If no column list is specified, all columns of the table except generated columns will be copied.</source>
          <target state="translated">Дополнительный список колонок для копирования.Если список столбцов не указан,будут скопированы все столбцы таблицы,кроме сгенерированных.</target>
        </trans-unit>
        <trans-unit id="f37b6dea6bba7854fbb2a25222ccbd3742c1fd86" translate="yes" xml:space="preserve">
          <source>An optional list of names to be used for columns of the view. If not given, the column names are deduced from the query.</source>
          <target state="translated">Необязательный список имен для столбцов вида.Если он не задан,то названия столбцов вычитаются из запроса.</target>
        </trans-unit>
        <trans-unit id="a1745e8f3d8a818bb59434a30224b4bc70bd52ef" translate="yes" xml:space="preserve">
          <source>An optional name for a column or table constraint. If the constraint is violated, the constraint name is present in error messages, so constraint names like &lt;code&gt;col must be positive&lt;/code&gt; can be used to communicate helpful constraint information to client applications. (Double-quotes are needed to specify constraint names that contain spaces.) If a constraint name is not specified, the system generates a name.</source>
          <target state="translated">Необязательное имя для ограничения столбца или таблицы. Если ограничение нарушено, имя ограничения присутствует в сообщениях об ошибках, поэтому имена ограничений, такие как &lt;code&gt;col must be positive&lt;/code&gt; могут использоваться для передачи полезной информации об ограничениях клиентским приложениям. (Для указания имен ограничений, содержащих пробелы, необходимы двойные кавычки.) Если имя ограничения не указано, система генерирует имя.</target>
        </trans-unit>
        <trans-unit id="f3ae3fadcc76fcc5b9297de7bc96718990dc996d" translate="yes" xml:space="preserve">
          <source>An optional name for a constraint. If not specified, the system generates a name.</source>
          <target state="translated">Необязательное имя для ограничения.Если не указано,система генерирует имя.</target>
        </trans-unit>
        <trans-unit id="bd6568613ce7c67d34419866e38138da4ce733d2" translate="yes" xml:space="preserve">
          <source>An output column's name can be used to refer to the column's value in &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;GROUP BY&lt;/code&gt; clauses, but not in the &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;HAVING&lt;/code&gt; clauses; there you must write out the expression instead.</source>
          <target state="translated">Имя выходного столбца можно использовать для ссылки на значение столбца в предложениях &lt;code&gt;ORDER BY&lt;/code&gt; и &lt;code&gt;GROUP BY&lt;/code&gt; , но не в &lt;code&gt;WHERE&lt;/code&gt; или &lt;code&gt;HAVING&lt;/code&gt; ; вместо этого вы должны написать выражение.</target>
        </trans-unit>
        <trans-unit id="b29ad290e8bd770fdebcb84bad7370f20ace4e23" translate="yes" xml:space="preserve">
          <source>Analogous statements with inverted conditions hold when &lt;code&gt;less&lt;/code&gt; = false.</source>
          <target state="translated">Аналогичные утверждения с перевернутыми условиями верны, когда &lt;code&gt;less&lt;/code&gt; = false.</target>
        </trans-unit>
        <trans-unit id="602ef0777e13fcee9897969f97ef1e867cdf140e" translate="yes" xml:space="preserve">
          <source>Analogous to &lt;code&gt;ON DELETE&lt;/code&gt; there is also &lt;code&gt;ON UPDATE&lt;/code&gt; which is invoked when a referenced column is changed (updated). The possible actions are the same. In this case, &lt;code&gt;CASCADE&lt;/code&gt; means that the updated values of the referenced column(s) should be copied into the referencing row(s).</source>
          <target state="translated">Аналогично &lt;code&gt;ON DELETE&lt;/code&gt; существует также &lt;code&gt;ON UPDATE&lt;/code&gt; , которое вызывается при изменении (обновлении) указанного столбца. Возможные действия такие же. В этом случае &lt;code&gt;CASCADE&lt;/code&gt; означает, что обновленные значения указанного столбца (столбцов) должны быть скопированы в ссылающуюся строку (строки).</target>
        </trans-unit>
        <trans-unit id="8e26143bf38a350af73fba34493a3e7479767511" translate="yes" xml:space="preserve">
          <source>Analytic function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0e68d1e2fd04310f44d64aff40ca304bd44245" translate="yes" xml:space="preserve">
          <source>Analyze (operation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c83db21cadbb2756e96e53b9c14b7e7a2b514a6" translate="yes" xml:space="preserve">
          <source>Ancient distributions might not have the &lt;code&gt;sysctl&lt;/code&gt; program, but equivalent changes can be made by manipulating the &lt;code&gt;/proc&lt;/code&gt; file system:</source>
          <target state="translated">В старых дистрибутивах может не быть программы &lt;code&gt;sysctl&lt;/code&gt; , но эквивалентные изменения можно внести, манипулируя файловой системой &lt;code&gt;/proc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d93beb44d205136520d673b54b56936f6980aa2" translate="yes" xml:space="preserve">
          <source>And finally create the transform to connect them all together:</source>
          <target state="translated">И,наконец,создать трансформацию,чтобы соединить их всех вместе:</target>
        </trans-unit>
        <trans-unit id="43c2b85844ed32a3fb79c6e1b9f3ea8d1ebdd551" translate="yes" xml:space="preserve">
          <source>And finally, most disk drives have caches. Some are write-through while some are write-back, and the same concerns about data loss exist for write-back drive caches as for disk controller caches. Consumer-grade IDE and SATA drives are particularly likely to have write-back caches that will not survive a power failure. Many solid-state drives (SSD) also have volatile write-back caches.</source>
          <target state="translated">И,наконец,большинство дисковых накопителей имеют кэш.Некоторые из них являются кэшами с обратной записью,а некоторые-с обратной записью,и те же самые опасения по поводу потери данных существуют для кэшей дисковых контроллеров с обратной записью.Диски IDE и SATA потребительского класса особенно часто имеют кэши с обратной записью,которые не переживут перебои с питанием.Многие твердотельные накопители (SSD)также имеют неустойчивые кэши с обратной записью.</target>
        </trans-unit>
        <trans-unit id="f5abe4b1cbcb838f669f793ea91def6b18bb7e30" translate="yes" xml:space="preserve">
          <source>And on the subscriber database:</source>
          <target state="translated">И в базе данных абонентов:</target>
        </trans-unit>
        <trans-unit id="e24853104ecb700e47b83196c8cd650b56525c5b" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;.dict&lt;/code&gt; file has the following structure:</source>
          <target state="translated">А файл &lt;code&gt;.dict&lt;/code&gt; имеет следующую структуру:</target>
        </trans-unit>
        <trans-unit id="588ca16f318d70344d76b4537a5c7291a5cee916" translate="yes" xml:space="preserve">
          <source>And the matching code in the C module could then follow this skeleton:</source>
          <target state="translated">И соответствующий код в модуле C может затем следовать этому скелету:</target>
        </trans-unit>
        <trans-unit id="680044bb057f2caf79b08b39f3f6077a48b66315" translate="yes" xml:space="preserve">
          <source>And to get 2-D cubes ordered by the first coordinate of the upper right corner descending:</source>
          <target state="translated">И получить двухмерные кубы,упорядоченные по первой координате опускания верхнего правого угла:</target>
        </trans-unit>
        <trans-unit id="6871b449d2c079d96e59fe6f124b014ba15535f8" translate="yes" xml:space="preserve">
          <source>And we can specify subfields as targets for &lt;code&gt;INSERT&lt;/code&gt;, too:</source>
          <target state="translated">И мы также можем указать подполя в качестве целей для &lt;code&gt;INSERT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a145997c5dd507c46627dcb8aa745e601bfd3eab" translate="yes" xml:space="preserve">
          <source>And, if the function is called with an argument of type &lt;code&gt;integer&lt;/code&gt;, the parser will try to convert that to &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">И, если функция вызывается с аргументом &lt;code&gt;integer&lt;/code&gt; типа , парсер попытается преобразовать его в &lt;code&gt;text&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7848b33d4bfc790590d465569216a9f6ae690895" translate="yes" xml:space="preserve">
          <source>Anonymous allocations are allocations that have been made with &lt;code&gt;ShmemAlloc()&lt;/code&gt; directly, rather than via &lt;code&gt;ShmemInitStruct()&lt;/code&gt; or &lt;code&gt;ShmemInitHash()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ab5b725ed73e7635d9823c37915d8903343a0f" translate="yes" xml:space="preserve">
          <source>Another alternative worth considering is to use &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers (see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;) in place of rules.</source>
          <target state="translated">Другой альтернативой, которую стоит рассмотреть, является использование триггеров &lt;code&gt;INSTEAD OF&lt;/code&gt; (см. &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; ) вместо правил.</target>
        </trans-unit>
        <trans-unit id="e823a73742793d80b913d4d208ddb3ca9056df81" translate="yes" xml:space="preserve">
          <source>Another approach is to create a separate &lt;code&gt;tsvector&lt;/code&gt; column to hold the output of &lt;code&gt;to_tsvector&lt;/code&gt;. To keep this column automatically up to date with its source data, use a stored generated column. This example is a concatenation of &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;, using &lt;code&gt;coalesce&lt;/code&gt; to ensure that one field will still be indexed when the other is &lt;code&gt;NULL&lt;/code&gt;:</source>
          <target state="translated">Другой подход - создать отдельный столбец &lt;code&gt;tsvector&lt;/code&gt; для хранения вывода &lt;code&gt;to_tsvector&lt;/code&gt; . Чтобы этот столбец автоматически обновлялся с исходными данными, используйте сохраненный сгенерированный столбец. Этот пример представляет собой объединение &lt;code&gt;title&lt;/code&gt; и &lt;code&gt;body&lt;/code&gt; с использованием &lt;code&gt;coalesce&lt;/code&gt; чтобы гарантировать, что одно поле все еще будет индексироваться, когда другое - &lt;code&gt;NULL&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c88aeeb193209d03f36ea4052749971eef461a5a" translate="yes" xml:space="preserve">
          <source>Another approach to querying is to exploit containment, for example:</source>
          <target state="translated">Другим подходом к запросу является,например,использование локализации:</target>
        </trans-unit>
        <trans-unit id="0f6657768acd9084b11e644584f044a4fc45d8af" translate="yes" xml:space="preserve">
          <source>Another approach, which can be used with or without altering &lt;code&gt;vm.overcommit_memory&lt;/code&gt;, is to set the process-specific &lt;em&gt;OOM score adjustment&lt;/em&gt; value for the postmaster process to &lt;code&gt;-1000&lt;/code&gt;, thereby guaranteeing it will not be targeted by the OOM killer. The simplest way to do this is to execute</source>
          <target state="translated">Другой подход, который можно использовать с изменением или без изменения &lt;code&gt;vm.overcommit_memory&lt;/code&gt; , заключается в установке значения &lt;em&gt;корректировки&lt;/em&gt; оценки &lt;em&gt;OOM для&lt;/em&gt; конкретного процесса для процесса postmaster равным &lt;code&gt;-1000&lt;/code&gt; , тем самым гарантируя, что он не станет целью убийцы OOM. Самый простой способ сделать это - выполнить</target>
        </trans-unit>
        <trans-unit id="0157777d67f21431cd43979bf17bb15a2c6fa069" translate="yes" xml:space="preserve">
          <source>Another caveat when building a unique index concurrently is that the uniqueness constraint is already being enforced against other transactions when the second table scan begins. This means that constraint violations could be reported in other queries prior to the index becoming available for use, or even in cases where the index build eventually fails. Also, if a failure does occur in the second scan, the &amp;ldquo;invalid&amp;rdquo; index continues to enforce its uniqueness constraint afterwards.</source>
          <target state="translated">Еще одно предостережение при создании уникального индекса одновременно заключается в том, что ограничение уникальности уже применяется к другим транзакциям, когда начинается второе сканирование таблицы. Это означает, что о нарушениях ограничений можно сообщать в других запросах до того, как индекс станет доступным для использования, или даже в тех случаях, когда построение индекса в конечном итоге не удается. Кроме того, если во время второго сканирования все же произойдет сбой, &amp;laquo;недействительный&amp;raquo; индекс продолжит применять свое ограничение уникальности впоследствии.</target>
        </trans-unit>
        <trans-unit id="8366e5720bf81785c8af920367ca1956fa9f6126" translate="yes" xml:space="preserve">
          <source>Another common reason for copying &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt; is that new encoding and locale settings can be specified when copying &lt;code&gt;template0&lt;/code&gt;, whereas a copy of &lt;code&gt;template1&lt;/code&gt; must use the same settings it does. This is because &lt;code&gt;template1&lt;/code&gt; might contain encoding-specific or locale-specific data, while &lt;code&gt;template0&lt;/code&gt; is known not to.</source>
          <target state="translated">Другой распространенной причиной копирования &lt;code&gt;template0&lt;/code&gt; вместо &lt;code&gt;template1&lt;/code&gt; является то, что при копировании &lt;code&gt;template0&lt;/code&gt; могут быть указаны новые настройки кодировки и локали , тогда как копия &lt;code&gt;template1&lt;/code&gt; должна использовать те же настройки, что и она. Это связано с тем, что &lt;code&gt;template1&lt;/code&gt; может содержать данные, относящиеся к кодировке или языку, а &lt;code&gt;template0&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="fbb209aa36c1a4990c8b7ddd6d829419598146fa" translate="yes" xml:space="preserve">
          <source>Another consideration is that a &lt;code&gt;setval&lt;/code&gt; executed on such a sequence will not be noticed by other sessions until they have used up any preallocated values they have cached.</source>
          <target state="translated">Другое соображение заключается в том, что &lt;code&gt;setval&lt;/code&gt; , выполняемый в такой последовательности, не будет замечен другими сеансами, пока они не израсходуют все предварительно выделенные значения, которые они кэшировали.</target>
        </trans-unit>
        <trans-unit id="3dd197e47ceae278b1382e01aa4231fc834370d4" translate="yes" xml:space="preserve">
          <source>Another disadvantage of the rule approach is that there is no simple way to force an error if the set of rules doesn't cover the insertion date; the data will silently go into the master table instead.</source>
          <target state="translated">Другим недостатком подхода к правилам является то,что нет простого способа принудить к ошибке,если набор правил не покрывает дату вставки;вместо этого данные будут молча заходить в главную таблицу.</target>
        </trans-unit>
        <trans-unit id="b74b279225b01a4f9a49098a715c0c2cd2860bb8" translate="yes" xml:space="preserve">
          <source>Another effect of &lt;code&gt;RECURSIVE&lt;/code&gt; is that &lt;code&gt;WITH&lt;/code&gt; queries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) Without &lt;code&gt;RECURSIVE&lt;/code&gt;, &lt;code&gt;WITH&lt;/code&gt; queries can only reference sibling &lt;code&gt;WITH&lt;/code&gt; queries that are earlier in the &lt;code&gt;WITH&lt;/code&gt; list.</source>
          <target state="translated">Другой эффект &lt;code&gt;RECURSIVE&lt;/code&gt; заключается в том, что запросы &lt;code&gt;WITH&lt;/code&gt; не нужно упорядочивать: запрос может ссылаться на другой, который находится позже в списке. (Тем не менее, циклические ссылки, или взаимная рекурсия, не выполняется.) Без &lt;code&gt;RECURSIVE&lt;/code&gt; , &lt;code&gt;WITH&lt;/code&gt; запросами могут ссылаться только родственным &lt;code&gt;WITH&lt;/code&gt; запросами , которые ранее в &lt;code&gt;WITH&lt;/code&gt; списка.</target>
        </trans-unit>
        <trans-unit id="f949f8323c537df82042ad10748a3400dd5e3c94" translate="yes" xml:space="preserve">
          <source>Another example &amp;mdash; the PostgreSQL mailing list archives contained 910,989 unique words with 57,491,343 lexemes in 461,020 messages.</source>
          <target state="translated">Другой пример - архивы списков рассылки PostgreSQL содержали 910 989 уникальных слов с 57 491 343 лексемами в 461 020 сообщениях.</target>
        </trans-unit>
        <trans-unit id="e840dc5efd9dcea852680d04861f5d19522482d9" translate="yes" xml:space="preserve">
          <source>Another example demonstrating these concepts is that all these queries mean the same thing:</source>
          <target state="translated">Другой пример,демонстрирующий эти понятия,заключается в том,что все эти запросы означают одно и то же:</target>
        </trans-unit>
        <trans-unit id="448793ead43f5a4696dde796c384f50ddecfec35" translate="yes" xml:space="preserve">
          <source>Another example with &lt;code&gt;--rate=100&lt;/code&gt; and &lt;code&gt;--latency-limit=5&lt;/code&gt; (note the additional &lt;code&gt;schedule_lag&lt;/code&gt; column):</source>
          <target state="translated">Другой пример с &lt;code&gt;--rate=100&lt;/code&gt; и &lt;code&gt;--latency-limit=5&lt;/code&gt; (обратите внимание на дополнительный столбец &lt;code&gt;schedule_lag&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="1eb54ef0acd3e1a10201fcaabd71c9780026708a" translate="yes" xml:space="preserve">
          <source>Another form of table aliasing gives temporary names to the columns of the table, as well as the table itself:</source>
          <target state="translated">Другая форма наложения псевдонимов на столбцы таблицы дает временные имена как столбцам таблицы,так и самой таблице:</target>
        </trans-unit>
        <trans-unit id="52020177212290ca0e1ac022789f990b2cddb766" translate="yes" xml:space="preserve">
          <source>Another identifier type used by the system is &lt;code&gt;xid&lt;/code&gt;, or transaction (abbreviated</source>
          <target state="translated">Другой тип идентификатора, используемый системой, - это &lt;code&gt;xid&lt;/code&gt; , или транзакция (сокращенно</target>
        </trans-unit>
        <trans-unit id="aed7ef2e15652a392b1a6ed9c8e4d99caec1a67e" translate="yes" xml:space="preserve">
          <source>Another important point is that when a server process is asked to display any of these statistics, it first fetches the most recent report emitted by the collector process and then continues to use this snapshot for all statistical views and functions until the end of its current transaction. So the statistics will show static information as long as you continue the current transaction. Similarly, information about the current queries of all sessions is collected when any such information is first requested within a transaction, and the same information will be displayed throughout the transaction. This is a feature, not a bug, because it allows you to perform several queries on the statistics and correlate the results without worrying that the numbers are changing underneath you. But if you want to see new results with each query, be sure to do the queries outside any transaction block. Alternatively, you can invoke &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt;(), which will discard the current transaction's statistics snapshot (if any). The next use of statistical information will cause a new snapshot to be fetched.</source>
          <target state="translated">Другой важный момент заключается в том, что когда серверный процесс запрашивает отображение любой из этих статистических данных, он сначала выбирает самый последний отчет, созданный процессом сборщика, а затем продолжает использовать этот моментальный снимок для всех статистических представлений и функций до конца своей текущей транзакции. . Таким образом, статистика будет показывать статическую информацию, пока вы продолжаете текущую транзакцию. Точно так же информация о текущих запросах всех сеансов собирается, когда любая такая информация впервые запрашивается в транзакции, и одна и та же информация будет отображаться на протяжении всей транзакции. Это функция, а не ошибка, потому что она позволяет вам выполнять несколько запросов по статистике и соотносить результаты, не беспокоясь о том, что числа меняются под вами. Но если вы хотите видеть новые результаты по каждому запросу,обязательно выполняйте запросы вне любого блока транзакции. В качестве альтернативы вы можете вызвать &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt; (), который отбросит моментальный снимок статистики текущей транзакции (если есть). Следующее использование статистической информации вызовет выборку нового снимка.</target>
        </trans-unit>
        <trans-unit id="b8503372565f5e8246e4f400f8ddf376d816116a" translate="yes" xml:space="preserve">
          <source>Another important property of transactional databases is closely related to the notion of atomic updates: when multiple transactions are running concurrently, each one should not be able to see the incomplete changes made by others. For example, if one transaction is busy totalling all the branch balances, it would not do for it to include the debit from Alice's branch but not the credit to Bob's branch, nor vice versa. So transactions must be all-or-nothing not only in terms of their permanent effect on the database, but also in terms of their visibility as they happen. The updates made so far by an open transaction are invisible to other transactions until the transaction completes, whereupon all the updates become visible simultaneously.</source>
          <target state="translated">Еще одно важное свойство транзакционных баз данных тесно связано с понятием атомарных обновлений:когда одновременно выполняется несколько транзакций,каждая из них не должна видеть неполные изменения,внесенные другими.Например,если одна транзакция занята суммированием всех остатков в филиале,она не будет включать в себя дебет с филиала Алисы,но не будет включать в себя кредит с филиала Боба,и наоборот.Таким образом,транзакции должны быть &quot;все или ничего&quot; не только с точки зрения их постоянного влияния на базу данных,но и с точки зрения их видимости по мере их осуществления.Обновления,сделанные до сих пор открытой транзакцией,невидимы для других транзакций до тех пор,пока транзакция не завершится,после чего все обновления становятся видимыми одновременно.</target>
        </trans-unit>
        <trans-unit id="23097e202fa3204d32b939bd963d1f1a19f9bc71" translate="yes" xml:space="preserve">
          <source>Another limitation is that when an inner tuple's node points to a set of leaf tuples, those tuples must all be in the same index page. (This is a design decision to reduce seeking and save space in the links that chain such tuples together.) If the set of leaf tuples grows too large for a page, a split is performed and an intermediate inner tuple is inserted. For this to fix the problem, the new inner tuple &lt;em&gt;must&lt;/em&gt; divide the set of leaf values into more than one node group. If the operator class's &lt;code&gt;picksplit&lt;/code&gt; function fails to do that, the SP-GiST core resorts to extraordinary measures described in &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;.</source>
          <target state="translated">Другое ограничение заключается в том, что когда узел внутреннего кортежа указывает на набор конечных кортежей, все эти кортежи должны находиться на одной странице индекса. (Это проектное решение, направленное на сокращение поиска и экономии места в ссылках, которые связывают такие кортежи вместе.) Если набор конечных кортежей становится слишком большим для страницы, выполняется разделение и вставляется промежуточный внутренний кортеж. Чтобы это разрешило проблему, новый внутренний кортеж &lt;em&gt;должен&lt;/em&gt; разделить набор значений листьев на более чем одну группу узлов. Если функция &lt;code&gt;picksplit&lt;/code&gt; класса операторов не может этого сделать, ядро ​​SP-GiST прибегает к чрезвычайным мерам, описанным в &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Разделе 65.4.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c5682b61a20f627d46e59c868bdcce430ea3716" translate="yes" xml:space="preserve">
          <source>Another limitation of the same kind is that a &lt;code&gt;CASE&lt;/code&gt; cannot prevent evaluation of an aggregate expression contained within it, because aggregate expressions are computed before other expressions in a &lt;code&gt;SELECT&lt;/code&gt; list or &lt;code&gt;HAVING&lt;/code&gt; clause are considered. For example, the following query can cause a division-by-zero error despite seemingly having protected against it:</source>
          <target state="translated">Другое ограничение того же типа состоит в том, что &lt;code&gt;CASE&lt;/code&gt; не может предотвратить оценку содержащегося в нем агрегатного выражения, поскольку агрегатные выражения вычисляются до того, как будут рассмотрены другие выражения в списке &lt;code&gt;SELECT&lt;/code&gt; или предложении &lt;code&gt;HAVING&lt;/code&gt; . Например, следующий запрос может вызвать ошибку деления на ноль, несмотря на кажущуюся защиту от нее:</target>
        </trans-unit>
        <trans-unit id="0e130eb29a636a2e4db63836c537e80b5eb47453" translate="yes" xml:space="preserve">
          <source>Another nonstandard extension is that following the escape character with a letter or digit provides access to the escape sequences defined for POSIX regular expressions; see &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;, &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;, and &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a59e6837fb64d2b0ae7bbcb08e5b72fd153fb2c" translate="yes" xml:space="preserve">
          <source>Another option for &lt;code&gt;local&lt;/code&gt; connections is for clients to use &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt;&lt;code&gt;requirepeer&lt;/code&gt;&lt;/a&gt; to specify the required owner of the server process connected to the socket.</source>
          <target state="translated">Другой вариант для &lt;code&gt;local&lt;/code&gt; подключений - для клиентов использовать &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt; &lt;code&gt;requirepeer&lt;/code&gt; &lt;/a&gt; для указания требуемого владельца серверного процесса, подключенного к сокету.</target>
        </trans-unit>
        <trans-unit id="306459cbdd31101692b05f06a566b18b0bdf0e20" translate="yes" xml:space="preserve">
          <source>Another option for &lt;code&gt;local&lt;/code&gt; connections is for clients to use &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt;&lt;code&gt;requirepeer&lt;/code&gt;&lt;/a&gt; to specify the required owner of the server process connected to the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5714af00c74e15b8a5da4136ed86aaafa447c5" translate="yes" xml:space="preserve">
          <source>Another option is to increase &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; on the primary server, so that dead rows will not be cleaned up as quickly as they normally would be. This will allow more time for queries to execute before they are canceled on the standby, without having to set a high &lt;code&gt;max_standby_streaming_delay&lt;/code&gt;. However it is difficult to guarantee any specific execution-time window with this approach, since &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; is measured in transactions executed on the primary server.</source>
          <target state="translated">Другой вариант - увеличить &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;Vacuum_defer_cleanup_age&lt;/a&gt; на основном сервере, чтобы мертвые строки не очищались так быстро, как обычно. Это даст больше времени для выполнения запросов, прежде чем они будут отменены на резервном &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; , без необходимости устанавливать высокое значение max_standby_streaming_delay . Однако при таком подходе трудно гарантировать какое-либо конкретное окно времени выполнения, так как &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; измеряется транзакциями, выполняемыми на основном сервере.</target>
        </trans-unit>
        <trans-unit id="7e21e953eee19c97f61f831dca8e524d5dd57839" translate="yes" xml:space="preserve">
          <source>Another option is to use rsync to perform a file system backup. This is done by first running rsync while the database server is running, then shutting down the database server long enough to do an &lt;code&gt;rsync --checksum&lt;/code&gt;. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) The second rsync will be quicker than the first, because it has relatively little data to transfer, and the end result will be consistent because the server was down. This method allows a file system backup to be performed with minimal downtime.</source>
          <target state="translated">Другой вариант - использовать rsync для резервного копирования файловой системы. Для этого сначала нужно запустить rsync во время работы сервера базы данных, а затем выключить сервер базы данных на время, достаточное для выполнения команды &lt;code&gt;rsync --checksum&lt;/code&gt; . ( &lt;code&gt;--checksum&lt;/code&gt; необходим, потому что &lt;code&gt;rsync&lt;/code&gt; имеет гранулярность времени модификации файла только в одну секунду.) Второй rsync будет быстрее, чем первый, потому что у него относительно мало данных для передачи, и конечный результат будет согласованным, поскольку сервер был вниз. Этот метод позволяет выполнить резервное копирование файловой системы с минимальным временем простоя.</target>
        </trans-unit>
        <trans-unit id="7c34c9f74979196480818c068869e2f214816a27" translate="yes" xml:space="preserve">
          <source>Another option that is often preferable is to remove the partition from the partitioned table but retain access to it as a table in its own right:</source>
          <target state="translated">Другой вариант,который часто предпочтительнее,это удалить раздел из таблицы разметки,но сохранить доступ к нему как к самостоятельной таблице:</target>
        </trans-unit>
        <trans-unit id="2a69438b1163aac867f43267272d34d1c58b2559" translate="yes" xml:space="preserve">
          <source>Another point to keep in mind is that by default, execute privilege is granted to &lt;code&gt;PUBLIC&lt;/code&gt; for newly created functions (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for more information). Frequently you will wish to restrict use of a security definer function to only some users. To do that, you must revoke the default &lt;code&gt;PUBLIC&lt;/code&gt; privileges and then grant execute privilege selectively. To avoid having a window where the new function is accessible to all, create it and set the privileges within a single transaction. For example:</source>
          <target state="translated">Еще один момент, о котором следует помнить, это то, что по умолчанию привилегия выполнения предоставляется &lt;code&gt;PUBLIC&lt;/code&gt; для вновь созданных функций (см. &lt;a href=&quot;ddl-priv&quot;&gt;Раздел 5.7&lt;/a&gt; для получения дополнительной информации). Часто вам нужно ограничить использование функции определения безопасности только некоторыми пользователями. Для этого вы должны отозвать привилегии &lt;code&gt;PUBLIC&lt;/code&gt; по умолчанию, а затем выборочно предоставить привилегию выполнения. Чтобы не было окна, в котором новая функция доступна для всех, создайте его и установите права в рамках одной транзакции. Например:</target>
        </trans-unit>
        <trans-unit id="c64ca403c18f38074dbf9506c7423e6c0d47b0ca" translate="yes" xml:space="preserve">
          <source>Another possibility is to create a configuration file directory and put this information into files there. For example, a &lt;code&gt;conf.d&lt;/code&gt; directory could be referenced at the end of &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">Другая возможность - создать каталог файлов конфигурации и поместить эту информацию в файлы там. Например, на каталог &lt;code&gt;conf.d&lt;/code&gt; можно ссылаться в конце &lt;code&gt;postgresql.conf&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e15bc878f1b5a7c697e8423bcee242bc5167d6a2" translate="yes" xml:space="preserve">
          <source>Another possibility is to store the documents as simple text files in the file system. In this case, the database can be used to store the full text index and to execute searches, and some unique identifier can be used to retrieve the document from the file system. However, retrieving files from outside the database requires superuser permissions or special function support, so this is usually less convenient than keeping all the data inside PostgreSQL. Also, keeping everything inside the database allows easy access to document metadata to assist in indexing and display.</source>
          <target state="translated">Другая возможность-хранение документов в файловой системе в виде простых текстовых файлов.В этом случае база данных может быть использована для хранения полного текстового индекса и выполнения поиска,а для получения документа из файловой системы может быть использован какой-нибудь уникальный идентификатор.Однако получение файлов вне базы данных требует прав суперпользователя или поддержки специальных функций,поэтому это обычно менее удобно,чем хранение всех данных внутри PostgreSQL.Кроме того,хранение всех данных внутри базы данных позволяет легко получить доступ к метаданным документов,что помогает в индексировании и отображении.</target>
        </trans-unit>
        <trans-unit id="8fbada3201971de13171c32bf7cda835bc3fd1af" translate="yes" xml:space="preserve">
          <source>Another possible type of join is a merge join, illustrated here:</source>
          <target state="translated">Другой возможный тип соединения-слияние,проиллюстрированное здесь:</target>
        </trans-unit>
        <trans-unit id="19829ac1739436800f592d8b7c21c52fef4c33d8" translate="yes" xml:space="preserve">
          <source>Another possible use for a partial index is to exclude values from the index that the typical query workload is not interested in; this is shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;Example 11.2&lt;/a&gt;. This results in the same advantages as listed above, but it prevents the &amp;ldquo;uninteresting&amp;rdquo; values from being accessed via that index, even if an index scan might be profitable in that case. Obviously, setting up partial indexes for this kind of scenario will require a lot of care and experimentation.</source>
          <target state="translated">Еще одно возможное использование частичного индекса - исключение из индекса значений, которые не интересуют типичную рабочую нагрузку запроса; это показано в &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;Примере 11.2&lt;/a&gt; . Это дает те же преимущества, что и перечисленные выше, но предотвращает доступ к &amp;laquo;неинтересным&amp;raquo; значениям через этот индекс, даже если в этом случае сканирование индекса может быть выгодным. Очевидно, что настройка частичных индексов для такого сценария потребует большой осторожности и экспериментов.</target>
        </trans-unit>
        <trans-unit id="f28a354a8ba88184cb3beacb89675afbd6c03d21" translate="yes" xml:space="preserve">
          <source>Another production-grade approach to managing log output is to send it to syslog and let syslog deal with file rotation. To do this, set the configuration parameter &lt;code&gt;log_destination&lt;/code&gt; to &lt;code&gt;syslog&lt;/code&gt; (to log to syslog only) in &lt;code&gt;postgresql.conf&lt;/code&gt;. Then you can send a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the syslog daemon whenever you want to force it to start writing a new log file. If you want to automate log rotation, the logrotate program can be configured to work with log files from syslog.</source>
          <target state="translated">Другой подход производственного уровня к управлению выводом журнала - это его отправка в системный журнал и предоставление возможности системному журналу заниматься ротацией файлов. Для этого установите для параметра конфигурации &lt;code&gt;log_destination&lt;/code&gt; значение &lt;code&gt;syslog&lt;/code&gt; (только для регистрации в syslog) в &lt;code&gt;postgresql.conf&lt;/code&gt; . Затем вы можете послать сигнал &lt;code&gt;SIGHUP&lt;/code&gt; демону syslog всякий раз, когда вы захотите заставить его начать запись нового файла журнала. Если вы хотите автоматизировать ротацию журналов, программу logrotate можно настроить для работы с файлами журналов из syslog.</target>
        </trans-unit>
        <trans-unit id="0d7e78b3e262e81affaac44d4c64dc15d4edfbba" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;FOR UPDATE&lt;/code&gt; is that without it, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; might fail if the cursor query does not meet the SQL standard's rules for being &amp;ldquo;simply updatable&amp;rdquo; (in particular, the cursor must reference just one table and not use grouping or &lt;code&gt;ORDER BY&lt;/code&gt;). Cursors that are not simply updatable might work, or might not, depending on plan choice details; so in the worst case, an application might work in testing and then fail in production. If &lt;code&gt;FOR UPDATE&lt;/code&gt; is specified, the cursor is guaranteed to be updatable.</source>
          <target state="translated">Еще одна причина использовать &lt;code&gt;FOR UPDATE&lt;/code&gt; заключается в том, что без него последующий &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; может завершиться неудачно, если запрос курсора не соответствует правилам стандарта SQL для &amp;laquo;простого обновления&amp;raquo; (в частности, курсор должен ссылаться только на одну таблицу и не использовать группировку или &lt;code&gt;ORDER BY&lt;/code&gt; ). Курсоры, которые нельзя просто обновить, могут работать, а могут и не работать, в зависимости от деталей выбора плана; поэтому в худшем случае приложение может работать при тестировании, а затем выйти из строя в производственной среде. Если указано &lt;code&gt;FOR UPDATE&lt;/code&gt; , курсор гарантированно обновляется.</target>
        </trans-unit>
        <trans-unit id="6f33d845713febc0898090d451e4ee3ef8ebffb5" translate="yes" xml:space="preserve">
          <source>Another requirement for a multiple-data-type family is that any implicit or binary-coercion casts that are defined between data types included in the operator family must not change the associated sort ordering.</source>
          <target state="translated">Другое требование для семейства,состоящего из нескольких типов данных,заключается в том,что любые неявные или двоичные касты,которые определяются между типами данных,входящими в семейство операторов,не должны изменять связанного с ними порядка сортировки.</target>
        </trans-unit>
        <trans-unit id="9114df95c9c9d6782e38dbaee1edab69dd63ee66" translate="yes" xml:space="preserve">
          <source>Another response could be this:</source>
          <target state="translated">Другой ответ может быть таким:</target>
        </trans-unit>
        <trans-unit id="67c38a78e448cde09317f71b64feae68f30e256d" translate="yes" xml:space="preserve">
          <source>Another risk of data loss is posed by the disk platter write operations themselves. Disk platters are divided into sectors, commonly 512 bytes each. Every physical read or write operation processes a whole sector. When a write request arrives at the drive, it might be for some multiple of 512 bytes (PostgreSQL typically writes 8192 bytes, or 16 sectors, at a time), and the process of writing could fail due to power loss at any time, meaning some of the 512-byte sectors were written while others were not. To guard against such failures, PostgreSQL periodically writes full page images to permanent WAL storage &lt;em&gt;before&lt;/em&gt; modifying the actual page on disk. By doing this, during crash recovery PostgreSQL can restore partially-written pages from WAL. If you have file-system software that prevents partial page writes (e.g., ZFS), you can turn off this page imaging by turning off the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. Battery-Backed Unit (BBU) disk controllers do not prevent partial page writes unless they guarantee that data is written to the BBU as full (8kB) pages.</source>
          <target state="translated">Другой риск потери данных связан с самими операциями записи на диск. Пластины диска разделены на сектора, обычно по 512 байт каждый. Каждая операция физического чтения или записи обрабатывает целый сектор. Когда на диск поступает запрос на запись, он может быть кратным 512 байтам (PostgreSQL обычно записывает 8192 байта или 16 секторов за раз), и процесс записи может завершиться неудачно из-за потери питания в любое время, что означает некоторые из 512-байтовых секторов были записаны, а другие нет. Чтобы защититься от таких сбоев, PostgreSQL периодически записывает полные образы страниц в постоянное хранилище WAL &lt;em&gt;перед&lt;/em&gt;изменение реальной страницы на диске. Таким образом, во время аварийного восстановления PostgreSQL может восстановить частично записанные страницы из WAL. Если у вас есть программное обеспечение файловой системы, которое предотвращает частичную запись страниц (например, ZFS), вы можете отключить отображение этой страницы, &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;отключив&lt;/a&gt; параметр full_page_writes . Контроллеры дисков с батарейным питанием (BBU) не предотвращают частичную запись страниц, если только они не гарантируют, что данные записываются в BBU как полные (8 КБ) страницы.</target>
        </trans-unit>
        <trans-unit id="a64140ba6c591322306ded2e563c831d5063eb12" translate="yes" xml:space="preserve">
          <source>Another special feature is that during input, you can write &lt;code&gt;?&lt;/code&gt; in place of the check digit, and the correct check digit will be inserted automatically.</source>
          <target state="translated">Еще одна особенность заключается в том, что во время ввода вы можете написать &lt;code&gt;?&lt;/code&gt; вместо контрольной цифры, и правильная контрольная цифра будет вставлена ​​автоматически.</target>
        </trans-unit>
        <trans-unit id="d8a7029d22a4fea1aec3f6a0a7967d7366ab11c8" translate="yes" xml:space="preserve">
          <source>Another special syntactical behavior associated with composite values is that we can use &lt;em&gt;functional notation&lt;/em&gt; for extracting a field of a composite value. The simple way to explain this is that the notations &lt;code&gt;field(table)&lt;/code&gt; and &lt;code&gt;table.field&lt;/code&gt; are interchangeable. For example, these queries are equivalent:</source>
          <target state="translated">Другое особое синтаксическое поведение, связанное с составными значениями, состоит в том, что мы можем использовать &lt;em&gt;функциональную нотацию&lt;/em&gt; для извлечения поля составного значения. Самый простой способ объяснить это - &lt;code&gt;field(table)&lt;/code&gt; обозначений (таблица) и &lt;code&gt;table.field&lt;/code&gt; взаимозаменяемы. Например, эти запросы эквивалентны:</target>
        </trans-unit>
        <trans-unit id="2d14ebbe44cc336bb06782ca5c2e2a5afdbf5d04" translate="yes" xml:space="preserve">
          <source>Another type of extra information is the number of rows removed by a filter condition:</source>
          <target state="translated">Другим типом дополнительной информации является количество строк,удаленных условием фильтрации:</target>
        </trans-unit>
        <trans-unit id="de04ff7f29beb7d9f803262abe6fbc7f7a247ce7" translate="yes" xml:space="preserve">
          <source>Another type of statistics stored for each column are most-common value lists. This allows very accurate estimates for individual columns, but may result in significant misestimates for queries with conditions on multiple columns.</source>
          <target state="translated">Другим типом статистики,хранящейся для каждого столбца,являются наиболее распространенные списки значений.Это позволяет получить очень точные оценки для отдельных столбцов,но может привести к значительной мистимации для запросов с условиями по нескольким столбцам.</target>
        </trans-unit>
        <trans-unit id="aef386cf940d64dd2d0246974eb986d99db04233" translate="yes" xml:space="preserve">
          <source>Another useful tool for monitoring database activity is the &lt;code&gt;pg_locks&lt;/code&gt; system table. It allows the database administrator to view information about the outstanding locks in the lock manager. For example, this capability can be used to:</source>
          <target state="translated">Еще один полезный инструмент для мониторинга активности базы данных - системная таблица &lt;code&gt;pg_locks&lt;/code&gt; . Это позволяет администратору базы данных просматривать информацию о невыполненных блокировках в диспетчере блокировок. Например, эту возможность можно использовать для:</target>
        </trans-unit>
        <trans-unit id="973de1b89f5a19d8493a281c676145e3c2762491" translate="yes" xml:space="preserve">
          <source>Another value expression in parentheses (used to group subexpressions and override precedence)</source>
          <target state="translated">Другое выражение в круглых скобках (используется для группировки подвыражений и переопределения старшинства)</target>
        </trans-unit>
        <trans-unit id="6edaee98c73d284626179be9ad3ba0277589e38b" translate="yes" xml:space="preserve">
          <source>Another way to accomplish the same thing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a50bf5d6a0c79646db228f587b35fc8dbea931f" translate="yes" xml:space="preserve">
          <source>Another way to do it is:</source>
          <target state="translated">Другой способ сделать это:</target>
        </trans-unit>
        <trans-unit id="09b69091260be1fa872b4a938337bcecea2b0096" translate="yes" xml:space="preserve">
          <source>Another way to get the same effect is to use the &lt;code&gt;regclass&lt;/code&gt; alias type, which will print the table OID symbolically:</source>
          <target state="translated">Другой способ получить тот же эффект - использовать тип псевдонима &lt;code&gt;regclass&lt;/code&gt; , который будет печатать OID таблицы символически:</target>
        </trans-unit>
        <trans-unit id="77f482e38cebbd37d2bd4865436228573a9f332c" translate="yes" xml:space="preserve">
          <source>Another way to obtain the same result as &lt;code&gt;\copy ... to&lt;/code&gt; is to use the SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; command and terminate it with &lt;code&gt;\g filename&lt;/code&gt; or &lt;code&gt;\g |program&lt;/code&gt;. Unlike &lt;code&gt;\copy&lt;/code&gt;, this method allows the command to span multiple lines; also, variable interpolation and backquote expansion can be used.</source>
          <target state="translated">Другой способ получить тот же результат, что и &lt;code&gt;\copy ... to&lt;/code&gt; - использовать команду SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; и завершить ее с помощью &lt;code&gt;\g filename&lt;/code&gt; или &lt;code&gt;\g |program&lt;/code&gt; . В отличие от &lt;code&gt;\copy&lt;/code&gt; , этот метод позволяет команде занимать несколько строк; также может использоваться интерполяция переменных и расширение обратных кавычек.</target>
        </trans-unit>
        <trans-unit id="af0ee54bbb9066194d74463e9d95fe7b567d2abb" translate="yes" xml:space="preserve">
          <source>Another way to return multiple columns is to use a &lt;code&gt;TABLE&lt;/code&gt; function:</source>
          <target state="translated">Другой способ вернуть несколько столбцов - использовать функцию &lt;code&gt;TABLE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="886fca6d2b20a157de482df72d3dea2c336eadc6" translate="yes" xml:space="preserve">
          <source>Another way to think about a discrete range type is that there is a clear idea of a &amp;ldquo;next&amp;rdquo; or &amp;ldquo;previous&amp;rdquo; value for each element value. Knowing that, it is possible to convert between inclusive and exclusive representations of a range's bounds, by choosing the next or previous element value instead of the one originally given. For example, in an integer range type &lt;code&gt;[4,8]&lt;/code&gt; and &lt;code&gt;(3,9)&lt;/code&gt; denote the same set of values; but this would not be so for a range over numeric.</source>
          <target state="translated">Другой способ думать о типе дискретного диапазона состоит в том, что существует четкое представление о &amp;laquo;следующем&amp;raquo; или &amp;laquo;предыдущем&amp;raquo; значении для каждого значения элемента. Зная это, можно преобразовывать между инклюзивным и исключительным представлениями границ диапазона, выбирая следующее или предыдущее значение элемента вместо первоначально заданного. Например, в целочисленном диапазоне типы &lt;code&gt;[4,8]&lt;/code&gt; и &lt;code&gt;(3,9)&lt;/code&gt; обозначают один и тот же набор значений; но это не будет так для диапазона, превышающего числовой.</target>
        </trans-unit>
        <trans-unit id="d84849349152ff8e618adbfaeb1704c4dc99ecf7" translate="yes" xml:space="preserve">
          <source>Another way to work with angles measured in degrees is to use the unit transformation functions &lt;code&gt;radians()&lt;/code&gt; and &lt;code&gt;degrees()&lt;/code&gt; shown earlier. However, using the degree-based trigonometric functions is preferred, as that way avoids round-off error for special cases such as &lt;code&gt;sind(30)&lt;/code&gt;.</source>
          <target state="translated">Другой способ работы с углами, измеряемыми в градусах, - это использование функций преобразования единиц в &lt;code&gt;radians()&lt;/code&gt; и &lt;code&gt;degrees()&lt;/code&gt; показанных ранее. Однако использование тригонометрических функций на основе степеней является предпочтительным, так как это позволяет избежать ошибки округления для особых случаев, таких как &lt;code&gt;sind(30)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efdd30de2aea5b5d5befd3533f098d92f63380ab" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DECLARE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; statement, whose execution plan you wish to see.</source>
          <target state="translated">Любой &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;VALUES&lt;/code&gt; , &lt;code&gt;EXECUTE&lt;/code&gt; , &lt;code&gt;DECLARE&lt;/code&gt; , &lt;code&gt;CREATE TABLE AS&lt;/code&gt; или &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; , план выполнения которого вы хотите увидеть.</target>
        </trans-unit>
        <trans-unit id="386ffc8dd49c3fb7f2ddd349b2b9b4201e8b40ad" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; statement.</source>
          <target state="translated">Любой &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; или &lt;code&gt;VALUES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="450e11982aec06ef4f3dbb171ba6a8eb1e20a7be" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;cidr&lt;/code&gt; value can be cast to &lt;code&gt;inet&lt;/code&gt; implicitly or explicitly; therefore, the functions shown above as operating on &lt;code&gt;inet&lt;/code&gt; also work on &lt;code&gt;cidr&lt;/code&gt; values. (Where there are separate functions for &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;, it is because the behavior should be different for the two cases.) Also, it is permitted to cast an &lt;code&gt;inet&lt;/code&gt; value to &lt;code&gt;cidr&lt;/code&gt;. When this is done, any bits to the right of the netmask are silently zeroed to create a valid &lt;code&gt;cidr&lt;/code&gt; value. In addition, you can cast a text value to &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; using normal casting syntax: for example, &lt;code&gt;inet(expression)&lt;/code&gt; or &lt;code&gt;colname::cidr&lt;/code&gt;.</source>
          <target state="translated">Любое значение &lt;code&gt;cidr&lt;/code&gt; может быть явно или неявно преобразовано в &lt;code&gt;inet&lt;/code&gt; ; следовательно, функции, показанные выше как работающие в &lt;code&gt;inet&lt;/code&gt; , также работают со значениями &lt;code&gt;cidr&lt;/code&gt; . (Там, где есть отдельные функции для &lt;code&gt;inet&lt;/code&gt; и &lt;code&gt;cidr&lt;/code&gt; , это потому, что поведение должно быть разным для этих двух случаев.) Кроме того, разрешено приводить значение &lt;code&gt;inet&lt;/code&gt; к &lt;code&gt;cidr&lt;/code&gt; . Когда это будет сделано, любые биты справа от &lt;code&gt;cidr&lt;/code&gt; маски незаметно обнуляются для создания допустимого значения cidr . Кроме того, вы можете преобразовать текстовое значение в &lt;code&gt;inet&lt;/code&gt; или &lt;code&gt;cidr&lt;/code&gt; , используя обычный синтаксис преобразования : например, &lt;code&gt;inet(expression)&lt;/code&gt; или &lt;code&gt;colname::cidr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8208175702ffb5cdd4ede5051892cf19b0e69014" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;cidr&lt;/code&gt; value can be cast to &lt;code&gt;inet&lt;/code&gt; implicitly; therefore, the operators and functions shown below as operating on &lt;code&gt;inet&lt;/code&gt; also work on &lt;code&gt;cidr&lt;/code&gt; values. (Where there are separate functions for &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;, it is because the behavior should be different for the two cases.) Also, it is permitted to cast an &lt;code&gt;inet&lt;/code&gt; value to &lt;code&gt;cidr&lt;/code&gt;. When this is done, any bits to the right of the netmask are silently zeroed to create a valid &lt;code&gt;cidr&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a5e9f25fdf2d6789317985300af494edaa42f6" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The condition expression cannot refer to any tables except &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt;, and cannot contain aggregate functions.</source>
          <target state="translated">Любое условное выражение SQL (возвращающее &lt;code&gt;boolean&lt;/code&gt; ). Выражение условия не может ссылаться ни на какие таблицы, кроме &lt;code&gt;NEW&lt;/code&gt; и &lt;code&gt;OLD&lt;/code&gt; , и не может содержать агрегатные функции.</target>
        </trans-unit>
        <trans-unit id="7f04645af195b0769f156d1c9178d5413d13947d" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be added to queries that refer to the table if row level security is enabled. Rows for which the expression returns true will be visible. Any rows for which the expression returns false or null will not be visible to the user (in a &lt;code&gt;SELECT&lt;/code&gt;), and will not be available for modification (in an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;). Such rows are silently suppressed; no error is reported.</source>
          <target state="translated">Любое условное выражение SQL (возвращающее &lt;code&gt;boolean&lt;/code&gt; ). Условное выражение не может содержать агрегатных или оконных функций. Это выражение будет добавлено к запросам, которые ссылаются на таблицу, если включена защита на уровне строк. Строки, для которых выражение возвращает истину, будут видны. Любые строки, для которых выражение возвращает false или null, не будут видны пользователю (в &lt;code&gt;SELECT&lt;/code&gt; ) и не будут доступны для изменения (в &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; ). Такие строки молча подавляются; об ошибках не сообщается.</target>
        </trans-unit>
        <trans-unit id="9d0a8e5978d0613618d7d621bf1cd5c083979c7e" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be used in &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; queries against the table if row level security is enabled. Only rows for which the expression evaluates to true will be allowed. An error will be thrown if the expression evaluates to false or null for any of the records inserted or any of the records that result from the update. Note that the &lt;code&gt;check_expression&lt;/code&gt; is evaluated against the proposed new contents of the row, not the original contents.</source>
          <target state="translated">Любое условное выражение SQL (возвращающее &lt;code&gt;boolean&lt;/code&gt; ). Условное выражение не может содержать агрегатных или оконных функций. Это выражение будет использоваться в запросах &lt;code&gt;INSERT&lt;/code&gt; и &lt;code&gt;UPDATE&lt;/code&gt; к таблице, если включена защита на уровне строк. Будут разрешены только строки, для которых выражение истинно. Ошибка будет выдана, если выражение оценивается как ложное или нулевое для любой из вставленных записей или любой из записей, полученных в результате обновления. Обратите внимание, что &lt;code&gt;check_expression&lt;/code&gt; сравнивается с предложенным новым содержимым строки, а не с исходным содержимым.</target>
        </trans-unit>
        <trans-unit id="3e356ac9cfe76e1d8f07ddb1a43d7eac6d271ea2" translate="yes" xml:space="preserve">
          <source>Any character in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; that matches a character in the &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; set is replaced by the corresponding character in the &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt; set. If &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; is longer than &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt;, occurrences of the extra characters in &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; are removed.</source>
          <target state="translated">Любой символ в &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; который соответствует символу в наборе &lt;em&gt; &lt;code&gt;from&lt;/code&gt; ,&lt;/em&gt; заменяется соответствующим символом в наборе &lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt; . Если &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; длиннее, чем &lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt; , вхождения лишних символов в &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; удаляются.</target>
        </trans-unit>
        <trans-unit id="12f81b0886507c6c81c137ed43e36901064a888a" translate="yes" xml:space="preserve">
          <source>Any developer of a new &lt;code&gt;table access method&lt;/code&gt; can refer to the existing &lt;code&gt;heap&lt;/code&gt; implementation present in &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; for details of its implementation.</source>
          <target state="translated">Любой разработчик нового &lt;code&gt;table access method&lt;/code&gt; может обратиться к существующей реализации &lt;code&gt;heap&lt;/code&gt; присутствующей в &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; , для получения подробной информации о ее реализации.</target>
        </trans-unit>
        <trans-unit id="144550beabeed185659254b872d28c678638c93a" translate="yes" xml:space="preserve">
          <source>Any digest algorithm OpenSSL supports is automatically picked up. This is not possible with ciphers, which need to be supported explicitly.</source>
          <target state="translated">Любой алгоритм дайджеста,поддерживаемый OpenSSL,подхватывается автоматически.Это невозможно при использовании шифров,которые должны поддерживаться явно.</target>
        </trans-unit>
        <trans-unit id="c4c8c401fe264a209ebccf99c5f886fc113da7d7" translate="yes" xml:space="preserve">
          <source>Any file or directory beginning with &lt;code&gt;pgsql_tmp&lt;/code&gt; can be omitted from the backup. These files are removed on postmaster start and the directories will be recreated as needed.</source>
          <target state="translated">Любой файл или каталог, начинающийся с &lt;code&gt;pgsql_tmp&lt;/code&gt; , можно исключить из резервной копии. Эти файлы удаляются при запуске postmaster, а каталоги будут созданы заново по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="a836141ba30a8aa1360f43439d3c24535024a80a" translate="yes" xml:space="preserve">
          <source>Any generation expressions of copied column definitions will be copied. By default, new columns will be regular base columns.</source>
          <target state="translated">Любые выражения генерации скопированных определений столбцов будут скопированы.По умолчанию новые столбцы будут обычными базовыми.</target>
        </trans-unit>
        <trans-unit id="5e18734ff6a37a9bb9fd3457eedcb31fb70163d6" translate="yes" xml:space="preserve">
          <source>Any identity specifications of copied column definitions will be copied. A new sequence is created for each identity column of the new table, separate from the sequences associated with the old table.</source>
          <target state="translated">Любые идентификационные характеристики скопированных определений колонок будут скопированы.Для каждого идентификационного столбца новой таблицы создается новая последовательность,отдельная от последовательностей,связанных со старой таблицей.</target>
        </trans-unit>
        <trans-unit id="feba919d6ac95ebb1703749287894bc69e982374" translate="yes" xml:space="preserve">
          <source>Any memberships in the group role are automatically revoked (but the member roles are not otherwise affected).</source>
          <target state="translated">Любое членство в роли группы автоматически отменяется (но роли членов не затрагиваются иным образом).</target>
        </trans-unit>
        <trans-unit id="13a56d22fdbd5ea4aa4d99bf869d62836d2a9dbc" translate="yes" xml:space="preserve">
          <source>Any object that can be created with a &lt;code&gt;CREATE&lt;/code&gt; command. Most objects are specific to one database, and are commonly known as &lt;em&gt;local objects&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f42a74d5d4ceddfdc2731676cd56c9941e931e10" translate="yes" xml:space="preserve">
          <source>Any other backslashed character that is not mentioned in the above table will be taken to represent itself. However, beware of adding backslashes unnecessarily, since that might accidentally produce a string matching the end-of-data marker (&lt;code&gt;\.&lt;/code&gt;) or the null string (&lt;code&gt;\N&lt;/code&gt; by default). These strings will be recognized before any other backslash processing is done.</source>
          <target state="translated">Любой другой символ с обратной косой чертой, не упомянутый в приведенной выше таблице, будет представлять самого себя. Однако будьте осторожны с добавлением обратной косой черты без необходимости, так как это может случайно привести к появлению строки, соответствующей маркеру конца данных ( &lt;code&gt;\.&lt;/code&gt; ) Или нулевой строке ( по умолчанию &lt;code&gt;\N&lt;/code&gt; ). Эти строки будут распознаны до выполнения любой другой обработки с обратной косой чертой.</target>
        </trans-unit>
        <trans-unit id="59556037a647190d9808748d3940223c9b60fa38" translate="yes" xml:space="preserve">
          <source>Any other character following a backslash is taken literally. Thus, to include a backslash character, write two backslashes (&lt;code&gt;\\&lt;/code&gt;). Also, a single quote can be included in an escape string by writing &lt;code&gt;\'&lt;/code&gt;, in addition to the normal way of &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">Любой другой символ после обратной косой черты воспринимается буквально. Таким образом, чтобы включить обратную косую черту, напишите две обратной косой черты ( &lt;code&gt;\\&lt;/code&gt; ). Кроме того, в escape-строку можно включить одинарную кавычку, написав &lt;code&gt;\'&lt;/code&gt; в дополнение к обычному способу &lt;code&gt;''&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="deecfecd8837d0982d5dc84b37df7cbf1f0b77cf" translate="yes" xml:space="preserve">
          <source>Any process, possibly remote, that establishes a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;session&lt;/a&gt; by &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connecting&lt;/a&gt; to an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; to interact with a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6176992a355fd17e3c78216ef8246e171f7a7f5d" translate="yes" xml:space="preserve">
          <source>Any rows whose updated values do not pass the &lt;code&gt;WITH CHECK&lt;/code&gt; expression will cause an error, and the entire command will be aborted. If only a &lt;code&gt;USING&lt;/code&gt; clause is specified, then that clause will be used for both &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;WITH CHECK&lt;/code&gt; cases.</source>
          <target state="translated">Любые строки, обновленные значения которых не передают выражение &lt;code&gt;WITH CHECK&lt;/code&gt; , вызовут ошибку, и вся команда будет прервана. Если указано только предложение &lt;code&gt;USING&lt;/code&gt; , оно будет использоваться как для случаев &lt;code&gt;USING&lt;/code&gt; ,так и &lt;code&gt;WITH CHECK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e53b9947d34df736f27a314411d8d097ccb99c38" translate="yes" xml:space="preserve">
          <source>Any two opposite corners can be supplied on input, but the values will be reordered as needed to store the upper right and lower left corners, in that order.</source>
          <target state="translated">Любые два противоположных угла могут быть поставлены на вход,но значения будут переупорядочены по мере необходимости для хранения верхнего правого и нижнего левого углов в таком порядке.</target>
        </trans-unit>
        <trans-unit id="9cd48f92d0048ad74a4b2a1c77759555487aa4a5" translate="yes" xml:space="preserve">
          <source>Any value of &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; greater than 0 selects the shortest-precise format.</source>
          <target state="translated">Любое значение &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; больше 0 выбирает самый короткий и точный формат.</target>
        </trans-unit>
        <trans-unit id="6e1092ad7e1aa0d329dcf1a1dc88a2fd1167428b" translate="yes" xml:space="preserve">
          <source>Anything you enter in psql that begins with an unquoted backslash is a psql meta-command that is processed by psql itself. These commands make psql more useful for administration or scripting. Meta-commands are often called slash or backslash commands.</source>
          <target state="translated">Все,что вы вводите в psql,начинающееся с нецитируемого обратного слеша,является мета-командой psql,которая обрабатывается самим psql.Эти команды делают psql более полезным для администрирования или скриптинга.Мета-команды часто называют командами слеша или обратного слеша.</target>
        </trans-unit>
        <trans-unit id="ca34db883b90f5136d142c2d8962aac808f06344" translate="yes" xml:space="preserve">
          <source>Append the server log output to &lt;code&gt;filename&lt;/code&gt;. If the file does not exist, it is created. The umask is set to 077, so access to the log file is disallowed to other users by default.</source>
          <target state="translated">Добавьте вывод журнала сервера к &lt;code&gt;filename&lt;/code&gt; . Если файл не существует, он создается. Для umask установлено значение 077, поэтому доступ к файлу журнала другим пользователям по умолчанию запрещен.</target>
        </trans-unit>
        <trans-unit id="8837d91fde54bfbd4c7276bc104dbd7eb57e326a" translate="yes" xml:space="preserve">
          <source>Appendix A. PostgreSQL Error Codes</source>
          <target state="translated">Приложение А.Коды ошибок PostgreSQL</target>
        </trans-unit>
        <trans-unit id="8f525f98762ab18cc61fb77a68f4661a9eaa0966" translate="yes" xml:space="preserve">
          <source>Appendix B. Date/Time Support</source>
          <target state="translated">Приложение В.Дата/время поддержки</target>
        </trans-unit>
        <trans-unit id="0a4fd0d75b5e8cb67c2577d915d2f158e36d619c" translate="yes" xml:space="preserve">
          <source>Appendix C. SQL Key Words</source>
          <target state="translated">Приложение С.Ключевые слова SQL</target>
        </trans-unit>
        <trans-unit id="2d3d6ce5d75b048ec4b4bfd56085229d360ae080" translate="yes" xml:space="preserve">
          <source>Appendix D. SQL Conformance</source>
          <target state="translated">Приложение D.Совместимость с SQL</target>
        </trans-unit>
        <trans-unit id="1c760d4057771bdbd912b1a26d17b99309626b19" translate="yes" xml:space="preserve">
          <source>Appendix E. Release Notes</source>
          <target state="translated">Приложение Е.Информация о выпуске</target>
        </trans-unit>
        <trans-unit id="3cc083a7e98cb9a510c3b8e9fe828f669dae8eb2" translate="yes" xml:space="preserve">
          <source>Appendix F. Additional Supplied Modules</source>
          <target state="translated">Приложение F.Дополнительные поставляемые модули</target>
        </trans-unit>
        <trans-unit id="0a757b9f46902730f7dbc09c2b987bcc9b1402c2" translate="yes" xml:space="preserve">
          <source>Appendix G. Additional Supplied Programs</source>
          <target state="translated">Приложение G.Дополнительные поставляемые программы</target>
        </trans-unit>
        <trans-unit id="f731ac7aad79287ad6a9d70b29b7d9f22f9d74ad" translate="yes" xml:space="preserve">
          <source>Appendix K. PostgreSQL Limits</source>
          <target state="translated">Приложение К.Пределы PostgreSQL</target>
        </trans-unit>
        <trans-unit id="6b2f6b4afe56f03c3636cff98cc090e912a2978a" translate="yes" xml:space="preserve">
          <source>Appendix L. Acronyms</source>
          <target state="translated">Приложение L.Сокращения</target>
        </trans-unit>
        <trans-unit id="f60b3f6b35cf4c13bfaa5fa9f25882503add453a" translate="yes" xml:space="preserve">
          <source>Appendix M. Glossary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea37fd5c2add8dc11cd4eac4e99886acbe263edc" translate="yes" xml:space="preserve">
          <source>Appendix N. Color Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2daf479a3e3b6ca8645aabab30691c459271fc" translate="yes" xml:space="preserve">
          <source>Appendix: Additional Supplied Modules</source>
          <target state="translated">Приложение:Дополнительные поставляемые модули</target>
        </trans-unit>
        <trans-unit id="212a37d7af38255a5010be41cf96e1919f1f65fe" translate="yes" xml:space="preserve">
          <source>Appendix: Color Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe175a1da37b9c50cabd865124df334aa3597f0" translate="yes" xml:space="preserve">
          <source>Appendix: Date/Time Support</source>
          <target state="translated">Приложение:Дата/время поддержки</target>
        </trans-unit>
        <trans-unit id="a8d8b25f2c37eff5457e8db6ccb6dece99f46eb0" translate="yes" xml:space="preserve">
          <source>Appendix: SQL Conformance</source>
          <target state="translated">Приложение:SQL-компрессия</target>
        </trans-unit>
        <trans-unit id="1f6da0679b0bcee42966e5109a37944191c26ca8" translate="yes" xml:space="preserve">
          <source>Appendixes</source>
          <target state="translated">Appendixes</target>
        </trans-unit>
        <trans-unit id="2fc28e50f7d7e95a87ebbb410bfe469fb51248d4" translate="yes" xml:space="preserve">
          <source>Appends an element to the end of an array (same as the &lt;code&gt;anyarray&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;anyelement&lt;/code&gt; operator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99005fc867cd3e54c80bd91ee175bcce277708d9" translate="yes" xml:space="preserve">
          <source>Applicable Object Types</source>
          <target state="translated">Применимые типы объектов</target>
        </trans-unit>
        <trans-unit id="a63f73a380e6bb14bdd2ad6b10a8f68e5d42a5ad" translate="yes" xml:space="preserve">
          <source>Application Programming Interface</source>
          <target state="translated">Интерфейс прикладного программирования</target>
        </trans-unit>
        <trans-unit id="2f16f8fd5e0553e004d0e86eda56a845aa102673" translate="yes" xml:space="preserve">
          <source>Application name</source>
          <target state="translated">Название приложения</target>
        </trans-unit>
        <trans-unit id="b03ebc2274f172652f6125e87dba0dd896ad4421" translate="yes" xml:space="preserve">
          <source>Application of Multiple Policies</source>
          <target state="translated">Применение нескольких политик</target>
        </trans-unit>
        <trans-unit id="00135b8aa11b060725023cffb44e0b589a9f25a0" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with queries accessing the target page on the standby, whether or not the data to be removed is visible.</source>
          <target state="translated">Применение записи вакуумной уборки из WAL конфликтует с запросами на доступ к целевой странице в режиме ожидания,независимо от того,видны ли удаляемые данные или нет.</target>
        </trans-unit>
        <trans-unit id="3256ed72d4783ec493be93406d6bd97d0d7b90f1" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with standby transactions whose snapshots can still &amp;ldquo;see&amp;rdquo; any of the rows to be removed.</source>
          <target state="translated">Применение записи вакуумной очистки из WAL конфликтует с резервными транзакциями, снимки которых все еще могут &amp;laquo;видеть&amp;raquo; любую из удаляемых строк.</target>
        </trans-unit>
        <trans-unit id="76c74bd071dd73f01696fddbbffc77712a479faf" translate="yes" xml:space="preserve">
          <source>Applications</source>
          <target state="translated">Applications</target>
        </trans-unit>
        <trans-unit id="6b5428213daf1d5aba6d1295a6bbb19c08864fc0" translate="yes" xml:space="preserve">
          <source>Applications that wanted precise values have historically had to set &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; to 3 to obtain them. For maximum compatibility between versions, they should continue to do so.</source>
          <target state="translated">Приложениям, которым нужны точные значения, исторически приходилось устанавливать &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits равным&lt;/a&gt; 3, чтобы получить их. Для максимальной совместимости между версиями они должны продолжать делать это.</target>
        </trans-unit>
        <trans-unit id="ed624d6999cad953cb5b1bedd94e985196972ebd" translate="yes" xml:space="preserve">
          <source>Applications that wish to use backslash as escape should be modified to use escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;), because the default behavior of ordinary strings is now to treat backslash as an ordinary character, per SQL standard. This variable can be enabled to help locate code that needs to be changed.</source>
          <target state="translated">Приложения, которые хотят использовать обратную косую черту в качестве escape-последовательности, должны быть изменены для использования синтаксиса escape-строки ( &lt;code&gt;E'...'&lt;/code&gt; ), потому что поведение обычных строк по умолчанию теперь заключается в обработке обратной косой черты как обычного символа в соответствии со стандартом SQL. Эту переменную можно включить, чтобы помочь найти код, который необходимо изменить.</target>
        </trans-unit>
        <trans-unit id="85980229b9ae48d13b46796fb33f530f87d73b8b" translate="yes" xml:space="preserve">
          <source>Applications using this level must be prepared to retry transactions due to serialization failures.</source>
          <target state="translated">Приложения,использующие этот уровень,должны быть готовы к повторным попыткам транзакций из-за сбоев сериализации.</target>
        </trans-unit>
        <trans-unit id="55278f2bfbaabfad19c2fee75ec3133e8897d48a" translate="yes" xml:space="preserve">
          <source>Apply modifications to the page images obtained in the previous step.</source>
          <target state="translated">Применяйте изменения к изображениям страниц,полученным на предыдущем этапе.</target>
        </trans-unit>
        <trans-unit id="068d74cbbe7303d0ad643d8aa0d60cbff0956278" translate="yes" xml:space="preserve">
          <source>Apply the WAL from the source cluster, starting from the checkpoint created at failover. (Strictly speaking, pg_rewind doesn't apply the WAL, it just creates a backup label file that makes PostgreSQL start by replaying all WAL from that checkpoint forward.)</source>
          <target state="translated">Применить WAL из исходного кластера,начиная с контрольной точки,созданной при обходе отказа.(Строго говоря,pg_rewind не применяет WAL,он просто создает файл метки резервного копирования,который заставляет PostgreSQL запускаться,проигрывая всю WAL с этой контрольной точки вперед).</target>
        </trans-unit>
        <trans-unit id="e486b3d6c0bcfe71e975768cf7354a58fa17fa9a" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data for moving-aggregate mode, or zero to use a default estimate</source>
          <target state="translated">Ориентировочный средний размер (в байтах)данных о состоянии перехода для режима перемещения-агрегистрации,или ноль для использования оценки по умолчанию</target>
        </trans-unit>
        <trans-unit id="caafece427e1163ffa963b4dffa3cc2b00260a07" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data, or zero to use a default estimate</source>
          <target state="translated">Приблизительный средний размер (в байтах)данных о состоянии перехода,или ноль для использования оценки по умолчанию</target>
        </trans-unit>
        <trans-unit id="753bf6e471b3480498401484488505d0888a0767" translate="yes" xml:space="preserve">
          <source>Approximate floating-point number converted from a JSON number or string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d737059a7023272b67d00f7bdeb9dfcc94048eda" translate="yes" xml:space="preserve">
          <source>Approximate floating-point number converted from an SQL/JSON number or a string</source>
          <target state="translated">Приблизительное число с плавающей точкой,преобразованное из SQL/JSON числа или строки</target>
        </trans-unit>
        <trans-unit id="c0b0f0e736e61c866d8d2ac574b894e925e89613" translate="yes" xml:space="preserve">
          <source>Approximate value of &amp;pi;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="befde54a108cb9dc6ad6e0ebd28720531a6855e6" translate="yes" xml:space="preserve">
          <source>Apr</source>
          <target state="translated">Apr</target>
        </trans-unit>
        <trans-unit id="a0393902db1f516ef5f95f6830938558a88fb23c" translate="yes" xml:space="preserve">
          <source>April</source>
          <target state="translated">April</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="2e6a8c2f54eea95c918815af873f318c8b75d1ee" translate="yes" xml:space="preserve">
          <source>Arbitrary text that serves as the description of this object</source>
          <target state="translated">Произвольный текст,который служит описанием этого объекта</target>
        </trans-unit>
        <trans-unit id="a4183b8dc44cf7f7f1da3bacb0f01f6cc6331a8b" translate="yes" xml:space="preserve">
          <source>Archaic term for a &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL record&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="c2745399d3dc1caef67349072200fb056fc4129e" translate="yes" xml:space="preserve">
          <source>Architecture: Initial Snapshot</source>
          <target state="translated">Архитектура:Исходный снимок</target>
        </trans-unit>
        <trans-unit id="a57a286a92ae143de1dc965b902d9ecc2dfd66af" translate="yes" xml:space="preserve">
          <source>Are &lt;code&gt;aclitem&lt;/code&gt;s equal? (Notice that type &lt;code&gt;aclitem&lt;/code&gt; lacks the usual set of comparison operators; it has only equality. In turn, &lt;code&gt;aclitem&lt;/code&gt; arrays can only be compared for equality.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a9118149c6042fe6daa560647e16f79a2d3d97" translate="yes" xml:space="preserve">
          <source>Are horizontally aligned?</source>
          <target state="translated">Выровнены по горизонтали?</target>
        </trans-unit>
        <trans-unit id="0277a553173b27be90f022d132a83d4b3aaf7ebc" translate="yes" xml:space="preserve">
          <source>Are lines parallel?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae62863d19a1f09ae83d96496ecb5be1da1e9570" translate="yes" xml:space="preserve">
          <source>Are lines perpendicular?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8897c493ba700783f2c64a4d0f20f14b01d7b1e3" translate="yes" xml:space="preserve">
          <source>Are parallel?</source>
          <target state="translated">Параллельны?</target>
        </trans-unit>
        <trans-unit id="b0f274d71a2fb179ee895325d1f8e8eba6d7eaf4" translate="yes" xml:space="preserve">
          <source>Are points horizontally aligned (that is, have same y coordinate)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd10598c5b40d1cb91d9f056ebf89eb9d7aa121" translate="yes" xml:space="preserve">
          <source>Are points vertically aligned (that is, have same x coordinate)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cba229ff1c565c58441b7f5908ac5643aeb85b7" translate="yes" xml:space="preserve">
          <source>Are the left JSON path/value entries contained at the top level within the right JSON value?</source>
          <target state="translated">Содержатся ли левые JSON-пути/значения на верхнем уровне в пределах правого JSON-значения?</target>
        </trans-unit>
        <trans-unit id="7f5f796f9f81b0556b03d7a49d7711d325d01584" translate="yes" xml:space="preserve">
          <source>Are the ranges adjacent?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ac96b9bb2b90c235c16c3c150acca2ceb1786a" translate="yes" xml:space="preserve">
          <source>Are the two &lt;code&gt;seg&lt;/code&gt;s equal?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdbf4786edf9f977d2039f0d91270c27aa5a8043" translate="yes" xml:space="preserve">
          <source>Are these objects the same? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea55540eda7f3ae150bdf50ff88e357b0470bd4" translate="yes" xml:space="preserve">
          <source>Are vertically aligned?</source>
          <target state="translated">Выровнены по вертикали?</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">Тип аргумента</target>
        </trans-unit>
        <trans-unit id="227b299c7388311800207bda7f4dca4cbfe39510" translate="yes" xml:space="preserve">
          <source>Argument Type(s)</source>
          <target state="translated">Тип(ы)аргумента(ов)</target>
        </trans-unit>
        <trans-unit id="a051df2e8379a7a94517621abf96e2d1c250d0c1" translate="yes" xml:space="preserve">
          <source>Argument strings to pass to trigger, each NULL-terminated</source>
          <target state="translated">Строки аргументов,которые нужно передать,чтобы запустить,каждый NULL-терминированный</target>
        </trans-unit>
        <trans-unit id="3106eca9fcc5b17fbc0ab862b2b3e2e5d8ec1882" translate="yes" xml:space="preserve">
          <source>Arranges to save future query results to the file &lt;code&gt;filename&lt;/code&gt; or pipe future results to the shell command &lt;code&gt;command&lt;/code&gt;. If no argument is specified, the query output is reset to the standard output.</source>
          <target state="translated">Организует сохранить результаты в будущем запроса на файл &lt;code&gt;filename&lt;/code&gt; или будущей трубы приводит к командной оболочки &lt;code&gt;command&lt;/code&gt; . Если аргумент не указан, вывод запроса сбрасывается на стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="7a061ed91f80bf08d4b0e706de1a73a36b812215" translate="yes" xml:space="preserve">
          <source>Array Comparisons</source>
          <target state="translated">Сравнение массивов</target>
        </trans-unit>
        <trans-unit id="2cce75772b9783560b7ecdf1a652525e088ff999" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ALL (array)</source>
          <target state="translated">Сравнение массивов:ВСЕ (массив)</target>
        </trans-unit>
        <trans-unit id="ebbce493c47b875446149a16fbeabd59af95b506" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ANY/SOME (array)</source>
          <target state="translated">Сравнение массивов:ЛЮБОЙ/ЛЮБОЙ (массив)</target>
        </trans-unit>
        <trans-unit id="266d7d8ad9ef21fb1cf43acafe88df1627794e31" translate="yes" xml:space="preserve">
          <source>Array Comparisons: IN</source>
          <target state="translated">Сравнение массивов:IN</target>
        </trans-unit>
        <trans-unit id="cb5525261d1827b03403d3e1f7d54e339ee3bdc7" translate="yes" xml:space="preserve">
          <source>Array Comparisons: NOT IN</source>
          <target state="translated">Сравнение массивов:НЕ В</target>
        </trans-unit>
        <trans-unit id="378bd5c012fe9a2d09b80c0502903a9f1a4e46ef" translate="yes" xml:space="preserve">
          <source>Array Functions and Operators</source>
          <target state="translated">Функции массива и операторы</target>
        </trans-unit>
        <trans-unit id="1847f280fe6a7cfd6c208240da7d0ab7f1c91ffb" translate="yes" xml:space="preserve">
          <source>Array Types</source>
          <target state="translated">Типы массивов</target>
        </trans-unit>
        <trans-unit id="989d38553686cf9420b0efeacfb98e0cb0491104" translate="yes" xml:space="preserve">
          <source>Array element accessor. &lt;code&gt;subscript&lt;/code&gt; can be given in two forms: &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;start_index to end_index&lt;/code&gt;. The first form returns a single array element by its index. The second form returns an array slice by the range of indexes, including the elements that correspond to the provided &lt;code&gt;start_index&lt;/code&gt; and &lt;code&gt;end_index&lt;/code&gt;.</source>
          <target state="translated">Аксессор элемента массива. &lt;code&gt;subscript&lt;/code&gt; может быть задан в двух формах: &lt;code&gt;index&lt;/code&gt; или от &lt;code&gt;start_index to end_index&lt;/code&gt; . Первая форма возвращает единственный элемент массива по его индексу. Вторая форма возвращает срез массива по диапазону индексов, включая элементы, которые соответствуют предоставленным &lt;code&gt;start_index&lt;/code&gt; и &lt;code&gt;end_index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88048034955012a6a9f12b6c23a529e19a83c1b1" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;WHERE&lt;/code&gt;-clause filter conditions for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">Массив условий фильтрации &lt;code&gt;WHERE&lt;/code&gt; для таблиц конфигурации расширения или &lt;code&gt;NULL&lt;/code&gt; , если нет</target>
        </trans-unit>
        <trans-unit id="01ffa4580cea8a6c482fb4eea9629be04c79e61e" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;regclass&lt;/code&gt; OIDs for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">Массив OID &lt;code&gt;regclass&lt;/code&gt; для таблицы (таблиц) конфигурации расширения или &lt;code&gt;NULL&lt;/code&gt; , если нет</target>
        </trans-unit>
        <trans-unit id="24c2e81a77c22cd6c4b27ed6a767d8a3da693d5f" translate="yes" xml:space="preserve">
          <source>Array of item identifiers pointing to the actual items. Each entry is an (offset,length) pair. 4 bytes per item.</source>
          <target state="translated">Массив идентификаторов элементов,указывающих на фактические элементы.Каждая запись является парой (смещение,длина).4 байта на элемент.</target>
        </trans-unit>
        <trans-unit id="be15b795f8a08c896c323efe48ed797caf42d6d4" translate="yes" xml:space="preserve">
          <source>Array of subscribed publication names. These reference the publications on the publisher server. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">Массив подписанных имен публикаций. Они ссылаются на публикации на сервере издателя. Подробнее о публикациях см. &lt;a href=&quot;logical-replication-publication&quot;&gt;Раздел 30.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">Типы массивов</target>
        </trans-unit>
        <trans-unit id="31177effc11eb7035c25f786c3b9f262ea8dee25" translate="yes" xml:space="preserve">
          <source>Array: &amp;amp;&amp;amp;</source>
          <target state="translated">Массив: &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="24e29718edd609d75b45a77aa875138df131bbd7" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;</source>
          <target state="translated">Массив:&amp;gt;</target>
        </trans-unit>
        <trans-unit id="811842a370e6ca7314ad3ee641887ae43eed6200" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;=</source>
          <target state="translated">Массив:&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="736b98ce8f814e8462d7673c06a73e5d2921d61d" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;</source>
          <target state="translated">Массив: &amp;lt;</target>
        </trans-unit>
        <trans-unit id="72683d381cd2860b3b1a8eab0a2c5eedfb795924" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;&amp;gt;</source>
          <target state="translated">Массив: &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="397f0e2a9b9f910336a8ea8c6c32ba6704d652eb" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;=</source>
          <target state="translated">Массив: &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="5df64d9374ce5e9d00462533f6beea8afb43679c" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;@</source>
          <target state="translated">Массив: &amp;lt;@</target>
        </trans-unit>
        <trans-unit id="3fe38b2f63794530437e3485d0c38785ad75e487" translate="yes" xml:space="preserve">
          <source>Array: 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d17f1eb33a5388e6bfb317a245a8c37e5b460a" translate="yes" xml:space="preserve">
          <source>Array: =</source>
          <target state="translated">Массив:=</target>
        </trans-unit>
        <trans-unit id="db0f2c477d3b5e5a1ea32beab72408f0ff3b2f71" translate="yes" xml:space="preserve">
          <source>Array: @&amp;gt;</source>
          <target state="translated">Массив: @&amp;gt;</target>
        </trans-unit>
        <trans-unit id="150a65359d97d4ee8b8c087554e227e4e463443a" translate="yes" xml:space="preserve">
          <source>Array: ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dcd3d1ce93d0ca2cb3e60332e931604f93cc026" translate="yes" xml:space="preserve">
          <source>Array: ARRAY &amp;amp;&amp;amp; ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b37c182a6bd42ba7b5eb841ce25916a3a3c807" translate="yes" xml:space="preserve">
          <source>Array: ARRAY &amp;lt;@ ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d1bb5bc6001f266e8878cdac676402e49a8545" translate="yes" xml:space="preserve">
          <source>Array: ARRAY @&amp;gt; ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c09f59eadf2bb3b4328b3f453d0a6c85ef136cb" translate="yes" xml:space="preserve">
          <source>Array: IS NOT DISTINCT FROM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc80d05bcc1cb0f4e5e941af2a29b9db0657f22" translate="yes" xml:space="preserve">
          <source>Array: NULL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bbda7ebf850fa729d9606dbdfd7d1f3599ec47" translate="yes" xml:space="preserve">
          <source>Array: array_append</source>
          <target state="translated">Массив:array_append</target>
        </trans-unit>
        <trans-unit id="af82c1377e93f02d0993b9aadeb7d8e17521a1bc" translate="yes" xml:space="preserve">
          <source>Array: array_cat</source>
          <target state="translated">Массив:array_cat</target>
        </trans-unit>
        <trans-unit id="243f29a4a2e10d2646f7903c1f4a2d39c2a3d0a4" translate="yes" xml:space="preserve">
          <source>Array: array_dims</source>
          <target state="translated">Массив:array_dims</target>
        </trans-unit>
        <trans-unit id="5beacc0ab51ffbcd3c4683bef89fb252cd5ecd4f" translate="yes" xml:space="preserve">
          <source>Array: array_fill</source>
          <target state="translated">Массив:array_fill</target>
        </trans-unit>
        <trans-unit id="0a700d1340312f7d432d241fb96c7d69e0d7cbc8" translate="yes" xml:space="preserve">
          <source>Array: array_length</source>
          <target state="translated">Массив:array_length</target>
        </trans-unit>
        <trans-unit id="e39f07efeb19c70308a1b05104d42f13e6750589" translate="yes" xml:space="preserve">
          <source>Array: array_lower</source>
          <target state="translated">Массив:array_lower</target>
        </trans-unit>
        <trans-unit id="55bec9b1ab2dd7b5615b888955aa1685d7d9176c" translate="yes" xml:space="preserve">
          <source>Array: array_ndims</source>
          <target state="translated">Массив:array_ndims</target>
        </trans-unit>
        <trans-unit id="6abfbc8e90ab3825fd22a987883a8130d8647c22" translate="yes" xml:space="preserve">
          <source>Array: array_position</source>
          <target state="translated">Массив:array_position</target>
        </trans-unit>
        <trans-unit id="dc8f46967ae5b46ce3023fe830845635cbddc3a2" translate="yes" xml:space="preserve">
          <source>Array: array_positions</source>
          <target state="translated">Массив:массив_позиции</target>
        </trans-unit>
        <trans-unit id="170bb418b8b592fa19a657e9b3372281a737a509" translate="yes" xml:space="preserve">
          <source>Array: array_prepend</source>
          <target state="translated">Массив:array_prepend</target>
        </trans-unit>
        <trans-unit id="23c081b8640d7683a9a9eb917682404db2a9d9cf" translate="yes" xml:space="preserve">
          <source>Array: array_remove</source>
          <target state="translated">Массив:array_remove</target>
        </trans-unit>
        <trans-unit id="0bb70da04daab39f1a179be9e60eceee76a3242d" translate="yes" xml:space="preserve">
          <source>Array: array_replace</source>
          <target state="translated">Массив:array_replace</target>
        </trans-unit>
        <trans-unit id="d1576bf750554857f928eff64376711410524f13" translate="yes" xml:space="preserve">
          <source>Array: array_to_string</source>
          <target state="translated">Массив:массив_к_строке</target>
        </trans-unit>
        <trans-unit id="f1d1655c390920a19930233b2ba0cbcc608406ea" translate="yes" xml:space="preserve">
          <source>Array: array_upper</source>
          <target state="translated">Массив:array_upper</target>
        </trans-unit>
        <trans-unit id="f07fdded6b4337ac290721bed8d559d25ce497d7" translate="yes" xml:space="preserve">
          <source>Array: cardinality</source>
          <target state="translated">Массив:кардинальность</target>
        </trans-unit>
        <trans-unit id="4d56c61f6754af386d1ad55522ee718a6d173e5b" translate="yes" xml:space="preserve">
          <source>Array: select * from unnest as x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45177789238b533ec64ce75c721f78be3e3490d" translate="yes" xml:space="preserve">
          <source>Array: string_to_array</source>
          <target state="translated">Массив:string_to_array</target>
        </trans-unit>
        <trans-unit id="1b1aca770dcf002c23a04ca801aee9819ce75321" translate="yes" xml:space="preserve">
          <source>Array: unnest</source>
          <target state="translated">Массив:противоестественно</target>
        </trans-unit>
        <trans-unit id="8cbda94f98fa6831a0fab631dfd36cfb855d6147" translate="yes" xml:space="preserve">
          <source>Array: ||</source>
          <target state="translated">Массив:||</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="7ff0d6e651880818d49ef5a4d284aa7441e9760b" translate="yes" xml:space="preserve">
          <source>Arrays are not sets; searching for specific array elements can be a sign of database misdesign. Consider using a separate table with a row for each item that would be an array element. This will be easier to search, and is likely to scale better for a large number of elements.</source>
          <target state="translated">Массивы не являются наборами;поиск определенных элементов массива может быть признаком неправильного проектирования базы данных.Рассмотрим возможность использования отдельной таблицы со строкой для каждого элемента,который будет элементом массива.Это облегчит поиск и,скорее всего,позволит лучше масштабировать большое количество элементов.</target>
        </trans-unit>
        <trans-unit id="86a798d810f86ee1f57761b0f4f378302a450ab0" translate="yes" xml:space="preserve">
          <source>As PostgreSQL stands, this doesn't occur. Large objects are treated as objects in their own right; a table entry can reference a large object by OID, but there can be multiple table entries referencing the same large object OID, so the system doesn't delete the large object just because you change or remove one such entry.</source>
          <target state="translated">На языке PostgreSQL этого не происходит.Большие объекты рассматриваются как объекты сами по себе;запись в таблице может ссылаться на большой объект по OID,но может быть несколько записей в таблице,ссылающихся на один и тот же OID большого объекта,поэтому система не удаляет большой объект только потому,что вы изменяете или удаляете одну из таких записей.</target>
        </trans-unit>
        <trans-unit id="96ee90014e2be91ae6a2c0ff19bfbdac86380915" translate="yes" xml:space="preserve">
          <source>As a consequence, it is unwise to use functions with side effects as part of complex expressions. It is particularly dangerous to rely on side effects or evaluation order in &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses, since those clauses are extensively reprocessed as part of developing an execution plan. Boolean expressions (&lt;code&gt;AND&lt;/code&gt;/&lt;code&gt;OR&lt;/code&gt;/&lt;code&gt;NOT&lt;/code&gt; combinations) in those clauses can be reorganized in any manner allowed by the laws of Boolean algebra.</source>
          <target state="translated">Как следствие, неразумно использовать функции с побочными эффектами как часть сложных выражений. Особенно опасно полагаться на побочные эффекты или порядок оценки в &lt;code&gt;WHERE&lt;/code&gt; и &lt;code&gt;HAVING&lt;/code&gt; , поскольку эти предложения интенсивно обрабатываются как часть разработки плана выполнения. Булевы выражения ( комбинации &lt;code&gt;AND&lt;/code&gt; / &lt;code&gt;OR&lt;/code&gt; / &lt;code&gt;NOT&lt;/code&gt; ) в этих предложениях могут быть реорганизованы любым способом, разрешенным законами булевой алгебры.</target>
        </trans-unit>
        <trans-unit id="c00aa4eef1a46e7541eb69499cd40ccfaa63754a" translate="yes" xml:space="preserve">
          <source>As a convenience, there is a program you can execute from the shell to create new databases, &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">Для удобства существует программа &lt;code&gt;createdb&lt;/code&gt; . , Которую можно запустить из оболочки для создания новых баз данных .</target>
        </trans-unit>
        <trans-unit id="d25ac520ed3e5e990af0f244faf971c940fd4e71" translate="yes" xml:space="preserve">
          <source>As a general rule, if you get spurious parser errors for commands that contain any of the listed key words as an identifier you should try to quote the identifier to see if the problem goes away.</source>
          <target state="translated">Как правило,если Вы получаете поддельные ошибки синтаксического анализатора для команд,которые содержат любое из перечисленных ключевых слов в качестве идентификатора,то Вы должны попробовать процитировать идентификатор,чтобы посмотреть,не исчезнет ли проблема.</target>
        </trans-unit>
        <trans-unit id="95a9f6ed53fa85650318ffc030c2493caa298423" translate="yes" xml:space="preserve">
          <source>As a partial guard against this type of error, variable-length or nullable fields should not be made directly visible to the C compiler. This is accomplished by wrapping them in &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (where &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; is a symbol that is never defined). This prevents C code from carelessly trying to access fields that might not be there or might be at some other offset. As an independent guard against creating incorrect rows, we require all columns that should be non-nullable to be marked so in &lt;code&gt;pg_attribute&lt;/code&gt;. The bootstrap code will automatically mark catalog columns as &lt;code&gt;NOT NULL&lt;/code&gt; if they are fixed-width and are not preceded by any nullable column. Where this rule is inadequate, you can force correct marking by using &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; and &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; annotations as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a80a71669f88eae465ab66545f1b21816ccdfcd" translate="yes" xml:space="preserve">
          <source>As a partial guard against this type of error, variable-length or nullable fields should not be made directly visible to the C compiler. This is accomplished by wrapping them in &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (where &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; is a symbol that is never defined). This prevents C code from carelessly trying to access fields that might not be there or might be at some other offset. As an independent guard against creating incorrect rows, we require all columns that should be non-nullable to be marked so in &lt;code&gt;pg_attribute&lt;/code&gt;. The bootstrap code will automatically mark catalog columns as &lt;code&gt;NOT NULL&lt;/code&gt; if they are fixed-width and are not preceded by any nullable column. Where this rule is inadequate, you can force correct marking by using &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; and &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; annotations as needed. But note that &lt;code&gt;NOT NULL&lt;/code&gt; constraints are only enforced in the executor, not against tuples that are generated by random C code, so care is still needed when manually creating or updating catalog rows.</source>
          <target state="translated">В качестве частичной защиты от этого типа ошибок поля переменной длины или значения, допускающие значение NULL, не следует делать непосредственно видимыми для компилятора C. Это достигается &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; их в #ifdef CATALOG_VARLEN ... &lt;code&gt;#endif&lt;/code&gt; (где &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; - это символ, который никогда не определяется). Это предотвращает небрежную попытку кода C получить доступ к полям, которые могут отсутствовать или иметь другое смещение. В качестве независимой защиты от создания неправильных строк мы требуем, чтобы все столбцы, которые не должны допускать значения NULL, были помечены таким образом в &lt;code&gt;pg_attribute&lt;/code&gt; . Код начальной загрузки автоматически помечает столбцы каталога как &lt;code&gt;NOT NULL&lt;/code&gt; .если они имеют фиксированную ширину и перед ними нет столбцов, допускающих значение NULL. Если это правило неадекватно, вы можете принудительно &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; правильную маркировку, используя при &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; аннотации BKI_FORCE_NOT_NULL и BKI_FORCE_NULL . Но обратите внимание, что ограничения &lt;code&gt;NOT NULL&lt;/code&gt; применяются только в исполнителе, а не в отношении кортежей, которые генерируются случайным кодом C, поэтому при создании или обновлении строк каталога вручную по-прежнему требуется осторожность.</target>
        </trans-unit>
        <trans-unit id="47b0b4c39b5ede77f7f7daa11745dc4255dd8757" translate="yes" xml:space="preserve">
          <source>As a partitioned table does not have any data directly, attempts to use &lt;code&gt;TRUNCATE&lt;/code&gt;&lt;code&gt;ONLY&lt;/code&gt; on a partitioned table will always return an error.</source>
          <target state="translated">Поскольку в многораздельной таблице нет данных напрямую, попытки использовать &lt;code&gt;TRUNCATE&lt;/code&gt; &lt;code&gt;ONLY&lt;/code&gt; для многораздельной таблицы всегда будут возвращать ошибку.</target>
        </trans-unit>
        <trans-unit id="ff2aae32fe6bdd83d73023e8256b2cd3508deffa" translate="yes" xml:space="preserve">
          <source>As a result, you cannot create additional indexes that exist solely on the standby, nor statistics that exist solely on the standby. If these administration commands are needed, they should be executed on the primary, and eventually those changes will propagate to the standby.</source>
          <target state="translated">В результате вы не можете создавать дополнительные индексы,которые существуют только в режиме ожидания,а также статистику,которая существует только в режиме ожидания.Если эти команды администрирования необходимы,то они должны выполняться на первичном уровне,и в конечном итоге эти изменения будут распространяться на резервный.</target>
        </trans-unit>
        <trans-unit id="94f064aeef44b2237a7b84960c6af3e282dc0f3d" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, &lt;code&gt;queryid&lt;/code&gt; values can be assumed to be stable and comparable only so long as the underlying server version and catalog metadata details stay exactly the same. Two servers participating in replication based on physical WAL replay can be expected to have identical &lt;code&gt;queryid&lt;/code&gt; values for the same query. However, logical replication schemes do not promise to keep replicas identical in all relevant details, so &lt;code&gt;queryid&lt;/code&gt; will not be a useful identifier for accumulating costs across a set of logical replicas. If in doubt, direct testing is recommended.</source>
          <target state="translated">Как показывает &lt;code&gt;queryid&lt;/code&gt; значения queryid можно считать стабильными и сопоставимыми только до тех пор, пока базовая версия сервера и детали метаданных каталога остаются неизменными. Можно ожидать, что два сервера, участвующие в репликации на основе физического воспроизведения WAL, будут иметь одинаковые значения &lt;code&gt;queryid&lt;/code&gt; для одного и того же запроса. Однако схемы логической репликации не обещают сохранять реплики идентичными во всех соответствующих деталях, поэтому &lt;code&gt;queryid&lt;/code&gt; не будет полезным идентификатором для накопления затрат по набору логических реплик. В случае сомнений рекомендуется прямое тестирование.</target>
        </trans-unit>
        <trans-unit id="84cdd8b719c9d8f34c7f1d4c72b4f9ce0fe4768b" translate="yes" xml:space="preserve">
          <source>As a safety device, an aggressive vacuum scan will occur for any table whose multixact-age is greater than &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;. Aggressive vacuum scans will also occur progressively for all tables, starting with those that have the oldest multixact-age, if the amount of used member storage space exceeds the amount 50% of the addressable storage space. Both of these kinds of aggressive scans will occur even if autovacuum is nominally disabled.</source>
          <target state="translated">В качестве защитного устройства будет выполняться агрессивное вакуумное сканирование для любой таблицы, у которой multixact-age больше, чем &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; . Агрессивное вакуумное сканирование также будет происходить постепенно для всех таблиц, начиная с тех, которые имеют самый старый мультиплексный возраст, если объем используемого пространства хранения элементов превышает размер 50% адресуемого пространства хранения. Оба этих вида агрессивного сканирования будут выполняться, даже если автовакуум номинально отключен.</target>
        </trans-unit>
        <trans-unit id="2b18e01bd003b97bb977c2d73b7cfc8923da784c" translate="yes" xml:space="preserve">
          <source>As a sanity check, &lt;code&gt;seg&lt;/code&gt; rejects intervals with the lower bound greater than the upper, for example &lt;code&gt;5 .. 2&lt;/code&gt;.</source>
          <target state="translated">В качестве проверки &lt;code&gt;seg&lt;/code&gt; отклоняет интервалы, нижняя граница которых больше верхней, например &lt;code&gt;5 .. 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e65f5f3343ba0b45af614f4022a156a7c42809b5" translate="yes" xml:space="preserve">
          <source>As a simple example, here is how to create a policy on the &lt;code&gt;account&lt;/code&gt; relation to allow only members of the &lt;code&gt;managers&lt;/code&gt; role to access rows, and only rows of their accounts:</source>
          <target state="translated">В качестве простого примера, вот как создать политику в отношении &lt;code&gt;account&lt;/code&gt; чтобы разрешить доступ к строкам только членам роли &lt;code&gt;managers&lt;/code&gt; и только строкам их учетных записей:</target>
        </trans-unit>
        <trans-unit id="05f66f343edd96e743819d53bcce1284f5be3d29" translate="yes" xml:space="preserve">
          <source>As a special exception to the general principle that the structures must match, an array may contain a primitive value:</source>
          <target state="translated">В качестве особого исключения из общего принципа,что структуры должны совпадать,массив может содержать примитивное значение:</target>
        </trans-unit>
        <trans-unit id="4dafe6722800c895e7fb824e24cdc22785e38231" translate="yes" xml:space="preserve">
          <source>As a workaround to allow PostgreSQL to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses under a non-C locale, several custom operator classes exist. These allow the creation of an index that performs a strict character-by-character comparison, ignoring locale comparison rules. Refer to &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; for more information. Another approach is to create indexes using the &lt;code&gt;C&lt;/code&gt; collation, as discussed in &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.</source>
          <target state="translated">В качестве обходного пути, позволяющего PostgreSQL использовать индексы с предложениями &lt;code&gt;LIKE&lt;/code&gt; в локали, отличной от C, существует несколько пользовательских классов операторов. Это позволяет создать индекс, который выполняет строгое посимвольное сравнение, игнорируя правила сравнения языковых стандартов. Обратитесь к &lt;a href=&quot;indexes-opclass&quot;&gt;Разделу 11.10&lt;/a&gt; для получения дополнительной информации. Другой подход - создание индексов с использованием параметров сортировки &lt;code&gt;C&lt;/code&gt; , как описано в &lt;a href=&quot;collation&quot;&gt;Разделе 23.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38727bf2878bdfdd88e444d27be405dc29a205b6" translate="yes" xml:space="preserve">
          <source>As above, but import only the two tables &lt;code&gt;actors&lt;/code&gt; and &lt;code&gt;directors&lt;/code&gt; (if they exist):</source>
          <target state="translated">То же, что и выше, но импортируйте только две таблицы - &lt;code&gt;actors&lt;/code&gt; и &lt;code&gt;directors&lt;/code&gt; (если они существуют):</target>
        </trans-unit>
        <trans-unit id="fc0ab2ce564629da1cade53f45b45700cfa6ba3f" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-D&lt;/code&gt; option, you can set the environment variable &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">В качестве альтернативы опции &lt;code&gt;-D&lt;/code&gt; вы можете установить переменную окружения &lt;code&gt;PGDATA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="431e9cdc01712eabff181abecb6b83e3af47f9a9" translate="yes" xml:space="preserve">
          <source>As an alternative, it is sometimes more convenient to create the new table outside the partition structure, and make it a proper partition later. This allows the data to be loaded, checked, and transformed prior to it appearing in the partitioned table:</source>
          <target state="translated">В качестве альтернативы иногда удобнее создать новую таблицу вне структуры простенков,а позже сделать ее правильным простенком.Это позволяет загружать,проверять и преобразовывать данные перед их появлением в таблице простенков:</target>
        </trans-unit>
        <trans-unit id="dbbe816df8235daf5a726cf6177c485cd14e8ef4" translate="yes" xml:space="preserve">
          <source>As an example of using the output produced by these functions, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Example 9.1&lt;/a&gt; shows an XSLT stylesheet that converts the output of &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e3b2ce01a4421ab4c72defc488724bdaa1c1a4" translate="yes" xml:space="preserve">
          <source>As an example of using the output produced by these functions, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Figure 9.1&lt;/a&gt; shows an XSLT stylesheet that converts the output of &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</source>
          <target state="translated">В качестве примера использования вывода, созданного этими функциями, на &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;рисунке 9.1&lt;/a&gt; показана &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; стилей XSLT, которая преобразует вывод table_to_xml_and_xmlschema в документ HTML, содержащий табличное представление данных таблицы. Аналогичным образом результаты этих функций могут быть преобразованы в другие форматы на основе XML.</target>
        </trans-unit>
        <trans-unit id="0d1f3783f0bee859f0f7fd07d8117b96c39c5dbf" translate="yes" xml:space="preserve">
          <source>As an example we will create a configuration &lt;code&gt;pg&lt;/code&gt;, starting by duplicating the built-in &lt;code&gt;english&lt;/code&gt; configuration:</source>
          <target state="translated">В качестве примера мы создадим конфигурацию &lt;code&gt;pg&lt;/code&gt; , начав с дублирования встроенной &lt;code&gt;english&lt;/code&gt; конфигурации:</target>
        </trans-unit>
        <trans-unit id="faf1ed368ea36c292232738719a6fc50ce56d002" translate="yes" xml:space="preserve">
          <source>As an example, &lt;code&gt;CET-1CEST,M3.5.0,M10.5.0/3&lt;/code&gt; describes current (as of 2020) timekeeping practice in Paris. This specification says that standard time has the abbreviation &lt;code&gt;CET&lt;/code&gt; and is one hour ahead (east) of UTC; daylight savings time has the abbreviation &lt;code&gt;CEST&lt;/code&gt; and is implicitly two hours ahead of UTC; daylight savings time begins on the last Sunday in March at 2AM CET and ends on the last Sunday in October at 3AM CEST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75dd3c213ab262bc0285b838849480821b38de49" translate="yes" xml:space="preserve">
          <source>As an example, consider a table &lt;code&gt;mytab&lt;/code&gt;, initially containing:</source>
          <target state="translated">В качестве примера рассмотрим таблицу &lt;code&gt;mytab&lt;/code&gt; , изначально содержащую:</target>
        </trans-unit>
        <trans-unit id="90c5a9e56ec693f6e6129ec5a5d9bccec6f61c69" translate="yes" xml:space="preserve">
          <source>As an example, if an &lt;code&gt;UPDATE&lt;/code&gt; is issued, then the &lt;code&gt;ALL&lt;/code&gt; policy will be applicable both to what the &lt;code&gt;UPDATE&lt;/code&gt; will be able to select as rows to be updated (applying the &lt;code&gt;USING&lt;/code&gt; expression), and to the resulting updated rows, to check if they are permitted to be added to the table (applying the &lt;code&gt;WITH CHECK&lt;/code&gt; expression, if defined, and the &lt;code&gt;USING&lt;/code&gt; expression otherwise). If an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command attempts to add rows to the table that do not pass the &lt;code&gt;ALL&lt;/code&gt; policy's &lt;code&gt;WITH CHECK&lt;/code&gt; expression, the entire command will be aborted.</source>
          <target state="translated">Например, если выдается &lt;code&gt;UPDATE&lt;/code&gt; , то политика &lt;code&gt;ALL&lt;/code&gt; будет применяться как к тому, что &lt;code&gt;UPDATE&lt;/code&gt; сможет выбрать в качестве обновляемых строк (с применением выражения &lt;code&gt;USING&lt;/code&gt; ), так и к полученным обновленным строкам, чтобы проверить, разрешено добавлять в таблицу (с применением выражения &lt;code&gt;WITH CHECK&lt;/code&gt; , если оно определено, и выражения &lt;code&gt;USING&lt;/code&gt; в противном случае). Если команда &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;UPDATE&lt;/code&gt; пытается добавить в таблицу строки, которые не передают выражение &lt;code&gt;WITH CHECK&lt;/code&gt; политики &lt;code&gt;ALL&lt;/code&gt; , вся команда будет прервана.</target>
        </trans-unit>
        <trans-unit id="939804fcee1e20d77d25bd0bcffade6b732e6187" translate="yes" xml:space="preserve">
          <source>As an example, suppose that user &lt;code&gt;miriam&lt;/code&gt; creates table &lt;code&gt;mytable&lt;/code&gt; and does:</source>
          <target state="translated">В качестве примера предположим, что пользователь &lt;code&gt;miriam&lt;/code&gt; создает таблицу &lt;code&gt;mytable&lt;/code&gt; и выполняет:</target>
        </trans-unit>
        <trans-unit id="7dea5d7bb31aa71940b0966bc7e8fd7ee8f021dd" translate="yes" xml:space="preserve">
          <source>As an example, the full definition of the built-in TPC-B-like transaction is:</source>
          <target state="translated">В качестве примера можно привести полное определение встроенной TPC-B-подобной транзакции:</target>
        </trans-unit>
        <trans-unit id="cfc78f7c719c6f7419eadd4a007ca5004840837d" translate="yes" xml:space="preserve">
          <source>As an example, we can find the highest low-temperature reading anywhere with:</source>
          <target state="translated">В качестве примера,мы можем найти самые высокие показания при низких температурах в любом месте:</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">В качестве примера:</target>
        </trans-unit>
        <trans-unit id="b50a75f7dfe3aa7965ef5d4e176cb3485c343ba0" translate="yes" xml:space="preserve">
          <source>As an extension to the SQL standard, PostgreSQL allows there to be just one escape-double-quote separator, in which case the third regular expression is taken as empty; or no separators, in which case the first and third regular expressions are taken as empty.</source>
          <target state="translated">В качестве расширения к стандарту SQL,PostgreSQL позволяет использовать только один разделитель escape-double-quote,в этом случае третье регулярное выражение будет восприниматься как пустое;или не использовать разделители,в этом случае первое и третье регулярные выражения будут восприниматься как пустые.</target>
        </trans-unit>
        <trans-unit id="fa9c14e462aa9732a24d51e00bd5d77bf7a81cc2" translate="yes" xml:space="preserve">
          <source>As another example, if one often does queries like:</source>
          <target state="translated">В качестве другого примера,если часто делать такие запросы:</target>
        </trans-unit>
        <trans-unit id="a99c411c58f58d7e7474741b999e04e5e53fd82b" translate="yes" xml:space="preserve">
          <source>As before, however, PostgreSQL does not enforce the size restriction in any case.</source>
          <target state="translated">Однако,как и прежде,PostgreSQL ни в коем случае не применяет ограничение на размер.</target>
        </trans-unit>
        <trans-unit id="6c4c55629e9060b4cdfbd0fb1ea96b264210b4b6" translate="yes" xml:space="preserve">
          <source>As before, the estimated number of rows is just the product of this with the cardinality of &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">Как и раньше, предполагаемое количество строк - это просто произведение этого на мощность &lt;code&gt;tenk1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7a87fbf380bd12f56579ba8b09d2dfca1e87a7aa" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;, there are various situations in which subexpressions of an expression are evaluated at different times, so that the principle that &amp;ldquo;&lt;code&gt;CASE&lt;/code&gt; evaluates only necessary subexpressions&amp;rdquo; is not ironclad. For example a constant &lt;code&gt;1/0&lt;/code&gt; subexpression will usually result in a division-by-zero failure at planning time, even if it's within a &lt;code&gt;CASE&lt;/code&gt; arm that would never be entered at run time.</source>
          <target state="translated">Как описано в &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Разделе 4.2.14&lt;/a&gt; , существуют различные ситуации, в которых подвыражения выражения оцениваются в разное время, так что принцип &amp;laquo; &lt;code&gt;CASE&lt;/code&gt; оценивает только необходимые подвыражения&amp;raquo; не является железным. Например, постоянное подвыражение &lt;code&gt;1/0&lt;/code&gt; обычно приводит к отказу при делении на ноль во время планирования, даже если оно находится в плече &lt;code&gt;CASE&lt;/code&gt; , который никогда не будет введен во время выполнения.</target>
        </trans-unit>
        <trans-unit id="518e3cc29b2ad22029595abb39bdf434ee471900" translate="yes" xml:space="preserve">
          <source>As described in the previous section, transaction commit is normally &lt;em&gt;synchronous&lt;/em&gt;: the server waits for the transaction's WAL records to be flushed to permanent storage before returning a success indication to the client. The client is therefore guaranteed that a transaction reported to be committed will be preserved, even in the event of a server crash immediately after. However, for short transactions this delay is a major component of the total transaction time. Selecting asynchronous commit mode means that the server returns success as soon as the transaction is logically completed, before the WAL records it generated have actually made their way to disk. This can provide a significant boost in throughput for small transactions.</source>
          <target state="translated">Как описано в предыдущем разделе, фиксация транзакции обычно является &lt;em&gt;синхронной&lt;/em&gt; : сервер ожидает, пока записи WAL транзакции будут сброшены в постоянное хранилище, прежде чем вернуть клиенту индикацию успеха. Таким образом, клиенту гарантируется, что транзакция, о которой сообщается, будет сохранена, даже в случае сбоя сервера сразу после этого. Однако для коротких транзакций эта задержка является основным компонентом общего времени транзакции. Выбор режима асинхронной фиксации означает, что сервер возвращает успех, как только транзакция логически завершена, до того, как сгенерированные им записи WAL фактически попадут на диск. Это может обеспечить значительный прирост пропускной способности для небольших транзакций.</target>
        </trans-unit>
        <trans-unit id="64a53cc76e5b39051f25182477eec0422ea4a682" translate="yes" xml:space="preserve">
          <source>As explained above, it is possible to create indexes on partitioned tables and they are applied automatically to the entire hierarchy. This is very convenient, as not only the existing partitions will become indexed, but also any partitions that are created in the future will. One limitation is that it's not possible to use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; qualifier when creating such a partitioned index. To overcome long lock times, it is possible to use &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; the partitioned table; such an index is marked invalid, and the partitions do not get the index applied automatically. The indexes on partitions can be created separately using &lt;code&gt;CONCURRENTLY&lt;/code&gt;, and later &lt;em&gt;attached&lt;/em&gt; to the index on the parent using &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt;. Once indexes for all partitions are attached to the parent index, the parent index is marked valid automatically. Example:</source>
          <target state="translated">Как объяснялось выше, можно создавать индексы для многораздельных таблиц, и они автоматически применяются ко всей иерархии. Это очень удобно, так как индексируются не только существующие разделы, но и любые разделы, которые будут созданы в будущем. Одно ограничение заключается в том, что при создании такого многораздельного индекса невозможно использовать квалификатор &lt;code&gt;CONCURRENTLY&lt;/code&gt; . Чтобы преодолеть длительное время блокировки, можно использовать &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; для многораздельной таблицы; такой индекс помечается как недопустимый, и разделы не получают индекс автоматически. Индексы разделов могут быть созданы отдельно с помощью &lt;code&gt;CONCURRENTLY&lt;/code&gt; , а затем &lt;em&gt;присоединены&lt;/em&gt; к индексу родительского элемента с помощью &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt; . После присоединения индексов для всех разделов к родительскому индексу родительский индекс автоматически помечается как действительный. Пример:</target>
        </trans-unit>
        <trans-unit id="fb2dc582124a2fe2747429c6ba796f17d561c7c2" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;, the default privileges for any object type normally grant all grantable permissions to the object owner, and may grant some privileges to &lt;code&gt;PUBLIC&lt;/code&gt; as well. However, this behavior can be changed by altering the global default privileges with &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt;.</source>
          <target state="translated">Как объяснено в &lt;a href=&quot;ddl-priv&quot;&gt;Разделе 5.7&lt;/a&gt; , привилегии по умолчанию для любого типа объекта обычно предоставляют все предоставляемые разрешения владельцу объекта, а также могут предоставлять некоторые привилегии для &lt;code&gt;PUBLIC&lt;/code&gt; . Однако это поведение можно изменить, изменив глобальные привилегии по умолчанию с помощью &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cfc29a245774c7f93be3cd482cd2720e2efb253" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt;, functional dependencies are very cheap and efficient type of statistics, but their main limitation is their global nature (only tracking dependencies at the column level, not between individual column values).</source>
          <target state="translated">Как объяснялось в &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Разделе 70.2.1&lt;/a&gt; , функциональные зависимости - это очень дешевый и эффективный тип статистики, но их главное ограничение - их глобальный характер (отслеживание зависимостей только на уровне столбца, а не между значениями отдельных столбцов).</target>
        </trans-unit>
        <trans-unit id="c5ba1476be535d17f697ff078bc8840ec5998688" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;, the planner can determine cardinality of &lt;code&gt;t&lt;/code&gt; using the number of pages and rows obtained from &lt;code&gt;pg_class&lt;/code&gt;:</source>
          <target state="translated">Как объяснялось в &lt;a href=&quot;planner-stats&quot;&gt;Разделе 14.2&lt;/a&gt; , планировщик может определить количество элементов &lt;code&gt;t&lt;/code&gt; , используя количество страниц и строк, полученных из &lt;code&gt;pg_class&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39801241473f144107571af31829d77f27364c9d" translate="yes" xml:space="preserve">
          <source>As far as the operator class is concerned, returning &lt;code&gt;true&lt;/code&gt; indicates that deduplication is safe (or safe for the collation whose OID was passed to its &lt;code&gt;equalimage&lt;/code&gt; function). However, the core code will only deem deduplication safe for an index when &lt;em&gt;every&lt;/em&gt; indexed column uses an operator class that registers an &lt;code&gt;equalimage&lt;/code&gt; function, and each function actually returns &lt;code&gt;true&lt;/code&gt; when called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149ce91ff7ffadae424c16cab2b4c0512100eae4" translate="yes" xml:space="preserve">
          <source>As in basic &lt;code&gt;tsquery&lt;/code&gt; input, weight(s) can be attached to each lexeme to restrict it to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes of those weight(s). For example:</source>
          <target state="translated">Как и в базовом &lt;code&gt;tsquery&lt;/code&gt; , к каждой лексеме можно добавить вес (и), чтобы ограничить его соответствие только лексемам &lt;code&gt;tsvector&lt;/code&gt; с этим весом (-ами). Например:</target>
        </trans-unit>
        <trans-unit id="1c139aca10977b17d5102cc7674b71010f5c568f" translate="yes" xml:space="preserve">
          <source>As is standard in SQL, all functions return NULL, if any of the arguments are NULL. This may create security risks on careless usage.</source>
          <target state="translated">Как и в SQL,все функции возвращают NULL,если какой-либо из аргументов является NULL.Это может создать риски безопасности при небрежном использовании.</target>
        </trans-unit>
        <trans-unit id="585d0521870959cf15a89091a2347acd4003a598" translate="yes" xml:space="preserve">
          <source>As is typical of client/server applications, the client and the server can be on different hosts. In that case they communicate over a TCP/IP network connection. You should keep this in mind, because the files that can be accessed on a client machine might not be accessible (or might only be accessible using a different file name) on the database server machine.</source>
          <target state="translated">Как типично для клиентских/серверных приложений,клиент и сервер могут находиться на разных хостах.В этом случае они взаимодействуют через сетевое соединение TCP/IP.Вы должны помнить об этом,потому что файлы,к которым можно получить доступ на клиентской машине,могут быть недоступны (или могут быть доступны только с помощью другого имени файла)на машине сервера баз данных.</target>
        </trans-unit>
        <trans-unit id="29fce103d97e5fc966f97584895b606dc9b97769" translate="yes" xml:space="preserve">
          <source>As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. If this value is specified without units, it is taken as megabytes. The default is 80 MB. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">Пока использование диска WAL остается ниже этого параметра, старые файлы WAL всегда перерабатываются для будущего использования на контрольной точке, а не удаляются. Это можно использовать, чтобы гарантировать, что достаточно места WAL зарезервировано для обработки всплесков использования WAL, например, при выполнении больших пакетных заданий. Если это значение указано без единиц измерения, оно принимается в мегабайтах. По умолчанию 80 МБ. Этот параметр можно установить только в файле &lt;code&gt;postgresql.conf&lt;/code&gt; или в командной строке сервера.</target>
        </trans-unit>
        <trans-unit id="935b68a13a63015aa5e693b61464b2a9c3100546" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, each (active) subscription receives changes from a replication slot on the remote (publishing) side. Normally, the remote replication slot is created automatically when the subscription is created using &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; and it is dropped automatically when the subscription is dropped using &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt;. In some situations, however, it can be useful or necessary to manipulate the subscription and the underlying replication slot separately. Here are some scenarios:</source>
          <target state="translated">Как упоминалось ранее, каждая (активная) подписка получает изменения из слота репликации на удаленной (публикующей) стороне. Обычно слот удаленной репликации создается автоматически при создании подписки с помощью &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; и автоматически удаляется, когда подписка отбрасывается с помощью &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; . Однако в некоторых ситуациях может быть полезно или необходимо отдельно управлять подпиской и базовым слотом репликации. Вот несколько сценариев:</target>
        </trans-unit>
        <trans-unit id="6d35d01797be09599719c5fbe0e98e1d8b777874" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;, Serializable transactions are just Repeatable Read transactions which add nonblocking monitoring for dangerous patterns of read/write conflicts. When a pattern is detected which could cause a cycle in the apparent order of execution, one of the transactions involved is rolled back to break the cycle.</source>
          <target state="translated">Как упоминалось в &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Разделе 13.2.3&lt;/a&gt; , сериализуемые транзакции - это просто повторяющиеся транзакции чтения, которые добавляют неблокирующий мониторинг опасных шаблонов конфликтов чтения / записи. Когда обнаруживается шаблон, который может вызвать цикл в очевидном порядке выполнения, одна из задействованных транзакций откатывается, чтобы прервать цикл.</target>
        </trans-unit>
        <trans-unit id="820f9f6df5cbde09a17525e7847d0d2dfe09b2c4" translate="yes" xml:space="preserve">
          <source>As mentioned, there are multiple types of TOAST pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a &lt;em&gt;TOAST table&lt;/em&gt; that is separate from, but associated with, the table containing the TOAST pointer datum itself. These &lt;em&gt;on-disk&lt;/em&gt; pointer datums are created by the TOAST management code (in &lt;code&gt;access/common/toast_internals.c&lt;/code&gt;) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Section 68.2.1&lt;/a&gt;. Alternatively, a TOAST pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Section 68.2.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7967f9ae1b2dfb5df2376dc5e14f007c840b5d2" translate="yes" xml:space="preserve">
          <source>As mentioned, there are multiple types of TOAST pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a &lt;em&gt;TOAST table&lt;/em&gt; that is separate from, but associated with, the table containing the TOAST pointer datum itself. These &lt;em&gt;on-disk&lt;/em&gt; pointer datums are created by the TOAST management code (in &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt;) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Section 68.2.1&lt;/a&gt;. Alternatively, a TOAST pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Section 68.2.2&lt;/a&gt;.</source>
          <target state="translated">Как уже упоминалось, существует несколько типов данных указателя TOAST. Самым старым и наиболее распространенным типом является указатель на &lt;em&gt;внешние&lt;/em&gt; данные, хранящиеся в &lt;em&gt;таблице TOAST,&lt;/em&gt; которая отделена от таблицы, содержащей собственно данные указателя TOAST, но связана с ней. Эти данные указателя &lt;em&gt;на диске&lt;/em&gt; создаются управляющим кодом TOAST (в &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt; ), когда кортеж, который нужно сохранить на диске, слишком велик для сохранения как есть. Более подробная информация представлена ​​в &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Разделе 68.2.1.&lt;/a&gt;. В качестве альтернативы датум указателя TOAST может содержать указатель на данные вне линии, которые появляются в другом месте памяти. Такие данные обязательно недолговечны и никогда не появятся на диске, но они очень полезны для предотвращения копирования и избыточной обработки больших значений данных. Более подробная информация представлена ​​в &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Разделе 68.2.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e83c3b33db2892f30f5c07aab1da708113577a83" translate="yes" xml:space="preserve">
          <source>As noted above, if the server crashes during the backup it may not be possible to restart until the &lt;code&gt;backup_label&lt;/code&gt; file has been manually deleted from the &lt;code&gt;PGDATA&lt;/code&gt; directory. Note that it is very important to never remove the &lt;code&gt;backup_label&lt;/code&gt; file when restoring a backup, because this will result in corruption. Confusion about when it is appropriate to remove this file is a common cause of data corruption when using this method; be very certain that you remove the file only on an existing master and never when building a standby or restoring a backup, even if you are building a standby that will subsequently be promoted to a new master.</source>
          <target state="translated">Как отмечалось выше, в случае сбоя сервера во время резервного копирования его невозможно будет перезапустить, пока файл &lt;code&gt;backup_label&lt;/code&gt; не будет вручную удален из каталога &lt;code&gt;PGDATA&lt;/code&gt; . Обратите внимание, что очень важно никогда не удалять файл &lt;code&gt;backup_label&lt;/code&gt; при восстановлении резервной копии, поскольку это приведет к повреждению. Непонимание того, когда следует удалить этот файл, является частой причиной повреждения данных при использовании этого метода; будьте очень уверены, что вы удаляете файл только на существующем главном сервере и никогда при создании резервного или восстановлении резервной копии, даже если вы создаете резервный сервер, который впоследствии будет повышен до нового мастера.</target>
        </trans-unit>
        <trans-unit id="b565015dcc8ef588510a75b03d00c798591daa60" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, &lt;code&gt;amvacuumcleanup&lt;/code&gt; will also be called at completion of an &lt;code&gt;ANALYZE&lt;/code&gt; operation. In this case &lt;code&gt;stats&lt;/code&gt; is always NULL and any return value will be ignored. This case can be distinguished by checking &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt;. It is recommended that the access method do nothing except post-insert cleanup in such a call, and that only in an autovacuum worker process.</source>
          <target state="translated">Начиная с PostgreSQL 8.4, &lt;code&gt;amvacuumcleanup&lt;/code&gt; также будет вызываться при завершении операции &lt;code&gt;ANALYZE&lt;/code&gt; . В этом случае &lt;code&gt;stats&lt;/code&gt; всегда NULL, и любое возвращаемое значение будет проигнорировано. Этот случай можно отличить, установив флажок &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt; . Рекомендуется, чтобы при таком вызове метод доступа ничего не делал, кроме очистки после вставки, и это только в рабочем процессе автоочистки.</target>
        </trans-unit>
        <trans-unit id="41cf08ef1ae95fce9351d2775b5ca30eb5967a1b" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, this advice is less necessary since delayed indexing is used (see &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; for details). But for very large updates it may still be best to drop and recreate the index.</source>
          <target state="translated">Начиная с PostgreSQL 8.4, этот совет менее необходим, поскольку используется отложенное индексирование (подробности см. В &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Разделе 66.4.1&lt;/a&gt; ). Но для очень больших обновлений лучше всего отбросить и воссоздать индекс.</target>
        </trans-unit>
        <trans-unit id="fd60ea8bf7dbb2005dc3edad9e036817a4cf429d" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.0, &lt;code&gt;hstore&lt;/code&gt; uses a different internal representation than previous versions. This presents no obstacle for dump/restore upgrades since the text representation (used in the dump) is unchanged.</source>
          <target state="translated">Начиная с PostgreSQL 9.0, &lt;code&gt;hstore&lt;/code&gt; использует другое внутреннее представление, чем предыдущие версии. Это не создает препятствий для обновлений дампа / восстановления, поскольку текстовое представление (используемое в дампе) не изменяется.</target>
        </trans-unit>
        <trans-unit id="280a05cda72f4f22e9db55fedf9a21987eec509c" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be installed with &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt; not &lt;code&gt;CREATE LANGUAGE&lt;/code&gt;. Direct use of &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; should now be confined to extension installation scripts. If you have a &amp;ldquo;bare&amp;rdquo; language in your database, perhaps as a result of an upgrade, you can convert it to an extension using &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt;.</source>
          <target state="translated">Начиная с PostgreSQL 9.1, большинство процедурных языков были преобразованы в &amp;laquo;расширения&amp;raquo;, поэтому их следует устанавливать с &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION, а&lt;/a&gt; не &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; . Прямое использование &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; теперь должно быть ограничено сценариями установки расширений. Если у вас есть &amp;laquo;голый&amp;raquo; язык в вашей базе данных, возможно, в результате обновления, вы можете преобразовать его в расширение, используя &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad6c1afacf960c00b0b43cc22652add17660a754" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be removed with &lt;a href=&quot;sql-dropextension&quot;&gt;DROP EXTENSION&lt;/a&gt; not &lt;code&gt;DROP LANGUAGE&lt;/code&gt;.</source>
          <target state="translated">Начиная с PostgreSQL 9.1, большинство процедурных языков были преобразованы в &amp;laquo;расширения&amp;raquo;, и поэтому их следует удалить с помощью &lt;a href=&quot;sql-dropextension&quot;&gt;DROP EXTENSION, а&lt;/a&gt; не &lt;code&gt;DROP LANGUAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9efc7bda1a790af9716120cc8586743f8662e379" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, null key values can be included in the index. Also, placeholder nulls are included in the index for indexed items that are null or contain no keys according to &lt;code&gt;extractValue&lt;/code&gt;. This allows searches that should find empty items to do so.</source>
          <target state="translated">Начиная с PostgreSQL 9.1, в индекс можно включать нулевые значения ключей. Кроме того, пустые заполнители включаются в индекс для индексированных элементов, которые имеют значение NULL или не содержат ключей в соответствии с &lt;code&gt;extractValue&lt;/code&gt; . Это позволяет выполнять поиск, который должен находить пустые элементы.</target>
        </trans-unit>
        <trans-unit id="41a7562cb3e64fe55b5aa379cb00b42fdb0e1138" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, you can attach a &lt;code&gt;COLLATE&lt;/code&gt; specification to &lt;code&gt;citext&lt;/code&gt; columns or data values. Currently, &lt;code&gt;citext&lt;/code&gt; operators will honor a non-default &lt;code&gt;COLLATE&lt;/code&gt; specification while comparing case-folded strings, but the initial folding to lower case is always done according to the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; setting (that is, as though &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; were given). This may be changed in a future release so that both steps follow the input &lt;code&gt;COLLATE&lt;/code&gt; specification.</source>
          <target state="translated">Начиная с PostgreSQL 9.1, вы можете прикрепить спецификацию &lt;code&gt;COLLATE&lt;/code&gt; к столбцам &lt;code&gt;citext&lt;/code&gt; или значениям данных. В настоящее время операторы &lt;code&gt;citext&lt;/code&gt; будут учитывать спецификацию &lt;code&gt;COLLATE&lt;/code&gt; , отличную от заданной по умолчанию, при сравнении строк, свернутых по регистру, но начальное сворачивание в нижний регистр всегда выполняется в соответствии с настройкой базы данных &lt;code&gt;LC_CTYPE&lt;/code&gt; (то есть, как если бы &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; был задан по умолчанию ). Это может быть изменено в будущем выпуске, чтобы оба шага следовали входной спецификации &lt;code&gt;COLLATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cdab33dd907fd023cacb62f21aa10cc62e305ca" translate="yes" xml:space="preserve">
          <source>As pg_rewind copies configuration files entirely from the source, it may be required to correct the configuration used for recovery before restarting the target server, especially if the target is reintroduced as a standby of the source. If you restart the server after the rewind operation has finished but without configuring recovery, the target may again diverge from the primary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8c2a751dfbd5be0d7c157dabee58d14e6c8985" translate="yes" xml:space="preserve">
          <source>As previously stated, when a JSON value is input and then printed without any additional processing, &lt;code&gt;json&lt;/code&gt; outputs the same text that was input, while &lt;code&gt;jsonb&lt;/code&gt; does not preserve semantically-insignificant details such as whitespace. For example, note the differences here:</source>
          <target state="translated">Как указывалось ранее, когда значение JSON вводится и затем печатается без какой-либо дополнительной обработки, &lt;code&gt;json&lt;/code&gt; выводит тот же текст, который был &lt;code&gt;jsonb&lt;/code&gt; , в то время как jsonb не сохраняет семантически несущественные детали, такие как пробелы. Например, обратите внимание на различия здесь:</target>
        </trans-unit>
        <trans-unit id="1442483656b1d2da488c86cbbe647b9c3925f511" translate="yes" xml:space="preserve">
          <source>As seen in the second example, the element name can be omitted if the content value is a column reference, in which case the column name is used by default. Otherwise, a name must be specified.</source>
          <target state="translated">Как видно из второго примера,имя элемента может быть опущено,если значение содержимого является ссылкой на столбец,в этом случае имя столбца используется по умолчанию.В противном случае необходимо указать имя.</target>
        </trans-unit>
        <trans-unit id="fbfde401bab7c53809229a3d8a380b7c73d7b56a" translate="yes" xml:space="preserve">
          <source>As seen in this example, when the query is an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; command, the actual work of applying the table changes is done by a top-level Insert, Update, or Delete plan node. The plan nodes underneath this node perform the work of locating the old rows and/or computing the new data. So above, we see the same sort of bitmap table scan we've seen already, and its output is fed to an Update node that stores the updated rows. It's worth noting that although the data-modifying node can take a considerable amount of run time (here, it's consuming the lion's share of the time), the planner does not currently add anything to the cost estimates to account for that work. That's because the work to be done is the same for every correct query plan, so it doesn't affect planning decisions.</source>
          <target state="translated">Как видно в этом примере, когда запрос представляет собой &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; , фактическая работа по применению изменений таблицы выполняется узлом плана верхнего уровня Вставить, Обновить или Удалить. Узлы плана под этим узлом выполняют работу по поиску старых строк и / или вычислению новых данных. Итак, выше мы видим тот же вид сканирования таблицы растровых изображений, который мы уже видели, и его вывод передается на узел обновления, в котором хранятся обновленные строки. Стоит отметить, что хотя узел изменения данных может занять значительное время выполнения (здесь он потребляет львиную долю времени), планировщик в настоящее время ничего не добавляет к оценкам затрат для учета этой работы. Это связано с тем, что работа, которую необходимо выполнить для каждого правильного плана запроса, не влияет на решения по планированию.</target>
        </trans-unit>
        <trans-unit id="c1072787f6d22b0aaf6039c0a8fa7f37aca0290a" translate="yes" xml:space="preserve">
          <source>As shown above, all comparison operators are binary operators that return values of type &lt;code&gt;boolean&lt;/code&gt;. Thus, expressions like &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; are not valid (because there is no &lt;code&gt;&amp;lt;&lt;/code&gt; operator to compare a Boolean value with &lt;code&gt;3&lt;/code&gt;). Use the &lt;code&gt;BETWEEN&lt;/code&gt; predicates shown below to perform range tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299b9141677294c0e2aa3b93c3483b8a98e2f995" translate="yes" xml:space="preserve">
          <source>As shown above, the &lt;code&gt;union&lt;/code&gt; function's first &lt;code&gt;internal&lt;/code&gt; argument is actually a &lt;code&gt;GistEntryVector&lt;/code&gt; pointer. The second argument is a pointer to an integer variable, which can be ignored. (It used to be required that the &lt;code&gt;union&lt;/code&gt; function store the size of its result value into that variable, but this is no longer necessary.)</source>
          <target state="translated">Как показано выше, первый &lt;code&gt;internal&lt;/code&gt; аргумент функции &lt;code&gt;union&lt;/code&gt; на самом деле является указателем &lt;code&gt;GistEntryVector&lt;/code&gt; . Второй аргумент - это указатель на целочисленную переменную, которую можно игнорировать. (Раньше требовалось, чтобы функция &lt;code&gt;union&lt;/code&gt; сохраняла размер своего значения результата в этой переменной, но теперь в этом нет необходимости.)</target>
        </trans-unit>
        <trans-unit id="e49718fcf44bf904fec83a97285f69086516abb8" translate="yes" xml:space="preserve">
          <source>As shown here, the &lt;code&gt;rank&lt;/code&gt; function produces a numerical rank for each distinct &lt;code&gt;ORDER BY&lt;/code&gt; value in the current row's partition, using the order defined by the &lt;code&gt;ORDER BY&lt;/code&gt; clause. &lt;code&gt;rank&lt;/code&gt; needs no explicit parameter, because its behavior is entirely determined by the &lt;code&gt;OVER&lt;/code&gt; clause.</source>
          <target state="translated">Как показано здесь, функция &lt;code&gt;rank&lt;/code&gt; производит числовой ранг для каждого отдельного значения &lt;code&gt;ORDER BY&lt;/code&gt; в разделе текущей строки, используя порядок, определенный предложением &lt;code&gt;ORDER BY&lt;/code&gt; . &lt;code&gt;rank&lt;/code&gt; не требует явного параметра, потому что его поведение полностью определяется предложением &lt;code&gt;OVER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7278da1d6766bb19352b261eabd292dd18fce4c5" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.2&lt;/a&gt;, a btree operator class must provide five comparison operators, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. One might expect that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; should also be part of the operator class, but it is not, because it would almost never be useful to use a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE clause in an index search. (For some purposes, the planner treats &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as associated with a btree operator class; but it finds that operator via the &lt;code&gt;=&lt;/code&gt; operator's negator link, rather than from &lt;code&gt;pg_amop&lt;/code&gt;.)</source>
          <target state="translated">Как показано в &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Таблице 37.2&lt;/a&gt; , класс операторов btree должен обеспечивать пять операторов сравнения, &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;&lt;/code&gt; . Можно было бы ожидать, что &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; также должен быть частью класса операторов, но это не так, потому что почти никогда не было бы полезно использовать предложение &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE при поиске по индексу. (Для некоторых целей планировщик рассматривает &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; как связанный с классом операторов btree; но он находит этот оператор через ссылку &lt;code&gt;pg_amop&lt;/code&gt; оператора &lt;code&gt;=&lt;/code&gt; , а не из pg_amop .)</target>
        </trans-unit>
        <trans-unit id="2b7658bd4634c80bfa02d903fd89d9f89cfdf0c3" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Table 37.8&lt;/a&gt;, btree defines one required and two optional support functions.</source>
          <target state="translated">Как показано в &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Таблице 37.8&lt;/a&gt; , btree определяет одну обязательную и две дополнительные функции поддержки.</target>
        </trans-unit>
        <trans-unit id="e2e2d713a7e1c4b73e9dae4d9b294d20af0dfdbd" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.3&lt;/a&gt;, a btree operator class must provide five comparison operators, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. One might expect that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; should also be part of the operator class, but it is not, because it would almost never be useful to use a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE clause in an index search. (For some purposes, the planner treats &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as associated with a btree operator class; but it finds that operator via the &lt;code&gt;=&lt;/code&gt; operator's negator link, rather than from &lt;code&gt;pg_amop&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9a67840a67dabf7761754a18fc846d1c2e26f5" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Table 37.9&lt;/a&gt;, btree defines one required and four optional support functions. The five user-defined methods are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01827ef18402ec5bd4e9a302a910b59d06b2ca2b" translate="yes" xml:space="preserve">
          <source>As shown in the previous section, the table expression in the &lt;code&gt;SELECT&lt;/code&gt; command constructs an intermediate virtual table by possibly combining tables, views, eliminating rows, grouping, etc. This table is finally passed on to processing by the &lt;em&gt;select list&lt;/em&gt;. The select list determines which &lt;em&gt;columns&lt;/em&gt; of the intermediate table are actually output.</source>
          <target state="translated">Как показано в предыдущем разделе, табличное выражение в команде &lt;code&gt;SELECT&lt;/code&gt; создает промежуточную виртуальную таблицу, возможно объединяя таблицы, представления, удаляя строки, группируя и т. Д. Эта таблица, наконец, передается на обработку &lt;em&gt;списком выбора&lt;/em&gt; . Список выбора определяет, какие &lt;em&gt;столбцы&lt;/em&gt; промежуточной таблицы фактически выводятся.</target>
        </trans-unit>
        <trans-unit id="a1a6ed6a1882593d5ac926bd03fffe04913abef7" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing a composite value you can write double quotes around any individual field value. You &lt;em&gt;must&lt;/em&gt; do so if the field value would otherwise confuse the composite-value parser. In particular, fields containing parentheses, commas, double quotes, or backslashes must be double-quoted. To put a double quote or backslash in a quoted composite field value, precede it with a backslash. (Also, a pair of double quotes within a double-quoted field value is taken to represent a double quote character, analogously to the rules for single quotes in SQL literal strings.) Alternatively, you can avoid quoting and use backslash-escaping to protect all data characters that would otherwise be taken as composite syntax.</source>
          <target state="translated">Как было показано ранее, при записи составного значения вы можете заключать в двойные кавычки любое отдельное значение поля. Вы &lt;em&gt;должны&lt;/em&gt; сделать это, если иначе значение поля может запутать синтаксический анализатор составного значения. В частности, поля, содержащие круглые скобки, запятые, двойные кавычки или обратную косую черту, должны быть заключены в двойные кавычки. Чтобы поместить двойные кавычки или обратную косую черту в значение составного поля в кавычках, поставьте перед ним обратную косую черту. (Кроме того, пара двойных кавычек в значении поля, заключенного в двойные кавычки, используется для представления символа двойной кавычки, аналогично правилам для одинарных кавычек в строках литералов SQL.) В качестве альтернативы вы можете избежать кавычек и использовать обратную косую черту для защиты все символы данных, которые в противном случае были бы приняты как составной синтаксис.</target>
        </trans-unit>
        <trans-unit id="bf6c49e3bf726dc38d17652f47395db71e4e4fbd" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing an array value you can use double quotes around any individual array element. You &lt;em&gt;must&lt;/em&gt; do so if the element value would otherwise confuse the array-value parser. For example, elements containing curly braces, commas (or the data type's delimiter character), double quotes, backslashes, or leading or trailing whitespace must be double-quoted. Empty strings and strings matching the word &lt;code&gt;NULL&lt;/code&gt; must be quoted, too. To put a double quote or backslash in a quoted array element value, precede it with a backslash. Alternatively, you can avoid quotes and use backslash-escaping to protect all data characters that would otherwise be taken as array syntax.</source>
          <target state="translated">Как было показано ранее, при записи значения массива вы можете заключать в двойные кавычки любой отдельный элемент массива. Вы &lt;em&gt;должны&lt;/em&gt; сделать это, если иначе значение элемента могло бы запутать синтаксический анализатор значений массива. Например, элементы, содержащие фигурные скобки, запятые (или символ-разделитель типа данных), двойные кавычки, обратные косые черты или начальные или конечные пробелы, должны быть заключены в двойные кавычки. Пустые строки и строки, соответствующие слову &lt;code&gt;NULL&lt;/code&gt; ,также должны быть заключены в кавычки. Чтобы поместить двойные кавычки или обратную косую черту в значение элемента массива в кавычках, поставьте перед ним обратную косую черту. В качестве альтернативы вы можете избегать кавычек и использовать обратную косую черту для защиты всех символов данных, которые в противном случае были бы приняты как синтаксис массива.</target>
        </trans-unit>
        <trans-unit id="8a1775eb12b1097993052bc9db7c32cd0419a0ce" translate="yes" xml:space="preserve">
          <source>As shown, an array data type is named by appending square brackets (&lt;code&gt;[]&lt;/code&gt;) to the data type name of the array elements. The above command will create a table named &lt;code&gt;sal_emp&lt;/code&gt; with a column of type &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;name&lt;/code&gt;), a one-dimensional array of type &lt;code&gt;integer&lt;/code&gt; (&lt;code&gt;pay_by_quarter&lt;/code&gt;), which represents the employee's salary by quarter, and a two-dimensional array of &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;schedule&lt;/code&gt;), which represents the employee's weekly schedule.</source>
          <target state="translated">Как показано, тип данных массива именуется добавлением квадратных скобок ( &lt;code&gt;[]&lt;/code&gt; ) к имени типа данных элементов массива. Приведенная выше команда создаст таблицу с именем &lt;code&gt;sal_emp&lt;/code&gt; со столбцом типа &lt;code&gt;text&lt;/code&gt; ( &lt;code&gt;name&lt;/code&gt; ), одномерным массивом типа &lt;code&gt;integer&lt;/code&gt; ( &lt;code&gt;pay_by_quarter&lt;/code&gt; ), который представляет зарплату сотрудника по кварталам, и двумерным массивом &lt;code&gt;text&lt;/code&gt; ( &lt;code&gt;schedule&lt;/code&gt; ) , который представляет собой недельный график сотрудника.</target>
        </trans-unit>
        <trans-unit id="e0b46ae37bd20da5e49ea599dd897a3ac9299776" translate="yes" xml:space="preserve">
          <source>As the above example suggests, a &lt;code&gt;tsquery&lt;/code&gt; is not just raw text, any more than a &lt;code&gt;tsvector&lt;/code&gt; is. A &lt;code&gt;tsquery&lt;/code&gt; contains search terms, which must be already-normalized lexemes, and may combine multiple terms using AND, OR, NOT, and FOLLOWED BY operators. (For syntax details see &lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;Section 8.11.2&lt;/a&gt;.) There are functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, and &lt;code&gt;phraseto_tsquery&lt;/code&gt; that are helpful in converting user-written text into a proper &lt;code&gt;tsquery&lt;/code&gt;, primarily by normalizing words appearing in the text. Similarly, &lt;code&gt;to_tsvector&lt;/code&gt; is used to parse and normalize a document string. So in practice a text search match would look more like this:</source>
          <target state="translated">Как &lt;code&gt;tsquery&lt;/code&gt; из приведенного выше примера, tsquery - это не просто необработанный текст, &lt;code&gt;tsvector&lt;/code&gt; как и tsvector . &lt;code&gt;tsquery&lt;/code&gt; содержит поисковые термины, которые должны быть уже нормированные лексемы, и может объединять несколько терминов , используя AND, OR, NOT и последующим операторов. (Подробнее о синтаксисе см. &lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;Раздел 8.11.2&lt;/a&gt; .) Существуют функции &lt;code&gt;to_tsquery&lt;/code&gt; , &lt;code&gt;plainto_tsquery&lt;/code&gt; и &lt;code&gt;phraseto_tsquery&lt;/code&gt; , которые помогают преобразовывать написанный пользователем текст в правильный &lt;code&gt;tsquery&lt;/code&gt; , в первую очередь за счет нормализации слов, появляющихся в тексте. Аналогично &lt;code&gt;to_tsvector&lt;/code&gt; используется для анализа и нормализации строки документа. Итак, на практике соответствие текстового поиска будет выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="6b22935fd06acdc1c0f8d1431b124c6c0f7b088d" translate="yes" xml:space="preserve">
          <source>As the last example demonstrates, the regexp split functions ignore zero-length matches that occur at the start or end of the string or immediately after a previous match. This is contrary to the strict definition of regexp matching that is implemented by &lt;code&gt;regexp_match&lt;/code&gt; and &lt;code&gt;regexp_matches&lt;/code&gt;, but is usually the most convenient behavior in practice. Other software systems such as Perl use similar definitions.</source>
          <target state="translated">Как показывает последний пример, функции разделения регулярного выражения игнорируют совпадения нулевой длины, которые встречаются в начале или конце строки или сразу после предыдущего совпадения. Это противоречит строгому определению сопоставления регулярных выражений, которое реализуется с помощью &lt;code&gt;regexp_match&lt;/code&gt; и &lt;code&gt;regexp_matches&lt;/code&gt; , но обычно это наиболее удобное поведение на практике. Другие программные системы, такие как Perl, используют аналогичные определения.</target>
        </trans-unit>
        <trans-unit id="0378825838c0e066e87e6d5b0be89bee2dd5620d" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;IN&lt;/code&gt; is null.</source>
          <target state="translated">Как обычно, нулевые значения в строках объединяются в соответствии с обычными правилами логических выражений SQL. Две строки считаются равными, если все их соответствующие члены не равны нулю и равны; строки не равны, если какие-либо соответствующие члены не равны нулю и не равны; в противном случае результат этого сравнения строк неизвестен (ноль). Если все результаты для каждой строки неравны или равны нулю, по крайней мере, с одним нулем, то результат &lt;code&gt;IN&lt;/code&gt; будет нулевым.</target>
        </trans-unit>
        <trans-unit id="0b8508c03666af11ade2c1725a303ade508dcc57" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;NOT IN&lt;/code&gt; is null.</source>
          <target state="translated">Как обычно, нулевые значения в строках объединяются в соответствии с обычными правилами логических выражений SQL. Две строки считаются равными, если все их соответствующие члены не равны нулю и равны; строки не равны, если какие-либо соответствующие члены не равны нулю и не равны; в противном случае результат этого сравнения строк неизвестен (ноль). Если все результаты для каждой строки либо не равны, либо равны нулю, по крайней мере, с одним нулем, тогда результат &lt;code&gt;NOT IN&lt;/code&gt; будет нулем.</target>
        </trans-unit>
        <trans-unit id="00f8ed65d004834d267f75de424eb5e9aec68c8b" translate="yes" xml:space="preserve">
          <source>As visible here, JIT was used, but inlining and expensive optimization were not. If &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; were also lowered, that would change.</source>
          <target state="translated">Как видно здесь, JIT использовалась, но не встраивание и дорогостоящая оптимизация. Если бы &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; или &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; также были снижены, это изменилось бы.</target>
        </trans-unit>
        <trans-unit id="e991d7170113bfec3a30551fcd7b4c1810192115" translate="yes" xml:space="preserve">
          <source>As we can see, a complex table hierarchy could require a substantial amount of DDL. In the above example we would be creating a new child table each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">Как видим,сложная иерархия таблиц может потребовать значительного количества DDL.В приведенном выше примере мы будем каждый месяц создавать новую дочернюю таблицу,поэтому,возможно,было бы разумно написать сценарий,который автоматически генерировал бы требуемую DDL.</target>
        </trans-unit>
        <trans-unit id="13f137c0044f99ee6629a214a80858091639b3df" translate="yes" xml:space="preserve">
          <source>As we saw in the previous section, the query planner needs to estimate the number of rows retrieved by a query in order to make good choices of query plans. This section provides a quick look at the statistics that the system uses for these estimates.</source>
          <target state="translated">Как мы видели в предыдущем разделе,планировщик запросов должен оценить количество строк,полученных запросом,чтобы сделать правильный выбор планов запросов.В этом разделе дается краткий обзор статистики,используемой системой для этих оценок.</target>
        </trans-unit>
        <trans-unit id="6a378a5df8689a29e440cf7e593b2b7b017debb3" translate="yes" xml:space="preserve">
          <source>As well as tables, this option can be used to dump the definition of matching views, materialized views, foreign tables, and sequences. It will not dump the contents of views or materialized views, and the contents of foreign tables will only be dumped if the corresponding foreign server is specified with &lt;code&gt;--include-foreign-data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28715fe2eadf5afacb168abae8c272e3eef5af1" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;EXISTS&lt;/code&gt;, it's unwise to assume that the subquery will be evaluated completely.</source>
          <target state="translated">Как и в случае с &lt;code&gt;EXISTS&lt;/code&gt; , неразумно предполагать, что подзапрос будет вычислен полностью.</target>
        </trans-unit>
        <trans-unit id="22733a70e9587403334559bc9fffe583566e0a7a" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;LIKE&lt;/code&gt;, a backslash disables the special meaning of any of these metacharacters. A different escape character can be specified with &lt;code&gt;ESCAPE&lt;/code&gt;, or the escape capability can be disabled by writing &lt;code&gt;ESCAPE ''&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181bd891b583b10919f382d152707212af1347e4" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;LIKE&lt;/code&gt;, a backslash disables the special meaning of any of these metacharacters; or a different escape character can be specified with &lt;code&gt;ESCAPE&lt;/code&gt;.</source>
          <target state="translated">Как и в случае с &lt;code&gt;LIKE&lt;/code&gt; , обратная косая черта отключает особое значение любого из этих метасимволов; или с помощью &lt;code&gt;ESCAPE&lt;/code&gt; можно указать другой escape-символ .</target>
        </trans-unit>
        <trans-unit id="8c360e616acbe7a6ddce202d4edfd50d452f4ba5" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;SIMILAR TO&lt;/code&gt;, the specified pattern must match the entire data string, or else the function fails and returns null. To indicate the part of the pattern for which the matching data sub-string is of interest, the pattern should contain two occurrences of the escape character followed by a double quote (&lt;code&gt;&quot;&lt;/code&gt;). The text matching the portion of the pattern between these separators is returned when the match is successful.</source>
          <target state="translated">Как и в случае с &lt;code&gt;SIMILAR TO&lt;/code&gt; , указанный шаблон должен соответствовать всей строке данных, иначе функция завершится ошибкой и вернет null. Чтобы указать часть шаблона, для которой представляет интерес соответствующая подстрока данных, шаблон должен содержать два вхождения escape-символа, за которыми следует двойная кавычка ( &lt;code&gt;&quot;&lt;/code&gt; ). Текст, соответствующий части шаблона между этими разделителями, является возвращается при успешном совпадении.</target>
        </trans-unit>
        <trans-unit id="2f915404c792b4b375081401e8be4799b6fdf5c9" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;pgstattuple&lt;/code&gt;, the results are accumulated page-by-page, and should not be expected to represent an instantaneous snapshot of the whole index.</source>
          <target state="translated">Как и в случае с &lt;code&gt;pgstattuple&lt;/code&gt; , результаты накапливаются постранично, и не следует ожидать, что они представляют собой мгновенный снимок всего индекса.</target>
        </trans-unit>
        <trans-unit id="fd70faee0fe9a1b62ee5a071b1f7e464081b1189" translate="yes" xml:space="preserve">
          <source>As with any security settings, it's important to test and ensure that the system is behaving as expected. Using the example above, this demonstrates that the permission system is working properly.</source>
          <target state="translated">Как и в случае с любыми настройками безопасности,важно протестировать и убедиться,что система ведет себя так,как ожидается.Использование приведенного выше примера показывает,что система разрешений работает правильно.</target>
        </trans-unit>
        <trans-unit id="f8169958f7a4429a1d75d6cb1d9f2e4af52ed1d2" translate="yes" xml:space="preserve">
          <source>As with any server daemon that is accessible to the outside world, it is advisable to run PostgreSQL under a separate user account. This user account should only own the data that is managed by the server, and should not be shared with other daemons. (For example, using the user &lt;code&gt;nobody&lt;/code&gt; is a bad idea.) In particular, it is advisable that this user account not own the PostgreSQL executable files, to ensure that a compromised server process could not modify those executables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9153f6ce7772c623a80d637e2a8064efd48ff4" translate="yes" xml:space="preserve">
          <source>As with any server daemon that is accessible to the outside world, it is advisable to run PostgreSQL under a separate user account. This user account should only own the data that is managed by the server, and should not be shared with other daemons. (For example, using the user &lt;code&gt;nobody&lt;/code&gt; is a bad idea.) It is not advisable to install executables owned by this user because compromised systems could then modify their own binaries.</source>
          <target state="translated">Как и любой серверный демон, доступный для внешнего мира, рекомендуется запускать PostgreSQL под отдельной учетной записью пользователя. Эта учетная запись пользователя должна владеть только данными, управляемыми сервером, и не должна использоваться другими демонами. (Например, использование пользователя &lt;code&gt;nobody&lt;/code&gt; - плохая идея.) Не рекомендуется устанавливать исполняемые файлы, принадлежащие этому пользователю, потому что скомпрометированные системы могут затем изменить свои собственные двоичные файлы.</target>
        </trans-unit>
        <trans-unit id="c718a2b52c9e3b6c8aed088c8f0e6614024fc446" translate="yes" xml:space="preserve">
          <source>As with base backups, the easiest way to produce a standalone hot backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. If you include the &lt;code&gt;-X&lt;/code&gt; parameter when calling it, all the write-ahead log required to use the backup will be included in the backup automatically, and no special action is required to restore the backup.</source>
          <target state="translated">Как и в случае с базовыми резервными копиями, самый простой способ создать автономное горячее резервное копирование - использовать инструмент &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; . Если вы &lt;code&gt;-X&lt;/code&gt; параметр -X при его вызове, весь журнал упреждающей записи, необходимый для использования резервной копии, будет автоматически включен в резервную копию, и никаких специальных действий для восстановления резервной копии не потребуется.</target>
        </trans-unit>
        <trans-unit id="478aba2ebcc8faa95902624459b6a85534e22480" translate="yes" xml:space="preserve">
          <source>As with dropping a column, you need to add &lt;code&gt;CASCADE&lt;/code&gt; if you want to drop a constraint that something else depends on. An example is that a foreign key constraint depends on a unique or primary key constraint on the referenced column(s).</source>
          <target state="translated">Как и при удалении столбца, вам нужно добавить &lt;code&gt;CASCADE&lt;/code&gt; , если вы хотите удалить ограничение, от которого зависит что-то еще. Примером является то, что ограничение внешнего ключа зависит от ограничения уникальности или первичного ключа для указанного столбца (столбцов).</target>
        </trans-unit>
        <trans-unit id="f3f0c2f615e83e516256da21365a0381f69d219d" translate="yes" xml:space="preserve">
          <source>As with other PostgreSQL text search configuration files, the rules file must be stored in UTF-8 encoding. The data is automatically translated into the current database's encoding when loaded. Any lines containing untranslatable characters are silently ignored, so that rules files can contain rules that are not applicable in the current encoding.</source>
          <target state="translated">Как и другие файлы конфигурации текстового поиска PostgreSQL,файл правил должен храниться в кодировке UTF-8.При загрузке данные автоматически переводятся в текущую кодировку БД.Любые строки,содержащие непереводимые символы,молча игнорируются,так что файлы правил могут содержать правила,которые не применимы в текущей кодировке.</target>
        </trans-unit>
        <trans-unit id="10502eec64e33ad71eb02c8495b055a53abfa416" translate="yes" xml:space="preserve">
          <source>As with the plain file-system-backup technique, this method can only support restoration of an entire database cluster, not a subset. Also, it requires a lot of archival storage: the base backup might be bulky, and a busy system will generate many megabytes of WAL traffic that have to be archived. Still, it is the preferred backup technique in many situations where high reliability is needed.</source>
          <target state="translated">Как и в случае с простой технологией резервного копирования файловой системы,этот метод может поддерживать только восстановление всего кластера баз данных,а не подмножества.Также он требует большого объема архивного хранения:резервное копирование базы может быть громоздким,а загруженная система будет генерировать много мегабайт трафика WAL,который необходимо архивировать.Тем не менее,это предпочтительная техника резервного копирования во многих ситуациях,когда требуется высокая надежность.</target>
        </trans-unit>
        <trans-unit id="41912914d23f57d6b4964446c4839bcd6bf6e2ec" translate="yes" xml:space="preserve">
          <source>As with vacuuming for space recovery, frequent updates of statistics are more useful for heavily-updated tables than for seldom-updated ones. But even for a heavily-updated table, there might be no need for statistics updates if the statistical distribution of the data is not changing much. A simple rule of thumb is to think about how much the minimum and maximum values of the columns in the table change. For example, a &lt;code&gt;timestamp&lt;/code&gt; column that contains the time of row update will have a constantly-increasing maximum value as rows are added and updated; such a column will probably need more frequent statistics updates than, say, a column containing URLs for pages accessed on a website. The URL column might receive changes just as often, but the statistical distribution of its values probably changes relatively slowly.</source>
          <target state="translated">Как и в случае с очисткой для восстановления пространства, частое обновление статистики более полезно для сильно обновляемых таблиц, чем для редко обновляемых. Но даже для сильно обновленной таблицы может не потребоваться обновление статистики, если статистическое распределение данных не сильно меняется. Простое практическое правило - подумать о том, насколько изменяются минимальные и максимальные значения столбцов в таблице. Например, &lt;code&gt;timestamp&lt;/code&gt; столбец, содержащий время обновления строки, будет иметь постоянно увеличивающееся максимальное значение по мере добавления и обновления строк; такой столбец, вероятно, потребует более частого обновления статистики, чем, скажем, столбец, содержащий URL-адреса страниц, к которым осуществляется доступ на веб-сайте. Столбец URL может получать изменения так же часто, но статистическое распределение его значений, вероятно, меняется относительно медленно.</target>
        </trans-unit>
        <trans-unit id="25d8d489832d7110fbb67ed9e2a0a908cb5a5e5d" translate="yes" xml:space="preserve">
          <source>As you can see, in this skeleton we're dealing with a data type where &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt;. It's easy enough to support data types where this is not the case, by implementing the proper union algorithm in this GiST support method.</source>
          <target state="translated">Как видите, в этом скелете мы имеем дело с типом данных, в котором &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt; . Достаточно просто поддерживать типы данных там, где это не так, путем реализации правильного алгоритма объединения в этом методе поддержки GiST.</target>
        </trans-unit>
        <trans-unit id="bf9aec8aa0de7661a07d98a75f47c3b69757e7a1" translate="yes" xml:space="preserve">
          <source>As you see, pg_dump writes its result to the standard output. We will see below how this can be useful. While the above command creates a text file, pg_dump can create files in other formats that allow for parallelism and more fine-grained control of object restoration.</source>
          <target state="translated">Как видите,pg_dump записывает свой результат в стандартный вывод.Ниже мы увидим,как это может быть полезно.В то время как вышеприведенная команда создает текстовый файл,pg_dump может создавать файлы других форматов,которые допускают параллельность и более тонкий контроль над восстановлением объекта.</target>
        </trans-unit>
        <trans-unit id="21e1923806603d461ddac0e0413cc2a388550aac" translate="yes" xml:space="preserve">
          <source>As you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key word &lt;code&gt;CHECK&lt;/code&gt; followed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense.</source>
          <target state="translated">Как видите, определение ограничения идет после типа данных, как и определения значений по умолчанию. Значения по умолчанию и ограничения могут быть перечислены в любом порядке. Контрольное ограничение состоит из ключевого слова &lt;code&gt;CHECK&lt;/code&gt; , за которым следует выражение в круглых скобках. Выражение ограничения проверки должно включать столбец, ограниченный таким образом, иначе ограничение не имело бы особого смысла.</target>
        </trans-unit>
        <trans-unit id="d1b9d2baec69327019075ccf63fb47f3a04b6635" translate="yes" xml:space="preserve">
          <source>As you see, the expression for the new value can refer to the existing value(s) in the row. We also left out the &lt;code&gt;WHERE&lt;/code&gt; clause. If it is omitted, it means that all rows in the table are updated. If it is present, only those rows that match the &lt;code&gt;WHERE&lt;/code&gt; condition are updated. Note that the equals sign in the &lt;code&gt;SET&lt;/code&gt; clause is an assignment while the one in the &lt;code&gt;WHERE&lt;/code&gt; clause is a comparison, but this does not create any ambiguity. Of course, the &lt;code&gt;WHERE&lt;/code&gt; condition does not have to be an equality test. Many other operators are available (see &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;). But the expression needs to evaluate to a Boolean result.</source>
          <target state="translated">Как видите, выражение для нового значения может относиться к существующим значениям в строке. Мы также &lt;code&gt;WHERE&lt;/code&gt; предложение WHERE . Если он не указан, это означает, что все строки в таблице обновлены. Если он присутствует, обновляются только те строки, которые соответствуют условию &lt;code&gt;WHERE&lt;/code&gt; . Обратите внимание, что знак равенства в предложении &lt;code&gt;SET&lt;/code&gt; является присваиванием, а знак равенства в предложении &lt;code&gt;WHERE&lt;/code&gt; - сравнением, но это не создает никакой двусмысленности. Конечно, условие &lt;code&gt;WHERE&lt;/code&gt; не обязательно должно быть проверкой равенства. Доступны многие другие операторы (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Главу 9&lt;/a&gt; ). Но выражение должно давать логический результат.</target>
        </trans-unit>
        <trans-unit id="439358cf5e5d4c690518e4e11abfb19b1e44a30e" translate="yes" xml:space="preserve">
          <source>As you see, the expression for the new value can refer to the existing value(s) in the row. We also left out the &lt;code&gt;WHERE&lt;/code&gt; clause. If it is omitted, it means that all rows in the table are updated. If it is present, only those rows that match the &lt;code&gt;WHERE&lt;/code&gt; condition are updated. Note that the equals sign in the &lt;code&gt;SET&lt;/code&gt; clause is an assignment while the one in the &lt;code&gt;WHERE&lt;/code&gt; clause is a comparison, but this does not create any ambiguity. Of course, the &lt;code&gt;WHERE&lt;/code&gt; condition does not have to be an equality test. Many other operators are available (see &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;). But the expression needs to evaluate to a Boolean result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313a697ffb23a7210631919b2999246578e93b67" translate="yes" xml:space="preserve">
          <source>Aside from avoiding the time for the archiver or WAL sender to process the WAL data, doing this will actually make certain commands faster, because they are designed not to write WAL at all if &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt;. (They can guarantee crash safety more cheaply by doing an &lt;code&gt;fsync&lt;/code&gt; at the end than by writing WAL.) This applies to the following commands:</source>
          <target state="translated">Помимо избежать время архиватора или WAL отправителя для обработки данных WAL, делая это на самом деле сделать некоторые команды быстрее, потому что они предназначены не писать WAL вообще если &lt;code&gt;wal_level&lt;/code&gt; является &lt;code&gt;minimal&lt;/code&gt; . (Они могут гарантировать более дешевую защиту от сбоев, выполнив &lt;code&gt;fsync&lt;/code&gt; в конце, чем написав WAL.) Это применимо к следующим командам:</target>
        </trans-unit>
        <trans-unit id="b1744fb0dcc66faea0f0e11e29ee96bb68e2530a" translate="yes" xml:space="preserve">
          <source>Aside from avoiding the time for the archiver or WAL sender to process the WAL data, doing this will actually make certain commands faster, because they do not to write WAL at all if &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; and the current subtransaction (or top-level transaction) created or truncated the table or index they change. (They can guarantee crash safety more cheaply by doing an &lt;code&gt;fsync&lt;/code&gt; at the end than by writing WAL.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba62da50a0cd807fd06ac3427894951fdffc554f" translate="yes" xml:space="preserve">
          <source>Aside from preventing cycles, the array value is often useful in its own right as representing the &amp;ldquo;path&amp;rdquo; taken to reach any particular row.</source>
          <target state="translated">Помимо предотвращения циклов, значение массива часто полезно само по себе, поскольку оно представляет &amp;laquo;путь&amp;raquo;, пройденный для достижения любой конкретной строки.</target>
        </trans-unit>
        <trans-unit id="f08bd4c872560fdf37016b1456326d2f1f83a30c" translate="yes" xml:space="preserve">
          <source>Aside from the index's own internal consistency requirements, concurrent updates create issues about consistency between the parent table (the &lt;em&gt;heap&lt;/em&gt;) and the index. Because PostgreSQL separates accesses and updates of the heap from those of the index, there are windows in which the index might be inconsistent with the heap. We handle this problem with the following rules:</source>
          <target state="translated">Помимо собственных требований к внутренней согласованности индекса, одновременные обновления создают проблемы с согласованностью между родительской таблицей ( &lt;em&gt;кучей&lt;/em&gt; ) и индексом. Поскольку PostgreSQL отделяет доступы и обновления кучи от операций индекса, есть окна, в которых индекс может быть несовместим с кучей. Мы решаем эту проблему по следующим правилам:</target>
        </trans-unit>
        <trans-unit id="66acedea6ec5e6c71ffc128f764e1116af5e0326" translate="yes" xml:space="preserve">
          <source>Assign a literal constant default value for the column &lt;code&gt;name&lt;/code&gt;, arrange for the default value of column &lt;code&gt;did&lt;/code&gt; to be generated by selecting the next value of a sequence object, and make the default value of &lt;code&gt;modtime&lt;/code&gt; be the time at which the row is inserted:</source>
          <target state="translated">Назначение буквенного значения по умолчанию константы для столбца &lt;code&gt;name&lt;/code&gt; , организовать значение по умолчанию столбца &lt;code&gt;did&lt;/code&gt; , чтобы быть сгенерировано путем выбора следующего значения объекта последовательности, и сделать значение по умолчанию &lt;code&gt;modtime&lt;/code&gt; быть время , при котором вставляется строка:</target>
        </trans-unit>
        <trans-unit id="1bfbe2935df02c420c8e520ec3e42a7fba80f23c" translate="yes" xml:space="preserve">
          <source>Assigns the specified &lt;em&gt;&lt;code&gt;weight&lt;/code&gt;&lt;/em&gt; to each element of the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a4d3134c8b9723881f294a52dd576fc9852c4b" translate="yes" xml:space="preserve">
          <source>Assigns the specified &lt;em&gt;&lt;code&gt;weight&lt;/code&gt;&lt;/em&gt; to elements of the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt; that are listed in &lt;em&gt;&lt;code&gt;lexemes&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f079970016568a6988faea4629841a26d4520b05" translate="yes" xml:space="preserve">
          <source>Associated sort operator (zero if none)</source>
          <target state="translated">Ассоциированный оператор сортировки (ноль,если нет)</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="d530f867f7438d52f3d933c2185ee58e5795fb55" translate="yes" xml:space="preserve">
          <source>Assume a table like this:</source>
          <target state="translated">Назначьте такой стол:</target>
        </trans-unit>
        <trans-unit id="d62cfe7fee7bb0995d8fe897df02204b5ae94b18" translate="yes" xml:space="preserve">
          <source>Assume we have dumped a database called &lt;code&gt;mydb&lt;/code&gt; into a custom-format dump file:</source>
          <target state="translated">Предположим, мы сбросили базу данных с именем &lt;code&gt;mydb&lt;/code&gt; в файл дампа нестандартного формата:</target>
        </trans-unit>
        <trans-unit id="00714db2b04e92390b518c92e4ea170b71450adc" translate="yes" xml:space="preserve">
          <source>Assuming that there is a table called &lt;code&gt;table1&lt;/code&gt;, this command would retrieve all rows and all user-defined columns from &lt;code&gt;table1&lt;/code&gt;. (The method of retrieval depends on the client application. For example, the psql program will display an ASCII-art table on the screen, while client libraries will offer functions to extract individual values from the query result.) The select list specification &lt;code&gt;*&lt;/code&gt; means all columns that the table expression happens to provide. A select list can also select a subset of the available columns or make calculations using the columns. For example, if &lt;code&gt;table1&lt;/code&gt; has columns named &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; (and perhaps others) you can make the following query:</source>
          <target state="translated">Предполагая, что существует таблица с именем &lt;code&gt;table1&lt;/code&gt; , эта команда извлечет все строки и все определенные пользователем столбцы из &lt;code&gt;table1&lt;/code&gt; . (Метод получения зависит от клиентского приложения. Например, программа psql отобразит на экране таблицу ASCII-art, а клиентские библиотеки предложат функции для извлечения отдельных значений из результата запроса.) Спецификация списка выбора &lt;code&gt;*&lt;/code&gt; означает все столбцы, которые предоставляет табличное выражение. В списке выбора также можно выбрать подмножество доступных столбцов или выполнить вычисления с использованием столбцов. Например, если &lt;code&gt;table1&lt;/code&gt; имеет столбцы с именами &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; (и, возможно, другие) вы можете сделать следующий запрос:</target>
        </trans-unit>
        <trans-unit id="89e7e252c06bfdf34cb9f5a168b455ee141acee7" translate="yes" xml:space="preserve">
          <source>Async. MM Repl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a8e2732fbce126a0a797cdd1e90b4272d9f93c" translate="yes" xml:space="preserve">
          <source>Asynchronous Commit</source>
          <target state="translated">Асинхронный комитет</target>
        </trans-unit>
        <trans-unit id="1d15a4a3147c0af21cd5fba27008e02e7487f287" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O depends on an effective &lt;code&gt;posix_fadvise&lt;/code&gt; function, which some operating systems lack. If the function is not present then setting this parameter to anything but zero will result in an error. On some operating systems (e.g., Solaris), the function is present but does not actually do anything.</source>
          <target state="translated">Асинхронный ввод-вывод зависит от эффективной функции &lt;code&gt;posix_fadvise&lt;/code&gt; , которая отсутствует в некоторых операционных системах. Если функция отсутствует, установка для этого параметра любого значения, кроме нуля, приведет к ошибке. В некоторых операционных системах (например, Solaris) функция присутствует, но фактически ничего не делает.</target>
        </trans-unit>
        <trans-unit id="abb97da8205f09a691f99d2fcdea6f23dc61d65e" translate="yes" xml:space="preserve">
          <source>Asynchronous Multimaster Replication</source>
          <target state="translated">Асинхронная многомастерная репликация</target>
        </trans-unit>
        <trans-unit id="00b2ec7d525c7895ab7759ef95defc6c17d534cd" translate="yes" xml:space="preserve">
          <source>Asynchronous commit introduces the risk of data loss. There is a short time window between the report of transaction completion to the client and the time that the transaction is truly committed (that is, it is guaranteed not to be lost if the server crashes). Thus asynchronous commit should not be used if the client will take external actions relying on the assumption that the transaction will be remembered. As an example, a bank would certainly not use asynchronous commit for a transaction recording an ATM's dispensing of cash. But in many scenarios, such as event logging, there is no need for a strong guarantee of this kind.</source>
          <target state="translated">Асинхронный коммит вводит риск потери данных.Существует короткий промежуток времени между сообщением клиенту о завершении транзакции и тем временем,когда транзакция действительно совершается (то есть гарантируется,что она не будет потеряна,если сервер выйдет из строя).Таким образом,асинхронный коммит не следует использовать,если клиент будет предпринимать внешние действия,полагаясь на то,что транзакция будет запомнена.В качестве примера можно привести тот факт,что банк,безусловно,не будет использовать асинхронный коммит для записи транзакции выдачи наличных в банкомате.Но во многих сценариях,например,в протоколировании событий,нет необходимости в сильных гарантиях такого рода.</target>
        </trans-unit>
        <trans-unit id="d90c24d882782b103f7c8579885000885b06b013" translate="yes" xml:space="preserve">
          <source>Asynchronous commit provides behavior different from setting &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = off. &lt;code&gt;fsync&lt;/code&gt; is a server-wide setting that will alter the behavior of all transactions. It disables all logic within PostgreSQL that attempts to synchronize writes to different portions of the database, and therefore a system crash (that is, a hardware or operating system crash, not a failure of PostgreSQL itself) could result in arbitrarily bad corruption of the database state. In many scenarios, asynchronous commit provides most of the performance improvement that could be obtained by turning off &lt;code&gt;fsync&lt;/code&gt;, but without the risk of data corruption.</source>
          <target state="translated">Асинхронная фиксация обеспечивает поведение, отличное от настройки &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = off. &lt;code&gt;fsync&lt;/code&gt; - это общесерверная настройка, которая изменяет поведение всех транзакций. Он отключает всю логику в PostgreSQL, которая пытается синхронизировать записи в разные части базы данных, и поэтому сбой системы (то есть сбой оборудования или операционной системы, а не сбой самого PostgreSQL) может привести к сколь угодно плохому повреждению базы данных. штат. Во многих сценариях асинхронная фиксация обеспечивает большую часть повышения производительности, которое можно получить, отключив &lt;code&gt;fsync&lt;/code&gt; , но без риска повреждения данных.</target>
        </trans-unit>
        <trans-unit id="38108f139265527283b18b5d33c78a6ddd380598" translate="yes" xml:space="preserve">
          <source>At a more basic level, it is not clear that solving query optimization with a GA algorithm designed for TSP is appropriate. In the TSP case, the cost associated with any substring (partial tour) is independent of the rest of the tour, but this is certainly not true for query optimization. Thus it is questionable whether edge recombination crossover is the most effective mutation procedure.</source>
          <target state="translated">На более базовом уровне неясно,подходит ли решение задачи оптимизации запросов с помощью алгоритма GA,разработанного для ТСП.В случае TSP стоимость,связанная с любой подстрокой (частичный тур),не зависит от остальной части тура,но для оптимизации запросов это,конечно,не так.Поэтому сомнительно,является ли кроссовер рекомбинации по краям наиболее эффективной процедурой мутации.</target>
        </trans-unit>
        <trans-unit id="4d29cf5673a23d613acb6f0d1c22f5f4b6b78fcf" translate="yes" xml:space="preserve">
          <source>At all times, PostgreSQL maintains a &lt;em&gt;write ahead log&lt;/em&gt; (WAL) in the &lt;code&gt;pg_wal/&lt;/code&gt; subdirectory of the cluster's data directory. The log records every change made to the database's data files. This log exists primarily for crash-safety purposes: if the system crashes, the database can be restored to consistency by &amp;ldquo;replaying&amp;rdquo; the log entries made since the last checkpoint. However, the existence of the log makes it possible to use a third strategy for backing up databases: we can combine a file-system-level backup with backup of the WAL files. If recovery is needed, we restore the file system backup and then replay from the backed-up WAL files to bring the system to a current state. This approach is more complex to administer than either of the previous approaches, but it has some significant benefits:</source>
          <target state="translated">PostgreSQL всегда ведет &lt;em&gt;журнал упреждающей записи&lt;/em&gt; (WAL) в &lt;code&gt;pg_wal/&lt;/code&gt; подкаталог каталога данных кластера. В журнал записываются все изменения, внесенные в файлы данных базы данных. Этот журнал существует в первую очередь для обеспечения безопасности при сбоях: в случае сбоя системы базу данных можно восстановить до согласованности путем &amp;laquo;воспроизведения&amp;raquo; записей журнала, сделанных с момента последней контрольной точки. Однако наличие журнала позволяет использовать третью стратегию резервного копирования баз данных: мы можем объединить резервное копирование на уровне файловой системы с резервным копированием файлов WAL. Если требуется восстановление, мы восстанавливаем резервную копию файловой системы, а затем воспроизводим ее из резервных копий файлов WAL, чтобы привести систему в текущее состояние. Этот подход сложнее в администрировании, чем любой из предыдущих подходов, но он имеет некоторые существенные преимущества:</target>
        </trans-unit>
        <trans-unit id="d0aa9f0f7a8b54305272b705ab4c8ce4332faa1e" translate="yes" xml:space="preserve">
          <source>At compile time, &lt;code&gt;transaction__start&lt;/code&gt; is converted to a macro called &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; (notice the underscores are single here), which is available by including &lt;code&gt;pg_trace.h&lt;/code&gt;. Add the macro call to the appropriate location in the source code. In this case, it looks like the following:</source>
          <target state="translated">Во время компиляции &lt;code&gt;transaction__start&lt;/code&gt; преобразуется в макрос под названием &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; (обратите внимание, что подчеркивания здесь одиночные), который доступен при включении &lt;code&gt;pg_trace.h&lt;/code&gt; . Добавьте вызов макроса в соответствующее место в исходном коде. В этом случае это выглядит так:</target>
        </trans-unit>
        <trans-unit id="1c05bc819458daf00162775e69bb6f11e3009ae1" translate="yes" xml:space="preserve">
          <source>At least as of version 5.1, it should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt;, as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</source>
          <target state="translated">По крайней мере, начиная с версии 5.1, нет необходимости выполнять какую-либо специальную настройку для таких параметров, как &lt;code&gt;SHMMAX&lt;/code&gt; , поскольку, похоже, это настроено так, чтобы вся память использовалась в качестве общей. Такая конфигурация обычно используется для других баз данных, таких как DB / 2.</target>
        </trans-unit>
        <trans-unit id="df036c0dc6f1685c583f36a683953e72b19d8691" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;LEFTARG&lt;/code&gt; and &lt;code&gt;RIGHTARG&lt;/code&gt; must be defined. For binary operators, both must be defined. For right unary operators, only &lt;code&gt;LEFTARG&lt;/code&gt; should be defined, while for left unary operators only &lt;code&gt;RIGHTARG&lt;/code&gt; should be defined.</source>
          <target state="translated">Должен быть определен хотя бы один из &lt;code&gt;LEFTARG&lt;/code&gt; и &lt;code&gt;RIGHTARG&lt;/code&gt; . Для бинарных операторов должны быть определены оба. Для унарных правых операторов следует определять только &lt;code&gt;LEFTARG&lt;/code&gt; , а для унарных левых операторов следует определять только &lt;code&gt;RIGHTARG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81523154b2540393f2eb08b2e64447cb44f3b4fa" translate="yes" xml:space="preserve">
          <source>At least one of the following options must be specified to select an action:</source>
          <target state="translated">Для выбора действия необходимо указать по крайней мере один из следующих вариантов:</target>
        </trans-unit>
        <trans-unit id="b72121826b7e4651c5d94f2436d0c7ffe3e3c260" translate="yes" xml:space="preserve">
          <source>At least one of these two things has to be ensured, or the PostgreSQL server will be very unreliable.</source>
          <target state="translated">По крайней мере,одна из этих двух вещей должна быть обеспечена,иначе сервер PostgreSQL будет очень ненадежен.</target>
        </trans-unit>
        <trans-unit id="1571c46302d3bf43b10096af00c294a218c61c85" translate="yes" xml:space="preserve">
          <source>At least one row per subscription, showing information about the subscription workers. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8eaf93cff7d6986839d33f973b6b2eb6f3e3612" translate="yes" xml:space="preserve">
          <source>At least one row per subscription, showing information about the subscription workers. See &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt; for details.</source>
          <target state="translated">По крайней мере, одна строка на подписку, показывающая информацию о сотрудниках подписки. Подробнее см. &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;Pg_stat_subscription&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d5c8007175669495e5c5ec2b3f06db9f4615159" translate="yes" xml:space="preserve">
          <source>At present, any table used as the target of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; must not have a conditional rule, nor an &lt;code&gt;ALSO&lt;/code&gt; rule, nor an &lt;code&gt;INSTEAD&lt;/code&gt; rule that expands to multiple statements.</source>
          <target state="translated">В настоящее время любая таблица, используемая в качестве цели оператора изменения данных в &lt;code&gt;WITH&lt;/code&gt; , не должна иметь ни условного правила, ни правила &lt;code&gt;ALSO&lt;/code&gt; , ни правила &lt;code&gt;INSTEAD&lt;/code&gt; , которое расширяется до нескольких операторов.</target>
        </trans-unit>
        <trans-unit id="ff0acb0e759b914c8ac0d92fbd4b06b6c52abe9f" translate="yes" xml:space="preserve">
          <source>At present, it's assumed that the sort order for an ordering operator is the default for the referenced operator family, i.e., &lt;code&gt;ASC NULLS LAST&lt;/code&gt;. This might someday be relaxed by adding additional columns to specify sort options explicitly.</source>
          <target state="translated">В настоящее время предполагается, что порядок сортировки для оператора упорядочения является значением по умолчанию для указанного семейства операторов, т. &lt;code&gt;ASC NULLS LAST&lt;/code&gt; . Когда-нибудь это можно будет смягчить, добавив дополнительные столбцы для явного указания параметров сортировки.</target>
        </trans-unit>
        <trans-unit id="0da87b74c1c3af23d284a826d817211a0d50dbca" translate="yes" xml:space="preserve">
          <source>At present, the &lt;code&gt;soundex&lt;/code&gt;, &lt;code&gt;metaphone&lt;/code&gt;, &lt;code&gt;dmetaphone&lt;/code&gt;, and &lt;code&gt;dmetaphone_alt&lt;/code&gt; functions do not work well with multibyte encodings (such as UTF-8).</source>
          <target state="translated">В настоящее время функции &lt;code&gt;soundex&lt;/code&gt; , &lt;code&gt;metaphone&lt;/code&gt; , &lt;code&gt;dmetaphone&lt;/code&gt; и &lt;code&gt;dmetaphone_alt&lt;/code&gt; не работают с многобайтовыми кодировками (такими как UTF-8).</target>
        </trans-unit>
        <trans-unit id="a78a49f80284f34a995726cc4689e41d04fb4798" translate="yes" xml:space="preserve">
          <source>At present, this setting is supported only on Linux and Windows. The setting is ignored on other systems when set to &lt;code&gt;try&lt;/code&gt;.</source>
          <target state="translated">В настоящее время этот параметр поддерживается только в Linux и Windows. В других системах эта настройка игнорируется, если задана &lt;code&gt;try&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="965d1f5ec334a9d95d86fe2f92675d08806b41f2" translate="yes" xml:space="preserve">
          <source>At startup, the standby begins by restoring all WAL available in the archive location, calling &lt;code&gt;restore_command&lt;/code&gt;. Once it reaches the end of WAL available there and &lt;code&gt;restore_command&lt;/code&gt; fails, it tries to restore any WAL available in the &lt;code&gt;pg_wal&lt;/code&gt; directory. If that fails, and streaming replication has been configured, the standby tries to connect to the primary server and start streaming WAL from the last valid record found in archive or &lt;code&gt;pg_wal&lt;/code&gt;. If that fails or streaming replication is not configured, or if the connection is later disconnected, the standby goes back to step 1 and tries to restore the file from the archive again. This loop of retries from the archive, &lt;code&gt;pg_wal&lt;/code&gt;, and via streaming replication goes on until the server is stopped or failover is triggered by a trigger file.</source>
          <target state="translated">При запуске резервный &lt;code&gt;restore_command&lt;/code&gt; с восстановления всего WAL, доступного в расположении архива, вызывая restore_command . Когда он достигает конца доступного там WAL и &lt;code&gt;restore_command&lt;/code&gt; завершается неудачно, он пытается восстановить любой WAL, доступный в каталоге &lt;code&gt;pg_wal&lt;/code&gt; . Если это не удается и потоковая репликация настроена, резервный пытается подключиться к первичному серверу и начать потоковую передачу WAL с последней действительной записи, найденной в архиве или &lt;code&gt;pg_wal&lt;/code&gt; . Если это не удается или потоковая репликация не настроена, или если соединение позже разрывается, резервный возвращается к шагу 1 и снова пытается восстановить файл из архива. Этот цикл повторных попыток из архива &lt;code&gt;pg_wal&lt;/code&gt; , а посредством потоковой репликации продолжается до тех пор, пока сервер не будет остановлен или аварийное переключение не будет запущено файлом триггера.</target>
        </trans-unit>
        <trans-unit id="55d8465dd064f760adc6de27f3c71c491c82a460" translate="yes" xml:space="preserve">
          <source>At the &lt;code&gt;REPEATABLE READ&lt;/code&gt; or &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction isolation level this would cause a serialization failure (with a &lt;code&gt;SQLSTATE&lt;/code&gt; of &lt;code&gt;'40001'&lt;/code&gt;), so there is no possibility of receiving rows out of order under these isolation levels.</source>
          <target state="translated">В &lt;code&gt;REPEATABLE READ&lt;/code&gt; или &lt;code&gt;SERIALIZABLE&lt;/code&gt; уровня изоляции транзакций это может привести к сбою сериализации (с &lt;code&gt;SQLSTATE&lt;/code&gt; из &lt;code&gt;'40001'&lt;/code&gt; ), так что нет никакой возможности получать строки из строя в соответствии с этими уровнями изоляции.</target>
        </trans-unit>
        <trans-unit id="f4f71998c9c0aa9a84a8100c70ee8a9266c4e5a9" translate="yes" xml:space="preserve">
          <source>At the beginning of the backup, a checkpoint needs to be performed on the source server. This can take some time (especially if the option &lt;code&gt;--checkpoint=fast&lt;/code&gt; is not used), during which pg_basebackup will appear to be idle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9934a1c03bcddc43aaddd8a50e8957f0b10bf33" translate="yes" xml:space="preserve">
          <source>At the beginning of the backup, a checkpoint needs to be written on the server the backup is taken from. Especially if the option &lt;code&gt;--checkpoint=fast&lt;/code&gt; is not used, this can take some time during which pg_basebackup will be appear to be idle.</source>
          <target state="translated">В начале резервного копирования необходимо записать контрольную точку на сервере, с которого берется резервная копия. В особенности, если параметр &lt;code&gt;--checkpoint=fast&lt;/code&gt; не используется, это может занять некоторое время, в течение которого pg_basebackup будет казаться неактивным.</target>
        </trans-unit>
        <trans-unit id="0a42b715d6522241c83704ed30aede2b52fb0a06" translate="yes" xml:space="preserve">
          <source>At the default &amp;ldquo;scale factor&amp;rdquo; of 1, the tables initially contain this many rows:</source>
          <target state="translated">При значении &amp;laquo;масштабного коэффициента&amp;raquo; по умолчанию, равном 1, таблицы изначально содержат такое количество строк:</target>
        </trans-unit>
        <trans-unit id="1c903746f8f0e8094ed1c641f98efb9a635313ed" translate="yes" xml:space="preserve">
          <source>At the end of each session, &lt;code&gt;UNLISTEN *&lt;/code&gt; is automatically executed.</source>
          <target state="translated">В конце каждого сеанса автоматически выполняется &lt;code&gt;UNLISTEN *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cd262012c4caf6374bfb34cbb6a915df644c90b" translate="yes" xml:space="preserve">
          <source>At the end of recovery, &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; held by prepared transactions will require twice the normal number of lock table entries. If you plan on running either a large number of concurrent prepared transactions that normally take &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, or you plan on having one large transaction that takes many &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, you are advised to select a larger value of &lt;code&gt;max_locks_per_transaction&lt;/code&gt;, perhaps as much as twice the value of the parameter on the primary server. You need not consider this at all if your setting of &lt;code&gt;max_prepared_transactions&lt;/code&gt; is 0.</source>
          <target state="translated">В конце восстановления &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; , удерживаемый подготовленными транзакциями, потребует вдвое больше обычного количества записей таблицы блокировок. Если вы планируете запускать большое количество параллельных подготовленных транзакций, которые обычно используют &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; , или вы планируете иметь одну большую транзакцию, которая требует много &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; , вам рекомендуется выбрать большее значение &lt;code&gt;max_locks_per_transaction&lt;/code&gt; , возможно, вдвое превышающее значение параметр на основном сервере. Вам вообще не нужно учитывать это, если ваш параметр &lt;code&gt;max_prepared_transactions&lt;/code&gt; равен 0.</target>
        </trans-unit>
        <trans-unit id="14547baffec9c8ba5963d60806059645bd69fca9" translate="yes" xml:space="preserve">
          <source>At the prompt, the user can type in SQL commands. Ordinarily, input lines are sent to the server when a command-terminating semicolon is reached. An end of line does not terminate a command. Thus commands can be spread over several lines for clarity. If the command was sent and executed without error, the results of the command are displayed on the screen.</source>
          <target state="translated">В строке запроса пользователь может вводить команды SQL.Обычно строки ввода отправляются на сервер при достижении точки с запятой,завершающей команду.Конец строки не завершает команду.Таким образом,для наглядности команды могут быть распределены по нескольким строкам.Если команда была отправлена и выполнена без ошибок,результаты команды отображаются на экране.</target>
        </trans-unit>
        <trans-unit id="a73b24b0f045657de48b1ab740f05e1e597825d0" translate="yes" xml:space="preserve">
          <source>At the same time, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; selects an extent of words in the second string. In the example above, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; would select the extent of a single word &lt;code&gt;'words'&lt;/code&gt;, whose set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;.</source>
          <target state="translated">В то же время &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; выбирает степень слов во второй строке. В приведенном выше примере &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; будет выбирать размер одного слова &lt;code&gt;'words'&lt;/code&gt; , чей набор триграмм равен &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1227060ad6250b9807827bf5fbb82f644935b87" translate="yes" xml:space="preserve">
          <source>At the same time, &lt;code&gt;strict_word_similarity&lt;/code&gt; selects an extent of words in the second string. In the example above, &lt;code&gt;strict_word_similarity&lt;/code&gt; would select the extent of a single word &lt;code&gt;'words'&lt;/code&gt;, whose set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416a07de78793e22bb0ac6ecdc4a78f4b476ae54" translate="yes" xml:space="preserve">
          <source>At the time of creation, all existing heap pages are scanned and a summary index tuple is created for each range, including the possibly-incomplete range at the end. As new pages are filled with data, page ranges that are already summarized will cause the summary information to be updated with data from the new tuples. When a new page is created that does not fall within the last summarized range, that range does not automatically acquire a summary tuple; those tuples remain unsummarized until a summarization run is invoked later, creating initial summaries. This process can be invoked manually using the &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; or &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; functions; automatically when &lt;code&gt;VACUUM&lt;/code&gt; processes the table; or by automatic summarization executed by autovacuum, as insertions occur. (This last trigger is disabled by default and can be enabled with the &lt;code&gt;autosummarize&lt;/code&gt; parameter.) Conversely, a range can be de-summarized using the &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; function, which is useful when the index tuple is no longer a very good representation because the existing values have changed.</source>
          <target state="translated">Во время создания все существующие страницы кучи сканируются, и для каждого диапазона создается сводный индексный кортеж, включая возможно неполный диапазон в конце. По мере того, как новые страницы заполняются данными, диапазоны страниц, которые уже суммированы, приведут к обновлению сводной информации данными из новых кортежей. Когда создается новая страница, которая не попадает в последний суммированный диапазон, этот диапазон не получает автоматически сводный кортеж; эти кортежи остаются несводными до тех пор, пока позже не будет вызван прогон суммирования, создающий начальные сводки. Этот процесс можно вызвать вручную с помощью &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; или &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; ; автоматически, когда &lt;code&gt;VACUUM&lt;/code&gt; обрабатывает стол; или автоматическим суммированием, выполняемым автовакуумом, когда происходит вставка. (Этот последний триггер отключен по умолчанию и может быть включен с &lt;code&gt;autosummarize&lt;/code&gt; параметра autosummarize .) И наоборот, диапазон можно &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; с помощью функции brin_desummarize_range (regclass, bigint) , которая полезна, когда индексный кортеж уже не очень хорош. представление, потому что существующие значения изменились.</target>
        </trans-unit>
        <trans-unit id="570ab49c8c4979d8f2b45f71407d683f61c768c4" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;pg_proc.dat&lt;/code&gt; has all three columns, &lt;code&gt;prokind&lt;/code&gt;, &lt;code&gt;proisagg&lt;/code&gt;, and &lt;code&gt;proiswindow&lt;/code&gt;, though they will appear only in rows where they have non-default values.</source>
          <target state="translated">На данный момент &lt;code&gt;pg_proc.dat&lt;/code&gt; имеет все три столбца: &lt;code&gt;prokind&lt;/code&gt; , &lt;code&gt;proisagg&lt;/code&gt; и &lt;code&gt;proiswindow&lt;/code&gt; , хотя они будут отображаться только в тех строках, в которых они имеют значения, отличные от значений по умолчанию.</target>
        </trans-unit>
        <trans-unit id="394da4678018ab888c36788be82e3560af3396a8" translate="yes" xml:space="preserve">
          <source>At this point, you will have an index on the &lt;code&gt;t&lt;/code&gt; column that you can use for similarity searching. A typical query is</source>
          <target state="translated">На этом этапе у вас будет индекс по столбцу &lt;code&gt;t&lt;/code&gt; , который вы можете использовать для поиска сходства. Типичный запрос</target>
        </trans-unit>
        <trans-unit id="2a3a5c5f47d6770989533a4fd46849cfebf7e2e9" translate="yes" xml:space="preserve">
          <source>At this writing, there are several limitations of the continuous archiving technique. These will probably be fixed in future releases:</source>
          <target state="translated">При этом этот написании есть несколько ограничений техники непрерывного хранения в архиве.Они,вероятно,будут исправлены в будущих выпусках:</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="f3023cb8188912c321e51f84008e15af7ab75428" translate="yes" xml:space="preserve">
          <source>Atomic</source>
          <target state="translated">Atomic</target>
        </trans-unit>
        <trans-unit id="7dfdf2c7a48eb8aa0595b9fdbbeea1555b65d328" translate="yes" xml:space="preserve">
          <source>Atomicity</source>
          <target state="translated">Atomicity</target>
        </trans-unit>
        <trans-unit id="cfaa3dc03c49871e78cddda27fc42c3f092dc0c4" translate="yes" xml:space="preserve">
          <source>Attach a comment to the table &lt;code&gt;mytable&lt;/code&gt;:</source>
          <target state="translated">Прикрепите комментарий к таблице &lt;code&gt;mytable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b30d15695b4486ee3edc48c2da787bd31caa82e5" translate="yes" xml:space="preserve">
          <source>Attaching a partition acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table, in addition to &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; locks on the table to be attached and on the default partition (if any).</source>
          <target state="translated">Присоединение раздела получает блокировку &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; для родительской таблицы в дополнение к блокировкам &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; для присоединяемой таблицы и раздела по умолчанию (если есть).</target>
        </trans-unit>
        <trans-unit id="d4f51e4421d7c33f901d2846a5f5963016f01207" translate="yes" xml:space="preserve">
          <source>Attempt to allow server crashes to produce core files, on platforms where this is possible, by lifting any soft resource limit placed on core files. This is useful in debugging or diagnosing problems by allowing a stack trace to be obtained from a failed server process.</source>
          <target state="translated">Попытка разрешить падение сервера для производства основных файлов,на платформах,где это возможно,путем снятия любого мягкого ограничения ресурсов,размещенных на основных файлах.Это полезно при отладке или диагностике проблем,позволяя получить трассировку стека из процесса отказа сервера.</target>
        </trans-unit>
        <trans-unit id="22d313995c5aa4824bbbe6a43fa47548d5dd9981" translate="yes" xml:space="preserve">
          <source>Attempt to insert a new stock item along with the quantity of stock. If the item already exists, instead update the stock count of the existing item. To do this without failing the entire transaction, use savepoints:</source>
          <target state="translated">Попытайтесь вставить новое складское изделие вместе с количеством,имеющимся на складе.Если изделие уже существует,вместо этого обновите количество имеющихся на складе.Чтобы сделать это,не упустив из виду всю операцию,используйте точки сохранения:</target>
        </trans-unit>
        <trans-unit id="77a267ab017550f3c7b55ed8bceaa27e998a453f" translate="yes" xml:space="preserve">
          <source>Attempt to terminate all existing connections to the target database before dropping it. See &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; for more information on this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918622fae6a483ce282b6f622cf8bcadbed1c7e1" translate="yes" xml:space="preserve">
          <source>Attempt to terminate all existing connections to the target database. It doesn't terminate if prepared transactions, active logical replication slots or subscriptions are present in the target database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76eb27398e988091546915b412edd431f3061249" translate="yes" xml:space="preserve">
          <source>Attempting to drop a table that does not exist is an error. Nevertheless, it is common in SQL script files to unconditionally try to drop each table before creating it, ignoring any error messages, so that the script works whether or not the table exists. (If you like, you can use the &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; variant to avoid the error messages, but this is not standard SQL.)</source>
          <target state="translated">Попытка удалить несуществующую таблицу является ошибкой. Тем не менее, в файлах сценария SQL обычно безоговорочно пытаются отбросить каждую таблицу перед ее созданием, игнорируя любые сообщения об ошибках, чтобы сценарий работал независимо от того, существует таблица или нет. (Если хотите, вы можете использовать вариант &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; , чтобы избежать сообщений об ошибках, но это не стандартный SQL.)</target>
        </trans-unit>
        <trans-unit id="a0d00292b426c90d6f3e1dbff7f81bbe2e552240" translate="yes" xml:space="preserve">
          <source>Attempting to enter a date using a mixture of ISO 8601 week-numbering fields and Gregorian date fields is nonsensical, and will cause an error. In the context of an ISO 8601 week-numbering year, the concept of a &amp;ldquo;month&amp;rdquo; or &amp;ldquo;day of month&amp;rdquo; has no meaning. In the context of a Gregorian year, the ISO week has no meaning.</source>
          <target state="translated">Попытка ввести дату с использованием сочетания полей нумерации недель ISO 8601 и полей даты по григорианскому календарю бессмысленна и приведет к ошибке. В контексте года с нумерацией недель ISO 8601 понятие &amp;laquo;месяц&amp;raquo; или &amp;laquo;день месяца&amp;raquo; не имеет значения. В контексте григорианского года неделя ISO не имеет значения.</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="c85e1c86ef58d9df3e2aa30f481d2a46d06ccc08" translate="yes" xml:space="preserve">
          <source>Attribute to match against the user name in the search when doing search+bind authentication. If no attribute is specified, the &lt;code&gt;uid&lt;/code&gt; attribute will be used.</source>
          <target state="translated">Атрибут для сопоставления с именем пользователя в поиске при выполнении аутентификации search + bind. Если атрибут не указан, будет использоваться атрибут &lt;code&gt;uid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="666a0c222579ebcb139d2bf4bc0c9f0b94222439" translate="yes" xml:space="preserve">
          <source>Attribute-level foreign data wrapper options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">Параметры оболочки сторонних данных на уровне атрибутов в виде строк &amp;laquo;ключевое слово = значение&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="81543c9a145dd6869d89d4e634466bddb425f66f" translate="yes" xml:space="preserve">
          <source>Attribute-level options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">Параметры уровня атрибута в виде строк &amp;laquo;ключевое слово = значение&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="75629af51d7c7f120dbb5b462013bfa48af33285" translate="yes" xml:space="preserve">
          <source>Aug</source>
          <target state="translated">Aug</target>
        </trans-unit>
        <trans-unit id="69d97c5797dc7d211aaa4e9229db5c8466d4edef" translate="yes" xml:space="preserve">
          <source>August</source>
          <target state="translated">August</target>
        </trans-unit>
        <trans-unit id="9ac07ce6cd52d678fbe1229a683f5eafa07e3b6a" translate="yes" xml:space="preserve">
          <source>Authenticate using SSL client certificates. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details.</source>
          <target state="translated">Выполните аутентификацию с помощью клиентских сертификатов SSL. См &lt;a href=&quot;auth-cert&quot;&gt;раздел 20.12&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="b62091287fb724791ca34488a0ab2a9fac4a1e4d" translate="yes" xml:space="preserve">
          <source>Authenticate using a RADIUS server. See &lt;a href=&quot;auth-radius&quot;&gt;Section 20.11&lt;/a&gt; for details.</source>
          <target state="translated">Выполните аутентификацию с помощью сервера RADIUS. См &lt;a href=&quot;auth-radius&quot;&gt;раздел 20.11&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="82054cdf870e919ceb8345be400ef8ccd343353b" translate="yes" xml:space="preserve">
          <source>Authenticate using an LDAP server. See &lt;a href=&quot;auth-ldap&quot;&gt;Section 20.10&lt;/a&gt; for details.</source>
          <target state="translated">Выполните аутентификацию с помощью сервера LDAP. См &lt;a href=&quot;auth-ldap&quot;&gt;раздел 20.10&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="55d3191d61e9daf8a3de6d8c5454a6099b6e7e03" translate="yes" xml:space="preserve">
          <source>Authenticate using the BSD Authentication service provided by the operating system. See &lt;a href=&quot;auth-bsd&quot;&gt;Section 20.14&lt;/a&gt; for details.</source>
          <target state="translated">Выполните аутентификацию с помощью службы аутентификации BSD, предоставляемой операционной системой. См &lt;a href=&quot;auth-bsd&quot;&gt;раздел 20.14&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="99ad70b6f56fd0c0d9729bfab969bd959ae5fb53" translate="yes" xml:space="preserve">
          <source>Authenticate using the Pluggable Authentication Modules (PAM) service provided by the operating system. See &lt;a href=&quot;auth-pam&quot;&gt;Section 20.13&lt;/a&gt; for details.</source>
          <target state="translated">Выполните аутентификацию с помощью службы подключаемых модулей аутентификации (PAM), предоставляемой операционной системой. См &lt;a href=&quot;auth-pam&quot;&gt;раздел 20.13&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="6ad4053a30971cdd0eca5d90cab892f9f383ba3e" translate="yes" xml:space="preserve">
          <source>Authentication Methods</source>
          <target state="translated">Методы аутентификации</target>
        </trans-unit>
        <trans-unit id="98fb3925f64e0642987c3e7beb38bbfbcaa16576" translate="yes" xml:space="preserve">
          <source>Authentication Problems</source>
          <target state="translated">Проблемы аутентификации</target>
        </trans-unit>
        <trans-unit id="bcf5b4f7c9dc716b472b6e8b3f05c043e93a5b63" translate="yes" xml:space="preserve">
          <source>Authentication failures and related problems generally manifest themselves through error messages like the following:</source>
          <target state="translated">Сбои при аутентификации и связанные с этим проблемы обычно проявляются в виде сообщений об ошибках,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="4a2641463bda57c970dcaba44cead46536e41155" translate="yes" xml:space="preserve">
          <source>Authentication method</source>
          <target state="translated">Метод аутентификации</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="ae017ff45a4a035cd29d47f616f68029f16fd0e1" translate="yes" xml:space="preserve">
          <source>Automatic Vacuuming</source>
          <target state="translated">Автоматическое вакуумирование</target>
        </trans-unit>
        <trans-unit id="7c977c91d67cb7d94506d78b8621aa22f728f9df" translate="yes" xml:space="preserve">
          <source>Automatic verification of the structural integrity of indexes plays a role in the general testing of new or proposed PostgreSQL features that could plausibly allow a logical inconsistency to be introduced. Verification of table structure and associated visibility and transaction status information plays a similar role. One obvious testing strategy is to call &lt;code&gt;amcheck&lt;/code&gt; functions continuously when running the standard regression tests. See &lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;Section 32.1&lt;/a&gt; for details on running the tests.</source>
          <target state="translated">Автоматическая проверка структурной целостности индексов играет роль в общем тестировании новых или предлагаемых функций PostgreSQL, которые могут допустить логическую несогласованность. Проверка структуры таблицы и связанной с ней информации о видимости и состоянии транзакции играет аналогичную роль. Одна из очевидных стратегий тестирования - непрерывный вызов функций &lt;code&gt;amcheck&lt;/code&gt; при выполнении стандартных регрессионных тестов. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;Раздел 32.1&lt;/a&gt; для подробностей о запуске тестов.</target>
        </trans-unit>
        <trans-unit id="dd9a137c5bedfde09ac590ac67aee8327d8ab3c7" translate="yes" xml:space="preserve">
          <source>Automatic verification of the structural integrity of indexes plays a role in the general testing of new or proposed PostgreSQL features that could plausibly allow a logical inconsistency to be introduced. Verification of table structure and associated visibility and transaction status information plays a similar role. One obvious testing strategy is to call &lt;code&gt;amcheck&lt;/code&gt; functions continuously when running the standard regression tests. See &lt;a href=&quot;https://www.postgresql.org/docs/13/regress-run.html&quot;&gt;Section 32.1&lt;/a&gt; for details on running the tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820a99cec2958e050680c6f99db97b790304fa53" translate="yes" xml:space="preserve">
          <source>Automatically drop objects (tables, functions, etc.) that are contained in the schema, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты (таблицы, функции и т.д.), содержащиеся в схеме, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7996658087a343e0aa2b3cf4b1db038fe35de48f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the access method (such as operator classes, operator families, and indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от метода доступа (такие как классы операторов, семейства операторов и индексы), и, в свою очередь, все объекты, зависящие от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="baccb8c23deca0c76a8a79a9c5f9953c38de8bc4" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the affected objects, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, которые зависят от затронутых объектов, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="38e895c6814216f5b3e9484010061f8b91dc249f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the aggregate function (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от функции агрегирования (например, использующие ее представления), и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="abc0b1d37273a9737a10dc3892acfa6c92fe5d93" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the collation, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически отбрасывать объекты, зависящие от сопоставления, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="745a5a5b00e94aac1eab4bd026b0c3eb4c8c446e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the constraint, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически отбрасывать объекты, зависящие от ограничения, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6ef4a74296e736f065e1732a22c73d138658014" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the domain (such as table columns), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от домена (например, столбцы таблицы), и, в свою очередь, все объекты, зависящие от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="660862c86777512d4fcfc8d0ae2ba2705d79fc1b" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, которые зависят от отброшенного столбца или ограничения (например, представления, ссылающиеся на столбец), и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ce7ac7937862e4e4126fdf7e2c5724e3de1e23e6" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the extension, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от расширения, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6bd522b5b8653034eb0b6145f2ce2e5dacb2cba0" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от сторонней таблицы (например, представления), и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a988e483f220bf7f0532dd68b502a2b7076edf0a" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign-data wrapper (such as foreign tables and servers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от оболочки сторонних данных (например, сторонние таблицы и серверы), и, в свою очередь, все объекты, зависящие от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e27007381181e414122b1ae56cdfd1a6d1dab2ad" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the function (such as operators or triggers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от функции (например, операторы или триггеры), и, в свою очередь, все объекты, зависящие от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1b9c92f0f554dcfb206e40bfd135fab8fe00e7e2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the index, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от индекса, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bcb27d2712f35ddb733c1f98ff51f21d7d424aaa" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the language (such as functions in the language), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от языка (например, функции на языке), и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2f6d0323ae070e0fb6a9170cf88c29d107b33c44" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the materialized view (such as other materialized views, or regular views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически отбрасывать объекты, которые зависят от материализованного представления (например, другие материализованные представления или обычные представления), и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf9e6848c526fa45713feaa1a3f98743157a4884" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически отбрасывать объекты, которые зависят от оператора (например, представления, использующие его), и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cbbaf53e6f678b4c8cf5eec8a71b6a7c2ee4f9ea" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator class (such as indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от класса операторов (например, индексы), и, в свою очередь, все объекты, зависящие от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eb5de09991d91e56b807fa44deb753015952ad1e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator family, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от семейства операторов, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e459a28af6e31c3e35e65f3a6c2487c577b6fa29" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the procedure, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от процедуры, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b0c32bf11160fbc2a809f14fb04d0b4471ad9003" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the rule, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически отбрасывать объекты, зависящие от правила, и, в свою очередь, все объекты, зависящие от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="de054c43bd92a23004c72d1888e8a17d538b0b78" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the sequence, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически отбрасывать объекты, которые зависят от последовательности, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bb69e1d5d516109b91608eb01c14e7c1738edbdf" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the server (such as user mappings), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от сервера (например, сопоставления пользователей), и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="40e6c61745089f774dd3e41d1dc840b568fe3b30" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически отбрасывать объекты, которые зависят от таблицы (например, представления), и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="53f104557d2e3eaa82997c5ded39fd7f6ba0b2a2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search configuration, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от конфигурации текстового поиска, и, в свою очередь, все объекты, зависящие от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c790e11a342e191d26db4cfa94c2202262cf7507" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search dictionary, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от словаря текстового поиска, и, в свою очередь, все объекты, зависящие от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ce0aa99a0b061d5935384944655cf0dc2b98983" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search parser, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически отбрасывать объекты, зависящие от парсера текстового поиска, и, в свою очередь, все объекты, зависящие от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="24a3aa8af1a85db5b902e0817649894b200120f5" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search template, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически отбрасывать объекты, зависящие от шаблона текстового поиска, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="52e34eb24e551596b0414271aef19a7a92f41187" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the transform, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от преобразования, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5430ece32ada38350ecf74986f0bbc942e6e3cfc" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the trigger, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически отбрасывать объекты, которые зависят от триггера, и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="946c18a9096115a846e5ed6451faa1e38fe8c835" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the type (such as table columns, functions, and operators), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от типа (такие как столбцы таблицы, функции и операторы), и, в свою очередь, все объекты, зависящие от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3d1c86e5f361718e066619a34ceb6e0c61659055" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the view (such as other views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">Автоматически удалять объекты, зависящие от представления (например, другие представления), и, в свою очередь, все объекты, которые зависят от этих объектов (см. &lt;a href=&quot;ddl-depend&quot;&gt;Раздел 5.14&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b54adcbf7578fd1e32a97c6d995480099f4e4ee" translate="yes" xml:space="preserve">
          <source>Automatically generate certain C code from SQL code. Currently, this works for &lt;code&gt;EXEC SQL TYPE&lt;/code&gt;.</source>
          <target state="translated">Автоматически генерировать определенный код C из кода SQL. В настоящее время это работает для &lt;code&gt;EXEC SQL TYPE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02a28684ac310395befcd622074bd92c8287b214" translate="yes" xml:space="preserve">
          <source>Automatically install any extensions that this extension depends on that are not already installed. Their dependencies are likewise automatically installed, recursively. The &lt;code&gt;SCHEMA&lt;/code&gt; clause, if given, applies to all extensions that get installed this way. Other options of the statement are not applied to automatically-installed extensions; in particular, their default versions are always selected.</source>
          <target state="translated">Автоматически устанавливайте все расширения, от которых зависит это расширение, которые еще не установлены. Их зависимости также устанавливаются автоматически, рекурсивно. Предложение &lt;code&gt;SCHEMA&lt;/code&gt; , если оно задано, применяется ко всем расширениям, которые устанавливаются таким образом. Другие параметры оператора не применяются к автоматически устанавливаемым расширениям; в частности, всегда выбираются их версии по умолчанию.</target>
        </trans-unit>
        <trans-unit id="82114421ee75a29b216b45460b9e22d194a04f14" translate="yes" xml:space="preserve">
          <source>Automatically propagate the operation to typed tables of the type being altered, and their descendants.</source>
          <target state="translated">Автоматически распространяет операцию на напечатанные таблицы изменяемого типа и их потомков.</target>
        </trans-unit>
        <trans-unit id="8cbbea802a2969bf6986433c47646c8510fbfd3b" translate="yes" xml:space="preserve">
          <source>Automatically restart sequences owned by columns of the truncated table(s).</source>
          <target state="translated">Автоматический перезапуск последовательностей,принадлежащих столбцам усеченной таблицы (таблиц).</target>
        </trans-unit>
        <trans-unit id="5642bfdf85a2050b70397bd1e7d1e3fa447f8560" translate="yes" xml:space="preserve">
          <source>Automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN.</source>
          <target state="translated">Автоматически останавливает репликацию и выходит с нормальным состоянием выхода 0,когда прием достигает указанного LSN.</target>
        </trans-unit>
        <trans-unit id="39275b6e09e38bef3ed571db2ef1da8d2f155a4e" translate="yes" xml:space="preserve">
          <source>Automatically truncate all tables that have foreign-key references to any of the named tables, or to any tables added to the group due to &lt;code&gt;CASCADE&lt;/code&gt;.</source>
          <target state="translated">Автоматически обрезать все таблицы, имеющие ссылки внешнего ключа на любую из названных таблиц или на любые таблицы, добавленные в группу из-за &lt;code&gt;CASCADE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e085180a439697544c8e28954b594a79f078a9d" translate="yes" xml:space="preserve">
          <source>Autovacuum (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b02d90144047f7b0ae09ab6bb39285e944deab" translate="yes" xml:space="preserve">
          <source>Autovacuum is not active during recovery. It will start normally at the end of recovery.</source>
          <target state="translated">Авто-вакуум не активен во время рекуперации.Обычно он начинается в конце восстановления.</target>
        </trans-unit>
        <trans-unit id="d7773c835487baf5b5c0ec83d176517e017c8f8a" translate="yes" xml:space="preserve">
          <source>Autovacuum worker or launcher waiting to update or read the current state of autovacuum workers.</source>
          <target state="translated">Работник автовакуума или пусковая установка ждет обновления или прочтения текущего состояния работников автовакуума.</target>
        </trans-unit>
        <trans-unit id="4aa1cd4d844c5afaaef04eccf35c0da21524cd29" translate="yes" xml:space="preserve">
          <source>Autovacuum workers generally don't block other commands. If a process attempts to acquire a lock that conflicts with the &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock held by autovacuum, lock acquisition will interrupt the autovacuum. For conflicting lock modes, see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;. However, if the autovacuum is running to prevent transaction ID wraparound (i.e., the autovacuum query name in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view ends with &lt;code&gt;(to prevent wraparound)&lt;/code&gt;), the autovacuum is not automatically interrupted.</source>
          <target state="translated">Рабочие автоочистки обычно не блокируют другие команды. Если процесс пытается получить блокировку, которая конфликтует с блокировкой &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; , удерживаемой автоочисткой, получение блокировки прервет автоочистку. Информацию о конфликтующих режимах блокировки см. В &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;таблице 13.2&lt;/a&gt; . Однако, если автоочистка выполняется для предотвращения зацикливания идентификатора транзакции (т. Е. Имя запроса автоочистки в представлении &lt;code&gt;pg_stat_activity&lt;/code&gt; заканчивается на &lt;code&gt;(to prevent wraparound)&lt;/code&gt; ), автоматическая очистка не прерывается автоматически.</target>
        </trans-unit>
        <trans-unit id="0edc11f659c78d515f96650dad0f6708f4c07fcc" translate="yes" xml:space="preserve">
          <source>Availability of WAL files claimed by this slot. Possible values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5a7bec123e69676856b9a816b4c6aef10e3a78" translate="yes" xml:space="preserve">
          <source>Available Client Character Sets</source>
          <target state="translated">Доступные наборы клиентских символов</target>
        </trans-unit>
        <trans-unit id="820b74a0a5297b8b6e88df74e84d5e81e977acf2" translate="yes" xml:space="preserve">
          <source>Available cipher suite details will vary across OpenSSL versions. Use the command &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; to see actual details for the currently installed OpenSSL version. Note that this list is filtered at run time based on the server key type.</source>
          <target state="translated">Доступные сведения о наборе шифров зависят от версии OpenSSL. Используйте команду &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; чтобы увидеть актуальные сведения об установленной в данный момент версии OpenSSL. Обратите внимание, что этот список фильтруется во время выполнения на основе типа ключа сервера.</target>
        </trans-unit>
        <trans-unit id="ba149cade6a0a4e50af1ecb3e25946c72c71094e" translate="yes" xml:space="preserve">
          <source>Average density of leaf pages</source>
          <target state="translated">Средняя плотность листовых страниц</target>
        </trans-unit>
        <trans-unit id="f099162f6d15d176bb9a41f82a80ea2cb1d18cf4" translate="yes" xml:space="preserve">
          <source>Average number of transactions that are executed per second, totaled across all sessions active for a measured run. This is used as a measure of the performance characteristics of an instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4903dacf2f00d069a2643728e3f02486ff810d77" translate="yes" xml:space="preserve">
          <source>Average width in bytes of column's entries</source>
          <target state="translated">Средняя ширина в байтах записей столбца</target>
        </trans-unit>
        <trans-unit id="3e9553fca4b719e6a36df1dda8f90b143771ffd9" translate="yes" xml:space="preserve">
          <source>B-Tree Indexes</source>
          <target state="translated">индексы B-дерева</target>
        </trans-unit>
        <trans-unit id="68486e8aa60ef6bf0ca374b07c2662a92ae24f27" translate="yes" xml:space="preserve">
          <source>B-Tree Support Functions</source>
          <target state="translated">Функции поддержки B-дерева</target>
        </trans-unit>
        <trans-unit id="717b6f33b42cc7559340881ecec59b687e47a41c" translate="yes" xml:space="preserve">
          <source>B-Tree deduplication is just as effective with &amp;ldquo;duplicates&amp;rdquo; that contain a NULL value, even though NULL values are never equal to each other according to the &lt;code&gt;=&lt;/code&gt; member of any B-Tree operator class. As far as any part of the implementation that understands the on-disk B-Tree structure is concerned, NULL is just another value from the domain of indexed values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bea9fad8fb62f91da10ba766f66a246a745ab74" translate="yes" xml:space="preserve">
          <source>B-Tree indexes are not directly aware that under MVCC, there might be multiple extant versions of the same logical table row; to an index, each tuple is an independent object that needs its own index entry. &amp;ldquo;Version duplicates&amp;rdquo; may sometimes accumulate and adversely affect query latency and throughput. This typically occurs with &lt;code&gt;UPDATE&lt;/code&gt;-heavy workloads where most individual updates cannot apply the HOT optimization (often because at least one indexed column gets modified, necessitating a new set of index tuple versions &amp;mdash; one new tuple for &lt;em&gt;each and every&lt;/em&gt; index). In effect, B-Tree deduplication ameliorates index bloat caused by version churn. Note that even the tuples from a unique index are not necessarily &lt;em&gt;physically&lt;/em&gt; unique when stored on disk due to version churn. The deduplication optimization is selectively applied within unique indexes. It targets those pages that appear to have version duplicates. The high level goal is to give &lt;code&gt;VACUUM&lt;/code&gt; more time to run before an &amp;ldquo;unnecessary&amp;rdquo; page split caused by version churn can take place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9504ad9e3e7718bba2e8ff2d49bd5578d047ea98" translate="yes" xml:space="preserve">
          <source>B-tree equivalent functionality for several data types</source>
          <target state="translated">Функциональность,эквивалентная B-дереву для нескольких типов данных</target>
        </trans-unit>
        <trans-unit id="905661856e09f20be385c26d6a37cee5d0959557" translate="yes" xml:space="preserve">
          <source>B-tree index over &lt;code&gt;ltree&lt;/code&gt;: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Индекс B-дерева над &lt;code&gt;ltree&lt;/code&gt; : &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdeef32a168111374c1be4cd04224fef89dc4b4b" translate="yes" xml:space="preserve">
          <source>B-tree index pages that have become completely empty are reclaimed for re-use. However, there is still a possibility of inefficient use of space: if all but a few index keys on a page have been deleted, the page remains allocated. Therefore, a usage pattern in which most, but not all, keys in each range are eventually deleted will see poor use of space. For such usage patterns, periodic reindexing is recommended.</source>
          <target state="translated">Полностью пустые страницы индекса B-дерева восстанавливаются для повторного использования.Однако существует вероятность неэффективного использования пространства:если все,кроме нескольких индексных ключей на странице,были удалены,то страница остается выделенной.Таким образом,схема использования,при которой большинство,но не все ключи в каждом диапазоне в конечном итоге удаляются,приведет к неэффективному использованию пробела.Для таких моделей использования рекомендуется периодическая реиндексация.</target>
        </trans-unit>
        <trans-unit id="065de2528617033a42220233cd1c35a251757908" translate="yes" xml:space="preserve">
          <source>B-tree indexes additionally accept this parameter:</source>
          <target state="translated">Индексы B-дерева дополнительно принимают этот параметр:</target>
        </trans-unit>
        <trans-unit id="4e65573a03a3b33fe194962539e298b25562884c" translate="yes" xml:space="preserve">
          <source>B-tree indexes also accept these parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33f3c038c507d02cde94014e083413eba3062f2" translate="yes" xml:space="preserve">
          <source>B-tree indexes can also be used to retrieve data in sorted order. This is not always faster than a simple scan and sort, but it is often helpful.</source>
          <target state="translated">Индексы B-дерева могут также использоваться для получения данных в отсортированном порядке.Это не всегда быстрее,чем простое сканирование и сортировка,но часто бывает полезно.</target>
        </trans-unit>
        <trans-unit id="c1aa64fe8a588b4b8c3bb44a5ae5f195209958ec" translate="yes" xml:space="preserve">
          <source>B-tree version number</source>
          <target state="translated">номер версии B-дерева</target>
        </trans-unit>
        <trans-unit id="ee82358aad15ad2f88908ab7225b36322cd1065a" translate="yes" xml:space="preserve">
          <source>B-tree, GiST and SP-GiST indexes</source>
          <target state="translated">B-дерево,индексы GiST и SP-GiST</target>
        </trans-unit>
        <trans-unit id="16921be12274c9c7c84517bda5d89a5ff3df5941" translate="yes" xml:space="preserve">
          <source>B-trees can handle equality and range queries on data that can be sorted into some ordering. In particular, the PostgreSQL query planner will consider using a B-tree index whenever an indexed column is involved in a comparison using one of these operators:</source>
          <target state="translated">B-деревья могут обрабатывать запросы на равенство и диапазон данных,которые могут быть отсортированы в некоторый порядок.В частности,планировщик запросов PostgreSQL будет рассматривать возможность использования индекса B-дерева всякий раз,когда индексируемый столбец участвует в сравнении с помощью одного из этих операторов:</target>
        </trans-unit>
        <trans-unit id="90fe59b25bb93f64682a57a1af270b45d31afdca" translate="yes" xml:space="preserve">
          <source>B.1. Date/Time Input Interpretation</source>
          <target state="translated">B.1.Интерпретация даты/входа/времени</target>
        </trans-unit>
        <trans-unit id="9899d2230f4a93f14e01b57b593ac9983fb8a83d" translate="yes" xml:space="preserve">
          <source>B.2. Handling of Invalid or Ambiguous Timestamps</source>
          <target state="translated">B.2 Обработка недействительных или неоднозначных временных меток</target>
        </trans-unit>
        <trans-unit id="3840db4e415d986c6609f0316669636755ab2262" translate="yes" xml:space="preserve">
          <source>B.3. Date/Time Key Words</source>
          <target state="translated">B.3.Дата/время Ключевые слова</target>
        </trans-unit>
        <trans-unit id="922ab4c02bf090b11d909a4d188dbe702c610716" translate="yes" xml:space="preserve">
          <source>B.4. Date/Time Configuration Files</source>
          <target state="translated">B.4.Файлы конфигурации даты/времени</target>
        </trans-unit>
        <trans-unit id="58922b284be009208c01702b42070c1a181d5b29" translate="yes" xml:space="preserve">
          <source>B.5. History of Units</source>
          <target state="translated">B.5.История Единиц</target>
        </trans-unit>
        <trans-unit id="9355cc4eed5770d5dfbba1271ff86061632e7258" translate="yes" xml:space="preserve">
          <source>B.5. POSIX Time Zone Specifications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc2d5b79639788bc98e2a3a622f6560e3933f91" translate="yes" xml:space="preserve">
          <source>B.6. History of Units</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="e87cf2c2aaae478fefafcf671d30d2bd91ab190c" translate="yes" xml:space="preserve">
          <source>BEGIN &amp;mdash; start a transaction block</source>
          <target state="translated">BEGIN - начать блокировку транзакции</target>
        </trans-unit>
        <trans-unit id="e3b1705472dc241e491b245a0698901129b83705" translate="yes" xml:space="preserve">
          <source>BIGNUM math</source>
          <target state="translated">бигнум математика</target>
        </trans-unit>
        <trans-unit id="c7854587bf0a26f0dd0236c46e64d140a0d9aa2a" translate="yes" xml:space="preserve">
          <source>BKI</source>
          <target state="translated">BKI</target>
        </trans-unit>
        <trans-unit id="a8e02c60c1fbe70ac08216f4d50adb47cd1b1f47" translate="yes" xml:space="preserve">
          <source>BREs differ from EREs in several respects. In BREs, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;?&lt;/code&gt; are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are &lt;code&gt;\{&lt;/code&gt; and &lt;code&gt;\}&lt;/code&gt;, with &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; by themselves ordinary characters. The parentheses for nested subexpressions are &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt;, with &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; by themselves ordinary characters. &lt;code&gt;^&lt;/code&gt; is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, &lt;code&gt;$&lt;/code&gt; is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and &lt;code&gt;*&lt;/code&gt; is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading &lt;code&gt;^&lt;/code&gt;). Finally, single-digit back references are available, and &lt;code&gt;\&amp;lt;&lt;/code&gt; and &lt;code&gt;\&amp;gt;&lt;/code&gt; are synonyms for &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; respectively; no other escapes are available in BREs.</source>
          <target state="translated">BRE отличаются от ERE по нескольким параметрам. В BREs, &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;?&lt;/code&gt; являются обычными символами и не имеют эквивалента по функциональности. Разделителями для границ являются &lt;code&gt;\{&lt;/code&gt; и &lt;code&gt;\}&lt;/code&gt; , с обычными символами &lt;code&gt;{&lt;/code&gt; и &lt;code&gt;}&lt;/code&gt; . Скобки для вложенных подвыражений - это &lt;code&gt;\(&lt;/code&gt; и &lt;code&gt;\)&lt;/code&gt; , с &lt;code&gt;(&lt;/code&gt; и &lt;code&gt;)&lt;/code&gt; сами по себе обычные символы. &lt;code&gt;^&lt;/code&gt; - это обычный символ, за исключением начала RE или начала подвыражения в скобках, &lt;code&gt;$&lt;/code&gt; является обычным символом, за исключением конца RE или конца заключенного в скобки подвыражения, а &lt;code&gt;*&lt;/code&gt; является обычным символом, если он появляется в начале RE или начале заключенного в скобки подвыражения (после возможного ведущего символа &lt;code&gt;^&lt;/code&gt; ). Наконец, доступны однозначные обратные ссылки, а &lt;code&gt;\&amp;lt;&lt;/code&gt; и &lt;code&gt;\&amp;gt;&lt;/code&gt; являются синонимами для &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; и &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; соответственно; в BRE нет других экранирований.</target>
        </trans-unit>
        <trans-unit id="b45363f80402fee41de7af6a2bc3803bd8fcc804" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Built-in Operator Classes</source>
          <target state="translated">Индексы БРИН:Встроенные классы операторов</target>
        </trans-unit>
        <trans-unit id="610805949da9a921d5d35ddef0174271633dc849" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Extensibility</source>
          <target state="translated">Индексы БРИН:Расширяемость</target>
        </trans-unit>
        <trans-unit id="e9ea37807ed02774eb4219265e764033548569ae" translate="yes" xml:space="preserve">
          <source>BRIN indexes (a shorthand for Block Range INdexes) store summaries about the values stored in consecutive physical block ranges of a table. Like GiST, SP-GiST and GIN, BRIN can support many different indexing strategies, and the particular operators with which a BRIN index can be used vary depending on the indexing strategy. For data types that have a linear sort order, the indexed data corresponds to the minimum and maximum values of the values in the column for each block range. This supports indexed queries using these operators:</source>
          <target state="translated">BRIN-индексы (сокращение от Block Range INdexes)хранят сводки о значениях,хранящихся в последовательных физических диапазонах блоков таблицы.Как и GiST,SP-GiST и GIN,BRIN может поддерживать множество различных стратегий индексации,а конкретные операторы,с которыми можно использовать индекс BRIN,отличаются в зависимости от стратегии индексации.Для типов данных,имеющих линейный порядок сортировки,индексированные данные соответствуют минимальным и максимальным значениям значений в столбце для каждого диапазона блоков.Это поддерживает индексированные запросы с использованием этих операторов:</target>
        </trans-unit>
        <trans-unit id="192104c1f501554301510ea5a728a13a08ab43a4" translate="yes" xml:space="preserve">
          <source>BRIN indexes accept different parameters:</source>
          <target state="translated">BRIN-индексы принимают различные параметры:</target>
        </trans-unit>
        <trans-unit id="b838c564f224f8b8543683d11eed0d0437e44e11" translate="yes" xml:space="preserve">
          <source>BRIN indexes can satisfy queries via regular bitmap index scans, and will return all tuples in all pages within each range if the summary info stored by the index is &lt;em&gt;consistent&lt;/em&gt; with the query conditions. The query executor is in charge of rechecking these tuples and discarding those that do not match the query conditions &amp;mdash; in other words, these indexes are lossy. Because a BRIN index is very small, scanning the index adds little overhead compared to a sequential scan, but may avoid scanning large parts of the table that are known not to contain matching tuples.</source>
          <target state="translated">Индексы BRIN могут удовлетворять запросы посредством регулярного сканирования индекса растрового изображения и возвращают все кортежи на всех страницах в каждом диапазоне, если сводная информация, хранимая индексом, &lt;em&gt;соответствует&lt;/em&gt; условиям запроса. Исполнитель запроса отвечает за повторную проверку этих кортежей и отбрасывание тех, которые не соответствуют условиям запроса - другими словами, эти индексы с потерями. Поскольку индекс BRIN очень мал, сканирование индекса добавляет небольшие накладные расходы по сравнению с последовательным сканированием, но может избежать сканирования больших частей таблицы, которые, как известно, не содержат совпадающих кортежей.</target>
        </trans-unit>
        <trans-unit id="55b3c9c4efac0d4d71eaa3d4c8cc93a475582a37" translate="yes" xml:space="preserve">
          <source>BRIN stands for Block Range Index. BRIN is designed for handling very large tables in which certain columns have some natural correlation with their physical location within the table. A &lt;em&gt;block range&lt;/em&gt; is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index. For example, a table storing a store's sale orders might have a date column on which each order was placed, and most of the time the entries for earlier orders will appear earlier in the table as well; a table storing a ZIP code column might have all codes for a city grouped together naturally.</source>
          <target state="translated">BRIN расшифровывается как Block Range Index. BRIN предназначен для работы с очень большими таблицами, в которых определенные столбцы имеют естественную корреляцию с их физическим расположением в таблице. &lt;em&gt;Диапазон блок&lt;/em&gt; представляет собой группу страниц, которые физически смежными в таблице; для каждого диапазона блоков некоторая сводная информация хранится в индексе. Например, таблица, в которой хранятся заказы на продажу магазина, может иметь столбец даты, в который был размещен каждый заказ, и большую часть времени записи для более ранних заказов также будут раньше появляться в таблице; таблица, в которой хранится столбец почтового индекса, может содержать все коды городов, естественно сгруппированные вместе.</target>
        </trans-unit>
        <trans-unit id="c5bca0a807cb4e3535b6c51a06c3bccf47631d7c" translate="yes" xml:space="preserve">
          <source>BSD Authentication</source>
          <target state="translated">аутентификация BSD</target>
        </trans-unit>
        <trans-unit id="f1a97c299183923139e5920b8bda3da33aa50cdf" translate="yes" xml:space="preserve">
          <source>BSD Authentication in PostgreSQL uses the &lt;code&gt;auth-postgresql&lt;/code&gt; login type and authenticates with the &lt;code&gt;postgresql&lt;/code&gt; login class if that's defined in &lt;code&gt;login.conf&lt;/code&gt;. By default that login class does not exist, and PostgreSQL will use the default login class.</source>
          <target state="translated">Аутентификация BSD в PostgreSQL использует тип входа &lt;code&gt;auth-postgresql&lt;/code&gt; и аутентифицируется с помощью класса входа &lt;code&gt;postgresql&lt;/code&gt; , если он определен в &lt;code&gt;login.conf&lt;/code&gt; . По умолчанию этот класс входа в систему не существует, и PostgreSQL будет использовать класс входа по умолчанию.</target>
        </trans-unit>
        <trans-unit id="eebf5442eb861b0130ab1dbae1411845a2d52d61" translate="yes" xml:space="preserve">
          <source>Backend (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99affebb8bc98ca77c8c04882ebec0dea90a3114" translate="yes" xml:space="preserve">
          <source>Backend Interface</source>
          <target state="translated">внутренний интерфейс</target>
        </trans-unit>
        <trans-unit id="328769872d8232ec584540b9757369093134e160" translate="yes" xml:space="preserve">
          <source>Backend type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc32da7c82d0789e65952daa2c9def14b3058549" translate="yes" xml:space="preserve">
          <source>Background worker (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b848315d26f8ea5458744e8623f2ff6b2080f8c1" translate="yes" xml:space="preserve">
          <source>Background writer (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f8490b7625580e80d17d5a1df23b1d4de6ebc4" translate="yes" xml:space="preserve">
          <source>Backslash &lt;code&gt;x&lt;/code&gt; followed by one or two hex digits specifies the character with that numeric code</source>
          <target state="translated">Обратная косая черта &lt;code&gt;x&lt;/code&gt; , за которой следует одна или две шестнадцатеричные цифры, указывает символ с этим числовым кодом.</target>
        </trans-unit>
        <trans-unit id="f71436b4e34992baf3c146d9f7bcd610fe7bd64e" translate="yes" xml:space="preserve">
          <source>Backslash Escape Sequence</source>
          <target state="translated">Последовательность бегства задом наперёд</target>
        </trans-unit>
        <trans-unit id="08da95faebff9b822ea5284de54543cc7bd092f0" translate="yes" xml:space="preserve">
          <source>Backslash characters (&lt;code&gt;\&lt;/code&gt;) can be used in the &lt;code&gt;COPY&lt;/code&gt; data to quote data characters that might otherwise be taken as row or column delimiters. In particular, the following characters &lt;em&gt;must&lt;/em&gt; be preceded by a backslash if they appear as part of a column value: backslash itself, newline, carriage return, and the current delimiter character.</source>
          <target state="translated">Символы обратной косой черты ( &lt;code&gt;\&lt;/code&gt; ) можно использовать в данных &lt;code&gt;COPY&lt;/code&gt; чтобы заключить в кавычки символы данных, которые в противном случае могли бы использоваться как разделители строк или столбцов. В частности, следующим символам &lt;em&gt;должна&lt;/em&gt; предшествовать обратная косая черта, если они появляются как часть значения столбца: сама обратная косая черта, новая строка, возврат каретки и текущий символ-разделитель.</target>
        </trans-unit>
        <trans-unit id="79f7f8eb79d3eb20be7d5f2fdb2c6cb1e00c749f" translate="yes" xml:space="preserve">
          <source>Backslash followed by one to three octal digits specifies the character with that numeric code</source>
          <target state="translated">Обратная косая черта,за которой следуют от одной до трех восьмеричных цифр,определяет символ с таким цифровым кодом.</target>
        </trans-unit>
        <trans-unit id="7b77925a9192b55418069493a221c26ff154c448" translate="yes" xml:space="preserve">
          <source>Backslash-semicolon is not a meta-command in the same way as the preceding commands; rather, it simply causes a semicolon to be added to the query buffer without any further processing.</source>
          <target state="translated">Обратная косая черта с точкой с запятой-это не мета-команда,как в предыдущих командах,а просто точка с запятой добавляется в буфер запроса без дальнейшей обработки.</target>
        </trans-unit>
        <trans-unit id="3415ee42fbdf165d3ab63673dafeffa9121924ae" translate="yes" xml:space="preserve">
          <source>Backspace (ASCII 8)</source>
          <target state="translated">Заднее пространство (ASCII 8)</target>
        </trans-unit>
        <trans-unit id="ee100250b3b61b298848fb969f8f888fd07a7761" translate="yes" xml:space="preserve">
          <source>Backtrace support is not available on all platforms, and the quality of the backtraces depends on compilation options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d331ac3f1a6cac9c6991fe1fa25efc25e1bcefe8" translate="yes" xml:space="preserve">
          <source>Backup Manifest File Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379196baf790f4b6fa0825b0de670c43e08df23a" translate="yes" xml:space="preserve">
          <source>Backup Manifest Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c6cad75143d38691a0caaf6de1d84dce170459" translate="yes" xml:space="preserve">
          <source>Backup Manifest Top-level Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e141d2d8691eaa6fba3c4489c0fc0d8b0d463b66" translate="yes" xml:space="preserve">
          <source>Backup Manifest WAL Range Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5932464fe7ee7685cdde1f28a54e89455da1784" translate="yes" xml:space="preserve">
          <source>Backup and Restore</source>
          <target state="translated">Резервное копирование и восстановление</target>
        </trans-unit>
        <trans-unit id="171ec47bee8f29611873a226142872b637cc0954" translate="yes" xml:space="preserve">
          <source>Backup verification proceeds in four stages. First, &lt;code&gt;pg_verifybackup&lt;/code&gt; reads the &lt;code&gt;backup_manifest&lt;/code&gt; file. If that file does not exist, cannot be read, is malformed, or fails verification against its own internal checksum, &lt;code&gt;pg_verifybackup&lt;/code&gt; will terminate with a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e2f1a9ee8c86cb8243f522b50b65e6423c34d6" translate="yes" xml:space="preserve">
          <source>Backward compatibility syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">Синтаксис обратной совместимости для удаления системного столбца &lt;code&gt;oid&lt;/code&gt; . Поскольку системные столбцы &lt;code&gt;oid&lt;/code&gt; больше не могут быть добавлены, это никогда не влияет.</target>
        </trans-unit>
        <trans-unit id="3ea614d7d0d66375e7b59ad1603ddbf9c6954a56" translate="yes" xml:space="preserve">
          <source>Backward fetches are also disallowed when the query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;; therefore &lt;code&gt;SCROLL&lt;/code&gt; may not be specified in this case.</source>
          <target state="translated">Обратные выборки также запрещены, если запрос включает &lt;code&gt;FOR UPDATE&lt;/code&gt; или &lt;code&gt;FOR SHARE&lt;/code&gt; ; поэтому в этом случае нельзя указывать &lt;code&gt;SCROLL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92077d51292270928790f0d07fb2a1301d60ee31" translate="yes" xml:space="preserve">
          <source>Backward-compatible syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">Обратно совместимый синтаксис для удаления системного столбца &lt;code&gt;oid&lt;/code&gt; . Поскольку системные столбцы &lt;code&gt;oid&lt;/code&gt; больше не могут быть добавлены, это никогда не влияет.</target>
        </trans-unit>
        <trans-unit id="044409ea2cd85fda028f96eed9a84a9fcc920931" translate="yes" xml:space="preserve">
          <source>Baltic</source>
          <target state="translated">Baltic</target>
        </trans-unit>
        <trans-unit id="485c014f257e394c215c16b50018b7e0c80f4130" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9f28dd05a6a2df955f43acccdc39e58fea4d0c" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm (same as &lt;code&gt;log&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">Базовые Типы</target>
        </trans-unit>
        <trans-unit id="7d67a1e0565652b8a1f39922bf439ec06adfe28a" translate="yes" xml:space="preserve">
          <source>Basically a thesaurus dictionary replaces all non-preferred terms by one preferred term and, optionally, preserves the original terms for indexing as well. PostgreSQL's current implementation of the thesaurus dictionary is an extension of the synonym dictionary with added &lt;em&gt;phrase&lt;/em&gt; support. A thesaurus dictionary requires a configuration file of the following format:</source>
          <target state="translated">В основном словарь тезауруса заменяет все нежелательные термины одним предпочтительным термином и, при необходимости, сохраняет исходные термины для индексации. Текущая реализация словаря тезауруса в PostgreSQL является расширением словаря синонимов с добавленной поддержкой &lt;em&gt;фраз&lt;/em&gt; . Для словаря тезауруса требуется файл конфигурации следующего формата:</target>
        </trans-unit>
        <trans-unit id="e1ddc988e6d784f9a638904386d7cd96020404d0" translate="yes" xml:space="preserve">
          <source>Batching WAL files so that they are transferred every three hours, rather than one at a time</source>
          <target state="translated">Пакетирование файлов WAL таким образом,чтобы они передавались каждые три часа,а не по одному.</target>
        </trans-unit>
        <trans-unit id="56ac908a2429c8b6f57e6b53eb261c2b37853b9f" translate="yes" xml:space="preserve">
          <source>Be aware however that such a query will be very inefficient.</source>
          <target state="translated">Однако имейте в виду,что такой запрос будет очень неэффективным.</target>
        </trans-unit>
        <trans-unit id="dd8576c5e404ad1333289b223aeb849843ea4d63" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;COPY&lt;/code&gt; ignores rules. If you want to use &lt;code&gt;COPY&lt;/code&gt; to insert data, you'll need to copy into the correct child table rather than directly into the master. &lt;code&gt;COPY&lt;/code&gt; does fire triggers, so you can use it normally if you use the trigger approach.</source>
          <target state="translated">Имейте в виду, что &lt;code&gt;COPY&lt;/code&gt; игнорирует правила. Если вы хотите использовать &lt;code&gt;COPY&lt;/code&gt; для вставки данных, вам нужно будет скопировать в правильную дочернюю таблицу, а не непосредственно в главную. &lt;code&gt;COPY&lt;/code&gt; запускает триггеры, поэтому вы можете использовать его как обычно, если используете подход триггера.</target>
        </trans-unit>
        <trans-unit id="3ec6516cf2acdacef6ec02909f23a042de655757" translate="yes" xml:space="preserve">
          <source>Be careful that the names and types of the view's columns will be assigned the way you want. For example:</source>
          <target state="translated">Будьте осторожны,чтобы названия и типы столбцов вида назначались так,как вы хотите.Например:</target>
        </trans-unit>
        <trans-unit id="2ecd0bd78d58da0c631755bb828f27e267549d1c" translate="yes" xml:space="preserve">
          <source>Be careful to specify the schema in which you installed the existing &lt;code&gt;hstore&lt;/code&gt; objects.</source>
          <target state="translated">Будьте внимательны при указании схемы, в которой вы установили существующие объекты &lt;code&gt;hstore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3286148c08a1b92253bcb1e687624659972203da" translate="yes" xml:space="preserve">
          <source>Be careful with the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. There is no concept of inheritance for the privileges of a &lt;code&gt;CREATEROLE&lt;/code&gt;-role. That means that even if a role does not have a certain privilege but is allowed to create other roles, it can easily create another role with different privileges than its own (except for creating roles with superuser privileges). For example, if the role &amp;ldquo;user&amp;rdquo; has the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege but not the &lt;code&gt;CREATEDB&lt;/code&gt; privilege, nonetheless it can create a new role with the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. Therefore, regard roles that have the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege as almost-superuser-roles.</source>
          <target state="translated">Будьте осторожны с привилегией &lt;code&gt;CREATEROLE&lt;/code&gt; . Не существует концепции наследования привилегий &lt;code&gt;CREATEROLE&lt;/code&gt; CREATEROLE. Это означает, что даже если роль не имеет определенных привилегий, но может создавать другие роли, она может легко создать другую роль с другими привилегиями, чем ее собственная (за исключением создания ролей с привилегиями суперпользователя). Например, если роль &amp;laquo;пользователь&amp;raquo; имеет привилегию &lt;code&gt;CREATEROLE&lt;/code&gt; , но не &lt;code&gt;CREATEDB&lt;/code&gt; привилегии CREATEDB , тем не менее, она может создать новую роль с привилегией &lt;code&gt;CREATEDB&lt;/code&gt; . Следовательно, &lt;code&gt;CREATEROLE&lt;/code&gt; роли с привилегией CREATEROLE почти суперпользовательскими.</target>
        </trans-unit>
        <trans-unit id="e9a084e06d49f90e432ff228c5d493ff5d910d84" translate="yes" xml:space="preserve">
          <source>Be certain that your backup includes all of the files under the database cluster directory (e.g., &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;). If you are using tablespaces that do not reside underneath this directory, be careful to include them as well (and be sure that your backup archives symbolic links as links, otherwise the restore will corrupt your tablespaces).</source>
          <target state="translated">Убедитесь, что ваша резервная копия включает все файлы в каталоге кластера базы данных (например, &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; ). Если вы используете табличные пространства, которые не находятся в этом каталоге, будьте осторожны, чтобы включить их также (и убедитесь, что ваша резервная копия архивирует символические ссылки как ссылки, иначе восстановление повредит ваши табличные пространства).</target>
        </trans-unit>
        <trans-unit id="1cca2cb275ffb0ac1d90a9275a182dd9576c7cb7" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null values&lt;/a&gt; are not considered equal to each other, multiple rows with null values are allowed to exist without violating the unique constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8050bf055d69a2c17aebfa6f23142af8cc972e31" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;...&lt;/code&gt; is widely used in data sources, it is allowed as an alternative spelling of &lt;code&gt;..&lt;/code&gt;. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in &lt;code&gt;0...23&lt;/code&gt; is meant to be &lt;code&gt;23&lt;/code&gt; or &lt;code&gt;0.23&lt;/code&gt;. This is resolved by requiring at least one digit before the decimal point in all numbers in &lt;code&gt;seg&lt;/code&gt; input.</source>
          <target state="translated">Потому что &lt;code&gt;...&lt;/code&gt; широко используются в источниках данных, допускаются в качестве альтернативного написания &lt;code&gt;..&lt;/code&gt; . К сожалению, это создает неоднозначность синтаксического анализа: неясно, должна ли верхняя граница в &lt;code&gt;0...23&lt;/code&gt; быть &lt;code&gt;23&lt;/code&gt; или &lt;code&gt;0.23&lt;/code&gt; . Это решается тем, что во всех числах во вводе &lt;code&gt;seg&lt;/code&gt; требуется по крайней мере одна цифра перед десятичной точкой .</target>
        </trans-unit>
        <trans-unit id="786d48aa791887748b32e63ec202e2ae60a5fb6e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;CLUSTER&lt;/code&gt; remembers which indexes are clustered, one can cluster the tables one wants clustered manually the first time, then set up a periodic maintenance script that executes &lt;code&gt;CLUSTER&lt;/code&gt; without any parameters, so that the desired tables are periodically reclustered.</source>
          <target state="translated">Поскольку &lt;code&gt;CLUSTER&lt;/code&gt; запоминает, какие индексы кластеризованы, можно кластеризовать таблицы, которые нужно кластеризовать вручную в первый раз, а затем настроить сценарий периодического обслуживания, который выполняет &lt;code&gt;CLUSTER&lt;/code&gt; без каких-либо параметров, чтобы нужные таблицы периодически повторно кластеризовались.</target>
        </trans-unit>
        <trans-unit id="483573a468db7932cd30d693208c560bce934759" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;float8&lt;/code&gt; has no meaningful &amp;ldquo;step&amp;rdquo;, we do not define a canonicalization function in this example.</source>
          <target state="translated">Поскольку &lt;code&gt;float8&lt;/code&gt; не имеет значимого &amp;laquo;шага&amp;raquo;, мы не определяем функцию канонизации в этом примере.</target>
        </trans-unit>
        <trans-unit id="8c58240b228b0ae5aff4efd20c01cc67a3bd5a52" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; calls are never rolled back, sequence objects cannot be used if &amp;ldquo;gapless&amp;rdquo; assignment of sequence numbers is needed. It is possible to build gapless assignment by using exclusive locking of a table containing a counter; but this solution is much more expensive than sequence objects, especially if many transactions need sequence numbers concurrently.</source>
          <target state="translated">Поскольку вызовы &lt;code&gt;nextval&lt;/code&gt; и &lt;code&gt;setval&lt;/code&gt; никогда не откатываются, объекты последовательности не могут использоваться, если требуется &amp;laquo;беспрерывное&amp;raquo; присвоение порядковых номеров. Можно построить присвоение без пропусков, используя монопольную блокировку таблицы, содержащей счетчик; но это решение намного дороже, чем объекты последовательности, особенно если многим транзакциям требуются порядковые номера одновременно.</target>
        </trans-unit>
        <trans-unit id="57fa06eff5bff23d9975c881fe012eee591895a8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are implemented using sequences, there may be &quot;holes&quot; or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still &quot;used up&quot; even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See &lt;code&gt;nextval()&lt;/code&gt; in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt; for details.</source>
          <target state="translated">Поскольку &lt;code&gt;smallserial&lt;/code&gt; , &lt;code&gt;serial&lt;/code&gt; и &lt;code&gt;bigserial&lt;/code&gt; реализованы с использованием последовательностей, могут быть &amp;laquo;дыры&amp;raquo; или пробелы в последовательности значений, которая появляется в столбце, даже если никакие строки никогда не удаляются. Значение, выделенное из последовательности, все еще &amp;laquo;израсходовано&amp;raquo;, даже если строка, содержащая это значение, никогда не вставляется успешно в столбец таблицы. Это может произойти, например, при откате вставляющей транзакции. Подробнее см. &lt;code&gt;nextval()&lt;/code&gt; в &lt;a href=&quot;functions-sequence&quot;&gt;Разделе 9.16&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bffe320d485976bda24d70a1ca1896c9923ad97" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are implemented using sequences, there may be &quot;holes&quot; or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still &quot;used up&quot; even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See &lt;code&gt;nextval()&lt;/code&gt; in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2055271ae8273a98d1c3120c9ad69e5bbb4dabd7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;to_tsvector&lt;/code&gt;(&lt;code&gt;NULL&lt;/code&gt;) will return &lt;code&gt;NULL&lt;/code&gt;, it is recommended to use &lt;code&gt;coalesce&lt;/code&gt; whenever a field might be null. Here is the recommended method for creating a &lt;code&gt;tsvector&lt;/code&gt; from a structured document:</source>
          <target state="translated">Поскольку &lt;code&gt;to_tsvector&lt;/code&gt; ( &lt;code&gt;NULL&lt;/code&gt; ) вернет &lt;code&gt;NULL&lt;/code&gt; , рекомендуется использовать &lt;code&gt;coalesce&lt;/code&gt; всякий раз, когда поле может иметь значение NULL. Вот рекомендуемый метод создания &lt;code&gt;tsvector&lt;/code&gt; из структурированного документа:</target>
        </trans-unit>
        <trans-unit id="e67190c3b34212fbd9608f10ce1643e97f3b598d" translate="yes" xml:space="preserve">
          <source>Because JSON containment is nested, an appropriate query can skip explicit selection of sub-objects. As an example, suppose that we have a &lt;code&gt;doc&lt;/code&gt; column containing objects at the top level, with most objects containing &lt;code&gt;tags&lt;/code&gt; fields that contain arrays of sub-objects. This query finds entries in which sub-objects containing both &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; and &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; appear, while ignoring any such keys outside the &lt;code&gt;tags&lt;/code&gt; array:</source>
          <target state="translated">Поскольку вложение JSON является вложенным, соответствующий запрос может пропустить явный выбор подобъектов. В качестве примера предположим, что у нас есть столбец &lt;code&gt;doc&lt;/code&gt; содержащий объекты на верхнем уровне, с большинством объектов, содержащих поля &lt;code&gt;tags&lt;/code&gt; которые содержат массивы подобъектов. Этот запрос находит записи, в которых есть подобъекты, содержащие как &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; ,так и &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; , при игнорировании любых таких ключей вне массива &lt;code&gt;tags&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a6a9b9301894dfb915e7f65b2cfd52739126757" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL does not require constraint names to be unique within a schema (but only per-table), it is possible that there is more than one match for a specified constraint name. In this case &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; will act on all matches. For a non-schema-qualified name, once a match or matches have been found in some schema in the search path, schemas appearing later in the path are not searched.</source>
          <target state="translated">Поскольку PostgreSQL не требует, чтобы имена ограничений были уникальными в пределах схемы (а только для каждой таблицы), возможно, что существует более одного совпадения для указанного имени ограничения. В этом случае &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; будет действовать для всех матчей. Для имени, не уточненного схемой, как только совпадение или совпадения были обнаружены в некоторой схеме в пути поиска, схемы, появляющиеся позже в пути, не ищутся.</target>
        </trans-unit>
        <trans-unit id="1054531abd84ea6ab456598b0cbf13df62bd8f3f" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities.</source>
          <target state="translated">Поскольку PostgreSQL имеет открытый исходный код и легко расширяется,ряд компаний взяли PostgreSQL и создали коммерческие решения с закрытым исходным кодом с уникальными возможностями обхода отказа,репликации и балансировки нагрузки.</target>
        </trans-unit>
        <trans-unit id="7c927394e6733d9a2cd5092ccd59b8f1d233eaee" translate="yes" xml:space="preserve">
          <source>Because Read Committed mode starts each command with a new snapshot that includes all transactions committed up to that instant, subsequent commands in the same transaction will see the effects of the committed concurrent transaction in any case. The point at issue above is whether or not a &lt;em&gt;single&lt;/em&gt; command sees an absolutely consistent view of the database.</source>
          <target state="translated">Поскольку в режиме Read Committed каждая команда запускается с нового моментального снимка, который включает все транзакции, зафиксированные до этого момента, последующие команды в той же транзакции в любом случае увидят эффекты зафиксированной параллельной транзакции. Вопрос, о котором говорилось выше, заключается в том, видит ли &lt;em&gt;отдельная&lt;/em&gt; команда абсолютно согласованное представление базы данных.</target>
        </trans-unit>
        <trans-unit id="cb5cad886e41acd11550eebbf5881fb1ea7474ee" translate="yes" xml:space="preserve">
          <source>Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system &lt;em&gt;data&lt;/em&gt; to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g. &lt;code&gt;data=writeback&lt;/code&gt; on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</source>
          <target state="translated">Поскольку WAL восстанавливает содержимое файла базы данных после сбоя, журналируемые файловые системы не нужны для надежного хранения файлов данных или файлов WAL. Фактически, накладные расходы на ведение журнала могут снизить производительность, особенно если при ведении журнала &lt;em&gt;данные&lt;/em&gt; файловой системы сбрасываются на диск. К счастью, сброс данных во время &lt;code&gt;data=writeback&lt;/code&gt; журнала часто можно отключить с помощью параметра монтирования файловой системы, например, data = writeback в файловой системе Linux ext3. Журналируемые файловые системы действительно улучшают скорость загрузки после сбоя.</target>
        </trans-unit>
        <trans-unit id="8e8b8c9914b76b9dd74e86a1ad52e4f86cc8bc3d" translate="yes" xml:space="preserve">
          <source>Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system &lt;em&gt;data&lt;/em&gt; to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g., &lt;code&gt;data=writeback&lt;/code&gt; on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af002f2ced30c87d8ca2cfc786b9d6c148a8b054" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;SECURITY DEFINER&lt;/code&gt; function is executed with the privileges of the user that owns it, care is needed to ensure that the function cannot be misused. For security, &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; should be set to exclude any schemas writable by untrusted users. This prevents malicious users from creating objects (e.g., tables, functions, and operators) that mask objects intended to be used by the function. Particularly important in this regard is the temporary-table schema, which is searched first by default, and is normally writable by anyone. A secure arrangement can be obtained by forcing the temporary schema to be searched last. To do this, write &lt;code&gt;pg_temp&lt;/code&gt; as the last entry in &lt;code&gt;search_path&lt;/code&gt;. This function illustrates safe usage:</source>
          <target state="translated">Поскольку функция &lt;code&gt;SECURITY DEFINER&lt;/code&gt; выполняется с привилегиями пользователя, которому она принадлежит, необходимо следить за тем, чтобы эту функцию нельзя было использовать неправильно. В целях безопасности следует установить &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; , чтобы исключить любые схемы, доступные для записи ненадежным пользователям. Это предотвращает создание злоумышленниками объектов (например, таблиц, функций и операторов), которые маскируют объекты, предназначенные для использования функцией. В этом отношении особенно важна схема временной таблицы, которая по умолчанию просматривается первой и обычно доступна для записи любому пользователю. Безопасное расположение может быть получено путем принудительного поиска временной схемы последней. Для этого напишите &lt;code&gt;pg_temp&lt;/code&gt; в качестве последней записи в &lt;code&gt;search_path&lt;/code&gt; . Эта функция иллюстрирует безопасное использование:</target>
        </trans-unit>
        <trans-unit id="7ccf103cb4c217d06785a0ccdc57267c861dec31" translate="yes" xml:space="preserve">
          <source>Because backslash is not a special character in the &lt;code&gt;CSV&lt;/code&gt; format, &lt;code&gt;\.&lt;/code&gt;, the end-of-data marker, could also appear as a data value. To avoid any misinterpretation, a &lt;code&gt;\.&lt;/code&gt; data value appearing as a lone entry on a line is automatically quoted on output, and on input, if quoted, is not interpreted as the end-of-data marker. If you are loading a file created by another application that has a single unquoted column and might have a value of &lt;code&gt;\.&lt;/code&gt;, you might need to quote that value in the input file.</source>
          <target state="translated">Поскольку обратная косая черта не является специальным символом в &lt;code&gt;CSV&lt;/code&gt; , &lt;code&gt;\.&lt;/code&gt; , маркер конца данных, также может отображаться как значение данных. Чтобы избежать неверного толкования, a &lt;code&gt;\.&lt;/code&gt; значение данных, появляющееся в виде одиночной записи в строке, автоматически цитируется на выходе, а на входе, если оно заключено в кавычки, не интерпретируется как маркер конца данных. Если вы загружаете файл, созданный другим приложением, который имеет один столбец без кавычек и может иметь значение &lt;code&gt;\.&lt;/code&gt; , вам может потребоваться заключить это значение в кавычки во входном файле.</target>
        </trans-unit>
        <trans-unit id="8837df7b2c1fb8da3ce2a114226b6b81d22d5575" translate="yes" xml:space="preserve">
          <source>Because column &lt;code&gt;y&lt;/code&gt; is not part of the index's search key, it does not have to be of a data type that the index can handle; it's merely stored in the index and is not interpreted by the index machinery. Also, if the index is a unique index, that is</source>
          <target state="translated">Поскольку столбец &lt;code&gt;y&lt;/code&gt; не является частью ключа поиска индекса, он не обязательно должен иметь тип данных, который может обрабатывать индекс; он просто хранится в индексе и не интерпретируется механизмом индекса. Кроме того, если индекс является уникальным индексом, то есть</target>
        </trans-unit>
        <trans-unit id="3d96d2addf447433c224777bf906ab67b3fda87a" translate="yes" xml:space="preserve">
          <source>Because custom options may need to be set in processes that have not loaded the relevant extension module, PostgreSQL will accept a setting for any two-part parameter name. Such variables are treated as placeholders and have no function until the module that defines them is loaded. When an extension module is loaded, it will add its variable definitions, convert any placeholder values according to those definitions, and issue warnings for any unrecognized placeholders that begin with its extension name.</source>
          <target state="translated">Так как пользовательские опции могут потребоваться в процессах,которые не загрузили соответствующий модуль расширения,PostgreSQL примет настройку для любого двухкомпонентного имени параметра.Такие переменные рассматриваются как плейсхолдеры и не имеют функции до тех пор,пока не будет загружен модуль,который их определяет.При загрузке модуля-расширения он будет добавлять свои определения переменных,конвертировать любые значения плейсхолдеров в соответствии с этими определениями и выдавать предупреждения любым нераспознанным плейсхолдерам,которые начинаются с его имени расширения.</target>
        </trans-unit>
        <trans-unit id="501d8e61189d0ec14bdd409d7b3e2083ee96580b" translate="yes" xml:space="preserve">
          <source>Because each btree operator class imposes a sort order on its data type, btree operator classes (or, really, operator families) have come to be used as PostgreSQL's general representation and understanding of sorting semantics. Therefore, they've acquired some features that go beyond what would be needed just to support btree indexes, and parts of the system that are quite distant from the btree AM make use of them.</source>
          <target state="translated">Поскольку каждый класс btree оператора накладывает порядок сортировки на свой тип данных,то в качестве общего представления и понимания семантики сортировки PostgreSQL стали использовать классы btree операторов (или,собственно,семейства операторов).Поэтому они приобрели некоторые возможности,которые выходят за рамки того,что было бы необходимо только для поддержки индексов btree,и части системы,которые достаточно далеки от btree AM,используют их.</target>
        </trans-unit>
        <trans-unit id="1cf84fc42fc11690b4a8d7c72f78d6f59379bbaa" translate="yes" xml:space="preserve">
          <source>Because each worker executes the parallel portion of the plan to completion, it is not possible to simply take an ordinary query plan and run it using multiple workers. Each worker would produce a full copy of the output result set, so the query would not run any faster than normal but would produce incorrect results. Instead, the parallel portion of the plan must be what is known internally to the query optimizer as a &lt;em&gt;partial plan&lt;/em&gt;; that is, it must be constructed so that each process which executes the plan will generate only a subset of the output rows in such a way that each required output row is guaranteed to be generated by exactly one of the cooperating processes. Generally, this means that the scan on the driving table of the query must be a parallel-aware scan.</source>
          <target state="translated">Поскольку каждый рабочий процесс выполняет параллельную часть плана до завершения, невозможно просто взять обычный план запроса и запустить его с использованием нескольких рабочих процессов. Каждый рабочий будет создавать полную копию выходного набора результатов, поэтому запрос не будет выполняться быстрее, чем обычно, но приведет к неверным результатам. Вместо этого параллельная часть плана должна быть тем, что внутри оптимизатора запросов называется &lt;em&gt;частичным планом&lt;/em&gt; ; то есть он должен быть построен так, чтобы каждый процесс, выполняющий план, генерировал только подмножество выходных строк таким образом, чтобы каждая требуемая выходная строка гарантированно генерировалась ровно одним из взаимодействующих процессов. Обычно это означает, что сканирование управляющей таблицы запроса должно быть параллельным сканированием.</target>
        </trans-unit>
        <trans-unit id="f7c3975c53757320af8c077a7aa386b120a149d9" translate="yes" xml:space="preserve">
          <source>Because logical replication is based on a similar architecture as &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;physical streaming replication&lt;/a&gt;, the monitoring on a publication node is similar to monitoring of a physical replication master (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;Section 26.2.5.2&lt;/a&gt;).</source>
          <target state="translated">Поскольку логическая репликация основана на архитектуре, аналогичной архитектуре &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;физической потоковой репликации&lt;/a&gt; , мониторинг узла публикации аналогичен мониторингу физического мастера репликации (см. &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;Раздел 26.2.5.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a2196adb2d7ec23f760e34a49d8237be649fa41e" translate="yes" xml:space="preserve">
          <source>Because of MVCC, it is always necessary to allow duplicate entries to exist physically in an index: the entries might refer to successive versions of a single logical row. The behavior we actually want to enforce is that no MVCC snapshot could include two rows with equal index keys. This breaks down into the following cases that must be checked when inserting a new row into a unique index:</source>
          <target state="translated">Из-за MVCC всегда необходимо позволять дублирующиеся записи физически существовать в индексе:записи могут относиться к последовательным версиям одной логической строки.Поведение,которое мы на самом деле хотим применить,заключается в том,что ни один MVCC снимок не может включать две строки с одинаковыми индексными ключами.Это разбивается на следующие случаи,которые должны быть проверены при вставке новой строки в уникальный индекс:</target>
        </trans-unit>
        <trans-unit id="92df70087fcf249f647fdf27a084f1becf03071e" translate="yes" xml:space="preserve">
          <source>Because of limited &lt;code&gt;maintenance_work_mem&lt;/code&gt;, &lt;code&gt;ambulkdelete&lt;/code&gt; might need to be called more than once when many tuples are to be deleted. The &lt;code&gt;stats&lt;/code&gt; argument is the result of the previous call for this index (it is NULL for the first call within a &lt;code&gt;VACUUM&lt;/code&gt; operation). This allows the AM to accumulate statistics across the whole operation. Typically, &lt;code&gt;ambulkdelete&lt;/code&gt; will modify and return the same struct if the passed &lt;code&gt;stats&lt;/code&gt; is not null.</source>
          <target state="translated">Из - за ограниченный &lt;code&gt;maintenance_work_mem&lt;/code&gt; , &lt;code&gt;ambulkdelete&lt;/code&gt; необходимости Мощи называться более чем один раз , когда многие кортежи будут удалены. &lt;code&gt;stats&lt;/code&gt; аргумент является результатом предыдущего вызова для этого индекса (это значение NULL для первого вызова в пределах &lt;code&gt;VACUUM&lt;/code&gt; операций). Это позволяет AM собирать статистику по всей операции. Обычно &lt;code&gt;ambulkdelete&lt;/code&gt; изменяет и возвращает ту же структуру, если переданная &lt;code&gt;stats&lt;/code&gt; не равна нулю.</target>
        </trans-unit>
        <trans-unit id="af06227e43627d5f9e3c80ba9b58e41dee4f1bd3" translate="yes" xml:space="preserve">
          <source>Because of the above rules, it is possible for an updating command to see an inconsistent snapshot: it can see the effects of concurrent updating commands on the same rows it is trying to update, but it does not see effects of those commands on other rows in the database. This behavior makes Read Committed mode unsuitable for commands that involve complex search conditions; however, it is just right for simpler cases. For example, consider updating bank balances with transactions like:</source>
          <target state="translated">Благодаря приведенным выше правилам,команда обновления может видеть непоследовательный снимок:она может видеть эффекты одновременных команд обновления на одних и тех же строках,которые пытается обновить,но не видит эффектов этих команд на других строках в БД.Такое поведение делает режим Read Committed непригодным для команд со сложными условиями поиска;однако,он подходит для более простых случаев.Например,рассмотрим обновление банковских остатков с помощью транзакций типа:</target>
        </trans-unit>
        <trans-unit id="094a085e303baa417739feb6622a057e4139e4ba" translate="yes" xml:space="preserve">
          <source>Because of this behavior, it's unwise to give a function that takes a single composite-type argument the same name as any of the fields of that composite type. If there is ambiguity, the field-name interpretation will be chosen if field-name syntax is used, while the function will be chosen if function-call syntax is used. However, PostgreSQL versions before 11 always chose the field-name interpretation, unless the syntax of the call required it to be a function call. One way to force the function interpretation in older versions is to schema-qualify the function name, that is, write &lt;code&gt;schema.func(compositevalue)&lt;/code&gt;.</source>
          <target state="translated">Из-за такого поведения неразумно давать функции, которая принимает единственный аргумент составного типа, то же имя, что и любое из полей этого составного типа. Если есть двусмысленность, будет выбрана интерпретация имени поля, если используется синтаксис имени поля, а функция будет выбрана, если используется синтаксис вызова функции. Однако в версиях PostgreSQL до 11 всегда выбиралась интерпретация имени поля, если только синтаксис вызова не требовал, чтобы это был вызов функции. Один из способов принудительной интерпретации функции в более старых версиях - это &lt;code&gt;schema.func(compositevalue)&lt;/code&gt; имя функции с помощью схемы, то есть написать schema.func (композитное значение) .</target>
        </trans-unit>
        <trans-unit id="f6916a8fbcc68029c3a341e8400e967ac545c917" translate="yes" xml:space="preserve">
          <source>Because of this behavior, putting more than one SQL command in a single &lt;code&gt;-c&lt;/code&gt; string often has unexpected results. It's better to use repeated &lt;code&gt;-c&lt;/code&gt; commands or feed multiple commands to psql's standard input, either using echo as illustrated above, or via a shell here-document, for example:</source>
          <target state="translated">Из-за такого поведения размещение нескольких команд SQL в одной строке &lt;code&gt;-c&lt;/code&gt; часто приводит к неожиданным результатам. Лучше использовать повторяющиеся команды &lt;code&gt;-c&lt;/code&gt; или передавать несколько команд на стандартный ввод psql, либо с помощью echo, как показано выше, либо через оболочку here-document, например:</target>
        </trans-unit>
        <trans-unit id="1e30503a8aa4dc4dd17e2394f194dfc73877aea7" translate="yes" xml:space="preserve">
          <source>Because of this convention of possibly renumbering OIDs assigned by patches, the OIDs assigned by a patch should not be considered stable until the patch has been included in an official release. We do not change manually-assigned object OIDs once released, however, as that would create assorted compatibility problems.</source>
          <target state="translated">Из-за этой конвенции о возможном изменении нумерации OID,присвоенных патчами,OID,присвоенные патчем,не должны считаться стабильными до тех пор,пока патч не будет включен в официальный выпуск.Однако,мы не изменяем OID объектов,назначенных вручную,после выпуска патча,так как это создаёт различные проблемы совместимости.</target>
        </trans-unit>
        <trans-unit id="167e13b17a2cb4d9e247d60e890e572062fe98da" translate="yes" xml:space="preserve">
          <source>Because of this indeterminacy, referencing other tables only within sub-selects is safer, though often harder to read and slower than using a join.</source>
          <target state="translated">Из-за этой неопределенности ссылаться на другие таблицы только в рамках подвыборов безопаснее,хотя зачастую это труднее прочитать и медленнее,чем использовать соединение.</target>
        </trans-unit>
        <trans-unit id="71a8fc6262b2555f78a8d5aeb3468844fc9b3fb8" translate="yes" xml:space="preserve">
          <source>Because optimizer statistics are not transferred by &lt;code&gt;pg_upgrade&lt;/code&gt;, you will be instructed to run a command to regenerate that information at the end of the upgrade. You might need to set connection parameters to match your new cluster.</source>
          <target state="translated">Поскольку статистика оптимизатора не передается с помощью &lt;code&gt;pg_upgrade&lt;/code&gt; , вам будет предложено запустить команду для восстановления этой информации в конце обновления. Возможно, вам потребуется настроить параметры подключения в соответствии с вашим новым кластером.</target>
        </trans-unit>
        <trans-unit id="c35cef2d44681e7faa9cdda9938f800f990d4dc8" translate="yes" xml:space="preserve">
          <source>Because pg_dump is used to transfer data to newer versions of PostgreSQL, the output of pg_dump can be expected to load into PostgreSQL server versions newer than pg_dump's version. pg_dump can also dump from PostgreSQL servers older than its own version. (Currently, servers back to version 8.0 are supported.) However, pg_dump cannot dump from PostgreSQL servers newer than its own major version; it will refuse to even try, rather than risk making an invalid dump. Also, it is not guaranteed that pg_dump's output can be loaded into a server of an older major version &amp;mdash; not even if the dump was taken from a server of that version. Loading a dump file into an older server may require manual editing of the dump file to remove syntax not understood by the older server. Use of the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option is recommended in cross-version cases, as it can prevent problems arising from varying reserved-word lists in different PostgreSQL versions.</source>
          <target state="translated">Поскольку pg_dump используется для передачи данных в более новые версии PostgreSQL, можно ожидать, что вывод pg_dump будет загружен в версии сервера PostgreSQL более новые, чем версия pg_dump. pg_dump также может делать дамп с серверов PostgreSQL, более старых, чем его собственная версия. (В настоящее время поддерживаются серверы до версии 8.0.) Однако pg_dump не может выполнять дамп с серверов PostgreSQL новее, чем его собственная основная версия; он откажется даже от попытки, а не рискнет сделать недопустимый дамп. Кроме того, не гарантируется, что вывод pg_dump может быть загружен на сервер более старой основной версии - даже если дамп был взят с сервера этой версии. Загрузка файла дампа на старый сервер может потребовать ручного редактирования файла дампа, чтобы удалить синтаксис, не понятный старому серверу. Использование &lt;code&gt;--quote-all-identifiers&lt;/code&gt; Эта опция рекомендуется в случаях, когда используются разные версии, поскольку она может предотвратить проблемы, возникающие из-за различий в списках зарезервированных слов в разных версиях PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="74ecae8ce7298adddc06312de549cde5a1f05bfd" translate="yes" xml:space="preserve">
          <source>Because roles can own database objects and can hold privileges to access other objects, dropping a role is often not just a matter of a quick &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;. Any objects owned by the role must first be dropped or reassigned to other owners; and any permissions granted to the role must be revoked.</source>
          <target state="translated">Поскольку роли могут владеть объектами базы данных и могут иметь привилегии для доступа к другим объектам, удаление роли часто является не просто вопросом быстрого &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; . Любые объекты, принадлежащие этой роли, необходимо сначала удалить или переназначить другим владельцам; и все разрешения, предоставленные роли, должны быть отозваны.</target>
        </trans-unit>
        <trans-unit id="3c6bd276df7f7795dcf1ec012b5fa318dae1fa92" translate="yes" xml:space="preserve">
          <source>Because sequences are non-transactional, changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</source>
          <target state="translated">Поскольку последовательности не являются транзакционными, изменения, сделанные &lt;code&gt;setval&lt;/code&gt; , не отменяются при откате транзакции.</target>
        </trans-unit>
        <trans-unit id="045cb510a11b664aff1ae0f9d4a4e6bf852e98a6" translate="yes" xml:space="preserve">
          <source>Because that day was a spring-forward transition date in that time zone, there was no civil time instant 2:30AM; clocks jumped forward from 2AM EST to 3AM EDT. PostgreSQL interprets the given time as if it were standard time (UTC-5), which then renders as 3:30AM EDT (UTC-4).</source>
          <target state="translated">Так как в этот день в этом часовом поясе был переход на пружинный переход,то не было мгновенного гражданского времени 2:30 AM;часы перескочили с 2AM EST на 3AM EDT.PostgreSQL интерпретирует данное время как стандартное время (UTC-5),которое затем выдается как 3:30AM EDT (UTC-4).</target>
        </trans-unit>
        <trans-unit id="f0a1c41a7fd794b4e227af5602d5ab126f9a65b2" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;...&lt;/code&gt; operator is widely used in data sources, it is allowed as an alternative spelling of the &lt;code&gt;..&lt;/code&gt; operator. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in &lt;code&gt;0...23&lt;/code&gt; is meant to be &lt;code&gt;23&lt;/code&gt; or &lt;code&gt;0.23&lt;/code&gt;. This is resolved by requiring at least one digit before the decimal point in all numbers in &lt;code&gt;seg&lt;/code&gt; input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c15eb3326253a984503903ababbb5a012e0e63" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node runs on the leader process, queries which produce a relatively large number of groups in comparison to the number of input rows will appear less favorable to the query planner. For example, in the worst-case scenario the number of groups seen by the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node could be as many as the number of input rows which were seen by all worker processes in the &lt;code&gt;Partial Aggregate&lt;/code&gt; stage. For such cases, there is clearly going to be no performance benefit to using parallel aggregation. The query planner takes this into account during the planning process and is unlikely to choose parallel aggregate in this scenario.</source>
          <target state="translated">Поскольку узел &lt;code&gt;Finalize Aggregate&lt;/code&gt; работает в процессе лидера, запросы, которые создают относительно большое количество групп по сравнению с количеством входных строк, будут казаться планировщику запросов менее подходящими. Например, в наихудшем сценарии количество групп, видимых узлом &lt;code&gt;Finalize Aggregate&lt;/code&gt; , может быть равным количеству входных строк, которые были просмотрены всеми рабочими процессами на этапе &lt;code&gt;Partial Aggregate&lt;/code&gt; . В таких случаях использование параллельного агрегирования явно не даст выигрыша в производительности. Планировщик запросов учитывает это в процессе планирования и вряд ли выберет параллельное агрегирование в этом сценарии.</target>
        </trans-unit>
        <trans-unit id="c37bfc8193816ef9726582311c95eb690d59a5d3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;json&lt;/code&gt; type stores an exact copy of the input text, it will preserve semantically-insignificant white space between tokens, as well as the order of keys within JSON objects. Also, if a JSON object within the value contains the same key more than once, all the key/value pairs are kept. (The processing functions consider the last value as the operative one.) By contrast, &lt;code&gt;jsonb&lt;/code&gt; does not preserve white space, does not preserve the order of object keys, and does not keep duplicate object keys. If duplicate keys are specified in the input, only the last value is kept.</source>
          <target state="translated">Поскольку тип &lt;code&gt;json&lt;/code&gt; хранит точную копию входящего текста, он сохранит семантически несущественные пробелы между токенами, а также порядок ключей в объектах JSON. Кроме того, если объект JSON внутри значения содержит один и тот же ключ более одного раза, все пары ключ / значение сохраняются. (Функции обработки рассматривают последнее значение как &lt;code&gt;jsonb&lt;/code&gt; .) Напротив, jsonb не сохраняет пробелы, не сохраняет порядок ключей объектов и не сохраняет повторяющиеся ключи объектов. Если во входных данных указаны повторяющиеся ключи, сохраняется только последнее значение.</target>
        </trans-unit>
        <trans-unit id="a2b58f4e608829c960ebd5345ab5c69ff0a6f48c" translate="yes" xml:space="preserve">
          <source>Because the cache is shared by all the databases, there will normally be pages from relations not belonging to the current database. This means that there may not be matching join rows in &lt;code&gt;pg_class&lt;/code&gt; for some rows, or that there could even be incorrect joins. If you are trying to join against &lt;code&gt;pg_class&lt;/code&gt;, it's a good idea to restrict the join to rows having &lt;code&gt;reldatabase&lt;/code&gt; equal to the current database's OID or zero.</source>
          <target state="translated">Поскольку кэш используется всеми базами данных, обычно будут страницы из отношений, не принадлежащих текущей базе данных. Это означает, что для некоторых строк в &lt;code&gt;pg_class&lt;/code&gt; может не быть совпадающих строк соединения или что могут быть даже неправильные соединения. Если вы пытаетесь присоединиться к &lt;code&gt;pg_class&lt;/code&gt; , рекомендуется ограничить соединение строками, имеющими &lt;code&gt;reldatabase&lt;/code&gt; данных reldatabase, равную OID текущей базы данных или нулю.</target>
        </trans-unit>
        <trans-unit id="db3d427c20974c56be935e79b307fe146f033de0" translate="yes" xml:space="preserve">
          <source>Because the data directory contains all the data stored in the database, it is essential that it be secured from unauthorized access. &lt;code&gt;initdb&lt;/code&gt; therefore revokes access permissions from everyone but the PostgreSQL user, and optionally, group. Group access, when enabled, is read-only. This allows an unprivileged user in the same group as the cluster owner to take a backup of the cluster data or perform other operations that only require read access.</source>
          <target state="translated">Поскольку каталог данных содержит все данные, хранящиеся в базе данных, важно, чтобы он был защищен от несанкционированного доступа. Поэтому &lt;code&gt;initdb&lt;/code&gt; отменяет права доступа у всех, кроме пользователя PostgreSQL и, возможно, группы. Групповой доступ, если он включен, доступен только для чтения. Это позволяет непривилегированному пользователю в той же группе, что и владелец кластера, делать резервную копию данных кластера или выполнять другие операции, требующие только доступа для чтения.</target>
        </trans-unit>
        <trans-unit id="1b1433bfc602856fd35d38e930969e2b25fd0ae1" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator class is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator class.</source>
          <target state="translated">Поскольку механизм индекса не проверяет разрешения на доступ к функциям перед их использованием,включение функции или оператора в операторский класс равнозначно предоставлению права публичного исполнения на него.Обычно это не относится к тем функциям,которые полезны в классе операторов.</target>
        </trans-unit>
        <trans-unit id="12e05e286bda0df5f833a009aa68ad96a2c3e153" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator family is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator family.</source>
          <target state="translated">Поскольку механизм индексирования не проверяет разрешения на доступ к функциям перед их использованием,включение функции или оператора в семейство операторов равнозначно предоставлению права публичного исполнения на нее.Обычно это не относится к тем функциям,которые полезны в семействе операторов.</target>
        </trans-unit>
        <trans-unit id="05ce34a0d540aca4ce52a5f0344a9da290661688" translate="yes" xml:space="preserve">
          <source>Because the number of possible column combinations is very large, it's impractical to compute multivariate statistics automatically. Instead, &lt;em&gt;extended statistics objects&lt;/em&gt;, more often called just &lt;em&gt;statistics objects&lt;/em&gt;, can be created to instruct the server to obtain statistics across interesting sets of columns.</source>
          <target state="translated">Поскольку количество возможных комбинаций столбцов очень велико, нецелесообразно автоматически вычислять многомерную статистику. Вместо этого можно создать &lt;em&gt;объекты расширенной статистики&lt;/em&gt; , которые чаще называют просто &lt;em&gt;объектами статистики&lt;/em&gt; , чтобы дать серверу команду получать статистику по интересным наборам столбцов.</target>
        </trans-unit>
        <trans-unit id="4d0acad31e5ac16c376a00a683ae533e823a54c5" translate="yes" xml:space="preserve">
          <source>Because the planner records statistics about the ordering of tables, it is advisable to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the newly clustered table. Otherwise, the planner might make poor choices of query plans.</source>
          <target state="translated">Поскольку планировщик записывает статистику о порядке таблиц, рекомендуется запускать &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; для новой кластеризованной таблицы. В противном случае планировщик может сделать неправильный выбор планов запроса.</target>
        </trans-unit>
        <trans-unit id="2d35897de153aa519a54a8b8fb6f5606c68e7ee1" translate="yes" xml:space="preserve">
          <source>Because the two-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; was used in the index above, only a query reference that uses the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; with the same configuration name will use that index. That is, &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; can use the index, but &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; cannot. This ensures that an index will be used only with the same configuration used to create the index entries.</source>
          <target state="translated">Поскольку в указанном выше индексе использовалась версия &lt;code&gt;to_tsvector&lt;/code&gt; с двумя аргументами , только ссылка на запрос, использующая версию &lt;code&gt;to_tsvector&lt;/code&gt; с двумя аргументами с тем же именем конфигурации, будет использовать этот индекс. То есть &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; может использовать индекс, а &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; нет. Это гарантирует, что индекс будет использоваться только с той же конфигурацией, которая использовалась для создания записей индекса.</target>
        </trans-unit>
        <trans-unit id="3db556aa68ed6f557f519e10166a776c7f49e136" translate="yes" xml:space="preserve">
          <source>Because there are no restrictions on use of a data type once it's been created, creating a base type or range type is tantamount to granting public execute permission on the functions mentioned in the type definition. This is usually not an issue for the sorts of functions that are useful in a type definition. But you might want to think twice before designing a type in a way that would require &amp;ldquo;secret&amp;rdquo; information to be used while converting it to or from external form.</source>
          <target state="translated">Поскольку нет никаких ограничений на использование типа данных после его создания, создание базового типа или типа диапазона равносильно предоставлению публичного разрешения на выполнение для функций, упомянутых в определении типа. Обычно это не проблема для функций, которые полезны в определении типа. Но вы можете дважды подумать, прежде чем проектировать тип таким образом, чтобы при преобразовании его во внешнюю форму или из нее использовалась &amp;laquo;секретная&amp;raquo; информация.</target>
        </trans-unit>
        <trans-unit id="21ceed46db3017cd5cd38ced3fddd77a8ce650db" translate="yes" xml:space="preserve">
          <source>Because these functions return detailed page-level information, access is restricted by default. By default, only the role &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; has &lt;code&gt;EXECUTE&lt;/code&gt; privilege. Superusers of course bypass this restriction. After the extension has been installed, users may issue &lt;code&gt;GRANT&lt;/code&gt; commands to change the privileges on the functions to allow others to execute them. However, it might be preferable to add those users to the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role instead.</source>
          <target state="translated">Поскольку эти функции возвращают подробную информацию на уровне страницы, доступ по умолчанию ограничен. По умолчанию только роль &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; имеет привилегию &lt;code&gt;EXECUTE&lt;/code&gt; . Конечно, суперпользователи обходят это ограничение. После установки расширения пользователи могут &lt;code&gt;GRANT&lt;/code&gt; команды GRANT, чтобы изменить права доступа к функциям, чтобы позволить другим выполнять их. Однако может быть предпочтительнее вместо этого добавить этих пользователей в роль &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cab3b5bbab6ef84f87ff0c28b63da48ab8adbf53" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_auth_members&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_auth_members&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">Поскольку идентификаторы пользователей являются &lt;code&gt;pg_auth_members&lt;/code&gt; , pg_auth_members совместно используется всеми базами данных кластера: существует только одна копия &lt;code&gt;pg_auth_members&lt;/code&gt; для каждого кластера, а не одна для каждой базы данных.</target>
        </trans-unit>
        <trans-unit id="0a9b4bf1d549fcf042c9f5eb8f3493cb9cfe27e7" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_authid&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_authid&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">Поскольку идентификаторы пользователей являются &lt;code&gt;pg_authid&lt;/code&gt; , pg_authid используется во всех базах данных кластера: существует только одна копия &lt;code&gt;pg_authid&lt;/code&gt; на кластер, а не одна на базу данных.</target>
        </trans-unit>
        <trans-unit id="b7824c0664ad3fb70745076ae899f66946c9584d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.1, the arguments of the sequence functions were of type &lt;code&gt;text&lt;/code&gt;, not &lt;code&gt;regclass&lt;/code&gt;, and the above-described conversion from a text string to an OID value would happen at run time during each call. For backward compatibility, this facility still exists, but internally it is now handled as an implicit coercion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;regclass&lt;/code&gt; before the function is invoked.</source>
          <target state="translated">До PostgreSQL 8.1 аргументы функций последовательности имели тип &lt;code&gt;text&lt;/code&gt; , а не &lt;code&gt;regclass&lt;/code&gt; , и описанное выше преобразование текстовой строки в значение OID происходило во время выполнения во время каждого вызова. Для обратной совместимости эта возможность все еще существует, но внутри она теперь обрабатывается как неявное приведение &lt;code&gt;text&lt;/code&gt; к &lt;code&gt;regclass&lt;/code&gt; перед вызовом функции.</target>
        </trans-unit>
        <trans-unit id="5fe2f878504da2e1db73277f0e33ea8b96b5ad9c" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the &lt;code&gt;.*&lt;/code&gt; syntax was not expanded in row constructors, so that writing &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; created a two-field row whose first field was another row value. The new behavior is usually more useful. If you need the old behavior of nested row values, write the inner row value without &lt;code&gt;.*&lt;/code&gt;, for instance &lt;code&gt;ROW(t, 42)&lt;/code&gt;.</source>
          <target state="translated">До PostgreSQL 8.2 синтаксис &lt;code&gt;.*&lt;/code&gt; Не расширялся в конструкторах строк, поэтому запись &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; создавала строку с двумя полями, первое поле которой было другим значением строки. Новое поведение обычно более полезно. Если вам нужно старое поведение значений вложенных строк, запишите значение внутренней строки без &lt;code&gt;.*&lt;/code&gt; , Например &lt;code&gt;ROW(t, 42)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8d01c186f775230385d810745e30ede0c0292d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were respectively called &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;. These names are still available, but are deprecated and will eventually be removed.</source>
          <target state="translated">До PostgreSQL 8.2 операторы включения &lt;code&gt;@&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;@&lt;/code&gt; назывались соответственно &lt;code&gt;~&lt;/code&gt; и &lt;code&gt;@&lt;/code&gt; . Эти имена все еще доступны, но устарели и в конечном итоге будут удалены.</target>
        </trans-unit>
        <trans-unit id="c036ccc0fef09aace79d8f72b4bc4956e2e6b969" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.3, these functions would silently accept values of several non-string data types as well, due to the presence of implicit coercions from those data types to &lt;code&gt;text&lt;/code&gt;. Those coercions have been removed because they frequently caused surprising behaviors. However, the string concatenation operator (&lt;code&gt;||&lt;/code&gt;) still accepts non-string input, so long as at least one input is of a string type, as shown in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;. For other cases, insert an explicit coercion to &lt;code&gt;text&lt;/code&gt; if you need to duplicate the previous behavior.</source>
          <target state="translated">До PostgreSQL 8.3 эти функции также могли молча принимать значения некоторых нестроковых типов данных из-за наличия неявных &lt;code&gt;text&lt;/code&gt; этих типов данных в текст . Эти принуждения были устранены, потому что они часто вызывали неожиданное поведение. Однако оператор конкатенации строк ( &lt;code&gt;||&lt;/code&gt; ) по-прежнему принимает нестроковый ввод, если хотя бы один ввод относится к строковому типу, как показано в &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Таблице 9.9&lt;/a&gt; . В других случаях вставьте явное приведение к &lt;code&gt;text&lt;/code&gt; если вам нужно дублировать предыдущее поведение.</target>
        </trans-unit>
        <trans-unit id="3b8019c3d24fcdf13fb68d8305a1528d20dff010" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, psql allowed the first argument of a single-letter backslash command to start directly after the command, without intervening whitespace. Now, some whitespace is required.</source>
          <target state="translated">До версии PostgreSQL 8.4,psql разрешал первый аргумент однобуквенной команды обратного слеша запускаться непосредственно после команды,без вмешательства пробела.Теперь требуется некоторое количество пробельных символов.</target>
        </trans-unit>
        <trans-unit id="95fbf31e963d4b484912ba157149b28d1649f2d4" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, the &lt;code&gt;OPERATOR&lt;/code&gt; clause could include a &lt;code&gt;RECHECK&lt;/code&gt; option. This is no longer supported because whether an index operator is &amp;ldquo;lossy&amp;rdquo; is now determined on-the-fly at run time. This allows efficient handling of cases where an operator might or might not be lossy.</source>
          <target state="translated">До PostgreSQL 8.4 предложение &lt;code&gt;OPERATOR&lt;/code&gt; могло включать параметр &lt;code&gt;RECHECK&lt;/code&gt; . Это больше не поддерживается, потому что то, является ли оператор индекса &amp;laquo;с потерями&amp;raquo;, теперь определяется &amp;laquo;на лету&amp;raquo; во время выполнения. Это позволяет эффективно обрабатывать случаи, когда оператор может или не может иметь потери.</target>
        </trans-unit>
        <trans-unit id="5824a92b6b2740af57b007a3a86225a310d091b7" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, &lt;code&gt;pg_am&lt;/code&gt; contained many additional columns representing properties of index access methods. That data is now only directly visible at the C code level. However, &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; and related functions have been added to allow SQL queries to inspect index access method properties; see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;Table 9.68&lt;/a&gt;.</source>
          <target state="translated">До PostgreSQL 9.6 &lt;code&gt;pg_am&lt;/code&gt; содержал множество дополнительных столбцов, представляющих свойства методов доступа к индексу. Эти данные теперь напрямую видны только на уровне кода C. Однако были добавлены &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; и связанные функции, позволяющие запросам SQL проверять свойства метода доступа к индексу; см. &lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;Таблицу 9.68&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4765a073d10eb89d73b00161ddb8dddb0be1ef8" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, SQL commands in script files were terminated by newlines, and so they could not be continued across lines. Now a semicolon is &lt;em&gt;required&lt;/em&gt; to separate consecutive SQL commands (though a SQL command does not need one if it is followed by a meta command). If you need to create a script file that works with both old and new versions of pgbench, be sure to write each SQL command on a single line ending with a semicolon.</source>
          <target state="translated">До PostgreSQL 9.6 команды SQL в файлах сценариев заканчивались символами новой строки, поэтому их нельзя было продолжить через строки. Теперь точка с запятой &lt;em&gt;требуется&lt;/em&gt; для разделения последовательных команд SQL (хотя команде SQL она не нужна, если за ней следует метакоманда). Если вам нужно создать файл сценария, который работает как со старой, так и с новой версиями pgbench, обязательно пишите каждую команду SQL в одной строке, заканчивающейся точкой с запятой.</target>
        </trans-unit>
        <trans-unit id="25a91312b02bab209e6a6f9a691f6a084f05d75d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, the &lt;code&gt;-c&lt;/code&gt; option implied &lt;code&gt;-X&lt;/code&gt; (&lt;code&gt;--no-psqlrc&lt;/code&gt;); this is no longer the case.</source>
          <target state="translated">До PostgreSQL 9.6 опция &lt;code&gt;-c&lt;/code&gt; подразумевала &lt;code&gt;-X&lt;/code&gt; ( &lt;code&gt;--no-psqlrc&lt;/code&gt; ); это уже не так.</target>
        </trans-unit>
        <trans-unit id="e88cb3afc9e7c5edbb82c8ba3662818b28a3aaef" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL had the &lt;code&gt;INCLUDE&lt;/code&gt; feature, people sometimes made covering indexes by writing the payload columns as ordinary index columns, that is writing</source>
          <target state="translated">До того, как в PostgreSQL появилась функция &lt;code&gt;INCLUDE&lt;/code&gt; , люди иногда создавали покрывающие индексы, записывая столбцы полезной нагрузки как обычные столбцы индекса, т.е.</target>
        </trans-unit>
        <trans-unit id="b6ecfe47fb55ef8a0352cf146e2122df69c11049" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.2, the shell-type creation syntax &lt;code&gt;CREATE TYPE name&lt;/code&gt; did not exist. The way to create a new base type was to create its input function first. In this approach, PostgreSQL will first see the name of the new data type as the return type of the input function. The shell type is implicitly created in this situation, and then it can be referenced in the definitions of the remaining I/O functions. This approach still works, but is deprecated and might be disallowed in some future release. Also, to avoid accidentally cluttering the catalogs with shell types as a result of simple typos in function definitions, a shell type will only be made this way when the input function is written in C.</source>
          <target state="translated">До версии PostgreSQL 8.2 синтаксис создания типа оболочки &lt;code&gt;CREATE TYPE name&lt;/code&gt; не существовал. Чтобы создать новый базовый тип, сначала нужно создать его функцию ввода. При таком подходе PostgreSQL сначала увидит имя нового типа данных как тип возвращаемого значения входной функции. В этой ситуации тип оболочки создается неявно, а затем на него можно ссылаться в определениях остальных функций ввода-вывода. Этот подход по-прежнему работает, но считается устаревшим и может быть запрещен в некоторых будущих версиях. Кроме того, чтобы избежать случайного загромождения каталогов типами оболочки из-за простых опечаток в определениях функций, тип оболочки будет создаваться таким образом только тогда, когда функция ввода написана на C.</target>
        </trans-unit>
        <trans-unit id="133cff6a54d531aaca5754e3dd9245f0764b14c3" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the &lt;code&gt;SET&lt;/code&gt; clause was not available, and so older functions may contain rather complicated logic to save, set, and restore &lt;code&gt;search_path&lt;/code&gt;. The &lt;code&gt;SET&lt;/code&gt; clause is far easier to use for this purpose.</source>
          <target state="translated">До версии PostgreSQL 8.3 предложение &lt;code&gt;SET&lt;/code&gt; было недоступно, поэтому старые функции могут содержать довольно сложную логику для сохранения, установки и восстановления &lt;code&gt;search_path&lt;/code&gt; . Предложение &lt;code&gt;SET&lt;/code&gt; гораздо проще использовать для этой цели.</target>
        </trans-unit>
        <trans-unit id="d40dc4e81bdd5f6ad72cddc10364e0a47323f2d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the name of a generated array type was always exactly the element type's name with one underscore character (&lt;code&gt;_&lt;/code&gt;) prepended. (Type names were therefore restricted in length to one less character than other names.) While this is still usually the case, the array type name may vary from this in case of maximum-length names or collisions with user type names that begin with underscore. Writing code that depends on this convention is therefore deprecated. Instead, use &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typarray&lt;/code&gt; to locate the array type associated with a given type.</source>
          <target state="translated">До PostgreSQL версии 8.3 имя создаваемого типа массива всегда было в точности именем типа элемента с добавлением одного символа подчеркивания ( &lt;code&gt;_&lt;/code&gt; ). (Таким образом, длина имен типов была ограничена на один символ меньше, чем у других имен.) Хотя это обычно так, имя типа массива может отличаться от этого в случае имен максимальной длины или конфликтов с именами типов пользователей, которые начинаются с подчеркивания . Поэтому писать код, который зависит от этого соглашения, не рекомендуется. Вместо этого используйте &lt;code&gt;pg_type&lt;/code&gt; . &lt;code&gt;typarray&lt;/code&gt; , чтобы найти тип массива, связанный с данным типом.</target>
        </trans-unit>
        <trans-unit id="6cde500737c3794e75266509d120c3f451ce96fd" translate="yes" xml:space="preserve">
          <source>Before anyone can access the database, you must start the database server. The database server program is called &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a33375376d06d4d560a6a1c1041e7d31e19935" translate="yes" xml:space="preserve">
          <source>Before anyone can access the database, you must start the database server. The database server program is called &lt;code&gt;postgres&lt;/code&gt;. The &lt;code&gt;postgres&lt;/code&gt; program must know where to find the data it is supposed to use. This is done with the &lt;code&gt;-D&lt;/code&gt; option. Thus, the simplest way to start the server is:</source>
          <target state="translated">Прежде чем кто-либо сможет получить доступ к базе данных, вы должны запустить сервер базы данных. Программа сервера базы данных называется &lt;code&gt;postgres&lt;/code&gt; . Программа &lt;code&gt;postgres&lt;/code&gt; должна знать, где найти данные, которые она должна использовать. Это делается с помощью опции &lt;code&gt;-D&lt;/code&gt; . Таким образом, самый простой способ запустить сервер:</target>
        </trans-unit>
        <trans-unit id="222bfa6cd0afdad9a2e9f50eb2cacfa866429974" translate="yes" xml:space="preserve">
          <source>Before doing so, the function should check the sign of &lt;code&gt;offset&lt;/code&gt;: if it is less than zero, raise error &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; (22013) with error text like &amp;ldquo;invalid preceding or following size in window function&amp;rdquo;. (This is required by the SQL standard, although nonstandard operator families might perhaps choose to ignore this restriction, since there seems to be little semantic necessity for it.) This requirement is delegated to the &lt;code&gt;in_range&lt;/code&gt; function so that the core code needn't understand what &amp;ldquo;less than zero&amp;rdquo; means for a particular data type.</source>
          <target state="translated">Перед этим функция должна проверить знак &lt;code&gt;offset&lt;/code&gt; : если он меньше нуля, вызвать ошибку &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; (22013) с текстом ошибки типа &amp;laquo;недопустимый предыдущий или следующий размер в оконной функции&amp;raquo;. (Это требуется стандартом SQL, хотя нестандартные семейства операторов могут, возможно, проигнорировать это ограничение, поскольку, похоже, в нем мало семантической необходимости.) Это требование делегировано функции &lt;code&gt;in_range&lt;/code&gt; , так что основной код не должен понимать что означает &amp;laquo;меньше нуля&amp;raquo; для определенного типа данных.</target>
        </trans-unit>
        <trans-unit id="9433a751fdf2c9c611a9f86077418abf326bf14a" translate="yes" xml:space="preserve">
          <source>Before restoring an SQL dump, all the users who own objects or were granted permissions on objects in the dumped database must already exist. If they do not, the restore will fail to recreate the objects with the original ownership and/or permissions. (Sometimes this is what you want, but usually it is not.)</source>
          <target state="translated">Перед восстановлением дампа SQL все пользователи,владеющие объектами или получившие права доступа к объектам в базе данных,содержащей дампы,должны уже существовать.Если они этого не сделают,то при восстановлении не удастся воссоздать объекты с изначальными правами собственности и/или разрешениями.(Иногда это то,что вы хотите,но обычно это не так).</target>
        </trans-unit>
        <trans-unit id="5350218eee7862579014da56e03f9c4a8c7df37f" translate="yes" xml:space="preserve">
          <source>Before running the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; command, it is recommended to create a &lt;code&gt;CHECK&lt;/code&gt; constraint on the table to be attached matching the desired partition constraint. That way, the system will be able to skip the scan to validate the implicit partition constraint. Without the &lt;code&gt;CHECK&lt;/code&gt; constraint, the table will be scanned to validate the partition constraint while holding an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on that partition and a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table. It may be desired to drop the redundant &lt;code&gt;CHECK&lt;/code&gt; constraint after &lt;code&gt;ATTACH PARTITION&lt;/code&gt; is finished.</source>
          <target state="translated">Перед запуском команды &lt;code&gt;ATTACH PARTITION&lt;/code&gt; рекомендуется создать ограничение &lt;code&gt;CHECK&lt;/code&gt; для присоединяемой таблицы, соответствующее желаемому ограничению раздела. Таким образом, система сможет пропустить сканирование для проверки неявного ограничения разделения. Без ограничения &lt;code&gt;CHECK&lt;/code&gt; таблица будет сканироваться для проверки ограничения раздела, удерживая блокировку &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; для этого раздела и блокировку &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; для родительской таблицы. Может потребоваться сбросить избыточное ограничение &lt;code&gt;CHECK&lt;/code&gt; после завершения &lt;code&gt;ATTACH PARTITION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0534112e08b3f377dcff7dae34fa42dedf03836d" translate="yes" xml:space="preserve">
          <source>Before running the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; command, it is recommended to create a &lt;code&gt;CHECK&lt;/code&gt; constraint on the table to be attached matching the desired partition constraint. That way, the system will be able to skip the scan which is otherwise needed to validate the implicit partition constraint. Without the &lt;code&gt;CHECK&lt;/code&gt; constraint, the table will be scanned to validate the partition constraint while holding an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on that partition and a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table. It may be desired to drop the redundant &lt;code&gt;CHECK&lt;/code&gt; constraint after &lt;code&gt;ATTACH PARTITION&lt;/code&gt; is finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd8ecaf3b3090d8469e126e6ec0aadfd531ece9" translate="yes" xml:space="preserve">
          <source>Before we proceed, you should understand the basic PostgreSQL system architecture. Understanding how the parts of PostgreSQL interact will make this chapter somewhat clearer.</source>
          <target state="translated">Прежде чем мы продолжим,вы должны понять базовую архитектуру системы PostgreSQL.Понимание того,как части PostgreSQL взаимодействуют друг с другом,сделает эту главу несколько более понятной.</target>
        </trans-unit>
        <trans-unit id="2bd6b34f5ab63eba4552e311eedb5465ee67a88a" translate="yes" xml:space="preserve">
          <source>Before you can do anything, you must initialize a database storage area on disk. We call this a &lt;em&gt;database cluster&lt;/em&gt;. (The SQL standard uses the term catalog cluster.) A database cluster is a collection of databases that is managed by a single instance of a running database server. After initialization, a database cluster will contain a database named &lt;code&gt;postgres&lt;/code&gt;, which is meant as a default database for use by utilities, users and third party applications. The database server itself does not require the &lt;code&gt;postgres&lt;/code&gt; database to exist, but many external utility programs assume it exists. Another database created within each cluster during initialization is called &lt;code&gt;template1&lt;/code&gt;. As the name suggests, this will be used as a template for subsequently created databases; it should not be used for actual work. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for information about creating new databases within a cluster.)</source>
          <target state="translated">Прежде чем вы сможете что-либо сделать, вы должны инициализировать область хранения базы данных на диске. Мы называем это &lt;em&gt;кластером базы данных&lt;/em&gt; . (В стандарте SQL используется термин &amp;laquo;кластер каталога&amp;raquo;.) Кластер базы данных - это набор баз данных, которым управляет единственный экземпляр работающего сервера баз данных. После инициализации кластер базы данных будет содержать базу данных с именем &lt;code&gt;postgres&lt;/code&gt; , которая предназначена как база данных по умолчанию для использования утилитами, пользователями и сторонними приложениями. Самому серверу базы данных не требуется &lt;code&gt;postgres&lt;/code&gt; базы данных postgres , но многие внешние служебные программы предполагают, что она существует. Другая база данных, созданная в каждом кластере во время инициализации, называется &lt;code&gt;template1&lt;/code&gt; .. Как следует из названия, он будет использоваться в качестве шаблона для создаваемых впоследствии баз данных; его не следует использовать для реальной работы. ( Информацию о создании новых баз данных в кластере см. В &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;главе 22.&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="80b6d48dacb8cea98d5f49fb8a5fb0ff5e17a88f" translate="yes" xml:space="preserve">
          <source>Before you can do anything, you must initialize a database storage area on disk. We call this a &lt;em&gt;database cluster&lt;/em&gt;. (The SQL standard uses the term catalog cluster.) A database cluster is a collection of databases that is managed by a single instance of a running database server. After initialization, a database cluster will contain a database named &lt;code&gt;postgres&lt;/code&gt;, which is meant as a default database for use by utilities, users and third party applications. The database server itself does not require the &lt;code&gt;postgres&lt;/code&gt; database to exist, but many external utility programs assume it exists. Another database created within each cluster during initialization is called &lt;code&gt;template1&lt;/code&gt;. As the name suggests, this will be used as a template for subsequently created databases; it should not be used for actual work. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for information about creating new databases within a cluster.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5021e6ec2c149bc593346cdbced55fdf083dae8" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to load an extension into a database, the extension's supporting files must be installed. Information about installing the extensions supplied with PostgreSQL can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Additional Supplied Modules&lt;/a&gt;.</source>
          <target state="translated">Прежде чем вы сможете использовать &lt;code&gt;CREATE EXTENSION&lt;/code&gt; для загрузки расширения в базу данных, необходимо установить вспомогательные файлы расширения. Информацию об установке расширений, поставляемых с PostgreSQL, можно найти в &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;дополнительных поставляемых модулях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="083511ee8f3db20d9fdeeef0f34879a74ab033ad" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to load an extension into a database, the extension's supporting files must be installed. Information about installing the extensions supplied with PostgreSQL can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Additional Supplied Modules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42b034c7e4f7289aaf07ce4a58233afbf01dc95" translate="yes" xml:space="preserve">
          <source>Before you can use PostgreSQL you need to install it, of course. It is possible that PostgreSQL is already installed at your site, either because it was included in your operating system distribution or because the system administrator already installed it. If that is the case, you should obtain information from the operating system documentation or your system administrator about how to access PostgreSQL.</source>
          <target state="translated">Разумеется,перед тем,как использовать PostgreSQL,необходимо его установить.Возможно,что PostgreSQL уже установлен на вашем сайте,либо потому,что он включен в дистрибутив операционной системы,либо потому,что его уже установил системный администратор.Если это так,то вы должны получить информацию о том,как получить доступ к PostgreSQL,в документации по операционной системе или у вашего системного администратора.</target>
        </trans-unit>
        <trans-unit id="b26dbac1aa32ad5c0e931ef76f5f13b493f4cca5" translate="yes" xml:space="preserve">
          <source>Begin recovery on the standby server from the local WAL archive, using &lt;code&gt;restore_command&lt;/code&gt; that waits as described previously (see &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">Начните восстановление на резервном сервере из локального архива WAL, используя &lt;code&gt;restore_command&lt;/code&gt; которая ожидает, как описано ранее (см. &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Раздел 25.3.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b089abb1b8e490f01578f107a306004e919d4fa6" translate="yes" xml:space="preserve">
          <source>Begin streaming changes from the logical replication slot specified by &lt;code&gt;--slot&lt;/code&gt;, continuing until terminated by a signal. If the server side change stream ends with a server shutdown or disconnect, retry in a loop unless &lt;code&gt;--no-loop&lt;/code&gt; is specified.</source>
          <target state="translated">Начать потоковую передачу изменений из логического слота репликации, указанного параметром &lt;code&gt;--slot&lt;/code&gt; , до тех пор, пока он не будет завершен сигналом. Если поток изменений на стороне сервера заканчивается выключением или отключением сервера, повторите попытку в цикле, если не указано &lt;code&gt;--no-loop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5723f3fda46717e1c7feda49b72b28e567ff2c36" translate="yes" xml:space="preserve">
          <source>Begin the output with a command to create the database itself and reconnect to the created database. (With a script of this form, it doesn't matter which database in the destination installation you connect to before running the script.) If &lt;code&gt;--clean&lt;/code&gt; is also specified, the script drops and recreates the target database before reconnecting to it.</source>
          <target state="translated">Начните вывод с команды для создания самой базы данных и повторного подключения к созданной базе данных. (Для сценария этой формы не имеет значения, к какой базе данных в целевой установке вы подключаетесь перед запуском сценария.) Если также указан &lt;code&gt;--clean&lt;/code&gt; , сценарий удаляет и воссоздает целевую базу данных перед повторным подключением к ней.</target>
        </trans-unit>
        <trans-unit id="039cd3e67eb5290833876444452a3461967b021e" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.1, these index types also support index searches for &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;ILIKE&lt;/code&gt;, for example</source>
          <target state="translated">Начиная с PostgreSQL 9.1, эти типы индексов также поддерживают поиск по индексу для &lt;code&gt;LIKE&lt;/code&gt; и &lt;code&gt;ILIKE&lt;/code&gt; , например</target>
        </trans-unit>
        <trans-unit id="50f6ae535e6d21e272577a4aeb90ccdf9bd1fc99" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.3, these index types also support index searches for regular-expression matches (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; operators), for example</source>
          <target state="translated">Начиная с PostgreSQL 9.3, эти типы индексов также поддерживают поиск по индексу совпадений регулярных выражений ( операторы &lt;code&gt;~&lt;/code&gt; и &lt;code&gt;~*&lt;/code&gt; ), например</target>
        </trans-unit>
        <trans-unit id="e18ae86eb6dacc56f3e992def21c4e72f662c365" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">Работает так же, как &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; , за исключением того, что изменения не потребляются; то есть они будут возвращены снова при будущих звонках.</target>
        </trans-unit>
        <trans-unit id="2cc29d4604bab2d23897cf42e9aa658714f98b76" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt; and that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">Ведет себя так же, как &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; , за исключением того, что изменения возвращаются как &lt;code&gt;bytea&lt;/code&gt; и изменения не потребляются; то есть они будут возвращены снова при будущих звонках.</target>
        </trans-unit>
        <trans-unit id="0d8b3d76c539629fdd464e88d07fda0a141c2719" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="translated">Работает так же, как &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; , за исключением того, что изменения возвращаются как &lt;code&gt;bytea&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52757979ec3d8a6995e55b22d0069c2c9da4e33a" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_peek_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e28951f118886fb1db9aad1518cc8230f657d1" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, except that it acquires a shared lock rather than exclusive lock on each retrieved row. A shared lock blocks other transactions from performing &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; or &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; on these rows, but it does not prevent them from performing &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">Действует аналогично &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; , за исключением того, что получает общую блокировку, а не эксклюзивную блокировку для каждой полученной строки. Общая блокировка блокирует выполнение другими транзакциями &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; или &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; для этих строк, но не мешает им выполнять &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; или &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4166e40468956f25d587c502c88de582346f3e60" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR SHARE&lt;/code&gt;, except that the lock is weaker: &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; is blocked, but not &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;. A key-shared lock blocks other transactions from performing &lt;code&gt;DELETE&lt;/code&gt; or any &lt;code&gt;UPDATE&lt;/code&gt; that changes the key values, but not other &lt;code&gt;UPDATE&lt;/code&gt;, and neither does it prevent &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">Действует аналогично &lt;code&gt;FOR SHARE&lt;/code&gt; , за исключением того, что блокировка слабее: &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; блокируется, но не &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; . Блокировка с общим ключом не позволяет другим транзакциям выполнять &lt;code&gt;DELETE&lt;/code&gt; или любое &lt;code&gt;UPDATE&lt;/code&gt; которое изменяет значения ключа, но не другое &lt;code&gt;UPDATE&lt;/code&gt; , а также не предотвращает &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; , &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; или &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3975839e55e061601c3038a505012e75c26cc40" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR UPDATE&lt;/code&gt;, except that the lock acquired is weaker: this lock will not block &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; commands that attempt to acquire a lock on the same rows. This lock mode is also acquired by any &lt;code&gt;UPDATE&lt;/code&gt; that does not acquire a &lt;code&gt;FOR UPDATE&lt;/code&gt; lock.</source>
          <target state="translated">Действует аналогично &lt;code&gt;FOR UPDATE&lt;/code&gt; , за исключением того, что полученная блокировка слабее: эта блокировка не будет блокировать команды &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; , которые пытаются получить блокировку для тех же строк. Этот режим блокировки также используется любым &lt;code&gt;UPDATE&lt;/code&gt; которое не получает блокировку &lt;code&gt;FOR UPDATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfbd41304878c2d772d5d897e0245d1caed66504" translate="yes" xml:space="preserve">
          <source>Behavior of B-Tree Operator Classes</source>
          <target state="translated">Поведение оператора класса B-дерева</target>
        </trans-unit>
        <trans-unit id="126af5216968b8a395d1e58cbc6d82b4d656f6fb" translate="yes" xml:space="preserve">
          <source>Below is a larger example of how this feature can be used in production environments. The table &lt;code&gt;passwd&lt;/code&gt; emulates a Unix password file:</source>
          <target state="translated">Ниже приведен более крупный пример того, как эту функцию можно использовать в производственных средах. Таблица &lt;code&gt;passwd&lt;/code&gt; эмулирует файл паролей Unix:</target>
        </trans-unit>
        <trans-unit id="7fca4fa390ed5f3e5c9eff1ebae50bc1ae5a07f1" translate="yes" xml:space="preserve">
          <source>Below we create a dictionary and bind some token types to an astronomical thesaurus and English stemmer:</source>
          <target state="translated">Ниже мы создадим словарь и привяжем некоторые типы жетонов к астрономическому тезауру и английскому стволовику:</target>
        </trans-unit>
        <trans-unit id="870f5d9661b7407b932b1598182f5f2d810cf9fe" translate="yes" xml:space="preserve">
          <source>Benchmarking Options</source>
          <target state="translated">Опции сопоставления с контрольными показателями</target>
        </trans-unit>
        <trans-unit id="2fb7c98fc75cb4f79b347af89afb1652e417df34" translate="yes" xml:space="preserve">
          <source>Besides the configuration parameters documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;, there are a few that can only be adjusted using the &lt;code&gt;SET&lt;/code&gt; command or that have a special syntax:</source>
          <target state="translated">Помимо параметров конфигурации, описанных в &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;главе 19&lt;/a&gt; , есть несколько, которые можно настроить только с помощью команды &lt;code&gt;SET&lt;/code&gt; или которые имеют специальный синтаксис:</target>
        </trans-unit>
        <trans-unit id="ef6d7a0bd27a4a7a7898b15686b3e50c0c08dc1a" translate="yes" xml:space="preserve">
          <source>Besides the configuration parameters documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;, there are a few that can only be adjusted using the &lt;code&gt;SET&lt;/code&gt; command or that have a special syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdcdb56c299825a17bc63b94d508dafd4fc2a95" translate="yes" xml:space="preserve">
          <source>Between (inclusive of the range endpoints).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c66d70ecd66ce14264e1d077f56c53c9c3ae8a" translate="yes" xml:space="preserve">
          <source>Between, after sorting the two endpoint values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60abe3d5ae299760f0dd57db1ab7b6b69b7cc66b" translate="yes" xml:space="preserve">
          <source>Beware that recent releases of macOS ignore attempts to set &lt;code&gt;SHMMAX&lt;/code&gt; to a value that isn't an exact multiple of 4096.</source>
          <target state="translated">Помните, что последние выпуски macOS игнорируют попытки установить для &lt;code&gt;SHMMAX&lt;/code&gt; значение, не кратное 4096.</target>
        </trans-unit>
        <trans-unit id="b80b5f7ca59611a24bc9604afc3876b56110cee0" translate="yes" xml:space="preserve">
          <source>Beware that the &lt;code&gt;ROWS&lt;/code&gt; mode can produce unpredictable results if the &lt;code&gt;ORDER BY&lt;/code&gt; ordering does not order the rows uniquely. The &lt;code&gt;RANGE&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; modes are designed to ensure that rows that are peers in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.</source>
          <target state="translated">Помните, что режим &lt;code&gt;ROWS&lt;/code&gt; может привести к непредсказуемым результатам, если упорядочение &lt;code&gt;ORDER BY&lt;/code&gt; не однозначно упорядочивает строки. В &lt;code&gt;RANGE&lt;/code&gt; и &lt;code&gt;GROUPS&lt;/code&gt; режимы предназначены для обеспечения того , чтобы строки, которые сверстники в &lt;code&gt;ORDER BY&lt;/code&gt; заказа обрабатывает так: все строки данной экспертной группы будет находиться в кадре или исключен из него.</target>
        </trans-unit>
        <trans-unit id="774be1cf4f3a522f1a25f2b6316b0d501136298e" translate="yes" xml:space="preserve">
          <source>Beware that this approach can fail if the outer query level contains additional processing, such as a join, because that might cause the subquery's output to be reordered before the aggregate is computed.</source>
          <target state="translated">Остерегайтесь,что этот подход может провалиться,если уровень внешнего запроса содержит дополнительную обработку,такую как соединение,потому что это может привести к переупорядочиванию результатов подзапроса перед вычислением агрегата.</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="4afac498b0186c05ae272a50fdfb777d86f83f5a" translate="yes" xml:space="preserve">
          <source>Big Five</source>
          <target state="translated">Большая пятерка</target>
        </trans-unit>
        <trans-unit id="05792c2e47b633979450a4d3fdc731bebb67e917" translate="yes" xml:space="preserve">
          <source>Binary Data Types</source>
          <target state="translated">Типы двоичных данных</target>
        </trans-unit>
        <trans-unit id="d978fc265919867464402ead8b5aa5056e5fbd19" translate="yes" xml:space="preserve">
          <source>Binary Data Types: bytea</source>
          <target state="translated">Типы двоичных данных:байты</target>
        </trans-unit>
        <trans-unit id="be10328dd5eb2024df80c19f0915f781f57e2ed4" translate="yes" xml:space="preserve">
          <source>Binary Format</source>
          <target state="translated">двоичный формат</target>
        </trans-unit>
        <trans-unit id="eea185b10ff34a7d0730fbc39d8d1573222be81b" translate="yes" xml:space="preserve">
          <source>Binary String Functions and Operators</source>
          <target state="translated">Двоичные строковые функции и операторы</target>
        </trans-unit>
        <trans-unit id="cbcfd399e3b6e28f48b32806c48d9294b5084ef2" translate="yes" xml:space="preserve">
          <source>Binary String: bit_length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8dff4368de0e3c40124e448acd2ca6783cd44df" translate="yes" xml:space="preserve">
          <source>Binary String: btrim</source>
          <target state="translated">Двоичная строка:btrim</target>
        </trans-unit>
        <trans-unit id="3d3110a88c097ff95d0ceb59cb2d12b59b1aeb9f" translate="yes" xml:space="preserve">
          <source>Binary String: convert</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8938914c9b70ca934924b934ba9839025c7024" translate="yes" xml:space="preserve">
          <source>Binary String: convert_from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e921f5d76c05cb18ae66971b494afa6830c1fe08" translate="yes" xml:space="preserve">
          <source>Binary String: convert_to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab4683aaea619005a4200cd9a5215872f4f193a" translate="yes" xml:space="preserve">
          <source>Binary String: decode</source>
          <target state="translated">Двоичная строка:расшифровка</target>
        </trans-unit>
        <trans-unit id="1bb599e86584900c656608c4be089126932fb4ca" translate="yes" xml:space="preserve">
          <source>Binary String: encode</source>
          <target state="translated">Двоичная строка:кодирование</target>
        </trans-unit>
        <trans-unit id="ed9e62f8973e5d6bffd91187c9e478de6423b5ec" translate="yes" xml:space="preserve">
          <source>Binary String: get_bit</source>
          <target state="translated">Двоичная строка:get_bit</target>
        </trans-unit>
        <trans-unit id="a7dc78314758d39820bb026c008feb884ce531ff" translate="yes" xml:space="preserve">
          <source>Binary String: get_byte</source>
          <target state="translated">Двоичная строка:get_byte</target>
        </trans-unit>
        <trans-unit id="3b3dfd58346ed838c2d28b9b46ab8febf746666b" translate="yes" xml:space="preserve">
          <source>Binary String: length</source>
          <target state="translated">Двоичная строка:длина</target>
        </trans-unit>
        <trans-unit id="3d6bb6f2a913f2fe4e19cd19b79eb492e8027877" translate="yes" xml:space="preserve">
          <source>Binary String: md5</source>
          <target state="translated">Двоичная строка:мд5</target>
        </trans-unit>
        <trans-unit id="2b6e00319f3a8699a801221f672b9e6fae165f94" translate="yes" xml:space="preserve">
          <source>Binary String: octet_length</source>
          <target state="translated">Двоичная строка:octet_length</target>
        </trans-unit>
        <trans-unit id="549d7f8bb245593c2f0ec51b5eecfcb99bfc4c36" translate="yes" xml:space="preserve">
          <source>Binary String: overlay</source>
          <target state="translated">Двоичная строка:наложение</target>
        </trans-unit>
        <trans-unit id="317470b7465e50bb01ea0ed9d647db9aa1569cbc" translate="yes" xml:space="preserve">
          <source>Binary String: position</source>
          <target state="translated">Двоичная строка:позиция</target>
        </trans-unit>
        <trans-unit id="9434d0dc118c447e4ee164199720303685e8f31a" translate="yes" xml:space="preserve">
          <source>Binary String: set_bit</source>
          <target state="translated">Двоичная строка:set_bit</target>
        </trans-unit>
        <trans-unit id="f39a20b22ec73f10ccf2ff12ede513b3bf197e16" translate="yes" xml:space="preserve">
          <source>Binary String: set_byte</source>
          <target state="translated">Двоичная строка:set_byte</target>
        </trans-unit>
        <trans-unit id="edd1f7f5db831e55c4404df9e415cec21d97ca8d" translate="yes" xml:space="preserve">
          <source>Binary String: sha224</source>
          <target state="translated">Двоичная строка:sha224</target>
        </trans-unit>
        <trans-unit id="a4e5fd05bd7c2057fbb588451d73bc8e364bcd00" translate="yes" xml:space="preserve">
          <source>Binary String: sha256</source>
          <target state="translated">Двоичная строка:sha256</target>
        </trans-unit>
        <trans-unit id="199ba90dac671366fc2d30018bc9cc60da6d8112" translate="yes" xml:space="preserve">
          <source>Binary String: sha384</source>
          <target state="translated">Двоичная строка:sha384</target>
        </trans-unit>
        <trans-unit id="b17b7742692d6cc8900d5a09fbba1ba2dcf79e2d" translate="yes" xml:space="preserve">
          <source>Binary String: sha512</source>
          <target state="translated">Двоичная строка:sha512</target>
        </trans-unit>
        <trans-unit id="138398c9ed1548fd9d09e373d02441ec780c3dba" translate="yes" xml:space="preserve">
          <source>Binary String: substr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb754287eb3b8d22b0752ef54dea23d275538097" translate="yes" xml:space="preserve">
          <source>Binary String: substring</source>
          <target state="translated">Двоичная строка:подстрока</target>
        </trans-unit>
        <trans-unit id="0880194133ad39b402dac81c879f4881bf8922df" translate="yes" xml:space="preserve">
          <source>Binary String: trim</source>
          <target state="translated">Двоичная строка:отделка</target>
        </trans-unit>
        <trans-unit id="4b19a17003e3a215c61a3139f7843b960e175e71" translate="yes" xml:space="preserve">
          <source>Binary String: ||</source>
          <target state="translated">Двоичная струна:||</target>
        </trans-unit>
        <trans-unit id="c41bc309d8cd529592e339f0c36e8e967a2fed13" translate="yes" xml:space="preserve">
          <source>Binary cursors are a PostgreSQL extension.</source>
          <target state="translated">Бинарные курсоры являются расширением PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="6b44f09a82f5b765933694a9db3f15e511f15291" translate="yes" xml:space="preserve">
          <source>Binary cursors should be used carefully. Many applications, including psql, are not prepared to handle binary cursors and expect data to come back in the text format.</source>
          <target state="translated">Двоичные курсоры следует использовать осторожно.Многие приложения,включая psql,не готовы к работе с бинарными курсорами и ожидают,что данные вернутся в текстовом формате.</target>
        </trans-unit>
        <trans-unit id="253c59e522f194890c38a49fa034c56d5597e5ce" translate="yes" xml:space="preserve">
          <source>Bit 16</source>
          <target state="translated">бит 16</target>
        </trans-unit>
        <trans-unit id="b304e502a60fe2721a2acc2ea86477e058a5fc18" translate="yes" xml:space="preserve">
          <source>Bit String Functions and Operators</source>
          <target state="translated">Функции и операторы битовой строки</target>
        </trans-unit>
        <trans-unit id="e1ec8af5ed0ac3706706e7ca0257fb8472997bd9" translate="yes" xml:space="preserve">
          <source>Bit String Types</source>
          <target state="translated">Типы битовых струн</target>
        </trans-unit>
        <trans-unit id="26d5338edfde42da5636b07f3a1f7b3b99348954" translate="yes" xml:space="preserve">
          <source>Bit String: #</source>
          <target state="translated">Бит-стринг:#</target>
        </trans-unit>
        <trans-unit id="54a89e1d14e86ab43af7735b61c206ac06fd6632" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;amp;</source>
          <target state="translated">Битовая строка: &amp;amp;</target>
        </trans-unit>
        <trans-unit id="25bf3896db23b3430dc3419d701ee4519f795bf6" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;gt;&amp;gt;</source>
          <target state="translated">Битовая строка: &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d52a6739aec041222c397e3ab3508452bbdace4c" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;lt;&amp;lt;</source>
          <target state="translated">Битовая строка: &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="698c5053f7fb4235a075904b83c81d0e7f75e767" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; # B&amp;#x27;01101&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fec3321c838e2393b12b6d782dae5847bd67b84" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;amp; B&amp;#x27;01101&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80854d98441f5f666a756550418ab3915bb0869" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;gt;&amp;gt; 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020f62b450e6a960545b1de75bca157ae03bc7a2" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;lt;&amp;lt; 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcb968f9fd9173bd5d0d4f8617eb3f6d27f69c3" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; | B&amp;#x27;01101&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292bdc723b3de75f45f35aaf3b8989a7fc5eb2b2" translate="yes" xml:space="preserve">
          <source>Bit String: bit_length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918db4fa99e0649c8060902f9a3e94ba75c279e0" translate="yes" xml:space="preserve">
          <source>Bit String: get_bit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6891e5dceae12938ae30b567970719872fccde2c" translate="yes" xml:space="preserve">
          <source>Bit String: length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5f6f7cb2e1bc80a507138569c25bed2001e0f1" translate="yes" xml:space="preserve">
          <source>Bit String: octet_length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00634ec6386463ae42b1b7bb26891e1338c4b35c" translate="yes" xml:space="preserve">
          <source>Bit String: overlay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d8c1cd0116787005f4bee7aff429712b20961" translate="yes" xml:space="preserve">
          <source>Bit String: position</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f3120e8f7e91a683313ad8017d180967d09509" translate="yes" xml:space="preserve">
          <source>Bit String: set_bit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb70e33ea681844ee935ae674a0a87b670e898dd" translate="yes" xml:space="preserve">
          <source>Bit String: substring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e47fbeeacb2ccb2058a0e13885d27607dc2ff89" translate="yes" xml:space="preserve">
          <source>Bit String: |</source>
          <target state="translated">Бит-стринг:|</target>
        </trans-unit>
        <trans-unit id="a9f58217517f242096405bc47fb766301ddb90d4" translate="yes" xml:space="preserve">
          <source>Bit String: ||</source>
          <target state="translated">Бит-стринг:||</target>
        </trans-unit>
        <trans-unit id="fb535d3c1297857f6c6638c764b59c16782c04dd" translate="yes" xml:space="preserve">
          <source>Bit String: ~</source>
          <target state="translated">Бит-стринг:~</target>
        </trans-unit>
        <trans-unit id="91c158702eba7e22d8c0b8480c6181f06bc8d6e5" translate="yes" xml:space="preserve">
          <source>Bit String: ~ B&amp;#x27;10001&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2efae331bc5aa821406a784a6e78c0b9daf6c7df" translate="yes" xml:space="preserve">
          <source>Bit mask identifying trigger firing conditions</source>
          <target state="translated">Битовая маска,определяющая условия стрельбы на спусковом крючке</target>
        </trans-unit>
        <trans-unit id="35edcdbad2868d30fa30834e2406d3005ac8363c" translate="yes" xml:space="preserve">
          <source>Bit strings are strings of 1's and 0's. They can be used to store or visualize bit masks. There are two SQL bit types: &lt;code&gt;bit(n)&lt;/code&gt; and &lt;code&gt;bit varying(n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a positive integer.</source>
          <target state="translated">Битовые строки - это строки из единиц и нулей. Их можно использовать для хранения или визуализации битовых масок. Существует два типа &lt;code&gt;bit(n)&lt;/code&gt; SQL: бит (n) и &lt;code&gt;bit varying(n)&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - положительное целое число.</target>
        </trans-unit>
        <trans-unit id="440588c03e76a6dbf3a0dad3d94ffb56eaf0107d" translate="yes" xml:space="preserve">
          <source>Bit-string constants look like regular string constants with a &lt;code&gt;B&lt;/code&gt; (upper or lower case) immediately before the opening quote (no intervening whitespace), e.g., &lt;code&gt;B'1001'&lt;/code&gt;. The only characters allowed within bit-string constants are &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Константы в виде битовой строки выглядят как обычные строковые константы с &lt;code&gt;B'1001'&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; (в верхнем или нижнем регистре) непосредственно перед открывающей кавычкой (без промежуточных пробелов), например B'1001 ' . В константах битовой строки разрешены только символы &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef8b2561e514bdc32792b41e10c969f64c960716" translate="yes" xml:space="preserve">
          <source>Bit-string types</source>
          <target state="translated">типы бит-стринг</target>
        </trans-unit>
        <trans-unit id="3119bee988c6c128ef1a7a4d003a2772fc4ae36a" translate="yes" xml:space="preserve">
          <source>BitmapAnd and BitmapOr nodes always report their actual row counts as zero, due to implementation limitations.</source>
          <target state="translated">BitmapAnd и BitmapOr узлы всегда сообщают о том,что их реальная строка считается нулевой,в связи с ограничениями по реализации.</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2461564dd1b0dd1dfe10a6e27226bb4f00cb800c" translate="yes" xml:space="preserve">
          <source>Bitwise AND (inputs must be of equal length)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a7a98dcaae40a13757076e24af311dfee77860" translate="yes" xml:space="preserve">
          <source>Bitwise OR (inputs must be of equal length)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba80ac4bf1c4bbad0f4a7d6ddfd25841835e177" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16eb5b05790cd70e7dd8947da148a14b1c3b585" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR (inputs must be of equal length)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8659c0b8789aa4ee715f09528a9e4eecaaa826e" translate="yes" xml:space="preserve">
          <source>Bitwise shift left</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b90f67d593a4af9275c5c94d26eb0e231cb737a" translate="yes" xml:space="preserve">
          <source>Bitwise shift left (string length is preserved)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50231ce6a71d579851db8fdf27b3184364b82e41" translate="yes" xml:space="preserve">
          <source>Bitwise shift right</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8813dffcb464fd01e7635b2efefa7c701a1bc5" translate="yes" xml:space="preserve">
          <source>Bitwise shift right (string length is preserved)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfd5b423062918623ca47aa91c65abf2e858720" translate="yes" xml:space="preserve">
          <source>Bloat</source>
          <target state="translated">Bloat</target>
        </trans-unit>
        <trans-unit id="6f50e3e14cce1a8627751575e909b4caa4d3a6a3" translate="yes" xml:space="preserve">
          <source>Bloom is better than btree in handling this type of search:</source>
          <target state="translated">Bloom лучше,чем btree,в работе с этим типом поиска:</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="92c882ac33d0ee2cd51460d3e115370fb18b7f64" translate="yes" xml:space="preserve">
          <source>Blowfish cipher</source>
          <target state="translated">шифр Blowfish</target>
        </trans-unit>
        <trans-unit id="38d26af6e5082bc6e784c3815947a0f5acecada7" translate="yes" xml:space="preserve">
          <source>Blowfish crypt</source>
          <target state="translated">склеп Петуха</target>
        </trans-unit>
        <trans-unit id="17d54f2a65a51558dd8c1f3e789157750ff7d6f8" translate="yes" xml:space="preserve">
          <source>Blowfish-based, variant 2a</source>
          <target state="translated">на основе паяльной рыбы,вариант 2а</target>
        </trans-unit>
        <trans-unit id="58299c5eb711f9a461ff1240fa8b1c0679ab5056" translate="yes" xml:space="preserve">
          <source>Boolean AND</source>
          <target state="translated">булев И</target>
        </trans-unit>
        <trans-unit id="c69f2185492e832f7277d3fff7b42d01f558fb61" translate="yes" xml:space="preserve">
          <source>Boolean NOT</source>
          <target state="translated">НЕ БУЛЕВО</target>
        </trans-unit>
        <trans-unit id="2c320907721a13b5dd2b75f194044bf4fb118e32" translate="yes" xml:space="preserve">
          <source>Boolean OR</source>
          <target state="translated">булева ИЛИ</target>
        </trans-unit>
        <trans-unit id="54bd3ce38554ce1715613858323d1049c39c0685" translate="yes" xml:space="preserve">
          <source>Boolean Type</source>
          <target state="translated">булевский тип</target>
        </trans-unit>
        <trans-unit id="9656fd514386a9028815794334d9467f9f5a0c5e" translate="yes" xml:space="preserve">
          <source>Boolean Type: boolean</source>
          <target state="translated">Булевский тип:булевский</target>
        </trans-unit>
        <trans-unit id="d602b755186d61e697c04da0a7d821ff7d4efa39" translate="yes" xml:space="preserve">
          <source>Boolean aggregates &lt;code&gt;bool_and&lt;/code&gt; and &lt;code&gt;bool_or&lt;/code&gt; correspond to standard SQL aggregates &lt;code&gt;every&lt;/code&gt; and &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;. As for &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;some&lt;/code&gt;, it seems that there is an ambiguity built into the standard syntax:</source>
          <target state="translated">Логические агрегаты &lt;code&gt;bool_and&lt;/code&gt; и &lt;code&gt;bool_or&lt;/code&gt; соответствуют стандартным агрегатам SQL &lt;code&gt;every&lt;/code&gt; и &lt;code&gt;any&lt;/code&gt; или &lt;code&gt;some&lt;/code&gt; . Что касается &lt;code&gt;any&lt;/code&gt; и &lt;code&gt;some&lt;/code&gt; , кажется, что в стандартный синтаксис встроена двусмысленность:</target>
        </trans-unit>
        <trans-unit id="e7e48e64bd944bf0341a3c4f226c0c85bf62984d" translate="yes" xml:space="preserve">
          <source>Boolean constants can be represented in SQL queries by the SQL key words &lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;FALSE&lt;/code&gt;, and &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Логические константы могут быть представлены в SQL-запросах ключевыми словами SQL &lt;code&gt;TRUE&lt;/code&gt; , &lt;code&gt;FALSE&lt;/code&gt; и &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52e1ee47a7ff1168010b326824ee21ddfeae28c3" translate="yes" xml:space="preserve">
          <source>Boolean types</source>
          <target state="translated">булевы типы</target>
        </trans-unit>
        <trans-unit id="fa793a8aacedef81b06cc550c19f522284580fd4" translate="yes" xml:space="preserve">
          <source>Boolean value tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec240e7050d6f871548eb16c80190949f2f4c3c5" translate="yes" xml:space="preserve">
          <source>Boolean values can also be tested using the predicates</source>
          <target state="translated">Булевы значения также могут быть протестированы с помощью предикатов</target>
        </trans-unit>
        <trans-unit id="61e93ae531636a2f7c54ab2267a73987c4067669" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;NOT NULL&lt;/code&gt; constraints of a partitioned table are always inherited by all its partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints that are marked &lt;code&gt;NO INHERIT&lt;/code&gt; are not allowed to be created on partitioned tables.</source>
          <target state="translated">Оба &lt;code&gt;CHECK&lt;/code&gt; и &lt;code&gt;NOT NULL&lt;/code&gt; ограничения секционированной таблицы всегда наследуется всеми его разделами. Ограничения &lt;code&gt;CHECK&lt;/code&gt; с пометкой &lt;code&gt;NO INHERIT&lt;/code&gt; не могут быть созданы для многораздельных таблиц.</target>
        </trans-unit>
        <trans-unit id="b889ca8993198c7004a576b1cf90c434b540954c" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt; can be any non-null string, with a maximum of 255 characters. The cost parameters specify how much to charge for a character insertion, deletion, or substitution, respectively. You can omit the cost parameters, as in the second version of the function; in that case they all default to 1.</source>
          <target state="translated">И &lt;code&gt;source&lt;/code&gt; и &lt;code&gt;target&lt;/code&gt; могут быть любой строкой, отличной от NULL, длиной не более 255 символов. Параметры стоимости указывают, сколько будет взиматься плата за вставку, удаление или замену символа соответственно. Можно опустить параметры стоимости, как во второй версии функции; в этом случае все они по умолчанию равны 1.</target>
        </trans-unit>
        <trans-unit id="5ea32d54e6cfd34abb39f16058fc4fd6f2961804" translate="yes" xml:space="preserve">
          <source>Both advisory locks and regular locks are stored in a shared memory pool whose size is defined by the configuration variables &lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;. Care must be taken not to exhaust this memory or the server will be unable to grant any locks at all. This imposes an upper limit on the number of advisory locks grantable by the server, typically in the tens to hundreds of thousands depending on how the server is configured.</source>
          <target state="translated">И рекомендательные, и обычные блокировки хранятся в пуле разделяемой памяти, размер которого определяется переменными конфигурации &lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt; и &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; . Следует проявлять осторожность, чтобы не исчерпать эту память, иначе сервер вообще не сможет предоставить какие-либо блокировки. Это накладывает верхний предел на количество рекомендательных блокировок, предоставляемых сервером, обычно от десятков до сотен тысяч в зависимости от того, как настроен сервер.</target>
        </trans-unit>
        <trans-unit id="64fe65c7e1e3e888472be5adaa2902cc6b0a1a3b" translate="yes" xml:space="preserve">
          <source>Both forms of bit-string constant can be continued across lines in the same way as regular string constants. Dollar quoting cannot be used in a bit-string constant.</source>
          <target state="translated">Обе формы битовых стринговых констант могут быть продолжены через линии так же,как и обычные строковые константы.Долларовая кавычка не может быть использована в битовой строковой константе.</target>
        </trans-unit>
        <trans-unit id="2b41d8e55f4edf059d0388795bf4f266c2e06c3f" translate="yes" xml:space="preserve">
          <source>Both minmax and inclusion operator classes support cross-data-type operators, though with these the dependencies become more complicated. The minmax operator class requires a full set of operators to be defined with both arguments having the same data type. It allows additional data types to be supported by defining extra sets of operators. Inclusion operator class operator strategies are dependent on another operator strategy as shown in &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;Table 67.3&lt;/a&gt;, or the same operator strategy as themselves. They require the dependency operator to be defined with the &lt;code&gt;STORAGE&lt;/code&gt; data type as the left-hand-side argument and the other supported data type to be the right-hand-side argument of the supported operator. See &lt;code&gt;float4_minmax_ops&lt;/code&gt; as an example of minmax, and &lt;code&gt;box_inclusion_ops&lt;/code&gt; as an example of inclusion.</source>
          <target state="translated">И minmax, и классы операторов включения поддерживают операторы перекрестных типов данных, хотя с ними зависимости усложняются. Класс операторов minmax требует, чтобы был определен полный набор операторов с обоими аргументами, имеющими один и тот же тип данных. Он позволяет поддерживать дополнительные типы данных путем определения дополнительных наборов операторов. Стратегии операторов класса операторов включения зависят от другой стратегии оператора, как показано в &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;таблице 67.3&lt;/a&gt; , или той же стратегии оператора, что и они сами. Они требуют, чтобы оператор зависимости был определен с типом данных &lt;code&gt;STORAGE&lt;/code&gt; в качестве аргумента левой стороны, а другой поддерживаемый тип данных - аргументом правой стороны поддерживаемого оператора. См. &lt;code&gt;float4_minmax_ops&lt;/code&gt; в качестве примера minmax и &lt;code&gt;box_inclusion_ops&lt;/code&gt; как пример включения.</target>
        </trans-unit>
        <trans-unit id="d935d6e4440b7d13db8dea9774a168802ac598e0" translate="yes" xml:space="preserve">
          <source>Both star symbols and simple words can be quantified to restrict how many labels they can match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6bb44fe8014c95fc406791cc963af10b33bb29" translate="yes" xml:space="preserve">
          <source>Both the maximum precision and the maximum scale of a &lt;code&gt;numeric&lt;/code&gt; column can be configured. To declare a column of type &lt;code&gt;numeric&lt;/code&gt; use the syntax:</source>
          <target state="translated">Можно настроить как максимальную точность, так и максимальный масштаб &lt;code&gt;numeric&lt;/code&gt; столбца. Чтобы объявить столбец &lt;code&gt;numeric&lt;/code&gt; типа, используйте синтаксис:</target>
        </trans-unit>
        <trans-unit id="ea3fb61640ce7586a68af124013d79c4c57b81a1" translate="yes" xml:space="preserve">
          <source>Both the scan position and the mark position (if any) must be maintained consistently in the face of concurrent insertions or deletions in the index. It is OK if a freshly-inserted entry is not returned by a scan that would have found the entry if it had existed when the scan started, or for the scan to return such an entry upon rescanning or backing up even though it had not been returned the first time through. Similarly, a concurrent delete might or might not be reflected in the results of a scan. What is important is that insertions or deletions not cause the scan to miss or multiply return entries that were not themselves being inserted or deleted.</source>
          <target state="translated">И положение сканирования,и положение метки (если таковая имеется)должны поддерживаться последовательно перед лицом одновременных вставок или удалений в индексе.Ничего страшного,если только что вставленная запись не будет возвращена сканом,который нашел бы запись,если бы она существовала на момент начала сканирования,или если скан вернет такую запись при повторном сканировании или резервном копировании,даже если она не была возвращена в первый раз.Аналогичным образом,одновременное удаление может быть отражено или не отражено в результатах сканирования.Важно,чтобы вставка или удаление не приводили к пропуску или умножению возвращаемых записей,которые сами по себе не были вставлены или удалены.</target>
        </trans-unit>
        <trans-unit id="3bce0a8d20dfad3adb1a5af3b099eec9aec7a17c" translate="yes" xml:space="preserve">
          <source>Both the system-wide startup file and the user's personal startup file can be made psql-version-specific by appending a dash and the PostgreSQL major or minor release number to the file name, for example &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; or &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt;. The most specific version-matching file will be read in preference to a non-version-specific file.</source>
          <target state="translated">Как общесистемный файл запуска, так и личный файл запуска пользователя можно сделать зависящим от версии psql, добавив к имени файла тире и основной или дополнительный номер выпуска PostgreSQL, например &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; или &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt; . Наиболее конкретный файл соответствия версии будет прочитан вместо файла, не зависящего от версии.</target>
        </trans-unit>
        <trans-unit id="a9f1bcbf395b360aecae5c7aad8432687c5d0c98" translate="yes" xml:space="preserve">
          <source>Boxes are output using the second syntax.</source>
          <target state="translated">Боксы выводятся с использованием второго синтаксиса.</target>
        </trans-unit>
        <trans-unit id="3b7172d9675205f8063e821e7bb335558a00ea56" translate="yes" xml:space="preserve">
          <source>Boxes are represented by pairs of points that are opposite corners of the box. Values of type &lt;code&gt;box&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">Боксы представлены парами точек, которые находятся в противоположных углах бокса. Значения типа &lt;code&gt;box&lt;/code&gt; задаются с помощью любого из следующих синтаксисов:</target>
        </trans-unit>
        <trans-unit id="80edaabf28ae789b6d2df8969096454a0d5adc8a" translate="yes" xml:space="preserve">
          <source>Brackets (&lt;code&gt;[]&lt;/code&gt;) are used to select the elements of an array. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more information on arrays.</source>
          <target state="translated">Скобки ( &lt;code&gt;[]&lt;/code&gt; ) используются для выбора элементов массива. См. &lt;a href=&quot;arrays&quot;&gt;Раздел 8.15&lt;/a&gt; для получения дополнительной информации о массивах.</target>
        </trans-unit>
        <trans-unit id="a42247eae020c4a6a90987074cedeaeafefcb933" translate="yes" xml:space="preserve">
          <source>Break the input string into tokens and categorize each token as a string, time, time zone, or number.</source>
          <target state="translated">Разбейте входную строку на маркеры и классифицируйте каждую маркерную строку как строку,время,часовой пояс или число.</target>
        </trans-unit>
        <trans-unit id="7f060d64f6791f16fa5efaff60c076733c80c6cc" translate="yes" xml:space="preserve">
          <source>Brian Gladman</source>
          <target state="translated">Брайан Глэдман</target>
        </trans-unit>
        <trans-unit id="ffa9096408246acd9955cddd88051877608e02b2" translate="yes" xml:space="preserve">
          <source>Bucardo</source>
          <target state="translated">Bucardo</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="8d8140d7cfbb395763a377b0065a8f622c660961" translate="yes" xml:space="preserve">
          <source>Build a new index. The index relation has been physically created, but is empty. It must be filled in with whatever fixed data the access method requires, plus entries for all tuples already existing in the table. Ordinarily the &lt;code&gt;ambuild&lt;/code&gt; function will call &lt;code&gt;table_index_build_scan()&lt;/code&gt; to scan the table for existing tuples and compute the keys that need to be inserted into the index. The function must return a palloc'd struct containing statistics about the new index.</source>
          <target state="translated">Создайте новый индекс. Отношение индекса было физически создано, но пусто. Он должен быть заполнен любыми фиксированными данными, необходимыми для метода доступа, плюс записи для всех кортежей, уже существующих в таблице. Обычно функция &lt;code&gt;ambuild&lt;/code&gt; вызывает &lt;code&gt;table_index_build_scan()&lt;/code&gt; для сканирования таблицы на наличие существующих кортежей и вычисления ключей, которые необходимо вставить в индекс. Функция должна возвращать структуру palloc'd, содержащую статистику о новом индексе.</target>
        </trans-unit>
        <trans-unit id="5ab5f75a4f668c4f5eba6aa186b68fe6555350c4" translate="yes" xml:space="preserve">
          <source>Build an empty index, and write it to the initialization fork (&lt;code&gt;INIT_FORKNUM&lt;/code&gt;) of the given relation. This method is called only for unlogged indexes; the empty index written to the initialization fork will be copied over the main relation fork on each server restart.</source>
          <target state="translated">Создайте пустой индекс и запишите его в вилку инициализации ( &lt;code&gt;INIT_FORKNUM&lt;/code&gt; ) данного отношения. Этот метод вызывается только для незарегистрированных индексов; пустой индекс, записанный в вилку инициализации, будет копироваться через вилку основного отношения при каждом перезапуске сервера.</target>
        </trans-unit>
        <trans-unit id="59b2f3dbb6bd6f1f5bde23a4b9bc5f2c1659dd06" translate="yes" xml:space="preserve">
          <source>Build the new PostgreSQL source with &lt;code&gt;configure&lt;/code&gt; flags that are compatible with the old cluster. pg_upgrade will check &lt;code&gt;pg_controldata&lt;/code&gt; to make sure all settings are compatible before starting the upgrade.</source>
          <target state="translated">Соберите новый исходный код PostgreSQL с флагами &lt;code&gt;configure&lt;/code&gt; , совместимыми со старым кластером. pg_upgrade проверит &lt;code&gt;pg_controldata&lt;/code&gt; , чтобы убедиться, что все настройки совместимы, перед запуском обновления.</target>
        </trans-unit>
        <trans-unit id="b0efda5eef1ba866b7542374c8ece9a4b87bf621" translate="yes" xml:space="preserve">
          <source>Build time for a GIN index is very sensitive to the &lt;code&gt;maintenance_work_mem&lt;/code&gt; setting; it doesn't pay to skimp on work memory during index creation.</source>
          <target state="translated">Время построения индекса GIN очень чувствительно к настройке &lt;code&gt;maintenance_work_mem&lt;/code&gt; ; не стоит экономить на рабочей памяти во время создания индекса.</target>
        </trans-unit>
        <trans-unit id="33f8808cf736a2f0f4fe91a19f0db395826f76fd" translate="yes" xml:space="preserve">
          <source>Building Indexes Concurrently</source>
          <target state="translated">Строительные индексы Одновременно</target>
        </trans-unit>
        <trans-unit id="39c26d35b65d38341a1a91676925e41df6b2055c" translate="yes" xml:space="preserve">
          <source>Building an index type that supports concurrent updates usually requires extensive and subtle analysis of the required behavior. For the b-tree and hash index types, you can read about the design decisions involved in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; and &lt;code&gt;src/backend/access/hash/README&lt;/code&gt;.</source>
          <target state="translated">Построение типа индекса, поддерживающего одновременные обновления, обычно требует обширного и тонкого анализа требуемого поведения. Для типов b-tree и hash index вы можете прочитать о проектных решениях, связанных с &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; и &lt;code&gt;src/backend/access/hash/README&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47e5cdcd370dad05acde9abb1ab525b1924edb0a" translate="yes" xml:space="preserve">
          <source>Building large GiST indexes by simply inserting all the tuples tends to be slow, because if the index tuples are scattered across the index and the index is large enough to not fit in cache, the insertions need to perform a lot of random I/O. Beginning in version 9.2, PostgreSQL supports a more efficient method to build GiST indexes based on buffering, which can dramatically reduce the number of random I/Os needed for non-ordered data sets. For well-ordered data sets the benefit is smaller or non-existent, because only a small number of pages receive new tuples at a time, and those pages fit in cache even if the index as whole does not.</source>
          <target state="translated">Построение больших индексов GiST путем простой вставки всех кортежей,как правило,происходит медленно,потому что если кортежи индексов разбросаны по всему индексу,а индекс достаточно большой,чтобы не поместиться в кэш,вставки должны выполнять много случайных входов/выходов.Начиная с версии 9.2,PostgreSQL поддерживает более эффективный метод построения индексов GiST на основе буферизации,что может значительно уменьшить количество случайных входов/выходов,необходимых для неупорядоченных наборов данных.Для хорошо упорядоченных наборов данных преимущество меньше или вообще отсутствует,потому что только небольшое количество страниц одновременно получают новые кортежи,и эти страницы помещаются в кэш,даже если индекс в целом не помещается.</target>
        </trans-unit>
        <trans-unit id="802f99132933c7e50ae4b1dc60414e1dd9622319" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair.</source>
          <target state="translated">Сборка JSON-объекта из текстового массива.Массив должен иметь либо ровно одно измерение с четным количеством членов,в этом случае они берутся как переменные пары ключ/значение,либо два измерения,чтобы каждый внутренний массив имел ровно два элемента,которые берутся как пары ключ/значение.</target>
        </trans-unit>
        <trans-unit id="12655969a97b05cc10e81a0f90560ca3e925543c" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair. All values are converted to JSON strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2aecbff08d9f05062e48cef54ff41a7deab5245" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values.</source>
          <target state="translated">Сборка JSON-объекта из списка вариантов аргументов.По условию,список аргументов состоит из переменных ключей и значений.</target>
        </trans-unit>
        <trans-unit id="3f46fcc8bccbe3831f46147a1da2fc888d15802b" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values. Key arguments are coerced to text; value arguments are converted as per &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_jsonb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad91ede47a5280dfb0e7c89b0ab06f2bb7e0630d" translate="yes" xml:space="preserve">
          <source>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list.</source>
          <target state="translated">Сборка возможно-гетерогенно-печатного JSON-массива из списка вариадических аргументов.</target>
        </trans-unit>
        <trans-unit id="fc07e20c2337d94398080bc4db916907237b8429" translate="yes" xml:space="preserve">
          <source>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list. Each argument is converted as per &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_jsonb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5998f67810590d9a53e6c46c1e94143e2a8d11" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary record from a JSON object (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">Создает произвольную запись из объекта JSON (см. Примечание ниже). Как и все функции, возвращающие &lt;code&gt;record&lt;/code&gt; , вызывающий должен явно определить структуру записи с помощью предложения &lt;code&gt;AS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08637f34c0762d04a0506b89a280023ac2d9b88b" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary set of records from a JSON array of objects (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">Создает произвольный набор записей из массива объектов JSON (см. Примечание ниже). Как и все функции, возвращающие &lt;code&gt;record&lt;/code&gt; , вызывающий должен явно определить структуру записи с помощью предложения &lt;code&gt;AS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd7d28e330cbb1847ac7f97e57334ab1657662f" translate="yes" xml:space="preserve">
          <source>Built-In Functions</source>
          <target state="translated">Встроенные функции</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
