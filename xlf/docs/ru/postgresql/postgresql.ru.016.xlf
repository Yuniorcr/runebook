<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d835303635997cc515233b553b202dd2ca61cd9f" translate="yes" xml:space="preserve">
          <source>More generically, a relation is a set of tuples; for example, the result of a query is also a relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ff6c49fed97ba21bc443a8e95921cd7fef478d" translate="yes" xml:space="preserve">
          <source>More generically, the term &lt;em&gt;schema&lt;/em&gt; is used to mean all data descriptions (&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; definitions, &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraints&lt;/a&gt;, comments, etc) for a given &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; or subset thereof.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c771e450e93955920d70db2f3a188ef32edea882" translate="yes" xml:space="preserve">
          <source>More information about partial indexes can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;, &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt;.</source>
          <target state="translated">Дополнительную информацию о частичных индексах можно найти в &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt; , &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt; и &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc9aa3892ba23ddac98c416e33335aa51d42e075" translate="yes" xml:space="preserve">
          <source>More information about partial indexes can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;, &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9300c1996c675687b056f93327336beacca1fbf" translate="yes" xml:space="preserve">
          <source>More information about the lock modes and locking strategies can be found in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="translated">Более подробную информацию о режимах блокировки и стратегиях блокировки можно найти в &lt;a href=&quot;explicit-locking&quot;&gt;Разделе 13.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef70336c8dc9c2d758937dd2be0326ac89265cd4" translate="yes" xml:space="preserve">
          <source>More information about updating and deleting data is in &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt;. Also see the description of foreign key constraint syntax in the reference documentation for &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">Более подробная информация об обновлении и удалении данных находится в &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;главе 6&lt;/a&gt; . Также см. Описание синтаксиса ограничения внешнего ключа в справочной документации для &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cadcf76a3de36d133ed36e25753f765d08135f4c" translate="yes" xml:space="preserve">
          <source>More information about updating and deleting data is in &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt;. Also see the description of foreign key constraint syntax in the reference documentation for &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e689fb0c34bef953cc6f900b699843e5aff59cf5" translate="yes" xml:space="preserve">
          <source>More information about window functions can be found in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">Более подробную информацию о функциях окна можно найти в &lt;a href=&quot;tutorial-window&quot;&gt;Разделе 3.5&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;Разделе 9.21&lt;/a&gt; и &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Разделе 7.2.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="910afb407202e4aaa34247efa3cbb1ddac8f9709" translate="yes" xml:space="preserve">
          <source>More information about window functions can be found in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29b35804e6bc278cd58dd861059bfbd8e576bad" translate="yes" xml:space="preserve">
          <source>More specifically, setting this value to &lt;code&gt;on&lt;/code&gt; will add a &lt;code&gt;Gather&lt;/code&gt; node to the top of any query plan for which this appears to be safe, so that the query runs inside of a parallel worker. Even when a parallel worker is not available or cannot be used, operations such as starting a subtransaction that would be prohibited in a parallel query context will be prohibited unless the planner believes that this will cause the query to fail. If failures or unexpected results occur when this option is set, some functions used by the query may need to be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (or, possibly, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;).</source>
          <target state="translated">В частности, установка этого значения на &lt;code&gt;on&lt;/code&gt; добавит узел &lt;code&gt;Gather&lt;/code&gt; в начало любого плана запроса, для которого это кажется безопасным, так что запрос будет выполняться внутри параллельного рабочего. Даже если параллельный исполнитель недоступен или не может использоваться, такие операции, как запуск субтранзакции, которая была бы запрещена в контексте параллельного запроса, будут запрещены, если планировщик не считает, что это приведет к сбою запроса. Если при установке этого параметра возникают сбои или неожиданные результаты, некоторые функции, используемые запросом, могут быть помечены &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (или, возможно, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf1a578b87b8dcebec736c6d3df5e511c59a7712" translate="yes" xml:space="preserve">
          <source>More usually, &lt;code&gt;VALUES&lt;/code&gt; is used within a larger SQL command. The most common use is in &lt;code&gt;INSERT&lt;/code&gt;:</source>
          <target state="translated">Чаще всего &lt;code&gt;VALUES&lt;/code&gt; используется в более крупной команде SQL. Чаще всего используется &lt;code&gt;INSERT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f34f1661d8425a72a96b8b7cb49353a492e8fe95" translate="yes" xml:space="preserve">
          <source>Moreover, if we have a function that accepts a single argument of a composite type, we can call it with either notation. These queries are all equivalent:</source>
          <target state="translated">Более того,если у нас есть функция,которая принимает один аргумент составного типа,мы можем вызвать ее с любой нотацией.Все эти запросы эквивалентны:</target>
        </trans-unit>
        <trans-unit id="b6b5cd5fdbfc629a7d3f75be5167b4b144a3f86d" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;pg_ctl&lt;/code&gt; modes require knowing the data directory location; therefore, the &lt;code&gt;-D&lt;/code&gt; option is required unless &lt;code&gt;PGDATA&lt;/code&gt; is set.</source>
          <target state="translated">Большинство режимов &lt;code&gt;pg_ctl&lt;/code&gt; требуют знания местоположения каталога данных; следовательно, опция &lt;code&gt;-D&lt;/code&gt; требуется, если не установлен &lt;code&gt;PGDATA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69cf03cafc4ea41c94813d7e422965750bb31a86" translate="yes" xml:space="preserve">
          <source>Most aggregate functions ignore null inputs, so that rows in which one or more of the expression(s) yield null are discarded. This can be assumed to be true, unless otherwise specified, for all built-in aggregates.</source>
          <target state="translated">Большинство функций агрегата игнорируют нулевые входы,так что строки,в которых одно или несколько выражений дают нулевой результат,отбрасываются.Это можно считать истинным,если не указано иначе,для всех встроенных агрегатов.</target>
        </trans-unit>
        <trans-unit id="7ba0155b71f54b39b68d7c23be1cc2e11116377b" translate="yes" xml:space="preserve">
          <source>Most atoms, and all constraints, have no greediness attribute (because they cannot match variable amounts of text anyway).</source>
          <target state="translated">Большинство атомов и все ограничения не имеют атрибута жадности (потому что они все равно не могут совпадать с переменным количеством текста).</target>
        </trans-unit>
        <trans-unit id="7f53fad77c0918001bf87e5c2287a1e18f906e5e" translate="yes" xml:space="preserve">
          <source>Most common implementations</source>
          <target state="translated">Наиболее распространенные внедрения</target>
        </trans-unit>
        <trans-unit id="750c1315d8a2e4c64b7b2cf3fe9029ccf298aef6" translate="yes" xml:space="preserve">
          <source>Most kinds of catalog objects are simply referenced by their names. Note that type names must exactly match the referenced &lt;code&gt;pg_type&lt;/code&gt; entry's &lt;code&gt;typname&lt;/code&gt;; you do not get to use any aliases such as &lt;code&gt;integer&lt;/code&gt; for &lt;code&gt;int4&lt;/code&gt;.</source>
          <target state="translated">На большинство объектов каталога просто ссылаются по их именам. Обратите внимание, что имена типов должны точно соответствовать имени типа &lt;code&gt;pg_type&lt;/code&gt; записи &lt;code&gt;typname&lt;/code&gt; ; вы не можете использовать псевдонимы, такие как &lt;code&gt;integer&lt;/code&gt; для &lt;code&gt;int4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca0f34a89e8d302478dfd8fb8ad2a79bdc73278" translate="yes" xml:space="preserve">
          <source>Most local objects belong to a specific &lt;a href=&quot;glossary#GLOSSARY-SCHEMA&quot;&gt;schema&lt;/a&gt; in their containing database, such as &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; (all types), &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;routines&lt;/a&gt; (all types), data types, etc. The names of such objects of the same type in the same schema are enforced to be unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbe371d76c6dc7cba4d9098c63670e12f1237d3" translate="yes" xml:space="preserve">
          <source>Most of the functions that reconstruct (decompile) database objects have an optional &lt;em&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/em&gt; flag, which if &lt;code&gt;true&lt;/code&gt; causes the result to be &amp;ldquo;pretty-printed&amp;rdquo;. Pretty-printing suppresses unnecessary parentheses and adds whitespace for legibility. The pretty-printed format is more readable, but the default format is more likely to be interpreted the same way by future versions of PostgreSQL; so avoid using pretty-printed output for dump purposes. Passing &lt;code&gt;false&lt;/code&gt; for the &lt;em&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/em&gt; parameter yields the same result as omitting the parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a098765cd76a02dd3c28ed1a2d6ced931f0a323" translate="yes" xml:space="preserve">
          <source>Most queries retrieve only a fraction of the rows in a table, due to &lt;code&gt;WHERE&lt;/code&gt; clauses that restrict the rows to be examined. The planner thus needs to make an estimate of the &lt;em&gt;selectivity&lt;/em&gt; of &lt;code&gt;WHERE&lt;/code&gt; clauses, that is, the fraction of rows that match each condition in the &lt;code&gt;WHERE&lt;/code&gt; clause. The information used for this task is stored in the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; system catalog. Entries in &lt;code&gt;pg_statistic&lt;/code&gt; are updated by the &lt;code&gt;ANALYZE&lt;/code&gt; and &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; commands, and are always approximate even when freshly updated.</source>
          <target state="translated">Большинство запросов извлекают только часть строк в таблице из-за &lt;code&gt;WHERE&lt;/code&gt; которые ограничивают проверяемые строки. Таким образом , планировщик должен сделать оценку &lt;em&gt;селективности&lt;/em&gt; в &lt;code&gt;WHERE&lt;/code&gt; положений, то есть, доля строк , которые соответствуют каждому условию в &lt;code&gt;WHERE&lt;/code&gt; пункте. Информация, используемая для этой задачи, хранится в системном каталоге &lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt; . Записи в &lt;code&gt;pg_statistic&lt;/code&gt; обновляются командами &lt;code&gt;ANALYZE&lt;/code&gt; и &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; и всегда являются приблизительными, даже если они только что обновлены.</target>
        </trans-unit>
        <trans-unit id="6eb034f582f8c2b79ea5f1d4aeb8e1cc749b45b2" translate="yes" xml:space="preserve">
          <source>Most scalar data types should have a corresponding array type (that is, a standard varlena array type whose element type is the scalar type, and which is referenced by the &lt;code&gt;typarray&lt;/code&gt; field of the scalar type's &lt;code&gt;pg_type&lt;/code&gt; entry). &lt;code&gt;genbki.pl&lt;/code&gt; is able to generate the &lt;code&gt;pg_type&lt;/code&gt; entry for the array type automatically in most cases.</source>
          <target state="translated">Большинство скалярных типов данных должны иметь соответствующий тип массива (то есть, стандартный тип varlena массива, элемент типа является скалярным типом, и который ссылается на &lt;code&gt;typarray&lt;/code&gt; поле скалярного типа по &lt;code&gt;pg_type&lt;/code&gt; входа). &lt;code&gt;genbki.pl&lt;/code&gt; большинстве случаев genbki.pl может автоматически генерировать запись &lt;code&gt;pg_type&lt;/code&gt; для типа массива.</target>
        </trans-unit>
        <trans-unit id="8934cf5770ff56a86643f007085fd816b1b58dfa" translate="yes" xml:space="preserve">
          <source>Most system catalogs are copied from the template database during database creation and are thereafter database-specific. A few catalogs are physically shared across all databases in a cluster; these are noted in the descriptions of the individual catalogs.</source>
          <target state="translated">Большинство системных каталогов копируются из шаблонной базы данных в процессе создания базы данных,а затем они становятся специфическими для конкретной базы данных.Несколько каталогов физически доступны для всех баз данных в кластере;это отмечается в описании отдельных каталогов.</target>
        </trans-unit>
        <trans-unit id="a7bd8e4c0ba4c5fef185f840f580e4a5b9a25b96" translate="yes" xml:space="preserve">
          <source>Most types of dictionaries rely on configuration files, such as files of stop words. These files &lt;em&gt;must&lt;/em&gt; be stored in UTF-8 encoding. They will be translated to the actual database encoding, if that is different, when they are read into the server.</source>
          <target state="translated">Большинство типов словарей полагаются на файлы конфигурации, такие как файлы стоп-слов. Эти файлы &lt;em&gt;должны&lt;/em&gt; храниться в кодировке UTF-8. Они будут переведены в фактическую кодировку базы данных, если она отличается, при считывании на сервер.</target>
        </trans-unit>
        <trans-unit id="4deea28851a7ae4ce56d6b6d82c468bb35f41bb4" translate="yes" xml:space="preserve">
          <source>Most variables that control psql's behavior cannot be unset; instead, an &lt;code&gt;\unset&lt;/code&gt; command is interpreted as setting them to their default values. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473029ab69353e53921e8ecd7440a49c9a86be94" translate="yes" xml:space="preserve">
          <source>Most variables that control psql's behavior cannot be unset; instead, an &lt;code&gt;\unset&lt;/code&gt; command is interpreted as setting them to their default values. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, below.</source>
          <target state="translated">Большинство переменных, управляющих поведением psql, нельзя сбросить; вместо этого команда &lt;code&gt;\unset&lt;/code&gt; интерпретируется как установка их значений по умолчанию. См. &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Переменные&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="7293739c8cef6860367bef80e497db37fda337b4" translate="yes" xml:space="preserve">
          <source>Moving an object to a new schema additionally requires &lt;code&gt;remove_name&lt;/code&gt; permission on the old schema and &lt;code&gt;add_name&lt;/code&gt; permission on the new one.</source>
          <target state="translated">Для перемещения объекта в новую схему дополнительно требуется разрешение &lt;code&gt;remove_name&lt;/code&gt; для старой схемы и разрешение &lt;code&gt;add_name&lt;/code&gt; для новой.</target>
        </trans-unit>
        <trans-unit id="9a676159878bdf52262c05ecb519fb1a7d01d39b" translate="yes" xml:space="preserve">
          <source>Much of the PostgreSQL type system is built around a rich set of functions. Functions can have one or more arguments. Since PostgreSQL permits function overloading, the function name alone does not uniquely identify the function to be called; the parser must select the right function based on the data types of the supplied arguments.</source>
          <target state="translated">Большая часть системы типа PostgreSQL построена вокруг богатого набора функций.Функции могут иметь один или несколько аргументов.Так как PostgreSQL допускает перегрузку функций,имя функции само по себе не идентифицирует однозначно вызываемую функцию;синтаксический анализатор должен выбрать нужную функцию на основе типов данных предоставленных аргументов.</target>
        </trans-unit>
        <trans-unit id="2740f0c680a6e63e450d5b3c062a5229834ae2d2" translate="yes" xml:space="preserve">
          <source>Mule internal code</source>
          <target state="translated">Внутренний код модуля</target>
        </trans-unit>
        <trans-unit id="344fa8c431ce29a1cdabfe9e517c51ceaef15678" translate="yes" xml:space="preserve">
          <source>Multi-Version Concurrency Control</source>
          <target state="translated">Мультиверсионный валютный контроль</target>
        </trans-unit>
        <trans-unit id="99e2646c11c9e1032892edf955d9bbabc4a055aa" translate="yes" xml:space="preserve">
          <source>Multi-version concurrency control (MVCC)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384caf1b9fc6ff1244af37a2f4eefa0674d24a27" translate="yes" xml:space="preserve">
          <source>Multicolumn GIN indexes are implemented by building a single B-tree over composite values (column number, key value). The key values for different columns can be of different types.</source>
          <target state="translated">Многоколоночные GIN-индексы реализуются путем построения одного B-дерева поверх составных значений (номер столбца,ключевое значение).Ключевые значения для разных столбцов могут быть разных типов.</target>
        </trans-unit>
        <trans-unit id="2c159674cdc49534760eb0265af934a2b89d41fe" translate="yes" xml:space="preserve">
          <source>Multicolumn Indexes</source>
          <target state="translated">Многоколоночные индексы</target>
        </trans-unit>
        <trans-unit id="2d93cd8bc72bc57af1ba376ce47d069b6c4a937d" translate="yes" xml:space="preserve">
          <source>Multicolumn indexes should be used sparingly. In most situations, an index on a single column is sufficient and saves space and time. Indexes with more than three columns are unlikely to be helpful unless the usage of the table is extremely stylized. See also &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt; and &lt;a href=&quot;indexes-index-only-scans&quot;&gt;Section 11.9&lt;/a&gt; for some discussion of the merits of different index configurations.</source>
          <target state="translated">Многоколоночные индексы следует использовать с осторожностью. В большинстве случаев достаточно индекса для одного столбца, что позволяет сэкономить место и время. Индексы с более чем тремя столбцами вряд ли будут полезны, если использование таблицы не будет чрезмерно стилизованным. См. Также &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Раздел 11.5&lt;/a&gt; и &lt;a href=&quot;indexes-index-only-scans&quot;&gt;Раздел 11.9&lt;/a&gt; для обсуждения достоинств различных конфигураций индекса.</target>
        </trans-unit>
        <trans-unit id="b99aa634fe16bee7bdf05b0cf7793d76fb5f12b3" translate="yes" xml:space="preserve">
          <source>Multidimensional array constructor elements can be anything yielding an array of the proper kind, not only a sub-&lt;code&gt;ARRAY&lt;/code&gt; construct. For example:</source>
          <target state="translated">Элементами конструктора многомерного массива может быть что угодно, дающее массив надлежащего типа, а не только суб- конструкция &lt;code&gt;ARRAY&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="5dca66d7f2aee43ef1797a393d0e215db306ea18" translate="yes" xml:space="preserve">
          <source>Multidimensional array values can be built by nesting array constructors. In the inner constructors, the key word &lt;code&gt;ARRAY&lt;/code&gt; can be omitted. For example, these produce the same result:</source>
          <target state="translated">Значения многомерных массивов могут быть построены путем вложения конструкторов массивов. Во внутренних конструкторах ключевое слово &lt;code&gt;ARRAY&lt;/code&gt; можно опустить. Например, они дают тот же результат:</target>
        </trans-unit>
        <trans-unit id="b8d7e3b8a7276708d01165024b6293de444e2c11" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays must have matching extents for each dimension. A mismatch causes an error, for example:</source>
          <target state="translated">Многомерные массивы должны иметь соответствующие размеры для каждого измерения.Несоответствие приводит,например,к ошибке:</target>
        </trans-unit>
        <trans-unit id="b92978283c35094160cf22fc851c3df5bcf7effd" translate="yes" xml:space="preserve">
          <source>Multilingual Emacs</source>
          <target state="translated">Многоязычный Эмакс</target>
        </trans-unit>
        <trans-unit id="da392350dc33944a643a54bf379fde9199e79c15" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;EXCEPT&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless parentheses dictate otherwise. &lt;code&gt;EXCEPT&lt;/code&gt; binds at the same level as &lt;code&gt;UNION&lt;/code&gt;.</source>
          <target state="translated">Несколько операторов &lt;code&gt;EXCEPT&lt;/code&gt; в одном &lt;code&gt;SELECT&lt;/code&gt; оцениваются слева направо, если иное не указано в круглых скобках. &lt;code&gt;EXCEPT&lt;/code&gt; связывает на том же уровне, что и &lt;code&gt;UNION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="545da6f8ee31d7740c9c3d5dad863f020a69eb93" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;INTERSECT&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless parentheses dictate otherwise. &lt;code&gt;INTERSECT&lt;/code&gt; binds more tightly than &lt;code&gt;UNION&lt;/code&gt;. That is, &lt;code&gt;A UNION B INTERSECT C&lt;/code&gt; will be read as &lt;code&gt;A UNION (B INTERSECT C)&lt;/code&gt;.</source>
          <target state="translated">Несколько операторов &lt;code&gt;INTERSECT&lt;/code&gt; в одном &lt;code&gt;SELECT&lt;/code&gt; оцениваются слева направо, если иное не указано в скобках. &lt;code&gt;INTERSECT&lt;/code&gt; связывается сильнее, чем &lt;code&gt;UNION&lt;/code&gt; . То есть, &lt;code&gt;A UNION B INTERSECT C&lt;/code&gt; будет читаться как &lt;code&gt;A UNION (B INTERSECT C)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44cc99500b8c6afffdf8915313cbba82fb39e906" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;UNION&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless otherwise indicated by parentheses.</source>
          <target state="translated">Несколько операторов &lt;code&gt;UNION&lt;/code&gt; в одном &lt;code&gt;SELECT&lt;/code&gt; оцениваются слева направо, если иное не указано в скобках.</target>
        </trans-unit>
        <trans-unit id="09ad30df55e0ee1fdeb0db77709134b50e5f6d5c" translate="yes" xml:space="preserve">
          <source>Multiple Identity Columns</source>
          <target state="translated">Несколько идентификационных столбцов</target>
        </trans-unit>
        <trans-unit id="e2933c3051980c1e2e6ec097345b6b77b93e0721" translate="yes" xml:space="preserve">
          <source>Multiple RADIUS servers can be specified, in which case they will be tried sequentially. If a negative response is received from a server, the authentication will fail. If no response is received, the next server in the list will be tried. To specify multiple servers, put the names within quotes and separate the server names with a comma. If multiple servers are specified, all other RADIUS options can also be given as a comma separate list, to apply individual values to each server. They can also be specified as a single value, in which case this value will apply to all servers.</source>
          <target state="translated">Можно указать несколько RADIUS-серверов,в этом случае они будут опробованы последовательно.При получении отрицательного ответа от сервера аутентификация будет неудачной.Если ответ не будет получен,будет произведена попытка подключения следующего сервера из списка.Чтобы указать несколько серверов,поместите имена в кавычки и разделите имена серверов запятой.Если указано несколько серверов,все остальные опции RADIUS также могут быть заданы в виде отдельного списка через запятую,чтобы применить индивидуальные значения к каждому серверу.Они также могут быть указаны как одно значение,в этом случае это значение будет применяться ко всем серверам.</target>
        </trans-unit>
        <trans-unit id="52ee8ebc172afa9611da532af89c4c55f27f12a0" translate="yes" xml:space="preserve">
          <source>Multiple RADIUS servers can be specified, in which case they will be tried sequentially. If a negative response is received from a server, the authentication will fail. If no response is received, the next server in the list will be tried. To specify multiple servers, separate the server names with commas and surround the list with double quotes. If multiple servers are specified, the other RADIUS options can also be given as comma-separated lists, to provide individual values for each server. They can also be specified as a single value, in which case that value will apply to all servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cf9ecc42c00f97b187ac65e4ad87ed8ddddec7" translate="yes" xml:space="preserve">
          <source>Multiple function calls can be combined into a single &lt;code&gt;FROM&lt;/code&gt;-clause item by surrounding them with &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.</source>
          <target state="translated">Несколько вызовов функций можно объединить в один элемент предложения &lt;code&gt;FROM&lt;/code&gt; , заключив их в &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; . Результатом такого элемента является объединение первой строки из каждой функции, затем второй строки из каждой функции и т. Д. Если одни функции производят меньше строк, чем другие, отсутствующие данные заменяются нулевыми значениями, так что общее количество возвращаемых строк всегда такое же, как для функции, которая произвела наибольшее количество строк.</target>
        </trans-unit>
        <trans-unit id="cb041e89d71104ed194545d06d97265abcc8ac5c" translate="yes" xml:space="preserve">
          <source>Multiple inheritance via the &lt;code&gt;INHERITS&lt;/code&gt; clause is a PostgreSQL language extension. SQL:1999 and later define single inheritance using a different syntax and different semantics. SQL:1999-style inheritance is not yet supported by PostgreSQL.</source>
          <target state="translated">Множественное наследование через предложение &lt;code&gt;INHERITS&lt;/code&gt; - это расширение языка PostgreSQL. SQL: 1999 и более поздние версии определяют единичное наследование с использованием другого синтаксиса и другой семантики. Наследование в стиле SQL: 1999 еще не поддерживается PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="dfc4b99f808466861398cb5089390dbcf8288968" translate="yes" xml:space="preserve">
          <source>Multiple initial administrators, and all the other options of &lt;code&gt;CREATE ROLE&lt;/code&gt;, are PostgreSQL extensions.</source>
          <target state="translated">Несколько начальных администраторов и все остальные варианты &lt;code&gt;CREATE ROLE&lt;/code&gt; являются расширениями PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="7023aa5fc8e888d453cd39667bc365999be7e91b" translate="yes" xml:space="preserve">
          <source>Multiple locking clauses can be written if it is necessary to specify different locking behavior for different tables. If the same table is mentioned (or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed as &lt;code&gt;NOWAIT&lt;/code&gt; if that is specified in any of the clauses affecting it. Otherwise, it is processed as &lt;code&gt;SKIP LOCKED&lt;/code&gt; if that is specified in any of the clauses affecting it.</source>
          <target state="translated">Можно написать несколько предложений блокировки, если необходимо указать разное поведение блокировки для разных таблиц. Если одна и та же таблица упоминается (или неявно затрагивается) более чем одним блокирующим предложением, то она обрабатывается, как если бы она была указана только самым сильным. Точно так же таблица обрабатывается как &lt;code&gt;NOWAIT&lt;/code&gt; , если это указано в любом из затрагивающих ее предложений. В противном случае он обрабатывается как &lt;code&gt;SKIP LOCKED&lt;/code&gt; , если это указано в любом из затрагивающих его предложений.</target>
        </trans-unit>
        <trans-unit id="9ff93077b96a2599909c71e452a52b617dcb75f7" translate="yes" xml:space="preserve">
          <source>Multiple-Server Parallel Query Execution</source>
          <target state="translated">Параллельное выполнение многосерверных запросов</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="83d4c1590260d359ecbe9f085d559899657ac6eb" translate="yes" xml:space="preserve">
          <source>Multiplies each point of the first argument by the second &lt;code&gt;point&lt;/code&gt; (treating a point as being a complex number represented by real and imaginary parts, and performing standard complex multiplication). If one interprets the second &lt;code&gt;point&lt;/code&gt; as a vector, this is equivalent to scaling the object's size and distance from the origin by the length of the vector, and rotating it counterclockwise around the origin by the vector's angle from the &lt;code&gt;x&lt;/code&gt; axis. Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;,&lt;a href=&quot;#ftn.FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;&lt;sup id=&quot;FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;&lt;code&gt;path&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f690d76a3a6b4f3cf2f400b6a49ebe14dc72a219" translate="yes" xml:space="preserve">
          <source>Multiply an interval by a scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0c5f6099e92ebebc75583d550cc71584a93e4c" translate="yes" xml:space="preserve">
          <source>Multiply the number of rows generated by the scale factor. For example, &lt;code&gt;-s 100&lt;/code&gt; will create 10,000,000 rows in the &lt;code&gt;pgbench_accounts&lt;/code&gt; table. Default is 1. When the scale is 20,000 or larger, the columns used to hold account identifiers (&lt;code&gt;aid&lt;/code&gt; columns) will switch to using larger integers (&lt;code&gt;bigint&lt;/code&gt;), in order to be big enough to hold the range of account identifiers.</source>
          <target state="translated">Умножьте количество созданных строк на коэффициент масштабирования. Например, &lt;code&gt;-s 100&lt;/code&gt; создаст 10 000 000 строк в таблице &lt;code&gt;pgbench_accounts&lt;/code&gt; . По умолчанию 1. Когда масштаб равен 20 000 или больше, столбцы, используемые для хранения идентификаторов учетных записей ( &lt;code&gt;aid&lt;/code&gt; столбцы), переключатся на использование более крупных целых чисел ( &lt;code&gt;bigint&lt;/code&gt; ), чтобы они были достаточно большими, чтобы вместить диапазон идентификаторов учетных записей.</target>
        </trans-unit>
        <trans-unit id="0b63b41e9535d1638fe83e7fb152d39f9e2c71b6" translate="yes" xml:space="preserve">
          <source>Multivariate Statistics Examples</source>
          <target state="translated">Примеры многомерной статистики</target>
        </trans-unit>
        <trans-unit id="67f1e276e130e436d878dd37efbefd858f1a15f3" translate="yes" xml:space="preserve">
          <source>Multivariate correlation can be demonstrated with a very simple data set &amp;mdash; a table with two columns, both containing the same values:</source>
          <target state="translated">Многомерная корреляция может быть продемонстрирована с помощью очень простого набора данных - таблицы с двумя столбцами, каждый из которых содержит одинаковые значения:</target>
        </trans-unit>
        <trans-unit id="68e9ef2c165e4fa8adf23b844de4bcd199158fae" translate="yes" xml:space="preserve">
          <source>MurmurHash2 hash</source>
          <target state="translated">MurmurHash2 хэш</target>
        </trans-unit>
        <trans-unit id="1d1a603b8a91745540a0eb62aecc8635b092e498" translate="yes" xml:space="preserve">
          <source>Mutation as genetic operator is deprecated so that no repair mechanisms are needed to generate legal TSP tours.</source>
          <target state="translated">Мутация как генетический оператор устарела,так что нет необходимости в ремонтных механизмах для создания легальных TSP туров.</target>
        </trans-unit>
        <trans-unit id="411d403f2e3b649eb2f47189fa6c058b68a3959d" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;), and to his former student Andy Dong for his example written for Illustra. I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">В первую очередь я благодарен профессору Джо Хеллерстайну ( &lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt; ) за разъяснение сути GiST ( &lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt; ) и его бывший студент Энди Донг по своему примеру написал для Illustra. Я также благодарен всем разработчикам Postgres, настоящим и прошлым, за то, что они позволили мне создать свой собственный мир и спокойно жить в нем. И я хотел бы выразить свою благодарность Argonne Lab и Министерству энергетики США за годы верной поддержки моих исследований баз данных.</target>
        </trans-unit>
        <trans-unit id="63806797acec7e92b9e9bba40d5e19f39040d989" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;). I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">Прежде всего я благодарен профессору Джо Хеллерстайну ( &lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt; ) за разъяснение сути GiST ( &lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt; ). Я также благодарен всем разработчикам Postgres, настоящим и прошлым, за то, что они позволили мне создать свой собственный мир и спокойно жить в нем. И я хотел бы выразить свою благодарность Argonne Lab и Министерству энергетики США за годы верной поддержки моих исследований баз данных.</target>
        </trans-unit>
        <trans-unit id="6b165eae6146362f8f4218790f243080eeac62ec" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;), and to his former student Andy Dong for his example written for Illustra. I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c665518a6c8a774be8b227ccf9e0e2930a0b4db" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;). I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990ae3b2652542659607c20d6be633d0e3b25e79" translate="yes" xml:space="preserve">
          <source>MySpell does not support compound words. Hunspell has sophisticated support for compound words. At present, PostgreSQL implements only the basic compound word operations of Hunspell.</source>
          <target state="translated">MySpell не поддерживает сложные слова.В Hunspell есть сложная поддержка сложных слов.В настоящее время PostgreSQL реализует только базовые операции с составными словами Hunspell.</target>
        </trans-unit>
        <trans-unit id="5e441f15c5e733792befe0ffc73906895c439622" translate="yes" xml:space="preserve">
          <source>MySpell format is a subset of Hunspell. The &lt;code&gt;.affix&lt;/code&gt; file of Hunspell has the following structure:</source>
          <target state="translated">Формат MySpell - это подмножество Hunspell. &lt;code&gt;.affix&lt;/code&gt; файл Hunspell имеет следующую структуру:</target>
        </trans-unit>
        <trans-unit id="488df82bbfc103d0d771499379d0ae7070c9580f" translate="yes" xml:space="preserve">
          <source>N-distinct counts for combinations of column values. If greater than zero, the estimated number of distinct values in the combination. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique combination of columns in which the number of distinct combinations is the same as the number of rows.</source>
          <target state="translated">N-различных счетчиков для комбинаций значений столбца. Если больше нуля, предполагаемое количество различных значений в комбинации. Если меньше нуля, отрицательное значение числа различных значений, деленное на количество строк. (Отрицательная форма используется, когда &lt;code&gt;ANALYZE&lt;/code&gt; считает, что количество различных значений может увеличиваться по мере роста таблицы; положительная форма используется, когда кажется, что столбец имеет фиксированное количество возможных значений.) Например, -1 указывает на уникальная комбинация столбцов, в которой количество различных комбинаций совпадает с количеством строк.</target>
        </trans-unit>
        <trans-unit id="b9f3788bf337d1fbd1e44a8ca35f9f8dc00922f3" translate="yes" xml:space="preserve">
          <source>N-distinct counts, serialized as &lt;code&gt;pg_ndistinct&lt;/code&gt; type</source>
          <target state="translated">N-различных счетчиков, сериализованных как тип &lt;code&gt;pg_ndistinct&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df7b392c5a7d73b13e58918e0a512d5732187d0d" translate="yes" xml:space="preserve">
          <source>N.1. When Color is Used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b9c07010036ea2172a9c209c09188b295a72b2" translate="yes" xml:space="preserve">
          <source>N.2. Configuring the Colors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75dedcc315971ca035b9f33d5ff4a268f0acad9" translate="yes" xml:space="preserve">
          <source>NAS</source>
          <target state="translated">NAS</target>
        </trans-unit>
        <trans-unit id="05c70c4a8ccede51b0f764a8b31b48ffad7c77b1" translate="yes" xml:space="preserve">
          <source>NLS</source>
          <target state="translated">NLS</target>
        </trans-unit>
        <trans-unit id="578dc1c57657369feb194b2bc15910a2480a2342" translate="yes" xml:space="preserve">
          <source>NOT &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">НЕ &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efde75752ab811815325697b4ba90b5afbe2e2a6" translate="yes" xml:space="preserve">
          <source>NOTIFY</source>
          <target state="translated">NOTIFY</target>
        </trans-unit>
        <trans-unit id="3e7d70b52328177b60019485c8ea011b37cce023" translate="yes" xml:space="preserve">
          <source>NOTIFY &amp;mdash; generate a notification</source>
          <target state="translated">NOTIFY - генерировать уведомление</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="385a7cff63d2b3c51a6859910c942e284cc2cff9" translate="yes" xml:space="preserve">
          <source>Name of SSL cipher in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">Имя используемого SSL-шифра,или NULL,если SSL не используется на этом соединении.</target>
        </trans-unit>
        <trans-unit id="5eaeda54ec9eb68b2072fa5d1feb6c035f44d644" translate="yes" xml:space="preserve">
          <source>Name of a language</source>
          <target state="translated">Название языка</target>
        </trans-unit>
        <trans-unit id="0178948b94c691d929c18fcd5464bd15baa26a58" translate="yes" xml:space="preserve">
          <source>Name of a new or existing column.</source>
          <target state="translated">Название новой или существующей колонки.</target>
        </trans-unit>
        <trans-unit id="560c42c98008ce51d03f9d6187d29c37c7009544" translate="yes" xml:space="preserve">
          <source>Name of a new or existing constraint.</source>
          <target state="translated">Название нового или существующего ограничения.</target>
        </trans-unit>
        <trans-unit id="35dcedcca97d439e09701340473e9f3ca046b02c" translate="yes" xml:space="preserve">
          <source>Name of a notification channel (any identifier).</source>
          <target state="translated">Название канала уведомления (любой идентификатор).</target>
        </trans-unit>
        <trans-unit id="ce514f0b60e997e86128266bb519efbba0a6ff6b" translate="yes" xml:space="preserve">
          <source>Name of a settable configuration parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;.</source>
          <target state="translated">Имя настраиваемого параметра конфигурации. Доступные параметры описаны в &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;главе 19&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f56681bfb8a12163f30d0b4fed0f1fd757c8babb" translate="yes" xml:space="preserve">
          <source>Name of a settable configuration parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954ee074d5be1c36459da8f7253027e56d893199" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and below.</source>
          <target state="translated">Имя настраиваемого рабочего параметра. Доступные параметры описаны в &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;главе 19&lt;/a&gt; и ниже.</target>
        </trans-unit>
        <trans-unit id="9a0e3cf73c45665ec4941eb25f3329677ad2c627" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page.</source>
          <target state="translated">Имя настраиваемого рабочего параметра. Доступные параметры описаны в &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;главе 19&lt;/a&gt; и на справочной странице &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a2c1ef6c12c7af08e5bbbc68b4033b620233cc" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafb6ab430fc1bf75e0c604287df03b8d7d814d7" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2301404426d669bb911593cec730650e2bdbfe" translate="yes" xml:space="preserve">
          <source>Name of a single trigger to disable or enable.</source>
          <target state="translated">Имя одиночного триггера для отключения или включения.</target>
        </trans-unit>
        <trans-unit id="c0e033b344c49040ea83d0610c59dfd1b03a919f" translate="yes" xml:space="preserve">
          <source>Name of an existing column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231d1ed2d468b8d6e17991509cbba8cadc17e1e5" translate="yes" xml:space="preserve">
          <source>Name of an existing constraint to drop or rename.</source>
          <target state="translated">Название существующего ограничения на сброс или переименование.</target>
        </trans-unit>
        <trans-unit id="22745c3446c7c4d17ba8fa32b15b8f7c06992bdd" translate="yes" xml:space="preserve">
          <source>Name of an existing constraint to drop.</source>
          <target state="translated">Название существующего ограничения к сбросу.</target>
        </trans-unit>
        <trans-unit id="b073ede31105aa5c1b6f36a11370455d96d537b0" translate="yes" xml:space="preserve">
          <source>Name of an existing table. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is affected. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are affected. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">Имя существующей таблицы. Если перед именем таблицы указано &lt;code&gt;ONLY&lt;/code&gt; , это влияет только на эту таблицу. Если &lt;code&gt;ONLY&lt;/code&gt; не указан, это влияет на таблицу и все ее дочерние таблицы (если есть). При желании после имени таблицы можно указать &lt;code&gt;*&lt;/code&gt; , чтобы явно указать, что включены дочерние таблицы.</target>
        </trans-unit>
        <trans-unit id="694de0e59c53dd44f4f4691acabc413768ef9d9a" translate="yes" xml:space="preserve">
          <source>Name of anonymous-block handler function, or null if none</source>
          <target state="translated">Имя анонимно-блочной обработчик функции,или null если нет</target>
        </trans-unit>
        <trans-unit id="5915762ae281a23f2bd1848ce737f5d865ae38a8" translate="yes" xml:space="preserve">
          <source>Name of call handler function</source>
          <target state="translated">Название функции обработчика вызовов</target>
        </trans-unit>
        <trans-unit id="206dec00fa32e6c205384b3df437c35f69e88392" translate="yes" xml:space="preserve">
          <source>Name of default version, or &lt;code&gt;NULL&lt;/code&gt; if none is specified</source>
          <target state="translated">Имя версии по умолчанию или &lt;code&gt;NULL&lt;/code&gt; , если ничего не указано</target>
        </trans-unit>
        <trans-unit id="ee034d5b0508537af88d7be3d4206b7d9a6f7ace" translate="yes" xml:space="preserve">
          <source>Name of extended statistics</source>
          <target state="translated">Наименование расширенной статистики</target>
        </trans-unit>
        <trans-unit id="987fff60ced95bb42507af7d6f424dce288531b4" translate="yes" xml:space="preserve">
          <source>Name of index</source>
          <target state="translated">Наименование индекса</target>
        </trans-unit>
        <trans-unit id="b76e90e08249294dc6388d288e0a0ff43959a02e" translate="yes" xml:space="preserve">
          <source>Name of materialized view</source>
          <target state="translated">Название материализованного вида</target>
        </trans-unit>
        <trans-unit id="6501e212c15d2fb75aeb9acf75320931a339d605" translate="yes" xml:space="preserve">
          <source>Name of materialized view's owner</source>
          <target state="translated">Имя владельца материализованного вида</target>
        </trans-unit>
        <trans-unit id="e6cf10a0a70ad19c5b7371da58941b6c0037ae86" translate="yes" xml:space="preserve">
          <source>Name of policy</source>
          <target state="translated">Название политики</target>
        </trans-unit>
        <trans-unit id="a146b1bd6e895582068f638a02a8412aaeadca11" translate="yes" xml:space="preserve">
          <source>Name of publication</source>
          <target state="translated">Наименование публикации</target>
        </trans-unit>
        <trans-unit id="611f97b7cc9cb3302c011583c51a64d361fde262" translate="yes" xml:space="preserve">
          <source>Name of rule</source>
          <target state="translated">Название правила</target>
        </trans-unit>
        <trans-unit id="916daa93b2ab22b09d0d27a6fc75daa92e090cbf" translate="yes" xml:space="preserve">
          <source>Name of schema containing extended statistic</source>
          <target state="translated">Наименование схемы,содержащей расширенную статистику</target>
        </trans-unit>
        <trans-unit id="b8e23c7699d61150cab192ab08cb0a8c8eff18ba" translate="yes" xml:space="preserve">
          <source>Name of schema containing materialized view</source>
          <target state="translated">Наименование схемы,содержащей материализованное представление</target>
        </trans-unit>
        <trans-unit id="8a4b8a6f4e6c77468796e3b2343ea829020a1a97" translate="yes" xml:space="preserve">
          <source>Name of schema containing sequence</source>
          <target state="translated">Название схемы,содержащей последовательность</target>
        </trans-unit>
        <trans-unit id="9330f5310d2e7af8a885aaca54f40c7a5b2e64d8" translate="yes" xml:space="preserve">
          <source>Name of schema containing table</source>
          <target state="translated">Название схемы,содержащей таблицу</target>
        </trans-unit>
        <trans-unit id="dd40e81316e76702c45608033ccb5e0f85f3dfea" translate="yes" xml:space="preserve">
          <source>Name of schema containing table and index</source>
          <target state="translated">Наименование схемы,содержащей таблицу и индекс</target>
        </trans-unit>
        <trans-unit id="b025c1d95310dde444c37ad986883a8dee5bb9d3" translate="yes" xml:space="preserve">
          <source>Name of schema containing table policy is on</source>
          <target state="translated">Название схемы,содержащей политику таблиц,указано на</target>
        </trans-unit>
        <trans-unit id="651e03eac67fc05e08a5fc3c4b0db8b8a5ca2d70" translate="yes" xml:space="preserve">
          <source>Name of schema containing view</source>
          <target state="translated">Название схемы,содержащей вид</target>
        </trans-unit>
        <trans-unit id="fd465cc8a117f3266eab848066483930a22454ae" translate="yes" xml:space="preserve">
          <source>Name of sequence</source>
          <target state="translated">Название последовательности</target>
        </trans-unit>
        <trans-unit id="f8e19bb0d7e02e23ea651a2fbd412be10bd907ea" translate="yes" xml:space="preserve">
          <source>Name of sequence's owner</source>
          <target state="translated">Имя владельца последовательности</target>
        </trans-unit>
        <trans-unit id="2c617ffcb7fc75270eec292d65c4160eff374b06" translate="yes" xml:space="preserve">
          <source>Name of table</source>
          <target state="translated">Название таблицы</target>
        </trans-unit>
        <trans-unit id="f10df6f392a1568c4d43e34377ec16b2f3a7fa44" translate="yes" xml:space="preserve">
          <source>Name of table policy is on</source>
          <target state="translated">Название политики таблицы на</target>
        </trans-unit>
        <trans-unit id="c0513b8ba01d1af1c795daf01358ee55cf3296c9" translate="yes" xml:space="preserve">
          <source>Name of table the index is for</source>
          <target state="translated">Наименование таблицы,для которой индекс</target>
        </trans-unit>
        <trans-unit id="d795c0056cb1fd8b2838b400cf90a77a5b34f1c7" translate="yes" xml:space="preserve">
          <source>Name of table the rule is for</source>
          <target state="translated">Название таблицы,для которой действует правило</target>
        </trans-unit>
        <trans-unit id="6f44460598242d440e308c5206bbdd4ee6c15df5" translate="yes" xml:space="preserve">
          <source>Name of table's owner</source>
          <target state="translated">Имя владельца стола</target>
        </trans-unit>
        <trans-unit id="cc73fa216f99d868d036ec5fa8be32ea593b2352" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing index (null if default for database)</source>
          <target state="translated">Имя табличного пространства,содержащего индекс (ноль,если для БД по умолчанию)</target>
        </trans-unit>
        <trans-unit id="13a740701fe416ff32d444b4b9dea241f97f8406" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing materialized view (null if default for database)</source>
          <target state="translated">Имя табличного пространства,содержащего материализованное представление (нулевое,если для БД по умолчанию)</target>
        </trans-unit>
        <trans-unit id="e235059f85c95c9cf0964b16c38689bf7ab5f960" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing table (null if default for database)</source>
          <target state="translated">Имя табличного пространства,содержащего таблицу (нулевое,если для БД по умолчанию)</target>
        </trans-unit>
        <trans-unit id="38df58659a85a8c6be97b9180f6ba3a3db8fd801" translate="yes" xml:space="preserve">
          <source>Name of the SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b950b20317e5d48a4d7180b3b67b23925387d954" translate="yes" xml:space="preserve">
          <source>Name of the WAL file of the last failed archival operation</source>
          <target state="translated">Имя файла WAL последней неудачной операции архивирования</target>
        </trans-unit>
        <trans-unit id="50c7ff72173e6a33ac0f4b45d6945424b157e3f8" translate="yes" xml:space="preserve">
          <source>Name of the access method</source>
          <target state="translated">Название метода доступа</target>
        </trans-unit>
        <trans-unit id="42336fd50699db80c8e30a44b238f551cdfe5e05" translate="yes" xml:space="preserve">
          <source>Name of the application that is connected to this WAL sender</source>
          <target state="translated">Имя приложения,подключенного к этому отправителю WAL.</target>
        </trans-unit>
        <trans-unit id="73eb48e900d4da8e91ccec691048b06a84e20927" translate="yes" xml:space="preserve">
          <source>Name of the application that is connected to this backend</source>
          <target state="translated">Имя приложения,которое подключено к этому бэкенду.</target>
        </trans-unit>
        <trans-unit id="e5622c8d744e74d58e5852a23ea1813374720ca0" translate="yes" xml:space="preserve">
          <source>Name of the column described by this row</source>
          <target state="translated">Название столбца,описываемого этой строкой</target>
        </trans-unit>
        <trans-unit id="05582534113d6fd58f1c91cf719019de03349552" translate="yes" xml:space="preserve">
          <source>Name of the database in which the transaction was executed</source>
          <target state="translated">Имя базы данных,в которой была выполнена транзакция.</target>
        </trans-unit>
        <trans-unit id="3c046694c5a00d97ff6a1379659314bd6a78ef25" translate="yes" xml:space="preserve">
          <source>Name of the database this backend is connected to</source>
          <target state="translated">Имя базы данных,к которой подключен бэкэнд.</target>
        </trans-unit>
        <trans-unit id="21b466dc28882ad5e606c7e29b3635f8046375c5" translate="yes" xml:space="preserve">
          <source>Name of the database to which this backend is connected.</source>
          <target state="translated">Имя базы данных,к которой подключен этот бэкенд.</target>
        </trans-unit>
        <trans-unit id="a4b1ce5ff884a2efdb43d43a59c57f0b4fa4d401" translate="yes" xml:space="preserve">
          <source>Name of the event source for pg_ctl to use for logging to the event log when running as a Windows service. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. Note that this only controls messages sent from pg_ctl itself; once started, the server will use the event source specified by its &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt; parameter. Should the server fail very early in startup, before that parameter has been set, it might also log using the default event source name &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">Имя источника событий, который pg_ctl будет использовать для записи в журнал событий при работе в качестве службы Windows. По умолчанию - &lt;code&gt;PostgreSQL&lt;/code&gt; . Обратите внимание, что это контролирует только сообщения, отправленные самим pg_ctl; после запуска сервер будет использовать источник событий, указанный в параметре &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt; . Если сервер выйдет из строя на очень раннем этапе запуска, до того, как этот параметр был установлен, он также может войти в журнал с использованием имени источника событий по умолчанию &lt;code&gt;PostgreSQL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db2a8ab1c7a6e8e7352acea353746079da1e0da5" translate="yes" xml:space="preserve">
          <source>Name of the extension</source>
          <target state="translated">Название расширения</target>
        </trans-unit>
        <trans-unit id="b32842559bebdaa75c2073237260c49768556ba4" translate="yes" xml:space="preserve">
          <source>Name of the field to order siblings by (optional)</source>
          <target state="translated">Название поля для заказа братьев и сестер по (необязательно)</target>
        </trans-unit>
        <trans-unit id="d305530c62c0c372c9b705ff8915012e6f1258b2" translate="yes" xml:space="preserve">
          <source>Name of the foreign server</source>
          <target state="translated">Имя иностранного сервера</target>
        </trans-unit>
        <trans-unit id="59348747feca44834dd28cf94d333b16c8cfbbf0" translate="yes" xml:space="preserve">
          <source>Name of the foreign-data wrapper</source>
          <target state="translated">Название обертки для иностранных данных</target>
        </trans-unit>
        <trans-unit id="9e20c57335eda37ac38552a55cb17fe874d8fb6b" translate="yes" xml:space="preserve">
          <source>Name of the function</source>
          <target state="translated">Название функции</target>
        </trans-unit>
        <trans-unit id="eee39eba3634db32e7cb3a66942216268c13c704" translate="yes" xml:space="preserve">
          <source>Name of the group</source>
          <target state="translated">Название группы</target>
        </trans-unit>
        <trans-unit id="e6e050c906fd9fbc0c7b4d3a235e25d068290256" translate="yes" xml:space="preserve">
          <source>Name of the key field</source>
          <target state="translated">Название ключевого поля</target>
        </trans-unit>
        <trans-unit id="b217fce5b600ff5e59a7bde206ff84c6743ebd06" translate="yes" xml:space="preserve">
          <source>Name of the language</source>
          <target state="translated">Название языка</target>
        </trans-unit>
        <trans-unit id="999d13acc30868afb96a2061f85f8cfbf835af9a" translate="yes" xml:space="preserve">
          <source>Name of the language this template is for</source>
          <target state="translated">Название языка для данного шаблона</target>
        </trans-unit>
        <trans-unit id="c0904d4653e24f5cf40ca0e66167033212dff01e" translate="yes" xml:space="preserve">
          <source>Name of the last WAL file successfully archived</source>
          <target state="translated">Имя последнего успешно архивированного файла WAL</target>
        </trans-unit>
        <trans-unit id="632030382b37c4353da7f8cfd3fb10f03fb4878e" translate="yes" xml:space="preserve">
          <source>Name of the local user to be mapped</source>
          <target state="translated">Имя локального пользователя,который будет отображен.</target>
        </trans-unit>
        <trans-unit id="3283788f7750678653d33179d0a9b570a3fb07a0" translate="yes" xml:space="preserve">
          <source>Name of the lock mode held or desired by this process (see &lt;a href=&quot;explicit-locking#LOCKING-TABLES&quot;&gt;Section 13.3.1&lt;/a&gt; and &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;)</source>
          <target state="translated">Имя режима блокировки, поддерживаемого или желаемого этим процессом (см. &lt;a href=&quot;explicit-locking#LOCKING-TABLES&quot;&gt;Раздел 13.3.1&lt;/a&gt; и &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Раздел 13.2.3&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="bca4b201210cb86555d12a73e7fa1d0df2b4ce1d" translate="yes" xml:space="preserve">
          <source>Name of the namespace</source>
          <target state="translated">Название пространства имен</target>
        </trans-unit>
        <trans-unit id="116ede6679101b358b013bfe3778515f6a6eb59a" translate="yes" xml:space="preserve">
          <source>Name of the notification channel to be signaled (any identifier).</source>
          <target state="translated">Название канала оповещения,по которому будет подаваться сигнал (любой идентификатор).</target>
        </trans-unit>
        <trans-unit id="b1846b8dfbb275c5d01dbe581ad89ecd8bd17f99" translate="yes" xml:space="preserve">
          <source>Name of the on-disk file of this relation; zero means this is a &amp;ldquo;mapped&amp;rdquo; relation whose disk file name is determined by low-level state</source>
          <target state="translated">Имя файла этого отношения на диске; ноль означает, что это &amp;laquo;сопоставленное&amp;raquo; отношение, имя файла на диске которого определяется состоянием низкого уровня.</target>
        </trans-unit>
        <trans-unit id="ffd1b3d5baf3902d7d64e922601a9c11dc846fd8" translate="yes" xml:space="preserve">
          <source>Name of the operator</source>
          <target state="translated">Имя оператора</target>
        </trans-unit>
        <trans-unit id="f362cae832a0a92cf6859f4e3035227030a3fa7e" translate="yes" xml:space="preserve">
          <source>Name of the parent-key field</source>
          <target state="translated">Имя поля с родительским ключом</target>
        </trans-unit>
        <trans-unit id="914386f36015301aa42cdc85d2971f37bbd3f6e1" translate="yes" xml:space="preserve">
          <source>Name of the publication</source>
          <target state="translated">Название публикации</target>
        </trans-unit>
        <trans-unit id="f8ba7366e5638b5adb85cf058a4f60fc77a1437d" translate="yes" xml:space="preserve">
          <source>Name of the replication slot in the upstream database (also used for the local replication origin name); null represents &lt;code&gt;NONE&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95141217167b4e44530e9c633ef9691ad9e4c7d5" translate="yes" xml:space="preserve">
          <source>Name of the replication slot in the upstream database. Also used for local replication origin name.</source>
          <target state="translated">Имя слота репликации в восходящей базе данных.Также используется для локального имени источника репликации.</target>
        </trans-unit>
        <trans-unit id="48b6dcd7b3f9b0cceabe3c942a0ff0d053cf3051" translate="yes" xml:space="preserve">
          <source>Name of the replication slot to use. The default behavior is to use the name of the subscription for the slot name.</source>
          <target state="translated">Имя используемого слота репликации.Поведением по умолчанию является использование имени подписки для имени слота.</target>
        </trans-unit>
        <trans-unit id="0c22c3cdbc7df0d29a30ef0e5d20c6d53a22aba3" translate="yes" xml:space="preserve">
          <source>Name of the schema that the extension must be installed into, or &lt;code&gt;NULL&lt;/code&gt; if partially or fully relocatable</source>
          <target state="translated">Имя схемы, в которую должно быть установлено расширение, или &lt;code&gt;NULL&lt;/code&gt; , если его можно частично или полностью перемещать.</target>
        </trans-unit>
        <trans-unit id="46b2c8652132c7dc1c02610fe232f22c32a70e49" translate="yes" xml:space="preserve">
          <source>Name of the schema that this table is in</source>
          <target state="translated">Название схемы,в которой находится эта таблица.</target>
        </trans-unit>
        <trans-unit id="aeed8d4431144cabd5a1127005bce646d16cab11" translate="yes" xml:space="preserve">
          <source>Name of the schema this function is in</source>
          <target state="translated">Название схемы эта функция находится в</target>
        </trans-unit>
        <trans-unit id="b11dd1fd926881e2c689b2ce026036d1c6bf66aa" translate="yes" xml:space="preserve">
          <source>Name of the schema this index is in</source>
          <target state="translated">Название схемы,в которой находится этот индекс.</target>
        </trans-unit>
        <trans-unit id="55e1e35ee330306af1edafba8c0ccceb0641d202" translate="yes" xml:space="preserve">
          <source>Name of the schema this sequence is in</source>
          <target state="translated">Название схемы эта последовательность находится в</target>
        </trans-unit>
        <trans-unit id="d75b4d0b583232f5341524b6ac4e00946212dc64" translate="yes" xml:space="preserve">
          <source>Name of the source relation</source>
          <target state="translated">Имя отношения к источнику</target>
        </trans-unit>
        <trans-unit id="02fe646b94a9a3942519f9c9b3db9e92f9c9c3fd" translate="yes" xml:space="preserve">
          <source>Name of the statistics object</source>
          <target state="translated">Название объекта статистики</target>
        </trans-unit>
        <trans-unit id="33574f9c61c2e627eb0d3d0f3da70a170678a9ff" translate="yes" xml:space="preserve">
          <source>Name of the subscription</source>
          <target state="translated">Название подписки</target>
        </trans-unit>
        <trans-unit id="90ae080c0a5fc808f5e0a7e8b8cae579504b16d5" translate="yes" xml:space="preserve">
          <source>Name of the system service to register. This name will be used as both the service name and the display name. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">Имя регистрируемой системной службы. Это имя будет использоваться как имя службы и отображаемое имя. По умолчанию - &lt;code&gt;PostgreSQL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5e271781547e2a1e2376a48974f2d9fab48cde2" translate="yes" xml:space="preserve">
          <source>Name of the table for this index</source>
          <target state="translated">Наименование таблицы для этого индекса</target>
        </trans-unit>
        <trans-unit id="0200e1f7b3df494bd305d84c497873916f941937" translate="yes" xml:space="preserve">
          <source>Name of the table, index, view, etc.</source>
          <target state="translated">Название таблицы,индекс,представление и т.д.</target>
        </trans-unit>
        <trans-unit id="a1f59b4d65687dc8fe0a85f1b74351b10bfba7a6" translate="yes" xml:space="preserve">
          <source>Name of the user logged into this WAL sender process</source>
          <target state="translated">Имя пользователя,вошедшего в этот процесс отправителя WAL</target>
        </trans-unit>
        <trans-unit id="3fe80a85bf2161f51d9c08098d7bfcdedce6c9ee" translate="yes" xml:space="preserve">
          <source>Name of the user logged into this backend</source>
          <target state="translated">Имя пользователя,вошедшего в этот бэкэнд.</target>
        </trans-unit>
        <trans-unit id="04f7b7b315d382679587d80fba309d2bb70b1345" translate="yes" xml:space="preserve">
          <source>Name of the user that executed the transaction</source>
          <target state="translated">Имя пользователя,совершившего операцию</target>
        </trans-unit>
        <trans-unit id="c24f99aa0c8caf23a96b75cece5098629fd6a94e" translate="yes" xml:space="preserve">
          <source>Name of this database</source>
          <target state="translated">Название этой базы данных</target>
        </trans-unit>
        <trans-unit id="2086d14cece3b039e0a515f48cc92518784c4d7a" translate="yes" xml:space="preserve">
          <source>Name of this database, or &lt;code&gt;NULL&lt;/code&gt; for shared objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d6411e8bd4b74b577e7365540cb543464ed926" translate="yes" xml:space="preserve">
          <source>Name of this database, or &lt;code&gt;NULL&lt;/code&gt; for the shared objects.</source>
          <target state="translated">Имя этой базы данных или &lt;code&gt;NULL&lt;/code&gt; для общих объектов.</target>
        </trans-unit>
        <trans-unit id="09edc4fe28078a94e956caa9447364b4707b6491" translate="yes" xml:space="preserve">
          <source>Name of this function</source>
          <target state="translated">Название этой функции</target>
        </trans-unit>
        <trans-unit id="a2e0e5204a994c27fb6b9e0e825c613dd1c4755e" translate="yes" xml:space="preserve">
          <source>Name of this index</source>
          <target state="translated">Наименование этого индекса</target>
        </trans-unit>
        <trans-unit id="52256e99af10a92f8d2567b55a83d56fe82e813a" translate="yes" xml:space="preserve">
          <source>Name of this operator class</source>
          <target state="translated">Название данного класса оператора</target>
        </trans-unit>
        <trans-unit id="8660634803fb7c50b11c80dde370467806dff8e0" translate="yes" xml:space="preserve">
          <source>Name of this operator family</source>
          <target state="translated">Имя семьи этого оператора</target>
        </trans-unit>
        <trans-unit id="67e86bea4f13cfb5fdec580a24af26d2de2fdc44" translate="yes" xml:space="preserve">
          <source>Name of this sequence</source>
          <target state="translated">Название этой последовательности</target>
        </trans-unit>
        <trans-unit id="b490c1221b4b64551bfddc6b8b9c77d0ea3870a9" translate="yes" xml:space="preserve">
          <source>Name of this table</source>
          <target state="translated">Название этой таблицы</target>
        </trans-unit>
        <trans-unit id="79333580b15aa0175b731014d71be95e862ff44a" translate="yes" xml:space="preserve">
          <source>Name of validator function, or null if none</source>
          <target state="translated">Имя функции валидатора,или ноль,если нет</target>
        </trans-unit>
        <trans-unit id="d340979d7f1712dd54645083825a2794537380b7" translate="yes" xml:space="preserve">
          <source>Name of view</source>
          <target state="translated">Название вида</target>
        </trans-unit>
        <trans-unit id="ca9987204d1e0d3bf0d8020ca5eccf2de116a77a" translate="yes" xml:space="preserve">
          <source>Name of view's owner</source>
          <target state="translated">Имя владельца просмотра</target>
        </trans-unit>
        <trans-unit id="715cd77a48eca5f7bbf90153374438716221cbe4" translate="yes" xml:space="preserve">
          <source>Named and mixed call notations currently cannot be used when calling an aggregate function (but they do work when an aggregate function is used as a window function).</source>
          <target state="translated">Именованные и смешанные нотации вызовов в настоящее время не могут быть использованы при вызове агрегатной функции (но они работают,когда агрегатная функция используется в качестве оконной функции).</target>
        </trans-unit>
        <trans-unit id="febb13b6b6bedee695a2cdffc8584795987df071" translate="yes" xml:space="preserve">
          <source>Named run-time parameters can be set in either of these styles:</source>
          <target state="translated">Именованные параметры выполнения могут быть установлены в любом из этих стилей:</target>
        </trans-unit>
        <trans-unit id="b335beb0e29ec02f76a030301ce30aec55d10a00" translate="yes" xml:space="preserve">
          <source>Names can be assigned to table constraints in the same way as column constraints:</source>
          <target state="translated">Имена могут быть назначены ограничениям таблицы точно так же,как ограничениям столбцов:</target>
        </trans-unit>
        <trans-unit id="90e76064cba28bce291e20a00492ac8908ed2815" translate="yes" xml:space="preserve">
          <source>Names of prerequisite extensions, or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">Имена обязательных расширений или &lt;code&gt;NULL&lt;/code&gt; , если нет</target>
        </trans-unit>
        <trans-unit id="879c37a97f04ee34ad69a53c4aa464879102ff50" translate="yes" xml:space="preserve">
          <source>Names of the columns the extended statistics is defined on</source>
          <target state="translated">Названия столбцов,на которых определяется расширенная статистика по</target>
        </trans-unit>
        <trans-unit id="774a71278e16cec9ccf959b5bab94713611e399e" translate="yes" xml:space="preserve">
          <source>Names of the publications on the publisher to subscribe to.</source>
          <target state="translated">Названия публикаций,на которые издатель должен подписаться.</target>
        </trans-unit>
        <trans-unit id="ef2014703004a1217b3fec5210db4117b70e51de" translate="yes" xml:space="preserve">
          <source>Names or IP addresses of LDAP servers to connect to. Multiple servers may be specified, separated by spaces.</source>
          <target state="translated">Имена или IP-адреса LDAP-серверов для подключения.Может быть указано несколько серверов,разделенных пробелами.</target>
        </trans-unit>
        <trans-unit id="3f95be766c8568501a000e46e6894d04ef9f8877" translate="yes" xml:space="preserve">
          <source>Namespace Available to &lt;code&gt;GROUP BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt;</source>
          <target state="translated">Пространство имен, доступное для &lt;code&gt;GROUP BY&lt;/code&gt; и &lt;code&gt;ORDER BY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47230dc537dc21987e746d4c719b4cc41ae69b6a" translate="yes" xml:space="preserve">
          <source>Namespace of this operator class</source>
          <target state="translated">Пространство имен этого класса операторов</target>
        </trans-unit>
        <trans-unit id="a230663970531d46658f671326f61bad6755f192" translate="yes" xml:space="preserve">
          <source>Namespace of this operator family</source>
          <target state="translated">Пространство имен этого семейства операторов</target>
        </trans-unit>
        <trans-unit id="a1c428db5a690b5f5a2a8bbbdfae45bd49175ad0" translate="yes" xml:space="preserve">
          <source>National Language Support</source>
          <target state="translated">Поддержка национального языка</target>
        </trans-unit>
        <trans-unit id="725efb9e43acf1bf580c09d2cb1b0cf911451468" translate="yes" xml:space="preserve">
          <source>National Standard</source>
          <target state="translated">Национальный стандарт</target>
        </trans-unit>
        <trans-unit id="9d1f7ad08bfbe66715ad20935eced5ce9dc0eb67" translate="yes" xml:space="preserve">
          <source>Natural logarithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c36a47f8e482a64ff81cd9e84619cb8413e09b" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c2729e4aa8267e02a5e14878260b805c76e4f0" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to argument (same as &lt;code&gt;ceil&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333e55744c1836d8e2f747a46f8a58bd387549f7" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to the SQL/JSON number</source>
          <target state="translated">Ближайшее целое число,большее или равное номеру SQL/JSON</target>
        </trans-unit>
        <trans-unit id="3089188f4ef21fadc5a7ae8a8917660ce59f776c" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to the given number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc0f09f7738d16783cda39dfae33946b8073a87" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee672459bc21a36f5d885e59227b9978e9d1866" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to the SQL/JSON number</source>
          <target state="translated">Ближайшее целое число меньше или равно числу SQL/JSON</target>
        </trans-unit>
        <trans-unit id="6a166687429ef42663b71e2fae4f0d6dcf7415c3" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to the given number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e224c76bc25e4149e084462adee5b7564caac26" translate="yes" xml:space="preserve">
          <source>Needless to say, processing XML data with PostgreSQL will be less error-prone and more efficient if the XML data encoding, client encoding, and server encoding are the same. Since XML data is internally processed in UTF-8, computations will be most efficient if the server encoding is also UTF-8.</source>
          <target state="translated">Нет необходимости говорить о том,что обработка XML-данных с PostgreSQL будет менее подвержена ошибкам и более эффективна,если кодировка XML-данных,клиентская кодировка и серверная кодировка будут одинаковыми.Так как данные XML обрабатываются внутренне в кодировке UTF-8,вычисления будут наиболее эффективными,если серверная кодировка также в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="dfc508fa9ddaeb33e233aa812ebad0ab8c049dd2" translate="yes" xml:space="preserve">
          <source>Negate an interval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b33f9b7a0a4606b4bd747722b21501d99fa70ad" translate="yes" xml:space="preserve">
          <source>Negates a &lt;code&gt;tsquery&lt;/code&gt;, producing a query that matches documents that do not match the input query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24048c04eba343a323fecac37d642445c66f6c28" translate="yes" xml:space="preserve">
          <source>Negation</source>
          <target state="translated">Negation</target>
        </trans-unit>
        <trans-unit id="192f6939bf2bfe49ee33bf49687c9297f6c0972d" translate="yes" xml:space="preserve">
          <source>Negation; unlike subtraction, this can iterate over multiple values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cadf6ca95971ac3dd5c11e621924026c16209f" translate="yes" xml:space="preserve">
          <source>Negator of this operator, if any</source>
          <target state="translated">Негатор этого оператора,если таковой есть.</target>
        </trans-unit>
        <trans-unit id="cdedd7a3e12a28ecdae254105845f04dc8b7e221" translate="yes" xml:space="preserve">
          <source>Neither sequential scans nor nested-loop joins can be disabled completely; the &lt;code&gt;-fs&lt;/code&gt; and &lt;code&gt;-fn&lt;/code&gt; options simply discourage the optimizer from using those plan types if it has any other alternative.</source>
          <target state="translated">Ни последовательное сканирование, ни соединение с вложенными циклами нельзя полностью отключить; параметры &lt;code&gt;-fs&lt;/code&gt; и &lt;code&gt;-fn&lt;/code&gt; просто отговаривают оптимизатора от использования этих типов планов, если у него есть другие альтернативы.</target>
        </trans-unit>
        <trans-unit id="999497fbc59b4c8badf88b3dddf684b5320af0cd" translate="yes" xml:space="preserve">
          <source>Neither the source nor the destination encoding can be &lt;code&gt;SQL_ASCII&lt;/code&gt;, as the server's behavior for cases involving the &lt;code&gt;SQL_ASCII&lt;/code&gt;&amp;ldquo;encoding&amp;rdquo; is hard-wired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc249089e46e70234a72d288cf1c8de145f74bd2" translate="yes" xml:space="preserve">
          <source>Neither timezone names nor abbreviations are hard-wired into the server; they are obtained from configuration files stored under &lt;code&gt;.../share/timezone/&lt;/code&gt; and &lt;code&gt;.../share/timezonesets/&lt;/code&gt; of the installation directory (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt;).</source>
          <target state="translated">Ни названия часовых поясов, ни сокращения жестко не зашиты в сервер; они берутся из файлов конфигурации, хранящихся в &lt;code&gt;.../share/timezone/&lt;/code&gt; и &lt;code&gt;.../share/timezonesets/&lt;/code&gt; каталога установки (см. &lt;a href=&quot;datetime-config-files&quot;&gt;Раздел B.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3e9e1f6f189ff8e4d505c81b54a796d5e66a2542" translate="yes" xml:space="preserve">
          <source>NetBSD</source>
          <target state="translated">NetBSD</target>
        </trans-unit>
        <trans-unit id="8d546e29b4f4fdcb009106a5c128188e2431946d" translate="yes" xml:space="preserve">
          <source>NetBSD versions before 5.0 work like old OpenBSD (see below), except that kernel parameters should be set with the keyword &lt;code&gt;options&lt;/code&gt; not &lt;code&gt;option&lt;/code&gt;.</source>
          <target state="translated">Версии NetBSD до 5.0 работают так же, как старый OpenBSD (см. Ниже), за исключением того, что параметры ядра должны быть установлены с ключевым словом &lt;code&gt;options&lt;/code&gt; not &lt;code&gt;option&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4970c28f364d041c28f5d5ff2bc88daf1a13ad01" translate="yes" xml:space="preserve">
          <source>Network Address Types</source>
          <target state="translated">Типы сетевых адресов</target>
        </trans-unit>
        <trans-unit id="1aab162fb1d4be431f43c575684b7d8c545c8302" translate="yes" xml:space="preserve">
          <source>Network Address Types: cidr</source>
          <target state="translated">Типы сетевых адресов:cidr</target>
        </trans-unit>
        <trans-unit id="a0a4631210875f94aba2f16fc813f4614e393764" translate="yes" xml:space="preserve">
          <source>Network Address Types: inet</source>
          <target state="translated">Типы сетевых адресов:инет</target>
        </trans-unit>
        <trans-unit id="341da3e8cf1498f3f62648168d4190e67f278782" translate="yes" xml:space="preserve">
          <source>Network Address Types: macaddr</source>
          <target state="translated">Типы сетевых адресов:macaddr</target>
        </trans-unit>
        <trans-unit id="81bbd3c87492587fd7ddfed55118e840abffce9f" translate="yes" xml:space="preserve">
          <source>Network Address Types: macaddr8</source>
          <target state="translated">Типы сетевых адресов:macaddr8</target>
        </trans-unit>
        <trans-unit id="c5f17a43f889ac0d89795d00fba1671fe47f62f0" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;amp;</source>
          <target state="translated">Сетевой адрес: &amp;amp;</target>
        </trans-unit>
        <trans-unit id="3182c01748d8a83efe78a3f4ab6c4e990eacea0c" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;amp;&amp;amp;</source>
          <target state="translated">Сетевой адрес: &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="c32091a6107e7e44a68fb436fb33982336ccc452" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;</source>
          <target state="translated">Сетевой адрес:&amp;gt;</target>
        </trans-unit>
        <trans-unit id="86a00c20e3381c9260f079dcb6e41c4262f1ea3a" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;&amp;gt;</source>
          <target state="translated">Сетевой адрес: &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3736d0bb3a030e00d7114ef9030a0916af6881f" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;&amp;gt;=</source>
          <target state="translated">Сетевой адрес: &amp;gt;&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="b6a612c0f5ca1e234f11a6f50c9a9f41342ace58" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;=</source>
          <target state="translated">Сетевой адрес:&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="0cab881598e19094a73fe2cb680ef2e7600ff52c" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;</source>
          <target state="translated">Сетевой адрес: &amp;lt;</target>
        </trans-unit>
        <trans-unit id="a2a64bdcd407fdda5883dcb3954eb4988b1bf440" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;gt;</source>
          <target state="translated">Сетевой адрес: &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e00740580248e58ab92c3eb2672f19b765c748b0" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;lt;</source>
          <target state="translated">Сетевой адрес: &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1ff901142c2068fe8cf464afe26c9042106af748" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;lt;=</source>
          <target state="translated">Сетевой адрес: &amp;lt;&amp;lt; =</target>
        </trans-unit>
        <trans-unit id="68fb0bbbf4bee491f6e6bbc78cee804b2462e684" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;=</source>
          <target state="translated">Сетевой адрес: &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="6b9e98c353b63977350c4597ab783ed68802ee56" translate="yes" xml:space="preserve">
          <source>Network Address: +</source>
          <target state="translated">Сетевой адрес:+</target>
        </trans-unit>
        <trans-unit id="39dd97c5cafd7589b71c3638f6bb1482a7b84d8f" translate="yes" xml:space="preserve">
          <source>Network Address: -</source>
          <target state="translated">Сетевой адрес:-</target>
        </trans-unit>
        <trans-unit id="777f2ecef47fe73d67412a0b49eb5b48a584a4d2" translate="yes" xml:space="preserve">
          <source>Network Address: 200 + inet &amp;#x27;::ffff:fff0:1&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b124004ce04609acad1c95336f7a76fcba56d8c" translate="yes" xml:space="preserve">
          <source>Network Address: 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43debcb1e648bae4f59d9ad9d57421aa61da314" translate="yes" xml:space="preserve">
          <source>Network Address: =</source>
          <target state="translated">Адрес сети:=</target>
        </trans-unit>
        <trans-unit id="f6da4644273b4e1c84158d7bdc34944932533ec4" translate="yes" xml:space="preserve">
          <source>Network Address: abbrev</source>
          <target state="translated">Адрес сети:аббревиатура</target>
        </trans-unit>
        <trans-unit id="c0aa9d1b8f2a11dc8e2d5492bfd563df5e51a186" translate="yes" xml:space="preserve">
          <source>Network Address: broadcast</source>
          <target state="translated">Адрес сети:широковещательный</target>
        </trans-unit>
        <trans-unit id="22c496032e898e93c86c9e0b2d1794774c6cc3b0" translate="yes" xml:space="preserve">
          <source>Network Address: family</source>
          <target state="translated">Сетевой адрес:семейный</target>
        </trans-unit>
        <trans-unit id="6144652f94deb193ec23e96153e939af827c258d" translate="yes" xml:space="preserve">
          <source>Network Address: host</source>
          <target state="translated">Адрес сети:хост</target>
        </trans-unit>
        <trans-unit id="60b63d4c005ed64503064242e41d8bfa685a802b" translate="yes" xml:space="preserve">
          <source>Network Address: hostmask</source>
          <target state="translated">Адрес сети:хостмаска</target>
        </trans-unit>
        <trans-unit id="ed88700d6440e7a05db8038b5e1ae51130f83f6c" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.0.5&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f03ec2774c64bbb3436fa6566e034e58c68aaf6" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.43&amp;#x27; - 36</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd543dd857eb909c7c1f144d1c68cc26ed17c84" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.43&amp;#x27; - inet &amp;#x27;192.168.1.19&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba4aae2f54763673ad24c08605a0dc7418f7e69" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.5&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf25351bf5e670090a9a613676ffca0130707992" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; &amp;amp; inet &amp;#x27;0.0.0.255&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb861d30d1aca8b8d63e37fc34ab35aac460d1f8" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; + 25</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47709a664ccb6f4f20ab0bedea8e5350679a1107" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; | inet &amp;#x27;0.0.0.255&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538a8494f874e1b3946b7a79168cf4b1aa49a99c" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;amp;&amp;amp; inet &amp;#x27;192.168.1.80/28&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08083b1369b886565f8ea80c8058e2d3af87577" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;amp;&amp;amp; inet &amp;#x27;192.168.2.0/28&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9c76f3500e47f384b3cac60e30dacdb3c47029" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;gt;&amp;gt; inet &amp;#x27;192.168.1.5&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a7912881770eacd62ec019a35b786530ba8e82" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;gt;&amp;gt;= inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f515856eebe2d81a6af46f2f540cf2ea72af80" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49b063066e4c4fbd3500c30f240ef74c750c98e" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;lt;&amp;lt;= inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5e1d3f81690c06565afe5ca9d8a5a94ccf4f70" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;::1&amp;#x27; - inet &amp;#x27;::ffff:1&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c102cda170efbd5c926c080194943072fd0080" translate="yes" xml:space="preserve">
          <source>Network Address: inet_merge</source>
          <target state="translated">Адрес сети:inet_merge</target>
        </trans-unit>
        <trans-unit id="026b427d2abc32061f460f5004b1e92329b176c3" translate="yes" xml:space="preserve">
          <source>Network Address: inet_same_family</source>
          <target state="translated">Адрес сети:inet_same_family</target>
        </trans-unit>
        <trans-unit id="78246e2d890ea6d8b5a4e72ded75baf6bfea7473" translate="yes" xml:space="preserve">
          <source>Network Address: macaddr8_set7bit</source>
          <target state="translated">Адрес сети:macaddr8_set7bit</target>
        </trans-unit>
        <trans-unit id="1c089819bd8607b5f9a99695372b4e5df1ae11f3" translate="yes" xml:space="preserve">
          <source>Network Address: masklen</source>
          <target state="translated">Адрес сети:маска</target>
        </trans-unit>
        <trans-unit id="e38c25828a5f421b05060a2505734c3b8ed3c4ff" translate="yes" xml:space="preserve">
          <source>Network Address: netmask</source>
          <target state="translated">Адрес сети:сетевая маска</target>
        </trans-unit>
        <trans-unit id="9e08bb5a4ba97edb3516d3ee46ca743eed995918" translate="yes" xml:space="preserve">
          <source>Network Address: network</source>
          <target state="translated">Адрес сети:сеть</target>
        </trans-unit>
        <trans-unit id="e7c94e499362212c6e5807040cfed09039e1ec82" translate="yes" xml:space="preserve">
          <source>Network Address: set_masklen</source>
          <target state="translated">Адрес сети:set_masklen</target>
        </trans-unit>
        <trans-unit id="0ec1baf847c109f5d8cc27de72a96ec587a99682" translate="yes" xml:space="preserve">
          <source>Network Address: text</source>
          <target state="translated">Адрес сети:текст</target>
        </trans-unit>
        <trans-unit id="221efaf6a0e58b3e7e632e503daaffa7a1a069d7" translate="yes" xml:space="preserve">
          <source>Network Address: trunc</source>
          <target state="translated">Сетевой адрес:усеченный</target>
        </trans-unit>
        <trans-unit id="ab7cd2917681a96bc47067425beee2467a73704d" translate="yes" xml:space="preserve">
          <source>Network Address: |</source>
          <target state="translated">Сетевой адрес:|</target>
        </trans-unit>
        <trans-unit id="83814dd86a48a4c95e9a2274b66946fe0603b1c9" translate="yes" xml:space="preserve">
          <source>Network Address: ~</source>
          <target state="translated">Сетевой адрес:~</target>
        </trans-unit>
        <trans-unit id="103c5dac467afa451157b604c5b1cc764cc21efb" translate="yes" xml:space="preserve">
          <source>Network Address: ~ inet &amp;#x27;192.168.1.6&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2ec6319838e0ec218c4906d73f925465627945" translate="yes" xml:space="preserve">
          <source>Network address types</source>
          <target state="translated">Типы сетевых адресов</target>
        </trans-unit>
        <trans-unit id="424a86543035666947635d11018cbc54c86cb289" translate="yes" xml:space="preserve">
          <source>Never issue a password prompt. If the server requires password authentication and a password is not available by other means such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="translated">Никогда не запрашивайте пароль. Если сервер требует аутентификации по паролю, а пароль недоступен другими средствами, такими как файл &lt;code&gt;.pgpass&lt;/code&gt; , попытка подключения не удастся. Эта опция может быть полезна в пакетных заданиях и сценариях, где нет пользователя для ввода пароля.</target>
        </trans-unit>
        <trans-unit id="9093e824038ec1b001eb89049bd2ea01904578a0" translate="yes" xml:space="preserve">
          <source>Never issue a password prompt. If the server requires password authentication and a password is not available from other sources such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d783af92d40765554d538ccb5cb29b09817e84f6" translate="yes" xml:space="preserve">
          <source>New OIDs cannot be assigned, though some UUID generators may still work as long as they do not rely on writing new status to the database.</source>
          <target state="translated">Новые OID-ы не могут быть назначены,хотя некоторые генераторы UUID все еще могут работать,пока не будут полагаться на запись нового статуса в базу данных.</target>
        </trans-unit>
        <trans-unit id="1599ff1bdbcb64919583d13e639c6bfaf051dfca" translate="yes" xml:space="preserve">
          <source>New aggregate functions are registered with the &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; command. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt; for more information about writing aggregate functions and the meaning of the transition functions, etc.</source>
          <target state="translated">Новые агрегатные функции регистрируются с помощью команды &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; . См. &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;Раздел 37.12&lt;/a&gt; для получения дополнительной информации о написании агрегатных функций, о значении функций перехода и т. Д.</target>
        </trans-unit>
        <trans-unit id="5691f2234d0749ef354ef0f06ef7f16ccef71ffc" translate="yes" xml:space="preserve">
          <source>New aggregate functions are registered with the &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; command. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt; for more information about writing aggregate functions and the meaning of the transition functions, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31c4f5893b955e11ebf06d3912e5da97f70565f" translate="yes" xml:space="preserve">
          <source>New array values can also be constructed using the concatenation operator, &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">Новые значения массива также могут быть созданы с помощью оператора конкатенации &lt;code&gt;||&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="98e5f0d308c976c18e3e4b7efffa4995977e2612" translate="yes" xml:space="preserve">
          <source>New domain constraint for the domain.</source>
          <target state="translated">Новое ограничение домена.</target>
        </trans-unit>
        <trans-unit id="796d9d5ad0384fcde7a5cdd2291232f588f72876" translate="yes" xml:space="preserve">
          <source>New leaf pages are added to a B-Tree index when an existing leaf page cannot fit an incoming tuple. A &lt;em&gt;page split&lt;/em&gt; operation makes room for items that originally belonged on the overflowing page by moving a portion of the items to a new page. Page splits must also insert a new &lt;em&gt;downlink&lt;/em&gt; to the new page in the parent page, which may cause the parent to split in turn. Page splits &amp;ldquo;cascade upwards&amp;rdquo; in a recursive fashion. When the root page finally cannot fit a new downlink, a &lt;em&gt;root page split&lt;/em&gt; operation takes place. This adds a new level to the tree structure by creating a new root page that is one level above the original root page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12c3795c3d4f4819f76dadf3e557565c057892c" translate="yes" xml:space="preserve">
          <source>New libc collations can be created like this:</source>
          <target state="translated">Новые либкколлекции могут быть созданы вот так:</target>
        </trans-unit>
        <trans-unit id="650ded8d5d402f503baa0bc831171b9d8bc4272d" translate="yes" xml:space="preserve">
          <source>New major versions also typically introduce some user-visible incompatibilities, so application programming changes might be required. All user-visible changes are listed in the release notes (&lt;a href=&quot;https://www.postgresql.org/docs/12/release.html&quot;&gt;Appendix E&lt;/a&gt;); pay particular attention to the section labeled &quot;Migration&quot;. If you are upgrading across several major versions, be sure to read the release notes for each intervening version.</source>
          <target state="translated">Новые основные версии также обычно содержат некоторые видимые пользователем несовместимости, поэтому могут потребоваться изменения в программировании приложений. Все видимые пользователем изменения перечислены в примечаниях к выпуску ( &lt;a href=&quot;https://www.postgresql.org/docs/12/release.html&quot;&gt;Приложение E&lt;/a&gt; ); Обратите особое внимание на раздел &amp;laquo;Миграция&amp;raquo;. Если вы обновляете несколько основных версий, обязательно прочтите примечания к выпуску для каждой промежуточной версии.</target>
        </trans-unit>
        <trans-unit id="48e034a875ce9ccd77246027f6e0993adbe610b3" translate="yes" xml:space="preserve">
          <source>New major versions also typically introduce some user-visible incompatibilities, so application programming changes might be required. All user-visible changes are listed in the release notes (&lt;a href=&quot;https://www.postgresql.org/docs/13/release.html&quot;&gt;Appendix E&lt;/a&gt;); pay particular attention to the section labeled &quot;Migration&quot;. If you are upgrading across several major versions, be sure to read the release notes for each intervening version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56ea799e1817e77cfb14f705f9837d87da3531d" translate="yes" xml:space="preserve">
          <source>New name for an existing column.</source>
          <target state="translated">Новое название для существующей колонки.</target>
        </trans-unit>
        <trans-unit id="b258c013a0b2baff94eb0ca18fab582791cfc317" translate="yes" xml:space="preserve">
          <source>New name for the table.</source>
          <target state="translated">Новое название таблицы.</target>
        </trans-unit>
        <trans-unit id="e2584f9de9d6b68e373738ded405b0367bf25369" translate="yes" xml:space="preserve">
          <source>New probes can be defined within the code wherever the developer desires, though this will require a recompilation. Below are the steps for inserting new probes:</source>
          <target state="translated">Новые зонды могут быть определены в коде везде,где разработчик хочет,хотя это потребует перекомпиляции.Ниже приведены шаги по вставке новых зондов:</target>
        </trans-unit>
        <trans-unit id="9bb5261862459d4fc2f236436c680944b53b22bf" translate="yes" xml:space="preserve">
          <source>New row</source>
          <target state="translated">Новый ряд</target>
        </trans-unit>
        <trans-unit id="b1955e711ad4344c38fc8ef166f89eecc1ca6dce" translate="yes" xml:space="preserve">
          <source>New row &lt;a href=&quot;#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup id=&quot;RLS-SELECT-PRIV&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">Новая строка &lt;a href=&quot;#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup id=&quot;RLS-SELECT-PRIV&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45bbeac915cddbd627fa355d4df5b9dbbc9336c8" translate="yes" xml:space="preserve">
          <source>New rows are checked against the conditions of the view and all underlying base views. If the &lt;code&gt;CHECK OPTION&lt;/code&gt; is specified, and neither &lt;code&gt;LOCAL&lt;/code&gt; nor &lt;code&gt;CASCADED&lt;/code&gt; is specified, then &lt;code&gt;CASCADED&lt;/code&gt; is assumed.</source>
          <target state="translated">Новые строки проверяются на соответствие условиям представления и всех базовых представлений. Если указан &lt;code&gt;CHECK OPTION&lt;/code&gt; ,но не указано ни &lt;code&gt;LOCAL&lt;/code&gt; , ни &lt;code&gt;CASCADED&lt;/code&gt; , то предполагается &lt;code&gt;CASCADED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08a4db17fa684c55666b397d42c621a7aaca8bcb" translate="yes" xml:space="preserve">
          <source>New rows are only checked against the conditions defined directly in the view itself. Any conditions defined on underlying base views are not checked (unless they also specify the &lt;code&gt;CHECK OPTION&lt;/code&gt;).</source>
          <target state="translated">Новые строки проверяются только на соответствие условиям, определенным непосредственно в самом представлении. Любые условия, определенные на базовых базовых представлениях, не проверяются (если они также не указывают &lt;code&gt;CHECK OPTION&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0fffd55cc966a5c918570729a73087e9799e7b21" translate="yes" xml:space="preserve">
          <source>New server version.</source>
          <target state="translated">Новая серверная версия.</target>
        </trans-unit>
        <trans-unit id="326bf78cdc5261237c497696e2f88d3bf937ac51" translate="yes" xml:space="preserve">
          <source>New table constraint for the foreign table.</source>
          <target state="translated">Новое ограничение на стол для иностранцев.</target>
        </trans-unit>
        <trans-unit id="c7fc18feb54e6ecc777a74b8dce9c763304724d3" translate="yes" xml:space="preserve">
          <source>New table constraint for the table.</source>
          <target state="translated">Новое ограничение для таблицы.</target>
        </trans-unit>
        <trans-unit id="0ef8f5b2618f8741358d2dc6f311e26c77d17c09" translate="yes" xml:space="preserve">
          <source>New value of parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter. &lt;code&gt;DEFAULT&lt;/code&gt; can be written to specify resetting the parameter to its default value (that is, whatever value it would have had if no &lt;code&gt;SET&lt;/code&gt; had been executed in the current session).</source>
          <target state="translated">Новое значение параметра. Значения могут быть указаны как строковые константы, идентификаторы, числа или их списки, разделенные запятыми, в зависимости от конкретного параметра. &lt;code&gt;DEFAULT&lt;/code&gt; может быть записан для указания сброса параметра до значения по умолчанию (то есть любого значения, которое он имел бы, если бы в текущем сеансе не выполнялся &lt;code&gt;SET&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="74ad18207dee0729707d6021134389a09abbbcf4" translate="yes" xml:space="preserve">
          <source>New value of the parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter. &lt;code&gt;DEFAULT&lt;/code&gt; can be written to specify removing the parameter and its value from &lt;code&gt;postgresql.auto.conf&lt;/code&gt;.</source>
          <target state="translated">Новое значение параметра. Значения могут быть указаны как строковые константы, идентификаторы, числа или их списки, разделенные запятыми, в зависимости от конкретного параметра. Можно написать &lt;code&gt;DEFAULT&lt;/code&gt; , чтобы указать удаление параметра и его значения из &lt;code&gt;postgresql.auto.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f73bcda4d00edad798e144ba44c98c20a80aa1b" translate="yes" xml:space="preserve">
          <source>Newer operating systems may check for the known TSC problems and switch to a slower, more stable clock source when they are seen. If your system supports TSC time but doesn't default to that, it may be disabled for a good reason. And some operating systems may not detect all the possible problems correctly, or will allow using TSC even in situations where it's known to be inaccurate.</source>
          <target state="translated">Более новые операционные системы могут проверять известные проблемы TSC и при их обнаружении переключаться на более медленный и стабильный источник тактовых импульсов.Если ваша система поддерживает время TSC,но не поддерживает его по умолчанию,она может быть отключена по уважительной причине.А некоторые операционные системы могут не обнаружить все возможные проблемы корректно,или разрешат использовать TSC даже в ситуациях,когда известно,что это неточно.</target>
        </trans-unit>
        <trans-unit id="91613c0496c344d2d60b757f74e45fc5cc402ce3" translate="yes" xml:space="preserve">
          <source>Newline (ASCII 10)</source>
          <target state="translated">Новая линия (ASCII 10)</target>
        </trans-unit>
        <trans-unit id="abcfe34ad9620d6f4bc03407b5ef1c1c15fc3d23" translate="yes" xml:space="preserve">
          <source>Newlines are inserted between fields as needed to limit line length to 80 characters, if possible. A newline is also inserted between the metadata fields and the regular fields.</source>
          <target state="translated">Новые строки вставляются между полями по мере необходимости для ограничения длины строки до 80 символов,если это возможно.Новая линия также вставляется между полями метаданных и обычными полями.</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="668d132684646785e22fe1441b80ce3d2edabbcd" translate="yes" xml:space="preserve">
          <source>Next field is Julian Date</source>
          <target state="translated">Следующее поле-Джулиан Дата</target>
        </trans-unit>
        <trans-unit id="b894f41f03f11b1ed4f8f278b45d31b30d6d7e9d" translate="yes" xml:space="preserve">
          <source>Next field is time</source>
          <target state="translated">Следующее поле-время</target>
        </trans-unit>
        <trans-unit id="8bbd06fda45074a003115cb92bcdeae70e3776f1" translate="yes" xml:space="preserve">
          <source>Next let's consider an example with an equality condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">Теперь давайте рассмотрим пример с условием равенства в &lt;code&gt;WHERE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0accafa67ae47755f44a4c829c06920cf375701d" translate="yes" xml:space="preserve">
          <source>Next the fraction of the histogram occupied by &amp;ldquo;&amp;lt; 1000&amp;rdquo; is worked out. This is the selectivity. The histogram divides the range into equal frequency buckets, so all we have to do is locate the bucket that our value is in and count &lt;em&gt;part&lt;/em&gt; of it and &lt;em&gt;all&lt;/em&gt; of the ones before. The value 1000 is clearly in the second bucket (993&amp;ndash;1997). Assuming a linear distribution of values inside each bucket, we can calculate the selectivity as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed06150c503b0381101da4c9e29738d8aede6e0" translate="yes" xml:space="preserve">
          <source>Next the fraction of the histogram occupied by &amp;ldquo;&amp;lt; 1000&amp;rdquo; is worked out. This is the selectivity. The histogram divides the range into equal frequency buckets, so all we have to do is locate the bucket that our value is in and count &lt;em&gt;part&lt;/em&gt; of it and &lt;em&gt;all&lt;/em&gt; of the ones before. The value 1000 is clearly in the second bucket (993-1997). Assuming a linear distribution of values inside each bucket, we can calculate the selectivity as:</source>
          <target state="translated">Затем вычисляется доля гистограммы, занятая &amp;laquo;&amp;lt;1000&amp;raquo;. Это избирательность. Гистограмма делит диапазон на сегменты с равной частотой, поэтому все, что нам нужно сделать, это найти сегмент, в котором находится наше значение, и подсчитать его &lt;em&gt;часть&lt;/em&gt; и &lt;em&gt;все&lt;/em&gt; предыдущие. Значение 1000 явно находится во втором сегменте (993&amp;ndash;1997). Предполагая линейное распределение значений внутри каждого сегмента, мы можем рассчитать избирательность как:</target>
        </trans-unit>
        <trans-unit id="5e15fe544e0817c8abcd5bf63590f065c8fda5e8" translate="yes" xml:space="preserve">
          <source>Next we register the Ispell dictionary &lt;code&gt;english_ispell&lt;/code&gt;, which has its own configuration files:</source>
          <target state="translated">Далее мы регистрируем словарь Ispell &lt;code&gt;english_ispell&lt;/code&gt; , который имеет собственные файлы конфигурации:</target>
        </trans-unit>
        <trans-unit id="5d2e580901bf6290e8151d5811cdef90838e8edb" translate="yes" xml:space="preserve">
          <source>Next, &lt;code&gt;pg_verifybackup&lt;/code&gt; will checksum all the files, compare the checksums against the values in the manifest, and emit errors for any files for which the computed checksum does not match the checksum stored in the manifest. This step is not performed for any files which produced errors in the previous step, since they are already known to have problems. Files which were ignored in the previous step are also ignored in this step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb6f7d3081e6797875cb41a13e6c45a3f761bbf" translate="yes" xml:space="preserve">
          <source>Next, create a trigram index on the word column:</source>
          <target state="translated">Далее создайте триграммовый индекс в столбце слова:</target>
        </trans-unit>
        <trans-unit id="d9e892095e44895492c517f24015243e155c5a35" translate="yes" xml:space="preserve">
          <source>Next, there might be a cache in the disk drive controller; this is particularly common on RAID controller cards. Some of these caches are &lt;em&gt;write-through&lt;/em&gt;, meaning writes are sent to the drive as soon as they arrive. Others are &lt;em&gt;write-back&lt;/em&gt;, meaning data is sent to the drive at some later time. Such caches can be a reliability hazard because the memory in the disk controller cache is volatile, and will lose its contents in a power failure. Better controller cards have &lt;em&gt;battery-backup units&lt;/em&gt; (BBUs), meaning the card has a battery that maintains power to the cache in case of system power loss. After power is restored the data will be written to the disk drives.</source>
          <target state="translated">Далее, в контроллере дисковода может быть кэш; это особенно часто встречается на картах контроллера RAID. Некоторые из этих кешей являются &lt;em&gt;сквозными&lt;/em&gt; , то есть записи отправляются на диск сразу после их поступления. Другие - с &lt;em&gt;обратной записью&lt;/em&gt; , то есть данные отправляются на диск в более позднее время. Такие кэши могут представлять опасность для надежности, поскольку память в кэше контроллера диска является непостоянной и теряет свое содержимое при сбое питания. В более совершенных картах контроллеров есть &lt;em&gt;блоки резервного питания&lt;/em&gt; (BBU), то есть на карте есть аккумулятор, обеспечивающий питание кеш-памяти в случае отключения питания системы. После восстановления питания данные будут записаны на диски.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="ab63ab43b9cd6b9423e3548d5b6495e55251533e" translate="yes" xml:space="preserve">
          <source>No background workers can be obtained because of the limitation that the total number of background workers cannot exceed &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;.</source>
          <target state="translated">Невозможно получить фоновые рабочие &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;процессы&lt;/a&gt; из-за ограничения, что общее количество фоновых рабочих не может превышать max_worker_processes .</target>
        </trans-unit>
        <trans-unit id="1db509e223519bbbe9c20165e8b19fc16220b41f" translate="yes" xml:space="preserve">
          <source>No background workers can be obtained because of the limitation that the total number of background workers launched for purposes of parallel query cannot exceed &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;.</source>
          <target state="translated">Невозможно получить фоновые рабочие процессы из-за ограничения, что общее количество фоновых рабочих процессов, запускаемых для целей параллельного запроса, не может превышать &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="737fbf99fcaacc1c750aa9911a89ba763b4fb6c2" translate="yes" xml:space="preserve">
          <source>No conflict resolution necessary</source>
          <target state="translated">Нет необходимости в разрешении конфликта</target>
        </trans-unit>
        <trans-unit id="c4ae42341e7948bd6be9068db7f6b708eab0516f" translate="yes" xml:space="preserve">
          <source>No direct modifications of buffers are allowed! All modifications must be done in copies acquired from &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt;. In other words, code that makes generic WAL records should never call &lt;code&gt;BufferGetPage()&lt;/code&gt; for itself. However, it remains the caller's responsibility to pin/unpin and lock/unlock the buffers at appropriate times. Exclusive lock must be held on each target buffer from before &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; until after &lt;code&gt;GenericXLogFinish()&lt;/code&gt;.</source>
          <target state="translated">Прямые модификации буферов не допускаются! Все изменения должны производиться в копиях, полученных от &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; . Другими словами, код, &lt;code&gt;BufferGetPage()&lt;/code&gt; общие записи WAL, никогда не должен вызывать BufferGetPage () для себя. Однако ответственность за закрепление / открепление и блокирование / разблокирование буферов в соответствующее время остается за вызывающей стороной. Эксклюзивная блокировка должна удерживаться для каждого целевого буфера от &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; до &lt;code&gt;GenericXLogFinish()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59fe225d3b68631dd2336d2bf5588427b3b21997" translate="yes" xml:space="preserve">
          <source>No error concerning corruption raised by &lt;code&gt;amcheck&lt;/code&gt; should ever be a false positive. &lt;code&gt;amcheck&lt;/code&gt; raises errors in the event of conditions that, by definition, should never happen, and so careful analysis of &lt;code&gt;amcheck&lt;/code&gt; errors is often required.</source>
          <target state="translated">Никакая ошибка, связанная с повреждением, &lt;code&gt;amcheck&lt;/code&gt; никогда не должна быть ложноположительной. &lt;code&gt;amcheck&lt;/code&gt; выдает ошибки в случае условий, которые по определению никогда не должны происходить, поэтому часто требуется тщательный анализ ошибок &lt;code&gt;amcheck&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b39fb69a71692aa8fa18d1717c1f94f66adfcdf" translate="yes" xml:space="preserve">
          <source>No master server overhead</source>
          <target state="translated">Нет накладных расходов на главный сервер</target>
        </trans-unit>
        <trans-unit id="69d7c6fd29e6141d46559276ef0d0824b8ca6117" translate="yes" xml:space="preserve">
          <source>No more than 256 positions per lexeme</source>
          <target state="translated">Не более 256 позиций на лексему</target>
        </trans-unit>
        <trans-unit id="d6105567c57e07dede5d4075af64116a14eb0b4d" translate="yes" xml:space="preserve">
          <source>No particular limit is imposed on the length of REs in this implementation. However, programs intended to be highly portable should not employ REs longer than 256 bytes, as a POSIX-compliant implementation can refuse to accept such REs.</source>
          <target state="translated">Никаких конкретных ограничений в отношении продолжительности РЭ в рамках этой реализации не установлено.Однако программы,предназначенные для высокой переносимости,не должны использовать РЭ длиннее 256 байт,поскольку в реализации,соответствующей POSIX,может быть отказано в приеме таких РЭ.</target>
        </trans-unit>
        <trans-unit id="b403c7e51ec107180064180093a27a248cb9fcae" translate="yes" xml:space="preserve">
          <source>No special action is taken at the ends of transactions. This is the default behavior.</source>
          <target state="translated">По окончании операций никаких специальных действий не предпринимается.Это поведение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="61fdd0ee1a0e012e017d3d0ae54de832b57200e8" translate="yes" xml:space="preserve">
          <source>No special hardware required</source>
          <target state="translated">Специальное оборудование не требуется</target>
        </trans-unit>
        <trans-unit id="ae79014d45aed5cbc3110d3674ce8fdfb2183d69" translate="yes" xml:space="preserve">
          <source>No support for encryption key as master key. As such practice is generally discouraged, this should not be a problem.</source>
          <target state="translated">Нет поддержки ключа шифрования в качестве главного ключа.Поскольку такая практика обычно не поощряется,это не должно быть проблемой.</target>
        </trans-unit>
        <trans-unit id="8c30a7a5188f10c0ac8624ba81f5e723c5467bcf" translate="yes" xml:space="preserve">
          <source>No support for several subkeys. This may seem like a problem, as this is common practice. On the other hand, you should not use your regular GPG/PGP keys with &lt;code&gt;pgcrypto&lt;/code&gt;, but create new ones, as the usage scenario is rather different.</source>
          <target state="translated">Нет поддержки нескольких подключей. Это может показаться проблемой, поскольку это обычная практика. С другой стороны, вы не должны использовать обычные ключи GPG / PGP с &lt;code&gt;pgcrypto&lt;/code&gt; , а создавать новые, поскольку сценарий использования несколько отличается.</target>
        </trans-unit>
        <trans-unit id="c9435d4dd42a8ebc8de1b106f0a226340aa75454" translate="yes" xml:space="preserve">
          <source>No support for signing. That also means that it is not checked whether the encryption subkey belongs to the master key.</source>
          <target state="translated">Никакой поддержки для подписания.Это также означает,что не проверяется,принадлежит ли шифровальный подключ мастер-ключу.</target>
        </trans-unit>
        <trans-unit id="c0ba19704438347e67d6c41db6384452ae2aa5a4" translate="yes" xml:space="preserve">
          <source>No waiting for multiple servers</source>
          <target state="translated">Не нужно ждать нескольких серверов</target>
        </trans-unit>
        <trans-unit id="4b6d8042bc7e3d0b0614251a34971ce673127f09" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;C&lt;/code&gt; and non-&lt;code&gt;POSIX&lt;/code&gt; locales rely on the operating system's collation library for character set ordering. This controls the ordering of keys stored in indexes. For this reason, a cluster cannot switch to an incompatible collation library version, either through snapshot restore, binary streaming replication, a different operating system, or an operating system upgrade.</source>
          <target state="translated">Локали, отличные от &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;POSIX&lt;/code&gt; , зависят от библиотеки сопоставления операционной системы для упорядочивания наборов символов. Это контролирует порядок ключей, хранящихся в индексах. По этой причине кластер не может переключиться на несовместимую версию библиотеки сортировки ни с помощью восстановления моментального снимка, ни с помощью двоичной потоковой репликации, ни с помощью другой операционной системы, ни с помощью обновления операционной системы.</target>
        </trans-unit>
        <trans-unit id="b791053ba5b378d8e57979f3c97566be063ef0d0" translate="yes" xml:space="preserve">
          <source>Non-Deferred Uniqueness Constraints</source>
          <target state="translated">Непредложенная уникальность Ограничения</target>
        </trans-unit>
        <trans-unit id="2edd532d90e9a265b3d587446d10683f0ddb82ba" translate="yes" xml:space="preserve">
          <source>Non-Durable Settings</source>
          <target state="translated">Необслуживаемые настройки</target>
        </trans-unit>
        <trans-unit id="1606d825faba4ca859c553032bca97393df353c3" translate="yes" xml:space="preserve">
          <source>Non-absolute directory names are taken as relative to the directory containing the referencing configuration file. Within the specified directory, only non-directory files whose names end with the suffix &lt;code&gt;.conf&lt;/code&gt; will be included. File names that start with the &lt;code&gt;.&lt;/code&gt; character are also ignored, to prevent mistakes since such files are hidden on some platforms. Multiple files within an include directory are processed in file name order (according to C locale rules, i.e. numbers before letters, and uppercase letters before lowercase ones).</source>
          <target state="translated">Неабсолютные имена каталогов принимаются относительно каталога, содержащего ссылочный файл конфигурации. В указанный каталог будут включены только файлы, не являющиеся каталогами, имена которых заканчиваются суффиксом &lt;code&gt;.conf&lt;/code&gt; . Имена файлов, начинающиеся с &lt;code&gt;.&lt;/code&gt; также игнорируются, чтобы предотвратить ошибки, поскольку такие файлы скрыты на некоторых платформах. Несколько файлов в подключаемом каталоге обрабатываются в порядке имен файлов (в соответствии с правилами локали C, т. Е. Числа перед буквами и буквы верхнего регистра перед строчными).</target>
        </trans-unit>
        <trans-unit id="375e6f9829aa08a22fb91bd89b1b288cc7a6547e" translate="yes" xml:space="preserve">
          <source>Non-absolute directory names are taken as relative to the directory containing the referencing configuration file. Within the specified directory, only non-directory files whose names end with the suffix &lt;code&gt;.conf&lt;/code&gt; will be included. File names that start with the &lt;code&gt;.&lt;/code&gt; character are also ignored, to prevent mistakes since such files are hidden on some platforms. Multiple files within an include directory are processed in file name order (according to C locale rules, i.e., numbers before letters, and uppercase letters before lowercase ones).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0daa9d12e18919b30fa114566dbfc8fde09c52f" translate="yes" xml:space="preserve">
          <source>Non-equality comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005bf64a001e88d6c5954633016b2d70a8916d20" translate="yes" xml:space="preserve">
          <source>Non-equality operator</source>
          <target state="translated">Некачественный оператор</target>
        </trans-unit>
        <trans-unit id="5d6b03babc67eb26f4a561798892e8e1d042f8b8" translate="yes" xml:space="preserve">
          <source>Non-equality operator (same as &lt;code&gt;!=&lt;/code&gt;)</source>
          <target state="translated">Оператор неравенства (такой же, как &lt;code&gt;!=&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="20c0da4f56e91a8e794e8ad5b40aa2db7a25e473" translate="yes" xml:space="preserve">
          <source>Non-schema objects such as blobs are not dumped when &lt;code&gt;-n&lt;/code&gt; is specified. You can add blobs back to the dump with the &lt;code&gt;--blobs&lt;/code&gt; switch.</source>
          <target state="translated">Объекты, не относящиеся к схеме, такие как большие двоичные объекты, не выгружаются, если указан параметр &lt;code&gt;-n&lt;/code&gt; . Вы можете добавить капли обратно в дамп с &lt;code&gt;--blobs&lt;/code&gt; переключателя --blobs .</target>
        </trans-unit>
        <trans-unit id="9caf6bd6e45fde8300143ee2bd8d45d380012859" translate="yes" xml:space="preserve">
          <source>Non-standard syntax for &lt;code&gt;trim()&lt;/code&gt;</source>
          <target state="translated">Нестандартный синтаксис для &lt;code&gt;trim()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b82aac77684b2e34b968be8bab3328cdefd6c87" translate="yes" xml:space="preserve">
          <source>Non-superusers can only apply &lt;code&gt;LOAD&lt;/code&gt; to library files located in &lt;code&gt;$libdir/plugins/&lt;/code&gt; &amp;mdash; the specified &lt;code&gt;filename&lt;/code&gt; must begin with exactly that string. (It is the database administrator's responsibility to ensure that only &amp;ldquo;safe&amp;rdquo; libraries are installed there.)</source>
          <target state="translated">Не суперпользователи могут применять &lt;code&gt;LOAD&lt;/code&gt; только к файлам библиотеки, расположенным в &lt;code&gt;$libdir/plugins/&lt;/code&gt; - указанное &lt;code&gt;filename&lt;/code&gt; должно начинаться именно с этой строки. (Ответственность за то, чтобы там были установлены только &amp;laquo;безопасные&amp;raquo; библиотеки, лежит на администраторе базы данных.)</target>
        </trans-unit>
        <trans-unit id="33362508c287b322946b88bcd446c4aed0b4f943" translate="yes" xml:space="preserve">
          <source>Non-zero values of this setting add overhead, as PostgreSQL will need to store textual representations of parameter values in memory at the start of each statement, whether or not an error eventually occurs. The overhead is greater when bind parameters are sent in binary form than when they are sent as text, since the former case requires data conversion while the latter only requires copying the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdcf35d8373c6ae03dbb38620bdfe970a151c4ed" translate="yes" xml:space="preserve">
          <source>Nondeterministic collations are only supported with the ICU provider.</source>
          <target state="translated">Недетерминистические коллизии поддерживаются только с провайдером ICU.</target>
        </trans-unit>
        <trans-unit id="592caa46c1febc51d4ba97d3f0cb331e0f251855" translate="yes" xml:space="preserve">
          <source>Nonrepeatable Read</source>
          <target state="translated">Неповторяемое чтение</target>
        </trans-unit>
        <trans-unit id="4cd9a0397eea6fedc043bb59b16fdf2f16c3bc14" translate="yes" xml:space="preserve">
          <source>Nonstandard Clauses</source>
          <target state="translated">Нестандартные пункты</target>
        </trans-unit>
        <trans-unit id="d10c40965cecc5427a7ccc11e532baca90682092" translate="yes" xml:space="preserve">
          <source>Nordic</source>
          <target state="translated">Nordic</target>
        </trans-unit>
        <trans-unit id="5d192ac91d079d3947c34df6ca0da6af270cb95a" translate="yes" xml:space="preserve">
          <source>Normal cursors return data in text format, the same as a &lt;code&gt;SELECT&lt;/code&gt; would produce. The &lt;code&gt;BINARY&lt;/code&gt; option specifies that the cursor should return data in binary format. This reduces conversion effort for both the server and client, at the cost of more programmer effort to deal with platform-dependent binary data formats. As an example, if a query returns a value of one from an integer column, you would get a string of &lt;code&gt;1&lt;/code&gt; with a default cursor, whereas with a binary cursor you would get a 4-byte field containing the internal representation of the value (in big-endian byte order).</source>
          <target state="translated">Обычные курсоры возвращают данные в текстовом формате, как при &lt;code&gt;SELECT&lt;/code&gt; . Параметр &lt;code&gt;BINARY&lt;/code&gt; указывает, что курсор должен возвращать данные в двоичном формате. Это сокращает усилия по преобразованию как для сервера, так и для клиента за счет дополнительных усилий программиста для работы с зависящими от платформы форматами двоичных данных. Например, если запрос возвращает значение единицы из целочисленного столбца, вы получите строку &lt;code&gt;1&lt;/code&gt; с курсором по умолчанию, тогда как с двоичным курсором вы получите 4-байтовое поле, содержащее внутреннее представление значения ( в порядке байтов с прямым порядком байтов).</target>
        </trans-unit>
        <trans-unit id="e719f066c8f80c3d098dc0de105e52604edf52bd" translate="yes" xml:space="preserve">
          <source>Normally a copy of &lt;code&gt;pg_type.typstorage&lt;/code&gt; of this column's type. For TOAST-able data types, this can be altered after column creation to control storage policy.</source>
          <target state="translated">Обычно копия &lt;code&gt;pg_type.typstorage&lt;/code&gt; типа этого столбца. Для типов данных с поддержкой TOAST это можно изменить после создания столбца для управления политикой хранения.</target>
        </trans-unit>
        <trans-unit id="dfefa02592536f045045c313a59b93cf3ea4a182" translate="yes" xml:space="preserve">
          <source>Normally it is better to start &lt;code&gt;postgres&lt;/code&gt; in the background. For this, use the usual Unix shell syntax:</source>
          <target state="translated">Обычно лучше запускать &lt;code&gt;postgres&lt;/code&gt; в фоновом режиме. Для этого используйте обычный синтаксис оболочки Unix:</target>
        </trans-unit>
        <trans-unit id="eb15db27354b906033434be491a2ae185754105d" translate="yes" xml:space="preserve">
          <source>Normally the set of partitions established when initially defining the table are not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around.</source>
          <target state="translated">Обычно набор простенков,установленный при первичной дефиниции таблицы,не предназначен для того,чтобы оставаться статичным.Обычно требуется удалить старые разделы данных и периодически добавлять новые разделы для новых данных.Одним из наиболее важных преимуществ разметки является именно то,что она позволяет выполнить эту болезненную в остальном задачу практически мгновенно,манипулируя структурой разделов,а не физически перемещая вокруг себя большие объемы данных.</target>
        </trans-unit>
        <trans-unit id="fe2f8f91b212090479c992426f90bbd96089fce0" translate="yes" xml:space="preserve">
          <source>Normally the set of partitions established when initially defining the table is not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e1a3935578c6fbceb8f9dfc1ec7edf36d93788" translate="yes" xml:space="preserve">
          <source>Normally there is one entry, with &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;, for each table column that has been analyzed. If the table has inheritance children, a second entry with &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; is also created. This row represents the column's statistics over the inheritance tree, i.e., statistics for the data you'd see with &lt;code&gt;SELECT column FROM table*&lt;/code&gt;, whereas the &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; row represents the results of &lt;code&gt;SELECT column FROM ONLY table&lt;/code&gt;.</source>
          <target state="translated">Обычно для каждого анализируемого столбца таблицы есть одна запись со значением &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; . Если таблица имеет дочерние &lt;code&gt;stainherit&lt;/code&gt; наследования, также создается вторая запись со значением Stainherit = &lt;code&gt;true&lt;/code&gt; . Эта строка представляет статистику столбца по дереву наследования, т. &lt;code&gt;stainherit&lt;/code&gt; Статистику для данных, которые вы бы увидели с помощью &lt;code&gt;SELECT column FROM table*&lt;/code&gt; , тогда как строка Stainherit = &lt;code&gt;false&lt;/code&gt; представляет результаты &lt;code&gt;SELECT column FROM ONLY table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef0a797677cd4cd7010abb5ff69a6286820deaa9" translate="yes" xml:space="preserve">
          <source>Normally these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt; so that they apply to all server processes, but it is possible to turn them on or off in individual sessions using the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command. (To prevent ordinary users from hiding their activity from the administrator, only superusers are allowed to change these parameters with &lt;code&gt;SET&lt;/code&gt;.)</source>
          <target state="translated">Обычно эти параметры устанавливаются в &lt;code&gt;postgresql.conf&lt;/code&gt; так, что они применяются ко всем процессам сервера, но их можно включить или выключить в отдельных сеансах с помощью команды &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; . (Чтобы обычные пользователи не скрывали свою активность от администратора, только суперпользователи могут изменять эти параметры с помощью &lt;code&gt;SET&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="defa435e9220700a95afbba17bf09c1d280dc0dd" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;EXPLAIN&lt;/code&gt; will display every plan node created by the planner. However, there are cases where the executor can determine that certain nodes need not be executed because they cannot produce any rows, based on parameter values that were not available at planning time. (Currently this can only happen for child nodes of an Append or MergeAppend node that is scanning a partitioned table.) When this happens, those plan nodes are omitted from the &lt;code&gt;EXPLAIN&lt;/code&gt; output and a &lt;code&gt;Subplans Removed: N&lt;/code&gt; annotation appears instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059b752177da2be76f272de074908dfea33c9049" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;VACUUM&lt;/code&gt; will skip pages based on the &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-VISIBILITY-MAP&quot;&gt;visibility map&lt;/a&gt;. Pages where all tuples are known to be frozen can always be skipped, and those where all tuples are known to be visible to all transactions may be skipped except when performing an aggressive vacuum. Furthermore, except when performing an aggressive vacuum, some pages may be skipped in order to avoid waiting for other sessions to finish using them. This option disables all page-skipping behavior, and is intended to be used only when the contents of the visibility map are suspect, which should happen only if there is a hardware or software issue causing database corruption.</source>
          <target state="translated">Обычно &lt;code&gt;VACUUM&lt;/code&gt; пропускает страницы в зависимости от &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-VISIBILITY-MAP&quot;&gt;карты видимости&lt;/a&gt; . Страницы, где известно, что все кортежи заморожены, всегда можно пропустить, а те, где известно, что все кортежи видны для всех транзакций, могут быть пропущены, кроме случаев, когда выполняется агрессивная очистка. Кроме того, за исключением выполнения агрессивной очистки, некоторые страницы могут быть пропущены, чтобы не ждать, пока другие сеансы закончат их использовать. Этот параметр отключает все действия с пропуском страниц и предназначен для использования только в том случае, если содержимое карты видимости является подозрительным, что должно происходить только при наличии аппаратной или программной проблемы, вызывающей повреждение базы данных.</target>
        </trans-unit>
        <trans-unit id="5a28b92dedca807b45d1375cda7834475db13842" translate="yes" xml:space="preserve">
          <source>Normally, a database session will read a dictionary configuration file only once, when it is first used within the session. If you modify a configuration file and want to force existing sessions to pick up the new contents, issue an &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; command on the dictionary. This can be a &amp;ldquo;dummy&amp;rdquo; update that doesn't actually change any parameter values.</source>
          <target state="translated">Обычно сеанс базы данных читает файл конфигурации словаря только один раз, когда он впервые используется в сеансе. Если вы изменяете файл конфигурации и хотите заставить существующие сеансы получать новое содержимое, выполните команду &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; в словаре. Это может быть &amp;laquo;фиктивное&amp;raquo; обновление, которое фактически не меняет никаких значений параметров.</target>
        </trans-unit>
        <trans-unit id="8bffa790046f833c87fae190fc13aecca45c4acb" translate="yes" xml:space="preserve">
          <source>Normally, a referencing row need not satisfy the foreign key constraint if any of its referencing columns are null. If &lt;code&gt;MATCH FULL&lt;/code&gt; is added to the foreign key declaration, a referencing row escapes satisfying the constraint only if all its referencing columns are null (so a mix of null and non-null values is guaranteed to fail a &lt;code&gt;MATCH FULL&lt;/code&gt; constraint). If you don't want referencing rows to be able to avoid satisfying the foreign key constraint, declare the referencing column(s) as &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">Обычно ссылающаяся строка не обязана удовлетворять ограничению внешнего ключа, если какой-либо из ее ссылающихся столбцов имеет значение NULL. Если к объявлению внешнего ключа добавлено &lt;code&gt;MATCH FULL&lt;/code&gt; ,ссылающаяся строка ускользает, удовлетворяя ограничению, только если все ее ссылающиеся столбцы равны нулю (поэтому сочетание нулевых и ненулевых значений гарантированно не &lt;code&gt;MATCH FULL&lt;/code&gt; к сбою ограничения MATCH FULL ). Если вы не хотите, чтобы ссылочные строки могли избежать выполнения ограничения внешнего ключа, объявите ссылочный столбец (столбцы) как &lt;code&gt;NOT NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a73d6e4c0676c9748a26df54015a17cf72960f1a" translate="yes" xml:space="preserve">
          <source>Normally, psql will dispatch a SQL command to the server as soon as it reaches the command-ending semicolon, even if more input remains on the current line. Thus for example entering</source>
          <target state="translated">Обычно psql посылает SQL-команду на сервер,как только она достигает точки с запятой,даже если в текущей строке остается больше входных данных.Таким образом,например,ввод</target>
        </trans-unit>
        <trans-unit id="c995fea5a35dfbddf38f7ea21e264f8ae6030a27" translate="yes" xml:space="preserve">
          <source>Normally, recovery will proceed through all available WAL segments, thereby restoring the database to the current point in time (or as close as possible given the available WAL segments). Therefore, a normal recovery will end with a &amp;ldquo;file not found&amp;rdquo; message, the exact text of the error message depending upon your choice of &lt;code&gt;restore_command&lt;/code&gt;. You may also see an error message at the start of recovery for a file named something like &lt;code&gt;00000001.history&lt;/code&gt;. This is also normal and does not indicate a problem in simple recovery situations; see &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;Section 25.3.5&lt;/a&gt; for discussion.</source>
          <target state="translated">Обычно восстановление будет происходить по всем доступным сегментам WAL, тем самым восстанавливая базу данных до текущего момента времени (или как можно более близкого к имеющимся сегментам WAL). Поэтому обычное восстановление закончится сообщением &amp;laquo;файл не найден&amp;raquo;, точный текст сообщения об ошибке зависит от вашего выбора &lt;code&gt;restore_command&lt;/code&gt; . Вы также можете увидеть сообщение об ошибке в начале восстановления для файла с именем, например, &lt;code&gt;00000001.history&lt;/code&gt; . Это тоже нормально и не указывает на проблему в простых ситуациях восстановления; см. &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;раздел 25.3.5&lt;/a&gt; для обсуждения.</target>
        </trans-unit>
        <trans-unit id="991460ee5abf98bebd31fd08e1871d36222f94b0" translate="yes" xml:space="preserve">
          <source>Normally, the database user who executes this command becomes the owner of the new database. However, a different owner can be specified via the &lt;code&gt;-O&lt;/code&gt; option, if the executing user has appropriate privileges.</source>
          <target state="translated">Обычно пользователь базы данных, выполняющий эту команду, становится владельцем новой базы данных. Однако можно указать другого владельца с помощью опции &lt;code&gt;-O&lt;/code&gt; , если у выполняющего пользователя есть соответствующие привилегии.</target>
        </trans-unit>
        <trans-unit id="cce3fdca736676d73614d21a0ddda63501859fa9" translate="yes" xml:space="preserve">
          <source>Normally, the single-user mode server treats newline as the command entry terminator; there is no intelligence about semicolons, as there is in psql. To continue a command across multiple lines, you must type backslash just before each newline except the last one. The backslash and adjacent newline are both dropped from the input command. Note that this will happen even when within a string literal or comment.</source>
          <target state="translated">Обычно однопользовательский режим сервера воспринимает newline как терминатор ввода команд;нет никакой информации о точках с запятой,как в psql.Чтобы продолжить команду в нескольких строках,вы должны ввести обратный слеш непосредственно перед каждой новой строкой,кроме последней.Обратный слеш и соседняя новая строка отбрасываются из входной команды.Обратите внимание,что это произойдет,даже если внутри строкового литерала или комментария.</target>
        </trans-unit>
        <trans-unit id="1ab9de63486b486ed7137fde8276d785f144a066" translate="yes" xml:space="preserve">
          <source>Normally, there is a single apply process running for an enabled subscription. A disabled subscription or a crashed subscription will have zero rows in this view. If the initial data synchronization of any table is in progress, there will be additional workers for the tables being synchronized.</source>
          <target state="translated">Обычно для включенной подписки выполняется один процесс применения.Отключенная подписка или разбитая подписка будет иметь нулевые строки в этом представлении.Если начальная синхронизация данных какой-либо таблицы выполняется,то для синхронизируемых таблиц будут дополнительные рабочие места.</target>
        </trans-unit>
        <trans-unit id="67e110cfa914197db96be5bd8ad2cb0e12d33a41" translate="yes" xml:space="preserve">
          <source>Normally, this form will cause a scan of the table to verify that all existing rows in the table satisfy the new constraint. But if the &lt;code&gt;NOT VALID&lt;/code&gt; option is used, this potentially-lengthy scan is skipped. The constraint will still be enforced against subsequent inserts or updates (that is, they'll fail unless there is a matching row in the referenced table, in the case of foreign keys, or they'll fail unless the new row matches the specified check condition). But the database will not assume that the constraint holds for all rows in the table, until it is validated by using the &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; option. See &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Notes&lt;/a&gt; below for more information about using the &lt;code&gt;NOT VALID&lt;/code&gt; option.</source>
          <target state="translated">Обычно эта форма вызывает сканирование таблицы, чтобы убедиться, что все существующие строки в таблице удовлетворяют новому ограничению. Но если используется опция &lt;code&gt;NOT VALID&lt;/code&gt; , это потенциально длительное сканирование пропускается. Ограничение по-прежнему будет применяться к последующим вставкам или обновлениям (то есть они завершатся ошибкой, если в ссылочной таблице нет соответствующей строки, в случае внешних ключей, или они потерпят неудачу, если новая строка не соответствует указанной проверке состояние). Но база данных не будет предполагать, что ограничение выполняется для всех строк в таблице, пока оно не будет проверено с помощью параметра &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; . См. &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Примечания&lt;/a&gt; ниже для получения дополнительной информации об использовании параметра &lt;code&gt;NOT VALID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01a8f59aaf55d8442cfcf99c35955b402850a73f" translate="yes" xml:space="preserve">
          <source>Normally, you will want to start the database server when the computer boots. Autostart scripts are operating-system-specific. There are a few distributed with PostgreSQL in the &lt;code&gt;contrib/start-scripts&lt;/code&gt; directory. Installing one will require root privileges.</source>
          <target state="translated">Обычно вам нужно запустить сервер базы данных при загрузке компьютера. Сценарии автозапуска зависят от операционной системы. Некоторые из них распространяются с PostgreSQL в каталоге &lt;code&gt;contrib/start-scripts&lt;/code&gt; . Для его установки потребуются права root.</target>
        </trans-unit>
        <trans-unit id="6c89afe408dffc3292c4743bcc6ff18a8191e1d0" translate="yes" xml:space="preserve">
          <source>Normally, you will want to start the database server when the computer boots. Autostart scripts are operating-system-specific. There are a few example scripts distributed with PostgreSQL in the &lt;code&gt;contrib/start-scripts&lt;/code&gt; directory. Installing one will require root privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99872ab32108649405bf8805c9de4baeb85fb7ad" translate="yes" xml:space="preserve">
          <source>North European</source>
          <target state="translated">североевропейский</target>
        </trans-unit>
        <trans-unit id="f79ff66cfb084d1746f64ba03a393ded056f91f0" translate="yes" xml:space="preserve">
          <source>Not all client APIs support all the listed character sets. For example, the PostgreSQL JDBC driver does not support &lt;code&gt;MULE_INTERNAL&lt;/code&gt;, &lt;code&gt;LATIN6&lt;/code&gt;, &lt;code&gt;LATIN8&lt;/code&gt;, and &lt;code&gt;LATIN10&lt;/code&gt;.</source>
          <target state="translated">Не все клиентские API поддерживают все перечисленные наборы символов. Например, драйвер JDBC PostgreSQL не поддерживает &lt;code&gt;MULE_INTERNAL&lt;/code&gt; , &lt;code&gt;LATIN6&lt;/code&gt; , &lt;code&gt;LATIN8&lt;/code&gt; и &lt;code&gt;LATIN10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bacd7c0a9a33892b688e78e77b6ecea0ecffd5d" translate="yes" xml:space="preserve">
          <source>Not all of the requested files will be WAL segment files; you should also expect requests for files with a suffix of &lt;code&gt;.history&lt;/code&gt;. Also be aware that the base name of the &lt;code&gt;%p&lt;/code&gt; path will be different from &lt;code&gt;%f&lt;/code&gt;; do not expect them to be interchangeable.</source>
          <target state="translated">Не все запрошенные файлы будут файлами сегментов WAL; вам также следует ожидать запросов на файлы с суффиксом &lt;code&gt;.history&lt;/code&gt; . Также имейте в виду, что базовое имя пути &lt;code&gt;%p&lt;/code&gt; будет отличаться от &lt;code&gt;%f&lt;/code&gt; ; не ожидайте, что они будут взаимозаменяемыми.</target>
        </trans-unit>
        <trans-unit id="91e930192ef14cc5c350419a549c884c45961c36" translate="yes" xml:space="preserve">
          <source>Not between (the negation of &lt;code id=&quot;between&quot;&gt;BETWEEN&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5510ea0072017c65967037de500e9abf1a00ab2" translate="yes" xml:space="preserve">
          <source>Not between, after sorting the two endpoint values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb5b8bcff17673aebb4af5a3aeb0b4ab1932316" translate="yes" xml:space="preserve">
          <source>Not equal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb1931a7fb65e60520184c9226b83ff8b5335ec" translate="yes" xml:space="preserve">
          <source>Not equal, treating null as a comparable value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f925a3c210bc672e17b8d68ff775e287c505fff" translate="yes" xml:space="preserve">
          <source>Not every user has authorization to create new databases. If PostgreSQL refuses to create databases for you then the site administrator needs to grant you permission to create databases. Consult your site administrator if this occurs. If you installed PostgreSQL yourself then you should log in for the purposes of this tutorial under the user account that you started the server as. &lt;a href=&quot;#ftn.id-1.4.3.4.10.4&quot;&gt;&lt;sup id=&quot;id-1.4.3.4.10.4&quot;&gt;[1]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">Не каждый пользователь имеет право создавать новые базы данных. Если PostgreSQL отказывается создавать для вас базы данных, администратор сайта должен предоставить вам разрешение на создание баз данных. Если это произойдет, обратитесь к администратору вашего сайта. Если вы установили PostgreSQL самостоятельно, вам следует войти в систему для целей этого руководства под учетной записью пользователя, под которой вы запустили сервер. &lt;a href=&quot;#ftn.id-1.4.3.4.10.4&quot;&gt;&lt;sup id=&quot;id-1.4.3.4.10.4&quot;&gt;[1]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7dd5e10546306e9d83ef043283f9c8c8719bbf88" translate="yes" xml:space="preserve">
          <source>Not possible</source>
          <target state="translated">Невозможно</target>
        </trans-unit>
        <trans-unit id="14141efdb351648cd5997a4ec11511c9b9025f02" translate="yes" xml:space="preserve">
          <source>Not the password (always reads as &lt;code&gt;********&lt;/code&gt;)</source>
          <target state="translated">Не пароль (всегда читается как &lt;code&gt;********&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5b3582a3ba934510ccb693b77b7924863143d181" translate="yes" xml:space="preserve">
          <source>Notable differences between the existing POSIX-based regular-expression feature and XQuery regular expressions include:</source>
          <target state="translated">Заметные различия между существующей функцией регулярных выражений на основе POSIX и регулярными выражениями XQuery включают в себя:</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="9b3331f6b2637140f06fa920c5a275390198583a" translate="yes" xml:space="preserve">
          <source>Note also that if one is relying on explicit locking to prevent concurrent changes, one should either use Read Committed mode, or in Repeatable Read mode be careful to obtain locks before performing queries. A lock obtained by a repeatable read transaction guarantees that no other transactions modifying the table are still running, but if the snapshot seen by the transaction predates obtaining the lock, it might predate some now-committed changes in the table. A repeatable read transaction's snapshot is actually frozen at the start of its first query or data-modification command (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;), so it is possible to obtain locks explicitly before the snapshot is frozen.</source>
          <target state="translated">Также обратите внимание, что если кто-то полагается на явную блокировку для предотвращения одновременных изменений, следует либо использовать режим Read Committed, либо в режиме Repeatable Read будьте осторожны, чтобы получить блокировки перед выполнением запросов. Блокировка, полученная посредством повторяющейся транзакции чтения, гарантирует, что никакие другие транзакции, изменяющие таблицу, еще не выполняются, но если моментальный снимок, увиденный транзакцией, предшествует получению блокировки, он может предшествовать некоторым уже зафиксированным изменениям в таблице. Моментальный снимок повторяющейся транзакции чтения фактически замораживается в начале своего первого запроса или команды изменения данных ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; ), поэтому можно явно получить блокировки до того, как моментальный снимок будет заморожен.</target>
        </trans-unit>
        <trans-unit id="7593ffc9010adfe129fd98d3fee440d02e9a7b83" translate="yes" xml:space="preserve">
          <source>Note however that if multiple standby servers are restoring from the same archive directory, you will need to ensure that you do not delete WAL files until they are no longer needed by any of the servers. &lt;code&gt;archive_cleanup_command&lt;/code&gt; would typically be used in a warm-standby configuration (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command.</source>
          <target state="translated">Однако обратите внимание, что если несколько резервных серверов выполняют восстановление из одного и того же каталога архива, вам необходимо убедиться, что вы не удаляете файлы WAL до тех пор, пока они не перестанут быть нужны ни одному из серверов. &lt;code&gt;archive_cleanup_command&lt;/code&gt; обычно используется в конфигурации горячего резервирования (см. &lt;a href=&quot;warm-standby&quot;&gt;Раздел 26.2&lt;/a&gt; ). Напишите &lt;code&gt;%%&lt;/code&gt; , чтобы вставить в команду фактический символ &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9a98603977441f8554a2833afe694dbcfe6aeee" translate="yes" xml:space="preserve">
          <source>Note however that simple names are matched to column names before table names, so this example works only because there is no column named &lt;code&gt;c&lt;/code&gt; in the query's tables.</source>
          <target state="translated">Однако обратите внимание, что простые имена сопоставляются с именами столбцов перед именами таблиц, поэтому этот пример работает только потому, что в таблицах запроса нет столбца с именем &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90893364f9fe7dce948b26423ee4ecd2e88b2f16" translate="yes" xml:space="preserve">
          <source>Note however that you &lt;em&gt;cannot&lt;/em&gt; accomplish that effect with a command limited to a single schema. This command has no effect, unless it is undoing a matching &lt;code&gt;GRANT&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aef3a8d9770be0e69a039281f14778156239350" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;try all combinations&amp;rdquo; is not a realistic exercise. Usually password cracking is done with the help of dictionaries, which contain both regular words and various mutations of them. So, even somewhat word-like passwords could be cracked much faster than the above numbers suggest, while a 6-character non-word-like password may escape cracking. Or not.</source>
          <target state="translated">Обратите внимание, что &amp;laquo;испробовать все комбинации&amp;raquo; - нереальное упражнение. Обычно взлом паролей осуществляется с помощью словарей, которые содержат как обычные слова, так и различные их модификации. Таким образом, даже пароли, похожие на слова, могут быть взломаны намного быстрее, чем предполагают приведенные выше цифры, в то время как пароль из 6 символов, не похожий на слова, может не поддаваться взлому. Или не.</target>
        </trans-unit>
        <trans-unit id="00e6a4c57a18e5fbbf85ff612c2a3727ded13249" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;/etc/rc&lt;/code&gt; is usually overwritten by macOS system updates, so you should expect to have to redo these edits after each update.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;/etc/rc&lt;/code&gt; обычно перезаписывается обновлениями системы macOS, поэтому вам следует ожидать, что вам придется повторять эти изменения после каждого обновления.</target>
        </trans-unit>
        <trans-unit id="27a1cfa3bf0ee9c52c7a87330ba166c5fa86db79" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GREATEST&lt;/code&gt; and &lt;code&gt;LEAST&lt;/code&gt; are not in the SQL standard, but are a common extension. Some other databases make them return NULL if any argument is NULL, rather than only when all are NULL.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;GREATEST&lt;/code&gt; и &lt;code&gt;LEAST&lt;/code&gt; не входят в стандарт SQL, но являются общим расширением. Некоторые другие базы данных заставляют их возвращать NULL, если какой-либо аргумент равен NULL, а не только тогда, когда все они равны NULL.</target>
        </trans-unit>
        <trans-unit id="d1e87e3a532a3c85a5fb7cefcf86b5bd58f7519a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;INSERT&lt;/code&gt; with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; checks &lt;code&gt;INSERT&lt;/code&gt; policies' &lt;code&gt;WITH CHECK&lt;/code&gt; expressions only for rows appended to the relation by the &lt;code&gt;INSERT&lt;/code&gt; path.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;INSERT&lt;/code&gt; с &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; проверяет выражения &lt;code&gt;WITH CHECK&lt;/code&gt; политик &lt;code&gt;INSERT&lt;/code&gt; только для строк, добавленных к отношению по пути &lt;code&gt;INSERT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c319652e77f1cdd2df39e790f0f919f2b95a2486" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;amcheck&lt;/code&gt; examines a page as represented in some shared memory buffer at the time of verification if there is only a shared buffer hit when accessing the block. Consequently, &lt;code&gt;amcheck&lt;/code&gt; does not necessarily examine data read from the file system at the time of verification. Note that when checksums are enabled, &lt;code&gt;amcheck&lt;/code&gt; may raise an error due to a checksum failure when a corrupt block is read into a buffer.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;amcheck&lt;/code&gt; проверяет страницу в том виде, в котором она представлена ​​в некотором буфере разделяемой памяти, во время проверки, если при доступе к блоку имеется только попадание в общий буфер. Следовательно, &lt;code&gt;amcheck&lt;/code&gt; не обязательно проверяет данные, считанные из файловой системы во время проверки. Обратите внимание, что когда контрольные суммы включены, &lt;code&gt;amcheck&lt;/code&gt; может вызвать ошибку из-за сбоя контрольной суммы, когда поврежденный блок считывается в буфер.</target>
        </trans-unit>
        <trans-unit id="ef24e95dba1150cbef958d74c2f80a5630d7740c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;extract&lt;/code&gt;'s day of the week numbering differs from that of the &lt;code&gt;to_char(..., 'D')&lt;/code&gt; function.</source>
          <target state="translated">Обратите внимание, что нумерация дней недели в &lt;code&gt;extract&lt;/code&gt; отличается от нумерации функции &lt;code&gt;to_char(..., 'D')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="993b93174865d889f669c89fbc134d310b24fd79" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt; consider only the rows within the &amp;ldquo;window frame&amp;rdquo;, which by default contains the rows from the start of the partition through the last peer of the current row. This is likely to give unhelpful results for &lt;code&gt;last_value&lt;/code&gt; and sometimes also &lt;code&gt;nth_value&lt;/code&gt;. You can redefine the frame by adding a suitable frame specification (&lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt;) to the &lt;code&gt;OVER&lt;/code&gt; clause. See &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt; for more information about frame specifications.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;first_value&lt;/code&gt; , &lt;code&gt;last_value&lt;/code&gt; и &lt;code&gt;nth_value&lt;/code&gt; учитывают только строки в &amp;laquo;рамке окна&amp;raquo;, которая по умолчанию содержит строки от начала раздела до последнего однорангового узла текущей строки. Это может дать бесполезные результаты для &lt;code&gt;last_value&lt;/code&gt; , а иногда и для &lt;code&gt;nth_value&lt;/code&gt; . Вы можете переопределить фрейм, добавив подходящую спецификацию фрейма ( &lt;code&gt;RANGE&lt;/code&gt; , &lt;code&gt;ROWS&lt;/code&gt; или &lt;code&gt;GROUPS&lt;/code&gt; ) в предложение &lt;code&gt;OVER&lt;/code&gt; . См. &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Раздел 4.2.8&lt;/a&gt; для получения дополнительной информации о спецификациях рамы.</target>
        </trans-unit>
        <trans-unit id="e089463c04f2f8771502e8d62b431f3c71d88b7d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;m&lt;/code&gt; columns can also be moved out to secondary storage, but only as a last resort (&lt;code&gt;e&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; columns are moved first).</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;m&lt;/code&gt; столбцов также можно переместить во вторичное хранилище, но только в крайнем случае ( столбцы &lt;code&gt;e&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; перемещаются первыми).</target>
        </trans-unit>
        <trans-unit id="40331004e0ffed62ad250a770b0b797c5ac46ee7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;max_standby_archive_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply any one WAL segment's data. Thus, if one query has resulted in significant delay earlier in the WAL segment, subsequent conflicting queries will have much less grace time.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;max_standby_archive_delay&lt;/code&gt; не совпадает с максимальной продолжительностью времени, в течение которого запрос может выполняться до отмены; скорее это максимальное общее время, разрешенное для применения данных любого одного сегмента WAL. Таким образом, если один запрос привел к значительной задержке ранее в сегменте WAL, последующие конфликтующие запросы будут иметь гораздо меньшее время отсрочки.</target>
        </trans-unit>
        <trans-unit id="d4ea769871b3208ec9bdd68befff4d7903f7eff9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply WAL data once it has been received from the primary server. Thus, if one query has resulted in significant delay, subsequent conflicting queries will have much less grace time until the standby server has caught up again.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; не совпадает с максимальной продолжительностью времени, в течение которого запрос может выполняться до отмены; скорее, это максимальное общее время, разрешенное для применения данных WAL после их получения от первичного сервера. Таким образом, если один запрос привел к значительной задержке, последующие конфликтующие запросы будут иметь гораздо меньше времени отсрочки до тех пор, пока резервный сервер снова не догонит.</target>
        </trans-unit>
        <trans-unit id="d6596a8da6c53c8c974c373f17703e4e032c6d9e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;plainto_tsquery&lt;/code&gt; will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;plainto_tsquery&lt;/code&gt; не распознает операторы &lt;code&gt;tsquery&lt;/code&gt; , метки веса или метки соответствия префиксов во входных данных:</target>
        </trans-unit>
        <trans-unit id="531e2b77490742cd189acb5bc5e4276f0143a9de" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;postgres_fdw&lt;/code&gt; currently lacks support for &lt;code&gt;INSERT&lt;/code&gt; statements with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause. However, the &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; clause is supported, provided a unique index inference specification is omitted. Note also that &lt;code&gt;postgres_fdw&lt;/code&gt; supports row movement invoked by &lt;code&gt;UPDATE&lt;/code&gt; statements executed on partitioned tables, but it currently does not handle the case where a remote partition chosen to insert a moved row into is also an &lt;code&gt;UPDATE&lt;/code&gt; target partition that will be updated later.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;postgres_fdw&lt;/code&gt; в настоящее время не поддерживает &lt;code&gt;INSERT&lt;/code&gt; с предложением &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; . Однако предложение &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; поддерживается при условии, что не указана спецификация вывода уникального индекса. Также обратите внимание, что &lt;code&gt;postgres_fdw&lt;/code&gt; поддерживает перемещение строк, вызываемое операторами &lt;code&gt;UPDATE&lt;/code&gt; , выполняемыми в многораздельных таблицах, но в настоящее время он не обрабатывает случай, когда удаленный раздел, выбранный для вставки перемещенной строки, также является целевым разделом &lt;code&gt;UPDATE&lt;/code&gt; , который будет обновлен позже.</target>
        </trans-unit>
        <trans-unit id="9d0c357cbd644595d94bcf660fedeb383e698ab1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;to_tsquery&lt;/code&gt; will process prefixes in the same way as other words, which means this comparison returns true:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;to_tsquery&lt;/code&gt; будет обрабатывать префиксы так же, как и другие слова, что означает, что это сравнение возвращает true:</target>
        </trans-unit>
        <trans-unit id="547e51942705ea4910d562213bfd3cab3c67874d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;wal_receiver_timeout&lt;/code&gt;, &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; and &lt;code&gt;wal_retrieve_retry_interval&lt;/code&gt; configuration parameters affect the logical replication workers as well.</source>
          <target state="translated">Обратите внимание, что параметры конфигурации &lt;code&gt;wal_receiver_timeout&lt;/code&gt; , &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; и &lt;code&gt;wal_retrieve_retry_interval&lt;/code&gt; также влияют на работников логической репликации.</target>
        </trans-unit>
        <trans-unit id="e5c3c7860afae265b42af4a1e6e8bf5af951d1e2" translate="yes" xml:space="preserve">
          <source>Note that GIN index build time can often be improved by increasing &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;, while GiST index build time is not sensitive to that parameter.</source>
          <target state="translated">Обратите внимание, что время построения индекса GIN часто можно улучшить, увеличив &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; , в то время как время построения индекса GiST не зависит от этого параметра.</target>
        </trans-unit>
        <trans-unit id="4b8a5f57b365044d35823a4b451d18873918bc73" translate="yes" xml:space="preserve">
          <source>Note that XML forests are not valid XML documents if they consist of more than one element, so it might be useful to wrap &lt;code&gt;xmlforest&lt;/code&gt; expressions in &lt;code&gt;xmlelement&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что леса XML не являются допустимыми XML-документами, если они состоят из более чем одного элемента, поэтому может быть полезно &lt;code&gt;xmlforest&lt;/code&gt; выражения &lt;code&gt;xmlelement&lt;/code&gt; в xmlelement .</target>
        </trans-unit>
        <trans-unit id="41bc51ade685b6e9a9074785e60b9928bfbc83ce" translate="yes" xml:space="preserve">
          <source>Note that a file system backup will typically be larger than an SQL dump. (pg_dump does not need to dump the contents of indexes for example, just the commands to recreate them.) However, taking a file system backup might be faster.</source>
          <target state="translated">Обратите внимание,что резервное копирование файловой системы обычно больше,чем дамп SQL.(Например,pg_dump не нужно создавать дамп содержимого индексов,достаточно просто выполнить команды для их повторного создания).Однако резервное копирование файловой системы может быть сделано быстрее.</target>
        </trans-unit>
        <trans-unit id="4c32d659dad68b2cd17eab976deb46f2e6ed59ea" translate="yes" xml:space="preserve">
          <source>Note that a foreign table can be declared with fewer columns, or with a different column order, than its underlying remote table has. Matching of columns to the remote table is by name, not position.</source>
          <target state="translated">Обратите внимание,что посторонняя таблица может быть объявлена с меньшим количеством столбцов или с другим порядком столбцов,чем это есть у удаленной таблицы,лежащей в основе.Подгонка столбцов под удаленную таблицу осуществляется по имени,а не по позиции.</target>
        </trans-unit>
        <trans-unit id="c47a3a43d56fab6f7325c7aa20434bcba1bc9c0b" translate="yes" xml:space="preserve">
          <source>Note that all data types use rather obvious input formats. Constants that are not simple numeric values usually must be surrounded by single quotes (&lt;code&gt;'&lt;/code&gt;), as in the example. The &lt;code&gt;date&lt;/code&gt; type is actually quite flexible in what it accepts, but for this tutorial we will stick to the unambiguous format shown here.</source>
          <target state="translated">Обратите внимание, что все типы данных используют довольно очевидные форматы ввода. Константы, которые не являются простыми числовыми значениями, обычно должны быть заключены в одинарные кавычки ( &lt;code&gt;'&lt;/code&gt; ), как в примере. Тип &lt;code&gt;date&lt;/code&gt; самом деле довольно гибкий в том, что он принимает, но в этом уроке мы будем придерживаться однозначного формата, показанного здесь.</target>
        </trans-unit>
        <trans-unit id="25d42cd6ceef922ecf25e7b24fce40695e12cb56" translate="yes" xml:space="preserve">
          <source>Note that all other sessions will immediately be able to see the data once it has been successfully loaded. This violates the normal rules of MVCC visibility and users specifying should be aware of the potential problems this might cause.</source>
          <target state="translated">Обратите внимание,что все остальные сеансы сразу же смогут увидеть данные после их успешной загрузки.Это нарушает обычные правила видимости MVCC,и пользователи,указывающие их,должны знать о потенциальных проблемах,которые это может вызвать.</target>
        </trans-unit>
        <trans-unit id="df99d378fb51575b390c0b84d9d7987211c8c70b" translate="yes" xml:space="preserve">
          <source>Note that all the solutions described above take care of starting new log files at configurable intervals, but they do not handle deletion of old, no-longer-useful log files. You will probably want to set up a batch job to periodically delete old log files. Another possibility is to configure the rotation program so that old log files are overwritten cyclically.</source>
          <target state="translated">Обратите внимание,что все описанные выше решения заботятся о запуске новых лог-файлов с настраиваемыми интервалами,но они не обрабатывают удаление старых,бесполезных лог-файлов.Скорее всего,вы захотите настроить пакетное задание на периодическое удаление старых лог-файлов.Другая возможность-настроить программу ротации таким образом,чтобы старые лог-файлы перезаписывались циклически.</target>
        </trans-unit>
        <trans-unit id="2c87d02f3e8f6257698af02e373aea3121b7dc2e" translate="yes" xml:space="preserve">
          <source>Note that although WAL archiving will allow you to restore any modifications made to the data in your PostgreSQL database, it will not restore changes made to configuration files (that is, &lt;code&gt;postgresql.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt; and &lt;code&gt;pg_ident.conf&lt;/code&gt;), since those are edited manually rather than through SQL operations. You might wish to keep the configuration files in a location that will be backed up by your regular file system backup procedures. See &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt; for how to relocate the configuration files.</source>
          <target state="translated">Обратите внимание, что хотя архивирование WAL позволяет вам восстановить любые изменения, внесенные в данные в вашей базе данных PostgreSQL, оно не будет восстанавливать изменения, внесенные в файлы конфигурации (то есть &lt;code&gt;postgresql.conf&lt;/code&gt; , &lt;code&gt;pg_hba.conf&lt;/code&gt; и &lt;code&gt;pg_ident.conf&lt;/code&gt; ), поскольку они редактируется вручную, а не с помощью операций SQL. Возможно, вы захотите сохранить файлы конфигурации в месте, для которого будут созданы резервные копии с помощью обычных процедур резервного копирования файловой системы. См. &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Раздел 19.2,&lt;/a&gt; чтобы узнать, как переместить файлы конфигурации.</target>
        </trans-unit>
        <trans-unit id="d53090021f825a89df9ea9e9d71eae604c7c4a95" translate="yes" xml:space="preserve">
          <source>Note that an &lt;code&gt;AS&lt;/code&gt; clause is required when &lt;code&gt;VALUES&lt;/code&gt; is used in a &lt;code&gt;FROM&lt;/code&gt; clause, just as is true for &lt;code&gt;SELECT&lt;/code&gt;. It is not required that the &lt;code&gt;AS&lt;/code&gt; clause specify names for all the columns, but it's good practice to do so. (The default column names for &lt;code&gt;VALUES&lt;/code&gt; are &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc in PostgreSQL, but these names might be different in other database systems.)</source>
          <target state="translated">Обратите внимание, что предложение &lt;code&gt;AS&lt;/code&gt; требуется, когда &lt;code&gt;VALUES&lt;/code&gt; используется в предложении &lt;code&gt;FROM&lt;/code&gt; , как и для &lt;code&gt;SELECT&lt;/code&gt; . Не требуется, чтобы в предложении &lt;code&gt;AS&lt;/code&gt; указывались имена для всех столбцов, но это рекомендуется. (Имена столбцов по умолчанию для &lt;code&gt;VALUES&lt;/code&gt; - &lt;code&gt;column1&lt;/code&gt; , &lt;code&gt;column2&lt;/code&gt; и т. Д. В PostgreSQL, но эти имена могут отличаться в других системах баз данных.)</target>
        </trans-unit>
        <trans-unit id="2b4af4e58c7c07f18643d7fac4e1368ce1d5e583" translate="yes" xml:space="preserve">
          <source>Note that any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Thus, for example, revoking &lt;code&gt;SELECT&lt;/code&gt; privilege from &lt;code&gt;PUBLIC&lt;/code&gt; does not necessarily mean that all roles have lost &lt;code&gt;SELECT&lt;/code&gt; privilege on the object: those who have it granted directly or via another role will still have it. Similarly, revoking &lt;code&gt;SELECT&lt;/code&gt; from a user might not prevent that user from using &lt;code&gt;SELECT&lt;/code&gt; if &lt;code&gt;PUBLIC&lt;/code&gt; or another membership role still has &lt;code&gt;SELECT&lt;/code&gt; rights.</source>
          <target state="translated">Обратите внимание, что любая конкретная роль будет иметь сумму привилегий, предоставленных ей непосредственно, привилегий, предоставленных любой роли, членом которой она в настоящее время является, и привилегий, предоставленных &lt;code&gt;PUBLIC&lt;/code&gt; . Таким образом, например, отмена привилегии &lt;code&gt;SELECT&lt;/code&gt; у &lt;code&gt;PUBLIC&lt;/code&gt; не обязательно означает, что все роли потеряли привилегию &lt;code&gt;SELECT&lt;/code&gt; для объекта: те, кому она была предоставлена ​​напрямую или через другую роль, все равно будут иметь ее. Точно так же отмена &lt;code&gt;SELECT&lt;/code&gt; у пользователя может не помешать этому пользователю использовать &lt;code&gt;SELECT&lt;/code&gt; , если &lt;code&gt;PUBLIC&lt;/code&gt; или другая роль членства все еще имеет права &lt;code&gt;SELECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fd76787f2a53ba7fb758f8a964cdd22772c1d78" translate="yes" xml:space="preserve">
          <source>Note that because &lt;code&gt;recovery.signal&lt;/code&gt; will not be removed when &lt;code&gt;recovery_target_action&lt;/code&gt; is set to &lt;code&gt;shutdown&lt;/code&gt;, any subsequent start will end with immediate shutdown unless the configuration is changed or the &lt;code&gt;recovery.signal&lt;/code&gt; file is removed manually.</source>
          <target state="translated">Обратите внимание: поскольку &lt;code&gt;recovery.signal&lt;/code&gt; не будет удален, если для &lt;code&gt;recovery_target_action&lt;/code&gt; установлено значение &lt;code&gt;shutdown&lt;/code&gt; , любой последующий запуск завершится немедленным завершением работы, если только конфигурация не будет изменена или файл &lt;code&gt;recovery.signal&lt;/code&gt; не будет удален вручную.</target>
        </trans-unit>
        <trans-unit id="9c33fcc287f27c5bc2a2b32d53b1b513b1091d88" translate="yes" xml:space="preserve">
          <source>Note that casting to just &amp;ldquo;bit&amp;rdquo; means casting to &lt;code&gt;bit(1)&lt;/code&gt;, and so will deliver only the least significant bit of the integer.</source>
          <target state="translated">Обратите внимание, что преобразование только в &amp;laquo;бит&amp;raquo; означает преобразование в &lt;code&gt;bit(1)&lt;/code&gt; , поэтому будет доставлен только младший значащий бит целого числа.</target>
        </trans-unit>
        <trans-unit id="fd0a0fb6f9e97d5efee795fd874b77207c725a32" translate="yes" xml:space="preserve">
          <source>Note that collecting the additional timing information needed for per-statement latency computation adds some overhead. This will slow average execution speed and lower the computed TPS. The amount of slowdown varies significantly depending on platform and hardware. Comparing average TPS values with and without latency reporting enabled is a good way to measure if the timing overhead is significant.</source>
          <target state="translated">Обратите внимание,что сбор дополнительной временной информации,необходимой для расчета латентности в расчете на одно выражение,добавляет некоторые накладные расходы.Это замедлит среднюю скорость выполнения и снизит вычисленную TPS.Степень замедления значительно варьируется в зависимости от платформы и аппаратного обеспечения.Сравнение средних значений TPS с включенной отчетностью о задержках и без нее является хорошим способом измерения того,насколько существенны накладные расходы на синхронизацию.</target>
        </trans-unit>
        <trans-unit id="46048f7966588bd79b584545411fe217e62e0e87" translate="yes" xml:space="preserve">
          <source>Note that constraints other than &lt;code&gt;NOT NULL&lt;/code&gt; will never be imported from the remote tables. Although PostgreSQL does support &lt;code&gt;CHECK&lt;/code&gt; constraints on foreign tables, there is no provision for importing them automatically, because of the risk that a constraint expression could evaluate differently on the local and remote servers. Any such inconsistency in the behavior of a &lt;code&gt;CHECK&lt;/code&gt; constraint could lead to hard-to-detect errors in query optimization. So if you wish to import &lt;code&gt;CHECK&lt;/code&gt; constraints, you must do so manually, and you should verify the semantics of each one carefully. For more detail about the treatment of &lt;code&gt;CHECK&lt;/code&gt; constraints on foreign tables, see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что ограничения, отличные от &lt;code&gt;NOT NULL&lt;/code&gt; , никогда не будут импортированы из удаленных таблиц. Хотя PostgreSQL поддерживает ограничения &lt;code&gt;CHECK&lt;/code&gt; для сторонних таблиц, их автоматический импорт не предусмотрен из-за риска того, что выражение ограничения может оцениваться по-разному на локальном и удаленном серверах. Любая такая несогласованность в поведении ограничения &lt;code&gt;CHECK&lt;/code&gt; может привести к трудно обнаруживаемым ошибкам при оптимизации запроса. Поэтому, если вы хотите импортировать ограничения &lt;code&gt;CHECK&lt;/code&gt; , вы должны сделать это вручную и тщательно проверить семантику каждого из них. Дополнительные сведения об обработке ограничений &lt;code&gt;CHECK&lt;/code&gt; для сторонних таблиц см. В разделе &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="699164176c152ba6b84d675ad75f5ace743cae19" translate="yes" xml:space="preserve">
          <source>Note that cost estimate functions must be written in C, not in SQL or any available procedural language, because they must access internal data structures of the planner/optimizer.</source>
          <target state="translated">Отметим,что функции оценки стоимости должны быть написаны на C,а не на SQL или любом доступном процедурном языке,так как они должны иметь доступ к внутренним структурам данных планировщика/оптимизатора.</target>
        </trans-unit>
        <trans-unit id="06d4a3361a37979804bf5a58a39eb486b3f91ba2" translate="yes" xml:space="preserve">
          <source>Note that deadlocks can also occur as the result of row-level locks (and thus, they can occur even if explicit locking is not used). Consider the case in which two concurrent transactions modify a table. The first transaction executes:</source>
          <target state="translated">Обратите внимание,что тупиковые ситуации могут возникать и в результате блокировок на уровне рядов (и,таким образом,они могут возникать даже в том случае,если явная блокировка не используется).Рассмотрим случай,когда две параллельные транзакции изменяют таблицу.Выполняется первая транзакция:</target>
        </trans-unit>
        <trans-unit id="6082e5afeea05f3f2e208c50995f15f349743dca" translate="yes" xml:space="preserve">
          <source>Note that deduplication is deemed unsafe and cannot be used in the following cases involving semantically significant differences among equal datums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8001d46d3d20b93246bb06a2398e61902d0e24f2" translate="yes" xml:space="preserve">
          <source>Note that different keys may have the same ID. This is rare but a normal event. The client application should then try to decrypt with each one, to see which fits &amp;mdash; like handling &lt;code&gt;ANYKEY&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что разные ключи могут иметь одинаковый идентификатор. Это редкое, но нормальное явление. Затем клиентское приложение должно попытаться расшифровать каждый из них, чтобы увидеть, что подходит - например, обработка &lt;code&gt;ANYKEY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d9652ff899a1fe6db38db0e7bf8d1018609b472" translate="yes" xml:space="preserve">
          <source>Note that different units are used for the per loop time than the histogram. The loop can have resolution within a few nanoseconds (ns), while the individual timing calls can only resolve down to one microsecond (us).</source>
          <target state="translated">Обратите внимание,что для времени цикла используются другие единицы измерения,чем для гистограммы.Петля может иметь разрешение в пределах нескольких наносекунд (нс),в то время как индивидуальные звонки по времени могут разрешаться только до одной микросекунды (нас).</target>
        </trans-unit>
        <trans-unit id="8463fb9b10613a7f093421dc720a6dd930e1df32" translate="yes" xml:space="preserve">
          <source>Note that enabling or disabling group access on an existing cluster requires the cluster to be shut down and the appropriate mode to be set on all directories and files before restarting PostgreSQL. Otherwise, a mix of modes might exist in the data directory. For clusters that allow access only by the owner, the appropriate modes are &lt;code&gt;0700&lt;/code&gt; for directories and &lt;code&gt;0600&lt;/code&gt; for files. For clusters that also allow reads by the group, the appropriate modes are &lt;code&gt;0750&lt;/code&gt; for directories and &lt;code&gt;0640&lt;/code&gt; for files.</source>
          <target state="translated">Обратите внимание, что включение или отключение группового доступа в существующем кластере требует, чтобы кластер был выключен и перед перезапуском PostgreSQL был установлен соответствующий режим для всех каталогов и файлов. В противном случае в каталоге данных может существовать сочетание режимов. Для кластеров, которые разрешают доступ только владельцу, подходящие режимы: &lt;code&gt;0700&lt;/code&gt; для каталогов и &lt;code&gt;0600&lt;/code&gt; для файлов. Для кластеров, которые также разрешают чтение для группы, подходящие режимы - &lt;code&gt;0750&lt;/code&gt; для каталогов и &lt;code&gt;0640&lt;/code&gt; для файлов.</target>
        </trans-unit>
        <trans-unit id="836bf1d98935001a9e7ffe81c54955b795aef94c" translate="yes" xml:space="preserve">
          <source>Note that even when this parameter is disabled, the system will launch autovacuum processes if necessary to prevent transaction ID wraparound. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt; for more information.</source>
          <target state="translated">Обратите внимание, что даже если этот параметр отключен, система будет запускать процессы автоочистки, если необходимо, чтобы предотвратить перенос идентификатора транзакции. См. &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Раздел 24.1.5&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7f1ea5bec1703e5249cd8348fa7e3e07222422cf" translate="yes" xml:space="preserve">
          <source>Note that exclusion constraints are not supported as arbiters with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;. In all cases, only &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; constraints and unique indexes are supported as arbiters.</source>
          <target state="translated">Обратите внимание, что ограничения исключения не поддерживаются в качестве арбитров с &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; . Во всех случаях в качестве арбитров поддерживаются только ограничения &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; и уникальные индексы.</target>
        </trans-unit>
        <trans-unit id="8de881cb4486af9a5996e8f814cf056ae7026e35" translate="yes" xml:space="preserve">
          <source>Note that for constraint triggers, evaluation of the &lt;code&gt;WHEN&lt;/code&gt; condition is not deferred, but occurs immediately after the row update operation is performed. If the condition does not evaluate to true then the trigger is not queued for deferred execution.</source>
          <target state="translated">Обратите внимание, что для триггеров ограничений оценка условия &lt;code&gt;WHEN&lt;/code&gt; не откладывается, а происходит сразу после выполнения операции обновления строки. Если условие не истинно, то триггер не ставится в очередь для отложенного выполнения.</target>
        </trans-unit>
        <trans-unit id="0be6e3fd01fb4ed50e92212c3560099998e4c687" translate="yes" xml:space="preserve">
          <source>Note that for historic reasons, the function &lt;code&gt;md5&lt;/code&gt; returns a hex-encoded value of type &lt;code&gt;text&lt;/code&gt; whereas the SHA-2 functions return type &lt;code&gt;bytea&lt;/code&gt;. Use the functions &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; to convert between the two, for example &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; to get a hex-encoded text representation.</source>
          <target state="translated">Обратите внимание, что по историческим причинам функция &lt;code&gt;md5&lt;/code&gt; возвращает значение типа &lt;code&gt;text&lt;/code&gt; в шестнадцатеричной кодировке, тогда как функции SHA-2 возвращают тип &lt;code&gt;bytea&lt;/code&gt; . Используйте функции &lt;code&gt;encode&lt;/code&gt; и &lt;code&gt;decode&lt;/code&gt; для преобразования между ними, например &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; чтобы получить текстовое представление в шестнадцатеричной кодировке.</target>
        </trans-unit>
        <trans-unit id="cfe04c8846d33d71c984b2b6f7148e6d08053137" translate="yes" xml:space="preserve">
          <source>Note that foreign tables that use a foreign-data wrapper with no handler cannot be accessed.</source>
          <target state="translated">Обратите внимание,что невозможно получить доступ к посторонним таблицам,использующим обертку с посторонними данными без обработчика.</target>
        </trans-unit>
        <trans-unit id="02035a3862ae6605e031adf46021fcd89539c880" translate="yes" xml:space="preserve">
          <source>Note that granting users the EXECUTE privilege on &lt;code&gt;pg_read_file()&lt;/code&gt;, or related functions, allows them the ability to read any file on the server that the database server process can read; these functions bypass all in-database privilege checks. This means that, for example, a user with such access is able to read the contents of the &lt;code&gt;pg_authid&lt;/code&gt; table where authentication information is stored, as well as read any table data in the database. Therefore, granting access to these functions should be carefully considered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5453a69c6ad7e7ddfed4130bdc5747df6c5fd62b" translate="yes" xml:space="preserve">
          <source>Note that granting users the EXECUTE privilege on &lt;code&gt;pg_read_file()&lt;/code&gt;, or related functions, allows them the ability to read any file on the server which the database can read and that those reads bypass all in-database privilege checks. This means that, among other things, a user with this access is able to read the contents of the &lt;code&gt;pg_authid&lt;/code&gt; table where authentication information is contained, as well as read any file in the database. Therefore, granting access to these functions should be carefully considered.</source>
          <target state="translated">Обратите внимание, что предоставление пользователям привилегии EXECUTE для &lt;code&gt;pg_read_file()&lt;/code&gt; или связанных функций позволяет им читать любой файл на сервере, который может читать база данных, и что эти чтения обходят все проверки привилегий в базе данных. Это означает, что, помимо прочего, пользователь с таким доступом может читать содержимое таблицы &lt;code&gt;pg_authid&lt;/code&gt; ,в которой содержится информация для аутентификации, а также читать любой файл в базе данных. Поэтому следует тщательно продумать предоставление доступа к этим функциям.</target>
        </trans-unit>
        <trans-unit id="fd90b8fb5e3c2266322a8f9361a13beecb2d12fc" translate="yes" xml:space="preserve">
          <source>Note that here the &lt;code&gt;field&lt;/code&gt; parameter needs to be a string value, not a name. The valid field names for &lt;code&gt;date_part&lt;/code&gt; are the same as for &lt;code&gt;extract&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что здесь параметр &lt;code&gt;field&lt;/code&gt; должен быть строковым значением, а не именем. Допустимые имена полей для &lt;code&gt;date_part&lt;/code&gt; такие же, как и для &lt;code&gt;extract&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13c19c7fbcb3e2d4787b53bfa2ce9ac2e3e6f680" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;MINVALUE&lt;/code&gt; or &lt;code&gt;MAXVALUE&lt;/code&gt; is used for one column of a partitioning bound, the same value must be used for all subsequent columns. For example, &lt;code&gt;(10, MINVALUE, 0)&lt;/code&gt; is not a valid bound; you should write &lt;code&gt;(10, MINVALUE, MINVALUE)&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;MINVALUE&lt;/code&gt; или &lt;code&gt;MAXVALUE&lt;/code&gt; используется для одного столбца границы разделения, то же значение должно использоваться для всех последующих столбцов. Например, &lt;code&gt;(10, MINVALUE, 0)&lt;/code&gt; не является допустимой границей; вы должны написать &lt;code&gt;(10, MINVALUE, MINVALUE)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba56c2e43467332103da0c13e1894f6a417084e8" translate="yes" xml:space="preserve">
          <source>Note that if a &lt;code&gt;FROM&lt;/code&gt; clause is not specified, the query cannot reference any database tables. For example, the following query is invalid:</source>
          <target state="translated">Обратите внимание: если предложение &lt;code&gt;FROM&lt;/code&gt; не указано, запрос не может ссылаться ни на какие таблицы базы данных. Например, следующий запрос недействителен:</target>
        </trans-unit>
        <trans-unit id="90a3cd6b9233790897980d2c49eb8226596f6f8e" translate="yes" xml:space="preserve">
          <source>Note that if both &lt;code&gt;fields&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are specified, the &lt;code&gt;fields&lt;/code&gt; must include &lt;code&gt;SECOND&lt;/code&gt;, since the precision applies only to the seconds.</source>
          <target state="translated">Обратите внимание, что если указаны оба &lt;code&gt;fields&lt;/code&gt; и &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;fields&lt;/code&gt; должны включать &lt;code&gt;SECOND&lt;/code&gt; , поскольку точность применяется только к секундам.</target>
        </trans-unit>
        <trans-unit id="1ee74a393ded0f5a9715105cabc63616fc14f639" translate="yes" xml:space="preserve">
          <source>Note that if extra WAL files which are not required to recover the backup are present, they will not be checked by this tool, although a separate invocation of &lt;code&gt;pg_waldump&lt;/code&gt; could be used for that purpose. Also note that WAL verification is version-specific: you must use the version of &lt;code&gt;pg_verifybackup&lt;/code&gt;, and thus of &lt;code&gt;pg_waldump&lt;/code&gt;, which pertains to the backup being checked. In contrast, the data file integrity checks should work with any version of the server that generates a &lt;code&gt;backup_manifest&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a560da48a0c3eebe2ee9e445e8f80b7a7c072449" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand expression yields null, the result of the &lt;code&gt;IN&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">Обратите внимание, что если левое выражение дает null или если нет равных правых значений и хотя бы одно правое выражение дает null, результатом конструкции &lt;code&gt;IN&lt;/code&gt; будет null, а не false. Это соответствует обычным правилам SQL для логических комбинаций нулевых значений.</target>
        </trans-unit>
        <trans-unit id="0c5f4c3fbdd65353e1a71d55f99ee8748d4b0fa1" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand expression yields null, the result of the &lt;code&gt;NOT IN&lt;/code&gt; construct will be null, not true as one might naively expect. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">Обратите внимание, что если левое выражение дает ноль или если нет равных правых значений и по крайней мере одно правое выражение дает ноль, результатом конструкции &lt;code&gt;NOT IN&lt;/code&gt; будет NULL, а не истина, как можно было бы наивно ожидать. . Это соответствует обычным правилам SQL для логических комбинаций нулевых значений.</target>
        </trans-unit>
        <trans-unit id="3770b570045d24672e81b92be3b78c98e0908b47" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the &lt;code&gt;IN&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">Обратите внимание, что если левое выражение дает ноль или если нет равных правых значений и хотя бы одна правая строка дает ноль, результатом конструкции &lt;code&gt;IN&lt;/code&gt; будет ноль, а не ложь. Это соответствует обычным правилам SQL для логических комбинаций нулевых значений.</target>
        </trans-unit>
        <trans-unit id="95d9a10f36eb36219f7c3566abef0868c3a7a8f8" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the &lt;code&gt;NOT IN&lt;/code&gt; construct will be null, not true. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">Обратите внимание, что если левое выражение дает ноль или если нет равных правых значений и хотя бы одна правая строка дает ноль, результатом конструкции &lt;code&gt;NOT IN&lt;/code&gt; будет NULL, а не истина. Это соответствует обычным правилам SQL для логических комбинаций нулевых значений.</target>
        </trans-unit>
        <trans-unit id="b5695d0e24822e1a46463dd2f7c72886d58ca728" translate="yes" xml:space="preserve">
          <source>Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the &lt;code&gt;ANY&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">Обратите внимание, что если успехов нет и хотя бы одна правая строка дает нулевое значение для результата оператора, результат конструкции &lt;code&gt;ANY&lt;/code&gt; будет нулевым, а не ложным. Это соответствует обычным правилам SQL для логических комбинаций нулевых значений.</target>
        </trans-unit>
        <trans-unit id="f74d4f9409b75f18ec02eb7363768188eed257dd" translate="yes" xml:space="preserve">
          <source>Note that if you use this option currently, you probably also want the dump be in &lt;code&gt;INSERT&lt;/code&gt; format, as the &lt;code&gt;COPY FROM&lt;/code&gt; during restore does not support row security.</source>
          <target state="translated">Обратите внимание, что если вы используете этот параметр в настоящее время, вы, вероятно, также хотите, чтобы дамп был в формате &lt;code&gt;INSERT&lt;/code&gt; , поскольку &lt;code&gt;COPY FROM&lt;/code&gt; во время восстановления не поддерживает защиту строк.</target>
        </trans-unit>
        <trans-unit id="76b5be5ae69de8a00f81a37774ba0bddbcd592c1" translate="yes" xml:space="preserve">
          <source>Note that in a standard-conforming string literal, &lt;code&gt;\&lt;/code&gt; just means &lt;code&gt;\&lt;/code&gt; anyway. This parameter only affects the handling of non-standard-conforming literals, including escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание , что в стандартном соответствующих требованиях строкового литерала, &lt;code&gt;\&lt;/code&gt; просто означает &lt;code&gt;\&lt;/code&gt; в любом случае. Этот параметр влияет только на обработку нестандартных литералов, включая синтаксис escape-строки ( &lt;code&gt;E'...'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="23bc72830133f60c02bed8bfbe946fd178dc8663" translate="yes" xml:space="preserve">
          <source>Note that in some macOS versions, &lt;em&gt;all five&lt;/em&gt; shared-memory parameters must be set in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, else the values will be ignored.</source>
          <target state="translated">Обратите внимание, что в некоторых версиях macOS &lt;em&gt;все пять параметров&lt;/em&gt; общей памяти должны быть установлены в &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; , иначе значения будут игнорироваться.</target>
        </trans-unit>
        <trans-unit id="7d63d2dbef5cb198e7018e15f160e61a7a98bae4" translate="yes" xml:space="preserve">
          <source>Note that in the latter case the &lt;code&gt;COLLATE&lt;/code&gt; clause is attached to an input argument of the operator we wish to affect. It doesn't matter which argument of the operator or function call the &lt;code&gt;COLLATE&lt;/code&gt; clause is attached to, because the collation that is applied by the operator or function is derived by considering all arguments, and an explicit &lt;code&gt;COLLATE&lt;/code&gt; clause will override the collations of all other arguments. (Attaching non-matching &lt;code&gt;COLLATE&lt;/code&gt; clauses to more than one argument, however, is an error. For more details see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.) Thus, this gives the same result as the previous example:</source>
          <target state="translated">Обратите внимание, что в последнем случае предложение &lt;code&gt;COLLATE&lt;/code&gt; присоединяется к входному аргументу оператора, на который мы хотим воздействовать. Не имеет значения, к какому аргументу вызова оператора или функции присоединено предложение &lt;code&gt;COLLATE&lt;/code&gt; , потому что сопоставление, применяемое оператором или функцией, выводится с учетом всех аргументов, а явное предложение &lt;code&gt;COLLATE&lt;/code&gt; переопределит сопоставления всех остальных аргументы. (Однако присоединение несовпадающих предложений &lt;code&gt;COLLATE&lt;/code&gt; к более чем одному аргументу является ошибкой. Подробнее см. &lt;a href=&quot;collation&quot;&gt;Раздел 23.2&lt;/a&gt; .) Таким образом, это дает тот же результат, что и в предыдущем примере:</target>
        </trans-unit>
        <trans-unit id="a84d7bddb80d9016bd6c4bee8fb7ca51415943a4" translate="yes" xml:space="preserve">
          <source>Note that in this mode, the server will apply WAL one file at a time, so if you use the standby server for queries (see Hot Standby), there is a delay between an action in the master and when the action becomes visible in the standby, corresponding the time it takes to fill up the WAL file. &lt;code&gt;archive_timeout&lt;/code&gt; can be used to make that delay shorter. Also note that you can't combine streaming replication with this method.</source>
          <target state="translated">Обратите внимание, что в этом режиме сервер будет применять WAL по одному файлу за раз, поэтому, если вы используете резервный сервер для запросов (см. Горячий резерв), существует задержка между действием на главном сервере и тем, когда действие становится видимым в ожидания, что соответствует времени, необходимому для заполнения файла WAL. &lt;code&gt;archive_timeout&lt;/code&gt; можно использовать, чтобы сократить эту задержку. Также обратите внимание, что вы не можете комбинировать потоковую репликацию с этим методом.</target>
        </trans-unit>
        <trans-unit id="8a1638c843cb47802240a66e163419411cf8f8a8" translate="yes" xml:space="preserve">
          <source>Note that in this mode, the server will apply WAL one file at a time, so if you use the standby server for queries (see Hot Standby), there is a delay between an action in the master and when the action becomes visible in the standby, corresponding to the time it takes to fill up the WAL file. &lt;code&gt;archive_timeout&lt;/code&gt; can be used to make that delay shorter. Also note that you can't combine streaming replication with this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4405d800f3ae0d5fa272786ae62fc932fc40328" translate="yes" xml:space="preserve">
          <source>Note that in this syntax, &lt;code&gt;BINARY&lt;/code&gt; and &lt;code&gt;CSV&lt;/code&gt; are treated as independent keywords, not as arguments of a &lt;code&gt;FORMAT&lt;/code&gt; option.</source>
          <target state="translated">Обратите внимание, что в этом синтаксисе &lt;code&gt;BINARY&lt;/code&gt; и &lt;code&gt;CSV&lt;/code&gt; обрабатываются как независимые ключевые слова, а не как аргументы опции &lt;code&gt;FORMAT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a52e8eceb78cffa4749cb6c0e0ac81c842683dee" translate="yes" xml:space="preserve">
          <source>Note that it is currently not supported by &lt;code&gt;postgres_fdw&lt;/code&gt; to prepare the remote transaction for two-phase commit.</source>
          <target state="translated">Обратите внимание, что в настоящее время &lt;code&gt;postgres_fdw&lt;/code&gt; не поддерживает подготовку удаленной транзакции к двухфазной фиксации.</target>
        </trans-unit>
        <trans-unit id="5bf276b552e113c8aa30767266df52ef9cf60275" translate="yes" xml:space="preserve">
          <source>Note that it is currently not supported for the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause of an &lt;code&gt;INSERT&lt;/code&gt; applied to a partitioned table to update the partition key of a conflicting row such that it requires the row be moved to a new partition.</source>
          <target state="translated">Обратите внимание, что в настоящее время он не поддерживается для предложения &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; в &lt;code&gt;INSERT&lt;/code&gt; , применяемом к многораздельной таблице для обновления ключа раздела конфликтующей строки, так что для этого требуется, чтобы строка была перемещена в новый раздел.</target>
        </trans-unit>
        <trans-unit id="1def70c0867779a85dc5cf9834ec9df5745ab872" translate="yes" xml:space="preserve">
          <source>Note that it is entirely up to the access method to ensure that it correctly finds all and only the entries passing all the given scan keys. Also, the core system will simply hand off all the &lt;code&gt;WHERE&lt;/code&gt; clauses that match the index keys and operator families, without any semantic analysis to determine whether they are redundant or contradictory. As an example, given &lt;code&gt;WHERE x &amp;gt; 4 AND x &amp;gt; 14&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a b-tree indexed column, it is left to the b-tree &lt;code&gt;amrescan&lt;/code&gt; function to realize that the first scan key is redundant and can be discarded. The extent of preprocessing needed during &lt;code&gt;amrescan&lt;/code&gt; will depend on the extent to which the index access method needs to reduce the scan keys to a &amp;ldquo;normalized&amp;rdquo; form.</source>
          <target state="translated">Обратите внимание, что это полностью зависит от метода доступа, чтобы убедиться, что он правильно находит все и только записи, передающие все заданные ключи сканирования. Кроме того, базовая система просто передает все &lt;code&gt;WHERE&lt;/code&gt; , соответствующие ключам индекса и семействам операторов, без какого-либо семантического анализа, чтобы определить, являются ли они избыточными или противоречивыми. В качестве примера, учитывая &lt;code&gt;WHERE x &amp;gt; 4 AND x &amp;gt; 14&lt;/code&gt; где &lt;code&gt;x&lt;/code&gt; - индексированный столбец b-дерева, функции &lt;code&gt;amrescan&lt;/code&gt; b-дерева остается понять, что первый ключ сканирования является избыточным и может быть отброшен. Степень предварительной обработки, необходимой во время &lt;code&gt;amrescan&lt;/code&gt; , будет зависеть от степени, в которой метод доступа к индексу должен привести ключи сканирования к &amp;laquo;нормализованной&amp;raquo; форме.</target>
        </trans-unit>
        <trans-unit id="873ebf4f2aa65167f1962a321c4caa0aa6923fed" translate="yes" xml:space="preserve">
          <source>Note that it is permitted for an access method to implement only &lt;code&gt;amgetbitmap&lt;/code&gt; and not &lt;code&gt;amgettuple&lt;/code&gt;, or vice versa, if its internal implementation is unsuited to one API or the other.</source>
          <target state="translated">Обратите внимание, что для метода доступа разрешено реализовывать только &lt;code&gt;amgetbitmap&lt;/code&gt; , а не &lt;code&gt;amgettuple&lt;/code&gt; , или наоборот, если его внутренняя реализация не подходит для одного или другого API.</target>
        </trans-unit>
        <trans-unit id="0eac953a1d1c9a171b24393d7da1daab96fde8aa" translate="yes" xml:space="preserve">
          <source>Note that it is possible that pre-existing options of the foreign-data wrapper, or of dependent servers, user mappings, or foreign tables, are invalid according to the new validator. PostgreSQL does not check for this. It is up to the user to make sure that these options are correct before using the modified foreign-data wrapper. However, any options specified in this &lt;code&gt;ALTER FOREIGN DATA WRAPPER&lt;/code&gt; command will be checked using the new validator.</source>
          <target state="translated">Обратите внимание: возможно, что ранее существовавшие параметры оболочки сторонних данных или зависимых серверов, сопоставлений пользователей или сторонних таблиц недействительны в соответствии с новым средством проверки. PostgreSQL не проверяет это. Пользователь должен убедиться, что эти параметры верны, прежде чем использовать измененную оболочку сторонних данных. Однако любые параметры, указанные в этой команде &lt;code&gt;ALTER FOREIGN DATA WRAPPER&lt;/code&gt; , будут проверяться с помощью нового валидатора.</target>
        </trans-unit>
        <trans-unit id="54f1f1ea0bfe92e9a92461b1d9eddd8c8bc5388c" translate="yes" xml:space="preserve">
          <source>Note that it is possible to create array values containing null values even when this variable is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что можно создавать значения массива, содержащие нулевые значения, даже если эта переменная &lt;code&gt;off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e482ec43ca141e91073df95564c36e7944046093" translate="yes" xml:space="preserve">
          <source>Note that it would not make much sense to test a non-schema-qualified type name in this way &amp;mdash; if the name can be recognized at all, it must be visible.</source>
          <target state="translated">Обратите внимание, что не имеет большого смысла тестировать таким образом имя типа, не уточненное схемой - если имя вообще можно распознать, оно должно быть видимым.</target>
        </trans-unit>
        <trans-unit id="1aef4a22f764ee40b1bcb8140980923ce0f949fc" translate="yes" xml:space="preserve">
          <source>Note that it's quite possible for two objects to be linked by more than one &lt;code&gt;pg_depend&lt;/code&gt; entry. For example, a child partitioned index would have both a partition-type dependency on its associated partition table, and an auto dependency on each column of that table that it indexes. This sort of situation expresses the union of multiple dependency semantics. A dependent object can be dropped without &lt;code&gt;CASCADE&lt;/code&gt; if any of its dependencies satisfies its condition for automatic dropping. Conversely, all the dependencies' restrictions about which objects must be dropped together must be satisfied.</source>
          <target state="translated">Обратите внимание, что два объекта вполне могут быть связаны более чем одной &lt;code&gt;pg_depend&lt;/code&gt; . Например, дочерний многораздельный индекс будет иметь как зависимость типа раздела от связанной с ним таблицы разделов, так и автоматическую зависимость от каждого столбца этой таблицы, который он индексирует. Такого рода ситуации выражают объединение семантики множественных зависимостей. Зависимый объект может быть удален без &lt;code&gt;CASCADE&lt;/code&gt; , если какая-либо из его зависимостей удовлетворяет условию автоматического удаления. И наоборот, все ограничения зависимостей относительно того, какие объекты должны быть удалены вместе, должны быть выполнены.</target>
        </trans-unit>
        <trans-unit id="7a633bec827cd5945acb13add9ef3e8ab355704d" translate="yes" xml:space="preserve">
          <source>Note that late binding was the only behavior supported in PostgreSQL releases before 8.1, so you might need to do this to preserve the semantics of old applications.</source>
          <target state="translated">Обратите внимание,что поздняя привязка была единственным поведением,поддерживаемым в релизах PostgreSQL до 8.1,так что вам может понадобиться сделать это,чтобы сохранить семантику старых приложений.</target>
        </trans-unit>
        <trans-unit id="f498abb4a796a1a75315ef84efac83b6642a42d1" translate="yes" xml:space="preserve">
          <source>Note that libpq uses the SAM-compatible name if no explicit user name is specified. If you use libpq or a driver based on it, you should leave this option disabled or explicitly specify user name in the connection string.</source>
          <target state="translated">Обратите внимание,что libpq использует SAM-совместимое имя,если явное имя пользователя не указано.Если вы используете libpq или драйвер,основанный на ней,вам следует оставить эту опцию отключенной или явно указать имя пользователя в строке соединения.</target>
        </trans-unit>
        <trans-unit id="743714bf2d851c6ffde333b305cc76acb3b1f4e3" translate="yes" xml:space="preserve">
          <source>Note that loading a large number of rows using &lt;code&gt;COPY&lt;/code&gt; is almost always faster than using &lt;code&gt;INSERT&lt;/code&gt;, even if &lt;code&gt;PREPARE&lt;/code&gt; is used and multiple insertions are batched into a single transaction.</source>
          <target state="translated">Обратите внимание, что загрузка большого количества строк с помощью &lt;code&gt;COPY&lt;/code&gt; почти всегда быстрее, чем с помощью &lt;code&gt;INSERT&lt;/code&gt; , даже если используется &lt;code&gt;PREPARE&lt;/code&gt; и несколько вставок объединяются в одну транзакцию.</target>
        </trans-unit>
        <trans-unit id="42e8e431b9942cab90fba21d1a0369e9ad613d53" translate="yes" xml:space="preserve">
          <source>Note that locale names are specific to the operating system, so that the above commands might not work in the same way everywhere.</source>
          <target state="translated">Обратите внимание,что имена локалей специфичны для операционной системы,так что вышеуказанные команды могут работать не везде одинаково.</target>
        </trans-unit>
        <trans-unit id="a9b85d99902345f4af7308b01a61dc7702db748b" translate="yes" xml:space="preserve">
          <source>Note that not all SQL commands are able to work on inheritance hierarchies. Commands that are used for data querying, data modification, or schema modification (e.g., &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, most variants of &lt;code&gt;ALTER TABLE&lt;/code&gt;, but not &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt;) typically default to including child tables and support the &lt;code&gt;ONLY&lt;/code&gt; notation to exclude them. Commands that do database maintenance and tuning (e.g., &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;) typically only work on individual, physical tables and do not support recursing over inheritance hierarchies. The respective behavior of each individual command is documented in its reference page (&lt;a href=&quot;https://www.postgresql.org/docs/12/sql-commands.html&quot;&gt;SQL Commands&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что не все команды SQL могут работать с иерархиями наследования. Команды, которые используются для запроса данных, модификации данных или модификации схемы (например, &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , большинство вариантов &lt;code&gt;ALTER TABLE&lt;/code&gt; , но не &lt;code&gt;INSERT&lt;/code&gt; или &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt; ) обычно по умолчанию включают дочерние таблицы и поддерживают &lt;code&gt;ONLY&lt;/code&gt; обозначение для их исключения. Команды, выполняющие обслуживание и настройку базы данных (например, &lt;code&gt;REINDEX&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; ) обычно работают только с отдельными физическими таблицами и не поддерживают рекурсивный переход по иерархиям наследования. Соответствующее поведение каждой отдельной команды задокументировано на ее справочной странице ( &lt;a href=&quot;https://www.postgresql.org/docs/12/sql-commands.html&quot;&gt;команды SQL&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="327ef47ac3644ee0b774c6ef4fdf9e2c60c4fad3" translate="yes" xml:space="preserve">
          <source>Note that not all SQL commands are able to work on inheritance hierarchies. Commands that are used for data querying, data modification, or schema modification (e.g., &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, most variants of &lt;code&gt;ALTER TABLE&lt;/code&gt;, but not &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt;) typically default to including child tables and support the &lt;code&gt;ONLY&lt;/code&gt; notation to exclude them. Commands that do database maintenance and tuning (e.g., &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;) typically only work on individual, physical tables and do not support recursing over inheritance hierarchies. The respective behavior of each individual command is documented in its reference page (&lt;a href=&quot;https://www.postgresql.org/docs/13/sql-commands.html&quot;&gt;SQL Commands&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5e9d67d623aca716181f6ec9cb80abc27268bb" translate="yes" xml:space="preserve">
          <source>Note that object keys are compared in their storage order; in particular, since shorter keys are stored before longer keys, this can lead to results that might be unintuitive, such as:</source>
          <target state="translated">Обратите внимание,что объектные ключи сравниваются в порядке хранения;в частности,поскольку более короткие ключи хранятся раньше,чем более длинные,это может привести к результатам,которые могут быть не интуитивно понятны,например:</target>
        </trans-unit>
        <trans-unit id="c0b32073b6d3e410922a70ee12709380a01c6753" translate="yes" xml:space="preserve">
          <source>Note that older clients might lack support for the SCRAM authentication mechanism, and hence not work with passwords encrypted with SCRAM-SHA-256. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for more details.</source>
          <target state="translated">Обратите внимание, что более старые клиенты могут не поддерживать механизм аутентификации SCRAM и, следовательно, не работать с паролями, зашифрованными с помощью SCRAM-SHA-256. За подробностями &lt;a href=&quot;auth-password&quot;&gt;обратитесь&lt;/a&gt; к Разделу 20.5 .</target>
        </trans-unit>
        <trans-unit id="a9b3d09d3d6340576d5c998f6421491652b39ecd" translate="yes" xml:space="preserve">
          <source>Note that only updating transactions might need to be retried; read-only transactions will never have serialization conflicts.</source>
          <target state="translated">Обратите внимание,что может потребоваться перепроверять только обновляемые транзакции;транзакции,доступные только для чтения,никогда не будут иметь конфликтов сериализации.</target>
        </trans-unit>
        <trans-unit id="2954af76eca7ba35f68a0a8d801d4249462c8089" translate="yes" xml:space="preserve">
          <source>Note that ordering options apply only to the expression they follow; for example &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; does not mean the same thing as &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что параметры упорядочения применяются только к выражению, за которым они следуют; например, &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; не означает то же самое, что &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1c2c8127025345a934a6314a2f889673aacbd3b" translate="yes" xml:space="preserve">
          <source>Note that parallel queries may consume very substantially more resources than non-parallel queries, because each worker process is a completely separate process which has roughly the same impact on the system as an additional user session. This should be taken into account when choosing a value for this setting, as well as when configuring other settings that control resource utilization, such as &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;. Resource limits such as &lt;code&gt;work_mem&lt;/code&gt; are applied individually to each worker, which means the total utilization may be much higher across all processes than it would normally be for any single process. For example, a parallel query using 4 workers may use up to 5 times as much CPU time, memory, I/O bandwidth, and so forth as a query which uses no workers at all.</source>
          <target state="translated">Обратите внимание, что параллельные запросы могут потреблять значительно больше ресурсов, чем непараллельные запросы, потому что каждый рабочий процесс - это полностью отдельный процесс, который оказывает примерно такое же влияние на систему, как и дополнительный сеанс пользователя. Это следует учитывать при выборе значения для этого параметра, а также при настройке других параметров, управляющих использованием ресурсов, таких как &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt; . Ограничения ресурсов, такие как &lt;code&gt;work_mem&lt;/code&gt; , применяются индивидуально к каждому исполнителю , что означает, что общее использование может быть намного выше для всех процессов, чем обычно для любого отдельного процесса. Например, параллельный запрос с использованием 4 рабочих процессов может использовать до 5 раз больше процессорного времени, памяти, пропускной способности ввода-вывода и т.д., чем запрос, который вообще не использует рабочих.</target>
        </trans-unit>
        <trans-unit id="03d17cb56c53d9a14510ff412e2277014674b9c7" translate="yes" xml:space="preserve">
          <source>Note that parallel utility commands should not consume substantially more memory than equivalent non-parallel operations. This strategy differs from that of parallel query, where resource limits generally apply per worker process. Parallel utility commands treat the resource limit &lt;code&gt;maintenance_work_mem&lt;/code&gt; as a limit to be applied to the entire utility command, regardless of the number of parallel worker processes. However, parallel utility commands may still consume substantially more CPU resources and I/O bandwidth.</source>
          <target state="translated">Обратите внимание, что параллельные служебные команды не должны потреблять значительно больше памяти, чем эквивалентные непараллельные операции. Эта стратегия отличается от стратегии параллельного запроса, где ограничения ресурсов обычно применяются для каждого рабочего процесса. Параллельные служебные команды обрабатывают ограничение ресурсов &lt;code&gt;maintenance_work_mem&lt;/code&gt; как ограничение, которое должно применяться ко всей служебной команде, независимо от количества параллельных рабочих процессов. Однако параллельные служебные команды могут по-прежнему потреблять значительно больше ресурсов ЦП и пропускной способности ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="1c3896a4097aefd43e61d30f8ed6fc4608d53683" translate="yes" xml:space="preserve">
          <source>Note that partition pruning is driven only by the constraints defined implicitly by the partition keys, not by the presence of indexes. Therefore it isn't necessary to define indexes on the key columns. Whether an index needs to be created for a given partition depends on whether you expect that queries that scan the partition will generally scan a large part of the partition or just a small part. An index will be helpful in the latter case but not the former.</source>
          <target state="translated">Обратите внимание,что обрезка разделов происходит только по ограничениям,неявно заданным ключами разделов,а не по наличию индексов.Поэтому нет необходимости определять индексы на столбцах ключей.Нужно ли создавать индекс для данного раздела,зависит от того,ожидаете ли вы,что запросы,которые сканируют раздел,обычно будут сканировать большую или только малую часть раздела.Индекс будет полезен во втором случае,но не в первом.</target>
        </trans-unit>
        <trans-unit id="c526234778414186549c3a732294e28ea6360814" translate="yes" xml:space="preserve">
          <source>Note that pg_dump will set &lt;code&gt;row_security&lt;/code&gt; to &lt;code&gt;OFF&lt;/code&gt; by default, to ensure all contents of a table are dumped out. If the user running pg_dump does not have appropriate permissions, an error will be returned. However, superusers and the owner of the table being dumped always bypass RLS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8457004be1bd2121d647641e3e2f206401f9ee82" translate="yes" xml:space="preserve">
          <source>Note that revoking this privilege will not alter the existence or location of existing objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed232352821561d7f4d97b0cbed4bb08fe3a2ef" translate="yes" xml:space="preserve">
          <source>Note that roles are defined at the database cluster level, and so are valid in all databases in the cluster.</source>
          <target state="translated">Обратите внимание,что роли определяются на уровне кластера баз данных,и поэтому действительны во всех базах данных в кластере.</target>
        </trans-unit>
        <trans-unit id="746fd0d5f2f710a9b186a9ef98779e17d15fa9db" translate="yes" xml:space="preserve">
          <source>Note that tablespace directories are not cleaned up either way.</source>
          <target state="translated">Обратите внимание,что каталоги табличных пространств в любом случае не очищаются.</target>
        </trans-unit>
        <trans-unit id="d1d5538437b8defc93f56eee03304e310c0c5042" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;actual time&amp;rdquo; values are in milliseconds of real time, whereas the &lt;code&gt;cost&lt;/code&gt; estimates are expressed in arbitrary units; so they are unlikely to match up. The thing that's usually most important to look for is whether the estimated row counts are reasonably close to reality. In this example the estimates were all dead-on, but that's quite unusual in practice.</source>
          <target state="translated">Обратите внимание, что значения &amp;laquo;фактического времени&amp;raquo; выражаются в миллисекундах реального времени, тогда как оценки &lt;code&gt;cost&lt;/code&gt; выражаются в произвольных единицах; так что они вряд ли совпадут. Обычно наиболее важно обращать внимание на то, насколько приблизительное количество строк достаточно близко к реальности. В этом примере все оценки были точными, но на практике это довольно необычно.</target>
        </trans-unit>
        <trans-unit id="9e220f4fc878ea43d3bad6e0a739b4b79c17d896" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;best match&amp;rdquo; rules are identical for operator and function type resolution. Some examples follow.</source>
          <target state="translated">Обратите внимание, что правила &amp;laquo;наилучшего соответствия&amp;raquo; идентичны для разрешения типа оператора и функции. Ниже приведены некоторые примеры.</target>
        </trans-unit>
        <trans-unit id="ef1701ee0df5df14d039148f316d2e4d2b8aa8fd" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;same as&amp;rdquo; operator, &lt;code&gt;~=&lt;/code&gt;, represents the usual notion of equality for the &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; types. Some of the geometric types also have an &lt;code&gt;=&lt;/code&gt; operator, but &lt;code&gt;=&lt;/code&gt; compares for equal &lt;em&gt;areas&lt;/em&gt; only. The other scalar comparison operators (&lt;code&gt;&amp;lt;=&lt;/code&gt; and so on), where available for these types, likewise compare areas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a397047ec4388fcee29b79f7e608c05447ff76" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;same as&amp;rdquo; operator, &lt;code&gt;~=&lt;/code&gt;, represents the usual notion of equality for the &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; types. Some of these types also have an &lt;code&gt;=&lt;/code&gt; operator, but &lt;code&gt;=&lt;/code&gt; compares for equal &lt;em&gt;areas&lt;/em&gt; only. The other scalar comparison operators (&lt;code&gt;&amp;lt;=&lt;/code&gt; and so on) likewise compare areas for these types.</source>
          <target state="translated">Обратите внимание, что оператор &amp;laquo;то же самое&amp;raquo;, &lt;code&gt;~=&lt;/code&gt; , представляет обычное понятие равенства для типов &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; и &lt;code&gt;circle&lt;/code&gt; . Некоторые из этих типов также имеют оператор &lt;code&gt;=&lt;/code&gt; , но &lt;code&gt;=&lt;/code&gt; сравнивает только равные &lt;em&gt;площади&lt;/em&gt; . Другие операторы скалярного сравнения ( &lt;code&gt;&amp;lt;=&lt;/code&gt; и т. Д.) Аналогичным образом сравнивают области для этих типов.</target>
        </trans-unit>
        <trans-unit id="3f9568498993be48d548609f8f99b58407bdc0b5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;CHECK OPTION&lt;/code&gt; is only supported on views that are automatically updatable, and do not have &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers or &lt;code&gt;INSTEAD&lt;/code&gt; rules. If an automatically updatable view is defined on top of a base view that has &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers, then the &lt;code&gt;LOCAL CHECK OPTION&lt;/code&gt; may be used to check the conditions on the automatically updatable view, but the conditions on the base view with &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers will not be checked (a cascaded check option will not cascade down to a trigger-updatable view, and any check options defined directly on a trigger-updatable view will be ignored). If the view or any of its base relations has an &lt;code&gt;INSTEAD&lt;/code&gt; rule that causes the &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command to be rewritten, then all check options will be ignored in the rewritten query, including any checks from automatically updatable views defined on top of the relation with the &lt;code&gt;INSTEAD&lt;/code&gt; rule.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;CHECK OPTION&lt;/code&gt; поддерживается только в автоматически обновляемых представлениях, не имеющих триггеров &lt;code&gt;INSTEAD OF&lt;/code&gt; или правил &lt;code&gt;INSTEAD&lt;/code&gt; . Если автоматически обновляемое представление определено поверх базового представления, у которого есть триггеры &lt;code&gt;INSTEAD OF&lt;/code&gt; , тогда &lt;code&gt;LOCAL CHECK OPTION&lt;/code&gt; может использоваться для проверки условий в автоматически обновляемом представлении, но условия в базовом представлении с триггерами &lt;code&gt;INSTEAD OF&lt;/code&gt; не будут быть проверенным (опция каскадной проверки не будет переходить каскадно в представление, обновляемое триггером, и любые параметры проверки, определенные непосредственно в представлении, обновляемом триггером, будут игнорироваться). Если представление или какое-либо из его базовых отношений имеет правило &lt;code&gt;INSTEAD&lt;/code&gt; , которое вызывает &lt;code&gt;INSERT&lt;/code&gt; Команда INSERT или &lt;code&gt;UPDATE&lt;/code&gt; должна быть переписана, тогда все параметры проверки будут проигнорированы в переписанном запросе, включая любые проверки из автоматически обновляемых представлений, определенных поверх отношения с правилом &lt;code&gt;INSTEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="048b814d4fde306f95eb514ec96249604d0f3baf" translate="yes" xml:space="preserve">
          <source>Note that the checksum depends on the block number, so matching block numbers should be passed (except when doing esoteric debugging).</source>
          <target state="translated">Обратите внимание,что контрольная сумма зависит от номера блока,поэтому следует передавать соответствующие номера блоков (за исключением случаев эзотерической отладки).</target>
        </trans-unit>
        <trans-unit id="8c92d729af687d63d61faa7693bb18cfc4db6007" translate="yes" xml:space="preserve">
          <source>Note that the command is invoked by the shell, so if you need to pass any arguments to shell command that come from an untrusted source, you must be careful to strip or escape any special characters that might have a special meaning for the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">Обратите внимание,что команда вызывается оболочкой,поэтому если вам нужно передать любые аргументы в команду оболочки,которые исходят из недоверенного источника,вы должны быть осторожны,чтобы удалить или избежать любых специальных символов,которые могут иметь особое значение для оболочки.Из соображений безопасности лучше всего использовать фиксированную командную строку,или,по крайней мере,не передавать в ней пользовательский ввод.</target>
        </trans-unit>
        <trans-unit id="95e2592cd121958603de591b16676dfd151d7385" translate="yes" xml:space="preserve">
          <source>Note that the effects of all per-row &lt;code&gt;BEFORE INSERT&lt;/code&gt; triggers are reflected in &lt;code&gt;excluded&lt;/code&gt; values, since those effects may have contributed to the row being excluded from insertion.</source>
          <target state="translated">Обратите внимание, что эффекты всех триггеров &lt;code&gt;BEFORE INSERT&lt;/code&gt; для каждой строки отражаются в &lt;code&gt;excluded&lt;/code&gt; значениях, поскольку эти эффекты могли способствовать исключению строки из вставки.</target>
        </trans-unit>
        <trans-unit id="5d831510235276a5c3036f14f7c31dd0c8581fc2" translate="yes" xml:space="preserve">
          <source>Note that the first item on any non-rightmost page (any page with a non-zero value in the &lt;code&gt;btpo_next&lt;/code&gt; field) is the page's &amp;ldquo;high key&amp;rdquo;, meaning its &lt;code&gt;data&lt;/code&gt; serves as an upper bound on all items appearing on the page, while its &lt;code&gt;ctid&lt;/code&gt; field does not point to another block. Also, on internal pages, the first real data item (the first item that is not a high key) reliably has every column truncated away, leaving no actual value in its &lt;code&gt;data&lt;/code&gt; field. Such an item does have a valid downlink in its &lt;code&gt;ctid&lt;/code&gt; field, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e212873009117f62fcd9c668559d87771494a3ea" translate="yes" xml:space="preserve">
          <source>Note that the first item on any non-rightmost page (any page with a non-zero value in the &lt;code&gt;btpo_next&lt;/code&gt; field) is the page's &amp;ldquo;high key&amp;rdquo;, meaning its &lt;code&gt;data&lt;/code&gt; serves as an upper bound on all items appearing on the page, while its &lt;code&gt;ctid&lt;/code&gt; field is meaningless. Also, on non-leaf pages, the first real data item (the first item that is not a high key) is a &amp;ldquo;minus infinity&amp;rdquo; item, with no actual value in its &lt;code&gt;data&lt;/code&gt; field. Such an item does have a valid downlink in its &lt;code&gt;ctid&lt;/code&gt; field, however.</source>
          <target state="translated">Обратите внимание, что первый элемент на любой не самой правой странице (любая страница с ненулевым значением в поле &lt;code&gt;btpo_next&lt;/code&gt; ) является &amp;laquo;высоким ключом&amp;raquo; страницы, то есть его &lt;code&gt;data&lt;/code&gt; служат верхней границей для всех элементов, появляющихся на странице, в то время как его поле &lt;code&gt;ctid&lt;/code&gt; бессмысленно. Кроме того, на нелистовых страницах первый реальный элемент данных (первый элемент, не являющийся высоким ключом) является элементом &amp;laquo;минус бесконечность&amp;raquo; без фактического значения в его поле &lt;code&gt;data&lt;/code&gt; . Однако у такого элемента действительно есть действительный нисходящий канал в поле &lt;code&gt;ctid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="535954ca2908fbda93be1ed4d604a5a38ff7249d" translate="yes" xml:space="preserve">
          <source>Note that the following sections describe the behavior of the builtin &lt;code&gt;heap&lt;/code&gt;&lt;a href=&quot;tableam&quot;&gt;table access method&lt;/a&gt;, and the builtin &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;index access methods&lt;/a&gt;. Due to the extensible nature of PostgreSQL, other access methods might work differently.</source>
          <target state="translated">Обратите внимание, что в следующих разделах описывается поведение встроенного &lt;a href=&quot;tableam&quot;&gt;метода доступа к таблице &lt;/a&gt; &lt;code&gt;heap&lt;/code&gt; и встроенных &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;методов доступа к индексу&lt;/a&gt; . Из-за расширяемости PostgreSQL другие методы доступа могут работать иначе.</target>
        </trans-unit>
        <trans-unit id="b97c4406cd03632c5651253443e7276d76c22605" translate="yes" xml:space="preserve">
          <source>Note that the following sections describe the behavior of the builtin &lt;code&gt;heap&lt;/code&gt;&lt;a href=&quot;tableam&quot;&gt;table access method&lt;/a&gt;, and the builtin &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;index access methods&lt;/a&gt;. Due to the extensible nature of PostgreSQL, other access methods might work differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff99b02bab93b2bce6ccdae00e15d7def0f0061" translate="yes" xml:space="preserve">
          <source>Note that the locale behavior of the server is determined by the environment variables seen by the server, not by the environment of any client. Therefore, be careful to configure the correct locale settings before starting the server. A consequence of this is that if client and server are set up in different locales, messages might appear in different languages depending on where they originated.</source>
          <target state="translated">Обратите внимание,что поведение локали сервера определяется переменными окружения,видимыми сервером,а не окружением любого клиента.Поэтому перед запуском сервера внимательно настройте правильные параметры локали.Следствием этого является то,что если клиент и сервер настроены в разных локалях,то сообщения могут появляться на разных языках в зависимости от того,откуда они исходят.</target>
        </trans-unit>
        <trans-unit id="07d471153d0c31d19d3a687501b18f85b42ddbd4" translate="yes" xml:space="preserve">
          <source>Note that the only supported &lt;a href=&quot;auth-methods&quot;&gt;authentication methods&lt;/a&gt; for use with GSSAPI encryption are &lt;code&gt;gss&lt;/code&gt;, &lt;code&gt;reject&lt;/code&gt;, and &lt;code&gt;trust&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что единственными поддерживаемыми &lt;a href=&quot;auth-methods&quot;&gt;методами аутентификации&lt;/a&gt; для использования с шифрованием GSSAPI являются &lt;code&gt;gss&lt;/code&gt; , &lt;code&gt;reject&lt;/code&gt; и &lt;code&gt;trust&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1ad926ce9c3e21892b3792f7b8c1dbecab3b69d" translate="yes" xml:space="preserve">
          <source>Note that the operator precedence rules also apply to user-defined operators that have the same names as the built-in operators mentioned above. For example, if you define a &amp;ldquo;+&amp;rdquo; operator for some custom data type it will have the same precedence as the built-in &amp;ldquo;+&amp;rdquo; operator, no matter what yours does.</source>
          <target state="translated">Обратите внимание, что правила приоритета операторов также применяются к определяемым пользователем операторам, которые имеют те же имена, что и встроенные операторы, упомянутые выше. Например, если вы определяете оператор &amp;laquo;+&amp;raquo; для некоторого настраиваемого типа данных, он будет иметь тот же приоритет, что и встроенный оператор &amp;laquo;+&amp;raquo;, независимо от того, что делает ваш.</target>
        </trans-unit>
        <trans-unit id="c8f86dee03c6b505a272324fb9a4a25b4a43909d" translate="yes" xml:space="preserve">
          <source>Note that the ordering options are considered independently for each sort column. For example &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; means &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt;, which is not the same as &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что варианты сортировки рассматриваются независимо для каждого столбца сортировки. Например, &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; означает &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt; , что не то же самое, что &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2d7f74d4ba0ae61a9bd9e94f45d68a74a955765" translate="yes" xml:space="preserve">
          <source>Note that the parser automatically understands that &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are of type &lt;code&gt;boolean&lt;/code&gt;, but this is not so for &lt;code&gt;NULL&lt;/code&gt; because that can have any type. So in some contexts you might have to cast &lt;code&gt;NULL&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt; explicitly, for example &lt;code&gt;NULL::boolean&lt;/code&gt;. Conversely, the cast can be omitted from a string-literal Boolean value in contexts where the parser can deduce that the literal must be of type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что синтаксический анализатор автоматически понимает, что &lt;code&gt;TRUE&lt;/code&gt; и &lt;code&gt;FALSE&lt;/code&gt; относятся к &lt;code&gt;boolean&lt;/code&gt; типу , но это не так для &lt;code&gt;NULL&lt;/code&gt; , потому что он может иметь любой тип. Поэтому в некоторых контекстах вам может потребоваться явное &lt;code&gt;boolean&lt;/code&gt; &lt;code&gt;NULL&lt;/code&gt; в логическое значение , например &lt;code&gt;NULL::boolean&lt;/code&gt; . И наоборот, приведение может быть опущено для логического значения строкового литерала в контекстах, где синтаксический анализатор может сделать вывод, что литерал должен иметь тип &lt;code&gt;boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6830af538ea3d4def0017ebca2cb9eb811ef481a" translate="yes" xml:space="preserve">
          <source>Note that the password prompt will occur again for each database to be dumped. Usually, it's better to set up a &lt;code&gt;~/.pgpass&lt;/code&gt; file than to rely on manual password entry.</source>
          <target state="translated">Обратите внимание, что запрос пароля будет появляться снова для каждой базы данных, которая будет выгружена. Обычно лучше создать файл &lt;code&gt;~/.pgpass&lt;/code&gt; , чем полагаться на ввод пароля вручную.</target>
        </trans-unit>
        <trans-unit id="42ada1c8e6a6026750e361cb5d7ba311ef045adc" translate="yes" xml:space="preserve">
          <source>Note that the query planner does not consider deferring the evaluation of parallel-restricted functions or aggregates involved in the query in order to obtain a superior plan. So, for example, if a &lt;code&gt;WHERE&lt;/code&gt; clause applied to a particular table is parallel restricted, the query planner will not consider performing a scan of that table in the parallel portion of a plan. In some cases, it would be possible (and perhaps even efficient) to include the scan of that table in the parallel portion of the query and defer the evaluation of the &lt;code&gt;WHERE&lt;/code&gt; clause so that it happens above the &lt;code&gt;Gather&lt;/code&gt; node. However, the planner does not do this.</source>
          <target state="translated">Обратите внимание, что планировщик запросов не рассматривает откладывание оценки функций или агрегатов с параллельным ограничением, задействованных в запросе, для получения лучшего плана. Так, например, если предложение &lt;code&gt;WHERE&lt;/code&gt; , примененное к определенной таблице, ограничено параллельным доступом, планировщик запросов не будет рассматривать выполнение сканирования этой таблицы в параллельной части плана. В некоторых случаях было бы возможно (и, возможно, даже эффективно) включить сканирование этой таблицы в параллельную часть запроса и отложить оценку &lt;code&gt;WHERE&lt;/code&gt; , чтобы это происходило над узлом &lt;code&gt;Gather&lt;/code&gt; . Однако планировщик этого не делает.</target>
        </trans-unit>
        <trans-unit id="5f4f575c0dfc110a613df4c8c43c09b6bc17afc4" translate="yes" xml:space="preserve">
          <source>Note that the single-user mode server does not provide sophisticated line-editing features (no command history, for example). Single-user mode also does not do any background processing, such as automatic checkpoints or replication.</source>
          <target state="translated">Обратите внимание,что сервер в однопользовательском режиме не предоставляет сложных функций редактирования строки (нет истории команд,например).Однопользовательский режим также не выполняет никакой фоновой обработки,такой как автоматические контрольно-пропускные пункты или репликация.</target>
        </trans-unit>
        <trans-unit id="542b405bccbd1dfc2248044e2da7018d901a07e8" translate="yes" xml:space="preserve">
          <source>Note that the unique key on this catalog is (&lt;code&gt;collname&lt;/code&gt;, &lt;code&gt;collencoding&lt;/code&gt;, &lt;code&gt;collnamespace&lt;/code&gt;) not just (&lt;code&gt;collname&lt;/code&gt;, &lt;code&gt;collnamespace&lt;/code&gt;). PostgreSQL generally ignores all collations that do not have &lt;code&gt;collencoding&lt;/code&gt; equal to either the current database's encoding or -1, and creation of new entries with the same name as an entry with &lt;code&gt;collencoding&lt;/code&gt; = -1 is forbidden. Therefore it is sufficient to use a qualified SQL name (&lt;code&gt;schema&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt;) to identify a collation, even though this is not unique according to the catalog definition. The reason for defining the catalog this way is that initdb fills it in at cluster initialization time with entries for all locales available on the system, so it must be able to hold entries for all encodings that might ever be used in the cluster.</source>
          <target state="translated">Обратите внимание, что уникальный ключ в этом каталоге ( &lt;code&gt;collname&lt;/code&gt; &lt;code&gt;collencoding&lt;/code&gt; , &lt;code&gt;collnamespace&lt;/code&gt; столбец , пространство имен-столбцов ), а не просто (имя- &lt;code&gt;collname&lt;/code&gt; , &lt;code&gt;collnamespace&lt;/code&gt; имен- столбцов ). PostgreSQL обычно игнорирует все сопоставления, для которых &lt;code&gt;collencoding&lt;/code&gt; не равен либо кодировке текущей базы данных, либо -1, а создание новых записей с тем же именем, что и запись с &lt;code&gt;collencoding&lt;/code&gt; = -1, запрещено. Поэтому достаточно использовать квалифицированное имя SQL ( &lt;code&gt;schema&lt;/code&gt; . &lt;code&gt;name&lt;/code&gt; ) для идентификации параметров сортировки, даже если они не уникальны в соответствии с определением каталога. Причина определения каталога таким образом заключается в том, что initdb заполняет его во время инициализации кластера записями для всех локалей, доступных в системе, поэтому он должен иметь возможность хранить записи для всех кодировок, которые могут когда-либо использоваться в кластере.</target>
        </trans-unit>
        <trans-unit id="57816233be3efc2c0b4b0cdc3b84a0dda807639d" translate="yes" xml:space="preserve">
          <source>Note that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the update does not need any permissions on the underlying base relations (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что пользователь, выполняющий вставку, обновление или удаление в представлении, должен иметь соответствующие права вставки, обновления или удаления в представлении. Вдобавок владелец представления должен иметь соответствующие привилегии в отношении базовых отношений, но пользователю, выполняющему обновление, не нужны никакие разрешения для базовых отношений (см. &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Раздел 40.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="52e6a2ffb8f6a4ee70000d58285441af2239687a" translate="yes" xml:space="preserve">
          <source>Note that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the update does not need any permissions on the underlying base relations (see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f758ecc8993acb3505a10e1f0f3118a15da20e0" translate="yes" xml:space="preserve">
          <source>Note that the white space on each line is actually a tab character.</source>
          <target state="translated">Обратите внимание,что пробел белого на каждой строке на самом деле является символом табуляции.</target>
        </trans-unit>
        <trans-unit id="f2961d22f06a0ed36b2caf77fbad086d6c0a84ff" translate="yes" xml:space="preserve">
          <source>Note that there are some limitations in an online backup from the standby:</source>
          <target state="translated">Обратите внимание,что существуют некоторые ограничения на онлайновое резервное копирование из режима ожидания:</target>
        </trans-unit>
        <trans-unit id="4d288b29e3c118d6d8c73403f59b3896205eea76" translate="yes" xml:space="preserve">
          <source>Note that there are some limitations in taking a backup from a standby:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad0151522b3b77d6456a32b223d7660f4475e688" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;CREATE ROUTINE&lt;/code&gt; command.</source>
          <target state="translated">Обратите внимание, что здесь нет команды &lt;code&gt;CREATE ROUTINE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1d66a79704a8f138a556c34b5e710e75580d121" translate="yes" xml:space="preserve">
          <source>Note that there needs to be at least one permissive policy to grant access to records before restrictive policies can be usefully used to reduce that access. If only restrictive policies exist, then no records will be accessible. When a mix of permissive and restrictive policies are present, a record is only accessible if at least one of the permissive policies passes, in addition to all the restrictive policies.</source>
          <target state="translated">Обратите внимание,что должна быть,по крайней мере,одна разрешительная политика для предоставления доступа к записям,прежде чем ограничительные политики могут быть полезны для сокращения этого доступа.Если существуют только ограничительные политики,то никакие записи не будут доступны.При наличии сочетания разрешительных и ограничительных политик запись доступна только в том случае,если,в дополнение ко всем ограничительным политикам,пройдет хотя бы одна из разрешительных политик.</target>
        </trans-unit>
        <trans-unit id="95b9e36ae86d5f4054bebe05afb0d0ec344eb9ad" translate="yes" xml:space="preserve">
          <source>Note that these potentially produce a lot of data, which needs to be built up in memory. When requesting content mappings of large schemas or databases, it might be worthwhile to consider mapping the tables separately instead, possibly even through a cursor.</source>
          <target state="translated">Обратите внимание,что они потенциально производят большое количество данных,которые необходимо собрать в памяти.При запросе отображения содержимого больших схем или баз данных,возможно,стоит рассмотреть возможность отображения таблиц отдельно,возможно,даже с помощью курсора.</target>
        </trans-unit>
        <trans-unit id="b8effb15698d614b121eab24d0dff7bc4e7c22a6" translate="yes" xml:space="preserve">
          <source>Note that this actually means &amp;ldquo;revoke all privileges that I granted&amp;rdquo;.</source>
          <target state="translated">Обратите внимание, что на самом деле это означает &amp;laquo;отозвать все предоставленные мной привилегии&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a377102624b4be7d75b74040aea8858a414e0fc7" translate="yes" xml:space="preserve">
          <source>Note that this behavior is consistent with other popular implementations of host name-based access control, such as the Apache HTTP Server and TCP Wrappers.</source>
          <target state="translated">Обратите внимание,что такое поведение согласуется с другими популярными реализациями контроля доступа на основе имени хоста,такими как HTTP-сервер Apache и TCP-обертки.</target>
        </trans-unit>
        <trans-unit id="765730fc2ec6d6848cd71e4c2044c699075b50df" translate="yes" xml:space="preserve">
          <source>Note that this command is subtly different from the server-side &lt;code&gt;lo_import&lt;/code&gt; because it acts as the local user on the local file system, rather than the server's user and file system.</source>
          <target state="translated">Обратите внимание, что эта команда немного отличается от команды &lt;code&gt;lo_import&lt;/code&gt; на стороне сервера, потому что она действует как локальный пользователь в локальной файловой системе, а не как пользователь сервера и файловая система.</target>
        </trans-unit>
        <trans-unit id="0f8fb90970b8968e4f7127f317566345b970df55" translate="yes" xml:space="preserve">
          <source>Note that this doesn't affect any existing rows in the table, it just changes the default for future &lt;code&gt;INSERT&lt;/code&gt; commands.</source>
          <target state="translated">Обратите внимание, что это не влияет на существующие строки в таблице, это просто изменяет значение по умолчанию для будущих команд &lt;code&gt;INSERT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56e3b32d061c366fed83bd98f4d4590767c40034" translate="yes" xml:space="preserve">
          <source>Note that this is different from</source>
          <target state="translated">Обратите внимание,что это отличается от</target>
        </trans-unit>
        <trans-unit id="9e5d1d4e065e9c7dc21ef91bf768d68d3c9d8a1d" translate="yes" xml:space="preserve">
          <source>Note that this is not the same as the left-to-right &amp;ldquo;short-circuiting&amp;rdquo; of Boolean operators that is found in some programming languages.</source>
          <target state="translated">Обратите внимание, что это не то же самое, что &amp;laquo;короткое замыкание&amp;raquo; логических операторов слева направо, которое встречается в некоторых языках программирования.</target>
        </trans-unit>
        <trans-unit id="ca51a28e46507688c57df1dccd9f468de8996aae" translate="yes" xml:space="preserve">
          <source>Note that this option currently also requires the dump be in &lt;code&gt;INSERT&lt;/code&gt; format, as &lt;code&gt;COPY FROM&lt;/code&gt; does not support row security.</source>
          <target state="translated">Обратите внимание, что этот параметр в настоящее время также требует, чтобы дамп был в формате &lt;code&gt;INSERT&lt;/code&gt; , поскольку &lt;code&gt;COPY FROM&lt;/code&gt; не поддерживает защиту строк.</target>
        </trans-unit>
        <trans-unit id="9da43a46207df32c5bc41dc69140b018443cc610" translate="yes" xml:space="preserve">
          <source>Note that this option is incompatible with the &lt;code&gt;--index&lt;/code&gt; and &lt;code&gt;--system&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb5224f9cf66b54a71c646c3cd12c1c98805d5f" translate="yes" xml:space="preserve">
          <source>Note that this option only affects the exact form &lt;code&gt;= NULL&lt;/code&gt;, not other comparison operators or other expressions that are computationally equivalent to some expression involving the equals operator (such as &lt;code&gt;IN&lt;/code&gt;). Thus, this option is not a general fix for bad programming.</source>
          <target state="translated">Обратите внимание, что этот параметр влияет только на точную форму &lt;code&gt;= NULL&lt;/code&gt; , но не на другие операторы сравнения или другие выражения, которые в вычислительном отношении эквивалентны некоторому выражению, содержащему оператор равенства (например, &lt;code&gt;IN&lt;/code&gt; ). Таким образом, этот вариант не является общим средством исправления плохого программирования.</target>
        </trans-unit>
        <trans-unit id="e47f160f4c862fafa44c7f19b4f7d0d78fd15669" translate="yes" xml:space="preserve">
          <source>Note that this option will remain set for the entire session, and so it affects uses of the meta-command &lt;code&gt;\connect&lt;/code&gt; as well as the initial connection attempt.</source>
          <target state="translated">Обратите внимание, что этот параметр будет оставаться установленным для всего сеанса, поэтому он влияет на использование метакоманды &lt;code&gt;\connect&lt;/code&gt; а также на первоначальную попытку подключения.</target>
        </trans-unit>
        <trans-unit id="9cb49d36842c28bbc6961c206fc6fb511f408fc8" translate="yes" xml:space="preserve">
          <source>Note that this query cannot use this index:</source>
          <target state="translated">Обратите внимание,что данный запрос не может использовать данный индекс:</target>
        </trans-unit>
        <trans-unit id="eeb09f3d3f513d7242e768b40d1a3d7a48755d6c" translate="yes" xml:space="preserve">
          <source>Note that this setting only affects the main shared memory area. Operating systems such as Linux, FreeBSD, and Illumos can also use huge pages (also known as &amp;ldquo;super&amp;rdquo; pages or &amp;ldquo;large&amp;rdquo; pages) automatically for normal memory allocation, without an explicit request from PostgreSQL. On Linux, this is called &amp;ldquo;transparent huge pages&amp;rdquo; (THP). That feature has been known to cause performance degradation with PostgreSQL for some users on some Linux versions, so its use is currently discouraged (unlike explicit use of &lt;code&gt;huge_pages&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что этот параметр влияет только на основную общую область памяти. Операционные системы, такие как Linux, FreeBSD и Illumos, также могут автоматически использовать огромные страницы (также известные как &amp;laquo;супер&amp;raquo; или &amp;laquo;большие&amp;raquo; страницы) для нормального распределения памяти без явного запроса от PostgreSQL. В Linux это называется &amp;laquo;прозрачные огромные страницы&amp;raquo; (THP). Известно, что эта функция вызывает снижение производительности PostgreSQL для некоторых пользователей в некоторых версиях Linux, поэтому ее использование в настоящее время не рекомендуется (в отличие от явного использования &lt;code&gt;huge_pages&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="601d111715a6b1b59291397e0542ab5aa27f6545" translate="yes" xml:space="preserve">
          <source>Note that this view does not include memory allocated using the dynamic shared memory infrastructure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906c24642d7c9d1ccf94ab876f98cee1fa64d503" translate="yes" xml:space="preserve">
          <source>Note that this way the connection from &lt;code&gt;shell.foo.com&lt;/code&gt; to &lt;code&gt;db.foo.com&lt;/code&gt; will not be encrypted by the SSH tunnel. SSH offers quite a few configuration possibilities when the network is restricted in various ways. Please refer to the SSH documentation for details.</source>
          <target state="translated">Обратите внимание, что в этом случае соединение от &lt;code&gt;shell.foo.com&lt;/code&gt; к &lt;code&gt;db.foo.com&lt;/code&gt; не будет зашифровано туннелем SSH. SSH предлагает довольно много возможностей настройки, когда сеть ограничена различными способами. Пожалуйста, обратитесь к документации SSH за подробностями.</target>
        </trans-unit>
        <trans-unit id="aed9a462aeaf6aae78a53a2e55aac5e3c16613ab" translate="yes" xml:space="preserve">
          <source>Note that this will result in locking all rows of &lt;code&gt;mytable&lt;/code&gt;, whereas &lt;code&gt;FOR UPDATE&lt;/code&gt; at the top level would lock only the actually returned rows. This can make for a significant performance difference, particularly if the &lt;code&gt;ORDER BY&lt;/code&gt; is combined with &lt;code&gt;LIMIT&lt;/code&gt; or other restrictions. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required.</source>
          <target state="translated">Обратите внимание, что это приведет к блокировке всех строк &lt;code&gt;mytable&lt;/code&gt; , тогда как &lt;code&gt;FOR UPDATE&lt;/code&gt; на верхнем уровне заблокирует только фактически возвращенные строки. Это может привести к значительной разнице в производительности, особенно если &lt;code&gt;ORDER BY&lt;/code&gt; сочетается с &lt;code&gt;LIMIT&lt;/code&gt; или другими ограничениями. Таким образом, этот метод рекомендуется только в том случае, если ожидаются одновременные обновления столбцов упорядочения и требуется строго отсортированный результат.</target>
        </trans-unit>
        <trans-unit id="59d9533d6b1ff70587da7945ccc9db2ea583f449" translate="yes" xml:space="preserve">
          <source>Note that two rows are displayed for the same column, one corresponding to the complete inheritance hierarchy starting at the &lt;code&gt;road&lt;/code&gt; table (&lt;code&gt;inherited&lt;/code&gt;=&lt;code&gt;t&lt;/code&gt;), and another one including only the &lt;code&gt;road&lt;/code&gt; table itself (&lt;code&gt;inherited&lt;/code&gt;=&lt;code&gt;f&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что для одного и того же столбца отображаются две строки: одна соответствует полной иерархии наследования, начиная с таблицы &lt;code&gt;road&lt;/code&gt; ( &lt;code&gt;inherited&lt;/code&gt; = &lt;code&gt;t&lt;/code&gt; ), а другая включает только саму таблицу &lt;code&gt;road&lt;/code&gt; ( &lt;code&gt;inherited&lt;/code&gt; = &lt;code&gt;f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="10e9b0e25eb4f44f89bb51356ad1df0c93761c8b" translate="yes" xml:space="preserve">
          <source>Note that unlike most catalogs with a &amp;ldquo;namespace&amp;rdquo; column, &lt;code&gt;extnamespace&lt;/code&gt; is not meant to imply that the extension belongs to that schema. Extension names are never schema-qualified. Rather, &lt;code&gt;extnamespace&lt;/code&gt; indicates the schema that contains most or all of the extension's objects. If &lt;code&gt;extrelocatable&lt;/code&gt; is true, then this schema must in fact contain all schema-qualifiable objects belonging to the extension.</source>
          <target state="translated">Обратите внимание, что в отличие от большинства каталогов со столбцом &amp;laquo;пространство имен&amp;raquo;, &lt;code&gt;extnamespace&lt;/code&gt; не означает, что расширение принадлежит этой схеме. Имена расширений никогда не уточняются схемой. Скорее &lt;code&gt;extnamespace&lt;/code&gt; указывает схему, которая содержит большую часть или все объекты расширения. Если &lt;code&gt;extrelocatable&lt;/code&gt; истинно, тогда эта схема должна фактически содержать все подходящие для схемы объекты, принадлежащие расширению.</target>
        </trans-unit>
        <trans-unit id="95d30679c93680a49476e594a17f9119213eea89" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;code&gt;cube&lt;/code&gt;-based part of the module, units are hardwired here: changing the &lt;code&gt;earth()&lt;/code&gt; function will not affect the results of this operator.</source>
          <target state="translated">Обратите внимание, что в отличие от части модуля, основанной на &lt;code&gt;cube&lt;/code&gt; зашиты модули: изменение функции &lt;code&gt;earth()&lt;/code&gt; не повлияет на результаты этого оператора.</target>
        </trans-unit>
        <trans-unit id="aec424e8783da60644af6ec05ea73b5e181a5ff9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;ldapscheme&lt;/code&gt; or &lt;code&gt;ldaptls&lt;/code&gt; only encrypts the traffic between the PostgreSQL server and the LDAP server. The connection between the PostgreSQL server and the PostgreSQL client will still be unencrypted unless SSL is used there as well.</source>
          <target state="translated">Обратите внимание, что использование &lt;code&gt;ldapscheme&lt;/code&gt; или &lt;code&gt;ldaptls&lt;/code&gt; шифрует только трафик между сервером PostgreSQL и сервером LDAP. Соединение между сервером PostgreSQL и клиентом PostgreSQL будет по-прежнему незашифрованным, если там также не используется SSL.</target>
        </trans-unit>
        <trans-unit id="f4e11f3a6327ed7b6ce66ef2d86de4e055bd13dd" translate="yes" xml:space="preserve">
          <source>Note that using this mode together with the &lt;code&gt;-f&lt;/code&gt; (&lt;code&gt;FULL&lt;/code&gt;) option might cause deadlock failures if certain system catalogs are processed in parallel.</source>
          <target state="translated">Обратите внимание, что использование этого режима вместе с параметром &lt;code&gt;-f&lt;/code&gt; ( &lt;code&gt;FULL&lt;/code&gt; ) может вызвать сбои в тупиковой ситуации, если определенные системные каталоги обрабатываются параллельно.</target>
        </trans-unit>
        <trans-unit id="f608b76c0c846a43652d18d27b367a743ac19721" translate="yes" xml:space="preserve">
          <source>Note that weight labels apply to &lt;em&gt;positions&lt;/em&gt;, not &lt;em&gt;lexemes&lt;/em&gt;. If the input vector has been stripped of positions then &lt;code&gt;setweight&lt;/code&gt; does nothing.</source>
          <target state="translated">Обратите внимание, что метки веса применяются к &lt;em&gt;позициям&lt;/em&gt; , а не &lt;em&gt;лексемам&lt;/em&gt; . Если входной вектор был лишен позиций, &lt;code&gt;setweight&lt;/code&gt; ничего не делает.</target>
        </trans-unit>
        <trans-unit id="a501f50ad867471d366c858d1e68c08c9bf71a3b" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;ANALYZE&lt;/code&gt; is run on a partitioned table, all of its partitions are also recursively analyzed as also mentioned in &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;. In that case, &lt;code&gt;ANALYZE&lt;/code&gt; progress is reported first for the parent table, whereby its inheritance statistics are collected, followed by that for each partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb0133d2b01bcc98921dcbe4b4f3b20ca215976" translate="yes" xml:space="preserve">
          <source>Note that when an ACL entry in another catalog is null, it is taken to represent the hard-wired default privileges for its object, &lt;em&gt;not&lt;/em&gt; whatever might be in &lt;code&gt;pg_default_acl&lt;/code&gt; at the moment. &lt;code&gt;pg_default_acl&lt;/code&gt; is only consulted during object creation.</source>
          <target state="translated">Обратите внимание, что когда запись ACL в другом каталоге имеет значение NULL, она используется для представления жестко &lt;code&gt;pg_default_acl&lt;/code&gt; привилегий по умолчанию для его объекта, а &lt;em&gt;не того,&lt;/em&gt; что может быть в pg_default_acl в данный момент. &lt;code&gt;pg_default_acl&lt;/code&gt; используется только во время создания объекта.</target>
        </trans-unit>
        <trans-unit id="2e6cf1460524f06f7b596e4f9001c12f09f21277" translate="yes" xml:space="preserve">
          <source>Note that when autovacuum runs, up to &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; times this memory may be allocated, so be careful not to set the default value too high. It may be useful to control for this by separately setting &lt;a href=&quot;runtime-config-resource#GUC-AUTOVACUUM-WORK-MEM&quot;&gt;autovacuum_work_mem&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что при запуске &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;автоочистки&lt;/a&gt; эта память может быть выделена до autovacuum_max_workers раз, поэтому будьте осторожны, чтобы не установить слишком высокое значение по умолчанию. Может быть полезно контролировать это, отдельно устанавливая &lt;a href=&quot;runtime-config-resource#GUC-AUTOVACUUM-WORK-MEM&quot;&gt;autovacuum_work_mem&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b298d8fd9d5a27445f1547b4987f220ddf522324" translate="yes" xml:space="preserve">
          <source>Note that when multiple rewrite rules are applied in this way, the order of application can be important; so in practice you will want the source query to &lt;code&gt;ORDER BY&lt;/code&gt; some ordering key.</source>
          <target state="translated">Обратите внимание, что когда таким образом применяется несколько правил перезаписи, порядок применения может иметь значение; поэтому на практике вам нужно, чтобы исходный запрос был &lt;code&gt;ORDER BY&lt;/code&gt; некоторому ключу упорядочения.</target>
        </trans-unit>
        <trans-unit id="15b117a19d6af07c7a1d926814d3fa7ed429f962" translate="yes" xml:space="preserve">
          <source>Note that when using nondefault WAL segment sizes, the numbers in the WAL file names are different from the LSNs that are reported by system functions and system views. This option takes a WAL file name, not an LSN.</source>
          <target state="translated">Обратите внимание,что при использовании нестандартных размеров сегментов WAL,номера в именах файлов WAL отличаются от LSN,которые сообщаются системными функциями и системными представлениями.Этот параметр принимает имя файла WAL,а не LSN.</target>
        </trans-unit>
        <trans-unit id="5091d99db40796ae0ac6a127a75124d1c7974a77" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;COPY&lt;/code&gt; allows options such as &lt;code&gt;HEADER&lt;/code&gt; to be specified without a corresponding value, the foreign table option syntax requires a value to be present in all cases. To activate &lt;code&gt;COPY&lt;/code&gt; options typically written without a value, you can pass the value TRUE, since all such options are Booleans.</source>
          <target state="translated">Обратите внимание, что хотя &lt;code&gt;COPY&lt;/code&gt; позволяет указывать такие параметры, как &lt;code&gt;HEADER&lt;/code&gt; , без соответствующего значения, синтаксис параметра сторонней таблицы требует, чтобы значение присутствовало во всех случаях. Чтобы активировать параметры &lt;code&gt;COPY&lt;/code&gt; , обычно записываемые без значения, вы можете передать значение ИСТИНА, поскольку все такие параметры являются логическими.</target>
        </trans-unit>
        <trans-unit id="20e2ed64775c1454506227ebe10642431813ecd2" translate="yes" xml:space="preserve">
          <source>Note that while a table's filenode often matches its OID, this is &lt;em&gt;not&lt;/em&gt; necessarily the case; some operations, like &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt;, can change the filenode while preserving the OID. Avoid assuming that filenode and table OID are the same. Also, for certain system catalogs including &lt;code&gt;pg_class&lt;/code&gt; itself, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfilenode&lt;/code&gt; contains zero. The actual filenode number of these catalogs is stored in a lower-level data structure, and can be obtained using the &lt;code&gt;pg_relation_filenode()&lt;/code&gt; function.</source>
          <target state="translated">Обратите внимание, что хотя файловый узел таблицы часто совпадает с ее OID, это &lt;em&gt;не&lt;/em&gt; всегда так; некоторые операции, такие как &lt;code&gt;TRUNCATE&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; и некоторые формы &lt;code&gt;ALTER TABLE&lt;/code&gt; , могут изменять файловый узел при сохранении OID. Не предполагайте, что файловый узел и OID таблицы совпадают. Кроме того , для некоторых системных каталогов , включая &lt;code&gt;pg_class&lt;/code&gt; сам, &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;relfilenode&lt;/code&gt; содержит ноль. Фактический номер файлового узла этих каталогов хранится в структуре данных нижнего уровня и может быть получен с помощью функции &lt;code&gt;pg_relation_filenode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd42ff3a7dd119700e6cb55e96c90dc5e6fd840" translate="yes" xml:space="preserve">
          <source>Note that while rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">Обратите внимание,что хотя строки можно перемещать с локального раздела на раздел с посторонней таблицей (при условии,что обертка с посторонней информацией поддерживает маршрутизацию кортежей),их нельзя перемещать с раздела с посторонней таблицей на другой раздел.</target>
        </trans-unit>
        <trans-unit id="2d8be16bebefaea4da0b18cb12ca9511981a5205" translate="yes" xml:space="preserve">
          <source>Note that while the above will indeed grant all privileges if executed by a superuser or the owner of &lt;code&gt;kinds&lt;/code&gt;, when executed by someone else it will only grant those permissions for which the someone else has grant options.</source>
          <target state="translated">Обратите внимание, что, хотя приведенное выше действительно предоставит все привилегии, если выполняется суперпользователем или владельцем &lt;code&gt;kinds&lt;/code&gt; , при выполнении кем-то другим он предоставит только те разрешения, для которых у кого-то есть параметры предоставления.</target>
        </trans-unit>
        <trans-unit id="ec3a83831ac9036a3595c6ce5f5e7350a4e67363" translate="yes" xml:space="preserve">
          <source>Note that while this system allows creating collations that &amp;ldquo;ignore case&amp;rdquo; or &amp;ldquo;ignore accents&amp;rdquo; or similar (using the &lt;code&gt;ks&lt;/code&gt; key), in order for such collations to act in a truly case- or accent-insensitive manner, they also need to be declared as not &lt;em&gt;deterministic&lt;/em&gt; in &lt;code&gt;CREATE COLLATION&lt;/code&gt;; see &lt;a href=&quot;collation#COLLATION-NONDETERMINISTIC&quot;&gt;Section 23.2.2.4&lt;/a&gt;. Otherwise, any strings that compare equal according to the collation but are not byte-wise equal will be sorted according to their byte values.</source>
          <target state="translated">Обратите внимание, что хотя эта система позволяет создавать сопоставления, которые &amp;laquo;игнорируют регистр&amp;raquo; или &amp;laquo;игнорируют акценты&amp;raquo; или аналогичные (с использованием ключа &lt;code&gt;ks&lt;/code&gt; ), для того, чтобы такие сопоставления действовали действительно без учета регистра или акцента, они также должны быть объявлен &lt;em&gt;недетерминированным&lt;/em&gt; в &lt;code&gt;CREATE COLLATION&lt;/code&gt; ; см. &lt;a href=&quot;collation#COLLATION-NONDETERMINISTIC&quot;&gt;Раздел 23.2.2.4&lt;/a&gt; . В противном случае любые строки, которые сравниваются равными согласно сопоставлению, но не равны побайтово, будут отсортированы в соответствии с их байтовыми значениями.</target>
        </trans-unit>
        <trans-unit id="84595e2b092724cd7800c2af7679de35fbd01caf" translate="yes" xml:space="preserve">
          <source>Note that with any of these methods, attempting to prewarm more blocks than can be cached &amp;mdash; by the OS when using &lt;code&gt;prefetch&lt;/code&gt; or &lt;code&gt;read&lt;/code&gt;, or by PostgreSQL when using &lt;code&gt;buffer&lt;/code&gt; &amp;mdash; will likely result in lower-numbered blocks being evicted as higher numbered blocks are read in. Prewarmed data also enjoys no special protection from cache evictions, so it is possible that other system activity may evict the newly prewarmed blocks shortly after they are read; conversely, prewarming may also evict other data from cache. For these reasons, prewarming is typically most useful at startup, when caches are largely empty.</source>
          <target state="translated">Обратите внимание, что с помощью любого из этих методов попытка предварительно нагреть больше блоков, чем может быть кэшировано - ОС при использовании &lt;code&gt;prefetch&lt;/code&gt; или &lt;code&gt;read&lt;/code&gt; или PostgreSQL при использовании &lt;code&gt;buffer&lt;/code&gt; - скорее всего, приведет к вытеснению блоков с меньшими номерами при чтении блоков с более высокими номерами. in. Предварительно нагретые данные также не имеют специальной защиты от вытеснения из кэша, поэтому возможно, что другие действия системы могут вытеснить вновь нагретые блоки вскоре после их чтения; и наоборот, предварительное нагревание может также вытеснить другие данные из кеша. По этим причинам предварительное нагревание обычно наиболее полезно при запуске, когда кеши в основном пусты.</target>
        </trans-unit>
        <trans-unit id="e25d9c4fc7da6af49acba3a1d74aecf78d61de9d" translate="yes" xml:space="preserve">
          <source>Note that you can name the collation objects in the SQL environment anything you want. In this example, we follow the naming style that the predefined collations use, which in turn also follow BCP 47, but that is not required for user-defined collations.</source>
          <target state="translated">Обратите внимание,что объекты сверки в среде SQL можно назвать как угодно.В этом примере мы следуем стилю именования,который используется в предопределенных коллизиях,которые,в свою очередь,также следуют за BCP 47,но это не требуется для определяемых пользователем коллизий.</target>
        </trans-unit>
        <trans-unit id="d9f6471c0f24b8d6760419402c171355a4484c03" translate="yes" xml:space="preserve">
          <source>Note that you must execute this command while logged into the PostgreSQL user account, which is described in the previous section.</source>
          <target state="translated">Обратите внимание,что вы должны выполнить эту команду во время входа в аккаунт пользователя PostgreSQL,что описано в предыдущем разделе.</target>
        </trans-unit>
        <trans-unit id="bb0a6a455313edbad71a60b25303151964bacc15" translate="yes" xml:space="preserve">
          <source>Note that you should also create an index with the default operator class if you want queries involving ordinary &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt; comparisons to use an index. Such queries cannot use the &lt;code&gt;xxx_pattern_ops&lt;/code&gt; operator classes. (Ordinary equality comparisons can use these operator classes, however.) It is possible to create multiple indexes on the same column with different operator classes. If you do use the C locale, you do not need the &lt;code&gt;xxx_pattern_ops&lt;/code&gt; operator classes, because an index with the default operator class is usable for pattern-matching queries in the C locale.</source>
          <target state="translated">Обратите внимание, что вам также следует создать индекс с классом операторов по умолчанию, если вы хотите, чтобы запросы, включающие обычные сравнения &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;gt;=&lt;/code&gt; , использовали индекс. В таких запросах нельзя использовать &lt;code&gt;xxx_pattern_ops&lt;/code&gt; операторов xxx_pattern_ops . (Однако эти классы операторов могут использоваться при обычном сравнении на равенство.) Можно создать несколько индексов в одном столбце с разными классами операторов. Если вы действительно используете языковой стандарт C, вам не нужны &lt;code&gt;xxx_pattern_ops&lt;/code&gt; операторов xxx_pattern_ops , потому что индекс с классом оператора по умолчанию может использоваться для запросов сопоставления с образцом в локали C.</target>
        </trans-unit>
        <trans-unit id="a9ac1561fc3ccdadc787e0b99a4aeb85f57a226f" translate="yes" xml:space="preserve">
          <source>Note that, for the purposes of combining multiple policies, &lt;code&gt;ALL&lt;/code&gt; policies are treated as having the same type as whichever other type of policy is being applied.</source>
          <target state="translated">Обратите внимание, что в целях объединения нескольких политик &lt;code&gt;ALL&lt;/code&gt; политики рассматриваются как имеющие тот же тип, что и любой другой тип политики, применяемый.</target>
        </trans-unit>
        <trans-unit id="0ce85a00735b68da34a1fd226cafeaa370c6ae8f" translate="yes" xml:space="preserve">
          <source>Note the relatively large number of false positives: 2439 rows were selected to be visited in the heap, but none actually matched the query. We could reduce that by specifying a larger signature length. In this example, creating the index with &lt;code&gt;length=200&lt;/code&gt; reduced the number of false positives to 55; but it doubled the index size (to 306 MB) and ended up being slower for this query (125 ms overall).</source>
          <target state="translated">Обратите внимание на относительно большое количество ложных срабатываний: для посещения было выбрано 2439 строк в куче, но ни одна из них не соответствовала запросу. Мы могли бы уменьшить это, указав большую длину подписи. В этом примере создание индекса с &lt;code&gt;length=200&lt;/code&gt; уменьшило количество ложных срабатываний до 55; но он удвоил размер индекса (до 306 МБ) и оказался медленнее для этого запроса (всего 125 мс).</target>
        </trans-unit>
        <trans-unit id="ad6486d9d7802af73d40de7a1e56de198a7926a1" translate="yes" xml:space="preserve">
          <source>Note the use of the double underline in the probe name. In a DTrace script using the probe, the double underline needs to be replaced with a hyphen, so &lt;code&gt;transaction-start&lt;/code&gt; is the name to document for users.</source>
          <target state="translated">Обратите внимание на использование двойного подчеркивания в названии зонда. В сценарии DTrace, использующем зонд, двойное подчеркивание необходимо заменить дефисом, поэтому имя &lt;code&gt;transaction-start&lt;/code&gt; должно быть документировано для пользователей.</target>
        </trans-unit>
        <trans-unit id="6d65457512b308441a74c7c138c05193c57c7bb6" translate="yes" xml:space="preserve">
          <source>Note there can be ambiguity in the &lt;code&gt;months&lt;/code&gt; field returned by &lt;code&gt;age&lt;/code&gt; because different months have different numbers of days. PostgreSQL's approach uses the month from the earlier of the two dates when calculating partial months. For example, &lt;code&gt;age('2004-06-01', '2004-04-30')&lt;/code&gt; uses April to yield &lt;code&gt;1 mon 1 day&lt;/code&gt;, while using May would yield &lt;code&gt;1 mon 2 days&lt;/code&gt; because May has 31 days, while April has only 30.</source>
          <target state="translated">Обратите внимание, что поле &lt;code&gt;months&lt;/code&gt; возвращаемое по &lt;code&gt;age&lt;/code&gt; может быть неоднозначным, поскольку в разных месяцах разное количество дней. Подход PostgreSQL использует месяц от более ранней из двух дат при вычислении неполных месяцев. Например, &lt;code&gt;age('2004-06-01', '2004-04-30')&lt;/code&gt; использует апрель для получения &lt;code&gt;1 mon 1 day&lt;/code&gt; , а использование May даст &lt;code&gt;1 mon 2 days&lt;/code&gt; потому что в мае 31 день, а в апреле - только 30. .</target>
        </trans-unit>
        <trans-unit id="1afbaf202c9ac2c26c7604e3bc2b4bbf35293589" translate="yes" xml:space="preserve">
          <source>Note, however, that the SQL/MED functionality as a whole is not yet conforming.</source>
          <target state="translated">Отметим,однако,что функциональность SQL/MED в целом еще не соответствует.</target>
        </trans-unit>
        <trans-unit id="ccd71e26f3c643a05b48c9814bdace2e62bf73fd" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;ltxtquery&lt;/code&gt; allows whitespace between symbols, but &lt;code&gt;ltree&lt;/code&gt; and &lt;code&gt;lquery&lt;/code&gt; do not.</source>
          <target state="translated">Примечание: &lt;code&gt;ltxtquery&lt;/code&gt; допускает пробелы между символами, а &lt;code&gt;ltree&lt;/code&gt; и &lt;code&gt;lquery&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="b12db1dd6e1d08b3916e0fb99c42096b024c7157" translate="yes" xml:space="preserve">
          <source>Note: This index type is lossy.</source>
          <target state="translated">Примечание:Этот тип индекса является убыточным.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9128e4dc19fdcbce3767684f6724986d863634bf" translate="yes" xml:space="preserve">
          <source>Notes for Windows Users</source>
          <target state="translated">Примечания для пользователей Windows</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="070bd4d20a16681cab0fd80e64bbfd09232b5422" translate="yes" xml:space="preserve">
          <source>Notice here that we don't need to (and indeed cannot) put parentheses around the column name appearing just after &lt;code&gt;SET&lt;/code&gt;, but we do need parentheses when referencing the same column in the expression to the right of the equal sign.</source>
          <target state="translated">Обратите внимание, что нам не нужно (да и не может) заключать в круглые скобки имя столбца, появляющееся сразу после &lt;code&gt;SET&lt;/code&gt; , но нам нужны круглые скобки при ссылке на тот же столбец в выражении справа от знака равенства.</target>
        </trans-unit>
        <trans-unit id="4daabf40dd7349fdbfe5f996ee7218e2e875bd85" translate="yes" xml:space="preserve">
          <source>Notice how the &lt;code&gt;AS&lt;/code&gt; clause is used to relabel the output column. (The &lt;code&gt;AS&lt;/code&gt; clause is optional.)</source>
          <target state="translated">Обратите внимание, как предложение &lt;code&gt;AS&lt;/code&gt; используется для изменения метки выходного столбца. (Предложение &lt;code&gt;AS&lt;/code&gt; является необязательным.)</target>
        </trans-unit>
        <trans-unit id="6e1ea47811c08b80c4e6755f65407fcd8d137657" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;BETWEEN&lt;/code&gt; treats the endpoint values as included in the range. &lt;code&gt;BETWEEN SYMMETRIC&lt;/code&gt; is like &lt;code&gt;BETWEEN&lt;/code&gt; except there is no requirement that the argument to the left of &lt;code&gt;AND&lt;/code&gt; be less than or equal to the argument on the right. If it is not, those two arguments are automatically swapped, so that a nonempty range is always implied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa7b0c69e4931a2ff5fa82ad77b7c14b3d74a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;BETWEEN&lt;/code&gt; treats the endpoint values as included in the range. &lt;code&gt;NOT BETWEEN&lt;/code&gt; does the opposite comparison:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;BETWEEN&lt;/code&gt; обрабатывает значения конечных точек как включенные в диапазон. &lt;code&gt;NOT BETWEEN&lt;/code&gt; выполняет противоположное сравнение:</target>
        </trans-unit>
        <trans-unit id="8240947764f6659f2796d4acf4007ac22ad3a1c1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;supernova star&lt;/code&gt; matches &lt;code&gt;supernovae stars&lt;/code&gt; in &lt;code&gt;thesaurus_astro&lt;/code&gt; because we specified the &lt;code&gt;english_stem&lt;/code&gt; stemmer in the thesaurus definition. The stemmer removed the &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;supernova star&lt;/code&gt; матчи &lt;code&gt;supernovae stars&lt;/code&gt; в &lt;code&gt;thesaurus_astro&lt;/code&gt; , потому что мы указали &lt;code&gt;english_stem&lt;/code&gt; стеммер в определении тезауруса. Стеммер удалил &lt;code&gt;e&lt;/code&gt; и &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89eb1ae6972d1166d8e27e8ffc5a4983fca12820" translate="yes" xml:space="preserve">
          <source>Notice that although the recursive view's name is schema-qualified in this &lt;code&gt;CREATE&lt;/code&gt;, its internal self-reference is not schema-qualified. This is because the implicitly-created CTE's name cannot be schema-qualified.</source>
          <target state="translated">Обратите внимание, что хотя имя рекурсивного представления уточнено схемой в этом &lt;code&gt;CREATE&lt;/code&gt; , его внутренняя ссылка на себя не уточнена схемой. Это связано с тем, что имя неявно созданного CTE не может быть дополнено схемой.</target>
        </trans-unit>
        <trans-unit id="c36fb1e9faaa2ef2c027bbd666eb850c4abbeb31" translate="yes" xml:space="preserve">
          <source>Notice that except for the two-argument form of &lt;code&gt;enum_range&lt;/code&gt;, these functions disregard the specific value passed to them; they care only about its declared data type. Either null or a specific value of the type can be passed, with the same result. It is more common to apply these functions to a table column or function argument than to a hardwired type name as suggested by the examples.</source>
          <target state="translated">Обратите внимание, что, за исключением формы &lt;code&gt;enum_range&lt;/code&gt; с двумя аргументами , эти функции игнорируют конкретное значение, переданное им; они заботятся только о его объявленном типе данных. Можно передать либо null, либо конкретное значение типа с тем же результатом. Эти функции чаще применяются к столбцу таблицы или аргументу функции, чем к имени фиксированного типа, как это предлагается в примерах.</target>
        </trans-unit>
        <trans-unit id="fb75cf9e722bdf4111edc3be58d21f8a3427f3ff" translate="yes" xml:space="preserve">
          <source>Notice that except for the two-argument form of &lt;code&gt;enum_range&lt;/code&gt;, these functions disregard the specific value passed to them; they care only about its declared data type. Either null or a specific value of the type can be passed, with the same result. It is more common to apply these functions to a table column or function argument than to a hardwired type name as used in the examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7db9efeeec80f82f8d01c7d6c915db40d7ca58" translate="yes" xml:space="preserve">
          <source>Notice that here the planner has chosen to &amp;ldquo;materialize&amp;rdquo; the inner relation of the join, by putting a Materialize plan node atop it. This means that the &lt;code&gt;t2&lt;/code&gt; index scan will be done just once, even though the nested-loop join node needs to read that data ten times, once for each row from the outer relation. The Materialize node saves the data in memory as it's read, and then returns the data from memory on each subsequent pass.</source>
          <target state="translated">Обратите внимание, что здесь планировщик решил &amp;laquo;материализовать&amp;raquo; внутреннюю связь соединения, поместив на него узел плана Материализовать. Это означает, что сканирование индекса &lt;code&gt;t2&lt;/code&gt; будет выполнено только один раз, даже несмотря на то, что узел соединения с вложенным циклом должен прочитать эти данные десять раз, по одному разу для каждой строки из внешнего отношения. Узел материализации сохраняет данные в памяти по мере их чтения, а затем возвращает данные из памяти на каждом последующем проходе.</target>
        </trans-unit>
        <trans-unit id="4bf689adc2caa48f04b5854bba37632c664406c0" translate="yes" xml:space="preserve">
          <source>Notice that in both &lt;code&gt;ROWS&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; mode, &lt;code&gt;0 PRECEDING&lt;/code&gt; and &lt;code&gt;0 FOLLOWING&lt;/code&gt; are equivalent to &lt;code&gt;CURRENT ROW&lt;/code&gt;. This normally holds in &lt;code&gt;RANGE&lt;/code&gt; mode as well, for an appropriate data-type-specific meaning of &amp;ldquo;zero&amp;rdquo;.</source>
          <target state="translated">Обратите внимание , что в обоих &lt;code&gt;ROWS&lt;/code&gt; и &lt;code&gt;GROUPS&lt;/code&gt; режиме &lt;code&gt;0 PRECEDING&lt;/code&gt; и &lt;code&gt;0 FOLLOWING&lt;/code&gt; эквивалентны &lt;code&gt;CURRENT ROW&lt;/code&gt; . Это обычно также выполняется в режиме &lt;code&gt;RANGE&lt;/code&gt; для соответствующего значения &amp;laquo;ноль&amp;raquo; для конкретного типа данных.</target>
        </trans-unit>
        <trans-unit id="944ef29330d1f49189c08507e0ff3ef14adbfe93" translate="yes" xml:space="preserve">
          <source>Notice that inside the dollar-quoted string, single quotes can be used without needing to be escaped. Indeed, no characters inside a dollar-quoted string are ever escaped: the string content is always written literally. Backslashes are not special, and neither are dollar signs, unless they are part of a sequence matching the opening tag.</source>
          <target state="translated">Обратите внимание,что внутри строки,котируемой в долларах,можно использовать одиночные котировки без необходимости экранирования.Действительно,ни один символ внутри строки,заключенной в доллар,никогда не экранируется:содержимое строки всегда пишется буквально.Пробелы не являются особыми и знаки доллара тоже не являются знаками доллара,если только они не являются частью последовательности,соответствующей открывающему тегу.</target>
        </trans-unit>
        <trans-unit id="f68a4013d1520908a834c3452585e4c0680f0866" translate="yes" xml:space="preserve">
          <source>Notice that placing the restriction in the &lt;code&gt;WHERE&lt;/code&gt; clause produces a different result:</source>
          <target state="translated">Обратите внимание, что размещение ограничения в &lt;code&gt;WHERE&lt;/code&gt; дает другой результат:</target>
        </trans-unit>
        <trans-unit id="d13f7a26b5cfa0ec363a717ba07bad2b152f0f72" translate="yes" xml:space="preserve">
          <source>Notice that the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; is used. Only text search functions that specify a configuration name can be used in expression indexes (&lt;a href=&quot;indexes-expressional&quot;&gt;Section 11.7&lt;/a&gt;). This is because the index contents must be unaffected by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;. If they were affected, the index contents might be inconsistent because different entries could contain &lt;code&gt;tsvector&lt;/code&gt;s that were created with different text search configurations, and there would be no way to guess which was which. It would be impossible to dump and restore such an index correctly.</source>
          <target state="translated">Обратите внимание, что используется версия &lt;code&gt;to_tsvector&lt;/code&gt; с двумя аргументами . В индексах выражений можно использовать только функции текстового поиска, которые задают имя конфигурации ( &lt;a href=&quot;indexes-expressional&quot;&gt;раздел 11.7&lt;/a&gt; ). Это связано с тем, что &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; не должен влиять на содержимое индекса . Если бы они были затронуты, содержимое индекса могло бы быть несовместимым, потому что разные записи могли бы содержать &lt;code&gt;tsvector&lt;/code&gt; , которые были созданы с разными конфигурациями текстового поиска, и не было бы способа угадать, что было каким. Сбросить и восстановить такой индекс правильно было бы невозможно.</target>
        </trans-unit>
        <trans-unit id="4b9c07bbe048665c89925c842ae22cd1fc6040f9" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;DROP&lt;/code&gt; syntax only specifies the &amp;ldquo;slot&amp;rdquo; in the operator family, by strategy or support number and input data type(s). The name of the operator or function occupying the slot is not mentioned. Also, for &lt;code&gt;DROP FUNCTION&lt;/code&gt; the type(s) to specify are the input data type(s) the function is intended to support; for GiST, SP-GiST and GIN indexes this might have nothing to do with the actual input argument types of the function.</source>
          <target state="translated">Обратите внимание, что синтаксис &lt;code&gt;DROP&lt;/code&gt; определяет только &amp;laquo;слот&amp;raquo; в семействе операторов, по стратегии или номеру поддержки и типу (-ам) входных данных. Имя оператора или функции, занимающей слот, не упоминается. Кроме того, для &lt;code&gt;DROP FUNCTION&lt;/code&gt; тип (ы), который нужно указать, - это тип (ы) входных данных, которые функция предназначена для поддержки; для индексов GiST, SP-GiST и GIN это может не иметь ничего общего с фактическими типами входных аргументов функции.</target>
        </trans-unit>
        <trans-unit id="051e5841933239126fb981b1dfd93c63aee12913" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;EXPLAIN&lt;/code&gt; output shows the &lt;code&gt;WHERE&lt;/code&gt; clause being applied as a &amp;ldquo;filter&amp;rdquo; condition attached to the Seq Scan plan node. This means that the plan node checks the condition for each row it scans, and outputs only the ones that pass the condition. The estimate of output rows has been reduced because of the &lt;code&gt;WHERE&lt;/code&gt; clause. However, the scan will still have to visit all 10000 rows, so the cost hasn't decreased; in fact it has gone up a bit (by 10000 * &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;, to be exact) to reflect the extra CPU time spent checking the &lt;code&gt;WHERE&lt;/code&gt; condition.</source>
          <target state="translated">Обратите внимание, что выходные данные &lt;code&gt;EXPLAIN&lt;/code&gt; показывают, что &lt;code&gt;WHERE&lt;/code&gt; применяется как условие &amp;laquo;фильтрации&amp;raquo;, прикрепленное к узлу плана сканирования Seq. Это означает, что узел плана проверяет условие для каждой сканируемой строки и выводит только те, которые соответствуют условию. Оценка выходных строк была уменьшена из-за &lt;code&gt;WHERE&lt;/code&gt; . Однако сканирование все равно должно будет пройти все 10000 строк, поэтому стоимость не снизилась; на самом деле он немного вырос (на 10000 * &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt; , если быть точным), чтобы отразить дополнительное время процессора, потраченное на проверку условия &lt;code&gt;WHERE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d34da680054f05253f7563479166aab9f149ee00" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;WITH&lt;/code&gt; query was evaluated only once, so that we got two sets of the same three random values.</source>
          <target state="translated">Обратите внимание, что запрос &lt;code&gt;WITH&lt;/code&gt; был оценен только один раз, поэтому мы получили два набора одинаковых трех случайных значений.</target>
        </trans-unit>
        <trans-unit id="51724582644bab73340aa6c622d37155c5257732" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;picksplit&lt;/code&gt; function's result is delivered by modifying the passed-in &lt;code&gt;v&lt;/code&gt; structure. The return value per se is ignored, though it's conventional to pass back the address of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;picksplit&lt;/code&gt; функции picksplit доставляется путем изменения переданной структуры &lt;code&gt;v&lt;/code&gt; . Само по себе возвращаемое значение игнорируется, хотя обычно возвращается адрес &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf156003e881a5db213ca4ff342d316a104a89cc" translate="yes" xml:space="preserve">
          <source>Notice that the above commands specify copying the &lt;code&gt;template0&lt;/code&gt; database. When copying any other database, the encoding and locale settings cannot be changed from those of the source database, because that might result in corrupt data. For more information see &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что приведенные выше команды определяют копирование базы данных &lt;code&gt;template0&lt;/code&gt; . При копировании любой другой базы данных нельзя изменить настройки кодировки и локали по сравнению с исходной базой данных, поскольку это может привести к повреждению данных. Для получения дополнительной информации см. &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Раздел 22.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8cdb89e02698866354e5dd11605d6eb9295c222" translate="yes" xml:space="preserve">
          <source>Notice that the array elements are ordinary SQL constants or expressions; for instance, string literals are single quoted, instead of double quoted as they would be in an array literal. The &lt;code&gt;ARRAY&lt;/code&gt; constructor syntax is discussed in more detail in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;Section 4.2.12&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что элементы массива являются обычными константами или выражениями SQL; например, строковые литералы заключаются в одинарные кавычки, а не в двойные, как в литерале массива. &lt;code&gt;ARRAY&lt;/code&gt; синтаксис конструктора обсуждается более подробно в &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;разделе 4.2.12&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66469b4e59f919ba275ed4a6fda1a4c5c23cd621" translate="yes" xml:space="preserve">
          <source>Notice that the individual subcommands do not end with semicolons.</source>
          <target state="translated">Обратите внимание,что отдельные подкоманды не заканчиваются точкой с запятой.</target>
        </trans-unit>
        <trans-unit id="3160def781e659e6cdc752185f9870b36c8a345f" translate="yes" xml:space="preserve">
          <source>Notice that the number of rows estimated to be returned from the bitmap index scan reflects only the condition used with the index; this is important since it affects the cost estimate for the subsequent heap fetches.</source>
          <target state="translated">Обратите внимание,что количество строк,которое предполагается вернуть в результате сканирования растрового индекса,отражает только условие,используемое с индексом;это важно,так как влияет на оценку стоимости последующих захватов кучи.</target>
        </trans-unit>
        <trans-unit id="873a445a12a2fae4f43b1f16da917ba94ef395cb" translate="yes" xml:space="preserve">
          <source>Notice that the owner's implicit grant options are not marked in the access privileges display. A &lt;code&gt;*&lt;/code&gt; will appear only when grant options have been explicitly granted to someone.</source>
          <target state="translated">Обратите внимание, что неявные параметры предоставления владельцем не отмечены на экране прав доступа. Значок &lt;code&gt;*&lt;/code&gt; появится только в том случае, если кому-то были явно предоставлены варианты предоставления.</target>
        </trans-unit>
        <trans-unit id="bf407e6deb6991a0a95054bdc8f3340e9ff64b36" translate="yes" xml:space="preserve">
          <source>Notice that the period (&lt;code&gt;.&lt;/code&gt;) is not a metacharacter for &lt;code&gt;SIMILAR TO&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что точка ( &lt;code&gt;.&lt;/code&gt; ) Не является метасимволом для &lt;code&gt;SIMILAR TO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74768806db56cf6b766037079dc057b3f23de85a" translate="yes" xml:space="preserve">
          <source>Notice that the primary key overlaps with the foreign keys in the last table.</source>
          <target state="translated">Обратите внимание,что первичный ключ пересекается с инородными ключами в последней таблице.</target>
        </trans-unit>
        <trans-unit id="8e2f5e5785b45b8d6d5aee74a3bd7e8d7b7e0944" translate="yes" xml:space="preserve">
          <source>Notice that this example defines the &lt;code&gt;page_count&lt;/code&gt; result column as an integer. The function deals internally with string representations, so when you say you want an integer in the output, it will take the string representation of the XPath result and use PostgreSQL input functions to transform it into an integer (or whatever type the &lt;code&gt;AS&lt;/code&gt; clause requests). An error will result if it can't do this &amp;mdash; for example if the result is empty &amp;mdash; so you may wish to just stick to &lt;code&gt;text&lt;/code&gt; as the column type if you think your data has any problems.</source>
          <target state="translated">Обратите внимание, что в этом примере &lt;code&gt;page_count&lt;/code&gt; результата page_count определяется как целое число. Функция имеет дело со строковыми представлениями внутри, поэтому, когда вы говорите, что хотите получить целое число на выходе, она будет принимать строковое представление результата XPath и использовать функции ввода PostgreSQL для преобразования его в целое число (или любой другой тип , запрашиваемый предложением &lt;code&gt;AS&lt;/code&gt; ). . Если этого не произойдет, возникнет ошибка - например, если результат будет пустым - поэтому вы можете просто использовать &lt;code&gt;text&lt;/code&gt; в качестве типа столбца, если считаете, что с вашими данными есть проблемы.</target>
        </trans-unit>
        <trans-unit id="8b9217ccd836ba1fba783902d277384da15bf50d" translate="yes" xml:space="preserve">
          <source>Notice that we showed &lt;code&gt;inner_cardinality&lt;/code&gt; as 10000, that is, the unmodified size of &lt;code&gt;tenk2&lt;/code&gt;. It might appear from inspection of the &lt;code&gt;EXPLAIN&lt;/code&gt; output that the estimate of join rows comes from 50 * 1, that is, the number of outer rows times the estimated number of rows obtained by each inner index scan on &lt;code&gt;tenk2&lt;/code&gt;. But this is not the case: the join relation size is estimated before any particular join plan has been considered. If everything is working well then the two ways of estimating the join size will produce about the same answer, but due to round-off error and other factors they sometimes diverge significantly.</source>
          <target state="translated">Обратите внимание, что мы показали &lt;code&gt;inner_cardinality&lt;/code&gt; как 10000, то есть неизмененный размер &lt;code&gt;tenk2&lt;/code&gt; . Из просмотра выходных данных &lt;code&gt;EXPLAIN&lt;/code&gt; может показаться, что оценка строк соединения получается из 50 * 1, то есть количество внешних строк, умноженное на расчетное количество строк, полученных при каждом сканировании внутреннего индекса на &lt;code&gt;tenk2&lt;/code&gt; . Но это не так: размер отношения соединения оценивается до рассмотрения какого-либо конкретного плана соединения. Если все работает хорошо, то два способа оценки размера соединения дадут примерно одинаковый ответ, но из-за ошибки округления и других факторов они иногда значительно расходятся.</target>
        </trans-unit>
        <trans-unit id="159dfc60dcca0632285615def5fab2a023373a94" translate="yes" xml:space="preserve">
          <source>Notice that while the plain (unaggregated) log file shows which script was used for each transaction, the aggregated log does not. Therefore if you need per-script data, you need to aggregate the data on your own.</source>
          <target state="translated">Обратите внимание,что в то время как простой (недезагрегированный)файл журнала показывает,какой сценарий использовался для каждой операции,агрегированный журнал этого не делает.Поэтому,если вам нужны данные по каждому сценарию,то вам необходимо агрегировать данные самостоятельно.</target>
        </trans-unit>
        <trans-unit id="99369cd02fa72e17001071790856a797298fed53" translate="yes" xml:space="preserve">
          <source>Notice the typical form of recursive queries: an initial condition, followed by &lt;code&gt;UNION&lt;/code&gt;, followed by the recursive part of the query. Be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. (See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; for more examples.)</source>
          <target state="translated">Обратите внимание на типичную форму рекурсивных запросов: начальное условие, за которым следует &lt;code&gt;UNION&lt;/code&gt; , за которым следует рекурсивная часть запроса. Убедитесь, что рекурсивная часть запроса в конечном итоге не вернет кортежи, иначе запрос будет повторяться бесконечно. (Дополнительные примеры см. В &lt;a href=&quot;queries-with&quot;&gt;Разделе 7.8&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="085506905d3dc520376505271fd3c45af0c829eb" translate="yes" xml:space="preserve">
          <source>Notice we don't use &lt;code&gt;-C&lt;/code&gt;, and instead connect directly to the database to be restored into. Also note that we clone the new database from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, to ensure it is initially empty.</source>
          <target state="translated">Обратите внимание, что мы не используем &lt;code&gt;-C&lt;/code&gt; , а вместо этого подключаемся напрямую к базе данных, в которую нужно восстановить. Также обратите внимание, что мы клонируем новую базу данных из &lt;code&gt;template0&lt;/code&gt; ,а не из &lt;code&gt;template1&lt;/code&gt; , чтобы убедиться, что она изначально пуста.</target>
        </trans-unit>
        <trans-unit id="bb9bfefd5391f52be54267e2a938a126661b0ff7" translate="yes" xml:space="preserve">
          <source>Nov</source>
          <target state="translated">Nov</target>
        </trans-unit>
        <trans-unit id="3c5bf776f5efcaa22d6e0fd4839db7d2b83e52be" translate="yes" xml:space="preserve">
          <source>November</source>
          <target state="translated">November</target>
        </trans-unit>
        <trans-unit id="0ffcf97fe0b617e1a1fb0f97e1a88d84bed8f352" translate="yes" xml:space="preserve">
          <source>Now consider the same query, but with a constant that is not in the MCV list:</source>
          <target state="translated">Теперь рассмотрим тот же самый запрос,но с константой,которой нет в списке MCV:</target>
        </trans-unit>
        <trans-unit id="1101583b5cab5dfe73a02721963b60a84711fcd9" translate="yes" xml:space="preserve">
          <source>Now it is impossible to create orders with non-NULL &lt;code&gt;product_no&lt;/code&gt; entries that do not appear in the products table.</source>
          <target state="translated">Теперь невозможно создавать заказы с записями &lt;code&gt;product_no&lt;/code&gt; , отличными от NULL, которые не отображаются в таблице товаров.</target>
        </trans-unit>
        <trans-unit id="05189fbbab4b515fc19f955242b1b42d3dc53c9c" translate="yes" xml:space="preserve">
          <source>Now it is possible to bind the thesaurus dictionary &lt;code&gt;thesaurus_simple&lt;/code&gt; to the desired token types in a configuration, for example:</source>
          <target state="translated">Теперь можно привязать словарь &lt;code&gt;thesaurus_simple&lt;/code&gt; к нужным типам токенов в конфигурации, например:</target>
        </trans-unit>
        <trans-unit id="14b6efa33e8cde1d203d7549fcab8edf43d173c9" translate="yes" xml:space="preserve">
          <source>Now it is possible to create a foreign table with &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. In this example we wish to access the table named &lt;code&gt;some_schema.some_table&lt;/code&gt; on the remote server. The local name for it will be &lt;code&gt;foreign_table&lt;/code&gt;:</source>
          <target state="translated">Теперь можно создать стороннюю таблицу с помощью &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; . В этом примере мы хотим получить доступ к таблице с именем &lt;code&gt;some_schema.some_table&lt;/code&gt; на удаленном сервере. Местное имя для него будет &lt;code&gt;foreign_table&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dd96a87b36842da43e36de2200fdfc1838f0e684" translate="yes" xml:space="preserve">
          <source>Now let's add another condition to the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">Теперь давайте добавим еще одно условие в &lt;code&gt;WHERE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="95432c22f405504df2d81a0fb2d4efc9ca2560c4" translate="yes" xml:space="preserve">
          <source>Now let's consider a case with more than one condition in the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">Теперь рассмотрим случай с более чем одним условием в &lt;code&gt;WHERE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0a0a72cb219eba72676d0750f57b70ee142cf22" translate="yes" xml:space="preserve">
          <source>Now let's modify the query to add a &lt;code&gt;WHERE&lt;/code&gt; condition:</source>
          <target state="translated">Теперь давайте изменим запрос, добавив условие &lt;code&gt;WHERE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="47c1122f650e2dbfda8bc7f189317df3657e8635" translate="yes" xml:space="preserve">
          <source>Now look at the table definition again:</source>
          <target state="translated">Теперь посмотрите еще раз на определение таблицы:</target>
        </trans-unit>
        <trans-unit id="d6a6836d17a53567c7bdd65d95a74e120c1311f5" translate="yes" xml:space="preserve">
          <source>Now suppose that &lt;code&gt;alice&lt;/code&gt; wishes to change the &amp;ldquo;slightly secret&amp;rdquo; information, but decides that &lt;code&gt;mallory&lt;/code&gt; should not be trusted with the new content of that row, so she does:</source>
          <target state="translated">Теперь предположим, что &lt;code&gt;alice&lt;/code&gt; желает изменить &amp;laquo;слегка секретную&amp;raquo; информацию, но решает, что &lt;code&gt;mallory&lt;/code&gt; не следует доверять новое содержимое этой строки, поэтому она делает:</target>
        </trans-unit>
        <trans-unit id="9c4ea909bc20a14cf1d5201600f80228a4642b36" translate="yes" xml:space="preserve">
          <source>Now the parenthesized object is correctly interpreted as a reference to the &lt;code&gt;item&lt;/code&gt; column, and then the subfield can be selected from it.</source>
          <target state="translated">Теперь объект в скобках правильно интерпретируется как ссылка на столбец &lt;code&gt;item&lt;/code&gt; , и тогда из него можно выбрать подполе.</target>
        </trans-unit>
        <trans-unit id="deae757ce21f92bbc32823a914fbc837ca56a164" translate="yes" xml:space="preserve">
          <source>Now this is fine for PostgreSQL-specific applications, but standard code using JDBC or ODBC won't delete the objects, resulting in orphan objects &amp;mdash; objects that are not referenced by anything, and simply occupy disk space.</source>
          <target state="translated">Теперь это нормально для приложений, специфичных для PostgreSQL, но стандартный код, использующий JDBC или ODBC, не удаляет объекты, что приводит к появлению бесхозных объектов - объектов, на которые ничто не ссылается, а просто занимает дисковое пространство.</target>
        </trans-unit>
        <trans-unit id="084bd00ac798eb5161b956e1962a53497a37531c" translate="yes" xml:space="preserve">
          <source>Now try inserting an invalid record:</source>
          <target state="translated">Теперь попробуй вставить недействительную запись:</target>
        </trans-unit>
        <trans-unit id="5458bef284659cf16721d439d4b767332bf554fc" translate="yes" xml:space="preserve">
          <source>Now we are ready to perform a fast full text search:</source>
          <target state="translated">Теперь мы готовы выполнить быстрый полнотекстовый поиск:</target>
        </trans-unit>
        <trans-unit id="a02f5ffaa75cbfc6c6328ab3a75ec757069f839c" translate="yes" xml:space="preserve">
          <source>Now we can see how it works. &lt;code&gt;ts_lexize&lt;/code&gt; is not very useful for testing a thesaurus, because it treats its input as a single token. Instead we can use &lt;code&gt;plainto_tsquery&lt;/code&gt; and &lt;code&gt;to_tsvector&lt;/code&gt; which will break their input strings into multiple tokens:</source>
          <target state="translated">Теперь мы можем увидеть, как это работает. &lt;code&gt;ts_lexize&lt;/code&gt; не очень полезен для тестирования тезауруса, потому что он обрабатывает входные данные как один токен. Вместо этого мы можем использовать &lt;code&gt;plainto_tsquery&lt;/code&gt; и &lt;code&gt;to_tsvector&lt;/code&gt; , которые разбивают их входные строки на несколько токенов:</target>
        </trans-unit>
        <trans-unit id="18b6223b0641dfa27780508785b1cab41976292c" translate="yes" xml:space="preserve">
          <source>Now we can set up the mappings for words in configuration &lt;code&gt;pg&lt;/code&gt;:</source>
          <target state="translated">Теперь мы можем настроить сопоставления для слов в конфигурации &lt;code&gt;pg&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b4d3c996fedace29e66a9cecc69860990e5567d4" translate="yes" xml:space="preserve">
          <source>Now we can show some &lt;code&gt;INSERT&lt;/code&gt; statements:</source>
          <target state="translated">Теперь мы можем показать несколько операторов &lt;code&gt;INSERT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9811d50e24107f487d484ef3d4f8590f2676cba5" translate="yes" xml:space="preserve">
          <source>Now we can test our configuration:</source>
          <target state="translated">Теперь мы можем проверить нашу конфигурацию:</target>
        </trans-unit>
        <trans-unit id="ace10f4ace4cfabef3a16f550a37af5ffc6dcce7" translate="yes" xml:space="preserve">
          <source>Now we can test our dictionary:</source>
          <target state="translated">Теперь мы можем проверить наш словарь:</target>
        </trans-unit>
        <trans-unit id="f27c4f52d858064037f2d98b4e6143af1fdd5e4c" translate="yes" xml:space="preserve">
          <source>Now we change the prompt to something more interesting:</source>
          <target state="translated">Теперь мы меняем подсказку на что-то более интересное:</target>
        </trans-unit>
        <trans-unit id="d4a301c61d4f0a929427d7399e79093ab65b2312" translate="yes" xml:space="preserve">
          <source>Now we will figure out how we can get the Hayward records back in. What we want the query to do is to scan the &lt;code&gt;weather&lt;/code&gt; table and for each row to find the matching &lt;code&gt;cities&lt;/code&gt; row(s). If no matching row is found we want some &amp;ldquo;empty values&amp;rdquo; to be substituted for the &lt;code&gt;cities&lt;/code&gt; table's columns. This kind of query is called an &lt;em&gt;outer join&lt;/em&gt;. (The joins we have seen so far are inner joins.) The command looks like this:</source>
          <target state="translated">Теперь мы выясним, как мы можем вернуть записи Хейворда. Нам нужно, чтобы запрос выполнял сканирование таблицы &lt;code&gt;weather&lt;/code&gt; и для каждой строки поиск соответствующих строк (строк) с &lt;code&gt;cities&lt;/code&gt; . Если соответствующая строка не найдена, мы хотим, чтобы некоторые &amp;laquo;пустые значения&amp;raquo; были заменены столбцами таблицы &lt;code&gt;cities&lt;/code&gt; . Такой тип запроса называется &lt;em&gt;внешним соединением&lt;/em&gt; . (До сих пор мы видели соединения внутренние.) Команда выглядит так:</target>
        </trans-unit>
        <trans-unit id="7ce7fd7c4c102dd293619badd0d980d7f605bb16" translate="yes" xml:space="preserve">
          <source>Now you are ready to create the foreign data table. Using the &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; command, you will need to define the columns for the table, the CSV file name, and its format:</source>
          <target state="translated">Теперь вы готовы создать таблицу сторонних данных. Используя команду &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; , вам нужно будет определить столбцы для таблицы, имя файла CSV и его формат:</target>
        </trans-unit>
        <trans-unit id="64a8dd2545b6bf024381f0d92feccb523f90f566" translate="yes" xml:space="preserve">
          <source>Now you need only &lt;code&gt;SELECT&lt;/code&gt; from a foreign table to access the data stored in its underlying remote table. You can also modify the remote table using &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. (Of course, the remote user you have specified in your user mapping must have privileges to do these things.)</source>
          <target state="translated">Теперь вам нужно только &lt;code&gt;SELECT&lt;/code&gt; из внешней таблицы, чтобы получить доступ к данным, хранящимся в ее базовой удаленной таблице. Вы также можете изменить удаленную таблицу с помощью &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; или &lt;code&gt;DELETE&lt;/code&gt; . (Конечно, удаленный пользователь, которого вы указали в сопоставлении пользователей, должен иметь права на выполнение этих действий.)</target>
        </trans-unit>
        <trans-unit id="08d3e6ece6ec2bb9a41472c3b51de60739aa48a4" translate="yes" xml:space="preserve">
          <source>Now, a &lt;code&gt;SELECT&lt;/code&gt; query similar to the previous example can be used to suggest spellings for misspelled words in user search terms. A useful extra test is to require that the selected words are also of similar length to the misspelled word.</source>
          <target state="translated">Теперь запрос &lt;code&gt;SELECT&lt;/code&gt; , аналогичный предыдущему примеру, можно использовать для предложения вариантов написания слов с ошибками в условиях поиска пользователя. Полезная дополнительная проверка - потребовать, чтобы выбранные слова были такой же длины, как и слово с ошибкой.</target>
        </trans-unit>
        <trans-unit id="eb91f362c7c32cf6e84b89572465a581c06ab515" translate="yes" xml:space="preserve">
          <source>Now, let's make the condition more restrictive:</source>
          <target state="translated">Теперь,давайте сделаем условие более ограничительным:</target>
        </trans-unit>
        <trans-unit id="fb9ab76d936c6c858686ae054f0811c70819eab5" translate="yes" xml:space="preserve">
          <source>Now, the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/code&gt; will be recognized as an application of the indexable operator &lt;code&gt;?&lt;/code&gt; to the indexed expression &lt;code&gt;jdoc -&amp;gt; 'tags'&lt;/code&gt;. (More information on expression indexes can be found in &lt;a href=&quot;indexes-expressional&quot;&gt;Section 11.7&lt;/a&gt;.)</source>
          <target state="translated">Теперь, &lt;code&gt;WHERE&lt;/code&gt; пункт &lt;code&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/code&gt; будет распознаваться как приложение индексируемого оператора &lt;code&gt;?&lt;/code&gt; в индексированное выражение &lt;code&gt;jdoc -&amp;gt; 'tags'&lt;/code&gt; . (Более подробную информацию об индексах выражений можно найти в &lt;a href=&quot;indexes-expressional&quot;&gt;Разделе 11.7&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="9343983b435f96d35ab006d0ce2a792fa81e36a3" translate="yes" xml:space="preserve">
          <source>Now, the catalogs also provide a cast from &lt;code&gt;numeric&lt;/code&gt; to &lt;code&gt;integer&lt;/code&gt;. If that cast were marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which it is not &amp;mdash; then the parser would be faced with choosing between the above interpretation and the alternative of casting the &lt;code&gt;numeric&lt;/code&gt; constant to &lt;code&gt;integer&lt;/code&gt; and applying the &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;integer&lt;/code&gt; operator. Lacking any knowledge of which choice to prefer, it would give up and declare the query ambiguous. The fact that only one of the two casts is implicit is the way in which we teach the parser to prefer resolution of a mixed &lt;code&gt;numeric&lt;/code&gt;-and-&lt;code&gt;integer&lt;/code&gt; expression as &lt;code&gt;numeric&lt;/code&gt;; there is no built-in knowledge about that.</source>
          <target state="translated">Теперь каталоги также обеспечивают преобразование &lt;code&gt;numeric&lt;/code&gt; в &lt;code&gt;integer&lt;/code&gt; . Если бы это приведение было помечено как &lt;code&gt;AS IMPLICIT&lt;/code&gt; - а это не так - тогда синтаксическому анализатору пришлось бы выбирать между приведенной выше интерпретацией и альтернативой преобразования &lt;code&gt;numeric&lt;/code&gt; константы в &lt;code&gt;integer&lt;/code&gt; и применения оператора &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; целое число . Не зная, какой вариант предпочесть, он откажется и объявит запрос неоднозначным. Тот факт, что только одно из двух приведений является неявным, является способом, которым мы обучаем синтаксический анализатор предпочитать разрешение смешанного &lt;code&gt;numeric&lt;/code&gt; и &lt;code&gt;integer&lt;/code&gt; выражения как &lt;code&gt;numeric&lt;/code&gt; ; нет никаких встроенных знаний об этом.</target>
        </trans-unit>
        <trans-unit id="7e07cf090027f130a2dc1fbc4d060d70553c3b5f" translate="yes" xml:space="preserve">
          <source>Now, the main problem with the btree search is that btree is inefficient when the search conditions do not constrain the leading index column(s). A better strategy for btree is to create a separate index on each column. Then the planner will choose something like this:</source>
          <target state="translated">Теперь основная проблема поиска в дереве btree заключается в том,что btree неэффективна,когда условия поиска не ограничивают ведущий столбец(и)индекса.Лучшей стратегией для btree является создание отдельного индекса по каждому столбцу.Тогда планировщик выберет что-то подобное:</target>
        </trans-unit>
        <trans-unit id="8cf5b756d6afa6277b947e17d815b23a45e8f0cf" translate="yes" xml:space="preserve">
          <source>Now, this methodology can be cumbersome with a very large number of entries in the &lt;code&gt;one_to_many&lt;/code&gt; table. Often, a join like this would result in an index scan and a fetch for each right hand entry in the table for a particular left hand entry. If you have a very dynamic system, there is not much you can do. However, if you have some data which is fairly static, you can create a summary table with the aggregator.</source>
          <target state="translated">Теперь эта методология может быть громоздкой из-за очень большого количества записей в таблице &lt;code&gt;one_to_many&lt;/code&gt; . Часто такое соединение приводит к сканированию индекса и выборке для каждой правой записи в таблице для конкретной левой записи. Если у вас очень динамичная система, вы мало что можете сделать. Однако, если у вас есть данные, которые довольно статичны, вы можете создать сводную таблицу с помощью агрегатора.</target>
        </trans-unit>
        <trans-unit id="333cddf155e5f6b845810ca1b1ec9493a847d199" translate="yes" xml:space="preserve">
          <source>Now, we can run some queries on the table. First, we show how to access a single element of an array. This query retrieves the names of the employees whose pay changed in the second quarter:</source>
          <target state="translated">Теперь мы можем запустить несколько запросов на столе.Сначала мы покажем,как получить доступ к одному элементу массива.В этом запросе имена сотрудников,чья зарплата изменилась во втором квартале:</target>
        </trans-unit>
        <trans-unit id="e60c418bd02619354d423e5f131c6effce59534d" translate="yes" xml:space="preserve">
          <source>Now, we have a table &lt;code&gt;test&lt;/code&gt; populated with data describing the hierarchy shown below:</source>
          <target state="translated">Теперь у нас есть &lt;code&gt;test&lt;/code&gt; таблица, заполненная данными, описывающими иерархию, показанную ниже:</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="abc801eb7aa113d4d373983685ad8e4b411d4462" translate="yes" xml:space="preserve">
          <source>Null values are represented by &lt;code&gt;_null_&lt;/code&gt;. (Note that there is no way to create a value that is just that string.)</source>
          <target state="translated">Нулевые значения представлены &lt;code&gt;_null_&lt;/code&gt; . (Обратите внимание, что нет способа создать значение, которое представляет собой только эту строку.)</target>
        </trans-unit>
        <trans-unit id="71197a0f68656e301e5e80254d15a53eb1f65444" translate="yes" xml:space="preserve">
          <source>Nullness tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf00f0e98d92759b2ab900b85062ac054ac00545" translate="yes" xml:space="preserve">
          <source>Number of &amp;ldquo;internal&amp;rdquo; (upper-level) pages</source>
          <target state="translated">Количество &amp;laquo;внутренних&amp;raquo; (верхних) страниц</target>
        </trans-unit>
        <trans-unit id="766db6ffc20af3c98e8a0c222cc91dcfc261ce82" translate="yes" xml:space="preserve">
          <source>Number of &lt;code&gt;CHECK&lt;/code&gt; constraints on the table; see &lt;a href=&quot;catalog-pg-constraint&quot;&gt;&lt;code&gt;pg_constraint&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">Количество ограничений &lt;code&gt;CHECK&lt;/code&gt; в таблице; см. каталог &lt;a href=&quot;catalog-pg-constraint&quot;&gt; &lt;code&gt;pg_constraint&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f562c8ed4194c0f5d892247c878f35e3b1adf69e" translate="yes" xml:space="preserve">
          <source>Number of WAL files that have been successfully archived</source>
          <target state="translated">Количество успешно заархивированных файлов WAL</target>
        </trans-unit>
        <trans-unit id="c384981df593e79281c2a20754104f1934f6c9b7" translate="yes" xml:space="preserve">
          <source>Number of argument strings passed to trigger function</source>
          <target state="translated">Количество строк аргументов,переданных в триггерную функцию</target>
        </trans-unit>
        <trans-unit id="686b06e76d78fdcab0c83dfec56d5de3d95d6021" translate="yes" xml:space="preserve">
          <source>Number of arguments that have defaults</source>
          <target state="translated">Количество аргументов,которые имеют значения по умолчанию</target>
        </trans-unit>
        <trans-unit id="ad8f1d6b3919325e33519443b298eab45ab86017" translate="yes" xml:space="preserve">
          <source>Number of backends currently connected to this database, or &lt;code&gt;NULL&lt;/code&gt; for shared objects. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646ba2279db42aaed6dee8b8ba74083e8ded4a4e" translate="yes" xml:space="preserve">
          <source>Number of backends currently connected to this database, or &lt;code&gt;NULL&lt;/code&gt; for the shared objects. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.</source>
          <target state="translated">Количество серверных ВМ, подключенных в настоящее время к этой базе данных, или &lt;code&gt;NULL&lt;/code&gt; для общих объектов. Это единственный столбец в этом представлении, который возвращает значение, отражающее текущее состояние; все остальные столбцы возвращают накопленные значения с момента последнего сброса.</target>
        </trans-unit>
        <trans-unit id="055e292dc7e47521853b27a0e59b3a6f4ac3517d" translate="yes" xml:space="preserve">
          <source>Number of backends pinning this buffer</source>
          <target state="translated">Количество бэкэндов,прикрепляющих этот буфер</target>
        </trans-unit>
        <trans-unit id="7fc2a68fbd98db7f2b41bb2e743259772026c43c" translate="yes" xml:space="preserve">
          <source>Number of bitmap pages</source>
          <target state="translated">Количество растровых страниц</target>
        </trans-unit>
        <trans-unit id="7826db063f5934f4aaa44397cffd4f35886a95d2" translate="yes" xml:space="preserve">
          <source>Number of bits generated for each index column. Each parameter's name refers to the number of the index column that it controls. The default is &lt;code&gt;2&lt;/code&gt; bits and maximum is &lt;code&gt;4095&lt;/code&gt;. Parameters for index columns not actually used are ignored.</source>
          <target state="translated">Количество битов, сгенерированных для каждого столбца индекса. Имя каждого параметра относится к номеру столбца индекса, которым он управляет. По умолчанию - &lt;code&gt;2&lt;/code&gt; бита, максимум - &lt;code&gt;4095&lt;/code&gt; . Параметры для столбцов индекса, которые фактически не используются, игнорируются.</target>
        </trans-unit>
        <trans-unit id="33909c2a9901d0948fd89312acfb6d3e292b76cf" translate="yes" xml:space="preserve">
          <source>Number of bits generated for each index column. Each parameter's name refers to the number of the index column that it controls. The default is &lt;code&gt;2&lt;/code&gt; bits and the maximum is &lt;code&gt;4095&lt;/code&gt;. Parameters for index columns not actually used are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6ee47813de9741b16e5983ad54532485c3f7d8" translate="yes" xml:space="preserve">
          <source>Number of bits in string</source>
          <target state="translated">Количество битов в строке</target>
        </trans-unit>
        <trans-unit id="1efe22f20b8b3239aa455f2b88a22e48c7032a46" translate="yes" xml:space="preserve">
          <source>Number of bits in the encryption algorithm used, or NULL if SSL is not used on this connection</source>
          <target state="translated">Количество бит в используемом алгоритме шифрования,или NULL,если SSL не используется на данном соединении</target>
        </trans-unit>
        <trans-unit id="0aaa9d047e0edd588ca0e7b28edd0b562bba9543" translate="yes" xml:space="preserve">
          <source>Number of blocks already processed in the current phase.</source>
          <target state="translated">Количество блоков,уже обработанных в текущей фазе.</target>
        </trans-unit>
        <trans-unit id="1c4fa9ae3322de072b98477062cf3a411db62a9c" translate="yes" xml:space="preserve">
          <source>Number of blocks checked for existence for this SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e601295de63e2a2c268076613ec412bef9974925" translate="yes" xml:space="preserve">
          <source>Number of blocks zeroed during initializations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00533abb6601d842f496de1f71453437a6ebdea3" translate="yes" xml:space="preserve">
          <source>Number of bucket pages</source>
          <target state="translated">Количество ковшовых страниц</target>
        </trans-unit>
        <trans-unit id="5f0a807486a5a6ed87ce1d425faa9e67bccd0b96" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in all indexes on this table</source>
          <target state="translated">Количество попаданий буфера во все индексы в этой таблице</target>
        </trans-unit>
        <trans-unit id="e19591b7755dbe90f2648065af697ccee73ba936" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this index</source>
          <target state="translated">Количество попаданий буфера в этот индекс</target>
        </trans-unit>
        <trans-unit id="7bc9f9ddcb6814f42c1dfcc0f6c3a5f06c83a41c" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this sequence</source>
          <target state="translated">Количество попаданий буфера в этой последовательности</target>
        </trans-unit>
        <trans-unit id="1b92c223ff9c814c48eef462cd5d9e3733ab3a60" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table</source>
          <target state="translated">Количество попаданий в буфер в этой таблице</target>
        </trans-unit>
        <trans-unit id="fb5ce149dfa5df345dadf32e3e7609e73a91ab4d" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table's TOAST table (if any)</source>
          <target state="translated">Количество попаданий в буфер в таблице TOAST этой таблицы (если таковые имеются)</target>
        </trans-unit>
        <trans-unit id="23b7daeca394ace2c29173c2e4db7f60e4ffa150" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table's TOAST table indexes (if any)</source>
          <target state="translated">Количество попаданий буфера в индексы таблицы TOAST этой таблицы (если таковые имеются)</target>
        </trans-unit>
        <trans-unit id="820cb42f301c46e1dfd210dd8b99d341db358b4e" translate="yes" xml:space="preserve">
          <source>Number of buffers allocated</source>
          <target state="translated">Количество выделенных буферов</target>
        </trans-unit>
        <trans-unit id="9d5ff89dcfa3fb4035bf4d286f1b89c75201025e" translate="yes" xml:space="preserve">
          <source>Number of buffers written by the background writer</source>
          <target state="translated">Количество буферов,написанных фоновым автором</target>
        </trans-unit>
        <trans-unit id="0754f03bfbfe66ccdcb625fa7e3f44aa2c2a10bf" translate="yes" xml:space="preserve">
          <source>Number of buffers written directly by a backend</source>
          <target state="translated">Количество буферов,написанных непосредственно бэкэндом.</target>
        </trans-unit>
        <trans-unit id="5c0d5f7ac01275f2192348fde149f7bc358fa9b2" translate="yes" xml:space="preserve">
          <source>Number of buffers written during checkpoints</source>
          <target state="translated">Количество буферов,написанных во время контрольно-пропускных пунктов</target>
        </trans-unit>
        <trans-unit id="07fff57f12d731d3ce6021e11cbee81eeb3c2283" translate="yes" xml:space="preserve">
          <source>Number of bytes in binary string</source>
          <target state="translated">Количество байт в двоичной строке</target>
        </trans-unit>
        <trans-unit id="776e4abf0d400377907ab4118caf858bc018038c" translate="yes" xml:space="preserve">
          <source>Number of bytes in string</source>
          <target state="translated">Количество байт в строке</target>
        </trans-unit>
        <trans-unit id="0c72d2a102dbeffb7f10cf64774275780bc212cb" translate="yes" xml:space="preserve">
          <source>Number of bytes used to store a particular value (possibly compressed)</source>
          <target state="translated">Количество байтов,используемых для хранения определенного значения (возможно,сжатого)</target>
        </trans-unit>
        <trans-unit id="c08b0fa84d37e1078db655b5ae7decd119da648e" translate="yes" xml:space="preserve">
          <source>Number of characters in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">Количество символов в &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd2d8b2ef7ef37c5c432bb5b54f4a96fe58d0820" translate="yes" xml:space="preserve">
          <source>Number of characters in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; in the given &lt;em&gt;&lt;code&gt;encoding&lt;/code&gt;&lt;/em&gt;. The &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; must be valid in this encoding.</source>
          <target state="translated">Количество символов в &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; в заданной &lt;em&gt; &lt;code&gt;encoding&lt;/code&gt; &lt;/em&gt; . &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; должна быть действительна в этой кодировке.</target>
        </trans-unit>
        <trans-unit id="21fa6ae67d156ef97e3bcf08c970e730cf5312e3" translate="yes" xml:space="preserve">
          <source>Number of characters in string</source>
          <target state="translated">Количество символов в строке</target>
        </trans-unit>
        <trans-unit id="757246d7eeb8dba1a7138e1dc8e8018c67750493" translate="yes" xml:space="preserve">
          <source>Number of child tables scanned. This counter only advances when the phase is &lt;code&gt;acquiring inherited sample rows&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd1fcff19995e8c8816753d9ab90a523509512c" translate="yes" xml:space="preserve">
          <source>Number of child tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c03f4ded52583235611efb49840aea96640208" translate="yes" xml:space="preserve">
          <source>Number of clients simulated, that is, number of concurrent database sessions. Default is 1.</source>
          <target state="translated">Количество смоделированных клиентов,то есть количество параллельных сессий базы данных.По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="85c5091c823d8842dadc7ece08cd606b9ead02d8" translate="yes" xml:space="preserve">
          <source>Number of completed index vacuum cycles.</source>
          <target state="translated">Количество завершенных циклов создания индексного вакуума.</target>
        </trans-unit>
        <trans-unit id="07c0251b99d852d386e6230c7bc68b422860b2c8" translate="yes" xml:space="preserve">
          <source>Number of data page checksum failures detected in this database (or on a shared object), or NULL if data checksums are not enabled.</source>
          <target state="translated">Количество отказов контрольной суммы страницы данных,обнаруженных в этой базе данных (или на общем объекте),или NULL,если контрольная сумма данных не включена.</target>
        </trans-unit>
        <trans-unit id="fd10e6b6630a5e0b1a1e37d857ce93abbe92b80c" translate="yes" xml:space="preserve">
          <source>Number of dead tuples</source>
          <target state="translated">Количество мертвых кортежей</target>
        </trans-unit>
        <trans-unit id="afdac9c7f2737a1b2507732298381e07eead13a4" translate="yes" xml:space="preserve">
          <source>Number of dead tuples (exact)</source>
          <target state="translated">Количество мертвых кортежей (точно)</target>
        </trans-unit>
        <trans-unit id="02be773fcf618322b70d57bc8dd9f3bf3919a6ff" translate="yes" xml:space="preserve">
          <source>Number of dead tuples collected since the last index vacuum cycle.</source>
          <target state="translated">Количество мертвых кортежей,собранных со времени последнего цикла вакуумирования индекса.</target>
        </trans-unit>
        <trans-unit id="dfb451e3ffa3210bb1e566dd30fd90934219a10e" translate="yes" xml:space="preserve">
          <source>Number of dead tuples that we can store before needing to perform an index vacuum cycle, based on &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;.</source>
          <target state="translated">Количество мертвых кортежей, которые мы можем сохранить до выполнения цикла очистки индекса, на основе &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4921acfb7b89b906d587e207c982d99387b078d" translate="yes" xml:space="preserve">
          <source>Number of deadlocks detected in this database</source>
          <target state="translated">Количество обнаруженных дедлоков в этой базе данных</target>
        </trans-unit>
        <trans-unit id="7cb4a85ff41caf8fe6b956d1175a54bab38b2930" translate="yes" xml:space="preserve">
          <source>Number of deleted pages</source>
          <target state="translated">Количество удаленных страниц</target>
        </trans-unit>
        <trans-unit id="c3223e4de0ae9c43ca827d1664c98d5d300c8a06" translate="yes" xml:space="preserve">
          <source>Number of dimensions, if the column is an array type; otherwise 0. (Presently, the number of dimensions of an array is not enforced, so any nonzero value effectively means &amp;ldquo;it's an array&amp;rdquo;.)</source>
          <target state="translated">Количество измерений, если столбец является массивом; в противном случае 0. (В настоящее время количество измерений массива не является обязательным, поэтому любое ненулевое значение фактически означает &amp;laquo;это массив&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="2be05a9b990f09033b8618eab5d65ae1aecc4032" translate="yes" xml:space="preserve">
          <source>Number of direct (non-aggregated) arguments of an ordered-set or hypothetical-set aggregate, counting a variadic array as one argument. If equal to &lt;code&gt;pronargs&lt;/code&gt;, the aggregate must be variadic and the variadic array describes the aggregated arguments as well as the final direct arguments. Always zero for normal aggregates.</source>
          <target state="translated">Количество прямых (неагрегированных) аргументов агрегата упорядоченного набора или гипотетического набора, считая массив с переменными числами как один аргумент. Если равно &lt;code&gt;pronargs&lt;/code&gt; , агрегат должен быть вариативным, а вариативный массив описывает агрегированные аргументы, а также конечные прямые аргументы. Всегда ноль для обычных агрегатов.</target>
        </trans-unit>
        <trans-unit id="7aaf798c193e9c02ed1872cdc3758501e3edd2e9" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read for this SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e023d3421063e999e37bd8a8607f9d3b37c25b" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from all indexes on this table</source>
          <target state="translated">Количество блоков дисков,считанных из всех индексов в этой таблице.</target>
        </trans-unit>
        <trans-unit id="5d872dc4357e4133d7ccee125da5dd9ed6f1e23f" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this index</source>
          <target state="translated">Количество блоков диска,считанных из этого индекса</target>
        </trans-unit>
        <trans-unit id="f152a31061ce6ad3788ac1d44859392030a5e387" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this sequence</source>
          <target state="translated">Количество блоков дисков,считанных из этой последовательности</target>
        </trans-unit>
        <trans-unit id="5d8a5f136039b36181bc2310abac4c580db63dc6" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table</source>
          <target state="translated">Количество блоков дисков,считанных из этой таблицы</target>
        </trans-unit>
        <trans-unit id="0eec262fa83f105ce7c719197839961c454478bd" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table's TOAST table (if any)</source>
          <target state="translated">Количество блоков дисков,считанных из таблицы TOAST этой таблицы (если таковая имеется)</target>
        </trans-unit>
        <trans-unit id="c3595c16a4db90858d963b19c02306856a40fc17" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table's TOAST table indexes (if any)</source>
          <target state="translated">Количество блоков диска,считанных из индексов таблицы TOAST этой таблицы (если таковые имеются)</target>
        </trans-unit>
        <trans-unit id="afcfec9d8002c45f94146f16eeb8704ff31575b1" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read in this database</source>
          <target state="translated">Количество блоков дисков,считанных в этой базе данных</target>
        </trans-unit>
        <trans-unit id="900fa7cb003c1be6f273043153c16b1f15b30466" translate="yes" xml:space="preserve">
          <source>Number of disk blocks written for this SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da37950fc1304c1760a3162855b0cc7eba9abaaf" translate="yes" xml:space="preserve">
          <source>Number of empty pages</source>
          <target state="translated">Количество пустых страниц</target>
        </trans-unit>
        <trans-unit id="1eef621006cc03444cdc3f17923c510b432b6ba9" translate="yes" xml:space="preserve">
          <source>Number of entries in semaphore map</source>
          <target state="translated">Количество записей на семафорной карте</target>
        </trans-unit>
        <trans-unit id="477ceecd337608949a72430b5748c93213cf67af" translate="yes" xml:space="preserve">
          <source>Number of extended statistics computed. This counter only advances when the phase is &lt;code&gt;computing extended statistics&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fbf334710b4f84f1b18744b65687758f7ff55b" translate="yes" xml:space="preserve">
          <source>Number of extended statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad03f1cded443f2951e34811d9b174dcd53e9f1" translate="yes" xml:space="preserve">
          <source>Number of failed attempts for archiving WAL files</source>
          <target state="translated">Количество неудачных попыток архивирования файлов WAL</target>
        </trans-unit>
        <trans-unit id="83240d945e31782e131edbfaf89add567bc6e877" translate="yes" xml:space="preserve">
          <source>Number of flushes of dirty data for this SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909efe526c9ef59f71379f7b5459201d6e2057fb" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7d7d8e8c6ad921ea1f650987683cdca25be133" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned. Because the &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; is used to optimize scans, some blocks will be skipped without inspection; skipped blocks are included in this total, so that this number will eventually become equal to &lt;code&gt;heap_blks_total&lt;/code&gt; when the vacuum is complete. This counter only advances when the phase is &lt;code&gt;scanning heap&lt;/code&gt;.</source>
          <target state="translated">Количество просканированных блоков кучи. Поскольку &lt;a href=&quot;storage-vm&quot;&gt;карта видимости&lt;/a&gt; используется для оптимизации сканирования, некоторые блоки будут пропущены без проверки; пропущенные блоки включаются в это общее количество, так что это число в конечном итоге станет равным &lt;code&gt;heap_blks_total&lt;/code&gt; , когда вакуум будет завершен. Этот счетчик увеличивается только тогда, когда фаза &lt;code&gt;scanning heap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8abfe62e8394a6c74c6d4a5a932d175e4675308e" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;.</source>
          <target state="translated">Количество просканированных блоков кучи. Этот счетчик увеличивается только на этапе последовательного &lt;code&gt;seq scanning heap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3cc4495fb3d4a190394bf457f27a153df853feb" translate="yes" xml:space="preserve">
          <source>Number of heap blocks vacuumed. Unless the table has no indexes, this counter only advances when the phase is &lt;code&gt;vacuuming heap&lt;/code&gt;. Blocks that contain no dead tuples are skipped, so the counter may sometimes skip forward in large increments.</source>
          <target state="translated">Количество вакуумированных блоков кучи. Если таблица не имеет индексов, этот счетчик увеличивается только тогда, когда фаза &lt;code&gt;vacuuming heap&lt;/code&gt; . Блоки, которые не содержат мертвых кортежей, пропускаются, поэтому счетчик может иногда пропускать вперед с большим шагом.</target>
        </trans-unit>
        <trans-unit id="f7065ea221f976c9edbd673b5b220f7e3c796ada" translate="yes" xml:space="preserve">
          <source>Number of heap tuples scanned. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;, &lt;code&gt;index scanning heap&lt;/code&gt; or &lt;code&gt;writing new heap&lt;/code&gt;.</source>
          <target state="translated">Количество просканированных кортежей кучи. Этот счетчик увеличивается только тогда, когда фаза - это последовательное &lt;code&gt;seq scanning heap&lt;/code&gt; , &lt;code&gt;index scanning heap&lt;/code&gt; или &lt;code&gt;writing new heap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1608d82e7902ccc755c873e18179b75db06e972e" translate="yes" xml:space="preserve">
          <source>Number of heap tuples written. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;, &lt;code&gt;index scanning heap&lt;/code&gt; or &lt;code&gt;writing new heap&lt;/code&gt;.</source>
          <target state="translated">Количество записанных кортежей кучи. Этот счетчик увеличивается только тогда, когда фаза - это последовательное &lt;code&gt;seq scanning heap&lt;/code&gt; , &lt;code&gt;index scanning heap&lt;/code&gt; или &lt;code&gt;writing new heap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8a4f5e567445d068c8e050292c1c88bc19074f5" translate="yes" xml:space="preserve">
          <source>Number of index entries returned by scans on this index</source>
          <target state="translated">Количество записей индекса,возвращенных в результате сканирования этого индекса.</target>
        </trans-unit>
        <trans-unit id="2e47feab593e8d7f11f91aca87244c1647d56eda" translate="yes" xml:space="preserve">
          <source>Number of index scans initiated on this index</source>
          <target state="translated">Количество сканирований индекса,инициированных по этому индексу</target>
        </trans-unit>
        <trans-unit id="9740aebc5f5b78757843f388b08b6acf15d45722" translate="yes" xml:space="preserve">
          <source>Number of index scans initiated on this table</source>
          <target state="translated">Количество сканирований индексов,инициированных в этой таблице</target>
        </trans-unit>
        <trans-unit id="2512b3dbef65d5a2946445bd9f10f953be318af1" translate="yes" xml:space="preserve">
          <source>Number of indexes rebuilt. This counter only advances when the phase is &lt;code&gt;rebuilding index&lt;/code&gt;.</source>
          <target state="translated">Количество перестроенных индексов. Этот счетчик увеличивается только тогда, когда фаза &lt;code&gt;rebuilding index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c472386046a97dee2b6524340bae3b671c82f90b" translate="yes" xml:space="preserve">
          <source>Number of input arguments</source>
          <target state="translated">Количество вводимых аргументов</target>
        </trans-unit>
        <trans-unit id="2f8814269318ff6e97c5ce39779e7a57b9de7c2a" translate="yes" xml:space="preserve">
          <source>Number of leaf pages</source>
          <target state="translated">Количество листовых страниц</target>
        </trans-unit>
        <trans-unit id="09d24d58ee5f9d720e6e82ed3d6f447d63a9f297" translate="yes" xml:space="preserve">
          <source>Number of live rows fetched by index scans</source>
          <target state="translated">Количество живых рядов,полученных индексным сканированием</target>
        </trans-unit>
        <trans-unit id="7f6337cf0b1025e25455e7f1eb27c447744854cc" translate="yes" xml:space="preserve">
          <source>Number of live rows fetched by sequential scans</source>
          <target state="translated">Количество живых рядов,полученных последовательным сканированием</target>
        </trans-unit>
        <trans-unit id="c7bb465c5d5812b8f1ac688b0973b4608d17fc34" translate="yes" xml:space="preserve">
          <source>Number of live rows in the table. This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">Количество живых строк в таблице. Это только оценка, используемая планировщиком. Он обновляется с помощью &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; и нескольких команд DDL, таких как &lt;code&gt;CREATE INDEX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6384ca87c928ff5826fd519745a102a2e37dcfdf" translate="yes" xml:space="preserve">
          <source>Number of live table rows fetched by simple index scans using this index</source>
          <target state="translated">Количество строк живой таблицы,полученных простым сканированием индекса с использованием этого индекса.</target>
        </trans-unit>
        <trans-unit id="dd029b3676675a63d87f153e3800676e7c7dd2a6" translate="yes" xml:space="preserve">
          <source>Number of live tuples</source>
          <target state="translated">Количество живых кортежей</target>
        </trans-unit>
        <trans-unit id="d58d2b3f2cd29b1e4cc2b40b834ed9770119552a" translate="yes" xml:space="preserve">
          <source>Number of live tuples (estimated)</source>
          <target state="translated">Количество живых кортежей (оценочное)</target>
        </trans-unit>
        <trans-unit id="5571a3a39c2a5eeb8bba94092d426fefd43fd703" translate="yes" xml:space="preserve">
          <source>Number of lockers already waited for.</source>
          <target state="translated">Количество шкафчиков,которые уже ждали.</target>
        </trans-unit>
        <trans-unit id="11736240ddbd910654d9f20076ce6396954df295" translate="yes" xml:space="preserve">
          <source>Number of overflow pages</source>
          <target state="translated">Количество страниц переполнения</target>
        </trans-unit>
        <trans-unit id="2ef8f42ee9f5e2c4b09ad099506a9000c698f3af" translate="yes" xml:space="preserve">
          <source>Number of pages in the pending list</source>
          <target state="translated">Количество страниц в списке ожидания</target>
        </trans-unit>
        <trans-unit id="daa5300000bb09c7a79335a89c2593536d8853e6" translate="yes" xml:space="preserve">
          <source>Number of pages that are marked all-visible in the table's visibility map. This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">Количество страниц, которые помечены как все видимые на карте видимости таблицы. Это только оценка, используемая планировщиком. Он обновляется с помощью &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; и нескольких команд DDL, таких как &lt;code&gt;CREATE INDEX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3cf04020ae64faac82b051a0ef081a4ffd60a33" translate="yes" xml:space="preserve">
          <source>Number of points in path or polygon</source>
          <target state="translated">Количество точек на пути или многоугольник</target>
        </trans-unit>
        <trans-unit id="544446e4ab9a886e3d43e3c0ad1665073743283d" translate="yes" xml:space="preserve">
          <source>Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;&lt;code&gt;pg_stat_database_conflicts&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e27e77340db29b89a3fbca8921ff6b082deb57" translate="yes" xml:space="preserve">
          <source>Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; for details.)</source>
          <target state="translated">Количество запросов, отмененных из-за конфликтов с восстановлением в этой базе данных. (Конфликты возникают только на резервных серверах; подробности см. В &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="14b49512f9667544c12ae0c4b4cd966d96369baa" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to deadlocks</source>
          <target state="translated">Количество запросов в этой базе данных,которые были отменены из-за тупиковых ситуаций.</target>
        </trans-unit>
        <trans-unit id="2965fecffa2cf1a8144374cd40187c529bd62354" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to dropped tablespaces</source>
          <target state="translated">Количество запросов в этой базе данных,которые были отменены из-за удаленных табличных пространств</target>
        </trans-unit>
        <trans-unit id="285091906a09f767f888d2dff167e4dafef20892" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to lock timeouts</source>
          <target state="translated">Количество запросов в этой базе данных,которые были отменены в связи с таймаутами блокировки</target>
        </trans-unit>
        <trans-unit id="7bd181d498f49b3250f7391fd0a21bf7f1dd7ba8" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to old snapshots</source>
          <target state="translated">Количество запросов в этой базе данных,которые были отменены из-за старых снимков.</target>
        </trans-unit>
        <trans-unit id="a343fc19cbfe51192fb4c899e5aeef503d395f97" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to pinned buffers</source>
          <target state="translated">Количество запросов в этой базе данных,которые были отменены из-за прикрепленных буферов</target>
        </trans-unit>
        <trans-unit id="0ac9bcd7ffe37a50ba3f5b534d815f116bf780f4" translate="yes" xml:space="preserve">
          <source>Number of requested checkpoints that have been performed</source>
          <target state="translated">Количество запрошенных контрольно-пропускных пунктов,которые были выполнены</target>
        </trans-unit>
        <trans-unit id="ac10ddd98993ae90bf693c73dcdf8ce8ff50a428" translate="yes" xml:space="preserve">
          <source>Number of rows HOT updated (i.e., with no separate index update required)</source>
          <target state="translated">Количество обновленных рядов HOT (т.е.без необходимости отдельного обновления индекса)</target>
        </trans-unit>
        <trans-unit id="d2766fede1a28c68b26ca72aae563b9c0e3b81e7" translate="yes" xml:space="preserve">
          <source>Number of rows deleted</source>
          <target state="translated">Количество удаленных строк</target>
        </trans-unit>
        <trans-unit id="f34b08643d44d2358187f3d93aedd65adc903d85" translate="yes" xml:space="preserve">
          <source>Number of rows deleted by queries in this database</source>
          <target state="translated">Количество строк,удаленных по запросам в этой базе данных</target>
        </trans-unit>
        <trans-unit id="a2b82f360651a017d5888c1a773debe321eb0eb6" translate="yes" xml:space="preserve">
          <source>Number of rows fetched by queries in this database</source>
          <target state="translated">Количество строк,полученных по запросам в этой базе данных</target>
        </trans-unit>
        <trans-unit id="f45586cda10d5aa205f934dede2f25a7f45e1dde" translate="yes" xml:space="preserve">
          <source>Number of rows inserted</source>
          <target state="translated">Количество вставленных строк</target>
        </trans-unit>
        <trans-unit id="6a09e7859bb80515b532f0be7e2f1d0e3e69ef9b" translate="yes" xml:space="preserve">
          <source>Number of rows inserted by queries in this database</source>
          <target state="translated">Количество строк,вставленных по запросам в эту базу данных</target>
        </trans-unit>
        <trans-unit id="df7903056ffeb2c4aeb95ecc376e010c64637c6c" translate="yes" xml:space="preserve">
          <source>Number of rows returned by queries in this database</source>
          <target state="translated">Количество строк,возвращенных по запросам в этой базе данных</target>
        </trans-unit>
        <trans-unit id="323338c3c2a474e71a2da0eb4b11693b9c2f500b" translate="yes" xml:space="preserve">
          <source>Number of rows updated (includes HOT updated rows)</source>
          <target state="translated">Количество обновленных рядов (включая обновленные ряды HOT)</target>
        </trans-unit>
        <trans-unit id="454a23c41b48acf5b2ccd14833f1fbd50495e2fe" translate="yes" xml:space="preserve">
          <source>Number of rows updated by queries in this database</source>
          <target state="translated">Количество строк,обновленных по запросам в этой базе данных</target>
        </trans-unit>
        <trans-unit id="2ac84789e08f3d81095c6bdcfce3914d10c756d6" translate="yes" xml:space="preserve">
          <source>Number of scheduled checkpoints that have been performed</source>
          <target state="translated">Количество запланированных контрольно-пропускных пунктов,которые были выполнены</target>
        </trans-unit>
        <trans-unit id="70b6c2dc7031b941f16874427081ef44f2d0e18e" translate="yes" xml:space="preserve">
          <source>Number of sequential scans initiated on this table</source>
          <target state="translated">Количество последовательных сканирований,инициированных на этой таблице</target>
        </trans-unit>
        <trans-unit id="a406439f0d98d84ebcc73a534711b625f34ad9d2" translate="yes" xml:space="preserve">
          <source>Number of tablespaces streamed. This counter only advances when the phase is &lt;code&gt;streaming database files&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1eaebd91f46f68739419b406f7116ca7278810" translate="yes" xml:space="preserve">
          <source>Number of temporary files created by queries in this database. All temporary files are counted, regardless of why the temporary file was created (e.g., sorting or hashing), and regardless of the &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt; setting.</source>
          <target state="translated">Количество временных файлов, созданных запросами в этой базе данных. Подсчитываются все временные файлы, независимо от того, почему временный файл был создан (например, сортировка или хеширование), и независимо от настройки &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="321ef5914a0a09d168438f2273433fc677686e24" translate="yes" xml:space="preserve">
          <source>Number of the log line for each session or process, starting at 1</source>
          <target state="translated">Номер строки журнала для каждой сессии или процесса,начиная с 1</target>
        </trans-unit>
        <trans-unit id="63fe0ed940b40404d3e8a92d939916a5dc589c9e" translate="yes" xml:space="preserve">
          <source>Number of times a backend had to execute its own &lt;code&gt;fsync&lt;/code&gt; call (normally the background writer handles those even when the backend does its own write)</source>
          <target state="translated">Сколько раз бэкэнд должен был выполнить свой собственный вызов &lt;code&gt;fsync&lt;/code&gt; (обычно фоновый писатель обрабатывает их, даже когда бэкэнд выполняет свою собственную запись)</target>
        </trans-unit>
        <trans-unit id="68d8d91d15dbba072e77a826a2320fb4b78552e4" translate="yes" xml:space="preserve">
          <source>Number of times disk blocks were found already in the SLRU, so that a read was not necessary (this only includes hits in the SLRU, not the operating system's file system cache)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a553947fcdc098d224243a39019d65fcd42472fd" translate="yes" xml:space="preserve">
          <source>Number of times disk blocks were found already in the buffer cache, so that a read was not necessary (this only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache)</source>
          <target state="translated">Количество раз,когда дисковые блоки были найдены уже в буферном кэше,так что в чтении не было необходимости (сюда входят только хиты в буферном кэше PostgreSQL,а не в кэше файловой системы операционной системы)</target>
        </trans-unit>
        <trans-unit id="d7202f6daa9d37d53dc5948cf3ce73b0f377e700" translate="yes" xml:space="preserve">
          <source>Number of times executed</source>
          <target state="translated">Количество выполненных</target>
        </trans-unit>
        <trans-unit id="03d48edf24ffbd37a62d6a4ffcfb82831fa45c63" translate="yes" xml:space="preserve">
          <source>Number of times the background writer stopped a cleaning scan because it had written too many buffers</source>
          <target state="translated">Количество раз,когда фоновый пишущий аппарат останавливал чистку скана,потому что он записывал слишком много буферов.</target>
        </trans-unit>
        <trans-unit id="4ed26fe5383a5798683e9283907335221973e727" translate="yes" xml:space="preserve">
          <source>Number of times the statement was executed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20347e7e3ba3b446a92ff9a3bd79c5b1d653f5c0" translate="yes" xml:space="preserve">
          <source>Number of times the statement was planned (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db4c1e8598791346cf7ab2d43ead7da4a1cb087e" translate="yes" xml:space="preserve">
          <source>Number of times this function has been called</source>
          <target state="translated">Количество вызовов этой функции</target>
        </trans-unit>
        <trans-unit id="981adc683189320f78f847f75dfe9f19ed8a5df7" translate="yes" xml:space="preserve">
          <source>Number of times this table has been analyzed by the autovacuum daemon</source>
          <target state="translated">Количество раз,когда эта таблица анализировалась авто-вакуумным демоном.</target>
        </trans-unit>
        <trans-unit id="b87ae2050cfd76f7faad9ed39e95e377b7ba3065" translate="yes" xml:space="preserve">
          <source>Number of times this table has been manually analyzed</source>
          <target state="translated">Количество раз,когда эта таблица анализировалась вручную.</target>
        </trans-unit>
        <trans-unit id="86f3157922ed18f5e1cb8cdea053f28b23ec91b9" translate="yes" xml:space="preserve">
          <source>Number of times this table has been manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">Сколько раз эта таблица была очищена вручную (не считая &lt;code&gt;VACUUM FULL&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7d451fa30c0c321954c3a675d2c5bb4c2d50a932" translate="yes" xml:space="preserve">
          <source>Number of times this table has been vacuumed by the autovacuum daemon</source>
          <target state="translated">Количество раз,когда эта таблица была пропылесошена демон-автовакуум.</target>
        </trans-unit>
        <trans-unit id="4c54cfa40fa8364c91aff563ca87ddd6edf318b8" translate="yes" xml:space="preserve">
          <source>Number of transactions each client runs. Default is 10.</source>
          <target state="translated">Количество транзакций,выполняемых каждым клиентом.По умолчанию 10.</target>
        </trans-unit>
        <trans-unit id="3275a376403dc18fc868eeb773fd1acfe4f18aec" translate="yes" xml:space="preserve">
          <source>Number of transactions in this database that have been committed</source>
          <target state="translated">Количество транзакций в этой базе данных,которые были совершены</target>
        </trans-unit>
        <trans-unit id="5b3dba5ee04dc9d1479c1b216978bf3f1db9f6aa" translate="yes" xml:space="preserve">
          <source>Number of transactions in this database that have been rolled back</source>
          <target state="translated">Количество транзакций в этой базе данных,которые были откачены.</target>
        </trans-unit>
        <trans-unit id="ec735d5660ce6c32dd80bd724ca186e1322664ff" translate="yes" xml:space="preserve">
          <source>Number of truncates for this SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249fa0ad004c753cb36af02875bc1dafebf2db43" translate="yes" xml:space="preserve">
          <source>Number of tuples already processed in the current phase.</source>
          <target state="translated">Количество кортежей,уже обработанных в текущей фазе.</target>
        </trans-unit>
        <trans-unit id="e10a2168070471eb01214b024083f7afd7ad7f4a" translate="yes" xml:space="preserve">
          <source>Number of tuples in the pending list</source>
          <target state="translated">Количество кортежей в списке ожидания</target>
        </trans-unit>
        <trans-unit id="cf7d86c225385fe6e945a39e465f0448098943a9" translate="yes" xml:space="preserve">
          <source>Number of unused pages</source>
          <target state="translated">Количество неиспользованных страниц</target>
        </trans-unit>
        <trans-unit id="64210a61d52a14f7a802ee5036f59bb4880be4c1" translate="yes" xml:space="preserve">
          <source>Number of user columns in the relation (system columns not counted). There must be this many corresponding entries in &lt;code&gt;pg_attribute&lt;/code&gt;. See also &lt;code&gt;pg_attribute.attnum&lt;/code&gt;.</source>
          <target state="translated">Количество пользовательских столбцов в отношении (системные столбцы не учитываются). В &lt;code&gt;pg_attribute&lt;/code&gt; должно быть столько соответствующих записей . См. Также &lt;code&gt;pg_attribute.attnum&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5897414fda7aed8102e3f5d6f9e16ee579dd363" translate="yes" xml:space="preserve">
          <source>Number of worker threads within pgbench. Using more than one thread can be helpful on multi-CPU machines. Clients are distributed as evenly as possible among available threads. Default is 1.</source>
          <target state="translated">Количество рабочих нитей в pgbench.Использование более чем одного потока может быть полезно на многопроцессорных машинах.Клиенты распределены между доступными потоками как можно более равномерно.По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="cefa5441373f254fdc1cb9fdbc4d9c0c1aa44ee4" translate="yes" xml:space="preserve">
          <source>Numbers with 7 or fewer significant digits retain their original precision. That is, if your query returns 0.00, you will be sure that the trailing zeroes are not the artifacts of formatting: they reflect the precision of the original data. The number of leading zeroes does not affect precision: the value 0.0067 is considered to have just 2 significant digits.</source>
          <target state="translated">Цифры с 7 или менее значащими цифрами сохраняют свою первоначальную точность.То есть,если ваш запрос вернет 0.00,вы будете уверены,что трейлинговые нули не являются артефактами форматирования:они отражают точность исходных данных.Количество ведущих нулей не влияет на точность:считается,что значение 0.0067 имеет всего 2 значащие цифры.</target>
        </trans-unit>
        <trans-unit id="58224773d7dc5786efbb9bfbfa152b78d5c3ced5" translate="yes" xml:space="preserve">
          <source>Numeric Types</source>
          <target state="translated">числовые типы</target>
        </trans-unit>
        <trans-unit id="f1b55ea9345add00dc53f8d39e821048683ac6ac" translate="yes" xml:space="preserve">
          <source>Numeric Types: bigint</source>
          <target state="translated">Числовые типы:bigint</target>
        </trans-unit>
        <trans-unit id="34ca1938464846ffd7671c72fe6fcf56ce8ed626" translate="yes" xml:space="preserve">
          <source>Numeric Types: bigserial</source>
          <target state="translated">Цифровые типы:большой набор</target>
        </trans-unit>
        <trans-unit id="4f4c21c7dbf7d3b0ce15752213f48b0ca85c6be6" translate="yes" xml:space="preserve">
          <source>Numeric Types: decimal</source>
          <target state="translated">Числовые типы:десятичный</target>
        </trans-unit>
        <trans-unit id="5f39be2adc33677462c0440cd7f421e180a13185" translate="yes" xml:space="preserve">
          <source>Numeric Types: double precision</source>
          <target state="translated">Числовые типы:двойная точность</target>
        </trans-unit>
        <trans-unit id="7d13fe88ea7d98f3a10e5a107a6fb5f2b06420b9" translate="yes" xml:space="preserve">
          <source>Numeric Types: integer</source>
          <target state="translated">Числовые типы:целое число</target>
        </trans-unit>
        <trans-unit id="589f0dce7263b0f4a4ffcc692a06b6cca5db39a7" translate="yes" xml:space="preserve">
          <source>Numeric Types: numeric</source>
          <target state="translated">Числовые типы:числовой</target>
        </trans-unit>
        <trans-unit id="d049c61cbf5f08cf4a2b6ad03914911c2436a250" translate="yes" xml:space="preserve">
          <source>Numeric Types: real</source>
          <target state="translated">Числовые Типы:настоящий</target>
        </trans-unit>
        <trans-unit id="017b04d1c97e36f0333abaaf314c6a6c6bbedc30" translate="yes" xml:space="preserve">
          <source>Numeric Types: serial</source>
          <target state="translated">Числовые типы:последовательный</target>
        </trans-unit>
        <trans-unit id="9e36bc851d04411f4bd3afa229897af484988fe2" translate="yes" xml:space="preserve">
          <source>Numeric Types: smallint</source>
          <target state="translated">Числовые типы:мелкий шрифт</target>
        </trans-unit>
        <trans-unit id="3fa9584c0cd0a43cf41d81cfcfb10456d729bae0" translate="yes" xml:space="preserve">
          <source>Numeric Types: smallserial</source>
          <target state="translated">Числовые типы:мелкозернистый</target>
        </trans-unit>
        <trans-unit id="a172b52198f27b4b4b6b86a0f1c9b17a17d9bf18" translate="yes" xml:space="preserve">
          <source>Numeric character-entry escapes specifying values outside the ASCII range (0&amp;ndash;127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example &lt;code&gt;\u1234&lt;/code&gt; means the character &lt;code&gt;U+1234&lt;/code&gt;. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6907254669bc308bcd96a76901734e20d0b431f6" translate="yes" xml:space="preserve">
          <source>Numeric character-entry escapes specifying values outside the ASCII range (0-127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example &lt;code&gt;\u1234&lt;/code&gt; means the character &lt;code&gt;U+1234&lt;/code&gt;. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data.</source>
          <target state="translated">Экраны ввода числовых символов, указывающие значения вне диапазона ASCII (0&amp;ndash;127), имеют значение, зависящее от кодировки базы данных. Когда используется кодировка UTF-8, escape-значения эквивалентны кодовым точкам Unicode, например &lt;code&gt;\u1234&lt;/code&gt; означает символ &lt;code&gt;U+1234&lt;/code&gt; . Для других многобайтовых кодировок экранирование ввода символов обычно просто указывает конкатенацию байтовых значений для символа. Если escape-значение не соответствует какому-либо допустимому символу в кодировке базы данных, ошибка не возникнет, но оно никогда не будет соответствовать каким-либо данным.</target>
        </trans-unit>
        <trans-unit id="6e2759a88d02cd4c49727936e3e39cfce1c8fe1b" translate="yes" xml:space="preserve">
          <source>Numeric constants are accepted in these general forms:</source>
          <target state="translated">Числовые константы принимаются в этих общих формах:</target>
        </trans-unit>
        <trans-unit id="32c0946f98f3a53c7cc5e78bd6ba14716174ad6a" translate="yes" xml:space="preserve">
          <source>Numeric ordering, sorts sequences of digits by their numeric value, for example: &lt;code&gt;A-21&lt;/code&gt; &amp;lt; &lt;code&gt;A-123&lt;/code&gt; (also known as natural sort).</source>
          <target state="translated">Числовой порядок, сортировка последовательностей цифр по их числовому значению, например: &lt;code&gt;A-21&lt;/code&gt; &amp;lt; &lt;code&gt;A-123&lt;/code&gt; (также известная как естественная сортировка).</target>
        </trans-unit>
        <trans-unit id="8d7bc2659eda5afabdbd8dae30a1b10b69aab0fa" translate="yes" xml:space="preserve">
          <source>Numeric transaction identifier of the prepared transaction</source>
          <target state="translated">Числовой идентификатор готовой сделки</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">Числовые типы</target>
        </trans-unit>
        <trans-unit id="bbed1ad8168ad945da348f70d8f35c3aaa2d08ae" translate="yes" xml:space="preserve">
          <source>Numeric types consist of two-, four-, and eight-byte integers, four- and eight-byte floating-point numbers, and selectable-precision decimals. &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt; lists the available types.</source>
          <target state="translated">Числовые типы состоят из двух-, четырех- и восьмибайтовых целых чисел, четырех- и восьмибайтовых чисел с плавающей запятой и десятичных дробей с выбираемой точностью. &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;В таблице 8.2&lt;/a&gt; перечислены доступные типы.</target>
        </trans-unit>
        <trans-unit id="ae34df1114cf867e5a5e67721782e6b4936cf60a" translate="yes" xml:space="preserve">
          <source>Numeric values are physically stored without any extra leading or trailing zeroes. Thus, the declared precision and scale of a column are maximums, not fixed allocations. (In this sense the &lt;code&gt;numeric&lt;/code&gt; type is more akin to &lt;code&gt;varchar(n)&lt;/code&gt; than to &lt;code&gt;char(n)&lt;/code&gt;.) The actual storage requirement is two bytes for each group of four decimal digits, plus three to eight bytes overhead.</source>
          <target state="translated">Числовые значения физически хранятся без каких-либо дополнительных нулей в начале или в конце. Таким образом, заявленная точность и масштаб столбца являются максимальными, а не фиксированными выделениями. (В этом смысле &lt;code&gt;numeric&lt;/code&gt; тип больше похож на &lt;code&gt;varchar(n)&lt;/code&gt; чем на &lt;code&gt;char(n)&lt;/code&gt; .) Фактические требования к хранилищу - два байта для каждой группы из четырех десятичных цифр плюс от трех до восьми байтов накладных расходов.</target>
        </trans-unit>
        <trans-unit id="1cd1073fd79a8443ea8d6973895d5ee6ffe7cdf9" translate="yes" xml:space="preserve">
          <source>Numerical statistics of the appropriate kind for the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;, or null if the slot kind does not involve numerical values</source>
          <target state="translated">Числовая статистика соответствующего типа для &lt;code&gt;N&lt;/code&gt; - го &amp;laquo;слота&amp;raquo; или null, если тип слота не включает числовые значения.</target>
        </trans-unit>
        <trans-unit id="fb91068c51189c866a8e510b38ba4dfebf5d32bc" translate="yes" xml:space="preserve">
          <source>ODBC</source>
          <target state="translated">ODBC</target>
        </trans-unit>
        <trans-unit id="4d314276ba61e4f3bc6a1b4a234e301a4e785ad9" translate="yes" xml:space="preserve">
          <source>OID</source>
          <target state="translated">OID</target>
        </trans-unit>
        <trans-unit id="725ff3ec092f4de8d511006eba9dfe844003c6f9" translate="yes" xml:space="preserve">
          <source>OID of a database</source>
          <target state="translated">OID базы данных</target>
        </trans-unit>
        <trans-unit id="f8c02df27c83758b75b440e8700bcc0f8b46a3f0" translate="yes" xml:space="preserve">
          <source>OID of a function</source>
          <target state="translated">OID функции</target>
        </trans-unit>
        <trans-unit id="faffc6a7f80d0822867cb82f8a02546997b88ef9" translate="yes" xml:space="preserve">
          <source>OID of a handler function that is responsible for supplying information about the access method</source>
          <target state="translated">OID функции обработчика,которая отвечает за предоставление информации о способе доступа</target>
        </trans-unit>
        <trans-unit id="5a4a96aa8d7efd7ac397558d10f843a235a92c88" translate="yes" xml:space="preserve">
          <source>OID of a sequence</source>
          <target state="translated">OID последовательности</target>
        </trans-unit>
        <trans-unit id="996a8d685aef72e0b42d14422b03fa62a0285fd1" translate="yes" xml:space="preserve">
          <source>OID of a table</source>
          <target state="translated">идентификатор таблицы</target>
        </trans-unit>
        <trans-unit id="90f9df50ed473af29d597298ed5c8caeb84243d2" translate="yes" xml:space="preserve">
          <source>OID of database in which the statement was executed</source>
          <target state="translated">OID базы данных,в которой был выполнен отчет.</target>
        </trans-unit>
        <trans-unit id="080d0fef7c4d986b1330554caa1d1e593f3124b0" translate="yes" xml:space="preserve">
          <source>OID of session's temporary schema, or 0 if none</source>
          <target state="translated">OID временной схемы сессии,или 0,если нет.</target>
        </trans-unit>
        <trans-unit id="346ed8429eddd05e15627f07718d2d6a7f44eddd" translate="yes" xml:space="preserve">
          <source>OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this foreign table</source>
          <target state="translated">OID записи &lt;code&gt;pg_class&lt;/code&gt; для этой сторонней таблицы</target>
        </trans-unit>
        <trans-unit id="3bcb74cd3805e6c2a6b21b10048ed96a348a5d71" translate="yes" xml:space="preserve">
          <source>OID of the TOAST table associated with this table, 0 if none. The TOAST table stores large attributes &amp;ldquo;out of line&amp;rdquo; in a secondary table.</source>
          <target state="translated">OID таблицы TOAST, связанной с этой таблицей, 0, если нет. Таблица TOAST хранит большие атрибуты &amp;laquo;вне линии&amp;raquo; во вторичной таблице.</target>
        </trans-unit>
        <trans-unit id="0087f0d6da4c99ba53f0596b33bf633085b24106" translate="yes" xml:space="preserve">
          <source>OID of the child table currently being scanned. This field is only valid when the phase is &lt;code&gt;acquiring inherited sample rows&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb554635bbb124706c2580bd976000c272a3041" translate="yes" xml:space="preserve">
          <source>OID of the collation used for range comparisons, or 0 if none</source>
          <target state="translated">OID сверки,используемой для сравнения диапазонов,или 0,если нет.</target>
        </trans-unit>
        <trans-unit id="1af1844b19464c23fc7fd9fcae9a412bfe3133ff" translate="yes" xml:space="preserve">
          <source>OID of the data type this transform is for</source>
          <target state="translated">OID типа данных это преобразование для</target>
        </trans-unit>
        <trans-unit id="7be8af1517de8b566e91490637cc744e1bfc4538" translate="yes" xml:space="preserve">
          <source>OID of the database in which the lock target exists, or zero if the target is a shared object, or null if the target is a transaction ID</source>
          <target state="translated">OID базы данных,в которой существует цель блокировки,или ноль,если цель является общим объектом,или ноль,если целью является ID транзакции</target>
        </trans-unit>
        <trans-unit id="d6eff8fed00f101585817bdde7217d409d0452cb" translate="yes" xml:space="preserve">
          <source>OID of the database this backend is connected to</source>
          <target state="translated">OID базы данных,к которой подключен этот бэкэнд.</target>
        </trans-unit>
        <trans-unit id="c3f83d507478524c5f0343641eaf036c1dd5f6f4" translate="yes" xml:space="preserve">
          <source>OID of the database to which this backend is connected.</source>
          <target state="translated">OID базы данных,к которой подключен этот бэкенд.</target>
        </trans-unit>
        <trans-unit id="99d858de93dcac0523dbaa414705f17f8ce20935" translate="yes" xml:space="preserve">
          <source>OID of the database which the subscription resides in</source>
          <target state="translated">OID базы данных,в которой находится подписка.</target>
        </trans-unit>
        <trans-unit id="3c094c24ab67863a7765120475d6a2f2e2e272ea" translate="yes" xml:space="preserve">
          <source>OID of the element type (subtype) of this range type</source>
          <target state="translated">OID типа элемента (подтипа)этого типа диапазона</target>
        </trans-unit>
        <trans-unit id="91964bc019a248521428ce08554d6e0d30140b28" translate="yes" xml:space="preserve">
          <source>OID of the foreign server for this foreign table</source>
          <target state="translated">OID иностранного сервера для этой иностранной таблицы</target>
        </trans-unit>
        <trans-unit id="73727764a13452c62b9dc37a3cc28ff75c10a8fb" translate="yes" xml:space="preserve">
          <source>OID of the foreign-data wrapper of this foreign server</source>
          <target state="translated">OID обертки иностранных данных этого иностранного сервера.</target>
        </trans-unit>
        <trans-unit id="bef000be97274c50b609e7040996c7f3a74549e7" translate="yes" xml:space="preserve">
          <source>OID of the function</source>
          <target state="translated">OID функции</target>
        </trans-unit>
        <trans-unit id="d936ce13d6a2191f0fb1ebd586182169926914bd" translate="yes" xml:space="preserve">
          <source>OID of the function to convert a range value into canonical form, or 0 if none</source>
          <target state="translated">OID функции для преобразования значения диапазона в каноническую форму,или 0,если нет</target>
        </trans-unit>
        <trans-unit id="3de3255d0dade1eabbba67bef7bb7de2117ad3f9" translate="yes" xml:space="preserve">
          <source>OID of the function to return the difference between two element values as &lt;code&gt;double precision&lt;/code&gt;, or 0 if none</source>
          <target state="translated">OID функции, возвращающей разницу между двумя значениями элементов как &lt;code&gt;double precision&lt;/code&gt; , или 0, если нет</target>
        </trans-unit>
        <trans-unit id="04695e3476f4985e5e3d88253bca9d829918ada5" translate="yes" xml:space="preserve">
          <source>OID of the index being created or reindexed. During a non-concurrent &lt;code&gt;CREATE INDEX&lt;/code&gt;, this is 0.</source>
          <target state="translated">OID создаваемого или переиндексируемого индекса. Во время непараллельного &lt;code&gt;CREATE INDEX&lt;/code&gt; это 0.</target>
        </trans-unit>
        <trans-unit id="36fd3faf4abf64d7b63021e96a36b08b96b00ad5" translate="yes" xml:space="preserve">
          <source>OID of the language this transform is for</source>
          <target state="translated">OID языка,для которого это преобразование предназначено</target>
        </trans-unit>
        <trans-unit id="7e460991382ec78ace08e8b50c8809bb0c2a37f4" translate="yes" xml:space="preserve">
          <source>OID of the large object to be altered</source>
          <target state="translated">OID крупного объекта,подлежащего изменению.</target>
        </trans-unit>
        <trans-unit id="1d1d811b028d1d43309ac3a6a9795a5474876c40" translate="yes" xml:space="preserve">
          <source>OID of the local role being mapped, 0 if the user mapping is public</source>
          <target state="translated">OID локальной роли,отображаемой на карте,0,если отображение пользователя публично.</target>
        </trans-unit>
        <trans-unit id="f6befa197b5efdceb1d6e3e97ba6a7089030d83b" translate="yes" xml:space="preserve">
          <source>OID of the lock target within its system catalog, or null if the target is not a general database object</source>
          <target state="translated">OID мишени замка в его системном каталоге,или нулевой,если мишень не является общим объектом БД</target>
        </trans-unit>
        <trans-unit id="547ca9a3f91e95b8778cc1a87f9fe368954503d2" translate="yes" xml:space="preserve">
          <source>OID of the operator</source>
          <target state="translated">OID оператора</target>
        </trans-unit>
        <trans-unit id="57147e7dec8c6552f43472e577611d734b852d01" translate="yes" xml:space="preserve">
          <source>OID of the parser's headline function</source>
          <target state="translated">OID функции заголовка парсера</target>
        </trans-unit>
        <trans-unit id="e75052ec080efa2cb48c4eee33c12247804336c7" translate="yes" xml:space="preserve">
          <source>OID of the parser's lextype function</source>
          <target state="translated">OID лексикографической функции парсера</target>
        </trans-unit>
        <trans-unit id="070d9465021b789c1852df9d85e1dab51aa12f2b" translate="yes" xml:space="preserve">
          <source>OID of the parser's next-token function</source>
          <target state="translated">OID следующей функции парсера</target>
        </trans-unit>
        <trans-unit id="28ddd7cda8c6ae7b671231bc8b5771d3c20a5115" translate="yes" xml:space="preserve">
          <source>OID of the parser's shutdown function</source>
          <target state="translated">OID функции выключения синтаксического анализатора.</target>
        </trans-unit>
        <trans-unit id="3441d838ae5086ffa5ad3452eab23ff3831aa095" translate="yes" xml:space="preserve">
          <source>OID of the parser's startup function</source>
          <target state="translated">OID функции запуска синтаксического анализатора</target>
        </trans-unit>
        <trans-unit id="cf7d55d689e6813249b16676499a1c0b2b7376b1" translate="yes" xml:space="preserve">
          <source>OID of the range type</source>
          <target state="translated">OID типа диапазона</target>
        </trans-unit>
        <trans-unit id="00bba16646f2a65970a0b9e99737c24fb8db4ee2" translate="yes" xml:space="preserve">
          <source>OID of the relation targeted by the lock, or null if the target is not a relation or part of a relation</source>
          <target state="translated">OID отношения,на которое нацеливается замок,или null,если цель не является отношением или частью отношения</target>
        </trans-unit>
        <trans-unit id="10ccac12f9b1c1d8ff7d1e3fe492cab3d5e3c0cd" translate="yes" xml:space="preserve">
          <source>OID of the relation that the worker is synchronizing; null for the main apply worker</source>
          <target state="translated">OID отношения,которое рабочий синхронизирует;ноль для главного применяющего рабочего</target>
        </trans-unit>
        <trans-unit id="64dbbea0aaf12efa0d4ebae8170596e36c349efc" translate="yes" xml:space="preserve">
          <source>OID of the source data type</source>
          <target state="translated">OID типа исходных данных</target>
        </trans-unit>
        <trans-unit id="4ab6e82967b76a601d959c42c032a9613f62366e" translate="yes" xml:space="preserve">
          <source>OID of the subscription</source>
          <target state="translated">OID подписки</target>
        </trans-unit>
        <trans-unit id="529393343c510cc7f43e20828d0d63fb68383a2c" translate="yes" xml:space="preserve">
          <source>OID of the subtype's operator class used for range comparisons</source>
          <target state="translated">OID операторского класса подтипа,используемого для сравнения диапазонов</target>
        </trans-unit>
        <trans-unit id="633257d0b0d38e2fef790525052ae12fd0314ed1" translate="yes" xml:space="preserve">
          <source>OID of the system catalog containing the lock target, or null if the target is not a general database object</source>
          <target state="translated">OID системного каталога,содержащего цель блокировки,или нулевой,если цель не является общим объектом БД</target>
        </trans-unit>
        <trans-unit id="6ba91c2dce09309f79136d3e66a8e5ae37f1fe91" translate="yes" xml:space="preserve">
          <source>OID of the table being analyzed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da84f1d83f2a7ebd175fcdf78bf746dff039dba" translate="yes" xml:space="preserve">
          <source>OID of the table being clustered.</source>
          <target state="translated">OID таблицы сгруппированы.</target>
        </trans-unit>
        <trans-unit id="0e4debb724827a1126e4f0985aac0c3bd73e2728" translate="yes" xml:space="preserve">
          <source>OID of the table being vacuumed.</source>
          <target state="translated">OID стола пылесосят.</target>
        </trans-unit>
        <trans-unit id="e9109406be796a3753b7f074b353cc534267a046" translate="yes" xml:space="preserve">
          <source>OID of the table for this index</source>
          <target state="translated">OID таблицы для этого индекса</target>
        </trans-unit>
        <trans-unit id="50e7e1691ddba39a8ac80c840ffce2b6dd3a48c8" translate="yes" xml:space="preserve">
          <source>OID of the table on which the index is being created.</source>
          <target state="translated">OID таблицы,на которой создается индекс.</target>
        </trans-unit>
        <trans-unit id="090219832be11fe1619b95babe8e9c1e5e92c437" translate="yes" xml:space="preserve">
          <source>OID of the target data type</source>
          <target state="translated">OID целевого типа данных</target>
        </trans-unit>
        <trans-unit id="ac66a3e3aabe35420bf2d2c1e94ee59c9c06a065" translate="yes" xml:space="preserve">
          <source>OID of the template's initialization function</source>
          <target state="translated">OID функции инициализации шаблона</target>
        </trans-unit>
        <trans-unit id="50c0da2d8b347f30166307b39f81117e5e35c3ea" translate="yes" xml:space="preserve">
          <source>OID of the template's lexize function</source>
          <target state="translated">OID лексизационной функции шаблона</target>
        </trans-unit>
        <trans-unit id="a8374b131925b37be69ac971d0b27d489ca95329" translate="yes" xml:space="preserve">
          <source>OID of the user logged into this WAL sender process</source>
          <target state="translated">OID пользователя,вошедшего в этот процесс отправителя WAL</target>
        </trans-unit>
        <trans-unit id="5fe5cd795b2ac38b10709cbfaf75428859cfc40c" translate="yes" xml:space="preserve">
          <source>OID of the user logged into this backend</source>
          <target state="translated">OID пользователя,вошедшего в этот бэкэнд.</target>
        </trans-unit>
        <trans-unit id="ac6509d860cce791cfecdfeff54c3c371229705b" translate="yes" xml:space="preserve">
          <source>OID of the user mapping</source>
          <target state="translated">OID карты пользователя</target>
        </trans-unit>
        <trans-unit id="5cb18008fb6941eebe8d741c085bfe9b7fb69a3f" translate="yes" xml:space="preserve">
          <source>OID of this database, or 0 for objects belonging to a shared relation</source>
          <target state="translated">OID этой базы данных,или 0 для объектов,принадлежащих к общим отношениям</target>
        </trans-unit>
        <trans-unit id="a7af712c7c37a60b529576ed90f30e8cf2d7a00c" translate="yes" xml:space="preserve">
          <source>OID of this index</source>
          <target state="translated">OID этого индекса</target>
        </trans-unit>
        <trans-unit id="d3dd8c985a0eabab21975bbe483a04f61be0cad9" translate="yes" xml:space="preserve">
          <source>OID of user who executed the statement</source>
          <target state="translated">OID пользователя,выполнившего заявление</target>
        </trans-unit>
        <trans-unit id="387852e7a1481866714e0a22f56d3c6e25b3ae5f" translate="yes" xml:space="preserve">
          <source>OIDs assigned during normal database operation are constrained to be 16384 or higher. This ensures that the range 10000&amp;mdash;16383 is free for OIDs assigned automatically by &lt;code&gt;genbki.pl&lt;/code&gt; or during bootstrap. These automatically-assigned OIDs are not considered stable, and may change from one installation to another.</source>
          <target state="translated">OID, назначаемые при нормальной работе базы данных, должны быть 16384 или выше. Это гарантирует, что диапазон 10000&amp;ndash;16383 свободен для OID, автоматически назначаемых &lt;code&gt;genbki.pl&lt;/code&gt; или во время начальной загрузки. Эти автоматически назначаемые OID не считаются стабильными и могут изменяться от одной установки к другой.</target>
        </trans-unit>
        <trans-unit id="a08513f8d6a0456d0e2e3f8053e17f798ea2afa0" translate="yes" xml:space="preserve">
          <source>OLAP</source>
          <target state="translated">OLAP</target>
        </trans-unit>
        <trans-unit id="751cc96735bf8b84aef2fec3e06efb1b1a5b1ccc" translate="yes" xml:space="preserve">
          <source>OLTP</source>
          <target state="translated">OLTP</target>
        </trans-unit>
        <trans-unit id="25e9c7c3a98b268d5dfb9854a9b3f093ee86933f" translate="yes" xml:space="preserve">
          <source>OR &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">ИЛИ &lt;code&gt;tsquery&lt;/code&gt; вместе</target>
        </trans-unit>
        <trans-unit id="204bd21a2ea07120bf9aa428b287753e7d9939bc" translate="yes" xml:space="preserve">
          <source>ORDBMS</source>
          <target state="translated">ORDBMS</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">ЗАКАЗ</target>
        </trans-unit>
        <trans-unit id="8cd49ef586968599e62519504427958da4d48a39" translate="yes" xml:space="preserve">
          <source>ORs two &lt;code&gt;tsquery&lt;/code&gt;s together, producing a query that matches documents that match either input query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="b77e714dbd01a80315e52e6a9d94c65e9f359c98" translate="yes" xml:space="preserve">
          <source>Object Identifier</source>
          <target state="translated">Идентификатор объектов</target>
        </trans-unit>
        <trans-unit id="2ebed2ba0d6eed2f88e2d3187c0748eee35c9c48" translate="yes" xml:space="preserve">
          <source>Object Identifier Types</source>
          <target state="translated">Типы идентификаторов объектов</target>
        </trans-unit>
        <trans-unit id="690a335354f7107071acc3fa67c016dc6bc384da" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: oid</source>
          <target state="translated">Типы идентификаторов объектов:oid</target>
        </trans-unit>
        <trans-unit id="0075fd06325f676dff687ca83f8e432afb05cd0a" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regclass</source>
          <target state="translated">Типы идентификаторов объектов:рег-класс</target>
        </trans-unit>
        <trans-unit id="47d07e7ec3c2bb281acfd4b09b95c7bd692a6146" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regcollation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff60426c655614fda7aef019d73fd45fb97d826" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regconfig</source>
          <target state="translated">Типы идентификаторов объектов:regconfig</target>
        </trans-unit>
        <trans-unit id="dfaba8ba7726385dd9aaa48834af168d2f9ceedf" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regdictionary</source>
          <target state="translated">Типы идентификаторов объектов:прогностический словарь</target>
        </trans-unit>
        <trans-unit id="cc8674af1caee1212cf1ad2d15d842446e9a98aa" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regnamespace</source>
          <target state="translated">Типы идентификаторов объектов:переименование пространства имен</target>
        </trans-unit>
        <trans-unit id="c2b56a3df38b329696180cd377e1ed88251bb409" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regoper</source>
          <target state="translated">Типы идентификаторов объектов:регрессивный</target>
        </trans-unit>
        <trans-unit id="30c72913cd86047f07f98633a45661ed568c2533" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regoperator</source>
          <target state="translated">Типы идентификаторов объектов:реоператор</target>
        </trans-unit>
        <trans-unit id="a48a31a0bb9251c420e48d22aa7c1d09ca5723bd" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regproc</source>
          <target state="translated">Типы идентификаторов объектов:regproc</target>
        </trans-unit>
        <trans-unit id="67cdc0df1aaf8b31658af7a6a45b330191b5746d" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regprocedure</source>
          <target state="translated">Типы идентификаторов объектов:регпроцедура</target>
        </trans-unit>
        <trans-unit id="6c6385e5aae8c21dd4c725971f7b3936a95ef63b" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regrole</source>
          <target state="translated">Типы идентификаторов объектов:регроль</target>
        </trans-unit>
        <trans-unit id="f7695a1c32f9f4d88fc2778bef31cc0d65aad8a7" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regtype</source>
          <target state="translated">Типы идентификаторов объектов:регтип</target>
        </trans-unit>
        <trans-unit id="cadc94239cb6d9721bc9abae7ab74549ddda3fbb" translate="yes" xml:space="preserve">
          <source>Object Type</source>
          <target state="translated">Тип объекта</target>
        </trans-unit>
        <trans-unit id="440eaacb05716029aec3d29f1c4c8f8f3cf112cd" translate="yes" xml:space="preserve">
          <source>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type &lt;code&gt;oid&lt;/code&gt; represents an object identifier. There are also several alias types for &lt;code&gt;oid&lt;/code&gt; named &lt;code&gt;regsomething&lt;/code&gt;. &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;Table 8.26&lt;/a&gt; shows an overview.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486ece6dd89f3c4ea297334b48675b716e4268bd" translate="yes" xml:space="preserve">
          <source>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type &lt;code&gt;oid&lt;/code&gt; represents an object identifier. There are also several alias types for &lt;code&gt;oid&lt;/code&gt;: &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoper&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regrole&lt;/code&gt;, &lt;code&gt;regnamespace&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, and &lt;code&gt;regdictionary&lt;/code&gt;. &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;Table 8.26&lt;/a&gt; shows an overview.</source>
          <target state="translated">Идентификаторы объектов (OID) используются внутри PostgreSQL как первичные ключи для различных системных таблиц. Тип &lt;code&gt;oid&lt;/code&gt; представляет собой идентификатор объекта. Есть также несколько типов псевдонимов для &lt;code&gt;oid&lt;/code&gt; : &lt;code&gt;regproc&lt;/code&gt; , &lt;code&gt;regprocedure&lt;/code&gt; , &lt;code&gt;regoper&lt;/code&gt; , &lt;code&gt;regoperator&lt;/code&gt; , &lt;code&gt;regclass&lt;/code&gt; , &lt;code&gt;regtype&lt;/code&gt; , &lt;code&gt;regrole&lt;/code&gt; , &lt;code&gt;regnamespace&lt;/code&gt; , &lt;code&gt;regconfig&lt;/code&gt; и &lt;code&gt;regdictionary&lt;/code&gt; . &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;Таблица 8.26&lt;/a&gt; показывает обзор.</target>
        </trans-unit>
        <trans-unit id="e6ffe45f664bbe6f6262859df4e3695e1d12153a" translate="yes" xml:space="preserve">
          <source>Object-Relational Database Management System</source>
          <target state="translated">Объектно-реляционная система управления базой данных</target>
        </trans-unit>
        <trans-unit id="ec90b7e160c78de5740196cc2532f466404d90bc" translate="yes" xml:space="preserve">
          <source>Objects can have initial privileges either by having those privileges set when the system is initialized (by initdb) or when the object is created during a &lt;code&gt;CREATE EXTENSION&lt;/code&gt; and the extension script sets initial privileges using the &lt;code&gt;GRANT&lt;/code&gt; system. Note that the system will automatically handle recording of the privileges during the extension script and that extension authors need only use the &lt;code&gt;GRANT&lt;/code&gt; and &lt;code&gt;REVOKE&lt;/code&gt; statements in their script to have the privileges recorded. The &lt;code&gt;privtype&lt;/code&gt; column indicates if the initial privilege was set by initdb or during a &lt;code&gt;CREATE EXTENSION&lt;/code&gt; command.</source>
          <target state="translated">У объектов могут быть начальные привилегии либо при установке этих привилегий при инициализации системы (с помощью initdb), либо при создании объекта во время &lt;code&gt;CREATE EXTENSION&lt;/code&gt; , а сценарий расширения устанавливает начальные привилегии с использованием системы &lt;code&gt;GRANT&lt;/code&gt; . Обратите внимание, что система будет автоматически обрабатывать запись привилегий во время сценария расширения, и что авторам расширений необходимо использовать только операторы &lt;code&gt;GRANT&lt;/code&gt; и &lt;code&gt;REVOKE&lt;/code&gt; в своем сценарии, чтобы записать привилегии. &lt;code&gt;privtype&lt;/code&gt; столбец указывает , если начальная привилегия была установлена initdb или во время &lt;code&gt;CREATE EXTENSION&lt;/code&gt; команды.</target>
        </trans-unit>
        <trans-unit id="8d18be902bfa3d762f98290f3d1e8291c77198c6" translate="yes" xml:space="preserve">
          <source>Objects which have initial privileges set by initdb will have entries where &lt;code&gt;privtype&lt;/code&gt; is &lt;code&gt;'i'&lt;/code&gt;, while objects which have initial privileges set by &lt;code&gt;CREATE EXTENSION&lt;/code&gt; will have entries where &lt;code&gt;privtype&lt;/code&gt; is &lt;code&gt;'e'&lt;/code&gt;.</source>
          <target state="translated">Объекты, у которых есть начальные привилегии, установленные initdb, будут иметь записи, где &lt;code&gt;privtype&lt;/code&gt; равен &lt;code&gt;'i'&lt;/code&gt; , тогда как объекты, которые имеют начальные привилегии, установленные с помощью &lt;code&gt;CREATE EXTENSION&lt;/code&gt; , будут иметь записи, где &lt;code&gt;privtype&lt;/code&gt; равен &lt;code&gt;'e'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f79c201923795ddf3fc3a390dc899926a81383e" translate="yes" xml:space="preserve">
          <source>Objects with equal numbers of pairs are compared in the order:</source>
          <target state="translated">Объекты с одинаковым количеством пар сравниваются в порядке:</target>
        </trans-unit>
        <trans-unit id="40a4edd85bccc1fb19d69c2e2dabe7dd4292f362" translate="yes" xml:space="preserve">
          <source>Observe how in the traditional ICU locale naming system, the root locale is selected by an empty string.</source>
          <target state="translated">Наблюдайте,как в традиционной системе именования локалей ICU корневая локаль выбирается пустой строкой.</target>
        </trans-unit>
        <trans-unit id="82dae9ce3d89138d44c64eb3de8005375bc20848" translate="yes" xml:space="preserve">
          <source>Observe that this kind of partial index requires that the common values be predetermined, so such partial indexes are best used for data distributions that do not change. Such indexes can be recreated occasionally to adjust for new data distributions, but this adds maintenance effort.</source>
          <target state="translated">Обратите внимание,что этот вид частичных индексов требует предопределения общих значений,поэтому такие частичные индексы лучше всего использовать для не меняющихся распределений данных.Такие индексы могут время от времени пересоздаваться,чтобы приспособиться к новым распределениям данных,но это увеличивает усилия по обслуживанию.</target>
        </trans-unit>
        <trans-unit id="d607df7ca6e658558b5841d4666abffe49980352" translate="yes" xml:space="preserve">
          <source>Observe that this match would not succeed if written as</source>
          <target state="translated">Обратите внимание,что это совпадение не удастся,если оно будет написано как</target>
        </trans-unit>
        <trans-unit id="d177dde8092a5f060f1495243a63f697a9a17705" translate="yes" xml:space="preserve">
          <source>Observe two things about the result set:</source>
          <target state="translated">Обратите внимание на две вещи,касающиеся набора результатов:</target>
        </trans-unit>
        <trans-unit id="4201c9715be128e9359f0f8e049514e18476b73a" translate="yes" xml:space="preserve">
          <source>Obsolete version of &lt;code&gt;crosstab(text)&lt;/code&gt;. The parameter &lt;code&gt;N&lt;/code&gt; is now ignored, since the number of value columns is always determined by the calling query</source>
          <target state="translated">Устаревшая версия &lt;code&gt;crosstab(text)&lt;/code&gt; . Параметр &lt;code&gt;N&lt;/code&gt; теперь игнорируется, поскольку количество столбцов значений всегда определяется вызывающим запросом.</target>
        </trans-unit>
        <trans-unit id="7df429ce2fd206ab797db57eb8b6b362392f7035" translate="yes" xml:space="preserve">
          <source>Obsolete version of &lt;code&gt;crosstab(text)&lt;/code&gt;. The parameter &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is now ignored, since the number of value columns is always determined by the calling query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11744d185f0b82d838b338e8988d902a0140f6b7" translate="yes" xml:space="preserve">
          <source>Obtain a &lt;code&gt;SHARE&lt;/code&gt; lock on a primary key table when going to perform inserts into a foreign key table:</source>
          <target state="translated">Получите блокировку &lt;code&gt;SHARE&lt;/code&gt; для таблицы первичного ключа при выполнении вставки в таблицу внешнего ключа:</target>
        </trans-unit>
        <trans-unit id="05c7fc189f9bad2f9b668a2a40c5180d608c005f" translate="yes" xml:space="preserve">
          <source>Obtain exclusive session level advisory lock</source>
          <target state="translated">Получить эксклюзивный консультативный замок на уровне сеанса</target>
        </trans-unit>
        <trans-unit id="019972b3655998bb11d76b53a542ff72a8b76dca" translate="yes" xml:space="preserve">
          <source>Obtain exclusive session level advisory lock if available</source>
          <target state="translated">Получить эксклюзивный консультативный замок на уровне сеанса,если таковой имеется</target>
        </trans-unit>
        <trans-unit id="cbeca9dbec7784436d93a189577fd29e34a7fe37" translate="yes" xml:space="preserve">
          <source>Obtain exclusive transaction level advisory lock</source>
          <target state="translated">Получить эксклюзивный консультационный замок на уровне транзакций</target>
        </trans-unit>
        <trans-unit id="b51bd7cdf3315df0e1b538d8f77d94955e4c6d83" translate="yes" xml:space="preserve">
          <source>Obtain exclusive transaction level advisory lock if available</source>
          <target state="translated">Получить эксклюзивный консультационный замок на уровне транзакций,если он доступен</target>
        </trans-unit>
        <trans-unit id="b1ba75ca9786f988af27bd943f8ef875b87406fc" translate="yes" xml:space="preserve">
          <source>Obtain shared session level advisory lock</source>
          <target state="translated">Получить общий замок для консультаций на уровне сеанса</target>
        </trans-unit>
        <trans-unit id="4efab6b4a18b953adcf6fcfd9c4e7e2bbeb2b169" translate="yes" xml:space="preserve">
          <source>Obtain shared session level advisory lock if available</source>
          <target state="translated">Получить блокировку консультаций на уровне сеанса общего пользования,если таковая имеется</target>
        </trans-unit>
        <trans-unit id="9524c0b6999d2af997e67edd5b67a8f0eafef7e0" translate="yes" xml:space="preserve">
          <source>Obtain shared transaction level advisory lock</source>
          <target state="translated">Получить общий консультационный замок на уровне транзакций</target>
        </trans-unit>
        <trans-unit id="36c2761c3324c27688dc73a65bc20a430c91b936" translate="yes" xml:space="preserve">
          <source>Obtain shared transaction level advisory lock if available</source>
          <target state="translated">Получить консультативный замок на уровне общих транзакций,если он доступен</target>
        </trans-unit>
        <trans-unit id="443dac9c78b1145631de0395325a4f37cac34453" translate="yes" xml:space="preserve">
          <source>Obtain the client's operating system user name from the operating system and check if it matches the requested database user name. This is only available for local connections. See &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt; for details.</source>
          <target state="translated">Получите имя пользователя операционной системы клиента из операционной системы и проверьте, соответствует ли оно запрошенному имени пользователя базы данных. Это доступно только для локальных подключений. См &lt;a href=&quot;auth-peer&quot;&gt;раздел 20.9&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="0e679373412300b3d7cf749daeaf3997d4726aac" translate="yes" xml:space="preserve">
          <source>Obtain the operating system user name of the client by contacting the ident server on the client and check if it matches the requested database user name. Ident authentication can only be used on TCP/IP connections. When specified for local connections, peer authentication will be used instead. See &lt;a href=&quot;auth-ident&quot;&gt;Section 20.8&lt;/a&gt; for details.</source>
          <target state="translated">Получите имя пользователя операционной системы клиента, связавшись с сервером идентификации на клиенте, и проверьте, совпадает ли оно с запрошенным именем пользователя базы данных. Идентификационная аутентификация может использоваться только для соединений TCP / IP. Если указано для локальных подключений, вместо этого будет использоваться одноранговая аутентификация. См &lt;a href=&quot;auth-ident&quot;&gt;раздел 20.8&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="3c565c625c5016da01624ee751e9ac2b988301ee" translate="yes" xml:space="preserve">
          <source>Obtaining the next value is done using the &lt;code&gt;nextval()&lt;/code&gt; function instead of the standard's &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression.</source>
          <target state="translated">Получение следующего значения выполняется с помощью функции &lt;code&gt;nextval()&lt;/code&gt; вместо стандартного выражения &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77c27c2e821d493cd41fdb16ddcdf94550584d81" translate="yes" xml:space="preserve">
          <source>Obtains a shared session-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63cc890455fd4316e991288e66cd3d2f6153525e" translate="yes" xml:space="preserve">
          <source>Obtains a shared session-level advisory lock, waiting if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbea7407ba6bb6ee25b3386cda5d9955692d4486" translate="yes" xml:space="preserve">
          <source>Obtains a shared transaction-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3514ce32dda0a7ae50b8c2a334a5396bb99040f9" translate="yes" xml:space="preserve">
          <source>Obtains a shared transaction-level advisory lock, waiting if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e623c9bebc77403e0def2b4752f5561440ee38bb" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive session-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d59e1d231b4e0bffcbfc5dcc9980161d2e4fdb" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive session-level advisory lock, waiting if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bbbb737cb62d654d3a0339b01c5ad954c39d181" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive transaction-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd08a954b4fc7be94a0c48f352d297308ce7dc5" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive transaction-level advisory lock, waiting if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2c6c6809790186229da7b012c8919a980f66c8" translate="yes" xml:space="preserve">
          <source>Obviously, indexes with non-default sort orderings are a fairly specialized feature, but sometimes they can produce tremendous speedups for certain queries. Whether it's worth maintaining such an index depends on how often you use queries that require a special sort ordering.</source>
          <target state="translated">Очевидно,что индексы с порядком сортировки не по умолчанию являются достаточно специализированной функцией,но иногда они могут приводить к огромным ускорениям при определенных запросах.Стоит ли поддерживать такой индекс,зависит от того,как часто вы используете запросы,требующие особого порядка сортировки.</target>
        </trans-unit>
        <trans-unit id="eb1f89e656ff03a0a31a91974becb3d200ff4b46" translate="yes" xml:space="preserve">
          <source>Obviously, no one should be accessing the clusters during the upgrade. pg_upgrade defaults to running servers on port 50432 to avoid unintended client connections. You can use the same port number for both clusters when doing an upgrade because the old and new clusters will not be running at the same time. However, when checking an old running server, the old and new port numbers must be different.</source>
          <target state="translated">Очевидно,что никто не должен получать доступ к кластерам во время обновления.pg_upgrade по умолчанию запускает серверы на порту 50432,чтобы избежать непреднамеренных клиентских подключений.Вы можете использовать один и тот же номер порта для обоих кластеров при обновлении,потому что старый и новый кластеры не будут работать одновременно.Однако,при проверке старого работающего сервера,старый и новый номера портов должны быть разными.</target>
        </trans-unit>
        <trans-unit id="91a6106fff0646feab85327987f859dce96328f8" translate="yes" xml:space="preserve">
          <source>Obviously, pg_restore cannot restore information that is not present in the archive file. For instance, if the archive was made using the &amp;ldquo;dump data as &lt;code&gt;INSERT&lt;/code&gt; commands&amp;rdquo; option, pg_restore will not be able to load the data using &lt;code&gt;COPY&lt;/code&gt; statements.</source>
          <target state="translated">Очевидно, pg_restore не может восстановить информацию, которой нет в архивном файле. Например, если архив был создан с использованием опции &amp;laquo;выгрузить данные как команды &lt;code&gt;INSERT&lt;/code&gt; &amp;raquo;, pg_restore не сможет загрузить данные с помощью операторов &lt;code&gt;COPY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea9f0a51f8358360ebe5d226327ee6a6dba47689" translate="yes" xml:space="preserve">
          <source>Obviously, two rows are considered distinct if they differ in at least one column value. Null values are considered equal in this comparison.</source>
          <target state="translated">Очевидно,что две строки считаются разными,если они различаются хотя бы в одном столбце.Нулевые значения при этом сравнении считаются равными.</target>
        </trans-unit>
        <trans-unit id="0325b2d5f9478c521e0c1edeceeab6be935d2d2e" translate="yes" xml:space="preserve">
          <source>Occasionally it is useful to mix rules from several locales, e.g., use English collation rules but Spanish messages. To support that, a set of locale subcategories exist that control only certain aspects of the localization rules:</source>
          <target state="translated">Иногда полезно смешивать правила из нескольких локалей,например,использовать английские правила сверки,но сообщения на испанском языке.Для поддержки этого существует набор подкатегорий локалей,которые контролируют только определенные аспекты правил локализации:</target>
        </trans-unit>
        <trans-unit id="51327aef9866e85ef5b5b2294a28494d2715ae59" translate="yes" xml:space="preserve">
          <source>Oct</source>
          <target state="translated">Oct</target>
        </trans-unit>
        <trans-unit id="87206ae2363483496c099f8c3aac5b4a8ae2a66a" translate="yes" xml:space="preserve">
          <source>October</source>
          <target state="translated">October</target>
        </trans-unit>
        <trans-unit id="c07f133434909a3b139ea6fd5087f84900fccadf" translate="yes" xml:space="preserve">
          <source>Of course, a column can have more than one constraint. Just write the constraints one after another:</source>
          <target state="translated">Конечно,столбец может иметь несколько ограничений.Просто пишите ограничения один за другим:</target>
        </trans-unit>
        <trans-unit id="15554cdfd90fe94a0c248e4f64467a3a5d448ea0" translate="yes" xml:space="preserve">
          <source>Of course, each column must be used with operators appropriate to the index type; clauses that involve other operators will not be considered.</source>
          <target state="translated">Конечно,каждая колонка должна использоваться с операторами,соответствующими типу индекса;клаузулы,включающие другие операторы,рассматриваться не будут.</target>
        </trans-unit>
        <trans-unit id="3cfcf640173f2cee55033307859827db1cc0f9ba" translate="yes" xml:space="preserve">
          <source>Of course, if the remote table is not in fact updatable, an error would occur anyway. Use of this option primarily allows the error to be thrown locally without querying the remote server. Note however that the &lt;code&gt;information_schema&lt;/code&gt; views will report a &lt;code&gt;postgres_fdw&lt;/code&gt; foreign table to be updatable (or not) according to the setting of this option, without any check of the remote server.</source>
          <target state="translated">Конечно, если удаленная таблица фактически не обновляется, в любом случае возникнет ошибка. Использование этой опции в первую очередь позволяет выдать ошибку локально, не запрашивая удаленный сервер. Обратите внимание, однако, что представления &lt;code&gt;information_schema&lt;/code&gt; сообщают, что внешняя таблица &lt;code&gt;postgres_fdw&lt;/code&gt; обновляется (или нет) в соответствии с настройкой этой опции, без какой-либо проверки удаленного сервера.</target>
        </trans-unit>
        <trans-unit id="ac88e35965ca0b1056564e9dfa16bc3a086971ee" translate="yes" xml:space="preserve">
          <source>Of course, some SQL database systems might not implement schemas at all, or provide namespace support by allowing (possibly limited) cross-database access. If you need to work with those systems, then maximum portability would be achieved by not using schemas at all.</source>
          <target state="translated">Конечно,некоторые системы баз данных SQL могут вообще не реализовывать схемы или обеспечивать поддержку пространства имён,разрешая (возможно,ограниченный)межбазовый доступ.Если вам нужно работать с этими системами,то максимальная переносимость будет достигнута за счет отказа от использования схем вообще.</target>
        </trans-unit>
        <trans-unit id="b09f440f59472b164c47e7153b71ff603597271c" translate="yes" xml:space="preserve">
          <source>Of course, the &lt;code&gt;SELECT&lt;/code&gt; statement is compatible with the SQL standard. But there are some extensions and some missing features.</source>
          <target state="translated">Конечно, &lt;code&gt;SELECT&lt;/code&gt; совместим со стандартом SQL. Но есть некоторые расширения и некоторые недостающие функции.</target>
        </trans-unit>
        <trans-unit id="b998cb5ccff7c6a6d09f60a802fba18afa38d81f" translate="yes" xml:space="preserve">
          <source>Of course, the argument of a sequence function can be an expression as well as a constant. If it is a text expression then the implicit coercion will result in a run-time lookup.</source>
          <target state="translated">Конечно,аргументом функции последовательности может быть не только константа,но и выражение.Если это текстовое выражение,то неявное принуждение приведет к поиску выполнения.</target>
        </trans-unit>
        <trans-unit id="c8ec66919586aa50108f55c55fa32064846f02f9" translate="yes" xml:space="preserve">
          <source>Of course, the number and type of the constrained columns need to match the number and type of the referenced columns.</source>
          <target state="translated">Конечно,количество и тип ограниченных колонок должны соответствовать количеству и типу соответствующих колонок.</target>
        </trans-unit>
        <trans-unit id="608089afae6cc6682d178112cb3562d38642d49b" translate="yes" xml:space="preserve">
          <source>Of course, the previous example was heavily contrived. Normally, you would give names to your tables and columns that convey what kind of data they store. So let's look at a more realistic example:</source>
          <target state="translated">Конечно,предыдущий пример был сильно придуман.Обычно вы давали имена таблицам и столбцам,которые передавали,какие данные они хранят.Так что давайте рассмотрим более реалистичный пример:</target>
        </trans-unit>
        <trans-unit id="cdf2e77434f0f6336db99d58530ea7e875d07b42" translate="yes" xml:space="preserve">
          <source>Of course, the specific numbers shown here depend on the actual contents of the tables involved. Also note that the numbers, and even the selected query strategy, might vary between PostgreSQL releases due to planner improvements. In addition, the &lt;code&gt;ANALYZE&lt;/code&gt; command uses random sampling to estimate data statistics; therefore, it is possible for cost estimates to change after a fresh run of &lt;code&gt;ANALYZE&lt;/code&gt;, even if the actual distribution of data in the table has not changed.</source>
          <target state="translated">Конечно, конкретные числа, показанные здесь, зависят от фактического содержания задействованных таблиц. Также обратите внимание, что числа и даже выбранная стратегия запросов могут различаться между выпусками PostgreSQL из-за улучшений планировщика. Кроме того, команда &lt;code&gt;ANALYZE&lt;/code&gt; использует случайную выборку для оценки статистики данных; следовательно, оценка затрат может измениться после нового запуска &lt;code&gt;ANALYZE&lt;/code&gt; , даже если фактическое распределение данных в таблице не изменилось.</target>
        </trans-unit>
        <trans-unit id="a685091dfb5c40427eaec8e993f66849819cf14d" translate="yes" xml:space="preserve">
          <source>Of the character-entry escapes described in &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.19&lt;/a&gt;, XQuery supports only &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\t&lt;/code&gt;.</source>
          <target state="translated">Из escape-символов ввода, описанных в &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Таблице 9.19&lt;/a&gt; , XQuery поддерживает только &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; и &lt;code&gt;\t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c662143ec7a1becd10a1701782d2d5b95c4d60a8" translate="yes" xml:space="preserve">
          <source>Of the character-entry escapes described in &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;, XQuery supports only &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7f91ef8e30ab71323f7f16c956192d29cee4ea" translate="yes" xml:space="preserve">
          <source>Of the two operator classes for type &lt;code&gt;jsonb&lt;/code&gt;, &lt;code&gt;jsonb_ops&lt;/code&gt; is the default. &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports fewer operators but offers better performance for those operators. See &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt; for details.</source>
          <target state="translated">Из двух классов операторов для типа &lt;code&gt;jsonb&lt;/code&gt; , &lt;code&gt;jsonb_ops&lt;/code&gt; по умолчанию. &lt;code&gt;jsonb_path_ops&lt;/code&gt; поддерживает меньшее количество операторов, но обеспечивает лучшую производительность для этих операторов. См &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;раздел 8.14.4&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="34c9deaa906dcefa70af958d1df36fd494f6477e" translate="yes" xml:space="preserve">
          <source>Of the two operator classes for type &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;quad_point_ops&lt;/code&gt; is the default. &lt;code&gt;kd_point_ops&lt;/code&gt; supports the same operators but uses a different index data structure that may offer better performance in some applications.</source>
          <target state="translated">Из двух классов операторов для типа &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;quad_point_ops&lt;/code&gt; по умолчанию. &lt;code&gt;kd_point_ops&lt;/code&gt; поддерживает те же операторы, но использует другую структуру данных индекса, которая может обеспечить лучшую производительность в некоторых приложениях.</target>
        </trans-unit>
        <trans-unit id="823b07791eec5c49089c2fa31c806093113182bb" translate="yes" xml:space="preserve">
          <source>Of these extensions, &lt;code&gt;jsonb_plperl&lt;/code&gt; is considered &amp;ldquo;trusted&amp;rdquo;, that is, it can be installed by non-superusers who have &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database. The rest require superuser privilege to install.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7fdb11d6c25f66601f3fb8a8f5b8fcc9b0822b" translate="yes" xml:space="preserve">
          <source>Offset from UTC (positive means east of Greenwich)</source>
          <target state="translated">Смещение от UTC (положительное значение к востоку от Гринвича)</target>
        </trans-unit>
        <trans-unit id="1981d8aed8642cc19a01ec017cd302822eb99a80" translate="yes" xml:space="preserve">
          <source>Offset to end of free space</source>
          <target state="translated">Смещение до конца свободного пространства</target>
        </trans-unit>
        <trans-unit id="e27e1909bffb440ac18ed4f49dfc030d3bf289b3" translate="yes" xml:space="preserve">
          <source>Offset to start of free space</source>
          <target state="translated">Смещение к началу свободного пространства</target>
        </trans-unit>
        <trans-unit id="96263ee552b7638e48664d80735a522bd69e2d15" translate="yes" xml:space="preserve">
          <source>Offset to start of special space</source>
          <target state="translated">Смещение к началу специального пространства</target>
        </trans-unit>
        <trans-unit id="7f9b46694e3dc059ec6a436a3380fe755ceb8f95" translate="yes" xml:space="preserve">
          <source>Often you will want to create a schema owned by someone else (since this is one of the ways to restrict the activities of your users to well-defined namespaces). The syntax for that is:</source>
          <target state="translated">Часто вам захочется создать схему,принадлежащую кому-то другому (поскольку это один из способов ограничить деятельность ваших пользователей четко определенными пространствами имен).Синтаксис для этого:</target>
        </trans-unit>
        <trans-unit id="aa524be3205ddb773bfe2be8f0cbe395871121b5" translate="yes" xml:space="preserve">
          <source>Okay, the worst has happened and you need to recover from your backup. Here is the procedure:</source>
          <target state="translated">Ладно,случилось худшее,и тебе нужно восстановиться из резервной копии.Вот процедура:</target>
        </trans-unit>
        <trans-unit id="16be0330fc822ce35047bcbe410657ce60f50c0e" translate="yes" xml:space="preserve">
          <source>Older Linux kernels do not offer &lt;code&gt;/proc/self/oom_score_adj&lt;/code&gt;, but may have a previous version of the same functionality called &lt;code&gt;/proc/self/oom_adj&lt;/code&gt;. This works the same except the disable value is &lt;code&gt;-17&lt;/code&gt; not &lt;code&gt;-1000&lt;/code&gt;.</source>
          <target state="translated">Старые ядра Linux не предлагают &lt;code&gt;/proc/self/oom_score_adj&lt;/code&gt; , но могут иметь предыдущую версию той же функции, которая называется &lt;code&gt;/proc/self/oom_adj&lt;/code&gt; . Это работает так же, за исключением того, что значение отключения &lt;code&gt;-17&lt;/code&gt; ,а не &lt;code&gt;-1000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ced6ddc46443201e8e3d960abac900f5903d1b39" translate="yes" xml:space="preserve">
          <source>Older PostgreSQL versions do not have this setting and always use the client's preferences. This setting is mainly for backward compatibility with those versions. Using the server's preferences is usually better because it is more likely that the server is appropriately configured.</source>
          <target state="translated">Старые версии PostgreSQL не имеют такой настройки и всегда используют предпочтения клиента.Эта настройка в основном предназначена для обратной совместимости с этими версиями.Использование предпочтений сервера обычно лучше,потому что более вероятно,что сервер настроен соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="b76ff612400899f457b05452321eac3486e8a6ab" translate="yes" xml:space="preserve">
          <source>Oldest unpruned XMAX on page, or zero if none</source>
          <target state="translated">Старейший необработанный XMAX на странице,или ноль,если нет</target>
        </trans-unit>
        <trans-unit id="794b92ddcf68cabe2809fe5836f4849010daf46d" translate="yes" xml:space="preserve">
          <source>Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:obartunov@postgrespro.ru&quot;&gt;obartunov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">Олег &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:obartunov@postgrespro.ru&quot;&gt;obartunov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; &amp;lt; obartunov@postgrespro.ru &amp;gt; , Postgres Professional, Москва, Россия</target>
        </trans-unit>
        <trans-unit id="21c3dce2dbff52b671e09984835bd018b576e577" translate="yes" xml:space="preserve">
          <source>Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Moscow University, Russia</source>
          <target state="translated">Олег &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; &amp;lt; oleg@sai.msu.su &amp;gt; , Москва, Московский университет, Россия</target>
        </trans-unit>
        <trans-unit id="c57ccf7fdc0e782593eaa681140c5d9ba28fcdd1" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;ROW()&lt;/code&gt; syntax in the common case where only one field needs to be checked to recognize a cycle. This allows a simple array rather than a composite-type array to be used, gaining efficiency.</source>
          <target state="translated">Опускайте синтаксис &lt;code&gt;ROW()&lt;/code&gt; в общем случае, когда необходимо проверить только одно поле для распознавания цикла. Это позволяет использовать простой массив, а не массив составного типа, что повышает эффективность.</target>
        </trans-unit>
        <trans-unit id="263c5dac706b853afb054876ee3140dcdc435cf6" translate="yes" xml:space="preserve">
          <source>Omitted &lt;code&gt;FROM&lt;/code&gt; Clauses</source>
          <target state="translated">Опущено &lt;code&gt;FROM&lt;/code&gt; пунктов</target>
        </trans-unit>
        <trans-unit id="46b3737570e6db5d4ea7e5047dd8b127387b63f0" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;AS&lt;/code&gt; Key Word</source>
          <target state="translated">Пропуск ключевого слова &lt;code&gt;AS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22a45e27f71c292f06706c737b69fd6802e9347f" translate="yes" xml:space="preserve">
          <source>On FreeBSD, IDE drives can be queried using &lt;code&gt;atacontrol&lt;/code&gt; and write caching turned off using &lt;code&gt;hw.ata.wc=0&lt;/code&gt; in &lt;code&gt;/boot/loader.conf&lt;/code&gt;; SCSI drives can be queried using &lt;code&gt;camcontrol identify&lt;/code&gt;, and the write cache both queried and changed using &lt;code&gt;sdparm&lt;/code&gt; when available.</source>
          <target state="translated">В FreeBSD диски IDE можно запрашивать с помощью &lt;code&gt;atacontrol&lt;/code&gt; , а кэширование записи можно отключить с помощью &lt;code&gt;hw.ata.wc=0&lt;/code&gt; в &lt;code&gt;/boot/loader.conf&lt;/code&gt; ; &lt;code&gt;camcontrol identify&lt;/code&gt; SCSI можно запрашивать с помощью camcontrol identify , а кэш записи запрашивать и изменять с помощью &lt;code&gt;sdparm&lt;/code&gt; , если он доступен.</target>
        </trans-unit>
        <trans-unit id="d39ed9f52193cbb9703d5a56c5956b148e841314" translate="yes" xml:space="preserve">
          <source>On Linux 2.6 and later, it is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">В Linux 2.6 и более поздних версиях можно изменить поведение ядра, чтобы оно не &amp;laquo;перегружало&amp;raquo; память. Хотя этот параметр не предотвратит &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;запуск OOM-убийцы в&lt;/a&gt; целом, он значительно снизит шансы и, следовательно, приведет к более надежному поведению системы. Это делается путем выбора режима строгой избыточной фиксации через &lt;code&gt;sysctl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="501ddfe2d2530fe9fcac7688b14da5778270cdb1" translate="yes" xml:space="preserve">
          <source>On Linux &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; determines the maximum number of open files that the kernel will support. It can be changed by writing a different number into the file or by adding an assignment in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. The maximum limit of files per process is fixed at the time the kernel is compiled; see &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; for more information.</source>
          <target state="translated">В Linux &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; определяет максимальное количество открытых файлов, которые поддерживает ядро. Его можно изменить, записав другой номер в файл или добавив назначение в &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; . Максимальный предел файлов для каждого процесса фиксируется во время компиляции ядра; см. &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f009fe3fb04da9e8adcc93565c99cbfd73e2affe" translate="yes" xml:space="preserve">
          <source>On Linux and POSIX platforms &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_after&lt;/a&gt; allows to force the OS that pages written by the checkpoint should be flushed to disk after a configurable number of bytes. Otherwise, these pages may be kept in the OS's page cache, inducing a stall when &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint. This setting will often help to reduce transaction latency, but it also can have an adverse effect on performance; particularly for workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache.</source>
          <target state="translated">На платформах Linux и POSIX &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_after&lt;/a&gt; позволяет заставить ОС сбрасывать страницы, записанные контрольной точкой, на диск после настраиваемого количества байтов. В противном случае эти страницы могут храниться в кэше страниц ОС, вызывая остановку, когда &lt;code&gt;fsync&lt;/code&gt; запускается в конце контрольной точки. Этот параметр часто помогает уменьшить задержку транзакции, но также может отрицательно сказаться на производительности; особенно для рабочих нагрузок, которые больше, чем &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; , но меньше, чем кеш страниц ОС.</target>
        </trans-unit>
        <trans-unit id="c936f58f7f62e48372e8a8076ff322928b68bb04" translate="yes" xml:space="preserve">
          <source>On Linux or Unix systems, you might use:</source>
          <target state="translated">На Linux или Unix системах,вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="3f7c8c1bd4d71387a1210efd816cb3bef4ae3f74" translate="yes" xml:space="preserve">
          <source>On Linux systems either add</source>
          <target state="translated">В системах Linux либо добавьте</target>
        </trans-unit>
        <trans-unit id="dc805fd8588880f607d3f4520d6ee5e450aee68a" translate="yes" xml:space="preserve">
          <source>On Linux, IDE and SATA drives can be queried using &lt;code&gt;hdparm -I&lt;/code&gt;; write caching is enabled if there is a &lt;code&gt;*&lt;/code&gt; next to &lt;code&gt;Write cache&lt;/code&gt;. &lt;code&gt;hdparm -W 0&lt;/code&gt; can be used to turn off write caching. SCSI drives can be queried using &lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;sdparm&lt;/a&gt;. Use &lt;code&gt;sdparm --get=WCE&lt;/code&gt; to check whether the write cache is enabled and &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; to disable it.</source>
          <target state="translated">В Linux можно запросить диски IDE и SATA с помощью &lt;code&gt;hdparm -I&lt;/code&gt; ; кэширование записи включено, если рядом с &lt;code&gt;Write cache&lt;/code&gt; стоит &lt;code&gt;*&lt;/code&gt; . &lt;code&gt;hdparm -W 0&lt;/code&gt; можно использовать для отключения кэширования записи. &lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;Дисководы&lt;/a&gt; SCSI можно запросить с помощью sdparm . Используйте &lt;code&gt;sdparm --get=WCE&lt;/code&gt; , чтобы проверить, включен ли кеш записи, и &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; , чтобы отключить его.</target>
        </trans-unit>
        <trans-unit id="55da6c1d848d4260b86ebf92495a2847786e7138" translate="yes" xml:space="preserve">
          <source>On Microsoft Windows, also:</source>
          <target state="translated">И на Microsoft Windows тоже:</target>
        </trans-unit>
        <trans-unit id="3630213a83c6eeeff64f72e78908e323507bf7bd" translate="yes" xml:space="preserve">
          <source>On NetBSD, use either the FreeBSD or Linux start scripts, depending on preference.</source>
          <target state="translated">На NetBSD используйте либо скрипты запуска FreeBSD,либо Linux,в зависимости от предпочтений.</target>
        </trans-unit>
        <trans-unit id="ba742d094af1abbc78f9a3859fd3be730c7188af" translate="yes" xml:space="preserve">
          <source>On OpenBSD, add the following lines to the file &lt;code&gt;/etc/rc.local&lt;/code&gt;:</source>
          <target state="translated">В OpenBSD добавьте следующие строки в файл &lt;code&gt;/etc/rc.local&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6c2c1726b1c50e52c768b284b11ed29bfb8afb96" translate="yes" xml:space="preserve">
          <source>On Solaris, create a file called &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; that contains the following line:</source>
          <target state="translated">В Solaris создайте файл с именем &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; , содержащий следующую строку:</target>
        </trans-unit>
        <trans-unit id="2bb8949d83fc7ef1475b557895bfe563a925aea9" translate="yes" xml:space="preserve">
          <source>On Solaris, the disk write cache is controlled by &lt;code&gt;format -e&lt;/code&gt;. (The Solaris ZFS file system is safe with disk write-cache enabled because it issues its own disk cache flush commands.)</source>
          <target state="translated">В Solaris кэш записи на диск управляется &lt;code&gt;format -e&lt;/code&gt; . (Файловая система Solaris ZFS безопасна с включенным дисковым кешем записи, поскольку она выдает собственные команды очистки дискового кеша.)</target>
        </trans-unit>
        <trans-unit id="d85af98780490009a295939145f84e031804f11c" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter reports the permissions of the data directory defined by (&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;) at startup. (On Microsoft Windows this parameter will always display &lt;code&gt;0700&lt;/code&gt;). See &lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;group access&lt;/a&gt; for more information.</source>
          <target state="translated">В системах Unix этот параметр сообщает о разрешениях каталога данных, определенного параметром ( &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt; ) при запуске. (В Microsoft Windows для этого параметра всегда отображается &lt;code&gt;0700&lt;/code&gt; ). См. &lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;Групповой доступ&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="5d93a70eed193dd90ef032ea7d63d19a6516eb0a" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter sets the permissions for log files when &lt;code&gt;logging_collector&lt;/code&gt; is enabled. (On Microsoft Windows this parameter is ignored.) The parameter value is expected to be a numeric mode specified in the format accepted by the &lt;code&gt;chmod&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; system calls. (To use the customary octal format the number must start with a &lt;code&gt;0&lt;/code&gt; (zero).)</source>
          <target state="translated">В системах Unix этот параметр устанавливает разрешения для файлов журнала, когда включен &lt;code&gt;logging_collector&lt;/code&gt; . (В Microsoft Windows этот параметр игнорируется.) Ожидается, что значение параметра будет числовым режимом, указанным в формате, принимаемом системными вызовами &lt;code&gt;chmod&lt;/code&gt; и &lt;code&gt;umask&lt;/code&gt; . (Чтобы использовать обычный восьмеричный формат, число должно начинаться с &lt;code&gt;0&lt;/code&gt; (нуля).)</target>
        </trans-unit>
        <trans-unit id="aec768083a143a16efefa19e77bcef93265299f5" translate="yes" xml:space="preserve">
          <source>On Unix systems, the permissions on &lt;code&gt;server.key&lt;/code&gt; must disallow any access to world or group; achieve this by the command &lt;code&gt;chmod 0600 server.key&lt;/code&gt;. Alternatively, the file can be owned by root and have group read access (that is, &lt;code&gt;0640&lt;/code&gt; permissions). That setup is intended for installations where certificate and key files are managed by the operating system. The user under which the PostgreSQL server runs should then be made a member of the group that has access to those certificate and key files.</source>
          <target state="translated">В системах Unix разрешения на &lt;code&gt;server.key&lt;/code&gt; должны запрещать любой доступ к миру или группе; добиться этого с помощью команды &lt;code&gt;chmod 0600 server.key&lt;/code&gt; . В качестве альтернативы файл может принадлежать пользователю root и иметь групповой доступ на чтение (то есть разрешения &lt;code&gt;0640&lt;/code&gt; ). Эта установка предназначена для установок, в которых файлы сертификатов и ключей управляются операционной системой. Затем пользователь, от имени которого работает сервер PostgreSQL, должен быть включен в группу, имеющую доступ к этим файлам сертификатов и ключей.</target>
        </trans-unit>
        <trans-unit id="e0de69e7d7ec6add644868e783650d15d55a6f2e" translate="yes" xml:space="preserve">
          <source>On Windows hosts, preloading a library at server start will not reduce the time required to start each new server process; each server process will re-load all preload libraries. However, &lt;code&gt;shared_preload_libraries&lt;/code&gt; is still useful on Windows hosts for libraries that need to perform operations at postmaster start time.</source>
          <target state="translated">На хостах Windows предварительная загрузка библиотеки при запуске сервера не сокращает время, необходимое для запуска каждого нового серверного процесса; каждый серверный процесс перезагружает все библиотеки предварительной загрузки. Однако &lt;code&gt;shared_preload_libraries&lt;/code&gt; по-прежнему полезен на хостах Windows для библиотек, которым необходимо выполнять операции во время запуска postmaster.</target>
        </trans-unit>
        <trans-unit id="08c92789aa023ae69cee69a7db7a2ae77f278c4c" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;wal_sync_method&lt;/code&gt; is &lt;code&gt;open_datasync&lt;/code&gt; (the default), write caching can be disabled by unchecking &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt;. Alternatively, set &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync&lt;/code&gt; or &lt;code&gt;fsync_writethrough&lt;/code&gt;, which prevent write caching.</source>
          <target state="translated">В Windows, если &lt;code&gt;wal_sync_method&lt;/code&gt; - &lt;code&gt;open_datasync&lt;/code&gt; (по умолчанию), кеширование записи можно отключить , сняв флажок &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt; . В качестве альтернативы установите для &lt;code&gt;wal_sync_method&lt;/code&gt; значение &lt;code&gt;fsync&lt;/code&gt; или &lt;code&gt;fsync_writethrough&lt;/code&gt; , которые предотвращают кэширование записи.</target>
        </trans-unit>
        <trans-unit id="81eec3e42d4f18ead15b1e929550fb213358fb1f" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 1 second, since Windows does not provide a way to read the system default value.</source>
          <target state="translated">В Windows установка значения 0 устанавливает этот параметр на 1 секунду,поскольку Windows не предоставляет способа чтения значения по умолчанию системы.</target>
        </trans-unit>
        <trans-unit id="53478c470af75305cb8745b03e7cb49bde700061" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 2 hours, since Windows does not provide a way to read the system default value.</source>
          <target state="translated">В Windows установка значения 0 установит этот параметр на 2 часа,поскольку Windows не предоставляет способа чтения системного значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c0312ea0b4215b07b7b0ad5539831203f3c1aa4d" translate="yes" xml:space="preserve">
          <source>On Windows, when you use the &lt;code&gt;eventlog&lt;/code&gt; option for &lt;code&gt;log_destination&lt;/code&gt;, you should register an event source and its library with the operating system so that the Windows Event Viewer can display event log messages cleanly. See &lt;a href=&quot;event-log-registration&quot;&gt;Section 18.12&lt;/a&gt; for details.</source>
          <target state="translated">В операционной системе Windows, при использовании &lt;code&gt;eventlog&lt;/code&gt; опции для &lt;code&gt;log_destination&lt;/code&gt; , вы должны зарегистрировать источник событий и его библиотеку с операционной системой , так что просмотр событий Windows может отображать сообщения журнала событий чисто. См &lt;a href=&quot;event-log-registration&quot;&gt;раздел 18.12&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="fed4544374a90927980cc01194ee5bade4dcaae9" translate="yes" xml:space="preserve">
          <source>On a hot standby, the status of the WAL receiver process can be retrieved via the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;&lt;code&gt;pg_stat_wal_receiver&lt;/code&gt;&lt;/a&gt; view. A large difference between &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; and the view's &lt;code&gt;flushed_lsn&lt;/code&gt; indicates that WAL is being received faster than it can be replayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ae51b938e943ee6107b7e5c25bdb8c42c5ee40" translate="yes" xml:space="preserve">
          <source>On a hot standby, the status of the WAL receiver process can be retrieved via the &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; view. A large difference between &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; and the view's &lt;code&gt;received_lsn&lt;/code&gt; indicates that WAL is being received faster than it can be replayed.</source>
          <target state="translated">В горячем резерве состояние процесса-получателя WAL можно получить через представление &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; . Большая разница между &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; , и вид в &lt;code&gt;received_lsn&lt;/code&gt; указывает на то, что WAL время приема быстрее , чем это может быть переигран.</target>
        </trans-unit>
        <trans-unit id="a87ef11e5bf076fa4c6ca218448b2458c3ebe4c9" translate="yes" xml:space="preserve">
          <source>On all currently supported platforms, the &lt;code&gt;real&lt;/code&gt; type has a range of around 1E-37 to 1E+37 with a precision of at least 6 decimal digits. The &lt;code&gt;double precision&lt;/code&gt; type has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits. Values that are too large or too small will cause an error. Rounding might take place if the precision of an input number is too high. Numbers too close to zero that are not representable as distinct from zero will cause an underflow error.</source>
          <target state="translated">На всех поддерживаемых в настоящее время платформах &lt;code&gt;real&lt;/code&gt; тип имеет диапазон от 1E-37 до 1E + 37 с точностью не менее 6 десятичных знаков. Тип &lt;code&gt;double precision&lt;/code&gt; имеет диапазон от 1E-307 до 1E + 308 с точностью не менее 15 цифр. Слишком большие или слишком маленькие значения вызовут ошибку. Округление может произойти, если точность введенного числа слишком высока. Слишком близкие к нулю числа, которые нельзя представить как отличные от нуля, вызовут ошибку потери значимости.</target>
        </trans-unit>
        <trans-unit id="fc9f60ea02e43afcbb3f8733c606556d9627a339" translate="yes" xml:space="preserve">
          <source>On all platforms, the collations named &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; are available. Additional collations may be available depending on operating system support. The &lt;code&gt;default&lt;/code&gt; collation selects the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; values specified at database creation time. The &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;POSIX&lt;/code&gt; collations both specify &amp;ldquo;traditional C&amp;rdquo; behavior, in which only the ASCII letters &amp;ldquo;&lt;code&gt;A&lt;/code&gt;&amp;rdquo; through &amp;ldquo;&lt;code&gt;Z&lt;/code&gt;&amp;rdquo; are treated as letters, and sorting is done strictly by character code byte values.</source>
          <target state="translated">На всех платформах доступны сопоставления с именами &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;POSIX&lt;/code&gt; . Дополнительные параметры сортировки могут быть доступны в зависимости от поддержки операционной системы. &lt;code&gt;default&lt;/code&gt; параметры сортировки выбирает &lt;code&gt;LC_COLLATE&lt;/code&gt; и &lt;code&gt;LC_CTYPE&lt;/code&gt; значения , указанные при создании базы данных. Параметры сопоставления &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;POSIX&lt;/code&gt; определяют &amp;laquo;традиционное поведение C&amp;raquo;, при котором только буквы ASCII от &amp;laquo; &lt;code&gt;A&lt;/code&gt; &amp;raquo; до &amp;laquo; &lt;code&gt;Z&lt;/code&gt; &amp;raquo; обрабатываются как буквы, а сортировка выполняется строго по байтовым значениям символьного кода.</target>
        </trans-unit>
        <trans-unit id="1c0634f5bf5f884787664141e116cb74ad234b48" translate="yes" xml:space="preserve">
          <source>On error, the server can abort the authentication at any stage, and send an ErrorMessage.</source>
          <target state="translated">По ошибке сервер может прервать аутентификацию на любом этапе и отправить ErrorMessage.</target>
        </trans-unit>
        <trans-unit id="5350086780663aaf1bd7a44ba47818175298a073" translate="yes" xml:space="preserve">
          <source>On macOS, write caching can be prevented by setting &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync_writethrough&lt;/code&gt;.</source>
          <target state="translated">В macOS кэширование записи можно предотвратить, установив для &lt;code&gt;wal_sync_method&lt;/code&gt; значение &lt;code&gt;fsync_writethrough&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="befd8f0dca607b26fc6d2d970cd74ce25f6b225a" translate="yes" xml:space="preserve">
          <source>On many systems, however, syslog is not very reliable, particularly with large log messages; it might truncate or drop messages just when you need them the most. Also, on Linux, syslog will flush each message to disk, yielding poor performance. (You can use a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; at the start of the file name in the syslog configuration file to disable syncing.)</source>
          <target state="translated">Однако во многих системах системный журнал не очень надежен, особенно с большими сообщениями журнала; он может обрезать или отбрасывать сообщения именно тогда, когда они вам больше всего нужны. Кроме того, в Linux системный журнал сбрасывает каждое сообщение на диск, что снижает производительность. (Вы можете использовать &amp;laquo; &lt;code&gt;-&lt;/code&gt; &amp;raquo; в начале имени файла в файле конфигурации системного журнала, чтобы отключить синхронизацию.)</target>
        </trans-unit>
        <trans-unit id="cb6093f7e35a1c20e326af32dcefbf608a486601" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, PostgreSQL modifies its command title as reported by &lt;code&gt;ps&lt;/code&gt;, so that individual server processes can readily be identified. A sample display is</source>
          <target state="translated">На большинстве платформ Unix PostgreSQL изменяет заголовок своей команды, как сообщает &lt;code&gt;ps&lt;/code&gt; , чтобы можно было легко идентифицировать отдельные серверные процессы. Образец дисплея</target>
        </trans-unit>
        <trans-unit id="d3b91e78aa6712803e0d5864f8e480013e5bf3c9" translate="yes" xml:space="preserve">
          <source>On most Unix systems, you will need to alter the configuration of your system's syslog daemon in order to make use of the syslog option for &lt;code&gt;log_destination&lt;/code&gt;. PostgreSQL can log to syslog facilities &lt;code&gt;LOCAL0&lt;/code&gt; through &lt;code&gt;LOCAL7&lt;/code&gt; (see &lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;syslog_facility&lt;/a&gt;), but the default syslog configuration on most platforms will discard all such messages. You will need to add something like:</source>
          <target state="translated">В большинстве систем Unix вам нужно будет изменить конфигурацию вашего системного демона syslog, чтобы использовать параметр syslog для &lt;code&gt;log_destination&lt;/code&gt; . PostgreSQL может вести журнал в средствах системного журнала с &lt;code&gt;LOCAL0&lt;/code&gt; по &lt;code&gt;LOCAL7&lt;/code&gt; (см. &lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;Syslog_facility&lt;/a&gt; ), но конфигурация системного журнала по умолчанию на большинстве платформ отбрасывает все такие сообщения. Вам нужно будет добавить что-то вроде:</target>
        </trans-unit>
        <trans-unit id="50e3c6b1dcc491688ab2b7696ca3d74d8a9db77d" translate="yes" xml:space="preserve">
          <source>On most modern operating systems, PostgreSQL can determine which character set is implied by the &lt;code&gt;LC_CTYPE&lt;/code&gt; setting, and it will enforce that only the matching database encoding is used. On older systems it is your responsibility to ensure that you use the encoding expected by the locale you have selected. A mistake in this area is likely to lead to strange behavior of locale-dependent operations such as sorting.</source>
          <target state="translated">В большинстве современных операционных систем PostgreSQL может определить, какой набор символов подразумевается параметром &lt;code&gt;LC_CTYPE&lt;/code&gt; , и обеспечит использование только соответствующей кодировки базы данных. В старых системах вы несете ответственность за использование кодировки, ожидаемой выбранной вами локалью. Ошибка в этой области может привести к странному поведению операций, зависящих от локали, таких как сортировка.</target>
        </trans-unit>
        <trans-unit id="b2260de2d5df529fa47da0a7e6dd5d8bb23e03ee" translate="yes" xml:space="preserve">
          <source>On most platforms, if PostgreSQL is built with &lt;code&gt;--enable-dtrace&lt;/code&gt;, the arguments to a trace macro will be evaluated whenever control passes through the macro, &lt;em&gt;even if no tracing is being done&lt;/em&gt;. This is usually not worth worrying about if you are just reporting the values of a few local variables. But beware of putting expensive function calls into the arguments. If you need to do that, consider protecting the macro with a check to see if the trace is actually enabled:</source>
          <target state="translated">На большинстве платформ, если PostgreSQL построен с &lt;code&gt;--enable-dtrace&lt;/code&gt; , аргументы макроса трассировки будут оцениваться всякий раз, когда управление проходит через макрос, &lt;em&gt;даже если трассировка не выполняется&lt;/em&gt; . Обычно об этом не стоит беспокоиться, если вы просто сообщаете значения нескольких локальных переменных. Но остерегайтесь помещать в аргументы дорогостоящие вызовы функций. Если вам нужно это сделать, подумайте о защите макроса с помощью проверки, действительно ли трассировка включена:</target>
        </trans-unit>
        <trans-unit id="d1a020e1e97e31739abdd2c2ef2354878b9e297e" translate="yes" xml:space="preserve">
          <source>On one system, an &lt;code&gt;EXPLAIN&lt;/code&gt; showed a query with a cost of 8488 was reduced to a cost of 329. The original query was a join involving the &lt;code&gt;one_to_many&lt;/code&gt; table, which was replaced by:</source>
          <target state="translated">В одной системе &lt;code&gt;EXPLAIN&lt;/code&gt; показал, что запрос со стоимостью 8488 был уменьшен до стоимости 329. Исходный запрос представлял собой соединение с &lt;code&gt;one_to_many&lt;/code&gt; таблицы one_to_many , которое было заменено на:</target>
        </trans-unit>
        <trans-unit id="46913037bc93da8c08a056c91624219985822221" translate="yes" xml:space="preserve">
          <source>On output, double quotes always surround keys and values, even when it's not strictly necessary.</source>
          <target state="translated">На выходе двойные кавычки всегда окружают клавиши и значения,даже если в этом нет строгой необходимости.</target>
        </trans-unit>
        <trans-unit id="bac2b8b67734755e62d6acef24655269b5ebc6a2" translate="yes" xml:space="preserve">
          <source>On some newer Linux systems, it's possible to change the clock source used to collect timing data at any time. A second example shows the slowdown possible from switching to the slower acpi_pm time source, on the same system used for the fast results above:</source>
          <target state="translated">На некоторых новых Linux-системах можно в любое время изменить источник синхронизации,используемый для сбора данных о времени.Второй пример показывает возможное замедление от переключения на более медленный источник времени acpi_pm,на той же системе,которая использовалась для получения быстрых результатов выше:</target>
        </trans-unit>
        <trans-unit id="9ce5931c68b8a455769ec944aab5c902a50f0a9b" translate="yes" xml:space="preserve">
          <source>On some operating systems, the status of data in the kernel's page cache is unknown after a write-back failure. In some cases it might have been entirely forgotten, making it unsafe to retry; the second attempt may be reported as successful, when in fact the data has been lost. In these circumstances, the only way to avoid data loss is to recover from the WAL after any failure is reported, preferably after investigating the root cause of the failure and replacing any faulty hardware.</source>
          <target state="translated">На некоторых операционных системах состояние данных в кэше страниц ядра неизвестно после сбоя при обратной записи.В некоторых случаях оно могло быть полностью забыто,что делает повторные попытки небезопасными;вторая попытка может быть признана успешной,когда на самом деле данные были потеряны.В таких обстоятельствах единственным способом избежать потери данных является восстановление из WAL после сообщения о любом сбое,желательно после расследования первопричины сбоя и замены любого неисправного аппаратного обеспечения.</target>
        </trans-unit>
        <trans-unit id="eee21b404ba214868f7afb4e8cb293a79759405b" translate="yes" xml:space="preserve">
          <source>On some systems, this locale category does not exist. Setting this variable will still work, but there will be no effect. Also, there is a chance that no translated messages for the desired language exist. In that case you will continue to see the English messages.</source>
          <target state="translated">В некоторых системах эта категория локалей не существует.Установка этой переменной все равно будет работать,но никакого эффекта не будет.Также существует вероятность того,что переведенных сообщений для желаемого языка не существует.В этом случае вы будете продолжать видеть сообщения на английском языке.</target>
        </trans-unit>
        <trans-unit id="d8426bc3d71cab36b2e69aeb3bfdd7499b750f4a" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;*recheck&lt;/code&gt; should be set to true if the heap tuple needs to be rechecked against the query operator, or false if the index test is exact. That is, a false return value guarantees that the heap tuple does not match the query; a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to false guarantees that the heap tuple does match the query; and a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to true means that the heap tuple might match the query, so it needs to be fetched and rechecked by evaluating the query operator directly against the originally indexed item.</source>
          <target state="translated">В случае успеха для &lt;code&gt;*recheck&lt;/code&gt; должно быть установлено значение true, если кортеж кучи необходимо перепроверить по оператору запроса, или false, если проверка индекса точна. То есть ложное возвращаемое значение гарантирует, что кортеж кучи не соответствует запросу; истинное возвращаемое значение с &lt;code&gt;*recheck&lt;/code&gt; , установленным в false, гарантирует, что кортеж кучи действительно соответствует запросу; а истинное возвращаемое значение с &lt;code&gt;*recheck&lt;/code&gt; , установленным на true, означает, что кортеж кучи может соответствовать запросу, поэтому его необходимо извлечь и перепроверить, оценив оператор запроса непосредственно по первоначально проиндексированному элементу.</target>
        </trans-unit>
        <trans-unit id="471ab7df5323b9c1beeab9b6ad11a4a3d81ba199" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;COPY&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">При успешном завершении команда &lt;code&gt;COPY&lt;/code&gt; возвращает тег команды в форме</target>
        </trans-unit>
        <trans-unit id="a330b5f61b3e5eaefa54001cda5edd47cd225306" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;DELETE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">При успешном завершении команда &lt;code&gt;DELETE&lt;/code&gt; возвращает командный тег в форме</target>
        </trans-unit>
        <trans-unit id="606df5c042bda87282091ed6e870632af55a409b" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;FETCH&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">При успешном завершении команда &lt;code&gt;FETCH&lt;/code&gt; возвращает тег команды в форме</target>
        </trans-unit>
        <trans-unit id="522cefa61331276f75d9354dde07beed068c55b2" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;MOVE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">При успешном завершении команда &lt;code&gt;MOVE&lt;/code&gt; возвращает командный тег в форме</target>
        </trans-unit>
        <trans-unit id="10a00a825ef1af18a74c6369608739640c2c6694" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;INSERT&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">При успешном завершении команда &lt;code&gt;INSERT&lt;/code&gt; возвращает командный тег в форме</target>
        </trans-unit>
        <trans-unit id="adea3b7cb9bb8d678c08759a0633a3db722c1eb8" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;UPDATE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">При успешном завершении команда &lt;code&gt;UPDATE&lt;/code&gt; возвращает тег команды в форме</target>
        </trans-unit>
        <trans-unit id="17c3054fe4ff4e4031ec1aca452c9f2fbf414b42" translate="yes" xml:space="preserve">
          <source>On systems that have PostgreSQL started at boot time, there is probably a start-up file that will accomplish the same thing. For example, on a Red Hat Linux system one might find that this works:</source>
          <target state="translated">На системах,на которых PostgreSQL запущен во время загрузки,вероятно,есть стартовый файл,который выполнит то же самое.Например,на системе Red Hat Linux это может сработать:</target>
        </trans-unit>
        <trans-unit id="5c79b94518a5311140dc7e0d3b2812f742d2b393" translate="yes" xml:space="preserve">
          <source>On systems that support the keepalive socket option, setting &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt;, &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count&lt;/a&gt; helps the primary promptly notice a broken connection.</source>
          <target state="translated">В системах, поддерживающих опцию сокета keepalive, установка &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt; , &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt; и &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count&lt;/a&gt; помогает первичному устройству быстро обнаружить разорванное соединение.</target>
        </trans-unit>
        <trans-unit id="1fa1a4c2c8b8530e986a78ada66b4ce0e77848ad" translate="yes" xml:space="preserve">
          <source>On systems with less than 1GB of RAM, a smaller percentage of RAM is appropriate, so as to leave adequate space for the operating system.</source>
          <target state="translated">На системах с объемом оперативной памяти менее 1 ГБ,меньший процент оперативной памяти подходит для того,чтобы оставить достаточно места для операционной системы.</target>
        </trans-unit>
        <trans-unit id="f7c83da74a1e6d13c844e01daa0931d96bf79bb8" translate="yes" xml:space="preserve">
          <source>On that date, there were two possible interpretations of 2:30AM; there was 2:30AM EDT, and then an hour later after the reversion to standard time, there was 2:30AM EST. Again, PostgreSQL interprets the given time as if it were standard time (UTC-5). We can force the matter by specifying daylight-savings time:</source>
          <target state="translated">В эту дату были две возможные интерпретации 2:30AM;было 2:30AM EDT,а через час после возвращения к стандартному времени,было 2:30AM EST.Опять же,PostgreSQL интерпретирует данное время,как будто это стандартное время (UTC-5).Мы можем заставить это сделать,указав летнее время:</target>
        </trans-unit>
        <trans-unit id="108bc1acbd3eb627957c49ac13cf1805b058d6fd" translate="yes" xml:space="preserve">
          <source>On the other hand, the JSON existence operator is not nested: it will only look for the specified key or array element at top level of the JSON value.</source>
          <target state="translated">С другой стороны,оператор существования JSON не вложен:он будет искать только указанный ключ или элемент массива на верхнем уровне значения JSON.</target>
        </trans-unit>
        <trans-unit id="0944856f78282776625887773317f5e5a29f6901" translate="yes" xml:space="preserve">
          <source>On the other hand, the following query finds all the cities that are not state capitals and are situated at an altitude over 500 feet:</source>
          <target state="translated">С другой стороны,в следующем запросе найдены все города,которые не являются столицами штатов и расположены на высоте более 500 футов:</target>
        </trans-unit>
        <trans-unit id="dc15ca0265b44e308c416ac01f3b8fd4dd23be18" translate="yes" xml:space="preserve">
          <source>On the other hand, the following query finds all the cities that are not state capitals and are situated at an elevation over 500 feet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d66d041f4d766c1f0ee27254b9b736aa4e0885c" translate="yes" xml:space="preserve">
          <source>On the other hand, the prefix operator &lt;code&gt;~&lt;/code&gt; (bitwise negation) is defined only for integer data types, not for &lt;code&gt;float8&lt;/code&gt;. So, if we try a similar case with &lt;code&gt;~&lt;/code&gt;, we get:</source>
          <target state="translated">С другой стороны, префиксный оператор &lt;code&gt;~&lt;/code&gt; (побитовое отрицание) определен только для целочисленных типов данных, а не для &lt;code&gt;float8&lt;/code&gt; . Итак, если мы попробуем аналогичный случай с &lt;code&gt;~&lt;/code&gt; , мы получим:</target>
        </trans-unit>
        <trans-unit id="e3fb0b420bf61dd2f01fedc471af93946522a689" translate="yes" xml:space="preserve">
          <source>On the other hand, the structurally similar case</source>
          <target state="translated">С другой стороны,структурно аналогичный случай</target>
        </trans-unit>
        <trans-unit id="aa512d53935676cc08f57c9480c2f5a40cb3a7f6" translate="yes" xml:space="preserve">
          <source>On the other side of the coin, some systems allow individual processes to open large numbers of files; if more than a few processes do so then the system-wide limit can easily be exceeded. If you find this happening, and you do not want to alter the system-wide limit, you can set PostgreSQL's &lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;max_files_per_process&lt;/a&gt; configuration parameter to limit the consumption of open files.</source>
          <target state="translated">С другой стороны, некоторые системы позволяют отдельным процессам открывать большое количество файлов; если это делают более чем несколько процессов, можно легко превысить общесистемный предел. Если вы обнаружите, что это происходит, и не хотите изменять общесистемный лимит, вы можете установить &lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;параметр&lt;/a&gt; конфигурации PostgreSQL max_files_per_process, чтобы ограничить потребление открытых файлов.</target>
        </trans-unit>
        <trans-unit id="e90706123ac00808e07c484e32d4635f07e67a74" translate="yes" xml:space="preserve">
          <source>On the primary server, these cases simply result in waiting; and the user might choose to cancel either of the conflicting actions. However, on the standby there is no choice: the WAL-logged action already occurred on the primary so the standby must not fail to apply it. Furthermore, allowing WAL application to wait indefinitely may be very undesirable, because the standby's state will become increasingly far behind the primary's. Therefore, a mechanism is provided to forcibly cancel standby queries that conflict with to-be-applied WAL records.</source>
          <target state="translated">На основном сервере эти случаи просто приводят к ожиданию;и пользователь может выбрать отмену любого из конфликтующих действий.Однако,в режиме ожидания выбора нет:действие,записанное в WAL-журнал,уже произошло на основном сервере,поэтому резервный сервер не должен его не применять.Более того,разрешение WAL-приложению ждать неопределенное время может быть очень нежелательным,так как состояние ожидания будет все больше отставать от основного.Поэтому предусмотрен механизм принудительной отмены резервных запросов,которые конфликтуют с будущими записями WAL.</target>
        </trans-unit>
        <trans-unit id="12047b5caa5d65a62660b71617de0d4a759ef067" translate="yes" xml:space="preserve">
          <source>On the primary, parameters &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; have no effect if set on the primary.</source>
          <target state="translated">На первичном &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;сервере&lt;/a&gt; можно использовать параметры &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; и Vacuum_defer_cleanup_age . &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; и &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; не действуют, если установлены на основном сервере .</target>
        </trans-unit>
        <trans-unit id="f4d2789c0f0275ad798be7e6d4e299236ebe91e1" translate="yes" xml:space="preserve">
          <source>On the publisher side, &lt;code&gt;wal_level&lt;/code&gt; must be set to &lt;code&gt;logical&lt;/code&gt;, and &lt;code&gt;max_replication_slots&lt;/code&gt; must be set to at least the number of subscriptions expected to connect, plus some reserve for table synchronization. And &lt;code&gt;max_wal_senders&lt;/code&gt; should be set to at least the same as &lt;code&gt;max_replication_slots&lt;/code&gt; plus the number of physical replicas that are connected at the same time.</source>
          <target state="translated">На стороне издателя &lt;code&gt;wal_level&lt;/code&gt; должен быть установлен на &lt;code&gt;logical&lt;/code&gt; , а &lt;code&gt;max_replication_slots&lt;/code&gt; должен быть установлен как минимум на количество подписок, ожидаемых для подключения, плюс некоторый резерв для синхронизации таблиц. И &lt;code&gt;max_wal_senders&lt;/code&gt; должен быть установлен как минимум &lt;code&gt;max_replication_slots&lt;/code&gt; плюс количество физических реплик, подключенных одновременно.</target>
        </trans-unit>
        <trans-unit id="35745b04684e80ded8dc5507c072fa2674283617" translate="yes" xml:space="preserve">
          <source>On the standby, parameters &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; has no effect as long as the server remains in standby mode, though it will become relevant if the standby becomes primary.</source>
          <target state="translated">На резервном &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;сервере&lt;/a&gt; можно использовать параметры &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; , &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; и max_standby_streaming_delay . &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;Vacuum_defer_cleanup_age&lt;/a&gt; не действует, пока сервер остается в режиме ожидания, хотя он станет актуальным, если резервный станет основным.</target>
        </trans-unit>
        <trans-unit id="70715c6fbe3e407765f6386cd308c88b6865cc56" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;UNLISTEN&lt;/code&gt; has been executed, further &lt;code&gt;NOTIFY&lt;/code&gt; messages will be ignored:</source>
          <target state="translated">После выполнения &lt;code&gt;UNLISTEN&lt;/code&gt; дальнейшие сообщения &lt;code&gt;NOTIFY&lt;/code&gt; будут игнорироваться:</target>
        </trans-unit>
        <trans-unit id="ec65ec416b46f0c02b02945a4d9803e7d39332ca" translate="yes" xml:space="preserve">
          <source>Once a client is connected to the database, PostgreSQL provides two additional SQL commands (and equivalent functions) to interact with session-local configuration settings:</source>
          <target state="translated">Как только клиент подключен к БД,PostgreSQL предоставляет две дополнительные SQL команды (и эквивалентные им функции)для взаимодействия с сеансовыми настройками конфигурации:</target>
        </trans-unit>
        <trans-unit id="356c49cf82618dc4e123a48d759d153fd0e38847" translate="yes" xml:space="preserve">
          <source>Once a connection is established the client process can send a query to the &lt;em&gt;backend&lt;/em&gt; (server). The query is transmitted using plain text, i.e., there is no parsing done in the &lt;em&gt;frontend&lt;/em&gt; (client). The server parses the query, creates an &lt;em&gt;execution plan&lt;/em&gt;, executes the plan and returns the retrieved rows to the client by transmitting them over the established connection.</source>
          <target state="translated">Как только соединение установлено, клиентский процесс может отправить запрос на &lt;em&gt;бэкэнд&lt;/em&gt; (сервер). Запрос передается с использованием обычного текста, то есть во &lt;em&gt;внешнем интерфейсе&lt;/em&gt; (клиенте) не выполняется синтаксический анализ . Сервер анализирует запрос, создает &lt;em&gt;план выполнения&lt;/em&gt; , выполняет план и возвращает полученные строки клиенту, передавая их по установленному соединению.</target>
        </trans-unit>
        <trans-unit id="5ad9c4a6213a012c3300efd580e40047d30505b8" translate="yes" xml:space="preserve">
          <source>Once acquired, a lock is normally held till end of transaction. But if a lock is acquired after establishing a savepoint, the lock is released immediately if the savepoint is rolled back to. This is consistent with the principle that &lt;code&gt;ROLLBACK&lt;/code&gt; cancels all effects of the commands since the savepoint. The same holds for locks acquired within a PL/pgSQL exception block: an error escape from the block releases locks acquired within it.</source>
          <target state="translated">После получения блокировка обычно сохраняется до конца транзакции. Но если блокировка получена после установления точки сохранения, блокировка снимается сразу же после отката до точки сохранения. Это соответствует принципу &lt;code&gt;ROLLBACK&lt;/code&gt; отменяет все эффекты команд с точки сохранения. То же самое относится к блокировкам, полученным в блоке исключений PL / pgSQL: выход ошибки из блока снимает блокировки, полученные в нем.</target>
        </trans-unit>
        <trans-unit id="f6e9243ef6651a8f1bff8b046ab3cebbec0d9033" translate="yes" xml:space="preserve">
          <source>Once acquired, a lock is normally held until the end of the transaction. But if a lock is acquired after establishing a savepoint, the lock is released immediately if the savepoint is rolled back to. This is consistent with the principle that &lt;code&gt;ROLLBACK&lt;/code&gt; cancels all effects of the commands since the savepoint. The same holds for locks acquired within a PL/pgSQL exception block: an error escape from the block releases locks acquired within it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f916b016e9381b5815b3e4089f244578b1cdbc" translate="yes" xml:space="preserve">
          <source>Once an index is created, no further intervention is required: the system will update the index when the table is modified, and it will use the index in queries when it thinks doing so would be more efficient than a sequential table scan. But you might have to run the &lt;code&gt;ANALYZE&lt;/code&gt; command regularly to update statistics to allow the query planner to make educated decisions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;Chapter 14&lt;/a&gt; for information about how to find out whether an index is used and when and why the planner might choose &lt;em&gt;not&lt;/em&gt; to use an index.</source>
          <target state="translated">После создания индекса дальнейшее вмешательство не требуется: система обновит индекс при изменении таблицы и будет использовать индекс в запросах, если сочтет это более эффективным, чем последовательное сканирование таблицы. Но вам, возможно, придется регулярно запускать команду &lt;code&gt;ANALYZE&lt;/code&gt; для обновления статистики, чтобы планировщик запросов мог принимать обоснованные решения. См. &lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;Главу 14&lt;/a&gt; для получения информации о том, как узнать, используется ли индекс, а также когда и почему планировщик может &lt;em&gt;отказаться&lt;/em&gt; от использования индекса.</target>
        </trans-unit>
        <trans-unit id="642332a00907b7ff64fd98bc7d16bd9934680cd4" translate="yes" xml:space="preserve">
          <source>Once an index is created, no further intervention is required: the system will update the index when the table is modified, and it will use the index in queries when it thinks doing so would be more efficient than a sequential table scan. But you might have to run the &lt;code&gt;ANALYZE&lt;/code&gt; command regularly to update statistics to allow the query planner to make educated decisions. See &lt;a href=&quot;https://www.postgresql.org/docs/13/performance-tips.html&quot;&gt;Chapter 14&lt;/a&gt; for information about how to find out whether an index is used and when and why the planner might choose &lt;em&gt;not&lt;/em&gt; to use an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5421d611a483b4f3357d11ff23a5acc44acb58" translate="yes" xml:space="preserve">
          <source>Once any valuable objects have been transferred to new owners, any remaining objects owned by the role-to-be-dropped can be dropped with the &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; command. Again, this command cannot access objects in other databases, so it is necessary to run it in each database that contains objects owned by the role. Also, &lt;code&gt;DROP OWNED&lt;/code&gt; will not drop entire databases or tablespaces, so it is necessary to do that manually if the role owns any databases or tablespaces that have not been transferred to new owners.</source>
          <target state="translated">После передачи каких-либо ценных объектов новым владельцам все оставшиеся объекты, принадлежащие удаляемой роли, можно удалить с помощью команды &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; . Опять же, эта команда не может получить доступ к объектам в других базах данных, поэтому необходимо запускать ее в каждой базе данных, содержащей объекты, принадлежащие этой роли. Кроме того, &lt;code&gt;DROP OWNED&lt;/code&gt; не отбрасывает целые базы данных или табличные пространства, поэтому необходимо делать это вручную, если роль владеет какими-либо базами данных или табличными пространствами, которые не были переданы новым владельцам.</target>
        </trans-unit>
        <trans-unit id="e81389b8f98e0c4fa0978b0ecbccf3ec2c7326c5" translate="yes" xml:space="preserve">
          <source>Once created, a tablespace can be used from any database, provided the requesting user has sufficient privilege. This means that a tablespace cannot be dropped until all objects in all databases using the tablespace have been removed.</source>
          <target state="translated">После создания,табличное пространство может быть использовано из любой БД,при условии,что запрашивающий пользователь имеет достаточные привилегии.Это означает,что табличное пространство не может быть удалено до тех пор,пока все объекты во всех БД,использующих табличное пространство,не будут удалены.</target>
        </trans-unit>
        <trans-unit id="73da0c6102d03c025cdbc83b1b38fc971869013e" translate="yes" xml:space="preserve">
          <source>Once created, the enum type can be used in table and function definitions much like any other type:</source>
          <target state="translated">После создания,тип перечисления может быть использован в определениях таблиц и функций,как и любой другой тип:</target>
        </trans-unit>
        <trans-unit id="c9f4d5e2b4aa9fc314da7481d260ca60dd53ed46" translate="yes" xml:space="preserve">
          <source>Once failover to the standby occurs, there is only a single server in operation. This is known as a degenerate state. The former standby is now the primary, but the former primary is down and might stay down. To return to normal operation, a standby server must be recreated, either on the former primary system when it comes up, or on a third, possibly new, system. The &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt; utility can be used to speed up this process on large clusters. Once complete, the primary and standby can be considered to have switched roles. Some people choose to use a third server to provide backup for the new primary until the new standby server is recreated, though clearly this complicates the system configuration and operational processes.</source>
          <target state="translated">После переключения на резервный работает только один сервер. Это состояние называется вырожденным. Бывший резервный теперь является основным, но бывший основной не работает и может остаться. Чтобы вернуться к нормальной работе, резервный сервер должен быть воссоздан либо в прежней основной системе, когда она появится, либо в третьей, возможно, новой системе. &lt;a href=&quot;app-pgrewind&quot;&gt;Pg_rewind&lt;/a&gt; утилита может быть использована , чтобы ускорить этот процесс на больших кластерах. После завершения можно считать, что основной и резервный сервер поменялись ролями. Некоторые люди предпочитают использовать третий сервер для обеспечения резервного копирования для нового основного до тех пор, пока новый резервный сервер не будет воссоздан, хотя очевидно, что это усложняет конфигурацию системы и рабочие процессы.</target>
        </trans-unit>
        <trans-unit id="99eb90b007ab371c4c054db1b4a14dc72baaf9ae" translate="yes" xml:space="preserve">
          <source>Once prepared, a transaction can later be committed or rolled back with &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt; or &lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt;, respectively. Those commands can be issued from any session, not only the one that executed the original transaction.</source>
          <target state="translated">После подготовки транзакция может быть позже зафиксирована или откатена с помощью &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt; или &lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt; соответственно. Эти команды могут быть запущены из любого сеанса, а не только из того, в котором была выполнена исходная транзакция.</target>
        </trans-unit>
        <trans-unit id="a26efc323b5a3b586fc58ac6b6adb6fb3937603a" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each database so the optimizer has useful statistics. You can also run &lt;code&gt;vacuumdb -a -z&lt;/code&gt; to analyze all databases.</source>
          <target state="translated">После восстановления целесообразно запустить &lt;code&gt;ANALYZE&lt;/code&gt; для каждой базы данных, чтобы оптимизатор получил полезную статистику. Вы также можете запустить &lt;code&gt;vacuumdb -a -z&lt;/code&gt; для анализа всех баз данных.</target>
        </trans-unit>
        <trans-unit id="e1c807b866ed2972017d5380e0a876fec0d03a30" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each restored table so the optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">После восстановления целесообразно запустить &lt;code&gt;ANALYZE&lt;/code&gt; для каждой восстановленной таблицы, чтобы оптимизатор получил полезную статистику; см. &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Раздел 24.1.3&lt;/a&gt; и &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Раздел 24.1.6&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="4f22ae97ca76db6661c3c1f5a88b003eb151976f" translate="yes" xml:space="preserve">
          <source>Once started, &lt;code&gt;pg_upgrade&lt;/code&gt; will verify the two clusters are compatible and then do the upgrade. You can use &lt;code&gt;pg_upgrade --check&lt;/code&gt; to perform only the checks, even if the old server is still running. &lt;code&gt;pg_upgrade --check&lt;/code&gt; will also outline any manual adjustments you will need to make after the upgrade. If you are going to be using link or clone mode, you should use the option &lt;code&gt;--link&lt;/code&gt; or &lt;code&gt;--clone&lt;/code&gt; with &lt;code&gt;--check&lt;/code&gt; to enable mode-specific checks. &lt;code&gt;pg_upgrade&lt;/code&gt; requires write permission in the current directory.</source>
          <target state="translated">После запуска &lt;code&gt;pg_upgrade&lt;/code&gt; проверит совместимость двух кластеров, а затем выполнит обновление. Вы можете использовать &lt;code&gt;pg_upgrade --check&lt;/code&gt; только для выполнения проверок, даже если старый сервер все еще работает. &lt;code&gt;pg_upgrade --check&lt;/code&gt; также укажет на любые ручные настройки, которые вам нужно будет сделать после обновления. Если вы собираетесь использовать режим ссылки или клонирования, вам следует использовать параметр &lt;code&gt;--link&lt;/code&gt; или &lt;code&gt;--clone&lt;/code&gt; с &lt;code&gt;--check&lt;/code&gt; , чтобы включить проверки для конкретного режима. &lt;code&gt;pg_upgrade&lt;/code&gt; требует разрешения на запись в текущий каталог.</target>
        </trans-unit>
        <trans-unit id="c713ae812f1782bcff8d86ab36ed9c6d151c330d" translate="yes" xml:space="preserve">
          <source>Once streaming replication has been configured, configuring synchronous replication requires only one additional configuration step: &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; must be set to a non-empty value. &lt;code&gt;synchronous_commit&lt;/code&gt; must also be set to &lt;code&gt;on&lt;/code&gt;, but since this is the default value, typically no change is required. (See &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;Section 19.5.1&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;Section 19.6.2&lt;/a&gt;.) This configuration will cause each commit to wait for confirmation that the standby has written the commit record to durable storage. &lt;code&gt;synchronous_commit&lt;/code&gt; can be set by individual users, so it can be configured in the configuration file, for particular users or databases, or dynamically by applications, in order to control the durability guarantee on a per-transaction basis.</source>
          <target state="translated">После настройки потоковой репликации для настройки синхронной репликации требуется только один дополнительный шаг настройки: для &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; должно быть установлено непустое значение. &lt;code&gt;synchronous_commit&lt;/code&gt; также должен быть установлен &lt;code&gt;on&lt;/code&gt; , но так как это значение по умолчанию, как правило , не требуется никаких изменений. (См. &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;Раздел 19.5.1&lt;/a&gt; и &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;Раздел 19.6.2&lt;/a&gt; .) Эта конфигурация заставит каждую фиксацию ждать подтверждения того, что резервная система записала запись фиксации в долговременное хранилище. &lt;code&gt;synchronous_commit&lt;/code&gt; может быть установлен отдельными пользователями, поэтому он может быть настроен в файле конфигурации для конкретных пользователей или баз данных или динамически с помощью приложений, чтобы контролировать гарантию долговечности для каждой транзакции.</target>
        </trans-unit>
        <trans-unit id="9871853da7c650c2f0dd2795f59e948ae7531634" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s first return value is the last segment that is required to form a complete set of backup files. On a primary, if &lt;code&gt;archive_mode&lt;/code&gt; is enabled and the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. On a standby, &lt;code&gt;archive_mode&lt;/code&gt; must be &lt;code&gt;always&lt;/code&gt; in order for &lt;code&gt;pg_stop_backup&lt;/code&gt; to wait. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete. If you wish to place a time limit on the execution of &lt;code&gt;pg_stop_backup&lt;/code&gt;, set an appropriate &lt;code&gt;statement_timeout&lt;/code&gt; value, but make note that if &lt;code&gt;pg_stop_backup&lt;/code&gt; terminates because of this your backup may not be valid.</source>
          <target state="translated">После того, как файлы сегментов WAL, активные во время резервного копирования, будут заархивированы, все готово. Файл, идентифицированный первым возвращаемым значением &lt;code&gt;pg_stop_backup&lt;/code&gt; , является последним сегментом, который требуется для формирования полного набора файлов резервных копий. На первичном &lt;code&gt;archive_mode&lt;/code&gt; , если режим archive_mode включен и параметр &lt;code&gt;wait_for_archive&lt;/code&gt; равен &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;pg_stop_backup&lt;/code&gt; не возвращается, пока последний сегмент не будет заархивирован. В резервном режиме &lt;code&gt;archive_mode&lt;/code&gt; должен быть &lt;code&gt;always&lt;/code&gt; чтобы &lt;code&gt;pg_stop_backup&lt;/code&gt; ждал. Архивирование этих файлов происходит автоматически, поскольку вы уже настроили &lt;code&gt;archive_command&lt;/code&gt; .. В большинстве случаев это происходит быстро, но рекомендуется следить за своей системой архивации, чтобы убедиться в отсутствии задержек. Если процесс архивирования задерживается из-за сбоев команды архивирования, он будет продолжать попытки, пока архивирование не завершится успешно и резервное копирование не будет завершено. Если вы хотите установить ограничение по времени для выполнения &lt;code&gt;pg_stop_backup&lt;/code&gt; , установите соответствующее значение &lt;code&gt;statement_timeout&lt;/code&gt; , но обратите внимание, что если &lt;code&gt;pg_stop_backup&lt;/code&gt; завершается из-за этого, ваша резервная копия может быть недействительной.</target>
        </trans-unit>
        <trans-unit id="32e5f3f159f9a76e583d7e4dd4b47490f3262b2b" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s result is the last segment that is required to form a complete set of backup files. If &lt;code&gt;archive_mode&lt;/code&gt; is enabled, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete.</source>
          <target state="translated">После того, как файлы сегментов WAL, активные во время резервного копирования, будут заархивированы, все готово. Файл, идентифицированный результатом &lt;code&gt;pg_stop_backup&lt;/code&gt; , является последним сегментом, который требуется для формирования полного набора файлов резервных копий. Если &lt;code&gt;archive_mode&lt;/code&gt; включен, &lt;code&gt;pg_stop_backup&lt;/code&gt; не возвращается, пока последний сегмент не будет заархивирован. Архивирование этих файлов происходит автоматически, так как вы уже настроили &lt;code&gt;archive_command&lt;/code&gt; . В большинстве случаев это происходит быстро, но рекомендуется следить за своей системой архивации, чтобы убедиться в отсутствии задержек. Если процесс архивирования задерживается из-за сбоев команды архивирования, он будет продолжать попытки, пока архивирование не завершится успешно и резервное копирование не будет завершено.</target>
        </trans-unit>
        <trans-unit id="5f47c9896865faba1d610987fd3b05badac486b3" translate="yes" xml:space="preserve">
          <source>Once the delay specified by &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; has been exceeded, conflicting queries will be canceled. This usually results just in a cancellation error, although in the case of replaying a &lt;code&gt;DROP DATABASE&lt;/code&gt; the entire conflicting session will be terminated. Also, if the conflict is over a lock held by an idle transaction, the conflicting session is terminated (this behavior might change in the future).</source>
          <target state="translated">Как только задержка, указанная &lt;code&gt;max_standby_archive_delay&lt;/code&gt; или &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; , будет превышена, конфликтующие запросы будут отменены. Обычно это приводит только к ошибке отмены, хотя в случае воспроизведения &lt;code&gt;DROP DATABASE&lt;/code&gt; весь конфликтующий сеанс будет завершен. Кроме того, если конфликт произошел из-за блокировки, удерживаемой бездействующей транзакцией, конфликтующий сеанс завершается (это поведение может измениться в будущем).</target>
        </trans-unit>
        <trans-unit id="b8e1074216e0451321cd3f251827b2e9872eaede" translate="yes" xml:space="preserve">
          <source>Once the group role exists, you can add and remove members using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; commands:</source>
          <target state="translated">Когда роль группы существует, вы можете добавлять и удалять участников с помощью команд &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; и &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="69a71607e88d378416ed92ac7ffd6286dc445378" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when &lt;code&gt;pg_upgrade&lt;/code&gt; completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g. &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;share&lt;/code&gt;).</source>
          <target state="translated">Как только вы будете удовлетворены обновлением, вы можете удалить старые каталоги данных кластера, запустив упомянутый сценарий после завершения &lt;code&gt;pg_upgrade&lt;/code&gt; . (Автоматическое удаление невозможно, если внутри старого каталога данных есть определенные пользователем табличные пространства.) Вы также можете удалить старые каталоги установки (например, &lt;code&gt;bin&lt;/code&gt; , &lt;code&gt;share&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ddbea494f64cf75943b4997efd25a70a79386e0d" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when &lt;code&gt;pg_upgrade&lt;/code&gt; completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g., &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;share&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a7bdde6e82e682c3584d24535e62c92a86edd3" translate="yes" xml:space="preserve">
          <source>Once you have created a database, you can access it by:</source>
          <target state="translated">После того,как вы создали базу данных,вы можете получить к ней доступ:</target>
        </trans-unit>
        <trans-unit id="a17a3f555279791537a8bafe938cf8c6379fa784" translate="yes" xml:space="preserve">
          <source>Once you have done the necessary setup, you can run your benchmark with a command that doesn't include &lt;code&gt;-i&lt;/code&gt;, that is</source>
          <target state="translated">После того, как вы выполнили необходимую настройку, вы можете запустить тест с помощью команды, которая не включает &lt;code&gt;-i&lt;/code&gt; , то есть</target>
        </trans-unit>
        <trans-unit id="61eda2a3b905b905ee98026b455b6eb92908a307" translate="yes" xml:space="preserve">
          <source>One &lt;code&gt;postgres&lt;/code&gt; instance always manages the data of exactly one database cluster. A database cluster is a collection of databases that is stored at a common file system location (the &amp;ldquo;data area&amp;rdquo;). More than one &lt;code&gt;postgres&lt;/code&gt; instance can run on a system at one time, so long as they use different data areas and different communication ports (see below). When &lt;code&gt;postgres&lt;/code&gt; starts it needs to know the location of the data area. The location must be specified by the &lt;code&gt;-D&lt;/code&gt; option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable; there is no default. Typically, &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt; points directly to the data area directory created by &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;. Other possible file layouts are discussed in &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt;.</source>
          <target state="translated">Один экземпляр &lt;code&gt;postgres&lt;/code&gt; всегда управляет данными только одного кластера базы данных. Кластер базы данных - это набор баз данных, который хранится в общей файловой системе (&amp;laquo;область данных&amp;raquo;). В системе может работать более одного экземпляра &lt;code&gt;postgres&lt;/code&gt; одновременно, если они используют разные области данных и разные порты связи (см. Ниже). Когда &lt;code&gt;postgres&lt;/code&gt; запускается, ему необходимо знать расположение области данных. Местоположение должно быть указано параметром &lt;code&gt;-D&lt;/code&gt; или переменной среды &lt;code&gt;PGDATA&lt;/code&gt; ; по умолчанию нет. Обычно &lt;code&gt;-D&lt;/code&gt; или &lt;code&gt;PGDATA&lt;/code&gt; указывает непосредственно на каталог области данных, созданный &lt;a href=&quot;app-initdb&quot;&gt;initdb.&lt;/a&gt;. Другие возможные макеты файлов обсуждаются в &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Разделе 19.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d2b8f4e1b139546c73a22f8f91fadc862c3170c" translate="yes" xml:space="preserve">
          <source>One advantage of GIN is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert. This is much the same advantage as using GiST.</source>
          <target state="translated">Одним из преимуществ GIN является то,что он позволяет разрабатывать пользовательские типы данных с соответствующими методами доступа не эксперту по базе данных,а эксперту в области типа данных.Это во многом то же самое преимущество,что и использование GiST.</target>
        </trans-unit>
        <trans-unit id="e058cfc0d2adb864aa10f7c9c5f44bcfe8be50f0" translate="yes" xml:space="preserve">
          <source>One advantage of GiST is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">Одним из преимуществ GiST является то,что он позволяет разрабатывать пользовательские типы данных с соответствующими методами доступа не эксперту по базе данных,а эксперту в области типа данных.</target>
        </trans-unit>
        <trans-unit id="f48b87ea34b25adefa4f3efa4a97db47fb753d95" translate="yes" xml:space="preserve">
          <source>One advantage of the separate-column approach over an expression index is that it is not necessary to explicitly specify the text search configuration in queries in order to make use of the index. As shown in the example above, the query can depend on &lt;code&gt;default_text_search_config&lt;/code&gt;. Another advantage is that searches will be faster, since it will not be necessary to redo the &lt;code&gt;to_tsvector&lt;/code&gt; calls to verify index matches. (This is more important when using a GiST index than a GIN index; see &lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;.) The expression-index approach is simpler to set up, however, and it requires less disk space since the &lt;code&gt;tsvector&lt;/code&gt; representation is not stored explicitly.</source>
          <target state="translated">Одно из преимуществ подхода с отдельными столбцами по сравнению с индексом выражения заключается в том, что нет необходимости явно указывать конфигурацию текстового поиска в запросах, чтобы использовать индекс. Как показано в примере выше, запрос может зависеть от &lt;code&gt;default_text_search_config&lt;/code&gt; . Еще одно преимущество состоит в том, что поиск будет быстрее, так как нет необходимости &lt;code&gt;to_tsvector&lt;/code&gt; вызовы to_tsvector для проверки совпадений индекса. (Это более важно при использовании индекса GiST, чем индекса GIN; см. &lt;a href=&quot;textsearch-indexes&quot;&gt;Раздел 12.9&lt;/a&gt; .) Подход выражения-индекса проще в настройке, и он требует меньше места на диске, поскольку представление &lt;code&gt;tsvector&lt;/code&gt; не сохраняется явно.</target>
        </trans-unit>
        <trans-unit id="c591e2a82e983192d18fdc29edda9221e37c6723" translate="yes" xml:space="preserve">
          <source>One advantage of using concatenation in the vector form, rather than concatenating text before applying &lt;code&gt;to_tsvector&lt;/code&gt;, is that you can use different configurations to parse different sections of the document. Also, because the &lt;code&gt;setweight&lt;/code&gt; function marks all lexemes of the given vector the same way, it is necessary to parse the text and do &lt;code&gt;setweight&lt;/code&gt; before concatenating if you want to label different parts of the document with different weights.</source>
          <target state="translated">Одним из преимуществ использования конкатенации в векторной форме, а не конкатенации текста перед применением &lt;code&gt;to_tsvector&lt;/code&gt; , является то, что вы можете использовать разные конфигурации для анализа разных разделов документа. Кроме того, поскольку функция &lt;code&gt;setweight&lt;/code&gt; помечает все лексемы данного вектора одинаково, необходимо проанализировать текст и &lt;code&gt;setweight&lt;/code&gt; перед объединением, если вы хотите пометить разные части документа с разными весами.</target>
        </trans-unit>
        <trans-unit id="7aa492c47d8ea5d45e5da9a09ed3c6c96f7a96e5" translate="yes" xml:space="preserve">
          <source>One application of the rewrite system is in the realization of &lt;em&gt;views&lt;/em&gt;. Whenever a query against a view (i.e., a &lt;em&gt;virtual table&lt;/em&gt;) is made, the rewrite system rewrites the user's query to a query that accesses the &lt;em&gt;base tables&lt;/em&gt; given in the &lt;em&gt;view definition&lt;/em&gt; instead.</source>
          <target state="translated">Одно из применений системы перезаписи - реализация &lt;em&gt;представлений&lt;/em&gt; . Всякий раз, когда делается запрос к представлению (т. &lt;em&gt;Е. К виртуальной таблице&lt;/em&gt; ), система перезаписи переписывает запрос пользователя на запрос, который обращается к &lt;em&gt;базовым таблицам,&lt;/em&gt; указанным в &lt;em&gt;определении представления&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bee7fd28573b33fce2d46ef1ac5fa8251ec94562" translate="yes" xml:space="preserve">
          <source>One component of the statistics is the total number of entries in each table and index, as well as the number of disk blocks occupied by each table and index. This information is kept in the table &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt;, in the columns &lt;code&gt;reltuples&lt;/code&gt; and &lt;code&gt;relpages&lt;/code&gt;. We can look at it with queries similar to this one:</source>
          <target state="translated">Одним из компонентов статистики является общее количество записей в каждой таблице и индексе, а также количество дисковых блоков, занятых каждой таблицей и индексом. Эта информация хранится в таблице &lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt; , в столбцах &lt;code&gt;reltuples&lt;/code&gt; и &lt;code&gt;relpages&lt;/code&gt; . Мы можем посмотреть на это с помощью запросов, подобных этому:</target>
        </trans-unit>
        <trans-unit id="4bd99552b099beafc96cbe7829988f7a06eb967b" translate="yes" xml:space="preserve">
          <source>One convenient way to create a compatible table that will later be made a new child is to use the &lt;code&gt;LIKE&lt;/code&gt; clause in &lt;code&gt;CREATE TABLE&lt;/code&gt;. This creates a new table with the same columns as the source table. If there are any &lt;code&gt;CHECK&lt;/code&gt; constraints defined on the source table, the &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; option to &lt;code&gt;LIKE&lt;/code&gt; should be specified, as the new child must have constraints matching the parent to be considered compatible.</source>
          <target state="translated">Один удобный способ создать совместимую таблицу, которая позже станет новой дочерней, - это использовать предложение &lt;code&gt;LIKE&lt;/code&gt; в &lt;code&gt;CREATE TABLE&lt;/code&gt; . Это создает новую таблицу с теми же столбцами, что и исходная таблица. Если для исходной таблицы определены какие-либо ограничения &lt;code&gt;CHECK&lt;/code&gt; , следует &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; параметр INCLUDING CONSTRAINTS для &lt;code&gt;LIKE&lt;/code&gt; , поскольку новый дочерний элемент должен иметь ограничения, соответствующие родительской, чтобы считаться совместимым.</target>
        </trans-unit>
        <trans-unit id="313d199647b14e908c91b6831b2ac1803fbc36c9" translate="yes" xml:space="preserve">
          <source>One could accomplish the same thing with, say,</source>
          <target state="translated">То же самое можно сделать,скажем,</target>
        </trans-unit>
        <trans-unit id="7bcb03e673340a4965d50eadd319bf1730dddebc" translate="yes" xml:space="preserve">
          <source>One disadvantage of decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; is that it might cause &lt;code&gt;VACUUM&lt;/code&gt; to do useless work: freezing a row version is a waste of time if the row is modified soon thereafter (causing it to acquire a new XID). So the setting should be large enough that rows are not frozen until they are unlikely to change any more.</source>
          <target state="translated">Одним из недостатков уменьшения &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; является то, что это может привести к тому, что &lt;code&gt;VACUUM&lt;/code&gt; будет выполнять бесполезную работу: замораживание версии строки является пустой тратой времени, если строка вскоре после этого будет изменена (что приведет к получению нового XID). Таким образом, настройка должна быть достаточно большой, чтобы строки не замораживались до тех пор, пока они больше не будут меняться.</target>
        </trans-unit>
        <trans-unit id="d99c8486b08ccc8839ea87cdfcd9e4516a4d63fc" translate="yes" xml:space="preserve">
          <source>One disadvantage of the longitude/latitude representation is that you need to be careful about the edge conditions near the poles and near +/- 180 degrees of longitude. The &lt;code&gt;cube&lt;/code&gt;-based representation avoids these discontinuities.</source>
          <target state="translated">Один из недостатков представления долготы / широты заключается в том, что вам нужно быть осторожным с краевыми условиями вблизи полюсов и около +/- 180 градусов долготы. Представление на основе &lt;code&gt;cube&lt;/code&gt; избегает этих разрывов.</target>
        </trans-unit>
        <trans-unit id="17918ae437c6b6c4eb55d620ac26a6167c3d73b5" translate="yes" xml:space="preserve">
          <source>One example use of this mechanism is to copy the contents of a file into a table column. First load the file into a variable and then interpolate the variable's value as a quoted string:</source>
          <target state="translated">Одним из примеров использования этого механизма является копирование содержимого файла в столбец таблицы.Сначала загрузите файл в переменную,а затем интерполируйте значение переменной в виде кавычки:</target>
        </trans-unit>
        <trans-unit id="11e396823958b9942ef20dabe2804d32c8c47de7" translate="yes" xml:space="preserve">
          <source>One fairly large constraint of the table access method API is that, currently, if the AM wants to support modifications and/or indexes, it is necessary for each tuple to have a tuple identifier (TID) consisting of a block number and an item number (see also &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;). It is not strictly necessary that the sub-parts of TIDs have the same meaning they e.g. have for &lt;code&gt;heap&lt;/code&gt;, but if bitmap scan support is desired (it is optional), the block number needs to provide locality.</source>
          <target state="translated">Одно довольно большое ограничение API метода доступа к таблицам заключается в том, что в настоящее время, если AM хочет поддерживать модификации и / или индексы, необходимо, чтобы каждый кортеж имел идентификатор кортежа (TID), состоящий из номера блока и номера элемента. (см. также &lt;a href=&quot;storage-page-layout&quot;&gt;Раздел 68.6&lt;/a&gt; ). Строго не обязательно, чтобы части TID имели то же значение, которое они, например, имеют для &lt;code&gt;heap&lt;/code&gt; , но если требуется поддержка растрового сканирования (это необязательно), номер блока должен обеспечивать локальность.</target>
        </trans-unit>
        <trans-unit id="b0040d1980e299cbab932d09606b61e2f45cdab4" translate="yes" xml:space="preserve">
          <source>One fairly large constraint of the table access method API is that, currently, if the AM wants to support modifications and/or indexes, it is necessary for each tuple to have a tuple identifier (TID) consisting of a block number and an item number (see also &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;). It is not strictly necessary that the sub-parts of TIDs have the same meaning they e.g., have for &lt;code&gt;heap&lt;/code&gt;, but if bitmap scan support is desired (it is optional), the block number needs to provide locality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6157e87abd7338811eb2303b2c46792b171e86" translate="yes" xml:space="preserve">
          <source>One major reason for using a partial index is to avoid indexing common values. Since a query searching for a common value (one that accounts for more than a few percent of all the table rows) will not use the index anyway, there is no point in keeping those rows in the index at all. This reduces the size of the index, which will speed up those queries that do use the index. It will also speed up many table update operations because the index does not need to be updated in all cases. &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;Example 11.1&lt;/a&gt; shows a possible application of this idea.</source>
          <target state="translated">Одна из основных причин использования частичного индекса - избегать индексации общих значений. Поскольку запрос, ищущий общее значение (которое составляет более нескольких процентов всех строк таблицы), в любом случае не будет использовать индекс, нет смысла вообще сохранять эти строки в индексе. Это уменьшает размер индекса, что ускоряет запросы, использующие индекс. Это также ускорит многие операции обновления таблицы, поскольку индекс не нужно обновлять во всех случаях. &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;Пример 11.1&lt;/a&gt; показывает возможное применение этой идеи.</target>
        </trans-unit>
        <trans-unit id="d407807dcbba44e4e2aa91e451040ac8b91fe898" translate="yes" xml:space="preserve">
          <source>One might need to insert a large amount of data when first populating a database. This section contains some suggestions on how to make this process as efficient as possible.</source>
          <target state="translated">При первом пополнении базы данных может потребоваться вставка большого объема данных.В данном разделе содержатся некоторые предложения о том,как сделать этот процесс как можно более эффективным.</target>
        </trans-unit>
        <trans-unit id="af46cf06b4b2b1ea8a95f9146c144e8cb5a4d7fb" translate="yes" xml:space="preserve">
          <source>One must have the PostgreSQL superuser privilege to register a new language or change an existing language's parameters. However, once the language is created it is valid to assign ownership of it to a non-superuser, who may then drop it, change its permissions, rename it, or assign it to a new owner. (Do not, however, assign ownership of the underlying C functions to a non-superuser; that would create a privilege escalation path for that user.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bb08b9cf98dd6c73c6dc0c7e52247a78ee67c4" translate="yes" xml:space="preserve">
          <source>One of</source>
          <target state="translated">Один из</target>
        </trans-unit>
        <trans-unit id="0e3d57db8bbc433a035cda8e815f996da30de43e" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;TRUNCATE&lt;/code&gt;; this specifies the event that will fire the trigger. Multiple events can be specified using &lt;code&gt;OR&lt;/code&gt;, except when transition relations are requested.</source>
          <target state="translated">Одно из &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; или &lt;code&gt;TRUNCATE&lt;/code&gt; ; это определяет событие, которое запускает триггер. С помощью &lt;code&gt;OR&lt;/code&gt; можно указать несколько событий , кроме случаев, когда запрашиваются переходные отношения.</target>
        </trans-unit>
        <trans-unit id="e5e814c340c50927afd7b76075dffb81341dc8b6" translate="yes" xml:space="preserve">
          <source>One of several disjoint (not overlapping) subsets of a larger set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d58cd9872ba6b984b5aaf4db1dd4f254a5318e3" translate="yes" xml:space="preserve">
          <source>One of the most critical design decisions will be the column or columns by which you partition your data. Often the best choice will be to partition by the column or set of columns which most commonly appear in &lt;code&gt;WHERE&lt;/code&gt; clauses of queries being executed on the partitioned table. &lt;code&gt;WHERE&lt;/code&gt; clause items that match and are compatible with the partition key can be used to prune unneeded partitions. However, you may be forced into making other decisions by requirements for the &lt;code&gt;PRIMARY KEY&lt;/code&gt; or a &lt;code&gt;UNIQUE&lt;/code&gt; constraint. Removal of unwanted data is also a factor to consider when planning your partitioning strategy. An entire partition can be detached fairly quickly, so it may be beneficial to design the partition strategy in such a way that all data to be removed at once is located in a single partition.</source>
          <target state="translated">Одним из наиболее важных проектных решений будет столбец или столбцы, по которым вы разбиваете данные. Часто лучшим выбором будет разделение по столбцу или набору столбцов, которые чаще всего встречаются в &lt;code&gt;WHERE&lt;/code&gt; запросов, выполняемых в разделенной таблице. Элементы предложения &lt;code&gt;WHERE&lt;/code&gt; , которые соответствуют ключу раздела и совместимы с ним, могут использоваться для удаления ненужных разделов. Однако вы можете быть вынуждены принять другие решения из-за требований для &lt;code&gt;PRIMARY KEY&lt;/code&gt; или &lt;code&gt;UNIQUE&lt;/code&gt; КЛЮЧА.ограничение. Удаление нежелательных данных также является фактором, который следует учитывать при планировании стратегии разделения. Весь раздел можно отсоединить довольно быстро, поэтому может быть полезно разработать стратегию разделения таким образом, чтобы все данные, которые должны быть удалены одновременно, находились в одном разделе.</target>
        </trans-unit>
        <trans-unit id="511f9e4f8bd3667e3b6d755989f295209cbb7bb6" translate="yes" xml:space="preserve">
          <source>One of the obvious uses for &lt;code&gt;file_fdw&lt;/code&gt; is to make the PostgreSQL activity log available as a table for querying. To do this, first you must be &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;logging to a CSV file,&lt;/a&gt; which here we will call &lt;code&gt;pglog.csv&lt;/code&gt;. First, install &lt;code&gt;file_fdw&lt;/code&gt; as an extension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd64b8780a8987f51d6cf827b3649d1c335b7dcc" translate="yes" xml:space="preserve">
          <source>One of the obvious uses for &lt;code&gt;file_fdw&lt;/code&gt; is to make the PostgreSQL activity log available as a table for querying. To do this, first you must be logging to a CSV file, which here we will call &lt;code&gt;pglog.csv&lt;/code&gt;. First, install &lt;code&gt;file_fdw&lt;/code&gt; as an extension:</source>
          <target state="translated">Одно из очевидных применений &lt;code&gt;file_fdw&lt;/code&gt; - сделать журнал активности PostgreSQL доступным в виде таблицы для запросов. Для этого сначала вы должны войти в файл CSV, который здесь мы назовем &lt;code&gt;pglog.csv&lt;/code&gt; . Сначала установите &lt;code&gt;file_fdw&lt;/code&gt; как расширение:</target>
        </trans-unit>
        <trans-unit id="01a9a0754bb2d47df04d6f754f8a9d26cef931fd" translate="yes" xml:space="preserve">
          <source>One of the problems with the JDBC driver (and this affects the ODBC driver also), is that the specification assumes that references to BLOBs (Binary Large OBjects) are stored within a table, and if that entry is changed, the associated BLOB is deleted from the database.</source>
          <target state="translated">Одна из проблем с драйвером JDBC (и это тоже влияет на драйвер ODBC)заключается в том,что спецификация предполагает,что ссылки на BLOB (Binary Large OBjects)хранятся в таблице,и если эта запись изменена,то связанный с ней BLOB удаляется из БД.</target>
        </trans-unit>
        <trans-unit id="5e5610f45b959ec0066fbadc6e622bf504204314" translate="yes" xml:space="preserve">
          <source>One of the values estimated by &lt;code&gt;ANALYZE&lt;/code&gt; is the number of distinct values that appear in each column. Because only a subset of the rows are examined, this estimate can sometimes be quite inaccurate, even with the largest possible statistics target. If this inaccuracy leads to bad query plans, a more accurate value can be determined manually and then installed with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">Одно из значений, оцениваемых с помощью &lt;code&gt;ANALYZE&lt;/code&gt; , - это количество различных значений, которые появляются в каждом столбце. Поскольку проверяется только подмножество строк, эта оценка иногда может быть довольно неточной даже при максимально возможном целевом значении статистики. Если эта неточность приводит к плохим планам запроса, более точное значение можно определить вручную и затем установить с помощью &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; (см. &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="493483fbe186caeb533f2587ea2f5c9911b94b74" translate="yes" xml:space="preserve">
          <source>One or more server-challenge and client-response message will follow. Each server-challenge is sent in an AuthenticationSASLContinue message, followed by a response from client in an SASLResponse message. The particulars of the messages are mechanism specific.</source>
          <target state="translated">За ним последует одно или несколько сообщений о вызовах сервера и ответах клиентов.Каждый вызов сервера отправляется в сообщении AuthenticationSASLContinue,за которым следует ответ от клиента в сообщении SASLResponse.Специфика сообщений зависит от конкретного механизма.</target>
        </trans-unit>
        <trans-unit id="425be19de627a14da7ab3bb185d550dfbfe3423c" translate="yes" xml:space="preserve">
          <source>One parameter is specified per line. The equal sign between name and value is optional. Whitespace is insignificant (except within a quoted parameter value) and blank lines are ignored. Hash marks (&lt;code&gt;#&lt;/code&gt;) designate the remainder of the line as a comment. Parameter values that are not simple identifiers or numbers must be single-quoted. To embed a single quote in a parameter value, write either two quotes (preferred) or backslash-quote. If the file contains multiple entries for the same parameter, all but the last one are ignored.</source>
          <target state="translated">В каждой строке указывается один параметр. Знак равенства между именем и значением указывать необязательно. Пробелы не важны (за исключением значения параметра в кавычках), а пустые строки игнорируются. Знаки решетки ( &lt;code&gt;#&lt;/code&gt; ) обозначают оставшуюся часть строки как комментарий. Значения параметров, которые не являются простыми идентификаторами или числами, должны заключаться в одинарные кавычки. Чтобы вставить одинарную кавычку в значение параметра, напишите либо две кавычки (предпочтительно), либо обратную косую черту. Если файл содержит несколько записей для одного и того же параметра, все, кроме последней, игнорируются.</target>
        </trans-unit>
        <trans-unit id="71b216cd8704d27b44cb581f634267f6e26f6ef5" translate="yes" xml:space="preserve">
          <source>One past the highest completed transaction ID. All transaction IDs greater than or equal to &lt;code&gt;xmax&lt;/code&gt; had not yet completed as of the time of the snapshot, and thus are invisible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fe47df2bc317685fd9b966bcab8a9f820096f2" translate="yes" xml:space="preserve">
          <source>One row for each WAL sender process streaming a base backup, showing current progress. See &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;Section 27.4.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82642c7d45248923778a2209d5f115330d366506" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;ANALYZE&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#ANALYZE-PROGRESS-REPORTING&quot;&gt;Section 27.4.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b5eb3c3d07dabe60de983aaa0a3518afd885a7" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;VACUUM&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Section 27.4.2&lt;/a&gt;.</source>
          <target state="translated">По одной строке для каждого бэкэнда (включая рабочие процессы автоочистки), выполняющего &lt;code&gt;VACUUM&lt;/code&gt; , с указанием текущего прогресса. См. &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Раздел 27.4.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="effeab1715906cd694d7b1852e9b8750b001e4c5" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;VACUUM&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e814a8df1ec5e7ba9113e201d150026719d20049" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">По одной строке для каждого бэкэнда, на котором запущен &lt;code&gt;CLUSTER&lt;/code&gt; или &lt;code&gt;VACUUM FULL&lt;/code&gt; , показывающий текущий прогресс. См. &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Раздел 27.4.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fefdce83b8168d66ba70cfd9d6be8231c7483a5" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592609ed9243ae5def10fa9f090855998b555b8d" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Section 27.4.1&lt;/a&gt;.</source>
          <target state="translated">По одной строке для каждого бэкэнда, на котором выполняется &lt;code&gt;CREATE INDEX&lt;/code&gt; или &lt;code&gt;REINDEX&lt;/code&gt; , показывая текущий прогресс. См. &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Раздел 27.4.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c1c91b429aaf8e67212422dcd282876be59a3b8" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Section 27.4.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27c3edf1970037c5b38d9980359c2a682d83e63" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about I/O on that specific index. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_indexes&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636789b8fa3526dcb7ffa47252873c271555303c" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about I/O on that specific index. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;pg_statio_all_indexes&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка для каждого индекса в текущей базе данных, показывающая статистику ввода-вывода для этого конкретного индекса. Подробнее см. &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;Pg_statio_all_indexes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d77f2cdac8ddfb746a4ceaac2099e52076e9af7" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about accesses to that specific index. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-INDEXES-VIEW&quot;&gt;&lt;code&gt;pg_stat_all_indexes&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c843f1eedf963b1dea0a4c471c30395c4850fb0a" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about accesses to that specific index. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt;pg_stat_all_indexes&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка для каждого индекса в текущей базе данных, показывающая статистику доступа к этому конкретному индексу. Подробнее см. &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt;Pg_stat_all_indexes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fdb86eec2a29466a4d1044e6a5602fb45a47381" translate="yes" xml:space="preserve">
          <source>One row for each sequence in the current database, showing statistics about I/O on that specific sequence. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_sequences&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a19a27308f1c1e0f487d86ec09bd9389b70b95" translate="yes" xml:space="preserve">
          <source>One row for each sequence in the current database, showing statistics about I/O on that specific sequence. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;pg_statio_all_sequences&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка для каждой последовательности в текущей базе данных, показывающая статистику ввода-вывода для этой конкретной последовательности. Подробнее см. &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;Pg_statio_all_sequences&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af3494e4cc13caccb2edb628436f0d6fc2950bc0" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about I/O on that specific table. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-TABLES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_tables&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876cb7f3198f93830f07de3b355cbda033ba5c5c" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about I/O on that specific table. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt;pg_statio_all_tables&lt;/a&gt; for details.</source>
          <target state="translated">Одна строка для каждой таблицы в текущей базе данных, показывающая статистику ввода-вывода в этой конкретной таблице. См. &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt;Pg_statio_all_tables&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="b933ef4e80b93a79e66696a5ea76c78fbf07acf1" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about accesses to that specific table. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-TABLES-VIEW&quot;&gt;&lt;code&gt;pg_stat_all_tables&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
